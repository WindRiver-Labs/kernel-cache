From 730fb6e32f20f50eb0242ebef49216e0600bd32d Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Thu, 26 Nov 2009 12:16:52 -0800
Subject: [PATCH] MILS: Introduce VDK to VBI translation layer (aka. SHIM)

The MILS hypervisor is coded to a slightly different ABI than
the WR VBI 2.0 specification currently used by the Linux guest OS.
The addition of this mapping between the two ABI allows the Linux
guest OS to be used on the MILS hypervisor.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h           |    4 +
 arch/powerpc/include/asm/pv_dma-mapping.h     |    4 +
 arch/powerpc/include/asm/vdk_pv_dma-mapping.h |   63 +++
 arch/powerpc/include/asm/wrhv.h               |    1 +
 arch/powerpc/kernel/head_wrhv.S               |    8 +-
 arch/powerpc/kernel/vbi/Makefile              |    7 +-
 arch/powerpc/kernel/vbi/util.c                |   19 +
 arch/powerpc/kernel/vbi/vdk_syscalls.S        |  288 ++++++++++++
 arch/powerpc/kernel/vbi/wrhv.c                |  130 ++++++-
 arch/x86/kernel/vbi/Makefile                  |    4 +
 arch/x86/kernel/vbi/vdk_syscalls.S            |  151 +++++++
 drivers/serial/serial_core.c                  |    7 +
 include/vbi/arch.h                            |    6 +
 include/vbi/compat.h                          |   26 ++
 include/vbi/interface.h                       |    4 +
 include/vbi/interrupt.h                       |    8 +
 include/vbi/syscall.h                         |    5 +-
 include/vbi/syscalls.h                        |    5 +-
 include/vbi/vbi.h                             |    6 +
 include/vbi/vdk_interface.h                   |  579 +++++++++++++++++++++++++
 include/vbi/vdk_port.h                        |  110 +++++
 include/vbi/vdk_syscalls.h                    |  482 ++++++++++++++++++++
 init/Kconfig.wrhv                             |    9 +
 kernel/vbi/Makefile                           |    9 +-
 kernel/vbi/lib.c                              |    2 +
 25 files changed, 1924 insertions(+), 13 deletions(-)
 create mode 100644 arch/powerpc/include/asm/vdk_pv_dma-mapping.h
 create mode 100644 arch/powerpc/kernel/vbi/vdk_syscalls.S
 create mode 100644 arch/x86/kernel/vbi/vdk_syscalls.S
 create mode 100644 include/vbi/vdk_interface.h
 create mode 100644 include/vbi/vdk_port.h
 create mode 100644 include/vbi/vdk_syscalls.h

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 4fbc504..df58d0a 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -13,6 +13,9 @@
  *
  */
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/vdk_syscalls.h>
+#else
 #ifndef _ASM_ARCH_VBI_H
 #define _ASM_ARCH_VBI_H
 
@@ -659,3 +662,4 @@ endIntVcoreLock:
 #endif /*_ASMLANGUAGE */
 
 #endif /* _ASM_ARCH_VBI_H */
+#endif /* WRHV_MILS */
diff --git a/arch/powerpc/include/asm/pv_dma-mapping.h b/arch/powerpc/include/asm/pv_dma-mapping.h
index 3195ef3..352d891 100644
--- a/arch/powerpc/include/asm/pv_dma-mapping.h
+++ b/arch/powerpc/include/asm/pv_dma-mapping.h
@@ -1,3 +1,6 @@
+#ifdef CONFIG_WRHV_MILS
+#include <asm/vdk_pv_dma-mapping.h>
+#else
 #ifndef _ASM_PV_DMA_MAPPING_H
 #define _ASM_PV_DMA_MAPPING_H
 
@@ -76,3 +79,4 @@ paravirt_dma_map_single(struct device *dev, void *ptr, size_t size,
 #endif /* CONFIG_WRHV */
 
 #endif	/* _ASM_PV_DMA_MAPPING_H */
+#endif /* CONFIG_WRHV_MILS */
diff --git a/arch/powerpc/include/asm/vdk_pv_dma-mapping.h b/arch/powerpc/include/asm/vdk_pv_dma-mapping.h
new file mode 100644
index 0000000..469d24a
--- /dev/null
+++ b/arch/powerpc/include/asm/vdk_pv_dma-mapping.h
@@ -0,0 +1,63 @@
+#ifndef _ASM_PV_DMA_MAPPING_H
+#define _ASM_PV_DMA_MAPPING_H
+
+/* default native inline */
+#define dma_alloc_coherent	native_dma_alloc_coherent
+#define dma_map_single		native_dma_map_single
+
+/* redefine hypervisor specific inline */
+#undef dma_alloc_coherent
+#undef dma_map_single
+
+#define dma_alloc_coherent	paravirt_dma_alloc_coherent
+#define dma_map_single		paravirt_dma_map_single
+
+#include <vbi/vbi.h>
+
+static inline void *paravirt_dma_alloc_coherent(struct device *dev, size_t size,
+			dma_addr_t * dma_handle,
+			gfp_t gfp)
+{
+#ifdef CONFIG_NOT_COHERENT_CACHE
+	return __dma_alloc_coherent(size, dma_handle, gfp);
+#else
+	void *ret;
+	/* ignore region specifiers */
+	gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+	if (dev == NULL || dev->coherent_dma_mask < 0xffffffff)
+		gfp |= GFP_DMA;
+
+	ret = (void *)__get_free_pages(gfp, get_order(size));
+
+	if (ret != NULL) {
+		void *paddr;
+		memset(ret, 0, size);
+		if (vbi_get_guest_dma_addr(ret,(void *) &paddr) == 0) {
+			*dma_handle = (dma_addr_t)paddr;
+		} else {
+			free_pages((unsigned long)ret, get_order(size));
+			ret = NULL;
+		}
+	}
+
+	return ret;
+#endif
+
+}
+
+static inline dma_addr_t
+paravirt_dma_map_single(struct device *dev, void *ptr, size_t size,
+	enum dma_data_direction direction)
+{
+	void *paddr;
+	BUG_ON(direction == DMA_NONE);
+
+	__dma_sync(ptr, size, direction);
+	if (vbi_get_guest_dma_addr(ptr,(void *) &paddr) == 0)
+		return (dma_addr_t)paddr;
+	else
+		return (dma_addr_t)NULL;
+
+}
+#endif	/* _ASM_PV_DMA_MAPPING_H */
diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 6495671..996d85b 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -25,6 +25,7 @@ extern void wrhv_init_irq(void);
 extern void __init wrhv_calibrate_decr(void);
 extern void __init wrhv_time_init(void);
 extern int __init wrhv_earlycon_setup(void);
+extern int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags);
 #ifdef CONFIG_PCI
 extern int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev);
 #endif
diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index 0e765b9..deb4b8e 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -128,13 +128,19 @@ _ENTRY(__early_start)
 	addi	r4,r2,THREAD	/* init task's THREAD */
 	WRHV_MTSPRG3(r4,r1)
 	/* Establish the interrupt vector offsets */
+#ifdef CONFIG_WRHV_MILS
+	lis	r3,_start@h
+	ori	r3,r3,_start@l
+	bl	vbi_exec_vec_base_addr_set
+#else
 	lis	r0,VBI_SYS_hyIoctl@h
-	ori     r0,r0,VBI_SYS_hyIoctl@l
+	ori	r0,r0,VBI_SYS_hyIoctl@l
 	lis	r3,VBI_HYIOCTL_EXCBASE@h
 	ori	r3,r3,VBI_HYIOCTL_EXCBASE@l
 	lis	r4,_start@h
 	ori	r4,r4,_start@l
 	sc
+#endif
 
 	/* stack */
 	lis	r1,init_thread_union@h
diff --git a/arch/powerpc/kernel/vbi/Makefile b/arch/powerpc/kernel/vbi/Makefile
index daac59f..a02358c 100644
--- a/arch/powerpc/kernel/vbi/Makefile
+++ b/arch/powerpc/kernel/vbi/Makefile
@@ -2,4 +2,9 @@
 # Makefile for the vbi ppc.
 #
 
-obj-y		+= syscalls.o util.o wrhv.o vmmu_display.o show.o
+obj-y		+= util.o wrhv.o vmmu_display.o show.o
+ifeq ($(CONFIG_WRHV_MILS),y)
+obj-y		+= vdk_syscalls.o
+else
+obj-y		+= syscalls.o
+endif
diff --git a/arch/powerpc/kernel/vbi/util.c b/arch/powerpc/kernel/vbi/util.c
index 9c7ba61..c73e918 100644
--- a/arch/powerpc/kernel/vbi/util.c
+++ b/arch/powerpc/kernel/vbi/util.c
@@ -117,24 +117,43 @@ int vb_context_mmu_on(int pid,	/* context id */
 
 void vb__flush_dcache_icache(void *start)
 {
+#ifdef CONFIG_WRHV_MILS
+	vbi_flush_icache(start, (void *)(start + (PAGE_SIZE-1)), L1_CACHE_BYTES);
+	vbi_flush_dcache(start, (void *)(start + (PAGE_SIZE-1)), L1_CACHE_BYTES);
+#else
 	vbi_flush_icache(start, 4096);
 	vbi_flush_dcache(start, 4096);
+#endif
 }
 
 void vb_flush_dcache_range(unsigned long start, unsigned long stop)
 {
+#ifdef CONFIG_WRHV_MILS
+	vbi_flush_dcache((void *) start, (void *) stop, 8);
+#else
 	vbi_flush_dcache((void *) start, (stop - start + 1));
+#endif
 }
 
 void vb__flush_icache_range(unsigned long start, unsigned long stop)
 {
+#ifdef CONFIG_WRHV_MILS
+	vbi_flush_dcache((void *) start, (void *) stop, 8);
+	vbi_flush_icache((void *) start, (void *) stop, 8);
+#else
 	vbi_update_text_cache((void *) start, (stop - start + 1));
+#endif
 }
 
 void vb__flush_dcache_icache_phys(unsigned long physaddr)
 {
+#ifdef CONFIG_WRHV_MILS
+	vbi_flush_dcache((void *) physaddr, (void *) (physaddr + (PAGE_SIZE-1)), L1_CACHE_BYTES);
+	vbi_flush_icache((void *) physaddr, (void *) (physaddr + (PAGE_SIZE-1)), L1_CACHE_BYTES);
+#else
 	vbi_flush_icache((void *) physaddr, 4096);
 	vbi_flush_dcache((void *) physaddr, 4096);
+#endif
 }
 
 EXPORT_SYMBOL_GPL(wrhv_int_lock);
diff --git a/arch/powerpc/kernel/vbi/vdk_syscalls.S b/arch/powerpc/kernel/vbi/vdk_syscalls.S
new file mode 100644
index 0000000..df4141a
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/vdk_syscalls.S
@@ -0,0 +1,288 @@
+/* vdk_syscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/asm-offsets.h>
+#include <asm/cache.h>
+#include <asm/vbi.h>
+#include <vbi/vdk_syscalls.h>
+
+#ifdef CONFIG_PPC85xx_VT_MODE   /* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
+
+#ifdef CONFIG_PPC85xx_VT_MODE	/* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
+
+FUNC_EXPORT(vbi_virt_to_phys)
+FUNC_EXPORT(vbi_enable_vmmu)
+FUNC_EXPORT(vbi_config_vmmu)
+FUNC_EXPORT(vbi_flush_dcache)
+FUNC_EXPORT(vbi_flush_icache)
+FUNC_EXPORT(vbi_exec_vec_base_addr_set)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_int_controller_done)
+
+_WRS_TEXT_SEG_START
+
+#define vbi_hcall(name, call)		\
+FUNC_LABEL(name)			\
+	lis r0, HI(VBI_SYS_##call);	\
+	ori r0, r0, LO(VBI_SYS_##call);	\
+	HCALL;				\
+	blr;				\
+FUNC_END(name)
+
+
+/*
+ * vbi_flush_icache - flush the instruction cache
+ *
+ * This system call flushes the instruction cache for the specified address
+ * range.
+ *
+ */
+vbi_hcall(vbi_flush_icache,icache_flush)
+
+/*
+ * vbi_flush_dcache - flush the data cache
+ *
+ * This system call flushes the data cache for the specified address range.
+ *
+ */
+vbi_hcall(vbi_flush_dcache,dcache_flush)
+
+/*
+ * vbi_vmmu_config - configure the hypervisor virtual MMU
+ *
+ * This system call configures the context's virtual MMU within the hypervisor.
+ *
+ */
+vbi_hcall(vbi_config_vmmu,vmmu_config)
+
+/*
+ * vbi_vmmu_enable - enables the virtual MMU
+ *
+ * This system call enables a context's virtual MMU.
+ *
+ */
+vbi_hcall(vbi_enable_vmmu,vmmu_enable)
+
+/*
+ * vbi_vmmu_disable - disable the virtual MMU
+ *
+ * This system call disables a context's virtual MMU.
+ *
+ */
+vbi_hcall(vbi_disable_vmmu,vmmu_disable)
+
+/*
+ * vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
+ *
+ * This system call loads the TLB entries for the specified address range into
+ * the virtual MMU.
+ *
+ */
+vbi_hcall(vbi_tlb_load_vmmu,vmmu_tlbload)
+
+/*
+ * vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
+ *
+ * This system call flushes the TLB entries for the specified address range
+ * from the virtual MMU.
+ *
+ */
+vbi_hcall(vbi_tlb_flush_vmmu,vmmu_tlbflush)
+
+/*
+ * vbiExcVecBaseSet - set current partition exception vector base address
+ *
+ * This system call sets the calling partition exception vector base address.
+ *
+ */
+vbi_hcall(vbi_exec_vec_base_addr_set,excVecBaseSet)
+
+/*
+ * vbi_virt_to_phys - convert a guest OS address to a physical address
+ *
+ * This system call converts a guest OS address to a physical address
+ *
+ * HAE API vbiPaddr uses this system call.
+ *
+ */
+vbi_hcall(vbi_virt_to_phys,virtToPhys)
+
+
+/*
+ * vbi_int_controller_done - signal completion of processing by virtual
+ * int controller
+ *
+ * This system notifies the hypervisor that the virtual interrupt controller
+ * in the virtual board has finished procssing the information in the
+ * virtual interrupt controller registers, and requires a refresh.
+ *
+ */
+vbi_hcall(vbi_int_controller_done,int_controller_done)
+
+
+/*
+ * vbi_vcore_irq_lock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_lock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	0
+#else
+	li	p1, -1
+	lis	p2, HIADJ(wr_vb_control)
+	lwz	p2, LO(wr_vb_control)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+#endif
+	blr
+FUNC_END(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+
+/*
+ * vbi_vcore_irq_unlock - unlock interrupts for running core
+ *
+ * This routine enables interrupts and makes a fast hypercall if pending
+ * interrupts are detected for the calling core. This is a C wrapper function
+ * for the assembly MACRO VBI_INT_VCORE_UNLOCK().
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_unlock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	1
+#else
+	lis	p0, HIADJ(wr_vb_control)
+	lwz	p0, LO(wr_vb_control)(p0)
+	li	p1, 0
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+#endif
+tryAgain:
+	lis	p0, HIADJ(wr_vb_status)
+	lwz	p0, LO(wr_vb_status)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis r0, HI(VBI_SYS_int_enable)
+	ori r0, r0, LO(VBI_SYS_int_enable)
+	HCALL
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+
+/*
+ * The following calls are MILS extensions outside of the normal
+ * VBI 2.0 list of syscalls.
+ */
+
+/*
+ * vdk_sec_audit_event_inject - Inject a Security Audit event
+ *
+ * This system call forces injection of a security audit event.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_inject,secAuditEventInject)
+
+
+/*
+ * vdk_sec_audit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_collect,secAuditEventCollect)
+
+
+/*
+ * vdk_safe_crit_event_inject - Inject a Safety Critical event
+ *
+ * This system call forces injection of a Safety Critical event.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_inject,safeCritEventInject)
+
+
+/*
+ * vdk_safe_crit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_collect,safeCritEventCollect)
+
+
+/*
+ * vdk_schedule_name_to_id - return the schedule ID of the schedule <name>
+ *
+ * This system call returns the schedule ID given the schedule name
+ *
+ */
+vbi_hcall(vdk_schedule_name_to_id,scheduleNameToId)
+
+
+/*
+ * vdk_schedule_set - set the current schedule to schedule <name>
+ *
+ * This system call sets schedule <name> to current schedule
+ *
+ */
+vbi_hcall(vdk_schedule_set,scheduleSet)
+
+/*
+ * vdk_port_send - send message to a port
+ *
+ * This system call sends messages to the specified port
+ *
+ */
+vbi_hcall(vdk_port_send,portSend)
+
+/*
+ * vdk_port_get_recv_buf - receive from a port
+ *
+ * This system call gets a buffer from the specified port
+ *
+ */
+vbi_hcall(vdk_port_get_recv_buf,portGetRecvBuf)
+
+/*
+ * vdk_port_buf_release - release a buffer from a port
+ *
+ * This system call releases the specified buffer(s) from the specified port
+ *
+ */
+vbi_hcall(vdk_port_buf_release,portBufRelease)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 88032e0..64a2918 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -109,7 +109,6 @@
 
 #include <asm/paravirt.h>
 
-
 /* powerpc clocksource/clockevent code */
 #define HWTIMER_USE_JIFFY 1
 
@@ -122,6 +121,7 @@ struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
 struct vb_control *wr_control;
 struct vb_status *wr_status;
 EXPORT_SYMBOL(wr_config);
+EXPORT_SYMBOL(wr_status);
 
 void wrhv_mapping(void);
 void mpc85xx_power_down(void);
@@ -145,6 +145,76 @@ int wrhv_earlycon = -1;
 int wrhv_pci_devfn = -1;
 char wrhv_macaddr[6];
 
+#ifdef CONFIG_WRHV_MILS
+static inline uint32_t get_emsr(void)
+{
+	return 0;
+}
+
+static inline uint32_t get_dbsr(void)
+{
+	return 0;
+}
+
+static inline uint32_t get_dbcr(void)
+{
+	return 0;
+}
+
+static inline void put_emsr(uint32_t reg)
+{
+	return;
+}
+
+static inline void put_dbsr(uint32_t reg)
+{
+	return;
+}
+
+static inline void put_dbcr(uint32_t reg)
+{
+	return;
+}
+
+static inline int32_t vbi_vb_reset(uint32_t id, int32_t core, uint32_t options)
+{
+	printk(KERN_INFO "MILS: guest reboot not supported by hypervisor\n");
+	return -1;
+}
+
+#else	/* !MILS */
+
+static inline uint32_t get_emsr(void)
+{
+	return VBI_CNTRL_ADDR_GET()->vb_control_regs.emsr;
+}
+
+static inline uint32_t get_dbsr(void)
+{
+	return VBI_CNTRL_ADDR_GET()->vb_control_regs.dbsr;
+}
+
+static inline uint32_t get_dbcr(void)
+{
+	return VBI_CNTRL_ADDR_GET()->vb_control_regs.dbcr0;
+}
+
+static inline void put_emsr(uint32_t reg)
+{
+	VBI_CNTRL_ADDR_GET()->vb_control_regs.emsr = reg;
+}
+
+static inline void put_dbsr(uint32_t reg)
+{
+	VBI_CNTRL_ADDR_GET()->vb_control_regs.dbsr = reg;
+}
+
+static inline void put_dbcr(uint32_t reg)
+{
+	VBI_CNTRL_ADDR_GET()->vb_control_regs.dbcr0 = reg;
+}
+#endif /* CONFIG_WRHV_MILS */
+
 #define WRHV_EARLYCON_SIZE  14  /* sizeof("wrhv_earlycon=") */
 int __init wrhv_earlycon_setup(void)
 {
@@ -210,11 +280,12 @@ void wrhv_mapping(void)
 		 (unsigned long)wr_config->vb_status, _PAGE_RAM);
 	map_page((unsigned long)wr_config->vb_control,
 		 (unsigned long)wr_config->vb_control, _PAGE_RAM);
+#ifndef CONFIG_WRHV_MILS
 	map_page((unsigned long)wr_config->interruptConfiguration,
 		 (unsigned long)wr_config->interruptConfiguration, _PAGE_RAM);
 	map_page((unsigned long)wr_config->vb_control->vIoapic,
 		 (unsigned long)wr_config->vb_control->vIoapic, _PAGE_RAM);
-
+#endif
 	memcpy(&__wr_config, wr_config, sizeof(__wr_config));
 	/* map any shared memory region info */
 
@@ -224,7 +295,25 @@ void wrhv_mapping(void)
 			 (unsigned long)wr_config->
 			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
 
-	return;
+#ifdef CONFIG_WRHV_MILS
+	if (wr_config->memoryRegionsConfigAddress != 0) {
+		map_page((unsigned long)wr_config->memoryRegionsConfigAddress,
+			(unsigned long)wr_config->memoryRegionsConfigAddress,
+			_PAGE_RAM);
+	}
+	if (wr_config->interruptConfiguration != 0) {
+		map_page((unsigned long)wr_config->interruptConfiguration,
+			(unsigned long)wr_config->interruptConfiguration,
+			_PAGE_RAM);
+	}
+	if (wr_config->vb_status->vbInterruptController != 0) {
+		map_page((unsigned long)wr_config->vb_status->vbInterruptController,
+			(unsigned long)wr_config->vb_status->vbInterruptController,
+			_PAGE_RAM);
+	}
+#endif
+ 
+ 	return;
 }
 
 unsigned long __init wrhv_find_end_of_memory(void)
@@ -886,6 +975,7 @@ int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
 		flush_HPTE(0, va, pmd_val(*pmd));
 	return err;
 }
+EXPORT_SYMBOL(wrhv_map_page);
 
 void __iomem *
 wrhv___ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)
@@ -999,8 +1089,12 @@ out:
 /* arch/powerpc/kernel/traps.c */
 void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_status)
 {
-	debug_status = wr_control->vb_control_regs.dbsr;
-	wr_control->vb_control_regs.emsr &= ~MSR_DE;
+	uint32_t emsr;
+
+	debug_status = get_dbsr();
+	emsr = get_emsr();
+	emsr &= ~MSR_DE;
+	put_emsr(emsr);
 
 	if (debug_status & DBSR_IC) {   /* instruction completion */
 		regs->msr &= ~MSR_DE;
@@ -1048,6 +1142,8 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 	unsigned long addr;
 
 	switch (remcom_in_buffer[0]) {
+		uint32_t dbcr;
+		uint32_t emsr;
 		/*
 		 * sAA..AA   Step one instruction from AA..AA
 		 * This will return an error to gdb ..
@@ -1066,13 +1162,17 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 			 * Set hypervisor DBCR0_IC single step and
 			 * DBCR0_IDM internal debug mode.
 			 */
-			wr_control->vb_control_regs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
+			dbcr = get_dbcr();
+			dbcr |= (DBCR0_IC | DBCR0_IDM);
+			put_dbcr(dbcr);
 
 			/*
 			 * Set Debug Enable bit in hypervisor's emulated MSR which
 			 * is restored on return from exception
 			 */
-			wr_control->vb_control_regs.emsr |= MSR_DE;
+			emsr = get_emsr();
+			emsr |= MSR_DE;
+			put_emsr(emsr);
 			linux_regs->msr |= MSR_DE;
 			if (!user_mode(linux_regs)) {
 				preempt_disable();
@@ -1176,3 +1276,19 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	return irq;
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
+
+#if 0 // def CONFIG_WRHV_MILS
+EXPORT_SYMBOL(vbi_vcore_irq_lock);
+EXPORT_SYMBOL(vbi_vcore_irq_unlock);
+EXPORT_SYMBOL(vbi_int_controller_done);
+
+EXPORT_SYMBOL(vdk_port_send);
+EXPORT_SYMBOL(vdk_port_get_recv_buf);
+EXPORT_SYMBOL(vdk_port_buf_release);
+EXPORT_SYMBOL(vdk_schedule_name_to_id);
+EXPORT_SYMBOL(vdk_schedule_set);
+EXPORT_SYMBOL(vdk_sec_audit_event_inject);
+EXPORT_SYMBOL(vdk_sec_audit_event_collect);
+EXPORT_SYMBOL(vdk_safe_crit_event_inject);
+EXPORT_SYMBOL(vdk_safe_crit_event_collect);
+#endif
diff --git a/arch/x86/kernel/vbi/Makefile b/arch/x86/kernel/vbi/Makefile
index 79a6269..a25ef58 100644
--- a/arch/x86/kernel/vbi/Makefile
+++ b/arch/x86/kernel/vbi/Makefile
@@ -4,6 +4,10 @@
 
 obj-y		= wrhv.o wrhv_initrd.o syscalls.o
 
+ifeq ($(CONFIG_WRHV_MILS),y)
+obj-y	+= vdk_syscalls.o
+endif
+
 # wrhv embeds an initrd in the vmlinux
 $(obj)/wrhv_initrd.o: FORCE
 	@ $(AS) $(srctree)/$(src)/wrhv_initrd.S -o $@
diff --git a/arch/x86/kernel/vbi/vdk_syscalls.S b/arch/x86/kernel/vbi/vdk_syscalls.S
new file mode 100644
index 0000000..816b927
--- /dev/null
+++ b/arch/x86/kernel/vbi/vdk_syscalls.S
@@ -0,0 +1,151 @@
+/*
+ * vdk_syscalls.S - hypervisor system calls
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <asm/reg_vbi.h>
+#include <asm/vbi.h>
+#include <vbi/syscall.h>
+
+.text
+.balign 16
+
+#define VBI_STACK_FRAME_SIZE	4
+
+#define vdk_hcall(name, call, args)		\
+.globl name;					\
+name:						\
+	movl $VBI_SYS_##call,%eax;		\
+	push $##args;				\
+	vmcall;					\
+	addl $VBI_STACK_FRAME_SIZE, %esp;	\
+	ret
+
+/*
+ * vdk_virt_to_phys - translate a virtual address to physical
+ */
+vdk_hcall(vdk_virt_to_phys, virtToPhys, 2)
+
+/*
+ *
+ * vbi_int_controller_done - signal completion of processing by virtual int controller
+ *
+ * This system notifies the hypervisor that the virtual interrupt controller
+ * in the virtual board has finished procssing the information in the
+ * virtual interrupt controller registers, and requires a refresh.
+ *
+ */
+vdk_hcall(vbi_int_controller_done, int_controller_done, 0)
+
+/*
+ * The following are MILS extensions that are not present
+ * in the standard VBI 2.0 syscall list.
+ */
+
+/*
+ *
+ * vdk_port_buf_release - release a buffer from a port
+ *
+ * This system call releases the specified buffer(s) from the specified port
+ *
+ */
+vdk_hcall(vdk_port_buf_release, portBufRelease, 3)
+
+/*
+ *
+ * vdk_schedule_name_to_id - return the schedule ID of the schedule <name>
+ *
+ * This system call returns the schedule ID given the schedule name
+ *
+ */
+vdk_hcall(vdk_schedule_name_to_id, scheduleNameToId, 2)
+
+/*
+ *
+ * vdk_schedule_set - set the current schedule to schedule <name>
+ *
+ * This system call sets schedule <name> to current schedule
+ *
+ */
+vdk_hcall(vdk_schedule_set, scheduleSet, 2)
+
+/*
+ *
+ * vdk_sec_audit_event_inject - inject a security Audit event
+ *
+ */
+vdk_hcall(vdk_sec_audit_event_inject, secAuditEventInject, 3)
+
+/*
+ *
+ * vdk_sec_audit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vdk_hcall(vdk_sec_audit_event_collect, secAuditEventCollect, 3)
+
+/*
+ *
+ * vdk_safe_crit_event_inject - Inject a Safety Critical event
+ *
+ * This system call forces injection of a Safety Critical event.
+ *
+ */
+vdk_hcall(vdk_safe_crit_event_inject, safeCritEventInject, 1)
+
+/*
+ *
+ * vdk_safe_crit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vdk_hcall(vdk_safe_crit_event_collect, safeCritEventCollect, 3)
+
+/*
+ *
+ * vdk_port_send - send message to a port
+ *
+ * This system call sends messages to the specified port
+ *
+ */
+vdk_hcall(vdk_port_send, portSend, 5)
+
+/*
+ *
+ * vdk_port_get_recv_buf - receive from a port
+ *
+ * This system call gets a buffer from the specified port
+ *
+ */
+vdk_hcall(vdk_port_get_recv_buf, portGetRecvBuf, 2)
+
+/*
+ *
+ * vdk_bsp_ioctl - bsp ioctl call
+ *
+ * This system call interfaces to the Board Support Package
+ * I/O drivers etc
+ *
+ * Knwon BSP ioctl commands:
+ *       VDK_BSPIOCTL_ENABLE_INT   /@ Enable HW interrupt @/
+ *       VDK_BSPIOCTL_DISABLE_INT  /@ Disable HW interrupt@/
+ *       VDK_BSPIOCTL_RESET        /@ Reset HW device     @/
+ *
+ */
+vdk_hcall(vdk_bsp_ioctl, bspIoctl, 8)
+
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 7547e94..bcdc4b1 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2152,6 +2152,13 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 {
 	char address[64];
 
+#ifdef CONFIG_WRHV_MILS
+if(port->irq != 0) {
+	/* Everything in the MILS world has to be polled */
+	printk(" WRHV MILS: invalid uart IRQ#%d requested, adjusting\n",port->irq);
+	port->irq = 0;
+}
+#endif
 	switch (port->iotype) {
 	case UPIO_PORT:
 		snprintf(address, sizeof(address),
diff --git a/include/vbi/arch.h b/include/vbi/arch.h
index a21a675..ff8077e 100644
--- a/include/vbi/arch.h
+++ b/include/vbi/arch.h
@@ -14,6 +14,11 @@
  *
  */
 
+#ifdef CONFIG_WRHV_MILS
+/* MILS stores all arch specific definitions in
+ * include/vbi/vdk_interface.h
+ */
+#else
 #ifndef _VBI_ARCH_H
 #define _VBI_ARCH_H
 
@@ -32,3 +37,4 @@
 #endif
 
 #endif /* _VBI_ARCH_H */
+#endif /* CONFIG_WRHV_MILS */
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index fa1fe7d..95e6c6d 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -214,4 +214,30 @@
 #define vbiVioapicVectorGet	vbi_get_vioapic_vec
 #define vbiVioapicVectorSet	vbi_set_vioapic_vec
 
+#ifdef CONFIG_WRHV_MILS
+/*
+ * MILS/VDK mappings
+ */
+#define vdkIntDisable		vbi_vcore_irq_lock
+#define vdkIntEnable		vbi_vcore_irq_unlock
+#define vdkIntControllerDone	vbi_int_controller_done
+/*
+ * The following are not strictly a part of VBI 2.0 nomenclature
+ */
+#define vdkSecAuditEventInject	vdk_sec_audit_event_inject
+#define vdkSecAuditEventCollect	vdk_sec_audit_event_collect
+#define vdkSafeCritEventInject	vdk_safe_crit_event_inject
+#define vdkSafeCritEventCollect	vdk_safe_crit_event_collect
+#define vdkPortSend		vdk_port_send
+#define vdkPortGetRecvBuf	vdk_port_get_recv_buf
+#define vdkPortBufRelease	vdk_port_buf_release
+#define vdkScheduleSet		vdk_schedule_set
+#define vdkScheduleNameToId	vdk_schedule_name_to_id
+
+#define PORT_BUF_CTRL_DESC	struct portBufCtrlDesc
+#define PORT_STATUS		struct portStatus
+#define PORT_HY_INFO		struct portHyInfo
+
+#endif	/* MILS */
+
 #endif  /* _VBI_COMPAT_H */
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 51754d4..a78e221 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -80,6 +80,9 @@ identity mapped.
 
 */
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/vdk_interface.h>
+#else
 #ifndef _VBI_INTERFACE_H
 #define _VBI_INTERFACE_H
 
@@ -583,3 +586,4 @@ struct vb_config
 
 #endif /*_ASMLANGUAGE */
 #endif  /* _VBI_INTERFACE_H */
+#endif /* ! CONFIG_WRHV_MILS */
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
index b5c5fc0..bbaa835 100644
--- a/include/vbi/interrupt.h
+++ b/include/vbi/interrupt.h
@@ -26,7 +26,15 @@ interrupts configuration data.
 
 #ifndef	_ASMLANGUAGE
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/errors.h>
+static inline uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
+{
+	return VBI_INVALID_IRQ;
+}
+#else
 extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+#endif /* CONFIG_WRHV_MILS */
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index ce72393..f70ace2 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -14,9 +14,11 @@
  *
  */
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/vdk_syscalls.h>
+#else
 #ifndef _VBI_SYSCALL_H
 #define _VBI_SYSCALL_H
-
 #include <linux/linkage.h>
 #include <vbi/types.h>
 #include <vbi/arch.h>
@@ -161,3 +163,4 @@ extern asmlinkage int32_t vbi_vb_write_reg(VBI_HREG_SET *regCtl,
 
 #endif	/* _ASMLANGUAGE */
 #endif  /* _VBI_SYSCALL_H */
+#endif  /* WRHV_MILS */
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index ab61c84..2117fc0 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -14,6 +14,9 @@
  *
  */
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/vdk_syscalls.h>
+#else
 #ifndef _VBI_SYSCALLS_H
 #define _VBI_SYSCALLS_H
 
@@ -311,5 +314,5 @@ typedef uint32_t VBMGMT_HANDLE;
 typedef uint32_t VBI_NS_HANDLE;
 
 #endif	/* _ASMLANGUAGE */
-
 #endif	/* _VBI_SYSCALLS_H */
+#endif /* ! CONFIG_WRHV_MILS */
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index fcc765b..6ff2a65 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -85,8 +85,14 @@ various data structures.
  * vbi_unmask_vioapic_irq()
  *
  */
+
+#ifndef CONFIG_WRHV_MILS
 #define VBI_VIOAPIC_BASE_GET()		\
         (VBI_CNTRL_ADDR_GET()->vIoapic)
+#else
+#define VBI_VIOAPIC_BASE_GET() 		\
+	(return NULL)
+#endif
 
 /* VMMU0 and VMMU1 tables for context switch access macro's */
 #define VBI_VMMU0_GET()                   \
diff --git a/include/vbi/vdk_interface.h b/include/vbi/vdk_interface.h
new file mode 100644
index 0000000..73798c2
--- /dev/null
+++ b/include/vbi/vdk_interface.h
@@ -0,0 +1,579 @@
+/*
+ * vdk_interface.h - virtual board interface header file
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+#ifndef _VDK_INTERFACE_H
+#define _VDK_INTERFACE_H
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <vbi/types.h>
+#include <vbi/arch.h>
+#include <vbi/vdk_port.h>
+
+
+/* VB versioning information */
+#define	VBI_VERSION_MAJOR	1	/* major version */
+#define	VBI_VERSION_MINOR	2	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+#define VB_DEBUG_MSG(fmt, args...)    printk(fmt, ##args)
+#else
+#define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+
+/* Configuration Filename for the hypervisor this must not change */
+#define VB_WRHV_CONFIGURATION_FILE "milsKernel.xml"
+
+/* Hard limits for now */
+#define VB_MAX_VIRTUAL_BOARDS		1024
+#define VB_MAX_BUSES			1024
+
+#define VB_MAX_CORES			8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+#define VB_NAMELEN		64
+
+#ifndef	_ASMLANGUAGE
+
+#define VB_MAX_BOOTLINE_LENGTH		256
+
+#endif
+
+/* Virtual Interrupt Controller definitions */
+
+/*
+ * 32 is chosen as the maximum number of interrupt sources allowed.
+ * care must be taken if this is changed, since some algorithms and
+ * data structures will require modifications and become more complex
+ */
+#define VB_MAX_INTERRUPTS		32
+
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	VB_MAX_INTERRUPTS
+
+/*
+ * The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+#define VB_MAX_INTERRUPT_DATA		16
+
+/* Structure offsets for assembler */
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+#define VB_CONTROL_REG_STRUCT_END	0
+#endif
+
+#define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0                4*2
+#define VB_CONTROL_VMMU1                4*3
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+/* Assembler offsets for vb_status */
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+#define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0                 4*5
+#define VB_STATUS_VMMU1                 4*6
+
+#ifdef CONFIG_PPC32
+#define VB_CONTROL_SRR0                 4*4
+#define VB_CONTROL_SRR1                 4*5
+#define VB_CONTROL_CR                   4*6
+#define VB_CONTROL_R0                   4*7
+#define VB_CONTROL_R1                   4*8
+#define VB_CONTROL_SP                   VB_CONTROL_R1
+#define VB_CONTROL_R2                   4*9
+#define VB_CONTROL_R3                   4*10
+#define VB_CONTROL_R4                   4*11
+#define VB_CONTROL_R5                   4*12
+#define VB_CONTROL_R6                   4*13
+#define VB_CONTROL_R7                   4*14
+#define VB_CONTROL_R8                   4*15
+#define VB_CONTROL_R9                   4*16
+#define VB_CONTROL_R10                  4*17
+#define VB_CONTROL_R11                  4*18
+#define VB_CONTROL_R12                  4*19
+#define VB_CONTROL_R13                  4*20
+#define VB_CONTROL_EMSR                 4*21
+#define VB_STATUS_SRR0                  4*26
+#define VB_STATUS_SRR1                  4*27
+#define VB_STATUS_CR                    4*28
+#define VB_STATUS_LR                    4*29
+#define VB_STATUS_R3                    4*30
+#define VB_STATUS_R4                    4*31
+#define VB_STATUS_ESR                   4*34
+#define VB_STATUS_DEAR                  4*37
+#endif
+/* Assembler offsets for vb_config */
+#define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+#define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+#define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+#define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+#define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+
+/* Defines for vbIntInfo intDirection field */
+#define VB_INPUT_INT	1
+#define VB_OUTPUT_INT	2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by the hypervisor.
+ */
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+#ifndef VB_VIOAPIC_ENTRIES_SIZE
+#define VB_VIOAPIC_ENTRIES_SIZE 64
+#endif
+
+#ifndef	_ASMLANGUAGE
+
+/* Type definitions for all name identifer strings in hypervisor */
+#define VB_MAX_WRHV_NAME_LENGTH 64
+typedef char VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
+
+#define VB_MAX_EXCEPTION_TYPES	32
+
+struct vb_log_cfg
+{
+    signed long recordSize;      /* size of each record entry */
+    signed long maxRecords;      /* maximum number of log records */
+};
+
+/* Info for the memory map info */
+struct vb_mem_info
+{
+    VB_WRHV_NAME name;   /* The name of the shared memory region */
+    void *        addr;   /* The vbphysical address of the region */
+    unsigned int  length; /* The length in bytes of the region */
+    unsigned int  attr;   /* The arch specific MMU attributes of the region */
+    unsigned int  type;   /* padding */
+};
+
+typedef enum log_state
+{
+   /* Log types - first code must be non zero
+    * and all types will use a hamming distance of 2.
+    */
+   LOG_OK   = 0x00000101,
+   LOG_FULL = 0x00000102,
+} LOG_STATE;
+
+/* Log types (so far only three types) */
+
+typedef enum log_type
+{
+   /* Log types - first code must be non zero
+    * and all types will use a hamming distance of 2.
+    */
+   LOG_TYPE_TRUSTED_BOOT = 0x00000101,	 /* Trusted Boot trace log */
+   LOG_TYPE_SEC_AUDIT    = 0x00000102,	 /* Security Audit event log */
+   LOG_TYPE_SAFETY       = 0x00000104    /* Safety Critical event log: */
+} LOG_TYPE;
+
+struct vb_log_status
+{
+    LOG_STATE   logState;        /* State of log: overrun or not */
+    signed long numRecords;      /* number of records in log */
+    signed long logOverwrite;    /* overwritten entry */
+    signed long numOverwrites;   /* number of overwrites occured */
+    signed long lastCollectedVb; /* used by collection VB */
+};
+
+
+/* Status information about one interrupt */
+struct vbInterruptLevel
+{
+    uint64_t       timeStamp;    /* Time when last interrupt delivered here */
+    unsigned long  numInts;      /* How many interrupts since last delivered */
+    unsigned long  numIntData;   /* How many data elements have been stored */
+    unsigned long  intData[VB_MAX_INTERRUPT_DATA];
+};
+
+/* The virtual interrupt controller, with individual interrupt sources */
+struct vbInterruptController
+{
+    unsigned long      intPending; /* Which interrupts are pending
+                                    * high order bit (value 0x80000000)
+                                    * is int #0
+                                    */
+    struct vbInterruptLevel intLevel[VB_MAX_INTERRUPTS];
+};
+
+
+
+/* Configuration information for one interrupt */
+struct vb_int_info
+{
+    VB_WRHV_NAME  irq_name;      /* The name for this interrupt */
+    unsigned short irq_dir;      /* INPUT_INT or OUTPUT_INT */
+    unsigned short irq_num;      /* The interrupt number to be used by the vb*/
+    unsigned short irq_core;     /* the receiving core for this incomming int */
+};
+
+
+/* time donation status */
+
+struct td_status
+{
+    unsigned int  clientTwId;    /* active client TW object ID */
+    unsigned int  clientPortId;  /* port ID associated to client TW */
+    unsigned int  serverTwId;    /* active server TW object ID */
+    unsigned int  serverPortId;  /* port ID associated to server TW */
+};
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+		base->field
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+		base->field
+
+/* Do not change the order of these fields */
+struct vb_status
+{
+    unsigned int irq_pend_type; /* 0: Bits indicating which IRQs are pending */
+
+    /* reserved field for future use, required for timeStamp alignment */
+    unsigned long reserved1; /* 1: */
+
+    /* Timestamp when last interrupt was delivered */
+    uint64_t timeStamp;  /* 2-3:    64 bits*/
+
+    /* Interrupt registers
+     *
+     * When hypervisor interrupts a virtual board, it saves information here
+     * to be read by the virtual board software.
+     */
+
+    /* value of control->intDisable at time of the interrupt.
+     * control->intDisable is set to -1 by WRHV at the time of delivery of
+     * the interrupt
+     */
+    unsigned long prev_irq_disable;                /*  4: */
+
+    /* VMMU tables which were active when an MMU exception occurred */
+
+    void *vmmu0;                                /* 5: */
+    void *vmmu1;                                /* 6: */
+
+    /* current schedule status */
+    unsigned long currentSchedule;              /* 7: */
+    unsigned long currentTimeSlice;             /* 8: */
+    unsigned long remainingTicks;               /* 9: */
+
+    /* Location in vbPhyscial memory of the virtual interrupt controller */
+
+    struct vbInterruptController *vbInterruptController;  /* 10: */
+    struct portStatus *portStatus;             /* 11: port status */
+
+    struct vb_log_status secAuditLogStatus; /* 12-16: Security Audit Event log status */
+    struct vb_log_status safetyLogStatus;   /* 17-21: Safety Critical Event log status */
+    struct td_status tdStatus;       /* 22-25: time donation status */
+#ifdef CONFIG_PPC32
+    /* registers saved by hypervisor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+    uint32_t srr0; /* 26: PC at time of the interrupt */
+    uint32_t srr1; /* 27: MSR at time of the interrupt */
+    uint32_t cr;   /* 28: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 29: Link register at time of the interrupt */
+    uint32_t r3;   /* 30: R3 at time of the interrupt */
+    uint32_t r4;   /* 31: R4 at time of the interrupt */
+
+    /* Registers saved by hypervisor during exception processing only */
+
+    uint32_t mcsrr0; /* 32: */
+    uint32_t mcsrr1; /* 33: */
+    uint32_t esr;    /* 34: */
+    uint32_t mcsr;   /* 35: */
+    uint32_t mcar;   /* 36: */
+    uint32_t dear;   /* 37: */
+    uint32_t emsr;   /* 38: */
+    uint32_t esrr0;  /* 39: */
+    uint32_t esrr1;  /* 40: */
+
+    /* Configuration registers (only updated upon board creation */
+    uint32_t svr;    /* 41: */
+    uint32_t pir;    /* 42: */
+    uint32_t pvr;    /* 43: */
+    uint32_t hid0;   /* 44: */
+    uint32_t hid1;   /* 45: */
+    uint32_t bucsr;  /* 46: */
+    uint32_t l1csr0; /* 47: */
+    uint32_t l1csr1; /* 48: */
+#endif
+    uint32_t tick_count;    /* how many ticks VB should have received */
+};
+
+/*
+ * ----------------------- VIRTUAL BOARD CONTROL PAGE -----------------------
+ *
+ * Read/write page used as a communication channel from the VB to hypervisor.
+ *
+ * Any information that cannot be passed in machine registers from the
+ * virtual board to hypervisor are passed in this structure.
+ *
+ * Also state communication from the virtual board to wrhv (such as
+ * disabling all interrupts) uses this page
+ *
+ */
+
+/* Do not change the order of these fields */
+
+struct vb_control
+{
+    unsigned long irq_disable;	/*  0: -1 => Disable all interrupts */
+    unsigned long next_irq_disable;/*  1: New value for vbControl->intDisable */
+
+    void *        vmmu0;	/*  2: VMMU 0 table for context switch */
+    void *        vmmu1;	/*  3: VMMU 1 table for context switch */
+
+#ifdef CONFIG_PPC32
+    /* Registers to be restored by the VBI_SYS_ctx_load fast system call */
+
+    uint32_t srr0;         /*  4: PC */
+    uint32_t srr1;         /*  5: MSR */
+    uint32_t cr;           /*  6: condition registers */
+    uint32_t r0;           /*  7: General register R0 */
+    uint32_t sp;           /*  8: General register R1 (stack pointer) */
+    uint32_t r2;           /*  9: General register R2 */
+    uint32_t r3;           /* 10: General register R3 */
+    uint32_t r4;           /* 11: General register R4 */
+    uint32_t r5;           /* 12: General register R5 */
+    uint32_t r6;           /* 13: General register R6 */
+    uint32_t r7;           /* 14: General register R7 */
+    uint32_t r8;           /* 15: General register R8 */
+    uint32_t r9;           /* 16: General register R9 */
+    uint32_t r10;          /* 17: General register R10 */
+    uint32_t r11;          /* 18: General register R11 */
+    uint32_t r12;          /* 19: General register R12 */
+    uint32_t r13;          /* 20: General register R13 */
+
+    /* emulated registers used by the VBI_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;         /* 21: emulated MSR register */
+#endif
+
+    uint32_t level_irq_disable; /* TBD interrupt level enabling */
+    uint32_t vIoapic;  /* filler */
+    uint32_t irq_pend; /* filler */
+};
+
+
+
+/* Information about a shared memory region */
+struct vb_sm_info
+{
+    VB_WRHV_NAME  name;   /* The name of the shared memory region */
+    void *         addr;   /* The vbphysical address of the region */
+    unsigned int   length; /* The length in bytes of the region */
+    unsigned int   attr;   /* The arch specific MMU attributes of the region */
+    unsigned int   type;   /* TBD shared memory type field */
+    unsigned int * BoardIds; /* TBD board IDS connected */
+};
+
+/* info for IO port region */
+struct vb_io_port_info
+{
+    VB_WRHV_NAME      name;   /* The name of the shared memory region */
+    unsigned int       port;   /* unique port addr                   */
+    unsigned int       size;   /* port addr size */
+};
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+struct vb_config
+{
+    unsigned int  sizeConfig;  /* The size in pages of the configuration area */
+    int           boardID;     /* partition ID from the XML configuration */
+
+    unsigned int  sizeStatus;  /* effective size of vbStatus */
+    struct vb_status *vb_status;    /* Read only status */
+    unsigned int  sizeControl; /* effective size of vbControl */
+    struct vb_control *vb_control;   /* Read Write area */
+    int           supervisoryMode; /* Is this board is privileged mode? */
+
+    char board_name[VB_NAMELEN];   /* The name of this board */
+    unsigned int  partitionType;  /* TBD field */
+    unsigned int  phys_mem_size; /* The vbPhysical size of RAM */
+    unsigned int  mem_alias_addr;	/* address to which memory is aliased */
+    unsigned int  mem_alias_size;	/* size of aliases memory */
+    void *        reset_pc;              /* partition reset vector */
+
+    /* The frequency of the periodic tick interrupt */
+
+    unsigned int  tick_freq; /* Ticks per second */
+
+    /* The frequency of the timestamp */
+
+    unsigned int  stamp_freq; /* Ticks per second */
+
+    /* Interrupt configuration of this board */
+
+    unsigned int  num_ints;    /* Number of interrupt configurations */
+    struct vb_int_info *interruptConfiguration; /* Configuration location */
+
+    /* Shared memory configuration information */
+
+    unsigned int  num_sm;     /* Number of shared memory regions */
+    struct vb_sm_info *sharedMemoryRegionsConfigAddress; /* config info */
+
+    /* Shared memory state information */
+
+    void *        sharedMemoryRegionsStateAddress;
+
+    /* Memory map configuration for this virtual board */
+
+    unsigned int  num_mem;     /* Number of memory regions */
+    struct vb_mem_info *memoryRegionsConfigAddress; /* configuration info */
+
+#ifdef CONFIG_X86
+    /* IO port region for the virtual board */
+    unsigned int     numIoPortRgn;     /* number of io port regions */
+    struct vb_io_port_info * vbIoPortRgn;      /* IO port Region Info  array*/
+#endif
+
+    int           numExc;     /* how many exceptions to forward to VB */
+    unsigned int  exceptions [VB_MAX_EXCEPTION_TYPES]; /* forward EXC list */
+
+    /* OS specific boot line */
+
+    char	  bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+    /* partition cache mode */
+
+    unsigned int  cacheMode;
+
+    unsigned int      numPorts;  /* number of ports defined for the VB */
+    /*
+     * MILS vbInterface.h has the following:
+     *		typedef struct portConfig VB_PORT_INFO
+     *			... and later...
+     *		VB_PORT_INFO * portInfo; 
+     */
+    struct portConfig *portInfo;  /* port configuration and status */
+
+    struct vb_log_cfg secAuditLogCfg;
+    struct vb_log_cfg safetyLogCfg;
+
+    char		booter[VB_NAMELEN];	/* The name of the booter */
+    unsigned int	bootAddress;		/* Booter Address */
+    unsigned int	vbElfImage;		/* VB Elf Image */
+
+    int               coreId;  /* Just a filler since MILS can only run on 1 core */
+    int               corePrivateSize; /* Just another filler */
+    void              *corePrivate;  /* filler */
+    int               pid;   /*filler */
+    int               board_type; /* filler*/
+
+};
+
+extern struct vb_config *wr_config;
+extern struct vb_status *wr_status;
+extern struct vb_control *wr_control;
+
+/* IOAPIC and IRQ chip stubs */
+static inline int32_t vbi_send_vcore_vioapic_irq (uint32_t irq,
+	uint32_t vcoreSet, uint32_t options)
+{
+	return 0;
+}
+
+static inline int32_t vbi_mask_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline void vbi_idle(uint64_t timeStamp)
+{
+}
+
+static inline int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector)
+{
+	return 0;
+}
+
+static inline int32_t vbi_get_vioapic_vec(uint32_t irq)
+{
+	return 0;
+}
+
+static inline void mils_pic_init(void)
+{
+	return;
+}
+
+static inline unsigned int mils_vioapic_get_irq(void)
+{
+	return 0;
+}
+
+static inline int32_t vbi_unmask_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline int32_t vbi_ack_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+                                     uint32_t vb)
+{
+	return 0;
+}
+
+static inline int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t tCore)
+{
+	return 0;
+}
+
+extern asmlinkage int vbi_virt_to_phys (void * pVirtAddr, void *pPaddr);
+
+static inline int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr)
+{
+#ifdef CONFIG_PPC
+	return vbi_virt_to_phys(gaddr, paddr);
+#else
+	return vbi_virt_to_phys(__va(gaddr), paddr);
+#endif
+}
+
+extern int vb_context_mmu_on(int pid, void * pgtable, int pagesize, int debug);
+
+#endif /*_ASMLANGUAGE */
+#endif  /* _VDK_INTERFACE_H */
+
diff --git a/include/vbi/vdk_port.h b/include/vbi/vdk_port.h
new file mode 100644
index 0000000..2621ff7
--- /dev/null
+++ b/include/vbi/vdk_port.h
@@ -0,0 +1,110 @@
+/*
+ * vdk_interface.h - virtual board interface header file
+ *
+ * Copyright (c) 2008-2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VDK_PORT_H
+#define _VDK_PORT_H
+
+#ifndef	_ASMLANGUAGE
+
+struct portBufCtrlDesc
+    {
+	unsigned long   startIdx;          /* the location of the first index */
+	unsigned long   numIdx;            /* number of valid indexes         */
+	unsigned long * sBufIdxList;       /* array of SIPC buffer indexes    */
+};
+
+typedef enum                           /* port direction type */ 
+{
+	SOURCE=0,
+	DESTINATION = 1,
+	BOTH = 2,
+} PORT_DIRECTION_TYPE;
+
+typedef enum                           /* port mode type            */ 
+{
+	QUEUING, 
+	SAMPLING
+} PORT_MODE_TYPE;
+
+/* These are not needed by the SK, just need to pass to VB. */
+typedef enum                            /* queuing port protocol     */
+{
+	SENDER_BLOCK,
+	RECEIVER_DISCARD,
+	NOT_APPLICABLE
+} PORT_PROTOCOL_TYPE;
+
+/* PORT queuing status definition */
+/* These defined values should agree with apexType.h for HYPERVISOR. */
+#define PORT_Q_RETRY				3
+#define PORT_Q_AVAILABLE			4
+#define PORT_Q_DEST_UNAVAILABLE			9
+
+#define MAX_NAME_LENGTH 30
+
+struct portConfig
+{
+	unsigned long id;		/* unique port ID                   */
+	unsigned char *buf;		/* port payload buffer vaddr        */
+	unsigned long bufAttr;		/* port payload buffer attribute    */
+	char name[MAX_NAME_LENGTH];	/* port name                        */
+	unsigned long vbId;		/* parent vb                        */
+	unsigned long moduleId;		/* parent module                    */
+	unsigned long inChannel;	/* in channel                       */
+	unsigned long outChannel;	/* out channel                      */
+	PORT_DIRECTION_TYPE direction;	/* SOURCE or DESTINATION            */
+	PORT_MODE_TYPE mode;		/* QUEUING or SAMPLING              */
+	PORT_PROTOCOL_TYPE protocol;	/* RECEIVER_DISCARD or SENDER_BLOCK */
+	unsigned long msgSize;		/* max. message size (PAGE_ALIGNED) */
+	unsigned long numMsgs;		/* max. capacity for queuing ports  */
+};
+
+struct partPortConfig
+{
+	unsigned long numPorts;
+	struct portConfig portInfo[];
+};
+
+struct portStatus				/* port runtime status        */
+{
+	unsigned char *sBuf;			/* SIPC buffer                */
+	unsigned long sBufSize;			/* size of SIPC buffer        */
+	unsigned long seqNum;			/* recv sequence number       */
+	unsigned long *freeSBufIdxBitMap;	/* free SIPC buf idx bit map  */
+	unsigned long *msgLenArray;		/* message length array       */
+	struct portBufCtrlDesc sendDesc;	/* send control descriptor    */
+	struct portBufCtrlDesc recvDesc;	/* recv control descriptor    */
+	struct portBufCtrlDesc relsDesc;	/* release control descriptor */
+};
+
+/* SK access only port information */
+struct portHyInfo
+{
+	unsigned char *sBuf;			/* SIPC buffer               */
+	unsigned long *freeSBufIdxBitMap;	/* free SIPC buf idx bit map */
+	unsigned long *msgLenArray;		/* message length array      */
+	unsigned long *sendSBufIdxList;
+	unsigned long *recvSBufIdxList;
+	unsigned long *relsSBufIdxList;
+};
+
+extern int portSend (unsigned long portId, unsigned long sendCnt, 
+			unsigned long length, unsigned long * returnValue);
+extern int portGetRecvBuf (unsigned long portId, unsigned long bufIdx);
+extern int portBufRelease (unsigned long portId, unsigned long relsCnt);
+
+#endif /* _ASMLANGUAGE */
+#endif /* _VDK_PORT_H */
diff --git a/include/vbi/vdk_syscalls.h b/include/vbi/vdk_syscalls.h
new file mode 100644
index 0000000..d4a2a06
--- /dev/null
+++ b/include/vbi/vdk_syscalls.h
@@ -0,0 +1,482 @@
+/*
+ * vdk_syscalls.h - MILS VDK hypervisor system calls
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VDK_SYSCALLS_H
+#define _VDK_SYSCALLS_H
+
+#include <linux/linkage.h>
+
+#ifdef __ASSEMBLY__
+#define _ASMLANGUAGE
+
+#define p0      r3      /* argument register, volatile */
+#define p1      r4      /* argument register, volatile */
+#define p2      r5      /* argument register, volatile */
+#define p3      r6      /* argument register, volatile */
+#define p4      r7      /* argument register, volatile */
+#define p5      r8      /* argument register, volatile */
+#define p6      r9      /* argument register, volatile */
+#define p7      r10     /* argument register, volatile */
+#endif
+
+/*
+ * System call number encoding:
+ *
+ * 31                                                                        0
+ *
+ *  |               |               |        |               |               |
+ *  +---------------+---------------+        +---------------+---------------+
+ *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
+ *  +---------------+---------------+        +---------------+---------------+
+ *   ^ ^ ^         ^ ^                                                      ^
+ *   | | \--------/  \------------------------------------------------------/
+ *   | |      |                                |
+ *   | |      |                                |
+ *   | |      |                                +-- System call number
+ *   | |      |
+ *   | |      +-- Fast hypervisor system call number
+ *   | |
+ *   | +--------- Hypervisor system call
+ *   |
+ *   +----------- Fast hypervisor system call
+ *
+ *
+ *
+ *
+ */
+
+/* fast system call numbers handled by assembler code */
+#define HY_FAST_SYSCALL_MASK	0x3f000000
+#define HY_FAST_SYSCALL_SHIFT	24
+#define HY_FAST_SYSCALL_BIT	0x80000000
+#define HY_FAST_SYSCALL(x)	\
+	((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+	 HY_FAST_SYSCALL_BIT)
+
+/* C driven system calls */
+#define HY_SYSCALL_MASK		0x00ffffff
+#define HY_SYSCALL_SHIFT	0
+#define HY_SYSCALL_BIT		0x40000000
+#define HY_SYSCALL(x)	\
+	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+
+/*
+   NOTE:  Hypercall X represents no direct mapping.
+          F represents a "fast" hypercall
+
+-------------------------------------------------------------------------------
+|  Standard                    |  MILS                         |              |
+|  Hypercall                   |  Hypercall                    |  Hypercall # |
+------------------------------------------------------------------------------|
+|  VBI_SYS_tlb_flush           |  VDK_SYS_invalidate_tlb_entry |      5  F    |
+|  VBI_SYS_icache_flush        |  VDK_SYS_icache_flush         |      1  F    |
+|  VBI_SYS_dcache_flush        |  VDK_SYS_dcache_flush         |      2  F    |
+|  VBI_SYS_ctx_load            |  VDK_SYS_CTX_LOAD             |      3  F    |
+|  VBI_SYS_int_enable          |  VDK_SYS_int_enable           |      4  F    |
+|  VBI_SYS_cache_text_update   |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_excVecBaseSet       |  VDK_SYS_excVecBaseSet        |      0       |
+|  VBI_SYS_hyIoctl             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vmContextCreate     |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_send                |  VDK_SYS_portSend             |      18      |
+|  VBI_SYS_receive             |  VDK_SYS_portGetRecvBuf       |      19      |
+|  VBI_SYS_reply               |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_panic               |  VDK_SYS_panic                |      2       |
+|  VBI_SYS_int                 |  VDK_SYS_int                  |      3       |
+|  VBI_SYS_int_controller_done |  VDK_SYS_int_controller_done  |      4       |
+|  VBI_SYS_ctxctl              |  VDK_SYS_null                 |      X       |
+|  VBI_SYS_vmmu_config         |  VDK_SYS_vmmu_config          |      5       |
+|  VBI_SYS_vmmu_enable         |  VDK_SYS_vmmu_enable          |      6       |
+|  VBI_SYS_vmmu_disable        |  VDK_SYS_vmmu_disable         |      7       |
+|  VBI_SYS_vmmu_tlbload        |  VDK_SYS_vmmu_tlbload         |      8       |
+|  VBI_SYS_vmmu_tlbflush       |  VDK_SYS_vmmu_tlbflush        |      9       |
+|  VBI_SYS_ctx_load_vmmu       |  VDK_SYS_ctx_load_vmmu        |      10      |
+|  VBI_SYS_mmu_attr_set        |  VDK_SYS_mmu_attr_set         |      11      |
+|  VBI_SYS_mmu_attr_get        |  VDK_SYS_mmu_attr_get         |      12      |
+|  VBI_SYS_bspIoctl            |  VDK_SYS_bspIoctl             |      13      |
+|  VBI_SYS_ctxctl              |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbMgmt              |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vIoapicIoctl        |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbReset             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbRestart           |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbSuspend           |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbResume            |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_kputs               |  VDK_SYS_kputs                |      21      |
+|  VBI_SYS_kputc               |  VDK_SYS_kputc                |      22      |
+|  VBI_SYS_ps                  |  VDK_SYS_ps                   |      23      |
+|  VBI_SYS_dbgShStart          |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vtlb_op             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_ns_op               |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_memWrite_op         |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_memRead_op          |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_RegsWrite_op        |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_RegsRead_op         |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_DELETE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PTE      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_MAX_OPS         |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_FLUSH_OPS       |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_CR3_CACHE_ENTR  |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PTE      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_DELETE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_SET_PTE_AT      |  VDK_SYS_NULL                 |      X       |
+------------------------------------------------------------------------------|
+
+*/
+
+/* No direct mapping */
+/* Until the MILS dudes get themselves up to VBI 2.0 they
+have mapped a NULL / no-op to HY_SYSCALL(23) */
+#define VDK_SYS_NULL             HY_SYSCALL(23) /* define a non-existant system call */
+
+/* fast system calls */
+#define VBI_SYS_tlb_flush        HY_FAST_SYSCALL(5) /* TLB flush */
+#define VBI_SYS_icache_flush     HY_FAST_SYSCALL(1) /* instruction cache flush */
+#define VBI_SYS_dcache_flush     HY_FAST_SYSCALL(2) /* data cache flush  */
+#define VBI_SYS_ctx_load         HY_FAST_SYSCALL(3) /* context load */
+#define VBI_SYS_int_enable       HY_FAST_SYSCALL(4) /* int enable */
+#define VBI_SYS_cache_text_update                   \
+                                 VDK_SYS_NULL /* cache text update */
+/* Normal system calls */
+#define VBI_SYS_excVecBaseSet    HY_SYSCALL(0)  /* Set exception base vector */
+#define VBI_SYS_virtToPhys       HY_SYSCALL(1)  /* conv. virt addr to phys. */
+/* hypervisor services */
+#define VBI_SYS_hyIoctl          VDK_SYS_NULL  /* hypervisor ioctl */
+#define VBI_SYS_vmContextCreate  VDK_SYS_NULL  /* context create */
+#define VBI_SYS_send             VDK_SYS_NULL  /* send a message */
+#define VBI_SYS_receive          VDK_SYS_NULL  /* receive a message */
+#define VBI_SYS_reply            VDK_SYS_NULL  /* reply to a messages */
+#define VBI_SYS_panic            HY_SYSCALL(2)  /* halt the system */
+#define VBI_SYS_int              HY_SYSCALL(3)  /* deliver an interrupt */
+#define VBI_SYS_int_controller_done HY_SYSCALL(4) /* done intr processing*/
+#define VBI_SYS_ctxctl           VDK_SYS_NULL  /* context control operation */
+#define VBI_SYS_invalidate_tlb_entry   HY_FAST_SYSCALL(5) /* invalidate TLB entry */
+
+/* VMMU operations */
+#define VBI_SYS_vmmu_config     HY_SYSCALL(5)  /* configure the virtual MMU */
+#define VBI_SYS_vmmu_enable     HY_SYSCALL(6)  /* enable the virtual MMU    */
+#define VBI_SYS_vmmu_disable    HY_SYSCALL(7)  /* disable the virtual MMU   */
+#define VBI_SYS_vmmu_tlbload    HY_SYSCALL(8)  /* load a VMMU TLB entry     */
+#define VBI_SYS_vmmu_tlbflush   HY_SYSCALL(9)  /* flush a VMMU TLB entry    */
+#define VBI_SYS_ctx_load_vmmu   HY_SYSCALL(10)  /* load context with vmmu    */
+
+/* MMU operations */
+#define VBI_SYS_mmu_attr_set    HY_SYSCALL(11)  /* set physical memory attr  */
+#define VBI_SYS_mmu_attr_get    HY_SYSCALL(12)  /* get physical memory attr  */
+
+/* BSP specific interface */
+#define VBI_SYS_bspIoctl        HY_SYSCALL(13)  /* BSP specific operation   */
+
+/* Calls only used by the MILS specific add-on drivers */
+#define VBI_SYS_secAuditEventInject     HY_SYSCALL(16)
+#define VBI_SYS_secAuditEventCollect    HY_SYSCALL(17)
+#define VBI_SYS_portSend                HY_SYSCALL(18)
+#define VBI_SYS_portGetRecvBuf          HY_SYSCALL(19)
+#define VBI_SYS_portBufRelease          HY_SYSCALL(20)
+ 
+/* vbMgmt services */
+#define VBI_SYS_ctxctl          VDK_SYS_NULL  /* context control operation */
+#define VBI_SYS_vbMgmt          VDK_SYS_NULL
+
+/* Virtual IO APIC services */
+/* Not allowed to enable intr in MILS*/
+#define VBI_SYS_vIoapicIoctl    VDK_SYS_NULL
+
+/* Currently not implemented in MILS */
+#define VBI_SYS_vbReset         VDK_SYS_NULL  /* reset  vcores        */
+#define VBI_SYS_vbRestart       VDK_SYS_NULL  /* restart vcores       */
+#define VBI_SYS_vbSuspend       VDK_SYS_NULL  /* suspend vcores       */
+#define VBI_SYS_vbResume        VDK_SYS_NULL  /* Resume vcores        */
+#define VBI_SYS_intRedirect     VDK_SYS_NULL  /* vcores int redirect  */
+
+/* debug facilities */
+#define VBI_SYS_kputs           HY_SYSCALL(21)  /* print a string to the cons*/
+#define VBI_SYS_kputc           HY_SYSCALL(22)  /* print a char to the cons  */
+#define VBI_SYS_ps              VDK_SYS_NULL    /* process status display    */
+#define VBI_SYS_dbgShStart      VDK_SYS_NULL    /* start debug shell         */
+
+/* Calls only used by the MILS specific add-on drivers */
+#define VBI_SYS_scheduleSet             HY_SYSCALL(25)
+#define VBI_SYS_scheduleNameToId        HY_SYSCALL(26)
+#define VBI_SYS_safeCritEventInject     HY_SYSCALL(27)
+#define VBI_SYS_safeCritEventCollect    HY_SYSCALL(28)
+
+/* VTLB MMU operations */
+#define VBI_SYS_vtlb_op         VDK_SYS_NULL /* VTLB operation */
+
+/* Name services */
+#define VBI_SYS_ns_op           VDK_SYS_NULL  /* Name service operation */
+
+/* remote board memory services */
+/* Breaks MILS security model */
+#define VBI_SYS_memWrite_op     VDK_SYS_NULL  /* memory write service operation */
+/* Breaks MILS security model */
+#define VBI_SYS_memRead_op      VDK_SYS_NULL  /* memory read service operation */
+
+/* remote board register services */
+/* Breaks MILS security model */
+#define VBI_SYS_RegsWrite_op    VDK_SYS_NULL  /* regs write service operation */
+/* Breaks MILS security model */
+#define VBI_SYS_RegsRead_op     VDK_SYS_NULL  /* regs service operation */
+
+/* VTLB operation command and flags (intel-vt specific) */
+#define VBI_VTLB_OP_UPDATE_PMD		0
+#define VBI_VTLB_OP_UPDATE_PTE		0
+#define VBI_VTLB_OP_DELETE_PMD		0
+#define VBI_VTLB_OP_SET_PTE_AT		0
+#define VBI_VTLB_OP_SET_PTE		0
+#define VBI_VTLB_OP_FLUSH_OPS		0
+#define VBI_VTLB_OP_INIT		0
+
+/* VTLB macros */
+#define VBI_VTLB_OP_MAX_OPS		0
+#define VBI_VTLB_OP_CR3_CACHE_ENTRIES   0
+
+/* VTLB optimization supported options */
+#define VBI_VTLB_OPTIM_ENABLED			0
+#define VBI_VTLB_CR3_CACHE_ENABLED		0
+#define VBI_VTLB_OPS_CACHE_ENABLED		0
+#define VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	0
+
+
+
+/* Max number of syscalls*/
+#define VBI_SYS_max		(73 + 1)
+
+/* hyIoctl system call supported ioctl's */
+#define VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+#define VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
+#define VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+
+/* vIoapicIoctl system call supported ioctl's */
+#define VBI_IOAPICIOCTL_UNMASK	    1	/* unmask v io apic interrupt src */
+#define VBI_IOAPICIOCTL_SEND	    2	/* inject a v io apic interrupt */
+#define VBI_IOAPICIOCTL_EOI	    3	/* end of interrupt acknowledge */
+#define VBI_IOAPICIOCTL_VCORE_SEND  4	/* Send an irq to a core	*/
+/* remove this after vbControl is working, we don't need a hypercall for it: */
+#define VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
+
+/* VBI_IOAPICIOCTL_SEND options */
+#define VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
+#define VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
+#define VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
+#define VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
+#define VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
+
+/* sent interrupt to a virtual flags */
+#define VBI_IOAPICSEND_VCORE_NONE 0	/* there no option available for now */
+
+
+/* hyCtxctl system call supported operations */
+#define VBI_CTXCTL_IDLE		1	/* make current context idle	*/
+
+/* MMU protection attributes */
+#define VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+
+/* ETSEC MDIO supported ioctl's */
+#define VBI_BSPIOCTL_DRV_MDIO 1         /* mdio messages */
+
+/* system clock frequency query */
+#define VBI_BSPIOCTL_SYS_CLK 2
+
+#define VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
+
+#define MDIO_READ 1
+#define MDIO_WRITE 2
+#define MDIO_INT_ENABLE 3
+#define MDIO_INT_DISABLE 4
+
+/* vbi_hy_ioctl for PADDR */
+#define VBI_HYIOCTL_PADDR_DMA        0x0 /* Default used for DMA */
+#define VBI_HYIOCTL_PADDR_PHYS       0x1 /* When absolute phys addr needed */
+
+/* vbMgmt commands */
+#define VBI_VBMGMT_ATTACH       1       /* Attach to VB for control */
+#define VBI_VBMGMT_DETACH       2       /* Detech from VB */
+#define VBI_VBMGMT_SUSPEND      3       /* Suspend/halt VB */
+#define VBI_VBMGMT_RESUME       4       /* Resume/start a VB */
+#define VBI_VBMGMT_RESET        5       /* Reset VB */
+#define VBI_VBMGMT_RESTART      6       /* Restart a VB */
+
+/* vbMgmt error codes */
+#define VBI_ERROR_CODE              int32_t
+#define VBI_ERR_GENERAL             -101   /* General error */
+#define VBI_ERR_INVALID_ARG         -102   /* General error */
+
+/* vbMgmt reset macros */
+#define VBI_VBMGMT_RESET_NON_CORE0	    0x00000000     /* APs dont clear mem */
+#define VBI_VBMGMT_RESET_DOWNLOAD	 0x00000001 /* disable ELF reloading */
+#define VBI_VBMGMT_RESET_CLEAR		 0x00000002 /* do not clear memory */
+#define VBI_VBMGMT_RESET_AND_START_CORE0 0x00000004
+
+/* target vb options */
+#define VBI_VB_CORES_ALL	(0x80000000)
+#define VBI_VB_CORES_OTHERS	(0x40000000)
+
+
+
+/* vbi_ns_op system call supported operations */
+#define VBI_NS_REGISTER		1	/* register service name    */
+#define VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define VBI_NS_LOOKUP	        3	/* look up service name	    */
+
+#ifndef _ASMLANGUAGE
+
+/* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
+
+struct vbi_ctx_stats
+{
+	unsigned long ctx_type;		/* type of context (user, supv, etc) */
+	unsigned long switchin;		/* number of times switched in       */
+	unsigned long pended;		/* number of times in pend state     */
+	unsigned long tsCtxSwitchOutH;  /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchOutL;  /* timestamp: context switch (low)   */
+	unsigned long tsCtxSwitchInH;   /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchInL;   /* timestamp: context switch (low)   */
+	unsigned long tsCtxExcInH;	/* timestamp: exception entry (high) */
+	unsigned long tsCtxExcInL;	/* timestamp: exception entry (low)  */
+	unsigned long reset;		/* number of times context reset     */
+};
+
+/* VTLB operation structures (x86 specific) */
+struct vbi_vtlb_op
+{
+	uint32_t op;		/* VTLB operation id */
+	uint32_t arg1;		/* VTLB operation arg 1 */
+	uint32_t arg2;		/* VTLB operation arg 2 */
+	uint32_t arg3;		/* VTLB operation arg 3 */
+};
+
+struct vbi_vtlb_cr3_cache
+{
+	uint32_t guest_cr3;	/* Guest CR3 register */
+	uint32_t host_cr3;	/* Host CR3 register */
+};
+
+struct vbi_vtlb_control
+{
+	uint32_t size;		/* VTLB Control structure size */
+	uint32_t mode;		/* VTLB module */
+	uint32_t vtlb_ops_ix;	/* VTLB operation index */
+	struct vbi_vtlb_op vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
+	uint32_t cr3_cache_ix;	/* CR3 cache index */
+				/* cr3 cache*/
+	struct vbi_vtlb_cr3_cache cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES];
+};
+
+struct vbi_msg_ctl
+{
+	/* Unused by MILS */
+};
+
+struct vbi_msg_info
+{
+	/* Unused by MILS */
+};
+
+/*
+ * Control structure used by vbi_vb_mgmt for commands memory read, memory write,
+ *  register read, and register write.
+ */
+
+typedef struct vbMgmtCtl
+{
+	union
+	{
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t *pAddress; /* address of calling context */
+			uint32_t size;	/* number of total bytes */
+			uint32_t width;	/* bus width in bytes */
+		} vbMgmtMem;
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t regSet;	/* register set */
+			uint32_t reg;	/* macro to specify register */
+			uint32_t size;	/* number of total bytes */
+		} vbMgmtReg;
+	} data;
+} VBMGMT_CTL;
+
+typedef uint32_t VBMGMT_HANDLE;
+typedef uint32_t VBI_NS_HANDLE;
+
+/* Forward declaration */
+struct vmmuConfig;
+
+/* system call prototypes for use within a context */
+
+extern int vbi_flush_dcache (void *saddr, void *eaddr, unsigned size);
+extern int vbi_flush_icache (void *saddr, void *eaddr, unsigned size);
+extern int vbi_config_vmmu (struct vmmuConfig * config);
+extern int vbi_enable_vmmu (unsigned vmmu_num);
+extern int vbi_disable_vmmu (unsigned vmmu_num);
+
+extern asmlinkage int vbi_virt_to_phys (void * pVirtAddr, void *pPaddr);
+extern asmlinkage int vbi_int_controller_done(unsigned level);
+extern asmlinkage int32_t vbi_vcore_irq_lock(void);
+extern asmlinkage void vbi_vcore_irq_unlock(void);
+
+static inline int32_t vbi_hy_ioctl(unsigned ioctl, void *arg1, void *arg2, \
+		void *arg3, void *arg4)
+{
+	if(ioctl == VBI_HYIOCTL_PADDR) {
+		return vbi_virt_to_phys(arg1, (void *)arg2);
+	}
+	else
+		return -1;
+}
+
+/*
+ * The following are MILS extensions and not part of the normal
+ * VBI 2.0 syscall set.
+ */
+
+extern asmlinkage int vdk_sec_audit_event_inject(const int eventId,
+                                      const int32_t resource,
+                                      const uint32_t outcome);
+extern asmlinkage int vdk_sec_audit_event_collect(const int32_t numEntriesToGet,
+                                       char *pCollectedRecords,
+                                       int32_t *pNumEntriesRead);
+extern asmlinkage int vdk_safe_crit_event_inject(const char *pRecord);
+extern asmlinkage int vdk_safe_crit_event_collect(int numEntriesToGet,
+                                       char *pCollectedRecords,
+                                       int *pNumEntriesRead);
+extern asmlinkage int vdk_port_send(unsigned long vbPortId, unsigned long sendCnt,
+                         unsigned long length, unsigned long * returnValue);
+extern asmlinkage int vdk_port_get_recv_buf(unsigned long vbPortId, unsigned long bufIdx);
+extern asmlinkage int vdk_port_buf_release(unsigned long vbPortId,
+                                unsigned long relsCnt);
+extern asmlinkage int vdk_schedule_set(const char *name, unsigned long mode);
+extern asmlinkage int vdk_schedule_name_to_id(const char *name,
+                                   unsigned long *scheduleId);
+extern asmlinkage int vdk_bsp_ioctl(unsigned cmd, int p1, int p2, int p3,
+				 int p4, int p5, int p6, int p7);
+
+
+#endif	/* _ASMLANGUAGE */
+
+#endif	/* _VDK_SYSCALLS_H */
diff --git a/init/Kconfig.wrhv b/init/Kconfig.wrhv
index 5cc80a8..3ac41ca 100644
--- a/init/Kconfig.wrhv
+++ b/init/Kconfig.wrhv
@@ -8,6 +8,15 @@ config WRHV
 	select SERIAL_CORE
 	select SERIAL_CORE_CONSOLE
 
+
+config WRHV_MILS
+	bool "MILS grade Hypervisor"
+	default n
+	depends on WRHV
+	help
+	  This option selects the MILS secure hypervisor virtualization extensions
+	  in the Linux Kernel.
+
 config DEBUG_VIRTUAL_IRQS
 	bool "Debug VIOAPIC with software IRQ"
 	default n
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 2d0af85..b3ad2af 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -2,5 +2,10 @@
 # Makefile for the vbi goodies.
 #
 
-obj-y     = shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
-	    version.o msg.o ns.o show.o
+obj-y := wrhv.o paddr.o lib.o shmem.o show.o version.o
+ifeq ($(CONFIG_WRHV_MILS),y)
+# No MILS specific files needed
+else
+obj-y += io_apic.o interrupt.o idle.o msg.o ns.o
+endif
+
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index a524769..0a42821 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -182,6 +182,7 @@ struct vb_status *wr_vb_status;	/* The address of the core's Status area */
  */
 void vbi_init(struct vb_config *config)
 {
+#ifndef CONFIG_WRHV_MILS
 	/*
 	 * validate the vbi version; minor and maintenance should be backward
 	 * compatible.
@@ -189,6 +190,7 @@ void vbi_init(struct vb_config *config)
 	if ((config->major != vbi_version_major) ||
 					 (config->minor < vbi_version_minor))
 		vbi_panic("Invalid vbi version");
+#endif
 
 	wr_vb_config = config;
 	wr_vb_control = wr_vb_config->vb_control;
-- 
1.7.0

