From d3fcd787c9580f8f6a8a91a0ad3763da90236277 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 22 Oct 2009 14:47:11 -0400
Subject: [PATCH 3/3] vbi: cleanup, redundant comments, etc.

Some files had complete copies of the relevant structs encoded
a second time within the comments above the struct, with no
extra descriptions or value adds.  The comment blocks have been
cleaned up/pruned/reformatted to suck less, some of the trailing
whitespace crimes were removed, some struct entries have been
shuffled from 4 spaces to tabs, and needless brackets around
return values have been purged.)

This is a big diff, but no functional code changes are made by
this commit.  (Some straggling uses of OK and ERROR were replaced
by the underlying zero and -1 values respectively, as would have
been done by cpp before).

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/vbi/vmmu_display.c |  253 +++++------
 arch/powerpc/kernel/vbi/wrhv.c         |    3 +-
 kernel/vbi/idle.c                      |   60 +--
 kernel/vbi/interrupt.c                 |   72 ++--
 kernel/vbi/io_apic.c                   |  821 +++++++++++++-------------------
 kernel/vbi/lib.c                       |  794 ++----------------------------
 kernel/vbi/msg.c                       |  139 ++-----
 kernel/vbi/ns.c                        |  157 ++-----
 kernel/vbi/paddr.c                     |  108 ++---
 kernel/vbi/shmem.c                     |  203 +++------
 kernel/vbi/show.c                      |    8 +-
 kernel/vbi/version.c                   |    3 -
 kernel/vbi/wrhv.c                      |    5 +-
 13 files changed, 718 insertions(+), 1908 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/vmmu_display.c b/arch/powerpc/kernel/vbi/vmmu_display.c
index da13daf..43fb058 100644
--- a/arch/powerpc/kernel/vbi/vmmu_display.c
+++ b/arch/powerpc/kernel/vbi/vmmu_display.c
@@ -22,140 +22,119 @@
 #define __pa(vaddr) (((unsigned long )(vaddr))-0xC0000000)
 
 
-/*******************************************************************************
-*
-* vmmuPageTableDisplay - display information about the specified page table
-*
-* This routine display all the VMMU PTE entries in the specified table
-*
-*/
-
-void vmmuPageTableDisplay
-    (
-    VMMU_LEVEL_1_DESC *l1,
-    int                vmmuon
-    )
-    {
-    VMMU_LEVEL_2_DESC  *l2;
-    VMMU_PTE	       *pte;
-    VMMU_EFFECTIVE_ADDR ea;
-    u_int l1_index;
-    u_int i,j;
-
-    l1_index = 0;
-    ea.addr = 0;
-
-    printk ("Logical           Physical          R C U[01234567] WIMGE S[XWR] U[XWR]\n");
-    printk ("----------------- ----------------- - -  ---------- -----  -----  -----\n");
-
-    /* run through all the entries */
-
-    for (i=0; i<VMMU_L1_ENTRIES; i++)
-	{
-	if (l1->field.v)
-	    {
-	    ea.field.l1index = l1_index;
-	    l2 = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba);
-    	    if (vmmuon)
-                l2 = __va (l2);
-	    pte = (VMMU_PTE *)l2;
-	    for (j=0; j<VMMU_L2_ENTRIES; j++)
-		{
-		if (pte->field.v)
-		    {
-		    ea.field.l2index = j;
-		    printk ("%08x-%08x %08x-%08x %d %d ",
-			ea.addr, (u_int)ea.addr + 0xfff,
-			pte->field.rpn << VMMU_RPN_SHIFT,
-			(pte->field.rpn << VMMU_RPN_SHIFT) + 0xfff,
-			pte->field.r, pte->field.c);
-		    printk ("  %d%d%d%d%d%d%d%d  %d%d%d%d%d   %c%c%c    %c%c%c\n",
-			pte->field.u0, pte->field.u1,
-			pte->field.u2, pte->field.u3,
-			pte->field.u4, pte->field.u5,
-			pte->field.u6, pte->field.u7,
-			pte->field.w, pte->field.i, pte->field.m,
-			pte->field.g, pte->field.e,
-			pte->field.sx ? 'X' : ' ',
-			pte->field.sw ? 'W' : ' ',
-			pte->field.sr ? 'R' : ' ',
-			pte->field.ux ? 'X' : ' ',
-			pte->field.uw ? 'W' : ' ',
-			pte->field.ur ? 'R' : ' ');
-		    }
-		pte++;
-		}
-	    }
-	l1++;
-	l1_index++;
-	}
-    }
-
-/*******************************************************************************
-*
-* vmmuPteDisplay - display a specific PTE entry
-*
-* This routine display the VMMU PTE entrie corresponding to the specified
-* virtual address.
-*
-*/
-
-unsigned int vmmuPteDisplay
-    (
-    VMMU_LEVEL_1_DESC *l1, /* pointer to level-1 page table */
-    void   *vaddr	   /* virtual address to display */
-    )
-    {
-    volatile VMMU_LEVEL_2_DESC  *l2;
-    VMMU_PTE	       *pte;
-
-    /* find the level-1 page table descriptor for the virtual address */
-
-    l1 += VMMU_L1_INDEX(vaddr);
-
-    /* if no level-2 table exists abort and return error */
-
-    if (!l1->field.v)
-	{
-	return (-1);
-	}
-
-    /* locate correct PTE entry in level-2 table */
-
-    l2  = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba) +
-	   VMMU_L2_INDEX(vaddr);
-
-    l2 = __va (l2);
-
-    pte = &l2->pte;
-
-    /* if pte is not valid abort and return error */
-
-    if (!pte->field.v)
-	{
-	return (-1);
-	}
-
-    printk ("PTE for virtual address 0x%08x:\n", vaddr);
-    printk ("  Page Number:  0x%08x\n", pte->field.rpn<<VMMU_RPN_SHIFT);
-    printk ("  Referenced:   %d\n", pte->field.r);
-    printk ("  Changed:      %d\n", pte->field.c);
-    printk ("  User bits:    %d%d%d%d%d%d%d%d\n",
-	pte->field.u0, pte->field.u1,
-	pte->field.u2, pte->field.u3,
-	pte->field.u4, pte->field.u5,
-	pte->field.u6, pte->field.u7);
-    printk ("  WIMGE:        %d%d%d%d%d\n",
-	pte->field.w, pte->field.i, pte->field.m,
-	pte->field.g, pte->field.e);
-    printk ("  Supv Perms:   %c%c%c\n",
-	pte->field.sr ? 'R' : '-',
-	pte->field.sw ? 'W' : '-',
-	pte->field.sx ? 'X' : '-');
-    printk ("  User Perms:   %c%c%c\n",
-	pte->field.ur ? 'R' : '-',
-	pte->field.uw ? 'W' : '-',
-	pte->field.ux ? 'X' : '-');
-
-    return (0);
-    }
+/*
+ *
+ * vmmuPageTableDisplay - display information about the specified page table
+ *
+ * This routine display all the VMMU PTE entries in the specified table
+ *
+ */
+
+void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon)
+{
+	VMMU_LEVEL_2_DESC *l2;
+	VMMU_PTE *pte;
+	VMMU_EFFECTIVE_ADDR ea;
+	u_int l1_index;
+	u_int i,j;
+
+	l1_index = 0;
+	ea.addr = 0;
+
+	printk("Logical           Physical          R C U[01234567] WIMGE S[XWR] U[XWR]\n");
+	printk("----------------- ----------------- - -  ---------- -----  -----  -----\n");
+
+	/* run through all the entries */
+	for (i=0; i<VMMU_L1_ENTRIES; i++) {
+		if (l1->field.v) {
+			ea.field.l1index = l1_index;
+			l2 = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba);
+			if (vmmuon)
+				l2 = __va (l2);
+
+			pte = (VMMU_PTE *)l2;
+
+			for (j=0; j<VMMU_L2_ENTRIES; j++) {
+				if (pte->field.v) {
+					ea.field.l2index = j;
+					printk ("%08x-%08x %08x-%08x %d %d ",
+					ea.addr, (u_int)ea.addr + 0xfff,
+					pte->field.rpn << VMMU_RPN_SHIFT,
+					(pte->field.rpn << VMMU_RPN_SHIFT) + 0xfff,
+					pte->field.r, pte->field.c);
+					printk ("  %d%d%d%d%d%d%d%d  %d%d%d%d%d   %c%c%c    %c%c%c\n",
+					pte->field.u0, pte->field.u1,
+					pte->field.u2, pte->field.u3,
+					pte->field.u4, pte->field.u5,
+					pte->field.u6, pte->field.u7,
+					pte->field.w, pte->field.i,
+					pte->field.m,
+					pte->field.g, pte->field.e,
+					pte->field.sx ? 'X' : ' ',
+					pte->field.sw ? 'W' : ' ',
+					pte->field.sr ? 'R' : ' ',
+					pte->field.ux ? 'X' : ' ',
+					pte->field.uw ? 'W' : ' ',
+					pte->field.ur ? 'R' : ' ');
+				} /* pte field.v */
+				pte++;
+			} /* j */
+		} /* l1 field.v */
+		l1++;
+		l1_index++;
+	} /* i */
+}
+
+/*
+ * vmmuPteDisplay - display a specific PTE entry
+ *
+ * This routine display the VMMU PTE entrie corresponding to the specified
+ * virtual address.
+ *
+ */
+unsigned int vmmuPteDisplay(VMMU_LEVEL_1_DESC *l1, void *vaddr)
+{
+	volatile VMMU_LEVEL_2_DESC  *l2;
+	VMMU_PTE *pte;
+
+	/* find the level-1 page table descriptor for the virtual address */
+	l1 += VMMU_L1_INDEX(vaddr);
+
+	/* if no level-2 table exists abort and return error */
+	if (!l1->field.v)
+		return -1;
+
+	/* locate correct PTE entry in level-2 table */
+	l2  = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba) +
+		VMMU_L2_INDEX(vaddr);
+
+	l2 = __va (l2);
+
+	pte = &l2->pte;
+
+	if (!pte->field.v)
+		return  -1;
+
+	printk("PTE for virtual address 0x%08x:\n", vaddr);
+	printk("  Page Number:  0x%08x\n", pte->field.rpn<<VMMU_RPN_SHIFT);
+	printk("  Referenced:   %d\n", pte->field.r);
+	printk("  Changed:      %d\n", pte->field.c);
+	printk("  User bits:    %d%d%d%d%d%d%d%d\n",
+		pte->field.u0, pte->field.u1,
+		pte->field.u2, pte->field.u3,
+		pte->field.u4, pte->field.u5,
+		pte->field.u6, pte->field.u7);
+	printk("  WIMGE:        %d%d%d%d%d\n",
+		pte->field.w, pte->field.i, pte->field.m,
+		pte->field.g, pte->field.e);
+	printk("  Supv Perms:   %c%c%c\n",
+		pte->field.sr ? 'R' : '-',
+		pte->field.sw ? 'W' : '-',
+		pte->field.sx ? 'X' : '-');
+	printk("  User Perms:   %c%c%c\n",
+		pte->field.ur ? 'R' : '-',
+		pte->field.uw ? 'W' : '-',
+		pte->field.ux ? 'X' : '-');
+
+	return 0;
+}
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 3f5a044..dad4cec 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -136,7 +136,8 @@ void wrhv_mapping(void)
 {
 	/* map in vbConfig address */
 
-	/* WRHV VB_CONFIG should really add a length field for each
+	/*
+         * WRHV VB_CONFIG should really add a length field for each
 	 * of the objected we mapped.  As the sizes are WRHV
 	 * implementation AND worse, configuration dependent.
 	 *
diff --git a/kernel/vbi/idle.c b/kernel/vbi/idle.c
index 3976750..adf2ae4 100644
--- a/kernel/vbi/idle.c
+++ b/kernel/vbi/idle.c
@@ -1,4 +1,4 @@
-/* idle.c - context idle code 
+/* idle.c - context idle code
  *
  * Copyright (c) 2007-2009 Wind River Systems, Inc.
  *
@@ -14,47 +14,31 @@
  */
 
 /*
-DESCRIPTION
-This module provides an interface to put the currently running virtual board
-into the idle state.
-*/
-
-/* includes */
+ * This provides an interface to put the currently running virtual board
+ * into the idle state.
+ */
 
 #include <linux/types.h>
 #include <vbi/vbi.h>
 
-/*******************************************************************************
-*
-* vbiIdle - inform the hypervisor scheduler that the virtual board is idle
-*
-* This function informs the hypervisor that the virtual board core's is idle and
-* also provides a timeout at which it needs to be made ready to run again. This
-* routine halts the active core untill the specified timeout expires or and an
-* asynchronous event like a interrupt is delivered to the calling core. An zero
-* timeout means to halt the core indefinetly until an asynchronous event occurs.
-*
-* SYNOPSIS
-*
-* 
-* void vbiIdle (vbiTicks_t timeout)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*/
+/*
+ * vbiIdle - inform the hypervisor scheduler that the virtual board is
+ * idle
+ *
+ * This function informs the hypervisor that the virtual board core's is
+ * idle and also provides a timeout at which it needs to be made ready to
+ * run again. This routine halts the active core untill the specified
+ * timeout expires or and an asynchronous event like a interrupt is
+ * delivered to the calling core. An zero timeout means to halt the core
+ * indefinetly until an asynchronous event occurs.
+ *
+ */
 
-void vbiIdle
-    (
-    uint64_t timeStamp /* Time at which to wake up */
-    )
-    {
-    uint32_t tickCount = timeStamp & 0xFFFFFFFF;
+void vbiIdle(uint64_t timeStamp)
+{
+	uint32_t tickCount = timeStamp & 0xFFFFFFFF;
 
-    /* use the hypervisor system call to go into the idle state */
+	/* use the hypervisor system call to go into the idle state */
 
-    vbiCtxctl (VBI_CTXCTL_IDLE, tickCount, 0);
-    }
+	vbiCtxctl(VBI_CTXCTL_IDLE, tickCount, 0);
+}
diff --git a/kernel/vbi/interrupt.c b/kernel/vbi/interrupt.c
index e98487a..c538284 100644
--- a/kernel/vbi/interrupt.c
+++ b/kernel/vbi/interrupt.c
@@ -32,53 +32,39 @@
 #include <vbi/private.h>
 #include <linux/module.h>
 
-/******************************************************************************
-*
-* vbiIntVecFind - determine the irq for a specified name
-*
-* This function finds the irq number of a named interrupt from  the virtual
-* board configuration information.
-* 
-* The <intDirection> is either input or output. VB_INPUT_INT for input,
-* VB_OUTPUT_INT for output.
-*
-* EXAMPLES:
-* \cs
-*     fredIntVector = vbiIntVecFind ("fred", VB_INPUT_INT);
-* \ce
-*
-* RETURNS: vector number, VBI_INVALID_IRQ if not found
-*
-*/
+/*
+ * vbiIntVecFind - determine the irq for a specified name
+ *
+ * This function finds the irq number of a named interrupt from  the virtual
+ * board configuration information.
+ *
+ * The <intDirection> is either input or output. VB_INPUT_INT for input,
+ * VB_OUTPUT_INT for output.
+ *
+ */
 
-vbiIrq_t vbiIntVecFind
-    (
-    char *  intName,		/* string name of the interrupt */
-    int32_t  intDirection 	/* interrupt direction */
-    )
-    {
-    VB_CONFIG *   config = VBI_CONFIG_ADDR_GET();
-    VB_INT_INFO * info = config->interruptConfiguration;
-    int32_t       num  = config->numInts;
-    int32_t       i;
+vbiIrq_t vbiIntVecFind(char *intName, int32_t intDirection)
+{
+	VB_CONFIG *config = VBI_CONFIG_ADDR_GET();
+	VB_INT_INFO *info = config->interruptConfiguration;
+	int32_t num  = config->numInts;
+	int32_t i;
 
-    for (i = 0; i < num; i++, info++)
-        {
-        if (intDirection != (int32_t)(info->intDirection))
-            continue;
+	for (i = 0; i < num; i++, info++)
+	{
+		if (intDirection != (int32_t)(info->intDirection))
+			continue;
 
-        if (!_vbiStrncmp ((char *)intName, (char *)info->intName,
-            VB_MAX_WRHV_NAME_LENGTH))
-            {
+		if (!_vbiStrncmp ((char *)intName, (char *)info->intName,
+				VB_MAX_WRHV_NAME_LENGTH)) {
 
-            /* Found */
+		        /* Found */
+	        	return (int32_t)info->intNumber;
+	        }
+	}
 
-            return (int32_t)info->intNumber;
-            }
-        }
+	return VBI_INVALID_IRQ; /* no match */
+}
 
-    return (VBI_INVALID_IRQ); /* no match */
-    }
-#ifdef CONFIG_WRHV
 EXPORT_SYMBOL(vbiIntVecFind);
-#endif /* CONFIG_WRHV */
+
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
index bbb3f98..280b8b6 100644
--- a/kernel/vbi/io_apic.c
+++ b/kernel/vbi/io_apic.c
@@ -19,15 +19,10 @@
 #include <vbi/vbi.h>
 #include <vbi/private.h>
 
-/* globals */
-
-/* externs */
-
-/* defines */
-
-/* APIC register get/set macros  Accesses are double words using an
+/*
+ * APIC register get/set macros  Accesses are double words using an
  * indirect addressing scheme.
- * Redirection table entry bits: lower 32 bit 
+ * Redirection table entry bits: lower 32 bit
  */
 
 /* IO APIC Register Offset */
@@ -41,10 +36,6 @@
 
 #define VIOAPIC_MAX_REDTABLE_ENTRIES	128
 
-#ifndef OK
-#define OK  (0)
-#endif
-
 #if 0
 #define DEBUG
 #endif
@@ -54,9 +45,12 @@
 #else
 #define DEBUGM(fmt, arg...)
 #endif
-/* IO APIC register get/set macros */
-/* Accesses are double words using an
+
+/*
+ * IO APIC register get/set macros. Accesses are double words using an
  * indirect addressing scheme.
+ *
+ * FIXME: convert to readb() and let compiler check types etc.
  */
 
 #define	VIOAPIC_REG_GET(base, offset)		\
@@ -69,524 +63,353 @@
 /* data structures */
 
 /* IO APIC ID register */
-typedef union {
-    struct {
-	uint32_t reserved1:24;	/* reserved bits */
-	uint32_t IOAPIC_id:4;	/* apic id */
-	uint32_t reserved2:4;	/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t reserved1:24;	/* reserved bits */
+		uint32_t IOAPIC_id:4;	/* apic id */
+		uint32_t reserved2:4;	/* reserved bits */
+	} field;
+	uint32_t value;
 } VIOAPIC_ID;
 
-
 /* IO APIC Version Register */
-
-typedef union {
-    struct {
-	uint32_t version:8;		/* version identifier */
-	uint32_t reserved1:8;		/* reserved bits */
-	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
-					 * number of IRQ pins - 1 */
-	uint32_t reserved2:8;		/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t version:8;		/* version identifier */
+		uint32_t reserved1:8;		/* reserved bits */
+		uint32_t maxRedirEntry:8;	/* max number of entries - 1,
+						 * or number of IRQ pins - 1 */
+		uint32_t reserved2:8;		/* reserved bits */
+	} field;
+	uint32_t value;
 } VIOAPIC_VERSION;
 
 /* Virtual IO APIC redirection table entry. Split into high/low 32 */
+typedef union
+{
+	struct
+	{
+		uint32_t reserved:24;	/* reserved bits */
+		uint32_t destination:8;	/* destination field */
+	} field;
 
-typedef union {
-    struct {
-	uint32_t reserved:24;	/* reserved bits */
-	uint32_t destination:8;	/* destination field */
-    } field;
-
-    uint32_t value;
+	uint32_t value;
 } VIOAPIC_REDIR_HIGH;
 
-typedef union {
-    struct {
-	uint32_t vector:8;	/* vector number */
-	uint32_t deliveryMode:3;/* delivery mode:
-				 * fixed, lowest, SMI, reserved, NMI, 
-				 * INIT, reserved, extInt */
-	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
-	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
-	uint32_t polarity:1;	/* polarity: 0=high active */
-	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
-				 * accepts level, 0 after EOI */
-	uint32_t trigger:1;	/* 0=edge, 1=level */
-	uint32_t mask:1;	/* 1=masked */
-	uint32_t reserved:15;	/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t vector:8;	/* vector number */
+		uint32_t deliveryMode:3;/* delivery mode:
+					 * fixed, lowest, SMI, reserved, NMI,
+					 * INIT, reserved, extInt */
+		uint32_t destMode:1;	/* dest mode: 0=physical, 1=logical */
+		uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+		uint32_t polarity:1;	/* polarity: 0=high active */
+		uint32_t irr:1;		/* remote IRR (level only): 1 before
+				 	 * LAPIC accepts level, 0 after EOI */
+		uint32_t trigger:1;	/* 0=edge, 1=level */
+		uint32_t mask:1;	/* 1=masked */
+		uint32_t reserved:15;	/* reserved bits */
+	} field;
+	uint32_t value;
 } VIOAPIC_REDIR_LOW;
 
 typedef struct vioapicEntry
-    {
-    VIOAPIC_REDIR_LOW   vioapicLow;
-    VIOAPIC_REDIR_HIGH  vioapicHigh;
-
-    } VIOAPIC_ENTRY;
+{
+	VIOAPIC_REDIR_LOW vioapicLow;
+	VIOAPIC_REDIR_HIGH vioapicHigh;
+} VIOAPIC_ENTRY;
 
 typedef struct vioapic
-    {
-    VIOAPIC_ID      id;
-    VIOAPIC_VERSION version;
-    uint32_t        arb;
-    uint32_t        boot;
-    uint32_t        reserved[6];
-    VIOAPIC_ENTRY   entry [128];
-    } VIOAPIC;
-
-/* forward declarations */
+{
+	VIOAPIC_ID id;
+	VIOAPIC_VERSION version;
+	uint32_t arb;
+	uint32_t boot;
+	uint32_t reserved[6];
+	VIOAPIC_ENTRY entry [128];
+} VIOAPIC;
 
-/*******************************************************************************
- *
+/*
  * vbiVioapicAddrGet - Get VIOAPIC base address
  *
  * This routine gets the base address of the VIOAPIC specified in the VB
  * control structure.
- * 
+ *
  * RETURNS: the base address of the VB VIOAPIC base address
  *
- * \NOMANUAL
  */
+void *vbiVioapicAddrGet(void)
+{
+	return VBI_VIOAPIC_BASE_GET();
+}
+
+/*
+ * vbiVioapicVectorSet - Set a vector for the specified irq entry
+ *
+ * This routine sets a vector for the specified entry in the VIOAPIC
+ * redirection table. The previous entry in the table is trashed. Before
+ * setting the new vector in the entry the user can obtain the previous
+ * entry by calling vbiVioapicVectorGet(). The first argument passed to
+ * this function represent the index to the VIOAPIC redirection table. The
+ * second argument is the vector to set in the specified entry.  For Intel
+ * architectures when an interrupt is raised the vector determines the
+ * Interrupt descriptor table (IDT) entry where the IRQ is delivered.
+ *
+ * This routine is currently not supported for PPC.
+ *
+ */
+vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
 
-void * vbiVioapicAddrGet(void)
-    {
-    return(VBI_VIOAPIC_BASE_GET());
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicVectorSet - Set a vector for the specified irq entry
-*
-* This routine sets a vector for the specified entry in the VIOAPIC redirection
-* table. The previous entry in the table is trashed. Before setting the new
-* vector in the entry the user can obtain the previous entry by calling 
-* vbiVioapicVectorGet(). The first argument passed to this function represent
-* the index to the VIOAPIC redirection table. The second argument is the vector
-* to set in the specified entry. 
-* For Intel architectures when an interrupt is raised the vector determines the
-* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
-*
-* This routine is currently not supported for PPC.  
-*
-* SYNOPSIS
-*
-* 
-*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-vbiStatus_t vbiVioapicVectorSet
-    (
-    vbiIrq_t	irq,	/* descriptor table index */
-    vbiVector_t vector	/* the vector to set in the entry */
-    )
-    {
-    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq	*/
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
-    VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase, 
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
+	VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase,
 		 &(pVioapic->entry[irq].value));
 
-    /* Set the vector at the vioapic entry */
-
-    pVioapic->entry[irq].vioapicLow.field.vector = vector;
-
-    return (OK);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicVectorGet - Get a vector in the specified irq entry
-*
-* This routine gets a vector for the specified entry in the VIOAPIC table in
-* VIOAPIC redirection table. It may be used for saving the previous entry
-* before setting a new vector in the specified entry. This takes as an argument
-* the irq number that corresponds to the redirection table offset. 
-*
-* This routine is currently not supported for PPC 
-* 
-* SYNOPSIS
-*
-* 
-* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: vector number or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-vbiVector_t vbiVioapicVectorGet
-    (
-    vbiIrq_t	irq	/* descriptor table index */
-    )
-    {
-    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-    vbiVector_t		vector;
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq	*/
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorGet: base @ 0x%x\n", vioapicBase);
-
-    /* Set the vector at the vioapic entry */
-
-    vector = pVioapic->entry[irq].vioapicLow.field.vector;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
-
-    return (vector);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
-*
-* This routine enables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC redirection table. This routine makes a hypercall in order to
-* deliver pending interrupts that might be queued while the irq was masked.
-* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
-* masked. Then clears the mask bit in the VIOAPIC redirection table for the
-* specified IRQ directed to the calling virtual Core.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntUnmask 
-    (
-    vbiIrq_t irq
-    )
-    {
-    volatile VIOAPIC *   pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq number  */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    /* enable interrupt on VB */
-
-    return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
-    
-    }
-
-#ifdef CONFIG_WRHV
+	pVioapic->entry[irq].vioapicLow.field.vector = vector;
+
+	return 0;
+
+}
+
+/*
+ * vbiVioapicVectorGet - Get a vector in the specified irq entry
+ *
+ * This routine gets a vector for the specified entry in the VIOAPIC table in
+ * VIOAPIC redirection table. It may be used for saving the previous entry
+ * before setting a new vector in the specified entry. This takes as an argument
+ * the irq number that corresponds to the redirection table offset.
+ *
+ * This routine is currently not supported for PPC
+ *
+ * RETURNS: vector number or error number in case of failure
+ *
+ */
+vbiVector_t vbiVioapicVectorGet(vbiIrq_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+	vbiVector_t vector;
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	VB_DEBUG_MSG("vbiVioapicVectorGet: base @ 0x%x\n", vioapicBase);
+
+	vector = pVioapic->entry[irq].vioapicLow.field.vector;
+
+	VB_DEBUG_MSG("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
+
+	return vector ;
+
+}
+
+/*
+ * vbiVioapicIntUnmask - Unmask an irq for a virtual board
+ *
+ * This routine enables the interrupt vector that matches the specified IRQ at
+ * the VIOAPIC redirection table. This routine makes a hypercall in order to
+ * deliver pending interrupts that might be queued while the irq was masked.
+ * Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+ * masked. Then clears the mask bit in the VIOAPIC redirection table for the
+ * specified IRQ directed to the calling virtual Core.
+ *
+ */
+vbiStatus_t vbiVioapicIntUnmask(vbiIrq_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+	DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
+	
+}
 EXPORT_SYMBOL(vbiVioapicIntUnmask);
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiVioapicIntMask - Mask an irq 
-*
-* This routine disables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
-* VIOAPIC redirection table is set to 1. After calling this function hypervisor
-* will deliver this IRQ only if this IRQ is enabled by calling
-* vbiVioapicIntUnmask(). 
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntMask
-    (
-    vbiIrq_t irq
-    )
-    {
-    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* check argument */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return ERROR;
-
-    /* set the mask bit */
-
-    pVioapic->entry[irq].vioapicLow.field.mask = 1;
-
-    return (OK);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntAck - Acknowledge an irq 
-*
-* This routine acknowledges the specified IRQ for the running core. Calling 
-* this routine causes Hypervisor to purge any pending interrupt that arrived
-* while the acknowledgement was pending. When a virual board receives an interrupt
-* it must call this function. Otherwise Hypervisor will block subsequent interrupt
-* for the same IRQ. Exceptions are not required to be acknowledged.
-*
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntAck
-    (
-    vbiIrq_t    irq   /* table entry to modify (0-23) */
-    )
-    {
-    /* check argument */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntSend - Send an interrupt
-*
-* This routine makes a hypercall to trigger an IRQ to one or more virtual board
-* that are connected to the line. The first argument passed to this function
-* specifies the IRQ number. The second argument specifies the filter to apply
-* to the list of virtual  boards connected to the IRQ. The third argument is
-* applicable only when VIOAPIC_SEND_UNICAST filter is specified.
-*
-* In a SMP system a virtual board may have more than one core. If an IRQ is
-* sent to such system hypervisor will deliver the interrupt to the core that
-* was configured to receive the IRQ. The configuration is provided in the board
-* XML configuration file as the example shown below. 
-*
-*
-*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*
-*
-* The Vector number is not required to be specified in the XML. If not specified
-* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
-* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
-* 
-* The possible values for the filter (second argument) may be:
-*
-*
-*
-* VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
-*                         IRQ include the sender board.
-*
-* VIOAPIC_SEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
-*                         excluding the sender board
-*
-* VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
-*		          will be delivered only if the destination board is
-*                         connected to this IRQ 
-*			  
-*
-* VIOAPIC_SEND_NONE	- Ignore this call.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntSend 
-*             (
-*             vbiIrq_t irq, 
-*             uint32_t filter,
-*             vbiVb_t target 
-*             )
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
-*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
-*
-* INTERNAL
-* Important!! ignore filter and target arguments for now.
-*/
-
-vbiStatus_t vbiVioapicIntSend
-    (
-    vbiIrq_t    irq,		/* irq number			*/
-    uint32_t	filter,		/* destination filter		*/
-    vbiVb_t	target		/* vb id if filter is unicast	*/
-    )
-    {
-    return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
-    }
-
-#ifdef CONFIG_WRHV
+
+/*
+ * vbiVioapicIntMask - Mask an irq
+ *
+ * This routine disables the interrupt vector that matches the specified IRQ at
+ * the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+ * VIOAPIC redirection table is set to 1. After calling this function hypervisor
+ * will deliver this IRQ only if this IRQ is enabled by calling
+ * vbiVioapicIntUnmask().
+ *
+ */
+vbiStatus_t vbiVioapicIntMask(vbiIrq_t irq)
+{
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+	if (pVioapic == NULL)
+		return VBI_VIOAPIC_NULL;
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return -1;
+
+	pVioapic->entry[irq].vioapicLow.field.mask = 1;
+
+	return 0;
+
+}
+
+/*
+ * vbiVioapicIntAck - Acknowledge an irq
+ *
+ * This routine acknowledges the specified IRQ for the running core.
+ * Calling this routine causes Hypervisor to purge any pending interrupt
+ * that arrived while the acknowledgement was pending. When a virual board
+ * receives an interrupt it must call this function. Otherwise Hypervisor
+ * will block subsequent interrupt for the same IRQ. Exceptions are not
+ * required to be acknowledged.
+ *
+ */
+vbiStatus_t vbiVioapicIntAck(vbiIrq_t irq)
+{
+
+	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+		return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+	return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
+}
+
+/*
+ * vbiVioapicIntSend - Send an interrupt
+ *
+ * This routine makes a hypercall to trigger an IRQ to one or more virtual
+ * board that are connected to the line. The first argument passed to this
+ * function specifies the IRQ number. The second argument specifies the
+ * filter to apply to the list of virtual  boards connected to the IRQ.
+ * The third argument is applicable only when VIOAPIC_SEND_UNICAST filter
+ * is specified.
+ *
+ * In a SMP system a virtual board may have more than one core. If an IRQ
+ * is sent to such system hypervisor will deliver the interrupt to the
+ * core that was configured to receive the IRQ. The configuration is
+ * provided in the board XML configuration file as the example shown
+ * below.
+ *
+ *  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.
+ *
+ * The Vector number is not required to be specified in the XML. If not
+ * specified the VB manager assignes a vector to an IRQ. The Guest OS can
+ * obtain the vector number assigned to an IRQ by calling
+ * vbiIntVecFind("VECTOR_NAME").
+ *
+ * The possible values for the filter (second argument) may be:
+ *
+ *
+ *
+ * VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
+ *                        IRQ include the sender board.
+ *
+ * VIOAPIC_SEND_OTHERS  - Send to the group of virtual boards connected
+ *			  to this IRQ excluding the sender board
+ *
+ * VIOAPIC_SEND_UNICAST	- Send an interrupt to specified virtual board. This
+ *		          will be delivered only if the destination board is
+ *                        connected to this IRQ
+ *
+ * VIOAPIC_SEND_NONE	- Ignore this call.
+ *
+ *
+ * INTERNAL
+ * Important!! ignore filter and target arguments for now.
+ *
+ */
+vbiStatus_t vbiVioapicIntSend(vbiIrq_t irq, uint32_t filter, vbiVb_t target)
+{
+	return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
+}
 EXPORT_SYMBOL(vbiVioapicIntSend);
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiVioapicIntRedirect - Redirect an irq to another core
-*
-* This routine makes a hypercall to redirect an irq from one core to another
-* within the same virtual board. 
-* 
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntRedirect 
-    (
-    vbiIrq_t    irq,		/* irq number			*/
-    vbiCore_t	core		/* vb id if filter is unicast	*/
-    )
-    {
-
-    /* call interrupt redirect operator */
-
-    return (vbiVcoreIntRed_op(irq, core));
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicDisplay - display the virtual I/O APIC table
-*
-* \NOMANUAL
-*/
-
-void vbiVioapicDisplay (void)
+
+/*
+ * vbiVioapicIntRedirect - Redirect an irq to another core
+ *
+ * This routine makes a hypercall to redirect an irq from one core to another
+ * within the same virtual board.
+ *
+ */
+vbiStatus_t vbiVioapicIntRedirect( vbiIrq_t irq, vbiCore_t core)
+{
+	/* call interrupt redirect operator */
+	return vbiVcoreIntRed_op(irq, core);
+}
+
+/*
+ * vbiVioapicDisplay - display the virtual I/O APIC table
+ */
+void vbiVioapicDisplay(void)
 {
-    VIOAPIC_REDIR_LOW	regIoApicRedirLow;
-    VIOAPIC_REDIR_HIGH	regIoApicRedirHigh;
-    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-    uint32_t i;
-
-    static const char * deliveryModes[] = 
-        {" Fixed",	/* 0 */
-	 "Lowest",	/* 1 */
-	 "   SMI",	/* 2 */
-	 "  rsvd",	/* 3 */
-	 "   NMI",	/* 4 */
-	 "  INIT",	/* 5 */
-	 "  rsvd",	/* 6 */
-	 "ExtINT"};	/* 7 */
-
-    /* get the general virtual I/O APIC info */
-
-    VB_PRINTF ("Virtual I/O APIC:\n");
-    VB_PRINTF ("  Base address: 0x%p\n", pVioapic);
-    VB_PRINTF ("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
-    VB_PRINTF ("  version:     %d\n", pVioapic->version.field.version);
-    VB_PRINTF ("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
-
-    /* dump the virtual I/O APIC table */
-
-    VB_PRINTF ("\nRedirection Table:\n");
-    VB_PRINTF ("Entry Vector Mask Status Trig"
+	VIOAPIC_REDIR_LOW regIoApicRedirLow;
+	VIOAPIC_REDIR_HIGH regIoApicRedirHigh;
+	volatile VIOAPIC *pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+	uint32_t i;
+
+	static const char *deliveryModes[] =
+	{
+		" Fixed",	/* 0 */
+		"Lowest",	/* 1 */
+		"   SMI",	/* 2 */
+		"  rsvd",	/* 3 */
+		"   NMI",	/* 4 */
+		"  INIT",	/* 5 */
+		"  rsvd",	/* 6 */
+		"ExtINT"	/* 7 */
+	};
+
+	/* get the general virtual I/O APIC info */
+
+	VB_PRINTF("Virtual I/O APIC:\n");
+	VB_PRINTF("  Base address: 0x%p\n", pVioapic);
+	VB_PRINTF("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
+	VB_PRINTF("  version:     %d\n", pVioapic->version.field.version);
+	VB_PRINTF("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
+
+	/* dump the virtual I/O APIC table */
+
+	VB_PRINTF("\nRedirection Table:\n");
+	VB_PRINTF("Entry Vector Mask Status Trig"
 		"  Pol IRR DeliverMode Destination\n");
-    VB_PRINTF (
+	VB_PRINTF(
 	"----- ------ ---- ------ ----- --- --- ----------- -----------\n");
 
-    for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
+	for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
 
 	regIoApicRedirLow  = pVioapic->entry[i].vioapicLow;
 	regIoApicRedirHigh = pVioapic->entry[i].vioapicHigh;
 
-	VB_PRINTF (" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
-                i,
-                regIoApicRedirLow.field.vector,
-                regIoApicRedirLow.field.mask ? "MASK" : "none",
-                regIoApicRedirLow.field.delivStatus ? "PEND" : "idle",
-                regIoApicRedirLow.field.trigger ? "level" : "edge",
-                regIoApicRedirLow.field.polarity ? "lo" : "hi",
-                regIoApicRedirLow.field.irr,
-                deliveryModes[regIoApicRedirLow.field.deliveryMode],
-                regIoApicRedirLow.field.destMode ? "Set: " : "ID: ",
-                regIoApicRedirHigh.field.destination);
-    }
-    VB_PRINTF ("\n");
+	VB_PRINTF(" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
+			i,
+			regIoApicRedirLow.field.vector,
+			regIoApicRedirLow.field.mask ? "MASK" : "none",
+			regIoApicRedirLow.field.delivStatus ? "PEND" : "idle",
+			regIoApicRedirLow.field.trigger ? "level" : "edge",
+			regIoApicRedirLow.field.polarity ? "lo" : "hi",
+			regIoApicRedirLow.field.irr,
+			deliveryModes[regIoApicRedirLow.field.deliveryMode],
+			regIoApicRedirLow.field.destMode ? "Set: " : "ID: ",
+			regIoApicRedirHigh.field.destination);
+	}
+	VB_PRINTF ("\n");
 }
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index 770b6f1..301324b 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -16,27 +16,25 @@
 
 /*
 
-DESCRIPTION
-The vbi library (Virtual board interface) provides support functionality for
-software developers who are writing Virtual board applications, or as a guide to
-developers porting an operating system to the virtual board environment.
-This file contains the generic API that architecture independent. Separate
-documents are provided as supplement for APIs tied to a particular hardware
-architecture platform. 
-
-A given system may be composed of multiple VB where each VB may contain multiple
-Cores. During system bring-up stage hypervisor VB manager allocates resources
-specified in the XML configuration file for the each VB and initializes the
-configuration structure. Then the cores are launched starting at the entry point
-specified in the guest payload image. Hypervisor passes a pointer of the
-configuration page and a 32bit flag that holds the boot options of the core.
-These parameters are passed via stack or registers based on the underlying
-architecture platform.
+DESCRIPTION The vbi library (Virtual board interface) provides support
+functionality for software developers who are writing Virtual board
+applications, or as a guide to developers porting an operating system to
+the virtual board environment.  This file contains the generic API that
+architecture independent. Separate documents are provided as supplement
+for APIs tied to a particular hardware architecture platform.
+
+A given system may be composed of multiple VB where each VB may contain
+multiple Cores. During system bring-up stage hypervisor VB manager
+allocates resources specified in the XML configuration file for the each
+VB and initializes the configuration structure. Then the cores are
+launched starting at the entry point specified in the guest payload image.
+Hypervisor passes a pointer of the configuration page and a 32bit flag
+that holds the boot options of the core.  These parameters are passed via
+stack or registers based on the underlying architecture platform.
 
 
 figure 1.1: A simplified overview diagram of a hypervisor system.
 
-\cs
                            ________Hypercalls___||_______
        Virtual board 0    |                     ||       |
      _____________________V___                  ||       |
@@ -63,108 +61,73 @@ figure 1.1: A simplified overview diagram of a hypervisor system.
                                                 ||
 
                                                 ^
-                                                |   
+                                                |
                                              guest/hypervisor
                                               speration line
 
-\ce
-
-
-
-
-Once the guest starts running it must call vbiInit() with the save parameters
-passed to it's entry routine which is the base address of the configuration.
-page. This routine retrieves the control and status page page pointers and
-saves them in the corresponding global variables.
+Once the guest starts running it must call vbiInit() with the save
+parameters passed to it's entry routine which is the base address of the
+configuration.  page. This routine retrieves the control and status page
+page pointers and saves them in the corresponding global variables.
 
-If the VMMU is turned on care must be taken to ensure that the memory regions
-below are mapped via the VMMU. It is suggested to treat these regions as
-devices regions where the mapping is flat and the cache attribute is guarded.
+If the VMMU is turned on care must be taken to ensure that the memory
+regions below are mapped via the VMMU. It is suggested to treat these
+regions as devices regions where the mapping is flat and the cache
+attribute is guarded.
 
 A virtual board core is presented by hypervisor with 3 memory areas:
 
-\ml
-\m 1.
-Virtual Board Configuration Area
+1) Virtual Board Configuration Area
 
-This write protected memory area provides fixed configuration information to
-the virtual board.  The address of this is kept in the global variable
-wrhvConfig.  The address of this area is passed to the virtual board as the
-first parameter when the virtual board is started running at it's boot location.
+This write protected memory area provides fixed configuration information
+to the virtual board.  The address of this is kept in the global variable
+wrhvConfig.  The address of this area is passed to the virtual board as
+the first parameter when the virtual board is started running at it's boot
+location.
 
-\m 2.
-Virtual Board Status Area
+2)Virtual Board Status Area
 
-This write protected memory area provides data to the virtual board that 
-changes due to run-time activity, such as registers saved due to an 
+This write protected memory area provides data to the virtual board that
+changes due to run-time activity, such as registers saved due to an
 interrupt, timestamps, virtual interrupts etc.  The address of this is
 kept in the global variable wrhvStatus.
 
-\m 3.
-Virtual Board Control Area
-
-This writable memory area is used by the virtual board to communicate 
-information to the hypervisor, where they cannot be passed in a faster manner.
-The address of this area is kept in the global variable wrhvControl.
-
-\me
-
-GLOBAL VARIABLES
-
-\cs
-VB_CONFIG *  wrhvVbConfig; /@ The address of the cores Configuration area
-                            * This value is passed to the core as the first 
-                            * parameter upon startup
-                            @/
+3)Virtual Board Control Area
 
-VB_CONTROL * wrhvVbControl;/@ The address of the core's Control area @/
+This writable memory area is used by the virtual board to communicate
+information to the hypervisor, where they cannot be passed in a faster
+manner.  The address of this area is kept in the global variable
+wrhvControl.
 
-VB_STATUS *  wrhvVbStatus;  /@ The address of the core's Status area @/
-
-
-\ce
-
-INCLUDE FILES:  include/vbi/vbi.h
-
-\APPEND  vbiInterrupt.c
-\APPEND  vbiShmem.c
-\APPEND  vbiIdle.c
-\APPEND  vbiPaddr.c
-\APPEND  vbiShow.c
-\APPEND  vbiNs.c
-\APPEND  vbiMsg.c
-\APPEND  ../include/interface.h
 */
 
 #include <linux/types.h>
 #include <linux/module.h>
 #include <vbi/vbi.h>
 
-VB_CONFIG *  wrhvVbConfig;  /* The address of the core's Config area
+VB_CONFIG *wrhvVbConfig;  /* The address of the core's Config area
                             * This value is passed to the virtual board
                             * as the first parameter upon startup
                             */
+EXPORT_SYMBOL(wrhvVbConfig);
 
-VB_CONTROL * wrhvVbControl; /* The address of the core's Control area */
+VB_CONTROL *wrhvVbControl; /* The address of the core's Control area */
 
-VB_STATUS *  wrhvVbStatus;  /* The address of the core's Status area */
+VB_STATUS *wrhvVbStatus;  /* The address of the core's Status area */
 
-int32_t       wrhvVbIntNested; /* Used by VBI interrupt/exception management */
+int32_t wrhvVbIntNested; /* Used by VBI interrupt/exception management */
 
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(wrhvVbConfig);
-#endif /* CONFIG_WRHV */
 
-/*******************************************************************************
+/*
 * vbiInit - Initialize support for vbi library functions
 *
-* This routine initializes the vbi library 
+* This routine initializes the vbi library
 *
 * The routine should be called before accessing the virtual board configuration
 * data or making any hypercall. The parameters passed to this function should be
 * same as the boot parameters passed to the first executing program in the
 * running core by hypervisor which is a pointer to the core configuration
-* address. This routine retrieves the status and control page from the 
+* address. This routine retrieves the status and control page from the
 * configuration page and initializes the following global variables for future
 * reference.
 *
@@ -174,679 +137,28 @@ EXPORT_SYMBOL(wrhvVbConfig);
 *
 * The user must ensure that this memory regions are mapped if the MMU is
 * turn-on.
-* A good practice would be to map these regions as devices meaning 1-1 
+* A good practice would be to map these regions as devices meaning 1-1
 * translation.
-*\me
-*
-* SYNOPSIS
-*
-*
-* void vbiInit
-*    (
-*    VB_CONFIG	*config		/@ Address of the VB config area    @/
-*    )
-*
-*
-* RETURNS: N/A
-*
-*
 *
 */
 
-void vbiInit
-    (
-    VB_CONFIG *	config   /* Address of the VB config area */
-    )
-    {
+void vbiInit(VB_CONFIG *config)
+{
 
-    /* 
+    /*
      * validate the vbi version; minor and maintenance should be backward
      * compatible.
      */
 
     if (config->major < vbiVersionMajor )
-	{ 
+	{
 	vbiPanic("Invalid vbi version");
 	}	
-    
+
     /* Init global variables for config, status and control structures */
 
     wrhvVbConfig    = config;
     wrhvVbControl   = wrhvVbConfig->vbControl;
     wrhvVbStatus    = wrhvVbConfig->vbStatus;
-   
-    }
-
-/*******************************************************************************
-*
-* vbiVbSuspend - Suspend a virtual board's core
-*
-* This routine makes a hypercall in order to suspend one or more cores that
-* exist within the specified virtual board. The target core(s) enter HALT state
-* until vbiVbResume() is called change the state of the core(s). This function
-* will return only after all victim cores are suspended unless the opration
-* fails to complete. The second argument passed to this function specifies one
-* or more target cores. For suspending every core within the specified VB the
-* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
-* requesting the suspension may also be included in the list to be suspended.
-* To suspend everyone but the recipient then the second argument passed to this
-* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
-* should be a valid core number within the VB. This hypercall sends a message
-* to a given hypervisor manager that provides virtual board managment service. 
-*
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVbSuspend
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbReset(), vbiVbRestart()
-*/
-
-/*******************************************************************************
-*
-* vbiVbReset - Reset a virtual board's core
-*
-* This routine makes a hypercall in order to reset one or more cores that exist
-* within the specified virtual board. Calling this function puts the target core(s)
-* program counter to it's ENTRY function. The ENTRY function is determined based on
-* the loaded binary image. A core does not execute beyond it's ENTRY function
-* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
-* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
-* the third argument to this routine.  
-* The hypercall sends a message to a manager that provides VB managment services.
-* This function will return only after all victim cores are reset unless the
-* operation fails to complete. The order of which the victim cores are reset is not
-* determined. The second argument identifies the cores to perform the operation on.
-* The value of the second argument should be set to one of the following:
-*
-*
-*
-* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*
-* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*
-* A valid core number: Reset the specified core that exist within the Virtual Board.
-*\me
-*
-* The third argument argument passed to this function specifies options that are
-* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
-* one of the following or a combination:
-*
-*
-*
-* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images	
-*
-* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
-*\me
-*
-*
-* IMPORTANT:
-* If a user chooses to restart core without reloading the executable image then
-* the data section must be restored to prevent critical errors. It is the guest OS's
-* responsibility to clear the bss data sections in such scenario.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbReset
-*    (
-*    vbiVb_t      id,	    /@ Id of the VB to suspend	    @/
-*    vbiCore_t     core,	    /@ Core within the VB	    @/
-*    uint32_t     options   /@ reload , start options	    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
-*/
-
-/*******************************************************************************
-*
-* vbiVbRestart - Restart a virtual board's core
-*
-* This routine makes a hypercall in order to restart a virtual cores from reset.
-* It's called to start running a core or cores that were previously reset by
-* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
-* function retrieved from the corresponding binary image.
-* This function will return only after  all cores are out of reset unless the
-* operation fails to complete.  The second argument represents the cores to restart. 
-* For restarting every core in reset mode within the specified VB the second
-* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
-* VB then the core number must be passed in the second argument.
-*
-* This hypercall sends a message to a manager that provides VB managment
-* services. 
-* 
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbRestart
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
-*/
-
-/*******************************************************************************
-*
-* vbiVbResume - Resume a virtual board's core
-*
-* This routine makes a hypercall in order to resume one or cores within
-* the specified virtual board. It reactivates a cores or cores that were 
-* previously suspended by calling vbiVbResume(). This function will return only
-* after all victim cores are resumed unless the operation fails. The order of
-* which the cores are resumed is not determined. The second argument may a
-* magic number instead of a valid core number to indicate that the operation
-* is intended for more than one core. For resuming every core within the
-* specified VB then the second argument is set to be equal to VBI_VB_CORES_ALL.
-* This implies to resume every core within the specified VB. Using this option
-* when some of the cores within the VB are already running is not considered
-* as programming error.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbResume
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend() 
-*/
-
-/*******************************************************************************
-*
-* vbiKputs - print a string on the hypervisor kernel console
-*
-* This routine makes a hypercall and prints a string of characters to to
-* hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiKputc() 
-*/
-
-/*******************************************************************************
-*
-* vbiKputc - print a character on the hypervisor kernel console
-*
-* This routine makes a hypercall in order to print the specified character to
-* hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiKputc (int c) /@ character to print @/
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiKputs()
-*/
-
-/*******************************************************************************
-*
-* vbiPanic - halt the system and dump debug info 
-*
-* This routine makes a hypercall in order to halt the system and display debug
-* information on hypervisor console. If hypervisor is configured with
-* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
-* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
-* the offending cores registers dump is displayed on hypervisor console. If
-* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
-* the debug manager.
-*
-*
-* SYNOPSIS
-*
-* 
-* void vbiPanic (const char *msg) /@ pointer to message to print @/
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*/
-
-/*******************************************************************************
-*
-* vbiDebugShellStart - start the hypervisor debug shell
-*
-* This routine sends a message to the hypervisor debug shell manager in order to
-* start the WRHV shell program. The shell program spins therefore does not share
-* the processor with any other WRHV context. By default a caller of this routine 
-* is detached to allow the caling core to continue executing (as long as the are not
-* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
-* specified to force the caller virtual board core to block while the shell program
-* is running. 
-*
-* SYNOPSIS
-*
-*
-* void vbiDebugShellStart 
-*          (
-*          uint32_t  flags /@ detach by default @/
-*          ) 
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*/
-
-/*******************************************************************************
-*
-* vbiVbMemoryRead - Read a virtual board's memory
-*
-* This routine makes a hypercall to read a remote board's memory. The memory control
-* structure contains information about the target memory to read and the destination
-* buffer that hypervisor must populate with the data read. This routine is used
-* to copy data from a remote VB. It is the user's responsability to ensure that
-* the memory read is accessed orthogonally.
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-*
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	    @/
-*   void	*pAddress;	    /@ address of calling context	    @/
-*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
-*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
-*   uint32_t	reserved;	    /@ reserved for future use		    @/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryRead 
-*	(
-*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
-*	vbiVb_t	    targetBoard	    /@ target board				@/
-*	)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
 
-/*******************************************************************************
-*
-* vbiVbMemoryWrite - copy data to a remote board's memory
-*
-* This routine makes a hypercall to copy to a remote board memory. If the
-* VBI_DCACHE_FLUSH is set in the control memory control structure then this
-* routine flushes the data caches lines corresponding to the range of memory
-* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
-* cache lines corresponding to the range of address is invalidated after the
-* memory is copied. Invalidating the instruction is required if data containing
-* is updated since the instruction cache is not aware of the content in data
-* cache. Therefore flushing the data cache ensures that memory contains the
-* updated data and invalidating the instruction cache ensures that the stale
-* values in the instruction cache is thrown away. 
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-* 
-* 
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	@/
-*   void	*pAddress;	    /@ address of calling context	@/
-*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
-*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
-*   uint32_t	flags;		    /@ data/instruction flush option	@/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryWrite 
-*	(
-*	VBI_MEM_CTL	*memCtl, 
-*	vbiVb_t		targetBoard 
-*	)
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
-/*******************************************************************************
-*
-* vbiMemAttrSet - Set protection for a page of memory
-*
-* This routine makes a hypercall to set the MMU attribures for the specified
-* memory range. The possible attributes one or a combinarion of the following:
-* 
-* VBI_MMU_PROT_READ -  allow supervisor and user read
-* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
-* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrSet 
-*		(
-*		void	 *gaddr,	/@ Address of page to change attr   @/
-*		size_t   length,	/@ length of address		    @/
-*		uint32_t attr		/@ mmu attributes to set	    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-/******************************************************************************
-*
-* vbiMemAttrGet - Get MMU page protections
-*
-* This routine makes a hypercall to retrieve the MMU attributes associated for
-* the page where the specified address is mapped. This is not the VMMU
-* attributes. A guest OS has direct access to the mapping table of its VMMU
-* therefore a hypercall is not necessary.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrGet 
-*		(
-*		void	 *gaddr		/@ Address of page to change attr   @/
-*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicVectorSet - Set a vector for the specified irq entry
-*
-* This routine sets a vector for the specified entry in the VIOAPIC redirection
-* table. The previous entry in the table is trashed. Before setting the new
-* vector in the entry the user can obtain the previous entry by calling 
-* vbiVioapicVectorGet(). The first argument passed to this function represent
-* the index to the VIOAPIC redirection table. The second argument is the vector
-* to set in the specified entry. 
-* For Intel architectures when an interrupt is raised the vector determines the
-* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
-*
-* This routine is currently not supported for PPC.  
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*
-* 
-*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
-*
-*vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicVectorGet - Get a vector in the specified irq entry
-*
-* This routine gets a vector for the specified entry in the VIOAPIC table in
-* VIOAPIC redirection table. It may be used for saving the previous entry
-* before setting a new vector in the specified entry. This takes as an argument
-* the irq number that corresponds to the redirection table offset. 
-*
-* This routine is currently not supported for PPC 
-* This routine is currently not supported for MIPS.  
-* 
-* SYNOPSIS
-*
-* 
-* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: vector number or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntMask - Mask an irq 
-*
-* This routine disables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
-* VIOAPIC redirection table is set to 1. After calling this function hypervisor
-* will deliver this IRQ only if this IRQ is enabled by calling
-* vbiVioapicIntUnmask(). 
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
-*
-* This routine enables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC redirection table. This routine makes a hypercall in order to
-* deliver pending interrupts that might be queued while the irq was masked.
-* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
-* masked. Then clears the mask bit in the VIOAPIC redirection table for the
-* specified IRQ directed to the calling virtual Core.
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntSend - Send an interrupt
-*
-* This routine makes a hypercall to trigger an IRQ to one or more virtual board
-* that are connected to the line. The first argument passed to this function
-* specifies the IRQ number. The second argument specifies the filter to apply
-* to the list of virtual  boards connected to the IRQ. The third argument is
-* applicable only when VBI_IOAPICSEND_UNICAST filter is specified.
-*
-* In a SMP system a virtual board may have more than one core. If an IRQ is
-* sent to such system hypervisor will deliver the interrupt to the core that
-* was configured to receive the IRQ. The configuration is provided in the board
-* XML configuration file as the example shown below. 
-*
-*
-*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*
-*
-* The Vector number is not required to be specified in the XML. If not specified
-* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
-* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
-* 
-* The possible values for the filter (second argument) may be:
-*
-*
-*
-* VBI_IOAPICSEND_ALL	- Send to the group of virtual boards connected to this
-*                         IRQ include the sender board.
-*
-* VBI_IOAPICSEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
-*                         excluding the sender board
-*
-* VBI_IOAPICSEND_UNICAST	- Send an interrupt to the specified virtual board. This
-*		          will be delivered only if the destination board is
-*                         connected to this IRQ 
-*			  
-*
-* VBI_IOAPICSEND_NONE	- Ignore this call.
-*
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVioapicIntSend 
-*             (
-*             vbiIrq_t irq, 
-*             uint32_t filter,
-*             vbiVb_t target 
-*             )
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
-*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntAck - Acknowledge an irq 
-*
-* This routine acknowledges the specified IRQ for the running core. Calling 
-* this routine causes Hypervisor to purge any pending interrupt that arrived
-* while the acknowledgement was pending. When a virual board receives an interrupt
-* it must call this function. Otherwise Hypervisor will block subsequent interrupt
-* for the same IRQ. Exceptions are not required to be acknowledged.
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntRedirect - Redirect an irq to another core
-*
-* This routine makes a hypercall to redirect an irq from one core to another
-* within the same virtual board. 
-*
-* This routine is currently not supported for MIPS.   
-*
-* SYNOPSIS
-*
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
+}
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
index 70da875..3703607 100644
--- a/kernel/vbi/msg.c
+++ b/kernel/vbi/msg.c
@@ -17,123 +17,40 @@
 #include <linux/types.h>
 #include <vbi/private.h>
 
-#define DEBUGM(fmt, args...) 
+#define DEBUGM(fmt, args...)
 #define _DEBUGM(fmt, args...) printk(fmt, ##args)
 
-/*******************************************************************************
-*
-* vbiReceive - Receive a message from another context
-*
-* This routine makes a hypercall and waits for a message to be received from
-* another context. It blocks until a message is received. This operation may
-* be aborted if an interrupt is delivered to the waiting Virtual board. If the
-* "flags" field in the control structure passed to this function is set to be 
-* VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
-* aborted before the expected message was received successfully.   
-*
-* SYNOPSIS
-*
-* 
-* vbiCtx_t vbiReceive
-*    (
-*    void *       smsg,  /@ pointer to message to receive  @/
-*    size_t       len,   /@ length of message to receive   @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*
-*
-* RETURNS: sender context Id or an error number in case of failure
-*	   OK - in case of success
-*	   ERROR - in case of error	    
-*
-*
-* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
-*/
+/*
+ * vbiReceive - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received
+ * from another context. It blocks until a message is received. This
+ * operation may be aborted if an interrupt is delivered to the waiting
+ * Virtual board. If the "flags" field in the control structure passed to
+ * this function is set to be VBI_MSG_CTL_FLAG_RETRY the receive operation
+ * will be retried in case it was aborted before the expected message was
+ * received successfully.
+ *
+ */
 
-vbiStatus_t vbiReceive
-    (
-    void		*rmsg, /* pointer to message to receive  */
-    uint32_t		rlen,  /* length of message to receive   */
-    VBI_MSG_INFO	*info, /* status info structure pointer  */
-    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
-    )                                   
-    { 
-    vbiStatus_t retVal;
+vbiStatus_t vbiReceive(void *rmsg, uint32_t rlen, VBI_MSG_INFO *info,
+			VBI_MSG_CTL *ctl)
+{
+	vbiStatus_t retval;
 
-    while (1)
+	while (1)
 	{
-	retVal = vbiReceiveOp(rmsg, rlen, info, ctl);
+		retval = vbiReceiveOp(rmsg, rlen, info, ctl);
 
-        /* if retry flag set, continue */
+		/* if retry flag set, continue */
+		if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
+			break;
 
-	if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
-	    break;
-
-        /* if retry flag is set _AND_ msg was aborted, retry */
-	if (info->error != VBI_MSG_ERROR_ABORTED)
-	    break;
+		/* if retry flag is set _AND_ msg was aborted, retry */
+		if (info->error != VBI_MSG_ERROR_ABORTED)
+			break;
 	
-	DEBUGM("%s aborted, retrying \n", __FUNCTION__);
-
+		DEBUGM("%s aborted, retrying \n", __FUNCTION__);
 	}
-    return retVal;
-    }
-
-/*******************************************************************************
-*
-* vbiReply - Reply to message received from another context
-*
-* This routine makes a hypercall in order to reply to a message received from
-* another context. A message is received from remote context by calling
-* vbiReceive(). The reply will unblock the recipient which may preempt
-* the caller.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiReply
-*    (
-*    vbiCtx_t   id,    /@ context id to reply the message to @/
-*    void *       buff,  /@ pointer to reply message  @/
-*    size_t       len,   /@ length of message to reply   @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
-*/
-
-/*******************************************************************************
-*
-* vbiSend - Send a message to another context
-*
-* This routine makes a hypercall to send a message to the specified context and
-* waits for a reply.  The caller will block until the sender replies to the sent
-* message.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiSend
-*    (
-*    vbiCtx_t     id,    /@ context id to send the message to @/
-*    void *       smsg,  /@ pointer to message to send        @/
-*    size_t       slen,  /@ length of message to send         @/
-*    void *       rmsg,  /@ pointer to receive message buffer @/
-*    size_t       rlen,  /@ length of receive message         @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
-*/
+	return retval;
+}
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
index 3bf1d49..089b91e 100644
--- a/kernel/vbi/ns.c
+++ b/kernel/vbi/ns.c
@@ -33,129 +33,58 @@ for processing.
 /* enable/disable debugging */
 
 /*
- * #define DEBUG  define DEBUG to turn on debugging 
+ * #define DEBUG  define DEBUG to turn on debugging
  */
 
 #ifdef DEBUG
 #define DEBUGM(fmt, args...)    printk(fmt, ##args)
 #else
-#define DEBUGM(fmt, args...)   
+#define DEBUGM(fmt, args...)
 #endif
 
-/*******************************************************************************
-*
-* vbiNsRegister - register a service with the naming system
-*
-* This routine registers us as the provider of the specified service.
-* A message for the request is formulated and sent off to the name service
-* manager for processing.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiNsRegister 
-*    (
-*    char    *name,		/@ name of service we're registering	@/
-*    uint32_t revision		/@ version of service			@/
-*    )
-*\ce                                                                 
-* RETURNS: OK, or errno if unable to register the service
-*
-* SEE ALSO: vbiNsLookup(), vbiNsUnregister()
-*
-*/
-
-vbiStatus_t vbiNsRegister
-    (
-    char    *name,	/* name of service we're registering */
-    uint32_t revision	/* version of service */
-    )
-    {
-
-    /* sanity check */
-
-    if (name == NULL)
-	return -1;
-
-    return (vbiNsOp (VBI_NS_REGISTER, name, revision, NULL));
-    }
-
-/*******************************************************************************
-*
-* vbiNsUnegister - un-register a service with the naming system
-*
-* This routine removes us as the provider of the specified service.
-* A message for the request is formulated and sent off to the name service
-* manager for processing.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiNsUnregister 
-*    (
-*    char    *name,		/@ name of service we're unregistering	@/
-*    uint32_t revision		/@ version of service			@/
-*    )
-*\ce                                                                 
-*
-* RETURNS: OK, or errno if unable to un-register the service
-*
-* SEE ALSO: vbiNsLookup(), vbiNsRegister()
-*
-*/
-
-vbiStatus_t vbiNsUnregister
-    (
-    char    *name,	/* name of service we're un-registering */
-    uint32_t revision	/* version of service */
-    )
-    {
-
-    /* sanity check */
+/*
+ * vbiNsRegister - register a service with the naming system
+ *
+ * This routine registers us as the provider of the specified service.
+ * A message for the request is formulated and sent off to the name service
+ * manager for processing.
+ *
+ */
+vbiStatus_t vbiNsRegister(char *name, uint32_t revision)
+{
+	if (name == NULL)
+		return -1;
 
-    if (name == NULL)
-	return -1;
-    
-    return (vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL));
-    }
+	return vbiNsOp (VBI_NS_REGISTER, name, revision, NULL);
+}
 
-/*******************************************************************************
-*
-* vbiNsLookup - look up a service provider using the naming system
-*
-* This routine uses the naming system to look up the context id of the
-* provider of the specified service.  A message for the request is
-* formulated and sent off to the name service manager for processing.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiNsLookup 
-*    (
-*    char    *name,		/@ name of service we're unregistering	@/
-*    uint32_t revision		/@ version of service			@/
-*    VBI_NS_HANDLE *handle	/@ handle of service provider		@/
-*    )
-*
-* RETURNS: 
-*   ERROR is case of failure
-*
-* SEE ALSO: vbiNsRegister(), vbiNsUnregister()
-*
-*/
+/*
+ * vbiNsUnegister - un-register a service with the naming system
+ *
+ * This routine removes us as the provider of the specified service.
+ * A message for the request is formulated and sent off to the name service
+ * manager for processing.
+ *
+ */
+vbiStatus_t vbiNsUnregister(char *name, uint32_t revision)
+{
+	if (name == NULL)
+		return -1;
 
-vbiStatus_t vbiNsLookup
-    (
-    char     *name,	    /* name of service we're un-registering */
-    uint32_t  revision,	    /* version of service			*/
-    VBI_NS_HANDLE *handle   /* handle of service provider		*/
-    )
-    {
-    
-    /* sanity check */
+	return vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL);
+}
 
-    if (name == NULL || handle == NULL)
-	return -1;
+/*
+ * vbiNsLookup - look up a service provider using the naming system
+ *
+ * This routine uses the naming system to look up the context id of the
+ * provider of the specified service.  A message for the request is
+ * formulated and sent off to the name service manager for processing.
+ */
+vbiStatus_t vbiNsLookup(char *name, uint32_t revision, VBI_NS_HANDLE *handle)
+{
+	if (name == NULL || handle == NULL)
+		return -1;
 
-    return (vbiNsOp (VBI_NS_LOOKUP , name, revision, handle));
-    }
+	return  vbiNsOp (VBI_NS_LOOKUP , name, revision, handle);
+}
diff --git a/kernel/vbi/paddr.c b/kernel/vbi/paddr.c
index fe1507a..8529efe 100644
--- a/kernel/vbi/paddr.c
+++ b/kernel/vbi/paddr.c
@@ -17,9 +17,9 @@
 /*
 DESCRIPTION
 These modules provide interfaces to translate the current context's guest
-physical address into the physical machine address. vbiGuestDmaAddrGet is 
+physical address into the physical machine address. vbiGuestDmaAddrGet is
 specifically for a guest wanting an address that can be used by a DMA device.
-vbiGuestPhysToPhysAddr is used to return an absolute physical address to used 
+vbiGuestPhysToPhysAddr is used to return an absolute physical address to used
 perhaps to communicate with the hypervisor itself maybe buffer pointers.
 */
 
@@ -28,79 +28,37 @@ perhaps to communicate with the hypervisor itself maybe buffer pointers.
 #include <linux/types.h>
 #include <vbi/private.h>
 
-
-/*******************************************************************************
-*
-* vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical 
-*                          address
-*
-* This function makes a hypervisor call to translate the specified guest 
-* physical address to physical address. This may be required for quick buffer 
-* transfer that requires the physical address of a memory region. The 
-* hypervisor may be running with > 4GB memory so the phys address is always 
-* 64-bit.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiGuestPhysToPhysAddr 
-*		(
-*		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
-*		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
-*               )
-*
-*
-* RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
-* populated by the hypervisor with the required physical address (64-bit)
-*
-*
-*
-*/
-vbiStatus_t vbiGuestPhysToPhysAddr
-    (
-    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    )
-    {
-
+/*
+ * vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical
+ *                          address
+ *
+ * This function makes a hypervisor call to translate the specified guest
+ * physical address to physical address. This may be required for quick buffer
+ * transfer that requires the physical address of a memory region. The
+ * hypervisor may be running with > 4GB memory so the phys address is always
+ * 64-bit.
+ *
+ */
+vbiStatus_t vbiGuestPhysToPhysAddr(vbiGuestPhysAddr_t gaddr,
+					 vbiPhysAddr_t  *paddr)
+{
     /* use the hypervisor ioctl system call to do the translation */
+    return  vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 );
+}
 
-    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 ));
-    }
-
-/*******************************************************************************
-*
-* vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
-*
-* This function makes a hypervisor call to translate the specified guest 
-* physical address  to a physical address. This may be required for a device 
-* driver that requires the address it can use for DMA. The hypervisor may be 
-* running with > 4GB memory so the phys address is always 64-bit.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiGuestDmaAddrGet 
-*		(
-*		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
-*		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
-*               )
-*
-*
-* RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
-* populated by the hypervisor with the required physical address (64-bit)
-*
-*
-*
-*/
-vbiStatus_t vbiGuestDmaAddrGet
-    (
-    vbiGuestPhysAddr_t gaddr,	/* virtual address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    )
-    {
-
-    /* use the hypervisor ioctl system call to do the translation */
+/*
+ * vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
+ *
+ * This function makes a hypervisor call to translate the specified guest
+ * physical address  to a physical address. This may be required for a device
+ * driver that requires the address it can use for DMA. The hypervisor may be
+ * running with > 4GB memory so the phys address is always 64-bit.
+ *
+ */
+vbiStatus_t vbiGuestDmaAddrGet(vbiGuestPhysAddr_t gaddr,
+					vbiPhysAddr_t *paddr)
+{
 
-    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0));
-    }
+	/* use the hypervisor ioctl system call to do the translation */
+    	return vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0);
+}
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
index 5794234..9ea9cae 100644
--- a/kernel/vbi/shmem.c
+++ b/kernel/vbi/shmem.c
@@ -20,21 +20,18 @@ This module contains the code for retriving the memory regions assigned to
 a virtual board. The information is passed in to the virtual board via the
 configuration structure. There is a descriptor table for each type of memory.
 
-\sh MEMORY TYPES
-\ms
-\m -
+MEMORY TYPES
+
 There is a memory memory region assigned only to each board which can be
 retrieved by calling vbiMemRegionFind().
-\m -
+
 There is a shared memory which may be shared with other boards in the
 system. The shared memory can be retrieved by using vbiShmemRegionFind()
 
-\m -
 Each core in the system is assigned a private memory region. The base address
 and the length of this region may obtained by calling vbiCorePrvMemFind ()
 Alternatively the following macros can be used to obtained similar information
-    - 
-    -
+
 */
 
 #include <linux/types.h>
@@ -43,160 +40,86 @@ Alternatively the following macros can be used to obtained similar information
 #include <vbi/vbi.h>
 #include <vbi/private.h>
 
-/******************************************************************************
-*
+/*
 * vbiShmemRegionFind - locate the shared memory parameters for a given region
 *
-* This function finds the shared memory region associated with the name 
+* This function finds the shared memory region associated with the name
 * specified. The first argument to this function indicates the name of the
 * shared to find. If this region exists in the list of configured regions the
-* address, length and MMU attributes are set in the pointers passed in as 
+* address, length and MMU attributes are set in the pointers passed in as
 * arguments.
-* 
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiShmemRegionFind
-*   (
-*   const char *    smName,	/@ String name of the region    @/
-*   void * *	    addr,	/@ Location - OUT		@/
-*   size_t *	    length,	/@ Length - OUT			@/
-*   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
-*    )
-*
-*
-* RETURNS: OK or an errror number in case of failure
 *
-*
-*
-* SEE ALSO: vbiMemRegionFind() 
 */
-
-vbiStatus_t vbiShmemRegionFind
-    (
-    int8_t *         smName,      /* String name of the region */
-    void * *       addr,        /* Location - OUT */
-    uint32_t * length,      /* Length - OUT */
-    uint32_t * attr         /* MMU Attributes - OUT */
-    )
-    {
-    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
-    VB_SM_INFO * info = config->sharedMemoryRegionsConfigAddress;
-    int32_t          num  = config->numSm;
-    int32_t          i;
-
-    for (i = 0; i < num; i++, info++)
+vbiStatus_t vbiShmemRegionFind(int8_t *smName, void **addr,
+				 uint32_t *length, uint32_t *attr)
+{
+	VB_CONFIG *config = VBI_CONFIG_ADDR_GET();
+	VB_SM_INFO *info = config->sharedMemoryRegionsConfigAddress;
+	int32_t num = config->numSm;
+	int32_t i;
+
+	for (i = 0; i < num; i++, info++)
         {
-        if (!_vbiStrncmp ((char *)smName, (char *)info->name, 
-	    VB_MAX_WRHV_NAME_LENGTH))
-            {
-            /* Found */
-            *addr   = info->addr;
-            *length = info->length;
-            *attr   = info->attr;
-            return (OK);
-            }
-        }
-    *addr = 0;
-    return (VBI_INVALID_SHMEM);
-    }
-
-#ifdef CONFIG_WRHV
+		if (!_vbiStrncmp((char *)smName, (char *)info->name,
+				VB_MAX_WRHV_NAME_LENGTH)) {
+			/* Found */
+			*addr   = info->addr;
+			*length = info->length;
+			*attr   = info->attr;
+			return 0;
+		}
+	}
+	*addr = 0;
+	return VBI_INVALID_SHMEM;
+}
 EXPORT_SYMBOL(vbiShmemRegionFind);
-#endif /* CONFIG_WRHV */
 
-/******************************************************************************
-*
+/*
 * vbiMemRegionFind - locate the memory parameters for a given region
 *
-* This function finds the memory region associated with the name specified. 
+* This function finds the memory region associated with the name specified.
 * The first argument to this function indicates the name of the memory to find
-* If this region exists in the list of configured regions the address, 
+* If this region exists in the list of configured regions the address,
 * length and MMU attributes are set in the pointers passed in as
 * arguments.
 *
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemRegionFind
-*   (
-*   const char *    name,   /@ String name of the region    @/
-*   void * *	    addr,   /@ Location - OUT		    @/
-*   size_t *	    length, /@ Length - OUT		    @/
-*   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-* RETURNS: None
-*
 */
 
-vbiStatus_t vbiMemRegionFind
-    (
-    int8_t   *	    name,	/* String name of the region  */
-    void   * *	    addr,	/* Location - OUT		    */
-    uint32_t    *length,	/* Length - OUT		    */
-    uint32_t *	    attr	/* MMU Attributes - OUT	    */
-    )
-    {
-    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
-    VB_MEM_INFO * info = config->memoryRegionsConfigAddress;
-    int32_t      num  = config->numMem;
-    int32_t      i;
+vbiStatus_t vbiMemRegionFind(int8_t *name, void **addr,
+				 uint32_t *length, uint32_t *attr)
+{
+	VB_CONFIG *config = VBI_CONFIG_ADDR_GET();
+	VB_MEM_INFO *info = config->memoryRegionsConfigAddress;
+	int32_t num  = config->numMem;
+	int32_t i;
+
+	for (i = 0; i < num; i++, info++)
+	{
+		if (!_vbiStrncmp ((char *)name, (char *)info->name,
+			VB_MAX_WRHV_NAME_LENGTH)) {
+			/* Found */
+			*addr   = info->addr;
+			*length = info->length;
+			*attr   = info->attr;
+			return 0;
+		}
+	}
+	*addr = 0;
+
+	return VBI_INVALID_SHMEM;
+}
 
-    for (i = 0; i < num; i++, info++)
-        {
-        if (!_vbiStrncmp ((char *)name, (char *)info->name,
-            VB_MAX_WRHV_NAME_LENGTH))
-            {
-            /* Found */
-            *addr   = info->addr;
-            *length = info->length;
-            *attr   = info->attr;
-            return (OK);
-            }
-        }
-    *addr = 0;
-
-    return (VBI_INVALID_SHMEM);
-    
-    }
-
-/******************************************************************************
-*
+/*
 * vbiCorePrvMemFind - locate the private memory for a core
 *
 * This function gets the base address of the private memory region assigned to
-* the running core. 
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiCorePrvMemFind 
-*   (
-*   void * *    addr,	    /@ Location - OUT		    @/
-*   size_t *	length	    /@ Length - OUT		    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-* RETURNS: None
+* the running core.
 *
 */
-
-vbiStatus_t vbiCorePrvMemFind 
-    (
-    void * *       addr,      /* Location - OUT */
-    size_t *     length       /* Length - OUT */
-    )
-    {
-
-    *addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
-    *length = VBI_VCORE_PRIVMEM_SIZE_GET();
-    
-    return (OK);
-    }
-
+vbiStatus_t vbiCorePrvMemFind(void **addr, size_t *length)
+{
+	*addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
+	*length = VBI_VCORE_PRIVMEM_SIZE_GET();
+	
+	return 0;
+}
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
index 05e4edf..141cbf7 100644
--- a/kernel/vbi/show.c
+++ b/kernel/vbi/show.c
@@ -101,7 +101,7 @@ static void vbiInterruptsShow(VB_CONFIG *config)
 		if (p->intDirection == VB_INPUT_INT)
 			VB_PRINTF("%8s: Dir: In, Vector #: %d, Core: %d\n",
 		            p->intName, p->intNumber, p->intCore);
-		else 
+		else
 			VB_PRINTF("%8s: Dir: Out, Vector #: %d\n",
 		            p->intName, p->intNumber);
 	}
@@ -120,7 +120,7 @@ void vbiStatusShow(VB_STATUS *p)
 	VB_PRINTF("  Pending interrupts: 0x%08x\n", p->intPendingType);
 	VB_PRINTF("  timestamp:          %lld\n", p->timeStamp);
 	VB_PRINTF("  old int disable:    0x%08x\n", p->oldIntDisable);
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
 	vbiStsRegsDisplay();
 #endif
 }
@@ -139,8 +139,8 @@ void vbiControlShow(VB_CONTROL *p)
 
 	VB_PRINTF("  Disable interrupts:  0x%08x\n", p->intDisable);
 
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-	vbiCtrlRegsDisplay (); 
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
+	vbiCtrlRegsDisplay();
 #endif
 
 	VB_PRINTF("  Disabled interrupts:");
diff --git a/kernel/vbi/version.c b/kernel/vbi/version.c
index 1aa7b1f..69c5f83 100644
--- a/kernel/vbi/version.c
+++ b/kernel/vbi/version.c
@@ -31,13 +31,11 @@ building all hypervisor executables.
 #include <vbi/version.h>
 
 /* numerical values for vbi version */
-
 const uint32_t vbiVersionMajor = VBI_VERSION_MAJOR;
 const uint32_t vbiVersionMinor = VBI_VERSION_MINOR;
 const uint32_t vbiVersionMaint = VBI_VERSION_MAINT;
 
 /* string identifiers for vbi version */
-
 const char *vbiRuntimeName = VBI_RUNTIME_NAME;
 const char *vbiRuntimeVersion = VBI_RUNTIME_VERSION;
 const char *vbiVersion = VBI_VERSION;
@@ -47,4 +45,3 @@ const char *vbiCreationDate = VBI_RUNTIME_CREATION_DATE;
 #else
 const char *vbiCreationDate = __DATE__ ", " __TIME__;
 #endif
-
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index ae88409..b863ac0 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -21,7 +21,7 @@
 #include <linux/sched.h>
 #include <vbi/vbi.h>
 
-#define VIOAPIC_BASE_ADDR      (&wrhvVbControl->vIoapic)
+#define VIOAPIC_BASE_ADDR	(&wrhvVbControl->vIoapic)
 
 static uint32_t vioapic_reg_read(uint8_t offset)
 {
@@ -126,7 +126,8 @@ irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
 		update_process_times(user_mode(regs));
 		profile_tick(CPU_PROFILING);
 		if (lost_jiffies > (2*HZ)) {
-			printk(KERN_DEBUG "Time falling behind %d jiffies\n", lost_jiffies);
+			printk(KERN_DEBUG "Time falling behind %d jiffies\n",
+				lost_jiffies);
 			break;
 		}
 	} while (--ticks > 0);
-- 
1.6.5.rc3

