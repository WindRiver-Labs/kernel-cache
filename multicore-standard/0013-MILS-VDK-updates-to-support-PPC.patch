From c20a0676c97af878baddac76b8e8443e3da07c7e Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Fri, 19 Feb 2010 08:19:49 -0500
Subject: [PATCH] [MILS] VDK updates to support PPC

Additions to the VDK which are needed for PowerPC.

These MILS powerpc specific additions are the Linux specific
additions that were not a part of the reference VBI implementation.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/kernel/vbi/Makefile       |    7 +-
 arch/powerpc/kernel/vbi/vdk_syscalls.S |  148 +++++++++++++++++++++
 include/vbi/arch.h                     |    6 +
 include/vbi/interrupt.h                |    1 +
 include/vbi/vdk_interface.h            |  227 ++++++++++++++++++++------------
 include/vbi/vdk_syscalls.h             |   29 ++++-
 kernel/vbi/Makefile                    |    9 +-
 7 files changed, 338 insertions(+), 89 deletions(-)
 create mode 100644 arch/powerpc/kernel/vbi/vdk_syscalls.S

diff --git a/arch/powerpc/kernel/vbi/Makefile b/arch/powerpc/kernel/vbi/Makefile
index daac59f..a02358c 100644
--- a/arch/powerpc/kernel/vbi/Makefile
+++ b/arch/powerpc/kernel/vbi/Makefile
@@ -2,4 +2,9 @@
 # Makefile for the vbi ppc.
 #
 
-obj-y		+= syscalls.o util.o wrhv.o vmmu_display.o show.o
+obj-y		+= util.o wrhv.o vmmu_display.o show.o
+ifeq ($(CONFIG_WRHV_MILS),y)
+obj-y		+= vdk_syscalls.o
+else
+obj-y		+= syscalls.o
+endif
diff --git a/arch/powerpc/kernel/vbi/vdk_syscalls.S b/arch/powerpc/kernel/vbi/vdk_syscalls.S
new file mode 100644
index 0000000..974af7e
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/vdk_syscalls.S
@@ -0,0 +1,148 @@
+/* vdk_syscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/asm-offsets.h>
+#include <asm/cache.h>
+#include <vbi/vdk_syscalls.h>
+
+#ifdef CONFIG_PPC85xx_VT_MODE   /* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
+
+
+#define FUNC_LABEL(func) _GLOBAL(func)
+#define FUNC_EXPORT(func)
+#define FUNC_END(func)
+#define _WRS_TEXT_SEG_START
+#define HI(sym) sym@h
+#define HIADJ(sym) sym@ha
+#define LO(sym) sym@l
+
+_WRS_TEXT_SEG_START
+
+#define vbi_hcall(name, call)		\
+FUNC_EXPORT(name)			\
+FUNC_LABEL(name)			\
+	lis r0, HI(VBI_SYS_##call);	\
+	ori r0, r0, LO(VBI_SYS_##call);	\
+	HCALL;				\
+	blr;				\
+FUNC_END(name)
+
+
+/*
+*
+* vbi_flush_icache - flush the instruction cache
+*
+* This system call flushes the instruction cache for the specified address
+* range.
+*
+*/
+
+vbi_hcall(vbi_flush_icache,icache_flush)
+
+/*
+*
+* vbi_flush_dcache - flush the data cache
+*
+* This system call flushes the data cache for the specified address range.
+*
+*/
+
+vbi_hcall(vbi_flush_dcache,dcache_flush)
+
+/*
+*
+* vbi_vmmu_config - configure the hypervisor virtual MMU
+*
+* This system call configures the context's virtual MMU within the hypervisor.
+*
+*/
+
+vbi_hcall(vbi_config_vmmu,vmmu_config)
+
+/*
+*
+* vbi_vmmu_enable - enables the virtual MMU
+*
+* This system call enables a context's virtual MMU.
+*
+*/
+
+vbi_hcall(vbi_enable_vmmu,vmmu_enable)
+
+/*
+*
+* vbi_vmmu_disable - disable the virtual MMU
+*
+* This system call disables a context's virtual MMU.
+*
+*/
+
+vbi_hcall(vbi_disable_vmmu,vmmu_disable)
+
+/*
+*
+* vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
+*
+* This system call loads the TLB entries for the specified address range into
+* the virtual MMU.
+*
+*/
+
+vbi_hcall(vbi_tlb_load_vmmu,vmmu_tlbload)
+
+/*
+*
+* vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
+*
+* This system call flushes the TLB entries for the specified address range
+* from the virtual MMU.
+*
+*/
+
+vbi_hcall(vbi_tlb_flush_vmmu,vmmu_tlbflush)
+
+/*
+*
+* vbiExcVecBaseSet - set current partition exception vector base address
+*
+* This system call sets the calling partition exception vector base address.
+*
+*/
+
+vbi_hcall(vbi_exec_vec_base_addr_set,excVecBaseSet)
+
+/*
+*
+* vbi_virt_to_phys - convert a guest OS address to a physical address
+*
+* This system call converts a guest OS address to a physical address
+*
+* HAE API vbiPaddr uses this system call.
+*
+*/
+
+vbi_hcall(vbi_virt_to_phys,virtToPhys)
+
diff --git a/include/vbi/arch.h b/include/vbi/arch.h
index a21a675..ff8077e 100644
--- a/include/vbi/arch.h
+++ b/include/vbi/arch.h
@@ -14,6 +14,11 @@
  *
  */
 
+#ifdef CONFIG_WRHV_MILS
+/* MILS stores all arch specific definitions in
+ * include/vbi/vdk_interface.h
+ */
+#else
 #ifndef _VBI_ARCH_H
 #define _VBI_ARCH_H
 
@@ -32,3 +37,4 @@
 #endif
 
 #endif /* _VBI_ARCH_H */
+#endif /* CONFIG_WRHV_MILS */
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
index 3f3bed2..bbaa835 100644
--- a/include/vbi/interrupt.h
+++ b/include/vbi/interrupt.h
@@ -27,6 +27,7 @@ interrupts configuration data.
 #ifndef	_ASMLANGUAGE
 
 #ifdef CONFIG_WRHV_MILS
+#include <vbi/errors.h>
 static inline uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
 {
 	return VBI_INVALID_IRQ;
diff --git a/include/vbi/vdk_interface.h b/include/vbi/vdk_interface.h
index 3c2dc47..5cbbd1c 100644
--- a/include/vbi/vdk_interface.h
+++ b/include/vbi/vdk_interface.h
@@ -29,25 +29,6 @@
 #define	VBI_VERSION_MINOR	2	/* minor version */
 #define	VBI_VERSION_MAINT	0	/* maintenance version */
 
-/* macro to align guest fields for a 64-bit hypervisor */
-#if defined(LP64)
-#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			   __attribute__(( aligned(8) )) \
-			   decl_var
-#else
-#if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
-#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			    __attribute__(( aligned(8) )) \
-			    decl_var; \
-			    uint32_t pad_var
-#else
-#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			    __attribute__(( aligned(8) )) \
-			    uint32_t pad_var; \
-			    decl_var
-#endif
-#endif
-
 #undef VB_DEBUG  /* define it to turn on debugging */
 #ifdef VB_DEBUG
 #define VB_DEBUG_MSG(fmt, args...)    printk(fmt, ##args)
@@ -99,17 +80,8 @@
 
 #define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
 #define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-#define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
-#else
-#define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
-#define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
-#endif /* __VBI_BYTE_ORDER */
+#define VB_CONTROL_VMMU0                4*2
+#define VB_CONTROL_VMMU1                4*3
 
 /* Bit Mask definitions for VB_STATUS_INT_PENDING */
 #define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
@@ -125,32 +97,44 @@
 #define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
 #define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
 #define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-#define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
-#else
-#define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
-#endif /* __VBI_BYTE_ORDER */
-
+#define VB_STATUS_VMMU0                 4*5
+#define VB_STATUS_VMMU1                 4*6
+
+#ifdef CONFIG_PPC32
+#define VB_CONTROL_SRR0                 4*4
+#define VB_CONTROL_SRR1                 4*5
+#define VB_CONTROL_CR                   4*6
+#define VB_CONTROL_R0                   4*7
+#define VB_CONTROL_R1                   4*8
+#define VB_CONTROL_SP                   VB_CONTROL_R1
+#define VB_CONTROL_R2                   4*9
+#define VB_CONTROL_R3                   4*10
+#define VB_CONTROL_R4                   4*11
+#define VB_CONTROL_R5                   4*12
+#define VB_CONTROL_R6                   4*13
+#define VB_CONTROL_R7                   4*14
+#define VB_CONTROL_R8                   4*15
+#define VB_CONTROL_R9                   4*16
+#define VB_CONTROL_R10                  4*17
+#define VB_CONTROL_R11                  4*18
+#define VB_CONTROL_R12                  4*19
+#define VB_CONTROL_R13                  4*20
+#define VB_CONTROL_EMSR                 4*21
+#define VB_STATUS_SRR0                  4*26
+#define VB_STATUS_SRR1                  4*27
+#define VB_STATUS_CR                    4*28
+#define VB_STATUS_LR                    4*29
+#define VB_STATUS_R3                    4*30
+#define VB_STATUS_R4                    4*31
+#define VB_STATUS_ESR                   4*34
+#define VB_STATUS_DEAR                  4*37
+#endif
 /* Assembler offsets for vb_config */
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
 #define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
 #define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
 #define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
 #define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
 #define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
-#else
-#define VB_CONFIG_VBSTATUS		((2+0) * 8)
-#define VB_CONFIG_VBCONTROL		((2+1) * 8)
-#define VB_CONFIG_SMINFO		((2+2) * 8)
-#define VB_CONFIG_MEMINFO		((2+3) * 8)
-#define VB_CONFIG_INTINFO		((2+4) * 8)
-#endif /* __VBI_BYTE_ORDER */
 
 /* Defines for vbIntInfo intDirection field */
 #define VB_INPUT_INT	1
@@ -201,7 +185,7 @@ typedef enum                            /* queuing port protocol     */
     NOT_APPLICABLE
 } PORT_PROTOCOL_TYPE;
 
-typedef struct portConfig
+struct portConfig
 {
     unsigned long id;			/* unique port ID                   */
     unsigned char *buf;			/* port payload buffer vaddr        */
@@ -216,22 +200,22 @@ typedef struct portConfig
     PORT_PROTOCOL_TYPE protocol;	/* RECEIVER_DISCARD or SENDER_BLOCK */
     unsigned long msgSize;		/* max. message size (PAGE_ALIGNED) */
     unsigned long numMsgs;		/* max. capacity for queuing ports  */
-} PORT_CONFIG;
+};
 
-typedef struct partPortConfig
+struct partPortConfig
 {
     unsigned long numPorts;
-    PORT_CONFIG portInfo[];
-} PART_PORT_CONFIG;
+    struct portConfig portInfo[];
+};
 
 typedef struct portConfig VB_PORT_INFO;
 typedef struct portStatus VB_PORT_STATUS;
 
-typedef struct vb_log_cfg
+struct vb_log_cfg
 {
     signed long recordSize;      /* size of each record entry */
     signed long maxRecords;      /* maximum number of log records */
-} VB_LOG_CFG;
+};
 
 /* Info for the memory map info */
 struct vb_mem_info
@@ -275,23 +259,23 @@ typedef struct vb_log_status
 
 
 /* Status information about one interrupt */
-typedef struct vbInterruptLevel
+struct vbInterruptLevel
 {
     uint64_t       timeStamp;    /* Time when last interrupt delivered here */
     unsigned long  numInts;      /* How many interrupts since last delivered */
     unsigned long  numIntData;   /* How many data elements have been stored */
     unsigned long  intData[VB_MAX_INTERRUPT_DATA];
-} VB_INTERRUPT_LEVEL;
+};
 
 /* The virtual interrupt controller, with individual interrupt sources */
-typedef struct vbInterruptController
+struct vbInterruptController
 {
     unsigned long      intPending; /* Which interrupts are pending
                                     * high order bit (value 0x80000000)
                                     * is int #0
                                     */
-    VB_INTERRUPT_LEVEL intLevel[VB_MAX_INTERRUPTS];
-} VB_INTERRUPT_CONTROLLER;
+    struct vbInterruptLevel intLevel[VB_MAX_INTERRUPTS];
+};
 
 
 
@@ -307,14 +291,19 @@ struct vb_int_info
 
 /* time donation status */
 
-typedef struct td_status
+struct td_status
 {
     unsigned int  clientTwId;    /* active client TW object ID */
     unsigned int  clientPortId;  /* port ID associated to client TW */
     unsigned int  serverTwId;    /* active server TW object ID */
     unsigned int  serverPortId;  /* port ID associated to server TW */
-} TD_STATUS;
+};
 
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+		base->field
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+		base->field
 
 /* Do not change the order of these fields */
 struct vb_status
@@ -351,13 +340,47 @@ struct vb_status
 
     /* Location in vbPhyscial memory of the virtual interrupt controller */
 
-    VB_INTERRUPT_CONTROLLER * vbInterruptController;  /* 10: */
-    VB_PORT_STATUS *          portStatus;             /* 11: port status */
+    struct vbInterruptcontroller *vbInterruptController;  /* 10: */
+    VB_PORT_STATUS 		 *portStatus;             /* 11: port status */
 
     VB_LOG_STATUS secAuditLogStatus; /* 12-16: Security Audit Event log status */
     VB_LOG_STATUS safetyLogStatus;   /* 17-21: Safety Critical Event log status */
-    TD_STATUS     tdStatus;          /* 22-25: time donation status */
-    unsigned long tick_count;    /* how many ticks VB should have received */
+    struct td_status tdStatus;       /* 22-25: time donation status */
+#ifdef CONFIG_PPC32
+    /* registers saved by hypervisor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+    uint32_t srr0; /* 26: PC at time of the interrupt */
+    uint32_t srr1; /* 27: MSR at time of the interrupt */
+    uint32_t cr;   /* 28: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 29: Link register at time of the interrupt */
+    uint32_t r3;   /* 30: R3 at time of the interrupt */
+    uint32_t r4;   /* 31: R4 at time of the interrupt */
+
+    /* Registers saved by hypervisor during exception processing only */
+
+    uint32_t mcsrr0; /* 32: */
+    uint32_t mcsrr1; /* 33: */
+    uint32_t esr;    /* 34: */
+    uint32_t mcsr;   /* 35: */
+    uint32_t mcar;   /* 36: */
+    uint32_t dear;   /* 37: */
+    uint32_t emsr;   /* 38: */
+    uint32_t esrr0;  /* 39: */
+    uint32_t esrr1;  /* 40: */
+
+    /* Configuration registers (only updated upon board creation */
+    uint32_t svr;    /* 41: */
+    uint32_t pir;    /* 42: */
+    uint32_t pvr;    /* 43: */
+    uint32_t hid0;   /* 44: */
+    uint32_t hid1;   /* 45: */
+    uint32_t bucsr;  /* 46: */
+    uint32_t l1csr0; /* 47: */
+    uint32_t l1csr1; /* 48: */
+#endif
+    uint32_t tick_count;    /* how many ticks VB should have received */
 };
 
 /*
@@ -383,8 +406,35 @@ struct vb_control
     void *        vmmu0;	/*  2: VMMU 0 table for context switch */
     void *        vmmu1;	/*  3: VMMU 1 table for context switch */
 
-    unsigned long level_irq_disable; /* TBD interrupt level enabling */
-    unsigned long vIoapic;  /* filler */
+#ifdef CONFIG_PPC32
+    /* Registers to be restored by the VBI_SYS_ctx_load fast system call */
+
+    uint32_t srr0;         /*  4: PC */
+    uint32_t srr1;         /*  5: MSR */
+    uint32_t cr;           /*  6: condition registers */
+    uint32_t r0;           /*  7: General register R0 */
+    uint32_t sp;           /*  8: General register R1 (stack pointer) */
+    uint32_t r2;           /*  9: General register R2 */
+    uint32_t r3;           /* 10: General register R3 */
+    uint32_t r4;           /* 11: General register R4 */
+    uint32_t r5;           /* 12: General register R5 */
+    uint32_t r6;           /* 13: General register R6 */
+    uint32_t r7;           /* 14: General register R7 */
+    uint32_t r8;           /* 15: General register R8 */
+    uint32_t r9;           /* 16: General register R9 */
+    uint32_t r10;          /* 17: General register R10 */
+    uint32_t r11;          /* 18: General register R11 */
+    uint32_t r12;          /* 19: General register R12 */
+    uint32_t r13;          /* 20: General register R13 */
+
+    /* emulated registers used by the VBI_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;         /* 21: emulated MSR register */
+#endif
+
+    uint32_t level_irq_disable; /* TBD interrupt level enabling */
+    uint32_t vIoapic;  /* filler */
+    uint32_t irq_pend; /* filler */
 };
 
 
@@ -401,12 +451,12 @@ struct vb_sm_info
 };
 
 /* info for IO port region */
-typedef struct vb_io_port_info
+struct vb_io_port_info
 {
     VB_WRHV_NAME      name;   /* The name of the shared memory region */
     unsigned int       port;   /* unique port addr                   */
     unsigned int       size;   /* port addr size */
-} VB_IOPORT_INFO;
+};
 
 
 /*
@@ -461,7 +511,7 @@ struct vb_config
 
     /* IO port region for the virtual board */
     unsigned int     numIoPortRgn;     /* number of io port regions */
-    VB_IOPORT_INFO * vbIoPortRgn;      /* IO port Region Info  array*/
+    struct vb_io_port_info * vbIoPortRgn;      /* IO port Region Info  array*/
 
     int           numExc;     /* how many exceptions to forward to VB */
     unsigned int  exceptions [VB_MAX_EXCEPTION_TYPES]; /* forward EXC list */
@@ -474,16 +524,18 @@ struct vb_config
 
     unsigned int  cacheMode;
 
-    unsigned int   numPorts;  /* number of ports defined for the VB */
-    VB_PORT_INFO * portInfo;  /* port configuration and status */
+    unsigned int      numPorts;  /* number of ports defined for the VB */
+    VB_PORT_INFO      *portInfo;  /* port configuration and status */
+
+    unsigned int      irq_pend;  /* filler */
 
-    VB_LOG_CFG      secAuditLogCfg;
-    VB_LOG_CFG      safetyLogCfg;
-    int		    coreId;  /* Just a filler since MILS can only run on 1 core */
-    int             corePrivateSize; /* Just another filler */
-    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
-    int		    pid;   /*filler */
-    int		    board_type; /* filler*/
+    struct vb_log_cfg secAuditLogCfg;
+    struct vb_log_cfg safetyLogCfg;
+    int               coreId;  /* Just a filler since MILS can only run on 1 core */
+    int               corePrivateSize; /* Just another filler */
+    void              *corePrivate;  /* filler */
+    int               pid;   /*filler */
+    int               board_type; /* filler*/
 
 };
 
@@ -544,12 +596,19 @@ static inline int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t tCore)
 	return 0;
 }
 
-extern asmlinkage int vdk_virt_to_phys (void * pVirtAddr, void *pPaddr);
+extern asmlinkage int vbi_virt_to_phys (void * pVirtAddr, void *pPaddr);
 
 static inline int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr)
 {
-	return vdk_virt_to_phys(__va(gaddr), paddr);
+#ifdef CONFIG_PPC
+	return vbi_virt_to_phys(gaddr, paddr);
+#else
+	return vbi_virt_to_phys(__va(gaddr), paddr);
+#endif
 }
+
+extern int vb_context_mmu_on(int pid, void * pgtable, int pagesize, int debug);
+
 #endif /*_ASMLANGUAGE */
 #endif  /* _VDK_INTERFACE_H */
 
diff --git a/include/vbi/vdk_syscalls.h b/include/vbi/vdk_syscalls.h
index f199d8b..80693b1 100644
--- a/include/vbi/vdk_syscalls.h
+++ b/include/vbi/vdk_syscalls.h
@@ -17,6 +17,19 @@
 #ifndef _VDK_SYSCALLS_H
 #define _VDK_SYSCALLS_H
 
+#ifdef __ASSEMBLY__
+#define _ASMLANGUAGE
+
+#define p0      r3      /* argument register, volatile */
+#define p1      r4      /* argument register, volatile */
+#define p2      r5      /* argument register, volatile */
+#define p3      r6      /* argument register, volatile */
+#define p4      r7      /* argument register, volatile */
+#define p5      r8      /* argument register, volatile */
+#define p6      r9      /* argument register, volatile */
+#define p7      r10     /* argument register, volatile */
+#endif
+
 /*
  * System call number encoding:
  *
@@ -135,7 +148,8 @@ have mapped a NULL / no-op to HY_SYSCALL(23) */
 #define VBI_SYS_cache_text_update                   \
                                  VDK_SYS_NULL /* cache text update */
 /* Normal system calls */
-#define VBI_SYS_excVecBaseSet    HY_SYSCALL(0)  /* VDK_SYS_excVecBaseSet */
+#define VBI_SYS_excVecBaseSet    HY_SYSCALL(0)  /* Set exception base vector */
+#define VBI_SYS_virtToPhys       HY_SYSCALL(1)  /* conv. virt addr to phys. */
 /* hypervisor services */
 #define VBI_SYS_hyIoctl          VDK_SYS_NULL  /* hypervisor ioctl */
 #define VBI_SYS_vmContextCreate  VDK_SYS_NULL  /* context create */
@@ -146,6 +160,7 @@ have mapped a NULL / no-op to HY_SYSCALL(23) */
 #define VBI_SYS_int              HY_SYSCALL(3)  /* deliver an interrupt */
 #define VBI_SYS_int_controller_done HY_SYSCALL(4) /* done intr processing*/
 #define VBI_SYS_ctxctl           VDK_SYS_NULL  /* context control operation */
+#define VBI_SYS_invalidate_tlb_entry   HY_FAST_SYSCALL(5) /* invalidate TLB entry */
 
 /* VMMU operations */
 #define VBI_SYS_vmmu_config     HY_SYSCALL(5)  /* configure the virtual MMU */
@@ -387,6 +402,18 @@ typedef struct vbMgmtCtl
 typedef uint32_t VBMGMT_HANDLE;
 typedef uint32_t VBI_NS_HANDLE;
 
+/* Forward declaration */
+struct vmmuConfig;
+
+/* system call prototypes for use within a context */
+
+extern int vbi_flush_dcache (void *saddr, void *eaddr, unsigned size);
+extern int vbi_flush_icache (void *saddr, void *eaddr, unsigned size);
+extern int vbi_config_vmmu (struct vmmuConfig * config);
+extern int vbi_enable_vmmu (unsigned vmmu_num);
+extern int vbi_disable_vmmu (unsigned vmmu_num);
+extern int vbi_virt_to_phys (void * pVirtAddr, void *pPaddr);
+
 #endif	/* _ASMLANGUAGE */
 
 #endif	/* _VDK_SYSCALLS_H */
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index f7ca6fc..b3ad2af 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -1,8 +1,11 @@
 #
 # Makefile for the vbi goodies.
 #
-obj-y := lib.o shmem.o version.o msg.o ns.o show.o wrhv.o
-ifeq ($(CONFIG_WRHV_MILS),)
-obj-y += io_apic.o interrupt.o idle.o paddr.o
+
+obj-y := wrhv.o paddr.o lib.o shmem.o show.o version.o
+ifeq ($(CONFIG_WRHV_MILS),y)
+# No MILS specific files needed
+else
+obj-y += io_apic.o interrupt.o idle.o msg.o ns.o
 endif
 
-- 
1.7.0

