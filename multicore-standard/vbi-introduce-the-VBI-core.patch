From f9b335bb8d3a49d3610dcde4d245f7100a9cb3e0 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:05:12 -0400
Subject: [PATCH 01/20] vbi: introduce the VBI core

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/vbi/support/asm.h           |   33 ++
 include/vbi/support/ctype.h         |   96 ++++
 include/vbi/support/macros.h        |   32 ++
 include/vbi/support/stdio.h         |  239 ++++++++
 include/vbi/support/stdlib.h        |  109 ++++
 include/vbi/support/string.h        |   76 +++
 include/vbi/support/sys/arch.h      |   49 ++
 include/vbi/support/sys/cpu_types.h |   82 +++
 include/vbi/support/sys/regs.h      |   35 ++
 include/vbi/support/sys/types.h     |  359 +++++++++++++
 include/vbi/support/sys/vmmu.h      |  304 +++++++++++
 include/vbi/syscalls.h              |  391 ++++++++++++++
 include/vbi/vbInterface.h           |  836 ++++++++++++++++++++++++++++
 include/vbi/vbi.h                   | 1015 +++++++++++++++++++++++++++++++++++
 include/vbi/vbiArch.h               |   48 ++
 include/vbi/vbiErrors.h             |   63 +++
 include/vbi/vbiInterrupt.h          |   44 ++
 include/vbi/vbiPrv.h                |   93 ++++
 include/vbi/vbiShmem.h              |   59 ++
 include/vbi/vbiSyscall.h            |  233 ++++++++
 include/vbi/vbiTypes.h              |   58 ++
 include/vbi/vbiVersion.h            |   54 ++
 include/vbi/vbiVioapic.h            |  132 +++++
 kernel/vbiIdle.c                    |   72 +++
 kernel/vbiInterrupt.c               |  102 ++++
 kernel/vbiLib.c                     |  872 ++++++++++++++++++++++++++++++
 kernel/vbiMsg.c                     |  153 ++++++
 kernel/vbiNs.c                      |  173 ++++++
 kernel/vbiPaddr.c                   |  119 ++++
 kernel/vbiShmem.c                   |  220 ++++++++
 kernel/vbiShow.c                    |  327 +++++++++++
 kernel/vbiVersion.c                 |   56 ++
 kernel/vbiVioApic.c                 |  628 ++++++++++++++++++++++
 kernel/vbiVmmuDoc.c                 |  245 +++++++++
 34 files changed, 7407 insertions(+), 0 deletions(-)
 create mode 100644 include/vbi/support/asm.h
 create mode 100644 include/vbi/support/ctype.h
 create mode 100644 include/vbi/support/macros.h
 create mode 100644 include/vbi/support/stdio.h
 create mode 100644 include/vbi/support/stdlib.h
 create mode 100644 include/vbi/support/string.h
 create mode 100644 include/vbi/support/sys/arch.h
 create mode 100644 include/vbi/support/sys/cpu_types.h
 create mode 100644 include/vbi/support/sys/regs.h
 create mode 100644 include/vbi/support/sys/types.h
 create mode 100644 include/vbi/support/sys/vmmu.h
 create mode 100644 include/vbi/syscalls.h
 create mode 100644 include/vbi/vbInterface.h
 create mode 100644 include/vbi/vbi.h
 create mode 100644 include/vbi/vbiArch.h
 create mode 100644 include/vbi/vbiErrors.h
 create mode 100644 include/vbi/vbiInterrupt.h
 create mode 100644 include/vbi/vbiPrv.h
 create mode 100644 include/vbi/vbiShmem.h
 create mode 100644 include/vbi/vbiSyscall.h
 create mode 100644 include/vbi/vbiTypes.h
 create mode 100644 include/vbi/vbiVersion.h
 create mode 100644 include/vbi/vbiVioapic.h
 create mode 100644 kernel/vbiIdle.c
 create mode 100644 kernel/vbiInterrupt.c
 create mode 100644 kernel/vbiLib.c
 create mode 100644 kernel/vbiMsg.c
 create mode 100644 kernel/vbiNs.c
 create mode 100644 kernel/vbiPaddr.c
 create mode 100644 kernel/vbiShmem.c
 create mode 100644 kernel/vbiShow.c
 create mode 100644 kernel/vbiVersion.c
 create mode 100644 kernel/vbiVioApic.c
 create mode 100644 kernel/vbiVmmuDoc.c

diff --git a/include/vbi/support/asm.h b/include/vbi/support/asm.h
new file mode 100644
index 0000000..577b31c
--- /dev/null
+++ b/include/vbi/support/asm.h
@@ -0,0 +1,33 @@
+/* asm.h - razor C assembler definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01d,15jul09,dtr  Support PPCE500MC cpu.
+01c,17mar09,mpk  OCTEON port from drc
+01b,16jul08,gws  adding ARM cpu
+01a,04oct07,md   written
+*/
+
+#ifndef __INCasmh
+#define __INCasmh
+
+#include <sys/cpu_types.h>
+
+/* include the appropriate arch specific header file */
+
+#if (CPU == MIPSI64R2)
+# include <sys/mips64/asm.h>
+#elif (CPU == PPC85XX)
+# include <sys/ppc/asm.h>
+#elif (CPU == PPCE500MC)
+# include <sys/ppc/asm.h>
+#elif (CPU == PENTIUM)
+# include <sys/x86/asm.h>
+#elif (CPU == ARM1136)
+# include <sys/arm1136/asm.h>
+#endif
+
+#endif  /* __INCasmh */
diff --git a/include/vbi/support/ctype.h b/include/vbi/support/ctype.h
new file mode 100644
index 0000000..7d31ff3
--- /dev/null
+++ b/include/vbi/support/ctype.h
@@ -0,0 +1,96 @@
+/* ctype.h - ANSI standard ctype functions header */
+
+/* Copyright 1992 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01b,09dec08,???  fix for inclusion by assembly files
+01a,29feb08,md   written based on VxWorks version 01k
+*/
+
+#ifndef __INCctypeh
+#define __INCctypeh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include "sys/cpu_types.h"
+#else
+#include <sys/types.h>
+#endif /* CONFIG_WRHV */
+
+#ifndef _ASMLANGUAGE
+
+extern int      isalnum(int __c);
+extern int      isalpha(int __c);
+extern int      iscntrl(int __c);
+extern int      isdigit(int __c);
+extern int      isgraph(int __c);
+extern int      islower(int __c);
+extern int      isprint(int __c);
+extern int      ispunct(int __c);
+extern int      isspace(int __c);
+extern int      isupper(int __c);
+extern int      isxdigit(int __c);
+extern int      tolower(int __c);
+extern int      toupper(int __c);
+
+extern  const unsigned char *__ctype;
+extern  const unsigned char *__ctype_tolower;
+extern  const unsigned char *__ctype_toupper;
+
+#endif /* _ASMLANGUAGE */
+
+#define _C_UPPER         0x1
+#define _C_LOWER         0x2
+#define _C_NUMBER        0x4
+#define _C_WHITE_SPACE   0x8
+#define _C_PUNCT         0x10
+#define _C_CONTROL       0x20
+#define _C_HEX_NUMBER    0x40
+#define _C_B             0x80
+
+#define __isalpha(c)    (__ctype[(unsigned char)(c)] & (_C_UPPER | _C_LOWER))
+#define __isupper(c)    (__ctype[(unsigned char)(c)] & (_C_UPPER))
+#define __islower(c)    (__ctype[(unsigned char)(c)] & (_C_LOWER))
+#define __isdigit(c)    (__ctype[(unsigned char)(c)] & (_C_NUMBER))
+#define __isxdigit(c)   (__ctype[(unsigned char)(c)] & (_C_HEX_NUMBER))
+#define __isspace(c)    (__ctype[(unsigned char)(c)] & (_C_WHITE_SPACE | _C_CONTROL))
+#define __ispunct(c)    (__ctype[(unsigned char)(c)] & (_C_PUNCT))
+#define __isalnum(c)    (__ctype[(unsigned char)(c)] & (_C_UPPER | _C_LOWER | _C_NUMBER))
+#define __isprint(c)    (__ctype[(unsigned char)(c)] & (_C_PUNCT | _C_UPPER | _C_LOWER | \
+				       _C_WHITE_SPACE | _C_NUMBER))
+#define __isgraph(c)    (__ctype[(unsigned char)(c)] & (_C_PUNCT | _C_UPPER | _C_LOWER | \
+				       _C_NUMBER))
+#define __iscntrl(c)    (__ctype[(unsigned char)(c)] & (_C_CONTROL | _C_B))
+#define __toupper(c)    (__ctype_toupper[(unsigned char)(c)])
+#define __tolower(c)    (__ctype_tolower[(unsigned char)(c)])
+
+#ifndef __cplusplus
+#define isalpha(c)      __isalpha((unsigned char)(c))
+#define isupper(c)      __isupper((unsigned char)(c))
+#define islower(c)      __islower((unsigned char)(c))
+#define isdigit(c)      __isdigit((unsigned char)(c))
+#define isxdigit(c)     __isxdigit((unsigned char)(c))
+#define isspace(c)      __isspace((unsigned char)(c))
+#define ispunct(c)      __ispunct((unsigned char)(c))
+#define isalnum(c)      __isalnum((unsigned char)(c))
+#define isprint(c)      __isprint((unsigned char)(c))
+#define isgraph(c)      __isgraph((unsigned char)(c))
+#define iscntrl(c)      __iscntrl((unsigned char)(c))
+#define toupper(c)      __toupper((unsigned char)(c))
+#define tolower(c)      __tolower((unsigned char)(c))
+#endif
+
+#define isascii(c)	((unsigned char)(c) <= 0177)
+#define toascii(c)	((unsigned char)(c) & 0177)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCctypeh */
diff --git a/include/vbi/support/macros.h b/include/vbi/support/macros.h
new file mode 100644
index 0000000..2dea8d3
--- /dev/null
+++ b/include/vbi/support/macros.h
@@ -0,0 +1,32 @@
+/* macros.h - razor miscellaneous C macro definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01b,09apr09,mpk  hypervisor 64 bit changes to support mips cavium-octeon bsp
+01a,05oct07,md   written
+*/
+
+#ifndef __INCmacrosh
+#define __INCmacrosh
+
+/* macro for rounding values */
+
+#define ROUND_UP(x, align)	(((long) (x) + (align - 1)) & ~(align - 1))
+#define ROUND_DOWN(x, align)	((long)(x) & ~(align - 1))
+#define ALIGNED(x, align)	(((long)(x) & (align - 1)) == 0)
+
+/* macros for calcualating structure stuff */
+
+#define OFFSET(structure, member)	/* byte offset of member in structure*/\
+		((int) &(((structure *) 0) -> member))
+
+#define MEMBER_SIZE(structure, member)	/* size of a member of a structure */\
+		(sizeof (((structure *) 0) -> member))
+
+#define NELEMENTS(array)		/* number of elements in an array */ \
+		(sizeof (array) / sizeof ((array) [0]))
+
+#endif  /* __INCmacrosh */
diff --git a/include/vbi/support/stdio.h b/include/vbi/support/stdio.h
new file mode 100644
index 0000000..090c42d
--- /dev/null
+++ b/include/vbi/support/stdio.h
@@ -0,0 +1,239 @@
+/* stdio.h - stdio header file */
+
+/* Copyright 1992-2003 Wind River Systems, Inc. */
+/* Copyright (c) 1990 The Regents of the University of California */
+
+/*
+modification history
+--------------------
+01b,27nov07,foo  add our prototypes
+01a,04oct07,md   written based on VxWorks 02o version
+*/
+
+#ifndef __INCstdioh
+#define __INCstdioh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+#if defined(__STDC__) || defined(__cplusplus)
+#include <stdarg.h>
+#endif /* __STDC__ */
+
+/* types */
+
+struct __sbuf 			/* stdio buffers */
+    {
+    uchar_t * _base;		/* base address of {std,unget,line} buffer */
+    int	      _size;		/* size of the buffer */
+    };
+
+typedef	struct __sFILE
+    {
+    uchar_t *		_p;		/* current position in (some) buffer */
+    int			_r;		/* read space left for getc() */
+    int			_w;		/* write space left for putc() */
+    short		_flags;		/* flags, below;this FILE is free if 0*/
+    short		_file;		/* fileno, if Unix descriptor, else -1*/
+    struct __sbuf	_bf;		/* buffer (at least 1 byte,if !NULL) */
+    int			_lbfsize;	/* 0 or -_bf._size, for inline putc */
+    struct __sbuf	_ub;		/* ungetc buffer */
+    uchar_t *		_up;		/* old _p if _p is doing ungetc data */
+    int			_ur;		/* old _r if _r counting ungetc data */
+    uchar_t		_ubuf[3];	/* guarantee an ungetc() buffer */
+    uchar_t		_nbuf[1];	/* guarantee a getc() buffer */
+    struct __sbuf	_lb;		/* buffer for fgetline() */
+    int			_blksize;	/* stat.st_blksize (may be!=_bf._size)*/
+    int			_offset;	/* current lseek offset */
+    int			taskId;		/* task that owns this file pointer */
+    } FILE;
+
+/* __SRD and __SWR are never simultaneously asserted */
+
+#define	__SLBF		0x0001		/* line buffered */
+#define	__SNBF		0x0002		/* unbuffered */
+#define	__SRD		0x0004		/* OK to read */
+#define	__SWR		0x0008		/* OK to write */
+#define	__SWRNBF	(__SWR|__SNBF)	/* write unbuffered */
+#define	__SRW		0x0010		/* open for reading & writing */
+#define	__SEOF		0x0020		/* found EOF */
+#define	__SERR		0x0040		/* found error */
+#define	__SMBF		0x0080		/* _buf is from malloc */
+#define	__SAPP		0x0100		/* fdopen()ed in append mode */
+#define	__SSTR		0x0200		/* this is an sprintf/snprintf string */
+#define	__SOPT		0x0400		/* do fseek() optimisation */
+#define	__SNPT		0x0800		/* do not do fseek() optimisation */
+#define	__SOFF		0x1000		/* set iff _offset is in fact correct */
+#define	__SMOD		0x2000		/* true => fgetline modified _p text */
+
+#define	_IOFBF	0		/* setvbuf should set fully buffered */
+#define	_IOLBF	1		/* setvbuf should set line buffered */
+#define	_IONBF	2		/* setvbuf should set unbuffered */
+
+#define	BUFSIZ	_PARM_BUFSIZ	/* size of buffer used by setbuf */
+#define	BUFSIZE	BUFSIZ
+
+#ifndef EOF
+#define	EOF	(-1)
+#endif  /* EOF */
+
+#define FOPEN_MAX       _PARM_FOPEN_MAX
+#define FILENAME_MAX    _PARM_FILENAME_MAX
+
+#define	L_tmpnam	_PARM_L_tmpnam
+#define	TMP_MAX		_PARM_TMP_MAX
+
+#ifndef SEEK_SET
+#define	SEEK_SET	0	/* set file offset to offset */
+#endif
+
+#ifndef SEEK_CUR
+#define	SEEK_CUR	1	/* set file offset to current plus offset */
+#endif
+
+#ifndef SEEK_END
+#define	SEEK_END	2	/* set file offset to EOF plus offset */
+#endif
+
+#if _EXTENSION_POSIX_1003
+
+#define	L_cuserid	_PARM_L_cuserid
+#define	L_ctermid	_PARM_L_ctermid
+#define STREAM_MAX      FOPEN_MAX
+
+#endif /* _EXTENSION_POSIX_1003 */
+
+extern void	clearerr (FILE *);
+extern int	fclose (FILE *);
+extern int	feof (FILE *);
+extern int	ferror (FILE *);
+extern int	fflush (FILE *);
+extern int	fgetc (FILE *);
+extern int	fgetpos (FILE *, fpos_t *);
+extern char *	fgets (char *, size_t, FILE *);
+extern FILE *	fopen (const char *, const char *);
+extern int	fprintf (FILE *, const char *, ...);
+extern int	fputc (int, FILE *);
+extern int	fputs (const char *, FILE *);
+extern int	fread (void *, size_t, size_t, FILE *);
+extern FILE *	freopen (const char *, const char *, FILE *);
+extern int	fscanf (FILE *, const char *, ...);
+extern int	fseek (FILE *, long, int);
+extern int	fsetpos (FILE *, const fpos_t *);
+extern long	ftell (FILE *);
+extern int	fwrite (const void *, size_t, size_t, FILE *);
+extern int	getc (FILE *);
+extern int	getchar (void);
+extern char *	gets (char *);
+extern void	perror (const char *);
+extern int	printf (const char *, ...);
+extern int	putc (int, FILE *);
+extern int	putchar (int);
+extern int	puts (const char *);
+extern int	remove (const char *);
+extern int	rename  (const char *, const char *);
+extern void	rewind (FILE *);
+extern int	scanf (const char *, ...);
+extern void	setbuf (FILE *, char *);
+extern int	setvbuf (FILE *, char *, int, size_t);
+extern int	sprintf (char *, const char *, ...);
+extern int 	snprintf (char *, size_t, const char *, ...);
+extern int	sscanf (const char *, const char *, ...);
+extern FILE *	tmpfile (void);
+extern char *	tmpnam (char *);
+extern int	ungetc (int, FILE *);
+extern int	vfprintf (FILE *, const char *, va_list);
+extern int	vprintf (const char *, va_list);
+extern int	vsprintf (char *, const char *, va_list);
+extern int	vsnprintf (char *, size_t, const char *, va_list); 
+extern int	__srget (FILE *);		/* for macro definition below */
+extern int	__swbuf (int, FILE *);		/* for macro definition below */
+
+/* _EXTENSION_POSIX_1003 */
+
+extern FILE *	fdopen (int, const char *);
+extern int	fileno (FILE *);
+
+/* _EXTENSION_POSIX_1003 */
+
+/* WRS stdio functions declarations */
+
+#if _EXTENSION_WRS			/* undef for ANSI */
+
+extern int	fdprintf (int fd, const char *fmt, ...);
+extern int	vfdprintf (int fd, const char *fmt, va_list ap);
+extern int	printErr (const char *fmt, ...);
+extern int	getw (FILE *);
+extern int	putw (int, FILE *);
+extern void	setbuffer (FILE *, char *, int);
+extern int	setlinebuf (FILE *);
+extern FILE *   stdioFp (int std);
+extern STATUS   stdioShow (FILE * fp, int level);
+extern STATUS   stdioShowInit (void);
+extern STATUS   stdioInit (void);
+
+#endif /* _EXTENSION_WRS */
+
+
+/* Definition of stdin, stdout, stderr */
+
+extern FILE **	__stdin(void);		/* returns current task's stdin */
+extern FILE **	__stdout(void);		/* returns current task's stdout */
+extern FILE **	__stderr(void);		/* returns current task's stderr */
+
+#define stdin	(*__stdin())
+#define stdout	(*__stdout())
+#define stderr	(*__stderr())
+
+
+/* definition of stdio macros */
+
+#define	__sfileno(p)	((HANDLE_VERIFY(p, handleTypeFile) != OK) ? (-1) : \
+			((p)->_file))
+
+#define	__sgetc(p)	((HANDLE_VERIFY(p, handleTypeFile) != OK) ? (EOF) : \
+			((--(p)->_r < 0) ? (__srget(p)) : ((int)(*(p)->_p++))))
+
+#define	__sputc(c, p) 	((HANDLE_VERIFY(p, handleTypeFile) != OK) ? (EOF) : \
+			 (--(p)->_w < 0 ?				\
+			     (p)->_w >= (p)->_lbfsize ?			\
+				 (*(p)->_p = (c)), *(p)->_p != '\n' ?	\
+				     (int)*(p)->_p++ :			\
+				     __swbuf('\n', p) :			\
+				 __swbuf((int)(c), p) : 		\
+			     (*(p)->_p = (c), (int)*(p)->_p++)))
+
+#define	__sfeof(p)	((HANDLE_VERIFY(p, handleTypeFile) != OK) ? \
+			 (FALSE) : (((p)->_flags & __SEOF) != 0))
+
+#define	__sferror(p)	((HANDLE_VERIFY(p, handleTypeFile) != OK) ? \
+			 (FALSE) : (((p)->_flags & __SERR) != 0))
+
+#define	__sclearerr(p)	((void)((HANDLE_VERIFY(p, handleTypeFile) != OK) ? \
+				(0) : (((p)->_flags &= ~(__SERR|__SEOF)))))
+
+
+#define	getchar()	__sgetc(stdin)
+#define	getc(p)		__sgetc(p)
+#define	putchar(c)	(__sputc(c, (stdout)))
+#define	putc(c,p)	__sputc(c, p)
+#define	feof(p)		__sfeof(p)
+#define	ferror(p)	__sferror(p)
+#define	clearerr(p)	__sclearerr(p)
+
+#if _EXTENSION_POSIX_1003		/* undef for ANSI */
+#define	fileno(p)	__sfileno(p)
+#endif
+
+/* Razor extensions */
+extern int oprintf (FUNCPTR, int, const char *, ...);
+extern int kprintf (const char *, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCstdioh */
diff --git a/include/vbi/support/stdlib.h b/include/vbi/support/stdlib.h
new file mode 100644
index 0000000..2fdfc65
--- /dev/null
+++ b/include/vbi/support/stdlib.h
@@ -0,0 +1,109 @@
+/* stdlib.h - razor C standard library definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01a,04oct07,md   written
+*/
+
+#ifndef __INCstdlibh
+#define __INCstdlibh
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#else
+#include <sys/types.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#ifndef NULL
+#define NULL	0
+#endif
+
+#define EXIT_FAILURE 1
+#define EXIT_SUCCESS 0
+#define RAND_MAX 32767
+#define MB_CUR_MAX 1
+
+#define	OK	0
+#define	ERROR	(-1)
+
+#undef	TRUE
+#define	TRUE	1
+#undef	FALSE
+#define	FALSE	0
+
+#define EOS	'\0'	/* C string terminator */
+
+#ifndef	_ASMLANGUAGE
+
+extern double atof(const char *);
+extern int atoi(const char *);
+extern long atol(const char *);
+extern double strtod(const char *, char **);
+extern long strtol(const char *, char **, int);
+extern unsigned long strtoul(const char *, char **, int);
+extern int rand(void);
+extern int rand_r(unsigned int *);
+extern void srand(unsigned int);
+extern void *calloc(size_t, size_t);
+extern void free(void *);
+extern void *malloc(size_t);
+extern void *realloc(void *, size_t);
+#ifdef __VEC__
+extern void *vec_calloc(size_t, size_t);
+extern void vec_free(void *);
+extern void *vec_malloc(size_t);
+extern void *vec_realloc(void *, size_t);
+#endif
+
+extern void abort(void);
+extern int atexit(void (*)(void));
+extern void exit(int);
+extern char *getenv(const char *);
+extern int system(const char *);
+
+extern void *bsearch(const void *, const void *, size_t, size_t, int (*)(const void *, const void *));
+extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
+
+extern int abs(int);
+extern div_t div(int, int);
+extern long labs(long);
+extern ldiv_t ldiv(long, long);
+extern int mblen(const char *, size_t);
+extern int mbtowc(wchar_t *, const char *, size_t);
+extern int wctomb(char *, wchar_t);
+extern size_t mbstowcs(wchar_t *, const char *, size_t);
+extern size_t wcstombs(char *, const wchar_t *, size_t);
+
+#if !defined(__STRICT_ANSI__) || defined(__cplusplus)
+extern	long		a64l(const char *);
+extern	char *		l64a(long l);
+extern	double		drand48(void);
+extern	double		erand48(unsigned short *);
+extern	long		irand48(unsigned short);
+extern	long		jrand48(unsigned short *);
+extern	long		krand48(unsigned short *, unsigned short);
+extern	void		lcong48(unsigned short *);
+extern	long		lrand48(void);
+extern	long		mrand48(void);
+extern	long		nrand48(unsigned short *);
+extern	void		srand48(long);
+extern	unsigned short *seed48(unsigned short *);
+extern	char *		getpass(const char *);
+extern	int		putenv(char *);
+#endif /* __STRICT_ANSI__ */
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCstdlibh */
diff --git a/include/vbi/support/string.h b/include/vbi/support/string.h
new file mode 100644
index 0000000..cfd372b
--- /dev/null
+++ b/include/vbi/support/string.h
@@ -0,0 +1,76 @@
+/* string.h - string library header file */
+
+/* Copyright 2007-2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01b,21jul09,md   use size_t in prototypes
+01a,03oct07,md   written.
+*/
+
+#ifndef __INCstringh
+#define __INCstringh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "sys/types.h"
+
+#define	_EXTENSION_WRS	1
+
+extern void *	memchr (const void *__s, int __c, size_t __n);
+extern int 	memcmp (const void *__s1, const void *__s2, size_t __n);
+extern void *	memcpy (void *__s1, const void *__s2, size_t __n);
+extern void *	memmove (void *__s1, const void *__s2, size_t __n);
+extern void *	memset (void *__s, int __c, size_t __n);
+
+extern char *	strcat (char *__s1, const char *__s2);
+extern char *	strchr (const char *__s, int __c);
+extern int 	strcmp (const char *__s1, const char *__s2);
+extern int 	strcoll (const char *__s1, const char *__s2);
+extern char *	strcpy (char *__s1, const char *__s2);
+extern size_t 	strcspn (const char *__s1, const char *__s2);
+extern char *   strdup (const char * str);
+extern size_t 	strlen (const char *__s);
+extern char *	strncat (char *__s1, const char *__s2, size_t __n);
+extern int 	strncmp (const char *__s1, const char *__s2, size_t __n);
+extern char *	strncpy (char *__s1, const char *__s2, size_t __n);
+extern char *	strpbrk (const char *__s1, const char *__s2);
+extern char *	strrchr (const char *__s, int __c);
+extern size_t 	strspn (const char *__s1, const char *__s2);
+extern char *	strstr (const char *__s1, const char *__s2);
+extern char *	strtok (char *__s, const char *__sep);
+extern size_t 	strxfrm (char *__s1, const char *__s2, size_t __n);
+extern char *	strerror(int __errcode);
+
+#if _EXTENSION_POSIX_REENTRANT		/* undef for ANSI */
+extern char *	strtok_r (char *__s, const char *__sep, char **__ppLast);
+#endif
+
+#if _EXTENSION_WRS		 	/* undef for ANSI */
+extern int	strerror_r (int __errcode, char *__buf);
+extern void 	bcopy (const char *source, char *dest, size_t nbytes);
+extern void 	bcopyBytes (char *source, char *dest, size_t nbytes);
+extern void 	bcopyWords (char *source, char *dest, size_t nwords);
+extern void 	bcopyLongs (char *source, char *dest, size_t nlongs);
+extern void 	bfill (char *buf, size_t nbytes, int ch);
+extern void 	bfillBytes (char *buf, size_t nbytes, int ch);
+extern void 	bzero (char *buffer, size_t nbytes);
+extern int 	bcmp (char *buf1, char *buf2, size_t nbytes);
+extern void 	binvert (char *buf, size_t nbytes);
+extern void 	bswap (char *buf1, char *buf2, size_t nbytes);
+extern void 	uswab (char *source, char *destination, size_t nbytes);
+extern void 	swab (char *source, char *dest, size_t nbytes);
+extern char *	index (const char *s, int c);
+extern char *	rindex (const char *s, int c);
+extern size_t	strlcat (char *dst, const char *src, size_t siz);
+extern size_t   strlcpy (char *dst, const char *src, size_t siz);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCstringh */
diff --git a/include/vbi/support/sys/arch.h b/include/vbi/support/sys/arch.h
new file mode 100644
index 0000000..9223b9e
--- /dev/null
+++ b/include/vbi/support/sys/arch.h
@@ -0,0 +1,49 @@
+/* sys/arch.h - hypervisor architecture specific definitions */
+
+/* Copyright 2007-2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,06aug09,md   include wrhv arch specific file
+01f,15jul09,dtr  Add CPU PPCE500MC support.
+01e,20may09,md   add endian order type defines
+01d,17mar09,mpk  OCTEON port from drc
+01c,16jul08,gws  adding ARM cpu
+01b,04oct07,md   add cpu defines
+01a,06jul07,md   written.
+*/
+
+#ifndef __INCsysArchh
+#define __INCsysArchh
+
+#include <sys/cpu_types.h>
+
+/* endian types selectable by the arch specific header files */
+
+#define	__LITTLE_ENDIAN	1234	/* least-significant byte first		*/
+#define	__BIG_ENDIAN	4321	/* most-significant byte first		*/
+#define	__PDP_ENDIAN	3412	/* LSB first in word, MSW first in long	*/
+
+/* include the appropriate arch specific header file */
+
+#if (CPU == MIPSI64R2)
+# include <sys/mips64/arch.h>
+#elif (CPU == PPC85XX)
+# include <sys/ppc/arch.h>
+#elif (CPU == PPCE500MC)
+# include <sys/ppc/arch.h>
+#elif (CPU == PENTIUM)
+# include <sys/x86/arch.h>
+# include <sys/x86/wrhvArch.h>
+#elif (CPU == ARM1136)
+# include <sys/arm1136/arch.h>
+#endif
+
+/* ensure the arch has specified a byte ordering */
+
+#if !defined(__BYTE_ORDER)
+#error: Architecture has not defined a byte order!
+#endif
+
+#endif /* __INCsysArchh */
diff --git a/include/vbi/support/sys/cpu_types.h b/include/vbi/support/sys/cpu_types.h
new file mode 100644
index 0000000..5e4d4c9
--- /dev/null
+++ b/include/vbi/support/sys/cpu_types.h
@@ -0,0 +1,82 @@
+/* sys/cpu_types.h - hypervisor cpu architecture types */
+
+/* Copyright 2007-2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,15jul09,dtr  Add CPU PPCE500MC support.
+01f,04aug09,md   add _RType for each cpu arch
+01e,17mar09,mpk  OCTEON port from drc
+01d,16jul08,gws  adding ARM cpu
+01c,29feb08,md   move cpu specific stuff from types.h
+01b,09oct07,md   don't define if we're included by vxWorks
+01a,04oct07,md   written.
+*/
+
+#ifndef __INCsysCpuTypesh
+#define __INCsysCpuTypesh
+
+/* define the cpu types that we currently support */
+
+#define	PPC85XX		1
+#define	PENTIUM		2
+#define	ARM1136		3
+#define MIPSI64R2       4
+#define	PPCE500MC	5
+
+#ifndef _ASMLANGUAGE
+
+/* MIPS64R2 specific types */
+
+#if (CPU == MIPSI64R2)
+
+#define CPU_MIPS_32BIT ((CPU==_VX_MIPS32) || \
+			    (CPU==MIPSI2) || \
+			    (CPU==MIPSI32) || \
+			    (CPU==MIPSI32R2))
+
+#define CPU_MIPS_64BIT ((CPU==MIPS64) || \
+			    (CPU==MIPSI3) || \
+			    (CPU==MIPSI64) || \
+			    (CPU==MIPSI64R2))
+
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+
+#if	(CPU_MIPS_32BIT)
+typedef unsigned int	_RType;		/* registers are 32 bits */
+#elif	(CPU_MIPS_64BIT)
+typedef unsigned long	_RType;		/* registers are 64 bits */
+#else	/* CPU_MIPSxxBIT */
+#error "Invalid CPU value"
+#endif
+
+#endif /* CPU == MIPSI64R2 */
+
+/* PowerPC specific types */
+
+#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+typedef unsigned int	_RType;		/* register type */
+#endif
+
+/* Pentium specific types */
+
+#if (CPU == PENTIUM)
+typedef unsigned char	INSTR;		/* char instructions */
+					/* register type */
+#if defined (LP64)
+typedef unsigned long	_RType;
+#else
+typedef unsigned int	_RType;
+#endif
+#endif /* CPU == PENTIUM */
+
+#if (CPU == ARM1136)
+typedef unsigned long	INSTR;		/* 32 bit word-aligned instructions */
+typedef unsigned int	_RType;		/* register type */
+#endif
+
+#endif /* _ASMLANGUAGE */
+
+#endif /* __INCsysCpuTypesh */
diff --git a/include/vbi/support/sys/regs.h b/include/vbi/support/sys/regs.h
new file mode 100644
index 0000000..98ac7aa
--- /dev/null
+++ b/include/vbi/support/sys/regs.h
@@ -0,0 +1,35 @@
+/* sys/regs.h - hypervisor context registers */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01f,15jul09,dtr  Support CPU PPCE500MC.
+01e,17mar09,mpk  OCTEON port from drc
+01d,16jul08,gws  adding ARM cpu
+01c,04oct07,md   use local PowerPC register definitions
+01b,16jul07,md   use local x86 register definitions
+01a,06jul07,md   written.
+*/
+
+#ifndef __INCsysRegsh
+#define __INCsysRegsh
+
+#include <sys/cpu_types.h>
+
+/* include the appropriate arch specific header file */
+
+#if (CPU == MIPSI64R2)
+# include <sys/mips64/regs.h>
+#elif (CPU == PPC85XX)
+# include <sys/ppc/regs.h>
+#elif (CPU == PPCE500MC)
+# include <sys/ppc/regs.h>
+#elif (CPU == PENTIUM)
+# include <sys/x86/regs.h>
+#elif (CPU == ARM1136)
+# include <sys/arm1136/regs.h>
+#endif
+
+#endif /* __INCsysRegsh */
diff --git a/include/vbi/support/sys/types.h b/include/vbi/support/sys/types.h
new file mode 100644
index 0000000..f316eea
--- /dev/null
+++ b/include/vbi/support/sys/types.h
@@ -0,0 +1,359 @@
+/* sys/types.h - hypervisor data types */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01i,09sep09,mmi  remove vb_t type but instead use the definition in vbiTypes.h
+01h,29jun09,mmi  add vb_t
+01g,18may09,mpk  n32 changes
+01f,11may09,md   add hypervisor specific types
+01e,03apr09,mpk  build mips64 hypervisor using mips-wrs-linux-gnu compiler
+01d,18mar09,md   add pointer types
+01c,29feb08,md   add math type defines
+01b,09oct07,md   fix types when included from gcc
+01a,03oct07,md   written.
+*/
+
+#ifndef __INCsysTypesh
+#define __INCsysTypesh
+
+#ifdef CONFIG_WRHV
+#include "cpu_types.h"
+#else
+#include <sys/cpu_types.h>
+#endif
+
+/* don't define the types if we're building an assembler file */
+
+#if !defined(_ASMLANGUAGE)
+
+/* standard variable types */
+
+#if defined(__STDC__) || defined(__cplusplus)
+ typedef signed char int8_t;
+#else
+ typedef char int8_t;
+#endif
+typedef unsigned char uint8_t;
+typedef short int16_t;
+typedef unsigned short uint16_t;
+
+#if defined (LP64)
+typedef int 			fpos_t;
+typedef int 			wchar_t;
+typedef long unsigned int 	size_t;
+typedef int 			int32_t;
+typedef unsigned int 		uint32_t;
+typedef long 			int64_t;
+typedef unsigned long		uint64_t;
+#else
+typedef long 			fpos_t;
+typedef unsigned short   	wchar_t;
+typedef unsigned int 		size_t;
+typedef long 			int32_t;
+typedef unsigned long		uint32_t;
+typedef long long 		int64_t;
+typedef unsigned long long 	uint64_t;
+#endif
+
+typedef long 			intptr_t;
+typedef unsigned long   	uintptr_t;
+
+typedef struct {
+    int quot;
+    int rem;
+} div_t;
+
+typedef struct {
+    long quot;
+    long rem;
+} ldiv_t;
+
+typedef unsigned char u_char;
+typedef unsigned short u_short;
+typedef unsigned int u_int;
+typedef unsigned long u_long;
+
+typedef unsigned char uchar_t;
+typedef unsigned short ushort_t;
+typedef unsigned int uint_t;
+typedef unsigned long ulong_t;
+
+/* hypervisor specific types */
+
+typedef uint32_t ctx_t;		/* context id handle */
+typedef uint64_t timeout_t;	/* timeout specification */
+typedef int32_t  status_t;	/* operation/function status */
+typedef uint32_t clock_t;	/* clock rate specification */
+
+/* file system related types */
+
+#if defined (LP64)
+typedef unsigned long  dev_t;
+typedef unsigned long  ino_t;
+typedef signed   int   mode_t;
+typedef unsigned long  nlink_t;
+typedef unsigned short uid_t;
+typedef unsigned short gid_t;
+typedef unsigned long  time_t;
+typedef signed   long  blksize_t;
+typedef unsigned long  blkcnt_t;
+typedef signed   long  off_t;
+typedef signed   long  daddr_t;
+#else
+typedef unsigned int dev_t;
+typedef unsigned int ino_t;
+typedef unsigned int mode_t;
+typedef unsigned int nlink_t;
+typedef unsigned int uid_t;
+typedef unsigned int gid_t;
+typedef unsigned int time_t;
+typedef unsigned int blksize_t;
+typedef unsigned int blkcnt_t;
+typedef unsigned int off_t;
+typedef unsigned int daddr_t;
+#endif
+
+#ifdef LP64
+#define LONG_FMT "0x%llx"
+#else
+#define LONG_FMT "0x%lx"
+#endif
+
+/* VxWorks compatibility for importing source code */
+
+typedef unsigned int	UINT;
+typedef unsigned char	UINT8;
+typedef unsigned short	UINT16;
+typedef unsigned int	UINT32;
+typedef unsigned long	ULONG;
+typedef unsigned short	USHORT;
+typedef unsigned char	UCHAR;
+typedef signed char	INT8;
+typedef signed short	INT16;
+typedef signed int	INT32;
+typedef signed long	LONG;
+typedef signed short	SHORT;
+typedef int		BOOL;
+typedef int		STATUS;
+#ifdef __cplusplus
+typedef void (*VOIDFUNCPTR) (...);
+typedef int (*FUNCPTR) (...);
+#else
+typedef void (*VOIDFUNCPTR) ();
+typedef int (*FUNCPTR) ();
+#endif
+
+#define	IMPORT	extern
+#define	LOCAL	static
+#define	FAST
+
+#define _WRS_INLINE	static __inline__
+
+#endif /* _ASMLANGUAGE */
+
+/*
+ * stuff for limits.h
+ */
+#ifndef _ARCH_MB_LEN_MAX
+#define _ARCH_MB_LEN_MAX		1
+#endif
+
+#ifndef _ARCH_CHAR_BIT
+#define _ARCH_CHAR_BIT			8
+#endif
+
+#ifndef _ARCH_CHAR_MAX
+#define _ARCH_CHAR_MAX			127
+#endif
+
+#ifndef _ARCH_CHAR_MIN
+#define _ARCH_CHAR_MIN			(-127-1)
+#endif
+
+#ifndef _ARCH_SHRT_MAX
+#define _ARCH_SHRT_MAX			32767
+#endif
+
+#ifndef _ARCH_SHRT_MIN
+#define _ARCH_SHRT_MIN			(-32767-1)
+#endif
+
+#ifndef _ARCH_INT_MAX
+#define _ARCH_INT_MAX			2147483647
+#endif
+
+#ifndef _ARCH_INT_MIN
+#define _ARCH_INT_MIN			(-2147483647-1)
+#endif
+
+#ifndef _ARCH_LONG_MAX
+#define _ARCH_LONG_MAX			2147483647
+#endif
+
+#ifndef _ARCH_LONG_MIN
+#define _ARCH_LONG_MIN			(-2147483647-1)
+#endif
+
+#ifndef _ARCH_SCHAR_MAX
+#define _ARCH_SCHAR_MAX			127
+#endif
+
+#ifndef _ARCH_SCHAR_MIN
+#define _ARCH_SCHAR_MIN			(-127-1)
+#endif
+
+#ifndef _ARCH_UCHAR_MAX
+#define _ARCH_UCHAR_MAX			255
+#endif
+
+#ifndef _ARCH_USHRT_MAX
+#define _ARCH_USHRT_MAX			65535
+#endif
+
+#ifndef _ARCH_UINT_MAX
+#ifdef __STDC__
+#define _ARCH_UINT_MAX			4294967295u
+#else
+#define _ARCH_UINT_MAX			4294967295
+#endif
+#endif
+
+#ifndef _ARCH_ULONG_MAX
+#ifdef __STDC__
+#define _ARCH_ULONG_MAX			4294967295u
+#else
+#define _ARCH_ULONG_MAX			4294967295
+#endif
+#endif
+
+/*
+ * stuff for float.h
+ */
+#ifndef _ARCH_FLT_RADIX
+#define _ARCH_FLT_RADIX			2
+#endif
+
+#ifndef _ARCH_FLT_MANT_DIG
+#define _ARCH_FLT_MANT_DIG		24
+#endif
+
+#ifndef _ARCH_FLT_DIG
+#define _ARCH_FLT_DIG			7	/* not correct in ANSI spec.s */
+#endif
+
+#ifndef _ARCH_FLT_ROUNDS
+#define _ARCH_FLT_ROUNDS		1
+#endif
+
+#ifndef _ARCH_FLT_EPSILON
+#define _ARCH_FLT_EPSILON		1.19209290e-07F
+#endif
+
+#ifndef _ARCH_FLT_MIN_EXP
+#define _ARCH_FLT_MIN_EXP		(-125)
+#endif
+
+#ifndef _ARCH_FLT_MIN
+#define _ARCH_FLT_MIN			1.17549435e-38F
+#endif
+
+#ifndef _ARCH_FLT_MIN_10_EXP
+#define _ARCH_FLT_MIN_10_EXP		(-37)
+#endif
+
+#ifndef _ARCH_FLT_MAX_EXP
+#define _ARCH_FLT_MAX_EXP		128
+#endif
+
+#ifndef _ARCH_FLT_MAX
+#define _ARCH_FLT_MAX			3.40282347e+38F
+#endif
+
+#ifndef _ARCH_FLT_MAX_10_EXP
+#define _ARCH_FLT_MAX_10_EXP		38
+#endif
+
+#ifndef _ARCH_DBL_MANT_DIG
+#define _ARCH_DBL_MANT_DIG		53
+#endif
+
+#ifndef _ARCH_DBL_DIG
+#define _ARCH_DBL_DIG			15
+#endif
+
+#ifndef _ARCH_DBL_EPSILON
+#define _ARCH_DBL_EPSILON		2.2204460492503131e-16
+#endif
+
+#ifndef _ARCH_DBL_MIN_EXP
+#define _ARCH_DBL_MIN_EXP		(-1021)
+#endif
+
+#ifndef _ARCH_DBL_MIN
+#define _ARCH_DBL_MIN			2.2250738585072014e-308
+#endif
+
+#ifndef _ARCH_DBL_MIN_10_EXP
+#define _ARCH_DBL_MIN_10_EXP		(-307)
+#endif
+
+#ifndef _ARCH_DBL_MAX_EXP
+#define _ARCH_DBL_MAX_EXP		1024
+#endif
+
+#ifndef _ARCH_DBL_MAX
+#define _ARCH_DBL_MAX			1.7976931348623157e+308
+#endif
+
+#ifndef _ARCH_DBL_MAX_10_EXP
+#define _ARCH_DBL_MAX_10_EXP		308
+#endif
+
+#ifndef _ARCH_LDBL_MANT_DIG
+#define _ARCH_LDBL_MANT_DIG		53
+#endif
+
+#ifndef _ARCH_LDBL_DIG
+#define _ARCH_LDBL_DIG			15
+#endif
+
+#ifndef _ARCH_LDBL_EPSILON
+#define _ARCH_LDBL_EPSILON		2.2204460492503131e-16L
+#endif
+
+#ifndef _ARCH_LDBL_MIN_EXP
+#define _ARCH_LDBL_MIN_EXP		(-1021)
+#endif
+
+#ifndef _ARCH_LDBL_MIN
+#define _ARCH_LDBL_MIN			2.2250738585072014e-308L
+#endif
+
+#ifndef _ARCH_LDBL_MIN_10_EXP
+#define _ARCH_LDBL_MIN_10_EXP		(-307)
+#endif
+
+#ifndef _ARCH_LDBL_MAX_EXP
+#define _ARCH_LDBL_MAX_EXP		1024
+#endif
+
+#ifndef _ARCH_LDBL_MAX
+#define _ARCH_LDBL_MAX			1.7976931348623157e+308L
+#endif
+
+#ifndef _ARCH_LDBL_MAX_10_EXP
+#define _ARCH_LDBL_MAX_10_EXP		308
+#endif
+
+/*
+ * stuff for math.h
+ */
+#ifndef _ARCH_HUGH_VAL
+#define _ARCH_HUGH_VAL			_ARCH_DBL_MAX
+#endif
+
+
+#endif /* __INCsysTypesh */
diff --git a/include/vbi/support/sys/vmmu.h b/include/vbi/support/sys/vmmu.h
new file mode 100644
index 0000000..ec24eb8
--- /dev/null
+++ b/include/vbi/support/sys/vmmu.h
@@ -0,0 +1,304 @@
+/* sys/vmmu.h - hypervisor virtual MMU structure definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01e,12dec08,md   rename header files
+01d,21aug07,md   removed vxWorks.h
+01c,16may07,md   update defines and comments to match structure layout
+01b,24apr07,md   adjust fields to better match e500 pte
+01a,19apr07,md   written
+*/
+
+#ifndef __INCvmmuh
+#define __INCvmmuh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <wrhv.h>
+
+/*
+
+The vmmu virtual address space is restricted to 32 bits and is decoded using
+a level-1/level-2 page table.  The virtual address is decoded as follows:
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+		11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+
+
+Each page table entry is 8 bytes (2 words) and uses the following format:
+
+
+word 0 (32-bits):
+	
+	  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+	                                  6 7 8 9 0 1 2 3               
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+	 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+	 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+		V          - valid bit
+		Hypervisor - reserved for use by hypervisor
+		U0-U7      - user defined attributes
+		ERPN       - extended real page number bits
+		ATTR       - page attributes
+
+
+word 1 (32-bits):
+
+	  0                                19 20      23 2 2 2 2 2 2 3 3
+	                                                 4 5 6 7 8 9 0 1
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+	 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+	 |                                   |          | | |X|X|W|W|R|R|
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+		RPN        - real page number
+		R          - page referenced bit
+		C          - page changed bit
+		SX,SW,SR   - supervisor mode protection bits
+		UX,UW,UR   - user mode protection bits
+	
+*/
+
+#ifndef	_ASMLANGUAGE
+
+/* Page Table Entry Definition */
+
+typedef union vmmu_pte		/* vmmu pte format */
+    {
+    struct			/* Bit field description */
+	{
+	/* word 0 */
+
+	u_int v:1;		/* valid bit */
+	u_int hy:7;		/* reserved for use by hypervisor */
+	u_int rsvd1:8;		/* reserved */
+	u_int u0:1;		/* user attribute 0 */
+	u_int u1:1;		/* user attribute 1 */
+	u_int u2:1;		/* user attribute 2 */
+	u_int u3:1;		/* user attribute 3 */
+	u_int u4:1;		/* user attribute 4 */
+	u_int u5:1;		/* user attribute 5 */
+	u_int u6:1;		/* user attribute 6 */
+	u_int u7:1;		/* user attribute 7 */
+	u_int erpn:3;		/* extended real page number bits */
+	u_int w:1;		/* write thru/back */
+	u_int i:1;		/* cache inhibited */
+	u_int m:1;		/* memory coherent */
+	u_int g:1;		/* memory guarded  */
+	u_int e:1;		/* little endian bit */
+
+	/* word 1 */
+
+	u_int rpn:20;		/* real page number */
+	u_int rsvd2:4;		/* reserved */
+	u_int r:1;		/* page referenced bit */
+	u_int c:1;		/* page changed bit */
+	u_int ux:1;		/* user execute protection */
+	u_int sx:1;		/* supervisor execute protection */
+	u_int uw:1;		/* user write protection */
+	u_int sw:1;		/* supervisor write protection */
+	u_int ur:1;		/* user read protection */
+	u_int sr:1;		/* supervisor read protection */
+	} field;
+
+    struct 
+	{
+	u_int word0;		/* word 0 */
+	u_int word1;		/* word 1 */
+	} words;
+    } VMMU_PTE;
+
+/* Effective Address Definition */
+
+typedef union vmmuEffectiveAddr /* effective Address structure */
+    {
+    struct
+        {
+        u_int l1index:11;	/* Level 1 Index (2K) */
+        u_int l2index:9;	/* Level 2 Index (512) */
+        u_int po:12;		/* Page Offset (4K) */
+        } field;
+    void * addr;
+    } VMMU_EFFECTIVE_ADDR;
+
+/* Real Address Definition */
+
+typedef union vmmuRealAddress	/* Real Address Structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int rpn:20;           /* Real Page Number */
+        u_int po:12;            /* Page Offset */
+        }field;
+    void * realAddr;            /* Real Address */
+    } VMMU_REAL_ADDRESS;
+
+/* Level-1 descriptor definition */
+
+typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
+    {
+    struct                      /* Bit field desciption */
+        {
+        u_int l2ba:20;          /* Level 2 table Base Address */
+        u_int reserved:10;      /* Reserved */
+        u_int b:1;              /* Block translation */
+        u_int v:1;              /* Segment Valid bit */
+        } field;
+    u_int l1desc;               /* Level 1 descriptor */
+    } VMMU_LEVEL_1_DESC;
+
+/* Level-2 descriptor definition */
+
+typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
+    {
+    VMMU_PTE pte;		/* a full PTE entry */
+    } VMMU_LEVEL_2_DESC;
+
+/* Level-2 table pointer definition */
+
+typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int l2tb:20;          /* Level 2 Table Base */
+        u_int l2index:9;	/* Level 2 table Index */
+        u_int reserved:3;       /* Reserved */
+        } field;
+    VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
+    } VMMU_LEVEL_2_TBL_PTR;
+
+
+/* VMMU configuration system call paramter */
+
+typedef struct vmmuConfig
+    {
+    VMMU_LEVEL_1_DESC *addr;
+    u_int	  pageSize;
+    u_int	  contextId;
+    u_int	  vmmuNum;
+    } VMMU_CONFIG;
+
+#endif /* _ASMLANGUAGE */
+
+#ifndef	VMMU_PAGE_SIZE
+#define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
+#define	VMMU_RPN_SHIFT	12
+#endif
+#define	NVPAGES(x)		((x)/VMMU_PAGE_SIZE)
+
+/* VMMU protection attributes */
+
+#define	VMMU_PROT_SUPV_READ	0x00000001	/* supervisor read allowed    */
+#define	VMMU_PROT_USER_READ	0x00000002	/* user read allowed	      */
+#define	VMMU_PROT_SUPV_WRITE	0x00000004	/* supervisor write allowed   */
+#define	VMMU_PROT_USER_WRITE	0x00000008	/* user write allowed	      */
+#define	VMMU_PROT_SUPV_EXECUTE	0x00000010	/* supervisor execute allowed */
+#define	VMMU_PROT_USER_EXECUTE	0x00000020	/* user execute allowed	      */
+
+
+#define	VMMU_PROT_USER_RWX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE | \
+				VMMU_PROT_USER_EXECUTE \
+
+#define	VMMU_PROT_USER_RW	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE
+
+#define	VMMU_PROT_USER_RX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_EXECUTE
+
+#define	VMMU_PROT_SUPV_RWX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE | \
+				VMMU_PROT_SUPV_EXECUTE \
+
+#define	VMMU_PROT_SUPV_RW	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE
+
+#define	VMMU_PROT_SUPV_RX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_EXECUTE
+
+/* VMMU cache attributes */
+
+#define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
+#define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
+#define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
+#define	VMMU_CACHE_INHIBIT	0x00000008	/* cache inhibit 	*/
+#define	VMMU_CACHE_WRITETHROUGH	0x00000010	/* cache write through	*/
+#define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
+
+/* VMMU page table structure */
+
+#define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
+#define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
+#define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
+#define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
+
+/* address to level-1 table offset */
+
+#define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
+
+/* address to level-2 table offset */
+
+#define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
+
+/* offset within page */
+
+#define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
+
+/* address to logical block number */
+
+#define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
+#define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
+
+/* bit masks for PTE fields */
+
+/* word 0 */
+
+#define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
+#define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
+#define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
+
+/* word 1 */
+
+#define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
+#define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
+#define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
+#define	VMMU_PTE_RPN_MASK	0xfffff000	/* real page number */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvmmuh */
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
new file mode 100644
index 0000000..72588e2
--- /dev/null
+++ b/include/vbi/syscalls.h
@@ -0,0 +1,391 @@
+/* syscalls.h - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02v,04sep09,dtr  Add additional type of hyioctl call.
+02u,12aug09,dtr  Add defines for additional arg to vbiHyIoctl.
+02t,13jul09,dbt  stop using long for VTLB VBI system calls
+02s,16jul09,mmi  change NO_RESET to RESET and NO_DOWNLOAD to DOWNLOAD
+02r,13jul09,mmi  fix reset flag reset
+02q,13jul09,mmi  add VBI_VBMGMT_RESET_DOWNLOAD
+02p,06jul09,mmi  add vb managment syscall numbers
+02o,02jul09,mmi  update the interrupt sending options, fix textUpdate
+		 fast syscall number
+02n,23jun09,mmi  add VBI_VBMGM_RESTART
+02m,10jun09,mmi  add cache text update fast system call
+02l,29may09,mes  Fixed VBI_CTX_STATS to match HY_CTX_STATS
+02k,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02j,19mar09,mes  Fixed type of VBI_ERROR_CODE
+02i,02feb09,mmi  add name service system call
+02h,02mar09,mmi  fix header name define
+02g,24feb09,mmi  decouple vbi definitions from internal data, add vbMgmt API
+02f,19jan09,mmi  update msg API prototypes
+02e,12jan09,dtr  Add driver ioctl calls, remove legacy interrupt defns.
+02d,12dec08,md   rename header files
+02c,05dec08,mes  Removed shelf macros, added vbMgmt macros
+02b,01dec08,md   add VBI_IOAPICIOCTL_SEND options
+02a,21nov08,md   remove port and ED&R syscalls
+01z,20nov08,mmi  adtopt new naming convention
+01y,31oct08,dbt  Added vdkVtlbMmuOp hypercall.
+01x,16jun08,mmi  fix vdkBspIoctl prototype
+01w,19may08,gws  add vIoapicIoctl
+01v,18apr08,md   add extra arg to vdkHyioctl
+01u,11apr08,md   add EOI ioctl
+01t,06mar08,md   add debug shell ioctl
+01s,06dec07,foo  update hw ints
+01r,23nov07,foo  fix prototype, use basic types
+01q,25oct07,foo  updated with new vdk functions
+01p,27sep07,md   added exception profiling fields
+01o,26sep07,md   added profiling statistics and stats ioctl
+01n,10sep07,md   re-number hypervisor system calls
+01m,21aug07,md   added VDK_SYS_ctx_load_vmmu
+01l,05jul07,foo  added bspIoctl calls and defines
+01k,04jun07,md   added ctxctl and mmu system calls
+01j,17may07,ymz  added port syscall.
+01i,28may07,foo  update vdkInt prototype
+01h,18may07,md   add hypervisor ioctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed to vdk
+01e,10apr07,md   replace kprintf syscall with kputs and kputc
+01d,19mar07,foo  fix macro
+01c,17mar07,foo  modify definitions to all start with HY
+01b,15mar07,md   added interrupt system calls
+01a,09mar07,md   written
+*/
+
+#ifndef __INCsyscallsh
+#define __INCsyscallsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ *
+ *
+ * System call number encoding:
+ *
+ * 31                                                                        0
+ *
+ *  |               |               |        |               |               |
+ *  +---------------+---------------+        +---------------+---------------+
+ *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
+ *  +---------------+---------------+        +---------------+---------------+
+ *   ^ ^ ^         ^ ^                                                      ^
+ *   | | \--------/  \------------------------------------------------------/
+ *   | |      |                                |
+ *   | |      |                                |
+ *   | |      |                                +-- System call number
+ *   | |      |
+ *   | |      +-- Fast hypervisor system call number
+ *   | |
+ *   | +--------- Hypervisor system call
+ *   |
+ *   +----------- Fast hypervisor system call
+ *
+ *
+ *
+ *
+ */
+
+/* fast system call numbers handled by assembler code */
+
+#define	HY_FAST_SYSCALL_MASK	0x3f000000
+#define	HY_FAST_SYSCALL_SHIFT	24
+#define	HY_FAST_SYSCALL_BIT	0x80000000
+#define	HY_FAST_SYSCALL(x)	\
+    ((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+     HY_FAST_SYSCALL_BIT)
+
+/* C driven system calls */
+
+#define	HY_SYSCALL_MASK		0x00ffffff
+#define	HY_SYSCALL_SHIFT	0
+#define	HY_SYSCALL_BIT		0x40000000
+#define	HY_SYSCALL(x)	\
+    ((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+
+/* fast system calls */
+
+#define	VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush			*/
+#define	VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush	*/
+#define	VBI_SYS_dcache_flush	HY_FAST_SYSCALL(3) /* data cache flush		*/
+#define	VBI_SYS_ctx_load	HY_FAST_SYSCALL(4) /* context load		*/
+#define	VBI_SYS_int_enable	HY_FAST_SYSCALL(5) /* int enable		*/
+#define	VBI_SYS_cache_text_update		    \
+				HY_FAST_SYSCALL(6) /* cache text update		*/
+
+
+
+/* hypervisor services */
+
+#define	VBI_SYS_hyIoctl		 HY_SYSCALL(1)	/* hypervisor ioctl	     */
+#define	VBI_SYS_vmContextCreate	 HY_SYSCALL(2)	/* context create	     */
+#define	VBI_SYS_send		 HY_SYSCALL(3)	/* send a messages	     */
+#define	VBI_SYS_receive		 HY_SYSCALL(4)	/* receive a messages	     */
+#define	VBI_SYS_reply		 HY_SYSCALL(5)	/* reply to a messages	     */
+#define	VBI_SYS_panic		 HY_SYSCALL(6)	/* halt the system	     */
+#define	VBI_SYS_int 		 HY_SYSCALL(7)	/* deliver an interrupt	     */
+#define	VBI_SYS_int_controller_done HY_SYSCALL(8)/* done interrupt processing*/
+#define	VBI_SYS_ctxctl 	 	 HY_SYSCALL(9)	/* context control operation */
+
+/* VMMU operations */
+
+#define	VBI_SYS_vmmu_config 	HY_SYSCALL(10)	/* configure the virtual MMU */
+#define	VBI_SYS_vmmu_enable 	HY_SYSCALL(11)	/* enable the virtual MMU    */
+#define	VBI_SYS_vmmu_disable 	HY_SYSCALL(12)	/* disable the virtual MMU   */
+#define	VBI_SYS_vmmu_tlbload 	HY_SYSCALL(13)	/* load a VMMU TLB entry     */
+#define	VBI_SYS_vmmu_tlbflush 	HY_SYSCALL(14)	/* flush a VMMU TLB entry    */
+#define	VBI_SYS_ctx_load_vmmu	HY_SYSCALL(15)	/* load context with vmmu    */
+
+/* MMU operations */
+
+#define	VBI_SYS_mmu_attr_set	HY_SYSCALL(16)	/* set physical memory attr  */
+#define	VBI_SYS_mmu_attr_get	HY_SYSCALL(17)	/* get physical memory attr  */
+
+/* BSP specific interface */
+
+#define VBI_SYS_bspIoctl	HY_SYSCALL(18)	/* BSP specific opreration   */
+
+/* vbMgmt services */
+
+#define VBI_SYS_vbMgmt          HY_SYSCALL(20)
+
+/* Virtual IO APIC services */
+
+#define VBI_SYS_vIoapicIoctl	HY_SYSCALL(21)
+
+#define VBI_SYS_vbReset         HY_SYSCALL(22)	/* reset  vcores	*/
+#define VBI_SYS_vbRestart       HY_SYSCALL(23)	/* restart vcores	*/
+#define VBI_SYS_vbSuspend       HY_SYSCALL(24)	/* suspend vcores	*/
+#define VBI_SYS_vbResume        HY_SYSCALL(25)  /* Resume vcores	*/
+
+
+#define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
+
+/* debug facilities */
+
+#define	VBI_SYS_kputs		HY_SYSCALL(50)	/* print a string to the cons*/
+#define	VBI_SYS_kputc		HY_SYSCALL(51)	/* print a char to the cons  */
+#define VBI_SYS_ps		HY_SYSCALL(52)	/* process status display    */
+#define VBI_SYS_dbgShStart	HY_SYSCALL(53)	/* start debug shell	     */
+
+/* VTLB MMU operations */
+
+#define VBI_SYS_vtlb_op		HY_SYSCALL(55)	/* VTLB operation */
+
+/* Name services */
+
+#define VBI_SYS_ns_op		HY_SYSCALL(60)	/* Name service operation */
+
+/* remote board memory services */
+
+#define VBI_SYS_memWrite_op	HY_SYSCALL(70)	/* memory write service operation */
+
+#define VBI_SYS_memRead_op	HY_SYSCALL(71)	/* memory read service operation */
+
+
+/* remote board memory services */
+
+#define VBI_SYS_RegsWrite_op	HY_SYSCALL(72)	/* regs write service operation */
+
+#define VBI_SYS_RegsRead_op	HY_SYSCALL(73)	/* regs service operation */
+
+/* Max number of syscalls*/
+#define VBI_SYS_max 		(73 + 1)
+
+/* hyIoctl system call supported ioctl's */
+
+#define	VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define	VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define	VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define	VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define	VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define	VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define	VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define	VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+#define	VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
+#define	VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+
+/* vIoapicIoctl system call supported ioctl's */
+
+#define	VBI_IOAPICIOCTL_UNMASK	 1	/* unmask v io apic interrupt src */
+#define	VBI_IOAPICIOCTL_SEND	 2	/* inject a v io apic interrupt */
+#define	VBI_IOAPICIOCTL_EOI	 3	/* end of interrupt acknowledge */
+/* remove this after vbControl is working, we don't need a hypercall for it: */
+#define	VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
+
+/* VBI_IOAPICIOCTL_SEND options */
+
+#define	VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
+#define	VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
+#define	VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
+#define	VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
+#define	VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
+
+/* hyCtxctl system call supported operations */
+
+#define	VBI_CTXCTL_IDLE	 	1	/* make current context idle	*/
+
+/* MMU protection attributes */
+
+#define	VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define	VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define	VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+
+/* ETSEC MDIO supported ioctl's */
+#define VBI_BSPIOCTL_DRV_MDIO 1         /* mdio messages */
+
+/* system clock frequency query */
+#define VBI_BSPIOCTL_SYS_CLK 2
+
+#define	VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
+
+#define MDIO_READ 1
+#define MDIO_WRITE 2
+#define MDIO_INT_ENABLE 3
+#define MDIO_INT_DISABLE 4
+
+/* vbiHyIoctl for PADDR */
+#define VBI_HYIOCTL_PADDR_DMA        0x0 /* Default used for DMA */
+#define VBI_HYIOCTL_PADDR_PHYS       0x1 /* When absolute phys addr needed */
+
+/* vbMgmt commands */
+#define VBI_VBMGMT_ATTACH       1       /* Attach to VB for control */
+#define VBI_VBMGMT_DETACH       2       /* Detech from VB */
+#define VBI_VBMGMT_SUSPEND      3       /* Suspend/halt VB */
+#define VBI_VBMGMT_RESUME       4       /* Resume/start a VB */
+#define VBI_VBMGMT_RESET        5       /* Reset VB */
+#define VBI_VBMGMT_RESTART      6       /* Restart a VB */
+
+/* vbMgmt error codes */
+#define VBI_ERROR_CODE              int32_t
+#define VBI_ERR_GENERAL             -101   /* General error */
+#define VBI_ERR_INVALID_ARG         -102   /* General error */
+
+/* vbMgmt reset macros */
+#define VBI_VBMGMT_RESET_DOWNLOAD	    0x00000001     /* disable ELF reloading */
+#define VBI_VBMGMT_RESET_CLEAR		    0x00000002     /* do not clear memory */
+#define VBI_VBMGMT_RESET_AND_START_CORE0    0x00000004
+
+/* target vb options */
+
+#define VBI_VB_CORES_ALL	(0x80000000)		    
+#define VBI_VB_CORES_OTHERS	(0x40000000)
+
+/* VTLB operation command and flags (intel-vt specific) */
+
+#define	VBI_VTLB_OP_UPDATE_PMD		1
+#define	VBI_VTLB_OP_UPDATE_PTE		2
+#define	VBI_VTLB_OP_DELETE_PMD		3
+#define VBI_VTLB_OP_SET_PTE_AT		4
+#define	VBI_VTLB_OP_SET_PTE		5
+#define	VBI_VTLB_OP_FLUSH_OPS		6
+#define	VBI_VTLB_OP_INIT		7
+
+/* VTLB macros */
+
+#define	VBI_VTLB_OP_MAX_OPS		100
+#define	VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
+
+/* VTLB optimization supported options */
+
+#define	VBI_VTLB_OPTIM_ENABLED			1
+#define	VBI_VTLB_CR3_CACHE_ENABLED		2
+#define	VBI_VTLB_OPS_CACHE_ENABLED		4
+#define	VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
+
+/* vbiNsOp system call supported operations */
+
+#define	VBI_NS_REGISTER		1	/* register service name    */
+#define	VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define	VBI_NS_LOOKUP	        3	/* look up service name	    */
+
+#ifndef	_ASMLANGUAGE
+
+/* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
+
+typedef struct {
+    unsigned long ctx_type;          /* type of context (user, supv, etc) */
+    unsigned long switchin;          /* number of times switched in       */
+    unsigned long pended;            /* number of times in pend state     */
+    unsigned long tsCtxSwitchOutH;   /* timestamp: context switch (high)  */
+    unsigned long tsCtxSwitchOutL;   /* timestamp: context switch (low)   */
+    unsigned long tsCtxSwitchInH;    /* timestamp: context switch (high)  */
+    unsigned long tsCtxSwitchInL;    /* timestamp: context switch (low)   */
+    unsigned long tsCtxExcInH;	   /* timestamp: exception entry (high) */
+    unsigned long tsCtxExcInL;	   /* timestamp: exception entry (low)  */
+    unsigned long reset;            /* number of times context reset */
+} VBI_CTX_STATS;
+
+/* VTLB operation structures (x86 specific) */
+
+typedef struct vbi_vtlb_op		/* VTLB operation */
+    {
+    uint32_t		op;		/* VTLB operation id */
+    uint32_t		arg1;		/* VTLB operation arg 1 */
+    uint32_t		arg2;		/* VTLB operation arg 2 */
+    uint32_t		arg3;		/* VTLB operation arg 3 */
+    } VBI_VTLB_OP;
+
+typedef struct vbi_vtlb_cr3_cache
+    {
+    uint32_t		guest_cr3;	/* Guest CR3 register */
+    uint32_t		host_cr3;	/* Host CR3 register */
+    } VBI_VTLB_CR3_CACHE;
+    
+typedef struct vbi_vtlb_control
+    {
+    uint32_t		size;		/* VTLB Control structure size */
+    uint32_t		mode;		/* VTLB module */
+    uint32_t		vtlb_ops_ix;	/* VTLB operation index */
+    VBI_VTLB_OP		vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
+    uint32_t		cr3_cache_ix;	/* CR3 cache index */
+    VBI_VTLB_CR3_CACHE	cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES]; /* cr3 cache*/
+    } VBI_VTLB_CONTROL;			/* VBI VTLB control */
+
+/*
+ * Control structure used by vbiVbMgmt for commands memory read, memory write, 
+ *  register read, and register write.
+ */
+
+typedef struct vbMgmtCtl 
+    {
+    union 
+	{
+	struct 
+	    {
+	    uint32_t *pBuffer;  /* address of target context */
+	    uint32_t *pAddress; /* address of calling context */
+	    uint32_t size;	/* number of total bytes */
+	    uint32_t width;	/* bus width in bytes */
+	    } vbMgmtMem;
+	struct 
+	    {
+	    uint32_t *pBuffer;  /* address of target context */
+	    uint32_t regSet;	/* register set */
+	    uint32_t reg;	/* macro to specify register */
+	    uint32_t size;	/* number of total bytes */
+	    } vbMgmtReg;
+	} data;
+    } VBMGMT_CTL;
+
+typedef uint32_t VBMGMT_HANDLE;
+typedef uint32_t VBI_NS_HANDLE;
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCsyscallsh */
diff --git a/include/vbi/vbInterface.h b/include/vbi/vbInterface.h
new file mode 100644
index 0000000..7e036c4
--- /dev/null
+++ b/include/vbi/vbInterface.h
@@ -0,0 +1,836 @@
+/* vbInterface.h - virtual board interface header file */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02r,09sep09,mmi  include vbi types header file
+02q,28aug09,mmi  use a different wrapper header vbiArch.h for VBI and HV
+02p,26aug09,mmi  fix WIND00178026: update copyright dates
+02o,06aug09,dtr  Modify status intPending to intPendingType as per docs.
+02n,03jul09,mmi  rename version flags
+02m,16jun09,mmi  make vioapic field a pointer, move bootCount field to VB_STATUS
+02l,08jun09,mmi  fix apigen syntax
+02k,08jun09,mmi  update descriptions
+02j,22may09,md   adjust fields for 64-bit
+02i,22may09,mpk  use exception Stack for running Privileged VBI calls
+02h,14may09,md   add per-core private memory page
+02g,18may09,mpk  64-bit hypervisor, 32-bit Virtual Board
+02f,29apr09,mpk  move syscalls.h include to vbi.h
+02e,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02d,21apr09,md   add SMP guest information
+02d,17apr09,mpk  64-bit hypervisor, and supervisor vbi calls
+02c,29jan09,dtr  Fix reg offset macros.
+02b,28jan09,mmi  merge arch registers in vb status struct, use arch specific
+		 define for vioapic size, put regs struct at the beginning
+02a,22jan09,mmi  add ctypes.h
+01z,22jan09,mmi  abstract arch specific registers
+01y,23dec08,mmi  move vb function prototypes to vbMgr.h
+01x,14dec08,mmi  define VB_PRINTF to printf for vxWorks
+01w,12dec08,mmi  replace RAZOR name reference to WRHV
+01v,11dec08,mmi  use typedef instead of native types
+01u,02dec08,mmi  remove obsolete API definitions
+01t,19nov08,dtr  Remove interrupt controller.
+01s,03oct08,dbt  Added tickCount to VB_STATUS.
+01r,01aug08,md   add tracking of region data type
+01q,19may08,gws  add virtual IO APIC
+01p,23nov07,foo  add boot defines
+01o,08nov07,md   add bootline support
+01n,09nov07,foo  remove includes
+01m,25oct07,foo  updated for hardware interrupts
+01l,09oct07,md   add emulated srr1 register
+01k,04oct07,md   include sys/cpu_types.h
+01j,11sep07,md   added emulated MSR register for PPC
+01i,23aug07,md   added vmmu and PPC volatile regs to control page
+01h,25jul07,md   added memory aliasing information
+01g,29may07,ymz  added port support.
+01f,25may07,foo  updated for inter-board interrupts
+01e,17may07,foo  updated for improved interrupt delivery
+01d,23apr07,foo  added fields for user mode virtual boards and interrupts
+01c,16mar07,foo  renamed RAZOR_CPU to CPU 
+01b,16mar07,foo  update for generalized interface and interrupt delivery
+01a,15feb07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module defines the data structures used for information flow between
+wind river Hypervisor and a Virtual Board. There are three structures employed
+for this purpose: 
+\ms
+\m - 
+ configuration 
+\m - 
+ status 
+\m -
+ control
+\me
+
+The configuration structure is the first data exchanged between a given virtual 
+board and Hypervisor kernel. The pointers to the status and control structures are
+derived from the configuration structure. It contains pointers to the status, 
+control and other information about resources assigned to a virtual board. 
+The configuration data is shared accross the cores in the same virtual board unlike
+the data in the control and status structure which may be different for each core.
+The information in the configuration structure is static in the sense that the data
+it contains remain unmodified at least during the life of a boot cycle.
+
+The status structure is used to inform a virtual core at runtime about the state it
+is excecuting (interrupts, vmmu, elapsed time etc...). 
+
+The control structure is put in place as a fast method to pass information from
+the VB to Hypervisor or vis-versa. For examples during a virtual board context
+switch the control structure allows to store the incoming virtual board context
+setting before the virtual board sends a Hypercall using VBI_CTX_LOAD().
+
+Hypervisor passes (as parameter) a pointer of the configuration structure to the 
+entry function of the virtual core and a boot option flag. 
+
+The VBI library provides a initialization function vbiInit() to ensures that 
+Hypervisor version number is compatible with the VBI library in use. If the versions
+match then the configuration, status and control pointers are stored respectively to
+wrhvVbConfig, wrhvStatus and wrhvVbControl. 
+
+Therefore a virtual board must always call vbiInit() before accessing any data
+provided by Hypervisor nor send a hypercall to it. Refer to to vbiInit() description in the VBI API description document for more information. 
+
+Once the VBI library is initialized the virtual board should employ the provided 
+macros in order to access the fieds in wrhVbConfig, wrhvVbStatus and wrhvVbControl
+data structures. Accessing these structures via the VBI function guaranties source
+level compatibily between VBI versions.
+
+A guest OS should port vbiInit(), the access macros along with the necessary header
+files where the data structrures layout is defined.
+ To be aware:
+\ms
+\m -
+ Changing the order of the field this structure may have serious impact on the
+ integrity of the system. It exists hand crafted macros to match the C
+ structures offset. Therefore any change should be reflected in the macros
+ 
+\m -
+ When a virtual core boots the VMMU is not enbled but a programmer may choose
+ to turn-on the VMMU. In that scenario proper care must be taken to ensure that
+ the address where the control, status or configureation structure is reflected
+ in the VMMU mapping. Technically these area should be treated as I/O region
+ therefore it is encouraged that they are identity mapped.  
+\me
+
+\APPEND vbi/vbi.h
+
+*/
+
+#ifndef __INCvbInterfaceh
+#define __INCvbInterfaceh
+
+#ifdef CONFIG_WRHV
+#include "vbiTypes.h"
+#include "vbiArch.h"
+#else
+#include <vbiTypes.h>
+#include <vbiArch.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* VB versioning information */
+
+#define	VBI_VERSION_MAJOR	2	/* major version */
+#define	VBI_VERSION_MINOR	0	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+/* macro to align guest fields for a 64-bit hypervisor */
+
+#if defined(LP64)
+# define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			   __attribute__(( aligned(8) )) \
+			   decl_var
+#else
+# if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    decl_var; \
+			    uint32_t pad_var
+# else
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    uint32_t pad_var; \
+			    decl_var
+# endif
+#endif
+
+#ifdef PRJ_BUILD
+# define VB_PRINTF(fmt, args...)    printf(fmt, ##args)
+#else
+# define VB_PRINTF(fmt, args...)    kprintf(fmt, ##args)
+#endif
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+# define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
+#else
+# define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+
+/* Configuration Filename for the hypervisor this must not change */
+
+#define VB_WRHV_CONFIGURATION_FILE "wrhvConfig.xml"
+
+/* Hard limits for now */
+
+#define VB_MAX_VIRTUAL_BOARDS    1024
+#define VB_MAX_BUSES             1024
+
+#define VB_MAX_CORES     	 8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+
+#define VB_MAX_WRHV_NAME_LENGTH 64
+
+#ifndef	_ASMLANGUAGE
+typedef int8_t VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
+
+#define VB_MAX_BOOTLINE_LENGTH   256
+
+/* Virtual board timestamp is 64 bits */
+
+typedef uint64_t VB_TIMESTAMP;
+#endif
+
+/* Virtual Interrupt Controller definitions --------------------------- */
+
+/* 32 is chosen as the maximum number of interrupt sources allowed.
+ * care must be taken if this is changed, since some algorithms and
+ * data structures will require modifications and become more complex
+ */
+
+#define VB_MAX_INTERRUPTS     32
+
+/* The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+
+#define VB_MAX_INTERRUPT_DATA 16
+
+/* Structure offsets for assembler */
+
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+# define VB_CONTROL_REG_STRUCT_END 0
+#endif
+
+# define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#else
+# define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+/* Assembler offsets for VB_STATUS */
+
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+# define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#else
+# define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Assembler offsets for VB_CONFIG */
+
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+# define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+# define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+# define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+# define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#else
+# define VB_CONFIG_VBSTATUS		((2+0) * 8)
+# define VB_CONFIG_VBCONTROL		((2+1) * 8)
+# define VB_CONFIG_SMINFO		((2+2) * 8)
+# define VB_CONFIG_MEMINFO		((2+3) * 8)
+# define VB_CONFIG_INTINFO		((2+4) * 8)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Defines for vbIntInfo intDirection field */
+
+#define VB_INPUT_INT  1
+#define VB_OUTPUT_INT 2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by Razor
+ */
+
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+#ifndef VB_VIOAPIC_ENTRIES_SIZE
+#define VB_VIOAPIC_ENTRIES_SIZE 64
+#endif
+
+#ifndef	_ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_CONTROL - Virtual board cores control structure 
+*
+* VB_CONTROL is a data type that defines a virtual core's control structure.
+* This is called the control structure because a core uses to modify it's 
+* state. The code running in the context of a virtual core puts the desired
+* setting in this control and passes to Hypervisor via the Hypercall mechanism.
+* It is suggested to use the provided APIs for manipulating the virtual core
+* control structure instead of directly accessing it's members. 
+* Typically use cases for this structure are for following:
+*\ms
+*\m - 
+* During context switch for setting the incoming context's register state.
+* For more information about this refer to VBI_CTX_LOAD() description in the
+* architecture supplement API documentation.
+*\m -
+* Locking/unlocking the virtual core interrupts.
+*\m -
+* Loading the VMMU configuration data.
+*\m -
+* VIOAPIC configuration registers.
+* 
+*\me   
+* The control structure definition is generic accross the various architecture
+* flavours supported by Hypervisor with the exception of the emulated registers. 
+* There is an architecture specific extention available via a pointer of type 
+* VB_ARCH_STATUS_REGS to accomodate the registers unique for a given hardware
+* platform.
+* However that does imply that other fields defined in this structure are used
+* in every architecture. A field is considered generic if it is usefull at least to
+* two CPU families but not necessary to all CPUs.
+* The VIOAPIC is the only field that is meaning full accross all architectures.
+* Note that some architectures like Intel with VT technology don't require emulated
+* registers. The pointer of emulated registers is included only if 
+*_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
+* with read/write access attribute for the purpose of serving as duplex 
+* communication channel between Hypervisor and a virtual core. This mechanism
+* is fall back when it is not possible to use registers for transmitting data
+* from the virtual core to Hypervisor or vis-versa. More information about 
+* VB_ARCH_CONTROL_REGS may be found in the architecture supplement document.
+*
+* 
+* Control structure graphical illustration
+*\cs
+*    ______________
+*   |              |
+*   |              |<------- 64bits - pointer to arch specific registers 
+*   |              |          (See architecture supplement documentation)         
+*   |--------------|
+*   |              |<------- 32bits -  interrupt state flag
+*   |--------------|
+*   |              |<------- 32bits - virtual core to be loaded context's 
+*   |--------------|                  interrupt state    
+*   |              | 
+*   |              |<------- 64bits - pointer to VMMU configuration
+*   |--------------|
+*   |              |<------- 64bits - pointer to additional VMMU 
+*   |              |                  configuration (reserved for enhancement)  
+*   |--------------|
+*   |              | <------ 64bits - VIOAPIC information header (internal use only)
+*   |              |
+*   |--------------|
+*   |		   |
+*   |              |<------- Nbytes - VIOAPIC redirection table    
+*   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE   
+*   |              |
+*   |--------------|<------- 32bits - Pending interrupt vector number  
+*   |______________|            
+*\ce
+*
+* SYNOPSIS
+*
+* Virtual core's control C data structure type definition
+*\cs
+* typedef struct vbControl {
+*
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbControlRegs.
+*     @/
+*
+*#ifdef  _WRHV_ARCH_HAS_CTRL_REGS         
+*    VB_ALIGN_FIELD_64 (VB_ARCH_CONTROL_REGS  * vbControlRegs, pad1);
+*#endif
+*
+*   /@  0: -1 => Disable all interrupts					@/
+*
+*    uint32_t	intDisable;	
+*
+*   /@ 
+*    @ future interrupt state of a context to be loaded in 
+*    @ vbControl->intDisable after a context switch	    
+*    @/
+*
+*    uint32_t	newIntDisable;	
+*
+*   /@  2: VMMU 0 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*
+*   /@  3: VMMU 1 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*   /@ Virtual I/O APIC							@/
+*
+*    VB_ALIGN_FIELD_64 (uint32_t    vIoapicRegisters[VB_VIOAPIC_SIZE], pad4);
+*
+*   /@ actual virtual interrupt pending					@/
+*
+*    uint32_t	intPending;
+*
+*   } VB_CONTROL;
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*
+* INTERNAL
+* warning!!!!!!!
+* 1. Any modification of this structure field should be reflected in the
+* description.
+* 2. Make sure that VIOAPIC_SIZE is used in the structure
+* 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
+*     the code
+*\COMMAND 
+*/
+
+typedef struct vbControl {
+
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	      
+    VB_ARCH_CONTROL_REGS  vbControlRegs;
+#endif
+
+    uint32_t	intDisable;	/*  0: -1 => Disable all interrupts */
+    uint32_t	newIntDisable;	/*  1: New value for vbControl->intDisable */
+
+				/*  2: VMMU 0 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+
+				/*  3: VMMU 1 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    uint32_t	intLevelDisable;/* interrupt level enabling */
+
+    /* Virtual I/O APIC */
+
+    VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
+
+    /* actual virtual interrupt pending */
+
+    uint32_t	intPending;
+
+} VB_CONTROL;
+
+
+/*******************************************************************************
+*
+* VB_STATUS - Virtual board's core status structure
+*
+* VB_STATUS is a C data type structure that provides the definition of an area
+* where the state of a given core is posted by Hypervisor before a virtual core is 
+* scheduled to run. The fields of this structure are architecture agnostic. 
+* A pointer is provided to accomodate anything that is specific to the underlying
+* hardware. The architecture specific structure is included only if 
+* _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type  VB_STATUS_ARCH_REGS
+* holding the architecture dependent registers is defined by a file pulled
+* vbi/vbiArch.h at compile type according to CPU value.
+* The definition of VB_ARCH_STATUS_REGS can be found in the architecture
+* supplement documentation.
+* The purpose of this structure is to inform a virtual core at runtime the
+* status of a core's time variant data such as:
+*\ms
+*\m - 
+* Interrupts state
+*\ms
+*\m *
+* current interrupt state
+*\m *
+* previous interrupt state if the core is in an ISR context
+*\m *
+* The pending vector number if any
+*\me
+*\m -
+* A free running clock timestamp
+*\m -
+* Virtual core elapsed timer ticks
+*\m -
+* Current VMMU configuration
+*\me
+*  
+* SYNOPSIS
+*
+* Control structure graphical illustration
+*\cs
+*        _______________   
+*       |		|	
+*       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
+*       |		|		structure pointer
+*       |---------------|
+*       |		|<-------32bits - intPending; pending vector number
+*       |---------------|
+*       |///////////////|<-------32bits - Reserved for future enhencements
+*       |---------------|
+*       |		|<-------64bits - timeStamp; free running clock ticks
+*       |		|
+*       |---------------|
+*       |		|<-------32bits - oldIntDisable; interrupt state before
+*       |---------------|		   an interrupt was injected
+*       |		|<-------32bits - 
+*       |---------------|
+*       |		|
+*       |		|<-------64bits - vmmu0; current VMMU configuration
+*       |---------------|
+*       |		|<-------64bits - vmmu1; reserved for future use
+*       |		|
+*       |---------------|
+*       |		|<-------64bits - tickCount; elapsed virtual core ticks
+*       |		|
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbStatus {
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbStatusRegs
+*     @/
+*
+* #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+*    VB_ALIGN_FIELD_64 (VB_ARCH_STATUS_REGS  vbStatusRegs, pad1);
+* #endif
+*
+*    /@ Bits indicating which interrupts are pending			    @/
+*
+*    uint64_t	intPendingType;
+*
+*    /@ reserved field for future use, required for timeStamp alignment	    @/
+*
+*    uint32_t	reserved1;
+*
+*    /@ Timestamp when last interrupt was delivered			    @/
+*
+*    VB_TIMESTAMP timeStamp;  
+*
+*    /@ 
+*     @ Interrupt registers when the hypervisor interrupts a virtual board, 
+*     @ it saves the following information here for use by the virtual board.
+*     @/
+*
+*    /@ value of control->intDisable at time of the interrupt.
+*     @ control->intDisable is set to -1 by WRHV at the time of delivery of
+*     @ the interrupt
+*     @/
+*
+*    uint32_t	oldIntDisable; 
+*
+*    /@ VMMU tables which were active when an MMU exception occurred	    @/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*    /@ VB wall clock time expressed in the VB clock frequency  @/
+*
+*    uint64_t tickCount;
+*
+* } VB_STATUS;
+*\ce
+*
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+* INTERNAL
+* Make sure that intPendingType modification is reflected in the code
+*
+*\COMMAND
+*/
+
+typedef struct vbStatus {
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    VB_ARCH_STATUS_REGS  vbStatusRegs;
+#endif
+
+    /* Bits indicating which interrupts are pending */
+
+    uint32_t	intPendingType;
+
+    /* reserved field for future use, required for timeStamp alignment */
+
+    uint32_t	reserved1;
+
+    /* Timestamp when last interrupt was delivered */
+
+    VB_TIMESTAMP timeStamp;  
+
+    /* Interrupt registers
+     *
+     * When the hypervisor interrupts a virtual board, it saves the following
+     * information here for use by the virtual board.
+     */
+
+    /* value of control->intDisable at time of the interrupt.
+     * control->intDisable is set to -1 by WRHV at the time of delivery of
+     * the interrupt
+     */
+
+    uint32_t	oldIntDisable; 
+
+    /* VMMU tables which were active when an MMU exception occurred */
+
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    /* Virtual Board clock tick count */
+
+    uint64_t tickCount;
+
+    /* number of times this core has booted */
+
+    uint32_t	 bootCount;	 
+
+    /* initial program load flag */
+
+    uint32_t	 ipl;	 
+
+    /* The simulatror flag  */
+
+    uint32_t	 sim;	 
+
+} VB_STATUS;
+
+/*
+ * ----------------------- Virtual BOARD STATUS PAGE -----------------------
+ *
+ * Read only page used to provide static configuration to the Virtual Board
+ *
+ */
+
+/* Configuration information for interrupts */
+
+typedef struct vbIntInfo {
+    VB_WRHV_NAME intName;	/* the name of this interrupt */
+    uint16_t	 intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
+    uint16_t	 intNumber;	/* the local VB interrupt number */
+    uint32_t	 intCore;	/* the receiving core for this incomming int */
+} VB_INT_INFO;
+
+/* Information about a shared memory region */
+
+typedef struct vbSmInfo {
+    VB_WRHV_NAME name;		/* the name of the shared memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    uint32_t	 type;		/* shared memory type field */
+				/* id's of connected boards */
+    VB_ALIGN_FIELD_64 (void *boardIds, pad2);
+} VB_SM_INFO;
+
+/* Information for the memory map info */
+
+typedef struct vbMemInfo {
+    VB_WRHV_NAME name;		/* the name of the memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    VB_WRHV_NAME type;		/* the type of the region */
+} VB_MEM_INFO;
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+
+typedef struct vbConfig {
+
+    /* 
+     *  structure versioning information
+     *  --------------------------------
+     */
+
+    uint32_t major;	/* major revision number */
+    uint32_t minor;	/* minor revision number */
+    uint32_t maint;	/* maintenance revision number */
+    uint32_t pad;
+
+    /* 
+     *  pointers to secondary configuration structures
+     *  ----------------------------------------------
+     */
+
+    /* read-only status information */
+
+    VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
+
+    /* read-write control information */
+
+    VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
+
+    /* shared memory information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
+
+    /* memory regions information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
+
+    /* information about incoming and outgoing interrupt connections */
+
+    VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
+
+    /* 
+     *  general board specific configuration information
+     *  ------------------------------------------------
+     */
+
+    uint32_t	 pid;		 /* hypervisor context id */
+    vbiVb_t	 boardID;	 /* board ID from the XML configuration */
+
+    int32_t	 supervisoryMode;/* board is running in privileged mode */
+
+    VB_WRHV_NAME boardName;	 /* the name of this board */
+    uint32_t	 boardType;	 /* the type of this board */
+    uint32_t	 bootCount;	 /* number of times this core has booted */
+
+				 /* entry point for this VB */
+    VB_ALIGN_FIELD_64 (void *resetPC, pad6);
+
+    /* 
+     *  virtual core specific information
+     *  ---------------------------------
+     */
+
+    uint32_t  coreId;		  /* virtual core cpu id */
+    uint32_t  numCores;		  /* number of virtual cores */
+    uint32_t  corePrivateSize;	  /* size of core private memory */
+				  /* pointer to core private memory */
+    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+
+    /* 
+     *  main memory configuration settings 
+     *  ----------------------------------
+     */
+
+    uint32_t  physicalMemorySize; /* the vbPhysical size of RAM */
+    uint32_t  memoryAliasAddress; /* address to which memory is aliased */
+    uint32_t  memoryAliasSize;	  /* size of aliases memory */
+    uint32_t  numMem;		  /* number of memory regions */
+
+    /* 
+     *  shared memory configuration settings
+     *  ------------------------------------
+     */
+
+    /* number of shared memory regions */
+
+    uint32_t  numSm;
+
+    /* shared memory state information */
+
+    VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
+
+    /* 
+     *  clock and interrupt configuration
+     *  ---------------------------------
+     */
+
+    /* the frequency of the periodic tick interrupt */
+
+    uint32_t  tickTimerFrequency;	/* ticks per second */
+
+    /* the frequency of the timestamp */
+
+    uint32_t  timeStampFrequency;	/* ticks per second */
+
+    /* number of interrupts connected to this board */
+
+    uint32_t  numInts;
+
+    /* 
+     *  misc settings
+     *  -------------
+     */
+
+    /* OS specific boot line */
+
+    char      bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+    /* spare 32-bit fields for future use */
+
+    uint32_t	spare32[16];
+
+    /* spare 64-bit fields for future use */
+
+    uint64_t	spare64[16];
+
+    /* direct function call interface table */
+
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+    VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
+    VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
+#endif
+
+} VB_CONFIG;
+
+#ifndef __INCvxWorksh 
+extern int kprintf (const char *, ...);
+#else
+extern int printf (const char *, ...);
+#endif 
+
+#endif /*_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbInterfaceh */
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
new file mode 100644
index 0000000..a8dcbaf
--- /dev/null
+++ b/include/vbi/vbi.h
@@ -0,0 +1,1015 @@
+/* vbi.h - virtual board support definitions */
+
+/*
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+
+/*
+modification history
+--------------------
+01y,12aug09,dtr  Add standard address translation functions.
+01x,06aug09,dtr  Update VBI_INT_VCORE_PENDING docs and status->intPending
+                 to intPendingType.
+01w,14jul09,mmi  VBI_OLD_INT_DISABLE_GET() renamed to
+                 VB_INT_CORE_PREVSTATE_GET()
+01v,13jul09,mmi  fix mem alias address get macro
+01u,13jul09,mmi  fix VIOAPIC base address macro
+01t,03jul09,mmi  add vbi private memory base address get macro
+01s,12jun09,mmi  update macro's and comments
+01r,11jun09,mmi  update interrupt macros
+01q,09jun09,mmi  put back wrhvVbIntNested
+01p,08jun09,mmi  vbi 2.0 update
+01p,08jun09,md   add core number to panic message
+01o,26may09,mmi  add apigen description
+01n,07apr09,mpk  MIPS64 hypervisor, mips-wrs-linux-gnu compiler support
+01m,25feb09,mmi  remove vbiMsg.h
+01l,29jan09,mmi  add VB_PANIC
+01k,23jan09,mmi  add vbiMsg.h
+01j,23dec08,mmi  fix vbiVioapicIntSend() prototype, added show routines
+01i,19dec08,mmi  add VBI show routine function prototypes
+01h,14dec08,mmi  move printing function prototypes to vbInterface.h
+01g,13dec08,mmi  change vbiSyscalls.h to vbiSyscall.h
+01f,12dec08,mmi  rename RAZOR to WRHV
+01e,11dec08,mmi  replace razor with wrhv prefix, add access macros, moved
+		 razorvxworks.h contents to this file
+01d,10dec08,mmi  add VIOAPIC API prototypes
+01c,05dec08,mmi  add ctypes header file
+01b,20nov08,mmi  adopt new naming convention
+01a,20nov07,foo  written
+*/
+
+#ifndef __INCvbih
+#define __INCvbih
+
+#ifdef CONFIG_WRHV
+#include "vbiErrors.h"
+#include "vbiTypes.h"
+#include "vbiVersion.h"
+#include "vbiArch.h"
+#include "vbInterface.h"
+#include "vbiSyscall.h"
+#include "vbiInterrupt.h"
+#include "vbiShmem.h"
+#else
+#include <stdlib.h>
+#include <vbiErrors.h>
+#include <vbiTypes.h>
+#include <vbiVersion.h>
+#include <vbiArch.h>
+#include <vbInterface.h>
+#include <vbiSyscall.h>
+#include <vbiInterrupt.h>
+#include <vbiShmem.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef _ASMLANGUAGE
+/*
+DESCRIPTION
+This module contains the vbi methods prototypes and access macros to access the
+various data structures. 
+*/
+
+/* Access macros for VB control structure */
+
+/*******************************************************************************
+*
+* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+*
+* This macro returns the base address of the running virtual core's control
+* structure.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CNTRL_ADDR_GET()        (wrhvVbControl)
+
+#define VBI_INT_STATE_GET()             \
+        ((VBI_CNTRL_ADDR_GET()->intDisable) == -1 ? TRUE: FALSE)
+
+#define VBI_INT_STATE_SET(value)        \
+        ((VBI_CNTRL_ADDR_GET())->intDisable = value)
+
+
+#define VBI_INT_PENDING_SET(value)        \
+        (VBI_CNTRL_ADDR_GET()->intPending = value)
+
+/*******************************************************************************
+*
+* VBI_VIOAPIC_BASE_GET - Get the virtual I/O APIC base address
+*
+* This macro returns the virtual I/O APIC base address in the configuration
+* structure. This is a table that controls the state of individual IRQ 
+* connected to a virtual board. If the underlying hardware supports an IRQ can
+* be redirected to a specific vector number. The redirection capability is not
+* used for PPC platforms since all interrupts are funneled via vector 0x500. 
+* The VIOAPIC is comprised of a description header and a redirection table. Each
+* entry in the redirection table is 64 bits wide. The size of the redirection
+* table is architecture specific. See the VBI user's guide for more detailed 
+* information.
+*
+* API's for controlling the VIOAPIC:
+*\ms
+*\m - 
+* vbiVioapicIntSend()
+*\m - 
+* vbiVioapicVectorSet()
+*\m - 
+* vbiVioapicVectorGet()
+*\m - 
+* vbiVioapicIntAck()
+*\m - 
+* vbiVioapicIntMask()
+*\m - 
+* vbiVioapicIntUnmask()
+*\me
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* void * VBI_VIOAPIC_BASE_GET (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIoapicIntUnmask(), vbiVioapicVectorGet(), vbiIoapicIntMask(), 
+*           vbiIoapicIntSend(), vbiIoapicIntRedirect(), vbiIoapicIntAck(),
+*	    VBI User's Guide
+*/
+
+#define VBI_VIOAPIC_BASE_GET()		\
+        (VBI_CNTRL_ADDR_GET()->vIoapic)
+
+/* VMMU0 and VMMU1 tables for context switch access macro's */
+
+#define VBI_VMMU0_GET()                   \
+        (VBI_CNTRL_ADDR_GET()->vmmu0)
+
+#define VBI_VMMU0_SET(value)              \
+        (VBI_CNTRL_VMMU0_GET() = value)
+
+/*******************************************************************************
+*
+* VBI_STATUS_ADDR_GET - Get virtual core status structure address
+*
+* This macro returns the base address of the status structure of currently
+* running core. This structure is read-only and contains a description of
+* the running virtual core. Hypervisor uses this data to inform the
+* virtual board time variant data that may be updated during hypervisor context
+* Switch. Typical that are available in the status structure are:
+*
+*\ms
+*\m - 
+*Timer tick counter
+*\m -
+*Pending interrupt state
+*\m -
+*The interrupt state before this core was schedule
+*\m -
+*VMMU configuration
+*\m -
+*Virtual core registers state
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_STATUS * VBI_STATUS_ADDR_GET(void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_STATUS_ADDR_GET()       (wrhvVbStatus)
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_PENDING - Get the pending interrupt 
+*
+* This returns the pending interrupts vector number for the running core. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiVector_t VBI_INT_VCORE_PENDING (void)
+*
+*\ce
+*
+* RETURNS: VB Interrupt Vector or 0xffff (PowerPC) Not applicable for X86
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
+*/
+
+#define VBI_INT_VCORE_PENDING()				    \
+        (VBI_CNTRL_ADDR_GET()->intPending)
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_PENDING_TYPE_GET - Get the pending interrupts
+*
+* This returns the type of pending interrupts for the running core. This API
+* are not use by hardware with virtualization support.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiVector_t VBI_INT_VCORE_PENDING_TYPE_GET(void)
+*
+*\ce
+*
+* RETURNS: 2 for timer interrupt, 1 for other external interrupts or
+*	    0 if none is pending
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
+*/
+
+
+#define VBI_INT_VCORE_PENDING_TYPE_GET()            \
+        (VBI_STATUS_ADDR_GET()->intPendingType)
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_PREVSTATE_GET - Get the core's previous interrupt status 
+*
+* This returns the previous interrupt state of the currently running core. This
+* flag reflects the state of interrupts before Hypervisor injected an
+* interrupt. The guest OS must restore this flag in the control structure
+* before returning from the interrupt service routine.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* bool VBI_INT_VCORE_PREVSTATE_GET (void)
+*
+*\ce
+*
+* RETURNS: TRUE if locked otherwise FALSE
+*
+* ERROR CODES: 
+*
+* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*              VBI_INT_VCORE_UNLOCK()
+*/
+
+#define VBI_INT_VCORE_PREVSTATE_GET()				\
+        ((VBI_STATUS_ADDR_GET()->oldIntDisable) == -1? TRUE: FALSE)
+
+/* timeStamp field  */
+
+#define VBI_TIMESTAMP_GET()					\
+        (VBI_STATUS_ADDR_GET()->timeStamp)
+
+/* vmm[0,1] access macro */
+
+
+/*******************************************************************************
+*
+* VBI_VMMU_CONFIG_GET - Get a core's VMMU configuration addr
+*
+* This macro gets the core's VMMU configuration structure address. The VMMU
+* structure is a descriptor of the VMMU context with the following info:
+*
+*\ms
+*\m -
+* The VMMU page table base address 
+*\m - 
+* The VMMU pages
+*\m -
+* The page size granularity 
+*\me 
+*
+* VMMU_CONFIG definition:
+*
+* typedef struct vmmuConfig
+*    {
+*    VMMU_LEVEL_1_DESC *addr;
+*    size_t         pageSize;
+*    uint32_t       reserved;
+*    uint32_t       vmmu_num;
+*    } VMMU_CONFIG;
+*
+* The vmmu virtual address space is restricted to 32 bits and is decoded using
+* a level-1/level-2 page table.  The virtual address is decoded as follows:
+*\cs
+*
+*
+*
+*
+*
+*
+*
+*
+*                          32-bit Virtual Address
+*        +---------------------------------------------------------+
+*        |      L1 offset       | L2 offset |    Page offset       |
+*        +---------------------------------------------------------+
+*                11 bits           9 bits           12 bits
+*                  |                 |
+*                  |                 |
+*    +-------------+                 |
+*    |                               |
+*    |                               |
+*    |           L1 Table            |            L2 Table
+*    |    2047 +----------+          |      511 +----------+
+*    |         |          |          |          |          |
+*    |         |          |          |          |          |
+*    |         |          |          |          |----------|
+*    |         |          |          |   +----->|    PTE   | 8 byte PTE
+*    |         |          |          |   |      |----------|
+*    |         |          |          |   |      |          |
+*    |         |----------| 20 bits  |   |      |          |
+*    +-------->|  L2 ptr  |----------+---+      |          |
+*              |----------|                     |          |
+*              |          |                     |          |
+*              |          |                     |          |
+*            0 +----------+                   0 +----------+
+*               2 page (8KB)                    1 page (4KB)
+*             2048 L2 pointers                 512 PTE entries
+*
+* Each page table entry is 8 bytes (2 words) and uses the following format:
+*
+* word 0 (32-bits):
+*          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+*                                          6 7 8 9 0 1 2 3
+*         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+*         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+*         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+*         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+*
+*                V          - valid bit
+*                Hypervisor - reserved for use by hypervisor
+*                U0-U7      - user defined attributes
+*                ERPN       - extended real page number bits
+*                ATTR       - page attributes
+*
+* word 1 (32-bits):
+*
+*          0                                19 20      23 2 2 2 2 2 2 3 3
+*                                                         4 5 6 7 8 9 0 1
+*         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+*         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+*         |                                   |          | | |X|X|W|W|R|R|
+*         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+*
+*                RPN        - real page number
+*                R          - page referenced bit
+*                C          - page changed bit
+*                SX,SW,SR   - supervisor mode protection bits
+*                UX,UW,UR   - user mode protection bits
+*\ce
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VMMU_CONFIG * VBI_VMMU_CONFIG_GET (void)
+*
+*\ce
+*
+* RETURNS: A pointer to the cores VMMU_CONFIG structure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuDisable(),
+*           vbiVmmuTlbFlush(), vbiVmmuTlbLoad()
+*/
+
+
+#define VBI_VMMU0_CONFIG_GET()          \
+        (VBI_STATUS_ADDR_GET()->vmmu0)
+
+#define VBI_VMMU1_CONFIG_GET()          \
+        (VBI_STATUS_ADDR_GET()->vmmu1)
+
+/*******************************************************************************
+*
+* VBI_TICKS_COUNT_GET - Get the elapsed ticks count
+*
+* This returns the number timer ticks elapsed since the board has started. 
+* The frequency of the counter is based on the virtual board configuration XML
+* file "TimerTicksFrequency" flag.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiTicks_t VBI_TICKS_COUNT_GET (void)
+*
+*\ce
+*
+* RETURNS: count number of elapsed ticks for a VB
+*
+* ERROR CODES: 
+*
+* SEE ALSO: 
+*/
+
+#define VBI_TICK_COUNT_GET()             \
+        (VBI_STATUS_ADDR_GET()->tickCount)
+
+/*******************************************************************************
+*
+* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+*
+* This macro returns the base address of the configuration structure of the 
+* running core. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CONFIG_ADDR_GET()       (wrhvVbConfig)
+
+/*******************************************************************************
+*
+* VBI_CONTEXT_ID_GET - Get virtual core context Id
+*
+* This macro returns the virtual core context id. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiCtx_t VBI_CONTEXT_ID_GET (void)
+*
+*\ce
+*
+* RETURNS: virtual core context id
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CONTEXT_ID_GET()             \
+        (VBI_CONFIG_ADDR_GET()->pid)
+
+/*******************************************************************************
+*
+* VBI_BOARD_ID_GET - Get virtual Id
+*
+* This macro returns the virtual board id that the running core is attached.
+* This is positive integer in the range [1, N]. Where N is the total number of
+* boards in the system.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiVb_t VBI_BOARD_ID_GET (void)
+*
+*\ce
+*
+* RETURNS: virtual board id;
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_BOARD_ID_GET()               \
+        (VBI_CONFIG_ADDR_GET()->boardID)
+
+/*******************************************************************************
+*
+* VBI_VCORES_COUNT_GET - Get the number of cores in a VB.
+*
+* This macro returns the number of virtual cores in the VB that the calling
+* core is attached. This is a positive integer in the range of [1:N]. Where N
+* the total number of cores in the virtual board.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* uint32_t VBI_VCORES_COUNT_GET (void)
+*
+*\ce
+*
+* RETURNS: number of cores in a virtual board
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_VCORE_ID_GET()
+*/
+
+#define VBI_VCORES_COUNT_GET()               \
+        (VBI_CONFIG_ADDR_GET()->numCores)
+
+/*******************************************************************************
+*
+* VBI_VCORE_ID_GET - Get a core's id
+*
+* This macro returns the running core id. This is a positive integer in the
+* range of [0:N-1]; Where N is the total number of cores in the system.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* vbiCore_t VBI_CORE_ID_GET (void)
+*
+*\ce
+*
+* RETURNS: the running core id
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_VCORE_ID_GET()			\
+        (VBI_CONFIG_ADDR_GET()->coreId)
+
+/*******************************************************************************
+*
+* VBI_VCORE_PRIVMEM_SIZE_GET - Get core's private memory size
+*
+* This macro returns the size in bytes of the running core's private memory
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* size_t VBI_VCORE_PRIVMEM_SIZE_GET (void)
+*
+*\ce
+*
+* RETURNS: size in bytes of the core's private memory
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiCorePrvMemFind 
+*/
+
+#define VBI_VCORE_PRIVMEM_SIZE_GET()               \
+        (VBI_CONFIG_ADDR_GET()->corePrivateSize)
+
+/*******************************************************************************
+*
+* VBI_VCORE_PRIVMEM_BASE_GET - Get core's private memory base address
+*
+* This macro returns the base of the private memory associated to the running
+* core's private memory
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* void * VBI_VCORE_PRIVMEM_BASE_GET (void)
+*
+*\ce
+*
+* RETURNS: a pointer to the core's private memory
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiCorePrvMemFind 
+*/
+
+#define VBI_VCORE_PRIVMEM_BASE_GET()               \
+        (VBI_CONFIG_ADDR_GET()->corePrivate)
+
+/*******************************************************************************
+*
+* VBI_PRV_MODE_GET - Get virtual core privilege mode
+*
+* This macro returns the virtual core privilege mode. A privileged core has
+* has full privilege access to hardware. If a core is configured to run in
+* privilege mode then care must be taken to prevent negative impact to the
+* rest of the system. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* uint32_t VBI_PRV_MODE_GET (void)
+*
+*\ce
+*
+* RETURNS: 1 if core has supervisor privilege otherwise 0
+*
+* ERROR CODES: N/A
+* 
+* SEE ALSO: 
+*\NOMANUAL
+*/
+
+#define VBI_PRIV_MODE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->supervisorMode)
+
+/*******************************************************************************
+*
+* VBI_BOARD_NAME - Get a VB name
+*
+* This macro returns the name of the virtual board that the running core is
+* attached. This is a NULL terminated string of a maximum length of 64 bytes. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* char * VBI_BOARD_NAME (void)
+*
+*\ce
+*
+* RETURNS: a string representing the board name
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_BOARD_NAME_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->boardName)
+
+#define VBI_BOARD_TYPE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->boardType)
+
+/*******************************************************************************
+*
+* VBI_BOOT_COUNT_GET - Get the number of times this board has booted
+*
+* This macro returns the number of times a board has booted. This may used to
+* determine if the .bss data region needs to clear after a reset. This is a
+* zero value since the board has booted at least one time to call this API.
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* uint32_t VBI_BOOT_COUNT (void)
+*
+*\ce
+*
+* RETURNS: a positive number greater than 0
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_BOOT_COUNT_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->bootCount)
+
+/*******************************************************************************
+*
+* VBI_MEM_SIZE_GET - Get the virtual board ram size 
+*
+* This macro returns the size of ram memory in bytes that a virtual board
+* has been assigned. If a virtual board has more than one core then it's memory
+* is shared among all cores. Hypervisor maps the size of memory provided in the
+* board's XML configuration file "RamSize" flag. 
+* This is a virtual memory region from Hypervisor perspective but serves as the
+* phyisical memory for the virtual board. 
+*
+* The size returned by this macro does not include the following:
+*
+*\ms
+*\m -
+* Private memory of each core attached to this virtual board
+*\m -
+* The regions that contain the configuration, status and control structures
+*\m -
+* The shared memory with other boards
+*\me
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* size_t VBI_MEM_SIZE_GET (void)
+*
+*\ce
+*
+* RETURNS: The size of memory in bytes for virtual board 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_MEM_SIZE_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->physicalMemorySize)
+
+/*******************************************************************************
+*
+* VBI_MEM_ALIAS_SIZE_GET - Get the size of aliased ram
+*
+* This macro returns a virtual board's aliased memory size. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* size_t VBI_MEM_ALIAS_SIZE_GET (void)
+*
+*\ce
+*
+* RETURNS: The aliased memory size.
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*\NOMANUAL
+*/
+
+#define VBI_MEM_ALIAS_SIZE_GET()		    \
+        (VBI_CONFIG_ADDR_GET()->memoryAliasSize)
+
+/*******************************************************************************
+*
+* VBI_MEM_ALIAS_ADDR_GET - Get the virtual board ram alias address 
+*
+* This macro returns a virtual board's ram alias base address. This is a
+* physical address from the board's perspective but a virtual address mapped
+* to the board's ram address from Hypervisor's perspective. 
+* Hypervisor maps this address based on "RamAliasAddr" value in the board's XML 
+* configuration file. The virtual board's ram and this address point to the
+* same physical address. This is convenient mechanism for a virtual board that
+* needs to remap it's physical address to a different address.
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* void * VBI_MEM_ALIAS_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: The base address of ram alias address 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_MEM_ALIAS_ADDR_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->memoryAliasAddress)
+
+
+/*******************************************************************************
+*
+* VBI_MEM_ENTRY_RTN - Get a core entry point function
+*
+* This macro returns the address of the entry point function of a particular
+* core. This address is derived from the guest OS binary image a compile time
+* while creating the hypervisor system.elf image. Hypervisor calls this
+* function and passes it to the configuration address and the boot flag when
+* launching a virtual core.
+* 
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* void * VBI_MEM_ENTRY_RTN(void)
+*
+*\ce
+*
+* RETURNS: The entry point function of a virtual core 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_ENTRY_RTN_GET()			    \
+        (VBI_CONFIG_ADDR_GET()->resetPC)
+
+/*******************************************************************************
+*
+* VBI_TICK_TIMER_FREQ_GET - Get a core timer tick frequency
+*
+* This macro returns a core's timer clock frequency. It is the number of timer
+* ticks per second. It is based on the "TickTimerFrequency" flag specified in
+* the board's XML configuration file.
+* The timer tick interrupt is delivered to only the running core of a VB. If a
+* core is not running the counter in the status page is incremented. 
+* If "TickTimerFrequency" is set to a value of 0 for a board it  disables the
+* timer tick.
+*
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* vbiTicks_t VBI_TICK_TIMER_FREQ_GET (void)
+*
+*\ce
+*
+* RETURNS: The number of ticks per second
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_TICK_TIMER_FREQ_GET()		        \
+        (VBI_CONFIG_ADDR_GET()->tickTimerFrequency)
+
+#define VBI_TIMESTAMP_FREQ_GET()			\
+        (VBI_CONFIG_ADDR_GET()->timeStampFrequency)
+
+/*******************************************************************************
+*
+* VBI_BOOTLINE_ADDR_GET - Get a virtual board bootline parameters address
+*
+* The bootline parameters is a string that contains configuration data that a
+* user may specify in the virtual XML configuration "BootLine" flag. A guest
+* OS running on Hypervisor must use this bootline instead of it's native
+* bootline parameters. For example VxWorks bootline parameters are not passed
+* to the VB running VxWorks. The size of the bootline parameters string is
+* determined by VB_MAX_BOOTLINE_LENGTH at compile time flag. The bootline is
+* NULL terminated string.
+* 
+* SYNOPSIS
+*
+*\cs
+*
+* C Preprocessor Macro
+*
+* const char * VBI_BOOTLINE_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: The address of the bootline parameters.
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_BOOTLINE_ADDR_GET()				\
+        (VBI_CONFIG_ADDR_GET()->bootLine)
+
+#define VBI_PANIC(vector, halt)				\
+    {							\
+    VB_PRINTF ("core%d: unhandled exception: 0x%x\n",   \
+		wrhvVbConfig->coreId, vector);		\
+    if (halt)						\
+        {						\
+        vbiPanic ("unhandled exception");		\
+	}						\
+    }							 
+
+#ifndef ERROR
+#define ERROR	(-1)
+#endif
+#ifndef OK
+#define OK	0
+#endif
+#ifndef NULL
+#define NULL	0
+#endif
+
+/* typedefs */
+
+typedef struct vbiClkHook
+    {
+    void (*rtn)(void *pArg);
+    void * pArg;
+    } VBI_CLK_HOOK_INFO, * VBI_CLK_HOOK_INFO_PTR;
+
+/* externs */
+
+extern VB_CONFIG  * wrhvVbConfig;
+extern VB_STATUS  * wrhvVbStatus;
+extern VB_CONTROL * wrhvVbControl;
+extern int32_t      wrhvVbIntNested;
+extern void vbiInit (VB_CONFIG * config);
+extern void vbiExcStub (void);
+extern void ASSERT_FN (const char *, const char *, int);
+extern void vbiIdle (uint64_t);
+extern void * vbiVioapicAddrGet (void);
+extern vbiStatus_t vbiVioapicVectorSet (vbiIrq_t irq, vbiVector_t vector); 
+extern vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntSend (vbiIrq_t irq, uint32_t filter,
+				      vbiVb_t target);
+extern vbiStatus_t vbiVioapicIntSend (vbiIrq_t irq, uint32_t filter, 
+				     vbiVb_t vb);
+extern vbiStatus_t vbiVioapicIntRedirect(vbiIrq_t irq, vbiCore_t tCore);
+
+extern vbiStatus_t vbiGuestDmaAddrGet
+    (
+    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    );
+extern vbiStatus_t vbiGuestPhysToPhysAddr
+    (
+    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    );
+
+extern void vbiVioapicDisplay (void);
+extern void vbiSharedMemoryShow (VB_CONFIG * config);
+extern void vbiStatusShow (VB_STATUS * p);
+extern void vbiControlShow (VB_CONTROL * p);
+extern void vbiConfigShow (VB_CONFIG * p);
+extern void vbiMemoryShow  ( VB_CONFIG * config);
+extern void vbiStsRegsDisplay (void);
+extern void vbiCtrlRegsDisplay (void);
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbih */
diff --git a/include/vbi/vbiArch.h b/include/vbi/vbiArch.h
new file mode 100644
index 0000000..64e9ef2
--- /dev/null
+++ b/include/vbi/vbiArch.h
@@ -0,0 +1,48 @@
+/* vbi/vbiArch.h - vbi architecture specific definitions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,28aug09,mmi  adjust arch header files path
+01f,15jul09,dtr  Add CPU PPCE500MC.
+01e,25may09,md   add endian order type defines
+01d,17mar09,mpk  Cavium OCTEON MIPS64 port for hypervisor
+01c,29jan09,mmi  add vbi/ to the header files path
+01b,28jan09,mmi  check PENTIUM4 and PENTIUM, consider error case
+01a,21jan08,mmi  written.
+*/
+
+#ifndef __INCvbiArchh
+#define __INCvbiArchh
+
+/* endian types selectable by the arch specific header files */
+
+#define __VBI_LITTLE_ENDIAN 1234  /* least-significant byte first         */
+#define __VBI_BIG_ENDIAN    4321  /* most-significant byte first          */
+#define __VBI_PDP_ENDIAN    3412  /* LSB first in word, MSW first in long */
+
+/* include the appropriate arch specific header file */
+
+#if (CPU == MIPSI64R2)
+# include <mips64/vbiMips64Arch.h>
+#elif (CPU == PPC85XX) || (CPU == PPC32) || (CPU == PPCE500MC)
+# include <ppc/vbiPpcArch.h>
+#elif (CPU == PENTIUM) || (CPU == PENTIUM4)
+#ifdef CONFIG_WRHV
+# include "x86/vbiX86Arch.h"
+#else
+# include <x86/vbiX86Arch.h>
+#endif /* CONFIG_WRHV */
+#else
+# error "no arch header file included"
+#endif
+
+/* ensure the arch has specified a byte ordering */
+
+#if !defined(__VBI_BYTE_ORDER)
+# error: Architecture has not defined a byte order!
+#endif
+
+#endif /* __INCvbiArchh */
diff --git a/include/vbi/vbiErrors.h b/include/vbi/vbiErrors.h
new file mode 100644
index 0000000..d8bf8cd
--- /dev/null
+++ b/include/vbi/vbiErrors.h
@@ -0,0 +1,63 @@
+/* vbi/VbiErrors.h - vbi errors */
+
+/* 
+ * Copyright (c) 2009 Wind River Systems, Inc. 
+ *
+ * The right to copy, distribute, modify or otherwise make use 
+ * of this software may be licensed only pursuant to the terms 
+ * of an applicable Wind River license agreement. 
+ */
+
+/*
+modification history
+--------------------
+01e,14jul09,mmi  add vbi memory errors
+01d,07jul09,mmi  add vbMgmt error numbers
+01c,17jun09,mmi  add VBI_VIOAPIC_NULL
+01b,11jun09,mmi  add VBI_EXCBASE_SET_ERROR
+01a,16apr0r9,mmi written
+*/
+
+#ifndef __INCvbiErrorsh
+#define __INCvbiErrorsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VBI_ERRORS_START		(0)
+
+/* generic vbi errors */
+
+#define VBI_INVALID_VERSION		(VBI_ERRORS_START + (-1))
+#define VBI_INVALID_IRQ			(VBI_ERRORS_START + (-2))
+#define VBI_INVALID_SHMEM		(VBI_ERRORS_START + (-3))
+#define VBI_INVALID_MEM			(VBI_ERRORS_START + (-4))
+
+/* vbi Exceptions error */
+
+#define VBI_EXC_ERROR_START		(VBI_ERRORS_START + (-1000))
+#define VBI_EXCBASE_SET_ERROR		(VBI_EXC_ERROR_START + (-1))
+
+/* VIOAPIC errors   */
+#define VBI_VIOAPIC_ERROR_START		(VBI_EXC_ERROR_START + (-100))		
+#define VBI_VIOAPIC_NULL		(VBI_VIOAPIC_ERROR_START + (-1))
+#define VBI_VIOAPIC_IRQ_OUTBOUND	(VBI_VIOAPIC_ERROR_START + (-2))
+#define VBI_VIOAPIC_IRQ_INVALID_DIR	(VBI_VIOAPIC_ERROR_START + (-3))
+#define VBI_VIOAPIC_UNAVAIL		(VBI_VIOAPIC_ERROR_START + (-4))
+
+
+/* VB MANAGEMENT errors */
+
+#define VBI_VBMGMT_ERROR_START		(VBI_VIOAPIC_ERROR_START +  (-100))
+#define VBI_ERR_VBMGMT_VB_INVALID	VBI_VBMGMT_ERROR_START +    (-1)	
+#define VBI_ERR_VBMGMT_INVALID_ARG	VBI_VBMGMT_ERROR_START +    (-2)
+#define VBI_ERR_VBGMT_RESET_FAILED	VBI_VBMGMT_ERROR_START +    (-3)
+#define VBI_ERR_VBMGMT_CTX_INVALID	VBI_VBMGMT_ERROR_START +    (-4)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCvbiVersionh */
diff --git a/include/vbi/vbiInterrupt.h b/include/vbi/vbiInterrupt.h
new file mode 100644
index 0000000..7d721d1
--- /dev/null
+++ b/include/vbi/vbiInterrupt.h
@@ -0,0 +1,44 @@
+/* vbiInterrupt.h - utility functions to read interrupt configuration data*/
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01i,02jul09,mmi  fix return type
+01h,18jun09,mmi  rename the file
+01g,31mar09,mmi  change interrupt direction flags
+01f,26feb09,mmi  change vbiIntVecFind definition to return vector
+01e,17dec08,mmi  rename vbiIntCtrlFindVector
+01d,20nov08,mmi  adopt new naming convention
+01c,04sep08,dcc  modified vbiIntCtrlConnect() signature
+01b,27nov07,foo  fix parameter
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for utility functions for reading the 
+interrupts configuration data.
+
+*/
+
+#ifndef __INCinterrupth
+#define __INCinterrupth
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+extern vbiIrq_t vbiIntVecFind (char * intName, int32_t intDirection);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCinterrupth */
diff --git a/include/vbi/vbiPrv.h b/include/vbi/vbiPrv.h
new file mode 100644
index 0000000..884d845
--- /dev/null
+++ b/include/vbi/vbiPrv.h
@@ -0,0 +1,93 @@
+/* vbiPrv.h - virtual board interface private definitions */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+
+/*
+modification history
+--------------------
+01d,03sep09,mmi  add inlined strncmp() for vbi library
+01c,02sep09,mmi  add vbiReceiveOp
+01b,03jul09,mmi  add vbiNsOp
+01a,03jul09,mmi  written
+*/
+
+#ifndef __INCvbiPrvh
+#define __INCvbiPrvh
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifdef CONFIG_WRHV
+#define _WRS_INLINE     static __inline__
+#define EOS     '\0'    /* C string terminator */
+#define LINKAGE asmlinkage
+#include <linux/types.h>
+#include <linux/linkage.h>
+#include "syscalls.h"
+#include "vbiSyscall.h"
+#include "vbiTypes.h"
+#else
+#define LINKAGE
+#endif /* CONFIG_WRHV */
+
+#ifndef _ASMLANGUAGE
+
+
+_WRS_INLINE vbiStatus_t _vbiStrncmp 
+    (
+    const char * s1, 
+    const char * s2, 
+    size_t n
+    )
+    {                                        
+    if (n == 0)
+	return (0);
+ 
+    while (*s1++ == *s2++)
+	{
+ 	if ((s1 [-1] == EOS) || (--n == 0))
+ 	    return (0);
+        }
+ 
+    return ((s1 [-1]) - (s2 [-1]));
+    }
+
+/* private ioapic operator */
+
+extern LINKAGE vbiStatus_t  vbiIoapicOp (uint32_t ioctl, vbiIrq_t irq, uint32_t filter, vbiVb_t vbId);
+
+/* private interrupt redirection operator */
+
+extern LINKAGE vbiStatus_t  vbiVcoreIntRed_op (vbiIrq_t irq, vbiCore_t CoreId);
+
+/* Name service private operator */
+
+extern LINKAGE vbiStatus_t  vbiNsOp (uint32_t op, char* name, uint32_t rev, 
+			VBI_NS_HANDLE *handle);
+
+/* Message receive private operator */
+
+extern LINKAGE vbiStatus_t vbiReceiveOp
+    (
+    void		*rmsg, /* pointer to message to receive  */
+    uint32_t		rlen,  /* length of message to receive   */
+    VBI_MSG_INFO	*info, /* status info structure pointer  */
+    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
+    );                                   
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbih */
diff --git a/include/vbi/vbiShmem.h b/include/vbi/vbiShmem.h
new file mode 100644
index 0000000..6ce7945
--- /dev/null
+++ b/include/vbi/vbiShmem.h
@@ -0,0 +1,59 @@
+/* vbiShmem.h - Virtual Interface  memory utility functions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,14jul09,mmi  update with vbiStatus_t return type
+01f,03jul09,mmi  add private memory function
+01e,12dec08,mmi  replace razor with wrhv
+01d,11dec08,mmi  use typedef's instead natives
+01c,20nov08,mmi  adopt new naming convention
+01b,26nov07,foo  update prototype
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for managing memory regions
+
+*/
+
+#ifndef __INCvbiShmemh
+#define __INCvbiShmemh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+extern vbiStatus_t vbiShmemRegionFind
+    (
+    int8_t *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    );
+
+extern vbiStatus_t vbiMemRegionFind
+    (
+    int8_t *         name,        /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    );
+
+/* find the base address and length of a core's private memory */
+
+extern vbiStatus_t vbiCorePrvMemFind (void * * addr, size_t *  length);  
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiShmemh */
diff --git a/include/vbi/vbiSyscall.h b/include/vbi/vbiSyscall.h
new file mode 100644
index 0000000..3252718
--- /dev/null
+++ b/include/vbi/vbiSyscall.h
@@ -0,0 +1,233 @@
+/* vbiSyscall.h - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02s,02sep09,mmi  apply patch
+02r,31aug09,mmi  use VBI_HREG_SET instead of VB_HREG_SET
+02q,26aug09,mmi  Fix defect WIND00178030: add vbiKputc proto
+02p,12aug09,dtr  Update vbiHyIoctl API to add additional argument.
+02o,22jul09,mpk  support vbi register read, write
+02n,03jul09,mmi  move vbiNsOp to private header file, add
+		 vbiVbRegRead/Write
+02m,02jul09,mmi  add one more parameter to vbiIoapicIoctl
+02l,23jun09,mmi  add vbi2.0 apis
+02k,11jun09,mmi  update interrupts api protortype
+02j,10jun09,mmi  update hypercall interface according to vbi 2.0 spec
+02i,26feb09,mmi  add vbiNs
+02h,24feb09,mmi  remove duplicate defines already in syscalls.h
+02g,06feb09,mmi  include vbiMsg.h
+02f,19jan09,mmi  update msg API prototypes
+02e,12jan09,dtr  Add driver ioctl calls, remove legacy interrupt defns.
+02d,12dec08,md   rename header files
+02c,05dec08,mes  Removed shelf macros, added vbMgmt macros
+02b,01dec08,md   add VBI_IOAPICIOCTL_SEND options
+02a,21nov08,md   remove port and ED&R syscalls
+01z,20nov08,mmi  adtopt new naming convention
+01y,31oct08,dbt  Added vdkVtlbMmuOp hypercall.
+01x,16jun08,mmi  fix vdkBspIoctl prototype
+01w,19may08,gws  add vIoapicIoctl
+01v,18apr08,md   add extra arg to vdkHyioctl
+01u,11apr08,md   add EOI ioctl
+01t,06mar08,md   add debug shell ioctl
+01s,06dec07,foo  update hw ints
+01r,23nov07,foo  fix prototype, use basic types
+01q,25oct07,foo  updated with new vdk functions
+01p,27sep07,md   added exception profiling fields
+01o,26sep07,md   added profiling statistics and stats ioctl
+01n,10sep07,md   re-number hypervisor system calls
+01m,21aug07,md   added VDK_SYS_ctx_load_vmmu
+01l,05jul07,foo  added bspIoctl calls and defines
+01k,04jun07,md   added ctxctl and mmu system calls
+01j,17may07,ymz  added port syscall.
+01i,28may07,foo  update vdkInt prototype
+01h,18may07,md   add hypervisor ioctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed to vdk
+01e,10apr07,md   replace kprintf syscall with kputs and kputc
+01d,19mar07,foo  fix macro
+01c,17mar07,foo  modify definitions to all start with HY
+01b,15mar07,md   added interrupt system calls
+01a,09mar07,md   written
+*/
+
+#ifndef __INCvbiSyscallh
+#define __INCvbiSyscallh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifdef CONFIG_WRHV
+#define LINKAGE asmlinkage
+#include <linux/linkage.h>
+#include "vbiTypes.h"
+#include "vbiArch.h"
+#include "syscalls.h"
+#else
+#define LINKAGE
+#include <vbiArch.h>
+#include <syscalls.h>
+#endif /* CONFIG_WRHV */
+
+#ifndef	_ASMLANGUAGE
+
+/* Forward declaration */
+struct vmmuConfig;
+struct VB_ARCH_CONTROL_REGS; 
+
+/* information about incoming message */
+
+typedef struct vbiMsgInfo {
+    vbiCtx_t    id;	/* context id of sender */
+    uint32_t type;	/* message type (msg/event) */
+    size_t   slen;	/* length of sent buffer */
+    size_t   rlen;	/* length of received buffer */
+    uint32_t error;	/* extended error status */
+    time_t   timestamp;	/* time message was sent */
+    uint32_t nmsg;	/* number of queued messages remaining */
+} VBI_MSG_INFO;
+
+/* extended error codes reported in "error" field */
+
+#define	VBI_MSG_ERROR_INTLEVEL  1	/* operation not allowed at interrupt level */
+#define	VBI_MSG_ERROR_BAD_ID    2	/* bad context id specified */
+#define	VBI_MSG_ERROR_ABORTED   3	/* operation aborted */
+#define	VBI_MSG_ERROR_TIMEOUT   4	/* operation timed out */
+#define	VBI_MSG_ERROR_XCALL     5	/* cross call to remote cpu failed */
+
+/* message types as reported in the "type" field */
+
+#define	VBI_MSG_TYPE_REGULAR  1	/* regular message */
+#define	VBI_MSG_TYPE_EVENT    2	/* event message */
+#define	VBI_MSG_TYPE_REPLY    3	/* reply message */
+
+
+/* modifiers for message processing */
+
+typedef struct vbiMsgCtl {
+    uint32_t flags;	/* operation flags */
+    uint32_t ordering;	/* order to receive messages */
+    time_t   timeout;	/* receive timeout */
+} VBI_MSG_CTL;
+
+/* message control flags */
+#define VBI_MSG_CTL_FLAG_RETRY 1
+
+/* memory read/write control structure */
+
+typedef struct vbiMemCtl
+    {
+    void	*pBuffer;	    /* address of target context	    */
+    void	*pAddress;	    /* address of calling context	    */
+    size_t	sizeIn;		    /* number of bytes to be read	    */
+    size_t	sizeOut;	    /* number of bytes successfully read    */
+    uint32_t	flags;	    	    /* data/instruction flush option	    */
+  } VBI_MEM_CTL;
+
+#define VBI_DCACHE_FLUSH 	0x0001
+#define VBI_ICACHE_INV 		0x0002
+
+/* system call prototypes for use within a context */
+
+extern LINKAGE int  vbiHyIoctl (unsigned ioctl, void *arg1, void *arg2, void *arg3, void *arg4);
+extern LINKAGE int  vbiIoapicIoctl (unsigned ioctl, unsigned arg1, unsigned arg2);
+extern LINKAGE int  vbiCtxctl (unsigned operation, unsigned arg1, unsigned arg2);
+extern LINKAGE int32_t vbiVbMgmt (uint32_t cmd, uint32_t boardId, int32_t *outError,
+			  uint32_t flags, void * ctl);
+extern LINKAGE int  vbiVtlbOp (unsigned int op, unsigned long arg1,
+			  unsigned long arg2, unsigned long arg3);
+
+/*******************************************************************************
+ * Modified APIs for VBI 2.0 
+ */
+
+/* Message send	    */
+
+extern LINKAGE vbiStatus_t vbiSend (vbiCtx_t	    id, 
+			    void	    *smsg, 
+			    size_t	    slen, 
+			    void	    *rmsg,
+			    size_t	    rlen, 
+			    VBI_MSG_INFO    *info, 
+			    VBI_MSG_CTL    *ctl);
+/* message receive  */
+
+extern vbiStatus_t vbiReceive (void		*rmsg, 
+			       uint32_t		rlen, 
+			       VBI_MSG_INFO	*info,
+			       VBI_MSG_CTL     *ctl);                                   
+/* message reply */
+
+extern LINKAGE int32_t vbiReply (vbiCtx_t	    id, 
+			 void		    *smsg, 
+			 size_t		    slen, 
+			 VBI_MSG_CTL	    *ctl);
+
+extern LINKAGE vbiStatus_t vbiPanic (const char *msg);
+extern vbiStatus_t vbiDcacheFlush (void *saddr, size_t size);
+extern vbiStatus_t vbiIcacheFlush (void *saddr, size_t size);
+extern LINKAGE vbiStatus_t vbiKputs (const char *s);
+extern LINKAGE vbiStatus_t vbiKputc (int c);
+extern vbiStatus_t vbiVmmuConfig (struct vmmuConfig * config);
+extern vbiStatus_t vbiVmmuEnable (uint32_t  vmmu_num);
+extern vbiStatus_t vbiVmmuDisable (uint32_t vmmu_num);
+extern vbiStatus_t vbiNsRegister (char  *name, uint32_t  revision);
+extern vbiStatus_t vbiNsUnRegister (char *name, uint32_t  revision);
+extern vbiStatus_t vbiNsLookup (char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle);
+extern vbiStatus_t vbiVmmuTlbFlush (struct vmmuConfig * config, void *addr, size_t len);
+
+
+/* Prior to vbi 2.0 these api were vbiMmuAttrSet/Get */
+
+extern LINKAGE vbiStatus_t  vbiMemAttrSet (void *vaddr, size_t len, vbiMemAttr_t attr);
+extern LINKAGE vbiStatus_t  vbiMemAttrGet (void *vaddr, vbiMemAttr_t * attr);
+
+/*******************************************************************************
+ * START: New APIs introduced for vbi 2.0  
+ */
+
+extern LINKAGE vbiStatus_t vbiIntVCoreUnlock (void);
+extern LINKAGE vbiIntState_t vbiIntVCoreLock (void);
+extern vbiStatus_t vbiCacheTextUpdate (void *saddr, size_t size);
+extern vbiStatus_t  vbiExcBaseSet (void * excTblBase);
+
+/* virtual board management API's */
+
+extern LINKAGE vbiStatus_t vbiVbSuspend (vbiVb_t id, vbiCore_t core);
+extern LINKAGE vbiStatus_t vbiVbReset (vbiVb_t id, vbiCore_t core, uint32_t options);
+extern LINKAGE vbiStatus_t vbiVbRestart (vbiVb_t id, vbiCore_t core);
+extern LINKAGE vbiStatus_t vbiVbResume (vbiVb_t id, vbiCore_t core);
+
+/* read remote vb's memory */
+
+extern LINKAGE vbiStatus_t vbiVbMemoryRead (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern LINKAGE vbiStatus_t vbiVbMemoryWrite (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern LINKAGE void vbiDebugShellStart (uint32_t  flags);
+
+/* read remote vb's registers */
+
+extern LINKAGE vbiStatus_t vbiVbRegisterRead (VBI_HREG_SET *regCtl, 
+				       vbiVb_t targetBoard, vbiCore_t core);
+extern LINKAGE vbiStatus_t vbiVbRegisterWrite (VBI_HREG_SET *regCtl, 
+					vbiVb_t targetBoard, vbiCore_t core);
+
+/*******************************************************************************
+ * END: New APIs introduced for vbi 2.0  
+ */
+
+
+#endif
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiSyscallh */
diff --git a/include/vbi/vbiTypes.h b/include/vbi/vbiTypes.h
new file mode 100644
index 0000000..08c6c71
--- /dev/null
+++ b/include/vbi/vbiTypes.h
@@ -0,0 +1,58 @@
+/* vbiTypes.h - virtual board interfaces types definitions */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+
+/*
+modification history
+--------------------
+01e,09sep09,mmi  change vbiIrq_t to unsigned type
+01d,12aug09,dtr  ADd vbiGuestPhysAddr type.
+01c,02jul09,mmi  fixe vbiIrq_t and vbiVector_t types
+01b,11jun09,mmi  add vbiIntState_t, vbiMemAttr_t, etc..
+01a,09jun09,mmi  written
+*/
+
+#ifndef __INCvbiTypesh
+#define __INCvbiTypesh
+
+#ifdef CONFIG_WRHV
+#ifdef CONFIG_X86
+#define CPU PENTIUM
+#define PPC32 -1
+#endif /* CONFIG_X86 */
+#include "support/sys/cpu_types.h"
+#else
+#include <ctype.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef _ASMLANGUAGE
+
+typedef uint32_t		vbiVb_t;
+typedef int32_t			vbiCore_t;
+typedef int32_t			vbiCtx_t;
+typedef uint64_t    		vbiPhysAddr_t;
+typedef void *       		vbiGuestPhysAddr_t;
+typedef int32_t			vbiStatus_t;		
+typedef int32_t			vbiIntState_t;		
+typedef int32_t			vbiMemAttr_t;		
+typedef int32_t			vbiVector_t;		
+typedef uint32_t		vbiIrq_t;		
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiTypesh */
diff --git a/include/vbi/vbiVersion.h b/include/vbi/vbiVersion.h
new file mode 100644
index 0000000..bf5bf29
--- /dev/null
+++ b/include/vbi/vbiVersion.h
@@ -0,0 +1,54 @@
+/* vbi/version.h - vbi version information */
+
+/* 
+ * Copyright (c) 2009 Wind River Systems, Inc. 
+ *
+ * The right to copy, distribute, modify or otherwise make use 
+ * of this software may be licensed only pursuant to the terms 
+ * of an applicable Wind River license agreement. 
+ */
+
+/*
+modification history
+--------------------
+01c,26aug09,mmi  Fix defect WIND00178026: update vbi version comment
+01b,02jul09,mmi  update version number
+01a,16apr0r9,mmi written
+*/
+
+#ifndef __INCvbiVersionh
+#define __INCvbiVersionh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Release identification, major, minor, and maintenance numbers.
+ * 
+ * Current vbi release number
+ */
+
+#define VBI_RUNTIME_NAME     "Wind River Hypervisor Virtual board interface"
+#define VBI_RUNTIME_VERSION  "2.0.0"
+
+/* textual description of this product version */
+
+#define VBI_VERSION VBI_RUNTIME_NAME " " VBI_RUNTIME_VERSION
+
+#ifndef _ASMLANGUAGE
+extern const char *vbiCreationDate;
+extern const char *vbiRuntimeVersion;
+extern const char *vbiRuntimeName;
+extern const char *vbiVersion;
+
+extern const uint32_t vbiVersionMajor;
+extern const uint32_t vbiVersionMinor;
+extern const uint32_t vbiVersionMaint;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCvbiVersionh */
diff --git a/include/vbi/vbiVioapic.h b/include/vbi/vbiVioapic.h
new file mode 100644
index 0000000..8b0751b
--- /dev/null
+++ b/include/vbi/vbiVioapic.h
@@ -0,0 +1,132 @@
+/* vIoapic.h - virtual IO APIC definitions */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute or otherwise make use of this software
+ * may be licensed only pursuant to the terms of an applicable Wind River
+ * license agreement. 
+*/
+
+/*
+modification history
+--------------------
+01f,13jul09,mmi  adjust max ioapic entries
+01e,17jun09,mmi  create a vioapic structure
+01d,14apr09,mpk  use uint32_t instead of long
+01c,12dec08,md   rename header files
+01b,09dec08,md   fix reg set/get macros
+01a,14apr08,gws  written
+*/
+
+#ifndef	__INCVIOAPICh
+#define	__INCVIOAPICh
+
+#include <wrhv.h>
+#include <sys/types.h>
+#include <vbMgr.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* define 128 entries for all platforms */
+
+#define VIOAPIC_REDTABLE_ENTRIES	(128)	
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	(VIOAPIC_REDTABLE_ENTRIES)
+
+#ifndef	_ASMLANGUAGE
+
+/* data structures */
+
+/* IO APIC ID register */
+typedef union {
+    struct {
+	uint32_t reserved1:24;	/* reserved bits */
+	uint32_t IOAPIC_id:4;	/* apic id */
+	uint32_t reserved2:4;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_ID;
+
+
+/* IO APIC Version Register */
+
+typedef union {
+    struct {
+	uint32_t version:8;		/* version identifier */
+	uint32_t reserved1:8;		/* reserved bits */
+	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
+					 * number of IRQ pins - 1 */
+	uint32_t reserved2:8;		/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_VERSION;
+
+/* Virtual IO APIC redirection table entry. Split into high/low 32 */
+
+typedef union {
+    struct {
+	uint32_t reserved:24;	/* reserved bits */
+	uint32_t destination:8;	/* destination field */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_HIGH;
+
+typedef union {
+    struct {
+	uint32_t vector:8;	/* vector number */
+	uint32_t deliveryMode:3;/* delivery mode:
+				 * fixed, lowest, SMI, reserved, NMI, 
+				 * INIT, reserved, extInt */
+	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
+	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+	uint32_t polarity:1;	/* polarity: 0=high active */
+	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
+				 * accepts level, 0 after EOI */
+	uint32_t trigger:1;	/* 0=edge, 1=level */
+	uint32_t mask:1;	/* 1=masked */
+	uint32_t reserved:15;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_LOW;
+
+typedef struct vioapicEntry 
+    {
+    VIOAPIC_REDIR_LOW	vioapicLow;
+    VIOAPIC_REDIR_HIGH	vioapicHigh;
+
+    } VIOAPIC_ENTRY;
+    
+typedef struct vioapic
+    {
+    VIOAPIC_ID	    id;
+    VIOAPIC_VERSION version;
+    uint32_t	    arb;
+    uint32_t	    boot;
+    uint32_t	    reserved[6];
+    VIOAPIC_ENTRY   entry [VIOAPIC_MAX_REDTABLE_ENTRIES];
+    } VIOAPIC;
+
+/* external declarations */
+
+extern int vIoapicInterrupt (HY_CTX * ctx, uint32_t globalInt);
+extern void vIoapicInit (VB_INFO * info);
+extern uint32_t vIoapicGetVector (HY_CTX * ctx, uint32_t irq);
+extern uint32_t vIoapicGetMask (HY_CTX * ctx, uint32_t irq);
+extern void vIoapicSetMask (HY_CTX * ctx, uint32_t irq, uint32_t mask);
+
+#endif /* _ASMLANGUAGE */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __INCVIOAPICh */
+
+
diff --git a/kernel/vbiIdle.c b/kernel/vbiIdle.c
new file mode 100644
index 0000000..f41f4dd
--- /dev/null
+++ b/kernel/vbiIdle.c
@@ -0,0 +1,72 @@
+/* vbiIdle.c - context idle code */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01h,26aug09,mmi  fix WIND00178026: update copyright
+01g,25may09,mmi  introduce a new type vbiTicks_t
+01f,15may09,mmi  fix apigen errors
+01e,11dec08,mmi  alwasy include vbi.h
+01d,19nov08,mmi  adopt new naming convention vbi...
+01c,02jul08,md   fix parameter ordering
+01b,21nov07,foo  idle parameter
+01a,04jun07,md   written
+*/
+
+/*
+DESCRIPTION
+This module provides an interface to put the currently running virtual board
+into the idle state.
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiIdle - inform the hypervisor scheduler that the virtual board is idle
+*
+* This function informs the hypervisor that the virtual board core's is idle and
+* also provides a timeout at which it needs to be made ready to run again. This
+* routine halts the active core untill the specified timeout expires or and an
+* asynchronous event like a interrupt is delivered to the calling core. An zero
+* timeout means to halt the core indefinetly until an asynchronous event occurs.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiIdle (vbiTicks_t timeout)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void vbiIdle
+    (
+    uint64_t timeStamp /* Time at which to wake up */
+    )
+    {
+    uint32_t tickCount = timeStamp & 0xFFFFFFFF;
+
+    /* use the hypervisor system call to go into the idle state */
+
+    vbiCtxctl (VBI_CTXCTL_IDLE, tickCount, 0);
+    }
diff --git a/kernel/vbiInterrupt.c b/kernel/vbiInterrupt.c
new file mode 100644
index 0000000..24fecd3
--- /dev/null
+++ b/kernel/vbiInterrupt.c
@@ -0,0 +1,102 @@
+/* vbiInterrupt.c - virtual board interrupt configuration utility */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01m,03sep09,mmi  fix depency to vba library for comparing strings
+01l,26aug09,mmi  fix WIND00178026: update copyright
+01k,03jul09,mmi  update description
+01j,19jun09,mmi  revert to previous name for this file
+01i,26feb09,mmi  change vbiIntVecFind definition to return vector
+01h,17dec08,mmi  rename vbiIntCtrlFindVector with vbiIntVecFind
+01g,13dec08,mmi  remove razorVxWorks.h 
+01f,21nov08,mmi  include vbi.h instead of vdk.h
+01e,19nov08,mmi  change API's names to vbiXXX and miscl. cleanup
+01d,10sep08,md   fix vbiIntCtlrConnect parameters
+01c,23nov07,foo  fix includes
+01b,25oct07,foo  update for real hardware interrupt implementation
+01a,09may07,foo  written
+*/
+
+/*
+ * This module contains the code for accessing the the interrupts configuration
+ * of the virtual board.
+ */
+
+/*#define DEBUG 1*/
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#ifdef CONFIG_WRHV
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#include <linux/module.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiIntVecFind - determine the irq for a specified name
+*
+* This function finds the irq number of a named interrupt from  the virtual
+* board configuration information.
+* 
+* The <intDirection> is either input or output. VB_INPUT_INT for input,
+* VB_OUTPUT_INT for output.
+*
+* EXAMPLES:
+* \cs
+*     fredIntVector = vbiIntVecFind ("fred", VB_INPUT_INT);
+* \ce
+*
+* RETURNS: vector number, VBI_INVALID_IRQ if not found
+*
+*/
+
+vbiIrq_t vbiIntVecFind
+    (
+    char *  intName,		/* string name of the interrupt */
+    int32_t  intDirection 	/* interrupt direction */
+    )
+    {
+    VB_CONFIG *   config = VBI_CONFIG_ADDR_GET();
+    VB_INT_INFO * info = config->interruptConfiguration;
+    int32_t       num  = config->numInts;
+    int32_t       i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (intDirection != (int32_t)(info->intDirection))
+            continue;
+
+        if (!_vbiStrncmp ((char *)intName, (char *)info->intName,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+
+            /* Found */
+
+            return (int32_t)info->intNumber;
+            }
+        }
+
+    return (VBI_INVALID_IRQ); /* no match */
+    }
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiIntVecFind);
+#endif /* CONFIG_WRHV */
diff --git a/kernel/vbiLib.c b/kernel/vbiLib.c
new file mode 100644
index 0000000..8c0f6fb
--- /dev/null
+++ b/kernel/vbiLib.c
@@ -0,0 +1,872 @@
+/* vbiLib.c - virtual Board Interface Library */
+
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01p,02sep09,mmi  mov message API descriptions to vbiMsg.c
+01o,15aug09,rdd  Fixing typo breaking file
+01n,14aug09,mpk  update vbi documentation
+01m,18jul09,mmi  remove flags
+01l,17jul09,mmi  fix description
+01k,16jul09,mpk  update VBI with mips64 support information
+01j,03jul09,mmi  add vbiInterrupt to docs
+01i,12jun09,mmi  append vbInterface.h for apigen
+01h,09jun09,mmi  put back wrhvVbIntNested
+01g,25may09,mmi  Update API descriptions
+01f,12may09,mmi  fix apigen errors and update for VBI 2.0
+01e,11dec08,mmi  replace razor with wrhv prefix
+01d,20nov08,mmi  adopt vbi naming convention
+01c,30sep08,md   update docs
+01b,28nov07,foo  vdk doc
+01a,20nov07,foo  written
+*/
+
+/*
+
+DESCRIPTION
+The vbi library (Virtual board interface) provides support functionality for
+software developers who are writing Virtual board applications, or as a guide to
+developers porting an operating system to the virtual board environment.
+This file contains the generic API that architecture independent. Separate
+documents are provided as supplement for APIs tied to a particular hardware
+architecture platform. 
+
+A given system may be composed of multiple VB where each VB may contain multiple
+Cores. During system bring-up stage hypervisor VB manager allocates resources
+specified in the XML configuration file for the each VB and initializes the
+configuration structure. Then the cores are launched starting at the entry point
+specified in the guest payload image. Hypervisor passes a pointer of the
+configuration page and a 32bit flag that holds the boot options of the core.
+These parameters are passed via stack or registers based on the underlying
+architecture platform.
+
+
+figure 1.1: A simplified overview diagram of a hypervisor system.
+
+\cs
+                           ________Hypercalls___||_______
+       Virtual board 0    |                     ||       |
+     _____________________V___                  ||       |
+    |    _____         _____  |\                ||       |
+    |   |Core |       |Core | | \     shared    ||    ___V____
+    |   | 0   |       | n   | |  \    pages     ||   |        |
+    |   |_____|       |_____| |   \   ______    ||   |        |
+    |_________________________|    \ |______|   ||   |        |
+                         ^           |______|--------|  H     |
+                         |           |______|   ||   |  Y     |
+                .        | interrupts           ||   |  P     |
+                .         ---------------------------|  E     |
+                .        |                      ||   |  R     |
+       Virtual board N   |           ______     ||   |  V     |
+     ____________________V____      |______|    ||   |  I     |
+    |    _____         _____  |    /|______|----||---|  S     |
+    |   |Core |       |Core | |   / |______|    ||   |  O     |
+    |   | 0   |       | n   | |  /              ||   |  R     |
+    |   |_____|       |_____| | /               ||   |________|
+    |_________________________|/                ||        ^
+                          ^                     ||        |
+                          |                     ||        |
+                          |_____________________||________|
+                                                ||
+
+                                                ^
+                                                |   
+                                             guest/hypervisor
+                                              speration line
+
+\ce
+
+
+
+
+Once the guest starts running it must call vbiInit() with the save parameters
+passed to it's entry routine which is the base address of the configuration.
+page. This routine retrieves the control and status page page pointers and
+saves them in the corresponding global variables.
+
+If the VMMU is turned on care must be taken to ensure that the memory regions
+below are mapped via the VMMU. It is suggested to treat these regions as
+devices regions where the mapping is flat and the cache attribute is guarded.
+
+A virtual board core is presented by hypervisor with 3 memory areas:
+
+\ml
+\m 1.
+Virtual Board Configuration Area
+
+This write protected memory area provides fixed configuration information to
+the virtual board.  The address of this is kept in the global variable
+wrhvConfig.  The address of this area is passed to the virtual board as the
+first parameter when the virtual board is started running at it's boot location.
+
+\m 2.
+Virtual Board Status Area
+
+This write protected memory area provides data to the virtual board that 
+changes due to run-time activity, such as registers saved due to an 
+interrupt, timestamps, virtual interrupts etc.  The address of this is
+kept in the global variable wrhvStatus.
+
+\m 3.
+Virtual Board Control Area
+
+This writable memory area is used by the virtual board to communicate 
+information to the hypervisor, where they cannot be passed in a faster manner.
+The address of this area is kept in the global variable wrhvControl.
+
+\me
+
+GLOBAL VARIABLES
+
+\cs
+VB_CONFIG *  wrhvVbConfig; /@ The address of the cores Configuration area
+                            * This value is passed to the core as the first 
+                            * parameter upon startup
+                            @/
+
+VB_CONTROL * wrhvVbControl;/@ The address of the core's Control area @/
+
+VB_STATUS *  wrhvVbStatus;  /@ The address of the core's Status area @/
+
+
+\ce
+
+INCLUDE FILES:  include/vbi/vbi.h
+
+\APPEND  vbiInterrupt.c
+\APPEND  vbiShmem.c
+\APPEND  vbiIdle.c
+\APPEND  vbiPaddr.c
+\APPEND  vbiShow.c
+\APPEND  vbiNs.c
+\APPEND  vbiMsg.c
+\APPEND  ../include/vbInterface.h
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+VB_CONFIG *  wrhvVbConfig;  /* The address of the core's Config area
+                            * This value is passed to the virtual board
+                            * as the first parameter upon startup
+                            */
+
+VB_CONTROL * wrhvVbControl; /* The address of the core's Control area */
+
+VB_STATUS *  wrhvVbStatus;  /* The address of the core's Status area */
+
+int32_t       wrhvVbIntNested; /* Used by VBI interrupt/exception management */
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(wrhvVbConfig);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+* vbiInit - Initialize support for vbi library functions
+*
+* This routine initializes the vbi library 
+*
+* The routine should be called before accessing the virtual board configuration
+* data or making any hypercall. The parameters passed to this function should be
+* same as the boot parameters passed to the first executing program in the
+* running core by hypervisor which is a pointer to the core configuration
+* address. This routine retrieves the status and control page from the 
+* configuration page and initializes the following global variables for future
+* reference.
+*\ms
+*\m - Configuration page base address is stored in wrhvVbConfig
+*\m - Status page base address is stored in wrhvVbStatus
+*\m - Control page base address is stored in wrhvVbControl
+*
+* The user must ensure that this memory regions are mapped if the MMU is
+* turn-on.
+* A good practice would be to map these regions as devices meaning 1-1 
+* translation.
+*\me
+*\ce
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* void vbiInit
+*    (
+*    VB_CONFIG	*config		/@ Address of the VB config area    @/
+*    )
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void vbiInit
+    (
+    VB_CONFIG *	config   /* Address of the VB config area */
+    )
+    {
+
+    /* 
+     * validate the vbi version; minor and maintenance should be backward
+     * compatible.
+     */
+
+    if (config->major < vbiVersionMajor )
+	{ 
+	vbiPanic("Invalid vbi version");
+	}	
+    
+    /* Init global variables for config, status and control structures */
+
+    wrhvVbConfig    = config;
+    wrhvVbControl   = wrhvVbConfig->vbControl;
+    wrhvVbStatus    = wrhvVbConfig->vbStatus;
+   
+    }
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service. 
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target core(s)
+* program counter to it's ENTRY function. The ENTRY function is determined based on
+* the loaded binary image. A core does not execute beyond it's ENTRY function
+* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
+* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+* the third argument to this routine.  
+* The hypercall sends a message to a manager that provides VB managment services.
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset is not
+* determined. The second argument identifies the cores to perform the operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images	
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest OS's
+* responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,	    /@ Id of the VB to suspend	    @/
+*    vbiCore_t     core,	    /@ Core within the VB	    @/
+*    uint32_t     options   /@ reload , start options	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
+*/
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to restart. 
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services. 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were 
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_CORES_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend() 
+*/
+
+/*******************************************************************************
+*
+* vbiKputs - print a string on the hypervisor kernel console
+*
+* This routine makes a hypercall and prints a string of characters to to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputc() 
+*/
+
+/*******************************************************************************
+*
+* vbiKputc - print a character on the hypervisor kernel console
+*
+* This routine makes a hypercall in order to print the specified character to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputc (int c) /@ character to print @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputs()
+*/
+
+/*******************************************************************************
+*
+* vbiPanic - halt the system and dump debug info 
+*
+* This routine makes a hypercall in order to halt the system and display debug
+* information on hypervisor console. If hypervisor is configured with
+* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
+* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
+* the offending cores registers dump is displayed on hypervisor console. If
+* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
+* the debug manager.
+*
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiPanic (const char *msg) /@ pointer to message to print @/
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine 
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running. 
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart 
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          ) 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicVectorSet - Set a vector for the specified irq entry
+*
+* This routine sets a vector for the specified entry in the VIOAPIC redirection
+* table. The previous entry in the table is trashed. Before setting the new
+* vector in the entry the user can obtain the previous entry by calling 
+* vbiVioapicVectorGet(). The first argument passed to this function represent
+* the index to the VIOAPIC redirection table. The second argument is the vector
+* to set in the specified entry. 
+* For Intel architectures when an interrupt is raised the vector determines the
+* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
+*
+* This routine is currently not supported for PPC.  
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicVectorGet - Get a vector in the specified irq entry
+*
+* This routine gets a vector for the specified entry in the VIOAPIC table in
+* VIOAPIC redirection table. It may be used for saving the previous entry
+* before setting a new vector in the specified entry. This takes as an argument
+* the irq number that corresponds to the redirection table offset. 
+*
+* This routine is currently not supported for PPC 
+* This routine is currently not supported for MIPS.  
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: vector number or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntMask - Mask an irq 
+*
+* This routine disables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+* VIOAPIC redirection table is set to 1. After calling this function hypervisor
+* will deliver this IRQ only if this IRQ is enabled by calling
+* vbiVioapicIntUnmask(). 
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
+*
+* This routine enables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC redirection table. This routine makes a hypercall in order to
+* deliver pending interrupts that might be queued while the irq was masked.
+* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+* masked. Then clears the mask bit in the VIOAPIC redirection table for the
+* specified IRQ directed to the calling virtual Core.
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntSend - Send an interrupt
+*
+* This routine makes a hypercall to trigger an IRQ to one or more virtual board
+* that are connected to the line. The first argument passed to this function
+* specifies the IRQ number. The second argument specifies the filter to apply
+* to the list of virtual  boards connected to the IRQ. The third argument is
+* applicable only when VBI_IOAPICSEND_UNICAST filter is specified.
+*
+* In a SMP system a virtual board may have more than one core. If an IRQ is
+* sent to such system hypervisor will deliver the interrupt to the core that
+* was configured to receive the IRQ. The configuration is provided in the board
+* XML configuration file as the example shown below. 
+*
+*\cs
+*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
+*\ce
+*
+* The Vector number is not required to be specified in the XML. If not specified
+* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
+* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
+* 
+* The possible values for the filter (second argument) may be:
+*
+*\ms
+*\m -
+* VBI_IOAPICSEND_ALL	- Send to the group of virtual boards connected to this
+*                         IRQ include the sender board.
+*\m -
+* VBI_IOAPICSEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
+*                         excluding the sender board
+*\m -
+* VBI_IOAPICSEND_UNICAST	- Send an interrupt to the specified virtual board. This
+*		          will be delivered only if the destination board is
+*                         connected to this IRQ 
+*			  
+*\m -
+* VBI_IOAPICSEND_NONE	- Ignore this call.
+*
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntSend 
+*             (
+*             vbiIrq_t irq, 
+*             uint32_t filter,
+*             vbiVb_t target 
+*             )
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
+*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntAck - Acknowledge an irq 
+*
+* This routine acknowledges the specified IRQ for the running core. Calling 
+* this routine causes Hypervisor to purge any pending interrupt that arrived
+* while the acknowledgement was pending. When a virual board receives an interrupt
+* it must call this function. Otherwise Hypervisor will block subsequent interrupt
+* for the same IRQ. Exceptions are not required to be acknowledged.
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntRedirect - Redirect an irq to another core
+*
+* This routine makes a hypercall to redirect an irq from one core to another
+* within the same virtual board. 
+*
+* This routine is currently not supported for MIPS.   
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
diff --git a/kernel/vbiMsg.c b/kernel/vbiMsg.c
new file mode 100644
index 0000000..2104db6
--- /dev/null
+++ b/kernel/vbiMsg.c
@@ -0,0 +1,153 @@
+/* vbiMsg.c - vbi Message library */
+
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,08sep09,mmi  update comments
+01a,2sep09,mmi written
+*/
+
+/*
+
+DESCRIPTION
+VBI message library routines.
+
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+#define DEBUGM(fmt, args...) 
+#define _DEBUGM(fmt, args...) kprintf(fmt, ##args)
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received. This operation may
+* be aborted if an interrupt is delivered to the waiting Virtual board. If the
+* "flags" field in the control structure passed to this function is set to be 
+* VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
+* aborted before the expected message was received successfully.   
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*	   OK - in case of success
+*	   ERROR - in case of error	    
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiStatus_t vbiReceive
+    (
+    void		*rmsg, /* pointer to message to receive  */
+    uint32_t		rlen,  /* length of message to receive   */
+    VBI_MSG_INFO	*info, /* status info structure pointer  */
+    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
+    )                                   
+    { 
+    vbiStatus_t retVal;
+
+    while (1)
+	{
+	retVal = vbiReceiveOp(rmsg, rlen, info, ctl);
+
+        /* if retry flag set, continue */
+
+	if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
+	    break;
+
+        /* if retry flag is set _AND_ msg was aborted, retry */
+	if (info->error != VBI_MSG_ERROR_ABORTED)
+	    break;
+	
+	DEBUGM("%s aborted, retrying \n", __FUNCTION__);
+
+	}
+    return retVal;
+    }
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t   id,    /@ context id to reply the message to @/
+*    void *       buff,  /@ pointer to reply message  @/
+*    size_t       len,   /@ length of message to reply   @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
diff --git a/kernel/vbiNs.c b/kernel/vbiNs.c
new file mode 100644
index 0000000..4353a07
--- /dev/null
+++ b/kernel/vbiNs.c
@@ -0,0 +1,173 @@
+/* wrhvNs.c - hypervisor naming service, client side interface */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01g,18jul09,mmi  fix return types in vbNsXX() definition and comments
+01f,06jul09,mmi  add vbiPrv.h
+01e,21may09,mmi  update api descriptions
+01d,11dec08,md   rename header files
+01c,11dec08,md   rename of ns header files
+01b,19nov08,md   change in message passing API
+01a,03nov08,md   written
+*/
+
+/*
+DESCRIPTION
+
+This module implements a the client side of a simple naming service for the
+internal thread managers of the hypervisor.
+
+The interfaces formulate a message request and send it to the naming service
+for processing.
+
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+
+/* enable/disable debugging */
+
+/*
+ * #define DEBUG  define DEBUG to turn on debugging 
+ */
+
+#ifdef DEBUG
+#define DEBUGM(fmt, args...)    kprintf(fmt, ##args)
+#else
+#define DEBUGM(fmt, args...)   
+#endif
+
+/*******************************************************************************
+*
+* vbiNsRegister - register a service with the naming system
+*
+* This routine registers us as the provider of the specified service.
+* A message for the request is formulated and sent off to the name service
+* manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsRegister 
+*    (
+*    char    *name,		/@ name of service we're registering	@/
+*    uint32_t revision		/@ version of service			@/
+*    )
+*\ce                                                                 
+* RETURNS: OK, or errno if unable to register the service
+*
+* SEE ALSO: vbiNsLookup(), vbiNsUnregister()
+*
+*/
+
+vbiStatus_t vbiNsRegister
+    (
+    char    *name,	/* name of service we're registering */
+    uint32_t revision	/* version of service */
+    )
+    {
+
+    /* sanity check */
+
+    if (name == NULL)
+	return ERROR;
+
+    return (vbiNsOp (VBI_NS_REGISTER, name, revision, NULL));
+    }
+
+/*******************************************************************************
+*
+* vbiNsUnegister - un-register a service with the naming system
+*
+* This routine removes us as the provider of the specified service.
+* A message for the request is formulated and sent off to the name service
+* manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsUnregister 
+*    (
+*    char    *name,		/@ name of service we're unregistering	@/
+*    uint32_t revision		/@ version of service			@/
+*    )
+*\ce                                                                 
+*
+* RETURNS: OK, or errno if unable to un-register the service
+*
+* SEE ALSO: vbiNsLookup(), vbiNsRegister()
+*
+*/
+
+vbiStatus_t vbiNsUnregister
+    (
+    char    *name,	/* name of service we're un-registering */
+    uint32_t revision	/* version of service */
+    )
+    {
+
+    /* sanity check */
+
+    if (name == NULL)
+	return ERROR;
+    
+    return (vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL));
+    }
+
+/*******************************************************************************
+*
+* vbiNsLookup - look up a service provider using the naming system
+*
+* This routine uses the naming system to look up the context id of the
+* provider of the specified service.  A message for the request is
+* formulated and sent off to the name service manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsLookup 
+*    (
+*    char    *name,		/@ name of service we're unregistering	@/
+*    uint32_t revision		/@ version of service			@/
+*    VBI_NS_HANDLE *handle	/@ handle of service provider		@/
+*    )
+*
+* RETURNS: 
+*   ERROR is case of failure
+*
+* SEE ALSO: vbiNsRegister(), vbiNsUnregister()
+*
+*/
+
+vbiStatus_t vbiNsLookup
+    (
+    char     *name,	    /* name of service we're un-registering */
+    uint32_t  revision,	    /* version of service			*/
+    VBI_NS_HANDLE *handle   /* handle of service provider		*/
+    )
+    {
+    
+    /* sanity check */
+
+    if (name == NULL || handle == NULL)
+	return ERROR;
+
+    return (vbiNsOp (VBI_NS_LOOKUP , name, revision, handle));
+    }
diff --git a/kernel/vbiPaddr.c b/kernel/vbiPaddr.c
new file mode 100644
index 0000000..44145a3
--- /dev/null
+++ b/kernel/vbiPaddr.c
@@ -0,0 +1,119 @@
+/* vbiPaddr.c - translate virtual address to a physical address */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01h,12aug09,dtr  Add vbiGuestDmaAddrGet and change name of vbiVirtToPhys to be
+                 vbiGuestPhysToPhys.
+01g,09jun09,mmi  rename physAddr_t to vbiPhysAddr_t
+01f,25may09,mmi  fix function prototype to use  physAddr_t for the physical
+                 address
+01e,15may09,mmi  fix apigen errors
+01d,23jan09,mmi  fix included header file
+01c,13dec08,mmi  replace vbiSyscalls.h with vbiSyscall.h
+01b,19nov08,mmi  introduced the VBI terminology
+01a,18apr08,md   written
+*/
+
+/*
+DESCRIPTION
+These modules provide interfaces to translate the current context's guest
+physical address into the physical machine address. vbiGuestDmaAddrGet is 
+specifically for a guest wanting an address that can be used by a DMA device.
+vbiGuestPhysToPhysAddr is used to return an absolute physical address to used 
+perhaps to communicate with the hypervisor itself maybe buffer pointers.
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+
+/*******************************************************************************
+*
+* vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical 
+*                          address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address to physical address. This may be required for quick buffer 
+* transfer that requires the physical address of a memory region. The 
+* hypervisor may be running with > 4GB memory so the phys address is always 
+* 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestPhysToPhysAddr 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestPhysToPhysAddr
+    (
+    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 ));
+    }
+
+/*******************************************************************************
+*
+* vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address  to a physical address. This may be required for a device 
+* driver that requires the address it can use for DMA. The hypervisor may be 
+* running with > 4GB memory so the phys address is always 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestDmaAddrGet 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestDmaAddrGet
+    (
+    vbiGuestPhysAddr_t gaddr,	/* virtual address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0));
+    }
diff --git a/kernel/vbiShmem.c b/kernel/vbiShmem.c
new file mode 100644
index 0000000..f2eb7a3
--- /dev/null
+++ b/kernel/vbiShmem.c
@@ -0,0 +1,220 @@
+/* vbiShmem.c - shared memory utility functions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01m,03sep09,mmi  use _vbiStrncmp() for comparing strings
+01l,26aug09,mmi  fix WIND00178026: update copyright date
+01k,14jul09,mmi  fix private memory base get
+01j,03jul09,mmi  add private memory utility function
+01i,25may09,mmi  introduce vbiAttr_t for memory region attributes
+01h,22may09,mmi  revert to previous type function argument
+01g,15may09,mmi  fix apigen errors
+01f,17dec08,mmi  Use the correct number of memory region
+01e,12dec08,mmi  replace VB_MAX_RAZOR with VB_MAX_WRHV
+01d,11dec08,mmi  include vbi.h by default
+01c,19nov08,mmi  removed duplicate definition and rename functions to vbiXXX
+01b,23nov07,foo  fix includes
+01a,09may07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module contains the code for retriving the memory regions assigned to
+a virtual board. The information is passed in to the virtual board via the
+configuration structure. There is a descriptor table for each type of memory.
+
+\sh MEMORY TYPES
+\ms
+\m -
+There is a memory memory region assigned only to each board which can be
+retrieved by calling vbiMemRegionFind().
+\m -
+There is a shared memory which may be shared with other boards in the
+system. The shared memory can be retrieved by using vbiShmemRegionFind()
+
+\m -
+Each core in the system is assigned a private memory region. The base address
+and the length of this region may obtained by calling vbiCorePrvMemFind ()
+Alternatively the following macros can be used to obtained similar information
+    - 
+    -
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiShmemRegionFind - locate the shared memory parameters for a given region
+*
+* This function finds the shared memory region associated with the name 
+* specified. The first argument to this function indicates the name of the
+* shared to find. If this region exists in the list of configured regions the
+* address, length and MMU attributes are set in the pointers passed in as 
+* arguments.
+* 
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiShmemRegionFind
+*   (
+*   const char *    smName,	/@ String name of the region    @/
+*   void * *	    addr,	/@ Location - OUT		@/
+*   size_t *	    length,	/@ Length - OUT			@/
+*   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an errror number in case of failure
+*
+* ERRNO:                                
+*
+* SEE ALSO: vbiMemRegionFind() 
+*/
+
+vbiStatus_t vbiShmemRegionFind
+    (
+    int8_t *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    )
+    {
+    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
+    VB_SM_INFO * info = config->sharedMemoryRegionsConfigAddress;
+    int32_t          num  = config->numSm;
+    int32_t          i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!_vbiStrncmp ((char *)smName, (char *)info->name, 
+	    VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return (OK);
+            }
+        }
+    *addr = 0;
+    return (VBI_INVALID_SHMEM);
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiShmemRegionFind);
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiMemRegionFind - locate the memory parameters for a given region
+*
+* This function finds the memory region associated with the name specified. 
+* The first argument to this function indicates the name of the memory to find
+* If this region exists in the list of configured regions the address, 
+* length and MMU attributes are set in the pointers passed in as
+* arguments.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemRegionFind
+*   (
+*   const char *    name,   /@ String name of the region    @/
+*   void * *	    addr,   /@ Location - OUT		    @/
+*   size_t *	    length, /@ Length - OUT		    @/
+*   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiMemRegionFind
+    (
+    int8_t   *	    name,	/* String name of the region  */
+    void   * *	    addr,	/* Location - OUT		    */
+    uint32_t    *length,	/* Length - OUT		    */
+    uint32_t *	    attr	/* MMU Attributes - OUT	    */
+    )
+    {
+    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
+    VB_MEM_INFO * info = config->memoryRegionsConfigAddress;
+    int32_t      num  = config->numMem;
+    int32_t      i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!_vbiStrncmp ((char *)name, (char *)info->name,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return (OK);
+            }
+        }
+    *addr = 0;
+
+    return (VBI_INVALID_SHMEM);
+    
+    }
+
+/******************************************************************************
+*
+* vbiCorePrvMemFind - locate the private memory for a core
+*
+* This function gets the base address of the private memory region assigned to
+* the running core. 
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiCorePrvMemFind 
+*   (
+*   void * *    addr,	    /@ Location - OUT		    @/
+*   size_t *	length	    /@ Length - OUT		    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiCorePrvMemFind 
+    (
+    void * *       addr,      /* Location - OUT */
+    size_t *     length       /* Length - OUT */
+    )
+    {
+
+    *addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
+    *length = VBI_VCORE_PRIVMEM_SIZE_GET();
+    
+    return (OK);
+    }
+
diff --git a/kernel/vbiShow.c b/kernel/vbiShow.c
new file mode 100644
index 0000000..9745ef8
--- /dev/null
+++ b/kernel/vbiShow.c
@@ -0,0 +1,327 @@
+/* vbiShow.c - virtual board data show functions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01l,06aug09,dtr  Modify status intPending to intPendingType.
+01k,04jun09,md   add core number to interrupt display
+01j,25may09,mmi  vbiShow should be the only published API
+01i,20may09,mmi  update function headers
+01h,29apr09,mpk  add Privileged OS VBI support
+01g,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+01f,17apr09,mpk  supervisor VBI calls
+01e,11mar09,mmi  fix defect WIND00158420
+01d,22jan09,mmi  call show routines only if available
+01c,23dec08,mmi  call show routines for access registers
+01b,23dec08,mmi  make vbiMemoryShow non-static
+01a,19dec08,mmi  created based on vbShow version 01j
+*/
+
+/*
+DESCRIPTION
+
+The Virtual Board show functions display virtual board status,
+control and configuration data structures.
+
+*/
+
+#ifdef CONFIG_WRHV
+#define LONG_FMT "0x%lx"
+#define kprintf printk
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiSharedMemoryShow - print information about the shared memory configuration
+*
+* This routine traverse the array of shared memories descriptor for a given board
+* and displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiSharedMemoryShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+* \NOMANUAL
+*/
+
+void vbiSharedMemoryShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_SM_INFO * p = config->sharedMemoryRegionsConfigAddress;
+    int          numSm = config->numSm;
+    void *       pState = config->sharedMemoryRegionsStateAddress;
+    int          i;
+
+    VB_PRINTF("%d Shared memory regions, Config at 0x%x:\n", numSm, p);
+
+    /* dump shared memory info if we have any attached */
+
+    for (i=0; i < numSm; i++,p++)
+        {
+	VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x)\n",
+		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
+		p->attr);
+        }
+
+    VB_PRINTF("Shared memory State at 0x%x:\n", pState);
+
+
+    }
+
+/*******************************************************************************
+*
+* vbiMemoryShow - print information about a board's  memory configuration
+*
+* This routine traverse the array of memory regions descriptor for a given board
+* and displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiSharedMemoryShow (void)
+*
+*\ce
+*
+* RETURNS: returns OK or errno in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiMemoryShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_MEM_INFO * p = config->memoryRegionsConfigAddress;
+    int          numSm = config->numMem;
+    int          i;
+
+    VB_PRINTF ("%d memory regions, Config at 0x%x:\n", numSm, p);
+
+    /* dump shared memory info if we have any attached */
+
+    for (i=0; i < numSm; i++,p++)
+        {
+	VB_PRINTF ("%8s: 0x%08x -> 0x%08x  (attr: 0x%x) (type: %s)\n",
+		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
+                p->attr, p->type);
+        }
+    }
+
+/*******************************************************************************
+*
+* vbiInterruptsShow - print information about a board's interrupts configuration
+*
+* This routine traverse the interrupts descriptors table for a given board and
+* displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiInterruptsShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*\NOMANUAL
+*
+*/
+
+static void vbiInterruptsShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_INT_INFO * p = config->interruptConfiguration;
+    int           numInt = config->numInts;
+    int           i;
+
+    VB_PRINTF ("%d interrupt configurations, Config at 0x%x\n", numInt, p);
+
+    for (i = 0; i < numInt; i++, p++)
+        {
+	if (p->intDirection == VB_INPUT_INT)
+	    {
+	    VB_PRINTF ("%8s: Direction: In, Vector Number: %d, Core: %d\n",
+                p->intName, p->intNumber, p->intCore);
+	    }
+	else
+	    {
+	    VB_PRINTF ("%8s: Direction: Out, Vector Number: %d\n",
+                p->intName, p->intNumber);
+	    }
+        }
+    }
+
+/*******************************************************************************
+*
+* vbiStatusShow - print information about a board's status structures
+*
+* This routine displays information in the status structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiStatusShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiStatusShow
+    (
+    VB_STATUS *p
+    )
+    {
+
+    VB_PRINTF ("VB status: 0x%x\n", p);
+
+    VB_PRINTF ("  Pending interrupts: 0x%08x\n", p->intPendingType);
+    VB_PRINTF ("  timestamp:          %lld\n", p->timeStamp);
+    VB_PRINTF ("  old int disable:    0x%08x\n", p->oldIntDisable);
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    vbiStsRegsDisplay (p);
+#endif
+    }
+
+/*******************************************************************************
+*
+* vbiControlShow - print information about a board's control structures
+*
+* This routine displays information in the control structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiControlShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiControlShow
+    (
+    VB_CONTROL * p
+    )
+    {
+    int i;
+
+    VB_PRINTF ("VB control data: 0x%x\n", p);
+
+    VB_PRINTF ("  Disable interrupts:  0x%08x\n", p->intDisable);
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    vbiCtrlRegsDisplay (p); 
+#endif
+
+    VB_PRINTF ("  Disabled interrupts:");
+    for (i=0; i < VB_MAX_INTERRUPTS; i++)
+        {
+	if ((p->intLevelDisable & (1 << (32 - i))) != 0)
+            {
+	    VB_PRINTF (" %d", i);
+            }
+        }
+    VB_PRINTF ("\n");
+    }
+
+/*******************************************************************************
+*
+* vbiConfigShow - print information about a board's config structures
+*
+* This routine displays information in the config structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiConfigShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*/
+
+void vbiConfigShow
+    (
+    VB_CONFIG * p
+    )
+    {
+
+    VB_PRINTF ("VB config data: 0x%x\n", p);
+
+    VB_PRINTF ("pid:                %d\n",	    p->pid);
+    VB_PRINTF ("Board ID:           %d\n",	    p->boardID);
+
+    VB_PRINTF ("Status Address:     " LONG_FMT "\n", p->vbStatus);
+    VB_PRINTF ("Control Address:    " LONG_FMT "\n", p->vbControl);
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+    VB_PRINTF ("Syscall Table Address:    " LONG_FMT "\n", p->vbSyscallTable);
+#endif
+    VB_PRINTF ("SupervisoryMode:    %d\n",	    p->supervisoryMode);
+
+    VB_PRINTF ("Board Name:         %s\n",	    p->boardName);
+    VB_PRINTF ("Board Type:         %d\n",	    p->boardType);
+    VB_PRINTF ("Physical Memory:    %d\n",     p->physicalMemorySize);
+    VB_PRINTF ("Memory Alias Addr:  0x%08x\n", p->memoryAliasAddress);
+    VB_PRINTF ("Memory Alias Size:  %u\n",     p->memoryAliasSize);
+    VB_PRINTF ("Reset PC:           0x%08x\n", p->resetPC);
+
+    VB_PRINTF ("Timer Frequency:     %d/sec\n",	    p->tickTimerFrequency);
+    VB_PRINTF ("TimeStamp Frequency: %dULL/sec\n",	    p->timeStampFrequency);
+
+    VB_PRINTF ("numInts:             %d\n",	    p->numInts);
+
+    vbiMemoryShow (p);
+    vbiSharedMemoryShow (p);
+    vbiInterruptsShow (p);
+
+    }
diff --git a/kernel/vbiVersion.c b/kernel/vbiVersion.c
new file mode 100644
index 0000000..74a838d
--- /dev/null
+++ b/kernel/vbiVersion.c
@@ -0,0 +1,56 @@
+/* vbiVersion.c - creation version/date/time module */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River License agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,03jul09,mmi  rename VB_VERSION_XX
+01a,16apr09,mmi  written 
+*/
+
+/*
+This module is always built with each executable image.  It provides
+the VBI version id, and the time and date it was built.
+
+The date stamp may be overriden by defining VBI_RUNTIME_CREATION_DATE. This
+will be primarily used by guest OS's that use VBI.
+
+The ANSI predefined macros __DATE__ and __TIME__ are used to provide
+the date/time information.  ANSI compliant compilers are required for
+building all hypervisor executables.
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiVersion.h>
+#else
+#include <vbi.h>
+#include <vbiVersion.h>
+#endif /* CONFIG_WRHV */
+
+/* numerical values for vbi version */
+
+const uint32_t vbiVersionMajor = VBI_VERSION_MAJOR;
+const uint32_t vbiVersionMinor = VBI_VERSION_MINOR;
+const uint32_t vbiVersionMaint = VBI_VERSION_MAINT;
+
+/* string identifiers for vbi version */
+
+const char *vbiRuntimeName       = VBI_RUNTIME_NAME;
+const char *vbiRuntimeVersion    = VBI_RUNTIME_VERSION;
+const char *vbiVersion		 = VBI_VERSION;
+
+#ifdef VBI_RUNTIME_CREATION_DATE
+const char *vbiCreationDate = VBI_RUNTIME_CREATION_DATE;
+#else
+const char *vbiCreationDate = __DATE__ ", " __TIME__;
+#endif
+
diff --git a/kernel/vbiVioApic.c b/kernel/vbiVioApic.c
new file mode 100644
index 0000000..8a50ae4
--- /dev/null
+++ b/kernel/vbiVioApic.c
@@ -0,0 +1,628 @@
+/* vbiVioapic.c - Virtual IO APIC library */
+
+/*
+ * Copyright (c) 2008-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01o,26aug09,mmi  fix WIND00178023: vioapic unmask routine
+01n,13aug09,dtr  Update vbiVioapicIntAck docs and API.
+01m,18jul09,mmi  remove X86 from unmask
+01l,07jul09,mmi  turn off debugging by default
+01k,02jul09,mmi  update send api
+01j,16jun09,mmi  create vioapic structure
+01i,09jun09,mmi  update macros to access config structure
+01h,29mar09,mmi  set MASK properly
+01g,09apr09,mpk  hypervisor 64 bit changes to support mips cavium-octeon bsp
+01f,19mar09,mes  Fixed return values of VBI functions
+01e,24feb09,mmi  include vbiSyscall.h
+01d,22dec09,mmi  fix send function proto
+01c,13dec08,mmi  define structures locally
+01b,11dec08,mmi  replace razor with wrhvVb
+01a,10dec08,mmi created base on x86 version
+*/
+
+/* 
+DESCRIPTION 
+
+This module implements the Virtual IO APIC library
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#define kprintf printk
+#else
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/* globals */
+
+/* externs */
+
+/* defines */
+
+/* APIC register get/set macros  Accesses are double words using an
+ * indirect addressing scheme.
+ * Redirection table entry bits: lower 32 bit 
+ */
+
+/* IO APIC Register Offset */
+
+#define VIOAPIC_REG_ID		0x00	/* IOAPIC ID */
+#define VIOAPIC_REG_VERS	0x01	/* IOAPIC Version */
+#define VIOAPIC_REG_ARB		0x02	/* IOAPIC Arbitration ID */
+#define VIOAPIC_REG_BOOT	0x03	/* IOAPIC Boot Configuration */
+#define VIOAPIC_REG_REDTBL	0x10	/* Redirection Table (24 * 64bit) */
+/* Redirection table entry size per IO APIC */
+
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	128
+
+#ifndef OK
+#define OK  (0)
+#endif
+
+#if 0
+#define DEBUG
+#endif
+
+#ifdef DEBUG
+#define DEBUGM(fmt, arg...) kprintf(fmt, ##arg)
+#else
+#define DEBUGM(fmt, arg...)
+#endif
+/* IO APIC register get/set macros */
+/* Accesses are double words using an
+ * indirect addressing scheme.
+ */
+
+#define	VIOAPIC_REG_GET(base, offset)		\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))))
+
+#define	VIOAPIC_REG_SET(base, offset, value)	\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))) = \
+	(value))
+
+/* data structures */
+
+/* IO APIC ID register */
+typedef union {
+    struct {
+	uint32_t reserved1:24;	/* reserved bits */
+	uint32_t IOAPIC_id:4;	/* apic id */
+	uint32_t reserved2:4;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_ID;
+
+
+/* IO APIC Version Register */
+
+typedef union {
+    struct {
+	uint32_t version:8;		/* version identifier */
+	uint32_t reserved1:8;		/* reserved bits */
+	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
+					 * number of IRQ pins - 1 */
+	uint32_t reserved2:8;		/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_VERSION;
+
+/* Virtual IO APIC redirection table entry. Split into high/low 32 */
+
+typedef union {
+    struct {
+	uint32_t reserved:24;	/* reserved bits */
+	uint32_t destination:8;	/* destination field */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_HIGH;
+
+typedef union {
+    struct {
+	uint32_t vector:8;	/* vector number */
+	uint32_t deliveryMode:3;/* delivery mode:
+				 * fixed, lowest, SMI, reserved, NMI, 
+				 * INIT, reserved, extInt */
+	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
+	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+	uint32_t polarity:1;	/* polarity: 0=high active */
+	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
+				 * accepts level, 0 after EOI */
+	uint32_t trigger:1;	/* 0=edge, 1=level */
+	uint32_t mask:1;	/* 1=masked */
+	uint32_t reserved:15;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_LOW;
+
+typedef struct vioapicEntry
+    {
+    VIOAPIC_REDIR_LOW   vioapicLow;
+    VIOAPIC_REDIR_HIGH  vioapicHigh;
+
+    } VIOAPIC_ENTRY;
+
+typedef struct vioapic
+    {
+    VIOAPIC_ID      id;
+    VIOAPIC_VERSION version;
+    uint32_t        arb;
+    uint32_t        boot;
+    uint32_t        reserved[6];
+    VIOAPIC_ENTRY   entry [128];
+    } VIOAPIC;
+
+/* forward declarations */
+
+/*******************************************************************************
+ *
+ * vbiVioapicAddrGet - Get VIOAPIC base address
+ *
+ * This routine gets the base address of the VIOAPIC specified in the VB
+ * control structure.
+ * 
+ * RETURNS: the base address of the VB VIOAPIC base address
+ *
+ * \NOMANUAL
+ */
+
+void * vbiVioapicAddrGet(void)
+    {
+    return(VBI_VIOAPIC_BASE_GET());
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicVectorSet - Set a vector for the specified irq entry
+*
+* This routine sets a vector for the specified entry in the VIOAPIC redirection
+* table. The previous entry in the table is trashed. Before setting the new
+* vector in the entry the user can obtain the previous entry by calling 
+* vbiVioapicVectorGet(). The first argument passed to this function represent
+* the index to the VIOAPIC redirection table. The second argument is the vector
+* to set in the specified entry. 
+* For Intel architectures when an interrupt is raised the vector determines the
+* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
+*
+* This routine is currently not supported for PPC.  
+*
+* SYNOPSIS
+*\cs
+* 
+*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+vbiStatus_t vbiVioapicVectorSet
+    (
+    vbiIrq_t	irq,	/* descriptor table index */
+    vbiVector_t vector	/* the vector to set in the entry */
+    )
+    {
+    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq	*/
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
+    VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase, 
+		 &(pVioapic->entry[irq].value));
+
+    /* Set the vector at the vioapic entry */
+
+    pVioapic->entry[irq].vioapicLow.field.vector = vector;
+
+    return (OK);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicVectorGet - Get a vector in the specified irq entry
+*
+* This routine gets a vector for the specified entry in the VIOAPIC table in
+* VIOAPIC redirection table. It may be used for saving the previous entry
+* before setting a new vector in the specified entry. This takes as an argument
+* the irq number that corresponds to the redirection table offset. 
+*
+* This routine is currently not supported for PPC 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: vector number or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+vbiVector_t vbiVioapicVectorGet
+    (
+    vbiIrq_t	irq	/* descriptor table index */
+    )
+    {
+    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+    vbiVector_t		vector;
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq	*/
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorGet: base @ 0x%x\n", vioapicBase);
+
+    /* Set the vector at the vioapic entry */
+
+    vector = pVioapic->entry[irq].vioapicLow.field.vector;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
+
+    return (vector);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
+*
+* This routine enables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC redirection table. This routine makes a hypercall in order to
+* deliver pending interrupts that might be queued while the irq was masked.
+* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+* masked. Then clears the mask bit in the VIOAPIC redirection table for the
+* specified IRQ directed to the calling virtual Core.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntUnmask 
+    (
+    vbiIrq_t irq
+    )
+    {
+    volatile VIOAPIC *   pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq number  */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    /* enable interrupt on VB */
+
+    return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
+    
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiVioapicIntUnmask);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiVioapicIntMask - Mask an irq 
+*
+* This routine disables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+* VIOAPIC redirection table is set to 1. After calling this function hypervisor
+* will deliver this IRQ only if this IRQ is enabled by calling
+* vbiVioapicIntUnmask(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntMask
+    (
+    vbiIrq_t irq
+    )
+    {
+    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* check argument */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return ERROR;
+
+    /* set the mask bit */
+
+    pVioapic->entry[irq].vioapicLow.field.mask = 1;
+
+    return (OK);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntAck - Acknowledge an irq 
+*
+* This routine acknowledges the specified IRQ for the running core. Calling 
+* this routine causes Hypervisor to purge any pending interrupt that arrived
+* while the acknowledgement was pending. When a virual board receives an interrupt
+* it must call this function. Otherwise Hypervisor will block subsequent interrupt
+* for the same IRQ. Exceptions are not required to be acknowledged.
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntAck
+    (
+    vbiIrq_t    irq   /* table entry to modify (0-23) */
+    )
+    {
+    VB_CONFIG * config = VBI_CONFIG_ADDR_GET();
+    VB_INT_INFO * info = config->interruptConfiguration;
+
+    /* check argument */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    /* sanity test on irq direction */
+
+    if (info[irq].intDirection != VB_INPUT_INT)
+	return VBI_VIOAPIC_IRQ_INVALID_DIR;
+
+    return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntSend - Send an interrupt
+*
+* This routine makes a hypercall to trigger an IRQ to one or more virtual board
+* that are connected to the line. The first argument passed to this function
+* specifies the IRQ number. The second argument specifies the filter to apply
+* to the list of virtual  boards connected to the IRQ. The third argument is
+* applicable only when VIOAPIC_SEND_UNICAST filter is specified.
+*
+* In a SMP system a virtual board may have more than one core. If an IRQ is
+* sent to such system hypervisor will deliver the interrupt to the core that
+* was configured to receive the IRQ. The configuration is provided in the board
+* XML configuration file as the example shown below. 
+*
+*\cs
+*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
+*\ce
+*
+* The Vector number is not required to be specified in the XML. If not specified
+* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
+* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
+* 
+* The possible values for the filter (second argument) may be:
+*
+*\ms
+*\m -
+* VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
+*                         IRQ include the sender board.
+*\m -
+* VIOAPIC_SEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
+*                         excluding the sender board
+*\m -
+* VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
+*		          will be delivered only if the destination board is
+*                         connected to this IRQ 
+*			  
+*\m -
+* VIOAPIC_SEND_NONE	- Ignore this call.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntSend 
+*             (
+*             vbiIrq_t irq, 
+*             uint32_t filter,
+*             vbiVb_t target 
+*             )
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
+*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
+*
+* INTERNAL
+* Important!! ignore filter and target arguments for now.
+*/
+
+vbiStatus_t vbiVioapicIntSend
+    (
+    vbiIrq_t    irq,		/* irq number			*/
+    uint32_t	filter,		/* destination filter		*/
+    vbiVb_t	target		/* vb id if filter is unicast	*/
+    )
+    {
+    return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiVioapicIntSend);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiVioapicIntRedirect - Redirect an irq to another core
+*
+* This routine makes a hypercall to redirect an irq from one core to another
+* within the same virtual board. 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntRedirect 
+    (
+    vbiIrq_t    irq,		/* irq number			*/
+    vbiCore_t	core		/* vb id if filter is unicast	*/
+    )
+    {
+
+    /* call interrupt redirect operator */
+
+    return (vbiVcoreIntRed_op(irq, core));
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicDisplay - display the virtual I/O APIC table
+*
+* \NOMANUAL
+*/
+
+void vbiVioapicDisplay (void)
+{
+    VIOAPIC_REDIR_LOW	regIoApicRedirLow;
+    VIOAPIC_REDIR_HIGH	regIoApicRedirHigh;
+    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+    uint32_t i;
+
+    static const char * deliveryModes[] = 
+        {" Fixed",	/* 0 */
+	 "Lowest",	/* 1 */
+	 "   SMI",	/* 2 */
+	 "  rsvd",	/* 3 */
+	 "   NMI",	/* 4 */
+	 "  INIT",	/* 5 */
+	 "  rsvd",	/* 6 */
+	 "ExtINT"};	/* 7 */
+
+    /* get the general virtual I/O APIC info */
+
+    VB_PRINTF ("Virtual I/O APIC:\n");
+    VB_PRINTF ("  Base address: 0x%p\n", pVioapic);
+    VB_PRINTF ("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
+    VB_PRINTF ("  version:     %d\n", pVioapic->version.field.version);
+    VB_PRINTF ("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
+
+    /* dump the virtual I/O APIC table */
+
+    VB_PRINTF ("\nRedirection Table:\n");
+    VB_PRINTF ("Entry Vector Mask Status Trig"
+		"  Pol IRR DeliverMode Destination\n");
+    VB_PRINTF (
+	"----- ------ ---- ------ ----- --- --- ----------- -----------\n");
+
+    for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
+
+	regIoApicRedirLow  = pVioapic->entry[i].vioapicLow;
+	regIoApicRedirHigh = pVioapic->entry[i].vioapicHigh;
+
+	VB_PRINTF (" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
+                i,
+                regIoApicRedirLow.field.vector,
+                regIoApicRedirLow.field.mask ? "MASK" : "none",
+                regIoApicRedirLow.field.delivStatus ? "PEND" : "idle",
+                regIoApicRedirLow.field.trigger ? "level" : "edge",
+                regIoApicRedirLow.field.polarity ? "lo" : "hi",
+                regIoApicRedirLow.field.irr,
+                deliveryModes[regIoApicRedirLow.field.deliveryMode],
+                regIoApicRedirLow.field.destMode ? "Set: " : "ID: ",
+                regIoApicRedirHigh.field.destination);
+    }
+    VB_PRINTF ("\n");
+}
diff --git a/kernel/vbiVmmuDoc.c b/kernel/vbiVmmuDoc.c
new file mode 100644
index 0000000..07ed871
--- /dev/null
+++ b/kernel/vbiVmmuDoc.c
@@ -0,0 +1,245 @@
+/* vbiVmmuDoc.c - Virtual Board Interface VMMU APIs */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind RIver License agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,03jul09,mmi  fix vbiVmmuEnable/Disable
+01a,31may09,mmi written
+*/
+
+/*
+DESCRIPTION
+The module contains the VBI VMMU supplement.
+The VMMU configuration structure is an essential data type to understand this
+module. It is the descriptor for an VMMU context with the following info:
+
+\ms
+\m -
+ The VMMU page table base address 
+\m - 
+ The VMMU pages
+\m -
+ The page size granularity 
+\me 
+
+ VMMU_CONFIG definition:
+
+ typedef struct vmmuConfig
+    {
+    VMMU_LEVEL_1_DESC *addr;
+    size_t         pageSize;
+    uint32_t       reserved;
+    uint32_t       vmmu_num;
+    } VMMU_CONFIG;
+
+ The vmmu virtual address space is restricted to 32 bits and is decoded using
+ a level-1/level-2 page table.  The virtual address is decoded as follows:
+\cs
+
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+                11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+ Each page table entry is 8 bytes (2 words) and uses the following format:
+
+ word 0 (32-bits):
+          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+                                          6 7 8 9 0 1 2 3
+         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+                V          - valid bit
+                Hypervisor - reserved for use by hypervisor
+                U0-U7      - user defined attributes
+                ERPN       - extended real page number bits
+                ATTR       - page attributes
+
+ word 1 (32-bits):
+
+          0                                19 20      23 2 2 2 2 2 2 3 3
+                                                         4 5 6 7 8 9 0 1
+         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+         |                                   |          | | |X|X|W|W|R|R|
+         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+                RPN        - real page number
+                R          - page referenced bit
+                C          - page changed bit
+                SX,SW,SR   - supervisor mode protection bits
+                UX,UW,UR   - user mode protection bits
+\ce
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+*/
+
+
+/*******************************************************************************
+*
+* vbiVmmuConfig - configure the hypervisor virtual MMU
+*
+* This makes a hypercall in order to register a context's  virtual MMU within
+* the hypervisor using a fast hypercall. To enable the newly configured VMMU the
+* user must vbiVmmuEnable(). This funtion takes a pointer to a VMMU
+* configuration structure. 
+* Whenever the VMMU state is changed, the vbiVmmuConfig() operation will flush
+* the TLB entries to ensure consistency between the processor and the page tables.
+* 
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuConfig (VMMU_CONFIG * pVmmuConfig) /@ config pointer @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuEnable(), vbiVmmuDisable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuEnable - Enable virtual MMU
+*
+* This routines enables the context's virtual MMU within the hypervisor using a
+* fast hypercall. Before calling this routine one must ensure to configure the
+* VMMU page table, map all necessary memory regions, initialize the VMMU
+* configuration and register it by calling vbiVmmuConfig(). Once the VMMU
+* is enabled any memory access is translated via the VMMU page tables. The
+* argument passed to this routine is the VMMU index. Currently hypervisor
+* supports only one VMMU therefore the index is always zero.
+*
+* Special care must taken to ensure that the executed code and data regions
+* accessed are mapped. It is suggested that any data regions shared with 
+* Hypervisor is idendity mapped (flat mapping or 1-1 translation).
+* 
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuEnable (vbiVmmuIndex_t vmmuIndex) /@ vmmu Handle @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuDisable - Disable VMMU for running core
+*
+* This routines disables the core's VMMU within the hypervisor using a 
+* hypercall. The argument passed to this routine is the VMMU index. Currently
+* hypervisor supports only one VMMU therefore the index is always zero. 
+*
+* This is equivalent to calling vbiVmmuConfig(vbiVmmuIndex_t, NULL). 
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuDisable (VBI_VMMU_HANDLE vmmuHandle) /@ vmmu handle @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuTlbFlush - Flush TLB entries for a range of address
+*
+* This routine flushes the TLB entries for the specified address range from 
+* the virtual MMU.
+* The vbVmmuTlbFlush function is used to ensure that any VMMU translations for
+* the specified address range are cleared from the processor.s TLB cache.
+* All page translations starting at address for a length of length bytes in the
+* specified vmmu context will be cleared from the TLB cache
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuTlbFlush
+*		( 
+*		VMMU_CONFIG *config,	/@ The VMMU configuration to use @/
+*		void	    *addr,	/@ Starting address              @/
+*		size_t	    len)	/@ length                        @/
+*		)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuEnable()
+*/
-- 
1.6.5.rc1

