From 7364cb221aa466997955ae83f834f0355d7fbaaa Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Fri, 26 Feb 2010 15:10:00 -0500
Subject: [PATCH] Example implmentation of a shared memory driver

In order to validate the ability of inter VB communication
via shared memory a test module was needed.

This simple driver serves multiple purposes:
        -test the vbi_find_shmem API
        -illustrate how to communicate from
          kernel space to userspace
        -provide the basic pieces needed for a
          functioning kernel module

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 init/Kconfig.wrhv       |    7 +
 kernel/Makefile         |    1 +
 kernel/sharedmem_test.c |  282 +++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 290 insertions(+), 0 deletions(-)
 create mode 100644 kernel/sharedmem_test.c

diff --git a/init/Kconfig.wrhv b/init/Kconfig.wrhv
index 3ac41ca..71375a7 100644
--- a/init/Kconfig.wrhv
+++ b/init/Kconfig.wrhv
@@ -8,6 +8,13 @@ config WRHV
 	select SERIAL_CORE
 	select SERIAL_CORE_CONSOLE
 
+config SHAREDMEM_TEST
+      tristate "Simple shared memory test between guests"
+      default n
+      depends on WRHV_MILS
+      help
+        This enables basic test code for Virtual Boards to share
+        memory between them.
 
 config WRHV_MILS
 	bool "MILS grade Hypervisor"
diff --git a/kernel/Makefile b/kernel/Makefile
index c723c24..0d34db7 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -53,6 +53,7 @@ obj-$(CONFIG_KEXEC) += kexec.o
 obj-$(CONFIG_BACKTRACE_SELF_TEST) += backtracetest.o
 obj-$(CONFIG_HWTIMER_HOOKS) += hwtimer.o
 obj-$(CONFIG_HWTIMER_TEST) += hwtimer_test.o
+obj-$(CONFIG_SHAREDMEM_TEST) += sharedmem_test.o
 obj-$(CONFIG_COMPAT) += compat.o
 obj-$(CONFIG_CGROUPS) += cgroup.o
 obj-$(CONFIG_CGROUP_DEBUG) += cgroup_debug.o
diff --git a/kernel/sharedmem_test.c b/kernel/sharedmem_test.c
new file mode 100644
index 0000000..63a9aca
--- /dev/null
+++ b/kernel/sharedmem_test.c
@@ -0,0 +1,282 @@
+/*
+* sharedmem_test.c, simple test module to illustrate the use of
+*	shared memory communication between guests
+*
+* Copyright (c) 2010 Wind River Systems, Inc.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+* See the GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/cdev.h>
+#include <asm/pgtable.h>
+
+#include <vbi/types.h>
+#include <vbi/shmem.h>
+#include <vbi/errors.h>
+
+#undef DEBUG
+
+#define SHAREDMEM_MAJOR 253
+#define SHAREDMEM_LEN 128
+#define SHAREDMEM_MAX_REGIONS 10
+#define XML_NAMELEN 255
+
+static unsigned long *shared_base;
+static void *addr;
+static int in_use[SHAREDMEM_MAX_REGIONS] = {0,};
+
+
+/* called when an open call on the device is made */
+static int sharedmem_open(struct inode *inode, struct file *file)
+{
+	char shared_name[XML_NAMELEN];
+	int minor = iminor(inode);
+	unsigned int attr;
+	unsigned int shared_len;
+	int ret;
+
+	if (minor > SHAREDMEM_MAX_REGIONS)
+		return -ENODEV;
+
+	if (in_use[minor])
+		return -EBUSY;
+	else
+		in_use[minor] = 1;
+
+	sprintf(shared_name, "dshm%d", minor);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: open \n");
+	printk(KERN_DEBUG " Looking for shared memory region %s \n",
+		shared_name);
+#endif
+	ret = vbi_find_shmem(shared_name, &addr, &shared_len, &attr);
+	if (ret == VBI_INVALID_SHMEM) {
+		printk(KERN_ERR " Error finding shared memory \n");
+		return -ENODEV;
+	} else {
+		shared_base = ioremap_nocache((unsigned long)addr, shared_len);
+	}
+	return 0;
+}
+
+static int sharedmem_release(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+
+	if (minor > SHAREDMEM_MAX_REGIONS)
+		return -EINVAL;
+
+	in_use[minor] = 0;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: release\n");
+#endif
+	iounmap(shared_base);
+	return 0;
+}
+
+/* called when from sharedmem is read */
+static ssize_t sharedmem_read(struct file *file, char *buf,
+		size_t count, loff_t *ppos)
+{
+	int ret;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: read \n");
+#endif
+
+	if (*ppos < 0)
+		return -EFAULT;
+
+	/* Copy shared memory to userspace */
+	ret = copy_to_user(buf, shared_base, count);
+
+	if (count <= 0 || ret != 0)
+		return -EFAULT;
+
+	return ret;
+}
+
+/* function called when to sharedmem is written */
+static ssize_t sharedmem_write(struct file *file, const char *buf,
+		size_t count, loff_t *ppos)
+{
+	int ret;
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem write ");
+	printk(KERN_DEBUG "    buf %s  count: %d \n", buf, count);
+#endif
+	if (*ppos < 0)
+		return -EFAULT;
+
+	ret = copy_from_user(shared_base, buf, count);  /*get data from user*/
+
+	if (count <= 0 || ret != 0)
+		return -EFAULT;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: write returning: %d \n", count + *ppos);
+#endif
+
+	return count;
+}
+
+/* mmap open */
+void simple_vma_open(struct vm_area_struct *vma)
+{
+#ifdef DEBUG
+	printk(KERN_DEBUG " Simple VMA open, virt 0x%lx\n",
+		vma->vm_start);
+#endif
+#ifdef CONFIG_PPC
+	pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE;
+#else
+	pgprot_noncached(vma->vm_page_prot);
+#endif
+}
+
+void simple_vma_close(struct vm_area_struct *vma)
+{
+#ifdef DEBUG
+	printk(KERN_DEBUG "Simple VMA close \n");
+#endif
+}
+
+struct page *simple_vma_nopage(struct vm_area_struct *vma,
+		unsigned long address, int write_access)
+{
+	struct page *pageptr;
+#ifdef DEBUG
+	unsigned long physaddr = address - vma->vm_start;
+	printk(KERN_NOTICE " VMA Nopage, physaddr 0x%lx  address 0x%lx   \n",
+		physaddr, address);
+#endif
+	pageptr = virt_to_page(shared_base);
+	get_page(pageptr);
+	return pageptr;
+}
+
+static struct vm_operations_struct simple_remap_vm_ops = {
+	.open = simple_vma_open,
+	.close = simple_vma_close,
+};
+
+
+static int sharedmem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long physical = (unsigned long)addr;
+#ifdef DEBUG
+	unsigned long off = vma->vm_pgoff << PAGE_SHIFT;
+	unsigned long vsize = vma->vm_end - vma->vm_start;
+	unsigned long psize = shared_len - off;
+
+	printk(KERN_DEBUG "---- Shared mem MMAP ---- \n");
+	printk(KERN_DEBUG "   offset: 0x%lx \n", off);
+	printk(KERN_DEBUG "   physical: 0x%lx \n", physical);
+	printk(KERN_DEBUG "   vsize: 0x%lx \n", vsize);
+	printk(KERN_DEBUG "   psize: 0x%lx \n", psize);
+	printk(KERN_DEBUG "   vm_start: 0x%lx \n", vma->vm_start);
+#endif
+
+	vma->vm_flags |= VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (io_remap_pfn_range(vma, vma->vm_start, physical >> PAGE_SHIFT,
+		PAGE_SIZE, vma->vm_page_prot))
+	return -EAGAIN;
+
+	vma->vm_ops = &simple_remap_vm_ops;
+	simple_vma_open(vma);
+
+	return 0;
+}
+
+struct cdev shm_cdev = {
+	.kobj   =       {.name = "dshm", },
+	.owner  =       THIS_MODULE,
+};
+
+struct file_operations sharedmem_fops = {
+	.owner    =       THIS_MODULE,
+	.llseek   =       NULL,
+	.read     =       sharedmem_read,
+	.write    =       sharedmem_write,
+	.readdir  =       NULL,
+	.poll     =       NULL,
+	.ioctl    =       NULL,
+	.mmap     =       sharedmem_mmap,
+	.open     =       sharedmem_open,
+	.flush    =       NULL,
+	.release  =       sharedmem_release,
+	.fsync    =       NULL,
+	.fasync   =       NULL,
+	.lock     =       NULL,
+};
+
+static int __init sharedmem_init_module(void)
+{
+	int ret;
+
+	dev_t dev = MKDEV(SHAREDMEM_MAJOR, 0);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: Initializing module\n");
+#endif
+	ret = register_chrdev_region(dev, SHAREDMEM_MAX_REGIONS, "dshm");
+	if (ret)
+		goto error;
+
+	cdev_init(&shm_cdev, &sharedmem_fops);
+	ret = cdev_add(&shm_cdev, dev, SHAREDMEM_MAX_REGIONS);
+	if (ret) {
+		kobject_put(&shm_cdev.kobj);
+		goto error_region;
+	}
+
+	return 0;
+
+error_region:
+	unregister_chrdev_region(dev, SHAREDMEM_MAX_REGIONS);
+error:
+	return ret;
+}
+
+static void __exit sharedmem_cleanup_module(void)
+{
+#ifdef DEBUG
+	printk(KERN_DEBUG "sharedmem: cleaning up module\n");
+#endif
+	cdev_del(&shm_cdev);
+	unregister_chrdev_region(MKDEV(SHAREDMEM_MAJOR, 0),
+		SHAREDMEM_MAX_REGIONS);
+}
+
+module_init(sharedmem_init_module);
+module_exit(sharedmem_cleanup_module);
+MODULE_AUTHOR("Wind River Systems");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Shared Memory device driver");
+
+
-- 
1.7.0

