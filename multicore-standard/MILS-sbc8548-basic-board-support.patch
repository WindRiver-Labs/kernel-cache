From 194b48b93216a1dc893e434fb6c2dcac75fe816a Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Fri, 19 Feb 2010 08:01:33 -0500
Subject: [PATCH] [MILS] sbc8548 basic board support

Add support for Wind River SBC8548 with only minimum functionality.
Currently only the serial and network are supported.

The chosen node is needed to enable early console.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/boot/dts/wrhv_sbc8548.dts     |  398 ++++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/Kconfig        |    7 +
 arch/powerpc/platforms/85xx/Makefile       |    1 +
 arch/powerpc/platforms/85xx/wrhv_sbc8548.c |  171 ++++++++++++
 include/vbi/vdk_interface.h                |   10 +
 5 files changed, 587 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/boot/dts/wrhv_sbc8548.dts
 create mode 100644 arch/powerpc/platforms/85xx/wrhv_sbc8548.c

diff --git a/arch/powerpc/boot/dts/wrhv_sbc8548.dts b/arch/powerpc/boot/dts/wrhv_sbc8548.dts
new file mode 100644
index 0000000..e7a06f6
--- /dev/null
+++ b/arch/powerpc/boot/dts/wrhv_sbc8548.dts
@@ -0,0 +1,398 @@
+/*
+ * SBC8548 Device Tree Source for Linux guest.
+ *
+ * Copyright 2007 Wind River Systems Inc.
+ *
+ * Paul Gortmaker (see MAINTAINERS for contact information)
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+
+/dts-v1/;
+
+/ {
+	model = "SBC8548";
+	compatible = "SBC8548";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	aliases {
+		ethernet0 = &enet0;
+		ethernet1 = &enet1;
+		serial0 = &serial0;
+		serial1 = &serial1;
+		pci0 = &pci0;
+		/* pci1 doesn't have a corresponding physical connector */
+		pci2 = &pci2;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8548@0 {
+			device_type = "cpu";
+			reg = <0>;
+			d-cache-line-size = <0x20>;	// 32 bytes
+			i-cache-line-size = <0x20>;	// 32 bytes
+			d-cache-size = <0x8000>;	// L1, 32K
+			i-cache-size = <0x8000>;	// L1, 32K
+			timebase-frequency = <0>;	// From uboot
+			bus-frequency = <0>;
+			clock-frequency = <0>;
+			next-level-cache = <&L2>;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x00000000 0x10000000>;
+	};
+
+	localbus@e0000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		reg = <0xe0000000 0x5000>;
+		interrupt-parent = <&mpic>;
+
+		ranges = <0x0 0x0 0xff800000 0x00800000		/*8MB Flash*/
+			  0x3 0x0 0xf0000000 0x04000000		/*64MB SDRAM*/
+			  0x4 0x0 0xf4000000 0x04000000 	/*64MB SDRAM*/
+			  0x5 0x0 0xf8000000 0x00b10000		/* EPLD */
+			  0x6 0x0 0xfb800000 0x04000000>;	/*64MB Flash*/
+
+
+		flash@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "cfi-flash";
+			reg = <0x0 0x0 0x800000>;
+			bank-width = <1>;
+			device-width = <1>;
+			partition@0x0 {
+				label = "space";
+				reg = <0x00000000 0x00100000>;
+			};
+			partition@0x100000 {
+				label = "bootloader";
+				reg = <0x00100000 0x00700000>;
+				read-only;
+			};
+		};
+
+		epld@5,0 {
+			compatible = "wrs,epld-localbus";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			reg = <0x5 0x0 0x00b10000>;
+			ranges = <
+				0x0 0x0 0x5 0x000000 0x1fff	/* LED */
+				0x1 0x0 0x5 0x100000 0x1fff	/* Switches */
+				0x3 0x0 0x5 0x300000 0x1fff	/* HW Rev. */
+				0xb 0x0	0x5 0xb00000 0x1fff	/* EEPROM */
+			>;
+
+			led@0,0 {
+				compatible = "led";
+				reg = <0x0 0x0 0x1fff>;
+			};
+
+			switches@1,0 {
+				compatible = "switches";
+				reg = <0x1 0x0 0x1fff>;
+			};
+
+			hw-rev@3,0 {
+				compatible = "hw-rev";
+				reg = <0x3 0x0 0x1fff>;
+			};
+
+			eeprom@b,0 {
+				compatible = "eeprom";
+				reg = <0xb 0 0x1fff>;
+			};
+
+		};
+
+		alt-flash@6,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			reg = <0x6 0x0 0x04000000>;
+			compatible = "cfi-flash";
+			bank-width = <4>;
+			device-width = <1>;
+			partition@0x0 {
+				label = "bootloader";
+				reg = <0x00000000 0x00100000>;
+				read-only;
+			};
+			partition@0x00100000 {
+				label = "file-system";
+				reg = <0x00100000 0x01f00000>;
+			};
+			partition@0x02000000 {
+				label = "boot-config";
+				reg = <0x02000000 0x00100000>;
+			};
+			partition@0x02100000 {
+				label = "space";
+				reg = <0x02100000 0x01f00000>;
+			};
+                };
+        };
+
+	soc8548@e0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "soc";
+		ranges = <0x00000000 0xe0000000 0x00100000>;
+		reg = <0xe0000000 0x00001000>;	// CCSRBAR
+		bus-frequency = <0>;
+		compatible = "simple-bus";
+
+		memory-controller@2000 {
+			compatible = "fsl,8548-memory-controller";
+			reg = <0x2000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <0x12 0x2>;
+		};
+
+		L2: l2-cache-controller@20000 {
+			compatible = "fsl,8548-l2-cache-controller";
+			reg = <0x20000 0x1000>;
+			cache-line-size = <0x20>;	// 32 bytes
+			cache-size = <0x80000>;	// L2, 512K
+			interrupt-parent = <&mpic>;
+			interrupts = <0x10 0x2>;
+		};
+
+		i2c@3000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <0>;
+			compatible = "fsl-i2c";
+			reg = <0x3000 0x100>;
+			interrupts = <0x2b 0x2>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+		};
+
+		i2c@3100 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <1>;
+			compatible = "fsl-i2c";
+			reg = <0x3100 0x100>;
+			interrupts = <0x2b 0x2>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+		};
+
+		dma@21300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,mpc8548-dma", "fsl,eloplus-dma";
+			reg = <0x21300 0x4>;
+			ranges = <0x0 0x21100 0x200>;
+			cell-index = <0>;
+			dma-channel@0 {
+				compatible = "fsl,mpc8548-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <20 2>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,mpc8548-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <21 2>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,mpc8548-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <22 2>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,mpc8548-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <23 2>;
+			};
+		};
+
+		mdio@24520 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,gianfar-mdio";
+			reg = <0x24520 0x20>;
+
+			phy0: ethernet-phy@19 {
+				interrupt-parent = <&mpic>;
+				interrupts = <0x6 0x1>;
+				reg = <0x19>;
+				device_type = "ethernet-phy";
+			};
+			phy1: ethernet-phy@1a {
+				interrupt-parent = <&mpic>;
+				interrupts = <0x7 0x1>;
+				reg = <0x1a>;
+				device_type = "ethernet-phy";
+			};
+		};
+
+		enet0: ethernet@24000 {
+			cell-index = <0>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "gianfar";
+			reg = <0x24000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <0x1d 0x2 0x1e 0x2 0x22 0x2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy0>;
+		};
+
+		enet1: ethernet@25000 {
+			cell-index = <1>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "gianfar";
+			reg = <0x25000 0x1000>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			interrupts = <0x23 0x2 0x24 0x2 0x28 0x2>;
+			interrupt-parent = <&mpic>;
+			phy-handle = <&phy1>;
+		};
+
+		serial0: serial@4500 {
+			cell-index = <0>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4500 0x100>;	// reg base, size
+			clock-frequency = <0>;	// should we fill in in uboot?
+			interrupts = <0x2a 0x2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		serial1: serial@4600 {
+			cell-index = <1>;
+			device_type = "serial";
+			compatible = "ns16550";
+			reg = <0x4600 0x100>;	// reg base, size
+			clock-frequency = <0>;	// should we fill in in uboot?
+			interrupts = <0x2a 0x2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		global-utilities@e0000 {	//global utilities reg
+			compatible = "fsl,mpc8548-guts";
+			reg = <0xe0000 0x1000>;
+			fsl,has-rstcr;
+		};
+
+		crypto@30000 {
+			compatible = "fsl,sec2.1", "fsl,sec2.0";
+			reg = <0x30000 0x10000>;
+			interrupts = <45 2>;
+			interrupt-parent = <&mpic>;
+			fsl,num-channels = <4>;
+			fsl,channel-fifo-len = <24>;
+			fsl,exec-units-mask = <0xfe>;
+			fsl,descriptor-types-mask = <0x12b0ebf>;
+		};
+
+		mpic: pic@40000 {
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			reg = <0x40000 0x40000>;
+			compatible = "chrp,open-pic";
+			device_type = "open-pic";
+		};
+	};
+
+	pci0: pci@e0008000 {
+		cell-index = <0>;
+		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+		interrupt-map = <
+			/* IDSEL 0x01 (PCI-X slot) @66MHz */
+			0x0800 0x0 0x0 0x1 &mpic 0x2 0x1
+			0x0800 0x0 0x0 0x2 &mpic 0x3 0x1
+			0x0800 0x0 0x0 0x3 &mpic 0x4 0x1
+			0x0800 0x0 0x0 0x4 &mpic 0x1 0x1
+
+			/* IDSEL 0x11 (PCI, 3.3V 32bit) @33MHz */
+			0x8800 0x0 0x0 0x1 &mpic 0x2 0x1
+			0x8800 0x0 0x0 0x2 &mpic 0x3 0x1
+			0x8800 0x0 0x0 0x3 &mpic 0x4 0x1
+			0x8800 0x0 0x0 0x4 &mpic 0x1 0x1>;
+
+		interrupt-parent = <&mpic>;
+		interrupts = <0x18 0x2>;
+		bus-range = <0 0>;
+		ranges = <0x02000000 0x0 0x80000000 0x80000000 0x0 0x10000000
+			  0x01000000 0x0 0x00000000 0xe2000000 0x0 0x00800000>;
+		clock-frequency = <66666666>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		reg = <0xe0008000 0x1000>;
+		compatible = "fsl,mpc8540-pcix", "fsl,mpc8540-pci";
+		device_type = "pci";
+	};
+
+	pci2: pcie@e000a000 {
+		cell-index = <2>;
+		interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
+		interrupt-map = <
+
+			/* IDSEL 0x0 (PEX) */
+			0x0000 0x0 0x0 0x1 &mpic 0x0 0x1
+			0x0000 0x0 0x0 0x2 &mpic 0x1 0x1
+			0x0000 0x0 0x0 0x3 &mpic 0x2 0x1
+			0x0000 0x0 0x0 0x4 &mpic 0x3 0x1>;
+
+		interrupt-parent = <&mpic>;
+		interrupts = <0x1a 0x2>;
+		bus-range = <0x0 0xff>;
+		ranges = <0x02000000 0x0 0xa0000000 0xa0000000 0x0 0x20000000
+			  0x01000000 0x0 0x00000000 0xe3000000 0x0 0x08000000>;
+		clock-frequency = <33333333>;
+		#interrupt-cells = <1>;
+		#size-cells = <2>;
+		#address-cells = <3>;
+		reg = <0xe000a000 0x1000>;
+		compatible = "fsl,mpc8548-pcie";
+		device_type = "pci";
+		pcie@0 {
+			reg = <0x0 0x0 0x0 0x0 0x0>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			device_type = "pci";
+			ranges = <0x02000000 0x0 0xa0000000
+				  0x02000000 0x0 0xa0000000
+				  0x0 0x20000000
+
+				  0x01000000 0x0 0x00000000
+				  0x01000000 0x0 0x00000000
+				  0x0 0x08000000>;
+		};
+	};
+	chosen {
+			linux,stdout-path = &serial0;
+	};
+};
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 978fdf7..75f2da8 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -122,6 +122,13 @@ config WRHV_8572
 	select FSL_ULI1575 
 	help
 
+config WRHV_SBC8548
+	bool "WindRiver SBC8548 (HV)"
+	depends on WRHV
+	help
+	  This option enables support for the Wind River SBC8548
+	  Hypervisor enabled board.
+
 endif # MPC85xx
 
 config TQM85xx
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 3b971e3..813158e 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_SBC8560)     += sbc8560.o
 obj-$(CONFIG_SBC8548)     += sbc8548.o
 obj-$(CONFIG_KSI8560)	  += ksi8560.o
 obj-$(CONFIG_WRHV_8572)	  += wrhv_8572ds.o
+obj-$(CONFIG_WRHV_SBC8548) += wrhv_sbc8548.o
diff --git a/arch/powerpc/platforms/85xx/wrhv_sbc8548.c b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
new file mode 100644
index 0000000..f91a3fa
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
@@ -0,0 +1,171 @@
+/*
+ * Wind River SBC8548 HV setup and early boot code.
+ *
+ * Copyright 2010 Wind River Systems Inc.
+ *
+ * Based largely on the sbc8548 and 8572 support - Copyright 2007
+ * Wind River Systems.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/initrd.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/fsl_devices.h>
+#include <linux/of_platform.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/atomic.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/ipic.h>
+#include <asm/pci-bridge.h>
+#include <asm/irq.h>
+#include <mm/mmu_decl.h>
+#include <asm/prom.h>
+#include <asm/udbg.h>
+#include <asm/mpic.h>
+#include <asm/wrhv.h>
+
+#include <sysdev/fsl_soc.h>
+#include <sysdev/fsl_pci.h>
+#define CPU_FREQ 33333333 /* WRHV CPU frequency */
+#define PROC_FREQ 50000000 /* CPU Freq */
+#define PROC_DIV 16  /* Time base divisor */
+#define LOOP_PER_JIF 2662400 /* Loops per jiffy */
+
+extern struct vb_config *wr_config;
+extern struct vb_status *wr_status;
+extern struct vb_control *wr_control;
+
+static void __init wrhv_sbc8548_setup_freq(void)
+{
+	wrhv_cpu_freq = CPU_FREQ;
+	ppc_proc_freq = PROC_FREQ;
+	ppc_tb_freq = ppc_proc_freq / PROC_DIV;
+	loops_per_jiffy = LOOP_PER_JIF;
+}
+
+static void __init wrhv_sbc8548_map_config(void)
+{
+	wr_config = (struct vb_config *) 0xf0000000;
+	wr_control = wr_config->vb_control;
+	wr_status = wr_config->vb_status;
+
+	wrhv_mapping(); /* Map VB_CONFIG structure */
+	vbi_init(wr_config);
+
+	strncpy(cmd_line, VBI_BOOTLINE_ADDR_GET(), VB_MAX_BOOTLINE_LENGTH - 1);
+	cmd_line[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
+}
+
+
+#ifndef CONFIG_WRHV_MILS
+static void __init sbc8548_pic_init(void)
+{
+	wrhv_init_irq();
+}
+#endif
+
+/*
+ * Setup the architecture
+ */
+static void __init sbc8548_setup_arch(void)
+{
+#ifdef CONFIG_PCI
+	struct device_node *np;
+#endif
+
+	if (ppc_md.progress)
+		ppc_md.progress("sbc8548_setup_arch()", 0);
+	wrhv_sbc8548_setup_freq();
+#ifdef CONFIG_PCI
+	for_each_node_by_type(np, "pci") {
+		if (of_device_is_compatible(np, "fsl,mpc8540-pci") ||
+		    of_device_is_compatible(np, "fsl,mpc8548-pcie")) {
+			struct resource rsrc;
+			of_address_to_resource(np, 0, &rsrc);
+			if ((rsrc.start & 0xfffff) == 0x8000)
+				fsl_add_bridge(np, 1);
+			else
+				fsl_add_bridge(np, 0);
+		}
+	}
+#endif
+}
+
+static void sbc8548_show_cpuinfo(struct seq_file *m)
+{
+	uint memsize = total_memory;
+
+	seq_printf(m, "Vendor\t\t: Wind River\n");
+	/* Display the amount of memory */
+	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
+}
+
+static struct of_device_id __initdata of_bus_ids[] = {
+	{ .name = "soc", },
+	{ .type = "soc", },
+	{ .compatible = "simple-bus", },
+	{},
+};
+
+static int __init declare_of_platform_devices(void)
+{
+	of_platform_bus_probe(NULL, of_bus_ids, NULL);
+
+	return 0;
+}
+machine_device_initcall(sbc8548, declare_of_platform_devices);
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init sbc8548_probe(void)
+{
+        unsigned long root = of_get_flat_dt_root();
+
+	wrhv_sbc8548_map_config();
+        return of_flat_dt_is_compatible(root, "SBC8548");
+}
+
+define_machine(sbc8548) {
+	.name		= "WRHV_SBC8548",
+	.probe		= sbc8548_probe,
+	.setup_arch	= sbc8548_setup_arch,
+#ifdef CONFIG_WRHV_MILS
+	.init_IRQ	= mils_pic_init,
+	.get_irq	= mils_vioapic_get_irq,
+#else
+	.init_IRQ	= sbc8548_pic_init,
+	.get_irq	= wrhv_vioapic_get_irq,
+	.power_save	= wrhv_power_save,
+	.earlycon_setup = wrhv_earlycon_setup,
+#endif
+	.show_cpuinfo	= sbc8548_show_cpuinfo,
+	.restart	= wrhv_restart,
+#ifdef CONFIG_PCI
+	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+#endif
+	.calibrate_decr = wrhv_calibrate_decr,
+	.progress	= udbg_progress,
+};
diff --git a/include/vbi/vdk_interface.h b/include/vbi/vdk_interface.h
index 714b57b..33d29b5 100644
--- a/include/vbi/vdk_interface.h
+++ b/include/vbi/vdk_interface.h
@@ -513,6 +513,16 @@ static inline int32_t vbi_get_vioapic_vec(uint32_t irq)
 	return 0;
 }
 
+static inline void mils_pic_init(void)
+{
+	return;
+}
+
+static inline unsigned int mils_vioapic_get_irq(void)
+{
+	return 0;
+}
+
 static inline int32_t vbi_unmask_vioapic_irq(uint32_t irq)
 {
 	return 0;
-- 
1.7.0

