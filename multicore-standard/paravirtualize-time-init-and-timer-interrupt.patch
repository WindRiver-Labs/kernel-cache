From e4fab8ac76b6f10c82a8445f9d4a3cf09632b0e5 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Tue, 27 Oct 2009 15:57:07 -0400
Subject: [PATCH] paravirtualize time init and timer interrupt

seperate time_init into two parts, first part is
common to both native and paravirtual target. 2nd
part is target specific initialization. Also add
paravirtual ops for timer_interrupt and clocksource.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/paravirt.h |    7 +-
 arch/powerpc/kernel/paravirt.c      |   19 +++----
 arch/powerpc/kernel/time.c          |  107 +++++++++++++++--------------------
 arch/powerpc/kernel/vbi/wrhv.c      |   44 ++++++++++----
 4 files changed, 88 insertions(+), 89 deletions(-)

diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
index 0934d05..91a8318 100644
--- a/arch/powerpc/include/asm/paravirt.h
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -36,14 +36,15 @@ extern int paravirt_kgdb_arch_handle_exception(int vector, int signo,
                                struct pt_regs *linux_regs);
 extern int __init native_early_init_dt_scan_memory(unsigned long node,
 				const char *uname, int depth, void *data);
+extern void __init native_time_init_cont(void);
 
 /*
  * paravirtual operations structure
  */
 struct pv_time_ops {
-	void (*hw_time_init)(void);
-	void (*hw_timer_interrupt)(struct pt_regs *regs);
-	void (*hw_clocksource_init)(void);
+	void (*time_init_cont)(void);
+	void (*timer_interrupt)(struct pt_regs *regs);
+	void (*clocksource_init)(void);
 };
 
 struct pv_cpu_ops {
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 2959a5e..47b3eff 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -113,12 +113,9 @@ struct pv_info pv_info = {
 
 /* default native operations */
 struct pv_time_ops pv_time_ops = {
-#if 0
-	.hw_time_init = native_time_init,
-	.hw_timer_interrupt = native_timer_interrupt,
-	.hw_clocksource_init = native_clocksource_init,
-
-#endif
+	.time_init_cont = native_time_init_cont,
+	.timer_interrupt = native_timer_interrupt,
+	.clocksource_init = native_clocksource_init,
 };
 
 struct pv_irq_ops pv_irq_ops = {
@@ -149,19 +146,19 @@ struct pv_mmu_ops pv_mmu_ops = {
 
 
 /* pv_time_ops */
-void __init paravirt_time_init(void)
+void __init paravirt_time_init_cont(void)
 {
-	pv_time_ops.hw_time_init();
+	pv_time_ops.time_init_cont();
 }
 
 void paravirt_timer_interrupt(struct pt_regs * regs)
 {	
-	pv_time_ops.hw_timer_interrupt(regs);
+	pv_time_ops.timer_interrupt(regs);
 }
 
-void __init wrhv_clocksource_init(void)
+void __init paravirt_clocksource_init(void)
 {
-	pv_time_ops.hw_clocksource_init();
+	pv_time_ops.clocksource_init();
 }
 
 
diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index f7370c7..12c55f1 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -73,15 +73,16 @@
 #include <asm/iseries/hv_call_xm.h>
 #endif
 
-#ifdef CONFIG_WRHV
-#include <linux/wrhv.h>
-#endif
 
 /* powerpc clocksource/clockevent code */
 
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
 
+#ifdef CONFIG_PARAVIRT
+#define HWTIMER_USE_JIFFY 1
+#endif
+
 static cycle_t rtc_read(void);
 static struct clocksource clocksource_rtc = {
 	.name         = "rtc",
@@ -129,31 +130,6 @@ struct decrementer_clock {
 
 static DEFINE_PER_CPU(struct decrementer_clock, decrementers);
 
-#ifdef CONFIG_WRHV
-static void wrhv_set_mode(enum clock_event_mode mode,
-				 struct clock_event_device *dev)
-{
-	return;
-}
-
-static int wrhv_set_next_event(unsigned long evt,
-				      struct clock_event_device *dev)
-{
-	//__get_cpu_var(decrementers).next_tb = get_tb_or_rtc() + evt;
-	//set_dec(evt);
-	return 0;
-}
-static struct clock_event_device wrhv_clockevent = {
-       .name           = "wrhv",
-       .shift          = 32,
-       .irq            = 0,
-       .mult           = 1,	/* To be filled in */
-       .set_mode       = wrhv_set_mode,
-       .set_next_event = wrhv_set_next_event,
-       .features       = CLOCK_EVT_FEAT_ONESHOT,
-};
-#endif
-
 #ifdef CONFIG_PPC_ISERIES
 static unsigned long __initdata iSeries_recal_titan;
 static signed long __initdata iSeries_recal_tb;
@@ -598,7 +574,7 @@ static struct hwtimer_data powerpc_timer_data = {
 
 static DECLARE_HWTIMER_LOCK(powerpc_timer_lock);
 
-static struct hwtimer powerpc_timer = {
+struct hwtimer powerpc_timer = {
 	.data		= &powerpc_timer_data,
 	.set_freq	= NULL,
 	.get_freq	= powerpc_timer_get_freq,
@@ -614,7 +590,7 @@ static struct hwtimer powerpc_timer = {
    a per-cpu count of how many ticks are left until the given cpu should
    activate the hwtimer callback. */
 
-static atomic_t hwtimer_cpu_trigger[NR_CPUS];
+atomic_t hwtimer_cpu_trigger[NR_CPUS];
 
 #endif  /*  CONFIG_HWTIMER_HOOKS */
 
@@ -632,31 +608,21 @@ static atomic_t hwtimer_cpu_trigger[NR_CPUS];
  * timer_interrupt - gets called when the decrementer overflows,
  * with interrupts disabled.
  */
-void timer_interrupt(struct pt_regs * regs)
+void paravirt_timer_interrupt(struct pt_regs *regs)
+	__attribute__((weak, alias("native_timer_interrupt")));
+
+void timer_interrupt(struct pt_regs *regs)
+{
+	paravirt_timer_interrupt(regs);
+}
+
+void native_timer_interrupt(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs;
 	struct decrementer_clock *decrementer =  &__get_cpu_var(decrementers);
-#ifdef CONFIG_WRHV
-	struct clock_event_device *evt = &wrhv_clockevent;
-#else	
 	struct clock_event_device *evt = &decrementer->event;
-#endif
 	u64 now;
 
-#ifdef CONFIG_WRHV
-	if (atomic_read(&ppc_n_lost_interrupts) != 0)
-		do_IRQ(regs);
-
-	old_regs = set_irq_regs(regs);
-	irq_enter();
-
-	calculate_steal_time();
-
-	trace_trap_entry(regs, regs->trap);
-
-	wrhv_timer_interrupt(0, NULL);
-#else /* CONFIG_WRHV */
-
 	/* Ensure a positive value is written to the decrementer, or else
 	 * some CPUs will continuue to take decrementer exceptions */
 	set_dec(DECREMENTER_MAX);
@@ -712,7 +678,6 @@ void timer_interrupt(struct pt_regs * regs)
 		cu->current_tb = mfspr(SPRN_PURR);
 	}
 #endif
-#endif /* CONFIG_WRHV */
 
 	irq_exit();
 	set_irq_regs(old_regs);
@@ -935,11 +900,16 @@ void update_vsyscall_tz(void)
 	++vdso_data->tb_update_count;
 }
 
-static void __init clocksource_init(void)
+void paravirt_clocksource_init(void)
+	__attribute__((weak, alias("native_clocksource_init")));
+
+void __init clocksource_init(void)
+{
+	paravirt_clocksource_init();
+}
+
+void __init native_clocksource_init(void)
 {
-#ifdef CONFIG_WRHV
-	return;
-#else
 	struct clocksource *clock;
 
 	if (__USE_RTC())
@@ -957,7 +927,6 @@ static void __init clocksource_init(void)
 
 	printk(KERN_INFO "clocksource: %s mult[%x] shift[%d] registered\n",
 	       clock->name, clock->mult, clock->shift);
-#endif
 }
 
 static int decrementer_set_next_event(unsigned long evt,
@@ -1019,6 +988,24 @@ void secondary_cpu_time_init(void)
 	register_decrementer_clockevent(smp_processor_id());
 }
 
+
+/* time_init() is seperate into two parts, the first part is common to
+ * native and paravirtual target. The 2nd part, time_init_cont is target
+ * specific init
+ */
+void paravirt_time_init_cont(void)
+	__attribute__((weak, alias("native_time_init_cont")));
+
+void __init time_init_cont(void)
+{
+	paravirt_time_init_cont();
+}
+
+void __init native_time_init_cont(void)
+{
+	init_decrementer_clockevent();
+}
+
 /* This function is only called on the boot processor */
 void __init time_init(void)
 {
@@ -1129,14 +1116,10 @@ void __init time_init(void)
 	/* Register the clocksource, if we're not running on iSeries */
 	if (!firmware_has_feature(FW_FEATURE_ISERIES))
 		clocksource_init();
-#ifndef CONFIG_WRHV
-	init_decrementer_clockevent();
-#else
-	wrhv_clockevent.cpumask = cpumask_of_cpu(0);
-	clockevents_register_device(&wrhv_clockevent);
-#endif  /* CONFIG_WRHV */
-}
 
+	/* continue with native or paravirtual specific time_init */
+	time_init_cont();
+}
 
 #define FEBRUARY	2
 #define	STARTOFTIME	1970
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 05788e8..99799ec 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -109,9 +109,11 @@
 
 
 /* powerpc clocksource/clockevent code */
+#define HWTIMER_USE_JIFFY 1
 
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
+#include <linux/hwtimer.h>
 
 static struct vb_config __wr_config;
 struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
@@ -128,6 +130,10 @@ extern int vb_context_mmu_on(int pid,  /* context id */
 			void *pgtable,    /* level 1 page table */
 			int pagesize, int debug);
 
+/* declared in linux/arch/powerpc/kernel/time.c */
+extern atomic_t hwtimer_cpu_trigger[NR_CPUS];
+extern struct hwtimer powerpc_timer;
+
 unsigned long wrhv_cpu_freq = 0;
 
 void wrhv_mapping(void)
@@ -216,13 +222,6 @@ void wrhv_restart(void)
 	while (1);
 }
 
-static struct irqaction wrhv_timer_irq = {
-	.handler = wrhv_timer_interrupt,
-	.flags= IRQF_DISABLED,
-	.mask = CPU_MASK_NONE,
-	.name = "timer",
-};
-
 void __init wrhv_calibrate_decr(void)
 {
 	/* The timebase is updated every 8 bus clocks */
@@ -443,20 +442,39 @@ void wrhv_hw_timer_interrupt(struct pt_regs * regs)
 
 	wrhv_timer_interrupt(0, NULL);
 
+#ifdef HWTIMER_USE_JIFFY
+	if (atomic_dec_and_test(&hwtimer_cpu_trigger[smp_processor_id()])) {
+		atomic_set(&hwtimer_cpu_trigger[smp_processor_id()],
+		num_online_cpus());
+		spin_lock(powerpc_timer.lock);
+		if (powerpc_timer.hook != NULL)
+			(powerpc_timer.hook) (powerpc_timer.hook_data);
+		spin_unlock(powerpc_timer.lock);
+	}
+#endif /* HWTIMER_USE_JIFFY */
+
 	irq_exit();
 	set_irq_regs(old_regs);
+
 	trace_trap_exit();
 }
 
-void __init wrhv_hw_clocksource_init(void)
+void __init wrhv_clocksource_init(void)
 {
 	return;
 }
 extern atomic_t hwtimer_cpu_trigger[];
 
-void __init wrhv_hw_time_init(void)
+void __init wrhv_time_init_cont(void)
 {
-	return;
+	if (smp_processor_id() == 0) {
+		unsigned int i;
+		for_each_possible_cpu(i)
+		atomic_set(&hwtimer_cpu_trigger[i], i + 1);
+		register_hwtimer(&powerpc_timer);
+	}
+	wrhv_clockevent.cpumask = cpumask_of_cpu(0);
+	clockevents_register_device(&wrhv_clockevent);
 }
 
 
@@ -916,9 +934,9 @@ void wrhv_init(void)
 	pv_info.name = "wrhv";
 	pv_info.paravirt_enabled = 1;
 
-	pv_time_ops.hw_time_init = wrhv_hw_time_init;
-	pv_time_ops.hw_timer_interrupt = wrhv_hw_timer_interrupt;
-	pv_time_ops.hw_clocksource_init = wrhv_hw_clocksource_init;
+	pv_time_ops.time_init_cont = wrhv_time_init_cont;
+	pv_time_ops.timer_interrupt = wrhv_hw_timer_interrupt;
+	pv_time_ops.clocksource_init = wrhv_clocksource_init;
 
 	pv_irq_ops.do_IRQ = wrhv_do_IRQ;
 	pv_irq_ops.irq_of_parse_and_map =
-- 
1.6.5.2

