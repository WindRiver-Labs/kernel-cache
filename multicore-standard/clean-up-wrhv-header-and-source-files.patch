From 9e5d836fa6f96ed3169efccc05be96752dcd99c7 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Tue, 27 Oct 2009 15:57:05 -0400
Subject: [PATCH 36/59] clean up wrhv header and source files

remove unnecessary CONFIG_WRHV define in hypervisor specific
file and clean up some comment.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/reg_wrhv.h       |    3 +-
 arch/powerpc/kernel/entry_32.S            |    3 -
 arch/powerpc/kernel/vbi/wrhv.c            |   66 ++--------------------------
 arch/powerpc/platforms/85xx/wrhv_8572ds.c |    9 +----
 4 files changed, 8 insertions(+), 73 deletions(-)

diff --git a/arch/powerpc/include/asm/reg_wrhv.h b/arch/powerpc/include/asm/reg_wrhv.h
index 77f4514..4d88f9e 100644
--- a/arch/powerpc/include/asm/reg_wrhv.h
+++ b/arch/powerpc/include/asm/reg_wrhv.h
@@ -24,7 +24,8 @@
 
 #include <linux/stringify.h>
 #include <asm/cputable.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
+#include <vbi/syscalls.h>
 
 /* macro used in on entry_32.S */
 #define PARAVIRT_ENABLE_MSR_EE      WRHV_INT_UNLOCK(r10,r11)
diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 046400c..e504e8a 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -31,9 +31,6 @@
 #include <asm/asm-offsets.h>
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
-#ifdef CONFIG_WRHV
-#include <vbi/syscalls.h>
-#endif /* CONFIG_WRHV */
 
 /*
  * MSR_KERNEL is > 0x10000 on 4xx/Book-E since it include MSR_CE.
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 577b2b8..3c0bda1 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -328,9 +328,7 @@ void wrhv_do_IRQ(struct pt_regs *regs)
 	 * The value NO_IRQ_IGNORE is for buggy hardware and means that this
 	 * IRQ has already been handled. -- Tom
 	 */
-#ifdef CONFIG_WRHV
 check_again:
-#endif
 	irq = ppc_md.get_irq();
 
 	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
@@ -369,9 +367,7 @@ check_again:
 		} else
 #endif
 			generic_handle_irq(irq);
-#ifdef CONFIG_WRHV
 		goto check_again;
-#endif
 	} else if (irq != NO_IRQ_IGNORE)
 		/* That's not SMP safe ... but who cares ? */
 		set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
@@ -515,13 +511,6 @@ void __init wrhv_MMU_init(void)
 	total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
 	lowmem_end_addr = memstart_addr + total_lowmem;
 
-#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_WRHV)
-	/* Freescale Book-E parts expect lowmem to be mapped by fixed TLB
-	 * entries, so we need to adjust lowmem to match the amount we can map
-	 * in the fixed entries */
-	adjust_total_lowmem();
-#endif /* CONFIG_FSL_BOOKE && !CONFIG_WRHV*/
-
 	if (total_lowmem > __max_low_memory) {
 		total_lowmem = __max_low_memory;
 		lowmem_end_addr = memstart_addr + total_lowmem;
@@ -612,8 +601,6 @@ int __init wrhv_gfar_of_init(void)
 
 		/* If we aren't the FEC we have multiple interrupts */
 		if (model && strcasecmp(model, "FEC")) {
-#if defined(CONFIG_WRHV)
-#include <vbi/vbiInterrupt.h>
 			int vector;
 			char eTsec_tx[10];
 			char eTsec_rx[10];
@@ -640,15 +627,6 @@ int __init wrhv_gfar_of_init(void)
 			r[3].start = vector;
 			r[3].end = vector;
 			r[3].flags = IORESOURCE_IRQ;
-#else
-			r[1].name = gfar_tx_intr;
-
-			r[2].name = gfar_rx_intr;
-			of_irq_to_resource(np, 1, &r[2]);
-
-			r[3].name = gfar_err_intr;
-			of_irq_to_resource(np, 2, &r[3]);
-#endif
 			n_res += 2;
 		}
 
@@ -762,11 +740,6 @@ void wrhv_flush_dcache_page(struct page *page)
 void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
 		      pte_t pte)
 {
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-	unsigned long access = 0, trap;
-#endif
-#endif /* !CONFIG_WRHV */
 	unsigned long pfn = pte_pfn(pte);
 
 	/* handle i-cache coherency */
@@ -798,30 +771,6 @@ void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
 			set_bit(PG_arch_1, &page->flags);
 		}
 	}
-
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-	/* We only want HPTEs for linux PTEs that have _PAGE_ACCESSED set */
-	if (!pte_young(pte) || address >= TASK_SIZE)
-		return;
-
-	/* We try to figure out if we are coming from an instruction
-	 * access fault and pass that down to __hash_page so we avoid
-	 * double-faulting on execution of fresh text. We have to test
-	 * for regs NULL since init will get here first thing at boot
-	 *
-	 * We also avoid filling the hash if not coming from a fault
-	 */
-	if (current->thread.regs == NULL)
-		return;
-	trap = TRAP(current->thread.regs);
-	if (trap == 0x400)
-		access |= _PAGE_EXEC;
-	else if (trap != 0x300)
-		return;
-	hash_preload(vma->vm_mm, address, access, trap);
-#endif /* CONFIG_PPC_STD_MMU */
-#endif /* !CONFIG_WRHV */
 }
 
 /* arch/powerpc/mm/mmu_context_32.c */
@@ -934,12 +883,7 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 		/* set the trace bit if we're stepping */
 		if (remcom_in_buffer[0] == 's') {
 #if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
-#ifdef CONFIG_WRHV
 			wr_control->vb_control_regs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
-#else
-			mtspr(SPRN_DBCR0,
-			      mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);
-#endif
 			linux_regs->msr |= MSR_DE;
 #else
 			linux_regs->msr |= MSR_SE;
@@ -1001,7 +945,7 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	int irq;
 	u8  pin;
 	char VectorName[8];
-	
+
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 
 	switch (dev->bus->number) {
@@ -1025,11 +969,11 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	default:
 		break;
 	}
-	
+
 	dev->irq = irq;
-        printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d\n",
-                dev->bus->number, dev->class, dev->irq);
-	
+	printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d\n",
+		dev->bus->number, dev->class, dev->irq);
+
 	return irq;
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index a55cdb3..f1b6cf4 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -109,9 +109,7 @@ static void __init wrhv_8572ds_setup_arch(void)
 	if (ppc_md.progress)
 		ppc_md.progress("wrhv_8572ds_setup_arch()", 0);
 
-#ifdef CONFIG_WRHV
 	wrhv_cpu_freq = get_bsp_clock_freq();
-#endif
 
 #ifdef CONFIG_PCI
 	for_each_node_by_type(np, "pci") {
@@ -140,10 +138,6 @@ static void wrhv_8572ds_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
 }
 
-extern VB_CONFIG	*wrhvConfig;
-extern VB_STATUS	*wrhvStatus;
-extern VB_CONTROL	*wrhvControl;
-
 /*
  * Called very early, device-tree isn't unflattened
  */
@@ -151,8 +145,7 @@ static int __init wrhv_8572ds_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
 
-	/*
-	 * wrhvConfig should have been initialized in wrhv_init(),
+	/* wr_config should have been initialized in wrhv_init(),
 	 * continue to complete the vbi initialization here.
 	 */
 	wrhv_mapping(); /* Map vb_config structure */
-- 
1.6.5.2

