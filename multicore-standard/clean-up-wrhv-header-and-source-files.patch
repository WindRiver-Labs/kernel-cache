From 6e4874fe49d668eec7744cfde3ac32ebe3a0f2bb Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Tue, 27 Oct 2009 15:57:05 -0400
Subject: [PATCH 1/3] clean up wrhv header and source files

remove unnecessary CONFIG_WRHV define in hypervisor specific
file and clean up some comment.

Signed-off-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/include/asm/reg_wrhv.h       |    1 +
 arch/powerpc/kernel/entry_32.S            |    3 -
 arch/powerpc/kernel/vbi/wrhv.c            |   61 +---------------------------
 arch/powerpc/platforms/85xx/wrhv_8572ds.c |   12 ++----
 arch/powerpc/sysdev/fsl_soc.c             |   30 --------------
 5 files changed, 8 insertions(+), 99 deletions(-)

diff --git a/arch/powerpc/include/asm/reg_wrhv.h b/arch/powerpc/include/asm/reg_wrhv.h
index f071b0e..a36f2ef 100644
--- a/arch/powerpc/include/asm/reg_wrhv.h
+++ b/arch/powerpc/include/asm/reg_wrhv.h
@@ -25,6 +25,7 @@
 #include <linux/stringify.h>
 #include <asm/cputable.h>
 #include <vbi/interface.h>
+#include <vbi/syscalls.h>
 
 /* macro used in on entry_32.S */
 #define PARAVIRT_ENABLE_MSR_EE      WRHV_INT_UNLOCK(r10,r11)
diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 046400c..e504e8a 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -31,9 +31,6 @@
 #include <asm/asm-offsets.h>
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
-#ifdef CONFIG_WRHV
-#include <vbi/syscalls.h>
-#endif /* CONFIG_WRHV */
 
 /*
  * MSR_KERNEL is > 0x10000 on 4xx/Book-E since it include MSR_CE.
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index b1d2e04..c0b4142 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -331,9 +331,7 @@ void wrhv_do_IRQ(struct pt_regs *regs)
          * The value NO_IRQ_IGNORE is for buggy hardware and means that this
          * IRQ has already been handled. -- Tom
          */
-#ifdef CONFIG_WRHV
 check_again:
-#endif
         irq = ppc_md.get_irq();
 
         if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
@@ -372,9 +370,7 @@ check_again:
                 } else
 #endif
                         generic_handle_irq(irq);
-#ifdef CONFIG_WRHV
                 goto check_again;
-#endif
         } else if (irq != NO_IRQ_IGNORE)
                 /* That's not SMP safe ... but who cares ? */
                 set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
@@ -518,13 +514,6 @@ void __init wrhv_MMU_init(void)
         total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
         lowmem_end_addr = memstart_addr + total_lowmem;
 
-#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_WRHV)
-        /* Freescale Book-E parts expect lowmem to be mapped by fixed TLB
-         * entries, so we need to adjust lowmem to match the amount we can map
-         * in the fixed entries */
-        adjust_total_lowmem();
-#endif /* CONFIG_FSL_BOOKE && !CONFIG_WRHV*/
-
         if (total_lowmem > __max_low_memory) {
                 total_lowmem = __max_low_memory;
                 lowmem_end_addr = memstart_addr + total_lowmem;
@@ -615,8 +604,6 @@ int __init wrhv_gfar_of_init(void)
 
                 /* If we aren't the FEC we have multiple interrupts */
                 if (model && strcasecmp(model, "FEC")) {
-#if defined(CONFIG_WRHV)
-#include <vbi/interrupt.h>
                         int vector;
                         char eTsec_tx[10];
                         char eTsec_rx[10];
@@ -643,15 +630,6 @@ int __init wrhv_gfar_of_init(void)
                         r[3].start = vector;
 			r[3].end = vector;
                         r[3].flags = IORESOURCE_IRQ;
-#else
-                        r[1].name = gfar_tx_intr;
-
-                        r[2].name = gfar_rx_intr;
-                        of_irq_to_resource(np, 1, &r[2]);
-
-                        r[3].name = gfar_err_intr;
-                        of_irq_to_resource(np, 2, &r[3]);
-#endif
                         n_res += 2;
                 }
 
@@ -765,11 +743,6 @@ void wrhv_flush_dcache_page(struct page *page)
 void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
                       pte_t pte)
 {
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-        unsigned long access = 0, trap;
-#endif
-#endif /* !CONFIG_WRHV */
         unsigned long pfn = pte_pfn(pte);
 
         /* handle i-cache coherency */
@@ -801,30 +774,6 @@ void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
                         set_bit(PG_arch_1, &page->flags);
                 }
         }
-
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-        /* We only want HPTEs for linux PTEs that have _PAGE_ACCESSED set */
-        if (!pte_young(pte) || address >= TASK_SIZE)
-                return;
-
-        /* We try to figure out if we are coming from an instruction
-         * access fault and pass that down to __hash_page so we avoid
-         * double-faulting on execution of fresh text. We have to test
-         * for regs NULL since init will get here first thing at boot
-         *
-         * We also avoid filling the hash if not coming from a fault
-         */
-        if (current->thread.regs == NULL)
-                return;
-        trap = TRAP(current->thread.regs);
-  	if (trap == 0x400)
-                access |= _PAGE_EXEC;
-        else if (trap != 0x300)
-                return;
-        hash_preload(vma->vm_mm, address, access, trap);
-#endif /* CONFIG_PPC_STD_MMU */
-#endif /* !CONFIG_WRHV */
 }
 
 /* arch/powerpc/mm/mmu_context_32.c */
@@ -937,12 +886,7 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
                 /* set the trace bit if we're stepping */
                 if (remcom_in_buffer[0] == 's') {
 #if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
-#ifdef CONFIG_WRHV
                         wrhvControl->vbControlRegs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
-#else
-                        mtspr(SPRN_DBCR0,
-                              mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);
-#endif
                         linux_regs->msr |= MSR_DE;
 #else
                         linux_regs->msr |= MSR_SE;
@@ -961,9 +905,10 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 void wrhv_init(void)
 {
 	/* initialize wrhvConfig so that we can access
-	 * vbi configuration.
+	 * vbi configuration. The vbi configuration space
+	 * is defined in Hypervisor linux.xml
 	 */
-	wrhvConfig = (VB_CONFIG *)0xF0000000;   /* TODO */
+	wrhvConfig = (VB_CONFIG *)0xF0000000;
 	wrhvControl = wrhvConfig->vbControl;
 	wrhvStatus = wrhvConfig->vbStatus;
 
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index 954265f..770e1ed 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -36,6 +36,10 @@
 #include <asm/udbg.h>
 #include <asm/wrhv.h>
 
+extern VB_CONFIG	*wrhvConfig;
+extern VB_STATUS	*wrhvStatus;
+extern VB_CONTROL	*wrhvControl;
+
 static void __init wrhv_sbc85xx_pic_init(void)
 {
 	wrhv_init_irq();
@@ -63,7 +67,6 @@ static int mpc85xx_exclude_device(struct pci_controller *hose,
 }
 #endif /* CONFIG_PCI */
 
-#ifdef CONFIG_WRHV
 static int get_bsp_clock_freq(void)
 {
 	VBI_BSP_MSG		clk_msg;
@@ -93,7 +96,6 @@ static int get_bsp_clock_freq(void)
 		 clk_reply.dataVal);
 	return clk_reply.dataVal;
 }
-#endif /* CONFIG_WRHV */
 
 /*
  * Setup the architecture
@@ -107,9 +109,7 @@ static void __init wrhv_8572ds_setup_arch(void)
 	if (ppc_md.progress)
 		ppc_md.progress("wrhv_8572ds_setup_arch()", 0);
 
-#ifdef CONFIG_WRHV
 	wrhv_cpu_freq = get_bsp_clock_freq();
-#endif
 
 #ifdef CONFIG_PCI
 	for_each_node_by_type(np, "pci") {
@@ -138,10 +138,6 @@ static void wrhv_8572ds_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
 }
 
-extern VB_CONFIG	*wrhvConfig;
-extern VB_STATUS	*wrhvStatus;
-extern VB_CONTROL	*wrhvControl;
-
 /*
  * Called very early, device-tree isn't unflattened
  */
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 88bb42a..a15e9fb 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -322,35 +322,6 @@ int __init native_gfar_of_init(void)
 
 		/* If we aren't the FEC we have multiple interrupts */
 		if (model && strcasecmp(model, "FEC")) {
-#if defined(CONFIG_WRHV)
-#include <vbi/interrupt.h>
-			int vector;
-			char eTsec_tx[10];
-			char eTsec_rx[10];
-			char eTsec_err[10];
-			
-			sprintf(eTsec_tx,"etsec%d_tx", i+1);
-			sprintf(eTsec_rx,"etsec%d_rx", i+1);
-			sprintf(eTsec_err,"etsec%d_err", i+1);
-
-			r[1].name = gfar_tx_intr;
-			vector = vbiIntVecFind(eTsec_tx, VB_INPUT_INT);
-			r[1].start = vector;
-			r[1].end = vector;
-			r[1].flags = IORESOURCE_IRQ;
-		
-			r[2].name = gfar_rx_intr;	
-			vector = vbiIntVecFind(eTsec_rx, VB_INPUT_INT);
-			r[2].start = vector;
-			r[2].end = vector;
-			r[2].flags = IORESOURCE_IRQ;
-
-			r[3].name = gfar_err_intr;
-			vector = vbiIntVecFind(eTsec_err, VB_INPUT_INT);
-			r[3].start = vector;
-			r[3].end = vector;
-			r[3].flags = IORESOURCE_IRQ;
-#else
 			r[1].name = gfar_tx_intr;
 
 			r[2].name = gfar_rx_intr;
@@ -358,7 +329,6 @@ int __init native_gfar_of_init(void)
 
 			r[3].name = gfar_err_intr;
 			of_irq_to_resource(np, 2, &r[3]);
-#endif
 			n_res += 2;
 		}
 
-- 
1.6.5.2

