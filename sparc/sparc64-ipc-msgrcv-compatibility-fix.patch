From f65a6e5532c58523e3e1bad6a376d6dbb7efd5bb Mon Sep 17 00:00:00 2001
From: Hong H. Pham <hong.pham@windriver.com>
Date: Tue, 17 Feb 2009 10:45:16 -0500
Subject: [PATCH] sparc64 ipc msgrcv compatibility fix

The glibc-2.8 SPARC64 SysV IPC msgrcv() handler uses the old API, which
requires passing an ipc_kludge structure as the fifth argument.  The Linux
kernel's SPARC64 sys_ipc msgrcv handler does not check for the backward
compatibility hack, so a bogus "msgflag" parameter gets passed down to the
real SysV IPC handler.  This causes msgrcv() to hang.

The fix is to implement the msgrcv backwards compatibility hack, despite
the comment in sys_ipc() that there's no need for this hack.

Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 arch/sparc64/kernel/sys_sparc.c |   27 ++++++++++++++++++++++++---
 1 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/arch/sparc64/kernel/sys_sparc.c b/arch/sparc64/kernel/sys_sparc.c
index 73b287e..b7ec1ab 100644
--- a/arch/sparc64/kernel/sys_sparc.c
+++ b/arch/sparc64/kernel/sys_sparc.c
@@ -437,8 +437,11 @@ SYSCALL_DEFINE6(ipc, unsigned int, call, int, first, unsigned long, second,
 		unsigned long, third, void __user *, ptr, long, fifth)
 {
 	long err;
+	int version;
+
+	version = call >> 16; /* hack for backward compatibility */
+	call &= 0xffff;
 
-	/* No need for backward compatibility. We can start fresh... */
 	if (call <= SEMCTL) {
 		switch (call) {
 		case SEMOP:
@@ -471,8 +474,26 @@ SYSCALL_DEFINE6(ipc, unsigned int, call, int, first, unsigned long, second,
 					 (int)third);
 			goto out;
 		case MSGRCV:
-			err = sys_msgrcv(first, ptr, (size_t)second, fifth,
-					 (int)third);
+			switch (version) {
+			case 0: {
+				struct ipc_kludge tmp;
+
+				err = -EINVAL;
+				if (!ptr)
+					break;
+				if ((err = copy_from_user(&tmp,
+				              (struct ipc_kludge __user *) ptr,
+				              sizeof (tmp)) ? -EFAULT : 0))
+					break;
+				err = sys_msgrcv(first, tmp.msgp,
+				                 (size_t) second, tmp.msgtyp,
+				                 third);
+				break;
+			}
+			default:
+				err = sys_msgrcv(first, ptr, (size_t)second,
+				                 fifth, (int)third);
+			}
 			goto out;
 		case MSGGET:
 			err = sys_msgget((key_t)first, (int)second);
