From cb9e04836e913f91d2f62eaa0e70721fda387aba Mon Sep 17 00:00:00 2001
From: Francis Bogsanyi <francis.bogsanyi@windriver.com>
Date: Wed, 5 Nov 2008 13:07:25 -0500
Subject: [PATCH] SPARC64 SUN4V hypervisor watchdog

Add SPARC64 SUN4V hypervisor watchdog driver.

Signed-off-by: Francis Bogsanyi <francis.bogsanyi@windriver.com>
Signed-off-by: Hong H. Pham <hong.pham@windriver.com>
---
 drivers/watchdog/Kconfig                   |    8 +
 drivers/watchdog/Makefile                  |    2 +
 drivers/watchdog/sun4v_mach_set_watchdog.S |   15 ++
 drivers/watchdog/sun4v_wdt.c               |  269 ++++++++++++++++++++++++++++
 4 files changed, 294 insertions(+), 0 deletions(-)
 create mode 100644 drivers/watchdog/sun4v_mach_set_watchdog.S
 create mode 100644 drivers/watchdog/sun4v_wdt.c

diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index b02d0cd..8b5bfde 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -813,6 +813,14 @@ config WATCHDOG_RIO
 	  machines.  The watchdog timeout period is normally one minute but
 	  can be changed with a boot-time parameter.
 
+config SUN4V_HYPERVISOR_WDT
+	tristate "Sun4V Hypervisor Watchdog support"
+	depends on SPARC64
+	default m
+	help
+	  Say Y here to support the Hypervisor watchdog capability on Sun4V
+	  machines.
+
 # XTENSA Architecture
 
 #
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index e0ef123..0a32c33 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -122,6 +122,8 @@ obj-$(CONFIG_SH_WDT) += shwdt.o
 # SPARC Architecture
 
 # SPARC64 Architecture
+sun4v_watchdog-objs := sun4v_wdt.o sun4v_mach_set_watchdog.o
+obj-$(CONFIG_SUN4V_HYPERVISOR_WDT) += sun4v_watchdog.o
 
 # XTENSA Architecture
 
diff --git a/drivers/watchdog/sun4v_mach_set_watchdog.S b/drivers/watchdog/sun4v_mach_set_watchdog.S
new file mode 100644
index 0000000..7aa13d1
--- /dev/null
+++ b/drivers/watchdog/sun4v_mach_set_watchdog.S
@@ -0,0 +1,15 @@
+#include <linux/linkage.h>
+#include <asm/hypervisor.h>
+
+
+	.globl  sun4v_wdt_set_watchdog
+	.type   sun4v_wdt_set_watchdog,#function
+sun4v_wdt_set_watchdog:
+	mov     %o1, %o4
+	mov     HV_FAST_MACH_SET_WATCHDOG, %o5
+	ta      HV_FAST_TRAP
+	stx     %o1, [%o4]
+	retl
+	nop
+	.size   sun4v_wdt_set_watchdog, .-sun4v_wdt_set_watchdog
+
diff --git a/drivers/watchdog/sun4v_wdt.c b/drivers/watchdog/sun4v_wdt.c
new file mode 100644
index 0000000..994626b
--- /dev/null
+++ b/drivers/watchdog/sun4v_wdt.c
@@ -0,0 +1,269 @@
+/*
+ * linux/drivers/char/watchdog/sun4v_wdt.c
+ *
+ * Watchdog driver for the sun4v hypervisor watchdog
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/platform_device.h>
+#include <linux/moduleparam.h>
+#include <linux/bitops.h>
+#include <linux/uaccess.h>
+#include <asm/hypervisor.h>
+#include <asm/mdesc.h>
+
+#define PFX "sun4v Watchdog Timer: "
+
+
+extern unsigned long sun4v_wdt_set_watchdog(unsigned long timeout,
+                                            unsigned long *orig_timeout);
+
+static unsigned timer_margin = 0;
+module_param(timer_margin, uint, 0);
+MODULE_PARM_DESC(timer_margin, "initial watchdog timeout (in seconds)");
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static int debug = 0;
+module_param(debug, int, 0);
+MODULE_PARM_DESC(debug, "Enable debugging");
+
+static unsigned long sun4v_wdt_users = 0;
+static unsigned long sun4v_wdt_timeout = 0UL;
+
+static void sun4v_wdt_set(unsigned long timeout)
+{
+	unsigned long orig_timeout;
+	unsigned long ret = sun4v_wdt_set_watchdog(timeout, &orig_timeout);
+	if (ret != HV_EOK) {
+		pr_err(PFX "unable to set watchdog\n");
+	} else {
+		if (debug)
+			pr_info(PFX "set watchdog to %lu (orig %lu)\n",
+			        timeout, orig_timeout);
+	}
+}
+
+#define sun4v_wdt_keepalive() sun4v_wdt_set(sun4v_wdt_timeout)
+#define sun4v_wdt_disable() sun4v_wdt_set(0UL)
+
+static void sun4v_wdt_adjust_timeout(unsigned new_timeout)
+{
+        const u64 *val;
+	u64 watchdog_resolution_timeout;
+	u64 watchdog_max_timeout;
+	u64 node;
+        struct mdesc_handle *md;
+
+ 	md = mdesc_grab();
+        if (!md)
+                goto out;
+
+        node = mdesc_node_by_name(md, MDESC_NODE_NULL, "platform");
+        if (node == MDESC_NODE_NULL) {
+		if (debug)
+                	pr_info(PFX "No platform MDESC node.\n");
+
+                goto out_release;
+        }
+
+        val = mdesc_get_property(md, node, "watchdog-resolution", NULL);
+	if (val == NULL) {
+		if (debug)
+                	pr_info(PFX
+			        "No platform.watchdog-resolution-timeout "
+			        "MDESC property.\n");
+
+                goto out_release;
+	}
+	watchdog_resolution_timeout = *val;
+
+        val = mdesc_get_property(md, node, "watchdog-max-timeout", NULL);
+	if (val == NULL) {
+		if (debug)
+                	pr_info(PFX
+			        "No platform.watchdog-max-timeout MDESC "
+			        "property.\n");
+
+                goto out_release;
+	}
+	watchdog_max_timeout = *val;
+
+	if ((new_timeout * 1000UL) < watchdog_resolution_timeout)
+		new_timeout = watchdog_resolution_timeout / 1000UL;
+	if ((new_timeout * 1000UL) > watchdog_max_timeout)
+		new_timeout = watchdog_max_timeout / 1000UL;
+out_release:
+	mdesc_release(md);
+out:
+	timer_margin = new_timeout;
+	sun4v_wdt_timeout = timer_margin * 1000UL;
+}
+
+static int sun4v_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &sun4v_wdt_users))
+		return -EBUSY;
+
+	sun4v_wdt_keepalive();
+	return nonseekable_open(inode, file);
+}
+
+static int sun4v_wdt_release(struct inode *inode, struct file *file)
+{
+#ifndef CONFIG_WATCHDOG_NOWAYOUT
+	sun4v_wdt_disable();
+#else
+	printk(KERN_CRIT PFX "Unexpected close, not stopping!\n");
+#endif
+	clear_bit(0, &sun4v_wdt_users);
+	return 0;
+}
+
+static ssize_t sun4v_wdt_write(struct file *file, const char __user *data, size_t len, loff_t *ppos)
+{
+	if (len) {
+		sun4v_wdt_keepalive();
+	}
+	return len;
+}
+
+static long sun4v_wdt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+
+	int new_margin;
+	static const struct watchdog_info ident = {
+		.identity = "sun4v Watchdog",
+		.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+		.firmware_version = 0,
+	};
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &ident, sizeof(ident)) ? -EFAULT : 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		sun4v_wdt_keepalive();
+		return 0;
+	case WDIOC_SETTIMEOUT:
+		if (get_user(new_margin, p))
+			return -EFAULT;
+		sun4v_wdt_adjust_timeout(new_margin);
+		sun4v_wdt_keepalive();
+		/* Fall-thru */
+	case WDIOC_GETTIMEOUT:
+		return put_user(timer_margin, p);
+	default:
+		return -ENOTTY;
+	}
+}
+
+static const struct file_operations sun4v_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= sun4v_wdt_write,
+	.unlocked_ioctl	= sun4v_wdt_ioctl,
+	.open		= sun4v_wdt_open,
+	.release	= sun4v_wdt_release,
+};
+
+static struct miscdevice sun4v_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &sun4v_wdt_fops,
+};
+
+static char probe_err[] __devinitdata = KERN_ERR PFX "probe failed. Only SUN4V NIAGARA2 is supported\n";
+static char probe_msg[] __devinitdata = KERN_INFO PFX "initialized. timer_margin=%u sec (nowayout= %d)\n";
+static char probe_register_err[] __devinitdata = KERN_ERR PFX "misc_register failed with %d\n";
+static char init_msg[] __initdata = KERN_INFO PFX "loaded.\n";
+
+static int __devinit sun4v_wdt_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (SUN4V_CHIP_NIAGARA2 != sun4v_chip_type) {
+		printk(probe_err);
+		return -ENODEV;
+	}
+
+	sun4v_wdt_users = 0UL;
+
+	sun4v_wdt_disable();
+	sun4v_wdt_adjust_timeout(timer_margin);
+
+	/*sun4v_wdt_miscdev.parent = &pdev->dev;*/
+	ret = misc_register(&sun4v_wdt_miscdev);
+	if (ret) {
+		printk(probe_register_err, ret);
+	} else {
+		printk(probe_msg, timer_margin, nowayout);
+	}
+
+	return ret;
+}
+
+static void sun4v_wdt_shutdown(struct platform_device *pdev)
+{
+	sun4v_wdt_disable();
+}
+
+static int __devexit sun4v_wdt_remove(struct platform_device *pdev)
+{
+	misc_deregister(&sun4v_wdt_miscdev);
+	return 0;
+}
+
+static struct platform_device *sun4v_wdt_platform_device;
+static struct platform_driver sun4v_wdt_driver = {
+	.probe		= sun4v_wdt_probe,
+	.remove		= __devexit_p(sun4v_wdt_remove),
+	.shutdown	= sun4v_wdt_shutdown,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "sun4v_wdt",
+	},
+};
+
+static int __init sun4v_wdt_init(void)
+{
+	int ret = platform_driver_register(&sun4v_wdt_driver);
+
+	if (ret)
+		return ret;
+
+	sun4v_wdt_platform_device = platform_device_register_simple("sun4v_wdt", -1, NULL, 0);
+	if (IS_ERR(sun4v_wdt_platform_device)) {
+		ret = PTR_ERR(sun4v_wdt_platform_device);
+	        platform_driver_unregister(&sun4v_wdt_driver);
+	} else {
+		printk(init_msg);
+	}
+
+	return ret;
+}
+
+static void __exit sun4v_wdt_exit(void)
+{
+        platform_device_unregister(sun4v_wdt_platform_device);
+	platform_driver_unregister(&sun4v_wdt_driver);
+}
+
+module_init(sun4v_wdt_init);
+module_exit(sun4v_wdt_exit);
+
+MODULE_AUTHOR("Francis Bogsanyi");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_ALIAS("platform:sun4v_wdt");
-- 
1.6.0.3

