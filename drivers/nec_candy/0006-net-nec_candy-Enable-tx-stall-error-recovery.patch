From d798b278b32e1ff347bec77dac2421b612cdd983 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Tue, 28 Apr 2009 14:13:18 +0900
Subject: [PATCH] net: nec_candy: Enable tx stall error recovery

Once tx errors are detected (TUDR, LCOL, ECOL and EDFR), Candy stops its
transmission.  This patch enables tx_stall_recover for those tx errors,
and tries to re-start transmission again.

With this patch, we're not expected to reach tx_timeout, but we also add
debug code to prepare for emergencies.

The last_tx_{err_status,buff_desc} variables is used to track the latest
tx descriptor written to the hardware in the tx error recovery process.
The tx descriptor 'status' and 'pointer' in question, will be printed out
when tx_timeout error is finally triggered.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/net/nec_candy.c |   28 ++++++++++++++++++++--------
 1 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/drivers/net/nec_candy.c b/drivers/net/nec_candy.c
index f82a1e4..b85d975 100644
--- a/drivers/net/nec_candy.c
+++ b/drivers/net/nec_candy.c
@@ -106,6 +106,9 @@ static char version[] __devinitdata =
 
 static struct candy_private *candy_priv_head;
 
+static unsigned short last_tx_err_status;
+static unsigned int last_tx_buff_desc;
+
 /***********************************************************************
  * helpers
  ***********************************************************************/
@@ -728,9 +731,9 @@ candy_error_recover(struct net_device *dev)
 	spin_unlock(&pp->lock);
 }
 
-#if defined(WORKAROUND_E8_TX_STALL)
 /*
- * This implements the workaround described for E-8
+ * This implements the workaround described for E-8,
+ * and Tx errors that stop the transmission
  */
 static void
 tx_stall_recover(struct net_device *dev)
@@ -738,6 +741,10 @@ tx_stall_recover(struct net_device *dev)
 	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
+	last_tx_err_status = pp->tx_ring[pp->tx_head].status;
+	last_tx_buff_desc = (unsigned int)&pp->tx_ring[pp->tx_head];
+
+#ifdef WORKAROUND_E8_TX_STALL
 	/* E-8 bug only happens when receiving is on */
 	if ((candy_in(p->macc1) & SRXEN) && (candy_in(p->rxcfg) & RXE)) {
 
@@ -750,11 +757,12 @@ tx_stall_recover(struct net_device *dev)
 
 		candy_set_bits(p->rxcfg, RXE);
 		candy_set_macc1_bits(p->macc1, SRXEN);
-	} else {
+	} else
+#endif
+	{
 		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
 	}
 }
-#endif
 
 /***********************************************************************
  * hardware-independent helper routine
@@ -1257,14 +1265,13 @@ handle_tx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
 		       "status = %04x, isr = 0x%08lx.\n",
 		       dev->name, pp->tx_head, dp->status, isr);
 
-#if defined(WORKAROUND_E8_TX_STALL)
-	tx_stall_recover(dev);
-#endif
-
 	pp->stats.tx_errors++;
 	pp->stats.tx_aborted_errors++;
 	if (dp->status & TUDR)
 		pp->stats.tx_fifo_errors++;
+
+	if (dp->status & (TUDR | LCOL | ECOL | EDFR))
+		tx_stall_recover(dev);
 }
 
 static void
@@ -1302,6 +1309,8 @@ candy_tx_done(struct net_device *dev, ulong isr)
 		/* handle error */
 		if (!(dp->status & TOK)) {
 			handle_tx_error(dev, dp, isr);
+			/* transmitter should have stopped */
+			break;
 		}
 
 		/* reclaim the descriptor */
@@ -1714,6 +1723,9 @@ candy_tx_timeout(struct net_device *dev)
 	struct candy_private *pp = (struct candy_private *)dev->priv;
 
 	printk(KERN_ERR "%s : tx_timeout.\n", dev->name);
+	printk(KERN_ERR "Last Tx Err Status = 0x%04x\n", last_tx_err_status);
+	printk(KERN_ERR "Last Tx Buff Desc = 0x%08x\n", last_tx_buff_desc);
+	printk(KERN_ERR "TXDP = 0x%08x\n", candy_in(pp->regs->txdp));
 
 	pp->stats.tx_errors++;
 
-- 
1.6.0.4

