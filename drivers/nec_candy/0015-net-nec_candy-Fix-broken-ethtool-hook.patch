From 9efabd1f5b9352b1853115a99a2b3a32c16cd448 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Thu, 24 Sep 2009 19:12:42 +0900
Subject: [PATCH 15/16] net: nec_candy: Fix broken ethtool hook

Convert an obsolete ioctl-based ethtool hook into the recent ethtool_ops
based one.  Some operations are simply converted, and some are replaced
with generic ethtool_op_* routines provided by net/core/ethtool.c.
Resulting operations available are as well or better than before.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/net/nec_candy.c |  241 +++++++++++++---------------------------------
 1 files changed, 68 insertions(+), 173 deletions(-)

diff --git a/drivers/net/nec_candy.c b/drivers/net/nec_candy.c
index 0fdc8da..018dff6 100644
--- a/drivers/net/nec_candy.c
+++ b/drivers/net/nec_candy.c
@@ -260,192 +260,89 @@ candy_set_media_speed(struct net_device *dev)
 }
 
 static int
-candy_ethtool_ioctl(struct candy_private *pp, void *useraddr)
+candy_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	u32 ethcmd;
-
-	/*
-	 * dev_ioctl() in ../../net/core/dev.c has already checked
-	 * capable(CAP_NET_ADMIN), so don't bother with that here.
-	 */
-
-	if (get_user(ethcmd, (u32 *)useraddr))
-		return -EFAULT;
-
-	switch (ethcmd) {
-
-	case ETHTOOL_GDRVINFO: {
-		struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
-
-		strcpy(info.driver, DRV_NAME);
-		strcpy(info.version, DRV_VERSION);
-		strcpy(info.bus_info, "");
-		info.regdump_len = CANDY_REGS_SIZE;
-		info.n_stats = 0;
-		if (copy_to_user(useraddr, &info, sizeof(info)))
-			return -EFAULT;
-		return 0;
-	}
-
-	/* get settings */
-	case ETHTOOL_GSET: {
-		struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-
-		spin_lock_irq(&pp->lock);
-		mii_ethtool_gset(&pp->mii_if, &ecmd);
-		spin_unlock_irq(&pp->lock);
-		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-			return -EFAULT;
-		return 0;
-	}
-
-	/* set settings */
-	case ETHTOOL_SSET: {
-		int r;
-		struct ethtool_cmd ecmd;
-
-		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-			return -EFAULT;
-		spin_lock_irq(&pp->lock);
-		r = mii_ethtool_sset(&pp->mii_if, &ecmd);
-		spin_unlock_irq(&pp->lock);
-		return r;
-	}
-
-	/* restart autonegotiation */
-	case ETHTOOL_NWAY_RST: {
-		return mii_nway_restart(&pp->mii_if);
-	}
-
-	/* get link status */
-	case ETHTOOL_GLINK: {
-		struct ethtool_value edata = { ETHTOOL_GLINK };
-
-		edata.data = mii_link_ok(&pp->mii_if);
-		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
-
-	/* get message-level */
-	case ETHTOOL_GMSGLVL: {
-		struct ethtool_value edata = { ETHTOOL_GMSGLVL };
-
-		edata.data = pp->msg_enable;
-		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
-
-	/* set message-level */
-	case ETHTOOL_SMSGLVL: {
-		struct ethtool_value edata;
-
-		if (copy_from_user(&edata, useraddr, sizeof(edata)))
-			return -EFAULT;
-		pp->msg_enable = edata.data;
-		return 0;
-	}
-
-	/* register's dump */
-	case ETHTOOL_GREGS: {
-		struct ethtool_regs regs;
-		u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
-		int rc;
-
-		if (!regbuf)
-			return -ENOMEM;
-		memset(regbuf, 0, CANDY_REGS_SIZE);
-
-		rc = copy_from_user(&regs, useraddr, sizeof(regs));
-		if (rc) {
-			rc = -EFAULT;
-			goto err_out_gregs;
-		}
-
-		if (regs.len > CANDY_REGS_SIZE)
-			regs.len = CANDY_REGS_SIZE;
-		if (regs.len < CANDY_REGS_SIZE) {
-			rc = -EINVAL;
-			goto err_out_gregs;
-		}
-
-		regs.version = CANDY_REGS_VER;
-		rc = copy_to_user(useraddr, &regs, sizeof(regs));
-		if (rc) {
-			rc = -EFAULT;
-			goto err_out_gregs;
-		}
-
-		useraddr += offsetof(struct ethtool_regs, data);
-
-		spin_lock_irq(&pp->lock);
-		memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
-		spin_unlock_irq(&pp->lock);
-
-		if (copy_to_user(useraddr, regbuf, regs.len))
-			rc = -EFAULT;
-
-err_out_gregs:
-		kfree(regbuf);
-		return rc;
-	}
-
-	/* get/set TX checksumming */
-	case ETHTOOL_GTXCSUM: {
-		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+	struct candy_private *pp = netdev_priv(dev);
 
-		edata.data = (pp->ndev->features & NETIF_F_IP_CSUM) != 0;
-		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
+	spin_lock_irq(&pp->lock);
+	mii_ethtool_gset(&pp->mii_if, cmd);
+	spin_unlock_irq(&pp->lock);
+	return 0;
+}
 
-	case ETHTOOL_STXCSUM: {
-		struct ethtool_value edata;
+static int
+candy_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct candy_private *pp = netdev_priv(dev);
+	int r;
 
-		if (copy_from_user(&edata, useraddr, sizeof(edata)))
-			return -EFAULT;
+	spin_lock_irq(&pp->lock);
+	r = mii_ethtool_sset(&pp->mii_if, cmd);
+	spin_unlock_irq(&pp->lock);
+	return r;
+}
 
-		if (edata.data)
-			pp->ndev->features |= NETIF_F_IP_CSUM;
-		else
-			pp->ndev->features &= ~NETIF_F_IP_CSUM;
+static void
+candy_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->fw_version, "N/A");
+	strcpy(info->bus_info, dev_name(&dev->dev));
+}
 
-		return 0;
-	}
+static int
+candy_get_regs_len(struct net_device *dev)
+{
+	return CANDY_REGS_SIZE;
+}
 
-	/* get/set scatter-gather */
-	case ETHTOOL_GSG: {
-		struct ethtool_value edata = { ETHTOOL_GSG };
+static void
+candy_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)
+{
+	struct candy_private *pp = netdev_priv(dev);
 
-		edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
-		if (copy_to_user(useraddr, &edata, sizeof(edata)))
-			return -EFAULT;
-		return 0;
-	}
+	spin_lock_irq(&pp->lock);
+	memcpy_fromio(buf, pp->regs, regs->len);
+	spin_unlock_irq(&pp->lock);
+}
 
-	case ETHTOOL_SSG: {
-		struct ethtool_value edata;
+static u32
+candy_get_msglevel(struct net_device *dev)
+{
+	struct candy_private *pp = netdev_priv(dev);
 
-		if (copy_from_user(&edata, useraddr, sizeof(edata)))
-			return -EFAULT;
+	return pp->msg_enable;
+}
 
-		if (edata.data)
-			pp->ndev->features |= NETIF_F_SG;
-		else
-			pp->ndev->features &= ~NETIF_F_SG;
+static void
+candy_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct candy_private *pp = netdev_priv(dev);
 
-		return 0;
-	}
+	pp->msg_enable = level;
+}
 
-	default:
-		break;
-	}
+static int
+candy_nway_reset(struct net_device *dev)
+{
+	struct candy_private *pp = netdev_priv(dev);
 
-	return -EOPNOTSUPP;
+	return mii_nway_restart(&pp->mii_if);
 }
 
+static const struct ethtool_ops candy_ethtool_ops = {
+	.get_settings		= candy_get_settings,
+	.set_settings		= candy_set_settings,
+	.get_drvinfo		= candy_get_drvinfo,
+	.get_regs_len		= candy_get_regs_len,
+	.get_regs		= candy_get_regs,
+	.get_msglevel		= candy_get_msglevel,
+	.set_msglevel		= candy_set_msglevel,
+	.nway_reset		= candy_nway_reset,
+	.get_link		= ethtool_op_get_link,
+};
+
 static int
 candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
@@ -453,9 +350,6 @@ candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	struct mii_ioctl_data *mii = (struct mii_ioctl_data *)&rq->ifr_data;
 	int rc;
 
-	if (cmd == SIOCETHTOOL)
-		return candy_ethtool_ioctl(pp, (void *)rq->ifr_data);
-
 	spin_lock_irq(&pp->lock);
 	rc = generic_mii_ioctl(&pp->mii_if, mii, cmd, NULL);
 	spin_unlock_irq(&pp->lock);
@@ -1807,6 +1701,7 @@ static int nec_candy_probe(struct device *dev)
 	ndev->open = candy_open;
 	ndev->stop = candy_close;
 	ndev->do_ioctl = candy_ioctl;
+	ndev->ethtool_ops = &candy_ethtool_ops;
 	ndev->hard_start_xmit = candy_xmit;
 	ndev->get_stats = candy_get_stats;
 	ndev->set_multicast_list = candy_set_rx_mode;
-- 
1.6.3.3

