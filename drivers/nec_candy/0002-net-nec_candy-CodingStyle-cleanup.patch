From a39a7187aa142d6a569a885014a589b8dda35c56 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Tue, 28 Apr 2009 14:11:02 +0900
Subject: [PATCH] net: nec_candy: CodingStyle cleanup

No logical change.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/net/nec_candy.c |  504 ++++++++++++++++++++++++-----------------------
 1 files changed, 262 insertions(+), 242 deletions(-)

diff --git a/drivers/net/nec_candy.c b/drivers/net/nec_candy.c
index 797ac4f..a3b30b1 100644
--- a/drivers/net/nec_candy.c
+++ b/drivers/net/nec_candy.c
@@ -76,7 +76,12 @@ static int debug = -1;
 #endif
 
 #ifdef DEBUG_NEC_CANDY
-#define ASSERT(x) if (!(x)) { panic("%s:%d - assert failed!\n", __FILE__, __LINE__); }
+#define ASSERT(x)						\
+	do {							\
+		if (!(x))					\
+			panic("%s:%d - assert failed!\n",	\
+			      __FILE__, __LINE__);		\
+	} while (0)
 #define VERIFY(x, y) ASSERT(x y)
 #define DEBUG(x)  do { x; } while (0)
 #else
@@ -128,8 +133,11 @@ static struct candy_private *candy_priv_head = NULL;
 		candy_out((p)->msr, candy_in((p)->msr) & ~CANDY_NAPI_MASK_INTS)
 #endif
 
-#define MEMSYNC(x)	\
-	do { volatile u32 *p = (volatile u32 *)x; (void)(*p); } while (0)
+#define MEMSYNC(x)							\
+	do {								\
+		volatile u32 *p = (volatile u32 *)x;			\
+		(void)(*p);						\
+	} while (0)
 
 /***********************************************************************
  * low-level hardware functions
@@ -138,28 +146,30 @@ static struct candy_private *candy_priv_head = NULL;
 static void
 mdio_write(struct net_device *dev, int phy_id, int location, int val)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	/* wait for busy */
-	while (candy_in(p->mind) & BUSY) ;
+	while (candy_in(p->mind) & BUSY)
+		;
 
 	/* start the write */
 
 	candy_out(p->madr,
 		  ((phy_id << FIAD_SHIFT) & FIAD_MASK) |
 		  (location & RGAD_MASK));
-	candy_out(p->mwtd, (ulong) val);
+	candy_out(p->mwtd, (ulong)val);
 }
 
 static int
 mdio_read(struct net_device *dev, int phy_id, int location)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	/* wait for busy */
-	while (candy_in(p->mind) & BUSY) ;
+	while (candy_in(p->mind) & BUSY)
+		;
 
 	/*  mac_reg->mcmd = 0; */
 	candy_out(p->madr,
@@ -168,9 +178,10 @@ mdio_read(struct net_device *dev, int phy_id, int location)
 	candy_out(p->mcmd, RSTAT);
 
 	/* wait for busy */
-	while (candy_in(p->mind) & BUSY) ;
+	while (candy_in(p->mind) & BUSY)
+		;
 
-	return (ushort) candy_in(p->mrdd);
+	return (ushort)candy_in(p->mrdd);
 }
 
 static void
@@ -225,23 +236,23 @@ candy_set_media_speed(struct net_device *dev)
 
 	media = mii_nway_result(lpa & advertise);
 	switch (media) {
-		case LPA_10FULL:
-		case LPA_10HALF:
-			pp->link_status.speed100 = 0;
-			break;
-		default:
-			if (pdata->rmii)
-				ccr &= ~SPD100;
-			pp->link_status.speed100 = 1;
+	case LPA_10FULL:
+	case LPA_10HALF:
+		pp->link_status.speed100 = 0;
+		break;
+	default:
+		if (pdata->rmii)
+			ccr &= ~SPD100;
+		pp->link_status.speed100 = 1;
 	}
 
 	switch (media) {
-		case LPA_10HALF:
-		case LPA_100HALF:
-			pp->link_status.fullduplex = 0;
-			break;
-		default:
-			pp->link_status.fullduplex = 1;
+	case LPA_10HALF:
+	case LPA_100HALF:
+		pp->link_status.fullduplex = 0;
+		break;
+	default:
+		pp->link_status.fullduplex = 1;
 	}
 
 	candy_out(pp->regs->ccr, ccr);
@@ -252,166 +263,180 @@ candy_ethtool_ioctl(struct candy_private *pp, void *useraddr)
 {
 	u32 ethcmd;
 
-	/* dev_ioctl() in ../../net/core/dev.c has already checked
-	   capable(CAP_NET_ADMIN), so don't bother with that here.  */
+	/*
+	 * dev_ioctl() in ../../net/core/dev.c has already checked
+	 * capable(CAP_NET_ADMIN), so don't bother with that here.
+	 */
 
-	if (get_user(ethcmd, (u32 *) useraddr))
+	if (get_user(ethcmd, (u32 *)useraddr))
 		return -EFAULT;
 
 	switch (ethcmd) {
 
-	case ETHTOOL_GDRVINFO:{
-			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
-			strcpy(info.driver, DRV_NAME);
-			strcpy(info.version, DRV_VERSION);
-			strcpy(info.bus_info, "");
-			info.regdump_len = CANDY_REGS_SIZE;
-			info.n_stats = 0;
-			if (copy_to_user(useraddr, &info, sizeof(info)))
-				return -EFAULT;
-			return 0;
-		}
-		/* get settings */
-	case ETHTOOL_GSET:{
-			struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-			spin_lock_irq(&pp->lock);
-			mii_ethtool_gset(&pp->mii_if, &ecmd);
-			spin_unlock_irq(&pp->lock);
-			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set settings */
-	case ETHTOOL_SSET:{
-			int r;
-			struct ethtool_cmd ecmd;
-			if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-				return -EFAULT;
-			spin_lock_irq(&pp->lock);
-			r = mii_ethtool_sset(&pp->mii_if, &ecmd);
-			spin_unlock_irq(&pp->lock);
-			return r;
-		}
-		/* restart autonegotiation */
-	case ETHTOOL_NWAY_RST:{
-			return mii_nway_restart(&pp->mii_if);
-		}
-		/* get link status */
-	case ETHTOOL_GLINK:{
-			struct ethtool_value edata = { ETHTOOL_GLINK };
-			edata.data = mii_link_ok(&pp->mii_if);
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
+	case ETHTOOL_GDRVINFO: {
+		struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+
+		strcpy(info.driver, DRV_NAME);
+		strcpy(info.version, DRV_VERSION);
+		strcpy(info.bus_info, "");
+		info.regdump_len = CANDY_REGS_SIZE;
+		info.n_stats = 0;
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+	}
 
-		/* get message-level */
-	case ETHTOOL_GMSGLVL:{
-			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
-			edata.data = pp->msg_enable;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set message-level */
-	case ETHTOOL_SMSGLVL:{
-			struct ethtool_value edata;
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
-			pp->msg_enable = edata.data;
-			return 0;
-		}
+	/* get settings */
+	case ETHTOOL_GSET: {
+		struct ethtool_cmd ecmd = { ETHTOOL_GSET };
 
-		/* register's dump */
-	case ETHTOOL_GREGS:{
-			struct ethtool_regs regs;
-			u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
-			int rc;
+		spin_lock_irq(&pp->lock);
+		mii_ethtool_gset(&pp->mii_if, &ecmd);
+		spin_unlock_irq(&pp->lock);
+		if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+			return -EFAULT;
+		return 0;
+	}
 
-			if (!regbuf)
-				return -ENOMEM;
-			memset(regbuf, 0, CANDY_REGS_SIZE);
+	/* set settings */
+	case ETHTOOL_SSET: {
+		int r;
+		struct ethtool_cmd ecmd;
+
+		if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+			return -EFAULT;
+		spin_lock_irq(&pp->lock);
+		r = mii_ethtool_sset(&pp->mii_if, &ecmd);
+		spin_unlock_irq(&pp->lock);
+		return r;
+	}
 
-			rc = copy_from_user(&regs, useraddr, sizeof(regs));
-			if (rc) {
-				rc = -EFAULT;
-				goto err_out_gregs;
-			}
+	/* restart autonegotiation */
+	case ETHTOOL_NWAY_RST: {
+		return mii_nway_restart(&pp->mii_if);
+	}
 
-			if (regs.len > CANDY_REGS_SIZE)
-				regs.len = CANDY_REGS_SIZE;
-			if (regs.len < CANDY_REGS_SIZE) {
-				rc = -EINVAL;
-				goto err_out_gregs;
-			}
+	/* get link status */
+	case ETHTOOL_GLINK: {
+		struct ethtool_value edata = { ETHTOOL_GLINK };
 
-			regs.version = CANDY_REGS_VER;
-			rc = copy_to_user(useraddr, &regs, sizeof(regs));
-			if (rc) {
-				rc = -EFAULT;
-				goto err_out_gregs;
-			}
+		edata.data = mii_link_ok(&pp->mii_if);
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	/* get message-level */
+	case ETHTOOL_GMSGLVL: {
+		struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+
+		edata.data = pp->msg_enable;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	/* set message-level */
+	case ETHTOOL_SMSGLVL: {
+		struct ethtool_value edata;
 
-			useraddr += offsetof(struct ethtool_regs, data);
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+		pp->msg_enable = edata.data;
+		return 0;
+	}
 
-			spin_lock_irq(&pp->lock);
-			memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
-			spin_unlock_irq(&pp->lock);
+	/* register's dump */
+	case ETHTOOL_GREGS: {
+		struct ethtool_regs regs;
+		u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
+		int rc;
 
-			if (copy_to_user(useraddr, regbuf, regs.len))
-				rc = -EFAULT;
+		if (!regbuf)
+			return -ENOMEM;
+		memset(regbuf, 0, CANDY_REGS_SIZE);
 
-		      err_out_gregs:
-			kfree(regbuf);
-			return rc;
+		rc = copy_from_user(&regs, useraddr, sizeof(regs));
+		if (rc) {
+			rc = -EFAULT;
+			goto err_out_gregs;
 		}
 
-		/* get/set TX checksumming */
-	case ETHTOOL_GTXCSUM:{
-			struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+		if (regs.len > CANDY_REGS_SIZE)
+			regs.len = CANDY_REGS_SIZE;
+		if (regs.len < CANDY_REGS_SIZE) {
+			rc = -EINVAL;
+			goto err_out_gregs;
+		}
 
-			edata.data = (pp->ndev->features &
-				      NETIF_F_IP_CSUM) != 0;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
+		regs.version = CANDY_REGS_VER;
+		rc = copy_to_user(useraddr, &regs, sizeof(regs));
+		if (rc) {
+			rc = -EFAULT;
+			goto err_out_gregs;
 		}
-	case ETHTOOL_STXCSUM:{
-			struct ethtool_value edata;
 
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
+		useraddr += offsetof(struct ethtool_regs, data);
 
-			if (edata.data)
-				pp->ndev->features |= NETIF_F_IP_CSUM;
-			else
-				pp->ndev->features &= ~NETIF_F_IP_CSUM;
+		spin_lock_irq(&pp->lock);
+		memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
+		spin_unlock_irq(&pp->lock);
 
-			return 0;
-		}
+		if (copy_to_user(useraddr, regbuf, regs.len))
+			rc = -EFAULT;
+
+err_out_gregs:
+		kfree(regbuf);
+		return rc;
+	}
 
-		/* get/set scatter-gather */
-	case ETHTOOL_GSG:{
-			struct ethtool_value edata = { ETHTOOL_GSG };
+	/* get/set TX checksumming */
+	case ETHTOOL_GTXCSUM: {
+		struct ethtool_value edata = { ETHTOOL_GTXCSUM };
 
-			edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-	case ETHTOOL_SSG:{
-			struct ethtool_value edata;
+		edata.data = (pp->ndev->features & NETIF_F_IP_CSUM) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
 
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
+	case ETHTOOL_STXCSUM: {
+		struct ethtool_value edata;
 
-			if (edata.data)
-				pp->ndev->features |= NETIF_F_SG;
-			else
-				pp->ndev->features &= ~NETIF_F_SG;
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
 
-			return 0;
-		}
+		if (edata.data)
+			pp->ndev->features |= NETIF_F_IP_CSUM;
+		else
+			pp->ndev->features &= ~NETIF_F_IP_CSUM;
+
+		return 0;
+	}
+
+	/* get/set scatter-gather */
+	case ETHTOOL_GSG: {
+		struct ethtool_value edata = { ETHTOOL_GSG };
+
+		edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+			return -EFAULT;
+		return 0;
+	}
+
+	case ETHTOOL_SSG: {
+		struct ethtool_value edata;
+
+		if (copy_from_user(&edata, useraddr, sizeof(edata)))
+			return -EFAULT;
+
+		if (edata.data)
+			pp->ndev->features |= NETIF_F_SG;
+		else
+			pp->ndev->features &= ~NETIF_F_SG;
+
+		return 0;
+	}
 
 	default:
 		break;
@@ -424,11 +449,11 @@ static int
 candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
 	struct candy_private *pp = dev->priv;
-	struct mii_ioctl_data *mii = (struct mii_ioctl_data *) &rq->ifr_data;
+	struct mii_ioctl_data *mii = (struct mii_ioctl_data *)&rq->ifr_data;
 	int rc;
 
 	if (cmd == SIOCETHTOOL)
-		return candy_ethtool_ioctl(pp, (void *) rq->ifr_data);
+		return candy_ethtool_ioctl(pp, (void *)rq->ifr_data);
 
 	spin_lock_irq(&pp->lock);
 	rc = generic_mii_ioctl(&pp->mii_if, mii, cmd, NULL);
@@ -437,9 +462,9 @@ candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 }
 
 static void
-set_mac_addr(struct net_device *dev, u_char * addr)
+set_mac_addr(struct net_device *dev, u_char *addr)
 {
-	candy_regs *p = ((struct candy_private *) dev->priv)->regs;
+	candy_regs *p = ((struct candy_private *)dev->priv)->regs;
 
 	candy_out(p->lsa2, (addr[0] << 8 | addr[1]) & LSA2_MASK);
 	candy_out(p->lsa1,
@@ -449,7 +474,7 @@ set_mac_addr(struct net_device *dev, u_char * addr)
 static void
 candy_filter_init(struct net_device *dev)
 {
-	candy_regs *p = ((struct candy_private *) dev->priv)->regs;
+	candy_regs *p = ((struct candy_private *)dev->priv)->regs;
 
 	/* don't call while processing error recovery */
 
@@ -469,7 +494,7 @@ candy_filter_init(struct net_device *dev)
 static void
 candy_hw_init(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	unsigned int temp;
 	u32 afr, ht1, ht2;
@@ -585,7 +610,7 @@ candy_hw_init(struct net_device *dev)
 static void
 candy_down(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	DEBUG_VERBOSE(printk("candy_down() invoked.\n"));
@@ -608,7 +633,7 @@ candy_down(struct net_device *dev)
 static void
 candy_up(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	DEBUG_VERBOSE(printk("candy_up() invoked.\n"));
@@ -634,7 +659,7 @@ candy_up(struct net_device *dev)
 static void
 candy_set_filter(struct net_device *dev, int on)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	struct dev_mc_list *mclist = dev->mc_list;
 	unsigned long ht[2];
@@ -666,7 +691,7 @@ candy_set_filter(struct net_device *dev, int on)
 static void
 candy_error_recover(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	spin_lock(&pp->lock);
@@ -692,7 +717,7 @@ candy_error_recover(struct net_device *dev)
 static void
 tx_stall_recover(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	/* E-8 bug only happens when receiving is on */
@@ -707,7 +732,6 @@ tx_stall_recover(struct net_device *dev)
 
 		candy_set_bits(p->rxcfg, RXE);
 		candy_set_macc1_bits(p->macc1, SRXEN);
-
 	} else {
 		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
 	}
@@ -720,7 +744,7 @@ tx_stall_recover(struct net_device *dev)
 static void
 candy_init_rings(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	int i;
 
 	DEBUG_VERBOSE(printk("candy_init_rings() invoked.\n"));
@@ -804,13 +828,12 @@ candy_check_intr(ulong isr)
 static void
 reclaim_one_rx_desc(struct net_device *dev, char *buf)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
 
-	if (buf != NULL) {
+	if (buf != NULL)
 		dp->pointer = CPHYSADDR(buf);
-	}
 	dp->status = DB_LP;	/* 1 stands for buffer vs link ptr */
 	dp->size = RX_BUF_SIZE;
 
@@ -845,7 +868,7 @@ restart_rx_hw(struct net_device *dev)
 static void
 handle_rx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 
 	if (netif_msg_rx_err(pp))
 		printk(KERN_DEBUG "%s: rx_err, rx_ring[%d] error,"
@@ -881,7 +904,8 @@ static int candy_napi_rx(struct net_device *dev, int budget)
 			}
 		}
 
-		if ((dp->status & RXOK) == 0) { /* handle the error case */
+		/* handle the error case */
+		if ((dp->status & RXOK) == 0) {
 			handle_rx_error(dev, dp, 0);
 			reclaim_one_rx_desc(dev, NULL);
 			dp = &pp->rx_ring[pp->rx_head];
@@ -950,7 +974,7 @@ static int candy_napi_rx(struct net_device *dev, int budget)
 //static int candy_napi_poll(struct net_device *dev, int *budget)
 static int candy_napi_poll(struct napi_struct *napi, int budget)
 {
-	struct candy_private *pp = container_of(napi,struct candy_private,napi);
+	struct candy_private *pp = container_of(napi, struct candy_private, napi);
 	struct net_device *dev = pp->ndev;
 	int work_done;
 
@@ -959,7 +983,7 @@ static int candy_napi_poll(struct napi_struct *napi, int budget)
 	work_done += candy_napi_rx(dev, budget);
 
 	if (work_done < budget) {
-		__netif_rx_complete(dev,napi);
+		__netif_rx_complete(dev, napi);
 		candy_unmask_napi_ints(pp->regs);
 	}
 
@@ -973,7 +997,7 @@ static int candy_napi_poll(struct napi_struct *napi, int budget)
 static void
 candy_rx(struct net_device *dev, ulong isr)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
 	int pkt_len, rnod;
@@ -982,10 +1006,9 @@ candy_rx(struct net_device *dev, ulong isr)
 	int i;
 	int skb_size;
 
-	if (netif_msg_rx_status(pp)) {
+	if (netif_msg_rx_status(pp))
 		printk(KERN_DEBUG "\trx_head = %d, {0x%04x, %u, 0x%08lx}\n",
 		       pp->rx_head, dp->status, dp->size, dp->pointer);
-	}
 
 	/* FIXME : we are fetching packets.  How do we know where the
 	 * end is?  When OWN bit is 0 (in previous linux driver)?
@@ -1048,11 +1071,10 @@ candy_rx(struct net_device *dev, ulong isr)
 		 * To keep it flexible, we will leave rx_copybreak flexible.
 		 */
 
-		if (pkt_len < rx_copybreak) {
+		if (pkt_len < rx_copybreak)
 			skb_size = pkt_len + 2;
-		} else {
+		else
 			skb_size = RX_BUF_SIZE;
-		}
 
 		/* allocate a new skb */
 		newskb = dev_alloc_skb(skb_size);
@@ -1127,7 +1149,7 @@ append_one_tx_desc(struct net_device *dev,
 		   ushort status,
 		   ushort size, ulong pointer, struct sk_buff *skb)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	struct candy_desc *dp = &pp->tx_ring[pp->tx_tail];
 #ifdef WORKAROUND_E10_VR4133
 	int i, shift = pointer % 4;
@@ -1151,9 +1173,10 @@ append_one_tx_desc(struct net_device *dev,
 			dp->pointer -= shift;
 			for (i = 0; i < size; i++)
 				skb->data[i] = skb->data[i + shift];
-			dma_cache_wback_inv((ulong) (skb->data), skb->len);
+			dma_cache_wback_inv((ulong)(skb->data), skb->len);
 		} else {
-			panic("nec_candy.c: Unable to do a workaround for hardware bug (Restriction 10 for VR4133).\n");
+			panic("nec_candy.c: Unable to do a workaround for "
+			      "hardware bug (Restriction 10 for VR4133).\n");
 		}
 	}
 #endif
@@ -1167,7 +1190,7 @@ append_one_tx_desc(struct net_device *dev,
 static void
 reclaim_one_tx_desc(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	struct candy_desc *dp = &pp->tx_ring[pp->tx_head];
 
 	dp->status = 0;
@@ -1188,7 +1211,7 @@ reclaim_one_tx_desc(struct net_device *dev)
 static void
 restart_tx_hw(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	append_one_tx_desc(dev, 0, 0, 0, NULL);
@@ -1209,7 +1232,7 @@ restart_tx_hw(struct net_device *dev)
 static void
 handle_tx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 
 	if (netif_msg_tx_err(pp))
 		printk(KERN_DEBUG "%s: tx err, tx_ring[%d] error, "
@@ -1229,7 +1252,7 @@ handle_tx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
 static void
 candy_tx_done(struct net_device *dev, ulong isr)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	struct candy_desc *dp;
 
 	if (netif_msg_tx_done(pp))
@@ -1264,10 +1287,10 @@ candy_tx_done(struct net_device *dev, ulong isr)
 		}
 
 		/* reclaim the descriptor */
-		if (!pp->tx_skb[pp->tx_head]) {
+		if (!pp->tx_skb[pp->tx_head])
 			printk(KERN_ERR "%s: tx_done but without skb!\n",
 			       dev->name);
-		}
+
 		reclaim_one_tx_desc(dev);
 
 		/* FIXME: The Japanese version has a tx restart under
@@ -1276,9 +1299,8 @@ candy_tx_done(struct net_device *dev, ulong isr)
 	}
 
 	/* check if tx has stopped */
-	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail))
 		restart_tx_hw(dev);
-	}
 
 	/* check if queue were stopped */
 	if (netif_queue_stopped(dev) && (pp->tx_count < TX_RING_SIZE - 2)) {
@@ -1294,7 +1316,7 @@ candy_tx_done(struct net_device *dev, ulong isr)
 static void
 candy_update_stats(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 
 	/* some stats we get from hardware, while the rest we do
@@ -1341,8 +1363,8 @@ static int candy_close(struct net_device *dev);
 static irqreturn_t
 candy_interrupt(int irq, void *dev_instance)
 {
-	struct net_device *dev = (struct net_device *) dev_instance;
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct net_device *dev = (struct net_device *)dev_instance;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	ulong isr;
 
@@ -1376,20 +1398,18 @@ candy_interrupt(int irq, void *dev_instance)
 
 #ifdef CONFIG_CANDY_NAPI
 	if (isr & INT_ISR_RX_MASK) {
-		if (netif_rx_schedule_prep(dev,&pp->napi)) {
+		if (netif_rx_schedule_prep(dev, &pp->napi)) {
 			candy_mask_napi_ints(p);
-			__netif_rx_schedule(dev,&pp->napi);
+			__netif_rx_schedule(dev, &pp->napi);
 		}
 	}
 #else
-	if (isr & INT_ISR_RX_MASK) {
+	if (isr & INT_ISR_RX_MASK)
 		candy_rx(dev, isr);
-	}
 #endif
 
-	if (isr & INT_ISR_TX_MASK) {
+	if (isr & INT_ISR_TX_MASK)
 		candy_tx_done(dev, isr);
-	}
 
 	/* we may need to do something with other intrs too in the future */
 
@@ -1400,7 +1420,7 @@ static void
 candy_get_phy_status(struct net_device *dev, int *duplex, int *linkup,
 		     int *speed)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	u16 reg;
 
 	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMCR);
@@ -1412,7 +1432,7 @@ candy_get_phy_status(struct net_device *dev, int *duplex, int *linkup,
 		 * half or full duplex.
 		 */
 		*duplex = (reg & BMCR_FULLDPLX) ? 1 : 0;
-		*speed = (reg & BMCR_SPEED100) ? 1: 0;
+		*speed = (reg & BMCR_SPEED100) ? 1 : 0;
 	} else {
 		/*
 		 * Auto-negotiation is enabled.  Figure out what was
@@ -1449,8 +1469,8 @@ candy_get_phy_status(struct net_device *dev, int *duplex, int *linkup,
 static void
 candy_poll_mii(unsigned long data)
 {
-	struct net_device *dev = (struct net_device *) data;
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct net_device *dev = (struct net_device *)data;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	int phy_duplex, mac_duplex;
 	int phy_carrier, netif_carrier;
 	int phy_speed, mac_speed;
@@ -1496,7 +1516,7 @@ candy_poll_mii(unsigned long data)
 static int
 candy_open(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	int retval;
 
 	if (netif_msg_ifup(pp))
@@ -1522,9 +1542,9 @@ candy_open(struct net_device *dev)
 #endif
 	init_timer(&pp->phy_timer);
 
-	pp->phy_timer.data = (unsigned long) dev;
+	pp->phy_timer.data = (unsigned long)dev;
 	pp->phy_timer.function = &candy_poll_mii;
-	candy_poll_mii((unsigned long) dev);
+	candy_poll_mii((unsigned long)dev);
 
 	netif_start_queue(dev);
 
@@ -1534,7 +1554,7 @@ candy_open(struct net_device *dev)
 static int
 candy_close(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 
 #ifdef CONFIG_CANDY_NAPI
 	napi_disable(&pp->napi);
@@ -1570,7 +1590,7 @@ candy_close(struct net_device *dev)
 static int
 candy_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	ulong flags;
 
 	if (netif_msg_tx_queued(pp))
@@ -1614,13 +1634,11 @@ candy_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev->trans_start = jiffies;
 
 	/* do we need to start sending or just append */
-	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail))
 		restart_tx_hw(dev);
-	}
 
-	if (pp->tx_count >= TX_RING_SIZE - 2) {
+	if (pp->tx_count >= TX_RING_SIZE - 2)
 		netif_stop_queue(dev);
-	}
 
 	spin_unlock_irqrestore(&pp->lock, flags);
 
@@ -1630,7 +1648,7 @@ candy_xmit(struct sk_buff *skb, struct net_device *dev)
 static struct net_device_stats *
 candy_get_stats(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	unsigned long flags;
 
 	if (netif_device_present(dev)) {
@@ -1644,7 +1662,7 @@ candy_get_stats(struct net_device *dev)
 static void
 candy_set_rx_mode(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 	candy_regs *p = pp->regs;
 	ulong val;
 
@@ -1675,7 +1693,7 @@ candy_set_rx_mode(struct net_device *dev)
 static void
 candy_tx_timeout(struct net_device *dev)
 {
-	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_private *pp = (struct candy_private *)dev->priv;
 
 	printk(KERN_ERR "%s : tx_timeout.\n", dev->name);
 
@@ -1733,8 +1751,8 @@ static int nec_candy_probe(struct device *dev)
 		goto err2;
 	}
 
-	ndev->base_addr = (unsigned long) ioremap(res->start,
-						  res->end - res->start + 1);
+	ndev->base_addr = (unsigned long)ioremap(res->start,
+						 res->end - res->start + 1);
 	if (!ndev->base_addr) {
 		ret = -ENOMEM;
 		goto err3;
@@ -1753,49 +1771,51 @@ static int nec_candy_probe(struct device *dev)
 	ndev->set_multicast_list = candy_set_rx_mode;
 	ndev->tx_timeout = candy_tx_timeout;
 	ndev->watchdog_timeo = TX_TIMEOUT;
-
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	ndev->poll_controller = candy_poll_controller;
 #endif
 
 	/* init private data */
-	pp = (struct candy_private *) ndev->priv;
-	p = pp->regs = (candy_regs *) ndev->base_addr;
+	pp = (struct candy_private *)ndev->priv;
+	p = pp->regs = (candy_regs *)ndev->base_addr;
 	pp->dev = dev;
 
 #ifdef CONFIG_CANDY_NAPI
-	netif_napi_add(ndev, &pp->napi, candy_napi_poll,64);
+	netif_napi_add(ndev, &pp->napi, candy_napi_poll, 64);
 #endif
+
 	/* alloc tx/rx rings and rx buffers */
 
-	pp->tx_ring = kmalloc(sizeof(struct candy_desc) * (TX_RING_SIZE + 1), GFP_ATOMIC);
+	pp->tx_ring = kmalloc(sizeof(struct candy_desc) * (TX_RING_SIZE + 1),
+			      GFP_ATOMIC);
 	if (!pp->tx_ring) {
 		ret = -ENOMEM;
 		goto err4;
 	}
-	pp->rx_ring = kmalloc(sizeof(struct candy_desc) * (RX_RING_SIZE + 1), GFP_ATOMIC);
+	pp->rx_ring = kmalloc(sizeof(struct candy_desc) * (RX_RING_SIZE + 1),
+			      GFP_ATOMIC);
 	if (!pp->rx_ring) {
 		ret = -ENOMEM;
 		goto err5;
 	}
 
-	dma_cache_inv((ulong) pp->tx_ring,
+	dma_cache_inv((ulong)pp->tx_ring,
 		      sizeof(struct candy_desc) * (TX_RING_SIZE + 1));
-	dma_cache_inv((ulong) pp->rx_ring,
+	dma_cache_inv((ulong)pp->rx_ring,
 		      sizeof(struct candy_desc) * (RX_RING_SIZE + 1));
 
-	pp->tx_ring = (void *) KSEG1ADDR(pp->tx_ring);
-	pp->rx_ring = (void *) KSEG1ADDR(pp->rx_ring);
+	pp->tx_ring = (void *)KSEG1ADDR(pp->tx_ring);
+	pp->rx_ring = (void *)KSEG1ADDR(pp->rx_ring);
 
 	/* allocate rx skbs */
 	for (i = 0; i < RX_RING_SIZE; i++) {
 		pp->rx_skb[i] = dev_alloc_skb(RX_BUF_SIZE);
-		if (pp->rx_skb[i] == NULL) {
+		if (pp->rx_skb[i] == NULL)
 			panic("%s: failed to alloc rx skb!", ndev->name);
-		}
+
 		pp->rx_skb[i]->dev = ndev;
 		skb_reserve(pp->rx_skb[i], 2); /* align IP pkt to 16-byte */
-		dma_cache_inv((ulong) pp->rx_skb[i]->data, RX_BUF_SIZE);
+		dma_cache_inv((ulong)pp->rx_skb[i]->data, RX_BUF_SIZE);
 	}
 
 	/* set up links */
@@ -1869,13 +1889,13 @@ static int nec_candy_probe(struct device *dev)
 	if (ret != 0)
 		goto err6;
 
-	printk (KERN_INFO DRV_NAME ": Probe candy chip at "
-		"0x%08x, irq %d, Phy ID 0x%08x, "
-		"MAC Addr %02x:%02x:%02x:%02x:%02x:%02x\n",
-		res->start, ndev->irq, pp->mii_if.phy_id,
-		ndev->dev_addr[0], ndev->dev_addr[1],
-		ndev->dev_addr[2], ndev->dev_addr[3],
-		ndev->dev_addr[4], ndev->dev_addr[5]);
+	printk(KERN_INFO DRV_NAME ": Probe candy chip at "
+	       "0x%08x, irq %d, Phy ID 0x%08x, "
+	       "MAC Addr %02x:%02x:%02x:%02x:%02x:%02x\n",
+	       res->start, ndev->irq, pp->mii_if.phy_id,
+	       ndev->dev_addr[0], ndev->dev_addr[1],
+	       ndev->dev_addr[2], ndev->dev_addr[3],
+	       ndev->dev_addr[4], ndev->dev_addr[5]);
 
 	return 0;
 
@@ -1887,7 +1907,7 @@ err6:
 err5:
 	kfree(pp->tx_ring);
 err4:
-	iounmap((void *) ndev->base_addr);
+	iounmap((void *)ndev->base_addr);
 err3:
 	release_mem_region(res->start, res->end - res->start + 1);
 err2:
-- 
1.6.0.4

