From 83718e11f94b300bb496093df1ef181ab4f8ce71 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Mon, 7 Sep 2009 09:28:36 +0900
Subject: [PATCH 07/12] USB: EMMA EHCI/OHCI: Get PCI config resources via 2nd IORESOURCE_MEM

In order to make the driver more independent from some specific EMMA SoC,
we try to obtain a new resource for (pseudo) PCI configuration space via
2nd IORESOURCE_MEM, rather than using hardcorded [EO]HCI_CONFBASE.

At the same time, emma_pseudo_pci_init() and emma_start_[e]hc() function
prototypes are also changed to have 'int' return value.  They'll return
errors when we fail to get the PCI config resource, or fail to ioremap().

Finally, we don't need to include <asm/emma/emmaxxx.h> (which had never
been used so far, though).

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/usb/host/ehci-emma.c |   36 +++++++++++++++++++++++-------------
 drivers/usb/host/ohci-emma.c |   37 ++++++++++++++++++++++++-------------
 2 files changed, 47 insertions(+), 26 deletions(-)

diff --git a/drivers/usb/host/ehci-emma.c b/drivers/usb/host/ehci-emma.c
index 1fae7eb..b2052df 100644
--- a/drivers/usb/host/ehci-emma.c
+++ b/drivers/usb/host/ehci-emma.c
@@ -26,34 +26,39 @@
 
 #include <linux/platform_device.h>
 #include <linux/usb.h>
-#include <asm/emma/emmaxxx.h>
 
-/* ftop pseudo pci */
-#define EHCI_CONFBASE		(0xb0200500UL)
-#define OHCI_CONFBASE		(0xb0200200UL)
-#define PCI_CONFIG		EHCI_CONFBASE
 #define	PCI_CMD_MEM_ENABLE	(0x0002)
 #define	PCI_CMD_MASTER_ENABLE	(0x0004)
 
-static void emma_pseudo_pci_init(struct platform_device *pdev)
+static int emma_pseudo_pci_init(struct platform_device *pdev)
 {
-	struct resource *res;
+	struct resource *res, *cfg;
+	void __iomem *base;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
+	cfg = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!cfg)
+		return -ENXIO;
+	base = ioremap(cfg->start, resource_size(cfg));
+	if (!base)
+		return -ENOMEM;
+
 	/* PCI BAR */
-	writel(res->start, (void *)(PCI_CONFIG + 0x10));
+	writel(res->start, base + 0x10);
 
 	/* PCI command status */
-	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE,
-	       (void *)(PCI_CONFIG + 0x4));
+	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE, base + 0x4);
+
+	iounmap(base);
+	return 0;
 }
 
-static void emma_start_ehc(struct platform_device *pdev)
+static int emma_start_ehc(struct platform_device *pdev)
 {
 	pr_debug(__FILE__ ": starting EMMA EHCI USB Controller\n");
 
-	emma_pseudo_pci_init(pdev);
+	return emma_pseudo_pci_init(pdev);
 }
 
 static void emma_stop_ehc(struct platform_device *pdev)
@@ -115,7 +120,11 @@ int usb_ehci_emma_probe(const struct hc_driver *driver,
 		goto err2;
 	}
 
-	emma_start_ehc(pdev);
+	ret = emma_start_ehc(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to start HC\n");
+		goto err3;
+	}
 
 	ehci = hcd_to_ehci(hcd);
 	ehci->caps = hcd->regs;
@@ -131,6 +140,7 @@ int usb_ehci_emma_probe(const struct hc_driver *driver,
 
  err4:
 	emma_stop_ehc(pdev);
+ err3:
 	iounmap(hcd->regs);
  err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
diff --git a/drivers/usb/host/ohci-emma.c b/drivers/usb/host/ohci-emma.c
index 93da50e..27e95d5 100644
--- a/drivers/usb/host/ohci-emma.c
+++ b/drivers/usb/host/ohci-emma.c
@@ -25,34 +25,39 @@
 
 #include <linux/platform_device.h>
 #include <linux/usb.h>
-#include <asm/emma/emmaxxx.h>
 
-/* ftop pseudo pci */
-#define EHCI_CONFBASE		(0xb0200500UL)
-#define OHCI_CONFBASE		(0xb0200200UL)
-#define PCI_CONFIG		OHCI_CONFBASE
 #define	PCI_CMD_MEM_ENABLE	(0x0002)
 #define	PCI_CMD_MASTER_ENABLE	(0x0004)
 
-static void emma_pseudo_pci_init(struct platform_device *pdev)
+static int emma_pseudo_pci_init(struct platform_device *pdev)
 {
-	struct resource *res;
+	struct resource *res, *cfg;
+	void __iomem *base;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
+	cfg = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!cfg)
+		return -ENXIO;
+	base = ioremap(cfg->start, resource_size(cfg));
+	if (!base)
+		return -ENOMEM;
+
 	/* PCI BAR */
-	writel(res->start, (void *)(PCI_CONFIG + 0x10));
+	writel(res->start, base + 0x10);
 
 	/* PCI command status */
-	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE,
-	       (void *)(PCI_CONFIG + 0x4));
+	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE, base + 0x4);
+
+	iounmap(base);
+	return 0;
 }
 
-static void emma_start_hc(struct platform_device *pdev)
+static int emma_start_hc(struct platform_device *pdev)
 {
 	pr_debug(__FILE__ ": starting EMMA OHCI USB Controller\n");
 
-	emma_pseudo_pci_init(pdev);
+	return emma_pseudo_pci_init(pdev);
 }
 
 static void emma_stop_hc(struct platform_device *pdev)
@@ -113,7 +118,12 @@ int usb_hcd_emma_probe(const struct hc_driver *driver,
 		goto err2;
 	}
 
-	emma_start_hc(pdev);
+	ret = emma_start_hc(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to start HC\n");
+		goto err3;
+	}
+
 	ohci_hcd_init(hcd_to_ohci(hcd));
 
 	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
@@ -124,6 +134,7 @@ int usb_hcd_emma_probe(const struct hc_driver *driver,
 
  err4:
 	emma_stop_hc(pdev);
+ err3:
 	iounmap(hcd->regs);
  err2:
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
-- 
1.6.3.3

