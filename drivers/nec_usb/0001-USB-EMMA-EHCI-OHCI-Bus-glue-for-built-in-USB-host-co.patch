From 3fd7685332dbe8b857883a8712ecc2a0f40c8841 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Mon, 7 Sep 2009 09:26:02 +0900
Subject: [PATCH 01/12] USB: EMMA EHCI/OHCI: Bus glue for built-in USB host controllers

Recent EMMAXXX SoCs are equipped with USB EHCI/OHCI host controllers.
The HC core complies with the USB specification revision 2.0 and OHCI
spec rev. 1.0a for full-/low-speed signaling and Intel's EHCI spec rev.
1.0 for high-speed signaling.  The core consists of two HC cores with
PCI interface and USB2.0 transceivers.

This HC core is connected to the internal bus, and the FLIP bus bridge
will maintain control of it.  Then each host controller, in this case,
acts as if it's a PCI device.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 drivers/usb/host/ehci-emma.c |  275 ++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/ohci-emma.c |  286 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 561 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/host/ehci-emma.c
 create mode 100644 drivers/usb/host/ohci-emma.c

diff --git a/drivers/usb/host/ehci-emma.c b/drivers/usb/host/ehci-emma.c
new file mode 100644
index 0000000..9b699aa
--- /dev/null
+++ b/drivers/usb/host/ehci-emma.c
@@ -0,0 +1,275 @@
+/*
+ * EHCI HCD (Host Controller Driver) for USB.
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * Bus Glue for NEC EMMAXXX built-in EHCI host controller
+ *
+ * Based on fragments of previous drivers:
+ * hcd-pci.c by David Brownell <dbrownell@users.sourceforge.net>
+ * ohci-sa1111.c by Christopher Hoover <ch@hpl.hp.com>
+ * ehci-au1xxx.c by K.Boge <karsten.boge@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <asm/emma/emmaxxx.h>
+
+/* ftop registers */
+#define EMMA_FLIP_REGBASE	(0xb0200100)
+#define EMMA_FLIP_M0_CTR	(0x0)
+#define EMMA_FLIP_USB_CTR	(0x20)
+
+#define FLIP_OCI1_EN		(0x00100000UL)
+#define FLIP_OCI2_EN		(0x00200000UL)
+#define FLIP_PPON1_EN		(0x00400000UL)
+#define FLIP_PPON2_EN		(0x00800000UL)
+#define FLIP_OCI1_ACT		(0x00010000UL)
+#define FLIP_OCI2_ACT		(0x00020000UL)
+#define FLIP_PPON1_ACT		(0x00040000UL)
+#define FLIP_PPON2_ACT		(0x00080000UL)
+#define FLIP_ENDIAN_SWAP	(0x00000002UL)
+
+/* ftop pseudo pci */
+#define EHCI_CONFBASE		(0xb0200500UL)
+#define OHCI_CONFBASE		(0xb0200200UL)
+#define PCI_CONFIG		EHCI_CONFBASE
+#define	PCI_CMD_MEM_ENABLE	(0x0002)
+#define	PCI_CMD_MASTER_ENABLE	(0x0004)
+
+static int emma_flip_init(void)
+{
+	u32	d;
+
+	writel(0x00ff0900, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_USB_CTR));
+
+	d = readl((void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+	d |= FLIP_ENDIAN_SWAP;
+	writel(d, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+
+	return 0;
+}
+
+static void emma_pseudo_pci_init(struct platform_device *pdev)
+{
+	struct resource *res;
+	int		irq;
+	u32		d;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ehci_mem");
+	irq = platform_get_irq_byname(pdev, "ehci_irq");
+
+	/* PCI BAR */
+	writel(CPHYSADDR(res->start), (void *)(PCI_CONFIG + 0x10));
+
+	/* PCI interrupt line */
+	d = readl((void *)(PCI_CONFIG + 0x3c));
+	d &= ~0xff;
+	d |= irq;
+	writel(d, (void *)(PCI_CONFIG + 0x3c));
+
+	/* PCI command status */
+	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE,
+	       (void *)(PCI_CONFIG + 0x4));
+}
+
+static void emma_start_ehc(struct platform_device *pdev)
+{
+	pr_debug(__FILE__ ": starting EMMA EHCI USB Controller\n");
+
+	emma_flip_init();
+	emma_pseudo_pci_init(pdev);
+}
+
+static void emma_stop_ehc(struct platform_device *pdev)
+{
+	pr_debug(__FILE__ ": stopping EMMA EHCI USB Controller\n");
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_ehci_emma_probe - initialize EMMA built-in HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct platform_driver as probe().
+ */
+int usb_ehci_emma_probe(const struct hc_driver *driver,
+			struct platform_device *pdev)
+{
+	struct usb_hcd	*hcd;
+	struct ehci_hcd *ehci;
+	struct resource *res;
+	int irq, ret;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ehci_mem");
+	if (!res) {
+		pr_debug("Found HC with no register addr.  Check %s setup!\n",
+			 pdev->dev.bus_id);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	irq = platform_get_irq_byname(pdev, "ehci_irq");
+	if (irq == -ENXIO) {
+		pr_debug("Found HC with no IRQ.  Check %s setup!\n",
+			 pdev->dev.bus_id);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, "emma-ehci");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = (u64)res->start;
+	hcd->rsrc_len = (u64)(res->end - res->start + 1);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = (void __iomem *)((u32)hcd->rsrc_start);
+
+	emma_start_ehc(pdev);
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	ret = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_SHARED);
+	if (ret)
+		goto err4;
+
+	return 0;
+
+ err4:
+	emma_stop_ehc(pdev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_ehci_emma_remove - shutdown processing for EMMA built-in HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_emma_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ * Store this function in the HCD's struct platform_driver as remove().
+ */
+void usb_ehci_emma_remove(struct usb_hcd *hcd, struct platform_device *dev)
+{
+	usb_remove_hcd(hcd);
+	emma_stop_ehc(dev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_emma_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "EMMA EHCI",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_USB2 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ehci_hcd_emma_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_ehci_emma_probe(&ehci_emma_hc_driver, pdev);
+	return ret;
+}
+
+static int ehci_hcd_emma_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_ehci_emma_remove(hcd, pdev);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct platform_driver ehci_hcd_emma_driver = {
+	.probe		= ehci_hcd_emma_drv_probe,
+	.remove		= ehci_hcd_emma_drv_remove,
+	.driver = {
+		.name	= "emma-ehci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:emma-ehci");
diff --git a/drivers/usb/host/ohci-emma.c b/drivers/usb/host/ohci-emma.c
new file mode 100644
index 0000000..686c603
--- /dev/null
+++ b/drivers/usb/host/ohci-emma.c
@@ -0,0 +1,286 @@
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * Bus Glue for NEC EMMAXXX built-in OHCI host controller
+ *
+ * Based on fragments of previous drivers:
+ * hcd-pci.c by David Brownell <dbrownell@users.sourceforge.net>
+ * ohci-sa1111.c by Christopher Hoover <ch@hpl.hp.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/usb.h>
+#include <asm/emma/emmaxxx.h>
+
+/* ftop registers */
+#define EMMA_FLIP_REGBASE	(0xb0200100)
+#define EMMA_FLIP_M0_CTR	(0x0)
+#define EMMA_FLIP_USB_CTR	(0x20)
+
+#define FLIP_OCI1_EN		(0x00100000UL)
+#define FLIP_OCI2_EN		(0x00200000UL)
+#define FLIP_PPON1_EN		(0x00400000UL)
+#define FLIP_PPON2_EN		(0x00800000UL)
+#define FLIP_OCI1_ACT		(0x00010000UL)
+#define FLIP_OCI2_ACT		(0x00020000UL)
+#define FLIP_PPON1_ACT		(0x00040000UL)
+#define FLIP_PPON2_ACT		(0x00080000UL)
+#define FLIP_ENDIAN_SWAP	(0x00000002UL)
+
+/* ftop pseudo pci */
+#define EHCI_CONFBASE		(0xb0200500UL)
+#define OHCI_CONFBASE		(0xb0200200UL)
+#define PCI_CONFIG		OHCI_CONFBASE
+#define	PCI_CMD_MEM_ENABLE	(0x0002)
+#define	PCI_CMD_MASTER_ENABLE	(0x0004)
+
+static int emma_flip_init(void)
+{
+	u32	d;
+
+	writel(0x00ff0900, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_USB_CTR));
+
+	d = readl((void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+	d |= FLIP_ENDIAN_SWAP;
+	writel(d, (void *)(EMMA_FLIP_REGBASE + EMMA_FLIP_M0_CTR));
+
+	return 0;
+}
+
+static void emma_pseudo_pci_init(struct platform_device *pdev)
+{
+	struct resource *res;
+	int		irq;
+	u32		d;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ohci_mem");
+	irq = platform_get_irq_byname(pdev, "ohci_irq");
+
+	/* PCI BAR */
+	writel(CPHYSADDR(res->start), (void *)(PCI_CONFIG + 0x10));
+
+	/* PCI interrupt line */
+	d = readl((void *)(PCI_CONFIG + 0x3c));
+	d &= ~0xff;
+	d |= irq;
+	writel(d, (void *)(PCI_CONFIG + 0x3c));
+
+	/* PCI command status */
+	writel(PCI_CMD_MASTER_ENABLE | PCI_CMD_MEM_ENABLE,
+	       (void *)(PCI_CONFIG + 0x4));
+}
+
+static void emma_start_hc(struct platform_device *pdev)
+{
+	pr_debug(__FILE__ ": starting EMMA OHCI USB Controller\n");
+
+	emma_flip_init();
+	emma_pseudo_pci_init(pdev);
+}
+
+static void emma_stop_hc(struct platform_device *pdev)
+{
+	pr_debug(__FILE__ ": stopping EMMA OHCI USB Controller\n");
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_hcd_emma_probe - initialize EMMA built-in HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ * Store this function in the HCD's struct platform_driver as probe().
+ */
+int usb_hcd_emma_probe(const struct hc_driver *driver,
+		       struct platform_device *pdev)
+{
+	struct resource *res;
+	struct usb_hcd	*hcd;
+	int irq, ret;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ohci_mem");
+	if (!res) {
+		pr_debug("Found HC with no register addr.  Check %s setup!\n",
+			 pdev->dev.bus_id);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	irq = platform_get_irq_byname(pdev, "ohci_irq");
+	if (irq == -ENXIO) {
+		pr_debug("Found HC with no IRQ.  Check %s setup!\n",
+			 pdev->dev.bus_id);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	hcd = usb_create_hcd(driver, &pdev->dev, "emma-ohci");
+	if (!hcd)
+		return -ENOMEM;
+	hcd->rsrc_start = (u64)res->start;
+	hcd->rsrc_len = (u64)(res->end - res->start + 1);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		pr_debug("request_mem_region failed\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = (void __iomem *)((u32)hcd->rsrc_start);
+
+	emma_start_hc(pdev);
+	ohci_hcd_init(hcd_to_ohci(hcd));
+
+	ret = usb_add_hcd(hcd, pdev->resource[1].start, IRQF_SHARED);
+	if (ret)
+		goto err4;
+
+	return 0;
+
+ err4:
+	emma_stop_hc(pdev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+ err1:
+	usb_put_hcd(hcd);
+	return ret;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_hcd_emma_remove - shutdown processing for EMMA built-in HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_hcd_emma_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ * Store this function in the HCD's struct platform_driver as remove().
+ */
+void usb_hcd_emma_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	emma_stop_hc(pdev);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static int __devinit ohci_emma_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int		ret;
+
+	ret = ohci_init(ohci);
+	if (ret  < 0)
+		return ret;
+
+	ret = ohci_run(ohci);
+	if (ret < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+	return 0;
+}
+
+static const struct hc_driver ohci_emma_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "EMMA OHCI",
+	.hcd_priv_size		= sizeof(struct ohci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ohci_irq,
+	.flags			= HCD_USB11 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.start			= ohci_emma_start,
+	.stop			= ohci_stop,
+	.shutdown		= ohci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ohci_urb_enqueue,
+	.urb_dequeue		= ohci_urb_dequeue,
+	.endpoint_disable	= ohci_endpoint_disable,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ohci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ohci_hub_status_data,
+	.hub_control		= ohci_hub_control,
+#ifdef	CONFIG_PM
+	.bus_suspend		= ohci_bus_suspend,
+	.bus_resume		= ohci_bus_resume,
+#endif
+	.start_port_reset	= ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ohci_hcd_emma_drv_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	ret = usb_hcd_emma_probe(&ohci_emma_hc_driver, pdev);
+	return ret;
+}
+
+static int ohci_hcd_emma_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_hcd_emma_remove(hcd, pdev);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+static struct platform_driver ohci_hcd_emma_driver = {
+	.probe		= ohci_hcd_emma_drv_probe,
+	.remove		= ohci_hcd_emma_drv_remove,
+	.driver = {
+		.name	= "emma-ohci",
+		.owner	= THIS_MODULE,
+	},
+};
+
+MODULE_ALIAS("platform:emma-ohci");
-- 
1.6.3.3

