From marco.stornelli@gmail.com Sat Dec 15 00:46:14 2012
From: Marco Stornelli <marco.stornelli@gmail.com>
Date: Sat, 15 Dec 2012 09:39:21 +0100
Subject: pramfs: fix build for kernel 3.4
To: LTSI <ltsi-dev@lists.linuxfoundation.org>
Cc: Greg KH <gregkh@linuxfoundation.org>
Message-ID: <50CC3739.7070001@gmail.com>


Upgrade pramfs code for kernel 3.4

Signed-off-by: Marco Stornelli <marco.stornelli@gmail.com>
---
 fs/pramfs/acl.c            |   66 +---
 fs/pramfs/acl.h            |    3 
 fs/pramfs/balloc.c         |    2 
 fs/pramfs/file.c           |   47 +++
 fs/pramfs/inode.c          |  612 ++++++++++++++++++++++++++-------------------
 fs/pramfs/ioctl.c          |   24 +
 fs/pramfs/namei.c          |   24 -
 fs/pramfs/pram.h           |    8 
 fs/pramfs/super.c          |   27 +
 fs/pramfs/xattr_security.c |   33 +-
 include/linux/pram_fs_sb.h |    2 
 11 files changed, 478 insertions(+), 370 deletions(-)

--- a/fs/pramfs/acl.c
+++ b/fs/pramfs/acl.c
@@ -131,7 +131,7 @@ fail:
 /*
  * inode->i_mutex: don't care
  */
-static struct posix_acl *pram_get_acl(struct inode *inode, int type)
+struct posix_acl *pram_get_acl(struct inode *inode, int type)
 {
 	int name_index;
 	char *value = NULL;
@@ -195,12 +195,10 @@ static int pram_set_acl(struct inode *in
 	case ACL_TYPE_ACCESS:
 		name_index = PRAM_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			mode_t mode = inode->i_mode;
-			error = posix_acl_equiv_mode(acl, &mode);
+			error = posix_acl_equiv_mode(acl, &inode->i_mode);
 			if (error < 0)
 				return error;
 			else {
-				inode->i_mode = mode;
 				inode->i_ctime = CURRENT_TIME_SEC;
 				mark_inode_dirty(inode);
 				if (error == 0)
@@ -230,28 +228,6 @@ static int pram_set_acl(struct inode *in
 	return error;
 }
 
-int pram_check_acl(struct inode *inode, int mask, unsigned int flags)
-{
-	struct posix_acl *acl;
-
-	if (flags & IPERM_FLAG_RCU) {
-		if (!negative_cached_acl(inode, ACL_TYPE_ACCESS))
-			return -ECHILD;
-		return -EAGAIN;
-	}
-
-	acl = pram_get_acl(inode, ACL_TYPE_ACCESS);
-	if (IS_ERR(acl))
-		return PTR_ERR(acl);
-	if (acl) {
-		int error = posix_acl_permission(inode, acl, mask);
-		posix_acl_release(acl);
-		return error;
-	}
-
-	return -EAGAIN;
-}
-
 /*
  * Initialize the ACLs of a new inode. Called from pram_new_inode.
  *
@@ -274,29 +250,20 @@ int pram_init_acl(struct inode *inode, s
 	}
 
 	if (test_opt(inode->i_sb, POSIX_ACL) && acl) {
-		struct posix_acl *clone;
-		mode_t mode;
-
+		umode_t mode = inode->i_mode;
 		if (S_ISDIR(inode->i_mode)) {
 			error = pram_set_acl(inode, ACL_TYPE_DEFAULT, acl);
 			if (error)
 				goto cleanup;
 		}
-		clone = posix_acl_clone(acl, GFP_KERNEL);
-		error = -ENOMEM;
-		if (!clone)
-			goto cleanup;
-		mode = inode->i_mode;
-		error = posix_acl_create_masq(clone, &mode);
-		if (error >= 0) {
-			inode->i_mode = mode;
-			if (error > 0) {
-				/* This is an extended ACL */
-				error = pram_set_acl(inode,
-						     ACL_TYPE_ACCESS, clone);
-			}
+		error = posix_acl_create(&acl, GFP_KERNEL, &mode);
+		if (error < 0)
+			return error;
+		inode->i_mode = mode;
+		if (error > 0) {
+			/* This is an extended ACL */
+			error = pram_set_acl(inode, ACL_TYPE_ACCESS, acl);
 		}
-		posix_acl_release(clone);
 	}
 cleanup:
 	posix_acl_release(acl);
@@ -319,7 +286,7 @@ cleanup:
  */
 int pram_acl_chmod(struct inode *inode)
 {
-	struct posix_acl *acl, *clone;
+	struct posix_acl *acl;
 	int error;
 
 	if (!test_opt(inode->i_sb, POSIX_ACL))
@@ -329,14 +296,11 @@ int pram_acl_chmod(struct inode *inode)
 	acl = pram_get_acl(inode, ACL_TYPE_ACCESS);
 	if (IS_ERR(acl) || !acl)
 		return PTR_ERR(acl);
-	clone = posix_acl_clone(acl, GFP_KERNEL);
+	error = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);
+	if (error)
+		return error;
+	error = pram_set_acl(inode, ACL_TYPE_ACCESS, acl);
 	posix_acl_release(acl);
-	if (!clone)
-		return -ENOMEM;
-	error = posix_acl_chmod_masq(clone, inode->i_mode);
-	if (!error)
-		error = pram_set_acl(inode, ACL_TYPE_ACCESS, clone);
-	posix_acl_release(clone);
 	return error;
 }
 
--- a/fs/pramfs/acl.h
+++ b/fs/pramfs/acl.h
@@ -64,13 +64,12 @@ static inline int pram_acl_count(size_t
 #ifdef CONFIG_PRAMFS_POSIX_ACL
 
 /* acl.c */
-extern int pram_check_acl(struct inode *, int, unsigned int);
+extern struct posix_acl *pram_get_acl(struct inode *inode, int type);
 extern int pram_acl_chmod(struct inode *);
 extern int pram_init_acl(struct inode *, struct inode *);
 
 #else
 #include <linux/sched.h>
-#define pram_check_acl	NULL
 #define pram_get_acl	NULL
 #define pram_set_acl	NULL
 
--- a/fs/pramfs/balloc.c
+++ b/fs/pramfs/balloc.c
@@ -77,7 +77,7 @@ void pram_free_block(struct super_block
 		ps->s_free_blocknr_hint = cpu_to_be32(blocknr);
 	be32_add_cpu(&ps->s_free_blocks_count, 1);
 	pram_memlock_super(sb, ps);
-
+
 	unlock_super(sb);
 }
 
--- a/fs/pramfs/file.c
+++ b/fs/pramfs/file.c
@@ -352,8 +352,49 @@ static long pram_fallocate(struct file *
 	return ret;
 }
 
+loff_t pram_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct inode *inode = file->f_path.dentry->d_inode;
+	int retval;
+
+	if (origin != SEEK_DATA && origin != SEEK_HOLE)
+		return generic_file_llseek(file, offset, origin);
+
+	mutex_lock(&inode->i_mutex);
+	switch (origin) {
+	case SEEK_DATA:
+		retval = pram_find_region(inode, &offset, 0);
+		if (retval) {
+			mutex_unlock(&inode->i_mutex);
+			return retval;
+		}
+		break;
+	case SEEK_HOLE:
+		retval = pram_find_region(inode, &offset, 1);
+		if (retval) {
+			mutex_unlock(&inode->i_mutex);
+			return retval;
+		}
+		break;
+	}
+
+	if ((offset < 0 && !(file->f_mode & FMODE_UNSIGNED_OFFSET)) ||
+			offset > inode->i_sb->s_maxbytes) {
+		mutex_unlock(&inode->i_mutex);
+		return -EINVAL;
+	}
+
+	if (offset != file->f_pos) {
+		file->f_pos = offset;
+		file->f_version = 0;
+	}
+
+	mutex_unlock(&inode->i_mutex);
+	return offset;
+}
+
 const struct file_operations pram_file_operations = {
-	.llseek		= generic_file_llseek,
+	.llseek		= pram_llseek,
 	.read		= do_sync_read,
 	.write		= do_sync_write,
 	.aio_read	= generic_file_aio_read,
@@ -372,7 +413,7 @@ const struct file_operations pram_file_o
 
 #ifdef CONFIG_PRAMFS_XIP
 const struct file_operations pram_xip_file_operations = {
-	.llseek		= generic_file_llseek,
+	.llseek		= pram_llseek,
 	.read		= pram_xip_file_read,
 	.write		= xip_file_write,
 	.mmap		= pram_xip_file_mmap,
@@ -394,5 +435,5 @@ const struct inode_operations pram_file_
 	.removexattr	= generic_removexattr,
 #endif
 	.setattr	= pram_notify_change,
-	.check_acl	= pram_check_acl,
+	.get_acl	= pram_get_acl,
 };
--- a/fs/pramfs/inode.c
+++ b/fs/pramfs/inode.c
@@ -8,7 +8,7 @@
  * Copyright 2003 Matsushita Electric Industrial Co., Ltd.
  * 2003-2004 (c) MontaVista Software, Inc. , Steve Longerbeam
  * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed"as is"  without any
+ * License version 2. This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
 
@@ -18,27 +18,27 @@
 #include <linux/module.h>
 #include <linux/mpage.h>
 #include <linux/backing-dev.h>
-#include"pram.h"
-#include"xattr.h"
-#include"xip.h"
-#include"acl.h"
+#include "pram.h"
+#include "xattr.h"
+#include "xip.h"
+#include "acl.h"
 
-struct  backing_dev_info pram_backing_dev_info __read_mostly = {
-	.ra_pages       = 0,/* No readahead */
+struct backing_dev_info pram_backing_dev_info __read_mostly = {
+	.ra_pages       = 0,    /* No readahead */
 	.capabilities	= BDI_CAP_NO_ACCT_AND_WRITEBACK,
 };
 
 /*
- * allocate a data blockfor  inode andreturn  it's absolute blocknr.
- * Zeroes out the blockif  zero set. Increments inode->i_blocks.
+ * allocate a data block for inode and return it's absolute blocknr.
+ * Zeroes out the block if zero set. Increments inode->i_blocks.
  */
-static  int  pram_new_data_block(struct  inode *inode,unsigned  long  *blocknr,
-			int  zero)
+static int pram_new_data_block(struct inode *inode, unsigned long *blocknr,
+			       int zero)
 {
-	int  errval = pram_new_block(inode->i_sb, blocknr, zero);
+	int errval = pram_new_block(inode->i_sb, blocknr, zero);
 
-	if  (!errval) {
-		struct  pram_inode *pi = pram_get_inode(inode->i_sb,
+	if (!errval) {
+		struct pram_inode *pi = pram_get_inode(inode->i_sb,
 							inode->i_ino);
 		inode->i_blocks++;
 		pram_memunlock_inode(inode->i_sb, pi);
@@ -46,23 +46,23 @@ static  int  pram_new_data_block(struct
 		pram_memlock_inode(inode->i_sb, pi);
 	}
 
-	return  errval;
+	return errval;
 }
 
 /*
  * find the offset to the block represented by the given inode's file
  * relative block number.
  */
-u64 pram_find_data_block(struct  inode *inode,unsigned  long  file_blocknr)
+u64 pram_find_data_block(struct inode *inode, unsigned long file_blocknr)
 {
-	struct  super_block *sb = inode->i_sb;
-	struct  pram_inode *pi;
-	u64 *row;/* ptr to row block */
-	u64 *col;/* ptr to column blocks */
+	struct super_block *sb = inode->i_sb;
+	struct pram_inode *pi;
+	u64 *row; /* ptr to row block */
+	u64 *col; /* ptr to column blocks */
 	u64 bp = 0;
-	unsigned  int  i_row, i_col;
-	unsigned  int  N = sb->s_blocksize >> 3;/* num block ptrs per block */
-	unsigned  int  Nbits = sb->s_blocksize_bits - 3;
+	unsigned int i_row, i_col;
+	unsigned int N = sb->s_blocksize >> 3; /* num block ptrs per block */
+	unsigned int Nbits = sb->s_blocksize_bits - 3;
 
 	pi = pram_get_inode(sb, inode->i_ino);
 
@@ -70,42 +70,143 @@ u64 pram_find_data_block(struct  inode *
 	i_col  = file_blocknr & (N-1);
 
 	row = pram_get_block(sb, be64_to_cpu(pi->i_type.reg.row_block));
-	if  (row) {
+	if (row) {
 		col = pram_get_block(sb, be64_to_cpu(row[i_row]));
-		if  (col)
+		if (col)
 			bp = be64_to_cpu(col[i_col]);
 	}
 
-	return  bp;
+	return bp;
+}
+
+/*
+ * find the file offset for SEEK_DATA/SEEK_HOLE
+ */
+int pram_find_region(struct inode *inode, loff_t *offset, int hole)
+{
+	struct super_block *sb = inode->i_sb;
+	struct pram_inode *pi = pram_get_inode(sb, inode->i_ino);
+	int N = sb->s_blocksize >> 3; /* num block ptrs per block */
+	int first_row_index, last_row_index, i, j;
+	unsigned long first_blocknr, last_blocknr, blocks = 0, offset_in_block;
+	u64 *row; /* ptr to row block */
+	u64 *col; /* ptr to column blocks */
+	int data_found = 0, hole_found = 0;
+
+	if (*offset >= inode->i_size)
+		return -ENXIO;
+
+	if (!inode->i_blocks || !pi->i_type.reg.row_block) {
+		if (hole)
+			return inode->i_size;
+		else
+			return -ENXIO;
+	}
+
+	offset_in_block = *offset & (sb->s_blocksize - 1);
+
+	first_blocknr = *offset >> sb->s_blocksize_bits;
+	last_blocknr = inode->i_size >> sb->s_blocksize_bits;
+
+	first_row_index = first_blocknr >> (sb->s_blocksize_bits - 3);
+	last_row_index  = last_blocknr >> (sb->s_blocksize_bits - 3);
+
+	row = pram_get_block(sb, be64_to_cpu(pi->i_type.reg.row_block));
+
+	for (i = first_row_index; i <= last_row_index; i++) {
+		int first_col_index = (i == first_row_index) ?
+			first_blocknr & (N-1) : 0;
+		int last_col_index = (i == last_row_index) ?
+			last_blocknr & (N-1) : N-1;
+
+		if (!row[i]) {
+			hole_found = 1;
+			if (!hole)
+				blocks += sb->s_blocksize >> 3;
+			continue;
+		}
+
+		col = pram_get_block(sb, be64_to_cpu(row[i]));
+
+		for (j = first_col_index; j <= last_col_index; j++) {
+
+			if (col[j]) {
+				data_found = 1;
+				if (!hole)
+					goto out;
+			} else
+				hole_found = 1;
+
+			if (!hole_found || !hole)
+				blocks++;
+		}
+		cond_resched();
+	}
+ out:
+	/* Searching data but only hole found till the end */
+	if (!hole && !data_found && hole_found)
+		return -ENXIO;
+
+	if (data_found && !hole_found) {
+		/* Searching data but we are alredy into them */
+		if (!hole)
+			return 0;
+		/* Searching hole but only data found, go to the end */
+		else {
+			*offset = inode->i_size;
+			return 0;
+		}
+	}
+
+	/* Searching for hole, hole found and starting inside an hole */
+	if (hole && hole_found && !blocks) {
+			/* we found data after it */
+			if (data_found)
+				return 0;
+			else {
+				/* last hole */
+				*offset = inode->i_size;
+				return 0;
+			}
+	}
+
+	if (offset_in_block) {
+		blocks--;
+		*offset += (blocks << sb->s_blocksize_bits) +
+					(sb->s_blocksize - offset_in_block);
+	} else
+		*offset += blocks << sb->s_blocksize_bits;
+
+	return 0;
 }
 
 /*
  * Free data blocks from inode in the range start <=> end
  */
-static  void  __pram_truncate_blocks(struct  inode *inode, loff_t start,
+static void __pram_truncate_blocks(struct inode *inode, loff_t start,
 				   loff_t end)
 {
-	struct  super_block *sb = inode->i_sb;
-	struct  pram_inode *pi = pram_get_inode(sb, inode->i_ino);
-	int  N = sb->s_blocksize >> 3;/* num block ptrs per block */
-	int  Nbits = sb->s_blocksize_bits - 3;
-	int  first_row_index, last_row_index, i, j;
-	unsigned  long  blocknr, first_blocknr, last_blocknr;
-	unsigned  int  freed = 0;
-	u64 *row;/* ptr to row block */
-	u64 *col;/* ptr to column blocks */
+	struct super_block *sb = inode->i_sb;
+	struct pram_inode *pi = pram_get_inode(sb, inode->i_ino);
+	int N = sb->s_blocksize >> 3; /* num block ptrs per block */
+	int Nbits = sb->s_blocksize_bits - 3;
+	int first_row_index, last_row_index, i, j;
+	unsigned long blocknr, first_blocknr, last_blocknr;
+	unsigned int freed = 0;
+	u64 *row; /* ptr to row block */
+	u64 *col; /* ptr to column blocks */
 
-	if  (!pi->i_type.reg.row_block)
+	if (!pi->i_type.reg.row_block)
 		return;
 
 	first_blocknr = (start + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
 
-	if  (pi->i_flags & cpu_to_be32(PRAM_EOFBLOCKS_FL))
+	if (pi->i_flags & cpu_to_be32(PRAM_EOFBLOCKS_FL))
 		last_blocknr = (1UL << (2*sb->s_blocksize_bits - 6)) - 1;
 	else
 		last_blocknr = end >> sb->s_blocksize_bits;
 
-	if  (first_blocknr > last_blocknr)
+	if (first_blocknr > last_blocknr)
 		return;
 
 	first_row_index = first_blocknr >> Nbits;
@@ -113,20 +214,20 @@ static  void  __pram_truncate_blocks(str
 
 	row = pram_get_block(sb, be64_to_cpu(pi->i_type.reg.row_block));
 
-	for  (i = first_row_index; i <= last_row_index; i++) {
-		int  first_col_index = (i == first_row_index) ?
+	for (i = first_row_index; i <= last_row_index; i++) {
+		int first_col_index = (i == first_row_index) ?
 			first_blocknr & (N-1) : 0;
-		int  last_col_index = (i == last_row_index) ?
+		int last_col_index = (i == last_row_index) ?
 			last_blocknr & (N-1) : N-1;
 
-		if  (unlikely(!row[i]))
+		if (unlikely(!row[i]))
 			continue;
 
 		col = pram_get_block(sb, be64_to_cpu(row[i]));
 
-		for  (j = first_col_index; j <= last_col_index; j++) {
+		for (j = first_col_index; j <= last_col_index; j++) {
 
-			if  (unlikely(!col[j]))
+			if (unlikely(!col[j]))
 				continue;
 
 			blocknr = pram_get_blocknr(sb, be64_to_cpu(col[j]));
@@ -137,7 +238,9 @@ static  void  __pram_truncate_blocks(str
 			pram_memlock_block(sb, col);
 		}
 
-		if  (first_col_index == 0) {
+		cond_resched();
+
+		if (first_col_index == 0) {
 			blocknr = pram_get_blocknr(sb, be64_to_cpu(row[i]));
 			pram_free_block(sb, blocknr);
 			pram_memunlock_block(sb, row);
@@ -148,13 +251,13 @@ static  void  __pram_truncate_blocks(str
 
 	inode->i_blocks -= freed;
 
-	if  (start == 0) {
+	if (start == 0) {
 		blocknr = pram_get_blocknr(sb,
 					be64_to_cpu(pi->i_type.reg.row_block));
 		pram_free_block(sb, blocknr);
 		pram_memunlock_inode(sb, pi);
 		pi->i_type.reg.row_block = 0;
-		goto  update_blocks;
+		goto update_blocks;
 	}
 	pram_memunlock_inode(sb, pi);
 
@@ -163,13 +266,11 @@ static  void  __pram_truncate_blocks(str
 	pram_memlock_inode(sb, pi);
 }
 
-static  void  pram_truncate_blocks(struct  inode *inode, loff_t start, loff_t end)
+static void pram_truncate_blocks(struct inode *inode, loff_t start, loff_t end)
 {
-	if  (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	      S_ISLNK(inode->i_mode)))
 		return;
-	if  (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return;
 
 	__pram_truncate_blocks(inode, start, end);
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
@@ -177,29 +278,29 @@ static  void  pram_truncate_blocks(struc
 }
 
 /*
- * Allocate num data blocksfor  inode, starting at given file-relative
+ * Allocate num data blocks for inode, starting at given file-relative
  * block number.
  */
-int  pram_alloc_blocks(struct  inode *inode,int  file_blocknr,unsigned  int  num)
+int pram_alloc_blocks(struct inode *inode, int file_blocknr, unsigned int num)
 {
-	struct  super_block *sb = inode->i_sb;
-	struct  pram_inode *pi = pram_get_inode(sb, inode->i_ino);
-	int  N = sb->s_blocksize >> 3;/* num block ptrs per block */
-	int  Nbits = sb->s_blocksize_bits - 3;
-	int  first_file_blocknr;
-	int  last_file_blocknr;
-	int  first_row_index, last_row_index;
-	int  i, j, errval;
-	unsigned  long  blocknr;
+	struct super_block *sb = inode->i_sb;
+	struct pram_inode *pi = pram_get_inode(sb, inode->i_ino);
+	int N = sb->s_blocksize >> 3; /* num block ptrs per block */
+	int Nbits = sb->s_blocksize_bits - 3;
+	int first_file_blocknr;
+	int last_file_blocknr;
+	int first_row_index, last_row_index;
+	int i, j, errval;
+	unsigned long blocknr;
 	u64 *row;
 	u64 *col;
 
-	if  (!pi->i_type.reg.row_block) {
+	if (!pi->i_type.reg.row_block) {
 		/* alloc the 2nd order array block */
 		errval = pram_new_block(sb, &blocknr, 1);
-		if  (errval) {
+		if (errval) {
 			pram_dbg("failed to alloc 2nd order array block\n");
-			goto  fail;
+			goto fail;
 		}
 		pram_memunlock_inode(sb, pi);
 		pi->i_type.reg.row_block = cpu_to_be64(pram_get_block_off(sb,
@@ -215,19 +316,19 @@ int  pram_alloc_blocks(struct  inode *in
 	first_row_index = first_file_blocknr >> Nbits;
 	last_row_index  = last_file_blocknr >> Nbits;
 
-	for  (i = first_row_index; i <= last_row_index; i++) {
-		int  first_col_index, last_col_index;
+	for (i = first_row_index; i <= last_row_index; i++) {
+		int first_col_index, last_col_index;
 
 		/*
-		 * we are starting anew  row, so make sure
-		 * there is a block allocatedfor  the row.
+		 * we are starting a new row, so make sure
+		 * there is a block allocated for the row.
 		 */
-		if  (!row[i]) {
+		if (!row[i]) {
 			/* allocate the row block */
 			errval = pram_new_block(sb, &blocknr, 1);
-			if  (errval) {
+			if (errval) {
 				pram_dbg("failed to alloc row block\n");
-				goto  fail;
+				goto fail;
 			}
 			pram_memunlock_block(sb, row);
 			row[i] = cpu_to_be64(pram_get_block_off(sb, blocknr));
@@ -241,17 +342,19 @@ int  pram_alloc_blocks(struct  inode *in
 		last_col_index = (i == last_row_index) ?
 			last_file_blocknr & (N-1) : N-1;
 
-		for  (j = first_col_index; j <= last_col_index; j++) {
-			if  (!col[j]) {
+		for (j = first_col_index; j <= last_col_index; j++) {
+			if (!col[j]) {
 				errval = pram_new_data_block(inode, &blocknr,
 							     1);
-				if  (errval) {
+				if (errval) {
 					pram_dbg("fail to alloc data block\n");
-					/* For later recovery in truncate... */
-					pram_memunlock_inode(inode->i_sb, pi);
-					pi->i_flags |= cpu_to_be32(PRAM_EOFBLOCKS_FL);
-					pram_memlock_inode(inode->i_sb, pi);
-					goto  fail;
+					if (j != first_col_index) {
+						__pram_truncate_blocks(inode,
+							inode->i_size,
+					inode->i_size + ((j - first_col_index)
+					<< inode->i_sb->s_blocksize_bits));
+					}
+					goto fail;
 				}
 				pram_memunlock_block(sb, col);
 				col[j] = cpu_to_be64(pram_get_block_off(sb,
@@ -263,25 +366,25 @@ int  pram_alloc_blocks(struct  inode *in
 
 	errval = 0;
  fail:
-	return  errval;
+	return errval;
 }
 
-static  int  pram_read_inode(struct  inode *inode,struct  pram_inode *pi)
+static int pram_read_inode(struct inode *inode, struct pram_inode *pi)
 {
-	int  ret = -EIO;
+	int ret = -EIO;
 
 	mutex_lock(&PRAM_I(inode)->i_meta_mutex);
 
-	if  (pram_calc_checksum((u8 *)pi, PRAM_INODE_SIZE)) {
-		pram_err(inode->i_sb,"checksum error in inode %08x\n",
+	if (pram_calc_checksum((u8 *)pi, PRAM_INODE_SIZE)) {
+		pram_err(inode->i_sb, "checksum error in inode %08x\n",
 			  (u32)inode->i_ino);
-		goto  bad_inode;
+		goto bad_inode;
 	}
 
 	inode->i_mode = be16_to_cpu(pi->i_mode);
 	inode->i_uid = be32_to_cpu(pi->i_uid);
 	inode->i_gid = be32_to_cpu(pi->i_gid);
-	inode->i_nlink = be16_to_cpu(pi->i_links_count);
+	set_nlink(inode, be16_to_cpu(pi->i_links_count));
 	inode->i_size = be32_to_cpu(pi->i_size);
 	inode->i_atime.tv_sec = be32_to_cpu(pi->i_atime);
 	inode->i_ctime.tv_sec = be32_to_cpu(pi->i_ctime);
@@ -291,13 +394,13 @@ static  int  pram_read_inode(struct  ino
 	inode->i_generation = be32_to_cpu(pi->i_generation);
 	pram_set_inode_flags(inode, pi);
 
-	/* checkif  the inode is active. */
-	if  (inode->i_nlink == 0 && (inode->i_mode == 0 ||
+	/* check if the inode is active. */
+	if (inode->i_nlink == 0 && (inode->i_mode == 0 ||
 				    be32_to_cpu(pi->i_dtime))) {
-		/*this  inode is deleted */
+		/* this inode is deleted */
 		pram_dbg("read inode: inode %lu not active", inode->i_ino);
 		ret = -ESTALE;
-		goto  bad_inode;
+		goto bad_inode;
 	}
 
 	inode->i_blocks = be32_to_cpu(pi->i_blocks);
@@ -305,21 +408,21 @@ static  int  pram_read_inode(struct  ino
 	inode->i_mapping->a_ops = &pram_aops;
 	inode->i_mapping->backing_dev_info = &pram_backing_dev_info;
 
-	switch  (inode->i_mode & S_IFMT) {
-	case  S_IFREG:
-		if  (pram_use_xip(inode->i_sb)) {
+	switch (inode->i_mode & S_IFMT) {
+	case S_IFREG:
+		if (pram_use_xip(inode->i_sb)) {
 			inode->i_mapping->a_ops = &pram_aops_xip;
 			inode->i_fop = &pram_xip_file_operations;
-		}else  {
+		} else {
 			inode->i_op = &pram_file_inode_operations;
 			inode->i_fop = &pram_file_operations;
 		}
 		break;
-	case  S_IFDIR:
+	case S_IFDIR:
 		inode->i_op = &pram_dir_inode_operations;
 		inode->i_fop = &pram_dir_operations;
 		break;
-	case  S_IFLNK:
+	case S_IFLNK:
 		inode->i_op = &pram_symlink_inode_operations;
 		break;
 	default:
@@ -331,22 +434,22 @@ static  int  pram_read_inode(struct  ino
 	}
 
 	mutex_unlock(&PRAM_I(inode)->i_meta_mutex);
-	return  0;
+	return 0;
 
  bad_inode:
 	make_bad_inode(inode);
 	mutex_unlock(&PRAM_I(inode)->i_meta_mutex);
-	return  ret;
+	return ret;
 }
 
-int  pram_update_inode(struct  inode *inode)
+int pram_update_inode(struct inode *inode)
 {
-	struct  pram_inode *pi;
-	int  retval = 0;
+	struct pram_inode *pi;
+	int retval = 0;
 
 	pi = pram_get_inode(inode->i_sb, inode->i_ino);
-	if  (!pi)
-		return  -EACCES;
+	if (!pi)
+		return -EACCES;
 
 	mutex_lock(&PRAM_I(inode)->i_meta_mutex);
 
@@ -363,13 +466,13 @@ int  pram_update_inode(struct  inode *in
 	pi->i_generation = cpu_to_be32(inode->i_generation);
 	pram_get_inode_flags(inode, pi);
 
-	if  (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
+	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
 		pi->i_type.dev.rdev = cpu_to_be32(inode->i_rdev);
 
 	pram_memlock_inode(inode->i_sb, pi);
 
 	mutex_unlock(&PRAM_I(inode)->i_meta_mutex);
-	return  retval;
+	return retval;
 }
 
 /*
@@ -380,12 +483,12 @@ int  pram_update_inode(struct  inode *in
  * through the filesystem because the directory entry
  * has been deleted earlier.
  */
-static  void  pram_free_inode(struct  inode *inode)
+static void pram_free_inode(struct inode *inode)
 {
-	struct  super_block *sb = inode->i_sb;
-	struct  pram_super_block *ps;
-	struct  pram_inode *pi;
-	unsigned  long  inode_nr;
+	struct super_block *sb = inode->i_sb;
+	struct pram_super_block *ps;
+	struct pram_inode *pi;
+	unsigned long inode_nr;
 
 	pram_xattr_delete_inode(inode);
 
@@ -403,10 +506,10 @@ static  void  pram_free_inode(struct  in
 	/* increment s_free_inodes_count */
 	ps = pram_get_super(sb);
 	pram_memunlock_super(sb, ps);
-	if  (inode_nr < be32_to_cpu(ps->s_free_inode_hint))
+	if (inode_nr < be32_to_cpu(ps->s_free_inode_hint))
 		ps->s_free_inode_hint = cpu_to_be32(inode_nr);
 	be32_add_cpu(&ps->s_free_inodes_count, 1);
-	if  (be32_to_cpu(ps->s_free_inodes_count) ==
+	if (be32_to_cpu(ps->s_free_inodes_count) ==
 					 be32_to_cpu(ps->s_inodes_count) - 1) {
 		/* filesystem is empty */
 		pram_dbg("fs is empty!\n");
@@ -417,44 +520,44 @@ static  void  pram_free_inode(struct  in
 	unlock_super(sb);
 }
 
-struct  inode *pram_iget(struct  super_block *sb,unsigned  long  ino)
+struct inode *pram_iget(struct super_block *sb, unsigned long ino)
 {
-	struct  inode *inode;
-	struct  pram_inode *pi;
-	int  err;
+	struct inode *inode;
+	struct pram_inode *pi;
+	int err;
 
 	inode = iget_locked(sb, ino);
-	if  (unlikely(!inode))
-		return  ERR_PTR(-ENOMEM);
-	if  (!(inode->i_state & I_NEW))
-		return  inode;
+	if (unlikely(!inode))
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
 
 	pi = pram_get_inode(sb, ino);
-	if  (!pi) {
+	if (!pi) {
 		err = -EACCES;
-		goto  fail;
+		goto fail;
 	}
 	err = pram_read_inode(inode, pi);
-	if  (unlikely(err))
-		goto  fail;
+	if (unlikely(err))
+		goto fail;
 
 	unlock_new_inode(inode);
-	return  inode;
+	return inode;
 fail:
 	iget_failed(inode);
-	return  ERR_PTR(err);
+	return ERR_PTR(err);
 }
 
-void  pram_evict_inode(struct  inode *inode)
+void pram_evict_inode(struct inode *inode)
 {
-	int  want_delete = 0;
+	int want_delete = 0;
 
-	if  (!inode->i_nlink && !is_bad_inode(inode))
+	if (!inode->i_nlink && !is_bad_inode(inode))
 		want_delete = 1;
 
 	truncate_inode_pages(&inode->i_data, 0);
 
-	if  (want_delete) {
+	if (want_delete) {
 		/* unlink from chain in the inode's directory */
 		pram_remove_link(inode);
 		pram_truncate_blocks(inode, 0, inode->i_size);
@@ -463,65 +566,64 @@ void  pram_evict_inode(struct  inode *in
 
 	end_writeback(inode);
 
-	if  (want_delete)
+	if (want_delete)
 		pram_free_inode(inode);
 }
 
 
-
-struct  inode *pram_new_inode(struct  inode *dir,int  mode,
-			const  struct  qstr *qstr)
+struct inode *pram_new_inode(struct inode *dir, umode_t mode,
+			     const struct qstr *qstr)
 {
-	struct  super_block *sb;
-	struct  pram_sb_info *sbi;
-	struct  pram_super_block *ps;
-	struct  inode *inode;
-	struct  pram_inode *pi =NULL;
-	struct  pram_inode *diri =NULL;
-	int  i, errval;
+	struct super_block *sb;
+	struct pram_sb_info *sbi;
+	struct pram_super_block *ps;
+	struct inode *inode;
+	struct pram_inode *pi = NULL;
+	struct pram_inode *diri = NULL;
+	int i, errval;
 	ino_t ino = 0;
 
 	sb = dir->i_sb;
-	sbi = (struct  pram_sb_info *)sb->s_fs_info;
+	sbi = (struct pram_sb_info *)sb->s_fs_info;
 	inode = new_inode(sb);
-	if  (!inode)
-		return  ERR_PTR(-ENOMEM);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
 
 	lock_super(sb);
 	ps = pram_get_super(sb);
 
-	if  (ps->s_free_inodes_count) {
+	if (ps->s_free_inodes_count) {
 		/* find the oldest unused pram inode */
-		for  (i = be32_to_cpu(ps->s_free_inode_hint);
+		for (i = be32_to_cpu(ps->s_free_inode_hint);
 		     i < be32_to_cpu(ps->s_inodes_count); i++) {
 			ino = PRAM_ROOT_INO + (i << PRAM_INODE_BITS);
 			pi = pram_get_inode(sb, ino);
-			/* checkif  the inode is active. */
-			if  (be16_to_cpu(pi->i_links_count) == 0 &&
+			/* check if the inode is active. */
+			if (be16_to_cpu(pi->i_links_count) == 0 &&
 			   (be16_to_cpu(pi->i_mode) == 0 ||
 			   be32_to_cpu(pi->i_dtime))) {
-				/*this  inode is deleted */
+				/* this inode is deleted */
 				break;
 			}
 		}
 
-		if  (unlikely(i >= be32_to_cpu(ps->s_inodes_count))) {
-			pram_err(sb,"free inodes count!=0 but none free!?\n");
+		if (unlikely(i >= be32_to_cpu(ps->s_inodes_count))) {
+			pram_err(sb, "free inodes count!=0 but none free!?\n");
 			errval = -ENOSPC;
-			goto  fail1;
+			goto fail1;
 		}
 
 		pram_dbg("allocating inode %lu\n", ino);
-	}else  {
-		pram_dbg("no space left to createnew  inode!\n");
+	} else {
+		pram_dbg("no space left to create new inode!\n");
 		errval = -ENOSPC;
-		goto  fail1;
+		goto fail1;
 	}
 
 	diri = pram_get_inode(sb, dir->i_ino);
-	if  (!diri) {
+	if (!diri) {
 		errval = -EACCES;
-		goto  fail1;
+		goto fail1;
 	}
 
 	/* chosen inode is in ino */
@@ -541,25 +643,25 @@ struct  inode *pram_new_inode(struct  in
 
 	pram_set_inode_flags(inode, pi);
 
-	if  (insert_inode_locked(inode) < 0) {
+	if (insert_inode_locked(inode) < 0) {
 		errval = -EINVAL;
-		goto  fail2;
+		goto fail1;
 	}
-	errval = pram_write_inode(inode,NULL);
-	if  (errval)
-		goto  fail2;
+	errval = pram_write_inode(inode, NULL);
+	if (errval)
+		goto fail2;
 
 	errval = pram_init_acl(inode, dir);
-	if  (errval)
-		goto  fail2;
+	if (errval)
+		goto fail2;
 
 	errval = pram_init_security(inode, dir, qstr);
-	if  (errval)
-		goto  fail2;
+	if (errval)
+		goto fail2;
 
 	pram_memunlock_super(sb, ps);
 	be32_add_cpu(&ps->s_free_inodes_count, -1);
-	if  (i < be32_to_cpu(ps->s_inodes_count)-1)
+	if (i < be32_to_cpu(ps->s_inodes_count)-1)
 		ps->s_free_inode_hint = cpu_to_be32(i+1);
 	else
 		ps->s_free_inode_hint = 0;
@@ -567,46 +669,46 @@ struct  inode *pram_new_inode(struct  in
 
 	unlock_super(sb);
 
-	return  inode;
+	return inode;
 fail2:
 	unlock_super(sb);
-	inode->i_nlink = 0;
+	clear_nlink(inode);
 	unlock_new_inode(inode);
 	iput(inode);
-	return  ERR_PTR(errval);
+	return ERR_PTR(errval);
 fail1:
 	unlock_super(sb);
 	make_bad_inode(inode);
 	iput(inode);
-	return  ERR_PTR(errval);
+	return ERR_PTR(errval);
 }
 
-int  pram_write_inode(struct  inode *inode,struct  writeback_control *wbc)
+int pram_write_inode(struct inode *inode, struct writeback_control *wbc)
 {
-	return  pram_update_inode(inode);
+	return pram_update_inode(inode);
 }
 
 /*
  * dirty_inode() is called from __mark_inode_dirty()
  */
-void  pram_dirty_inode(struct  inode *inode,int  flags)
+void pram_dirty_inode(struct inode *inode, int flags)
 {
 	pram_update_inode(inode);
 }
 
-static  int  pram_readpage(struct  file *file,struct  page *page)
+static int pram_readpage(struct file *file, struct page *page)
 {
-	struct  inode *inode = page->mapping->host;
-	struct  super_block *sb = inode->i_sb;
+	struct inode *inode = page->mapping->host;
+	struct super_block *sb = inode->i_sb;
 	loff_t offset, size;
-	unsigned  long  fillsize, blocknr, bytes_filled;
+	unsigned long fillsize, blocknr, bytes_filled;
 	u64 block;
-	void  *buf, *bp;
-	int  ret;
+	void *buf, *bp;
+	int ret;
 
 	buf = kmap(page);
-	if  (!buf)
-		return  -ENOMEM;
+	if (!buf)
+		return -ENOMEM;
 
 	offset = page_offset(page);
 	size = i_size_read(inode);
@@ -614,23 +716,23 @@ static  int  pram_readpage(struct  file
 	fillsize = 0;
 	bytes_filled = 0;
 	ret = 0;
-	if  (offset < size) {
+	if (offset < size) {
 		size -= offset;
 		fillsize = size > PAGE_SIZE ? PAGE_SIZE : size;
-		while  (fillsize) {
-			int  count = fillsize > sb->s_blocksize ?
+		while (fillsize) {
+			int count = fillsize > sb->s_blocksize ?
 						sb->s_blocksize : fillsize;
 			block = pram_find_data_block(inode, blocknr);
-			if  (likely(block)) {
+			if (likely(block)) {
 				bp = pram_get_block(sb, block);
-				if  (!bp) {
+				if (!bp) {
 					SetPageError(page);
 					bytes_filled = 0;
 					ret = -EIO;
-					goto  out;
+					goto out;
 				}
 				memcpy(buf + bytes_filled, bp, count);
-			}else  {
+			} else {
 				memset(buf + bytes_filled, 0, count);
 			}
 			bytes_filled += count;
@@ -639,33 +741,33 @@ static  int  pram_readpage(struct  file
 		}
 	}
  out:
-	if  (bytes_filled < PAGE_SIZE)
+	if (bytes_filled < PAGE_SIZE)
 		memset(buf + bytes_filled, 0, PAGE_SIZE - bytes_filled);
-	if  (ret == 0)
+	if (ret == 0)
 		SetPageUptodate(page);
 
 	flush_dcache_page(page);
 	kunmap(page);
 	unlock_page(page);
-	return  ret;
+	return ret;
 }
 
 /*
- * Called to zeros out a single block. It's used in the"resize"
- * to avoid to keep data incase  the file grow up again.
+ * Called to zeros out a single block. It's used in the "resize"
+ * to avoid to keep data in case the file grow up again.
  */
-static  int  pram_block_truncate_page(struct  inode *inode, loff_t newsize)
+static int pram_block_truncate_page(struct inode *inode, loff_t newsize)
 {
-	struct  super_block *sb = inode->i_sb;
-	unsigned  long  offset = newsize & (sb->s_blocksize - 1);
-	unsigned  long  blocknr, length;
+	struct super_block *sb = inode->i_sb;
+	unsigned long offset = newsize & (sb->s_blocksize - 1);
+	unsigned long blocknr, length;
 	u64 blockoff;
-	char  *bp;
-	int  ret = 0;
+	char *bp;
+	int ret = 0;
 
 	/* Block boundary or extending ? */
-	if  (!offset || newsize > inode->i_size)
-		goto  out;
+	if (!offset || newsize > inode->i_size)
+		goto out;
 
 	length = sb->s_blocksize - offset;
 	blocknr = newsize >> sb->s_blocksize_bits;
@@ -673,131 +775,131 @@ static  int  pram_block_truncate_page(st
 	blockoff = pram_find_data_block(inode, blocknr);
 
 	/* Hole ? */
-	if  (!blockoff)
-		goto  out;
+	if (!blockoff)
+		goto out;
 
 	bp = pram_get_block(inode->i_sb, blockoff);
-	if  (!bp) {
+	if (!bp) {
 		ret = -EACCES;
-		goto  out;
+		goto out;
 	}
 	pram_memunlock_block(sb, bp);
 	memset(bp + offset, 0, length);
 	pram_memlock_block(sb, bp);
 out:
-	return  ret;
+	return ret;
 }
 
-static  int  pram_setsize(struct  inode *inode, loff_t newsize)
+static int pram_setsize(struct inode *inode, loff_t newsize)
 {
-	int  ret = 0;
+	int ret = 0;
 	loff_t oldsize = inode->i_size;
 
-	if  (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
+	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
 	    S_ISLNK(inode->i_mode)))
-		return  -EINVAL;
-	if  (IS_APPEND(inode) || IS_IMMUTABLE(inode))
-		return  -EPERM;
+		return -EINVAL;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return -EPERM;
 
-	if  (newsize != oldsize) {
-		if  (mapping_is_xip(inode->i_mapping))
+	if (newsize != oldsize) {
+		if (mapping_is_xip(inode->i_mapping))
 			ret = xip_truncate_page(inode->i_mapping, newsize);
 		else
 			ret = pram_block_truncate_page(inode, newsize);
 
-		if  (ret)
-			return  ret;
+		if (ret)
+			return ret;
 		i_size_write(inode, newsize);
 	}
 	/*
-	 * Waitfor  any concurrent readers to finish before to truncate the
-	 * blocks. Anynew  reader will see thenew  i_size so no problem.
-	 * In addition we have to wait, in xipcase, the call of xip_file_fault.
+	 * Wait for any concurrent readers to finish before to truncate the
+	 * blocks. Any new reader will see the new i_size so no problem.
+	 * In addition we have to wait, in xip case, the call of xip_file_fault.
 	 */
 	synchronize_rcu();
 	truncate_pagecache(inode, oldsize, newsize);
 	__pram_truncate_blocks(inode, newsize, oldsize);
-	/* Checkfor  the flag EOFBLOCKS is still valid after the set size */
+	/* Check for the flag EOFBLOCKS is still valid after the set size */
 	check_eof_blocks(inode, newsize);
 	inode->i_mtime = inode->i_ctime = CURRENT_TIME_SEC;
 	pram_update_inode(inode);
 
-	return  ret;
+	return ret;
 }
 
-int  pram_notify_change(struct  dentry *dentry,struct  iattr *attr)
+int pram_notify_change(struct dentry *dentry, struct iattr *attr)
 {
-	struct  inode *inode = dentry->d_inode;
-	struct  pram_inode *pi = pram_get_inode(inode->i_sb, inode->i_ino);
-	int  error;
+	struct inode *inode = dentry->d_inode;
+	struct pram_inode *pi = pram_get_inode(inode->i_sb, inode->i_ino);
+	int error;
 
-	if  (!pi)
-		return  -EACCES;
+	if (!pi)
+		return -EACCES;
 
 	error = inode_change_ok(inode, attr);
-	if  (error)
-		return  error;
+	if (error)
+		return error;
 
-	if  (attr->ia_valid & ATTR_SIZE &&
+	if (attr->ia_valid & ATTR_SIZE &&
 	    (attr->ia_size != inode->i_size ||
 	    pi->i_flags & cpu_to_be32(PRAM_EOFBLOCKS_FL))) {
 		error = pram_setsize(inode, attr->ia_size);
-		if  (error)
-			return  error;
+		if (error)
+			return error;
 	}
 	setattr_copy(inode, attr);
-	if  (attr->ia_valid & ATTR_MODE)
+	if (attr->ia_valid & ATTR_MODE)
 		error = pram_acl_chmod(inode);
 	error = pram_update_inode(inode);
 
-	return  error;
+	return error;
 }
 
-void  pram_set_inode_flags(struct  inode *inode,struct  pram_inode *pi)
+void pram_set_inode_flags(struct inode *inode, struct pram_inode *pi)
 {
-	unsigned  int  flags = be32_to_cpu(pi->i_flags);
+	unsigned int flags = be32_to_cpu(pi->i_flags);
 
 	inode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);
-	if  (flags & FS_SYNC_FL)
+	if (flags & FS_SYNC_FL)
 		inode->i_flags |= S_SYNC;
-	if  (flags & FS_APPEND_FL)
+	if (flags & FS_APPEND_FL)
 		inode->i_flags |= S_APPEND;
-	if  (flags & FS_IMMUTABLE_FL)
+	if (flags & FS_IMMUTABLE_FL)
 		inode->i_flags |= S_IMMUTABLE;
-	if  (flags & FS_NOATIME_FL)
+	if (flags & FS_NOATIME_FL)
 		inode->i_flags |= S_NOATIME;
-	if  (flags & FS_DIRSYNC_FL)
+	if (flags & FS_DIRSYNC_FL)
 		inode->i_flags |= S_DIRSYNC;
-	if  (!pi->i_xattr)
+	if (!pi->i_xattr)
 		inode_has_no_xattr(inode);
 }
 
-void  pram_get_inode_flags(struct  inode *inode,struct  pram_inode *pi)
+void pram_get_inode_flags(struct inode *inode, struct pram_inode *pi)
 {
-	unsigned  int  flags = inode->i_flags;
-	unsigned  int  pram_flags = be32_to_cpu(pi->i_flags);
+	unsigned int flags = inode->i_flags;
+	unsigned int pram_flags = be32_to_cpu(pi->i_flags);
 
 	pram_flags &= ~(FS_SYNC_FL|FS_APPEND_FL|FS_IMMUTABLE_FL|
 			FS_NOATIME_FL|FS_DIRSYNC_FL);
-	if  (flags & S_SYNC)
+	if (flags & S_SYNC)
 		pram_flags |= FS_SYNC_FL;
-	if  (flags & S_APPEND)
+	if (flags & S_APPEND)
 		pram_flags |= FS_APPEND_FL;
-	if  (flags & S_IMMUTABLE)
+	if (flags & S_IMMUTABLE)
 		pram_flags |= FS_IMMUTABLE_FL;
-	if  (flags & S_NOATIME)
+	if (flags & S_NOATIME)
 		pram_flags |= FS_NOATIME_FL;
-	if  (flags & S_DIRSYNC)
+	if (flags & S_DIRSYNC)
 		pram_flags |= FS_DIRSYNC_FL;
 
 	pi->i_flags = cpu_to_be32(pram_flags);
 }
 
-const  struct  address_space_operations pram_aops = {
+const struct address_space_operations pram_aops = {
 	.readpage	= pram_readpage,
 	.direct_IO	= pram_direct_IO,
 };
 
-const  struct  address_space_operations pram_aops_xip = {
+const struct address_space_operations pram_aops_xip = {
 	.get_xip_mem	= pram_get_xip_mem,
 };
--- a/fs/pramfs/ioctl.c
+++ b/fs/pramfs/ioctl.c
@@ -35,7 +35,7 @@ long pram_ioctl(struct file *filp, unsig
 	case FS_IOC_SETFLAGS: {
 		unsigned int oldflags;
 
-		ret = mnt_want_write(filp->f_path.mnt);
+		ret = mnt_want_write_file(filp);
 		if (ret)
 			return ret;
 
@@ -73,25 +73,31 @@ long pram_ioctl(struct file *filp, unsig
 		pram_memlock_inode(inode->i_sb, pi);
 		mutex_unlock(&inode->i_mutex);
 flags_out:
-		mnt_drop_write(filp->f_path.mnt);
+		mnt_drop_write_file(filp);
 		return ret;
 	}
 	case FS_IOC_GETVERSION:
 		return put_user(inode->i_generation, (int __user *) arg);
-	case FS_IOC_SETVERSION:
+	case FS_IOC_SETVERSION: {
+		__u32 generation;
 		if (!inode_owner_or_capable(inode))
 			return -EPERM;
-		ret = mnt_want_write(filp->f_path.mnt);
+		ret = mnt_want_write_file(filp);
 		if (ret)
 			return ret;
-		if (get_user(inode->i_generation, (int __user *) arg)) {
+		if (get_user(generation, (int __user *) arg)) {
 			ret = -EFAULT;
-		} else {
-			inode->i_ctime = CURRENT_TIME_SEC;
-			pram_update_inode(inode);
+			goto setversion_out;
 		}
-		mnt_drop_write(filp->f_path.mnt);
+		mutex_lock(&inode->i_mutex);
+		inode->i_ctime = CURRENT_TIME_SEC;
+		inode->i_generation = generation;
+		pram_update_inode(inode);
+		mutex_unlock(&inode->i_mutex);
+setversion_out:
+		mnt_drop_write_file(filp);
 		return ret;
+	}
 	default:
 		return -ENOTTY;
 	}
--- a/fs/pramfs/namei.c
+++ b/fs/pramfs/namei.c
@@ -24,14 +24,14 @@
 
 static inline void pram_inc_count(struct inode *inode)
 {
-	inode->i_nlink++;
+	inc_nlink(inode);
 	pram_write_inode(inode, NULL);
 }
 
 static inline void pram_dec_count(struct inode *inode)
 {
 	if (inode->i_nlink) {
-		inode->i_nlink--;
+		drop_nlink(inode);
 		pram_write_inode(inode, NULL);
 	}
 }
@@ -115,7 +115,7 @@ static struct dentry *pram_lookup(struct
  * If the create succeeds, we fill in the inode information
  * with d_instantiate().
  */
-static int pram_create(struct inode *dir, struct dentry *dentry, int mode,
+static int pram_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 		       struct nameidata *nd)
 {
 	struct inode *inode = pram_new_inode(dir, mode, &dentry->d_name);
@@ -134,7 +134,7 @@ static int pram_create(struct inode *dir
 	return err;
 }
 
-static int pram_mknod(struct inode *dir, struct dentry *dentry, int mode,
+static int pram_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
 		      dev_t rdev)
 {
 	struct inode *inode = pram_new_inode(dir, mode, &dentry->d_name);
@@ -200,14 +200,11 @@ static int pram_unlink(struct inode *dir
 	return 0;
 }
 
-static int pram_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+static int pram_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	struct inode *inode;
 	struct pram_inode *pi;
-	int err = -EMLINK;
-
-	if (dir->i_nlink >= PRAM_LINK_MAX)
-		goto out;
+	int err = 0;
 
 	pram_inc_count(dir);
 
@@ -262,7 +259,7 @@ static int pram_rmdir(struct inode *dir,
 	if (pi->i_type.dir.tail == 0) {
 		inode->i_ctime = dir->i_ctime;
 		inode->i_size = 0;
-		inode->i_nlink = 0;
+		clear_nlink(inode);
 		pram_write_inode(inode, NULL);
 		pram_dec_count(dir);
 		err = 0;
@@ -297,9 +294,6 @@ static int pram_rename(struct inode  *ol
 		pram_dec_count(new_inode);
 	} else {
 		if (S_ISDIR(old_inode->i_mode)) {
-			err = -EMLINK;
-			if (new_dir->i_nlink >= PRAM_LINK_MAX)
-				goto out;
 			pram_dec_count(old_dir);
 			pram_inc_count(new_dir);
 		}
@@ -361,7 +355,7 @@ const struct inode_operations pram_dir_i
 	.removexattr	= generic_removexattr,
 #endif
 	.setattr	= pram_notify_change,
-	.check_acl	= pram_check_acl,
+	.get_acl	= pram_get_acl,
 };
 
 const struct inode_operations pram_special_inode_operations = {
@@ -372,5 +366,5 @@ const struct inode_operations pram_speci
 	.removexattr	= generic_removexattr,
 #endif
 	.setattr	= pram_notify_change,
-	.check_acl	= pram_check_acl,
+	.get_acl	= pram_get_acl,
 };
--- a/fs/pramfs/pram.h
+++ b/fs/pramfs/pram.h
@@ -52,9 +52,8 @@
 #define PRAM_EOFBLOCKS_FL	0x20000000
 /* Flags that should be inherited by new inodes from their parent. */
 #define PRAM_FL_INHERITED (FS_SECRM_FL | FS_UNRM_FL | FS_COMPR_FL |\
-			   FS_SYNC_FL | FS_IMMUTABLE_FL | FS_APPEND_FL |\
-			   FS_NODUMP_FL | FS_NOATIME_FL | FS_COMPRBLK_FL |\
-			   FS_NOCOMP_FL | FS_JOURNAL_DATA_FL |\
+			   FS_SYNC_FL | FS_NODUMP_FL | FS_NOATIME_FL | \
+			   FS_COMPRBLK_FL | FS_NOCOMP_FL | FS_JOURNAL_DATA_FL |\
 			   FS_NOTAIL_FL | FS_DIRSYNC_FL)
 /* Flags that are appropriate for regular files (all but dir-specific ones). */
 #define PRAM_REG_FLMASK (~(FS_DIRSYNC_FL | FS_TOPDIR_FL))
@@ -94,7 +93,7 @@ extern u64 pram_find_data_block(struct i
 extern struct inode *pram_iget(struct super_block *sb, unsigned long ino);
 extern void pram_put_inode(struct inode *inode);
 extern void pram_evict_inode(struct inode *inode);
-extern struct inode *pram_new_inode(struct inode *dir, int mode,
+extern struct inode *pram_new_inode(struct inode *dir, umode_t mode,
 					const struct qstr *qstr);
 extern int pram_update_inode(struct inode *inode);
 extern int pram_write_inode(struct inode *inode, struct writeback_control *wbc);
@@ -102,6 +101,7 @@ extern void pram_dirty_inode(struct inod
 extern int pram_notify_change(struct dentry *dentry, struct iattr *attr);
 extern void pram_set_inode_flags(struct inode *inode, struct pram_inode *pi);
 extern void pram_get_inode_flags(struct inode *inode, struct pram_inode *pi);
+extern int pram_find_region(struct inode *inode, loff_t *offset, int hole);
 
 /* ioctl.c */
 extern long pram_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
--- a/fs/pramfs/super.c
+++ b/fs/pramfs/super.c
@@ -454,7 +454,9 @@ static struct pram_inode *pram_init(stru
 
 static inline void set_default_opts(struct pram_sb_info *sbi)
 {
+#ifdef CONFIG_PRAMFS_WRITE_PROTECT
 	set_opt(sbi->s_mount_opt, PROTECT);
+#endif
 	set_opt(sbi->s_mount_opt, ERRORS_CONT);
 }
 
@@ -471,7 +473,7 @@ static void pram_root_check(struct super
 		pram_warn("root is not a directory, trying to fix\n");
 		goto fail2;
 	}
-
+
 	if (pram_calc_checksum((u8 *)root_pi, PRAM_INODE_SIZE)) {
 		pram_warn("checksum error in root inode, trying to fix\n");
 		goto fail3;
@@ -633,6 +635,7 @@ static int pram_fill_super(struct super_
 	sb->s_magic = be16_to_cpu(super->s_magic);
 	sb->s_op = &pram_sops;
 	sb->s_maxbytes = pram_max_size(sb->s_blocksize_bits);
+	sb->s_max_links = PRAM_LINK_MAX;
 	sb->s_time_gran = 1;
 	sb->s_export_op = &pram_export_ops;
 	sb->s_xattr = pram_xattr_handlers;
@@ -647,10 +650,9 @@ static int pram_fill_super(struct super_
 		retval = PTR_ERR(root_i);
 		goto out;
 	}
-
-	sb->s_root = d_alloc_root(root_i);
+
+	sb->s_root = d_make_root(root_i);
 	if (!sb->s_root) {
-		iput(root_i);
 		printk(KERN_ERR "get pramfs root inode failed\n");
 		retval = -ENOMEM;
 		goto out;
@@ -685,9 +687,9 @@ int pram_statfs(struct dentry *d, struct
 	return 0;
 }
 
-static int pram_show_options(struct seq_file *seq, struct vfsmount *vfs)
+static int pram_show_options(struct seq_file *seq, struct dentry *root)
 {
-	struct pram_sb_info *sbi = PRAM_SB(vfs->mnt_sb);
+	struct pram_sb_info *sbi = PRAM_SB(root->d_sb);
 
 	seq_printf(seq, ",physaddr=0x%016llx", (u64)sbi->phys_addr);
 	if (sbi->initsize)
@@ -704,13 +706,13 @@ static int pram_show_options(struct seq_
 		seq_printf(seq, ",uid=%u", sbi->uid);
 	if (sbi->gid != 0)
 		seq_printf(seq, ",gid=%u", sbi->gid);
-	if (test_opt(vfs->mnt_sb, ERRORS_RO))
+	if (test_opt(root->d_sb, ERRORS_RO))
 		seq_puts(seq, ",errors=remount-ro");
-	if (test_opt(vfs->mnt_sb, ERRORS_PANIC))
+	if (test_opt(root->d_sb, ERRORS_PANIC))
 		seq_puts(seq, ",errors=panic");
 #ifdef CONFIG_PRAMFS_WRITE_PROTECT
 	/* memory protection enabled by default */
-	if (!test_opt(vfs->mnt_sb, PROTECT))
+	if (!test_opt(root->d_sb, PROTECT))
 		seq_puts(seq, ",noprotect");
 #else
 	/*
@@ -722,19 +724,19 @@ static int pram_show_options(struct seq_
 
 #ifdef CONFIG_PRAMFS_XATTR
 	/* user xattr not enabled by default */
-	if (test_opt(vfs->mnt_sb, XATTR_USER))
+	if (test_opt(root->d_sb, XATTR_USER))
 		seq_puts(seq, ",user_xattr");
 #endif
 
 #ifdef CONFIG_PRAMFS_POSIX_ACL
 	/* acl not enabled by default */
-	if (test_opt(vfs->mnt_sb, POSIX_ACL))
+	if (test_opt(root->d_sb, POSIX_ACL))
 		seq_puts(seq, ",acl");
 #endif
 
 #ifdef CONFIG_PRAMFS_XIP
 	/* xip not enabled by default */
-	if (test_opt(vfs->mnt_sb, XIP))
+	if (test_opt(root->d_sb, XIP))
 		seq_puts(seq, ",xip");
 #endif
 
@@ -817,7 +819,6 @@ static struct inode *pram_alloc_inode(st
 static void pram_i_callback(struct rcu_head *head)
 {
 	struct inode *inode = container_of(head, struct inode, i_rcu);
-	INIT_LIST_HEAD(&inode->i_dentry);
 	kmem_cache_free(pram_inode_cachep, PRAM_I(inode));
 }
 
--- a/fs/pramfs/xattr_security.c
+++ b/fs/pramfs/xattr_security.c
@@ -50,27 +50,28 @@ static int pram_xattr_security_set(struc
 			      value, size, flags);
 }
 
-int pram_init_security(struct inode *inode, struct inode *dir,
-			const struct qstr *qstr)
+int pram_initxattrs(struct inode *inode, const struct xattr *xattr_array,
+		    void *fs_info)
 {
-	int err;
-	size_t len;
-	void *value;
-	char *name;
-
-	err = security_inode_init_security(inode, dir, qstr, &name, &value, &len);
-	if (err) {
-		if (err == -EOPNOTSUPP)
-			return 0;
-		return err;
+	const struct xattr *xattr;
+	int err = 0;
+	for (xattr = xattr_array; xattr->name != NULL; xattr++) {
+		err = pram_xattr_set(inode, PRAM_XATTR_INDEX_SECURITY,
+				     xattr->name, xattr->value,
+				     xattr->value_len, 0);
+		if (err < 0)
+			break;
 	}
-	err = pram_xattr_set(inode, PRAM_XATTR_INDEX_SECURITY,
-			     name, value, len, 0);
-	kfree(name);
-	kfree(value);
 	return err;
 }
 
+int pram_init_security(struct inode *inode, struct inode *dir,
+		       const struct qstr *qstr)
+{
+	return security_inode_init_security(inode, dir, qstr,
+					    &pram_initxattrs, NULL);
+}
+
 const struct xattr_handler pram_xattr_security_handler = {
 	.prefix	= XATTR_SECURITY_PREFIX,
 	.list	= pram_xattr_security_list,
--- a/include/linux/pram_fs_sb.h
+++ b/include/linux/pram_fs_sb.h
@@ -34,7 +34,7 @@ struct pram_sb_info {
 	unsigned long s_mount_opt;
 	uid_t uid;		    /* Mount uid for root directory */
 	gid_t gid;		    /* Mount gid for root directory */
-	mode_t mode;		    /* Mount mode for root directory */
+	umode_t mode;		    /* Mount mode for root directory */
 	atomic_t next_generation;
 #ifdef CONFIG_PRAMFS_XATTR
 	struct rb_root desc_tree;
