From 53e09e8e36a22c3d0b7b0001f6c57ee9e750ee29 Mon Sep 17 00:00:00 2001
From: Josh Wu <josh.wu@atmel.com>
Date: Mon, 1 Nov 2010 16:38:41 +0800
Subject: video/atmel_lcdfb: add support for AT91SAM9x5
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Josh Wu <josh.wu@atmel.com>
Signed-off-by: Dan Liang <dan.liang@atmel.com>
Signed-off-by: Nicolas Ferre <nicolas.ferre@atmel.com>
[ukleinek: forward-port to 2.6.39-rcish]
Signed-off-by: Uwe Kleine-KÃ¶nig <u.kleine-koenig@pengutronix.de>

Conflicts:

	drivers/video/atmel_lcdfb.c
---
 arch/arm/mach-at91/include/mach/atmel_hlcdfb.h |  865 +++++++++++++++++++++++++
 drivers/video/atmel_lcdfb.c                    |  670 ++++++++++++++-----
 include/video/atmel_lcdc.h                     |   15 
 3 files changed, 1390 insertions(+), 160 deletions(-)
 create mode 100644 arch/arm/mach-at91/include/mach/atmel_hlcdfb.h

--- /dev/null
+++ b/arch/arm/mach-at91/include/mach/atmel_hlcdfb.h
@@ -0,0 +1,865 @@
+/*
+ *  Header file for AT91 High end LCD Controller
+ *
+ *  Data structure and register user interface
+ *
+ *  Copyright (C) 2010 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PUROFFSETE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ATMEL_HLCD_H__
+#define __ATMEL_HLCD_H__
+
+/* Lcdc hardware registers */
+#define ATMEL_LCDC_LCDCFG0	0x0000
+#define LCDC_LCDCFG0_CLKPOL		(0x1 << 0)
+#define LCDC_LCDCFG0_CLKSEL		(0x1 << 2)
+#define LCDC_LCDCFG0_CLKPWMSEL		(0x1 << 3)
+#define LCDC_LCDCFG0_CGDISBASE		(0x1 << 8)
+#define LCDC_LCDCFG0_CGDISOVR1		(0x1 << 9)
+#define LCDC_LCDCFG0_CGDISHEO		(0x1 << 11)
+#define LCDC_LCDCFG0_CGDISHCR		(0x1 << 12)
+#define LCDC_LCDCFG0_CLKDIV_OFFSET	16
+#define LCDC_LCDCFG0_CLKDIV		(0xff << LCDC_LCDCFG0_CLKDIV_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG1	0x0004
+#define LCDC_LCDCFG1_HSPW_OFFSET	0
+#define LCDC_LCDCFG1_HSPW		(0x3f << LCDC_LCDCFG1_HSPW_OFFSET)
+#define LCDC_LCDCFG1_VSPW_OFFSET	16
+#define LCDC_LCDCFG1_VSPW		(0x3f << LCDC_LCDCFG1_VSPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG2	0x0008
+#define LCDC_LCDCFG2_VFPW_OFFSET	0
+#define LCDC_LCDCFG2_VFPW		(0x3f << LCDC_LCDCFG2_VFPW_OFFSET)
+#define LCDC_LCDCFG2_VBPW_OFFSET	16
+#define LCDC_LCDCFG2_VBPW		(0x3f << LCDC_LCDCFG2_VBPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG3	0x000C
+#define LCDC_LCDCFG3_HFPW_OFFSET	0
+#define LCDC_LCDCFG3_HFPW		(0xff << LCDC_LCDCFG3_HFPW_OFFSET)
+#define LCDC_LCDCFG3_HBPW_OFFSET	16
+#define LCDC_LCDCFG3_HBPW		(0xff << LCDC_LCDCFG3_HBPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG4	0x0010
+#define LCDC_LCDCFG4_PPL_OFFSET		0
+#define LCDC_LCDCFG4_PPL		(0x7ff << LCDC_LCDCFG4_PPL_OFFSET)
+#define LCDC_LCDCFG4_RPF_OFFSET		16
+#define LCDC_LCDCFG4_RPF		(0x7ff << LCDC_LCDCFG4_RPF_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG5	0x0014
+#define LCDC_LCDCFG5_HSPOL		(0x1 << 0)
+#define LCDC_LCDCFG5_VSPOL		(0x1 << 1)
+#define LCDC_LCDCFG5_VSPDLYS		(0x1 << 2)
+#define LCDC_LCDCFG5_VSPDLYE		(0x1 << 3)
+#define LCDC_LCDCFG5_DISPPOL		(0x1 << 4)
+#define LCDC_LCDCFG5_SERIAL		(0x1 << 5)
+#define LCDC_LCDCFG5_DITHER		(0x1 << 6)
+#define LCDC_LCDCFG5_DISPDLY		(0x1 << 7)
+#define LCDC_LCDCFG5_MODE_OFFSET	8
+#define LCDC_LCDCFG5_MODE		(0x3 << LCDC_LCDCFG5_MODE_OFFSET)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_12BPP		(0x0 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_16BPP		(0x1 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_18BPP		(0x2 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_24BPP		(0x3 << 8)
+#define LCDC_LCDCFG5_VSPSU		(0x1 << 12)
+#define LCDC_LCDCFG5_VSPHO		(0x1 << 13)
+#define LCDC_LCDCFG5_GUARDTIME_OFFSET	16
+#define LCDC_LCDCFG5_GUARDTIME		(0x1f << LCDC_LCDCFG5_GUARDTIME_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG6	0x0018
+#define LCDC_LCDCFG6_PWMPS_OFFSET	0
+#define LCDC_LCDCFG6_PWMPS		(0x7 << LCDC_LCDCFG6_PWMPS_OFFSET)
+#define LCDC_LCDCFG6_PWMPOL		(0x1 << 4)
+#define LCDC_LCDCFG6_PWMCVAL_OFFSET	8
+#define LCDC_LCDCFG6_PWMCVAL		(0xff << LCDC_LCDCFG6_PWMCVAL_OFFSET)
+
+#define ATMEL_LCDC_LCDEN	0x0020
+#define LCDC_LCDEN_CLKEN		(0x1 << 0)
+#define LCDC_LCDEN_SYNCEN		(0x1 << 1)
+#define LCDC_LCDEN_DISPEN		(0x1 << 2)
+#define LCDC_LCDEN_PWMEN		(0x1 << 3)
+
+#define ATMEL_LCDC_LCDDIS	0x0024
+#define LCDC_LCDDIS_CLKDIS		(0x1 << 0)
+#define LCDC_LCDDIS_SYNCDIS		(0x1 << 1)
+#define LCDC_LCDDIS_DISPDIS		(0x1 << 2)
+#define LCDC_LCDDIS_PWMDIS		(0x1 << 3)
+#define LCDC_LCDDIS_CLKRST		(0x1 << 8)
+#define LCDC_LCDDIS_SYNCRST		(0x1 << 9)
+#define LCDC_LCDDIS_DISPRST		(0x1 << 10)
+#define LCDC_LCDDIS_PWMRST		(0x1 << 11)
+
+#define ATMEL_LCDC_LCDSR	0x0028
+#define LCDC_LCDSR_CLKSTS		(0x1 << 0)
+#define LCDC_LCDSR_LCDSTS		(0x1 << 1)
+#define LCDC_LCDSR_DISPSTS		(0x1 << 2)
+#define LCDC_LCDSR_PWMSTS		(0x1 << 3)
+#define LCDC_LCDSR_SIPSTS		(0x1 << 4)
+
+#define ATMEL_LCDC_LCDIER	0x002C
+#define LCDC_LCDIER_SOFIE		(0x1 << 0)
+#define LCDC_LCDIER_DISIE		(0x1 << 1)
+#define LCDC_LCDIER_DISPIE		(0x1 << 2)
+#define LCDC_LCDIER_FIFOERRIE		(0x1 << 4)
+#define LCDC_LCDIER_BASEIE		(0x1 << 8)
+#define LCDC_LCDIER_OVR1IE		(0x1 << 9)
+#define LCDC_LCDIER_HEOIE		(0x1 << 11)
+#define LCDC_LCDIER_HCRIE		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDIDR	0x0030
+#define LCDC_LCDIDR_SOFID		(0x1 << 0)
+#define LCDC_LCDIDR_DISID		(0x1 << 1)
+#define LCDC_LCDIDR_DISPID		(0x1 << 2)
+#define LCDC_LCDIDR_FIFOERRID		(0x1 << 4)
+#define LCDC_LCDIDR_BASEID		(0x1 << 8)
+#define LCDC_LCDIDR_OVR1ID		(0x1 << 9)
+#define LCDC_LCDIDR_HEOID		(0x1 << 11)
+#define LCDC_LCDIDR_HCRID		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDIMR	0x0034
+#define LCDC_LCDIMR_SOFIM		(0x1 << 0)
+#define LCDC_LCDIMR_DISIM		(0x1 << 1)
+#define LCDC_LCDIMR_DISPIM		(0x1 << 2)
+#define LCDC_LCDIMR_FIFOERRIM		(0x1 << 4)
+#define LCDC_LCDIMR_BASEIM		(0x1 << 8)
+#define LCDC_LCDIMR_OVR1IM		(0x1 << 9)
+#define LCDC_LCDIMR_HEOIM		(0x1 << 11)
+#define LCDC_LCDIMR_HCRIM		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDISR	0x0038
+#define LCDC_LCDISR_SOF			(0x1 << 0)
+#define LCDC_LCDISR_DIS			(0x1 << 1)
+#define LCDC_LCDISR_DISP		(0x1 << 2)
+#define LCDC_LCDISR_FIFOERR		(0x1 << 4)
+#define LCDC_LCDISR_BASE		(0x1 << 8)
+#define LCDC_LCDISR_OVR1		(0x1 << 9)
+#define LCDC_LCDISR_HEO			(0x1 << 11)
+#define LCDC_LCDISR_HCR			(0x1 << 12)
+
+#define ATMEL_LCDC_BASECHER	0x0040
+#define LCDC_BASECHER_CHEN		(0x1 << 0)
+#define LCDC_BASECHER_UPDATEEN		(0x1 << 1)
+#define LCDC_BASECHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_BASECHDR	0x0044
+#define LCDC_BASECHDR_CHDIS		(0x1 << 0)
+#define LCDC_BASECHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_BASECHSR	0x0048
+#define LCDC_BASECHSR_CHSR		(0x1 << 0)
+#define LCDC_BASECHSR_UPDATESR		(0x1 << 1)
+#define LCDC_BASECHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_BASEIER	0x004C
+#define LCDC_BASEIER_DMA		(0x1 << 2)
+#define LCDC_BASEIER_DSCR		(0x1 << 3)
+#define LCDC_BASEIER_ADD		(0x1 << 4)
+#define LCDC_BASEIER_DONE		(0x1 << 5)
+#define LCDC_BASEIER_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEIDR	0x0050
+#define LCDC_BASEIDR_DMA		(0x1 << 2)
+#define LCDC_BASEIDR_DSCR		(0x1 << 3)
+#define LCDC_BASEIDR_ADD		(0x1 << 4)
+#define LCDC_BASEIDR_DONE		(0x1 << 5)
+#define LCDC_BASEIDR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEIMR	0x0054
+#define LCDC_BASEIMR_DMA		(0x1 << 2)
+#define LCDC_BASEIMR_DSCR		(0x1 << 3)
+#define LCDC_BASEIMR_ADD		(0x1 << 4)
+#define LCDC_BASEIMR_DONE		(0x1 << 5)
+#define LCDC_BASEIMR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEISR	0x0058
+#define LCDC_BASEISR_DMA		(0x1 << 2)
+#define LCDC_BASEISR_DSCR		(0x1 << 3)
+#define LCDC_BASEISR_ADD		(0x1 << 4)
+#define LCDC_BASEISR_DONE		(0x1 << 5)
+#define LCDC_BASEISR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEHEAD	0x005C
+
+#define ATMEL_LCDC_BASEADDR	0x0060
+
+#define ATMEL_LCDC_BASECTRL	0x0064
+#define LCDC_BASECTRL_DFETCH		(0x1 << 0)
+#define LCDC_BASECTRL_LFETCH		(0x1 << 1)
+#define LCDC_BASECTRL_DMAIEN		(0x1 << 2)
+#define LCDC_BASECTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_BASECTRL_ADDIEN		(0x1 << 4)
+#define LCDC_BASECTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_BASENEXT	0x0068
+
+#define ATMEL_LCDC_BASECFG0	0x006C
+#define LCDC_BASECFG0_BLEN_OFFSET 4
+#define LCDC_BASECFG0_BLEN		(0x3 << LCDC_BASECFG0_BLEN_OFFSET)
+#define		LCDC_BASECFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_BASECFG0_DLBO		(0x1 << 8)
+
+#define ATMEL_LCDC_BASECFG1	0x0070
+#define LCDC_BASECFG1_CLUTEN		(0x1 << 0)
+#define LCDC_BASECFG1_RGBMODE_OFFSET	4
+#define LCDC_BASECFG1_RGBMODE		(0xf << LCDC_BASECFG1_RGBMODE_OFFSET)
+#define		LCDC_BASECFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_BASECFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_BASECFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_BASECFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_BASECFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_BASECFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_BASECFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_BASECFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_BASECFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_BASECFG1_CLUTMODE_OFFSET	8
+#define LCDC_BASECFG1_CLUTMODE		(0x3 << LCDC_BASECFG1_CLUTMODE_OFFSET)
+#define		LCDC_BASECFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_BASECFG2	0x0074
+
+#define ATMEL_LCDC_BASECFG3	0x0078
+#define LCDC_BASECFG3_BDEF_OFFSET	0
+#define LCDC_BASECFG3_BDEF		(0xff << LCDC_BASECFG3_BDEF_OFFSET)
+#define LCDC_BASECFG3_GDEF_OFFSET	8
+#define LCDC_BASECFG3_GDEF		(0xff << LCDC_BASECFG3_GDEF_OFFSET)
+#define LCDC_BASECFG3_RDEF_OFFSET	16
+#define LCDC_BASECFG3_RDEF		(0xff << LCDC_BASECFG3_RDEF_OFFSET)
+
+#define ATMEL_LCDC_BASECFG4	0x007C
+#define LCDC_BASECFG4_DMA		(0x1 << 8)
+#define LCDC_BASECFG4_REP		(0x1 << 9)
+
+#define ATMEL_LCDC_OVRCHER1	0x0100
+#define LCDC_OVRCHER1_CHEN		(0x1 << 0)
+#define LCDC_OVRCHER1_UPDATEEN		(0x1 << 1)
+#define LCDC_OVRCHER1_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_OVRCHDR1	0x0104
+#define LCDC_OVRCHDR1_CHDIS		(0x1 << 0)
+#define LCDC_OVRCHDR1_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_OVRCHSR1	0x0108
+#define LCDC_OVRCHSR1_CHSR		(0x1 << 0)
+#define LCDC_OVRCHSR1_UPDATESR		(0x1 << 1)
+#define LCDC_OVRCHSR1_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_OVRIER1	0x010C
+#define LCDC_OVRIER1_DMA		(0x1 << 2)
+#define LCDC_OVRIER1_DSCR		(0x1 << 3)
+#define LCDC_OVRIER1_ADD		(0x1 << 4)
+#define LCDC_OVRIER1_DONE		(0x1 << 5)
+#define LCDC_OVRIER1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRIDR1	0x0110
+#define LCDC_OVRIDR1_DMA		(0x1 << 2)
+#define LCDC_OVRIDR1_DSCR		(0x1 << 3)
+#define LCDC_OVRIDR1_ADD		(0x1 << 4)
+#define LCDC_OVRIDR1_DONE		(0x1 << 5)
+#define LCDC_OVRIDR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRIMR1	0x0114
+#define LCDC_OVRIMR1_DMA		(0x1 << 2)
+#define LCDC_OVRIMR1_DSCR		(0x1 << 3)
+#define LCDC_OVRIMR1_ADD		(0x1 << 4)
+#define LCDC_OVRIMR1_DONE		(0x1 << 5)
+#define LCDC_OVRIMR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRISR1	0x0118
+#define LCDC_OVRISR1_DMA		(0x1 << 2)
+#define LCDC_OVRISR1_DSCR		(0x1 << 3)
+#define LCDC_OVRISR1_ADD		(0x1 << 4)
+#define LCDC_OVRISR1_DONE		(0x1 << 5)
+#define LCDC_OVRISR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRHEAD1	0x011C
+
+#define ATMEL_LCDC_OVRADDR1	0x0120
+
+#define ATMEL_LCDC_OVRCTRL1	0x0124
+#define LCDC_OVRCTRL1_DFETCH		(0x1 << 0)
+#define LCDC_OVRCTRL1_LFETCH		(0x1 << 1)
+#define LCDC_OVRCTRL1_DMAIEN		(0x1 << 2)
+#define LCDC_OVRCTRL1_DSCRIEN		(0x1 << 3)
+#define LCDC_OVRCTRL1_ADDIEN		(0x1 << 4)
+#define LCDC_OVRCTRL1_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_OVRNEXT1	0x0128
+
+#define ATMEL_LCDC_OVR1CFG0	0x012C
+#define LCDC_OVR1CFG0_BLEN_OFFSET	4
+#define LCDC_OVR1CFG0_BLEN		(0x3 << LCDC_OVR1CFG0_BLEN_OFFSET)
+#define		LCDC_OVR1CFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_OVR1CFG0_DLBO		(0x1 << 8)
+#define LCDC_OVR1CFG0_ROTDIS		(0x1 << 12)
+#define LCDC_OVR1CFG0_LOCKDIS		(0x1 << 13)
+
+#define ATMEL_LCDC_OVR1CFG1	0x0130
+#define LCDC_OVR1CFG1_CLUTEN		(0x1 << 0)
+#define LCDC_OVR1CFG1_RGBMODE_OFFSET	4
+#define LCDC_OVR1CFG1_RGBMODE		(0xf << LCDC_OVR1CFG1_RGBMODE_OFFSET)
+#define		LCDC_OVR1CFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_OVR1CFG1_CLUTMODE_OFFSET	8
+#define LCDC_OVR1CFG1_CLUTMODE		(0x3 << LCDC_OVR1CFG1_CLUTMODE_OFFSET)
+#define		LCDC_OVR1CFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_OVR1CFG2	0x0134
+#define LCDC_OVR1CFG2_XOFFSET_OFFSET	0
+#define LCDC_OVR1CFG2_XOFFSET		(0x7ff << LCDC_OVR1CFG2_XOFFSET_OFFSET)
+#define LCDC_OVR1CFG2_YOFFSET_OFFSET	16
+#define LCDC_OVR1CFG2_YOFFSET		(0x7ff << LCDC_OVR1CFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG3	0x0138
+#define LCDC_OVR1CFG3_XSIZE_OFFSET	0
+#define LCDC_OVR1CFG3_XSIZE		(0x7ff << LCDC_OVR1CFG3_XSIZE_OFFSET)
+#define LCDC_OVR1CFG3_YSIZE_OFFSET	16
+#define LCDC_OVR1CFG3_YSIZE		(0x7ff << LCDC_OVR1CFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG4	0x013C
+
+#define ATMEL_LCDC_OVR1CFG5	0x0140
+
+#define ATMEL_LCDC_OVR1CFG6	0x0144
+#define LCDC_OVR1CFG6_BDEF_OFFSET	0
+#define LCDC_OVR1CFG6_BDEF		(0xff << LCDC_OVR1CFG6_BDEF_OFFSET)
+#define LCDC_OVR1CFG6_GDEF_OFFSET	8
+#define LCDC_OVR1CFG6_GDEF		(0xff << LCDC_OVR1CFG6_GDEF_OFFSET)
+#define LCDC_OVR1CFG6_RDEF_OFFSET	16
+#define LCDC_OVR1CFG6_RDEF		(0xff << LCDC_OVR1CFG6_RDEF_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG7	0x0148
+#define LCDC_OVR1CFG7_BKEY_OFFSET	0
+#define LCDC_OVR1CFG7_BKEY		(0xff << LCDC_OVR1CFG7_BKEY_OFFSET)
+#define LCDC_OVR1CFG7_GKEY_OFFSET	8
+#define LCDC_OVR1CFG7_GKEY		(0xff << LCDC_OVR1CFG7_GKEY_OFFST)
+#define LCDC_OVR1CFG7_RKEY_OFFSET	16
+#define LCDC_OVR1CFG7_RKEY		(0xff << LCDC_OVR1CFG7_RKEY_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG8	0x014C
+#define LCDC_OVR1CFG8_BMASK_OFFSET	0
+#define LCDC_OVR1CFG8_BMASK		(0xff << LCDC_OVR1CFG8_BMASK_OFFSET)
+#define LCDC_OVR1CFG8_GMASK_OFFSET	8
+#define LCDC_OVR1CFG8_GMASK		(0xff << LCDC_OVR1CFG8_GMASK_OFFSET)
+#define LCDC_OVR1CFG8_RMASK_OFFSET	16
+#define LCDC_OVR1CFG8_RMASK		(0xff << LCDC_OVR1CFG8_RMASK_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG9	0x0150
+#define LCDC_OVR1CFG9_CRKEY		(0x1 << 0)
+#define LCDC_OVR1CFG9_INV		(0x1 << 1)
+#define LCDC_OVR1CFG9_ITER2BL		(0x1 << 2)
+#define LCDC_OVR1CFG9_ITER		(0x1 << 3)
+#define LCDC_OVR1CFG9_REVALPHA		(0x1 << 4)
+#define LCDC_OVR1CFG9_GAEN		(0x1 << 5)
+#define LCDC_OVR1CFG9_LAEN		(0x1 << 6)
+#define LCDC_OVR1CFG9_OVR		(0x1 << 7)
+#define LCDC_OVR1CFG9_DMA		(0x1 << 8)
+#define LCDC_OVR1CFG9_REP		(0x1 << 9)
+#define LCDC_OVR1CFG9_DSTKEY		(0x1 << 10)
+#define LCDC_OVR1CFG9_GA_OFFSET		16
+#define LCDC_OVR1CFG9_GA		(0xff << LCDC_OVR1CFG9_GA_OFFSET)
+
+#define ATMEL_LCDC_HEOCHER	0x0280
+#define LCDC_HEOCHER_CHEN		(0x1 << 0)
+#define LCDC_HEOCHER_UPDATEEN		(0x1 << 1)
+#define LCDC_HEOCHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_HEOCHDR	0x0284
+#define LCDC_HEOCHDR_CHDIS		(0x1 << 0)
+#define LCDC_HEOCHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_HEOCHSR	0x0288
+#define LCDC_HEOCHSR_CHSR		(0x1 << 0)
+#define LCDC_HEOCHSR_UPDATESR		(0x1 << 1)
+#define LCDC_HEOCHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_HEOIER	0x028C
+#define LCDC_HEOIER_DMA			(0x1 << 2)
+#define LCDC_HEOIER_DSCR		(0x1 << 3)
+#define LCDC_HEOIER_ADD			(0x1 << 4)
+#define LCDC_HEOIER_DONE		(0x1 << 5)
+#define LCDC_HEOIER_OVR			(0x1 << 6)
+#define LCDC_HEOIER_UDMA		(0x1 << 10)
+#define LCDC_HEOIER_UDSCR		(0x1 << 11)
+#define LCDC_HEOIER_UADD		(0x1 << 12)
+#define LCDC_HEOIER_UDONE		(0x1 << 13)
+#define LCDC_HEOIER_UOVR		(0x1 << 14)
+#define LCDC_HEOIER_VDMA		(0x1 << 18)
+#define LCDC_HEOIER_VDSCR		(0x1 << 19)
+#define LCDC_HEOIER_VADD		(0x1 << 20)
+#define LCDC_HEOIER_VDONE		(0x1 << 21)
+#define LCDC_HEOIER_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOIDR	0x0290
+#define LCDC_HEOIDR_DMA			(0x1 << 2)
+#define LCDC_HEOIDR_DSCR		(0x1 << 3)
+#define LCDC_HEOIDR_ADD			(0x1 << 4)
+#define LCDC_HEOIDR_DONE		(0x1 << 5)
+#define LCDC_HEOIDR_OVR			(0x1 << 6)
+#define LCDC_HEOIDR_UDMA		(0x1 << 10)
+#define LCDC_HEOIDR_UDSCR		(0x1 << 11)
+#define LCDC_HEOIDR_UADD		(0x1 << 12)
+#define LCDC_HEOIDR_UDONE		(0x1 << 13)
+#define LCDC_HEOIDR_UOVR		(0x1 << 14)
+#define LCDC_HEOIDR_VDMA		(0x1 << 18)
+#define LCDC_HEOIDR_VDSCR		(0x1 << 19)
+#define LCDC_HEOIDR_VADD		(0x1 << 20)
+#define LCDC_HEOIDR_VDONE		(0x1 << 21)
+#define LCDC_HEOIDR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOIMR	0x0294
+#define LCDC_HEOIMR_DMA			(0x1 << 2)
+#define LCDC_HEOIMR_DSCR		(0x1 << 3)
+#define LCDC_HEOIMR_ADD			(0x1 << 4)
+#define LCDC_HEOIMR_DONE		(0x1 << 5)
+#define LCDC_HEOIMR_OVR			(0x1 << 6)
+#define LCDC_HEOIMR_UDMA		(0x1 << 10)
+#define LCDC_HEOIMR_UDSCR		(0x1 << 11)
+#define LCDC_HEOIMR_UADD		(0x1 << 12)
+#define LCDC_HEOIMR_UDONE		(0x1 << 13)
+#define LCDC_HEOIMR_UOVR		(0x1 << 14)
+#define LCDC_HEOIMR_VDMA		(0x1 << 18)
+#define LCDC_HEOIMR_VDSCR		(0x1 << 19)
+#define LCDC_HEOIMR_VADD		(0x1 << 20)
+#define LCDC_HEOIMR_VDONE		(0x1 << 21)
+#define LCDC_HEOIMR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOISR	0x0298
+#define LCDC_HEOISR_DMA			(0x1 << 2)
+#define LCDC_HEOISR_DSCR		(0x1 << 3)
+#define LCDC_HEOISR_ADD			(0x1 << 4)
+#define LCDC_HEOISR_DONE		(0x1 << 5)
+#define LCDC_HEOISR_OVR			(0x1 << 6)
+#define LCDC_HEOISR_UDMA		(0x1 << 10)
+#define LCDC_HEOISR_UDSCR		(0x1 << 11)
+#define LCDC_HEOISR_UADD		(0x1 << 12)
+#define LCDC_HEOISR_UDONE		(0x1 << 13)
+#define LCDC_HEOISR_UOVR		(0x1 << 14)
+#define LCDC_HEOISR_VDMA		(0x1 << 18)
+#define LCDC_HEOISR_VDSCR		(0x1 << 19)
+#define LCDC_HEOISR_VADD		(0x1 << 20)
+#define LCDC_HEOISR_VDONE		(0x1 << 21)
+#define LCDC_HEOISR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOHEAD	0x029C
+
+#define ATMEL_LCDC_HEOADDR	0x02A0
+
+#define ATMEL_LCDC_HEOCTRL	0x02A4
+#define LCDC_HEOCTRL_DFETCH		(0x1 << 0)
+#define LCDC_HEOCTRL_LFETCH		(0x1 << 1)
+#define LCDC_HEOCTRL_DMAIEN		(0x1 << 2)
+#define LCDC_HEOCTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_HEOCTRL_ADDIEN		(0x1 << 4)
+#define LCDC_HEOCTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEONEXT	0x02A8
+
+#define ATMEL_LCDC_HEOUHEAD	0x02AC
+
+#define ATMEL_LCDC_HEOUADDR	0x02B0
+
+#define ATMEL_LCDC_HEOUCTRL	0x02B4
+#define LCDC_HEOUCTRL_UDFETCH		(0x1 << 0)
+#define LCDC_HEOUCTRL_UDMAIEN		(0x1 << 2)
+#define LCDC_HEOUCTRL_UDSCRIEN		(0x1 << 3)
+#define LCDC_HEOUCTRL_UADDIEN		(0x1 << 4)
+#define LCDC_HEOUCTRL_UDONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEOUNEXT	0x02B8
+
+#define ATMEL_LCDC_HEOVHEAD	0x02BC
+
+#define ATMEL_LCDC_HEOVADDR	0x02C0
+
+#define ATMEL_LCDC_HEOVCTRL	0x02C4
+#define LCDC_HEOVCTRL_VDFETCH		(0x1 << 0)
+#define LCDC_HEOVCTRL_VDMAIEN		(0x1 << 2)
+#define LCDC_HEOVCTRL_VDSCRIEN		(0x1 << 3)
+#define LCDC_HEOVCTRL_VADDIEN		(0x1 << 4)
+#define LCDC_HEOVCTRL_VDONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEOVNEXT	0x02C8
+
+#define ATMEL_LCDC_HEOCFG0	0x02CC
+#define LCDC_HEOCFG0_BLEN_OFFSET	4
+#define LCDC_HEOCFG0_BLEN		(0x3 << LCDC_HEOCFG0_BLEN_OFFSET)
+#define		LCDC_HEOCFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_HEOCFG0_BLENUV_OFFSET	6
+#define LCDC_HEOCFG0_BLENUV		(0x3 << LCDC_HEOCFG0_BLENUV_OFFSET)
+#define		LCDC_HEOCFG0_BLENUV_AHB_SINGLE		(0x0 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR4		(0x1 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR8		(0x2 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR16		(0x3 << 6)
+#define LCDC_HEOCFG0_DLBO		(0x1 << 8)
+#define LCDC_HEOCFG0_ROTDIS		(0x1 << 12)
+#define LCDC_HEOCFG0_LOCKDIS		(0x1 << 13)
+
+#define ATMEL_LCDC_HEOCFG1	0x02D0
+#define LCDC_HEOCFG1_CLUTEN		(0x1 << 0)
+#define LCDC_HEOCFG1_YUVEN		(0x1 << 1)
+#define LCDC_HEOCFG1_RGBMODE_OFFSET	4
+#define LCDC_HEOCFG1_RGBMODE		(0xf << LCDC_HEOCFG1_RGBMODE_OFFSET)
+#define		LCDC_HEOCFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_HEOCFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_HEOCFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_HEOCFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_HEOCFG1_CLUTMODE_OFFSET	8
+#define LCDC_HEOCFG1_CLUTMODE		(0x3 << LCDC_HEOCFG1_CLUTMODE_OFFSET)
+#define		LCDC_HEOCFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_8BPP		(0x3 << 8)
+#define LCDC_HEOCFG1_YUVMODE_OFFSET	12
+#define LCDC_HEOCFG1_YUVMODE		(0xf << LCDC_HEOCFG1_YUVMODE_OFFSET)
+#define		LCDC_HEOCFG1_YUVMODE_32BPP_AYCBCR	(0x0 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE0	(0x1 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE1	(0x2 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE2	(0x3 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE3	(0x4 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_SEMIPLANAR	(0x5 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_PLANAR	(0x6 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_SEMIPLANAR	(0x7 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_PLANAR	(0x8 << 12)
+#define LCDC_HEOCFG1_YUV422ROT		(0x1 << 16)
+#define LCDC_HEOCFG1_YUV422SWP		(0x1 << 17)
+
+#define ATMEL_LCDC_HEOCFG2	0x02D4
+#define LCDC_HEOCFG2_XOFFSET_OFFSET	0
+#define LCDC_HEOCFG2_XOFFSET		(0x7ff << LCDC_HEOCFG2_XOFFSET_OFFSET)
+#define LCDC_HEOCFG2_YOFFSET_OFFSET	16
+#define LCDC_HEOCFG2_YOFFSET		(0x7ff << LCDC_HEOCFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG3	0x02D8
+#define LCDC_HEOCFG3_XSIZE_OFFSET	0
+#define LCDC_HEOCFG3_XSIZE		(0x7ff << LCDC_HEOCFG3_XSIZE_OFFSET)
+#define LCDC_HEOCFG3_YSIZE_OFFSET	16
+#define LCDC_HEOCFG3_YSIZE		(0x7ff << LCDC_HEOCFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG4	0x02DC
+#define LCDC_HEOCFG4_XMEM_SIZE_OFFSET	0
+#define LCDC_HEOCFG4_XMEM_SIZE		(0x7ff << LCDC_HEOCFG4_XMEM_SIZE_OFFSET)
+#define LCDC_HEOCFG4_YMEM_SIZE_OFFSET	16
+#define LCDC_HEOCFG4_YMEM_SIZE		(0x7ff << LCDC_HEOCFG4_YMEM_SIZE_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG5	0x02E0
+
+#define ATMEL_LCDC_HEOCFG6	0x02E4
+
+#define ATMEL_LCDC_HEOCFG7	0x02E8
+
+#define ATMEL_LCDC_HEOCFG8	0x02EC
+
+#define ATMEL_LCDC_HEOCFG9	0x02F0
+#define LCDC_HEOCFG9_BDEF_OFFSET	0
+#define LCDC_HEOCFG9_BDEF		(0xff << LCDC_HEOCFG9_BDEF_OFFSET)
+#define LCDC_HEOCFG9_GDEF_OFFSET	8
+#define LCDC_HEOCFG9_GDEF		(0xff << LCDC_HEOCFG9_GDEF_OFFSET)
+#define LCDC_HEOCFG9_RDEF_OFFSET	16
+#define LCDC_HEOCFG9_RDEF		(0xff << LCDC_HEOCFG9_RDEF_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG10	0x02F4
+#define LCDC_HEOCFG10_BKEY_OFFSET	0
+#define LCDC_HEOCFG10_BKEY		(0xff << LCDC_HEOCFG10_BKEY_OFFSET)
+#define LCDC_HEOCFG10_GKEY_OFFSET	8
+#define LCDC_HEOCFG10_GKEY		(0xff << LCDC_HEOCFG10_GKEY_OFFSET)
+#define LCDC_HEOCFG10_RKEY_OFFSET	16
+#define LCDC_HEOCFG10_RKEY		(0xff << LCDC_HEOCFG10_RKEY_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG11	0x02F8
+#define LCDC_HEOCFG11_BMASK_OFFSET	0
+#define LCDC_HEOCFG11_BMASK		(0xff << LCDC_HEOCFG11_BMASK_OFFSET)
+#define LCDC_HEOCFG11_GMASK_OFFSET	8
+#define LCDC_HEOCFG11_GMASK		(0xff << LCDC_HEOCFG11_GMASK_OFFSET)
+#define LCDC_HEOCFG11_RMASK_OFFSET	16
+#define LCDC_HEOCFG11_RMASK		(0xff << LCDC_HEOCFG11_RMASK_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG12	0x02FC
+#define LCDC_HEOCFG12_CRKEY		(0x1 << 0)
+#define LCDC_HEOCFG12_INV		(0x1 << 1)
+#define LCDC_HEOCFG12_ITER2BL		(0x1 << 2)
+#define LCDC_HEOCFG12_ITER		(0x1 << 3)
+#define LCDC_HEOCFG12_REVALPHA		(0x1 << 4)
+#define LCDC_HEOCFG12_GAEN		(0x1 << 5)
+#define LCDC_HEOCFG12_LAEN		(0x1 << 6)
+#define LCDC_HEOCFG12_OVR		(0x1 << 7)
+#define LCDC_HEOCFG12_DMA		(0x1 << 8)
+#define LCDC_HEOCFG12_REP		(0x1 << 9)
+#define LCDC_HEOCFG12_DSTKEY		(0x1 << 10)
+#define LCDC_HEOCFG12_VIDPRI		(0x1 << 12)
+#define LCDC_HEOCFG12_GA_OFFSET		16
+#define LCDC_HEOCFG12_GA		(0xff << LCDC_HEOCFG12_GA_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG13	0x0300
+#define LCDC_HEOCFG13_XFACTOR_OFFSET	0
+#define LCDC_HEOCFG13_XFACTOR		(0x1fff << LCDC_HEOCFG13_XFACTOR_OFFSET)
+#define LCDC_HEOCFG13_YFACTOR_OFFSET	16
+#define LCDC_HEOCFG13_YFACTOR		(0x1fff << LCDC_HEOCFG13_YFACTOR_OFFSET)
+#define LCDC_HEOCFG13_SCALEN		(0x1 << 31)
+
+#define ATMEL_LCDC_HEOCFG14	0x0304
+#define LCDC_HEOCFG14_CSCRY_OFFSET	0
+#define LCDC_HEOCFG14_CSCRY		(0x3ff << LCDC_HEOCFG14_CSCRY_OFFSET)
+#define LCDC_HEOCFG14_CSCRU_OFFSET	10
+#define LCDC_HEOCFG14_CSCRU		(0x3ff << LCDC_HEOCFG14_CSCRU_OFFSET)
+#define LCDC_HEOCFG14_CSCRV_OFFSET	20
+#define LCDC_HEOCFG14_CSCRV		(0x3ff << LCDC_HEOCFG14_CSCRV_OFFSET)
+#define LCDC_HEOCFG14_CSCYOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HEOCFG15	0x0308
+#define LCDC_HEOCFG15_CSCGY_OFFSET	0
+#define LCDC_HEOCFG15_CSCGY		(0x3ff << LCDC_HEOCFG15_CSCGY_OFFSET)
+#define LCDC_HEOCFG15_CSCGU_OFFSET	10
+#define LCDC_HEOCFG15_CSCGU		(0x3ff << LCDC_HEOCFG15_CSCGU_OFFSET)
+#define LCDC_HEOCFG15_CSCGV_OFFSET	20
+#define LCDC_HEOCFG15_CSCGV		(0x3ff << LCDC_HEOCFG15_CSCGV_OFFSET)
+#define LCDC_HEOCFG15_CSCUOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HEOCFG16	0x030C
+#define LCDC_HEOCFG16_CSCBY_OFFSET	0
+#define LCDC_HEOCFG16_CSCBY		(0x3ff << LCDC_HEOCFG16_CSCBY_OFFSET)
+#define LCDC_HEOCFG16_CSCBU_OFFSET	10
+#define LCDC_HEOCFG16_CSCBU		(0x3ff << LCDC_HEOCFG16_CSCBU_OFFSET)
+#define LCDC_HEOCFG16_CSCBV_OFFSET	20
+#define LCDC_HEOCFG16_CSCBV		(0x3ff << LCDC_HEOCFG16_CSCBV_OFFSET)
+#define LCDC_HEOCFG16_CSCVOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HCRCHER	0x0340
+#define LCDC_HCRCHER_CHEN		(0x1 << 0)
+#define LCDC_HCRCHER_UPDATEEN		(0x1 << 1)
+#define LCDC_HCRCHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_HCRCHDR	0x0344
+#define LCDC_HCRCHDR_CHDIS		(0x1 << 0)
+#define LCDC_HCRCHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_HCRCHSR	0x0348
+#define LCDC_HCRCHSR_CHSR		(0x1 << 0)
+#define LCDC_HCRCHSR_UPDATESR		(0x1 << 1)
+#define LCDC_HCRCHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_HCRIER	0x034C
+#define LCDC_HCRIER_DMA			(0x1 << 2)
+#define LCDC_HCRIER_DSCR		(0x1 << 3)
+#define LCDC_HCRIER_ADD			(0x1 << 4)
+#define LCDC_HCRIER_DONE		(0x1 << 5)
+#define LCDC_HCRIER_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRIDR	0x0350
+#define LCDC_HCRIDR_DMA			(0x1 << 2)
+#define LCDC_HCRIDR_DSCR		(0x1 << 3)
+#define LCDC_HCRIDR_ADD			(0x1 << 4)
+#define LCDC_HCRIDR_DONE		(0x1 << 5)
+#define LCDC_HCRIDR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRIMR	0x0354
+#define LCDC_HCRIMR_DMA			(0x1 << 2)
+#define LCDC_HCRIMR_DSCR		(0x1 << 3)
+#define LCDC_HCRIMR_ADD			(0x1 << 4)
+#define LCDC_HCRIMR_DONE		(0x1 << 5)
+#define LCDC_HCRIMR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRISR	0x0358
+#define LCDC_HCRISR_DMA			(0x1 << 2)
+#define LCDC_HCRISR_DSCR		(0x1 << 3)
+#define LCDC_HCRISR_ADD			(0x1 << 4)
+#define LCDC_HCRISR_DONE		(0x1 << 5)
+#define LCDC_HCRISR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRHEAD	0x035C
+
+#define ATMEL_LCDC_HCRADDR	0x0360
+
+#define ATMEL_LCDC_HCRCTRL	0x0364
+#define LCDC_HCRCTRL_DFETCH		(0x1 << 0)
+#define LCDC_HCRCTRL_LFETCH		(0x1 << 1)
+#define LCDC_HCRCTRL_DMAIEN		(0x1 << 2)
+#define LCDC_HCRCTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_HCRCTRL_ADDIEN		(0x1 << 4)
+#define LCDC_HCRCTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HCRNEXT	0x0368
+
+#define ATMEL_LCDC_HCRCFG0	0x036C
+#define LCDC_HCRCFG0_BLEN_OFFSET	4
+#define LCDC_HCRCFG0_BLEN		(0x3 << LCDC_HCRCFG0_BLEN_OFFSET)
+#define		LCDC_HCRCFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_HCRCFG0_DLBO		(0x1 << 8)
+
+#define ATMEL_LCDC_HCRCFG1	0x0370
+#define LCDC_HCRCFG1_CLUTEN		(0x1 << 0)
+#define LCDC_HCRCFG1_RGBMODE_OFFSET	4
+#define LCDC_HCRCFG1_RGBMODE		(0xf << LCDC_HCRCFG1_RGBMODE_OFFSET)
+#define		LCDC_HCRCFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_HCRCFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_HCRCFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_HCRCFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_HCRCFG1_CLUTMODE_OFFSET	8
+#define LCDC_HCRCFG1_CLUTMODE		(0x3 << LCDC_HCRCFG1_CLUTMODE_OFFSET)
+#define		LCDC_HCRCFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_HCRCFG2	0x0374
+#define LCDC_HCRCFG2_XOFFSET_OFFSET	0
+#define LCDC_HCRCFG2_XOFFSET		(0x7ff << LCDC_HCRCFG2_XOFFSET_OFFSET)
+#define LCDC_HCRCFG2_YOFFSET_OFFSET	16
+#define LCDC_HCRCFG2_YOFFSET		(0x7ff << LCDC_HCRCFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG3	0x0378
+#define LCDC_HCRCFG3_XSIZE_OFFSET	0
+#define LCDC_HCRCFG3_XSIZE		(0x7f << LCDC_HCRCFG3_XSIZE_OFFSET)
+#define LCDC_HCRCFG3_YSIZE_OFFSET	16
+#define LCDC_HCRCFG3_YSIZE		(0x7f << LCDC_HCRCFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG4	0x037C
+
+#define ATMEL_LCDC_HCRCFG6	0x0384
+#define LCDC_HCRCFG6_BDEF_OFFSET	0
+#define LCDC_HCRCFG6_BDEF		(0xff << LCDC_HCRCFG6_BDEF_OFFSET)
+#define LCDC_HCRCFG6_GDEF_OFFSET	8
+#define LCDC_HCRCFG6_GDEF		(0xff << LCDC_HCRCFG6_GDEF_OFFSET)
+#define LCDC_HCRCFG6_RDEF_OFFSET	16
+#define LCDC_HCRCFG6_RDEF		(0xff << LCDC_HCRCFG6_RDEF_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG7	0x0388
+#define LCDC_HCRCFG7_BKEY_OFFSET	0
+#define LCDC_HCRCFG7_BKEY		(0xff << LCDC_HCRCFG7_BKEY_OFFSET)
+#define LCDC_HCRCFG7_GKEY_OFFSET	8
+#define LCDC_HCRCFG7_GKEY		(0xff << LCDC_HCRCFG7_GKEY_OFFSET)
+#define LCDC_HCRCFG7_RKEY_OFFSET	16
+#define LCDC_HCRCFG7_RKEY		(0xff << LCDC_HCRCFG7_RKEY_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG8	0x038C
+#define LCDC_HCRCFG8_BMASK_OFFSET	0
+#define LCDC_HCRCFG8_BMASK		(0xff << LCDC_HCRCFG8_BMASK_OFFSET)
+#define LCDC_HCRCFG8_GMASK_OFFSET	8
+#define LCDC_HCRCFG8_GMASK		(0xff << LCDC_HCRCFG8_GMASK_OFFSET)
+#define LCDC_HCRCFG8_RMASK_OFFSET	16
+#define LCDC_HCRCFG8_RMASK		(0xff << LCDC_HCRCFG8_RMASK_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG9	0x0390
+#define LCDC_HCRCFG9_CRKEY		(0x1 << 0)
+#define LCDC_HCRCFG9_INV		(0x1 << 1)
+#define LCDC_HCRCFG9_ITER2BL		(0x1 << 2)
+#define LCDC_HCRCFG9_ITER		(0x1 << 3)
+#define LCDC_HCRCFG9_REVALPHA		(0x1 << 4)
+#define LCDC_HCRCFG9_GAEN		(0x1 << 5)
+#define LCDC_HCRCFG9_LAEN		(0x1 << 6)
+#define LCDC_HCRCFG9_OVR		(0x1 << 7)
+#define LCDC_HCRCFG9_DMA		(0x1 << 8)
+#define LCDC_HCRCFG9_REP		(0x1 << 9)
+#define LCDC_HCRCFG9_DSTKEY		(0x1 << 10)
+#define LCDC_HCRCFG9_GA_OFFSET		16
+#define LCDC_HCRCFG9_GA_Msk		(0xff << LCDC_HCRCFG9_GA_OFFSET)
+
+#define ATMEL_LCDC_BASECLUT	0x400
+#define LCDC_BASECLUT_BCLUT_OFFSET	0
+#define LCDC_BASECLUT_BCLUT		(0xff << LCDC_BASECLUT_BCLUT_OFFSET)
+#define LCDC_BASECLUT_GCLUT_OFFSET	8
+#define LCDC_BASECLUT_GCLUT		(0xff << LCDC_BASECLUT_GCLUT_OFFSET)
+#define LCDC_BASECLUT_RCLUT_OFFSET	16
+#define LCDC_BASECLUT_RCLUT		(0xff << LCDC_BASECLUT_RCLUT_OFFSET)
+
+#define ATMEL_LCDC_OVR1CLUT	0x800
+#define LCDC_OVR1CLUT_BCLUT_OFFSET	0
+#define LCDC_OVR1CLUT_BCLUT		(0xff << LCDC_OVR1CLUT_BCLUT_OFFSET)
+#define LCDC_OVR1CLUT_GCLUT_OFFSET	8
+#define LCDC_OVR1CLUT_GCLUT		(0xff << LCDC_OVR1CLUT_GCLUT_OFFSET)
+#define LCDC_OVR1CLUT_RCLUT_OFFSET	16
+#define LCDC_OVR1CLUT_RCLUT		(0xff << LCDC_OVR1CLUT_RCLUT_OFFSET)
+#define LCDC_OVR1CLUT_ACLUT_OFFSET	24
+#define LCDC_OVR1CLUT_ACLUT		(0xff << LCDC_OVR1CLUT_ACLUT_OFFSET)
+
+#define ATMEL_LCDC_HEOCLUT	0x1000
+#define LCDC_HEOCLUT_BCLUT_OFFSET	0
+#define LCDC_HEOCLUT_BCLUT		(0xff << LCDC_HEOCLUT_BCLUT_OFFSET)
+#define LCDC_HEOCLUT_GCLUT_OFFSET	8
+#define LCDC_HEOCLUT_GCLUT		(0xff << LCDC_HEOCLUT_GCLUT_OFFSET)
+#define LCDC_HEOCLUT_RCLUT_OFFSET	16
+#define LCDC_HEOCLUT_RCLUT		(0xff << LCDC_HEOCLUT_RCLUT_OFFSET)
+#define LCDC_HEOCLUT_ACLUT_OFFSET	24
+#define LCDC_HEOCLUT_ACLUT		(0xff << LCDC_HEOCLUT_ACLUT_OFFSET)
+
+#define ATMEL_LCDC_HCRCLUT	0x1400
+#define LCDC_HCRCLUT_BCLUT_OFFSET	0
+#define LCDC_HCRCLUT_BCLUT		(0xff << LCDC_HCRCLUT_BCLUT_OFFSET)
+#define LCDC_HCRCLUT_GCLUT_OFFSET	8
+#define LCDC_HCRCLUT_GCLUT		(0xff << LCDC_HCRCLUT_GCLUT_OFFSET)
+#define LCDC_HCRCLUT_RCLUT_OFFSET	16
+#define LCDC_HCRCLUT_RCLUT		(0xff << LCDC_HCRCLUT_RCLUT_OFFSET)
+#define LCDC_HCRCLUT_ACLUT_OFFSET	24
+#define LCDC_HCRCLUT_ACLUT		(0xff << LCDC_HCRCLUT_ACLUT_OFFSET)
+
+/* Base layer CLUT */
+#define ATMEL_LCDC_LUT(n)	(0x0400 + ((n)*4))
+
+
+#endif /* __ATMEL_HLCDC4_H__ */
--- a/drivers/video/atmel_lcdfb.c
+++ b/drivers/video/atmel_lcdfb.c
@@ -1,7 +1,7 @@
 /*
  *  Driver for AT91/AT32 LCD Controller
  *
- *  Copyright (C) 2007 Atmel Corporation
+ *  Copyright (C) 2007-2010 Atmel Corporation
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive for
@@ -25,6 +25,7 @@
 #include <asm/gpio.h>
 
 #include <video/atmel_lcdc.h>
+#include <mach/atmel_hlcdfb.h>
 
 #define lcdc_readl(sinfo, reg)		__raw_readl((sinfo)->mmio+(reg))
 #define lcdc_writel(sinfo, reg, val)	__raw_writel((val), (sinfo)->mmio+(reg))
@@ -76,6 +77,9 @@ static u32 contrast_ctr = ATMEL_LCDC_PS_
 		| ATMEL_LCDC_POL_POSITIVE
 		| ATMEL_LCDC_ENA_PWMENABLE;
 
+static const u32 contrast_pwm_ctr = LCDC_LCDCFG6_PWMPOL
+		| (ATMEL_LCDC_CVAL_DEFAULT << LCDC_LCDCFG6_PWMCVAL_OFFSET);
+
 #ifdef CONFIG_BACKLIGHT_ATMEL_LCDC
 
 /* some bl->props field just changed */
@@ -84,6 +88,7 @@ static int atmel_bl_update_status(struct
 	struct atmel_lcdfb_info *sinfo = bl_get_data(bl);
 	int			power = sinfo->bl_power;
 	int			brightness = bl->props.brightness;
+	u32			reg;
 
 	/* REVISIT there may be a meaningful difference between
 	 * fb_blank and power ... there seem to be some cases
@@ -94,17 +99,28 @@ static int atmel_bl_update_status(struct
 	else if (bl->props.power != sinfo->bl_power)
 		power = bl->props.power;
 
-	if (brightness < 0 && power == FB_BLANK_UNBLANK)
-		brightness = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
-	else if (power != FB_BLANK_UNBLANK)
+	if (brightness < 0 && power == FB_BLANK_UNBLANK) {
+		if (cpu_is_at91sam9x5())
+			brightness = lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6)
+				     >> LCDC_LCDCFG6_PWMCVAL_OFFSET;
+		else
+			brightness = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+	} else if (power != FB_BLANK_UNBLANK) {
 		brightness = 0;
+	}
 
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);
-	if (contrast_ctr & ATMEL_LCDC_POL_POSITIVE)
-		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,
-			brightness ? contrast_ctr : 0);
-	else
-		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
+	if (cpu_is_at91sam9x5()) {
+		reg = lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6) & ~LCDC_LCDCFG6_PWMCVAL;
+		reg |= brightness << LCDC_LCDCFG6_PWMCVAL_OFFSET;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG6, reg);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);
+		if (contrast_ctr & ATMEL_LCDC_POL_POSITIVE)
+			lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,
+					brightness ? contrast_ctr : 0);
+		else
+			lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
+	}
 
 	bl->props.fb_blank = bl->props.power = sinfo->bl_power = power;
 
@@ -115,7 +131,10 @@ static int atmel_bl_get_brightness(struc
 {
 	struct atmel_lcdfb_info *sinfo = bl_get_data(bl);
 
-	return lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+	if (cpu_is_at91sam9x5())
+		return lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6) >> LCDC_LCDCFG6_PWMCVAL_OFFSET;
+	else
+		return lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
 }
 
 static const struct backlight_ops atmel_lcdc_bl_ops = {
@@ -171,14 +190,17 @@ static void exit_backlight(struct atmel_
 
 static void init_contrast(struct atmel_lcdfb_info *sinfo)
 {
-	/* contrast pwm can be 'inverted' */
-	if (sinfo->lcdcon_pol_negative)
-			contrast_ctr &= ~(ATMEL_LCDC_POL_POSITIVE);
-
-	/* have some default contrast/backlight settings */
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);
-
+	if (cpu_is_at91sam9x5()) {
+		/* have some default contrast/backlight settings */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG6, contrast_pwm_ctr);
+	} else {
+		/* contrast pwm can be 'inverted' */
+		if (sinfo->lcdcon_pol_negative)
+				contrast_ctr &= ~(ATMEL_LCDC_POL_POSITIVE);
+		/* have some default contrast/backlight settings */
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);
+	}
 	if (sinfo->lcdcon_is_backlight)
 		init_backlight(sinfo);
 }
@@ -220,32 +242,78 @@ static unsigned long compute_hozval(unsi
 
 static void atmel_lcdfb_stop_nowait(struct atmel_lcdfb_info *sinfo)
 {
-	/* Turn off the LCD controller and the DMA controller */
-	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
-			sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);
-
-	/* Wait for the LCDC core to become idle */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)
-		msleep(10);
+	if (cpu_is_at91sam9x5()) {
+		/* Disable DISP signal */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_DISPDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_DISPSTS))
+			msleep(1);
+		/* Disable synchronization */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_SYNCDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_LCDSTS))
+			msleep(1);
+		/* Disable pixel clock */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_CLKDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_CLKSTS))
+			msleep(1);
+		/* Disable PWM */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_PWMDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_PWMSTS))
+			msleep(1);
+	} else {
+		/* Turn off the LCD controller and the DMA controller */
+		lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
+				sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);
+
+		/* Wait for the LCDC core to become idle */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)
+			msleep(10);
 
-	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
+		lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
+	}
 }
 
 static void atmel_lcdfb_stop(struct atmel_lcdfb_info *sinfo)
 {
 	atmel_lcdfb_stop_nowait(sinfo);
 
-	/* Wait for DMA engine to become idle... */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
-		msleep(10);
+	if (cpu_is_at91sam9x5()) {
+		/* Wait for the end of DMA transfer */
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_BASEISR) & LCDC_BASEISR_DMA))
+			msleep(10);
+	} else {
+		/* Wait for DMA engine to become idle... */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
+			msleep(10);
+	}
 }
 
 static void atmel_lcdfb_start(struct atmel_lcdfb_info *sinfo)
 {
-	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);
-	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
-		(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET)
-		| ATMEL_LCDC_PWR);
+	u32	value;
+
+	if (cpu_is_at91sam9x5()) {
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_CLKEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_CLKSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_SYNCEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_LCDSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_DISPEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_DISPSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_PWMEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_PWMSTS))
+			msleep(1);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);
+		lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
+			(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET)
+			| ATMEL_LCDC_PWR);
+	}
 }
 
 static void atmel_lcdfb_update_dma(struct fb_info *info,
@@ -254,14 +322,31 @@ static void atmel_lcdfb_update_dma(struc
 	struct atmel_lcdfb_info *sinfo = info->par;
 	struct fb_fix_screeninfo *fix = &info->fix;
 	unsigned long dma_addr;
+	struct lcd_dma_desc *desc;
 
 	dma_addr = (fix->smem_start + var->yoffset * fix->line_length
 		    + var->xoffset * info->var.bits_per_pixel / 8);
 
 	dma_addr &= ~3UL;
 
-	/* Set framebuffer DMA base address and pixel offset */
-	lcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);
+	if (cpu_is_at91sam9x5()) {
+		/* Setup the DMA descriptor, this descriptor will loop to itself */
+		desc = (struct lcd_dma_desc *)sinfo->p_dma_desc;
+
+		desc->address = dma_addr;
+		/* Disable DMA transfer interrupt & descriptor loaded interrupt. */
+		desc->control = LCDC_BASECTRL_ADDIEN | LCDC_BASECTRL_DSCRIEN
+				| LCDC_BASECTRL_DMAIEN | LCDC_BASECTRL_DFETCH;
+		desc->next = sinfo->dma_desc_phys;
+
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEADDR, dma_addr);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASECTRL, desc->control);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASENEXT, sinfo->dma_desc_phys);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASECHER, LCDC_BASECHER_CHEN | LCDC_BASECHER_UPDATEEN);
+	} else {
+		/* Set framebuffer DMA base address and pixel offset */
+		lcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);
+	}
 
 	atmel_lcdfb_update_dma2d(sinfo, var, info);
 }
@@ -272,12 +357,18 @@ static inline void atmel_lcdfb_free_vide
 
 	dma_free_writecombine(info->device, info->fix.smem_len,
 				info->screen_base, info->fix.smem_start);
+
+	if (cpu_is_at91sam9x5()) {
+		if (sinfo->p_dma_desc)
+			dma_free_writecombine(info->device, sizeof(struct lcd_dma_desc),
+						sinfo->p_dma_desc, sinfo->dma_desc_phys);
+	}
 }
 
 /**
  *	atmel_lcdfb_alloc_video_memory - Allocate framebuffer memory
  *	@sinfo: the frame buffer to allocate memory for
- * 	
+ *
  * 	This function is called only from the atmel_lcdfb_probe()
  * 	so no locking by fb_info->mm_lock around smem_len setting is needed.
  */
@@ -300,6 +391,19 @@ static int atmel_lcdfb_alloc_video_memor
 
 	memset(info->screen_base, 0, info->fix.smem_len);
 
+	if (cpu_is_at91sam9x5()) {
+		sinfo->p_dma_desc = dma_alloc_writecombine(info->device,
+						sizeof(struct lcd_dma_desc),
+						(dma_addr_t *)&(sinfo->dma_desc_phys),
+						GFP_KERNEL);
+
+		if (!sinfo->p_dma_desc) {
+			dma_free_writecombine(info->device, info->fix.smem_len,
+						info->screen_base, info->fix.smem_start);
+			return -ENOMEM;
+		}
+	}
+
 	return 0;
 }
 
@@ -393,18 +497,33 @@ static int atmel_lcdfb_check_var(struct
 	}
 
 	/* Saturate vertical and horizontal timings at maximum values */
-	var->vsync_len = min_t(u32, var->vsync_len,
-			(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);
-	var->upper_margin = min_t(u32, var->upper_margin,
-			ATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);
-	var->lower_margin = min_t(u32, var->lower_margin,
-			ATMEL_LCDC_VFP);
-	var->right_margin = min_t(u32, var->right_margin,
-			(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);
-	var->hsync_len = min_t(u32, var->hsync_len,
-			(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);
-	var->left_margin = min_t(u32, var->left_margin,
-			ATMEL_LCDC_HBP + 1);
+	if (cpu_is_at91sam9x5()) {
+		var->vsync_len = min_t(u32, var->vsync_len,
+				(LCDC_LCDCFG1_VSPW >> LCDC_LCDCFG1_VSPW_OFFSET) + 1);
+		var->upper_margin = min_t(u32, var->upper_margin,
+				(LCDC_LCDCFG2_VFPW >> LCDC_LCDCFG2_VFPW_OFFSET) + 1);
+		var->lower_margin = min_t(u32, var->lower_margin,
+				LCDC_LCDCFG2_VBPW >> LCDC_LCDCFG2_VBPW_OFFSET);
+		var->right_margin = min_t(u32, var->right_margin,
+				(LCDC_LCDCFG3_HBPW >> LCDC_LCDCFG3_HBPW_OFFSET) + 1);
+		var->hsync_len = min_t(u32, var->hsync_len,
+				(LCDC_LCDCFG1_HSPW >> LCDC_LCDCFG1_HSPW_OFFSET) + 1);
+		var->left_margin = min_t(u32, var->left_margin,
+				(LCDC_LCDCFG3_HFPW >> LCDC_LCDCFG3_HFPW_OFFSET) + 1);
+	} else {
+		var->vsync_len = min_t(u32, var->vsync_len,
+				(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);
+		var->upper_margin = min_t(u32, var->upper_margin,
+				ATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);
+		var->lower_margin = min_t(u32, var->lower_margin,
+				ATMEL_LCDC_VFP);
+		var->right_margin = min_t(u32, var->right_margin,
+				(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);
+		var->hsync_len = min_t(u32, var->hsync_len,
+				(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);
+		var->left_margin = min_t(u32, var->left_margin,
+				ATMEL_LCDC_HBP + 1);
+	}
 
 	/* Some parameters can't be zero */
 	var->vsync_len = max_t(u32, var->vsync_len, 1);
@@ -419,9 +538,53 @@ static int atmel_lcdfb_check_var(struct
 	case 8:
 		var->red.offset = var->green.offset = var->blue.offset = 0;
 		var->red.length = var->green.length = var->blue.length
-			= var->bits_per_pixel;
+				= var->bits_per_pixel;
+		break;
+	case 12:
+		if (cpu_is_at91sam9x5()) {
+			/* RGB:444 mode */
+			var->red.offset = 8;
+			var->blue.offset = 0;
+			var->green.offset = 4;
+			var->red.length = var->green.length = var->blue.length = 4;
+		} else {
+			/*TODO: rework*/
+			BUG();
+		}
+		break;
+	case 15:
+		if (cpu_is_at91sam9x5()) {
+			/* RGB:555 mode */
+			var->red.offset = 10;
+			var->blue.offset = 0;
+			var->green.length = 5;
+			var->red.length = var->green.length = var->blue.length = 5;
+		} else {
+			/*TODO: rework*/
+			BUG();
+		}
 		break;
 	case 16:
+		if (cpu_is_at91sam9x5()) {
+			if (sinfo->alpha_enabled) {
+				/* ARGB:4444 mode */
+				var->red.offset = 8;
+				var->blue.offset = 0;
+				var->green.offset = 4;
+				var->transp.offset = 12;
+				var->red.length = var->green.length
+						= var->blue.length
+						= var->transp.length = 4;
+			} else {
+				/* RGB:565 mode */
+				var->red.offset = 11;
+				var->blue.offset = 0;
+				var->green.offset = 5;
+				var->green.length = 6;
+				var->red.length = var->blue.length = 5;
+			}
+			break;
+		}
 		/* Older SOCs use IBGR:555 rather than BGR:565. */
 		if (sinfo->have_intensity_bit)
 			var->green.length = 5;
@@ -441,6 +604,7 @@ static int atmel_lcdfb_check_var(struct
 		var->red.length = var->blue.length = 5;
 		break;
 	case 32:
+		/* TODO 32 & 24 modes */
 		var->transp.offset = 24;
 		var->transp.length = 8;
 		/* fall through */
@@ -477,6 +641,252 @@ static void atmel_lcdfb_reset(struct atm
 	atmel_lcdfb_start(sinfo);
 }
 
+static int atmel_lcdfb_setup_9x5_core(struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long value;
+	unsigned long clk_value_khz;
+
+	dev_dbg(info->device, "%s:\n", __func__);
+	/* Set pixel clock */
+	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+	value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
+
+	if (value < 1) {
+		dev_notice(info->device, "using system clock as pixel clock\n");
+		value = LCDC_LCDCFG0_CLKPOL | LCDC_LCDCFG0_CLKPWMSEL | LCDC_LCDCFG0_CGDISBASE;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG0, value);
+	} else {
+		info->var.pixclock = KHZ2PICOS(clk_value_khz / value);
+		dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
+				PICOS2KHZ(info->var.pixclock));
+		value = value - 2;
+		dev_dbg(info->device, "  * programming CLKDIV = 0x%08lx\n",
+					value);
+		value = (value << LCDC_LCDCFG0_CLKDIV_OFFSET)
+			| LCDC_LCDCFG0_CLKPOL
+			| LCDC_LCDCFG0_CGDISBASE;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG0, value);
+	}
+
+	/* Initialize control register 5 */
+	value = (sinfo->guard_time << LCDC_LCDCFG5_GUARDTIME_OFFSET)
+		| LCDC_LCDCFG5_DISPDLY
+		| LCDC_LCDCFG5_VSPDLYS;
+
+	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+		value |= LCDC_LCDCFG5_HSPOL;
+	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+		value |= LCDC_LCDCFG5_VSPOL;
+
+	switch (info->var.bits_per_pixel) {
+	case 12:
+		value |= LCDC_LCDCFG5_MODE_OUTPUT_12BPP;
+		break;
+	case 16:
+		if (info->var.transp.offset != 0)
+			value |= LCDC_LCDCFG5_MODE_OUTPUT_12BPP;
+		else
+			value |= LCDC_LCDCFG5_MODE_OUTPUT_16BPP;
+		break;
+	case 18:
+		value |= LCDC_LCDCFG5_MODE_OUTPUT_18BPP;
+		break;
+	case 24:
+	case 32:
+		value |= LCDC_LCDCFG5_MODE_OUTPUT_24BPP;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	dev_dbg(info->device, "  * LCDC_LCDCFG5 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG5, value);
+
+	/* Vertical & Horizontal Timing */
+	value = (info->var.vsync_len - 1) << LCDC_LCDCFG1_VSPW_OFFSET;
+	value |= (info->var.hsync_len - 1) << LCDC_LCDCFG1_HSPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG1 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG1, value);
+
+	value = (info->var.lower_margin) << LCDC_LCDCFG2_VBPW_OFFSET;
+	value |= (info->var.upper_margin - 1) << LCDC_LCDCFG2_VFPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG2 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG2, value);
+
+	value = (info->var.right_margin - 1) << LCDC_LCDCFG3_HBPW_OFFSET;
+	value |= (info->var.left_margin - 1) << LCDC_LCDCFG3_HFPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG3 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG3, value);
+
+	/* Display size */
+	value = (info->var.yres - 1) << LCDC_LCDCFG4_RPF_OFFSET;
+	value |= (info->var.xres - 1) << LCDC_LCDCFG4_PPL_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG4 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG4, value);
+
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG0, LCDC_BASECFG0_BLEN_AHB_INCR4 | LCDC_BASECFG0_DLBO);
+	switch (info->var.bits_per_pixel) {
+	case 12:
+		value = LCDC_BASECFG1_RGBMODE_12BPP_RGB_444;
+		break;
+	case 16:
+		if (info->var.transp.offset != 0)
+			value = LCDC_BASECFG1_RGBMODE_16BPP_ARGB_4444;
+		else
+			value = LCDC_BASECFG1_RGBMODE_16BPP_RGB_565;
+		break;
+	case 18:
+		value = LCDC_BASECFG1_RGBMODE_18BPP_RGB_666_PACKED;
+		break;
+	case 24:
+		value = LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED;
+		break;
+	case 32:
+		value = LCDC_BASECFG1_RGBMODE_32BPP_ARGB_8888;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG1, value);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG2, 0);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG3, 0);	/* Default color */
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG4, LCDC_BASECFG4_DMA);
+
+	/* Disable all interrupts */
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDIDR, ~0UL);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASEIDR, ~0UL);
+	/* Enable BASE LAYER overflow interrupts, if want to enable DMA interrupt, also need set it at LCDC_BASECTRL reg */
+	lcdc_writel(sinfo, ATMEL_LCDC_BASEIER, LCDC_BASEIER_OVR);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDIER, LCDC_LCDIER_FIFOERRIE | LCDC_LCDIER_BASEIE);
+
+	return 0;
+}
+
+static int atmel_lcdfb_setup_core(struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long hozval_linesz;
+	unsigned long value;
+	unsigned long clk_value_khz;
+	unsigned long pix_factor = 2;
+
+	if (cpu_is_at91sam9x5()) {
+		return atmel_lcdfb_setup_9x5_core(info);
+	} else {
+		/* ...set frame size and burst length = 8 words (?) */
+		value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
+		value |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);
+		lcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);
+
+		/* Set pixel clock */
+		if (cpu_is_at91sam9g45() && !cpu_is_at91sam9g45es())
+			pix_factor = 1;
+
+		clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+		value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
+
+		if (value < pix_factor) {
+			dev_notice(info->device, "Bypassing pixel clock divider\n");
+			lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
+		} else {
+			value = (value / pix_factor) - 1;
+			dev_dbg(info->device, "  * programming CLKVAL = 0x%08lx\n",
+					value);
+			lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,
+					value << ATMEL_LCDC_CLKVAL_OFFSET);
+			info->var.pixclock =
+				KHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));
+			dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
+						PICOS2KHZ(info->var.pixclock));
+		}
+
+
+		/* Initialize control register 2 */
+		value = sinfo->default_lcdcon2;
+
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			value |= ATMEL_LCDC_INVLINE_INVERTED;
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			value |= ATMEL_LCDC_INVFRAME_INVERTED;
+
+		switch (info->var.bits_per_pixel) {
+		case 1:
+			value |= ATMEL_LCDC_PIXELSIZE_1;
+			break;
+		case 2:
+			value |= ATMEL_LCDC_PIXELSIZE_2;
+			break;
+		case 4:
+			value |= ATMEL_LCDC_PIXELSIZE_4;
+			break;
+		case 8:
+			value |= ATMEL_LCDC_PIXELSIZE_8;
+			break;
+		case 15: /* fall through */
+		case 16:
+			value |= ATMEL_LCDC_PIXELSIZE_16;
+			break;
+		case 24:
+			value |= ATMEL_LCDC_PIXELSIZE_24;
+			break;
+		case 32:
+			value |= ATMEL_LCDC_PIXELSIZE_32;
+			break;
+		default:
+			BUG();
+			break;
+		}
+		dev_dbg(info->device, "  * LCDCON2 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);
+
+		/* Vertical timing */
+		value = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;
+		value |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;
+		value |= info->var.lower_margin;
+		dev_dbg(info->device, "  * LCDTIM1 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);
+
+		/* Horizontal timing */
+		value = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;
+		value |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;
+		value |= (info->var.left_margin - 1);
+		dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
+
+		/* Horizontal value (aka line size) */
+		hozval_linesz = compute_hozval(info->var.xres,
+					lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2));
+
+		/* Display size */
+		value = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
+		value |= info->var.yres - 1;
+		dev_dbg(info->device, "  * LCDFRMCFG = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
+
+		/* FIFO Threshold: Use formula from data sheet */
+		value = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);
+		lcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);
+
+		/* Toggle LCD_MODE every frame */
+		lcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);
+
+		/* Disable all interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+		/* Enable FIFO & DMA errors */
+		lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+
+		/* ...wait for DMA engine to become idle... */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
+			msleep(10);
+
+		return 0;
+	}
+}
+
 /**
  *      atmel_lcdfb_set_par - Alters the hardware state.
  *      @info: frame buffer structure that represents a single frame buffer
@@ -494,11 +904,7 @@ static void atmel_lcdfb_reset(struct atm
 static int atmel_lcdfb_set_par(struct fb_info *info)
 {
 	struct atmel_lcdfb_info *sinfo = info->par;
-	unsigned long hozval_linesz;
-	unsigned long value;
-	unsigned long clk_value_khz;
 	unsigned long bits_per_line;
-	unsigned long pix_factor = 2;
 
 	might_sleep();
 
@@ -523,98 +929,8 @@ static int atmel_lcdfb_set_par(struct fb
 	dev_dbg(info->device, "  * update DMA engine\n");
 	atmel_lcdfb_update_dma(info, &info->var);
 
-	/* ...set frame size and burst length = 8 words (?) */
-	value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
-	value |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);
-	lcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);
-
 	/* Now, the LCDC core... */
-
-	/* Set pixel clock */
-	if (cpu_is_at91sam9g45() && !cpu_is_at91sam9g45es())
-		pix_factor = 1;
-
-	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
-
-	value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
-
-	if (value < pix_factor) {
-		dev_notice(info->device, "Bypassing pixel clock divider\n");
-		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
-	} else {
-		value = (value / pix_factor) - 1;
-		dev_dbg(info->device, "  * programming CLKVAL = 0x%08lx\n",
-				value);
-		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,
-				value << ATMEL_LCDC_CLKVAL_OFFSET);
-		info->var.pixclock =
-			KHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));
-		dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
-					PICOS2KHZ(info->var.pixclock));
-	}
-
-
-	/* Initialize control register 2 */
-	value = sinfo->default_lcdcon2;
-
-	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
-		value |= ATMEL_LCDC_INVLINE_INVERTED;
-	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
-		value |= ATMEL_LCDC_INVFRAME_INVERTED;
-
-	switch (info->var.bits_per_pixel) {
-		case 1:	value |= ATMEL_LCDC_PIXELSIZE_1; break;
-		case 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;
-		case 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;
-		case 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;
-		case 15: /* fall through */
-		case 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;
-		case 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;
-		case 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;
-		default: BUG(); break;
-	}
-	dev_dbg(info->device, "  * LCDCON2 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);
-
-	/* Vertical timing */
-	value = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;
-	value |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;
-	value |= info->var.lower_margin;
-	dev_dbg(info->device, "  * LCDTIM1 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);
-
-	/* Horizontal timing */
-	value = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;
-	value |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;
-	value |= (info->var.left_margin - 1);
-	dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
-
-	/* Horizontal value (aka line size) */
-	hozval_linesz = compute_hozval(info->var.xres,
-					lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2));
-
-	/* Display size */
-	value = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
-	value |= info->var.yres - 1;
-	dev_dbg(info->device, "  * LCDFRMCFG = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
-
-	/* FIFO Threshold: Use formula from data sheet */
-	value = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);
-	lcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);
-
-	/* Toggle LCD_MODE every frame */
-	lcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);
-
-	/* Disable all interrupts */
-	lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
-	/* Enable FIFO & DMA errors */
-	lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
-
-	/* ...wait for DMA engine to become idle... */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
-		msleep(10);
+	atmel_lcdfb_setup_core(info);
 
 	atmel_lcdfb_start(sinfo);
 
@@ -776,14 +1092,32 @@ static irqreturn_t atmel_lcdfb_interrupt
 	struct fb_info *info = dev_id;
 	struct atmel_lcdfb_info *sinfo = info->par;
 	u32 status;
+	u32 baselayer_status;
+
+	if (cpu_is_at91sam9x5()) {
+		/* Check for error status via interrupt.*/
+		status = lcdc_readl(sinfo, ATMEL_LCDC_LCDISR);
+		if (status & LCDC_LCDISR_FIFOERR) {
+			dev_warn(info->device, "FIFO underflow %#x\n", status);
+		} else if (status & LCDC_LCDISR_BASE) {
+			/* Check base layer's overflow error. */
+			baselayer_status = lcdc_readl(sinfo, ATMEL_LCDC_BASEISR);
+
+			if (baselayer_status & LCDC_BASEISR_OVR)
+				dev_warn(info->device, "base layer overflow %#x\n",
+							baselayer_status);
 
-	status = lcdc_readl(sinfo, ATMEL_LCDC_ISR);
-	if (status & ATMEL_LCDC_UFLWI) {
-		dev_warn(info->device, "FIFO underflow %#x\n", status);
-		/* reset DMA and FIFO to avoid screen shifting */
-		schedule_work(&sinfo->task);
+		}
+	} else {
+		status = lcdc_readl(sinfo, ATMEL_LCDC_ISR);
+		if (status & ATMEL_LCDC_UFLWI) {
+			dev_warn(info->device, "FIFO underflow %#x\n", status);
+			/* reset DMA and FIFO to avoid screen shifting */
+			schedule_work(&sinfo->task);
+		}
+		lcdc_writel(sinfo, ATMEL_LCDC_ICR, status);
 	}
-	lcdc_writel(sinfo, ATMEL_LCDC_ICR, status);
+
 	return IRQ_HANDLED;
 }
 
@@ -928,6 +1262,8 @@ static int __init atmel_lcdfb_probe(stru
 
 	/* Initialize video memory */
 	map = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	sinfo->p_dma_desc = NULL;
+	sinfo->dma_desc_phys = 0;
 	if (map) {
 		/* use a pre-allocated memory buffer */
 		info->fix.smem_start = map->start;
@@ -1038,7 +1374,7 @@ unmap_mmio:
 	exit_backlight(sinfo);
 	iounmap(sinfo->mmio);
 release_mem:
- 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
 free_fb:
 	if (map)
 		iounmap(info->screen_base);
@@ -1083,7 +1419,7 @@ static int __exit atmel_lcdfb_remove(str
 	fb_dealloc_cmap(&info->cmap);
 	free_irq(sinfo->irq_base, info);
 	iounmap(sinfo->mmio);
- 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
 	if (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {
 		iounmap(info->screen_base);
 		release_mem_region(info->fix.smem_start, info->fix.smem_len);
@@ -1108,10 +1444,17 @@ static int atmel_lcdfb_suspend(struct pl
 	 * We don't want to handle interrupts while the clock is
 	 * stopped. It may take forever.
 	 */
-	lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+	if (cpu_is_at91sam9x5()) {
+		/* Disable all interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDIDR, ~0UL);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEIDR, ~0UL);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+
+		sinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);
+	}
 
-	sinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_CTR);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);
 	if (sinfo->atmel_lcdfb_power_control)
 		sinfo->atmel_lcdfb_power_control(0);
 
@@ -1130,11 +1473,18 @@ static int atmel_lcdfb_resume(struct pla
 	atmel_lcdfb_start(sinfo);
 	if (sinfo->atmel_lcdfb_power_control)
 		sinfo->atmel_lcdfb_power_control(1);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);
 
-	/* Enable FIFO & DMA errors */
-	lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI
-			| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+	if (cpu_is_at91sam9x5()) {
+		/* Enable fifo error & BASE LAYER overflow interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEIER, LCDC_BASEIER_OVR);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDIER, LCDC_LCDIER_FIFOERRIE | LCDC_LCDIER_BASEIE);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);
+
+		/* Enable FIFO & DMA errors */
+		lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI
+				| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+	}
 
 	return 0;
 }
--- a/include/video/atmel_lcdc.h
+++ b/include/video/atmel_lcdc.h
@@ -47,12 +47,16 @@ struct atmel_lcdfb_info {
 	struct clk		*bus_clk;
 	struct clk		*lcdc_clk;
 
+	struct lcd_dma_desc	*p_dma_desc;
+	dma_addr_t		dma_desc_phys;
+
 #ifdef CONFIG_BACKLIGHT_ATMEL_LCDC
 	struct backlight_device	*backlight;
 	u8			bl_power;
 #endif
 	bool			lcdcon_is_backlight;
 	bool			lcdcon_pol_negative;
+	bool			alpha_enabled;
 	u8			saved_lcdcon;
 
 	u8			default_bpp;
@@ -65,6 +69,12 @@ struct atmel_lcdfb_info {
 	bool			have_intensity_bit;
 };
 
+struct lcd_dma_desc {
+	u32	address;
+	u32	control;
+	u32	next;
+};
+
 #define ATMEL_LCDC_DMABADDR1	0x00
 #define ATMEL_LCDC_DMABADDR2	0x04
 #define ATMEL_LCDC_DMAFRMPT1	0x08
@@ -215,6 +225,11 @@ struct atmel_lcdfb_info {
 #define	ATMEL_LCDC_OWRI		(1 << 5)
 #define	ATMEL_LCDC_MERI		(1 << 6)
 
+#if !defined(CONFIG_ARCH_AT91SAM9X5)
 #define ATMEL_LCDC_LUT(n)	(0x0c00 + ((n)*4))
+#else
+/* Base layer CLUT */
+#define ATMEL_LCDC_LUT(n)	(0x0400 + ((n)*4))
+#endif
 
 #endif /* __ATMEL_LCDC_H__ */
