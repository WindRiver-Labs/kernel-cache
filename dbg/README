1. What is self-test
====================
self tests are intended to check basic functionality of a feature or of a
kernel subystem. They provide sanity tests for a kernel module by testing
their internal state in relative isolation, providing a known valid baseline
for more complex functionality.

2. Summary for self-test
========================
Wind River Linux uses scc and cfg to manage these self-test kernel
configuration fragments to provide a convenient interface.

self-test.scc: A basic self-test trigger for all arches.
self-test.cfg: A basic self-test kernel configuration fragments.
self-test-x86.scc: x86 self-test trigger, including self-test.scc.
self-test-x86.cfg: x86 specific kernel configuration fragments.

How to use the self tests
-------------------------
The self-tests can be enabled in a build by adding the following options
to your configuration command:

	--enable-kernel=standard+dbg/self-test.scc
	or (for x86)
	--enable-kernel=standard+dbg/self-test-x86.scc


3. A brief introduction for self-test cases
===========================================
The basic concept, the related C file, and the documentation of every test case
may be included in the following items:

1) CONFIG_BACKTRACE_SELF_TEST=y
-------------------------------

This option provides a kernel module that can be used to test the kernel stack
backtrace code. This option is not useful for distributions or general kernels,
but only for kernel developers working on architecture code.

linux/kernel/backtracetest.c

Expected results:
====[ backtrace testing ]===========
Testing a backtrace from process context.
The following trace is a kernel self test and not a bug!
Pid: 1, comm: swapper Not tainted 2.6.27.45-WR3.0.3zz_standard-00011-g8b443e1 #1
 [<c0149240>] ? backtrace_regression_test+0x0/0xe0
 [<c0149275>] backtrace_regression_test+0x35/0xe0
 [<c01c7a35>] ? proc_create_data+0x65/0xb0
 [<c05f75bb>] ? kallsyms_init+0x0/0x2f
 [<c05f75e6>] ? kallsyms_init+0x2b/0x2f
 [<c010111f>] do_one_initcall+0x2f/0x140
 [<c01c7ad9>] ? create_proc_entry+0x59/0xa0
 [<c0152ae8>] ? register_irq_proc+0x98/0xb0
 [<c05e8285>] kernel_init+0x82/0xd9
 [<c05e8203>] ? kernel_init+0x0/0xd9
 [<c010375b>] kernel_thread_helper+0x7/0x10
 =======================

2) CONFIG_DEBUG_LOCKING_API_SELFTESTS=y
---------------------------------------

uses the generic lock debugging code's silent-failure feature to run a
matrix of testcases.  There are 218 testcases currently.

linux/Documentation/lockdep-design.txt
linux/lib/locking-selftest.c

3) CONFIG_RT_MUTEX_TESTER=y
---------------------------

RT-mutex tester: scriptable tester for rt mutexes, which allows userspace
scripting of mutex unit-tests (and dynamic tests as well), using the actual
rt-mutex implementation of the kernel.

linux/Documentation/rt-mutex-design.txt
linux/Documentation/rt-mutex.txt
linux/kernel/rtmutex-tester.c

Expected resuilts:
Initializing RT-Tester: OK

4) CONFIG_RCU_TORTURE_TEST=y
----------------------------

This is intended to enable a /proc-based intense torture test of the RCU
infrastructure. Most of the code is in a separate file that is compiled
only if the CONFIG variable is set. Documentation on how to run the test
and interpret the output is also included.

linux/Documentation/RCU/torture.txt

Expected results:
rcu-torture:--- Start of test: nreaders=2 nfakewriters=4 stat_interval=0
verbose=0 test_no_idle_hz=0 shuffle_interval=3 stutter=5 irqreader=1

5) CONFIG_FTRACE_SELFTEST=y
---------------------------

trace_selftest tries to do a startup self test on many features of ftrace
e.g. dynamic code modification and filters, entries in the trace buffer.

linux/kernel/trace/trace_selftest.c

Expected results:
Testing tracer sched_switch: PASSED
Testing tracer ftrace: PASSED

6) CONFIG_KGDB_TESTS=y (x86 only)
---------------------------------

kgdb internal test suite adds regression tests for testing the kgdb core
and arch specific implementation. This is designed to be built into the
kernel and not as a module because it uses a number of low level kernel
and kgdb primitives which should not be exported externally.

The kgdb test suite is designed as a KGDB I/O module which simulates the
communications that a debugger would have with kgdb.  The tests are broken
up in to a line by line and referenced here as a "get" which is kgdb
requesting input and "put" which is kgdb sending a response.

linux/Documentation/DocBook/kgdb.tmpl
linux/drivers/misc/kgdbts.c

Expected results:
kgdb: Registered I/O driver kgdbts.
kgdbts:RUN plant and detach test
kgdbts:RUN sw breakpoint test
kgdbts:RUN bad memory access test
kgdbts:RUN singlestep test 1000 iterations
kgdbts:RUN singlestep [0/1000]
kgdbts:RUN singlestep [100/1000]
kgdbts:RUN singlestep [200/1000]
kgdbts:RUN singlestep [300/1000]
kgdbts:RUN singlestep [400/1000]
kgdbts:RUN singlestep [500/1000]
kgdbts:RUN singlestep [600/1000]
kgdbts:RUN singlestep [700/1000]
kgdbts:RUN singlestep [800/1000]
kgdbts:RUN singlestep [900/1000]
kgdbts:RUN hw breakpoint test
kgdbts:RUN hw write breakpoint test
kgdbts:RUN access write breakpoint test
kgdbts:RUN do_fork for 100 breakpoints

7) CONFIG_CRYPTO_TEST=m
-----------------------
Like gdb, crypto test suite is intended to do self-test for all the features
of crypto, please read more codes and documentations related.

linux/Documentation/crypto
linux/crypto/tcrypt.c

8) CONFIG_KPROBES_SANITY_TEST=y
-------------------------------

This is a quick and naive smoke test for kprobes. It is intended to just
verify if some unrelated change broke the *probes subsystem. This needs
to be built in the kernel and runs a basic set of tests to verify if
kprobes, jprobes and kretprobes run fine on the kernel. In case of an
error, it'll print out a message with a "BUG" prefix.

linux/Documentation/kprobes.txt
linux/kernel/test_kprobes.c

Expected results:
Kprobe smoke test started
Kprobe smoke test passed successfully
