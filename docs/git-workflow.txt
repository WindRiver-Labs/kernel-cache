#1) High level workflow
=======================

These descriptions document the steps that are used to internally, externally
and system manage the open distro. Both git and other steps are documented.

phase1
------

 internal: how we work
 --------------------- 

   - looks like 2.0 with enhancements
   - manage the kernel tree via patches, quilt, wiggle, etc
   - export the tree to git via a publishing script
   - tracks major kernel RC and stable releases
   - trees are temporary and history will not be maintained
     between exported trees.
   - standard kernel only, limited tools support.
   - limited to selected BSPs.

 external: how the customer works
 --------------------------------

   - installs the DVDs for the build system and supporting tools
   - clones the Wind River published git tree, which has been exported
     externally (via DMZ or whatever)
   - TBD: either uses the smudge support to import a git tree or
          generates patches from that git tree. At some level it
          has to be the first option (git tree).
   - works against the git tree, ensuring that commits are contained
     into features and bisectable.
       - TODO: document this

 overall:  how both are generated and managed
 --------------------------------------------

   - customer generates feature based patches, submits them via a broker
     to Wind River.
       - git-patch, etc used to generated the diffs. Manually grouping
         changes into features.
   - broker puts the patches into our patch based kernels, patches,
     builds and boot tests kernel. commits changes to CVS.
   - Wind River periodically publishes new git trees with those
     integrated changes. If possible, it's just and update to a 
     previously published tree, but we shouldn't promise this yet.

#2) getting started using the build system
==========================================

  o checkout the edge layer and the 2.6.21 layer
  o configure a board build, specify:

       --enable-kernel-version=edge
       --enable-kernel=standard

  o change to the build directory, you now have to decide
    what type of working environment you need. 

     a) will you be creating a new repository
     b) will you be cloning an existing repository
     c) will you be starting with no base

   The answer to this question dictates the the value of the
   'kern_base' variable.
  
    The 'kern_base' dictates the foundation of the kernel. We'll apply
    patches and features on top of that base. The current choices are:
  
    none:    create a directory and the patching scripts will populate 
             the tree. output is a git tree.
    archive: extract a kernel tarball and apply patches on top of it. 
             output is a git tree
    git:     based on a named git tree, patches are applied to this tree.
             output is a git tree.

     a) kern_base=archive
     b) kern_base=<url or path to repo with 'git' somewhere>
     c) kern_base=none

  o if you are building a particular kernel type, make sure you
    specify the 'kern_profile' variable. 'standard' is the default.

  o configure your kernel
 
    make kern_base=<blah> kern_profile=<blah> linux

  o everything is patched and created in the 'linux' subdir. 
   
    NOTE: there is no version or no platform name in the linux
          subdirectory. since more than one platform/bsp/kernel
          can co-exist in a single directory

  o get help via 'make linux.help'

#3) getting started in stand alone mode
=======================================

  TBD/TODO

#4) use cases
=============

creating a repository:
----------------------

  audience: mainly internal
  steps:
  

merging patches from other git repositories:
--------------------------------------------

  audience: external and internal
  steps:


  #1) import the repo and gen the patch. note: this can be
      done with two calls instead of one.

    general:

     > wrgit-import.sh -d <depth> -i "treeish" -p <patch name> <repo>
 
    example:


     > wrgit-import.sh -d 100 \
        -i "bfa274e2..cb9069e5" \
        -p links/opt/HEAD/layers/wrll-linux-edge/dist/linux/patches/arm/2.6.25/linux-omap-2.6.25-rc3.diff \
        /opt/kernel/git-trees/linux-omap

TODO: drop most of the -p and run wrgit-persist.sh to relocate
TODO: try this with remote omap repo

  #2) resolve any issues

    guilt-push -f
   
       <merge via your technique of choice>
 
    guilt-refresh

  #3) add the patch to the associated smudge file.
      
     TODO: make this automatic ...

    general:
       > mkdir wrs/cfg/<path to smudge>
       > vi wrs/cfg/<path to smudge>/<blah.smudge>
         <add smudge commands, tags, etc>
       > wrgit-checkpoint.sh -b internal -r -t abs_base -d wrs
       > wrgit-extract.sh -p -c -o <destination> -x <prefix to remove from patches>
  
     example:
       > vi wrs/cfg/opt/HEAD/layers/wrll-linux-edge/dist/linux/ktypes/rc/rc.smudge

           dir ../../patches/arm/2.6.25
           patch linux-omap-2.6.25-rc3.diff
           tag linux-omap

       > wrgit-checkpoint.sh


    Extract the patch and put itin the persistent store.
      TODO: make the persistent store a configured and read variable
      TODO: move some functionality to the wrgit-persist.sh script

       > wrgit-export.sh -v -p -c -o /tmp/blah -x "links/opt/HEAD/layers"

          # check status, via diff (or whatever) and then sync to your
          # external patch repository

       > wrgit-export.sh -v -p -c -o /opt/HEAD/layers -x "links/opt/HEAD/layers"

  variant: using commits

       wrgit-import.sh -c -i <commit ids> <repo>

------------------------------

wrgit-import.sh -d 100 -i "bfa274e2436fc7ef72ef51c878083647f1cfd429..29e8c3c304b62f31b799565c9ee85d42bd163f80" -c -v /opt/kernel/git-trees/linus/linux-2.6/
guilt push -a

-------------------------------


Backing out patches:

  guilt-pop
  guilt-delete -f <patch>


------------------------------

pushing updates from edge layer (outside of tree) into repo

--------------------------------

 1331  git-tag wrs_rc_top

git-am /tmp/zedd.mbox

# find first and last commit

1335  git-rev-parse wrs_rc_top
1336  git-rev-parse HEAD
1338  git-rev-list wrs_rc_top..HEAD


wrgit-import.sh -i "wrs_rc_top..HEAD" -c
guilt-push -a


wrgit-classify.sh -c -x /opt/HEAD/layers/
wrgit-classify.sh -u -c wrll-linux-edge/dist/linux/patches/bsp/cavium/cavium.smudge
wrgit-classify.sh -u -p platform -p kconfig-fpu_stats wrll-linux-edge/dist/linux/patches/bsp/cavium/cavium.smudge


# multi BSP

 1480  guilt-branch cgl
 1481  guilt applied
 1482  git branch
 1483  git-diff rc..cgl
 1485  guilt pop -t wrs_rc_top


