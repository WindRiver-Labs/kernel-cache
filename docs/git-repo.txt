suggested git management techniques
-----------------------------------

  o standard kernel is the master tree.
  o cgl/preempt_rt maintained as branches with remote tracking
    to the standard kernel tree
  o push/pop + commits to do in-place updates of existing features
    to maintain atomic and complete history
  o rebase to kernel.org for standard kernel
  o rebase to standard kernel for enhanced trees
     - patches are resolved using the tool of your choice
  o generation of repository from patches in edge layer
     - directly supported by smudge and guilt

design discussion:
-----------------

   - hybrid. not all git, not all quilt.
       - uses git, guilt and smudge

   - ship a git tree with branches and tags
       - branches at major junction points, i.e. kernel typees
       - branches show all valid combos of patches (i.e. kernel.org+rt+hrt)
  
   - ship a second git tree (or branch) with all the patches as peer
     commits to reconstuct a branch

   - can be used for both internal and external patch mangement while
     keeping feature separation.

       - doesn't require conversion from git -> patches on the way out
         and patches -> git on the way in.
       - keeps feature separation and allows popping of features
       - allows work to be done in git and new trees imported
       - scripts provided to assist the deconstruction and reconstruction
         of branches
       - completely reconstructed from time to time

   - work flow to pop a feature out completely:

       - create a branch at the feature being updated
       - replace feature of question with fixes or new feature
       - run script to pull all patches that were above that feature
         and pull them into the new branch 
               - could be cherry pick to the feature tag and move to
                 the new branch.
               - runs smudge against the secondary git repository to
                 assist conflict resolution and alternative suggestions
               - generates patches that can then be imported to the new
                 branch
       - commit new feature + updated features on top

   - work flow to allow a custom feature update and fixups
       - branch back
       - run smudge as we do in 2.0, it finds ctx mods, exclude, etc.
       - reconstruct the branch, any broken patches must be resolved
         via wiggle or whatever.
       - create your ctx updates and fixes.
       - create a branch point at an updated feature (a ctx_mod), insert
         the fixed feature. keep the rest the same. creating the new branch/tag
         points to create small deviations from a larger more main branch
            - i.e. a BSP can replace busted feature, branch off for it, but
                   rejoin the 'standard' kernel branch.

   - scripts to generate the branched tree from the git patch blob
       - indicate tags (or auto based on feature)
       - indicate branch points (explicit)
       - all existing smudge commands work.

   - allows the use of zillions of git addons for visualizing things

   - optional integration with quilt


February 28th, repository design update ...
===========================================

building:

  - can be built standalone or in the build system

branches:

  - 1 branch per kernel type
      - standard kernel is the master branch, other branches
        are either constructed by smudge or by guilt-branch

      - the construction method of the branch dictates how they
        are kept up to date and how the differences in kernel 
        types impact patch substitutions
  
  - 1 branch per/bsp per kernel type
      - bsp branch from 'standard' kernel is the master
      - changes are not duplicated in the many branches, see
        'keeping up to date' for the details

  - 1 branch per remote kernel type
      - i.e. linux-next, -mm, etc

  - 1 branch with all BSPs merged, this ensures that they
    will all play nicely together.

  - dynamic branches. created as a one off to test a patch
    series.


patches:

  - patches are still required to track the commits and
    features in git as the 'persistent store'. This faciliates
    deconstructing and reconstructing the tree and branches.
    They also keep history clean, allow feature based bisection
    and keep changes contained.

  - patches are extracted from the repoistory via wrgit-extract.sh
    and can be maintained separately from the main tree.

tags:

  - most features are tagged on a per kernel basis 
  - each BSP start/stop is tagged on a per kernel basis
  - each kernel type has the bsp branch point tagged

keeping changes up to date:

  - the tree is managed and updated via guilt, smudge and
    supporting scripts

  - guilt:
      - pushes and pops patches from a branch. Allows a 
        complete feature to be pulled out and updated
        and existing patches to be re-pushed
      - patches should be saved before popping or deleting
 
  - guilt-rebase:
      - used to keep guilt based branches up to date.
      - if guilt has been used to pop/refresh and push
        a baseline branch (like 'standard'), then those
        changes need to be propagated to other branches
        via guilt-rebase. 

           - the rebase will pop local patches to the branch
             copy the new patches from the updated branch and
             re-push the entire branch. fixups will happen
             during the push and should be refreshed and saved

   - smudge-rebase:
      - used to keep smudge + guilt based patches up to date
      - if a baseline branch has been updated, it's patches
        and associated smudge files should be exported to 
        the internal branch (and hence 'wrs' working dir) for
        reconstruction of other branches.
      - smudge then runs accross the patch pool and builds 
        a series.
      - the existing branch is torn down, local patches merged
        into the series and the new branch constructed via
        guilt

  - patch series/context difference management.
      - git branch based. 

        a context difference in a patch or a patch being removed
        from a series in a dependent branch needs special 
        construction. these are a slightly more permanent version
        of a 'dynamic' branch

        in this model, the feature being mod'd or removed, would
        have a branch created before that feature, and then the
        replacment/update (or removal) done, and then the parent
        branch merged again starting from the tag on top of the
        modified feature. conflicts resolved, etc.

      - smudge based

        same problem, except rather than doing a branch and
        merge, a base branch is created as a peer to the 
        kernel type being modified. smudge is run to generate
        the patch list to build that branch.

        guilt then pushes the patches to create the branch.

  


