
This document exists to address the differences (and similarities)
in the kernel configuration for what is coming up in wrlinux-3.0 vs.
what was in wrlinux-2.0

Overview:
=========

If you haven't read my other 00-README-1st file in dist/linux that gives
an overview of how the patching and git is involved, and how there is
a kernel-cache of patches, then stop now and go read that 1st.

The two scripts that were doing what they did in 2.0 still exist somewhat.
These are still called generate_cfg and kconf_check

The "generate_cfg" simply is responsible for assembling the fragments
into a single file, and doing some basic sanity checks on the input along
the way.

Then there is "kconf_check" which does some checking on the final ".config"
as generated by LKC (Linux Kernel Configurator, i.e. what ships from
kernel.org).  It checks to see if you got most of what you asked for, if
what you've asked for actually exists in a Kconfig and so on.


			The Changes:
			============

These scripts are relocated from dist/linux/* to tools/kern_tools/*

Static data (i.e. the sorted list of Kconfig files, and the classification
of each as hardware and non-hardware) has been relocated from dist/linux
to the kernel cache, in ktypes/wrs_base/*  -- This data needs to be along
side of the kernel patch cache, since the list of available Kconfig files
is directly tied to what patches have been applied.

This static data has been renamed into the following four filenames:

hardware.kcf
non-hardware.kcf
hardware.cfg
non-hardware.cfg

The 1st two are the lists of hardware and non-hardware Kconfig files, which
provide roughly 95% of the sorting for us.  Overrides or exceptions to the
Kconfig sorting are put in the latter two -- the presence of a CONFIG_FOO
in one of these files would indicate that CONFIG_FOO is to be treated as
hardware/non-hardware independently of the Kconfig file for which it is
found in.

This naming convention is not unique to this directory.  In fact these same
four file names are looked for in any feature where there is a config
fragment.  So, if you add feature X, and it introduces a Kconfig, and
some options within that are mixed, (i.e. both hardware and non-hardware)
then you can classify them as such.


Specifying a Config fragment / Config fragment naming:
======================================================

We no longer force you to have your config fragment named "knl-base.cfg"
or "knl-<version>.cfg".  Instead, you explicitly call out your fragment
name in the scc file (i.e. smudge file/patches.list replacement -- see other
README if you don't know what an scc file is).  In addition, you are no
longer limited to just a single fragment per feature/bsp directory.  You
could in theory have the basic CPU settings in one fragment, and then the
MTD settings in another, and so on. (Don't go crazy and create 30 of them
when there is no real value in doing so).

The other part of specifying a config fragment, is that you are to indicate
whether it is hardware or non-hardware related content, i.e.

kconf non-hardware wrs_base.cfg

or

kconf hardware omap.cfg
kconf non-hardware omap-no-ext2fs.cfg

The idea here is that folks with PCD BSPs who wish to tune their non hardware
options from within the BSP (i.e. typically to reduce footprint) can do so.
Taking the above example, they could turn off ext2fs support, and since
they've classified the fragment as non-hardware, it won't be subjected to
the hardware-specific BSP audit that the main omap.cfg fragment would be.

Note that the presence of the kconf line in the scc file is what triggers
the processing of the four classification files listed above (the kcf and
cfg files).  So, if you have a feature, and it has Kconfig options which 
you need to classify, but your feature doesn't want to explicitly set the
values of those options (say for example, you add unionfs, but want the
kernel type to specify if it is on, or off) then you can just add an empty
config fragment to ensure those four (or any subset of the four)
classification files.


Migration of fragment data into the git tree:
=============================================

One of the requirements for 3.0/OpenDistro is to have it so that the final
published/generated git tree is sufficiently stand-alone so that a person
could actually configure and build a kernel from our git tree, by just
having the git tree itself, i.e. no surrounding build system.

To make this possible, it means that all the data associated with the
kernel fragments needs to be migrated from the kernel cache (which is
not present when you just pull/clone a generated tree) and put into
the git tree somewhere.

This data migration is automatic, and takes place when the tree is generated.
As the meta-series is processed, and branches are created, the config
fragment data associated with those branches is migrated from the kernel
cache into the git tree at linux/wrs/cfg/kconfig/  -- with the directory
structure of the kernel cache kept intact as subdirectories under this
directory in the git tree.  This migration includes the named fragment
and any of the four classification files if they are present.

Note that these files are now the authoritative copies used when configuring
a kernel with "make linux.config" -- as the git tree itself needs to be
stand-alone and not reference back to the kernel cache content.


When Things Happen:
===================

The linux.patch rule is responsible for creating the meta-series (via scc)
for that BSP/branch, and within that meta-series is where the kconf lines
from your original scc files are hooked in (by the scc program itself).

There has been a rule added to the dist/linux/Makefile called "linux.rescc"
which will go and regenerate the meta-series based on any changes that you
may have made to the underlying scc files (again the scc files within the
linux/wrs dir are the authoritative copies at this stage).

The next thing that happens is that "kgit-meta --init" is responsible for
walking the meta-series and doing the data migration mentioned above for
each fragment and its possible classification files.  No processing takes
place at this point.  It is strictly data copying.

The next thing to happen is from the linux.config dist/linux/Makefile
rule -- this invokes "kgit-meta --kconf" which then creates the BSP
specific dir in linux/wrs/cfg/kconfig/<BSPname>-<kerntype>/ by determining
the final branch name of the meta-series.  In this directory, it creates
three files, config_frag.txt, hdw_frags.txt, and non_hdw_frags.txt, which
are respectively: 1) all the config frags specified in the meta-series,
2) the fragments that were explicitly listed as hardware specific, and
3) the fragments that were explicitly listed as non-hardware specific.

Finally, "kgit-meta --kconf" ensures we check out the proper branch that
matches the BSP we want to configure for, before passing things back to the
Makefile for the remaining config processing.  We don't know what branch
the tree may be on -- the linux.patch rule currently switches back to
wrs_base.

Upon returning to the Makefile, the generate_cfg script takes all the
fragments listed in config_frag.txt and starts putting them together
in that order -- while auditing for some of the more common errors, and
puts the final concatenation of them in with the other kconfig data,
i.e. kconfig/<BSPname>-<kerntype>/<BSPname>-<kerntype>-config-<version>
This concatenation is then symlinked to the top of the build, so the
file is present as per what was done in the 2.0 WR release.  Also, as
per the 2.0 release, this file is for informational purposes only, and
changes should be made to the individual fragments and not this file.

The next thing the Makefile does is run LKC's make defconfig, but with
the defconfig source being the concatenation of the fragments.  Note that
in the past, we replaced arch/*/defconfig with the concatenated fragments,
but now we don't do that, as it would create a change in the source tree
that git would want to track if we did that.

With the above done, we now have a ".config" in the build tree (not
the source tree), and so the final step is to run the "kconf_check"
script and do the audit on the final output.  Once again, the most
important thing out of the audit is the check for items specified in
a fragment, but not making through LKC and out into the final .config
because of some dependency problem or similar -- do watch for those
as it can save you a lot of pain and debugging.


Config fragment order:
======================

The ordering of the config fragments (which dictates precedence in the case
of overlapping settings for CONFIG items) used to be dictated by a mix of
template ordering and a general trend from least hardware specific down to
the most hardware specific -- and this logic was all buried within the
generate_cfg script.

The overall rule of "he who sets it last, wins" still remains.  Meaning that
the last fragment to set CONFIG_BLAH is the one that will be processed.

The ordering is now completely controlled by the order in which the scc files
are processed -- there is no longer any logic within generate_cfg that
dictates arch before board, or similar.

Also, we used to have the ability to source a config fragment from the
top level build directory as the absolute last fragment (i.e. highest
precedence -- could override anything).  Since fragments are now listed
within an scc file, this functionality is no longer.  Should the need
present itself, we could look to processing an scc file from the top
level build directory, or something of that nature which would restore
similar functionality.


Content and Location of Auditing Data:
======================================

The general auditing of kernel fragment content is still mostly the same,
meaning the end goal is to ensure that the kernel types set the global
non-hardware specific features, and that the BSPs set all the features that
are hardware specific.

The output of the scripts used to live in a directory in the kernel tree
called "kconf" in the 2.0 product.  It is still in the linux source tree
(note the kernel now has separate source and build trees) but now it is
in the dir linux/wrs/cfg/kconfig/<bsp_name>/

One addition to the auditing is that now the common user error of incorrectly
specifying the syntax of an "off" option will now generate a warning.  To
be more specific, an option "CONFIG_WALLY" in a .config file is only a
valid line for turning that option off, if it reads exactly as:

# CONFIG_WALLY is not set

The common user error is to assume that the leading "#" mark means the line
is commented out (as per basic shell syntax) and hence the following text
is irrelevant.  However this is not the case.  LKC will ignore the line if
it does not have the exact " is not set" suffix.


Shared Kernel Config Data Across all Kernel Types:
==================================================

One thing that we did not have in 2.0 was an easy way to share config items
across all kernel types.  Meaning that if an item (say "CONFIG_NFS=y") was
to be on for standard, CGL, PCD, etc. then it was repeated in the config
fragment of each kernel type.

Now we have the concept of a wrs_base -- which is essentially a branch off
the default kernel version of choice, and this branch is the parent of all
the next tier of branches, which is the branches for each kernel type
(again, standard, CGL, PCD, ...).  The advantage this gives us, is that
wrs_base exists in the same way as all other kernel features/branches, and
as such, it can have a wrs_base.scc and that scc file can have a kconfig
fragment.  At the moment that fragment is relatively empty, but the plan
is to migrate common config items (like the NFS example, or CONFIG_NET etc)
out of the fragment for each kernel type and list it only once in the
wrs_base.cfg

Config Fragments for Other Kernel Types:
========================================

In the stage1 carry forward of the basic kernel configuration data of
the existing BSPs, the fragment associated with the 2.0 BSP top level
config (i.e. standard kernel type) was carried across from the 
wrlinux/templates/board/<bspname>/knl-base.cfg and put into the kernel
cache repo, and given the name bsp/<bspname>/<bspname>.cfg

If the 2.0 BSP had sub-fragments associated with other non-standard kernel
types, (e.g. templates/board/<bspname>/kernel/cgl/knl-base.cfg) then this data
has not been carried forward.  That will be a task associated with finalizing
the up-rev of that BSP.

Similarly, if there were modifications to a config that were in an async update
and hence in wrll-linux-2.6.21/templates/board and not wrlinux/templates/board,
then as part of the carry forward, you will have to sync in those changes as
appropriate.

It is envisioned that other kernel types will be handled by way of having
either conditional clauses within existing scc files, or additional scc
files.  In either case, the handling of the type-specific fragment will
be from a kconf line in an scc file.  More details on this will be available
as the support for other kernel types is completely finalized.
