#1) Should I be patching a kernel ?

  Typically you should not be constructing a patched kernel as we
  previously did in 1.0 -> 2.0. The suggested work flow is to 
  clone the generated kernel tree, place it in:
  
    <kernel layer>/git/default_kernel

  The build system will clone that tree, check out the correct 
  branch and build your kernel.
  
  From the cloned tree, you can use guilt to work with the individual
  commits (see question #4). 

#2) How do I create a template / layer to patch or configure the kernel

  scc works in a top down, explicitly controlled mechanism for
  listing kernel patches and configuration. Expecting a set of 
  patches and configuration files to be included from an external
  template is somewhat against the design. We should attempt to
  complete describe what makes up the kernel, not expect bolt-on
  patches and configuration values to "just work".

  That being said, there is a way to do this AND to keep the
  mechanism for explicit control.

    TODO: may auto-include patches.list, that is TBD

  Technique #1: template

    Create a template with a linux subdirectory, just has we 
    always have for previous releases.

       > mkdir templates/features/my_feature/linux

    In that directory place your feature description, your 
    patch and configuration (if required).

       > ls templates/features/my_feature/linux

          version.patch
          my_feature.scc
          my_feature.cfg

    The .scc file describes the patches, configuration and
    where in the patch order the feature should be inserted.


       # scc.section FINAL

       patch version.patch
       kconf non-hardware my_feature.cfg

    There are three sections which can be referenced for 
    patches: INIT, MAIN, FINAL

    INIT: your patch goes before any other patches (use carefully)
    MAIN: the body of the patch series
    FINAL: your patch goes at the end of the branch (suggested)

    'scc --help=scc' has additional information.
  
  Technique #2: kernel-cache with the BSP name dup'd

    TODO: xxx

  Technique #3: how do I add something to the kernel-cache

    Normally you don't have to. But if for some reason you do, then
    the following needs to be done:

     - 

#3) Something broke, how to do I submit a change ?

  See 00-README-submitting-patches

#4) How do I use guilt to manipulate the tree ?

  Ensure that you are using the patched version of guilt that ships
  with the kernel layer. It has been modified to work with our 
  directory structure and look for patch series in a configurable 
  location.

  Also ensure that you have READ the other other READMEs in this
  directory explaining how the git tree is constructed and maintained.

  And finally, make sure you've read the docs that come with guilt,
  online or in our tools build directory. The semantics of how guilt
  works have not been changed significantly and I won't repeat all
  of the common examples found in those documents.

  guilt works pretty much like quilt, push, pop, refresh, etc. You
  just get to leverage the advantages of being backed by a SCM and
  not having to remember to add files, etc.

  The thing to note is that our patch series is broken down into
  branches. Each branch only knows about the patches that were 
  used to construct it. That means that if you are working on a BSP
  and need to manipulate patches that impact that BSP, work on the
  BSP branch. You can't see the standard kernel patches from that
  branch. 

  If you want to work on the standard kernel, change to the standard
  kernel patch and use guilt there. This is key. It enforces the 
  scoping and encapsulation of the patches. Once you have worked on
  the standard kernel branch, you must propagate those patches to the
  BSP branches. 

      git checkout standard
        < work on standard kernel>
      git checkout my_bsp-standard
      guilt rebase standard

  And you'll have a rebased copy your new standard kernel patch on
  you BSP branch. Build and enjoy. 

  Of course you may have conflicts, during the rebase, and you'll 
  need to resolve those conflicts.

  This workflow involves extra steps, you are of course free to 
  work directly on your BSP branch to speed up testing of commits.
  When you send patches for inclusion, they'll be rebased against
  the appropriate sub branch.

#5 How can I build an arbitrary branch + my patches at an arbitrary branch point ?

  There are a few options which are defaulted by the build system:
  
      - kernel profile
      - build branch
      - branch point

  To build against an arbitrary tree, with your own patches, branching at
  an arbirary point you simply need to supply these values manually.

     - kernel profile: place a ".scc" file in the kernel cache or another 
       location where the build process can search for (and find) it. 
       Specify patches and configuration in this file.
     - build branch: pass the "ktgt" variable. Ensure that this branch 
                     exists in your cloned tree, or that your profile
                     creates the branch
     - branch point: if you don't want to work off the end of your build
       branch, then pass the "kver" variable to indicate the branch point.

  An example invokation using these options is:

     > make ksrc=/opt/kernel/git-trees/linux-2.6 kprofile=my_kern ktgt=master 
            kver=v2.6.27-rc1 linux.patch

  Make sure you have some configuration fragments available or you'll get
  and undefined build.


    
