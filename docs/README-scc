scc
------

 'scc' is the script / logic that controls the selection of the
 kernel patches passed to the build system during the kernel
 patching phase.

 It provides the following facilities:

   - top down / feature based control of patches. this allows 
     a feature/profile based global view of functionality and 
     compatibility to dictate which patches should be applied.
     it also allows feature/arch specific patch context mods to 
     be created by each individual feature.

   - feature inheritance and shared patches. each feature may
     explicitly include the features and inherit their patches.
     each feature can then modify the inherited patches list and
     substitute slightly different patches to work in their
     context. This allows the sharing and reuse of patches by
     only changing the minimum amount/context of existing
     feature patches.

   - allows upstream, feature based patches to be logically 
     grouped and used in many different patch stacks. This
     allows isolation and combination testing of features and
     allows a single set of patches to be used in multiple
     platforms. 

     modifications to a feature patch set are contained in the
     modifying top level feature's directory, leaving the
     original patch in it's pristine form. These are called
     "patch context mods" and can be architecture or feature 
     based.

   - automatic inclusion and searching of bug fix patches. 
     patches placed in search-able directories (see below for
     the list) are considered based on their scope and 
     severity for inclusion in the explicit feature based
     patch descriptions. This allows and invasive feature
     (e.g. RT) to control the amount of churn and context
     merge problems it encounters by patches that do not
     impact their core functionality.

   - wildcard or version specific patches are supported to
     allow patches to be carried automatically from kernel 
     revision to kernel revision. wildcard patches are found
     in "2.6.x" directories while version specific patches
     are in directories like "2.6.19".

   - direct mapping of published kernel feature compatibility
     profiles to named patch stacks.

 Normally all interactions with scc are hidden and it should
 rarely be invoked from the command line.

what's a good patch?
--------------------

   - upstream submittable
   - bisectable. meaning if there are multiple parts, each one
     can apply and compile individually.
   - properly #ifdef'd. If the board touches common code and
     might not be safe for all archs and boards, make sure it
     can be completely compiled out of the code and selected
     by Kconfig where appropriate.
   - don't modify the upstream patch, create a patch context mod
     that has our fix. This allows me to merge a new version
     of the patch and not clobber your changes. It also allows
     the patch to work in many different patch stacks.
   - shared and categorized where appropriate. if many boards
     will use the patch, put it in a common location. PaulG
     is doing an example for this.
   - using the newly defined patch header to indicate
     their scope/severity
   - same rules apply as PaulG has published. If you are 
     importing or forward porting a patch for a board make 
     sure it's the minimum amount for the fix. Don't change
     an entire subsystem, port the driver to the 2.6.20/21
     version of the subsystem. 
   - tested. don't break the patching of every kernel if you
     can possibly avoid it.

the patch header
----------------

To be searched and automatically included into the appropriate patch stacks,
all patches must have a standard header.

This header is very similar to what you'll use when sending a patch
upstream, hence should seem familiar.

All of the sections are mandatory, but the only items that are Wind River
specific are the 'wrs_severity' and 'wrs_scope' fields.  These two fields
allow patch descriptions/stacks to limit their exposure to disruptive changes
that do not impact their functionality.  The possible values for these fields
are at the end of this README under the 'scc --help' section.

---snip---- 8< ---- 8< -----snip---------

<patch description, suitable for a change log, not too long>

Signed-off-by: <1st person to blame>
Signed-off-by: <other people to blame, i.e. the reviewer>
---

   <diffstat>
   <extra explanation: i.e. if this is the first patch
    in a series, explain what it does here. Any testing,
    any known problems, whatever go here>

--- 

<the actual diff>

---snip---- 8< ---- 8< -----snip---------

patch header example (stolen from Andrew Morton):
-------------------------------------------------

      Another few #if/#ifdef cleanups, this time for the PPC architecture.

      Signed-off-by: <bruce.ashfield@windriver.com>
      Signed-off-by: Paul Gortmaker <wally.gleemer@windriver.com>
      ---

       25-gleemer/arch/ppc/kernel/process.c                    |    2 +-
       25-gleemer/arch/ppc/platforms/85xx/mpc85xx_cds_common.c |    2 +-
       25-gleemer/arch/ppc/syslib/ppc85xx_setup.c              |    4 ++--
       3 files changed, 4 insertions(+), 4 deletions(-)

      --- 25/arch/ppc/kernel/process.c
      +++ 25/arch/ppc/kernel/process.c
      @@ -667,7 +667,7 @@ void show_stack(struct task_struct *tsk,


how the patches are organized
-----------------------------

 <kernel cache goes here>
  

scc example(s)
-----------------

In the most simple example, scc files look very similiar to the
patches.list of previous releases. Once notable difference would 
be that the meta data concerning the licenence, source and reviewers
of the patch are contained inside the patch itself and not in 
the scc file itself. This information can of course be in the 
scc file, but only as a secondary source of information.

All of the "scc files" used as examples below can be placed
in many locations that scc recognizes as valid locations
for scc feature files:
  
  - any subdirectory listed in dist/linux/scc.dirs. these
    are commonly called "system directories"
  - any directory passed to scc via the command line
    option --fdirs. This is transparent and is handled
    by dist/linux/Makefile. It will include templates,
    layers and other location specified to configure.
  - board template directories

Outside of these directories, patches.list should be used.
 
Example #1: static list of patches 

  # the "dir" command indicates that all patches should
  # take this subdirectory as a prefix, until the next
  # "dir" directive is hit. Directories are relative to
  # the scc file.
  dir tools/2.6.x

  # "patch" indicates that a particular file should be 
  # returned as part of the patch list
  patch pagemaps.patch

  dir mips/2.6.x
  patch mips_endian_compile_flags.patch

  dir ppc/2.6.x
  patch ppc-booke.patch
  # IEEE-754I floating point implementation. Patches are
  # from http://patchwork.ozlabs.org/linuxppc/patch?id=9451
  # to http://patchwork.ozlabs.org/linuxppc/patch?id=9455 
  patch powerpcV2_DPFP_exceptions.patch  
  patch powerpcV2_embedded_floatingpoint_support.patch 
  patch powerpcV2_vectorSPFP_exceptions.patch
  patch powerpcV2_SPFP_exceptions.patch  
  patch powerpcV2_packing_denormalized_numbers.patch
  patch wrs_powerpcV2_math_emu_fix.patch
  
  dir shared/2.6.x
  patch a.out.patch
  patch nfs_rootfs_rpc_client.patch
  patch x86_64-build-fix.diff
  patch arm_parallel_build_fix.patch
  patch confdata-allow-reassign.diff
  patch wrs-powerpc-binutils-supression.diff
  patch hwtimer-api.diff

Example #1.1: static list using a scc variable

  At the bottom of the preceeding scc file, the 
  following could be adding to dynamically include
  another scc file for patch processing

  # now pick up any version specific patches, these
  # will override any 2.6.x patches of the same name.
  include patches_$KERNEL_VERSION

Example #2: scc file that includes others

  # patch profile "standard"

  # since smusge files are small shell scripts, dynamic
  # selection of includes is possible
  if [ "$KERNEL_VERSION" == "2.6.19" ]; then
      include rc
      include patches
  else
     include patches
     dir ../../patches/mips/2.6.20
     patch mips-2.6.20.diff
  fi

  include gcontainers
  include kmemleak
  include unionfs

Example #3: Fixing a context problem with a patch in another profile

  include standard
  include another_feature
  patch_trigger arch:all ctx_mod res_group_f0.8_single_2618.patch

  # this includes the standard feature and an additional feature
  # that causes the res_group_f0.8_single_2618.patch to fail to 
  # apply. This feature scc file can fix the context of 
  # res_group_f0.8_single_2618.patch and indicate to scc that
  # it should substitute the local patch res_group_f0.8_single_2618.patch
  # whenever it sees res_group_f0.8_single_2618.patch in the 
  # patch stack.

Example #4: excluding and fixing context problems on a per-arch basis

  dir ../../patches/tools/2.6.x
  patch linux-2.6.20-rc3-utrace.patch
  patch linux-2.6.20-rc3-utrace-powerpc-fixes.patch

  # for mips and arm remove the following patches from the patch list
  patch_trigger arch:mips,arm exclude linux-2.6.20-rc3-utrace.patch
  patch_trigger arch:mips,arm exclude linux-2.6.20-rc3-utrace-powerpc-fixes.patch

  # for other architectures, add the following context patch to the patch list.
  # The valid architectures match the build system variable: TARGET_LINUX_ARCH
  patch_trigger arch:i386,ppc,powerpc,ppc64,x86_64 ctx_mod linux-2.6.20-rc3-utrace.patch

Example #5: transforming a previously specified patch

  # we may not have the -mm patch for the latest rc, so apply a transform
  # to make sure we match
  patch_trigger arch:all transform /patch-2.6.20-rc[0-9]\.bz2/patch-2.6.20-rc4.bz2/

  # we don't want any mips.org patches either
  patch_trigger arch:all transform /.*mips-2.6.[0-9][0-9].*\.diff//
