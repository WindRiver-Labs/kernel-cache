
The Kernel and Git plus kern_tools Documentation 
------------------------------------------------

version 0.01a


Overview:
---------
Git, by nature wants to track things as they progress chronologically.  There
is no real feature separation - changes associated with one feature will be
mixed in with another.  But the WR kernel needs to present to the world, a Git
tree that has been built from the final version of each patch, grouped together
with all the other patches of that feature, rather than containing all the
internal development history that led up to that final patch data/sequence.

To achieve this, we will have a backing store (also provided by git) that will
track the changes to all the files/patches, in much the same way we have stored
patches in CVS up until now.  The patches will be pulled from this backing
store to build up a git tree with all the kernel features and BSPs of each
kernel type present on their respective branches.  The final tree will look
like a broccoli, with the trunk being the base kernel.org version, then the
base kernel types as main branches with their respective features contained
within, and then finally the BSP branches off of those.

This forward facing git tree will be automatically built from the latest
versions of the patches in the backing store, and due to the nature of git, it
will be rebuilt from the ground up whenever any significant changes to the core
backing store patches have occurred.  In "git speak" this means that when
feature X changes to X' --  we will be essentially rebasing everything that was
applied above/after X onto X' and blowing away all content associated with X.
As such, any constructed trees should be considered transient up until the
point when final product actually hits media for release.  The new tools within
./tools/kern_tools/ of the layer are scripts to help manage this duality
nature.

Initially, folks like BSP developers will be responsible for creating git
commmits on a branch (or branches) of the kernel type (or types) supported by
that BSP.  Once they have those commits on their local repository completed,
they can send those patches out for review using the normal process (i.e.
git-format-patch and git-send-email, with the wrs assistance wrappers, if
desired. Or optionally for large patch sets, allowing someone to do a
"git-pull" from your machine and BSP branch).  Once the patches have passed
review, a gatekeeper will handle the second part of the operation, which is
placing those patches into the backing store provided by kernel-cache such that
they will be incorporated into the next tree.

Changes to configuration - kernel config fragments, config.sh - or basically
anything that you wouldn't find in a kernel.org tree can be sent as git
diffs against the kernel cache. All other changes should be against the 
working tree, pretend you don't know that it came from a pool of patches
hiding in a separate git repository.

This document is designed to:

a) list the inputs and background information.
b) lay out how the execution flow takes place in building a kernel
c) list what each tool does as a part of this process
d) detail some common use cases that will assist in showing developers what the
anticipated work flow will be.


Inputs and background info:
===========================

Getting the tree:
------------------

You need either 2 or 3 git repositories in order to build the kernel.
The number of repositories varies based on the method used to import
the kernel.

  - kernel version layer: wrll-linux-2.6.27
  - kernel cache: kernel-cache
  - generated kernel: kernel-2.6.27

Start by getting yourself a copy of the kernel layer, and a copy of the backing
store archive of patches.  During development, these will be called
wrll-linux-2.6.27 and kernel-cache.  The latter is expected to be placed as
a subdir of the former -- i.e.

[xxx - update to final paths on Ala server -- these are temporary]

  cd my_path/to/layers
  git-clone git://yow-lpdgit/local/bashfiel/wrll-linux-2.6.27
  cd wrll-linux-2.6.27
  git-clone git://yow-lpdgit/local/bashfiel/kernel-cache
  cd git
  # ** the --bare is key. without this, you won't have the correct branches
  git-clone --bare git://yow-lpdgit/local/bashfiel/kernel-2.6.27 default_kernel

VERSION NOTE: At the point in time where the edge layer needs to continue
moving forward, but the kernel for 3.0 is chosen and fixed, then there will be
a creation of the wrll-linux-<version> layer and a backing store called kernel-cache
that clones and then forks from the edge content.  (i.e. to use a futuristic
example, say when the edge goes to move to 2.6.35-rc1 and commercial version
for wrlinux-7.3 is chosen as 2.6.34, then the two would be come separate
entities.)

The following examples assume you have put your unbundled toolchains that
you've used for your WR-2.0 work in the shared location of /opt/windriver/gnu
-- if not, then adjust the path specifications accordingly.

Start by getting yourself a clone of the basic kernel.org content, if you don't
already have one on your machine.  These are placed on the various git mirrors,
and it will be a building block for a lot of what you do, not to mention it
will save time and space when cloning the kernel.

--------
mkdir my_clones
cd my_clones
git-clone git://git.wrs.com/external/linux-2.6.git
--------


Building the Host Tools:
------------------------
Assuming you have the rest of the build system in place, you are now ready to
build the host tools.  You need to do this since there are additions in the
tools dir of the kernel layer that you won't have in your old host tools.  I tend
to set aside a separate dir and in that do a configure specifically for
building host tools and and do nothing else within that dir.  Following that
use model, you can do:

-------------------
cd /where/my_builds/are
mkdir h-tools
cd h-tools
/path_to/wrlinux/configure --enable-board=wrs_sbc8641d --enable-rootfs=glibc_std --enable-kernel=standard --enable-kernel-version=2.6.27 --enable-jobs=4 --with-toolchain-dir=/opt/windriver/gnu/ --enable-build-all-host-tools=yes
make host-tools
-------------------

Note the "--enable-kernel-version=2.6.27" part that is new.

If this all went well, then you should have a host tools tar bundle in your
export dir.  It is best that you probably unpack these into a shared location
as well, so that you aren't tying the host tools to a specific build directory
-- I'd suggest /opt/windriver for this as well.


Configuring for building a board:
--------------------------------
Now you are ready to configure for a board with shared toolchain and host
tools.  Lets start with a board that already exists as an example:

------------------
cd /where/my_builds/are
mkdir sbc8641d
cd sbc8641d
/path/to/wrlinux/configure --enable-board=wrs_sbc8641d --enable-rootfs=glibc_std --enable-kernel=standard --enable-kernel-version=2.6.27 --with-toolchain-dir=/opt/windriver/gnu/ --with-host-tools-dir=/opt/windriver/host-tools --enable-jobs=4
------------------

Note that we've replaced the --enable-build-all-host-tools with a location of
the shared location where we'd untarred the bundle we'd built in the previous
step.


Generating a Patched Tree:
--------------------------
As part of the workflow of a WR developer, you will now have two choices.
One is working from a published git tree that someone else has already
generated (there will probably be automatic nightly generations in the
future) and the other choice is simply patching up one yourself (which
will take slightly longer). ** This is the decision point mentioned earlier
that impacts which repositories you clone **

We'll assume that since you are probably working on the carry forward of a BSP,
that our primary interest is in building a kernel at this point in time.  As
such, your tree is now up to a point where you should be able to simply do a:

---------------
cd build
make ksrc=/path/to/my_clones/linux-2.6 linux.patch
---------------

and have it generate a git tree for this BSP in "linux".  Run some commands
like "git-branch -l"  and "git-tag -l" and "git-whatchanged
arch/powerpc/platforms/86xx" to get familiar with what exists.  Note the
availability of *all* the kernel history right back to when Linus started using
git (2.6.12-rc2) is now available right within your tree.  No more jumping
between a WR kernel tree and a kernel.org tree for comparisons.  The clone you
did above brought in all the base files, plus all their history -- much more
useful than what we got in the past from a plain tarball.

Also  note that even though we started with a BSP that already exists, there is
no real need at this point to have a separate git tree for each BSP patchset,
since we are storing each of them on their own branch.

Configuring a kernel:
---------------------
At this point, you can simply do a "make linux.config" and have the same
sort of kernel fragment processing take place that was happening in the
2.0 version of the product.  However, the location of the fragment data
and the output of the auditing that takes place has changed.  This is
covered in detail in the file 00-README-config -- found alongside this
file.  Also note that the ksrc you specified during the patch phase is
stored within your tree, so you don't need to specify it on further
steps like linux.config and linux.compile.

The other thing that you will first see once you configure a kernel is
that it will generate a build tree that is separate from your git source
tree.  This build dir will be called "linux-<BSPname>-<kerntype>-build"
where kerntype is one of standard, cgl, etc.  This functionality is
done by making use of the existing support that is within the kernel.org
tree by default -- it has nothing to do with the older "shadow" type of
separate build/source that was in the 1.x versions of the WR LPD product.
What this means, is that all the generated files (that includes the final
".config" itself, all ".o" and ".a" etc) are now in this directory.

Since the git source tree can contain any number of BSPs, all on their
own branch, you now can easily switch between builds of BSPs as well,
since each one also has their own separate build directory.


More Detailed Information on Variables, Scripts etc.
----------------------------------------------------

Lets look at some of the new things that you won't have seen before, like
the use of "ksrc=" to point at a git repository:

*) ksrc= 
---------
Basic use example:  Say you have a clone of the kernel.org tree in
~/git/linux-2.6 and this is to be used as baseline:

	make ksrc=~/git/linux-2.6/  linux.patch

Determine the source type for the base of the kernel (git/tar/etc) based on
what is passed in for ksrc.  Valid inputs are none/git/wgit.   Value is
stored in the ./cfg/ksrc of your tree so specifying it once at the initial
unpack will suffice. (Similarly, specifying an empty value will clear the
stored setting). 

A "git" is going to be one of the more preferred modes of operation.  In this
mode, the build system assumes you've pointed it at a suitable archive (be it
local or remote) which contains commits at least up to the baseline commit from
which the equivalent tarball would have within.  This repository will be cloned
to create the baseline tree and ".git" content that the WR build will be based
on.

A "wgit" is a git tree that has already been created by and used with the WR
build system -- in that it has a wrs/ directory with all the WR specific
content already in place. In this case, the tree will be used directly, and no
clone will take place.

If no value is set, then the default is to assume you have a suitable git tree
already available at wrll-linux-2.6.27/git/default_kernel/   This can be a
symlink to an existing on-disk git repo you already have, so long as it is
sufficiently up to date.


*) git_clone_opts=
------------------
Options given here are passed into the git-clone when the ksrc is git.
So valid inputs are a branch or tag name (e.g. v2.6.25).


*) LINUX_KERNEL_VERSION vs. LINUX_KERNEL_SRC_VERSION
-----------------------------------------------------
The difference here is primarily of interest between what the name of the
src package is vs. what is in the kernel's linux/Makefile itself.  For
example, you would have to be based off a 2.6.25 tarball while working through
all the 26rc-X releases leading up to the actual 2.6.26 release itself.

*) KERNEL_FEATURES
------------------
Taken from the config.sh if not supplied on the cmdline.  If no features are
given, then it defaults to TARGET_BOARD. (i.e. the branch to be constructed
will be the BSP branch for that board).

*) The ./wrs dir
----------------
This is the place for the various WRS specific bits that we need around to do a
build of the git tree, and to enable the tools which allow manipulation of
patches being worked on within an existing constructed git tree.  A more
detailed description of the files within is detailed below.

*) scc files, patches lists etc.
----------------------------------------
Generally speaking there are still scc files around that list patches for
features and BSPs.  One key difference is that the smudge files are essentially
compiled per feature, and then linked into a single executable that will patch
up from zero to the final leaf node of interest.  Also, file extensions for the
lists of patches will now be "foo.scc" instead of 2.0's "foo.smudge".

To this end, there is a "scc" that now does this task.  The other key point is
that there is a thing listed at the top of each scc file -- "scc_leaf" and
this indicates the parent of that leaf.  For example, a BSP that is supported
for the standard kernel type would be a leaf node (or branch) off of the end of
the branch created for the standard kernel type.  As such, it would contain the
line "scc_leaf ktypes/standard".

This hints at the next difference -- since we are now having the functionality
of patching up to a point A, branching and then continuing the patching to
point B, tagging etc etc.  we introduce the concept of a meta-series.  This
extends the regular concept of a series being a flat file of patch names to
also have embedded into that series file some basic state operations like tag,
branch etc.  The output of scc is such a meta-series.

=========================================================

Execution flow:
---------------

Sample command line usages of the tools are given where it can help understand
the use cases.  There may not be a need in most cases to run any of the kgit-*
commands, esp. if you are only generating and building a tree without modifying
or adding any patches.

As expected, the initial tree construction is all still hooked from linux
Makefile.  Inputs to the Makefile that didn't exist before were detailed above.

The linux.unpack rule calls kgit-init, which is responsible for getting the
base repo cloned in without any patches applied to branches, akin to what the
untar of the past does (if ksrc=tar).

kgit-init also sets up some dirs within wrs, and stores some data there that
will be used/referenced later.

The linux.patch rule spawns kgit-scc with the leaf node associated with the
kprofile -- which by default will be TARGET_BOARD.  This tracks down the actual
scc file associated with that leaf node, i.e.:

Command Line Example:
-----------
linux$kgit-scc -leaf wrs_sbc8641d.scc ../../kernel-next-cache              
../../kernel-next-cache/bsp/wrs_sbc8641d/wrs_sbc8641d.scc
linux$
-----------

This *.scc file is then fed to scc -- which in turn will walk backwards from
the tip/leaf node to the base of the tree, and process each scc file in turn
that it encounters.  Each scc file (e.g. "blah.scc" that is encountered
in turn will have a corresponding object file created ".blah.scc" (which may
also aid in debugging).  These objects are all then tied together by the file
./wrs/cfg/meta/obj/<leaf_name>   -- There is also a ".leaf_name.scc" which
actually created it (think of that as "main.o" to extend the C analogy).

The file  ./wrs/cfg/meta/obj/<leaf_name> is a shell script, that when run, will
actually generate the meta-series file itself.

Command Line Example:
-----------
linux$scc -e entry_point -o outfile_name -I../../kernel-next-cache/ ../../kernel-next-cache/bsp/wrs_sbc8641d/wrs_sbc8641d.scc
linux$ ls -l outfile_name *.o
-----------

The entry_point is akin to a ".globl start" to continue the gcc/gas analogy.
The above example creates the executable shell script outfile_name and the
"-I" tells it where to look for scc files, and the final arg is the base
scc file which the whole processing starts from.

The next step (still from the linux.patch rule) is to run the script and store
the meta series in ./wrs/cfg/meta/<leaf_name>-meta  -- and also into the file
./wrs/meta-series -- with the latter being the content for the most recently
run leaf node.

We say "most recently run" since now that BSPs are on a branch, there is no
fundamental reason as to why you can't have multiple boards within the same git
tree of your build, even if they aren't the board you configured for
originally.  Having other boards as branches within the same repo has lots of
advantages, one obvious one is to be able to use the git related tools directly
to compare how two different boards implement some feature.  Which brings in
the new make rule called "linux.addboard" -- this is essentially the same as
"linux.patch" but it overrides the default board name with the supplied board
name in the var kprofile.


Command Line Example:
-------------
make ksrc=~/git/linux-2.6/ linux.patch
make kprofile=fsl_imx27ads linux.addboard
make kprofile=fsl_imx31ads linux.addboard
make kprofile=fsl_imx31lite linux.addboard
-------------

We haven't quite finished describing the linux.patch rule yet -- there are two
more steps.  It does a "kgit-meta --init" on the meta series, which sets things
up in the ./wrs dir -- i.e. links in all the patches of interest from the
backingstore, and then finally "kgit-meta --apply" which actually processes the
meta series, doing the patching and branching as per the instructions laid out
in there by scc.  Note that since the whole point was to get this tree stored
in git that each patch that is applied is representative of a git-commit event.

In the process of running kgit-init and applying the patches, part of what is
put in the ./wrs dir is state information that will assist in working with the
git tree with quilt-like (i.e. guilt) tools.  Lets look at some of what is
created.

./cfg/<clone_of_tree_of_scc_files_from_kernel_cache>/ -- this starts out as
a copy of the scc files (with original absolute path directory structure
intact) that came from the kernel cache patch store.

./meta-series -- as per above discussion, the most recent meta-series file that
was created by a run of linux.patch or linux.addboard.

./wrs/scripts -- scripts like kgit-* and guilt-* are put here since a
requirement of the Open Distro is to have the ability to work on the created
git tree in a stand-alone fashion, independent of the whole WR build system.

./wrs/patches/ -- for every branch that is created from within a meta series,
there is a directory within here that contains the following: 

     1) a series file that really does just list in a flat file, the patches
that were applied between when this branch was started and when this branch was
finished (note -- a branch is considered finished when it has sub branches
spawned off of it -- i.e. "standard" is finished at the point when multiple
BSPs spawn off of that point.)

     2) a links dir that has initially symlinks from here back to the real
location of the patches listed in (1) in the kernel-cache patch store.  These
symlinks can be replaced with real files during operations on the generated
tree, akin to what was done with the symlinks of WR-2.0 when you did a
quilt-refresh.

     3) a status file that maps the git-commit IDs from the "kgit-meta --apply"
to the patch link that points at the patch in the kernel-cache.


======================== tool descriptions =====================


kgit
-----
Wrapper for sub-commands, as per what git does -- e.g. "git show" does what
"git-show" does.   Also can be used to test whether a git is WR generated git
vs. a generic git.


kgit-checkpoint
---------------
Takes all the listed untracked files (default is the wrs dir if unspec.) and
makes one uber commit that stores them all onto a branch.  Optional args are
the branch to commit on.  This is the behaviour of the default mode.  Tags are
created on either side of this commit (checkpoint_start and checkpoint_end).
In restore or "-r" mode, the index updates of the branch with the checkpoint
commit is "popped" while leaving the wrs content on disk, so that it
effectively returns wrs/ to an untracked state.


kgit-classify
-------------
If you have already assembled a kernel git tree via the "linux.patch" rule,
then you can use "kgit-classify ls" in your tree to see all the categories
(i.e. scc files) that were created -- this will include kernel types,
features and BSP(s).  Add a "-v" if you want to see the full path spec to the
scc files instead of just the basenames.  You can also dig down even deeper
to view the content of one of the listed scc files with the same command:

----------------------------
linux$kgit-classify ls bsp/wrs_sbc8641d          

dumping category details for: wrs_sbc8641d

--->--->--->--->--->--->--->--->--->
scc_leaf ktypes/standard

patch 0001-PHY-add-BCM5464-support-to-broadcom-PHY-driver.patch
patch 0002-phylib-factor-out-get_phy_id-from-within-get_phy_de.patch
patch 0003-gianfar-Determine-TBIPA-value-dynamically.patch
patch 0004-powerpc-Add-support-for-Wind-River-SBC8641D-board.patch
patch 0005-powerpc-Add-device-tree-source-for-Wind-River-SBC86.patch
patch 0006-powerpc-Add-defconfig-for-Wind-River-SBC8641D-board.patch
--->--->--->--->--->--->--->--->--->

linux$
----------------------------

Note that we've used the scc file as the input name -- not to be
confused with the BSP git branch name or git tag name(s).

The next use of this would be with "create" to create (or "rm" to delete) a new
classification.  This can be to create a class for a new kernel type (rare), a
new feature (less rare) and a BSP (most common).  All three are shown below,
where we create a new kernel type "uberkernel", a new feature "grsecurity" and
a new BSP for the Commodore64.

----------
linux$kgit-classify create ktypes/uberkernel.scc
[INFO] creating category config file 'ktypes/uberkernel.scc'
created category uberkernel.scc in ktypes/
created patch dir wrs/patches/wrs_sbc8641d-standard/ktypes
linux$ls -l wrs/cfg/ktypes/
total 0
-rw-r--r-- 1 paul wrs 0 2008-05-08 09:54 uberkernel.scc
linux$kgit-classify create features/grsecurity.scc
created category grsecurity.scc in features/
created patch dir wrs/patches/wrs_sbc8641d-standard/features
linux$ls -l wrs/cfg/features/grsecurity.scc 
-rw-r--r-- 1 paul wrs 0 2008-05-08 11:04 wrs/cfg/features/grsecurity.scc
linux$kgit-classify create bsp/commodore64.scc
created category commodore64.scc in bsp/
created patch dir wrs/patches/wrs_sbc8641d-standard/bsp
linux$ls -l wrs/cfg/bsp/
total 0
-rw-r--r-- 1 paul wrs 0 2008-05-08 10:54 commodore64.scc
linux$
----------

Note that by default both the scc file and the patches that implement
it both live in the same directory.  For features with only a few patches, this
is convenient.  But for things like BSPs which may have hundreds of patches, it
is nice if they are in a separate directory.  To achieve this you will want to
make use of 'kgit-classify create -o'. This is consistent with the layout that
was used in the 2.0 product release.

[ xxx To add: use of "-p" to add patches to a category ]


kgit-export
------------
xxx

kgit-import
-----------
xxx


kgit-init
---------
Similar to git-init, but checks if repo already exists, and if it is a Wind
River repo, or just plain git of kernel.org.  This actually spawns the
git-clone, if required,  makes sure the remote branches have a local variant of
the same name that track the remote ones, and creates the initial ./wrs dir and
content within.  Also creates the initial tag and create_stamp.

If the repo is an existing WR repo, with the wrs content "checkpoint"ed into a
commit, then the index data is popped from the commit list ("restore" mode) and
thus ./wrs is left in an untracked state.  Also, "kgit-export -p" is run.

Example command line usage that parallels the dist/linux/Makefile:
-----------
kgit-init -m boo -t wrs_git -o linux -b all:v2.6.25  /home/paul/git/linux-git/linux-2.6
-----------


kgit-meta
----------
A meta-series is created in ./wrs -- this file contains patches just as you'd
expect from guilt/quilt, but also has embedded commands within "#" style
comments. These commands are used to pass commands off to git etc. so that
branches and tags can be created, etc.  It is kgit-meta's job to run over that
meta-series file and from that, spawn all the embedded commands.


kgit-publish
------------
xxx

kgit-pull
---------
xxx

kgit-rebase
-----------
xxx

kgit-scc
--------
[xxx - this only gets used for --leaf so far in what I've seen; what else is it
responsible for?]

scc
---
Process a scc file into actionable items like patch, branch, tag etc.  Link
scc output into a chain of actionable items that will take a git tree from a
bare kernel.org clone into a fully patched BSP (or leaf node).  See the use
example in describing the execution path of the linux.patch rule.


======================== work flow examples =====================

-need here the following:


Creating a new BSP branch
=========================
Start by ensuring you've followed the intro steps above which got you to clone
a repo as a basis and configure the wrs_sbc8641d board.  This will have created
a git tree for you that contains the branch for the standard kernel.  Create a
branch off of this that matches your BSP name.  Lets assume you are working on
the commodore64 BSP.

----------
git-checkout -b commodore64 standard
----------

If you do a "git-branch -l" now, you will see that your new branch is marked
with a "*" indicating it is the active branch.  Start by working up your
patches off this branch.  You are free to use the tools of your choice -- be it
quilt, guilt, or just git itself.  The only requirement is that when you've
completed your task, that the patches you've created are each contained within
a git-commit that encompasses a reasonable group of functionality (see the
sbc8641d patches as an example).  This means doing a git-add of the files for
that commit, and then doing a "git-commit" of the added files.  Ensure you put
proper short and long descriptions in each commit message.

Note that before you've added any patches, if you run the following command:

----------
git-whatchanged standard..commodore64
----------

you will see that there is no commits shown as of yet.  When you are done
adding all your patches and have commits for them, the same command will show
you all the commits you've stacked on for your BSP.

Similarly, you can use the same branch names separated by dots for creating
your patch set that you wish to send out for review:

----------
git-format-patch -n --thread -o to_be_reviewed standard..commodore64
----------

This will dump all your created patches  (starting with the numeric prefix of
0001- and with threaded In-Reply-To headers) to the directory called
"to_be_reviewed".  Then you can use git-send-email (in conjunction with the wrs
helper wrappers) to send out your review request.


------------ [ xxx Workflow items to add:] -------

*) Adding a new patch or set of patches (a feature) into an existing branch,
which includes the classify etc and re-propagation back into kernel-cache
scc files etc.

*) updating or wholesale replacing a broken patch within an exisiting branch or
feature.

Presumably when I've done these, I will also have the info I need for the
above undocumented kgit-* commands.
