0) Introduction

Using this overview you should be able to obtain, build, boot, modify and
share the components that make up Wind River's open kernel. This document is
intended as a quick start and should not be a substitute for the more
detailed documents that accompany the entire open distro.

Assumptions:

  - DVDs of Wind River Linux 2.0 have been installed, including license keys,
    compilers and host tools

  - 2.0 supported host distribution and host compiler is available.

What you'll need:

  - git
  - wrlinux-edge.tar.gz of the Open Distro (edge) kernel layer
  - patch against 2.0 to add enhanced layer toolchain management

1) Overview

1.1 Building:

  - can be built stand alone or in the build system

1.2 Branches:

  - 1 branch per kernel type
      - standard kernel is the master branch, other branches
        are either constructed by scc or by guilt-branch
      - the construction method of the branch dictates how they
        are kept up to date and how the differences in kernel 
        types impact patch substitutions
  
  - 1 branch per/bsp per kernel type
      - bsp branch from 'standard' kernel is the master
      - changes are not duplicated in the many branches, see
        'keeping up to date' for the details

  - 1 branch per remote kernel type
      - i.e. linux-next, -mm, etc

  - 1 branch with all BSPs merged, this ensures that they
    will all play nicely together.

  - dynamic branches. created as a one off to test a patch
    series.

1.3 Patches:

  - patches are still required to track the commits and
    features in git as the 'persistent store'. This facilitates
    deconstructing and reconstructing the tree and branches.
    They also keep history clean, allow feature based bisection
    and keep changes contained.

  - patches are extracted from the repository and can be maintained
    separately from the main tree.

1.4 tags:

  - most features are tagged on a per kernel basis 
  - each BSP start/stop is tagged on a per kernel basis
  - each kernel type has the bsp branch point tagged

1.5 keeping changes up to date:

  - the tree is managed and updated via guilt, scc and
    supporting scripts

  - guilt:
      - pushes and pops patches from a branch. Allows a 
        complete feature to be pulled out and updated
        and existing patches to be re-pushed
      - patches should be saved before popping or deleting
 
  - guilt-rebase:
      - used to keep guilt based branches up to date.
      - if guilt has been used to pop/refresh and push
        a baseline branch (like 'standard'), then those
        changes need to be propagated to other branches
        via guilt-rebase. 

           - the rebase will pop local patches to the branch
             copy the new patches from the updated branch and
             re-push the entire branch. fixups will happen
             during the push and should be refreshed and saved

   - scc-rebase:
      - used to keep scc + guilt based patches up to date
      - if a baseline branch has been updated, it's patches
        and associated scc files should be exported to 
        the internal branch (and hence 'wrs' working dir) for
        reconstruction of other branches.
      - scc then runs across the patch pool and builds 
        a series.
      - the existing branch is torn down, local patches merged
        into the series and the new branch constructed via
        guilt

  - patch series/context difference management.
      - git branch based. 

        a context difference in a patch or a patch being removed
        from a series in a dependent branch needs special 
        construction. these are a slightly more permanent version
        of a 'dynamic' branch

        in this model, the feature being mod'd or removed, would
        have a branch created before that feature, and then the
        replacement/update (or removal) done, and then the parent
        branch merged again starting from the tag on top of the
        modified feature. conflicts resolved, etc.

      - scc based

        same problem, except rather than doing a branch and
        merge, a base branch is created as a peer to the 
        kernel type being modified. scc is run to generate
        the patch list to build that branch.

        guilt then pushes the patches to create the branch.
 
1.6 The properties of this repository are:

  - patch series -> git repository conversion.
     - History and commit blobs are created

  - git -> patch series conversion
     - fully formed feature divided patch series are created
     - division of patches into features is only as good as the git
       commits. Incremental submissions will show up as incremental
       patches and are of little use for reconstructing and grouping
       an entire feature.

  - git repositories can be used as patch sources, either
    directly or via the previously mentioned conversion(s).
     - cloning of the repository is not done by the build system.
     - the build system imports an already cloned repository as 
       a shared source
     - imports a particular tag or 'master'
 
  - contains patches from:
     - Wind River stable kernels
     - new kernel specific features
     - existing and new BSP support

  - history is partially preserved. no guarantee of permanent history
    being maintained. Since direct submissions from this repository
    to upstream sources are intended.
     - depending on the mechanism used to do block replacement and
       update of features, history may become cluttered and will be
       dropped.

  - the repository is generated from a series of patches. history
    is automatically generated from the contents of the patches.
     - both short and long log.

  - commits are grouped by feature and then subdivided to the 
    individual patches. 

  - incremental commits are avoided, multiple changes to a single
    file are maintained inside of their feature. Updates that belong
    as part of a lower layer feature, require upper level commits 
    to be removed, the feature updated (history changed) and the 
    upper layer features redone (or re-merged as the case may be)
      - i.e. pop commits, update, push commits, rebase superset
             git trees. 

2) Getting started

  2.1 Extract the Open Distro kernel layer:

    > cd <install>/wrlinux-2.0/layers
    > tar zxvf open-distro-kernel.tgz

   This layer provides:
  
     - host tools for the Open kernel git tree
     - meta information and persistent patch management scripts
     - build system hooks for working with the Open kernel tree

  2.2 Configure a build, via the mechanism of your choice, ensure that the
      following options are present:

     --enable-kernel-version=edge
     --enable-kernel=standard

   and that a supported board has been chosen. The list of 
   supported boards is separately published.
  
  2.3 Clone the Wind River open distro kernel into the default location.

    > cd <install>/layers/wrll-linux-edge/git
    > git-clone \
       http://opensource1.windriver.com/pub/git/Opensource.git windriver_kernel.git

  2.4 Build the host tools

    > cd <build>
    > make -C build-tools wiggle
    > make -C build-tools kern_tools
    > make -C build-tools guilt

3) Building a kernel
   
   > cd <build>
   > make -C build kern_profile=rc linux 

    This make target will clone the open distro kernel from step
    2.3, putting it in the 'linux' subdirectory. Check out the 
    appropriate branch and perform the build.

    To do a build for a specific BSP, the following should 
    be used:

   > make -C build git_tgt=<bsp>-rc kern_profile=rc linux 

4) Working with the kernel

   The kernel is managed via a hybrid git/patch queue mechanism to leverage
   the advantages of both models. Bare git commands can be used on a
   repository, but must be converted to the hybrid model before using any of
   the custom open kernel assists.

   The hybrid model is managed via a modified version of the host tool
   'guilt'. guilt closely matches the workflow of quilt, but leverages the
   advantages of having git back the patch application and manipulations.

     guilt          guilt-fold           guilt-new        guilt-rm
     guilt-add      guilt-fork           guilt-next       guilt-series
     guilt-applied  guilt-graph          guilt-patchbomb  guilt-status
     guilt-branch   guilt-header         guilt-pop        guilt-top
     guilt-delete   guilt-help           guilt-prev       guilt-unapplied
     guilt-diff     guilt-import         guilt-push
     guilt-export   guilt-import-commit  guilt-rebase
     guilt-files    guilt-init           guilt-refresh

   Wind River git repositories can be torn down and completely reconstructed
   by using patch meta data stored in a persistent location. This allows
   complete feature encapsulation, which in turn facilitates debug, and
   custom kernel construction. History is kept clean and fixes can easily be
   propagated to sub branches within a repository.

   Wind River git scripts are provided to ease the management of this meta
   data versus the active repository. Many of these scripts are invoked
   automatically by the build system and are not run outside of Wind River.

       kgit-apply   kgit-classify     kgit-import  
       kgit         kgit-checkpoint   kgit-export
       kgit-init    kgit-publish      kgit-meta

  4.1 work flow (guilt, rebase, etc)

   Work can be done in any number of ways:

     - edit and commit to git
     - import patches using git (git-apply, git-am, etc)
     - import patches using kgit-import (recommended)
     - ...

   Regardless of how work is done and committed to the repository, it must be
   converted to a format understood by the repository management scripts.

     - guilt-import-commit
     - kgit-import
     - ...

   And these converted and queued patches can be manipulated via:

     - guilt-push
     - guilt-pop
     - guilt-refresh
     - guilt-fold
     - guilt-new
     - ....

    4.1.1 import (TBD)
    4.1.2 push/pop/refresh (TBD)
    4.1.3 rebase (TBD) 

  4.2 publish, checkpoint, sharing

   In order to publish an in progress repository:

     > kgit-checkpoint
     > kgit-publish -d "Wind River Open Distro" \
            <src> <dest>.git

   Once published the existing repository can be resumed via:

     > kgit-checkpoint -r

   An in progress repository can be shared using standard git management
   techniques (git-pull, git-push, etc)

  4.3 re-animating of the clone to continue work

   If a clone of a checkpointed (and maybe published) repository is to
   be used as the basis for continued work, it must be reactived.

   reactivation can be done via:

     > kgit-init -b all

   and work may continue on top of the clone repository. If patches
   that were embedded in the cloned repository are to be pushed/popped
   then they must be extracted into the untracked "wrs" subdirectory.

     > kgit-extract -v -p -o wrs

5) Sending patches

   The standard git workflow for exported patches should be followed:

    > git-format-patch  

   or a branch can be created and a pull request issued.

6) Building userspace

  Building userspace is identical to the existing Wind River
  product. Updated kernel headers have been provided in the
  Open Distro kernel layer and will be automatically used
  when building a root filesystem.

  Note: only the glibc_std and glibc_small rootfs types are 
        currently supported.

