From 5cd9f0630702555229f5ffb3478eebdd80ec0f14 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Tue, 2 Sep 2008 15:14:30 +0800
Subject: [PATCH] af mercury

introduce mercury domain sockets, this is useful for efficient local
multicast datagram conmmunication.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
Signed-off-by: Harry Ciao <qingtao.cao@windriver.com>
---
 include/linux/socket.h           |    2 +
 include/linux/sysctl.h           |    7 +
 include/net/af_mercury.h         |  110 +++
 net/Kconfig                      |   10 +
 net/Makefile                     |    1 +
 net/mercury/Makefile             |    8 +
 net/mercury/af_mercury.c         | 1633 ++++++++++++++++++++++++++++++++++++++
 net/mercury/sysctl_net_mercury.c |   69 ++
 8 files changed, 1840 insertions(+), 0 deletions(-)
 create mode 100644 include/net/af_mercury.h
 create mode 100644 net/mercury/Makefile
 create mode 100644 net/mercury/af_mercury.c
 create mode 100644 net/mercury/sysctl_net_mercury.c

diff --git a/include/linux/socket.h b/include/linux/socket.h
index af309c9..ea3db0e 100644
--- a/include/linux/socket.h
+++ b/include/linux/socket.h
@@ -184,6 +184,7 @@ struct ucred {
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
+#define AF_MERCURY	27	/* mercury */
 #define AF_CAN		29	/* Controller Area Network      */
 #define AF_TIPC		30	/* TIPC sockets			*/
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
@@ -227,6 +228,7 @@ struct ucred {
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
+#define PF_MERCURY	AF_MERCURY
 #define PF_CAN		AF_CAN
 #define PF_TIPC		AF_TIPC
 #define PF_BLUETOOTH	AF_BLUETOOTH
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index 32ec458..011d468 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -247,6 +247,7 @@ enum
 	NET_LLC=18,
 	NET_NETFILTER=19,
 	NET_DCCP=20,
+	NET_MERCURY=21,
 	NET_IRDA=412,
 };
 
@@ -353,6 +354,12 @@ enum
 	NET_NF_CONNTRACK_CHECKSUM=32,
 };
 
+/* /proc/sys/net/mercury */
+enum
+{
+	NET_MERC_MAX_DGRAM_QLEN=1,
+};
+	
 /* /proc/sys/net/ipv4 */
 enum
 {
diff --git a/include/net/af_mercury.h b/include/net/af_mercury.h
new file mode 100644
index 0000000..0551e5c
--- /dev/null
+++ b/include/net/af_mercury.h
@@ -0,0 +1,110 @@
+/* 
+ * include/net/af_mercury.h, mercury surport
+ * 
+ * Copyright (c) 2006-2008 Wind River Systems, Inc. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ * 
+*/
+#ifndef __LINUX_NET_AFMERC_H
+#define __LINUX_NET_AFMERC_H
+
+#define MERC_ADD_MEMBERSHIP   35
+#define MERC_DROP_MEMBERSHIP  36
+
+#ifdef __KERNEL__
+extern void merc_inflight(struct file *fp);
+extern void merc_notinflight(struct file *fp);
+extern void merc_gc(void);
+
+#define MERC_HASH_SIZE	256
+
+extern struct hlist_head merc_socket_table[MERC_HASH_SIZE + 1];
+extern rwlock_t merc_table_lock;
+
+extern atomic_t merc_tot_inflight;
+
+static inline struct sock *first_merc_socket(int *i)
+{
+	for (*i = 0; *i <= MERC_HASH_SIZE; (*i)++) {
+		if (!hlist_empty(&merc_socket_table[*i]))
+			return __sk_head(&merc_socket_table[*i]);
+	}
+	return NULL;
+}
+
+static inline struct sock *next_merc_socket(int *i, struct sock *s)
+{
+	struct sock *next = sk_next(s);
+
+	/* More in this chain? */
+	if (next) return next;
+
+	/* Look for next non-empty chain. */
+	for ((*i)++; *i <= MERC_HASH_SIZE; (*i)++) {
+		if (!hlist_empty(&merc_socket_table[*i]))
+			return __sk_head(&merc_socket_table[*i]);
+	}
+	return NULL;
+}
+
+#define forall_merc_sockets(i, s) \
+	for (s = first_merc_socket(&(i)); s; s = next_merc_socket(&(i),(s)))
+
+struct merc_address
+{
+	atomic_t	refcnt;
+	int		len;
+	unsigned	hash;
+	struct sockaddr_un name[0];
+};
+
+struct merc_skb_parms
+{
+	struct ucred		creds;		/* Skb credentials	*/
+	struct scm_fp_list	*fp;		/* Passed files		*/
+};
+
+#define MERCCB(skb) 	(*(struct merc_skb_parms*)&((skb)->cb))
+#define MERCCREDS(skb)	(&MERCCB((skb)).creds)
+
+#define merc_state_rlock(s)	read_lock(&merc_sk(s)->lock)
+#define merc_state_runlock(s)	read_unlock(&merc_sk(s)->lock)
+#define merc_state_wlock(s)	write_lock(&merc_sk(s)->lock)
+#define merc_state_wunlock(s)	write_unlock(&merc_sk(s)->lock)
+
+struct merc_mcast
+{
+	struct sock *listener;
+	struct sock *addr;
+	struct merc_mcast *nextlistener;
+	struct merc_mcast *prevlistener;
+	struct merc_mcast *nextaddr;
+	struct merc_mcast *prevaddr;
+};
+
+/* The AF_MERC socket */
+struct merc_sock {
+	/* WARNING: sk has to be the first member */
+	struct sock		sk;
+	struct merc_address     *addr;
+	struct semaphore        readsem;
+	rwlock_t                lock;
+	int			is_mcast_addr;
+	struct merc_mcast	*mcastnode;
+	pid_t			pid;
+};
+#define merc_sk(__sk) ((struct merc_sock *)__sk)
+#endif
+#endif
diff --git a/net/Kconfig b/net/Kconfig
index 591dcac..2fb0655 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -61,6 +61,16 @@ config DGRAM_SOCKSTATS
  	  
  	  If unsure, say N.
  
+config MERCURY
+	tristate "mercury domain sockets"
+	default y
+	---help---
+	  If you say Y here, you will include support for mercury domain sockets;
+	  This is useful for efficient local multicast datagram communication.
+
+	  To compile this driver as a module, choose M here: the module will be
+	  called mercury.
+
 config INET
 	bool "Use native TCP/IP networking"
 	depends on !INTERPEAK
diff --git a/net/Makefile b/net/Makefile
index 4f43e7f..ecb0e2d 100644
--- a/net/Makefile
+++ b/net/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_NETFILTER)		+= netfilter/
 obj-$(CONFIG_INET)		+= ipv4/
 obj-$(CONFIG_XFRM)		+= xfrm/
 obj-$(CONFIG_UNIX)		+= unix/
+obj-$(CONFIG_MERCURY)		+= mercury/
 ifneq ($(CONFIG_IPV6),)
 obj-y				+= ipv6/
 endif
diff --git a/net/mercury/Makefile b/net/mercury/Makefile
new file mode 100644
index 0000000..35ec301
--- /dev/null
+++ b/net/mercury/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the Mercury domain socket layer.
+#
+
+obj-$(CONFIG_MERCURY)	+= mercury.o
+
+mercury-y			:= af_mercury.o
+mercury-$(CONFIG_SYSCTL)	+= sysctl_net_mercury.o
diff --git a/net/mercury/af_mercury.c b/net/mercury/af_mercury.c
new file mode 100644
index 0000000..16a090f
--- /dev/null
+++ b/net/mercury/af_mercury.c
@@ -0,0 +1,1633 @@
+/* 
+ * net/mercury/af_mercury.c, mercury surport
+ * 
+ * Copyright (c) 2006-2008 Wind River Systems, Inc. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ * 
+*/
+/*
+ * Aug 2004
+ * Clone & Mod of 2.6.7 unix sockets to allow for mercury semantics only:
+ *	-dgram only
+ *	-abstract namespace only
+ *	-multicast
+ *	-no fd passing
+ *	-we never wait for destination to have buffer space free
+ * 
+ * The basic idea behind mercury sockets is that we have essentially 
+ * two flavours of sockets; the ones that send/receive messages, and 
+ * the ones that simply act as addresses.
+ * 
+ * All mercury addresses must be in the abstract namespace.
+ * 
+ * When a socket is created, it can be used immediately to send 
+ * messages to any mercury address.  
+ * 
+ * To receive messages, ioctl() must be called on the socket with the 
+ * MERC_ADD_MEMBERSHIP command.  This looks for the address in question,
+ * and creates it if it does not already exist.  It then creates a listener
+ * node that links the address in question to the socket that is adding
+ * itself to the membership list for that address.
+ * 
+ * In this way, each socket has a linked list of nodes for each address in
+ * which it is a member, and each address has a linked list of nodes for
+ * every socket that is a member of that address.
+ * 
+ * A socket can deregister from an address by calling ioctl() with
+ * MERC_DROP_MEMBERSHIP.  This will remove the socket from the list of
+ * members for that address. If that socket was the only one registered
+ * for a given address, we also clean up the address itself.
+ * 
+ * When a socket is closed, it will automatically be deregistered from all
+ * addresses.
+ * 
+ * When sending a message, if any listeners received the message the return
+ * code will be 0. Otherwise, the return code will be an appropriate error
+ * number.
+ * 
+ * There is a wildcard address (a single asterisk, or "*") that will receive
+ * all messages.  This address does not count as a listener for the purposes
+ * of the above return code.  This means that a sender could get an error
+ * code even though a wildcard listener received the message.  The rational
+ * for this is that wildcard listeners are generally only used for debugging.
+ * 
+ */
+
+
+/*
+ *  SMP locking strategy:
+ *    --hash table is protected with rwlock merc_table_lock
+ *    --each socket state is protected by separate rwlock
+ *    --must always take multicast addr lock before process-owned socket lock
+ *    --if you must take socket locks and the table lock, take the table lock first
+ */
+
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/socket.h>
+#include <linux/un.h>
+#include <linux/fcntl.h>
+#include <linux/termios.h>
+#include <linux/sockios.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <net/sock.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/scm.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/smp_lock.h>
+#include <linux/rtnetlink.h>
+#include <net/checksum.h>
+#include <linux/security.h>
+#include <linux/tcp.h>
+#include <net/af_mercury.h>
+
+/* Turn this on to enable debugging of socket information.
+ * This is useful for tracking refcounts.
+ *
+ * #define DEBUG_SOCKINFO
+ */
+
+
+static struct proto merc_proto = {
+	.name	= "merc_sock",
+	.owner	= THIS_MODULE,
+	.obj_size = sizeof(struct merc_sock),
+};
+
+int sysctl_merc_max_dgram_qlen = 100;
+
+struct hlist_head merc_socket_table[MERC_HASH_SIZE + 1];
+rwlock_t merc_table_lock = RW_LOCK_UNLOCKED;
+atomic_t merc_nr_socks = ATOMIC_INIT(0);
+
+/* used to cache the data on the wildcard address */
+static unsigned wild_hash;
+static struct sockaddr_un wild_sunaddr;
+static int wild_namelen;
+
+#ifdef DEBUG_SOCKINFO
+struct sockinfo {
+	struct sock *sk;
+	char descr[100];
+	struct sockinfo *next;
+};
+
+struct sockinfo *allocated = NULL;
+rwlock_t alloc_lock = RW_LOCK_UNLOCKED;
+
+void del_alloc_info(struct sock *sk)
+{
+	struct sockinfo *info, *del = NULL;
+
+	write_lock(&alloc_lock);
+	info = allocated;
+
+	/* no entries */
+	if (!info)
+		goto unlock_out;
+
+	/* first entry matches */
+	if (info->sk == sk) {
+		del = info;
+		allocated = info->next;
+		goto unlock_out;
+	}
+
+	while (info->next) {
+		if (info->next->sk == sk) {
+			del = info->next;
+			info->next = info->next->next;
+			goto unlock_out;
+		}
+		info = info->next;
+	}
+
+unlock_out:
+	write_unlock(&alloc_lock);
+
+	if (del)
+		kfree(del);
+}
+
+void mod_alloc_info_descr(struct sock *sk, char *descr)
+{
+	struct sockinfo *info;
+
+	write_lock(&alloc_lock);
+	info = allocated;
+
+	while (info) {
+		if (info->sk == sk) {
+			strcpy(info->descr, descr);
+			break;
+		}
+		info = info->next;
+	}
+
+	write_unlock(&alloc_lock);
+}
+
+void add_alloc_info(struct sockinfo *info)
+{
+	write_lock(&alloc_lock);
+
+	info->next = allocated;
+	allocated = info;
+
+	write_unlock(&alloc_lock);
+}
+#endif
+
+void mcast_sock_free(struct sk_buff *skb)
+{
+	struct sock *sk = skb->sk;
+	sock_put(sk);
+}
+
+static inline void mcast_set_owner(struct sk_buff *skb, struct sock *sk)
+{
+	sock_hold(sk);
+	skb->sk = sk;
+	skb->destructor = mcast_sock_free;
+}
+
+#define merc_sockets_unbound	(&merc_socket_table[MERC_HASH_SIZE])
+
+#define MERC_ABSTRACT(sk)	(merc_sk(sk)->addr->hash != MERC_HASH_SIZE)
+
+static inline unsigned merc_hash_fold(unsigned hash)
+{
+	hash ^= hash >> 16;
+	hash ^= hash >> 8;
+	return hash & (MERC_HASH_SIZE - 1);
+}
+
+static inline void merc_release_addr(struct merc_address *addr)
+{
+	if (atomic_dec_and_test(&addr->refcnt))
+		kfree(addr);
+}
+
+/* call with write locks held on both sockets that have links to the node */
+static void unlink_mcast_node(struct merc_mcast *node)
+{
+	if (node->prevlistener == NULL)
+		merc_sk(node->addr)->mcastnode = node->nextlistener;
+	else
+		node->prevlistener->nextlistener = node->nextlistener;
+
+	if (node->nextlistener != NULL)
+		node->nextlistener->prevlistener = node->prevlistener;
+
+	if (node->prevaddr == NULL)
+		merc_sk(node->listener)->mcastnode = node->nextaddr;
+	else
+		node->prevaddr->nextaddr = node->nextaddr;
+
+	if (node->nextaddr != NULL)
+		node->nextaddr->prevaddr = node->prevaddr;
+}
+
+/*
+ *	Check merc socket name:
+ *		- should be not zero length.
+ *		- must be started by zero (allows us to not change other code, could
+ *		  clean this up later)
+ */
+
+static int merc_mkname(struct sockaddr_un *sunaddr, int len, unsigned *hashp)
+{
+	if (len <= sizeof(short) || len > sizeof(*sunaddr))
+		return -EINVAL;
+	if (!sunaddr || sunaddr->sun_family != AF_MERCURY)
+		return -EINVAL;
+	if (sunaddr->sun_path[0])
+		return -EINVAL;
+
+	*hashp = merc_hash_fold(csum_partial((char*)sunaddr, len, 0));
+	return len;
+}
+
+static void __merc_remove_socket(struct sock *sk)
+{
+	sk_del_node_init(sk);
+}
+
+static void __merc_insert_socket(struct hlist_head *list, struct sock *sk)
+{
+	WARN_ON(!sk_unhashed(sk));
+	sk_add_node(sk, list);
+}
+
+static inline void merc_remove_socket(struct sock *sk)
+{
+	write_lock(&merc_table_lock);
+	__merc_remove_socket(sk);
+	write_unlock(&merc_table_lock);
+}
+
+static inline void merc_insert_socket(struct hlist_head *list, struct sock *sk)
+{
+	write_lock(&merc_table_lock);
+	__merc_insert_socket(list, sk);
+	write_unlock(&merc_table_lock);
+}
+
+static struct sock *__merc_find_socket_byname(struct sockaddr_un *sunname,
+		int len, int type, unsigned hash)
+{
+	struct sock *s;
+	struct hlist_node *node;
+
+	sk_for_each(s, node, &merc_socket_table[hash ^ type]) {
+		struct merc_sock *u = merc_sk(s);
+
+		if (u->addr->len == len &&
+		    !memcmp(u->addr->name, sunname, len))
+			goto found;
+	}
+	s = NULL;
+found:
+	return s;
+}
+
+static inline struct sock *merc_find_socket_byname(struct sockaddr_un *sunname,
+						   int len, int type, unsigned hash)
+{
+	struct sock *s;
+
+	read_lock(&merc_table_lock);
+	s = __merc_find_socket_byname(sunname, len, type, hash);
+	if (s)
+		sock_hold(s);
+	read_unlock(&merc_table_lock);
+	return s;
+}
+
+static inline int merc_writable(struct sock *sk)
+{
+	return (atomic_read(&sk->sk_wmem_alloc) << 2) <= sk->sk_sndbuf;
+}
+
+static void merc_write_space(struct sock *sk)
+{
+	read_lock(&sk->sk_callback_lock);
+	if (merc_writable(sk)) {
+		if (sk->sk_sleep && waitqueue_active(sk->sk_sleep))
+			wake_up_interruptible(sk->sk_sleep);
+		sk_wake_async(sk, 2, POLL_OUT);
+	}
+	read_unlock(&sk->sk_callback_lock);
+}
+
+static void merc_sock_destructor(struct sock *sk)
+{
+	struct merc_sock *u = merc_sk(sk);
+
+	skb_queue_purge(&sk->sk_receive_queue);
+
+	WARN_ON(atomic_read(&sk->sk_wmem_alloc));
+	WARN_ON(!sk_unhashed(sk));
+	WARN_ON(sk->sk_socket);
+	if (!sock_flag(sk, SOCK_DEAD)) {
+		printk("Attempt to release alive merc socket: %p\n", sk);
+		return;
+	}
+
+	if (u->addr)
+		merc_release_addr(u->addr);
+
+	atomic_dec(&merc_nr_socks);
+#ifdef DEBUG_SOCKINFO
+	del_alloc_info(sk);
+#endif
+
+#ifdef MERC_REFCNT_DEBUG
+	printk(KERN_DEBUG "MERC %p is destroyed, %d are still alive.\n",
+	       sk, atomic_read(&merc_nr_socks));
+#endif
+}
+
+/* need the prototype */
+static int merc_release_sock(struct sock *sk, int embrion);
+
+/* handle unlinking a node and freeing the address if appropriate */
+void mcast_remove_node(struct merc_mcast *node, struct sock *other, struct sock *sk)
+{
+	int do_release = 0;
+
+	/* this is tricky, pay attention.
+	 * we are racing against merc_attach() wanting to register a new listener for other at
+	 * the same time that we may be trying to remove the last listener.  We take the table lock
+	 * to keep it from getting in there.  Once it's unlinked from the table, we can release the
+	 * lock and merc_attach() will make a new socket and bind it in while we can release
+	 * the old socket at our leisure.  A bit wasteful, but it shouldn't happen very often.
+	 */
+
+	/* must lock the table first */
+	write_lock(&merc_table_lock);
+
+	/* must lock "other" first to avoid deadlock with msg delivery */
+	merc_state_wlock(other);
+	merc_state_wlock(sk);
+
+	/* unlink the node */
+	unlink_mcast_node(node);
+
+	if (!merc_sk(other)->mcastnode) {
+		/* no more listeners on this address.
+		 * unbind it immediately so that nobody else can get to it via
+		 * merc_find_socket_byname().  Note double-underscore version
+		 * since we have to take the lock before the socket state locks.
+		 * We defer the actual release until we've given up the locks
+		 */
+		__merc_remove_socket(other);
+		do_release = 1;
+	}
+
+	merc_state_wunlock(sk);
+	merc_state_wunlock(other);
+
+	write_unlock(&merc_table_lock);
+
+	/* release refcounts for the node outside the socket locks */
+	sock_put(sk);
+	sock_put(other);
+
+	if (do_release)
+		sock_release(other->sk_socket);
+
+	kfree(node);
+}
+
+static void merc_release_mcast(struct sock *sk)
+{
+	struct merc_mcast *node;
+	struct merc_mcast *tmpnode;
+	struct sock *other;
+
+	/* we want to walk the chain and unlink from any multicast
+	 * addresses with which we are registered
+	 */
+	node = merc_sk(sk)->mcastnode;
+
+	while (node) {
+		other = node->addr;
+		tmpnode = node;
+		node = node->nextaddr;
+
+		/* note: this frees tmpnode and may release "other" if this was the last listener */
+		mcast_remove_node(tmpnode, other, sk);
+	}
+	return;
+}
+
+static int merc_release_sock(struct sock *sk, int embrion)
+{
+	struct sk_buff *skb;
+
+	merc_remove_socket(sk);
+
+	/* Clear state */
+	merc_state_wlock(sk);
+
+	sock_orphan(sk);
+
+	/* set SHUTDOWN_MASK for socket layer, we don't actually care about it
+	 * for our own functions, since we can just key off a flag of SOCK_DEAD
+	 * as set in sock_orphan()
+	 */
+	sk->sk_shutdown = SHUTDOWN_MASK;
+	merc_state_wunlock(sk);
+
+	/* now we are shutdown and orphaned.  We still need to remove all
+	 * links to us from the multicast addresses.  Cannot do this with
+	 * our own lock held otherwise we risk deadlock.
+	 */
+	merc_release_mcast(sk);
+
+	/* Try to flush out this socket. Throw out buffers at least */
+
+	while ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {
+		/* passed fds are erased in the kfree_skb hook	      */
+		kfree_skb(skb);
+	}
+
+	sock_put(sk);
+
+	/*printk("releasing socket %p\n", sk); */
+
+	/* ---- Socket is dead now and most probably destroyed ---- */
+
+	return 0;
+}
+
+static int merc_release(struct socket *);
+static int merc_bind(struct socket *, struct sockaddr *, int);
+static int merc_getname(struct socket *, struct sockaddr *, int *, int);
+static int merc_ioctl(struct socket *, unsigned int, unsigned long);
+static int merc_shutdown(struct socket *, int);
+static int merc_dgram_sendmsg(struct kiocb *, struct socket *,
+			      struct msghdr *, size_t);
+static int merc_dgram_recvmsg(struct kiocb *, struct socket *,
+			      struct msghdr *, size_t, int);
+static int merc_setsockopt(struct socket *sock, int level, int optname,
+			   char *optval, int optlen);
+
+static struct proto_ops merc_dgram_ops = {
+	.family		= PF_MERCURY,
+	.owner		= THIS_MODULE,
+	.release	= merc_release,
+	.bind		= merc_bind,
+	.connect	= sock_no_connect,
+	.socketpair	= sock_no_socketpair,
+	.accept		= sock_no_accept,
+	.getname	= merc_getname,
+	.poll		= datagram_poll,
+	.ioctl		= merc_ioctl,
+	.listen		= sock_no_listen,
+	.shutdown	= merc_shutdown,
+	.setsockopt	= merc_setsockopt,
+	.getsockopt	= sock_no_getsockopt,
+	.sendmsg	= merc_dgram_sendmsg,
+	.recvmsg	= merc_dgram_recvmsg,
+	.mmap		= sock_no_mmap,
+	.sendpage	= sock_no_sendpage,
+};
+
+static struct sock *merc_create1(struct net *net,struct socket *sock)
+{
+	struct sock *sk = NULL;
+	struct merc_sock *u;
+#ifdef DEBUG_SOCKINFO
+	struct sockinfo *info = NULL;
+#endif
+
+	if (atomic_read(&merc_nr_socks) >= 2 * files_stat.max_files)
+		goto out;
+
+#ifdef DEBUG_SOCKINFO
+	info = kmalloc(sizeof(struct sockinfo), GFP_KERNEL);
+	if (!info)
+		goto out;
+#endif
+
+	sk = sk_alloc(net,PF_MERCURY, GFP_KERNEL, &merc_proto);
+	if (!sk)
+		goto out;
+
+	atomic_inc(&merc_nr_socks);
+
+#ifdef DEBUG_SOCKINFO
+	info->sk = sk;
+	strcpy(info->descr, "no comment");
+	add_alloc_info(info);
+	info = NULL;
+#endif
+
+	sock_init_data(sock, sk);
+
+	sk->sk_sndbuf		= INT_MAX;
+	sk->sk_write_space	= merc_write_space;
+	sk->sk_max_ack_backlog	= sysctl_merc_max_dgram_qlen;
+	sk->sk_destruct		= merc_sock_destructor;
+
+	u = merc_sk(sk);
+	rwlock_init(&u->lock);
+	init_MUTEX(&u->readsem);	/* single task reading lock */
+
+	u->mcastnode = NULL;
+	u->is_mcast_addr = 0;
+
+	/* cache a ptr to the pid of the calling process.
+	 * Can't cache a task struct ptr since mercury sockets can be
+	 * duplicated on fork, and then the original owner can go away.
+	 */
+	u->pid = current->pid;
+
+
+	merc_insert_socket(merc_sockets_unbound, sk);
+
+out:
+#ifdef DEBUG_SOCKINFO
+	if (info)
+		kfree(info);
+#endif
+	return sk;
+}
+
+static int merc_create(struct net *net,struct socket *sock, int protocol)
+{
+	if (protocol && protocol != PF_MERCURY)
+		return -EPROTONOSUPPORT;
+
+	sock->state = SS_UNCONNECTED;
+
+	switch (sock->type) {
+	/*
+	 *	Believe it or not BSD has AF_MERCURY, SOCK_RAW though
+	 *	nothing uses it.
+	 */
+	case SOCK_RAW:
+		sock->type = SOCK_DGRAM;
+	case SOCK_DGRAM:
+		sock->ops = &merc_dgram_ops;
+		break;
+	default:
+		return -ESOCKTNOSUPPORT;
+	}
+
+	return merc_create1(net,sock) ? 0 : -ENOMEM;
+}
+
+static int merc_release(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+
+	if (!sk)
+		return 0;
+
+	sock->sk = NULL;
+
+	return merc_release_sock(sk, 0);
+}
+
+static int merc_autobind(struct socket *sock)
+{
+	struct sock *sk = sock->sk;
+	struct merc_sock *u = merc_sk(sk);
+	static u32 ordernum = 1;
+	struct merc_address *addr;
+	int err;
+
+	down(&u->readsem);
+
+	err = 0;
+	if (u->addr)
+		goto out;
+
+	err = -ENOMEM;
+	addr = kmalloc(sizeof(*addr) + sizeof(short) + 16, GFP_KERNEL);
+	if (!addr)
+		goto out;
+
+	memset(addr, 0, sizeof(*addr) + sizeof(short) + 16);
+	addr->name->sun_family = AF_MERCURY;
+	atomic_set(&addr->refcnt, 1);
+
+retry:
+	addr->len = sprintf(addr->name->sun_path + 1, "%05x", ordernum) + 1 + sizeof(short);
+	addr->hash = merc_hash_fold(csum_partial((void*)addr->name, addr->len, 0));
+
+	write_lock(&merc_table_lock);
+	ordernum = (ordernum + 1) & 0xFFFFF;
+
+	if (__merc_find_socket_byname(addr->name, addr->len, sock->type,
+				      addr->hash)) {
+		write_unlock(&merc_table_lock);
+		/* Sanity yield. It is unusual case, but yet... */
+		if (!(ordernum & 0xFF))
+			yield();
+		goto retry;
+	}
+	addr->hash ^= sk->sk_type;
+
+	__merc_remove_socket(sk);
+	u->addr = addr;
+	__merc_insert_socket(&merc_socket_table[addr->hash], sk);
+	write_unlock(&merc_table_lock);
+	err = 0;
+
+out:
+	up(&u->readsem);
+	return err;
+}
+
+static struct sock *merc_find_other(struct sockaddr_un *sunname, int len,
+				    int type, unsigned hash, int *error)
+{
+	struct sock *u;
+	int err = 0;
+
+	err = -ECONNREFUSED;
+	u = merc_find_socket_byname(sunname, len, type, hash);
+	if (!u)
+		goto fail;
+
+	return u;
+
+fail:
+	*error = err;
+	return NULL;
+}
+
+
+static int merc_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
+{
+	struct sock *sk = sock->sk;
+	struct merc_sock *u = merc_sk(sk);
+	struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;
+	int err;
+	unsigned hash;
+	struct merc_address *addr;
+	struct hlist_head *list;
+
+	err = -EINVAL;
+	if (sunaddr->sun_family != AF_MERCURY)
+		goto out;
+
+	if (addr_len == sizeof(short)) {
+		err = merc_autobind(sock);
+		goto out;
+	}
+
+	err = merc_mkname(sunaddr, addr_len, &hash);
+	if (err < 0)
+		goto out;
+	addr_len = err;
+
+	down(&u->readsem);
+
+	err = -EINVAL;
+	if (u->addr)
+		goto out_up;
+
+	err = -ENOMEM;
+	addr = kmalloc(sizeof(*addr) + addr_len, GFP_KERNEL);
+	if (!addr)
+		goto out_up;
+
+	memcpy(addr->name, sunaddr, addr_len);
+	addr->len = addr_len;
+	addr->hash = hash ^ sk->sk_type;
+	atomic_set(&addr->refcnt, 1);
+
+	write_lock(&merc_table_lock);
+
+	err = -EADDRINUSE;
+	if (__merc_find_socket_byname(sunaddr, addr_len,
+				      sk->sk_type, hash)) {
+		merc_release_addr(addr);
+		goto out_unlock;
+	}
+
+	list = &merc_socket_table[addr->hash];
+	err = 0;
+	__merc_remove_socket(sk);
+	u->addr = addr;
+	__merc_insert_socket(list, sk);
+
+out_unlock:
+	write_unlock(&merc_table_lock);
+out_up:
+	up(&u->readsem);
+out:
+	return err;
+}
+
+static int merc_getname(struct socket *sock, struct sockaddr *uaddr, int *uaddr_len, int peer)
+{
+	struct sock *sk = sock->sk;
+	struct merc_sock *u;
+	struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;
+	int err = 0;
+
+	if (peer) {
+		/* cannot be connected, not supported */
+		err = -ENOTCONN;
+		goto out;
+	}
+
+	sock_hold(sk);
+	u = merc_sk(sk);
+	merc_state_rlock(sk);
+	if (!u->addr) {
+		sunaddr->sun_family = AF_MERCURY;
+		sunaddr->sun_path[0] = 0;
+		*uaddr_len = sizeof(short);
+	} else {
+		struct merc_address *addr = u->addr;
+
+		*uaddr_len = addr->len;
+		memcpy(sunaddr, addr->name, *uaddr_len);
+	}
+	merc_state_runlock(sk);
+	sock_put(sk);
+out:
+	return err;
+}
+
+
+/* given a multicast merc socket, walk the chain of listeners and send to all of them
+ * must hold read lock on mcast_other before calling this
+ * return the number of listeners which got the message, or the last error value if no listeners
+ */
+static int merc_dgram_sendmcast(struct sock *mcast_other, struct sk_buff **skb,
+				struct sock *sk, int len, int dupall)
+{
+	int err = 0;
+	int sentmsgs = 0;
+	struct sk_buff *dupskb = NULL;
+	struct sk_buff *workskb = NULL;
+	struct sock *other;
+	struct merc_sock *tmp = merc_sk(mcast_other);
+	struct merc_mcast *node = tmp->mcastnode;
+
+	if (dupall) {
+		workskb = skb_clone(*skb, GFP_ATOMIC);
+		if (!workskb) {
+			err = -EMSGSIZE;
+			goto unlock_exit;
+		}
+		/* this is a bit tricky.  skb_clone() creates a new skb with no owner.  
+		 * The default ownership setting routine (skb_set_owner_w()) charges the
+		 * message to the socket's write queue.  This is not correct for us, since
+		 * the message doesn't actually take up any extra space.  Thus we need to
+		 * use our own ownership-setting routine (and our own destructor).
+		 */
+		mcast_set_owner(workskb, sk);
+	} else
+		workskb = *skb;
+
+mcastrestart:
+
+	if (!node) {
+		printk("whoops, no node\n");
+		err = -ECONNRESET;
+		goto unlock_exit;
+	}
+
+	other = node->listener;
+
+	if (!other) {
+		printk("whoops, no other\n");
+		err = -ECONNRESET;
+		goto nextlistener;
+	}
+
+	merc_state_rlock(other);
+
+	if (sock_flag(other, SOCK_DEAD)) {
+		merc_state_runlock(other);
+
+		err = -ECONNRESET;
+		goto nextlistener;
+	}
+
+	/* if the listener has no room, too bad */
+	if (skb_queue_len(&other->sk_receive_queue) > other->sk_max_ack_backlog) {
+		/* dump what info we have for debugging */
+		if (net_ratelimit()) {
+			char comm[16] = "unknown";
+			struct task_struct *tsk;
+			int size = (sizeof(comm) < sizeof(tsk->comm)) ? 
+				sizeof(comm) : sizeof(tsk->comm);
+			
+			read_lock(&tasklist_lock);
+			tsk = find_task_by_pid_ns(merc_sk(other)->pid,&init_pid_ns);
+			if (tsk) {
+				memset(comm, 0, sizeof(comm));
+				task_lock(tsk);
+				memcpy(comm, tsk->comm, size);
+				task_unlock(tsk);
+			}
+			read_unlock(&tasklist_lock);
+
+			/* ensure terminating null */
+			comm[sizeof(comm)-1] = 0;
+
+			printk(KERN_WARNING "%s(%d) unable to deliver event \"%.*s\" to %s(%d), rx queue full\n", 
+			       current->comm, current->pid,
+			       (int)(tmp->addr->len - sizeof(short) - 1), 
+			       tmp->addr->name->sun_path + 1, comm, merc_sk(other)->pid);
+		}
+
+		err = -ENOMEM;
+		goto unlocknextlistener;
+	}
+
+	if (node->nextlistener) {
+		dupskb = skb_clone(workskb, GFP_ATOMIC);
+		if (dupskb) {
+			/* this is a bit tricky.  skb_clone() creates a new skb with no owner.  
+			 * The default ownership setting routine (skb_set_owner_w()) charges the
+			 * message to the socket's write queue.  This is not correct for us, since
+			 * the message doesn't actually take up any extra space.  Thus we need to
+			 * use our own ownership-setting routine (and our own destructor).
+			 */
+			mcast_set_owner(dupskb, sk);
+		}
+	}
+
+	skb_queue_tail(&other->sk_receive_queue, workskb);
+	merc_state_runlock(other);
+	other->sk_data_ready(other, len);
+
+	sentmsgs = 1;
+
+	workskb = dupskb;
+	dupskb = NULL;
+
+	goto nextlistener;
+
+unlocknextlistener:
+	merc_state_runlock(other);
+
+nextlistener:
+	node = node->nextlistener;
+	if (node && workskb)
+		goto mcastrestart;
+
+unlock_exit:	
+	if (workskb)
+		kfree_skb(workskb);
+
+	if (!dupall)
+		*skb = NULL;
+
+	return sentmsgs ? 0 : err;
+}
+
+
+
+/*
+ *	Send AF_MERCURY data.
+ */
+
+static int __merc_dgram_sendmsg(unsigned hash, struct sockaddr_un *sunaddr, int namelen,
+				struct sock *sk, struct sk_buff *skb, size_t len,
+				int *free_skb, int dupall)
+{
+	int err;
+	struct sock *other = NULL;
+
+restart:
+	err = -ECONNRESET;
+	if (sunaddr == NULL)
+		goto out;
+
+	other = merc_find_other(sunaddr, namelen, sk->sk_type, hash, &err);
+
+	if (!other)
+		goto out;
+
+	merc_state_rlock(other);
+
+	if (sock_flag(other, SOCK_DEAD)) {
+		merc_state_runlock(other);
+		sock_put(other);
+		goto restart;
+	}
+
+	/* if its not a multicast destination, or it has no listeners (should never be true)
+	 * then just exit.  Do we want a warning log here?
+	 */
+	err = -ECONNREFUSED;
+	if (!(merc_sk(other)->is_mcast_addr && merc_sk(other)->mcastnode))
+		goto out_unlock;
+
+	err = merc_dgram_sendmcast(other, &skb, sk, len, dupall);
+
+	/* if we didn't have dupall set, then the skb is now gone and the caller
+	 * doesn't need to free it
+	 */
+	if (!dupall)
+		*free_skb = 0;
+
+out_unlock:
+	merc_state_runlock(other);
+	sock_put(other);
+out:
+	return err;
+}
+
+static int merc_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,
+			      struct msghdr *msg, size_t len)
+{
+	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
+	struct sock *sk = sock->sk;
+	struct merc_sock *u = merc_sk(sk);
+	struct sockaddr_un *sunaddr = msg->msg_name;
+	int namelen = 0;	/* fake GCC */
+	int err;
+	unsigned hash;
+	struct sk_buff *skb;
+	struct scm_cookie tmp_scm;
+	int do_free = 1;
+	int passcred;
+
+	if (NULL == siocb->scm)
+		siocb->scm = &tmp_scm;
+	err = scm_send(sock, msg, siocb->scm);
+	if (err < 0)
+		return err;
+
+	err = -EOPNOTSUPP;
+	if (msg->msg_flags & MSG_OOB)
+		goto out;
+
+	if (msg->msg_namelen) {
+		err = merc_mkname(sunaddr, msg->msg_namelen, &hash);
+		if (err < 0)
+			goto out;
+		namelen = err;
+	} else {
+		sunaddr = NULL;
+		err = -ENOTCONN;
+		goto out;
+	}
+
+	passcred = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;
+	if (passcred && !u->addr && (err = merc_autobind(sock)) != 0)
+		goto out;
+
+	err = -EMSGSIZE;
+	if (len > sk->sk_sndbuf - 32)
+		goto out;
+
+	skb = sock_alloc_send_skb(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);
+	if (skb == NULL) {
+		if (net_ratelimit())
+			printk(KERN_WARNING "task %s pid %d unable to allocate skb for sending event %.*s for reason %d.\n", 
+				current->comm, current->pid,
+				(int)(msg->msg_namelen - sizeof(short) - 1),
+				sunaddr->sun_path + 1, err);
+		goto out;
+	}
+
+	memcpy(MERCCREDS(skb), &siocb->scm->creds, sizeof(struct ucred));
+
+	skb_reset_transport_header(skb);
+	err = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);
+	if (err)
+		goto out_free;
+
+	/* handle wildcard listeners */
+	__merc_dgram_sendmsg(wild_hash, &wild_sunaddr, wild_namelen, sk, skb, len, &do_free, 1);
+
+	err = __merc_dgram_sendmsg(hash, sunaddr, namelen, sk, skb, len, &do_free, 0);
+
+out_free:
+	if (do_free)
+		kfree_skb(skb);
+out:
+	scm_destroy(siocb->scm);
+	return err;
+}
+
+
+static void merc_copy_addr(struct msghdr *msg, struct sock *sk)
+{
+	struct merc_sock *u = merc_sk(sk);
+
+	msg->msg_namelen = 0;
+	if (u->addr) {
+		msg->msg_namelen = u->addr->len;
+		memcpy(msg->msg_name, u->addr->name, u->addr->len);
+	}
+}
+
+static int merc_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,
+			      struct msghdr *msg, size_t size, int flags)
+{
+	struct sock_iocb *siocb = kiocb_to_siocb(iocb);
+	struct scm_cookie tmp_scm;
+	struct sock *sk = sock->sk;
+	struct merc_sock *u = merc_sk(sk);
+	int noblock = flags & MSG_DONTWAIT;
+	struct sk_buff *skb;
+	int err;
+
+	err = -EOPNOTSUPP;
+	if (flags & MSG_OOB)
+		goto out;
+
+	msg->msg_namelen = 0;
+	down(&u->readsem);
+
+	skb = skb_recv_datagram(sk, flags, noblock, &err);
+	if (!skb)
+		goto out_unlock;
+
+	if (msg->msg_name)
+		merc_copy_addr(msg, skb->sk);
+
+	if (size > skb->len)
+		size = skb->len;
+	else if (size < skb->len)
+		msg->msg_flags |= MSG_TRUNC;
+
+	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, size);
+	if (err)
+		goto out_free;
+
+	if (!siocb->scm) {
+		siocb->scm = &tmp_scm;
+		memset(&tmp_scm, 0, sizeof(tmp_scm));
+	}
+	siocb->scm->creds = *MERCCREDS(skb);
+
+	err = size;
+
+	scm_recv(sock, msg, siocb->scm, flags);
+
+out_free:
+	skb_free_datagram(sk,skb);
+out_unlock:
+	up(&u->readsem);
+out:
+	return err;
+}
+
+static int merc_shutdown(struct socket *sock, int mode)
+{
+	struct sock *sk = sock->sk;
+
+	mode = (mode + 1) & (RCV_SHUTDOWN | SEND_SHUTDOWN);
+
+	if (mode) {
+		merc_state_wlock(sk);
+		sk->sk_shutdown |= mode;
+		merc_state_wunlock(sk);
+		sk->sk_state_change(sk);
+	}
+	return 0;
+}
+
+static int merc_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
+{
+	struct sock *sk = sock->sk;
+	struct net *net = NULL;
+	long amount = 0;
+	int err;
+
+	switch(cmd) {
+	case SIOCOUTQ:
+		amount = atomic_read(&sk->sk_wmem_alloc);
+		err = put_user(amount, (int __user *)arg);
+		break;
+	case SIOCINQ:
+		{
+			struct sk_buff *skb;
+
+			spin_lock(&sk->sk_receive_queue.lock);
+			skb = skb_peek(&sk->sk_receive_queue);
+			if (skb)
+				amount = skb->len;
+			spin_unlock(&sk->sk_receive_queue.lock);
+			err = put_user(amount, (int __user *)arg);
+			break;
+		}
+
+	default:
+		net = sock_net(sk);
+		err = dev_ioctl(net,cmd, (void __user *)arg);
+		break;
+	}
+	return err;
+}
+
+
+static int merc_attach(struct sock *sk, int optlen, struct sockaddr_un *mreq)
+{
+	int err = 0;
+	struct merc_mcast *node;
+	struct sock *other;
+	struct socket *newsocket = NULL;
+	struct sockaddr_un *sunaddr;
+	int namelen;
+	unsigned hash;
+
+	sunaddr = mreq;
+
+	err = merc_mkname(sunaddr, optlen, &hash);
+	if (err < 0)
+		goto out;
+
+	namelen = err;
+
+	/* try and allocate a multicast node before we take any locks */
+	node = kmalloc(sizeof(struct merc_mcast), GFP_KERNEL);
+	if (!node) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+restart:
+
+	/* this is tricky, pay attention.
+	 * we are racing against mcast_remove_node() removing the last listener and wanting to
+	 * release "other" in the time between us finding "other" and actually linking ourselves
+	 * in as a listener.  Thus, we take the table lock, which prevents "other" from being unlinked
+	 * until we get ourselves linked in.  At that point, mcast_remove_node() can run, and there
+	 * will be at least one listener (us) so it won't remove "other".
+	 */
+	read_lock(&merc_table_lock);
+
+	/* see if the address we're trying to join already has a socket
+	 * note: if it finds "other", it does sock_hold(other) before passing it back
+	 */
+	other = __merc_find_socket_byname(sunaddr, namelen, SOCK_DGRAM, hash);
+
+	if (!other) {
+		read_unlock(&merc_table_lock);
+		/* allocate a socket for the listening address */
+
+		/* should be switched to sock_create_kern() when we upgrade kernels */
+		err = sock_create(AF_MERCURY, SOCK_DGRAM, 0, &newsocket);
+		if (err < 0)
+			goto free_out;
+
+		merc_sk(newsocket->sk)->is_mcast_addr = 1;
+#ifdef DEBUG_SOCKINFO
+		mod_alloc_info_descr(newsocket->sk, "dest addr");
+#endif
+		/* okay, have to set up a new multicast destination socket */
+		err = newsocket->ops->bind(newsocket, (struct sockaddr*) sunaddr, optlen);
+		if (err < 0) {
+			sock_release(newsocket);
+
+			/* if someone bound the same address first, we can handle it, otherwise
+			 * give up
+			 */
+			if (err != -EADDRINUSE)
+				goto free_out;
+		}
+
+		/* we (or someone else) bound it, so go back and try to find it again */
+		goto restart;
+
+	}
+
+	sock_hold(other);
+
+	/* okay, we found the destination. latch its state*/
+	merc_state_wlock(other);
+
+	if (sock_flag(other, SOCK_DEAD)) {
+		merc_state_wunlock(other);
+		sock_put(other);
+		read_unlock(&merc_table_lock);
+		goto restart;
+	}
+
+	/* if it's not a multicast address, we can't attach to it */
+	if (!merc_sk(other)->is_mcast_addr) {
+		err = -EADDRINUSE;
+		merc_state_wunlock(other);
+		sock_put(other);
+		read_unlock(&merc_table_lock);
+		goto free_out;
+	}
+
+	/* now set up the multicast node
+	 * this node sits on two linked lists, one for the multicast address
+	 * containing nodes pointing to all the sockets associated with the address,
+	 * and one for each userspace socket containing nodes pointing to all the
+	 * multicast addresses that the userspace socket is listening to
+	 */
+
+	/* take hold on socket for the node reference
+	 * implicit hold on "other" done in merc_find_other()
+	 */
+	sock_hold(sk);
+
+	node->listener = sk;
+	node->addr = other;
+
+	/* insert node at head of list from other */
+	node->nextlistener = merc_sk(other)->mcastnode;
+	node->prevlistener = NULL;
+	if (node->nextlistener != NULL)
+		node->nextlistener->prevlistener = node;
+	merc_sk(other)->mcastnode = node;
+
+	/* "other" already locked, must be locked first to avoid deadlock with msg delivery */
+	merc_state_wlock(sk);
+
+	/* insert node at head of list from sk */
+	node->nextaddr = merc_sk(sk)->mcastnode;
+	node->prevaddr = NULL;
+	if (node->nextaddr != NULL)
+		node->nextaddr->prevaddr = node;
+	merc_sk(sk)->mcastnode = node;
+
+	merc_state_wunlock(sk);
+	merc_state_wunlock(other);
+	read_unlock(&merc_table_lock);
+
+	return 0;
+
+free_out:
+	kfree(node);
+out:
+	return err;
+}
+
+static int merc_detach(struct sock *sk, int optlen, struct sockaddr_un *mreq)
+{
+	int err = 0;
+	struct merc_mcast *node;
+	struct sock *other;
+	struct sockaddr_un *sunaddr;
+	int namelen;
+	unsigned hash;
+
+	sunaddr = mreq;
+
+	err = merc_mkname(sunaddr, optlen, &hash);
+	if (err < 0)
+		goto out;
+	namelen = err;
+
+	/* get the socket for the address we're trying to detach from
+	 * note: if it finds "other", it does sock_hold(other) before passing it back
+	 */
+	other = merc_find_other(sunaddr, namelen, SOCK_DGRAM, hash, &err);
+	if (!other) {
+		/* strange, trying to leave a group that doesn't exist.
+		 * should probably log it or something
+		 */
+		err = 0;
+		goto out;
+	}
+
+	/* okay, we found the destination. latch its state*/
+	merc_state_rlock(other);
+
+	/* if its dead, we can't detach from it since 
+	 * there shouldn't be anything attached anyway*/
+	if (sock_flag(other, SOCK_DEAD)) {
+		merc_state_runlock(other);
+		err = -ENOENT;
+		goto put_out;
+	}
+
+	/* if it's not a multicast address, we can't detach from it */
+	if (!merc_sk(other)->is_mcast_addr) {
+		err = -ENOENT;
+		goto put_out;
+	}
+
+	node = merc_sk(other)->mcastnode;
+
+	while (node) {
+		if (node->listener == sk)
+			break;
+		node = node->nextlistener;
+	}
+
+	/* at this point, node will always be valid since it belongs to sk and we
+	 * don't allow simultaneous operations on the same fd. we can drop the lock
+	 * on other.
+	 */
+	merc_state_runlock(other);
+
+	if (node) {
+		/* note: this frees node and may release "other" if this was the last listener */
+		mcast_remove_node(node, other, sk);
+		err = 0;
+	} else {
+		/* not actually a group member */
+		err = -EINVAL;
+	}
+put_out:
+	/* release reference obtained in merc_find_other() */
+	sock_put(other);
+out:
+	return err;
+}
+
+
+static int merc_setsockopt(struct socket *sock, int level, int optname,
+			   char *optval, int optlen)
+{
+	int err = 0;
+	struct sock *sk = sock->sk;
+
+	if (sk->sk_type != SOCK_DGRAM) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	switch (optname) {
+	case MERC_ADD_MEMBERSHIP:
+	case MERC_DROP_MEMBERSHIP:
+		{
+			struct sockaddr_un mreq;
+
+			if (optlen > sizeof(struct sockaddr_un)) {
+				err = -EINVAL;
+				goto out;
+			}
+
+			memset(&mreq, 0, sizeof(mreq));
+			if (copy_from_user(&mreq, optval,optlen)) {
+				err = -EFAULT;
+				break;
+			}
+
+			if (optname == MERC_ADD_MEMBERSHIP)
+				err = merc_attach(sk, optlen, &mreq);
+			else
+				err = merc_detach(sk, optlen, &mreq);
+			break;
+		}
+	default:
+		err = -ENOPROTOOPT;
+		break;
+	}
+
+out:
+	return err;
+}
+
+#ifdef CONFIG_PROC_FS
+static struct sock *merc_seq_idx(int *iter, loff_t pos)
+{
+	loff_t off = 0;
+	struct sock *s;
+
+	for (s = first_merc_socket(iter); s; s = next_merc_socket(iter, s)) {
+		if (off == pos)
+			return s;
+		++off;
+	}
+	return NULL;
+}
+
+
+static void *merc_seq_start(struct seq_file *seq, loff_t *pos)
+{
+	read_lock(&merc_table_lock);
+	return *pos ? merc_seq_idx(seq->private, *pos - 1) : ((void *) 1);
+}
+
+static void *merc_seq_next(struct seq_file *seq, void *v, loff_t *pos)
+{
+	++*pos;
+
+	if (v == (void *)1) 
+		return first_merc_socket(seq->private);
+	return next_merc_socket(seq->private, v);
+}
+
+static void merc_seq_stop(struct seq_file *seq, void *v)
+{
+	read_unlock(&merc_table_lock);
+}
+
+static int merc_seq_show(struct seq_file *seq, void *v)
+{
+
+	if (v == (void *)1) {
+#ifdef DEBUG_SOCKINFO
+		struct sockinfo *info;
+
+		read_lock(&alloc_lock);
+		info = allocated;
+		while (info) {
+			seq_printf(seq, "%p: %d: %s\n", info->sk,
+				   atomic_read(&info->sk->sk_refcnt), info->descr);
+			info = info->next;
+		}
+		read_unlock(&alloc_lock);
+#endif
+		seq_puts(seq, "Num       RefCount Protocol Flags    Type St "
+			 "Inode Path              PID  Multicast Inodes (if any)\n");
+	} else {
+		struct sock *s = v;
+		struct merc_sock *u = merc_sk(s);
+		merc_state_rlock(s);
+
+		seq_printf(seq, "%p: %08X %08X %08X %04X %02X %5lu",
+			   s,
+			   atomic_read(&s->sk_refcnt),
+			   0,
+			   s->sk_state == TCP_LISTEN ? __SO_ACCEPTCON : 0,
+			   s->sk_type,
+			   s->sk_socket ?
+			   (s->sk_state == TCP_ESTABLISHED ? SS_CONNECTED : SS_UNCONNECTED) :
+			   (s->sk_state == TCP_ESTABLISHED ? SS_CONNECTING : SS_DISCONNECTING),
+			   sock_i_ino(s));
+
+		if (u->addr) {
+			int i, len;
+			seq_putc(seq, ' ');
+
+			i = 0;
+			len = u->addr->len - sizeof(short);
+			if (!MERC_ABSTRACT(s))
+				len--;
+			else {
+				seq_putc(seq, '@');
+				i++;
+			}
+			for (; i < len; i++)
+				seq_putc(seq, u->addr->name->sun_path[i]);
+		}
+
+
+		if (u->mcastnode && !u->is_mcast_addr) {
+			struct merc_mcast *node = u->mcastnode;
+
+			seq_printf(seq, " pid: %d mcast:", u->pid);
+			while (node) {
+				struct sock *other = node->addr;
+
+				/* don't need rlock on other, since we're not reading the state
+				 * In fact we *can't* take it since it could cause deadlock.
+				 * Must *always* take lock on "other" first when traversing nodes.
+				 */
+				seq_printf(seq, " %lu", sock_i_ino(other));
+				node = node->nextaddr;
+			}
+		}
+
+
+		merc_state_runlock(s);
+		seq_putc(seq, '\n');
+	}
+
+	return 0;
+}
+
+static struct seq_operations merc_seq_ops = {
+	.start  = merc_seq_start,
+	.next   = merc_seq_next,
+	.stop   = merc_seq_stop,
+	.show   = merc_seq_show,
+};
+
+
+static int merc_seq_open(struct inode *inode, struct file *file)
+{
+	struct seq_file *seq;
+	int rc = -ENOMEM;
+	int *iter = kmalloc(sizeof(int), GFP_KERNEL);
+
+	if (!iter)
+		goto out;
+
+	rc = seq_open(file, &merc_seq_ops);
+	if (rc)
+		goto out_kfree;
+
+	seq = file->private_data;
+	seq->private = iter;
+	*iter = 0;
+out:
+	return rc;
+out_kfree:
+	kfree(iter);
+	goto out;
+}
+
+static struct file_operations merc_seq_fops = {
+	.owner		= THIS_MODULE,
+	.open		= merc_seq_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release_private,
+};
+
+#endif
+
+static struct net_proto_family merc_family_ops = {
+	.family = PF_MERCURY,
+	.create = merc_create,
+	.owner	= THIS_MODULE,
+};
+
+#ifdef CONFIG_SYSCTL
+extern void merc_sysctl_register(void);
+extern void merc_sysctl_unregister(void);
+#else
+static inline void merc_sysctl_register(void)
+{
+}
+static inline void merc_sysctl_unregister(void)
+{
+}
+#endif
+
+/* returns negative there were problems */
+int init_wild_info(void)
+{
+	char *tag = "*";
+	int taglen = strlen(tag);
+
+	wild_namelen = offsetof(struct sockaddr_un, sun_path) + taglen + 2;
+	wild_sunaddr.sun_family = PF_MERCURY;
+	wild_sunaddr.sun_path[0] = 0;
+	memcpy(wild_sunaddr.sun_path + 1, tag, taglen + 1);
+	wild_namelen = offsetof(struct sockaddr_un, sun_path) + taglen + 2;
+
+	return merc_mkname(&wild_sunaddr, wild_namelen, &wild_hash);
+}
+
+static int __init af_merc_init(void)
+{
+	struct sk_buff *dummy_skb;
+	int rc;
+
+	if (sizeof(struct merc_skb_parms) > sizeof(dummy_skb->cb)) {
+		printk(KERN_CRIT "%s: panic\n", __FUNCTION__);
+		return -1;
+	}
+
+	if (init_wild_info() < 0) {
+		printk(KERN_CRIT "unable to initialize wildcard information for mercury\n");
+		return -1;
+	}
+
+	rc = proto_register(&merc_proto, 1);
+	if (rc != 0) return rc;
+
+	sock_register(&merc_family_ops);
+#ifdef CONFIG_PROC_FS
+	proc_net_fops_create(&init_net,"mercury", 0, &merc_seq_fops);
+#endif
+	merc_sysctl_register();
+	return 0;
+}
+
+static void __exit af_merc_exit(void)
+{
+	sock_unregister(PF_MERCURY);
+	merc_sysctl_unregister();
+	proc_net_remove(&init_net,"mercury");
+	proto_unregister(&merc_proto);
+}
+
+module_init(af_merc_init);
+module_exit(af_merc_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_NETPROTO(PF_MERCURY);
diff --git a/net/mercury/sysctl_net_mercury.c b/net/mercury/sysctl_net_mercury.c
new file mode 100644
index 0000000..4586149
--- /dev/null
+++ b/net/mercury/sysctl_net_mercury.c
@@ -0,0 +1,69 @@
+/* 
+ * net/mercury/sysctl_net_mercury.c, mercury surport
+ * 
+ * Copyright (c) 2006-2008 Wind River Systems, Inc. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ * 
+*/
+
+#include <linux/mm.h>
+#include <linux/sysctl.h>
+
+extern int sysctl_merc_max_dgram_qlen;
+
+ctl_table merc_table[] = {
+	{
+		.ctl_name	= NET_MERC_MAX_DGRAM_QLEN,
+		.procname	= "max_dgram_qlen",
+		.data		= &sysctl_merc_max_dgram_qlen,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table merc_net_table[] = {
+	{
+		.ctl_name	= NET_MERCURY,
+		.procname	= "mercury",
+		.mode		= 0555,
+		.child		= merc_table
+	},
+	{ .ctl_name = 0 }
+};
+
+static ctl_table merc_root_table[] = {
+	{
+		.ctl_name	= CTL_NET,
+		.procname	= "net",
+		.mode		= 0555,
+		.child		= merc_net_table
+	},
+	{ .ctl_name = 0 }
+};
+
+static struct ctl_table_header *merc_sysctl_header;
+
+void merc_sysctl_register(void)
+{
+	merc_sysctl_header = register_sysctl_table(merc_root_table);
+}
+
+void merc_sysctl_unregister(void)
+{
+	unregister_sysctl_table(merc_sysctl_header);
+}
+
-- 
1.6.0.3

