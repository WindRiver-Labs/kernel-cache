From f1b31aecf3dae13e34da186f00cff4b76eca823a Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Wed, 3 Sep 2008 11:56:48 +0800
Subject: [PATCH] socket stats

add socket stats surport. datagram sockets will be able to retrieve and
or reset counters for both the number of packets received in total
as well as the number of packets dropped due to buffer overflow.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 fs/compat_ioctl.c       |    2 +
 include/linux/sockios.h |    4 +++
 include/net/sock.h      |   51 +++++++++++++++++++++++++++++++++++++++++++++++
 net/Kconfig             |   11 ++++++++++
 net/core/sock.c         |    6 ++++-
 net/socket.c            |   20 ++++++++++++++++++
 6 files changed, 93 insertions(+), 1 deletions(-)

diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 5235c67..92e3f30 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -2047,6 +2047,8 @@ COMPATIBLE_IOCTL(SIOCGIFVLAN)
 COMPATIBLE_IOCTL(SIOCSIFVLAN)
 COMPATIBLE_IOCTL(SIOCBRADDBR)
 COMPATIBLE_IOCTL(SIOCBRDELBR)
+COMPATIBLE_IOCTL(SIOCGSOCKSTATS)
+COMPATIBLE_IOCTL(SIOCZEROSOCKSTATS)
 #ifdef CONFIG_BLOCK
 /* SG stuff */
 COMPATIBLE_IOCTL(SG_SET_TIMEOUT)
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index f4d7bf2..aff3d49 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -171,6 +171,10 @@
 #define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
 #define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
 
+/* per-socket statistics manipulation */
+#define SIOCGSOCKSTATS		0x89b0	/* get the per-socket statistics */
+#define SIOCZEROSOCKSTATS	0x89b1	/* zero the per-socket statistics */
+
 /* Device private ioctl calls */
 
 /*
diff --git a/include/net/sock.h b/include/net/sock.h
index 3039f83..c68d65c 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -76,6 +76,56 @@ SOCK_DEBUG(struct sock *sk, const char *msg, ...)
 }
 #endif
 
+/* per-socket statistics.  received is the total number of skbuffs received
+ * on that socket.  dropped_no_mem is the number of packets dropped due
+ * to a lack of space on the socket receive buffer.
+ *
+ * Note:  The lock only protects the reader from another cpu trying to zero
+ * the data.  There is still a race between the counts being updated and the
+ * counts being zeroed.  We don't worry about that.
+ */
+typedef struct {
+	__u64	received;
+	__u32	dropped_no_mem;
+} socket_stats;
+
+typedef struct {
+	socket_stats data;
+	spinlock_t lock;
+} socket_stats_struct;
+
+#ifdef CONFIG_DGRAM_SOCKSTATS
+#define DGRAM_SOCKET_STATS socket_stats_struct stats;
+#define inc_dgram_stats_received(sk) do{sk->stats.data.received++;} while(0)
+#define inc_dgram_stats_dropped(sk) \
+	do{sk->stats.data.dropped_no_mem++;} while(0)
+#define init_dgram_stats(sk) \
+do{ \
+	(sk)->stats.data.dropped_no_mem=0; \
+	(sk)->stats.data.received = 0; \
+	spin_lock_init(&(sk)->stats.lock); \
+} while(0)
+#define zero_dgram_stats(sk) \
+do{ \
+	spin_lock(&(sk)->stats.lock); \
+	(sk)->stats.data.dropped_no_mem=0; \
+	(sk)->stats.data.received = 0; \
+	spin_unlock(&(sk)->stats.lock); \
+} while(0)
+#define copy_dgram_stats(tostats, sk) \
+do{ \
+	spin_lock(&(sk)->stats.lock); \
+	(tostats)->dropped_no_mem = (sk)->stats.data.dropped_no_mem; \
+	(tostats)->received = (sk)->stats.data.received; \
+	spin_unlock(&(sk)->stats.lock); \
+} while(0)
+#else
+#define DGRAM_SOCKET_STATS
+#define inc_dgram_stats_received(sk)
+#define inc_dgram_stats_dropped(sk)
+#define init_dgram_stats(sk)
+#endif
+
 /* This is the per-socket lock.  The spinlock provides a synchronization
  * between user contexts and software interrupt processing, whereas the
  * mini-semaphore synchronizes multiple users amongst themselves.
@@ -279,6 +329,7 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+	DGRAM_SOCKET_STATS
 #ifdef CONFIG_INTERPEAK
     /* for mapping a socket to a certain VR (SO_VR setting)*/
     int              sk_vr;
diff --git a/net/Kconfig b/net/Kconfig
index 228a2af..0401ef9 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -60,6 +60,17 @@ config MERCURY
 	  To compile this driver as a module, choose M here: the module will be
 	  called mercury.
 
+config DGRAM_SOCKSTATS
+ 	bool "Datagram socket statistics"
+	default y
+ 	help
+ 	  If you say Y here, datagram sockets will be able to retrieve and
+ 	  or reset counters for both the number of packets received in total
+ 	  as well as the number of packets dropped due to buffer overflow.
+ 	  See code for data structures.
+ 	  
+ 	  If unsure, say N.
+ 
 config INET
 	bool "Use native TCP/IP networking"
 	depends on !INTERPEAK
diff --git a/net/core/sock.c b/net/core/sock.c
index af3c8e6..d473fb5 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -267,12 +267,14 @@ int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err = 0;
 	int skb_len;
-
+	
+ 	inc_dgram_stats_received(sk);
 	/* Cast sk->rcvbuf to unsigned... It's pointless, but reduces
 	   number of warnings when compiling with -W --ANK
 	 */
 	if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=
 	    (unsigned)sk->sk_rcvbuf) {
+		inc_dgram_stats_dropped(sk);
 		err = -ENOMEM;
 		goto out;
 	}
@@ -1757,6 +1759,8 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 	sk->sk_sndtimeo		=	MAX_SCHEDULE_TIMEOUT;
 
 	sk->sk_stamp = ktime_set(-1L, 0);
+	
+	init_dgram_stats(sk);
 
 #ifdef CONFIG_INTERPEAK
 	sk->sk_vr = current->vr;
diff --git a/net/socket.c b/net/socket.c
index 66e82ab..5160400 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -923,6 +923,26 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+#ifdef CONFIG_DGRAM_SOCKSTATS
+		case SIOCGSOCKSTATS:
+		{
+			socket_stats stats;
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			copy_dgram_stats(&stats, sock->sk);
+			err = copy_to_user(argp, &stats, 
+					sizeof(stats));
+			break;
+		}
+		case SIOCZEROSOCKSTATS:
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			zero_dgram_stats(sock->sk);
+			err = 0;
+			break;
+#endif
 		default:
 			err = sock->ops->ioctl(sock, cmd, arg);
 
-- 
1.5.5.1

