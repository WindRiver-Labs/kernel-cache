From 8fe5663dd813ccfe319c8b148f24df5c66e90ba6 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Wed, 3 Sep 2008 11:56:48 +0800
Subject: [PATCH] socket stats

add socket stats surport. datagram sockets will be able to retrieve and
or reset counters for both the number of packets received in total
as well as the number of packets dropped due to buffer overflow.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 5235c67..92e3f30 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -2047,6 +2047,8 @@ COMPATIBLE_IOCTL(SIOCGIFVLAN)
 COMPATIBLE_IOCTL(SIOCSIFVLAN)
 COMPATIBLE_IOCTL(SIOCBRADDBR)
 COMPATIBLE_IOCTL(SIOCBRDELBR)
+COMPATIBLE_IOCTL(SIOCGSOCKSTATS)
+COMPATIBLE_IOCTL(SIOCZEROSOCKSTATS)
 #ifdef CONFIG_BLOCK
 /* SG stuff */
 COMPATIBLE_IOCTL(SG_SET_TIMEOUT)
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index abef759..9ff2b8d 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -122,6 +122,10 @@
 #define SIOCBRADDIF	0x89a2		/* add interface to bridge      */
 #define SIOCBRDELIF	0x89a3		/* remove interface from bridge */
 
+/* per-socket statistics manipulation */
+#define SIOCGSOCKSTATS		0x89b0	/* get the per-socket statistics */
+#define SIOCZEROSOCKSTATS	0x89b1	/* zero the per-socket statistics */
+
 /* Device private ioctl calls */
 
 /*
diff --git a/include/net/sock.h b/include/net/sock.h
index 06c5259..c0b5a54 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -76,6 +76,56 @@ SOCK_DEBUG(struct sock *sk, const char *msg, ...)
 }
 #endif
 
+/* per-socket statistics.  received is the total number of skbuffs received
+ * on that socket.  dropped_no_mem is the number of packets dropped due
+ * to a lack of space on the socket receive buffer.
+ *
+ * Note:  The lock only protects the reader from another cpu trying to zero
+ * the data.  There is still a race between the counts being updated and the
+ * counts being zeroed.  We don't worry about that.
+ */
+typedef struct {
+	__u64	received;
+	__u32	dropped_no_mem;
+} socket_stats;
+
+typedef struct {
+	socket_stats data;
+	spinlock_t lock;
+} socket_stats_struct;
+
+#ifdef CONFIG_DGRAM_SOCKSTATS
+#define DGRAM_SOCKET_STATS socket_stats_struct stats;
+#define inc_dgram_stats_received(sk) do{sk->stats.data.received++;} while(0)
+#define inc_dgram_stats_dropped(sk) \
+	do{sk->stats.data.dropped_no_mem++;} while(0)
+#define init_dgram_stats(sk) \
+do{ \
+	(sk)->stats.data.dropped_no_mem=0; \
+	(sk)->stats.data.received = 0; \
+	spin_lock_init(&(sk)->stats.lock); \
+} while(0)
+#define zero_dgram_stats(sk) \
+do{ \
+	spin_lock(&(sk)->stats.lock); \
+	(sk)->stats.data.dropped_no_mem=0; \
+	(sk)->stats.data.received = 0; \
+	spin_unlock(&(sk)->stats.lock); \
+} while(0)
+#define copy_dgram_stats(tostats, sk) \
+do{ \
+	spin_lock(&(sk)->stats.lock); \
+	(tostats)->dropped_no_mem = (sk)->stats.data.dropped_no_mem; \
+	(tostats)->received = (sk)->stats.data.received; \
+	spin_unlock(&(sk)->stats.lock); \
+} while(0)
+#else
+#define DGRAM_SOCKET_STATS
+#define inc_dgram_stats_received(sk)
+#define inc_dgram_stats_dropped(sk)
+#define init_dgram_stats(sk)
+#endif
+
 /* This is the per-socket lock.  The spinlock provides a synchronization
  * between user contexts and software interrupt processing, whereas the
  * mini-semaphore synchronizes multiple users amongst themselves.
@@ -279,6 +329,7 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+	DGRAM_SOCKET_STATS
 };
 
 /*
diff --git a/net/Kconfig b/net/Kconfig
index dc58b47..1bf4026 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -47,6 +47,17 @@ config MERCURY
 	  To compile this driver as a module, choose M here: the module will be
 	  called mercury.
 
+config DGRAM_SOCKSTATS
+ 	bool "Datagram socket statistics"
+	default y
+ 	help
+ 	  If you say Y here, datagram sockets will be able to retrieve and
+ 	  or reset counters for both the number of packets received in total
+ 	  as well as the number of packets dropped due to buffer overflow.
+ 	  See code for data structures.
+ 	  
+ 	  If unsure, say N.
+ 
 config INET
 	bool "TCP/IP networking"
 	---help---
diff --git a/net/core/sock.c b/net/core/sock.c
index 91f8bbc..a05b5c0 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -267,12 +267,14 @@ int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err = 0;
 	int skb_len;
-
+	
+ 	inc_dgram_stats_received(sk);
 	/* Cast sk->rcvbuf to unsigned... It's pointless, but reduces
 	   number of warnings when compiling with -W --ANK
 	 */
 	if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=
 	    (unsigned)sk->sk_rcvbuf) {
+		inc_dgram_stats_dropped(sk);
 		err = -ENOMEM;
 		goto out;
 	}
@@ -1737,6 +1739,8 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 	sk->sk_sndtimeo		=	MAX_SCHEDULE_TIMEOUT;
 
 	sk->sk_stamp = ktime_set(-1L, 0);
+	
+	init_dgram_stats(sk);
 
 	atomic_set(&sk->sk_refcnt, 1);
 	atomic_set(&sk->sk_drops, 0);
diff --git a/net/socket.c b/net/socket.c
index e96f8f0..b15b18a 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -921,6 +921,26 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+#ifdef CONFIG_DGRAM_SOCKSTATS
+		case SIOCGSOCKSTATS:
+		{
+			socket_stats stats;
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			copy_dgram_stats(&stats, sock->sk);
+			err = copy_to_user(argp, &stats, 
+					sizeof(stats));
+			break;
+		}
+		case SIOCZEROSOCKSTATS:
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			zero_dgram_stats(sock->sk);
+			err = 0;
+			break;
+#endif
 		default:
 			err = sock->ops->ioctl(sock, cmd, arg);
 
