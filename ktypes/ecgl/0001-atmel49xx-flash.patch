From 0393c15a01df42fb80059b7926fc9c02f1fbdf13 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Wed, 3 Sep 2008 13:49:47 +0800
Subject: [PATCH] atmel49xx flash

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 drivers/mtd/chips/cfi_cmdset_0001.c |    4 +
 drivers/mtd/chips/jedec_probe.c     |   13 +++
 drivers/mtd/maps/Kconfig            |    9 ++
 drivers/mtd/maps/Makefile           |    1 +
 drivers/mtd/maps/atmel49xx_flash.c  |  199 +++++++++++++++++++++++++++++++++++
 drivers/mtd/maps/atmel49xx_uflash.c |  199 +++++++++++++++++++++++++++++++++++
 drivers/pci/quirks.c                |   23 ++++
 7 files changed, 448 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/maps/atmel49xx_flash.c
 create mode 100644 drivers/mtd/maps/atmel49xx_uflash.c

diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index e297fac..7488a31 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -472,12 +472,16 @@ struct mtd_info *cfi_cmdset_0001(struct map_info *map, int primary)
 				1<<cfi->cfiq->BufWriteTimeoutTyp;
 		/* No default; if it isn't specified, we won't use it */
 
+#ifdef CONFIG_INTEL_ATCA717 /* ATMEL AT49LW080 chip reports erase time in seconds */
+		cfi->chips[i].erase_time = 1000<<cfi->cfiq->BlockEraseTimeoutTyp;
+#else
 		if (cfi->cfiq->BlockEraseTimeoutTyp)
 			cfi->chips[i].erase_time =
 				CONFIG_MTD_CFI_INTELEXT_ERASE_MULTIPLIER
                                        <<cfi->cfiq->BlockEraseTimeoutTyp;
 		else
 			cfi->chips[i].erase_time = 2000000;
+#endif /* CONFIG_INTEL_ATCA717 */
 
 		cfi->chips[i].ref_point_counter = 0;
 		init_waitqueue_head(&(cfi->chips[i].wq));
diff --git a/drivers/mtd/chips/jedec_probe.c b/drivers/mtd/chips/jedec_probe.c
index 2f3f2f7..5355218 100644
--- a/drivers/mtd/chips/jedec_probe.c
+++ b/drivers/mtd/chips/jedec_probe.c
@@ -69,6 +69,7 @@
 #define AT49BV16XT	0x00C2
 #define AT49BV32X	0x00C8
 #define AT49BV32XT	0x00C9
+#define AT49LW080	0x00E1
 
 /* Eon */
 #define EN29SL800BB	0x226B
@@ -644,6 +645,18 @@ static const struct amd_flash_info jedec_table[] = {
 			ERASEINFO(0x02000,8)
 		}
 	}, {
+                .mfr_id         = MANUFACTURER_ATMEL,
+                .dev_id         = AT49LW080,
+                .name           = "Atmel AT49LW080",
+		.devtypes	= CFI_DEVICETYPE_X8,
+                .uaddr          =  MTD_UADDR_UNNECESSARY,    /* x8 */
+                .dev_size       = SIZE_1MiB,
+                .cmd_set        = P_ID_INTEL_EXT,
+                .nr_regions	= 1,
+                .regions        = {
+                        ERASEINFO(0x10000,16),
+                }
+	}, {
 		.mfr_id		= MANUFACTURER_EON,
 		.dev_id		= EN29SL800BT,
 		.name		= "Eon EN29SL800BT",
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index e626d89..5c79fc2 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -571,5 +571,14 @@ config MTD_PLATRAM
 
 	  This selection automatically selects the map_ram driver.
 
+config MTD_ATMEL49XX_FLASH
+        tristate "Flash chip on Force 715/717/7120 Boards"
+        depends on X86 && MTD_PARTITIONS && MTD_COMPLEX_MAPPINGS && MTD_JEDECPROBE
+        default y
+        help
+          This provides a driver for the on-board flash.  By default the
+          flash is split into 2 partitions which are accessed as separate
+          MTD devices.
+
 endmenu
 
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 71603b7..9e17291 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -65,3 +65,4 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+obj-$(CONFIG_MTD_ATMEL49XX_FLASH)   += atmel49xx_flash.o atmel49xx_uflash.o
diff --git a/drivers/mtd/maps/atmel49xx_flash.c b/drivers/mtd/maps/atmel49xx_flash.c
new file mode 100644
index 0000000..4ab7431
--- /dev/null
+++ b/drivers/mtd/maps/atmel49xx_flash.c
@@ -0,0 +1,199 @@
+/*
+ * atmel49xx_flash.c
+ *
+ * The map file for Boot Flash.
+ *
+ * Author: Force Computers (India) PVT. LTD.
+ *         Soumya K.S <soumya.ks@fci.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define FLASH_PHYS_ADDR 0xFFF00000	/* Boot Flash Area */
+
+#define FLASH_SIZE 0x100000
+
+/*
+ * Two partitions have been defined so far:
+ *
+ * 1. Partition 1 (0xFFF00000 - 0xFFFFFFFF)  -- 1.00MB
+ */
+
+#define FLASH_PARTITION0_ADDR 0x00000000
+#define FLASH_PARTITION0_SIZE 0x00100000
+
+map_word atmel49xx_read8(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+	val.x[0] = readb((void __iomem *) (map->map_priv_1 + ofs));
+	return val;
+}
+
+map_word atmel49xx_read16(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+	val.x[0] = readw((void __iomem *) (map->map_priv_1 + ofs));
+	return val;
+}
+
+map_word atmel49xx_read32(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+	val.x[0] = readl((void __iomem *) (map->map_priv_1 + ofs));
+	return val;
+}
+
+void atmel49xx_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void __iomem *) (map->map_priv_1 + from), len);
+}
+
+void atmel49xx_write8(struct map_info *map, map_word val, unsigned long adr)
+{
+	writeb(val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_write16(struct map_info *map, map_word val, unsigned long adr)
+{
+	writew(val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_write32(struct map_info *map, map_word val, unsigned long adr)
+{
+	writel(val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void __iomem *) (map->map_priv_1 + to), from, len);
+}
+
+struct map_info atmel49xx_map = {
+	.name = "Boot flash device",
+	.phys = FLASH_PHYS_ADDR,
+	.size = FLASH_SIZE,
+	.bankwidth = 1,
+	.read = atmel49xx_read8,
+	.copy_from = atmel49xx_copy_from,
+	.write = atmel49xx_write8,
+	.copy_to = atmel49xx_copy_to
+};
+
+struct mtd_partition atmel49xx_parts[] = {
+	{
+		name	: "BIOS Image",
+		offset	: FLASH_PARTITION0_ADDR,
+		size	: FLASH_PARTITION0_SIZE
+	},
+};
+
+
+#define PARTITION_COUNT (sizeof(atmel49xx_parts)/sizeof(struct mtd_partition))
+
+static struct mtd_info *mymtd;
+
+#define	T_BLOCK_MINUS15		0xFFB00002
+
+void fwh_init (void)
+{
+	unsigned char *fwh_tblocks;
+	unsigned int count=0;
+
+	/*
+	** set sectors to be in full access lock down.  This means that the
+	** value of the lock bit cannot be changed, i.e. the chip is always
+	** configured to allow read and write access.
+	*/
+
+	for (count=0; count<=0xF0000; count+=0x10000) {
+		fwh_tblocks = (unsigned char*)ioremap_nocache ((T_BLOCK_MINUS15+count),4);
+		*fwh_tblocks = 0x02;
+		iounmap ((unsigned char*)fwh_tblocks);
+	}
+}
+
+int __init init_atmel49xx(void)
+{
+	/*unlock blocks*/
+	fwh_init ();
+
+	printk(KERN_NOTICE "Atmel Boot flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+
+	atmel49xx_map.map_priv_1 = (unsigned long)ioremap( FLASH_PHYS_ADDR, FLASH_SIZE ) ;
+
+	if (!atmel49xx_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("jedec_probe", &atmel49xx_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+
+		/*
+		** since the chip cannot be locked make sure the functions are
+		** not configured so that -EOPNOTSUPP is returned when user
+		** attempts to lock an area
+		*/
+		mymtd->lock = NULL;
+		mymtd->unlock = NULL;
+		add_mtd_partitions(mymtd, atmel49xx_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "Atmel Boot flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)atmel49xx_map.map_priv_1);
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_atmel49xx(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (atmel49xx_map.map_priv_1) {
+		iounmap((void *)atmel49xx_map.map_priv_1);
+		atmel49xx_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_atmel49xx);
+module_exit(cleanup_atmel49xx);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("K S Soumya. <Soumya.KS@fci.com>");
+MODULE_DESCRIPTION("MTD map driver for Atmel Flash chip");
diff --git a/drivers/mtd/maps/atmel49xx_uflash.c b/drivers/mtd/maps/atmel49xx_uflash.c
new file mode 100644
index 0000000..598da5c
--- /dev/null
+++ b/drivers/mtd/maps/atmel49xx_uflash.c
@@ -0,0 +1,199 @@
+/*
+ * atmel49xx_uflash.c
+ *
+ * The map file for User Flash.
+ *
+ * Author: Force Computers (India) PVT. LTD.
+ *         Soumya K.S <soumya.ks@fci.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+
+#define FLASH_PHYS_ADDR 0xFFE00000	/* User Flash Area */
+
+#define FLASH_SIZE 0x100000
+
+/*
+ * Two partitions have been defined so far:
+ *
+ * 1. Partition 1 (0xFFE00000 - 0xFFEFFFFF)  -- 1.00MB
+ */
+
+#define FLASH_PARTITION0_ADDR 0x00000000
+#define FLASH_PARTITION0_SIZE 0x00100000
+
+map_word atmel49xx_uflash_read8(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+    val.x[0] = (__u8) __raw_readb((void __iomem *) (map->map_priv_1 + ofs));
+	return val;
+}
+
+map_word atmel49xx_uflash_read16(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+    val.x[0] = (__u16) __raw_readw((void __iomem *) (map->map_priv_1 + ofs));
+    return val;
+}
+
+map_word atmel49xx_uflash_read32(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+    val.x[0] = (__u32) __raw_readl((void __iomem *) (map->map_priv_1 + ofs));
+    return val;
+}
+
+void atmel49xx_uflash_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, (void __iomem *) (map->map_priv_1 + from), len);
+}
+
+void atmel49xx_uflash_write8(struct map_info *map, map_word val, unsigned long adr)
+{
+	__raw_writeb((__u8) val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_uflash_write16(struct map_info *map, map_word val, unsigned long adr)
+{
+	__raw_writew((__u16) val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_uflash_write32(struct map_info *map, map_word val, unsigned long adr)
+{
+	__raw_writel((__u32) val.x[0], (void __iomem *) (map->map_priv_1 + adr));
+	mb();
+}
+
+void atmel49xx_uflash_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio((void __iomem *) (map->map_priv_1 + to), from, len);
+}
+
+struct map_info atmel49xx_uflash_map = {
+	.name = "User flash device",
+	.phys = FLASH_PHYS_ADDR,
+	.size = FLASH_SIZE,
+	.bankwidth = 1,
+	.read = atmel49xx_uflash_read8,
+	.copy_from = atmel49xx_uflash_copy_from,
+	.write = atmel49xx_uflash_write8,
+	.copy_to = atmel49xx_uflash_copy_to
+};
+
+struct mtd_partition atmel49xx_uflash_parts[] = {
+	{
+		name	: "USER Flash",
+		offset	: FLASH_PARTITION0_ADDR,
+		size	: FLASH_PARTITION0_SIZE
+	},
+};
+
+
+#define PARTITION_COUNT (sizeof(atmel49xx_uflash_parts)/sizeof(struct mtd_partition))
+
+static struct mtd_info *mymtd;
+
+#define	T_BLOCK_MINUS15		0xFFA00002
+
+void ufwh_init (void)
+{
+	unsigned char *fwh_tblocks;
+	unsigned int count=0;
+
+	/*
+	** set sectors to be in full access lock down.  This means that the
+	** value of the lock bit cannot be changed, i.e. the chip is always
+	** configured to allow read and write access.
+	*/
+
+	for (count=0; count<=0xF0000; count+=0x10000) {
+		fwh_tblocks = (unsigned char*)ioremap_nocache ((T_BLOCK_MINUS15+count),4);
+		*fwh_tblocks = 0x02;
+		iounmap ((unsigned char*)fwh_tblocks);
+	}
+}
+
+int __init init_atmel49xx_uflash (void)
+{
+	/*unlock blocks*/
+	ufwh_init ();
+
+	printk(KERN_NOTICE "User flash device: %x at %x\n",
+			FLASH_SIZE, FLASH_PHYS_ADDR);
+
+	atmel49xx_uflash_map.map_priv_1 = (unsigned long)ioremap( FLASH_PHYS_ADDR, FLASH_SIZE ) ;
+
+	if (!atmel49xx_uflash_map.map_priv_1) {
+		printk("Failed to ioremap\n");
+		return -EIO;
+	}
+	mymtd = do_map_probe("jedec_probe", &atmel49xx_uflash_map);
+	if (mymtd) {
+		mymtd->owner = THIS_MODULE;
+
+		/*
+		** since the chip cannot be locked make sure the functions are
+		** not configured so that -EOPNOTSUPP is returned when user
+		** attempts to lock an area
+		*/
+		mymtd->lock = NULL;
+		mymtd->unlock = NULL;
+		add_mtd_partitions(mymtd, atmel49xx_uflash_parts, PARTITION_COUNT);
+		printk(KERN_NOTICE "User flash device initialized\n");
+		return 0;
+	}
+
+	iounmap((void *)atmel49xx_uflash_map.map_priv_1);
+
+	return -ENXIO;
+}
+
+static void __exit cleanup_atmel49xx_uflash (void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+	}
+	if (atmel49xx_uflash_map.map_priv_1) {
+		iounmap((void *)atmel49xx_uflash_map.map_priv_1);
+		atmel49xx_uflash_map.map_priv_1 = 0;
+	}
+}
+
+module_init(init_atmel49xx_uflash);
+module_exit(cleanup_atmel49xx_uflash);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("K S Soumya. <Soumya.KS@fci.com>");
+MODULE_DESCRIPTION("MTD map driver for Atmel Flash chip");
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 9236e7f..7d847a9 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -1362,6 +1362,29 @@ static void __init quirk_alder_ioapic(struct pci_dev *pdev)
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_EESSC,	quirk_alder_ioapic);
 #endif
 
+/* Enable the write through from the 6300ESB I/O controller to the flash chip */
+#if defined(CONFIG_MTD_ATMEL49XX_FLASH) || defined(CONFIG_MTD_ATMEL49XX_FLASH_MODULE)
+#if !defined(PCI_DEVICE_ID_INTEL_6300ESB_LPCIF)
+#define PCI_DEVICE_ID_INTEL_6300ESB_LPCIF 0x25a1
+#endif
+
+static void __init quirk_fwh_enable (struct pci_dev *lpc) {
+	unsigned char bios_cntl=0;      /*0x4e=0x01 (BIOS_CNTL-1 of 0x4e)*/
+#define BIOS_CNTL_REG   0x4E
+#define BIOSWE_BIT      0x01
+#define BIOSMI_BIT      0x10
+
+	if (lpc != NULL) {
+		pci_read_config_byte (lpc, BIOS_CNTL_REG, &bios_cntl);
+		bios_cntl &= ~(BIOSMI_BIT);
+		bios_cntl |= BIOSWE_BIT;
+		pci_write_config_byte (lpc, BIOS_CNTL_REG, bios_cntl);
+	}
+}
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_6300ESB_LPCIF,	quirk_fwh_enable );
+#endif
+
+
 int pcie_mch_quirk;
 EXPORT_SYMBOL(pcie_mch_quirk);
 
-- 
1.6.0.3

