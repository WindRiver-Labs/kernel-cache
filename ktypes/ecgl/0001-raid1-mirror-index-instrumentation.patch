From 20aceaf0aaa6591fdd7196acf5627902efe3aa53 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 4 Sep 2008 14:39:14 +0800
Subject: [PATCH] raid1 mirror index instrumentation

Instrument raid1_end_write_request to detect out-of-bounds array access

Signed-off-by: Chris Eineke  <chris.eineke@windriver.com>
Integrated-by: Yongli he   <yongli.he@windriver.com>
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 03a5ab7..71aa7f0 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -42,6 +42,14 @@
 #define PRINTK(x...)
 #endif
 
+#ifdef CONFIG_PANIC_LOGS
+extern void kcore_logon(int reboot);
+extern void kcore_logoff(void);
+#else
+#define kcore_logon(reboot) do { } while(0)
+#define kcore_logoff() do { } while(0)
+#endif /* CONFIG_PANIC_LOGS */
+
 /*
  * Number of guaranteed r1bios in case of extreme VM load:
  */
@@ -313,6 +321,26 @@ static void raid1_end_write_request(struct bio *bio, int error)
 		if (r1_bio->bios[mirror] == bio)
 			break;
 
+#if RAID1_INSTRUMENTATION
+	/*
+	 * There's a chance that the above loop will not find a matching index
+	 * of the mirror associated with the passed in struct bio *bio. We
+	 * would then end up with (mirror == conf->raid_disks) thus accessing
+	 * an out-of-bounds value of the zero-based r1_bio->bios[] array.
+	 */
+	if (unlikely(mirror >= conf->raid_disks)) {
+		int cpu = get_cpu();
+		kcore_logon(0);
+		printk(KERN_DEBUG "raid1.c: (CPU %d) None of the bio's in the "
+				"bios array matched the passed in bio struct. "
+				"[mirror=%d,conf->raid_disks=%d]\n", cpu,
+				mirror, conf->raid_disks);
+		MD_BUG();
+		put_cpu();
+		kcore_logoff();
+	}
+#endif
+
 	if (error == -EOPNOTSUPP && test_bit(R1BIO_Barrier, &r1_bio->state)) {
 		set_bit(BarriersNotsupp, &conf->mirrors[mirror].rdev->flags);
 		set_bit(R1BIO_BarrierRetry, &r1_bio->state);
