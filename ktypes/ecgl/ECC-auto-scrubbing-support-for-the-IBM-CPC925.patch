From feda172c51fc322607bfdd2ba7c92d8e574a8f47 Mon Sep 17 00:00:00 2001
From: hyl <yongli.he@windriver.com>
Date: Thu, 18 Dec 2008 16:40:07 -0500
Subject: [PATCH] ECC auto-scrubbing support for the IBM CPC925

Add hardware ECC auto-scrubbing support for the IBM CPC925 (used on the
mot_atca6101).

signed-off-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/Kconfig                 |    8 +++
 arch/powerpc/platforms/maple/setup.c |  104 ++++++++++++++++++++++++++++++++++
 2 files changed, 112 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index c4b1c7d..2fce861 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -345,6 +345,14 @@ config PHYP_DUMP
 
 	  If unsure, say "N"
 
+config CPC925_ECC_SCRUB
+	bool "ECC hardware auto-scrubbing"
+	depends on PPC_MAPLE
+	default n
+	help
+	  This turns on the hardware ECC auto-scrubbing for the IBM CPC925
+	  north bridge memory controller.
+
 config PPCBUG_NVRAM
 	bool "Enable reading PPCBUG NVRAM during boot" if PPLUS || LOPEC
 	default y if PPC_PREP
diff --git a/arch/powerpc/platforms/maple/setup.c b/arch/powerpc/platforms/maple/setup.c
index da3315c..284ab68 100644
--- a/arch/powerpc/platforms/maple/setup.c
+++ b/arch/powerpc/platforms/maple/setup.c
@@ -166,6 +166,101 @@ struct smp_ops_t maple_smp_ops = {
 };
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_CPC925_ECC_SCRUB
+
+#define CPC925_MEM_CTLLER_REGS_START    0xF8002000
+#define CPC925_MEM_CTLLER_REGS_SIZE     0x00001000
+#define CPC925_MEM_RFSH_PER_OFFSET      0x00000070
+#define CPC925_MEM_RFSH_PER_MASK        0xFF000000
+#define CPC925_MEM_RFSH_PER_SHIFT       24
+#define CPC925_MSCR_OFFSET              0x00000400
+#define CPC925_MSCR_SCRUB_MOD_MASK      0xC0000000
+#define CPC925_MSCR_BACKGR_SCRUB        0x40000000
+#define CPC925_MSCR_SI_SHIFT            16
+#define CPC925_MSCR_SI_MAX_VALUE        0xFF
+#define CPC925_MSCR_SI_MASK             (CPC925_MSCR_SI_MAX_VALUE << \
+                                         CPC925_MSCR_SI_SHIFT)
+#define CPC925_MSRSR_OFFSET             0x00000410
+#define CPC925_MSRSR_MASK               0x7FFFFFFF
+#define CPC925_MSRER_OFFSET             0x00000420
+#define CPC925_MSRER_MASK               0x7FFFFFFF
+
+#define SCRUBBING_CYCLE_TIME_SEC        (24 * 60 * 60) /* 24hs, in secs */
+#define REFRESH_PERIOD_USEC             6 /* rough DDR refresh period */
+
+#define SEC_TO_USEC(sec)                (1000000 * (sec))
+#define CONV_FACTOR                     1000 /* factor to prevent u32
+                                                overflows */
+
+static int start_ecc_scrub(void)
+{
+	int rc = 0;
+	u32 memory_start = 0;
+	u32 memory_end = 0;
+	u32 memory_range = 0;
+	u32 memory_range_f = 0;
+	volatile void* addr = NULL;
+
+	addr = ioremap(CPC925_MEM_CTLLER_REGS_START,
+		       CPC925_MEM_CTLLER_REGS_SIZE);
+	if (!addr) {
+		printk(KERN_INFO "Maple: Unable to ioremap CPC925 memory for "
+		       "ECC hardware scrubbing\n");
+		goto out;
+	}
+
+	memory_start = __raw_readl(addr + CPC925_MSRSR_OFFSET) & CPC925_MSRSR_MASK;
+	memory_end   = __raw_readl(addr + CPC925_MSRER_OFFSET) & CPC925_MSRER_MASK;
+
+	if (memory_end > memory_start) {
+		memory_range = memory_end - memory_start;
+	} else {
+		printk(KERN_DEBUG "Maple: memory_end <= memory_start\n");
+		/* old code doesn't exit here */
+	}
+
+	/* to prevent future overflow */
+	memory_range_f = memory_range / CONV_FACTOR;
+
+	if (memory_range_f == 0) {
+		printk(KERN_DEBUG "Maple: memory_range_f == 0\n");
+		goto iounmap_out;
+	}
+
+	/* it's ok to lose some precision to prevent future overflow */
+	u32 scrubble_cycle_time_f = SCRUBBING_CYCLE_TIME_SEC / CONV_FACTOR;
+
+	/* background scrub interval */
+	u32 si =   SEC_TO_USEC(scrubble_cycle_time_f)
+	/ (REFRESH_PERIOD_USEC * memory_range_f);
+
+	/* previous config */
+	u32 val = __raw_readl(addr + CPC925_MSCR_OFFSET);
+
+	/* set background scrubbing */
+	val &= ~CPC925_MSCR_SCRUB_MOD_MASK;
+	val |=  CPC925_MSCR_BACKGR_SCRUB;
+
+	/* set background scrub interval */
+	if (si > CPC925_MSCR_SI_MAX_VALUE) {
+		si = CPC925_MSCR_SI_MAX_VALUE;
+	}
+	val &= ~CPC925_MSCR_SI_MASK;
+	val |= (si << CPC925_MSCR_SI_SHIFT);
+
+	/* set current config */
+	__raw_writel(val, addr + CPC925_MSCR_OFFSET);
+
+	rc = 1;
+
+iounmap_out:
+	iounmap(addr);
+
+out:
+	return rc;
+}
+#endif
+
 static void __init maple_use_rtas_reboot_and_halt_if_present(void)
 {
 	if (rtas_service_present("system-reboot") &&
@@ -188,6 +283,15 @@ void __init maple_setup_arch(void)
 	/* Lookup PCI hosts */
        	maple_pci_init();
 
+#ifdef CONFIG_CPC925_ECC_SCRUB
+	if (!start_ecc_scrub()) {
+		printk(KERN_INFO "Maple: failed to initiate "
+				"ECC hardware scrubbing\n");
+	} else {
+		printk(KERN_INFO "Maple: ECC hardware scrubbing initiated\n");
+	}
+#endif
+
 #ifdef CONFIG_DUMMY_CONSOLE
 	conswitchp = &dummy_con;
 #endif
-- 
1.6.0.2.GIT

