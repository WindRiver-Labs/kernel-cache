From 3328260c87ec8346ad84b353b1cb13765a727be4 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Wed, 3 Sep 2008 13:08:20 +0800
Subject: [PATCH] qdisc

this  tracking the high water mark for
the per-device transmit queues.  The high water mark of the queue
will be exported via /proc/net/dev if procfs is enabled.  Writing to
/proc/net/reset_qdhighmarks will reset the high water marks for all
devices.this option will enable tracking the high water mark for
the per-device transmit queues.  The high water mark of the queue
will be exported via /proc/net/dev if procfs is enabled.  Writing to
/proc/net/reset_qdhighmarks will reset the high water marks for all
devices.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h
index e556962..8ca9405 100644
--- a/include/net/sch_generic.h
+++ b/include/net/sch_generic.h
@@ -15,6 +15,30 @@ struct qdisc_walker;
 struct tcf_walker;
 struct module;
 
+#ifdef CONFIG_QDISC_STATS
+#define HIGHQLEN_DECL u32 highqlen;
+#define check_highqlen(qdisc) \
+do { \
+	unsigned int qlen = qdisc->q.qlen; \
+	if (qlen > qdisc->highqlen) \
+		qdisc->highqlen = qlen; \
+} while (0)
+
+#define dev_seq_printf_qdisc_stuff(seq, dev) \
+do { \
+	if (netdev_get_tx_queue(dev,0)->qdisc) \
+		seq_printf(seq, "%10u", netdev_get_tx_queue(dev,0)->qdisc->highqlen); \
+} while(0)
+#define dev_seq_show_qdisc_stuff(seq) \
+	do { seq_puts(seq, " qdhighmark");} while (0)
+#else
+#define HIGHQLEN_DECL
+#define check_highqlen(qdisc)
+#define dev_seq_printf_qdisc_stuff(seq, dev)
+#define dev_seq_show_qdisc_stuff(seq)
+#endif
+#define qdisc_incr_qlen(qdisc) do{qdisc->q.qlen++; check_highqlen(qdisc);}while(0)
+
 struct qdisc_rate_table
 {
 	struct tc_ratespec rate;
@@ -70,6 +94,7 @@ struct Qdisc
 	 * and it will live until better solution will be invented.
 	 */
 	struct Qdisc		*__parent;
+	HIGHQLEN_DECL
 };
 
 struct Qdisc_class_ops
diff --git a/net/Kconfig b/net/Kconfig
index 1bf4026..be91dad 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -37,6 +37,18 @@ source "net/unix/Kconfig"
 source "net/xfrm/Kconfig"
 source "net/iucv/Kconfig"
 
+
+config QDISC_STATS
+ 	bool "Qdisc statistics reporting"
+ 	help
+ 	  Enabling this option will enable tracking the high water mark for
+ 	  the per-device transmit queues.  The high water mark of the queue
+ 	  will be exported via /proc/net/dev if procfs is enabled.  Writing to
+ 	  /proc/net/reset_qdhighmarks will reset the high water marks for all
+ 	  devices.
+ 
+ 	  Say Y if you want this additional tracking.
+
 config MERCURY
 	tristate "mercury domain sockets"
 	default y
diff --git a/net/core/dev.c b/net/core/dev.c
index f55ac79..1a0c467 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2589,7 +2589,7 @@ static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
 	struct net_device_stats *stats = dev->get_stats(dev);
 
 	seq_printf(seq, "%6s:%8lu %7lu %4lu %4lu %4lu %5lu %10lu %9lu "
-		   "%8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu\n",
+		   "%8lu %7lu %4lu %4lu %4lu %5lu %7lu %10lu",
 		   dev->name, stats->rx_bytes, stats->rx_packets,
 		   stats->rx_errors,
 		   stats->rx_dropped + stats->rx_missed_errors,
@@ -2605,6 +2605,8 @@ static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
 		    stats->tx_window_errors +
 		    stats->tx_heartbeat_errors,
 		   stats->tx_compressed);
+	dev_seq_printf_qdisc_stuff(seq, dev);
+	seq_printf(seq,"\n");
 }
 
 /*
@@ -2613,13 +2615,15 @@ static void dev_seq_printf_stats(struct seq_file *seq, struct net_device *dev)
  */
 static int dev_seq_show(struct seq_file *seq, void *v)
 {
-	if (v == SEQ_START_TOKEN)
+	if (v == SEQ_START_TOKEN) {
 		seq_puts(seq, "Inter-|   Receive                            "
 			      "                    |  Transmit\n"
 			      " face |bytes    packets errs drop fifo frame "
 			      "compressed multicast|bytes    packets errs "
-			      "drop fifo colls carrier compressed\n");
-	else
+			      "drop fifo colls carrier compressed");
+		dev_seq_show_qdisc_stuff(seq);
+		seq_puts(seq, "\n");
+	} else
 		dev_seq_printf_stats(seq, v);
 	return 0;
 }
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 9634091..8c017b0 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -379,7 +379,8 @@ static int pfifo_fast_enqueue(struct sk_buff *skb, struct Qdisc* qdisc)
 	struct sk_buff_head *list = prio2list(skb, qdisc);
 
 	if (skb_queue_len(list) < qdisc_dev(qdisc)->tx_queue_len) {
-		qdisc->q.qlen++;
+		qdisc_incr_qlen(qdisc);
+
 		return __qdisc_enqueue_tail(skb, qdisc, list);
 	}
 
@@ -403,7 +404,8 @@ static struct sk_buff *pfifo_fast_dequeue(struct Qdisc* qdisc)
 
 static int pfifo_fast_requeue(struct sk_buff *skb, struct Qdisc* qdisc)
 {
-	qdisc->q.qlen++;
+	qdisc_incr_qlen(qdisc);
+
 	return __qdisc_requeue(skb, qdisc, prio2list(skb, qdisc));
 }
 
