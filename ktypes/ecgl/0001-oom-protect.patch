From de7d9847e686dd05921610a20bbaff975452e5f2 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Tue, 2 Sep 2008 17:25:47 +0800
Subject: [PATCH] oom protect

This adds a new capability to the kernel which
Tay be called (by processes with appropriate priviledges) to
request protection from the out-of-memory killer as long as
the process is using less than the specified amount of virtual
memory.  This is accomplished through a call to setrlimit().

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 include/asm-generic/resource.h |    9 +++-
 include/linux/mm_types.h       |    4 ++
 include/linux/oom-protect.h    |   22 ++++++++
 init/Kconfig                   |   10 ++++
 kernel/Makefile                |    1 +
 kernel/fork.c                  |    4 ++
 kernel/oom-protect.c           |  113 ++++++++++++++++++++++++++++++++++++++++
 kernel/sys.c                   |   26 +++++++++
 mm/oom_kill.c                  |   16 ++++++
 9 files changed, 204 insertions(+), 1 deletions(-)
 create mode 100644 include/linux/oom-protect.h
 create mode 100644 kernel/oom-protect.c

diff --git a/include/asm-generic/resource.h b/include/asm-generic/resource.h
index 587566f..44ef27e 100644
--- a/include/asm-generic/resource.h
+++ b/include/asm-generic/resource.h
@@ -45,7 +45,14 @@
 					   0-39 for nice level 19 .. -20 */
 #define RLIMIT_RTPRIO		14	/* maximum realtime priority */
 #define RLIMIT_RTTIME		15	/* timeout for RT tasks in us */
-#define RLIM_NLIMITS		16
+#ifdef CONFIG_OOM_PROTECT
+# define RLIMIT_OOM_MAXVM	16	/* The maximum amount of virtual memory
+					   a process may allocate and still be
+					   safe from the OOM killer */
+# define RLIM_NLIMITS		17
+#else
+# define RLIM_NLIMITS		16
+#endif /* CONFIG_OOM_PROTECT */
 
 /*
  * SuS says limits have to be unsigned.
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index a57935f..2aa3f2f 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -280,6 +280,10 @@ struct mm_struct {
 #ifdef CONFIG_MEMMON
 	unsigned long memmon_flag_dir;  /* used to track per-page memmon flags */
 #endif
+#ifdef CONFIG_OOM_PROTECT
+	unsigned long oom_protect_bytes;	/* exempt from oom death if
+						 * total vm < this */
+#endif /* CONFIG_OOM_PROTECT */
 };
 
 #endif /* _LINUX_MM_TYPES_H */
diff --git a/include/linux/oom-protect.h b/include/linux/oom-protect.h
new file mode 100644
index 0000000..4081c90
--- /dev/null
+++ b/include/linux/oom-protect.h
@@ -0,0 +1,22 @@
+#ifndef _LINUX_OOM_PROTECT_H
+#define _LINUX_OOM_PROTECT_H
+
+/* The following commands may be specified for oom protection */
+#define SET_OOM_PROTECT 1
+#define QUERY_OOM_PROTECT 2
+
+/* This is the data structure for setting oom protection.
+ * The caller fills in the pid of the process to protect
+ * and the number of bytes for which to request protection.
+ */
+struct set_oom_protect_info {
+	unsigned int cmd;
+	int pid;
+	unsigned int max_vm_bytes;
+};
+
+#ifdef __KERNEL__
+int do_oom_protect(unsigned long);
+#endif /* __KERNEL__ */
+
+#endif /* _LINUX_OOM_PROTECT_H */
diff --git a/init/Kconfig b/init/Kconfig
index 7f70be6..b4e3157 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -991,6 +991,16 @@ config NOTIFY_SETTIME
 
 	  This is exposed to userspace via /proc/notify_settime_signal
 
+config OOM_PROTECT
+	bool "OOM killer protection"
+      	default y
+        help
+          When enabled this adds a new capability to the kernel which
+          may be called (by processes with appropriate priviledges) to
+          request protection from the out-of-memory killer as long as
+          the process is using less than the specified amount of virtual
+          memory.  This is accomplished through a call to setrlimit().
+
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/kernel/Makefile b/kernel/Makefile
index ad891fd..1c7dd13 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -96,6 +96,7 @@ obj-$(CONFIG_TRACING) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
 obj-$(CONFIG_SIGEXIT) += death_notify.o
 obj-$(CONFIG_NOTIFY_SETTIME) += notify_settime.o
+obj-$(CONFIG_OOM_PROTECT) += oom-protect.o
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/fork.c b/kernel/fork.c
index 97164fa..c33ec85 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -495,6 +495,10 @@ static struct mm_struct * mm_init(struct mm_struct * mm, struct task_struct *p)
 	mm->cached_hole_size = ~0UL;
 	mm_init_owner(mm, p);
 
+#ifdef CONFIG_OOM_PROTECT
+	mm->oom_protect_bytes = 0;
+#endif
+
 	if (likely(!mm_alloc_pgd(mm))) {
 		mm->def_flags = 0;
 		mmu_notifier_mm_init(mm);
diff --git a/kernel/oom-protect.c b/kernel/oom-protect.c
new file mode 100644
index 0000000..e6087f2
--- /dev/null
+++ b/kernel/oom-protect.c
@@ -0,0 +1,113 @@
+/* 
+ * kernel/oom-protect.c, Out Of Memory Protect  surport
+ * 
+ * Copyright (c) 2006-2008 Wind River Systems, Inc. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ * 
+*/
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+
+#include <linux/oom-protect.h>
+
+/*
+ * Protect the process whose pid is given from selection by the OOM killer
+ * when the system is out of memory.  If the total virtual memory allocated
+ * by the process (in pages) is less than the max_vm_bytes value passed,
+ * it will be exempt, otherwise it will be treated normally.
+ *
+ * On success we return the previous protection limit, on failure we return
+ * an appropriate error code.
+ *
+ * We take the read lock on tasklist to ensure the task doesn't go away
+ * between finding the task and setting oom protection on it.
+ *
+ * We take the task_lock to protect against others racing to  modify p->mm.
+ */
+int do_oom_protect(unsigned long arg)
+{
+	int ret = 0;
+	struct task_struct *p = NULL;
+	struct set_oom_protect_info args;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (copy_from_user(&args, (struct set_oom_protect_info __user *)arg,
+				sizeof(args)))
+		return -EFAULT;
+
+	ret = -ESRCH;
+	read_lock(&tasklist_lock);
+	p = args.pid ? find_task_by_pid_ns(args.pid,&init_pid_ns) : current;
+
+	if (!p)
+		goto tasklist_unlock_out;
+
+	ret = -EINVAL;
+	task_lock(p);
+	if (!p->mm)
+	{
+		printk(KERN_EMERG "do_oom_protect():!p->mm\n");
+		goto task_unlock_out;
+	}
+
+	switch (args.cmd) {
+		case SET_OOM_PROTECT:
+			printk(KERN_EMERG "do_oom_protect():SET_OOM_PROTECT\n");
+
+			if (p->mm->oom_protect_bytes > args.max_vm_bytes)
+			{
+				/* The standard setrlimit() code seems to choose to barf if you
+				 * try to reduce your limits, so we should do the same here. */
+				ret = -EINVAL;
+				goto task_unlock_out;
+			}
+
+			p->mm->oom_protect_bytes = args.max_vm_bytes;
+			ret = 0;
+			break;
+
+		case QUERY_OOM_PROTECT:
+			printk(KERN_EMERG "do_oom_protect():QUERY_OOM_PROTECT\n");
+
+			args.max_vm_bytes = p->mm->oom_protect_bytes;
+
+			if (copy_to_user((struct set_oom_protect_info __user *) arg,
+						&args, sizeof(struct set_oom_protect_info))) {
+				ret = -EFAULT;
+				goto task_unlock_out;
+			}
+
+			ret = 0;
+			break;
+
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+task_unlock_out:
+	task_unlock(p);
+
+tasklist_unlock_out:
+	read_unlock(&tasklist_lock);
+	return ret;
+}
diff --git a/kernel/sys.c b/kernel/sys.c
index 891d44c..97286d4 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -40,6 +40,8 @@
 #include <linux/kprobes.h>
 #include <linux/user_namespace.h>
 
+#include <linux/oom-protect.h>
+
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/unistd.h>
@@ -1468,6 +1470,18 @@ asmlinkage long sys_getrlimit(unsigned int resource, struct rlimit __user *rlim)
 		return -EINVAL;
 	else {
 		struct rlimit value;
+#ifdef CONFIG_OOM_PROTECT
+		/* Some special handling is required for the OOM protection
+		 * information since it passes structures, not integers */
+		if (resource == RLIMIT_OOM_MAXVM) {
+			struct set_oom_protect_info limit;
+			if(copy_from_user(&value, rlim, sizeof(*rlim)))
+				return -EFAULT;
+			if (!do_oom_protect(value.rlim_cur))
+				return copy_to_user(rlim, &value,
+						    sizeof(*rlim))?-EFAULT:0;
+		}
+#endif /* CONFIG_OOM_PROTECT */
 		task_lock(current->group_leader);
 		value = current->signal->rlim[resource];
 		task_unlock(current->group_leader);
@@ -1509,8 +1523,20 @@ asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)
 		return -EINVAL;
 	if (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
 		return -EFAULT;
+
 	if (new_rlim.rlim_cur > new_rlim.rlim_max)
 		return -EINVAL;
+
+#ifdef CONFIG_OOM_PROTECT
+	if (resource == RLIMIT_OOM_MAXVM) {
+		/* Special handling for the OOM-protection bits, where the
+		 * rlim_max and rlim_cur values are pointers to structures. */
+		printk(KERN_EMERG "OOM_MAXVM limit set.\n");
+		return do_oom_protect(new_rlim.rlim_max);
+	}
+#endif /* CONFIG_OOM_PROTECT */
+
+
 	old_rlim = current->signal->rlim + resource;
 	if ((new_rlim.rlim_max > old_rlim->rlim_max) &&
 	    !capable(CAP_SYS_RESOURCE))
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 7d4a0b8..d67b58f 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -72,6 +72,22 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 	 */
 	points = mm->total_vm;
 
+#ifdef CONFIG_OOM_PROTECT
+	/* Don't even consider this task if he's still within his
+	 * oom_protect_bytes range.  Question:  is this the best place to put
+	 * this short-cut?  Or should we calculate a point value for the process
+	 * anyway, even though we know he's not going to get killed?  Either way
+	 * is likely to have an impact on the total system statistics.  The
+	 * correct way to do this would be to rip through here and mark this guy
+	 * (these guys?) safe for a while until we determine that there are
+	 * *only* well-behaved processes left, then start killing the biggest
+	 * offenders of that bunch. */
+	if (p->mm->total_vm < p->mm->oom_protect_bytes) {
+		task_unlock(p);
+		return 0;
+	}
+#endif /* CONFIG_OOM_PROTECT */
+
 	/*
 	 * After this unlock we can no longer dereference local variable `mm'
 	 */
-- 
1.5.5.1

