From cdcbda2e5dcf42a35e4dcdc964889d8afd1c4c4a Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Tue, 2 Sep 2008 17:34:31 +0800
Subject: [PATCH] Protect high-volume server applications from being killed.

Some classes of server applications in carrier space necessarily fork
many short-lived children (eg. call processing applications).  In an OOM
condition the parent process can be identified as an attractive kill
candidate even though the application is functioning normally and are
not responsible for the original OOM condition.  This change is
necessary on systems where normal operations are close to resource
limits and the OOM protection feature is enabled, where it is more
likely that there will be unkillable processes that would be the best
first choice for OOM killing.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 mm/oom_kill.c |   27 ---------------------------
 1 files changed, 0 insertions(+), 27 deletions(-)

diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 35b41b5..3de696e 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -57,7 +57,6 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 {
 	unsigned long points, cpu_time, run_time, s;
 	struct mm_struct *mm;
-	struct task_struct *child;
 
 	task_lock(p);
 	mm = p->mm;
@@ -99,21 +98,6 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 		return ULONG_MAX;
 
 	/*
-	 * Processes which fork a lot of child processes are likely
-	 * a good choice. We add half the vmsize of the children if they
-	 * have an own mm. This prevents forking servers to flood the
-	 * machine with an endless amount of children. In case a single
-	 * child is eating the vast majority of memory, adding only half
-	 * to the parents will make the child our kill candidate of choice.
-	 */
-	list_for_each_entry(child, &p->children, sibling) {
-		task_lock(child);
-		if (child->mm != mm && child->mm)
-			points += child->mm->total_vm/2 + 1;
-		task_unlock(child);
-	}
-
-	/*
 	 * CPU time is in tens of seconds and run time is in thousands
          * of seconds. There is no particular reason for this other than
          * that it turned out to work very well in practice.
@@ -407,7 +391,6 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 			    unsigned long points, struct mem_cgroup *mem,
 			    const char *message)
 {
-	struct task_struct *c;
 
 	if (printk_ratelimit()) {
 		printk(KERN_WARNING "%s invoked oom-killer: "
@@ -428,16 +411,6 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		return 0;
 	}
 
-	printk(KERN_ERR "%s: kill process %d (%s) score %li or a child\n",
-					message, task_pid_nr(p), p->comm, points);
-
-	/* Try to kill a child first */
-	list_for_each_entry(c, &p->children, sibling) {
-		if (c->mm == p->mm)
-			continue;
-		if (!oom_kill_task(c))
-			return 0;
-	}
 	return oom_kill_task(p);
 }
 
-- 
1.5.5.1

