From 1cf9a9ba678f7559defcc21217643fe8431998df Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 7 Jun 2013 17:29:42 +0800
Subject: [PATCH 5/5] irq_work: Workaround for the soft lockup problem on ppc

On powerpc platform, when we exit 'perf top', there is
a soft lockup happens:
  BUG: soft lockup - CPU#1 stuck for 61s! [perf:1044]
  NIP [c00e3f78] irq_work_sync+0x28/0x60
  LR [c00e709c] free_event+0x1c/0x110
  Call Trace:
  [e9b2dcf0] [c066e1b0] _mutex_unlock+0x10/0x20 (unreliable)
  [e9b2dd00] [c00e7e84] perf_event_release_kernel+0xd4/0x120
  [e9b2dd20] [c0135b04] __fput+0x104/0x220
  [e9b2dd50] [c0131358] filp_close+0x68/0xa0
  [e9b2dd70] [c005649c] put_files_struct+0x12c/0x160
  [e9b2dda0] [c00581f8] do_exit+0x148/0x700
  [e9b2ddf0] [c00587f8] do_group_exit+0x48/0xb0
  [e9b2de10] [c006e7cc] get_signal_to_deliver+0x2ac/0x4a0
  [e9b2de70] [c0009ca4] T.463+0x54/0x280
  [e9b2df30] [c0009f28] do_signal+0x58/0x60
  [e9b2df40] [c0013930] do_user_signal+0x74/0xc4
  --- Exception: c00 at 0xff17df0

After investigation, kernel is blocked in:
  void irq_work_sync()
  {
	while (irq_work_is_set(entry, IRQ_WORK_BUSY))
		cpu_relax();
  }
IRQ_WORK_BUSY keeps set in irq_work entry, and irq_work_run() didn't
run as required.

We can run irq_work_run() in irq_work_sync() so as to workaround this
problem, and this solution is harmless since irq_work_sync() only
run on task exits.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 kernel/irq_work.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/kernel/irq_work.c b/kernel/irq_work.c
index dcd95c9..e92c9bf 100644
--- a/kernel/irq_work.c
+++ b/kernel/irq_work.c
@@ -122,7 +122,9 @@ void irq_work_run(void)
 {
 	struct irq_work *list, **head;
 
+	preempt_disable();
 	head = &__get_cpu_var(irq_work_list);
+	preempt_enable();
 	if (*head == NULL)
 		return;
 
@@ -160,7 +162,14 @@ void irq_work_sync(struct irq_work *entry)
 {
 	WARN_ON_ONCE(irqs_disabled());
 
-	while (irq_work_is_set(entry, IRQ_WORK_BUSY))
+	while (irq_work_is_set(entry, IRQ_WORK_BUSY)) {
+		/*
+		 * FIXME: irq_work_run() is called here to
+		 * resolve a soft lockup problem on ppc.
+		 * Any better solution?
+		 */
+		irq_work_run();
 		cpu_relax();
+	}
 }
 EXPORT_SYMBOL_GPL(irq_work_sync);
-- 
1.7.5.4

