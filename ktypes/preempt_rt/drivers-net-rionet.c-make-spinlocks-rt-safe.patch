From 6b0ab74bed7456bdd51bd908d46a2177e6f6e8bd Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Wed, 11 Aug 2010 17:44:09 +0800
Subject: [PATCH] drivers : net : rionet.c : make spinlocks rt-safe

Change the spinlocks in the TX path to use atomic_spin_[un]lock()
to make it rt-safe, Change also rionet_outb_msg_event() function
to use the tx_lock, its actually part of the tx path, otherwise
the tx buffer will suffer starvation.

Signed-off-by: Patrik Lindergren <patrik.lindergren@windriver.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/rionet.c |   14 +++++++-------
 1 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c
index 5e82a12..c0c1af1 100644
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@ -59,7 +59,7 @@ struct rionet_private {
 	int tx_cnt;
 	int ack_slot;
 	spinlock_t lock;
-	spinlock_t tx_lock;
+	raw_spinlock_t tx_lock;
 	u32 msg_enable;
 };
 
@@ -176,11 +176,11 @@ static int rionet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	u16 destid;
 	unsigned long flags;
 
-	spin_lock_irqsave(&rnet->tx_lock, flags);
+	raw_spin_lock_irqsave(&rnet->tx_lock, flags);
 
 	if ((rnet->tx_cnt + 1) > RIONET_TX_RING_SIZE) {
 		netif_stop_queue(ndev);
-		spin_unlock_irqrestore(&rnet->tx_lock, flags);
+		raw_spin_unlock_irqrestore(&rnet->tx_lock, flags);
 		printk(KERN_ERR "%s: BUG! Tx Ring full when queue awake!\n",
 		       ndev->name);
 		return NETDEV_TX_BUSY;
@@ -198,7 +198,7 @@ static int rionet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 			rionet_queue_tx_msg(skb, ndev, rionet_active[destid]);
 	}
 
-	spin_unlock_irqrestore(&rnet->tx_lock, flags);
+	raw_spin_unlock_irqrestore(&rnet->tx_lock, flags);
 
 	return NETDEV_TX_OK;
 }
@@ -252,7 +252,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	struct net_device *ndev = dev_id;
 	struct rionet_private *rnet = netdev_priv(ndev);
 
-	spin_lock(&rnet->lock);
+	raw_spin_lock(&rnet->tx_lock);
 
 	if (netif_msg_intr(rnet))
 		printk(KERN_INFO
@@ -271,7 +271,7 @@ static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo
 	if (rnet->tx_cnt < RIONET_TX_RING_SIZE)
 		netif_wake_queue(ndev);
 
-	spin_unlock(&rnet->lock);
+	raw_spin_unlock(&rnet->tx_lock);
 }
 
 static int rionet_open(struct net_device *ndev)
@@ -473,7 +473,7 @@ static int rionet_setup_netdev(struct rio_mport *mport)
 	SET_ETHTOOL_OPS(ndev, &rionet_ethtool_ops);
 
 	spin_lock_init(&rnet->lock);
-	spin_lock_init(&rnet->tx_lock);
+	raw_spin_lock_init(&rnet->tx_lock);
 
 	rnet->msg_enable = RIONET_DEFAULT_MSGLEVEL;
 
-- 
1.6.5.2

