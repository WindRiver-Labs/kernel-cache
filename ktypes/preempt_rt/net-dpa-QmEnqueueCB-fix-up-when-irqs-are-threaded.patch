From 90fa31ee36427a3d9d57f71738b8c839a02a4259 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Fri, 31 Dec 2010 13:11:11 +0800
Subject: [PATCH 3/4] net/dpa: QmEnqueueCB fix up when irqs are threaded

backport from wrlinux-4.1

When Q/B man irqs are threaded, actually QmEnqueueCB cannot relax CPU with
udelay() which is one busy-waiting, and cpu_realx which is really implemented
only as a barrier. So the apropriate interrupt route may not be waked up to
handle QmEnqueue then sync their flag since the irqs already threaded.

So here create one work queue to make QmEnqueueCB can sleep after its QmEnqueue.
Then the interrupt route can have a chance to be scheduled to do with QmEnqueue.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |   28 +++++++++++++++++++-
 1 files changed, 27 insertions(+), 1 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 6d40dd4..dc63aa0 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -950,7 +950,16 @@ static irqreturn_t fm_err_irq(int irq, void *_dev)
     return IRQ_HANDLED;
 }
 
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+enum {
+	HC_FRMRCV_COMPLETE,
+	HC_FRMRCV_READY,
+};
+static volatile int hcFrmRcv = HC_FRMRCV_READY;
+static DECLARE_WAIT_QUEUE_HEAD(wq);
+#else
 static volatile int   hcFrmRcv = 0;
+#endif
 static spinlock_t     lock;
 
 static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
@@ -962,7 +971,12 @@ static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *
 
     FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_DpaaFD *)&dq->fd);
     spin_lock_irqsave(&lock, flags);
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	hcFrmRcv = HC_FRMRCV_COMPLETE;
+	wake_up_interruptible(&wq);
+#else
     hcFrmRcv--;
+#endif
     spin_unlock_irqrestore(&lock, flags);
 
     return qman_cb_dqrr_consume;
@@ -1042,25 +1056,37 @@ static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
 static t_Error QmEnqueueCB (t_Handle h_Arg, void *p_Fd)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
-    int             _errno, timeout=1000000;
     unsigned long flags;
+    int             _errno;
+#if !defined(CONFIG_PREEMPT_HARDIRQS) && !defined(CONFIG_PREEMPT_SOFTIRQS)
+    int             timeout=1000000;
+#endif
 
     ASSERT_COND(p_LnxWrpFmDev);
 
     spin_lock_irqsave(&lock, flags);
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	hcFrmRcv=HC_FRMRCV_READY;
+#else
     hcFrmRcv++;
+#endif
     spin_unlock_irqrestore(&lock, flags);
 //MemDisp((uint8_t*)p_Fd,sizeof(t_DpaaFD));
     _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
     if (_errno)
         RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
 
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	wait_event_interruptible_timeout(wq, hcFrmRcv == HC_FRMRCV_COMPLETE,
+			msecs_to_jiffies(250));
+#else
     while (hcFrmRcv && --timeout)
     {
         udelay(1);
         cpu_relax();
     }
     BUG_ON(!timeout);
+#endif
 
     return E_OK;
 }
-- 
1.6.5.2

