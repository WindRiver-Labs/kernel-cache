From 3e40ae3d7c458709855d64f0e487fe745993bffa Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 2 Oct 2008 14:36:20 -0400
Subject: [PATCH] lttng-instrumentation-irq

LTTng instrumentation - irq

Instrumentation of IRQ related events : irq, softirq, tasklet entry and exit and
softirq "raise" events.

It allows tracers to perform latency analysis on those various types of
interrupts and to detect interrupts with max/min/avg duration. It helps
detecting driver or hardware problems which cause an ISR to take ages to
execute. It has been shown to be the case with bogus hardware causing an mmio
read to take a few milliseconds.

Those tracepoints are used by LTTng.

About the performance impact of tracepoints (which is comparable to markers),
even without immediate values optimizations, tests done by Hideo Aoki on ia64
show no regression. His test case was using hackbench on a kernel where
scheduler instrumentation (about 5 events in code scheduler code) was added.
See the "Tracepoints" patch header for performance result detail.

Changelog:
- Add retval as irq_exit argument.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Thomas Gleixner <tglx@linutronix.de>
CC: Russell King <rmk+lkml@arm.linux.org.uk>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
diff --git a/include/trace/irq.h b/include/trace/irq.h
new file mode 100644
index 0000000..48dc584
--- /dev/null
+++ b/include/trace/irq.h
@@ -0,0 +1,36 @@
+#ifndef _TRACE_IRQ_H
+#define _TRACE_IRQ_H
+
+#include <linux/kdebug.h>
+#include <linux/interrupt.h>
+#include <linux/tracepoint.h>
+
+DEFINE_TRACE(irq_entry,
+	TPPROTO(unsigned int id, struct pt_regs *regs),
+	TPARGS(id, regs));
+DEFINE_TRACE(irq_exit,
+	TPPROTO(irqreturn_t retval),
+	TPARGS(retval));
+DEFINE_TRACE(irq_softirq_entry,
+	TPPROTO(struct softirq_action *h, struct softirq_action *softirq_vec),
+	TPARGS(h, softirq_vec));
+DEFINE_TRACE(irq_softirq_exit,
+	TPPROTO(struct softirq_action *h, struct softirq_action *softirq_vec),
+	TPARGS(h, softirq_vec));
+DEFINE_TRACE(irq_softirq_raise,
+	TPPROTO(unsigned int nr),
+	TPARGS(nr));
+DEFINE_TRACE(irq_tasklet_low_entry,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_low_exit,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_high_entry,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+DEFINE_TRACE(irq_tasklet_high_exit,
+	TPPROTO(struct tasklet_struct *t),
+	TPARGS(t));
+
+#endif
diff --git a/kernel/irq/handle.c b/kernel/irq/handle.c
index e50a04d..5bd6f1f 100644
--- a/kernel/irq/handle.c
+++ b/kernel/irq/handle.c
@@ -16,6 +16,7 @@
 #include <linux/kallsyms.h>
 #include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
+#include <trace/irq.h>
 
 #include "internals.h"
 
@@ -235,7 +236,9 @@ unsigned int __do_IRQ(unsigned int irq)
 		if (desc->chip->ack)
 			desc->chip->ack(irq);
 		if (likely(!(desc->status & IRQ_DISABLED))) {
+			trace_irq_entry(irq, NULL);
 			action_ret = _handle_IRQ_event(irq, desc->action);
+			trace_irq_exit(action_ret);
 			if (!noirqdebug)
 				note_interrupt(irq, desc, action_ret);
 		}
@@ -296,7 +299,9 @@ unsigned int __do_IRQ(unsigned int irq)
 
 		spin_unlock(&desc->lock);
 
+		trace_irq_entry(irq, NULL);
 		action_ret = _handle_IRQ_event(irq, action);
+		trace_irq_exit(action_ret);
 		if (!noirqdebug)
 			note_interrupt(irq, desc, action_ret);
 
@@ -328,7 +333,12 @@ out:
  */
 irqreturn_t handle_IRQ_event(unsigned int irq, struct irqaction *action)
 {
-	return _handle_IRQ_event(irq, action);
+	irqreturn_t ret;
+
+	trace_irq_entry(irq, NULL);
+	ret = _handle_IRQ_event(irq, action);
+	trace_irq_exit(ret);
+	return ret;
 }
 
 #ifdef CONFIG_TRACE_IRQFLAGS
diff --git a/kernel/softirq.c b/kernel/softirq.c
index 158d775..6c8b3bf 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -29,6 +29,7 @@
 #include <linux/rcupdate.h>
 #include <linux/smp.h>
 #include <linux/tick.h>
+#include <trace/irq.h>
 
 #include <asm/irq.h>
 /*
@@ -428,6 +429,7 @@ void irq_exit(void)
  */
 inline void raise_softirq_irqoff(unsigned int nr)
 {
+	trace_irq_softirq_raise(nr);
 	__do_raise_softirq_irqoff(nr);
 
 #ifdef CONFIG_PREEMPT_SOFTIRQS
@@ -580,7 +582,9 @@ out_disabled:
 			WARN_ON(1);
 
 again:
+		trace_irq_tasklet_low_entry(t);
 		t->func(t->data);
+		trace_irq_tasklet_low_exit(t);
 
 		/*
 		 * Try to unlock the tasklet. We must use cmpxchg, because
@@ -600,8 +604,10 @@ again:
 			if (test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 				goto again;
 			if (!--loops) {
+				trace_irq_tasklet_high_entry(t);
 				printk("hm, tasklet state: %08lx\n", t->state);
 				WARN_ON(1);
+				trace_irq_tasklet_high_exit(t);
 				tasklet_unlock(t);
 				break;
 			}
