From 0e1c02a022ec1dd1908c85608deedea965d50d36 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sun, 23 Jan 2011 13:10:12 -0500
Subject: [PATCH] sched.h: make kernel_sem a mutex

Also change all of its users.

This is one of several extractions from the merge up to 33-rc8.

See it in a git tip repo with:

   git diff 5f854cfc024622e4aae14d7cf422f6ff86278688^2 \
	5f854cfc024622e4aae14d7cf422f6ff86278688 \
	include/linux/sched.h

and similar for the other two files.

You can find the origin of this change in the tip merge commit:

     commit 5f854cfc024622e4aae14d7cf422f6ff86278688
     Merge: cc24da0 4ec62b2
     Author: Thomas Gleixner <tglx@linutronix.de>
     Date:   Sun Feb 21 20:17:22 2010 +0100

         Forward to 2.6.33-rc8

         Merge branch 'linus' into rt/head with a pile of conflicts.

         Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

Normally there are not significant changes/additions in a merge commit that
are not from any other "normal" commit.  But in this case there are, so
break them out into separate explicit commits.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/include/linux/sched.h b/include/linux/sched.h
index adb6b4f..15a8bb1 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -187,7 +187,8 @@ print_cfs_rq(struct seq_file *m, int cpu, struct cfs_rq *cfs_rq)
 {
 }
 #endif
-extern struct semaphore kernel_sem;
+
+extern struct mutex kernel_sem;
 
 /*
  * Task state bitmask. NOTE! These bits are also
diff --git a/kernel/rtmutex.c b/kernel/rtmutex.c
index ec2273b..16bfa1c 100644
--- a/kernel/rtmutex.c
+++ b/kernel/rtmutex.c
@@ -1028,7 +1028,7 @@ static inline int rt_release_bkl(struct rt_mutex *lock, unsigned long flags)
 	fixup_rt_mutex_waiters(lock);
 	raw_spin_unlock_irqrestore(&lock->wait_lock, flags);
 
-	up(&kernel_sem);
+	mutex_unlock(&kernel_sem);
 
 	raw_spin_lock_irq(&lock->wait_lock);
 #endif
@@ -1038,7 +1038,7 @@ static inline int rt_release_bkl(struct rt_mutex *lock, unsigned long flags)
 static inline void rt_reacquire_bkl(int saved_lock_depth)
 {
 #ifdef CONFIG_LOCK_KERNEL
-	down(&kernel_sem);
+	mutex_lock(&kernel_sem);
 	current->lock_depth = saved_lock_depth;
 #endif
 }
diff --git a/lib/kernel_lock.c b/lib/kernel_lock.c
index c63faaf..5698b3f 100644
--- a/lib/kernel_lock.c
+++ b/lib/kernel_lock.c
@@ -10,7 +10,7 @@
 #include <linux/kmemcheck.h>
 #include <linux/module.h>
 #include <linux/kallsyms.h>
-#include <linux/semaphore.h>
+#include <linux/mutex.h>
 #include <linux/smp_lock.h>
 
 #define CREATE_TRACE_POINTS
@@ -30,7 +30,7 @@
  *
  * Don't use in new code.
  */
-struct semaphore kernel_sem;
+DEFINE_MUTEX(kernel_sem);
 
 /*
  * Re-acquire the kernel semaphore.
@@ -53,7 +53,7 @@ int __lockfunc __reacquire_kernel_lock(void)
 	current->lock_depth = -1;
 	local_irq_enable();
 
-	down(&kernel_sem);
+	mutex_lock(&kernel_sem);
 
 	local_irq_disable();
 	current->lock_depth = saved_lock_depth;
@@ -63,7 +63,7 @@ int __lockfunc __reacquire_kernel_lock(void)
 
 void __lockfunc __release_kernel_lock(void)
 {
-	up(&kernel_sem);
+	mutex_unlock(&kernel_sem);
 }
 
 /*
@@ -80,7 +80,7 @@ void __lockfunc _lock_kernel(const char *func, const char *file, int line)
 		/*
 		 * No recursion worries - we set up lock_depth _after_
 		 */
-		down(&kernel_sem);
+		mutex_lock(&kernel_sem);
 #ifdef CONFIG_DEBUG_RT_MUTEXES
 		current->last_kernel_lock = __builtin_return_address(0);
 #endif
@@ -97,7 +97,7 @@ void __lockfunc _unlock_kernel(const char *func, const char *file, int line)
 #ifdef CONFIG_DEBUG_RT_MUTEXES
 		current->last_kernel_lock = NULL;
 #endif
-		up(&kernel_sem);
+		mutex_unlock(&kernel_sem);
 	}
 	trace_unlock_kernel(func, file, line);
 }
-- 
1.7.1.1

