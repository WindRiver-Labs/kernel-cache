From a699ab58190cc7720d7182e5ae7f36b61989f049 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Mon, 19 Jul 2010 13:33:37 -0700
Subject: [PATCH] preempt_rt: add missing lock release to writeback_sb_inodes()

By continuing to hold this lock the system would appear to lock-up
and produce the following trace when doing 'sync':

INFO: task sync:1384 blocked for more than 120 seconds.
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
 ffff880015d47d48 0000000000000086 ffff880015d47e20 0000000000000001
 ffff8800178ab040 ffff880015d59820 ffff880015d47d68 0000000040df09e0
 0000000000000009 ffff880001788e38 ffff880015d47d38 ffff880015d47fd8
Call Trace:
 [<ffffffff811184b0>] ? bdi_sched_wait+0x0/0x10
 [<ffffffff8146b378>] schedule+0x18/0x30
 [<ffffffff811184b9>] bdi_sched_wait+0x9/0x10
 [<ffffffff8146baa7>] __wait_on_bit+0x57/0x80
 [<ffffffff8146d102>] ? _raw_spin_unlock_irqrestore+0x12/0x40
 [<ffffffff811184b0>] ? bdi_sched_wait+0x0/0x10
 [<ffffffff8146bb43>] out_of_line_wait_on_bit+0x73/0x90
 [<ffffffff81063740>] ? wake_bit_function+0x0/0x40
 [<ffffffff811183ee>] ? bdi_queue_work+0x9e/0xd0
 [<ffffffff81118497>] bdi_sync_writeback+0x77/0x90
 [<ffffffff811184e3>] sync_inodes_sb+0x23/0x1a0
 [<ffffffff8111d290>] __sync_filesystem+0x80/0x90
 [<ffffffff8111d372>] sync_filesystems+0xd2/0x130
 [<ffffffff8111d42c>] sys_sync+0x1c/0x40
 [<ffffffff8100252b>] system_call_done+0x0/0x5

By adding the missing unlock the problem is corrected. Additional
debugging was used to validate the fix as well.

This condition was not limited to 'sync', a system left to sit could
also easily enter this unusable state.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 fs/fs-writeback.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index e220c81..2e96415 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -637,9 +637,11 @@ static int writeback_sb_inodes(struct super_block *sb,
 			spin_unlock(&inode->i_lock);
 			continue;
 		}
-		if (sb != inode->i_sb)
+		if (sb != inode->i_sb) {
 			/* finish with this superblock */
+			spin_unlock(&inode->i_lock);
 			return 0;
+		}
 		if (inode->i_state & (I_NEW | I_WILL_FREE)) {
 			requeue_io(inode);
 			spin_unlock(&inode->i_lock);
-- 
1.6.5.2

