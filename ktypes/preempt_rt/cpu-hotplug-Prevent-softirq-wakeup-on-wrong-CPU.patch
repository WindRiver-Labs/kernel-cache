From 42adb5cafc4e1451f06cc4c7adb2004eaa317298 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Fri, 3 Sep 2010 00:07:35 -0700
Subject: [PATCH 22/27] cpu-hotplug: Prevent softirq wakeup on wrong CPU

(cherry picked from tip commit 96c5397b25bfa8910d4f89ec99190edafc251525)

When the plugged CPU sets the online flag it enables interrupts and
goes idle. When an interrupt happens and tried to wakeup a softirq
thread before the other cpu sets the active flag, then the softirq
thread is put on one of the active cpus. Prevent this by waiting for
the cpu_active bit.

Temporary workaround. Needs more thought.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 arch/x86/kernel/smpboot.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 7dde247..d931197 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -348,6 +348,9 @@ notrace static void __cpuinit start_secondary(void *unused)
 	per_cpu(cpu_state, smp_processor_id()) = CPU_ONLINE;
 	x86_platform.nmi_init();
 
+	while (!cpumask_test_cpu(smp_processor_id(), cpu_active_mask))
+		cpu_relax();
+
 	/* enable local interrupts */
 	local_irq_enable();
 
-- 
1.6.5.2

