From f877d3da452160ff713d43e4a91e0a207ad59f8d Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Sun, 26 Sep 2010 00:58:03 -0700
Subject: [PATCH] preempt-rt: tracing/ftrace: Fixes the selftest failure of the tracers except the sysprof

The commit "lttng: stop tracing of the notifier atomic call chain" has
tried to fix the bug of sleeping in atomic context via disabling the
tracing instead of disabling the preemption.

But that disabling operation is not atomic, which may be preempted,
After calling tracing_stop(will set trace_stop_count), If the current
executing path is preempted and doesn't return until doing
update_max_tr(), since update_max_tr() will return directly if
trace_stop_count is set, there will be no entry in the max_tr buffer, as
a result, the selftests of the tracers fail.

$ dmesg | grep tracer | grep -v sysprof
Testing tracer nop: PASSED
Testing tracer sched_switch: PASSED
Testing tracer function: .. no entries found ..FAILED!
Testing tracer irqsoff: .. no entries found ..FAILED!
Testing tracer preemptoff: .. no entries found ..FAILED!
Testing tracer preemptirqsoff: .. no entries found ..FAILED!
Testing tracer wakeup: .. no entries found ..FAILED!
Testing tracer function_graph: .. no entries found ..FAILED!
[snip]

So, we must ensure the disabling operation is atomic, and to reduce the
overhead of the operation, for notifier_call_chain() is already notrace,
we just need to wrap the rcu_read_{lock, unlock} and we can convert
tracing_{stop, start} to ftrace_{stop, start}. The latter will set the
global function_trace_stop to stop the calling of functions from mcount,
so, the function wrapped by ftrace_{stop, start} will not be really
traced.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 kernel/notifier.c |   33 +++++++++++++++++++++++++++++----
 1 files changed, 29 insertions(+), 4 deletions(-)

diff --git a/kernel/notifier.c b/kernel/notifier.c
index e555cae..3524e51 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -6,6 +6,7 @@
 #include <linux/vmalloc.h>
 #include <linux/reboot.h>
 #include <linux/idle.h>
+#include <linux/ftrace.h>
 
 /*
  *	Notifier list for kernel code which wants to be called
@@ -154,6 +155,32 @@ int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
 }
 EXPORT_SYMBOL_GPL(atomic_notifier_chain_unregister);
 
+/*
+ * The temp implementation of the notrace variants of rcu_read_{lock,
+ * unlock}, currently, only __atomic_notifier_call_chain uses them.
+ */
+static inline void rcu_read_lock_notrace(void)
+{
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	ftrace_stop();
+	rcu_read_lock();
+	ftrace_start();
+	raw_local_irq_restore(flags);
+}
+
+static inline void rcu_read_unlock_notrace(void)
+{
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	ftrace_stop();
+	rcu_read_unlock();
+	ftrace_start();
+	raw_local_irq_restore(flags);
+}
+
 /**
  *	__atomic_notifier_call_chain - Call functions in an atomic notifier chain
  *	@nh: Pointer to head of the atomic notifier chain
@@ -179,11 +206,9 @@ int __kprobes __atomic_notifier_call_chain(struct atomic_notifier_head *nh,
 {
 	int ret;
 
-	tracing_stop();
-	rcu_read_lock();
+	rcu_read_lock_notrace();
 	ret = notifier_call_chain(&nh->head, val, v, nr_to_call, nr_calls);
-	rcu_read_unlock();
-	tracing_start();
+	rcu_read_unlock_notrace();
 
 	return ret;
 }
-- 
1.6.5.2

