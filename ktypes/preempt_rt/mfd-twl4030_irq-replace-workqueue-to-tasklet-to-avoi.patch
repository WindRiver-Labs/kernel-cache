From f98e361b86e6c8059cd37f1dda9bd775785dabb0 Mon Sep 17 00:00:00 2001
From: Hui Wang <Hui.Wang@windriver.com>
Date: Fri, 14 Jan 2011 11:26:53 +0800
Subject: [PATCH 2/4] mfd/twl4030_irq: replace workqueue to tasklet to avoid warnings

When we suspend and resume the whole system, the following warnings
print out:
root@localhost:/root> echo mem > /sys/power/state
Freezing user space processes ... (elapsed 0.02 seconds) done.
Freezing remaining freezable tasks ... (elapsed 0.01 seconds) done.
Suspending console(s) (use no_console_suspend to debug)
Could not enter target state in pm_suspend
BUG: sleeping function called from invalid context at
/buildarea3/hwang4/work41/3530prt/build/linux/kernel/rtmutex.c:707
pcnt: 2 0 in_atomic(): 1, irqs_disabled(): 128, pid: 582, name: bash
[<c003e7d4>] [<c04ad88c>] (rt_spin_lock+0x30/0x5c)
[<c04ad88c>] [<c007d7f8>] (__queue_work+0x10/0x2c)
[<c007d7f8>] [<c007d87c>] (queue_work_on+0x50/0x5c)
[<c007d87c>] [<c033000c>] (twl4030_sih_unmask+0x4c/0x8c)
[<c033000c>] [<c00b2290>] (default_enable+0x20/0x30)
[<c00b2290>] [<c00b2104>] (check_irq_resend+0x20/0x98)
[<c00b2104>] [<c00b1210>] (__enable_irq+0x70/0x88)
[<c00b1210>] [<c00b3a58>] (resume_device_irqs+0x58/0xac)
[<c00b3a58>] [<c0098f14>] (suspend_devices_and_enter+0x18c/0x204)
[<c0098f14>] [<c0099048>] (enter_state+0xbc/0x120)
[<c0099048>] [<c0098768>] (state_store+0xa4/0xb8)
[<c0098768>] [<c02d2098>] (kobj_attr_store+0x18/0x1c)
[<c02d2098>] [<c014631c>] (sysfs_write_file+0x108/0x13c)
[<c014631c>] [<c00fc5f0>] (vfs_write+0xb0/0x128)
[<c00fc5f0>] [<c00fc7c0>] (sys_write+0x44/0xf4)
[<c00fc7c0>] [<c0037f00>] (ret_fast_syscall+0x0/0x30)
Restarting tasks ...
done.

This is because the spin_lock functions are sleepable in the
preempt_rt kernel, but these functions are called in an atomic and
irq_disabled context through queue_work()->__queue_work().

To avoid this issue, we replace workqueue with tasklet, it is safe
because:
1) tasklet_schedule() take similar functions of queue_work(), but it
can be called in the atomic and irq_disabled context.
2) in the preempt_rt kernel, tasklet is executing in kthread context
just like the workqueue does.

Signed-off-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/mfd/twl4030-irq.c |   43 ++++++++++++++++++++++---------------------
 1 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/drivers/mfd/twl4030-irq.c b/drivers/mfd/twl4030-irq.c
index d15e4d0..6a67da3 100644
--- a/drivers/mfd/twl4030-irq.c
+++ b/drivers/mfd/twl4030-irq.c
@@ -277,6 +277,13 @@ static unsigned twl4030_irq_base;
 
 static struct completion irq_event;
 
+static void twl4030_sih_do_mask(unsigned long);
+static void twl4030_sih_do_edge(unsigned long);
+
+
+static DECLARE_TASKLET_DISABLED(sih_mask_tasklet, twl4030_sih_do_mask, 0);
+static DECLARE_TASKLET_DISABLED(sih_edge_tasklet, twl4030_sih_do_edge, 0);
+
 /*
  * This thread processes interrupts reported by the Primary Interrupt Handler.
  */
@@ -475,21 +482,17 @@ static inline void activate_irq(int irq)
 
 static DEFINE_RAW_SPINLOCK(sih_agent_lock);
 
-static struct workqueue_struct *wq;
-
 struct sih_agent {
 	int			irq_base;
 	const struct sih	*sih;
 
 	u32			imr;
 	bool			imr_change_pending;
-	struct work_struct	mask_work;
 
 	u32			edge_change;
-	struct work_struct	edge_work;
 };
 
-static void twl4030_sih_do_mask(struct work_struct *work)
+static void twl4030_sih_do_mask(unsigned long sih_agent)
 {
 	struct sih_agent	*agent;
 	const struct sih	*sih;
@@ -499,7 +502,7 @@ static void twl4030_sih_do_mask(struct work_struct *work)
 	}			imr;
 	int			status;
 
-	agent = container_of(work, struct sih_agent, mask_work);
+	agent = (struct sih_agent *)sih_agent;
 
 	/* see what work we have */
 	raw_spin_lock_irq(&sih_agent_lock);
@@ -522,7 +525,7 @@ static void twl4030_sih_do_mask(struct work_struct *work)
 				"write", status);
 }
 
-static void twl4030_sih_do_edge(struct work_struct *work)
+static void twl4030_sih_do_edge(unsigned long sih_agent)
 {
 	struct sih_agent	*agent;
 	const struct sih	*sih;
@@ -530,7 +533,7 @@ static void twl4030_sih_do_edge(struct work_struct *work)
 	u32			edge_change;
 	int			status;
 
-	agent = container_of(work, struct sih_agent, edge_work);
+	agent = (struct sih_agent *)sih_agent;
 
 	/* see what work we have */
 	raw_spin_lock_irq(&sih_agent_lock);
@@ -604,7 +607,8 @@ static void twl4030_sih_mask(unsigned irq)
 	raw_spin_lock_irqsave(&sih_agent_lock, flags);
 	sih->imr |= BIT(irq - sih->irq_base);
 	sih->imr_change_pending = true;
-	queue_work(wq, &sih->mask_work);
+	sih_mask_tasklet.data = (unsigned long)sih;
+	tasklet_schedule(&sih_mask_tasklet);
 	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 }
 
@@ -616,7 +620,8 @@ static void twl4030_sih_unmask(unsigned irq)
 	raw_spin_lock_irqsave(&sih_agent_lock, flags);
 	sih->imr &= ~BIT(irq - sih->irq_base);
 	sih->imr_change_pending = true;
-	queue_work(wq, &sih->mask_work);
+	sih_mask_tasklet.data = (unsigned long)sih;
+	tasklet_schedule(&sih_mask_tasklet);
 	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 }
 
@@ -639,7 +644,8 @@ static int twl4030_sih_set_type(unsigned irq, unsigned trigger)
 		desc->status &= ~IRQ_TYPE_SENSE_MASK;
 		desc->status |= trigger;
 		sih->edge_change |= BIT(irq - sih->irq_base);
-		queue_work(wq, &sih->edge_work);
+		sih_edge_tasklet.data = (unsigned long)sih;
+		tasklet_schedule(&sih_edge_tasklet);
 	}
 	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 	return 0;
@@ -745,8 +751,6 @@ int twl4030_sih_setup(int module)
 	agent->irq_base = irq_base;
 	agent->sih = sih;
 	agent->imr = ~0;
-	INIT_WORK(&agent->mask_work, twl4030_sih_do_mask);
-	INIT_WORK(&agent->edge_work, twl4030_sih_do_edge);
 
 	for (i = 0; i < sih->bits; i++) {
 		irq = irq_base + i;
@@ -795,12 +799,6 @@ int twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)
 	if (status < 0)
 		return status;
 
-	wq = create_singlethread_workqueue("twl4030-irqchip");
-	if (!wq) {
-		pr_err("twl4030: workqueue FAIL\n");
-		return -ESRCH;
-	}
-
 	twl4030_irq_base = irq_base;
 
 	/* install an irq handler for each of the SIH modules;
@@ -846,6 +844,10 @@ int twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)
 		status = PTR_ERR(task);
 		goto fail_kthread;
 	}
+
+	tasklet_enable(&sih_mask_tasklet);
+	tasklet_enable(&sih_edge_tasklet);
+
 	return status;
 fail_kthread:
 	free_irq(irq_num, &irq_event);
@@ -854,8 +856,7 @@ fail_rqirq:
 fail:
 	for (i = irq_base; i < irq_end; i++)
 		set_irq_chip_and_handler(i, NULL, NULL);
-	destroy_workqueue(wq);
-	wq = NULL;
+
 	return status;
 }
 
-- 
1.6.5.2

