From 943f11c185514660e9cd87042ad28adcbc4159ec Mon Sep 17 00:00:00 2001
From: Fredrik Markstrom <fredrik.markstrom@gmail.com>
Date: Tue, 22 Apr 2014 15:20:04 +0800
Subject: [PATCH] tasklet: fix a race condition in the state-bit flipping in softirq.c

If a thread got preempted in tasklet_schedule after setting the SCHED bit but
before taking the "lock", the restart code in tasklet_action() can can run the
tasklet and clear SCHED. If other threads in the system schedule the task
again before the first tasklet_schedule() may run again it will successfully
set SCHED again and add the tasklet to a tasklet queue. If this happens and the
first tasklet_schedule() continues it will successfully get the lock and it
will verify that the SCHED bit is taken and add the tasklet queue, this is
wrong since it's already in a tasklet queue. The consequences are that the
tasklet will run one time too many and tasklets behind it in the first list
potentially on the wrong cpu.

Signed-off-by: Fredrik Markstrom <fredrik.markstrom@gmail.com>
Signed-off-by: baogen shang <baogen.shang@windriver.com>
---
 include/linux/interrupt.h |    6 ++--
 kernel/softirq.c          |   72 ++++++++++++++++++++++++++++-----------------
 2 files changed, 48 insertions(+), 30 deletions(-)

diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index ab50dcb..ea5023e 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -500,7 +500,7 @@ extern void __tasklet_schedule(struct tasklet_struct *t);
 
 static inline void tasklet_schedule(struct tasklet_struct *t)
 {
-	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+	if (!test_bit(TASKLET_STATE_SCHED, &t->state))
 		__tasklet_schedule(t);
 }
 
@@ -508,7 +508,7 @@ extern void __tasklet_hi_schedule(struct tasklet_struct *t);
 
 static inline void tasklet_hi_schedule(struct tasklet_struct *t)
 {
-	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+	if (!test_bit(TASKLET_STATE_SCHED, &t->state))
 		__tasklet_hi_schedule(t);
 }
 
@@ -522,7 +522,7 @@ extern void __tasklet_hi_schedule_first(struct tasklet_struct *t);
  */
 static inline void tasklet_hi_schedule_first(struct tasklet_struct *t)
 {
-	if (!test_and_set_bit(TASKLET_STATE_SCHED, &t->state))
+	if (!test_bit(TASKLET_STATE_SCHED, &t->state))
 		__tasklet_hi_schedule_first(t);
 }
 
diff --git a/kernel/softirq.c b/kernel/softirq.c
index de2bd27..3f2142c 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -592,34 +592,52 @@ static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);
 static void inline
 __tasklet_common_schedule(struct tasklet_struct *t, struct tasklet_head *head, unsigned int nr)
 {
-	if (tasklet_trylock(t)) {
-again:
-		/* We may have been preempted before tasklet_trylock
-		 * and __tasklet_action may have already run.
-		 * So double check the sched bit while the takslet
-		 * is locked before adding it to the list.
+	do  {
+		/* Read the current value of t->state and mask out RUN and
+		 * SCHED, we need to do this to be agnostic to bits other
+		 * (PENDING) then the two we are interested in.
 		 */
-		if (test_bit(TASKLET_STATE_SCHED, &t->state)) {
-			t->next = NULL;
-			*head->tail = t;
-			head->tail = &(t->next);
-			raise_softirq_irqoff(nr);
-			tasklet_unlock(t);
-		} else {
-			/* This is subtle. If we hit the corner case above
-			 * It is possible that we get preempted right here,
-			 * and another task has successfully called
-			 * tasklet_schedule(), then this function, and
-			 * failed on the trylock. Thus we must be sure
-			 * before releasing the tasklet lock, that the
-			 * SCHED_BIT is clear. Otherwise the tasklet
-			 * may get its SCHED_BIT set, but not added to the
-			 * list
-			 */
-			if (!tasklet_tryunlock(t))
-				goto again;
-		}
-	}
+		unsigned long exp =
+			t->state & ~(TASKLET_STATEF_RUN | TASKLET_STATEF_SCHED);
+
+		/* If neither RUN nor SCHED is set, set them both and shedule
+		 * the tasklet.
+		 */
+		if (cmpxchg(&t->state, exp,
+			    (exp | TASKLET_STATEF_RUN | TASKLET_STATEF_SCHED))
+		    == exp)
+			break;
+
+		/* If RUN is set but not SCHED, set SCHED and return. The
+		 * restart code (goto again) in __tasklet_action() will take
+		 * care of running the tasklet once more.
+		 */
+		else if (cmpxchg(&t->state, exp | TASKLET_STATEF_RUN,
+				 exp|TASKLET_STATEF_RUN|TASKLET_STATEF_SCHED)
+			 == exp | TASKLET_STATEF_RUN)
+			return;
+
+		/* If SCHED is already set, do nothing...
+		 * This tests is also done in interrupt.h, but SCHED might have
+		 * been set after that, if it is we don't want to end up looping
+		 * forever.
+		 */
+		else if (t->state & TASKLET_STATEF_SCHED)
+			return;
+
+		/* We didn't match any of the if():s above and that means
+		 * t->state changed between the tests, because the tests covers
+		 * all possible combinations. Try again and lets hope it's
+		 * nothing changes this time.
+		 */
+	} while (1);
+
+	t->next = NULL;
+	*head->tail = t;
+	head->tail = &(t->next);
+	raise_softirq_irqoff(nr);
+
+	tasklet_unlock(t);
 }
 
 void __tasklet_schedule(struct tasklet_struct *t)
-- 
1.7.0

