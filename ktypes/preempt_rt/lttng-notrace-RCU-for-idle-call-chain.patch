From d730abf1b5e705269004f2a1298e71dab38c9014 Mon Sep 17 00:00:00 2001
From: Bi Junxiao <Junxiao.Bi@windriver.com>
Date: Tue, 15 Mar 2011 11:18:08 +0800
Subject: [PATCH] lttng: notrace RCU for idle call chain

Lttng uses idle call chain from cpu idle entry to ensure the tracer
flush the last events in the current subbuffer. And this requires
the rcu read-side to be marked "no trace". The original idle call
chain is implemented by atomic_notifier call chain and replaces
rcu_read_lock with rcu_read_lock_sched_notrace. This is not a big
deal in standard kernel. But in the preempt_rt kernel, things
change.  rcu_read_lock_sched_notrace disables the kernel preemption
and this will cause a lot of call trace saying "function sleeping in
atomic context". As there is no available RCU lock which allows
kernel preemption and notrace now, and also it's not easy to
implement one since rcu_read_unlock is complicated and invokes a lot
of functions. So implement a separate idle call chain.

Signed-off-by: Junxiao Bi <junxiao.bi@windriver.com>

diff --git a/kernel/notifier.c b/kernel/notifier.c
index 0230f2e..87abfb7 100644
--- a/kernel/notifier.c
+++ b/kernel/notifier.c
@@ -587,7 +587,8 @@ int unregister_die_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL_GPL(unregister_die_notifier);
 
-static ATOMIC_NOTIFIER_HEAD(idle_notifier);
+static RAW_NOTIFIER_HEAD(idle_notifier);
+static DEFINE_SPINLOCK(idle_notifier_lock);
 
 /*
  * Trace last event before calling notifiers. Notifiers flush data from buffers
@@ -595,18 +596,33 @@ static ATOMIC_NOTIFIER_HEAD(idle_notifier);
  */
 int notrace notify_idle(enum idle_val val)
 {
-	return atomic_notifier_call_chain(&idle_notifier, val, NULL);
+	int ret;
+
+	rcu_read_lock_sched_notrace();
+	ret = notifier_call_chain(&idle_notifier.head, val, NULL, -1, NULL);
+	rcu_read_unlock_sched_notrace();
+
+	return ret;
 }
 EXPORT_SYMBOL_GPL(notify_idle);
 
 void register_idle_notifier(struct notifier_block *n)
 {
-	atomic_notifier_chain_register(&idle_notifier, n);
+	unsigned long flags;
+
+	spin_lock_irqsave(&idle_notifier_lock, flags);
+	notifier_chain_register(&idle_notifier.head, n);
+	spin_unlock_irqrestore(&idle_notifier_lock, flags);
 }
 EXPORT_SYMBOL_GPL(register_idle_notifier);
 
 void unregister_idle_notifier(struct notifier_block *n)
 {
-	atomic_notifier_chain_unregister(&idle_notifier, n);
+	unsigned long flags;
+
+	spin_lock_irqsave(&idle_notifier_lock, flags);
+	notifier_chain_unregister(&idle_notifier.head, n);
+	spin_unlock_irqrestore(&idle_notifier_lock, flags);
+	synchronize_sched();
 }
 EXPORT_SYMBOL_GPL(unregister_idle_notifier);
-- 
1.7.4

