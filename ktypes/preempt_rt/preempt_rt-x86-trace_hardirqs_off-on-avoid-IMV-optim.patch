From 358a4d1a570f1840cf593583a2ef782b541fbe31 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Fri, 20 Aug 2010 12:51:06 -0700
Subject: [PATCH] preempt_rt: x86: trace_hardirqs_off/on avoid IMV optimazation

Use the variant of trace_preemptirqsoff_hist() which does not make use
of the immediate value optimizations (ie. the one that starts
with an underscore) for the preemptirqsoff tracer. If we do use the IMV
optimization, attempting the text_poke which places the
BREAKPOINT_INSTRUCTION in arch_imv_update() will cause a fault which
will reboot the system.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 kernel/trace/trace_irqsoff.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c
index 4896b88..f0a3ba2 100644
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@ -309,7 +309,7 @@ inline void print_irqtrace_events(struct task_struct *curr)
  */
 void trace_hardirqs_on(void)
 {
-	trace_preemptirqsoff_hist(IRQS_ON, 0);
+	_trace_preemptirqsoff_hist(IRQS_ON, 0);
 	if (!preempt_trace() && irq_trace())
 		stop_critical_timing(CALLER_ADDR0, CALLER_ADDR1);
 }
@@ -319,7 +319,7 @@ void trace_hardirqs_off(void)
 {
 	if (!preempt_trace() && irq_trace())
 		start_critical_timing(CALLER_ADDR0, CALLER_ADDR1);
-	trace_preemptirqsoff_hist(IRQS_OFF, 1);
+	_trace_preemptirqsoff_hist(IRQS_OFF, 1);
 }
 EXPORT_SYMBOL(trace_hardirqs_off);
 
-- 
1.6.5.2

