From 035d2a06dae18ee424d75a98acf3cd7f33a5b95e Mon Sep 17 00:00:00 2001
From: Matt Sherer <matt.sherer@windriver.com>
Date: Thu, 2 Sep 2010 14:56:07 -0700
Subject: [PATCH] preempt_rt: x86: trace_hardirqs_off/on avoid IMV optimization

Use the variant of trace_preemptirqsoff_hist() which does not make use
of the immediate value optimizations (ie. the one that starts
with an underscore) for the preemptirqsoff tracer. If we do use the IMV
optimization, attempting the text_poke which places the
BREAKPOINT_INSTRUCTION in arch_imv_update() will cause a fault which
will reboot the system.

This patch was in place previously for other tracing calls but needs
to be extended to cover trace_hardirqs_o{n,ff}_caller().
---
 kernel/trace/trace_irqsoff.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c
index f0a3ba2..e0c0a4a 100644
--- a/kernel/trace/trace_irqsoff.c
+++ b/kernel/trace/trace_irqsoff.c
@@ -325,7 +325,7 @@ EXPORT_SYMBOL(trace_hardirqs_off);
 
 void trace_hardirqs_on_caller(unsigned long caller_addr)
 {
-	trace_preemptirqsoff_hist(IRQS_ON, 0);
+	_trace_preemptirqsoff_hist(IRQS_ON, 0);
 	if (!preempt_trace() && irq_trace())
 		stop_critical_timing(CALLER_ADDR0, caller_addr);
 }
@@ -335,7 +335,7 @@ void trace_hardirqs_off_caller(unsigned long caller_addr)
 {
 	if (!preempt_trace() && irq_trace())
 		start_critical_timing(CALLER_ADDR0, caller_addr);
-	trace_preemptirqsoff_hist(IRQS_OFF, 1);
+	_trace_preemptirqsoff_hist(IRQS_OFF, 1);
 }
 EXPORT_SYMBOL(trace_hardirqs_off_caller);
 
-- 
1.6.5.2

