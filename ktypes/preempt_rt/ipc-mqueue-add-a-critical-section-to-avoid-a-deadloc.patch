From eccc9a93230ba33b1bacf878589ce846549995a5 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 11 Oct 2012 10:38:21 +0800
Subject: [PATCH] ipc/mqueue: add a critical section to avoid a deadlock

commit f1c3c947ac5f2f33ba5b7fe02ce1055fded51130 upstream

In POSIX message queue, if a sender process has a higher priority than
a receiver process, the sender will be stuck at ipc/mqueue.c:447
  446                 while (ewp->state == STATE_PENDING)
  447                         cpu_relax();
Description of the problem
 (receiver process)
   1. receiver changes sender's state to STATE_PENDING (mqueue.c:840)
   2. wake up sender process and "switch to sender" (mqueue.c:841)
      Note: This context switch only happens in PREEMPT_RT kernel.
 (sender process)
   3. sender check the own state in above loop (mqueue.c:446-447)
   *. receiver will never wake up and cannot change sender's state to
      STATE_READY because sender has higher priority

Signed-off-by: Yoshitake Kobayashi <yoshitake.kobayashi@toshiba.co.jp>
Cc: viro@zeniv.linux.org.uk
Cc: dchinner@redhat.com
Cc: npiggin@kernel.dk
Cc: hch@lst.de
Cc: arnd@arndb.de
Link: http://lkml.kernel.org/r/4E2A38A0.1090601@toshiba.co.jp
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 ipc/mqueue.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index 11919ce..7992e0b 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -835,12 +835,17 @@ static inline void pipelined_receive(struct mqueue_inode_info *info)
 		wake_up_interruptible(&info->wait_q);
 		return;
 	}
+	/*
+	 * Keep them in one critical section for PREEMPT_RT:
+	 */
+	preempt_disable_rt();
 	msg_insert(sender->msg, info);
 	list_del(&sender->list);
 	sender->state = STATE_PENDING;
 	wake_up_process(sender->task);
 	smp_wmb();
 	sender->state = STATE_READY;
+	preempt_enable_rt();
 }
 
 SYSCALL_DEFINE5(mq_timedsend, mqd_t, mqdes, const char __user *, u_msg_ptr,
-- 
1.7.0

