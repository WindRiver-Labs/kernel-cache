trace: shared tasklet_action for high and low

From: Paul Gortmaker <paul.gortmaker@windriver.com>

The RT patches have a shared tasklet_action that is used
for what was before the tasklet_hi_action and the
tasklet_low_action.  Properly demux onto the right trace
call, given the caller of the now shared tasklet_action.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

---
 kernel/softirq.c |   20 ++++++++++++++------
 1 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/kernel/softirq.c b/kernel/softirq.c
index a78f949..0c070e5 100644
--- a/kernel/softirq.c
+++ b/kernel/softirq.c
@@ -555,7 +555,8 @@ void  tasklet_hi_enable(struct tasklet_struct *t)
 EXPORT_SYMBOL(tasklet_hi_enable);
 
 static void
-__tasklet_action(struct softirq_action *a, struct tasklet_struct *list)
+__tasklet_action(struct softirq_action *a, struct tasklet_struct *list,
+			int high)
 {
 	int loops = 1000000;
 
@@ -598,11 +599,18 @@ out_disabled:
 		 */
 		if (!test_and_clear_bit(TASKLET_STATE_SCHED, &t->state))
 			WARN_ON(1);
-				trace_irq_tasklet_low_entry(t);
 
 again:
-		t->func(t->data);
-				trace_irq_tasklet_low_exit(t);
+		if (high) {
+			trace_irq_tasklet_high_entry(t);
+			t->func(t->data);
+			trace_irq_tasklet_high_exit(t);
+
+		} else {
+			trace_irq_tasklet_low_entry(t);
+			t->func(t->data);
+			trace_irq_tasklet_low_exit(t);
+		}
 
 		/*
 		 * Try to unlock the tasklet. We must use cmpxchg, because
@@ -641,7 +649,7 @@ static void tasklet_action(struct softirq_action *a)
 	__get_cpu_var(tasklet_vec).tail = &__get_cpu_var(tasklet_vec).head;
 	local_irq_enable();
 
-	__tasklet_action(a, list);
+	__tasklet_action(a, list, 0);
 }
 
 static void tasklet_hi_action(struct softirq_action *a)
@@ -654,7 +662,7 @@ static void tasklet_hi_action(struct softirq_action *a)
 	__get_cpu_var(tasklet_hi_vec).tail = &__get_cpu_var(tasklet_hi_vec).head;
 	local_irq_enable();
 
-	__tasklet_action(a, list);
+	__tasklet_action(a, list, 1);
 }
 
 
