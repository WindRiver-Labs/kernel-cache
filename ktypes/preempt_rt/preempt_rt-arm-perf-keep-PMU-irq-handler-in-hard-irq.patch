From 0dce55ba56913389a365b9e8416649d266c56a59 Mon Sep 17 00:00:00 2001
From: Hui Wang <Hui.Wang@windriver.com>
Date: Wed, 12 Oct 2011 17:18:27 +0800
Subject: [PATCH] preempt_rt/arm/perf: keep PMU irq handler in hard irq context

When we execute "opcontrol --start" on the ARM hw_perf capable
platforms which is running a preempt_rt kernel, it will produce crash
like this:

Using 2.6+ OProfile kernel interface.
Using log file /var/lib/oprofile/samples/oprofiled.log
Daemon started.
Unable to handle kernel NULL pointer dereference at virtual address
pgd = c0004000
[00000040] *pgd=00000000

This is because the PMU irq handler is threaded in the preempt_rt
kernel, it will pass a NULL for pt_regs. While oprofile_add_sample()
will access pt_regs, this will produce crash.

To solve it, add a IRQF_NODELAY flag to tell kernel not thread this
irq handler.

Signed-off-by: Hui Wang <Hui.Wang@windriver.com>
---
 arch/arm/kernel/perf_event.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index b2d6945..86156d9 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -373,7 +373,8 @@ armpmu_reserve_hardware(void)
 
 	for (i = 0; i < pmu_irqs->num_irqs; ++i) {
 		err = request_irq(pmu_irqs->irqs[i], armpmu->handle_irq,
-				  IRQF_DISABLED | IRQF_NOBALANCING,
+				  IRQF_DISABLED | IRQF_NOBALANCING |
+				  IRQF_NODELAY,
 				  "armpmu", NULL);
 		if (err) {
 			pr_warning("unable to request IRQ%d for ARM "
-- 
1.7.0.2

