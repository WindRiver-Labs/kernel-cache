Subject: rt: move update_wall_time back to do timer
From: Thomas Gleixner <tglx@linutronix.de>
Date: Wed, 30 Apr 2008 15:01:10 +0200

Heavy networking or high load rt tasks can starve the timer
softirq. This can result in long loops in update_wall_time() once the
timer softirq gets hold of the CPU again. This code runs with
interrupts disabled and xtime lock write locked, so it can introduce
pretty long latencies. Move update_wall_time() back into do_timer, so
we avoid the looping and have a small but constant length irq off
section every tick.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 kernel/timer.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/timer.c b/kernel/timer.c
index 3a2ff53..5f8d51f 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -1159,7 +1159,6 @@ static inline void update_times(void)
 	ticks = jiffies - last_tick;
 	if (ticks) {
 		last_tick += ticks;
-		update_wall_time();
 		calc_load(ticks);
 	}
 	write_sequnlock_irqrestore(&xtime_lock, flags);
@@ -1189,6 +1188,7 @@ static void run_timer_softirq(struct softirq_action *h)
 void do_timer(unsigned long ticks)
 {
 	jiffies_64 += ticks;
+	update_wall_time();
 	trace_clock_add_timestamp(ticks);
 	trace_timer_update_time(&xtime, &wall_to_monotonic);
 }
