From 26b852fcc2e2d4290910c92a8293e76e32605f71 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 19 Sep 2011 12:56:59 +0800
Subject: [PATCH] preempt_rt/gianfar: Fix ARP suspend/resume generate call trace

During suspend/resume operation, sleepable spinlocks introduce
call trace:
BUG: sleeping function called from invalid context at linux/kernel/rtmutex.c:707
pcnt: 0 0 in_atomic(): 0, irqs_disabled(): 1, pid: 662, name: bash
Call Trace:
[ee21bca0] [c00084e0] show_stack+0x44/0x160 (unreliable)
[ee21bcd0] [c003eb6c] __might_sleep+0xe4/0x108
[ee21bce0] [c05ec2d4] rt_spin_lock+0x38/0xb4
[ee21bcf0] [c0450220] lock_tx_qs+0x38/0x58
[ee21bd10] [c0450500] gfar_suspend+0xd8/0x62c
[ee21bd50] [c04fe4a4] of_platform_pm_suspend+0x38/0x70
[ee21bd60] [c03d9fb4] pm_op+0x238/0x2c8
[ee21bd90] [c03da74c] __device_suspend+0x104/0x18c
[ee21bdc0] [c03dadcc] dpm_suspend_start+0x290/0x44c
[ee21be30] [c00927f4] suspend_devices_and_enter+0x98/0x20c
[ee21be60] [c0092a4c] enter_state+0xe4/0xf4
[ee21be80] [c0091fd4] state_store+0x9c/0xf8
[ee21bea0] [c0359eb4] kobj_attr_store+0x24/0x3c
[ee21beb0] [c01812ac] sysfs_write_file+0xe4/0x1dc
[ee21bee0] [c01210ec] vfs_write+0xb4/0x188
[ee21bf00] [c0121334] sys_write+0x50/0x10c
[ee21bf40] [c00124c4] ret_from_syscall+0x0/0x4

Preempt-rt kernel introduce SYSTEM_SUSPEND state to prevent
such condition. The commit log as following:

timekeeping suspend/resume calls read_persistant_clock() which takes
rtc_lock. That results in might sleep warnings because at that point
we run with interrupts disabled.

We cannot convert rtc_lock to a raw spinlock as that would trigger
other might sleep warnings.

As a temporary workaround we disable the might sleep warnings by
setting system_state to SYSTEM_SUSPEND before calling sysdev_suspend()
and restoring it to SYSTEM_RUNNING afer sysdev_resume().

For GIANFAR driver, suspend() & resume() routines are called after
suspend_freeze_processes() and before suspend_thaw_processes()
routines during suspend & resume process. And interrupts have
been disabled, it is safe to get a spinlock without might_sleep
check.

Set system_state to SYSTEM_SUSPEND could force skipping might_sleep
check.

Preempt-rt kernel involved same strategy for sysdev_suspend() &
sysdev_resume() routines.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/gianfar.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 027590a..611090b 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -1634,6 +1634,7 @@ static int gfar_arp_suspend(struct net_device *dev)
 
 	if (netif_running(dev)) {
 		local_irq_save(flags);
+		system_state = SYSTEM_SUSPEND;
 		lock_tx_qs(priv);
 		lock_rx_qs(priv);
 
@@ -1646,6 +1647,7 @@ static int gfar_arp_suspend(struct net_device *dev)
 
 		unlock_rx_qs(priv);
 		unlock_tx_qs(priv);
+		system_state = SYSTEM_RUNNING;
 		local_irq_restore(flags);
 
 		disable_napi(priv);
-- 
1.7.0.4

