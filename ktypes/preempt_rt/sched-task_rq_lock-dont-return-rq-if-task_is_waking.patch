From cf550b0024a5ab76bb66042442c5c649c090ec66 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 4 Jan 2011 11:54:05 -0500
Subject: [PATCH] sched: task_rq_lock, dont return rq if task_is_waking

The cherry pick of upstream 65cc8e4859ff29a9ddc989c88557d6059834c2a2
causes issues for RT (specifically, posix pthread_join/6-3.test will
cause an oops and hang the system) because RT uses TASK_WAKING
differently.  A full revert isn't required - just restoring two of
the task_is_waiting() checks that were removed by 65cc8e4 solves the
problem.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/sched.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 3bd3b69..b45b19e 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -1010,7 +1010,7 @@ static inline struct rq *__task_rq_lock(struct task_struct *p)
 	for (;;) {
 		rq = task_rq(p);
 		raw_spin_lock(&rq->lock);
-		if (likely(rq == task_rq(p)))
+		if (likely(rq == task_rq(p) && !task_is_waking(p)))
 			return rq;
 		raw_spin_unlock(&rq->lock);
 	}
@@ -1030,7 +1030,7 @@ static struct rq *task_rq_lock(struct task_struct *p, unsigned long *flags)
 		local_irq_save(*flags);
 		rq = task_rq(p);
 		raw_spin_lock(&rq->lock);
-		if (likely(rq == task_rq(p)))
+		if (likely(rq == task_rq(p) && !task_is_waking(p)))
 			return rq;
 		raw_spin_unlock_irqrestore(&rq->lock, *flags);
 	}
-- 
1.7.1

