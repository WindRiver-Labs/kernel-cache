From 06a305fa7a51de8444b741be7b6d9f15b9751207 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Sat, 1 Jan 2011 22:40:03 -0500
Subject: [PATCH] sched: TASK_WAKING state is not exclusive, part II

The commit for:
  "sched: move_task_off_dead_cpu(): Take rq->lock around select_fallback_rq()"

in RT on 2.6.33 had an "almost" cherry pick of upstream commit
1445c08d06c5594895b4fae952ef8a457e89c390, contained in commit
ae35e6fffd929f71b6ea1193862d50b56b636a1b on tip.  The difference
in these two almost identical commits is just the same issue
seen previously with respect to testing for equality on the
TASK_WAKING being not valid in RT.

With 2.6.34.x incorporating the upstream version, and hence the
RT queue dropping the tip version of this commit, we have to
restore the delta between the two, so that RT checks for the
set bit and not complete equality.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/sched.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index 96646b0..3bd3b69 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -5877,7 +5877,7 @@ void move_task_off_dead_cpu(int dead_cpu, struct task_struct *p)
 	local_irq_save(flags);
 
 	raw_spin_lock(&rq->lock);
-	needs_cpu = (task_cpu(p) == dead_cpu) && (p->state != TASK_WAKING);
+	needs_cpu = (task_cpu(p) == dead_cpu) && !(p->state & TASK_WAKING);
 	if (needs_cpu)
 		dest_cpu = select_fallback_rq(dead_cpu, p);
 	raw_spin_unlock(&rq->lock);
-- 
1.7.1

