From 73c957bf7dd267be0bd27a0ffbc490b7d7612041 Mon Sep 17 00:00:00 2001
From: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
Date: Thu, 30 Oct 2008 23:27:12 -0400
Subject: [PATCH] lttng-instrumentation-fs

LTTng instrumentation - fs

Core filesystem tracepoints.

Tracepoints added :

fs_buffer_wait_end
fs_buffer_wait_start
fs_close
fs_exec
fs_ioctl
fs_llseek
fs_lseek
fs_open
fs_poll
fs_pread64
fs_pwrite64
fs_read
fs_readv
fs_select
fs_write
fs_writev

Instrument the core FS events, extracting the information when it is available.
e.g. the instrumentation of "reads" is inserted _after_ the read, when
the information is ready. This would not be possible if the instrumentation
would be placed elsewhere (at the beginning of the system call for instance).

Those tracepoints are used by LTTng.

About the performance impact of tracepoints (which is comparable to markers),
even without immediate values optimizations, tests done by Hideo Aoki on ia64
show no regression. His test case was using hackbench on a kernel where
scheduler instrumentation (about 5 events in code scheduler code) was added.
See the "Tracepoints" patch header for performance result detail.

Signed-off-by: Mathieu Desnoyers <mathieu.desnoyers@polymtl.ca>
CC: Alexander Viro <viro@zeniv.linux.org.uk>
CC: Masami Hiramatsu <mhiramat@redhat.com>
CC: 'Peter Zijlstra' <peterz@infradead.org>
CC: "Frank Ch. Eigler" <fche@redhat.com>
CC: 'Ingo Molnar' <mingo@elte.hu>
CC: 'Hideo AOKI' <haoki@redhat.com>
CC: Takashi Nishiie <t-nishiie@np.css.fujitsu.com>
CC: 'Steven Rostedt' <rostedt@goodmis.org>
CC: Eduard - Gabriel Munteanu <eduard.munteanu@linux360.ro>
---
 fs/buffer.c        |    3 ++
 fs/compat.c        |    2 +
 fs/exec.c          |    2 +
 fs/ioctl.c         |    3 ++
 fs/open.c          |    3 ++
 fs/read_write.c    |   19 +++++++++++++-
 fs/select.c        |    3 ++
 include/trace/fs.h |   65 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 8 files changed, 98 insertions(+), 2 deletions(-)
 create mode 100644 include/trace/fs.h

diff --git a/fs/buffer.c b/fs/buffer.c
index da02a5f..4cfcdbf 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -41,6 +41,7 @@
 #include <linux/cpu.h>
 #include <linux/bitops.h>
 #include <linux/mpage.h>
+#include <trace/fs.h>
 
 static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);
 
@@ -89,7 +90,9 @@ void unlock_buffer(struct buffer_head *bh)
  */
 void __wait_on_buffer(struct buffer_head * bh)
 {
+	trace_fs_buffer_wait_start(bh);
 	wait_on_bit(&bh->b_state, BH_Lock, sync_buffer, TASK_UNINTERRUPTIBLE);
+	trace_fs_buffer_wait_end(bh);
 }
 
 static void
diff --git a/fs/compat.c b/fs/compat.c
index 075d050..f40f47a 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -51,6 +51,7 @@
 #include <linux/poll.h>
 #include <linux/mm.h>
 #include <linux/eventpoll.h>
+#include <trace/fs.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1406,6 +1407,7 @@ int compat_do_execve(char * filename,
 
 	retval = search_binary_handler(bprm, regs);
 	if (retval >= 0) {
+		trace_fs_exec(filename);
 		/* execve success */
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
diff --git a/fs/exec.c b/fs/exec.c
index 38b40b2..1c9e0e9 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -51,6 +51,7 @@
 #include <linux/cn_proc.h>
 #include <linux/audit.h>
 #include <linux/tracehook.h>
+#include <trace/fs.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -1342,6 +1343,7 @@ int do_execve(char * filename,
 	current->flags &= ~PF_KTHREAD;
 	retval = search_binary_handler(bprm,regs);
 	if (retval >= 0) {
+		trace_fs_exec(filename);
 		/* execve success */
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
diff --git a/fs/ioctl.c b/fs/ioctl.c
index 7db32b3..22d747b 100644
--- a/fs/ioctl.c
+++ b/fs/ioctl.c
@@ -13,6 +13,7 @@
 #include <linux/security.h>
 #include <linux/module.h>
 #include <linux/uaccess.h>
+#include <trace/fs.h>
 
 #include <asm/ioctls.h>
 
@@ -201,6 +202,8 @@ asmlinkage long sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
 	if (!filp)
 		goto out;
 
+	trace_fs_ioctl(fd, cmd, arg);
+
 	error = security_file_ioctl(filp, cmd, arg);
 	if (error)
 		goto out_fput;
diff --git a/fs/open.c b/fs/open.c
index 07da935..e356564 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -29,6 +29,7 @@
 #include <linux/rcupdate.h>
 #include <linux/audit.h>
 #include <linux/falloc.h>
+#include <trace/fs.h>
 
 int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
@@ -1023,6 +1024,7 @@ long do_sys_open(int dfd, const char __user *filename, int flags, int mode)
 				fsnotify_open(f->f_path.dentry);
 				fd_install(fd, f);
 			}
+			trace_fs_open(fd, tmp);
 		}
 		putname(tmp);
 	}
@@ -1112,6 +1114,7 @@ asmlinkage long sys_close(unsigned int fd)
 	filp = fdt->fd[fd];
 	if (!filp)
 		goto out_unlock;
+	trace_fs_close(fd);
 	rcu_assign_pointer(fdt->fd[fd], NULL);
 	FD_CLR(fd, fdt->close_on_exec);
 	__put_unused_fd(files, fd);
diff --git a/fs/read_write.c b/fs/read_write.c
index 9ba495d..5779fb4 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -16,6 +16,7 @@
 #include <linux/syscalls.h>
 #include <linux/pagemap.h>
 #include <linux/splice.h>
+#include <trace/fs.h>
 #include "read_write.h"
 
 #include <asm/uaccess.h>
@@ -130,6 +131,9 @@ asmlinkage off_t sys_lseek(unsigned int fd, off_t offset, unsigned int origin)
 		if (res != (loff_t)retval)
 			retval = -EOVERFLOW;	/* LFS: should only happen on 32 bit platforms */
 	}
+
+	trace_fs_lseek(fd, offset, origin);
+
 	fput_light(file, fput_needed);
 bad:
 	return retval;
@@ -157,6 +161,8 @@ asmlinkage long sys_llseek(unsigned int fd, unsigned long offset_high,
 	offset = vfs_llseek(file, ((loff_t) offset_high << 32) | offset_low,
 			origin);
 
+	trace_fs_llseek(fd, offset, origin);
+
 	retval = (int)offset;
 	if (offset >= 0) {
 		retval = -EFAULT;
@@ -344,6 +350,7 @@ asmlinkage ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_read(file, buf, count, &pos);
+		trace_fs_read(fd, buf, count, ret);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
 	}
@@ -361,6 +368,7 @@ asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t co
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_write(file, buf, count, &pos);
+		trace_fs_write(fd, buf, count, ret);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
 	}
@@ -381,8 +389,11 @@ asmlinkage ssize_t sys_pread64(unsigned int fd, char __user *buf,
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PREAD)
+		if (file->f_mode & FMODE_PREAD) {
 			ret = vfs_read(file, buf, count, &pos);
+			trace_fs_pread64(fd, buf, count, pos, ret);
+		}
+
 		fput_light(file, fput_needed);
 	}
 
@@ -402,8 +413,10 @@ asmlinkage ssize_t sys_pwrite64(unsigned int fd, const char __user *buf,
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = -ESPIPE;
-		if (file->f_mode & FMODE_PWRITE)  
+		if (file->f_mode & FMODE_PWRITE) {
 			ret = vfs_write(file, buf, count, &pos);
+			trace_fs_pwrite64(fd, buf, count, pos, ret);
+		}
 		fput_light(file, fput_needed);
 	}
 
@@ -648,6 +661,7 @@ sys_readv(unsigned long fd, const struct iovec __user *vec, unsigned long vlen)
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_readv(file, vec, vlen, &pos);
+		trace_fs_readv(fd, vec, vlen, ret);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
 	}
@@ -669,6 +683,7 @@ sys_writev(unsigned long fd, const struct iovec __user *vec, unsigned long vlen)
 	if (file) {
 		loff_t pos = file_pos_read(file);
 		ret = vfs_writev(file, vec, vlen, &pos);
+		trace_fs_writev(fd, vec, vlen, ret);
 		file_pos_write(file, pos);
 		fput_light(file, fput_needed);
 	}
diff --git a/fs/select.c b/fs/select.c
index 8f6d906..d4bacce 100644
--- a/fs/select.c
+++ b/fs/select.c
@@ -24,6 +24,7 @@
 #include <linux/fdtable.h>
 #include <linux/fs.h>
 #include <linux/rcupdate.h>
+#include <trace/fs.h>
 
 #include <asm/uaccess.h>
 
@@ -232,6 +233,7 @@ int do_select(int n, fd_set_bits *fds, s64 *timeout)
 				file = fget_light(i, &fput_needed);
 				if (file) {
 					f_op = file->f_op;
+					trace_fs_select(i, *timeout);
 					mask = DEFAULT_POLLMASK;
 					if (f_op && f_op->poll)
 						mask = (*f_op->poll)(file, retval ? NULL : wait);
@@ -552,6 +554,7 @@ static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait)
 		file = fget_light(fd, &fput_needed);
 		mask = POLLNVAL;
 		if (file != NULL) {
+			trace_fs_poll(fd);
 			mask = DEFAULT_POLLMASK;
 			if (file->f_op && file->f_op->poll)
 				mask = file->f_op->poll(file, pwait);
diff --git a/include/trace/fs.h b/include/trace/fs.h
new file mode 100644
index 0000000..5e30365
--- /dev/null
+++ b/include/trace/fs.h
@@ -0,0 +1,65 @@
+#ifndef _TRACE_FS_H
+#define _TRACE_FS_H
+
+#include <linux/buffer_head.h>
+#include <linux/tracepoint.h>
+
+DEFINE_TRACE(fs_buffer_wait_start,
+	TPPROTO(struct buffer_head *bh),
+	TPARGS(bh));
+DEFINE_TRACE(fs_buffer_wait_end,
+	TPPROTO(struct buffer_head *bh),
+	TPARGS(bh));
+DEFINE_TRACE(fs_exec,
+	TPPROTO(char *filename),
+	TPARGS(filename));
+DEFINE_TRACE(fs_ioctl,
+	TPPROTO(unsigned int fd, unsigned int cmd, unsigned long arg),
+	TPARGS(fd, cmd, arg));
+DEFINE_TRACE(fs_open,
+	TPPROTO(int fd, char *filename),
+	TPARGS(fd, filename));
+DEFINE_TRACE(fs_close,
+	TPPROTO(unsigned int fd),
+	TPARGS(fd));
+DEFINE_TRACE(fs_lseek,
+	TPPROTO(unsigned int fd, long offset, unsigned int origin),
+	TPARGS(fd, offset, origin));
+DEFINE_TRACE(fs_llseek,
+	TPPROTO(unsigned int fd, loff_t offset, unsigned int origin),
+	TPARGS(fd, offset, origin));
+
+/*
+ * Probes must be aware that __user * may be modified by concurrent userspace
+ * or kernel threads.
+ */
+DEFINE_TRACE(fs_read,
+	TPPROTO(unsigned int fd, char __user *buf, size_t count, ssize_t ret),
+	TPARGS(fd, buf, count, ret));
+DEFINE_TRACE(fs_write,
+	TPPROTO(unsigned int fd, const char __user *buf, size_t count,
+		ssize_t ret),
+	TPARGS(fd, buf, count, ret));
+DEFINE_TRACE(fs_pread64,
+	TPPROTO(unsigned int fd, char __user *buf, size_t count, loff_t pos,
+		ssize_t ret),
+	TPARGS(fd, buf, count, pos, ret));
+DEFINE_TRACE(fs_pwrite64,
+	TPPROTO(unsigned int fd, const char __user *buf, size_t count,
+		loff_t pos, ssize_t ret),
+	TPARGS(fd, buf, count, pos, ret));
+DEFINE_TRACE(fs_readv,
+	TPPROTO(unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret),
+	TPARGS(fd, vec, vlen, ret));
+DEFINE_TRACE(fs_writev,
+	TPPROTO(unsigned long fd, const struct iovec __user *vec,
+		unsigned long vlen, ssize_t ret),
+	TPARGS(fd, vec, vlen, ret));
+DEFINE_TRACE(fs_select,
+	TPPROTO(int fd, s64 timeout),
+	TPARGS(fd, timeout));
+DEFINE_TRACE(fs_poll,
+	TPPROTO(int fd),
+	TPARGS(fd));
+#endif
-- 
1.5.5.1

