From b82a44e5cf601f53cfa2ffaa31f335ca4db588b1 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Fri, 27 May 2011 10:26:07 -0400
Subject: [PATCH] preempt_rt: acpi: don't call cond_resched() if in_atomic

Preempt-rt changes the logic in __schedule_bug() from using
in_atomic_preempt_off() to in_atomic() to test if we are
currently in an atomic context. The ACPI macro
ACPI_PREEMPTION_POINT() continued to use in_atomic_preempt_off()
,however, since TIF_NEED_RESCHED (need_resched) was never
being set and the call to cond_resched made by
ACPI_PREEMPTION_POINT was always returning before calling
schedule we never had any issues. However, when you enable a
kernel feature like DEBUG_KMEMLEAK, which makes use of the
kernel's RCU feature when performing put_object() it results in
TIF_NEED_RESCHED being set which in turn causes need_resched()
to returning true and we end up calling schedule() from an
atomic context. Resulting in a

BUG: scheduling while atomic: swapper/0x10000001/0, CPU#0
Modules linked in:
Pid: 0, comm: swapper Not tainted 2.6.34.9-rt-WR4.2.0.0_preempt_rt #2
Call Trace:
 [<c1023d0e>] __schedule_bug+0x7e/0x90
 [<c14e0f5c>] __schedule+0x3cc/0x560
 [<c125b611>] ? acpi_os_release_object+0xd/0x11
 [<c10237a4>] ? __might_sleep+0x14/0x130
 [<c14e1213>] schedule+0x13/0x30
 [<c102df57>] __cond_resched+0x17/0x30
 [<c14e1345>] _cond_resched+0x25/0x30
 [<c1276732>] acpi_ps_complete_op+0x21a/0x229
...

Updating the logic in ACPI_PREEMPTION_POINT to use in_atomic()
will ensure cond_resched() is only called when we are in fact
not in an atomic context.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 include/acpi/platform/aclinux.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/acpi/platform/aclinux.h b/include/acpi/platform/aclinux.h
index e5039a2..8da1e8c 100644
--- a/include/acpi/platform/aclinux.h
+++ b/include/acpi/platform/aclinux.h
@@ -152,7 +152,7 @@ static inline void *acpi_os_acquire_object(acpi_cache_t * cache)
 #include <linux/hardirq.h>
 #define ACPI_PREEMPTION_POINT() \
 	do { \
-		if (!in_atomic_preempt_off() && !irqs_disabled()) \
+		if (!in_atomic() && !irqs_disabled()) \
 			cond_resched(); \
 	} while (0)
 
-- 
1.6.5.2

