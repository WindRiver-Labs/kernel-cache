From 58ec742866a1126795f2c6cf184caadbc3e54a63 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Fri, 3 Sep 2010 00:07:40 -0700
Subject: [PATCH 27/27] task_is_waking: TASK_WAKING state is not exclusive

In testing the 2.6.33 RT patches on newer kernels, it was found
by bisection that a failure scenario appeared as of the merge
commit 2531216f236, which in turn brought in commit 0970d2992dfd

  "sched: Fix race between ttwu() and task_rq_lock()"

which creates the task_is_waiting() function.  This drew attention to
the fact that similar commits in tip on the RT branch (the "almost"
cherry pick d69f55869272 and the merge 5f854cfc02462) have a subtle
difference, in that mainline task_is_waiting() tests on:

	p->state == TASK_WAKING

whereas the tip/RT version tests on:

	p->state & TASK_WAKING

Adding instrumentation such as:

 +  if (unlikely(p->state & TASK_WAKING) && (p->state != TASK_WAKING)) {
 +         printk(KERN_DEBUG "tiw: extra state bits: 0x%x\n", p->state);
 +         WARN_ON_RT(1);
 +  }

shows that TASK_[UN]INTERRUPTIBLE bits can also be set at the same
time in RT.  By inspecting ttwu(), you see it doesn't clear these
when setting the TASK_WAITING bit, and so the direct comparison
leads to false negatives from task_is_waking(), which in turn leads
to trying to wake already waking tasks, and you get something like this:

 ------------[ cut here ]------------
kernel BUG at /home/paul/rt/linux-2.6/kernel/sched.c:1284!
invalid opcode: 0000 [#1] PREEMPT SMP
last sysfs file: /sys/devices/virtual/block/ram14/uevent
CPU 3
Modules linked in:

Pid: 2705, comm: upstart-udev-br Tainted: G        W  2.6.33-rt29-01725-gfaf1b85
 #5 Wallowa/Wallowa
RIP: 0010:[<ffffffff8102a6ae>]  [<ffffffff8102a6ae>] resched_task+0x6e/0x80
RSP: 0018:ffff880001983d48  EFLAGS: 00010046
RAX: 000000000000cece RBX: ffff8800792bc040 RCX: 00000000000000ce
RDX: ffff8800793b4000 RSI: ffff88007f92f040 RDI: ffff8800792bc040
RBP: ffff880001983d58 R08: 0000000000000001 R09: 0000000000000000
R10: 0000000000000000 R11: 00000000000e7ef0 R12: ffff8800792bc080
R13: ffff8800792bc040 R14: ffff88007f92f040 R15: 0000000000000000
FS:  00007fec49913700(0000) GS:ffff880001980000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00007fec6c4f8000 CR3: 0000000078ce2000 CR4: 00000000000006a0
DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
Process upstart-udev-br (pid: 2705, threadinfo ffff8800793b4000, task ffff880079
2bc040)
Stack:
 ffff88000198ec80 ffff8800792bc080 ffff880001983db8 ffffffff8102b7a8
<0> ffff88000198ec80 ffff88000198ec80 ffff880001983d98 ffffffff8102fbbe
<0> ffff88007f92f040 ffff88007f92f040 ffff88000198ec80 ffff88000198ec80
Call Trace:
 <IRQ>
 [<ffffffff8102b7a8>] check_preempt_wakeup+0x118/0x2d0
 [<ffffffff8102fbbe>] ? enqueue_task_rt+0x2e/0x70
 [<ffffffff81037054>] try_to_wake_up+0x1f4/0x340
 [<ffffffff81062340>] ? tick_sched_timer+0x0/0x140
 [<ffffffff81037242>] wake_up_process+0x12/0x20
 [<ffffffff8104161c>] wakeup_softirqd+0x4c/0x60
 [<ffffffff81041853>] raise_softirq+0x23/0x30
 [<ffffffff81062340>] ? tick_sched_timer+0x0/0x140
 [<ffffffff81048a13>] run_local_timers+0x13/0x20
 [<ffffffff81048a5d>] update_process_times+0x3d/0x70
 [<ffffffff81062399>] tick_sched_timer+0x59/0x140
 [<ffffffff810583f1>] __run_hrtimer+0x51/0xb0
 [<ffffffff8105882e>] hrtimer_interrupt+0xde/0x240
 [<ffffffff81018026>] smp_apic_timer_interrupt+0x66/0xa0
 [<ffffffff81002d93>] apic_timer_interrupt+0x13/0x20
 <EOI>
 [<ffffffff810c1f11>] ? rw_copy_check_uvector+0x1/0x130
 [<ffffffff813f7304>] ? rt_spin_lock+0x34/0x80
 [<ffffffff810c2812>] ? do_readv_writev+0x62/0x1c0
 [<ffffffff8103f7e7>] ? do_wait+0x1e7/0x220
 [<ffffffff810c29ae>] vfs_writev+0x3e/0x60
 [<ffffffff810c2aac>] sys_writev+0x4c/0x80
 [<ffffffff810024ab>] system_call_fastpath+0x16/0x1b
Code: 19 00 44 39 e0 74 0d 0f ae f0 48 8b 43 08 f6 40 14 04 74 09 5b 41 5c c9 c3
 0f 1f 40 00 44 89 e7 ff 15 77 fb 55 00 5b 41 5c c9 c3 <0f> 0b eb fe 66 66 66 66
 66 2e 0f 1f 84 00 00 00 00 00 55 85 c9
RIP  [<ffffffff8102a6ae>] resched_task+0x6e/0x80
 RSP <ffff880001983d48>
 ---[ end trace f958ea6d0d497f63 ]---

Reverting back to the tip/RT version of task_is_waking() solves this.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/sched.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/kernel/sched.c b/kernel/sched.c
index cce190e..bd0fea4 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -996,7 +996,7 @@ static inline void finish_lock_switch(struct rq *rq, struct task_struct *prev)
  */
 static inline int task_is_waking(struct task_struct *p)
 {
-	return unlikely(p->state == TASK_WAKING);
+	return unlikely(p->state & TASK_WAKING);
 }
 
 /*
-- 
1.6.5.2

