From 901651e9540ae6e7ec5b99a2996408701afe3de1 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 1 Dec 2010 19:19:41 +0800
Subject: [PATCH] preempt_rt: gianfar:use SYSTEM_SUSPEND prevent call trace

During suspend/resume operation, sleepable spinlocks introduce
call trace:

BUG: sleeping function called from invalid context at
/home/ljiang0/work/fsl_p1022_prt_cgl/build/linux/kernel/rtmutex.c:707
pcnt: 0 0 in_atomic(): 0, irqs_disabled(): 1, pid: 693, name: bash
Call Trace:
[ee149cc0] [c000842c] show_stack+0x44/0x160 (unreliable)
[ee149cf0] [c003c85c] __might_sleep+0xe4/0x108
[ee149d00] [c04785ec] rt_spin_lock+0x38/0xb4
[ee149d10] [c02fe49c] lock_tx_qs+0x38/0x58
[ee149d30] [c02fed6c] gfar_suspend+0xa4/0x184
[ee149d50] [c03a6788] of_platform_pm_suspend+0x38/0x84
[ee149d60] [c02b7ce4] pm_op+0x90/0x140
[ee149d90] [c02b83c4] __device_suspend+0x104/0x18c
[ee149dc0] [c02b8a44] dpm_suspend_start+0x290/0x44c
[ee149e30] [c0090808] suspend_devices_and_enter+0x98/0x20c
[ee149e60] [c0090a60] enter_state+0xe4/0xf4
[ee149e80] [c008ffe4] state_store+0x9c/0x108
[ee149ea0] [c0247c2c] kobj_attr_store+0x24/0x3c
[ee149eb0] [c017809c] sysfs_write_file+0xe4/0x1dc
[ee149ee0] [c0118c34] vfs_write+0xb4/0x188
[ee149f00] [c0118e7c] sys_write+0x50/0x10c
[ee149f40] [c0011cec] ret_from_syscall+0x0/0x4

Preempt-rt kernel introduce SYSTEM_SUSPEND state to prevent
such condition. The commit log as following:

timekeeping suspend/resume calls read_persistant_clock() which takes
rtc_lock. That results in might sleep warnings because at that point
we run with interrupts disabled.
    
We cannot convert rtc_lock to a raw spinlock as that would trigger
other might sleep warnings.
    
As a temporary workaround we disable the might sleep warnings by
setting system_state to SYSTEM_SUSPEND before calling sysdev_suspend()
and restoring it to SYSTEM_RUNNING afer sysdev_resume().

For GIANFAR driver, suspend() & resume() routines are called after
suspend_freeze_processes() and before suspend_thaw_processes()
routines during suspend & resume process. And interrupts have
been disabled, it is safe to get a spinlock without might_sleep
check.

Set system_state to SYSTEM_SUSPEND could force skipping might_sleep
check.

Preempt-rt kernel involved same strategy for sysdev_suspend() &
sysdev_resume() routines.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/gianfar.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index a6159ff..4caf61d 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -1742,6 +1742,7 @@ static int gfar_suspend(struct device *dev)
 	if (netif_running(ndev)) {
 
 		local_irq_save(flags);
+		system_state = SYSTEM_SUSPEND;
 		lock_tx_qs(priv);
 		lock_rx_qs(priv);
 
@@ -1764,6 +1765,7 @@ static int gfar_suspend(struct device *dev)
 
 		unlock_rx_qs(priv);
 		unlock_tx_qs(priv);
+		system_state = SYSTEM_RUNNING;
 		local_irq_restore(flags);
 
 		disable_napi(priv);
@@ -1843,6 +1845,7 @@ static int gfar_resume(struct device *dev)
 	 * else woke us up.
 	 */
 	local_irq_save(flags);
+	system_state = SYSTEM_SUSPEND;
 	lock_tx_qs(priv);
 	lock_rx_qs(priv);
 
@@ -1854,6 +1857,7 @@ static int gfar_resume(struct device *dev)
 
 	unlock_rx_qs(priv);
 	unlock_tx_qs(priv);
+	system_state = SYSTEM_RUNNING;
 	local_irq_restore(flags);
 
 	netif_device_attach(ndev);
-- 
1.7.0.4

