From ae67ea8470b9704197fc0bbe7e106d291eeaba73 Mon Sep 17 00:00:00 2001
From: Hui Wang <Hui.Wang@windriver.com>
Date: Wed, 29 Dec 2010 16:00:16 +0800
Subject: [PATCH 1/4] mfd/twl4030_irq: replace spin_lock to raw_spin_lock to avoid warnings

When we suspend and resume the whole system, the following warnings
print out:
root@localhost:/root> echo mem > /sys/power/state
Freezing user space processes ... (elapsed 0.01 seconds) done.
Freezing remaining freezable tasks ... (elapsed 0.01 seconds) done.
Suspending console(s) (use no_console_suspend to debug)
Could not enter target state in pm_suspend
BUG: sleeping function called from invalid context at
/buildarea3/hwang4/work41/3530prt/build/linux/kernel/rtmutex.c:707
pcnt: 1 0 in_atomic(): 1, irqs_disabled(): 128, pid: 574, name: bash
[<c003e7d4>] [<c04ad7b4>] (rt_spin_lock+0x30/0x5c)
[<c04ad7b4>] [<c032ffac>] (twl4030_sih_unmask+0x20/0x58)
[<c032ffac>] [<c00b2290>] (default_enable+0x20/0x30)
[<c00b2290>] [<c00b2104>] (check_irq_resend+0x20/0x98)
[<c00b2104>] [<c00b1210>] (__enable_irq+0x70/0x88)
[<c00b1210>] [<c00b3a58>] (resume_device_irqs+0x58/0xac)
[<c00b3a58>] [<c0098f14>] (suspend_devices_and_enter+0x18c/0x204)
[<c0098f14>] [<c0099048>] (enter_state+0xbc/0x120)
[<c0099048>] [<c0098768>] (state_store+0xa4/0xb8)
[<c0098768>] [<c02d2098>] (kobj_attr_store+0x18/0x1c)
[<c02d2098>] [<c014631c>] (sysfs_write_file+0x108/0x13c)
[<c014631c>] [<c00fc5f0>] (vfs_write+0xb0/0x128)
[<c00fc5f0>] [<c00fc7c0>] (sys_write+0x44/0xf4)
[<c00fc7c0>] [<c0037f00>] (ret_fast_syscall+0x0/0x30)
Restarting tasks ...
done.

This is because the spin_lock is a sleepable lock in the preempt_rt
kernel, and we call it in an atomic and irq_disabled context. To avoid
this warning, replace spin_lock to raw_spin_lock.

Signed-off-by: Hui Wang <Hui.Wang@windriver.com>
---
 drivers/mfd/twl4030-irq.c |   22 +++++++++++-----------
 1 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/drivers/mfd/twl4030-irq.c b/drivers/mfd/twl4030-irq.c
index 202bdd5..d15e4d0 100644
--- a/drivers/mfd/twl4030-irq.c
+++ b/drivers/mfd/twl4030-irq.c
@@ -473,7 +473,7 @@ static inline void activate_irq(int irq)
 
 /*----------------------------------------------------------------------*/
 
-static DEFINE_SPINLOCK(sih_agent_lock);
+static DEFINE_RAW_SPINLOCK(sih_agent_lock);
 
 static struct workqueue_struct *wq;
 
@@ -502,7 +502,7 @@ static void twl4030_sih_do_mask(struct work_struct *work)
 	agent = container_of(work, struct sih_agent, mask_work);
 
 	/* see what work we have */
-	spin_lock_irq(&sih_agent_lock);
+	raw_spin_lock_irq(&sih_agent_lock);
 	if (agent->imr_change_pending) {
 		sih = agent->sih;
 		/* byte[0] gets overwritten as we write ... */
@@ -510,7 +510,7 @@ static void twl4030_sih_do_mask(struct work_struct *work)
 		agent->imr_change_pending = false;
 	} else
 		sih = NULL;
-	spin_unlock_irq(&sih_agent_lock);
+	raw_spin_unlock_irq(&sih_agent_lock);
 	if (!sih)
 		return;
 
@@ -533,11 +533,11 @@ static void twl4030_sih_do_edge(struct work_struct *work)
 	agent = container_of(work, struct sih_agent, edge_work);
 
 	/* see what work we have */
-	spin_lock_irq(&sih_agent_lock);
+	raw_spin_lock_irq(&sih_agent_lock);
 	edge_change = agent->edge_change;
 	agent->edge_change = 0;
 	sih = edge_change ? agent->sih : NULL;
-	spin_unlock_irq(&sih_agent_lock);
+	raw_spin_unlock_irq(&sih_agent_lock);
 	if (!sih)
 		return;
 
@@ -601,11 +601,11 @@ static void twl4030_sih_mask(unsigned irq)
 	struct sih_agent *sih = get_irq_chip_data(irq);
 	unsigned long flags;
 
-	spin_lock_irqsave(&sih_agent_lock, flags);
+	raw_spin_lock_irqsave(&sih_agent_lock, flags);
 	sih->imr |= BIT(irq - sih->irq_base);
 	sih->imr_change_pending = true;
 	queue_work(wq, &sih->mask_work);
-	spin_unlock_irqrestore(&sih_agent_lock, flags);
+	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 }
 
 static void twl4030_sih_unmask(unsigned irq)
@@ -613,11 +613,11 @@ static void twl4030_sih_unmask(unsigned irq)
 	struct sih_agent *sih = get_irq_chip_data(irq);
 	unsigned long flags;
 
-	spin_lock_irqsave(&sih_agent_lock, flags);
+	raw_spin_lock_irqsave(&sih_agent_lock, flags);
 	sih->imr &= ~BIT(irq - sih->irq_base);
 	sih->imr_change_pending = true;
 	queue_work(wq, &sih->mask_work);
-	spin_unlock_irqrestore(&sih_agent_lock, flags);
+	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 }
 
 static int twl4030_sih_set_type(unsigned irq, unsigned trigger)
@@ -634,14 +634,14 @@ static int twl4030_sih_set_type(unsigned irq, unsigned trigger)
 	if (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
 		return -EINVAL;
 
-	spin_lock_irqsave(&sih_agent_lock, flags);
+	raw_spin_lock_irqsave(&sih_agent_lock, flags);
 	if ((desc->status & IRQ_TYPE_SENSE_MASK) != trigger) {
 		desc->status &= ~IRQ_TYPE_SENSE_MASK;
 		desc->status |= trigger;
 		sih->edge_change |= BIT(irq - sih->irq_base);
 		queue_work(wq, &sih->edge_work);
 	}
-	spin_unlock_irqrestore(&sih_agent_lock, flags);
+	raw_spin_unlock_irqrestore(&sih_agent_lock, flags);
 	return 0;
 }
 
-- 
1.6.5.2

