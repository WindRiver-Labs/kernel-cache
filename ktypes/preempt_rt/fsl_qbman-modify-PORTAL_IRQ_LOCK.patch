From b5de1026b353cf48922d16f6b268510c5a3dd502 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 12 Jul 2011 17:36:33 +0800
Subject: [PATCH 2/2] fsl_qbman: modify PORTAL_IRQ_LOCK

When use p4080ds-usdpaa.dtb in preempt_rt kernel, call trace is reported:
UG: sleeping function called from invalid context at kernel/rtmutex.c:707
pcnt: 1 0 in_atomic(): 1, irqs_disabled(): 0, pid: 169, name: irq/122-QMan po
Call Trace:
[ebf51e90] [c0007cd0] show_stack+0x44/0x160 (unreliable)
[ebf51ec0] [c0035f6c] __might_sleep+0xe4/0x108
[ebf51ed0] [c05ffde4] rt_spin_lock+0x38/0xb4
[ebf51ee0] [c0524ce4] qman_irqsource_remove+0x114/0x150
[ebf51ef0] [c047ecc0] ingress_rx_default_dqrr+0x2d8/0x3a4
[ebf51f20] [c052ac54] portal_isr+0x244/0x2ac
[ebf51f50] [c00ad70c] irq_thread+0x16c/0x228
[ebf51fa0] [c006aee0] kthread+0x78/0x7c
[ebf51ff0] [c001127c] original_kernel_thread+0x4c/0x68
BUG: sleeping function called from invalid context at kernel/rtmutex.c:707
pcnt: 1 0 in_atomic(): 1, irqs_disabled(): 0, pid: 931, name: touch
Call Trace:
[e9889690] [c0007cd0] show_stack+0x44/0x160 (unreliable)
[e98896c0] [c0035f6c] __might_sleep+0xe4/0x108
[e98896d0] [c05ffde4] rt_spin_lock+0x38/0xb4
[e98896e0] [c0528860] qman_enqueue+0x20c/0x3f0
[e9889720] [c047fc94] dpa_tx+0x174/0x684
[e9889780] [c054fb78] dev_hard_start_xmit+0x1f8/0x510
[e98897d0] [c057f8e4] ip_finish_output+0x150/0x36c
[e9889800] [c057ff74] ip_local_out+0x34/0x48
[e9889810] [c0580208] ip_push_pending_frames+0x280/0x3b0
[e9889840] [c05a1f78] udp_push_pending_frames+0x108/0x494
[e9889870] [c05a4254] udp_sendmsg+0x3ec/0x6a8
[e9889930] [c05ab5bc] inet_sendmsg+0x38/0x7c
[e9889950] [c0539be4] sock_sendmsg+0xc0/0x160
[e9889a30] [c0539cb0] kernel_sendmsg+0x2c/0x44
[e9889a40] [c05de16c] xs_send_kvec+0x98/0xa8
[e9889a80] [c05de1fc] xs_sendpages+0x80/0x270
[e9889ab0] [c05de6d0] xs_udp_send_request+0x60/0x168
[e9889ad0] [c05dbf6c] xprt_transmit+0x70/0x2b0
[e9889af0] [c05d8fe4] call_transmit+0x1b8/0x290
[e9889b10] [c05e1410] __rpc_execute+0xf0/0x2fc
[e9889b60] [c05d9b08] rpc_run_task+0x44/0x90
[e9889b70] [c05d9c80] rpc_call_sync+0x50/0x80
[e9889ba0] [c02042c4] T.1016+0x40/0x7c
[e9889bb0] [c0205138] nfs_proc_getattr+0x54/0xa8
[e9889be0] [c01fafd0] __nfs_revalidate_inode+0xe4/0x204
[e9889ca0] [c01f4388] nfs_lookup_revalidate+0x28c/0x470
[e9889de0] [c011fb64] do_lookup+0x84/0x228
[e9889e10] [c0121944] do_last+0x360/0x74c
[e9889e40] [c0124584] do_filp_open+0x42c/0x628
[e9889f20] [c0112994] do_sys_open+0x64/0x198
[e9889f40] [c0011564] ret_from_syscall+0x0/0x4
Exception: c00 at 0x48017f0c
LR = 0x4800694c

To fix it, use raw_spin_lock* to define PORTAL_IRQ_LOCK

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c |    8 ++++----
 drivers/staging/fsl_qbman/qman_high.c |    8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index a1abc97..c459765 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -51,7 +51,7 @@ struct bman_portal {
 	struct tasklet_struct tasklet;
 #endif
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
-	spinlock_t sharing_lock; /* only used with BMAN_PORTAL_FLAG_SHARE */
+	raw_spinlock_t sharing_lock; /* only used with BMAN_PORTAL_FLAG_SHARE */
 	struct bman_portal *sharing_redirect;
 #endif
 	/* When the cpu-affine portal is activated, this is non-NULL */
@@ -73,14 +73,14 @@ struct bman_portal {
 #define PORTAL_IRQ_LOCK(p, irqflags) \
 	do { \
 		if ((p)->options & BMAN_PORTAL_FLAG_SHARE) \
-			spin_lock_irqsave(&(p)->sharing_lock, irqflags); \
+			raw_spin_lock_irqsave(&(p)->sharing_lock, irqflags); \
 		else \
 			local_irq_save(irqflags); \
 	} while (0)
 #define PORTAL_IRQ_UNLOCK(p, irqflags) \
 	do { \
 		if ((p)->options & BMAN_PORTAL_FLAG_SHARE) \
-			spin_unlock_irqrestore(&(p)->sharing_lock, irqflags); \
+			raw_spin_unlock_irqrestore(&(p)->sharing_lock, irqflags); \
 		else \
 			local_irq_restore(irqflags); \
 	} while (0)
@@ -289,7 +289,7 @@ struct bman_portal *bman_create_affine_portal(
 	tasklet_init(&portal->tasklet, portal_tasklet, (unsigned long)portal);
 #endif
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
-	spin_lock_init(&portal->sharing_lock);
+	raw_spin_lock_init(&portal->sharing_lock);
 	portal->sharing_redirect = NULL;
 #endif
 	memset(&portal->cb, 0, sizeof(portal->cb));
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index bec9358..11300f3 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -98,7 +98,7 @@ struct qman_portal {
 	struct tasklet_struct tasklet;
 #endif
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
-	spinlock_t sharing_lock; /* only used with QMAN_PORTAL_FLAG_SHARE */
+	raw_spinlock_t sharing_lock; /* only used with QMAN_PORTAL_FLAG_SHARE */
 	struct qman_portal *sharing_redirect;
 #endif
 #ifdef CONFIG_FSL_QMAN_ADAPTIVE_EQCR_THROTTLE
@@ -133,14 +133,14 @@ struct qman_portal {
 #define PORTAL_IRQ_LOCK(p, irqflags) \
 	do { \
 		if ((p)->options & QMAN_PORTAL_FLAG_SHARE) \
-			spin_lock_irqsave(&(p)->sharing_lock, irqflags); \
+			raw_spin_lock_irqsave(&(p)->sharing_lock, irqflags); \
 		else \
 			local_irq_save(irqflags); \
 	} while (0)
 #define PORTAL_IRQ_UNLOCK(p, irqflags) \
 	do { \
 		if ((p)->options & QMAN_PORTAL_FLAG_SHARE) \
-			spin_unlock_irqrestore(&(p)->sharing_lock, irqflags); \
+			raw_spin_unlock_irqrestore(&(p)->sharing_lock, irqflags); \
 		else \
 			local_irq_restore(irqflags); \
 	} while (0)
@@ -546,7 +546,7 @@ drain_loop:
 	tasklet_init(&portal->tasklet, portal_tasklet, (unsigned long)portal);
 #endif
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
-	spin_lock_init(&portal->sharing_lock);
+	raw_spin_lock_init(&portal->sharing_lock);
 	portal->sharing_redirect = NULL;
 #endif
 #ifdef CONFIG_FSL_QMAN_ADAPTIVE_EQCR_THROTTLE
-- 
1.7.0.4

