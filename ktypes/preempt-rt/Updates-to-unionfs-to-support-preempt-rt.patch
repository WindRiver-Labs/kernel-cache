From 35c9a0b8f82888183d21a18a2e50e86bbb03eb70 Mon Sep 17 00:00:00 2001
From: Mark Asselstine <mark.asselstine@windriver.com>
Date: Mon, 7 Jun 2010 11:35:18 -0400
Subject: [PATCH] Updates to unionfs to support preempt-rt

Although there is evidence that unionfs has been written to
behave well will preempt-rt there have been recent changes to
preempt-rt which require further coding changes in unionfs to
allow things to build and function correctly. Here we incorporate
the changes to the inode i_count and inode locking.

There was also a #define used for unionfs_rw_semaphore which was
designed for previous versions of preempt-rt which made use of
compat-rw-semaphore which is no longer required. Cleaned this
out.

Signed-off-by: Mark Asselstine <mark.asselstine@windriver.com>
---
 fs/unionfs/commonfops.c |    4 +++-
 fs/unionfs/copyup.c     |    4 +++-
 fs/unionfs/dentry.c     |    2 +-
 fs/unionfs/union.h      |    9 +--------
 4 files changed, 8 insertions(+), 11 deletions(-)

diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c
index 740c4ad..3b550b9 100644
--- a/fs/unionfs/commonfops.c
+++ b/fs/unionfs/commonfops.c
@@ -82,7 +82,9 @@ retry:
 	/* bring it to the same state as an unlinked file */
 	lower_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));
 	if (!unionfs_lower_inode_idx(dentry->d_inode, bindex)) {
-		atomic_inc(&lower_dentry->d_inode->i_count);
+		spin_lock(&lower_dentry->d_inode->i_lock);
+		lower_dentry->d_inode->i_count++;
+		spin_unlock(&lower_dentry->d_inode->i_lock);
 		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
 					    lower_dentry->d_inode);
 	}
diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c
index 9c7b2ac..8af03a7 100644
--- a/fs/unionfs/copyup.c
+++ b/fs/unionfs/copyup.c
@@ -546,7 +546,9 @@ out_free:
 			 * unlinked-open file, whose name is .unionfsXXXXX.
 			 */
 			struct inode *inode = new_lower_dentry->d_inode;
-			atomic_inc(&inode->i_count);
+			spin_lock(&inode->i_lock);
+			inode->i_count++;
+			spin_unlock(&inode->i_lock);
 			unionfs_set_lower_inode_idx(dentry->d_inode,
 						    ibstart(dentry->d_inode),
 						    inode);
diff --git a/fs/unionfs/dentry.c b/fs/unionfs/dentry.c
index a0c3bba..124fe86 100644
--- a/fs/unionfs/dentry.c
+++ b/fs/unionfs/dentry.c
@@ -374,7 +374,7 @@ static void unionfs_d_iput(struct dentry *dentry, struct inode *inode)
 	path_put_lowers_all(dentry, false);
 
 drop_lower_inodes:
-	rc = atomic_read(&inode->i_count);
+	rc = inode->i_count;
 	if (rc == 1 && inode->i_nlink == 1 && ibstart(inode) >= 0) {
 		/* see Documentation/filesystems/unionfs/issues.txt */
 		lockdep_off();
diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h
index 99335a3..73ab5ea 100644
--- a/fs/unionfs/union.h
+++ b/fs/unionfs/union.h
@@ -81,13 +81,6 @@ extern struct vm_operations_struct unionfs_vm_ops;
 /* How long should an entry be allowed to persist */
 #define RDCACHE_JIFFIES	(5*HZ)
 
-/* compatibility with Real-Time patches */
-#ifdef CONFIG_PREEMPT_RT
-# define unionfs_rw_semaphore	compat_rw_semaphore
-#else /* not CONFIG_PREEMPT_RT */
-# define unionfs_rw_semaphore	rw_semaphore
-#endif /* not CONFIG_PREEMPT_RT */
-
 /* file private data. */
 struct unionfs_file_info {
 	int bstart;
@@ -163,7 +156,7 @@ struct unionfs_sb_info {
 	 * branch-management is used on a pivot_root'ed union, because we
 	 * have to ->lookup paths which belong to the same union.
 	 */
-	struct unionfs_rw_semaphore rwsem;
+	struct rw_semaphore rwsem;
 	pid_t write_lock_owner;	/* PID of rw_sem owner (write lock) */
 	int high_branch_id;	/* last unique branch ID given */
 	char *dev_name;		/* to identify different unions in pr_debug */
-- 
1.6.0.3

