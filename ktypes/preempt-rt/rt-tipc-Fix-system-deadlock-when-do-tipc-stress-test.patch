From e89330abe2fbc77729ac93462fd827a91104a723 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 1 Nov 2013 15:02:50 +0800
Subject: [PATCH] rt/tipc: Fix system deadlock when do tipc stress test

On preempt_rt kernel, read_lock_bh() changed its semantics from
the standard one and only one reader could hold the lock, and
other readers are put on a wait list.
However, this behavior could lead to a deadlock on below scenario
when running tipcTS/tipcTC stress test:
On CPU0:
  bind()->tipc_publish()->tipc_nametbl_publish()->
  named_cluster_distribute()->tipc_link_send()
On CPU1:
  recv_msg()->tipc_recv_msg()->tipc_port_recv_msg()

Thus, a deadlock could happen like this:

        CPU0                          CPU1
        ----                          ----
   tipc_port_lock(ref);
                                  read_lock_bh(&tipc_net_lock);
                                  tipc_port_lock(ref);
   read_lock_bh(&tipc_net_lock);

Obviously deadlock may happen in this case.

To fix this problem, we can send the name table buffer out of
the protection of tipc_port_lock.

Signed-off-by: Ying Xue <ying.xue@windriver.com>
Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 net/tipc/name_distr.c |    6 +++---
 net/tipc/name_table.c |    8 +++++---
 net/tipc/name_table.h |    5 ++++-
 net/tipc/port.c       |   35 ++++++++++++++++++++++++++++-------
 4 files changed, 40 insertions(+), 14 deletions(-)

diff --git a/net/tipc/name_distr.c b/net/tipc/name_distr.c
index 211c172..862694d 100644
--- a/net/tipc/name_distr.c
+++ b/net/tipc/name_distr.c
@@ -130,7 +130,7 @@ static struct sk_buff *named_prepare_buf(u32 type, u32 size, u32 dest)
 	return buf;
 }
 
-static void named_cluster_distribute(struct sk_buff *buf)
+void named_cluster_distribute(struct sk_buff *buf)
 {
 	struct sk_buff *buf_copy;
 	struct tipc_node *n_ptr;
@@ -171,7 +171,7 @@ void tipc_named_publish(struct publication *publ)
 
 	item = (struct distr_item *)msg_data(buf_msg(buf));
 	publ_to_item(item, publ);
-	named_cluster_distribute(buf);
+	publ->buf = buf;
 }
 
 /**
@@ -197,7 +197,7 @@ void tipc_named_withdraw(struct publication *publ)
 
 	item = (struct distr_item *)msg_data(buf_msg(buf));
 	publ_to_item(item, publ);
-	named_cluster_distribute(buf);
+	publ->buf = buf;
 }
 
 /*
diff --git a/net/tipc/name_table.c b/net/tipc/name_table.c
index 4de58de..2c3ab82 100644
--- a/net/tipc/name_table.c
+++ b/net/tipc/name_table.c
@@ -717,25 +717,27 @@ struct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper,
  * tipc_nametbl_withdraw - withdraw name publication from network name tables
  */
 
-int tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key)
+struct sk_buff *tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key)
 {
 	struct publication *publ;
+	struct sk_buff *buf;
 
 	write_lock_bh(&tipc_nametbl_lock);
 	publ = tipc_nametbl_remove_publ(type, lower, tipc_own_addr, ref, key);
 	if (likely(publ)) {
 		table.local_publ_count--;
 		tipc_named_withdraw(publ);
+		buf = publ->buf;
 		write_unlock_bh(&tipc_nametbl_lock);
 		list_del_init(&publ->pport_list);
 		kfree(publ);
-		return 1;
+		return buf;
 	}
 	write_unlock_bh(&tipc_nametbl_lock);
 	err("Unable to remove local publication\n"
 	    "(type=%u, lower=%u, ref=%u, key=%u)\n",
 	    type, lower, ref, key);
-	return 0;
+	return NULL;
 }
 
 /**
diff --git a/net/tipc/name_table.h b/net/tipc/name_table.h
index 207d59e..9672c07 100644
--- a/net/tipc/name_table.h
+++ b/net/tipc/name_table.h
@@ -82,6 +82,7 @@ struct publication {
 	struct list_head node_list;
 	struct list_head cluster_list;
 	struct list_head zone_list;
+	struct sk_buff *buf;
 };
 
 
@@ -93,7 +94,7 @@ int tipc_nametbl_mc_translate(u32 type, u32 lower, u32 upper, u32 limit,
 			 struct tipc_port_list *dports);
 struct publication *tipc_nametbl_publish(u32 type, u32 lower, u32 upper,
 				    u32 scope, u32 port_ref, u32 key);
-int tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key);
+struct sk_buff *tipc_nametbl_withdraw(u32 type, u32 lower, u32 ref, u32 key);
 struct publication *tipc_nametbl_insert_publ(u32 type, u32 lower, u32 upper,
 					u32 scope, u32 node, u32 ref, u32 key);
 struct publication *tipc_nametbl_remove_publ(u32 type, u32 lower,
@@ -103,4 +104,6 @@ void tipc_nametbl_unsubscribe(struct tipc_subscription *s);
 int tipc_nametbl_init(void);
 void tipc_nametbl_stop(void);
 
+void named_cluster_distribute(struct sk_buff *buf);
+
 #endif
diff --git a/net/tipc/port.c b/net/tipc/port.c
index e684170..c3e8497 100644
--- a/net/tipc/port.c
+++ b/net/tipc/port.c
@@ -990,12 +990,14 @@ int tipc_publish(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 	if (!p_ptr)
 		return -EINVAL;
 
-	if (p_ptr->connected)
-		goto exit;
+	if (p_ptr->connected) {
+		tipc_port_unlock(p_ptr);
+		return res;
+	}
 	key = ref + p_ptr->pub_count + 1;
 	if (key == ref) {
-		res = -EADDRINUSE;
-		goto exit;
+		tipc_port_unlock(p_ptr);
+		return -EADDRINUSE;
 	}
 	publ = tipc_nametbl_publish(seq->type, seq->lower, seq->upper,
 				    scope, p_ptr->ref, key);
@@ -1005,8 +1007,11 @@ int tipc_publish(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 		p_ptr->published = 1;
 		res = 0;
 	}
-exit:
 	tipc_port_unlock(p_ptr);
+
+	if (publ && publ->buf)
+		named_cluster_distribute(publ->buf);
+
 	return res;
 }
 
@@ -1015,16 +1020,24 @@ int tipc_withdraw(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 	struct tipc_port *p_ptr;
 	struct publication *publ;
 	struct publication *tpubl;
+	struct sk_buff *buf;
+	struct sk_buff *tbuf;
+	struct sk_buff_head nametbl_queue;
 	int res = -EINVAL;
 
 	p_ptr = tipc_port_lock(ref);
 	if (!p_ptr)
 		return -EINVAL;
+
+	skb_queue_head_init(&nametbl_queue);
+
 	if (!seq) {
 		list_for_each_entry_safe(publ, tpubl,
 					 &p_ptr->publications, pport_list) {
-			tipc_nametbl_withdraw(publ->type, publ->lower,
+			buf = tipc_nametbl_withdraw(publ->type, publ->lower,
 					      publ->ref, publ->key);
+			if (buf)
+				skb_queue_tail(&nametbl_queue, buf);
 		}
 		res = 0;
 	} else {
@@ -1038,8 +1051,11 @@ int tipc_withdraw(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 				continue;
 			if (publ->upper != seq->upper)
 				break;
-			tipc_nametbl_withdraw(publ->type, publ->lower,
+			buf = tipc_nametbl_withdraw(publ->type, publ->lower,
 					      publ->ref, publ->key);
+			if (buf)
+				skb_queue_tail(&nametbl_queue, buf);
+
 			res = 0;
 			break;
 		}
@@ -1047,6 +1063,11 @@ int tipc_withdraw(u32 ref, unsigned int scope, struct tipc_name_seq const *seq)
 	if (list_empty(&p_ptr->publications))
 		p_ptr->published = 0;
 	tipc_port_unlock(p_ptr);
+
+	if (!skb_queue_empty(&nametbl_queue)) {
+		while (tbuf = skb_dequeue(&nametbl_queue))
+			named_cluster_distribute(tbuf);
+	}
 	return res;
 }
 
-- 
1.7.5.4

