From 7522f3624464bb32ff2dac8dfc438e303ffdc423 Mon Sep 17 00:00:00 2001
From: Jianchuan Wang <jianchuan.wang@windriver.com>
Date: Mon, 7 Mar 2016 15:34:30 +0800
Subject: [PATCH 2/8] grsec: Deter ptrace-based process snooping

The origin patch is from
deb.digdeo.fr/grsecurity-archives/kernel-4.1/grsecurity-3.1-4.1.7-201509201149.patch

Harding access limitation when non-root users to ptrace processes that
are not a descendent of the ptracing process.

Signed-off-by: Jianchuan Wang <jianchuan.wang@windriver.com>
---
 grsecurity/Kconfig     |   24 ++++++++++++++++++++++++
 kernel/fork.c          |   13 +++++++++++--
 kernel/ptrace.c        |   19 +++++++++++++++----
 mm/process_vm_access.c |    8 +++++++-
 security/Kconfig       |    2 ++
 5 files changed, 59 insertions(+), 7 deletions(-)
 create mode 100644 grsecurity/Kconfig

diff --git a/grsecurity/Kconfig b/grsecurity/Kconfig
new file mode 100644
index 0000000..7986e84
--- /dev/null
+++ b/grsecurity/Kconfig
@@ -0,0 +1,24 @@
+#
+# grecurity configuration
+#
+menu "Executable Protections"
+depends on GRKERNSEC
+
+config GRKERNSEC_HARDEN_PTRACE
+	bool "Deter ptrace-based process snooping"
+	default y if GRKERNSEC_ALL
+	help
+	  If you say Y here, TTY sniffers and other malicious monitoring
+	  programs implemented through ptrace will be defeated.  If you
+	  have been using the RBAC system, this option has already been
+	  enabled for several years for all users, with the ability to make
+	  fine-grained exceptions.
+
+	  This option only affects the ability of non-root users to ptrace
+	  processes that are not a descendent of the ptracing process.
+	  This means that strace ./binary and gdb ./binary will still work,
+	  but attaching to arbitrary processes will not.  If the sysctl
+	  option is enabled, a sysctl option with name "harden_ptrace" is
+	  created.
+
+endmenu
diff --git a/kernel/fork.c b/kernel/fork.c
index 25293e6..413016d 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -88,7 +88,9 @@
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
-
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+#include <linux/grsecurity.h>
+#endif
 /*
  * Minimum number of threads to boot the kernel
  */
@@ -791,8 +793,15 @@ struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)
 		return ERR_PTR(err);
 
 	mm = get_task_mm(task);
-	if (mm && mm != current->mm &&
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (mm &&
+		((mm != current->mm && !ptrace_may_access(task, mode)) ||
+		 (mode == PTRACE_MODE_ATTACH &&
+		  (gr_handle_proc_ptrace(task) || gr_acl_handle_procpidmem(task))))) {
+#else
+	if (mm && mm != current->mm && 
 			!ptrace_may_access(task, mode)) {
+#endif
 		mmput(mm);
 		mm = ERR_PTR(-EACCES);
 	}
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index c508388..74d4bdb 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -30,8 +30,9 @@
 #include <linux/kthread.h>
 #include <linux/ioprio.h>
 #include <linux/oom.h>
-
-
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+#include <linux/grsecurity.h>
+#endif
 /*
  * ptrace a task: make the debugger its new parent and
  * move it to the ptrace list.
@@ -1215,7 +1216,12 @@ SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
 #endif
 		goto out_put_task_struct;
         }
-
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (gr_handle_ptrace(child, request)) {
+		ret = -EPERM;
+		goto out_put_task_struct;
+	}
+#endif
 	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
 		ret = ptrace_attach(child, request, addr, data);
 		/*
@@ -1409,7 +1415,12 @@ COMPAT_SYSCALL_DEFINE4(ptrace, compat_long_t, request, compat_long_t, pid,
 #endif
 		goto out_put_task_struct;
         }
-
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (gr_handle_ptrace(child, request)) {
+		ret = -EPERM;
+		goto out_put_task_struct;
+	}
+#endif
 	if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
 		ret = ptrace_attach(child, request, addr, data);
 		/*
diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c
index e88d071..04bd075 100644
--- a/mm/process_vm_access.c
+++ b/mm/process_vm_access.c
@@ -21,6 +21,7 @@
 #include <linux/compat.h>
 #endif
 
+#include <linux/grsecurity.h>
 /**
  * process_vm_rw_pages - read/write pages from task specified
  * @pages: array of pointers to pages we want to copy
@@ -193,7 +194,12 @@ static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,
 		rc = -ESRCH;
 		goto free_proc_pages;
 	}
-
+#ifdef CONFIG_GRKERNSEC_HARDEN_PTRACE
+	if (gr_handle_ptrace(task, vm_write ? PTRACE_POKETEXT : PTRACE_ATTACH)) {
+		rc = -EPERM;
+		goto put_task_struct;
+	}
+#endif
 	mm = mm_access(task, PTRACE_MODE_ATTACH);
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
diff --git a/security/Kconfig b/security/Kconfig
index e4880a8..34eea89 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -74,6 +74,8 @@ config GRKERNSEC_CUSTOM
 	  automatically enabled.
 endchoice
 
+source grsecurity/Kconfig
+
 endmenu
 
 source security/keys/Kconfig
-- 
1.7.5.4

