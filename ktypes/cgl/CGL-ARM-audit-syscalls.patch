From 1d43d5e5501fdc1037340e774ea8a85a6e9dbd94 Mon Sep 17 00:00:00 2001
From: Amy Fong <amy.fong@windriver.com>
Date: Thu, 18 Feb 2010 07:05:05 -0800
Subject: [PATCH] ARM: Add audit syscall support for ARM platforms.

This adds support for tracing system calls in ARM under the audit
subsystem.

The work was implemented as directed from:
http://www.mail-archive.com/linux-audit@redhat.com/msg02523.html

To fully use this functionality, the userspace package audit needs to
have arm support added.

Signed-off-by: Amy Fong <Amy.Fong@windriver.com>
---
 arch/arm/Kconfig                   |    4 ++
 arch/arm/include/asm/thread_info.h |    2 +
 arch/arm/kernel/Makefile           |    3 +
 arch/arm/kernel/audit.c            |   77 ++++++++++++++++++++++++++++++++++++
 arch/arm/kernel/compat_audit.c     |   43 ++++++++++++++++++++
 arch/arm/kernel/entry-common.S     |    4 +-
 arch/arm/kernel/ptrace.c           |   25 ++++++++++++
 init/Kconfig                       |    2 +-
 8 files changed, 157 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/kernel/audit.c
 create mode 100644 arch/arm/kernel/compat_audit.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 93602d9..7226505 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -88,6 +88,10 @@ config GENERIC_HARDIRQS
 	bool
 	default y
 
+config AUDIT_ARCH
+	bool
+	default y
+
 config STACKTRACE_SUPPORT
 	bool
 	default y
diff --git a/arch/arm/include/asm/thread_info.h b/arch/arm/include/asm/thread_info.h
index a5e0213..322d243 100644
--- a/arch/arm/include/asm/thread_info.h
+++ b/arch/arm/include/asm/thread_info.h
@@ -132,6 +132,7 @@ extern void iwmmxt_task_switch(struct thread_info *);
  */
 #define TIF_SIGPENDING		0
 #define TIF_NEED_RESCHED	1
+#define TIF_SYSCALL_AUDIT	4	/* syscall auditing active */
 #define TIF_KERNEL_TRACE	7
 #define TIF_SYSCALL_TRACE	8
 #define TIF_RESTORE_SIGMASK	9       /* restore signal mask in do_signal */
@@ -142,6 +143,7 @@ extern void iwmmxt_task_switch(struct thread_info *);
 
 #define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
+#define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
 #define _TIF_KERNEL_TRACE	(1 << TIF_KERNEL_TRACE)
 #define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
 #define _TIF_RESTORE_SIGMASK	(1 << TIF_RESTORE_SIGMASK)
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index 4ae8192..489ae2a 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -47,3 +47,6 @@ head-y			:= head$(MMUEXT).o
 obj-$(CONFIG_DEBUG_LL)	+= debug.o
 
 extra-y := $(head-y) init_task.o vmlinux.lds
+
+obj-$(CONFIG_AUDIT)		+= audit.o
+compat-obj-$(CONFIG_AUDIT)	+= compat_audit.o
diff --git a/arch/arm/kernel/audit.c b/arch/arm/kernel/audit.c
new file mode 100644
index 0000000..fc5b1e2
--- /dev/null
+++ b/arch/arm/kernel/audit.c
@@ -0,0 +1,77 @@
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/audit.h>
+#include <asm/unistd.h>
+
+static unsigned dir_class[] = {
+#include <asm-generic/audit_dir_write.h>
+~0U
+};
+
+static unsigned read_class[] = {
+#include <asm-generic/audit_read.h>
+~0U
+};
+
+static unsigned write_class[] = {
+#include <asm-generic/audit_write.h>
+~0U
+};
+
+static unsigned chattr_class[] = {
+#include <asm-generic/audit_change_attr.h>
+~0U
+};
+
+static unsigned signal_class[] = {
+#include <asm-generic/audit_signal.h>
+~0U
+};
+
+int audit_classify_arch(int arch)
+{
+#ifdef CONFIG_COMPAT
+	if (arch == AUDIT_ARCH_ARM)
+		return 1;
+#endif
+	return 0;
+}
+
+int audit_classify_syscall(int abi, unsigned syscall)
+{
+#ifdef CONFIG_COMPAT
+	if (abi == AUDIT_ARCH_ARM)
+		return arm_classify_syscall(syscall);
+#endif
+	switch(syscall) {
+	case __NR_open:
+		return 2;
+	case __NR_openat:
+		return 3;
+	case __NR_socketcall:
+		return 4;
+	case __NR_execve:
+		return 5;
+	default:
+		return 0;
+	}
+}
+
+static int __init audit_classes_init(void)
+{
+#ifdef CONFIG_COMPAT
+	audit_register_class(AUDIT_CLASS_WRITE_32, arm_write_class);
+	audit_register_class(AUDIT_CLASS_READ_32, arm_read_class);
+	audit_register_class(AUDIT_CLASS_DIR_WRITE_32, arm_dir_class);
+	audit_register_class(AUDIT_CLASS_CHATTR_32, arm_chattr_class);
+	audit_register_class(AUDIT_CLASS_SIGNAL_32, arm_signal_class);
+#endif
+	audit_register_class(AUDIT_CLASS_WRITE, write_class);
+	audit_register_class(AUDIT_CLASS_READ, read_class);
+	audit_register_class(AUDIT_CLASS_DIR_WRITE, dir_class);
+	audit_register_class(AUDIT_CLASS_CHATTR, chattr_class);
+	audit_register_class(AUDIT_CLASS_SIGNAL, signal_class);
+	return 0;
+}
+
+__initcall(audit_classes_init);
diff --git a/arch/arm/kernel/compat_audit.c b/arch/arm/kernel/compat_audit.c
new file mode 100644
index 0000000..1f2effa
--- /dev/null
+++ b/arch/arm/kernel/compat_audit.c
@@ -0,0 +1,43 @@
+#include <asm/unistd.h>
+#include "audit.h"
+
+unsigned arm_dir_class[] = {
+#include <asm-generic/audit_dir_write.h>
+~0U
+};
+
+unsigned arm_chattr_class[] = {
+#include <asm-generic/audit_change_attr.h>
+~0U
+};
+
+unsigned arm_write_class[] = {
+#include <asm-generic/audit_write.h>
+~0U
+};
+
+unsigned arm_read_class[] = {
+#include <asm-generic/audit_read.h>
+~0U
+};
+
+unsigned arm_signal_class[] = {
+#include <asm-generic/audit_signal.h>
+~0U
+};
+
+int arm_classify_syscall(unsigned syscall)
+{
+	switch(syscall) {
+	case __NR_open:
+		return 2;
+	case __NR_openat:
+		return 3;
+	case __NR_socketcall:
+		return 4;
+	case __NR_execve:
+		return 5;
+	default:
+		return 1;
+	}
+}
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index a04452e..81f2e49 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -86,7 +86,7 @@ ENTRY(ret_from_fork)
 	get_thread_info tsk
 	ldr	r1, [tsk, #TI_FLAGS]		@ check for syscall tracing
 	mov	why, #1
-	tst	r1, #_TIF_SYSCALL_TRACE | _TIF_KERNEL_TRACE
+	tst	r1, #_TIF_SYSCALL_TRACE | _TIF_KERNEL_TRACE | _TIF_SYSCALL_AUDIT
 	beq	ret_slow_syscall		@ are we tracing syscalls?
 	mov	r1, sp
 	mov	r0, #1				@ trace exit [IP = 1]
@@ -275,7 +275,7 @@ ENTRY(vector_swi)
 #endif
 
 	stmdb	sp!, {r4, r5}			@ push fifth and sixth args
-	tst	ip, #_TIF_SYSCALL_TRACE | _TIF_KERNEL_TRACE
+	tst	ip, #_TIF_SYSCALL_TRACE | _TIF_KERNEL_TRACE | _TIF_SYSCALL_AUDIT
 	bne	__sys_trace			@ are we tracing syscalls?
 
 	cmp	scno, #NR_syscalls		@ check upper syscall limit
diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c
index a45f1cd..3b01a5e 100644
--- a/arch/arm/kernel/ptrace.c
+++ b/arch/arm/kernel/ptrace.c
@@ -23,12 +23,14 @@
 #include <linux/security.h>
 #include <linux/init.h>
 #include <linux/signal.h>
+#include <linux/audit.h>
 #include <trace/syscall.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
 #include <asm/traps.h>
+#include <asm/elf.h>
 
 #include "ptrace.h"
 
@@ -676,6 +678,15 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 	return ret;
 }
 
+static inline int audit_arch(void)
+{
+#ifdef __ARMEB__
+	return AUDIT_ARCH_ARMEB;
+#else
+	return AUDIT_ARCH_ARM;
+#endif
+}
+
 asmlinkage int syscall_trace(int why, struct pt_regs *regs, int scno)
 {
 	unsigned long ip;
@@ -686,6 +697,20 @@ asmlinkage int syscall_trace(int why, struct pt_regs *regs, int scno)
 	else
 		trace_syscall_exit(scno);
 
+	/* do the secure computing check first */
+	if (!why)
+		secure_computing(scno);
+
+	if (unlikely(current->audit_context)) {
+		/* why == 0, enter; why == 1, exit */
+		if (!why)
+			audit_syscall_entry(audit_arch(), scno,
+					    regs->ARM_r0, regs->ARM_r1,
+					    regs->ARM_r2, regs->ARM_r3);
+		else
+			audit_syscall_exit(AUDITSC_RESULT(regs->ARM_r0), regs->ARM_r0);
+	}
+
 	if (!test_thread_flag(TIF_SYSCALL_TRACE))
 		return scno;
 	if (!(current->ptrace & PT_PTRACED))
diff --git a/init/Kconfig b/init/Kconfig
index 182303f..4c4c303 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -226,7 +226,7 @@ config AUDIT
 
 config AUDITSYSCALL
 	bool "Enable system-call auditing support"
-	depends on AUDIT && (X86 || PPC || PPC64 || S390 || IA64 || UML || SPARC64|| SUPERH)
+	depends on AUDIT && (X86 || PPC || PPC64 || S390 || IA64 || UML || SPARC64|| SUPERH || ARM)
 	default y if SECURITY_SELINUX
 	help
 	  Enable low-overhead system-call auditing infrastructure that
-- 
1.6.5.2

