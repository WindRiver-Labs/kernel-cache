From 2a332666592db662c9cd3b513687da63e15a58e8 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Wed, 21 Apr 2010 20:30:05 -0700
Subject: [PATCH] net: add socket stats support

Datagram sockets will be able to retrieve and or reset counters
for both the number of packets received in total as well as the
number of packets dropped due to buffer overflow through ioctl
command SIOCGSOCKSTATS and SIOCZEROSOCKSTATS.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 include/linux/sockios.h |    4 +++
 include/net/sock.h      |   52 +++++++++++++++++++++++++++++++++++++++++++++++
 net/Kconfig             |   11 ++++++++++
 net/core/sock.c         |    4 +++
 net/socket.c            |   24 +++++++++++++++++++++
 5 files changed, 95 insertions(+), 0 deletions(-)

diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index 241f179..03d4d87 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -125,6 +125,10 @@
 /* hardware time stamping: parameters in linux/net_tstamp.h */
 #define SIOCSHWTSTAMP   0x89b0
 
+/* per-socket statistics manipulation */
+#define SIOCGSOCKSTATS		0x89c0	/* get the per-socket statistics */
+#define SIOCZEROSOCKSTATS	0x89c1	/* zero the per-socket statistics */
+
 /* Device private ioctl calls */
 
 /*
diff --git a/include/net/sock.h b/include/net/sock.h
index b4603cd..a76753d 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -80,6 +80,55 @@ SOCK_DEBUG(struct sock *sk, const char *msg, ...)
 }
 #endif
 
+/* per-socket statistics.  received is the total number of skbuffs received
+ * on that socket.  dropped_no_mem is the number of packets dropped due
+ * to a lack of space on the socket receive buffer.
+ *
+ * Note:  The lock only protects the reader from another cpu trying to zero
+ * the data.  There is still a race between the counts being updated and the
+ * counts being zeroed.  We don't worry about that.
+ */
+typedef struct {
+	__u64	received;
+	__u32	dropped_no_mem;
+} socket_stats;
+
+typedef struct {
+	socket_stats data;
+	spinlock_t lock;
+} socket_stats_struct;
+
+#ifdef CONFIG_DGRAM_SOCKSTATS
+#define inc_dgram_stats_received(sk)					\
+	do {sk->stats.data.received++; } while (0)
+#define inc_dgram_stats_dropped(sk)					\
+	do {sk->stats.data.dropped_no_mem++; } while (0)
+#define init_dgram_stats(sk)						\
+do {									\
+	(sk)->stats.data.dropped_no_mem = 0;				\
+	(sk)->stats.data.received = 0;					\
+	spin_lock_init(&(sk)->stats.lock);				\
+} while (0)
+#define zero_dgram_stats(sk)						\
+do {									\
+	spin_lock(&(sk)->stats.lock);					\
+	(sk)->stats.data.dropped_no_mem = 0;				\
+	(sk)->stats.data.received = 0;					\
+	spin_unlock(&(sk)->stats.lock);					\
+} while (0)
+#define copy_dgram_stats(tostats, sk)					\
+do {									\
+	spin_lock(&(sk)->stats.lock);					\
+	(tostats)->dropped_no_mem = (sk)->stats.data.dropped_no_mem;	\
+	(tostats)->received = (sk)->stats.data.received;		\
+	spin_unlock(&(sk)->stats.lock);					\
+} while	(0)
+#else
+#define inc_dgram_stats_received(sk)
+#define inc_dgram_stats_dropped(sk)
+#define init_dgram_stats(sk)
+#endif
+
 /* This is the per-socket lock.  The spinlock provides a synchronization
  * between user contexts and software interrupt processing, whereas the
  * mini-semaphore synchronizes multiple users amongst themselves.
@@ -315,6 +364,9 @@ struct sock {
   	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);  
 	void                    (*sk_destruct)(struct sock *sk);
+#ifdef CONFIG_DGRAM_SOCKSTATS
+	socket_stats_struct stats;
+#endif
 };
 
 /*
diff --git a/net/Kconfig b/net/Kconfig
index 7348d03..9f15d63 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -59,6 +59,17 @@ config QDISC_STATS
 
 	  Say Y if you want this additional tracking.
 
+config DGRAM_SOCKSTATS
+	bool "Datagram socket statistics"
+	default y
+	help
+	  If you say Y here, datagram sockets will be able to retrieve and
+	  or reset counters for both the number of packets received in total
+	  as well as the number of packets dropped due to buffer overflow.
+	  See code for data structures.
+
+	  If unsure, say N.
+
 config INET
 	bool "TCP/IP networking"
 	---help---
diff --git a/net/core/sock.c b/net/core/sock.c
index c5812bb..2e91ce5 100644
--- a/net/core/sock.c
+++ b/net/core/sock.c
@@ -279,12 +279,14 @@ int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 	unsigned long flags;
 	struct sk_buff_head *list = &sk->sk_receive_queue;
 
+	inc_dgram_stats_received(sk);
 	/* Cast sk->rcvbuf to unsigned... It's pointless, but reduces
 	   number of warnings when compiling with -W --ANK
 	 */
 	if (atomic_read(&sk->sk_rmem_alloc) + skb->truesize >=
 	    (unsigned)sk->sk_rcvbuf) {
 		atomic_inc(&sk->sk_drops);
+		inc_dgram_stats_dropped(sk);
 		return -ENOMEM;
 	}
 
@@ -1923,6 +1925,8 @@ void sock_init_data(struct socket *sock, struct sock *sk)
 
 	sk->sk_stamp = ktime_set(-1L, 0);
 
+	init_dgram_stats(sk);
+
 	/*
 	 * Before updating sk_refcnt, we must commit prior changes to memory
 	 * (Documentation/RCU/rculist_nulls.txt for details)
diff --git a/net/socket.c b/net/socket.c
index 5e8d0af..033c5a4 100644
--- a/net/socket.c
+++ b/net/socket.c
@@ -990,6 +990,26 @@ static long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 				err = dlci_ioctl_hook(cmd, argp);
 			mutex_unlock(&dlci_ioctl_mutex);
 			break;
+#ifdef CONFIG_DGRAM_SOCKSTATS
+		case SIOCGSOCKSTATS:
+		{
+			socket_stats stats;
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			copy_dgram_stats(&stats, sock->sk);
+			err = copy_to_user(argp, &stats,
+					sizeof(stats));
+			break;
+		}
+		case SIOCZEROSOCKSTATS:
+			err = -EINVAL;
+			if (!sock->sk)
+				break;
+			zero_dgram_stats(sock->sk);
+			err = 0;
+			break;
+#endif
 		default:
 			err = sock_do_ioctl(net, sock, cmd, arg);
 			break;
@@ -2923,6 +2943,10 @@ static int compat_sock_ioctl_trans(struct file *file, struct socket *sock,
 	case SIOCSIFVLAN:
 	case SIOCADDDLCI:
 	case SIOCDELDLCI:
+#ifdef CONFIG_DGRAM_SOCKSTATS
+	case SIOCGSOCKSTATS:
+	case SIOCZEROSOCKSTATS:
+#endif
 		return sock_ioctl(file, cmd, arg);
 
 	case SIOCGIFFLAGS:
-- 
1.6.5.2

