From 8ce1a9dada19c72828abd7bba9a293004d5ec8c4 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 7 Aug 2008 17:06:54 +0800
Subject: [PATCH] time of day notify

Add notification service for time of day changes, implemented through
/proc/notify_settime_signal.

Signed-off-by: Peter Seebach <peter.seebach@windriver.com>
Integrated-by: Yongli he   <yongli.he@windriver.com>
---
 fs/compat.c               |    4 ++
 fs/exec.c                 |    4 ++
 include/linux/hrtimer.h   |    5 ++
 include/linux/init_task.h |    8 ++++
 include/linux/sched.h     |    3 +
 include/linux/time.h      |    4 ++
 init/Kconfig              |   10 ++++
 kernel/Makefile           |    1 +
 kernel/hrtimer.c          |   18 ++++++++
 kernel/notify_settime.c   |  102 +++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 159 insertions(+), 0 deletions(-)
 create mode 100644 kernel/notify_settime.c

diff --git a/fs/compat.c b/fs/compat.c
index 82283db..5640a66 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -1412,6 +1412,10 @@ int compat_do_execve(char * filename,
 		/* execve success */
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
+#ifdef CONFIG_NOTIFY_SETTIME
+		/* there's got to be a better place for this! */
+		current->settime_sig = 0;
+#endif
 		free_bprm(bprm);
 		return retval;
 	}
diff --git a/fs/exec.c b/fs/exec.c
index 37dbb0f..9f5d602 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1347,6 +1347,10 @@ int do_execve(char * filename,
 		security_bprm_free(bprm);
 		acct_update_integrals(current);
 		free_bprm(bprm);
+#ifdef CONFIG_NOTIFY_SETTIME
+		/* there's got to be a better place for this!  */
+		current->settime_sig = 0;
+#endif
 		if (displaced)
 			put_files_struct(displaced);
 		return retval;
diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h
index 6d93dce..888b032 100644
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -237,8 +237,13 @@ static inline int hrtimer_is_hres_active(struct hrtimer *timer)
  * clock_was_set() is a NOP for non- high-resolution systems. The
  * time-sorted order guarantees that a timer does not expire early and
  * is expired in the next softirq when the clock was advanced.
+ * However, it becomes relevant anyway with CONFIG_NOTIFY_SETTIME.
  */
+#ifdef CONFIG_NOTIFY_SETTIME
+extern void clock_was_set(void);
+#else
 static inline void clock_was_set(void) { }
+#endif
 
 static inline void hres_timers_resume(void) { }
 
diff --git a/include/linux/init_task.h b/include/linux/init_task.h
index 873610e..b96204e 100644
--- a/include/linux/init_task.h
+++ b/include/linux/init_task.h
@@ -75,6 +75,13 @@ extern struct nsproxy init_nsproxy;
 #define INIT_SIGEXIT(tsk)
 #endif
 
+#ifdef CONFIG_NOTIFY_SETTIME
+#define INIT_NOTIFY_SETTIME \
+	.settime_sig    = 0,
+#else
+#define INIT_NOTIFY_SETTIME
+#endif
+
 extern struct group_info init_groups;
 
 #define INIT_STRUCT_PID {						\
@@ -199,6 +206,7 @@ extern struct group_info init_groups;
 	INIT_IDS							\
 	INIT_TRACE_IRQFLAGS						\
 	INIT_LOCKDEP							\
+	INIT_NOTIFY_SETTIME						\
 }
 
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 792da2c..9f0630f 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1320,6 +1320,9 @@ struct task_struct {
         void *proc;
         void (*proc_destruct)(void *proc);
 #endif
+#ifdef CONFIG_NOTIFY_SETTIME
+	int settime_sig;                /* notify_settime() signal */
+#endif
 
 };
 
diff --git a/include/linux/time.h b/include/linux/time.h
index e15206a..906fe17 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -125,6 +125,10 @@ extern int timekeeping_valid_for_hres(void);
 extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 
+#ifdef CONFIG_NOTIFY_SETTIME
+extern void clock_was_set(void); /* called whenever the clock is set */
+void do_notify_timechange(void);
+#endif
 /**
  * timespec_to_ns - Convert timespec to nanoseconds
  * @ts:		pointer to the timespec variable to be converted
diff --git a/init/Kconfig b/init/Kconfig
index 49c3140..50f8b9e 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -908,6 +908,16 @@ config MEMMON_SWAP_SUPPORT
 	  This slows down dirty page scanning significantly, so only enable if
 	  actually needed.
 
+config NOTIFY_SETTIME
+	bool "Notify processes when time of day is changed"
+	default y
+	help
+	  Enabling this will allow apps to register to be sent a signal
+	  whenever the time of day on the system has changed (due to someone
+	  calling settimeofday(), for instance).
+
+	  This is exposed to userspace via /proc/notify_settime_signal
+
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/kernel/Makefile b/kernel/Makefile
index fa561ab..36013a1 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -94,6 +94,7 @@ obj-$(CONFIG_FTRACE) += trace/
 obj-$(CONFIG_TRACING) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
 obj-$(CONFIG_SIGEXIT) += death_notify.o
+obj-$(CONFIG_NOTIFY_SETTIME) += notify_settime.o
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index b8e4dce..1a41921 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -623,6 +623,10 @@ void clock_was_set(void)
 {
 	/* Retrigger the CPU local events everywhere */
 	on_each_cpu(retrigger_next_event, NULL, 1);
+#ifdef CONFIG_NOTIFY_SETTIME
+	/* Notify any userspace apps that were interested in the change */
+	do_notify_timechange();
+#endif
 }
 
 /*
@@ -739,6 +743,20 @@ static inline void hrtimer_raise_softirq(void)
 
 #else
 
+#ifdef CONFIG_NOTIFY_SETTIME
+/*
+ * Clock realtime was set
+ *
+ * Change the offset of the realtime clock vs. the monotonic
+ * clock.  In the absence of high-res timers, that applies only
+ * with CONFIG_NOTIFY_SETTIME.
+ */
+void clock_was_set(void)
+{
+	/* Notify any userspace apps that were interested in the change */
+	do_notify_timechange();
+}
+#endif
 static inline int hrtimer_hres_active(void) { return 0; }
 static inline int hrtimer_is_hres_enabled(void) { return 0; }
 static inline int hrtimer_switch_to_hres(void) { return 0; }
diff --git a/kernel/notify_settime.c b/kernel/notify_settime.c
new file mode 100644
index 0000000..e364801
--- /dev/null
+++ b/kernel/notify_settime.c
@@ -0,0 +1,102 @@
+/*
+ *  Notify processes whenever the time is modified via settimeofday.
+ *  Copyright (C) 2006-2007 Wind River Systems, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+/*
+ * Called when the time is modified below with settimeofday in order
+ * to notify all of the tasks that requested notification.
+ */
+void do_notify_timechange(void)
+{
+	struct task_struct *p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		if (p->settime_sig)
+			group_send_sig_info(p->settime_sig, SEND_SIG_PRIV, p);
+	}
+	read_unlock(&tasklist_lock);
+}
+
+/*
+ * Set a signal to be delivered to the calling process whenever
+ * time of day is changed. A signal value of zero indicates that
+ * no signal should be sent.  On success, the call returns the
+ * old value of the signal.  A return value of -1 indicates an error.
+ */
+int do_notify_settime(int sig)
+{
+	int ret = -EINVAL;
+
+	if ((sig > 0) && (sig <= _NSIG)) {
+		ret = current->settime_sig;
+		current->settime_sig = sig;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_PROC_FS
+#define NOTIFY_SETTIME_PROCFS_NAME "notify_settime_signal"
+
+static int show_notify_settime_signal(char *page, char **start, off_t offset,
+				      int count, int *eof, void *data)
+{
+	return snprintf(page, count, "%d\n", current->settime_sig);
+}
+
+static int store_notify_settime_signal(struct file *file,
+					const char __user *buffer,
+				       unsigned long count, void *data)
+{
+	char str[16];
+	int sig = 0;
+
+	if (count > sizeof(str)-1) return -EINVAL;
+
+	memset(str, 0, sizeof(str));
+	if (copy_from_user(str, buffer, count)) return -EFAULT;
+
+	sscanf(str, "%d", &sig);
+	return do_notify_settime(sig);
+}
+
+static int __init notify_settime_init(void)
+{
+	struct proc_dir_entry *e;
+	int ret = 0;
+
+	e = create_proc_entry(NOTIFY_SETTIME_PROCFS_NAME,
+			      S_IFREG | S_IRUGO | S_IWUSR, NULL);
+	if (e) {
+		e->read_proc = show_notify_settime_signal;
+		e->write_proc = store_notify_settime_signal;
+		e->data = NULL;
+	} else {
+		ret = -ENOMEM;
+	}
+	return ret;
+}
+__initcall(notify_settime_init);
+#endif
-- 
1.5.5.1

