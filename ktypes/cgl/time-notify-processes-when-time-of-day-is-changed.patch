From 6ad2f9430aa4cd63de1080ba83b4c95fe06cce95 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Tue, 6 Apr 2010 18:35:28 -0700
Subject: [PATCH] time: notify processes when time of day is changed

Subject: [PATCH] time: notify processes when time of day is changed
Enabling this will allow apps to register to be sent a signal
whenever the time of day on the system has changed (due to someone
calling settimeofday(), for instance).

This is exposed to userspace via /proc/notify_settime_signal

Signed-off-by: Peter Seebach <peter.seebach@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 fs/compat.c               |    4 ++
 fs/exec.c                 |    4 ++
 include/linux/hrtimer.h   |    5 ++
 include/linux/init_task.h |    8 +++
 include/linux/sched.h     |    3 +
 include/linux/time.h      |    4 ++
 init/Kconfig              |   10 ++++
 kernel/Makefile           |    1 +
 kernel/hrtimer.c          |   18 ++++++++
 kernel/notify_settime.c   |  104 +++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 161 insertions(+), 0 deletions(-)
 create mode 100644 kernel/notify_settime.c

diff --git a/fs/compat.c b/fs/compat.c
index e507357..6575ee9 100644
--- a/fs/compat.c
+++ b/fs/compat.c
@@ -1578,6 +1578,10 @@ int compat_do_execve(char * filename,
 	current->in_execve = 0;
 	acct_update_integrals(current);
 	free_bprm(bprm);
+#ifdef CONFIG_NOTIFY_SETTIME
+	/* there's got to be a better place for this! */
+	current->settime_sig = 0;
+#endif
 	if (displaced)
 		put_files_struct(displaced);
 	return retval;
diff --git a/fs/exec.c b/fs/exec.c
index d234a86..6ca8bef 100644
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -1473,6 +1473,10 @@ int do_execve(char * filename,
 	current->in_execve = 0;
 	acct_update_integrals(current);
 	free_bprm(bprm);
+#ifdef CONFIG_NOTIFY_SETTIME
+	/* there's got to be a better place for this!  */
+	current->settime_sig = 0;
+#endif
 	if (displaced)
 		put_files_struct(displaced);
 	return retval;
diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h
index 5d86fb2..b457d7c 100644
--- a/include/linux/hrtimer.h
+++ b/include/linux/hrtimer.h
@@ -289,8 +289,13 @@ extern void hrtimer_peek_ahead_timers(void);
  * clock_was_set() is a NOP for non- high-resolution systems. The
  * time-sorted order guarantees that a timer does not expire early and
  * is expired in the next softirq when the clock was advanced.
+ * However, it becomes relevant anyway with CONFIG_NOTIFY_SETTIME.
  */
+#ifdef CONFIG_NOTIFY_SETTIME
+extern void clock_was_set(void);
+#else
 static inline void clock_was_set(void) { }
+#endif
 static inline void hrtimer_peek_ahead_timers(void) { }
 
 static inline void hres_timers_resume(void) { }
diff --git a/include/linux/init_task.h b/include/linux/init_task.h
index 71ec07d..c1857de 100644
--- a/include/linux/init_task.h
+++ b/include/linux/init_task.h
@@ -40,6 +40,13 @@ extern struct nsproxy init_nsproxy;
 	.signalfd_wqh	= __WAIT_QUEUE_HEAD_INITIALIZER(sighand.signalfd_wqh),	\
 }
 
+#ifdef CONFIG_NOTIFY_SETTIME
+#define INIT_NOTIFY_SETTIME \
+	.settime_sig    = 0,
+#else
+#define INIT_NOTIFY_SETTIME
+#endif
+
 extern struct group_info init_groups;
 
 #define INIT_STRUCT_PID {						\
@@ -180,6 +187,7 @@ extern struct cred init_cred;
 	INIT_TRACE_RECURSION						\
 	INIT_TASK_RCU_PREEMPT(tsk)					\
 	INIT_GR_FS_LOCK							\
+	INIT_NOTIFY_SETTIME						\
 }
 
 
diff --git a/include/linux/sched.h b/include/linux/sched.h
index b9e3631..8c9ba66 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1530,6 +1530,9 @@ struct task_struct {
 		unsigned long memsw_bytes; /* uncharged mem+swap usage */
 	} memcg_batch;
 #endif
+#ifdef CONFIG_NOTIFY_SETTIME
+	int settime_sig;                /* notify_settime() signal */
+#endif
 };
 
 #define MF_PAX_PAGEEXEC		0x01000000	/* Paging based non-executable pages */
diff --git a/include/linux/time.h b/include/linux/time.h
index 6e026e4..14e96fe 100644
--- a/include/linux/time.h
+++ b/include/linux/time.h
@@ -153,6 +153,10 @@ extern void update_wall_time(void);
 extern void update_xtime_cache(u64 nsec);
 extern void timekeeping_leap_insert(int leapsecond);
 
+#ifdef CONFIG_NOTIFY_SETTIME
+extern void do_notify_timechange(void);
+#endif
+
 struct tms;
 extern void do_sys_times(struct tms *);
 
diff --git a/init/Kconfig b/init/Kconfig
index 1eec3e1..b47b6d4 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1161,6 +1161,16 @@ config OOM_PROTECT
 	  request protection from the out-of-memory killer as long as
 	  the process is using less than the specified amount of virtual
 	  memory.  This is accomplished through a call to setrlimit().
+config NOTIFY_SETTIME
+	bool "Notify processes when time of day is changed"
+	default y
+	help
+	  Enabling this will allow apps to register to be sent a signal
+	  whenever the time of day on the system has changed (due to someone
+	  calling settimeofday(), for instance).
+
+	  This is exposed to userspace via /proc/notify_settime_signal
+
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/kernel/Makefile b/kernel/Makefile
index c4e164a..48954c5 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -101,6 +101,7 @@ obj-$(CONFIG_TRACING) += trace/
 obj-$(CONFIG_X86_DS) += trace/
 obj-$(CONFIG_RING_BUFFER) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
+obj-$(CONFIG_NOTIFY_SETTIME) += notify_settime.o
 obj-$(CONFIG_SLOW_WORK) += slow-work.o
 obj-$(CONFIG_SLOW_WORK_DEBUG) += slow-work-debugfs.o
 obj-$(CONFIG_PERF_EVENTS) += perf_event.o
diff --git a/kernel/hrtimer.c b/kernel/hrtimer.c
index b0aae60..ab70681 100644
--- a/kernel/hrtimer.c
+++ b/kernel/hrtimer.c
@@ -651,6 +651,10 @@ void clock_was_set(void)
 {
 	/* Retrigger the CPU local events everywhere */
 	on_each_cpu(retrigger_next_event, NULL, 1);
+#ifdef CONFIG_NOTIFY_SETTIME
+	/* Notify any userspace apps that were interested in the change */
+	do_notify_timechange();
+#endif
 }
 
 /*
@@ -740,6 +744,20 @@ static int hrtimer_switch_to_hres(void)
 
 #else
 
+#ifdef CONFIG_NOTIFY_SETTIME
+/*
+ * Clock realtime was set
+ *
+ * Change the offset of the realtime clock vs. the monotonic
+ * clock.  In the absence of high-res timers, that applies only
+ * with CONFIG_NOTIFY_SETTIME.
+ */
+void clock_was_set(void)
+{
+	/* Notify any userspace apps that were interested in the change */
+	do_notify_timechange();
+}
+#endif
 static inline int hrtimer_hres_active(void) { return 0; }
 static inline int hrtimer_is_hres_enabled(void) { return 0; }
 static inline int hrtimer_switch_to_hres(void) { return 0; }
diff --git a/kernel/notify_settime.c b/kernel/notify_settime.c
new file mode 100644
index 0000000..2866dcd
--- /dev/null
+++ b/kernel/notify_settime.c
@@ -0,0 +1,104 @@
+/*
+ *  Notify processes whenever the time is modified via settimeofday.
+ *  Copyright (C) 2006-2007 Wind River Systems, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/signal.h>
+#include <linux/stat.h>
+#include <linux/proc_fs.h>
+#include <linux/uaccess.h>
+
+/*
+ * Called when the time is modified below with settimeofday in order
+ * to notify all of the tasks that requested notification.
+ */
+void do_notify_timechange(void)
+{
+	struct task_struct *p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		if (p->settime_sig)
+			group_send_sig_info(p->settime_sig, SEND_SIG_PRIV, p);
+	}
+	read_unlock(&tasklist_lock);
+}
+
+/*
+ * Set a signal to be delivered to the calling process whenever
+ * time of day is changed. A signal value of zero indicates that
+ * no signal should be sent.  On success, the call returns the
+ * old value of the signal.  A return value of -1 indicates an error.
+ */
+static int do_notify_settime(int sig)
+{
+	int ret = -EINVAL;
+
+	if ((sig > 0) && (sig <= _NSIG)) {
+		ret = current->settime_sig;
+		current->settime_sig = sig;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_PROC_FS
+#define NOTIFY_SETTIME_PROCFS_NAME "notify_settime_signal"
+
+static int show_notify_settime_signal(char *page, char **start, off_t offset,
+				      int count, int *eof, void *data)
+{
+	return snprintf(page, count, "%d\n", current->settime_sig);
+}
+
+static int store_notify_settime_signal(struct file *file,
+					const char __user *buffer,
+				       unsigned long count, void *data)
+{
+	char str[16];
+	int sig = 0;
+
+	if (count > sizeof(str)-1)
+		return -EINVAL;
+
+	memset(str, 0, sizeof(str));
+	if (copy_from_user(str, buffer, count))
+		return -EFAULT;
+
+	sscanf(str, "%d", &sig);
+	return do_notify_settime(sig);
+}
+
+static int __init notify_settime_init(void)
+{
+	struct proc_dir_entry *e;
+	int ret = 0;
+
+	e = create_proc_entry(NOTIFY_SETTIME_PROCFS_NAME,
+			      S_IFREG | S_IRUGO | S_IWUSR, NULL);
+	if (e) {
+		e->read_proc = show_notify_settime_signal;
+		e->write_proc = store_notify_settime_signal;
+		e->data = NULL;
+	} else {
+		ret = -ENOMEM;
+	}
+	return ret;
+}
+device_initcall(notify_settime_init);
+#endif
-- 
1.6.0.3

