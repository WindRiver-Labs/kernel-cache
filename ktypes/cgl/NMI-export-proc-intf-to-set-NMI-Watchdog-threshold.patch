From 5f28ef05f0fa24a7cd117d4c6a6c32a65a921905 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Tue, 30 Mar 2010 23:15:09 -0700
Subject: [PATCH 2/2] NMI: export proc intf to set NMI Watchdog threshold

This enhancement patch creates a procfs entry for user space to
dynamically change the NMI Watchdog default timedout value,
which has been hard coded as 5 seconds in arch/x86/kernel/apic/nmi.c.

Signed-off-by: Harry Ciao<qingtao.cao@windriver.com>
Signed-off-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/x86/Kconfig           |   29 +++++++++++++++++++++++++++++
 arch/x86/include/asm/nmi.h |    1 +
 arch/x86/kernel/apic/nmi.c |   16 ++++++++++++++--
 include/linux/sysctl.h     |    1 +
 kernel/sysctl.c            |   14 ++++++++++++++
 kernel/sysctl_binary.c     |    1 +
 6 files changed, 60 insertions(+), 2 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 9f1f086..0d218a9 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -833,6 +833,35 @@ config APIC_NMI_DISABLING
 	  NMIs and 1 to re-enable them. The state can be obtained by reading
 	  the file.
 
+config NMI_WATCHDOG_THRESH_DEF
+	int "NMI Watchdog timedout default threshold"
+	range 1 100
+	default 5
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the default timedout seconds of NMI Watchdog, and could
+	  be adjusted at run time through /proc/sys/kernel/nmi_watchdog_thresh.
+	  However, its value must abide by the lower & upper limit defined at
+	  kernel configuration.
+
+config NMI_WATCHDOG_THRESH_MIN
+	int "NMI Watchdog timedout lower limit"
+	range 1 100
+	default 1
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the lower limit of NMI Watchdog timedout seconds, and it
+	  should be no less than 1 and no greater than 100.
+
+config NMI_WATCHDOG_THRESH_MAX
+	int "NMI Watchdog timedout upper limit"
+	range 1 100
+	default 100
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the upper limit of NMI Watchdog timedout seconds, and it
+	  should be no greater than 100, and no less than the lower limit of course.
+
 config X86_VISWS_APIC
 	def_bool y
 	depends on X86_32 && X86_VISWS
diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 513c676..141573b 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -18,6 +18,7 @@ int do_nmi_callback(struct pt_regs *regs, int cpu);
 extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
 extern int check_nmi_watchdog(void);
 extern int nmi_watchdog_enabled;
+extern int nmi_watchdog_thresh;
 extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
 extern int reserve_perfctr_nmi(unsigned int);
 extern void release_perfctr_nmi(unsigned int);
diff --git a/arch/x86/kernel/apic/nmi.c b/arch/x86/kernel/apic/nmi.c
index 8aa65ad..3b6842e 100644
--- a/arch/x86/kernel/apic/nmi.c
+++ b/arch/x86/kernel/apic/nmi.c
@@ -387,6 +387,9 @@ void touch_nmi_watchdog(void)
 }
 EXPORT_SYMBOL(touch_nmi_watchdog);
 
+/* Export a sysctl intf to set default timedout value at run time */
+int nmi_watchdog_thresh = CONFIG_NMI_WATCHDOG_THRESH_DEF;
+
 notrace __kprobes int
 nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 {
@@ -436,10 +439,19 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	if (!touched && __get_cpu_var(last_irq_sum) == sum) {
 		/*
 		 * Ayiee, looks like this CPU is stuck ...
-		 * wait a few IRQs (5 seconds) before doing the oops ...
+		 * wait a few IRQs (nmi_watchdog_thresh seconds)
+		 * before doing the oops ...
 		 */
 		__this_cpu_inc(alert_counter);
-		if (__this_cpu_read(alert_counter) == 5 * nmi_hz)
+
+		/*
+		 * Avoid unnecessary reading from the default timedout value,
+		 * thus avoid "dirty reading" from the sysctl entry.
+		 */
+		if ((__this_cpu_read(alert_counter) >=
+				CONFIG_NMI_WATCHDOG_THRESH_MIN * nmi_hz) &&
+		    (__this_cpu_read(alert_counter) ==
+				nmi_watchdog_thresh * nmi_hz))
 			/*
 			 * die_nmi will return ONLY if NOTIFY_STOP happens..
 			 */
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index 81ddcc4..476ad5f 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -154,6 +154,7 @@ enum
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
 	KERN_NMI_TOGGLE=77, /* int: NMI on/off */
+	KERN_NMI_WATCHDOG_THRESH=78, /* int: nmi watchdog timedout threshold */
 };
 
 
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 7da9be8..6f61ee5 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -240,6 +240,11 @@ static int min_sched_shares_ratelimit = 100000; /* 100 usec */
 static int max_sched_shares_ratelimit = NSEC_PER_SEC; /* 1 second */
 #endif
 
+#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)
+static int nmi_watchdog_thresh_min = CONFIG_NMI_WATCHDOG_THRESH_MIN;
+static int nmi_watchdog_thresh_max = CONFIG_NMI_WATCHDOG_THRESH_MAX;
+#endif
+
 static struct ctl_table kern_table[] = {
 	{
 		.procname	= "sched_child_runs_first",
@@ -697,6 +702,15 @@ static struct ctl_table kern_table[] = {
 		.mode           = 0644,
 		.proc_handler   = proc_nmi_enabled,
 	},
+	{
+		.procname       = "nmi_watchdog_thresh",
+		.data           = &nmi_watchdog_thresh,
+		.maxlen         = sizeof (int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec_minmax,
+		.extra1	        = &nmi_watchdog_thresh_min,
+		.extra2	        = &nmi_watchdog_thresh_max,
+	},
 #endif
 #ifdef CONFIG_APIC_NMI_DISABLING
 	{
diff --git a/kernel/sysctl_binary.c b/kernel/sysctl_binary.c
index fd1e51d..18f9fc8 100644
--- a/kernel/sysctl_binary.c
+++ b/kernel/sysctl_binary.c
@@ -137,6 +137,7 @@ static const struct bin_table bin_kern_table[] = {
 	{ CTL_INT,	KERN_NMI_WATCHDOG,		"nmi_watchdog" },
 	{ CTL_INT,	KERN_PANIC_ON_NMI,		"panic_on_unrecovered_nmi" },
 	{ CTL_INT,	KERN_NMI_TOGGLE,		"nmi_enabled" },
+	{ CTL_INT,	KERN_NMI_WATCHDOG_THRESH,	"nmi_watchdog_thresh" },
 	{}
 };
 
-- 
1.6.5.2

