From a11eef22def481c08a116c89547d4f267a87ff90 Mon Sep 17 00:00:00 2001
From: Harry Ciao <qingtao.cao@windriver.com>
Date: Tue, 9 Dec 2008 15:55:41 +0800
Subject: [PATCH] NMI: export proc intf to set NMI Watchdog threshold

This enhancement patch creates a procfs entry for user space to dynamically
change the NMI Watchdog default timedout value, which has been hard coded
as 5 seconds in arch/x86/kernel/nmi.c.

Signed-off-by: Harry Ciao<qingtao.cao@windriver.com>
---
 arch/x86/Kconfig       |   29 +++++++++++++++++++++++++++++
 arch/x86/kernel/nmi.c  |   29 +++++++++++++++++++++++------
 include/linux/sysctl.h |    1 +
 kernel/sysctl.c        |   16 ++++++++++++++++
 4 files changed, 69 insertions(+), 6 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index d0a7075..bf53346 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -682,6 +682,35 @@ config X86_IO_APIC
 	def_bool y
 	depends on X86_64 || (X86_32 && (X86_UP_IOAPIC || (SMP && !X86_VOYAGER) || X86_GENERICARCH))
 
+config NMI_WATCHDOG_THRESH_DEF
+	int "NMI Watchdog timedout default threshold"
+	range 1 100
+	default 5
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the default timedout seconds of NMI Watchdog, and could
+	  be adjusted at run time through /proc/sys/kernel/nmi_watchdog_thresh.
+	  However, its value must abide by the lower & upper limit defined at
+	  kernel configuration.
+
+config NMI_WATCHDOG_THRESH_MIN
+	int "NMI Watchdog timedout lower limit"
+	range 1 100
+	default 1
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the lower limit of NMI Watchdog timedout seconds, and it
+	  should be no less than 1 and no greater than 100.
+
+config NMI_WATCHDOG_THRESH_MAX
+	int "NMI Watchdog timedout upper limit"
+	range 1 100
+	default 100
+	depends on X86_LOCAL_APIC
+	help
+	  This amount is the upper limit of NMI Watchdog timedout seconds, and it
+	  should be no greater than 100, and no less than the lower limit of course.
+
 config X86_VISWS_APIC
 	def_bool y
 	depends on X86_32 && X86_VISWS
diff --git a/arch/x86/kernel/nmi.c b/arch/x86/kernel/nmi.c
index abb78a2..d23673e 100644
--- a/arch/x86/kernel/nmi.c
+++ b/arch/x86/kernel/nmi.c
@@ -378,6 +378,9 @@ void touch_nmi_watchdog(void)
 }
 EXPORT_SYMBOL(touch_nmi_watchdog);
 
+/* Export a sysctl intf to set default timedout value at run time */
+int nmi_watchdog_thresh = CONFIG_NMI_WATCHDOG_THRESH_DEF;
+
 notrace __kprobes int
 nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 {
@@ -423,15 +426,29 @@ nmi_watchdog_tick(struct pt_regs *regs, unsigned reason)
 	if (!touched && __get_cpu_var(last_irq_sum) == sum) {
 		/*
 		 * Ayiee, looks like this CPU is stuck ...
-		 * wait a few IRQs (5 seconds) before doing the oops ...
+		 * wait a few IRQs (nmi_watchdog_thresh seconds)
+		 * before doing the oops ...
 		 */
 		local_inc(&__get_cpu_var(alert_counter));
-		if (local_read(&__get_cpu_var(alert_counter)) == 5 * nmi_hz)
+
+		/*
+		 * Avoid unnecessary reading from the default timedout value,
+		 * thus avoid "dirty reading" from the sysctl entry.
+		 */
+		if (local_read(&__get_cpu_var(alert_counter)) >=
+			CONFIG_NMI_WATCHDOG_THRESH_MIN * nmi_hz) {
+			if (local_read(&__get_cpu_var(alert_counter)) ==
+				nmi_watchdog_thresh * nmi_hz) {
+				touch_nmi_watchdog();
 			/*
-			 * die_nmi will return ONLY if NOTIFY_STOP happens..
-			 */
-			die_nmi("BUG: NMI Watchdog detected LOCKUP",
-				regs, panic_on_timeout);
+				 * die_nmi will return ONLY if NOTIFY_STOP
+				 * happens..
+				 */
+				die_nmi("BUG: NMI Watchdog detected LOCKUP",
+					regs, panic_on_timeout);
+				touch_nmi_watchdog();
+			}
+ 		}
 	} else {
 		__get_cpu_var(last_irq_sum) = sum;
 		local_set(&__get_cpu_var(alert_counter), 0);
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index bf83aa7..32ec458 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -166,6 +166,7 @@ enum
 	KERN_DISABLE_HISTORY_BUFFER=77, /* int: disable the logging to exception and scheduler history buffers */
 	KERN_NMI_TOGGLE=78,	/* NMI on/off */
     	KERN_HRT_KHZ=79,        /* int: high res time frequency in khz */
+	KERN_NMI_WATCHDOG_THRESH=80, /* NMI Watchdog timedout threshold*/
 
 #ifdef CONFIG_GRKERNSEC
 	KERN_GRSECURITY=98,	/* grsecurity */
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index d98abef..6824a70 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -218,6 +218,12 @@ static ctl_table pax_table[] = {
 };
 #endif
 
+#if defined(CONFIG_X86_LOCAL_APIC) && defined(CONFIG_X86)
+extern int nmi_watchdog_thresh;
+int nmi_watchdog_thresh_min = CONFIG_NMI_WATCHDOG_THRESH_MIN;
+int nmi_watchdog_thresh_max = CONFIG_NMI_WATCHDOG_THRESH_MAX;
+#endif
+
 extern int prove_locking;
 extern int lock_stat;
 
@@ -717,6 +723,16 @@ static struct ctl_table kern_table[] = {
 		.mode           = 0644,
 		.proc_handler   = &proc_nmi_enabled,
 	},
+	{
+		.ctl_name	= KERN_NMI_WATCHDOG_THRESH,
+		.procname	= "nmi_watchdog_thresh",
+		.data		= &nmi_watchdog_thresh,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &nmi_watchdog_thresh_min,
+		.extra2		= &nmi_watchdog_thresh_max,
+	},
 #endif
 #if defined(CONFIG_X86)
 	{
-- 
1.6.0.2.GIT

