From cbd41f79e6e5ef95d623cc66e6c7fbf1b9166a10 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Tue, 30 Mar 2010 23:12:08 -0700
Subject: [PATCH 2/5] NMI disabling at runtime

Add interface to disable NMI interrupt from user-space at runtime.

The disabling of NMI is done by reverting the line on which NMIs
come in on the local APIC to a regular interrupt line, and then
masking it. Since this is not normal operating behaviour, errors
must be masked to prevent them from being recorded by the kernel.

The functionality is provided for both 32-bit and 64-bit kernels.

The interface is provided via the /proc/sys/kernel/nmi_enabled
entry. Writing a 0 to it disables NMI interrupts, writing a 1
re-enables them.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 arch/x86/Kconfig               |   10 +++++
 arch/x86/include/asm/nmi.h     |    7 +++
 arch/x86/kernel/apic/apic.c    |   47 ++++++++++++++++++++++
 arch/x86/kernel/apic/io_apic.c |   84 ++++++++++++++++++++++++++++++++++++++++
 include/linux/sysctl.h         |    1 +
 kernel/sysctl.c                |   11 +++++
 kernel/sysctl_binary.c         |    1 +
 7 files changed, 161 insertions(+), 0 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 0eacb1f..9f1f086 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -823,6 +823,16 @@ config X86_IO_APIC
 	def_bool y
 	depends on X86_64 || SMP || X86_32_NON_STANDARD || X86_UP_APIC
 
+config APIC_NMI_DISABLING
+	bool "Disabling of NMI during system operation"
+	default n
+	depends on X86_LOCAL_APIC && X86_IO_APIC
+	help
+	  Allows disabling the NMI interrupts during system operation through
+	  procfs entry /proc/sys/kernel/nmi_enabled. Set it to 0 to disable
+	  NMIs and 1 to re-enable them. The state can be obtained by reading
+	  the file.
+
 config X86_VISWS_APIC
 	def_bool y
 	depends on X86_32 && X86_VISWS
diff --git a/arch/x86/include/asm/nmi.h b/arch/x86/include/asm/nmi.h
index 93da9c3..513c676 100644
--- a/arch/x86/include/asm/nmi.h
+++ b/arch/x86/include/asm/nmi.h
@@ -75,4 +75,11 @@ void enable_lapic_nmi_watchdog(void);
 void stop_nmi(void);
 void restart_nmi(void);
 
+#ifdef CONFIG_APIC_NMI_DISABLING
+extern int proc_io_apic_toggle_nmi(ctl_table *table, int write,
+			void __user *buffer, size_t *lenp,
+			loff_t *ppos);
+extern int io_apic_enable_nmi;
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 #endif /* _ASM_X86_NMI_H */
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index 00187f1..db8f50b 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -282,6 +282,8 @@ u64 native_apic_icr_read(void)
 	return icr1 | ((u64)icr2 << 32);
 }
 
+#ifndef CONFIG_APIC_NMI_DISABLING
+
 /**
  * enable_NMI_through_LVT0 - enable NMI through local vector table 0
  */
@@ -298,6 +300,51 @@ void __cpuinit enable_NMI_through_LVT0(void)
 
 	apic_write(APIC_LVT0, v);
 }
+#else /* CONFIG_APIC_NMI_DISABLING */
+void enable_NMI_through_LVT0(void)
+{
+	unsigned int v;
+
+	/* unmask and set to NMI */
+	v = APIC_DM_NMI;
+
+	/* Level triggered for 82489DX (32bit mode) */
+	if (!lapic_is_integrated())
+		v |= APIC_LVT_LEVEL_TRIGGER;
+
+	apic_write(APIC_LVT0, v);
+}
+
+void apic_disable_nmi_during_operation(void *dummy)
+{
+	u32 old_lvterr_value;
+	unsigned long flags;
+
+	/* prevent errors to be recorded in the ESR */
+	old_lvterr_value = apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value | APIC_LVT_MASKED);
+
+	/* get out of NMI delivery mode and mask interrupt */
+	local_irq_save(flags);
+	apic_read(APIC_LVT0);
+	apic_write(APIC_LVT0, (APIC_DM_FIXED | APIC_LVT_MASKED));
+	local_irq_restore(flags);
+
+	/* revert LVT ERR register */
+	apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value);
+}
+
+void apic_reenable_nmi_during_operation(void *dummy)
+{
+	unsigned long flags;
+	/* re-enable NMI delivery mode */
+	local_irq_save(flags);
+	enable_NMI_through_LVT0();
+	local_irq_restore(flags);
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
 
 #ifdef CONFIG_X86_32
 /**
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 463de9a..5dd6965 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -42,6 +42,7 @@
 #include <linux/bootmem.h>
 #include <linux/dmar.h>
 #include <linux/hpet.h>
+#include <linux/sysctl.h>
 
 #include <asm/idle.h>
 #include <asm/io.h>
@@ -2855,6 +2856,89 @@ static void __init setup_nmi(void)
 	apic_printk(APIC_VERBOSE, " done.\n");
 }
 
+#ifdef CONFIG_APIC_NMI_DISABLING
+
+static int io_apic_nmi_disabled;	/* atomic, internal: current state */
+
+static int io_apic_disable_nmi(void)
+{
+	extern void apic_disable_nmi_during_operation(void *dummy);
+
+	/* lock disabling of NMIs: do not nest */
+	int already_disabled = cmpxchg(&io_apic_nmi_disabled, 0, 1);
+
+	if (already_disabled) {
+		printk(KERN_WARNING "NMIs are already disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Deactivating NMIs ...\n");
+
+	on_each_cpu(apic_disable_nmi_during_operation, NULL, 1);
+
+	printk(KERN_INFO" Done.\n");
+
+	return 0;
+}
+
+static int io_apic_reenable_nmi(void)
+{
+	extern void apic_reenable_nmi_during_operation(void *dummy);
+
+	if (!io_apic_nmi_disabled) {
+		printk(KERN_WARNING "NMIs were not disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Activating NMIs ...\n");
+
+	on_each_cpu(apic_reenable_nmi_during_operation, NULL, 1);
+
+	/* allow disabling later */
+	io_apic_nmi_disabled = 0;
+
+	printk(KERN_INFO " Done.\n");
+
+	return 0;
+}
+
+int io_apic_enable_nmi = 1;	/* set by proc_io_apic_toggle_nmi */
+
+int proc_io_apic_toggle_nmi(ctl_table *table, int write, void __user *buffer,
+				size_t *lenp, loff_t *ppos)
+{
+	static DECLARE_MUTEX(mutex);
+	int error;
+
+	if ((error = down_interruptible(&mutex)) < 0)
+		return error;
+
+	/* this will set/read io_apic_enable_nmi */
+	error = proc_dointvec_minmax(table, write, buffer,
+						lenp, ppos);
+	if (error < 0) {
+		up(&mutex);
+		printk(KERN_WARNING "Could not %s NMIs state in procfs\n",
+				write ? "write" : "read");
+		return error;
+	}
+
+	if (!write) {
+		up(&mutex);
+		return 0;
+	}
+
+	if (io_apic_enable_nmi)
+		error = io_apic_reenable_nmi();
+	else
+		error = io_apic_disable_nmi();
+
+	up(&mutex);
+	return error;
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 /*
  * This looks a bit hackish but it's about the only one way of sending
  * a few INTA cycles to 8259As and any associated glue logic.  ICR does
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index f66014c..81ddcc4 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -153,6 +153,7 @@ enum
 	KERN_MAX_LOCK_DEPTH=74, /* int: rtmutex's maximum lock depth */
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
+	KERN_NMI_TOGGLE=77, /* int: NMI on/off */
 };
 
 
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 8686b0f..7da9be8 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -698,6 +698,17 @@ static struct ctl_table kern_table[] = {
 		.proc_handler   = proc_nmi_enabled,
 	},
 #endif
+#ifdef CONFIG_APIC_NMI_DISABLING
+	{
+		.procname	= "nmi_enabled",
+		.data		= &io_apic_enable_nmi,
+		.maxlen		= sizeof(int),
+		.mode		= 0600,
+		.proc_handler	= proc_io_apic_toggle_nmi,
+		.extra1		= &zero,
+		.extra2		= &one,
+	},
+#endif
 #if defined(CONFIG_X86)
 	{
 		.procname	= "panic_on_unrecovered_nmi",
diff --git a/kernel/sysctl_binary.c b/kernel/sysctl_binary.c
index 8cd50d8..fd1e51d 100644
--- a/kernel/sysctl_binary.c
+++ b/kernel/sysctl_binary.c
@@ -136,6 +136,7 @@ static const struct bin_table bin_kern_table[] = {
 	{ CTL_INT,	KERN_MAX_LOCK_DEPTH,		"max_lock_depth" },
 	{ CTL_INT,	KERN_NMI_WATCHDOG,		"nmi_watchdog" },
 	{ CTL_INT,	KERN_PANIC_ON_NMI,		"panic_on_unrecovered_nmi" },
+	{ CTL_INT,	KERN_NMI_TOGGLE,		"nmi_enabled" },
 	{}
 };
 
-- 
1.6.5.2

