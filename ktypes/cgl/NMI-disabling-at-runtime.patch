From 7cf84afeaa4c185a14a64af4d77df97c131843f5 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Wed, 3 Dec 2008 17:16:49 -0500
Subject: [PATCH] NMI disabling at runtime

Add interface to disable NMI interrupt from user-space at runtime.

The disabling of NMI is done by reverting the line on which NMIs
come in on the local APIC to a regular interrupt line, and then
masking it. Since this is not normal operating behaviour, errors
must be masked to prevent them from being recorded by the kernel.

The functionality is provided for both 32-bit and 64-bit kernels.

The interface is provided via the /proc/sys/kernel/nmi_enabled
entry. Writing a 0 to it disables NMI interrupts, writing a 1
re-enables them.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/x86/Kconfig             |    9 ++++
 arch/x86/kernel/apic_32.c    |   45 +++++++++++++++++++++
 arch/x86/kernel/apic_64.c    |   46 ++++++++++++++++++++++
 arch/x86/kernel/io_apic_32.c |   87 ++++++++++++++++++++++++++++++++++++++++++
 arch/x86/kernel/io_apic_64.c |   87 ++++++++++++++++++++++++++++++++++++++++++
 include/linux/sysctl.h       |    1 +
 kernel/sysctl.c              |   19 +++++++++
 7 files changed, 294 insertions(+), 0 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 3036817..d0a7075 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1840,6 +1840,15 @@ config SYSVIPC_COMPAT
 
 endmenu
 
+config APIC_NMI_DISABLING
+	bool "Disabling of NMI during system operation"
+	default n
+	help
+	  Allows disabling the NMI interrupts during system operation through
+	  procfs entry /proc/sys/kernel/nmi_enabled. Set it to 0 to disable
+	  NMIs and 1 to re-enable them. The state can be obtained by reading
+	  the file.
+
 
 source "net/Kconfig"
 
diff --git a/arch/x86/kernel/apic_32.c b/arch/x86/kernel/apic_32.c
index 1b8cc33..92eda89 100644
--- a/arch/x86/kernel/apic_32.c
+++ b/arch/x86/kernel/apic_32.c
@@ -173,6 +173,8 @@ u32 safe_apic_wait_icr_idle(void)
 /**
  * enable_NMI_through_LVT0 - enable NMI through local vector table 0
  */
+#ifndef CONFIG_APIC_NMI_DISABLING
+
 void __cpuinit enable_NMI_through_LVT0(void)
 {
 	unsigned int v = APIC_DM_NMI;
@@ -183,6 +185,49 @@ void __cpuinit enable_NMI_through_LVT0(void)
 	apic_write(APIC_LVT0, v);
 }
 
+#else	/* CONFIG_APIC_NMI_DISABLING */
+
+void enable_NMI_through_LVT0(void)
+{
+	unsigned int v = APIC_DM_NMI;
+
+	/* Level triggered for 82489DX */
+	if (!lapic_is_integrated())
+		v |= APIC_LVT_LEVEL_TRIGGER;
+	apic_write(APIC_LVT0, v);
+}
+
+void apic_disable_nmi_during_operation(void * dummy)
+{
+	u32 old_lvterr_value;
+	unsigned long flags;
+
+	/* prevent errors to be recorded in the ESR */
+	old_lvterr_value = apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value | APIC_LVT_MASKED);
+
+	/* get out of NMI delivery mode and mask interrupt */
+	local_irq_save(flags);
+	apic_read(APIC_LVT0);
+	apic_write(APIC_LVT0, (APIC_DM_FIXED | APIC_LVT_MASKED));
+	local_irq_restore(flags);
+
+	/* revert LVT ERR register */
+	apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value);
+}
+
+void apic_reenable_nmi_during_operation(void * dummy)
+{
+	unsigned long flags;
+	/* re-enable NMI delivery mode */
+	local_irq_save(flags);
+	enable_NMI_through_LVT0();
+	local_irq_restore(flags);
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 /**
  * get_physical_broadcast - Get number of physical broadcast IDs
  */
diff --git a/arch/x86/kernel/apic_64.c b/arch/x86/kernel/apic_64.c
index e496483..0d9663c 100644
--- a/arch/x86/kernel/apic_64.c
+++ b/arch/x86/kernel/apic_64.c
@@ -144,6 +144,8 @@ u32 safe_apic_wait_icr_idle(void)
 /**
  * enable_NMI_through_LVT0 - enable NMI through local vector table 0
  */
+#ifndef CONFIG_APIC_NMI_DISABLING
+
 void __cpuinit enable_NMI_through_LVT0(void)
 {
 	unsigned int v;
@@ -153,6 +155,50 @@ void __cpuinit enable_NMI_through_LVT0(void)
 	apic_write(APIC_LVT0, v);
 }
 
+#else	/* CONFIG_APIC_NMI_DISABLING */
+
+void enable_NMI_through_LVT0(void)
+{
+	unsigned int v;
+
+	/* unmask and set to NMI */
+	v = APIC_DM_NMI;
+	apic_write(APIC_LVT0, v);
+}
+
+void apic_disable_nmi_during_operation(void * dummy)
+{
+	u32 old_lvterr_value;
+	unsigned long flags;
+
+	/* prevent errors to be recorded in the ESR */
+	old_lvterr_value = apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value | APIC_LVT_MASKED);
+
+	/* get out of NMI delivery mode and mask interrupt:
+	 * we are only called from process context, ISR is not
+	 * running while we execute this */
+	local_irq_save(flags);
+	apic_read(APIC_LVT0);
+	apic_write(APIC_LVT0, (APIC_DM_FIXED | APIC_LVT_MASKED));
+	local_irq_restore(flags);
+
+	/* revert LVT ERR register */
+	apic_read(APIC_LVTERR);
+	apic_write(APIC_LVTERR, old_lvterr_value);
+}
+
+void apic_reenable_nmi_during_operation (void * dummy)
+{
+	unsigned long flags;
+	/* re-enable NMI delivery mode */
+	local_irq_save(flags);
+	enable_NMI_through_LVT0();
+	local_irq_restore(flags);
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 /**
  * lapic_get_maxlvt - get the maximum number of local vector table entries
  */
diff --git a/arch/x86/kernel/io_apic_32.c b/arch/x86/kernel/io_apic_32.c
index 67fe4e9..7b84777 100644
--- a/arch/x86/kernel/io_apic_32.c
+++ b/arch/x86/kernel/io_apic_32.c
@@ -37,6 +37,7 @@
 #include <linux/freezer.h>
 #include <linux/kthread.h>
 #include <linux/jiffies.h>	/* time_after() */
+#include <linux/sysctl.h>
 
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -2105,6 +2106,92 @@ static void __init setup_nmi(void)
 	apic_printk(APIC_VERBOSE, " done.\n");
 }
 
+#ifdef CONFIG_APIC_NMI_DISABLING
+
+static int io_apic_nmi_disabled = 0;	/* atomic, internal: current state */
+
+static int io_apic_disable_nmi (void)
+{
+	extern void apic_disable_nmi_during_operation (void * dummy);
+
+	/* lock disabling of NMIs: do not nest */
+	int already_disabled = cmpxchg (&io_apic_nmi_disabled, 0, 1);
+
+	if (already_disabled) {
+		printk (KERN_WARNING "NMIs are already disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Deactivating NMIs ... \n");
+
+	on_each_cpu(apic_disable_nmi_during_operation, NULL, 1);
+
+	printk(KERN_INFO " Done.\n");
+
+	return 0;
+}
+
+static int io_apic_reenable_nmi (void)
+{
+	extern void apic_reenable_nmi_during_operation (void * dummy);
+
+	if (!io_apic_nmi_disabled) {
+		printk (KERN_WARNING "NMIs were not disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Activating NMIs ...\n");
+
+	on_each_cpu(apic_reenable_nmi_during_operation, NULL, 1);
+
+	/* allow disabling later */
+	io_apic_nmi_disabled = 0;
+
+	printk(KERN_INFO " Done.\n");
+
+	return 0;
+}
+
+int io_apic_enable_nmi = 1;	/* set by proc_io_apic_toggle_nmi */
+
+int proc_io_apic_toggle_nmi (ctl_table *table, int write, struct file *filp,
+				void __user *buffer, size_t *lenp,
+				loff_t *ppos)
+{
+	static DECLARE_MUTEX(mutex);
+	int error;
+
+	if((error = down_interruptible (&mutex)) < 0) {
+		return error;
+	}
+
+	/* this will set/read io_apic_enable_nmi */
+	error = proc_dointvec_minmax (table, write, filp, buffer,
+						lenp, ppos);
+	if (error < 0) {
+		up (&mutex);
+		printk (KERN_WARNING "Could not %s NMIs state in procfs\n",
+				write ? "write" : "read");
+		return error;
+	}
+
+	if (!write) {
+		up (&mutex);
+		return 0;
+	}
+
+	if (io_apic_enable_nmi) {
+		error = io_apic_reenable_nmi ();
+	} else {
+		error = io_apic_disable_nmi ();
+	}
+
+	up (&mutex);
+	return error;
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 /*
  * This looks a bit hackish but it's about the only one way of sending
  * a few INTA cycles to 8259As and any associated glue logic.  ICR does
diff --git a/arch/x86/kernel/io_apic_64.c b/arch/x86/kernel/io_apic_64.c
index 7e6e780..4e834dd 100644
--- a/arch/x86/kernel/io_apic_64.c
+++ b/arch/x86/kernel/io_apic_64.c
@@ -37,6 +37,7 @@
 #include <acpi/acpi_bus.h>
 #endif
 #include <linux/bootmem.h>
+#include <linux/sysctl.h>
 
 #include <asm/idle.h>
 #include <asm/io.h>
@@ -1648,6 +1649,92 @@ static void __init setup_nmi(void)
 	printk(" done.\n");
 }
 
+#ifdef CONFIG_APIC_NMI_DISABLING
+
+static int io_apic_nmi_disabled = 0;	/* atomic, internal: current state */
+
+static int io_apic_disable_nmi (void)
+{
+	extern void apic_disable_nmi_during_operation (void * dummy);
+
+	/* lock disabling of NMIs: do not nest */
+	int already_disabled = cmpxchg (&io_apic_nmi_disabled, 0, 1);
+
+	if (already_disabled) {
+		printk (KERN_WARNING "NMIs are already disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Deactivating NMIs ... \n");
+
+	on_each_cpu(apic_disable_nmi_during_operation, NULL, 1);
+
+	printk(KERN_INFO " Done.\n");
+
+	return 0;
+}
+
+static int io_apic_reenable_nmi (void)
+{
+	extern void apic_reenable_nmi_during_operation (void * dummy);
+
+	if (!io_apic_nmi_disabled) {
+		printk (KERN_WARNING "NMIs were not disabled\n");
+		return -EAGAIN;
+	}
+
+	printk(KERN_INFO "Activating NMIs ...\n");
+
+	on_each_cpu(apic_reenable_nmi_during_operation, NULL, 1);
+
+	/* allow disabling later */
+	io_apic_nmi_disabled = 0;
+
+	printk(KERN_INFO " Done.\n");
+
+	return 0;
+}
+
+int io_apic_enable_nmi = 1;	/* set by proc_io_apic_toggle_nmi */
+
+int proc_io_apic_toggle_nmi (ctl_table *table, int write, struct file *filp,
+				void __user *buffer, size_t *lenp,
+				loff_t *ppos)
+{
+	static DECLARE_MUTEX(mutex);
+	int error;
+
+	if((error = down_interruptible (&mutex)) < 0) {
+		return error;
+	}
+
+	/* this will set/read io_apic_enable_nmi */
+	error = proc_dointvec_minmax (table, write, filp, buffer,
+						lenp, ppos);
+	if (error < 0) {
+		up (&mutex);
+		printk (KERN_WARNING "Could not %s NMIs state in procfs\n",
+				write ? "write" : "read");
+		return error;
+	}
+
+	if (!write) {
+		up (&mutex);
+		return 0;
+	}
+
+	if (io_apic_enable_nmi) {
+		error = io_apic_reenable_nmi ();
+	} else {
+		error = io_apic_disable_nmi ();
+	}
+
+	up (&mutex);
+	return error;
+}
+
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 /*
  * This looks a bit hackish but it's about the only one way of sending
  * a few INTA cycles to 8259As and any associated glue logic.  ICR does
diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h
index af621f4..1f30a7b 100644
--- a/include/linux/sysctl.h
+++ b/include/linux/sysctl.h
@@ -165,6 +165,7 @@ enum
 	KERN_NMI_WATCHDOG=75, /* int: enable/disable nmi watchdog */
 	KERN_PANIC_ON_NMI=76, /* int: whether we will panic on an unrecovered */
 	KERN_DISABLE_HISTORY_BUFFER=77, /* int: disable the logging to exception and scheduler history buffers */
+	KERN_NMI_TOGGLE=78,	/* NMI on/off */
 
 #ifdef CONFIG_GRKERNSEC
 	KERN_GRSECURITY=98,	/* grsecurity */
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 94ea76f..fe44f09 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -125,6 +125,13 @@ extern char modprobe_path[];
 extern int sg_big_buff;
 #endif
 
+#ifdef CONFIG_APIC_NMI_DISABLING
+extern int proc_io_apic_toggle_nmi (ctl_table *, int, struct file *,
+                        		void __user *, size_t *, loff_t *);
+extern int io_apic_enable_nmi;
+static int nmi_flag_one = 1;
+#endif /* CONFIG_APIC_NMI_DISABLING */
+
 #ifdef __sparc__
 extern char reboot_command [];
 extern int stop_a_enabled;
@@ -902,6 +909,18 @@ static struct ctl_table kern_table[] = {
 		.child		= pax_table,
 	},
 #endif
+#ifdef CONFIG_APIC_NMI_DISABLING
+	{
+		.ctl_name	= KERN_NMI_TOGGLE,
+		.procname	= "nmi_enabled",
+		.mode		= 0600,
+		.data		= &io_apic_enable_nmi,
+		.maxlen		= sizeof (int),
+		.proc_handler	= &proc_io_apic_toggle_nmi,
+		.extra1		= &zero,
+		.extra2		= &nmi_flag_one,
+	},
+#endif /* CONFIG_APIC_NMI_DISABLING */
 
 /*
  * NOTE: do not add new entries to this table unless you have read
-- 
1.6.0.2.GIT

