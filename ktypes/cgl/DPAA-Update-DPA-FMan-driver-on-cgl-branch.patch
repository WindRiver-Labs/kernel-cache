From b5a3c29b8cd21872b057dd418ba6202b38c10ee9 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 22 Feb 2011 16:59:27 +0800
Subject: [PATCH 1/3] DPAA: Update DPA/FMan driver on cgl branch

Patch taken from FSL vendor SDK 2.2

Update FMan low level driver/API.
Update Freescale DPA(data-path) ethernet driver.

Add FMAN processor kernel option to support different board.
Change dpa.c(h) to dpaa_eth.c(h)
Remove the ioctls files.
Add Fman operation files: m_manip.c(h).
Modify code style.
Add more asserations and exceptions code o perfect code.
Add process branch for 10G Ethernet operation

integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |   16 +++++++++-------
 drivers/net/dpa/dpaa_eth.c                         |   16 +++++++++-------
 2 files changed, 18 insertions(+), 14 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 6184dc7..d0ec9d7 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -1047,18 +1047,18 @@ static t_Error QmEnqueueCB (t_Handle h_Arg, void *p_Fd)
 
     ASSERT_COND(p_LnxWrpFmDev);
 
-   spin_lock_irqsave(&lock, flags);
-   hcFrmRcv++;
-   spin_unlock_irqrestore(&lock, flags);
+    spin_lock_irqsave(&lock, flags);
+    hcFrmRcv++;
+    spin_unlock_irqrestore(&lock, flags);
 //MemDisp((uint8_t*)p_Fd,sizeof(t_DpaaFD));
     _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
     if (_errno)
         RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
 
-   while (hcFrmRcv && --timeout)
+    while (hcFrmRcv && --timeout)
     {
-       udelay(1);
-       cpu_relax();
+        udelay(1);
+        cpu_relax();
     }
     BUG_ON(!timeout);
 
@@ -1323,6 +1323,7 @@ static const struct qe_firmware *FindFmanMicrocode(void)
 	    else
 		    REPORT_ERROR(WARNING, E_NOT_FOUND, ("firmware node is incomplete"));
     }
+
 #ifdef	CONFIG_PPC85xx_VT_MODE
 	P4080_UCPatch = &p4080_fman_firmware;
 #else
@@ -1335,6 +1336,7 @@ static const struct qe_firmware *FindFmanMicrocode(void)
         return NULL;
     }
 #endif
+
     /* Make sure it really is a QE Firmware blob */
     hdr = &P4080_UCPatch->header;
     if (!hdr ||
@@ -1349,7 +1351,7 @@ static const struct qe_firmware *FindFmanMicrocode(void)
      */
     P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
 #ifndef	CONFIG_PPC85xx_VT_MODE
-    iounmap((void *)P4080_UCPatch);
+    iounmap(P4080_UCPatch);
     P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
 #endif
     if (!P4080_UCPatch) {
diff --git a/drivers/net/dpa/dpaa_eth.c b/drivers/net/dpa/dpaa_eth.c
index eb3c934..3badc74 100644
--- a/drivers/net/dpa/dpaa_eth.c
+++ b/drivers/net/dpa/dpaa_eth.c
@@ -53,6 +53,7 @@
 #ifdef CONFIG_PPC85xx_VT_MODE
 #include <vbi/vbi.h>
 #endif
+
 #include <linux/fsl_bman.h>
 
 #include "fsl_fman.h"
@@ -113,16 +114,16 @@ static const char rtx[][3] = {
 	[TX] = "TX"
 };
 
-#ifdef CONFIG_PPC85xx_VT_MODE
+#ifdef	CONFIG_PPC85xx_VT_MODE
 static u64 guest_dma_offset;
 
-#define dpa_bus_to_virt(addr)  \
-       __va(addr - guest_dma_offset)
+#define dpa_bus_to_virt(addr) 	\
+	__va(addr - guest_dma_offset)
 #else
-#define dpa_bus_to_virt(addr)   \
-       bus_to_virt(addr)
+#define	dpa_bus_to_virt(addr)	\
+	bus_to_virt(addr)
 #endif
- 
+
 static const char dpa_oh_compatibles[][24] __devinitconst = {
 	/* The dpa-ethernet node owns the OH port and must initialize it */
 	[OH_INIT] = "fsl,fman-port-oh",
@@ -2826,9 +2827,10 @@ static int __init __cold dpa_load(void)
 		goto _return;
 	}
 #endif
+
 #ifdef	CONFIG_PPC85xx_VT_MODE
 	vbi_get_guest_dma_addr((void *)virt_to_phys((void *)PAGE_OFFSET),
-		&guest_dma_offset);
+				&guest_dma_offset);
 #endif
 	_errno = of_register_platform_driver(&dpa_driver);
 	if (unlikely(_errno < 0)) {
-- 
1.6.5.2

