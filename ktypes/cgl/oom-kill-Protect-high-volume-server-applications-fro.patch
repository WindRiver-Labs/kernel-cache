From d64197195273fb80d85a64f3b6b1a472ce02fd10 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Mon, 12 Apr 2010 19:42:19 -0700
Subject: [PATCH] oom-kill: Protect high-volume server applications from being killed

Some classes of server applications in carrier space necessarily fork
many short-lived children (eg. call processing applications).  In an OOM
condition the parent process can be identified as an attractive kill
candidate even though the application is functioning normally and are
not responsible for the original OOM condition.  This change is
necessary on systems where normal operations are close to resource
limits and the OOM protection feature is enabled, where it is more
likely that there will be unkillable processes that would be the best
first choice for OOM killing.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: Joe MacDonald <Joe.MacDonald@windriver.com>
Signed-off-by: Rob Woolley <rob.woolley@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 init/Kconfig  |   15 +++++++++++++++
 mm/oom_kill.c |    8 ++++++++
 2 files changed, 23 insertions(+), 0 deletions(-)

diff --git a/init/Kconfig b/init/Kconfig
index fc16d2e..19f6871 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1163,6 +1163,21 @@ config NOTIFY_SETTIME
 
 	  This is exposed to userspace via /proc/notify_settime_signal
 
+config OOM_IGNORE_CHILD
+	bool "OOM Ignore Child VMSize"
+	default n
+	help
+	  When enabled, the OOM Killer no longer takes the virtual
+	  memory size of child processes into account when calculating
+	  badness.
+
+	  This helps protect high-volume server applications from being
+	  killed.  These applications typically fork many short-lived
+	  children.  In an OOM condition the parent process can be
+	  identified as an attractive kill candidate even though
+	  the application is functioning normally and is not
+	  responsible for the original OOM condition.
+
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index b68e802..318d0f4 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -75,7 +75,9 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 {
 	unsigned long points, cpu_time, run_time;
 	struct mm_struct *mm;
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	struct task_struct *child;
+#endif
 	int oom_adj = p->signal->oom_adj;
 	struct task_cputime task_time;
 	unsigned long utime;
@@ -107,6 +109,7 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 	if (p->flags & PF_OOM_ORIGIN)
 		return ULONG_MAX;
 
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	/*
 	 * Processes which fork a lot of child processes are likely
 	 * a good choice. We add half the vmsize of the children if they
@@ -121,6 +124,7 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 			points += child->mm->total_vm/2 + 1;
 		task_unlock(child);
 	}
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 
 	/*
 	 * CPU time is in tens of seconds and run time is in thousands
@@ -439,7 +443,9 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 			    unsigned long points, struct mem_cgroup *mem,
 			    const char *message)
 {
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	struct task_struct *c;
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 
 	if (printk_ratelimit())
 		dump_header(p, gfp_mask, order, mem);
@@ -453,6 +459,7 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		return 0;
 	}
 
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	printk(KERN_ERR "%s: kill process %d (%s) score %li or a child\n",
 					message, task_pid_nr(p), p->comm, points);
 
@@ -465,6 +472,7 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		if (!oom_kill_task(c))
 			return 0;
 	}
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 	return oom_kill_task(p);
 }
 
-- 
1.6.5.2

