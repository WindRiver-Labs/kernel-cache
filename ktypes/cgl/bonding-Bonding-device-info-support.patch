From 3d4a54eb96ebe39ece0e9875e619f4b6eaf3c088 Mon Sep 17 00:00:00 2001
From: Yong Zhang <yong.zhang@windriver.com>
Date: Fri, 19 Mar 2010 00:29:00 -0700
Subject: [PATCH 3/3] bonding: Bonding device info support

This provides the physical device the packet came in from
for a bonded ethernet device. (as ancillary data)

Signed-off-by: Liming Wang <liming.wang@windriver.com>
Integrated-by: Yong Zhang <yong.zhang@windriver.com>
---
 drivers/net/Kconfig    |    7 +++++++
 include/linux/skbuff.h |    4 ++++
 net/8021q/vlan_core.c  |    3 +++
 net/core/dev.c         |    6 +++++-
 net/packet/af_packet.c |   11 +++++++++++
 5 files changed, 30 insertions(+), 1 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 0ba5b8e..644661e 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -75,6 +75,13 @@ config BONDING
 	  To compile this driver as a module, choose M here: the module
 	  will be called bonding.
 
+config BONDING_DEVINFO
+	bool "Bonding driver device info support"
+	depends on BONDING
+	---help---
+	  This provides the physical device the packet came in from
+	  for a bonded ethernet device. (as ancillary data)
+
 config MACVLAN
 	tristate "MAC-VLAN support (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 03f816a..761c59b 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -320,6 +320,10 @@ struct sk_buff {
 	struct sock		*sk;
 	struct net_device	*dev;
 
+#ifdef CONFIG_BONDING_DEVINFO
+	struct net_device	*real_dev;
+#endif
+
 	/*
 	 * This is the control buffer. It is free to use for every
 	 * layer. Please put your private variables there. If you
diff --git a/net/8021q/vlan_core.c b/net/8021q/vlan_core.c
index c584a0a..415d891 100644
--- a/net/8021q/vlan_core.c
+++ b/net/8021q/vlan_core.c
@@ -16,6 +16,9 @@ int __vlan_hwaccel_rx(struct sk_buff *skb, struct vlan_group *grp,
 
 	skb->skb_iif = skb->dev->ifindex;
 	__vlan_hwaccel_put_tag(skb, vlan_tci);
+#ifdef CONFIG_BONDING_DEVINFO
+	skb->real_dev = skb->dev;
+#endif
 	skb->dev = vlan_group_get_device(grp, vlan_tci & VLAN_VID_MASK);
 
 	if (!skb->dev)
diff --git a/net/core/dev.c b/net/core/dev.c
index 59d4394..4b907bd 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -2508,8 +2508,12 @@ int netif_receive_skb(struct sk_buff *skb)
 	if (master) {
 		if (skb_bond_should_drop(skb, master))
 			null_or_orig = orig_dev; /* deliver only exact match */
-		else
+		else {
+#ifdef CONFIG_BONDING_DEVINFO
+			skb->real_dev = skb->dev;
+#endif
 			skb->dev = master;
+		}
 	}
 
 	__get_cpu_var(netdev_rx_stat).total++;
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 1612d41..c4fa2db 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -1499,6 +1499,9 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
 	int copied, err;
 	struct sockaddr_ll *sll;
 	int vnet_hdr_len = 0;
+#ifdef CONFIG_BONDING_DEVINFO
+	int index = 0;
+#endif
 
 	err = -EINVAL;
 	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
@@ -1589,6 +1589,14 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
+#ifdef CONFIG_BONDING_DEVINFO
+	if (msg->msg_controllen == 16 && msg->msg_control != NULL &&
+	    ((struct cmsghdr *)msg->msg_control)->cmsg_type == IP_PKTINFO) {
+		if (skb->real_dev)
+			index = skb->real_dev->ifindex;
+		put_cmsg(msg, SOL_SOCKET, IP_PKTINFO, sizeof(int), &index);
+	}
+#endif
 	if (msg->msg_name) {
 		/* If the address length field is there to be filled
 		 * in, we fill it in now.
-- 
1.6.5.2

