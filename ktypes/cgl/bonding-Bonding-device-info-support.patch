From 99562fb063ba7089e3f5cd58790ccc63221a51d5 Mon Sep 17 00:00:00 2001
From: Jianchuan Wang <jianchuan.wang@windriver.com>
Date: Tue, 23 Dec 2014 16:39:47 +0800
Subject: [PATCH 4/7] bonding: Bonding device info support

This provides the physical device the packet came in from
for a bonded ethernet device. (as ancillary data)

Signed-off-by: Liming Wang <liming.wang@windriver.com>
Signed-off-by: Jianchuan Wang <jianchuan.wang@windriver.com>
---
 drivers/net/Kconfig    |    8 ++++++++
 include/linux/skbuff.h |    4 ++++
 net/8021q/vlan_core.c  |    4 ++++
 net/core/dev.c         |    5 +++++
 net/packet/af_packet.c |   12 ++++++++++++
 5 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 494b888..263bd56 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -55,6 +55,14 @@ config BONDING
 	  To compile this driver as a module, choose M here: the module
 	  will be called bonding.
 
+config BONDING_DEVINFO
+	default n
+	bool "Bonding driver device info support"
+	depends on BONDING
+	---help---
+	  This provides the physical device the packet came in from
+	  for a bonded ethernet device. (as ancillary data)
+
 config DUMMY
 	tristate "Dummy net driver support"
 	---help---
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 25d8f34..b62b920 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -434,6 +434,10 @@ struct sk_buff {
 	struct sock		*sk;
 	struct net_device	*dev;
 
+#ifdef CONFIG_BONDING_DEVINFO
+	struct net_device   *real_dev;
+#endif
+
 	/*
 	 * This is the control buffer. It is free to use for every
 	 * layer. Please put your private variables there. If you
diff --git a/net/8021q/vlan_core.c b/net/8021q/vlan_core.c
index 5d56e05..6e16095 100644
--- a/net/8021q/vlan_core.c
+++ b/net/8021q/vlan_core.c
@@ -21,6 +21,10 @@ bool vlan_do_receive(struct sk_buff **skbp)
 	if (unlikely(!skb))
 		return false;
 
+#ifdef CONFIG_BONDING_DEVINFO
+	skb->real_dev = skb->dev;
+#endif
+
 	skb->dev = vlan_dev;
 	if (skb->pkt_type == PACKET_OTHERHOST) {
 		/* Our lower layer thinks this is not local, let's make sure.
diff --git a/net/core/dev.c b/net/core/dev.c
index 3ed11a5..d7eed29 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3633,6 +3633,11 @@ ncls:
 	/* deliver only exact match when indicated */
 	null_or_dev = deliver_exact ? skb->dev : NULL;
 
+#ifdef CONFIG_BONDING_DEVINFO
+	if (!null_or_dev)
+		skb->real_dev = skb->dev;
+#endif
+
 	type = skb->protocol;
 	list_for_each_entry_rcu(ptype,
 			&ptype_base[ntohs(type) & PTYPE_HASH_MASK], list) {
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 48b1817..c217e22 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -2861,6 +2861,9 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
 	struct sk_buff *skb;
 	int copied, err;
 	int vnet_hdr_len = 0;
+#ifdef CONFIG_BONDING_DEVINFO
+	int index = 0;
+#endif
 
 	err = -EINVAL;
 	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT|MSG_ERRQUEUE))
@@ -2959,6 +2962,15 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,
 
 	sock_recv_ts_and_drops(msg, sk, skb);
 
+#ifdef CONFIG_BONDING_DEVINFO
+	if (msg->msg_controllen == 16 && msg->msg_control != NULL &&
+	  ((struct cmsghdr *)msg->msg_control)->cmsg_type == IP_PKTINFO) {
+		if (skb->real_dev)
+			index = skb->real_dev->ifindex;
+		put_cmsg(msg, SOL_SOCKET, IP_PKTINFO, sizeof(int), &index);
+	}
+#endif
+
 	if (msg->msg_name) {
 		/* If the address length field is there to be filled
 		 * in, we fill it in now.
-- 
1.7.5.4

