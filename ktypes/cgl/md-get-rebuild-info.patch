From af4c7627c1aa1593a40479e7f606b333fc80cbac Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Wed, 3 Sep 2008 13:34:59 +0800
Subject: [PATCH] md get rebuild info

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: MacDonald, Joe <Joe.MacDonald@windriver.com>
---
 drivers/md/md.c           |   57 +++++++++++++++++++++++++++++++++++++++++++++
 include/linux/raid/md_u.h |   16 ++++++++++++
 2 files changed, 73 insertions(+), 0 deletions(-)

diff --git a/drivers/md/md.c b/drivers/md/md.c
index c7aae66..52d65c2 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -4183,6 +4183,59 @@ out:
 	return err;
 }
 
+static int get_array_rebuild_info(mddev_t * mddev, void __user * arg)
+{
+	mdu_array_rebuild_info_t info;
+	unsigned long  dt, db;
+
+	memset(&info, 0, sizeof(info));
+
+	if (mddev->curr_resync > 2)
+		info.state = MDU_REBUILD_STATE_REBUILDING;
+	else if (mddev->curr_resync > 0)
+		info.state = MDU_REBUILD_STATE_DELAYED; /* delayed sync */
+
+	if(info.state != MDU_REBUILD_STATE_REBUILDING)
+		goto done;
+
+	info.resync_blocks =
+		(mddev->curr_resync - atomic_read(&mddev->recovery_active))/2;
+
+	info.max_blocks = mddev->size;
+
+	/* Should not happen. */
+	if (!info.max_blocks) {
+		MD_BUG();
+		return -ENOENT;
+	}
+
+	/*
+	 * We do not want to overflow, so the order of operands and
+	 * the * 100 / 100 trick are important. We ensure dt is nonzero
+	 * so we never get division by zero.  We add 1 to (db/100) for
+	 * the same reason. Accuracy is not really important, it's only
+	 * an estimate anyway.
+	 *
+	 * dt: time from mark until now
+	 * db: blocks written from mark until now
+	 * rt: remaining time
+	 */
+	dt = ((jiffies - mddev->resync_mark) / HZ);
+	if (!dt)
+		dt++;
+	db = info.resync_blocks - (mddev->resync_mark_cnt/2);
+	info.time_remaining =
+		(dt * ((info.max_blocks-info.resync_blocks) / (db/100+1)))/100;
+
+	info.speed = db/dt;
+
+done:
+	if (copy_to_user(arg, &info, sizeof(info)))
+		return -EFAULT;
+
+	return 0;
+}
+
 static int get_disk_info(mddev_t * mddev, void __user * arg)
 {
 	mdu_disk_info_t info;
@@ -4920,6 +4973,10 @@ static int md_ioctl(struct inode *inode, struct file *file,
 			err = get_bitmap_file(mddev, argp);
 			goto done_unlock;
 
+		case GET_ARRAY_REBUILD_INFO:
+			err = get_array_rebuild_info(mddev, argp);
+			goto done_unlock;
+
 		case GET_DISK_INFO:
 			err = get_disk_info(mddev, argp);
 			goto done_unlock;
diff --git a/include/linux/raid/md_u.h b/include/linux/raid/md_u.h
index 7192035..dce0ff3 100644
--- a/include/linux/raid/md_u.h
+++ b/include/linux/raid/md_u.h
@@ -24,6 +24,7 @@
 #define PRINT_RAID_DEBUG	_IO (MD_MAJOR, 0x13)
 #define RAID_AUTORUN		_IO (MD_MAJOR, 0x14)
 #define GET_BITMAP_FILE		_IOR (MD_MAJOR, 0x15, mdu_bitmap_file_t)
+#define GET_ARRAY_REBUILD_INFO  _IOR (MD_MAJOR, 0x16, mdu_array_rebuild_info_t)
 
 /* configuration */
 #define CLEAR_ARRAY		_IO (MD_MAJOR, 0x20)
@@ -85,6 +86,21 @@ typedef struct mdu_array_info_s {
 
 } mdu_array_info_t;
 
+#define MDU_REBUILD_STATE_NO_REBUILD 0
+#define MDU_REBUILD_STATE_REBUILDING 1
+#define MDU_REBUILD_STATE_DELAYED 2
+typedef struct mdu_array_rebuild_info_s {
+	/*
+	 *  rebuild status of one particular array
+	 */
+	int state;
+	unsigned long resync_blocks;
+	unsigned long max_blocks;
+	unsigned long time_remaining;
+	unsigned long speed;
+
+} mdu_array_rebuild_info_t;
+
 typedef struct mdu_disk_info_s {
 	/*
 	 * configuration/status of one particular disk
-- 
1.5.5.1

