From 63e2b39843d560a166c2ef9cf27629cb4a0d5378 Mon Sep 17 00:00:00 2001
From: Rob Woolley <rob.woolley@windriver.com>
Date: Wed, 21 Jan 2009 08:37:27 -0500
Subject: [PATCH] Protect high-volume server applications from being killed.

Some classes of server applications in carrier space necessarily fork
many short-lived children (eg. call processing applications).  In an OOM
condition the parent process can be identified as an attractive kill
candidate even though the application is functioning normally and are
not responsible for the original OOM condition.  This change is
necessary on systems where normal operations are close to resource
limits and the OOM protection feature is enabled, where it is more
likely that there will be unkillable processes that would be the best
first choice for OOM killing.

Signed-off-by: Yongli he   <yongli.he@windriver.com>
Signed-off-by: Joe MacDonald <Joe.MacDonald@windriver.com>
Signed-off-by: Rob Woolley <rob.woolley@windriver.com>
---
 init/Kconfig  |   15 +++++++++++++++
 mm/oom_kill.c |    8 ++++++++
 2 files changed, 23 insertions(+), 0 deletions(-)

diff --git a/init/Kconfig b/init/Kconfig
index aebe29e..f484e68 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -917,6 +917,21 @@ config IMMEDIATE
 	  each time any specially-marked variable is updated. Should really be
 	  disabled for embedded systems with read-only text.
 
+config OOM_IGNORE_CHILD
+	bool "OOM Ignore Child VMSize"
+	default n
+	help
+	  When enabled, the OOM Killer no longer takes the virtual
+	  memory size of child processes into account when calculating
+	  badness.
+
+	  This helps protect high-volume server applications from being
+	  killed.  These applications typically fork many short-lived
+	  children.  In an OOM condition the parent process can be
+	  identified as an attractive kill candidate even though
+	  the application is functioning normally and is not
+	  responsible for the original OOM condition.
+
 endmenu		# General setup
 
 config HAVE_GENERIC_DMA_COHERENT
diff --git a/mm/oom_kill.c b/mm/oom_kill.c
index 64e5b4b..ab1cd12 100644
--- a/mm/oom_kill.c
+++ b/mm/oom_kill.c
@@ -58,7 +58,9 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 {
 	unsigned long points, cpu_time, run_time, s;
 	struct mm_struct *mm;
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	struct task_struct *child;
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 
 	task_lock(p);
 	mm = p->mm;
@@ -83,6 +85,7 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 	if (p->flags & PF_SWAPOFF)
 		return ULONG_MAX;
 
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	/*
 	 * Processes which fork a lot of child processes are likely
 	 * a good choice. We add half the vmsize of the children if they
@@ -97,6 +100,7 @@ unsigned long badness(struct task_struct *p, unsigned long uptime)
 			points += child->mm->total_vm/2 + 1;
 		task_unlock(child);
 	}
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 
 	/*
 	 * CPU time is in tens of seconds and run time is in thousands
@@ -385,7 +389,9 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 			    unsigned long points, struct mem_cgroup *mem,
 			    const char *message)
 {
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	struct task_struct *c;
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 
 	if (printk_ratelimit()) {
 		printk(KERN_WARNING "%s invoked oom-killer: "
@@ -406,6 +412,7 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		return 0;
 	}
 
+#ifndef CONFIG_OOM_IGNORE_CHILD
 	printk(KERN_ERR "%s: kill process %d (%s) score %li or a child\n",
 					message, task_pid_nr(p), p->comm, points);
 
@@ -416,6 +423,7 @@ static int oom_kill_process(struct task_struct *p, gfp_t gfp_mask, int order,
 		if (!oom_kill_task(c))
 			return 0;
 	}
+#endif /* CONFIG_OOM_IGNORE_CHILD */
 	return oom_kill_task(p);
 }
 
-- 
1.6.0.3

