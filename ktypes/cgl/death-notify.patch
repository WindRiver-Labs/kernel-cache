From dd845d5e619b3631f4e78d95710da39d1314ef6e Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Mon, 28 Jul 2008 15:54:58 +0800
Subject: [PATCH] Notification of death of arbitrary processes

This exposes a new feature which may be called to request
notification when an arbitrary process changes state. The
caller specifies a pid, signal number, and event mask, and
when that pid dies, or is stopped, or anything else that
would normally cause a SIGCHLD, the kernel will send the
specified signal to the caller if the event is in the event
mask originally passed down. The siginfo_t struct will
contain the same information as would be included with SIGCHLD.

 This is exposed to userspace via the prctl() call with the
PR_DO_NOTIFY_TASK_STATE option

Signed-off-by: Liming Wang <liming.wang@windriver.com>
Integrated-by: Yongli he   <yongli.he@windriver.com>
---
 include/linux/init_task.h |    9 +++
 include/linux/prctl.h     |   18 +++++
 include/linux/sched.h     |    4 +
 include/linux/signal.h    |   13 ++++
 init/Kconfig              |   16 +++++
 kernel/Makefile           |    1 +
 kernel/death_notify.c     |  166 +++++++++++++++++++++++++++++++++++++++++++++
 kernel/exit.c             |   32 +++++++++
 kernel/fork.c             |    4 +
 kernel/signal.c           |   33 +++++++++
 kernel/sys.c              |    5 ++
 11 files changed, 301 insertions(+), 0 deletions(-)
 create mode 100644 kernel/death_notify.c

diff --git a/include/linux/init_task.h b/include/linux/init_task.h
index 021d8e7..1078f52 100644
--- a/include/linux/init_task.h
+++ b/include/linux/init_task.h
@@ -67,6 +67,14 @@ extern struct nsproxy init_nsproxy;
 	.signalfd_wqh	= __WAIT_QUEUE_HEAD_INITIALIZER(sighand.signalfd_wqh),	\
 }
 
+#ifdef CONFIG_SIGEXIT
+#define INIT_SIGEXIT(tsk) \
+	.notify		= LIST_HEAD_INIT(tsk.notify),			\
+	.monitor	= LIST_HEAD_INIT(tsk.monitor),
+#else
+#define INIT_SIGEXIT(tsk)
+#endif
+
 extern struct group_info init_groups;
 
 #define INIT_STRUCT_PID {						\
@@ -169,6 +177,7 @@ extern struct group_info init_groups;
 	.journal_info	= NULL,						\
 	.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
 	.fs_excl	= ATOMIC_INIT(0),				\
+	INIT_SIGEXIT(tsk)						\
 	.pi_lock	= __SPIN_LOCK_UNLOCKED(tsk.pi_lock),		\
 	.pids = {							\
 		[PIDTYPE_PID]  = INIT_PID_LINK(PIDTYPE_PID),		\
diff --git a/include/linux/prctl.h b/include/linux/prctl.h
index 5ad7919..6ae515c 100644
--- a/include/linux/prctl.h
+++ b/include/linux/prctl.h
@@ -53,6 +53,24 @@
 #define PR_SET_NAME    15		/* Set process name */
 #define PR_GET_NAME    16		/* Get process name */
 
+#ifdef CONFIG_SIGEXIT
+#define PR_DO_NOTIFY_TASK_STATE 17	/* Set/get notification for task
+					   state changes */
+
+/* This is the data structure for requestion process death
+ * (and other state change) information.  Sig of -1 means
+ * query, sig of 0 means deregistration, positive sig means
+ * that you want to set it.  sig and events are value-result
+ * and will be updated with the previous values on every
+ * successful call.
+ */
+struct task_state_notify_info {
+	int pid;
+	int sig;
+	unsigned int events;
+};
+#endif
+
 /* Get/set process endian */
 #define PR_GET_ENDIAN	19
 #define PR_SET_ENDIAN	20
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 5270d44..88cdabb 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1283,6 +1283,10 @@ struct task_struct {
 	short il_next;
 #endif
 	atomic_t fs_excl;	/* holding fs exclusive resources */
+#ifdef CONFIG_SIGEXIT
+	struct list_head notify;        /* list of processes to notify on death */
+	struct list_head monitor;       /* list of outstanding monitor requests */
+#endif
 	struct rcu_head rcu;
 
 	/*
diff --git a/include/linux/signal.h b/include/linux/signal.h
index 84f997f..81d1f14 100644
--- a/include/linux/signal.h
+++ b/include/linux/signal.h
@@ -26,6 +26,19 @@ struct sigpending {
 	sigset_t signal;
 };
 
+#ifdef CONFIG_SIGEXIT
+struct signotifier {
+	struct task_struct *notify_tsk;
+	struct list_head notify_list;
+	struct list_head monitor_list;
+	int sig;
+	unsigned int events;
+};
+void unlink_status_notifier(struct signotifier *n);
+int do_notify_task_state(unsigned long arg);
+#endif
+
+
 /*
  * Define some primitives to manipulate sigset_t.
  */
diff --git a/init/Kconfig b/init/Kconfig
index b55f1f3..e7435f5 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -766,6 +766,22 @@ config ALWAYS_RESTART
 	bool "Force the system to restart instead of halt or power off"
 	default n
 
+config SIGEXIT
+	bool "Notification of death of arbitrary processes"
+	default y
+	help
+	  When enabled this exposes a new feature which may be called to request
+	  notification when an arbitrary process changes state.  The caller specifies
+	  a pid, signal number, and event mask, and when that pid dies, or is
+	  stopped, or anything else that would normally cause a SIGCHLD, the
+	  kernel will send the specified signal to the caller if the event is in
+	  the event mask originally passed down. The siginfo_t struct will
+	  contain the same information as would be included with SIGCHLD.
+
+	  This is exposed to userspace via the prctl()
+	  call with the PR_DO_NOTIFY_TASK_STATE option
+
+
 config SLUB_DEBUG
 	default y
 	bool "Enable SLUB debugging support" if EMBEDDED
diff --git a/kernel/Makefile b/kernel/Makefile
index 8b7f733..1383b4c 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -90,6 +90,7 @@ obj-$(CONFIG_HAVE_GENERIC_DMA_COHERENT) += dma-coherent.o
 obj-$(CONFIG_FTRACE) += trace/
 obj-$(CONFIG_TRACING) += trace/
 obj-$(CONFIG_SMP) += sched_cpupri.o
+obj-$(CONFIG_SIGEXIT) += death_notify.o
 
 ifneq ($(CONFIG_SCHED_NO_NO_OMIT_FRAME_POINTER),y)
 # According to Alan Modra <alan@linuxcare.com.au>, the -fno-omit-frame-pointer is
diff --git a/kernel/death_notify.c b/kernel/death_notify.c
new file mode 100644
index 0000000..39db72b
--- /dev/null
+++ b/kernel/death_notify.c
@@ -0,0 +1,166 @@
+/* 
+ * kernel/death_notify.c, Process death notification support
+ * 
+ * Copyright (c) 2006-2008 Wind River Systems, Inc. 
+ * 
+ * This program is free software; you can redistribute it and/or modify 
+ * it under the terms of the GNU General Public License version 2 as 
+ * published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, 
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of 
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
+ * See the GNU General Public License for more details. 
+ * 
+ * You should have received a copy of the GNU General Public License 
+ * along with this program; if not, write to the Free Software 
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+ * 
+ */
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/prctl.h>
+#include <asm/uaccess.h>
+
+void handle_already_monitoring(struct signotifier *node,
+       struct task_state_notify_info *args,
+       struct task_state_notify_info *oldargs)
+{
+	/* Store the old values */
+	oldargs->sig = node->sig;
+	oldargs->events = node->events;
+
+	/* We know that args->sig is 0 or a valid signal. */
+	if (args->sig > 0) {
+		/* Update the new values */
+		node->sig = args->sig;
+		node->events = args->events;
+	} else if (!args->sig) {
+		/* args->sig of 0 means to deregister */
+		unlink_status_notifier(node);
+	}
+}
+
+void setup_new_node(struct task_struct *p,
+	struct signotifier *node,
+	struct task_state_notify_info *args)
+{
+	node->notify_tsk = current;
+	node->sig = args->sig;
+	node->events = args->events;
+
+	/* Add this node to the list of notification requests
+	 * for the specified process.
+	 */
+	list_add_tail(&node->notify_list, &p->notify);
+
+	/* Also add this node to the list of monitor requests
+	 * for the current process.
+	 */
+	list_add_tail(&node->monitor_list, &current->monitor);
+}
+
+
+/* Returns 0 if arguments are valid, 1 if they are not. */
+int invalid_args(struct task_state_notify_info *args)
+{
+	int ret = 1;
+
+	if (args->pid <= 0) goto out;
+
+	/* Sig of -1 implies query, sig of 0 implies deregistration.
+	 * Otherwise sig must be positive and within range.
+	 */
+	if ((args->sig < -1) || (args->sig > _NSIG)) goto out;
+
+	/* If positive sig, must have valid events. */
+	if (args->sig > 0) {
+		if (!args->events || (args->events >= (1 << (NSIGCHLD+1)))) goto out;
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+/* If the config is defined, then processes can call this routine
+ * to request notification when the specified task's state changes.
+ * On the death (or other state change) of the specified process,
+ * we will send them the specified signal if the event is listed
+ * in their event bitfield.
+ *
+ * A sig of 0 means that we want to deregister.
+ *
+ * The sig/events fields are value/result.  On success we update them
+ * to reflect what they were before the call.
+ *
+ * Returns error code on error, on success we return 0.
+ */
+int do_notify_task_state(unsigned long arg)
+{
+	int err;
+	struct task_struct *p;
+	struct signotifier *node, *tmp;
+	struct task_state_notify_info args, oldargs;
+
+	if (copy_from_user(&args, (struct task_state_notify_info __user *)arg,
+			sizeof(args)))
+		return -EFAULT;
+	oldargs.pid = args.pid;
+
+	/* Validate the arguments passed in. */
+	err = -EINVAL;
+	if (invalid_args(&args))
+		goto out;
+
+	/* We must hold a write lock on tasklist_lock to add the notification
+	 * later on, and we need some lock on tasklist_lock for
+	 * find_task_by_pid(), so may as well take the write lock now.
+	 * Must use write_lock_irq().
+	 */
+	write_lock_irq(&tasklist_lock);
+
+	err = -ESRCH;
+	p = find_task_by_vpid(args.pid);
+	if (!p) goto unlock_out;
+
+	/* Now we know pid exists, unlikely to fail. */
+	err = 0;
+
+	/* Check if we're already monitoring the specified pid. If so, update
+	 * the monitoring parameters and return the old ones.
+	 */
+	list_for_each_entry(tmp, &p->notify, notify_list) {
+		if (tmp->notify_tsk == current) {
+			handle_already_monitoring(tmp, &args, &oldargs);
+			goto unlock_out;
+		}
+	}
+
+	/* If we get here, we're not currently monitoring the process.  */
+	oldargs.sig = 0;
+	oldargs.events = 0;
+
+	/* If we wanted to set up a new monitor, do it now. If we didn't
+	 * manage to allocate memory for the new node, then we return
+	 * an appropriate error.
+	 */
+	if (args.sig > 0) {
+		node = kmalloc(sizeof(*node), GFP_KERNEL);
+		if (node)
+			setup_new_node(p, node, &args);
+		else
+			err = -ENOMEM;
+	}
+
+unlock_out:
+	write_unlock_irq(&tasklist_lock);
+
+	/* Copy the old values back to caller. */
+	if (copy_to_user((struct task_state_notify_info __user *)arg,
+			&oldargs, sizeof(oldargs)))
+		err = -EFAULT;
+
+out:
+	return err;
+}
diff --git a/kernel/exit.c b/kernel/exit.c
index 38ec406..fd1a8eb 100644
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@ -153,6 +153,35 @@ static void delayed_put_task_struct(struct rcu_head *rhp)
 }
 
 
+#ifdef CONFIG_SIGEXIT
+void unlink_status_notifier(struct signotifier *n)
+{
+	list_del(&n->monitor_list);
+	list_del(&n->notify_list);
+	kfree(n);
+}
+EXPORT_SYMBOL(unlink_status_notifier);
+
+void release_notify_others(struct task_struct * p)
+{
+	struct signotifier *n, *t;
+
+	/* Need to clean up any outstanding requests where we
+	 * wanted to be notified when others died.
+	 */
+	list_for_each_entry_safe(n, t, &p->monitor, monitor_list) {
+		unlink_status_notifier(n);
+	}
+
+	/* Also need to clean up any outstanding requests where others
+	 * wanted to be notified when we died.
+	 */
+	list_for_each_entry_safe(n, t, &p->notify, notify_list) {
+		unlink_status_notifier(n);
+	}
+}
+#endif
+
 void release_task(struct task_struct * p)
 {
 	struct task_struct *leader;
@@ -162,6 +191,9 @@ repeat:
 	atomic_dec(&p->user->processes);
 	proc_flush_task(p);
 	write_lock_irq(&tasklist_lock);
+#ifdef CONFIG_SIGEXIT
+	release_notify_others(p);
+#endif
 	tracehook_finish_release_task(p);
 	__exit_signal(p);
 
diff --git a/kernel/fork.c b/kernel/fork.c
index 7ce2ebe..1e518ef 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1050,6 +1050,10 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 #ifdef CONFIG_DEBUG_MUTEXES
 	p->blocked_on = NULL; /* not blocked yet */
 #endif
+#ifdef CONFIG_SIGEXIT
+	INIT_LIST_HEAD(&p->notify);
+	INIT_LIST_HEAD(&p->monitor);
+#endif
 
 	/* Perform scheduler related setup. Assign this task to a CPU. */
 	sched_fork(p, clone_flags);
diff --git a/kernel/signal.c b/kernel/signal.c
index 954f77d..9a43bcd 100644
--- a/kernel/signal.c
+++ b/kernel/signal.c
@@ -1316,6 +1316,35 @@ ret:
 	return ret;
 }
 
+#ifdef CONFIG_SIGEXIT
+/* Notify those registered for process state updates via do_notify_task_state().
+ * If "del" is nonzero, the process is dying and we want to free
+ * the nodes in the list as we go.
+ *
+ * Note: we only notify processes for events in which they have registered
+ * interest.
+ *
+ * Must be called holding a lock on tasklist_lock.
+ */
+void do_notify_others(struct task_struct *tsk, struct siginfo *info)
+{
+	struct signotifier *node;
+	unsigned int events;
+
+	/* This method of generating the event bit must be
+	 * matched in the userspace library.
+	 */
+	events = 1 << (info->si_code & 0xFF);
+
+	list_for_each_entry(node, &tsk->notify, notify_list) {
+		if (events & node->events) {
+			info->si_signo = node->sig;
+			group_send_sig_info(node->sig, info, node->notify_tsk);
+		}
+	}
+}
+#endif
+
 /*
  * Wake up any threads in the parent blocked in wait* syscalls.
  */
@@ -1410,6 +1439,10 @@ int do_notify_parent(struct task_struct *tsk, int sig)
 	__wake_up_parent(tsk, tsk->parent);
 	spin_unlock_irqrestore(&psig->siglock, flags);
 
+#ifdef CONFIG_SIGEXIT
+	do_notify_others(tsk, &info);
+#endif
+
 	return sig;
 }
 
diff --git a/kernel/sys.c b/kernel/sys.c
index 3751675..f8f1014 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -1733,6 +1733,11 @@ asmlinkage long sys_prctl(int option, unsigned long arg2, unsigned long arg3,
 		case PR_SET_TSC:
 			error = SET_TSC_CTL(arg2);
 			break;
+#ifdef CONFIG_SIGEXIT
+		case PR_DO_NOTIFY_TASK_STATE:
+			error = do_notify_task_state(arg2);
+			break;
+#endif
 		default:
 			error = -EINVAL;
 			break;
-- 
1.5.5.1

