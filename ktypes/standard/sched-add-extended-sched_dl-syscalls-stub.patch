From dc150d4390d786c5f82fe6ac219de3a3b2e17fb4 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Fri, 1 Apr 2011 10:23:47 +0800
Subject: [PATCH 2/2] sched: add extended sched_dl syscalls stub

Add eight syscall and compat stubs.  These are only place holders to
avoid compiling and running errors. Please don't use them without the
EDF's patches:

 - sys_sched_setscheduler_ex
 - sys_sched_setparam_ex
 - sys_sched_getparam_ex
 - sys_sched_wait_interval
 - compat_sys_sched_setscheduler_ex
 - compat_sys_sched_setparam_ex
 - compat_sys_sched_getparam_ex
 - compat_sys_sched_wait_interval

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 include/linux/sched.h    |   51 +++++++++++++++++++++++++++++++
 include/linux/syscalls.h |   17 ++++++++++
 kernel/sched.c           |   75 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 143 insertions(+), 0 deletions(-)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 9bee1c0..cc3156e 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -94,6 +94,57 @@ struct sched_param {
 
 #include <asm/processor.h>
 
+/*
+ * Extended scheduling parameters data structure.
+ *
+ * This is needed because the original struct sched_param can not be
+ * altered without introducing ABI issues with legacy applications
+ * (e.g., in sched_getparam()).
+ *
+ * However, the possibility of specifying more than just a priority for
+ * the tasks may be useful for a wide variety of application fields, e.g.,
+ * multimedia, streaming, automation and control, and many others.
+ *
+ * This variant (sched_param_ex) is meant at describing a so-called
+ * sporadic time-constrained task. In such model a task is specified by:
+ *  - the activation period or minimum instance inter-arrival time;
+ *  - the maximum (or average, depending on the actual scheduling
+ *    discipline) computation time of all instances, a.k.a. runtime;
+ *  - the deadline (relative to the actual activation time) of each
+ *    instance.
+ * Very briefly, a periodic (sporadic) task asks for the execution of
+ * some specific computation --which is typically called an instance--
+ * (at most) every period. Moreover, each instance typically lasts no more
+ * than the runtime and must be completed by time instant t equal to
+ * the instance activation time + the deadline.
+ *
+ * This is reflected by the actual fields of the sched_param_ex structure:
+ *
+ *  @sched_priority:    task's priority (might be still useful)
+ *  @sched_deadline:    representative of the task's deadline
+ *  @sched_runtime:     representative of the task's runtime
+ *  @sched_period:      representative of the task's period
+ *  @sched_flags:       available for specifying some specific
+ *                      task or scheduling behaviour
+ *
+ * Given this task model, there are a multiplicity of scheduling algorithms
+ * and policies, each with its own advantages and drawbacks in having all
+ * the tasks make their timing constraint.
+ *
+ * As of now, the SCHED_DEADLINE policy (sched_dl scheduling class) is the
+ * only user of this new interface. It right now assumes deadlines are
+ * always equal to periods, thus it does not use the sched_period field.
+ * More information about the algorithm are available in the scheduling
+ * class file or in Documentation/.
+ */
+struct sched_param_ex {
+	int sched_priority;
+	struct timespec sched_runtime;
+	struct timespec sched_deadline;
+	struct timespec sched_period;
+	unsigned int sched_flags;
+};
+
 struct exec_domain;
 struct futex_pi_state;
 struct robust_list_head;
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 057929b..355f027 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -37,6 +37,7 @@ struct pollfd;
 struct rlimit;
 struct rusage;
 struct sched_param;
+struct sched_param_ex;
 struct sel_arg_struct;
 struct semaphore;
 struct sembuf;
@@ -344,16 +345,32 @@ asmlinkage long sys_clock_nanosleep(clockid_t which_clock, int flags,
 asmlinkage long sys_nice(int increment);
 asmlinkage long sys_sched_setscheduler(pid_t pid, int policy,
 					struct sched_param __user *param);
+asmlinkage long compat_sys_sched_setscheduler_ex(pid_t pid, int policy,
+			unsigned len, struct sched_param_ex __user *param);
+asmlinkage long compat_sys_sched_setparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param);
+asmlinkage long compat_sys_sched_getparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param);
+asmlinkage long compat_sys_sched_wait_interval(const struct timespec __user *rqtp,
+					struct timespec *rmtp);
+asmlinkage long sys_sched_setscheduler_ex(pid_t pid, int policy, unsigned len,
+					struct sched_param_ex __user *param);
 asmlinkage long sys_sched_setparam(pid_t pid,
 					struct sched_param __user *param);
+asmlinkage long sys_sched_setparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param);
 asmlinkage long sys_sched_getscheduler(pid_t pid);
 asmlinkage long sys_sched_getparam(pid_t pid,
 					struct sched_param __user *param);
+asmlinkage long sys_sched_getparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param);
 asmlinkage long sys_sched_setaffinity(pid_t pid, unsigned int len,
 					unsigned long __user *user_mask_ptr);
 asmlinkage long sys_sched_getaffinity(pid_t pid, unsigned int len,
 					unsigned long __user *user_mask_ptr);
 asmlinkage long sys_sched_yield(void);
+asmlinkage long sys_sched_wait_interval(const struct timespec __user *rqtp,
+					struct timespec *rmtp);
 asmlinkage long sys_sched_get_priority_max(int policy);
 asmlinkage long sys_sched_get_priority_min(int policy);
 asmlinkage long sys_sched_rr_get_interval(pid_t pid,
diff --git a/kernel/sched.c b/kernel/sched.c
index 66df4bd..c00f1ed 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4667,6 +4667,25 @@ SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy,
 }
 
 /**
+ * sys_sched_setscheduler_ex - same as above, but with extended sched_param
+ * @pid: the pid in question.
+ * @policy: new policy (could use extended sched_param).
+ * @len: size of data pointed by param_ex.
+ * @param: structure containg the extended parameters.
+ */
+asmlinkage long compat_sys_sched_setscheduler_ex(pid_t pid, int policy,
+                       unsigned len, struct sched_param_ex __user *param)
+{
+        return -ENOSYS;
+}
+
+SYSCALL_DEFINE4(sched_setscheduler_ex, pid_t, pid, int, policy,
+		unsigned, len, struct sched_param_ex __user *, param_ex)
+{
+	return -ENOSYS;
+}
+
+/**
  * sys_sched_setparam - set/change the RT priority of a thread
  * @pid: the pid in question.
  * @param: structure containing the new RT priority.
@@ -4677,6 +4696,24 @@ SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)
 }
 
 /**
+ * sys_sched_setparam_ex - same as above, but with extended sched_param
+ * @pid: the pid in question.
+ * @len: size of data pointed by param_ex.
+ * @param_ex: structure containing the extended parameters.
+ */
+asmlinkage long compat_sys_sched_setparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param)
+{
+        return -ENOSYS;
+}
+
+SYSCALL_DEFINE3(sched_setparam_ex, pid_t, pid, unsigned, len,
+		struct sched_param_ex __user *, param_ex)
+{
+	return -ENOSYS;
+}
+
+/**
  * sys_sched_getscheduler - get the policy (scheduling class) of a thread
  * @pid: the pid in question.
  */
@@ -4740,6 +4777,24 @@ out_unlock:
 	return retval;
 }
 
+/**
+ * sys_sched_getparam_ex - same as above, but with extended sched_param
+ * @pid: the pid in question.
+ * @len: size of data pointed by param_ex.
+ * @param_ex: structure containing the extended parameters.
+ */
+asmlinkage long compat_sys_sched_getparam_ex(pid_t pid, unsigned len,
+					struct sched_param_ex __user *param)
+{
+        return -ENOSYS;
+}
+
+SYSCALL_DEFINE3(sched_getparam_ex, pid_t, pid, unsigned, len,
+		struct sched_param_ex __user *, param_ex)
+{
+	return -ENOSYS;
+}
+
 long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
 {
 	cpumask_var_t cpus_allowed, new_mask;
@@ -4927,6 +4982,26 @@ SYSCALL_DEFINE0(sched_yield)
 	return 0;
 }
 
+/**
+ * sys_sched_wait_interval - sleep according to the scheduling class rules.
+ *
+ * This function is implemented inside each scheduling class, in case it
+ * wants to provide its tasks a mean of waiting a specific instant in
+ * time, while also honouring some specific rule of itself.
+ */
+asmlinkage long compat_sys_sched_wait_interval(const struct timespec __user *rqtp,
+					struct timespec *rmtp)
+{
+        return -ENOSYS;
+}
+
+SYSCALL_DEFINE2(sched_wait_interval,
+	const struct timespec __user *, rqtp,
+	struct timespec __user *, rmtp)
+{
+	return -ENOSYS;
+}
+
 static inline int should_resched(void)
 {
 	return need_resched() && !(preempt_count() & PREEMPT_ACTIVE);
-- 
1.7.0.4

