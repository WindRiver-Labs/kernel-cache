From 20a981e0351bdd75bfe244a610e996aed390ab1e Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 28 Oct 2010 17:37:10 -0700
Subject: [PATCH] fsldma: error completed_cookie due to undefined sr

The result is not sure to read the sr of DMA controller in
fsl_dma_update_completed_cookie after having been ACKed by
set_sr in fsldma_chan_irq.  For example, a block has been
found by lmbench in 8572ds from 2.6.34-rc1, get_sr will be
called at dma_is_idle in interrupt context as follows:
  821     if (dma_is_idle(chan))
  822             cookie = desc->async_tx.cookie;
  823     else {
  824             cookie = desc->async_tx.cookie - 1;
dma_is_idle maybe return a busy status in 8572ds after sr
register having been acked. And an error cookie will be
assigned to chan->completed_cookie in this case:
  829         chan->completed_cookie = cookie;

Then bw_tcp with 10M will be stuck at the folling do while loop
in tcp_service_net_dma:
  1271    do {
  1272      if (dma_async_memcpy_complete(tp->ucopy.dma_chan,
  1273                                    last_issued, &done,
  1274                                    &used) == DMA_SUCCESS) {
This is due to the error relationship among cookie, last_complete,
and last_used, which comes from fsl_dma_update_completed_cookie
above. So lmbench was blocked.

At the same time, cookie = desc->async_tx.cookie - 1 is not
necessary in the current DMA process mode, so remove it too.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/fsldma.c |   12 +++---------
 1 files changed, 3 insertions(+), 9 deletions(-)

diff --git a/drivers/dma/fsldma.c b/drivers/dma/fsldma.c
index 88f470f..fe61a38 100644
--- a/drivers/dma/fsldma.c
+++ b/drivers/dma/fsldma.c
@@ -818,15 +818,9 @@ static void fsl_dma_update_completed_cookie(struct fsldma_chan *chan)
 
 	/* Get the last descriptor, update the cookie to that */
 	desc = to_fsl_desc(chan->ld_running.prev);
-	if (dma_is_idle(chan))
-		cookie = desc->async_tx.cookie;
-	else {
-		cookie = desc->async_tx.cookie - 1;
-		if (unlikely(cookie < DMA_MIN_COOKIE))
-			cookie = DMA_MAX_COOKIE;
-	}
-
-	chan->completed_cookie = cookie;
+	BUG_ON(desc->async_tx.cookie < 0);
+	if(desc->async_tx.cookie > 0)
+		chan->completed_cookie = desc->async_tx.cookie;
 
 out_unlock:
 	spin_unlock_irqrestore(&chan->desc_lock, flags);
-- 
1.6.5.2

