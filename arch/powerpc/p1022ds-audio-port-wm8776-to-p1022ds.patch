From 6f2d13de6c7da6545ae3e1e4d7ee525986c19702 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 1 Dec 2010 16:12:10 +0800
Subject: [PATCH 04/13] p1022ds: audio: port wm8776 to p1022ds

Add wm8776 codec support for P1022DS platform.

Signed-off-by: Jiang Yutang <b14898@freescale.com>

[Extracted from the P1022DS_20100925-ltib.iso vendor drop.
Use CONFIG_SND_SOC_P1022_DS to brace the new added code to force
them affect P1022ds platform only.]

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 sound/soc/codecs/wm8776.c |   68 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 68 insertions(+), 0 deletions(-)

diff --git a/sound/soc/codecs/wm8776.c b/sound/soc/codecs/wm8776.c
index 4eb77f5..85c8434 100644
--- a/sound/soc/codecs/wm8776.c
+++ b/sound/soc/codecs/wm8776.c
@@ -2,6 +2,7 @@
  * wm8776.c  --  WM8776 ALSA SoC Audio driver
  *
  * Copyright 2009 Wolfson Microelectronics plc
+ * Copyright 2010 Freescale Semiconductor, Inc.
  *
  * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
  *
@@ -10,6 +11,8 @@
  * published by the Free Software Foundation.
  *
  * TODO: Input ALC/limiter support
+ *
+ * 2010_07_22 - add P1022DS support
  */
 
 #include <linux/module.h>
@@ -38,7 +41,11 @@ struct snd_soc_codec_device soc_codec_dev_wm8776;
 struct wm8776_priv {
 	struct snd_soc_codec codec;
 	u16 reg_cache[WM8776_CACHEREGNUM];
+#ifdef CONFIG_SND_SOC_P1022_DS
+	int sysclk;
+#else
 	int sysclk[2];
+#endif
 };
 
 #ifdef CONFIG_SPI_MASTER
@@ -144,6 +151,7 @@ static int wm8776_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	struct snd_soc_codec *codec = dai->codec;
 	int reg, iface, master;
 
+#ifndef CONFIG_SND_SOC_P1022_DS
 	switch (dai->id) {
 	case WM8776_DAI_DAC:
 		reg = WM8776_DACIFCTRL;
@@ -156,6 +164,7 @@ static int wm8776_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	default:
 		return -EINVAL;
 	}
+#endif
 
 	iface = 0;
 
@@ -178,6 +187,15 @@ static int wm8776_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	case SND_SOC_DAIFMT_LEFT_J:
 		iface |= 0x0001;
 		break;
+#ifdef CONFIG_SND_SOC_P1022_DS
+		/* FIXME: CHECK A/B */
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x0003;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		iface |= 0x0007;
+		break;
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -199,8 +217,14 @@ static int wm8776_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	}
 
 	/* Finally, write out the values */
+#ifdef CONFIG_SND_SOC_P1022_DS
+	snd_soc_update_bits(codec, WM8776_DACIFCTRL, 0xf, iface);
+	snd_soc_update_bits(codec, WM8776_ADCIFCTRL, 0xf, iface);
+	snd_soc_update_bits(codec, WM8776_MSTRCTRL, 0x180, 0x180);
+#else
 	snd_soc_update_bits(codec, reg, 0xf, iface);
 	snd_soc_update_bits(codec, WM8776_MSTRCTRL, 0x180, master);
+#endif
 
 	return 0;
 }
@@ -226,13 +250,22 @@ static int wm8776_hw_params(struct snd_pcm_substream *substream,
 
 	iface = 0;
 
+#ifdef CONFIG_SND_SOC_P1022_DS
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+#else
 	switch (dai->id) {
 	case WM8776_DAI_DAC:
+#endif
 		iface_reg = WM8776_DACIFCTRL;
 		master = 0x80;
 		ratio_shift = 4;
 		break;
+#ifdef CONFIG_SND_SOC_P1022_DS
+	case SNDRV_PCM_STREAM_CAPTURE:
+#else
 	case WM8776_DAI_ADC:
+#endif
 		iface_reg = WM8776_ADCIFCTRL;
 		master = 0x100;
 		ratio_shift = 0;
@@ -260,7 +293,11 @@ static int wm8776_hw_params(struct snd_pcm_substream *substream,
 	/* Only need to set MCLK/LRCLK ratio if we're master */
 	if (snd_soc_read(codec, WM8776_MSTRCTRL) & master) {
 		for (i = 0; i < ARRAY_SIZE(mclk_ratios); i++) {
+#ifdef CONFIG_SND_SOC_P1022_DS
+			if (wm8776->sysclk / params_rate(params)
+#else
 			if (wm8776->sysclk[dai->id] / params_rate(params)
+#endif
 			    == mclk_ratios[i])
 				break;
 		}
@@ -268,7 +305,11 @@ static int wm8776_hw_params(struct snd_pcm_substream *substream,
 		if (i == ARRAY_SIZE(mclk_ratios)) {
 			dev_err(codec->dev,
 				"Unable to configure MCLK ratio %d/%d\n",
+#ifdef CONFIG_SND_SOC_P1022_DS
+				wm8776->sysclk, params_rate(params));
+#else
 				wm8776->sysclk[dai->id], params_rate(params));
+#endif
 			return -EINVAL;
 		}
 
@@ -298,9 +339,13 @@ static int wm8776_set_sysclk(struct snd_soc_dai *dai,
 	struct snd_soc_codec *codec = dai->codec;
 	struct wm8776_priv *wm8776 = codec->private_data;
 
+#ifdef CONFIG_SND_SOC_P1022_DS
+	wm8776->sysclk = freq;
+#else
 	BUG_ON(dai->id >= ARRAY_SIZE(wm8776->sysclk));
 
 	wm8776->sysclk[dai->id] = freq;
+#endif
 
 	return 0;
 }
@@ -350,6 +395,28 @@ static struct snd_soc_dai_ops wm8776_adc_ops = {
 	.set_sysclk     = wm8776_set_sysclk,
 };
 
+#ifdef CONFIG_SND_SOC_P1022_DS
+struct snd_soc_dai wm8776_dai[] = {
+	{
+		.name = "WM8776",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = WM8776_RATES,
+			.formats = WM8776_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 2,
+			.channels_max = 2,
+			.rates = WM8776_RATES,
+			.formats = WM8776_FORMATS,
+		},
+		.ops = &wm8776_dac_ops,
+	},
+};
+#else
 struct snd_soc_dai wm8776_dai[] = {
 	{
 		.name = "WM8776 Playback",
@@ -376,6 +443,7 @@ struct snd_soc_dai wm8776_dai[] = {
 		.ops = &wm8776_adc_ops,
 	},
 };
+#endif
 EXPORT_SYMBOL_GPL(wm8776_dai);
 
 #ifdef CONFIG_PM
-- 
1.6.5.2

