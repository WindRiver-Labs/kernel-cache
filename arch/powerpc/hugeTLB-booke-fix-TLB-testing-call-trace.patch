From 97946bcb1ab9e14d57447dd697d9a8e16262eaaf Mon Sep 17 00:00:00 2001
From: yhe <yongli.he@windriver.com>
Date: Tue, 15 Jan 2013 13:13:37 +0800
Subject: [PATCH] hugeTLB/booke: fix TLB testing call trace

when acquired per cpu variable "bachp" we are in the atomic
context, this is unnecessary when there is no dereference to
per cpu variable. so lock it when just access it.

BUG: sleeping function called from invalid context at linux/kernel/rtmutex.c:646
in_atomic(): 1, irqs_disabled(): 0, pid: 2156, name: hugemmap01
Call Trace:
[c0000001ed7db590] [c00000000000b064] .show_stack+0xe4/0x250 (unreliable)
[c0000001ed7db660] [c000000000890a30] .dump_stack+0x20/0x30
[c0000001ed7db6d0] [c000000000089e48] .__might_sleep+0x108/0x160
[c0000001ed7db770] [c000000000885a44] .rt_spin_lock+0x34/0x90
[c0000001ed7db7f0] [c00000000019172c] .kmem_cache_free+0x8c/0x240
[c0000001ed7db8a0] [c00000000002f730] .free_hugepd_range+0x1e0/0x280
[c0000001ed7db950] [c00000000002fe8c] .hugetlb_free_pgd_range+0x25c/0x3d0
[c0000001ed7dba70] [c00000000016f164] .free_pgtables+0x154/0x190
[c0000001ed7dbb20] [c000000000173e1c] .unmap_region+0x13c/0x190
[c0000001ed7dbc50] [c000000000175620] .do_munmap+0x310/0x3e0
[c0000001ed7dbd10] [c000000000175744] .vm_munmap+0x54/0x90
[c0000001ed7dbdb0] [c0000000001773e8] .SyS_munmap+0x28/0x40
[c0000001ed7dbe30] [c0000000000005a4] syscall_exit+0x0/0x2c

Signed-off-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/mm/hugetlbpage.c |    3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c
index 42779c0..4aacc91 100644
--- a/arch/powerpc/mm/hugetlbpage.c
+++ b/arch/powerpc/mm/hugetlbpage.c
@@ -400,15 +400,14 @@ static void hugepd_free(struct mmu_gather *tlb, void *hugepte)
 {
 	struct hugepd_freelist **batchp;
 
-	batchp = &get_cpu_var(hugepd_freelist_cur);
 
 	if (atomic_read(&tlb->mm->mm_users) < 2 ||
 	    cpumask_equal(mm_cpumask(tlb->mm),
 			  cpumask_of(smp_processor_id()))) {
 		kmem_cache_free(hugepte_cache, hugepte);
-        put_cpu_var(hugepd_freelist_cur);
 		return;
 	}
+	batchp = &get_cpu_var(hugepd_freelist_cur);
 
 	if (*batchp == NULL) {
 		*batchp = (struct hugepd_freelist *)__get_free_page(GFP_ATOMIC);
-- 
1.7.9.7

