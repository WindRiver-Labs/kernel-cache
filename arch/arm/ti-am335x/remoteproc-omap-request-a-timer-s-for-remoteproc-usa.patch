From 8e7ca31132bea0cc188c0f186b4fdebfdbc74b25 Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Thu, 21 Feb 2013 13:20:45 -0600
Subject: [PATCH 0686/1115] remoteproc/omap: request a timer(s) for remoteproc
 usage

The remote processors in OMAP are equipped with internal timers,
like the internal SysTick timer in a Cortex M3/M4 NVIC or the
CTM timer within Unicache in IPU & DSP. However, these timers
are gated when the processor subsystem clock is gated, making
them rather difficult to use as OS tick sources. They will not
be able to wakeup the processor from any processor-sleep induced
clock-gating states.

This can be avoided by using an external timer as the tick source,
which can be controlled independently by the core remoteproc
driver code, but still allowing the processor subsystem clock to
be auto-gated when the remoteproc cores are idle.

This patch adds the support for remote processors to request a
timer(s) to be used by the remoteproc. The timers are enabled and
disabled in line with the enabling/disabling of the remoteproc.
The timer data is not mandatory if the advanced device management
features are not required.

The current design relies on OMAP dmtimer api, which are only
present in machine-specific layers, but this needs to be
revisited as and when the dmtimer code moves under the /drivers
folder.

The following timers are used as the tick sources for OMAP4+
remoteprocs, these are picked through the platform data.
	DSP : GPT5
	IPU : GPT3

Additional timer(s) can be used in similar fashion for purposes
like watchdog functionality or as a tick source to the second
processor in IPU (in non-SMP mode).

NOTE: If the gptimer is already in use by the time IPU and/or
DSP are loaded, the processors will fail to boot.

Signed-off-by: Suman Anna <s-anna@ti.com>
(cherry picked from commit fee98d0397b06815c6a7279bdd535a7a81c69b20)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/remoteproc.c              |  161 +++++++++++++++++++++++++
 drivers/remoteproc/omap_remoteproc.c          |   21 +++-
 include/linux/platform_data/remoteproc-omap.h |   24 ++++-
 3 files changed, 202 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-omap2/remoteproc.c b/arch/arm/mach-omap2/remoteproc.c
index 91ffa9e..24973a2 100644
--- a/arch/arm/mach-omap2/remoteproc.c
+++ b/arch/arm/mach-omap2/remoteproc.c
@@ -20,9 +20,12 @@
 #include <linux/remoteproc.h>
 #include <linux/dma-contiguous.h>
 #include <linux/dma-mapping.h>
+#include <linux/of.h>
 #include <linux/platform_data/remoteproc-omap.h>
 #include <linux/platform_data/iommu-omap.h>
 
+#include <plat/dmtimer.h>
+
 #include "omap_device.h"
 #include "omap_hwmod.h"
 #include "soc.h"
@@ -65,6 +68,21 @@ struct omap_rproc_pdev_data {
 #define OMAP_RPROC_CMA_SIZE_IPU		(0x7000000)
 
 /*
+ * These data structures define the desired timers that would
+ * be needed by the respective processors. The timer info is
+ * defined through its hwmod name, which serves both for identifying
+ * the timer as well as a matching logic to be used to lookup
+ * the specific timer device node from the DT blob.
+ */
+static struct omap_rproc_timers_info ipu_timers[] = {
+	{ .name = "timer3", },
+};
+
+static struct omap_rproc_timers_info dsp_timers[] = {
+	{ .name = "timer5", },
+};
+
+/*
  * These data structures define platform-specific information
  * needed for each supported remote processor.
  */
@@ -74,6 +92,8 @@ static struct omap_rproc_pdata omap4_rproc_data[] = {
 		.firmware	= "tesla-dsp.xe64T",
 		.mbox_name	= "mbox-dsp",
 		.oh_name	= "dsp",
+		.timers		= dsp_timers,
+		.timers_cnt	= ARRAY_SIZE(dsp_timers),
 		.set_bootaddr	= omap_ctrl_write_dsp_boot_addr,
 	},
 	{
@@ -81,6 +101,8 @@ static struct omap_rproc_pdata omap4_rproc_data[] = {
 		.firmware	= "ducati-m3-core0.xem3",
 		.mbox_name	= "mbox-ipu",
 		.oh_name	= "ipu",
+		.timers		= ipu_timers,
+		.timers_cnt	= ARRAY_SIZE(ipu_timers),
 	},
 };
 
@@ -217,6 +239,139 @@ out:
 }
 
 /**
+ * of_dev_timer_lookup - look up needed timer node from dt blob
+ * @np: parent device_node of all the searchable nodes
+ * @hwmod_name: hwmod name of the desired timer
+ *
+ * Parse the dt blob and find out needed timer by matching hwmod
+ * name. The match logic only loops through one level of child
+ * nodes of the @np parent device node, and uses the @hwmod_name
+ * instead of the actual timer device name to minimize the need
+ * for defining SoC specific timer data (the DT node names would
+ * also incorporate addresses, so the same timer may have completely
+ * different addresses on different SoCs).
+ *
+ * Return: The device node on success or NULL on failure.
+ */
+static struct device_node *of_dev_timer_lookup(struct device_node *np,
+						const char *hwmod_name)
+{
+	struct device_node *np0 = NULL;
+	const char *p;
+
+	for_each_child_of_node(np, np0) {
+		if (of_find_property(np0, "ti,hwmods", NULL)) {
+			p = of_get_property(np0, "ti,hwmods", NULL);
+			if (!strcmp(p, hwmod_name))
+				return np0;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * omap_rproc_enable_timers - enable the timers for a remoteproc
+ * @pdev - the remoteproc platform device
+ * @configure - boolean flag used to acquire and configure the timer handle
+ *
+ * This function is used primarily to enable the timers associated with
+ * a remoteproc. The configure flag is provided to allow the remoteproc
+ * driver core to either acquire and start a timer (during device
+ * initialization) or to just start a timer (during a resume operation).
+ */
+static int omap_rproc_enable_timers(struct platform_device *pdev,
+				    bool configure)
+{
+	int i;
+	int ret = 0;
+	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
+	struct omap_rproc_timers_info *timers = pdata->timers;
+	struct device_node *np = NULL;
+
+	if (!timers)
+		return -EINVAL;
+
+	if (!configure)
+		goto start_timers;
+
+	/*
+	 * support DT boot mode only since all supported SoCs for remoteproc
+	 * are DT-boot only on 3.10+ kernels
+	 */
+	if (!of_have_populated_dt())
+		return -EINVAL;
+
+	for (i = 0; i < pdata->timers_cnt; i++) {
+		/*
+		 * The current logic of requesting the desired timer utilizes
+		 * a somewhat crude lookup by finding the specific DT node from
+		 * all the sub-nodes of the 'ocp' node and matching it with its
+		 * hwmod name. This logic is expected to be eventually replaced
+		 * with a logic that uses the phandle to the appropriate timer
+		 * DT node.
+		 */
+		np = of_dev_timer_lookup(of_find_node_by_name(NULL, "ocp"),
+						timers[i].name);
+		if (!np) {
+			ret = -ENXIO;
+			dev_err(&pdev->dev, "device node lookup for timer %s failed: %d\n",
+				timers[i].name, ret);
+			goto free_timers;
+		}
+		timers[i].odt = omap_dm_timer_request_by_node(np);
+		if (!timers[i].odt) {
+			ret = -EBUSY;
+			dev_err(&pdev->dev, "request for timer %s failed: %d\n",
+				timers[i].name, ret);
+			goto free_timers;
+		}
+		omap_dm_timer_set_source(timers[i].odt, OMAP_TIMER_SRC_SYS_CLK);
+	}
+
+start_timers:
+	for (i = 0; i < pdata->timers_cnt; i++)
+		omap_dm_timer_start(timers[i].odt);
+	return 0;
+
+free_timers:
+	while (i--) {
+		omap_dm_timer_free(timers[i].odt);
+		timers[i].odt = NULL;
+	}
+
+	return ret;
+}
+
+/**
+ * omap_rproc_disable_timers - disable the timers for a remoteproc
+ * @pdev - the remoteproc platform device
+ * @configure - boolean flag used to release the timer handle
+ *
+ * This function is used primarily to disable the timers associated with
+ * a remoteproc. The configure flag is provided to allow the remoteproc
+ * driver core to either stop and release a timer (during device shutdown)
+ * or to just stop a timer (during a suspend operation).
+ */
+static int omap_rproc_disable_timers(struct platform_device *pdev,
+				     bool configure)
+{
+	int i;
+	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
+	struct omap_rproc_timers_info *timers = pdata->timers;
+
+	for (i = 0; i < pdata->timers_cnt; i++) {
+		omap_dm_timer_stop(timers[i].odt);
+		if (configure) {
+			omap_dm_timer_free(timers[i].odt);
+			timers[i].odt = NULL;
+		}
+	}
+
+	return 0;
+}
+
+/**
  * omap_rproc_reserve_cma - reserve CMA pools
  *
  * This function reserves the CMA pools for each of the remoteproc
@@ -292,6 +447,12 @@ static int __init omap_rproc_init(void)
 		omap4_rproc_data[i].device_enable = omap_rproc_device_enable;
 		omap4_rproc_data[i].device_shutdown =
 						omap_rproc_device_shutdown;
+		if (omap4_rproc_data[i].timers_cnt) {
+			omap4_rproc_data[i].enable_timers =
+						omap_rproc_enable_timers;
+			omap4_rproc_data[i].disable_timers =
+						omap_rproc_disable_timers;
+		}
 
 		device_initialize(&pdev->dev);
 		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
diff --git a/drivers/remoteproc/omap_remoteproc.c b/drivers/remoteproc/omap_remoteproc.c
index 5168972..2a940d6 100644
--- a/drivers/remoteproc/omap_remoteproc.c
+++ b/drivers/remoteproc/omap_remoteproc.c
@@ -1,7 +1,7 @@
 /*
  * OMAP Remote Processor driver
  *
- * Copyright (C) 2011 Texas Instruments, Inc.
+ * Copyright (C) 2011-2013 Texas Instruments, Inc.
  * Copyright (C) 2011 Google, Inc.
  *
  * Ohad Ben-Cohen <ohad@wizery.com>
@@ -142,14 +142,25 @@ static int omap_rproc_start(struct rproc *rproc)
 		goto put_mbox;
 	}
 
+	if (pdata->enable_timers) {
+		ret = pdata->enable_timers(pdev, true);
+		if (ret) {
+			dev_err(dev, "enable_timers failed: %d\n", ret);
+			goto put_mbox;
+		}
+	}
+
 	ret = pdata->device_enable(pdev);
 	if (ret) {
 		dev_err(dev, "omap_device_enable failed: %d\n", ret);
-		goto put_mbox;
+		goto reset_timers;
 	}
 
 	return 0;
 
+reset_timers:
+	if (pdata->disable_timers)
+		pdata->disable_timers(pdev, true);
 put_mbox:
 	omap_mbox_put(oproc->mbox, &oproc->nb);
 	return ret;
@@ -168,6 +179,12 @@ static int omap_rproc_stop(struct rproc *rproc)
 	if (ret)
 		return ret;
 
+	if (pdata->disable_timers) {
+		ret = pdata->disable_timers(pdev, true);
+		if (ret)
+			return ret;
+	}
+
 	omap_mbox_put(oproc->mbox, &oproc->nb);
 
 	return 0;
diff --git a/include/linux/platform_data/remoteproc-omap.h b/include/linux/platform_data/remoteproc-omap.h
index 3c1c644..243b3cc 100644
--- a/include/linux/platform_data/remoteproc-omap.h
+++ b/include/linux/platform_data/remoteproc-omap.h
@@ -1,7 +1,7 @@
 /*
  * Remote Processor - omap-specific bits
  *
- * Copyright (C) 2011 Texas Instruments, Inc.
+ * Copyright (C) 2011-2013 Texas Instruments, Inc.
  * Copyright (C) 2011 Google, Inc.
  *
  * This program is free software; you can redistribute it and/or
@@ -20,7 +20,17 @@
 struct rproc_ops;
 struct platform_device;
 
-/*
+/**
+ * struct omap_rproc_timers_info - timers for the omap rproc
+ * @name: hwmod name of the timer
+ * @odt: timer pointer
+ */
+struct omap_rproc_timers_info {
+	const char *name;
+	struct omap_dm_timer *odt;
+};
+
+/**
  * struct omap_rproc_pdata - omap remoteproc's platform data
  * @name: the remoteproc's name
  * @oh_name: omap hwmod device
@@ -28,9 +38,13 @@ struct platform_device;
  * @firmware: name of firmware file to load
  * @mbox_name: name of omap mailbox device to use with this rproc
  * @ops: start/stop rproc handlers
+ * @timers: timer(s) info rproc needs
+ * @timers_cnt: number of rproc timer(s)
  * @device_enable: omap-specific handler for enabling a device
  * @device_shutdown: omap-specific handler for shutting down a device
  * @set_bootaddr: omap-specific handler for setting the rproc boot address
+ * @enable_timers: omap-specific handler for requesting & enabling rproc timers
+ * @disable_timers: omap-specific handler for disabling & freeing rproc timers
  */
 struct omap_rproc_pdata {
 	const char *name;
@@ -39,9 +53,15 @@ struct omap_rproc_pdata {
 	const char *firmware;
 	const char *mbox_name;
 	const struct rproc_ops *ops;
+	struct omap_rproc_timers_info *timers;
+	u32 timers_cnt;
+
 	int (*device_enable) (struct platform_device *pdev);
 	int (*device_shutdown) (struct platform_device *pdev);
 	void(*set_bootaddr)(u32);
+
+	int (*enable_timers)(struct platform_device *pdev, bool configure);
+	int (*disable_timers)(struct platform_device *pdev, bool configure);
 };
 
 #if defined(CONFIG_OMAP_REMOTEPROC) || defined(CONFIG_OMAP_REMOTEPROC_MODULE)
-- 
1.7.5.4

