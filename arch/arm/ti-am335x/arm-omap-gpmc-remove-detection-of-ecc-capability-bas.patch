From e5f7ed0f8669324f6fa1e1a71630b5409c7d83b4 Mon Sep 17 00:00:00 2001
From: Pekon Gupta <pekon@ti.com>
Date: Fri, 25 Oct 2013 17:17:36 +0530
Subject: [PATCH 0627/1115] arm: omap: gpmc: remove detection of
 ecc-capability based on SoC name

gpmc_hwecc_bch_capable() constrained the selection of ecc-scheme based on
cpu_is_xx(). This was required for board-file approach to detect presence of ELM
hardware engine on SoC. (like OMAP2xxx, OMAP3xxx do not have ELM h/w engine).

But with DT based kernel, presence of ELM h/w engine on SoC is parsed from DT
data part of .dtsi file. Hence this check for detection of ELM based on
cpu_is_xx()for can be dropped. so removing gpmc_hwecc_bch_capable()

Signed-off-by: Pekon Gupta <pekon@ti.com>
(cherry picked from commit 4458982eef0f55d458103510e79afed742c93d04)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/gpmc-nand.c |   25 -------------------------
 1 files changed, 0 insertions(+), 25 deletions(-)

diff --git a/arch/arm/mach-omap2/gpmc-nand.c b/arch/arm/mach-omap2/gpmc-nand.c
index 662c7fd..2b03eba 100644
--- a/arch/arm/mach-omap2/gpmc-nand.c
+++ b/arch/arm/mach-omap2/gpmc-nand.c
@@ -43,28 +43,6 @@ static struct platform_device gpmc_nand_device = {
 	.resource	= gpmc_nand_resource,
 };
 
-static bool gpmc_hwecc_bch_capable(enum omap_ecc ecc_opt)
-{
-	/* support only OMAP3 class */
-	if (!cpu_is_omap34xx() && !soc_is_am33xx()) {
-		pr_err("BCH ecc is not supported on this CPU\n");
-		return 0;
-	}
-
-	/*
-	 * For now, assume 4-bit mode is only supported on OMAP3630 ES1.x, x>=1
-	 * and AM33xx derivates. Other chips may be added if confirmed to work.
-	 */
-	if ((ecc_opt == OMAP_ECC_BCH4_CODE_HW) &&
-	    (!cpu_is_omap3630() || (GET_OMAP_REVISION() == 0)) &&
-	    (!soc_is_am33xx())) {
-		pr_err("BCH 4-bit mode is not supported on this CPU\n");
-		return 0;
-	}
-
-	return 1;
-}
-
 int gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data,
 		   struct gpmc_timings *gpmc_t)
 {
@@ -127,9 +105,6 @@ int gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data,
 
 	gpmc_update_nand_reg(&gpmc_nand_data->reg, gpmc_nand_data->cs);
 
-	if (!gpmc_hwecc_bch_capable(gpmc_nand_data->ecc_opt))
-		return -EINVAL;
-
 	err = platform_device_register(&gpmc_nand_device);
 	if (err < 0) {
 		dev_err(dev, "Unable to register NAND device\n");
-- 
1.7.5.4

