From 4a4871497236107eff0bcb87fe5edd51a26ae79a Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Sun, 6 Oct 2013 21:14:23 -0500
Subject: [PATCH 0565/1115] ARM: OMAP: omap_hwmod: Add handling of per suspend
 cycle hwmod idling

Needed to let the AM335x PM handle the IPs which need forced
standby transition during every suspend-resume cycle when
the corresponding driver is not compiled into the kernel. These modules
do not have MSTANDBY asserted by default so although they are idled at
boot, they lose context during suspend cycle and must be idled again.
Flag added to omap_hwmod to track devices that require per suspend cycle
idling. All flagged hwmods are added to a list and then removed in
omap_device as drivers are bound in order to avoid masking bugs in driver
suspend code. A post PM notifier then idles unbound hwmods after every
suspend cycle.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit 223c8a2bb48d42186f265f71cda0ad19c595a37f)

Conflicts:
	arch/arm/mach-omap2/io.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/board-generic.c        |    1 +
 arch/arm/mach-omap2/common.h               |    1 +
 arch/arm/mach-omap2/io.c                   |    2 +-
 arch/arm/mach-omap2/omap_device.c          |   15 ++++++
 arch/arm/mach-omap2/omap_hwmod.c           |   73 ++++++++++++++++++++++++++++
 arch/arm/mach-omap2/omap_hwmod.h           |   10 ++++
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   15 ++++--
 7 files changed, 111 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-omap2/board-generic.c b/arch/arm/mach-omap2/board-generic.c
index b3a2be2..532b85a 100644
--- a/arch/arm/mach-omap2/board-generic.c
+++ b/arch/arm/mach-omap2/board-generic.c
@@ -148,6 +148,7 @@ DT_MACHINE_START(AM33XX_DT, "Generic AM33XX (Flattened Device Tree)")
 	.reserve	= am33xx_reserve,
 	.map_io		= am33xx_map_io,
 	.init_early	= am33xx_init_early,
+	.init_late	= am33xx_init_late,
 	.init_irq	= omap_intc_of_init,
 	.handle_irq	= omap3_intc_handle_irq,
 	.init_machine	= omap_generic_init,
diff --git a/arch/arm/mach-omap2/common.h b/arch/arm/mach-omap2/common.h
index 2f12446..ccf7bfd 100644
--- a/arch/arm/mach-omap2/common.h
+++ b/arch/arm/mach-omap2/common.h
@@ -106,6 +106,7 @@ void omap2430_init_late(void);
 void omap3430_init_late(void);
 void omap35xx_init_late(void);
 void omap3630_init_late(void);
+void am33xx_init_late(void);
 void am35xx_init_late(void);
 void ti81xx_init_late(void);
 void am33xx_init_late(void);
diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index 0e309b4..6dc2f33 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -598,9 +598,9 @@ void __init am33xx_init_early(void)
 
 void __init am33xx_init_late(void)
 {
+	omap_hwmod_force_mstandby_repeated();
 	omap2_common_pm_late_init();
 }
-
 #endif
 
 #ifdef CONFIG_SOC_AM43XX
diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 0cba70d..fd9a1d7 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -35,6 +35,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/of.h>
 #include <linux/notifier.h>
+#include <linux/suspend.h>
 
 #include "soc.h"
 #include "omap_device.h"
@@ -855,6 +856,7 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omap_device *od = to_omap_device(pdev);
+	struct omap_hwmod *oh = NULL;
 	int i;
 
 	if (!od)
@@ -879,6 +881,19 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 				 __func__);
 			omap_device_idle(pdev);
 		}
+	} else {
+	/*
+	 * There are some IPs that do not have MSTANDBY asserted by default
+	 * which is necessary for PER domain transition. If the drivers
+	 * are not compiled into the kernel HWMOD code will not change the
+	 * state of the IPs if the IP was never enabled, so we keep track of
+	 * them here to idle them with a pm_notifier.
+	 */
+		for (i = 0; i < od->hwmods_cnt; i++) {
+			oh = od->hwmods[i];
+			if (oh->flags & HWMOD_FORCE_MSTANDBY_REPEATED)
+				omap_hwmod_disable_force_mstandby_repeated(oh);
+		}
 	}
 
 	return 0;
diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 2432dfa..6331258 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -141,6 +141,7 @@
 #include <linux/cpu.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/suspend.h>
 
 #include <asm/system_misc.h>
 
@@ -208,6 +209,9 @@ static struct omap_hwmod *mpu_oh;
 /* io_chain_lock: used to serialize reconfigurations of the I/O chain */
 static DEFINE_SPINLOCK(io_chain_lock);
 
+/* _oh_force_mstandby_repeated_list for tracking nonstandard mstandby hwmods */
+static LIST_HEAD(_oh_force_mstandby_repeated_list);
+
 /*
  * linkspace: ptr to a buffer that struct omap_hwmod_link records are
  * allocated from - used to reduce the number of small memory
@@ -3904,6 +3908,75 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 	return 0;
 }
 
+/*
+ * There are some IPs that do not have MSTANDBY asserted by default
+ * which is necessary for PER domain transition. If the drivers
+ * are not compiled into the kernel HWMOD code will not change the
+ * state of the IPs if the IP was never enabled, so we keep track of
+ * them here to idle them with a pm_notifier.
+ */
+
+static int _omap_mstandby_pm_notifier(struct notifier_block *self,
+					unsigned long action, void *dev)
+{
+	struct omap_hwmod_list *oh_list_item = NULL;
+	switch (action) {
+	case PM_POST_SUSPEND:
+		list_for_each_entry(oh_list_item,
+			&_oh_force_mstandby_repeated_list, oh_list) {
+			omap_hwmod_enable(oh_list_item->oh);
+			omap_hwmod_idle(oh_list_item->oh);
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+struct notifier_block pm_nb = {
+	.notifier_call = _omap_mstandby_pm_notifier,
+};
+
+static int _check_for_force_mstandby_repeated(struct omap_hwmod *oh, void *data)
+{
+	if (oh->flags & HWMOD_FORCE_MSTANDBY_REPEATED)
+		omap_hwmod_enable_force_mstandby_repeated(oh);
+
+	return 0;
+}
+
+int omap_hwmod_force_mstandby_repeated(void)
+{
+	omap_hwmod_for_each(_check_for_force_mstandby_repeated, NULL);
+	register_pm_notifier(&pm_nb);
+	return 0;
+}
+
+int omap_hwmod_enable_force_mstandby_repeated(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_list *oh_list_item = NULL;
+
+	oh_list_item = kzalloc(sizeof(*oh_list_item), GFP_KERNEL);
+	oh_list_item->oh = oh;
+	list_add(&oh_list_item->oh_list, &_oh_force_mstandby_repeated_list);
+
+	return 0;
+}
+
+int omap_hwmod_disable_force_mstandby_repeated(struct omap_hwmod *oh)
+{
+	struct omap_hwmod_list *oh_list_item, *tmp;
+
+	list_for_each_entry_safe(oh_list_item, tmp,
+		&_oh_force_mstandby_repeated_list, oh_list) {
+			if (oh_list_item->oh == oh) {
+				list_del(&oh_list_item->oh_list);
+				kfree(oh_list_item);
+			}
+		}
+
+	return 0;
+}
+
 /**
  * omap_hwmod_assert_hardreset - assert the HW reset line of submodules
  * contained in the hwmod module.
diff --git a/arch/arm/mach-omap2/omap_hwmod.h b/arch/arm/mach-omap2/omap_hwmod.h
index d02acf9..5c939ca 100644
--- a/arch/arm/mach-omap2/omap_hwmod.h
+++ b/arch/arm/mach-omap2/omap_hwmod.h
@@ -528,6 +528,7 @@ struct omap_hwmod_omap4_prcm {
 #define HWMOD_BLOCK_WFI				(1 << 10)
 #define HWMOD_FORCE_MSTANDBY			(1 << 11)
 #define HWMOD_SWSUP_SIDLE_ACT			(1 << 12)
+#define HWMOD_FORCE_MSTANDBY_REPEATED		(1 << 13)
 
 /*
  * omap_hwmod._int_flags definitions
@@ -678,6 +679,11 @@ struct omap_hwmod {
 	u8				_postsetup_state;
 };
 
+struct omap_hwmod_list {
+	struct omap_hwmod *oh;
+	struct list_head oh_list;
+};
+
 struct omap_hwmod *omap_hwmod_lookup(const char *name);
 int omap_hwmod_for_each(int (*fn)(struct omap_hwmod *oh, void *data),
 			void *data);
@@ -731,6 +737,10 @@ int omap_hwmod_no_setup_reset(struct omap_hwmod *oh);
 
 int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx);
 
+int omap_hwmod_force_mstandby_repeated(void);
+int omap_hwmod_enable_force_mstandby_repeated(struct omap_hwmod *oh);
+int omap_hwmod_disable_force_mstandby_repeated(struct omap_hwmod *oh);
+
 extern void __init omap_hwmod_init(void);
 
 const char *omap_hwmod_get_main_clk(struct omap_hwmod *oh);
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index d6c3908..9d0e500 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -538,7 +538,8 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod = {
 	.name		= "cpgmac0",
 	.class		= &am33xx_cpgmac0_hwmod_class,
 	.clkdm_name	= "cpsw_125mhz_clkdm",
-	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+			   HWMOD_FORCE_MSTANDBY_REPEATED),
 	.mpu_rt_idx	= 1,
 	.prcm		= {
 		.omap4	= {
@@ -1369,7 +1370,8 @@ static struct omap_hwmod am33xx_tptc0_hwmod = {
 	.name		= "tptc0",
 	.class		= &am33xx_tptc_hwmod_class,
 	.clkdm_name	= "l3_clkdm",
-	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY,
+	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				  HWMOD_FORCE_MSTANDBY_REPEATED,
 	.main_clk	= "l3_gclk",
 	.prcm		= {
 		.omap4	= {
@@ -1383,7 +1385,8 @@ static struct omap_hwmod am33xx_tptc1_hwmod = {
 	.name		= "tptc1",
 	.class		= &am33xx_tptc_hwmod_class,
 	.clkdm_name	= "l3_clkdm",
-	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				   HWMOD_FORCE_MSTANDBY_REPEATED),
 	.main_clk	= "l3_gclk",
 	.prcm		= {
 		.omap4	= {
@@ -1397,7 +1400,8 @@ static struct omap_hwmod am33xx_tptc2_hwmod = {
 	.name		= "tptc2",
 	.class		= &am33xx_tptc_hwmod_class,
 	.clkdm_name	= "l3_clkdm",
-	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				   HWMOD_FORCE_MSTANDBY_REPEATED),
 	.main_clk	= "l3_gclk",
 	.prcm		= {
 		.omap4	= {
@@ -1553,7 +1557,8 @@ static struct omap_hwmod am33xx_usbss_hwmod = {
 	.name		= "usb_otg_hs",
 	.class		= &am33xx_usbotg_class,
 	.clkdm_name	= "l3s_clkdm",
-	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY,
+	.flags		= HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				  HWMOD_FORCE_MSTANDBY_REPEATED,
 	.prcm		= {
 		.omap4	= {
 			.clkctrl_offs	= AM33XX_CM_PER_USB0_CLKCTRL_OFFSET,
-- 
1.7.5.4

