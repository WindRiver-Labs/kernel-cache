From 8f14b19ea60d89feb71f3ebb4e50c3e406fc10e2 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 21 Jan 2014 14:20:28 +0800
Subject: [PATCH 0620/1115] reset: Make the am33xx/am43xx driver generic for
 all TI SoCs

The am33xx/am43xx specific reset driver can be easily used across
other TI SoCs based of the OMAP family like OMAP5 and DRA7.

Remove all references to amx3 (used to represent am33/am43) and
replace them with ti to make this a generic reset driver for all
TI SoCs (Based of AMxx family and OMAP family)

Signed-off-by: Rajendra Nayak <rnayak@ti.com>
Signed-off-by: Kishon Vijay Abraham I <kishon@ti.com>
(cherry picked from commit 71003c8d7a358faaf348c2521183b46edb0e0c79)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/Kconfig |    2 +
 drivers/reset/Kconfig       |   14 ++++
 drivers/reset/Makefile      |    1 +
 drivers/reset/ti_reset.c    |  157 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 174 insertions(+), 0 deletions(-)
 create mode 100644 drivers/reset/ti_reset.c

diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index 785494c..cfb2197 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -75,6 +75,7 @@ config SOC_AM33XX
 	select ARCH_HAS_RESET_CONTROLLER
 	select OMAP_MBOX_FWK if PM
 	select OMAP2PLUS_MBOX if PM
+	select RESET_TI
 
 config SOC_AM43XX
 	bool "TI AM43x"
@@ -87,6 +88,7 @@ config SOC_AM43XX
 	select MACH_OMAP_GENERIC
 	select MIGHT_HAVE_CACHE_L2X0
 	select ARCH_HAS_RESET_CONTROLLER
+	select RESET_TI
 
 config ARCH_OMAP2PLUS
 	bool
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index c9d04f7..ac07962 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -11,3 +11,17 @@ menuconfig RESET_CONTROLLER
 	  via GPIOs or SoC-internal reset controller modules.
 
 	  If unsure, say no.
+
+if	RESET_CONTROLLER
+
+config	RESET_TI
+	bool "TI reset controller"
+	help
+	  Reset controller support for TI SoC's
+
+	  Reset controller found in TI's AM series of SoC's like
+	  AM335x and AM43x and OMAP SoC's like OMAP5 and DRA7
+
+	  If unsure, say no.
+
+endif
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 1e2d83f..fafc87c 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_RESET_CONTROLLER) += core.o
+obj-$(CONFIG_RESET_TI) += ti_reset.o
diff --git a/drivers/reset/ti_reset.c b/drivers/reset/ti_reset.c
new file mode 100644
index 0000000..7b1447d
--- /dev/null
+++ b/drivers/reset/ti_reset.c
@@ -0,0 +1,157 @@
+/*
+ * PRCM reset driver for TI SoC's
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/reset.h>
+#include <linux/reset-controller.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#define DRIVER_NAME "ti_reset"
+
+struct ti_reset_reg_data {
+	u32	rstctrl_offs;
+	u32	rstst_offs;
+	u8	rstctrl_bit;
+	u8	rstst_bit;
+};
+
+struct ti_reset_data {
+	struct	ti_reset_reg_data *reg_data;
+	u8	nr_resets;
+};
+
+static void __iomem *reg_base;
+static const struct ti_reset_data *reset_data;
+
+static struct ti_reset_reg_data am335x_reset_reg_data[] = {
+	{
+		.rstctrl_offs	= 0x1104,
+		.rstst_offs	= 0x1114,
+		.rstctrl_bit	= 0,
+		.rstst_bit	= 0,
+	},
+};
+
+static struct ti_reset_data am335x_reset_data = {
+	.reg_data	= am335x_reset_reg_data,
+	.nr_resets	= ARRAY_SIZE(am335x_reset_reg_data),
+};
+
+static struct ti_reset_reg_data am43x_reset_reg_data[] = {
+	{
+		.rstctrl_offs	= 0x410,
+		.rstst_offs	= 0x414,
+		.rstctrl_bit	= 0,
+		.rstst_bit	= 0,
+	},
+};
+
+static struct ti_reset_data am43x_reset_data = {
+	.reg_data	= am43x_reset_reg_data,
+	.nr_resets	= ARRAY_SIZE(am43x_reset_reg_data),
+};
+
+static int ti_reset_clear_reset(struct reset_controller_dev *rcdev,
+				  unsigned long id)
+{
+	void __iomem *reg = reset_data->reg_data[id].rstst_offs + reg_base;
+	u8 bit = reset_data->reg_data[id].rstst_bit;
+	u32 val = readl(reg);
+
+	val &= ~(1 << bit);
+	val |= 1 << bit;
+	writel(val, reg);
+	return 0;
+}
+
+static int ti_reset_is_reset(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	void __iomem *reg = reset_data->reg_data[id].rstst_offs + reg_base;
+	u8 bit = reset_data->reg_data[id].rstst_bit;
+	u32 val = readl(reg);
+
+	val &= (1 << bit);
+	return !!val;
+}
+
+static int ti_reset_deassert(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	void __iomem *reg = reset_data->reg_data[id].rstctrl_offs +
+				reg_base;
+	u8 bit = reset_data->reg_data[id].rstctrl_bit;
+	u32 val = readl(reg);
+
+	val &= ~(1 << bit);
+	writel(val, reg);
+	return 0;
+}
+
+static struct reset_control_ops ti_reset_ops = {
+	.deassert = ti_reset_deassert,
+	.is_reset = ti_reset_is_reset,
+	.clear_reset = ti_reset_clear_reset,
+};
+
+static struct reset_controller_dev ti_reset_controller = {
+	.ops = &ti_reset_ops,
+};
+
+static const struct of_device_id ti_reset_of_match[] = {
+	{ .compatible = "ti,am3352-prcm", .data = &am335x_reset_data,},
+	{ .compatible = "ti,am4372-prcm", .data = &am43x_reset_data,},
+	{},
+};
+
+static int ti_reset_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	const struct of_device_id *id;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(reg_base))
+		return PTR_ERR(reg_base);
+
+	ti_reset_controller.of_node = pdev->dev.of_node;
+	id = of_match_device(ti_reset_of_match, &pdev->dev);
+	reset_data = id->data;
+	ti_reset_controller.nr_resets = reset_data->nr_resets;
+
+	reset_controller_register(&ti_reset_controller);
+
+	return 0;
+}
+
+static int ti_reset_remove(struct platform_device *pdev)
+{
+	reset_controller_unregister(&ti_reset_controller);
+
+	return 0;
+}
+
+static struct platform_driver ti_reset_driver = {
+	.probe	= ti_reset_probe,
+	.remove	= ti_reset_remove,
+	.driver	= {
+		.name		= DRIVER_NAME,
+		.owner		= THIS_MODULE,
+		.of_match_table	= of_match_ptr(ti_reset_of_match),
+	},
+};
+module_platform_driver(ti_reset_driver);
+
+MODULE_DESCRIPTION("PRCM reset driver for TI SoC's");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
-- 
1.7.5.4

