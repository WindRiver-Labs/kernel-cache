From 2dafe635a1d109422be5982316cde76e92095fff Mon Sep 17 00:00:00 2001
From: Suman Anna <s-anna@ti.com>
Date: Fri, 15 Feb 2013 11:52:23 -0600
Subject: [PATCH 0685/1115] ARM: OMAP2+: add remoteproc devices for OMAP4

OMAP4 has two remote processor subsystems - a dual ARM Cortex-M3 IPU
and a TI C6400-based DSP subsystem. This patch adds the support for
creating remoteproc platform devices, and other necessary platform
specific hooks needed for enabling and booting the remote processors.

A OMAP_REMOTEPROC dependent config option is defined for each rproc
device that provides the choice to enable/disable creating the
corresponding rproc device. The clock and reset management for these
devices is provided by the omap_device/omap_hwmod layer and hence
has to be implemented through platform data functions ops. The
omap_device layer does not program the resets when enabling a device
and is handled by the remoteproc platform hooks. The hooks perform
the reset management based on the remoteproc subsystem type. An IPU
subsystem has two resets, and the remoteproc device management code
asserts/deasserts these together because of the intrinsic device
management dependencies such as a shared MMU and shared cache between
the two Cortex-M3 processors. This allows the OMAP IPU to be run in
either a SMP-mode or a non-SMP mode (using a post-processed combined
image), and is transparent to the remoteproc core driver code.

Each of the devices is bound to its dedicated IOMMU device, used for
managing the MMU; and a dedicated mailbox instance for signalling
message availability and inter processor communication. These slave
devices are used by the remoteproc driver core through the respective
API provided by the iommu and mailbox drivers. A dedicated CMA pool,
tied with each remoteproc device, is used for managing the various
memory needs of the remote processors.

The current CMA pools and sizes are defined statically for each
device. The starting addresses are fixed to meet current dependencies
on the remote processor side, and will go away when the remote-side
code has been improved to gather this information runtime during its
initialization. There are no Kconfig symbols associated with the CMA
bases and sizes, since it would not scale well for remoteproc devices
on multiple SoCs without making the configuration code cumbersome.

The remoteproc CMA pools are also defined to be within the first 512MB
of RAM and end exactly at 0xA000000. The CMA base addresses are
computed by subtracting the required size from 0xA0000000. This allows
a vmalloc size of upto 496MB [__pa(VMALLOC_START) value of 0xA0800000],
without eliciting invalid pfn warnings when the cma regions are
activated.

Based on patches developed previously for TI product kernels, and
includes contributions from:
    Fernando Guzman Lugo <fernando.lugo@ti.com>
    Ohad Ben-Cohen <ohad@wizery.com>
    Juan Gutierrez <jgutierrez@ti.com>

Signed-off-by: Ohad Ben-Cohen <ohad@wizery.com>
Signed-off-by: Suman Anna <s-anna@ti.com>
(cherry picked from commit bd7a44cd0f1f89be0fb3ee2398b886438ec47d88)

Conflicts:
	arch/arm/mach-omap2/Makefile
	arch/arm/mach-omap2/common.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 MAINTAINERS                         |    6 +
 arch/arm/mach-omap2/Makefile        |    4 +
 arch/arm/mach-omap2/board-generic.c |    2 +-
 arch/arm/mach-omap2/common.c        |    7 +
 arch/arm/mach-omap2/common.h        |    2 +
 arch/arm/mach-omap2/remoteproc.c    |  331 +++++++++++++++++++++++++++++++++++
 drivers/remoteproc/Kconfig          |   36 ++++-
 7 files changed, 382 insertions(+), 6 deletions(-)
 create mode 100644 arch/arm/mach-omap2/remoteproc.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 414202f..656ed28 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5790,6 +5790,12 @@ S:	Maintained
 F:	arch/arm/boot/dts/*omap*
 F:	arch/arm/boot/dts/*am3*
 
+OMAP REMOTEPROC SUPPORT
+M:	Ohad Ben-Cohen <ohad@wizery.com>
+L:	linux-omap@vger.kernel.org
+S:	Maintained
+F:	arch/arm/*omap*/*remoteproc*
+
 OMAP CLOCK FRAMEWORK SUPPORT
 M:	Paul Walmsley <paul@pwsan.com>
 L:	linux-omap@vger.kernel.org
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 5965243..5a9a812 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -304,3 +304,7 @@ emac-$(CONFIG_TI_DAVINCI_EMAC)		:= am35xx-emac.o
 obj-y					+= $(emac-m) $(emac-y)
 
 obj-y					+= common-board-devices.o twl-common.o
+
+ifneq ($(CONFIG_OMAP_REMOTEPROC),)
+obj-y					+= remoteproc.o
+endif
diff --git a/arch/arm/mach-omap2/board-generic.c b/arch/arm/mach-omap2/board-generic.c
index 110f127..2491e6a 100644
--- a/arch/arm/mach-omap2/board-generic.c
+++ b/arch/arm/mach-omap2/board-generic.c
@@ -184,7 +184,7 @@ static const char *omap4_boards_compat[] __initdata = {
 };
 
 DT_MACHINE_START(OMAP4_DT, "Generic OMAP4 (Flattened Device Tree)")
-	.reserve	= omap_reserve,
+	.reserve	= omap4_reserve,
 	.smp		= smp_ops(omap4_smp_ops),
 	.map_io		= omap4_map_io,
 	.init_early	= omap4430_init_early,
diff --git a/arch/arm/mach-omap2/common.c b/arch/arm/mach-omap2/common.c
index 36089d7..e1ae24b 100644
--- a/arch/arm/mach-omap2/common.c
+++ b/arch/arm/mach-omap2/common.c
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_data/dsp-omap.h>
+#include <linux/platform_data/remoteproc-omap.h>
 #include <asm/memblock.h>
 #include <asm/mach/map.h>
 
@@ -32,6 +33,12 @@ int __weak omap_secure_ram_reserve_memblock(void)
 	return 0;
 }
 
+void __init omap4_reserve(void)
+{
+	omap_rproc_reserve_cma();
+	omap_reserve();
+}
+
 void __init omap_reserve(void)
 {
 	omap_dsp_reserve_sdram_memblock();
diff --git a/arch/arm/mach-omap2/common.h b/arch/arm/mach-omap2/common.h
index 196aa21..e9f03ed 100644
--- a/arch/arm/mach-omap2/common.h
+++ b/arch/arm/mach-omap2/common.h
@@ -332,6 +332,8 @@ extern void omap_sdrc_init(struct omap_sdrc_params *sdrc_cs0,
 				      struct omap_sdrc_params *sdrc_cs1);
 struct omap2_hsmmc_info;
 extern int omap4_twl6030_hsmmc_init(struct omap2_hsmmc_info *controllers);
+
+extern void omap4_reserve(void);
 extern void omap_reserve(void);
 
 extern void am33xx_reserve(void);
diff --git a/arch/arm/mach-omap2/remoteproc.c b/arch/arm/mach-omap2/remoteproc.c
new file mode 100644
index 0000000..91ffa9e
--- /dev/null
+++ b/arch/arm/mach-omap2/remoteproc.c
@@ -0,0 +1,331 @@
+/*
+ * Remote processor machine-specific module for OMAP4+ SoCs
+ *
+ * Copyright (C) 2011-2013 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt)    "%s: " fmt, __func__
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/remoteproc.h>
+#include <linux/dma-contiguous.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_data/remoteproc-omap.h>
+#include <linux/platform_data/iommu-omap.h>
+
+#include "omap_device.h"
+#include "omap_hwmod.h"
+#include "soc.h"
+#include "control.h"
+
+/**
+ * struct omap_rproc_pdev_data - rproc platform device creation helper structure
+ * @enabled: flag to dictate creation of the platform device
+ * @pdev: platform device handle
+ * @cma_addr: Base CMA address to use for the platform device
+ * @cma_size: CMA pool size to reserve starting from cma_addr
+ *
+ * This structure is mainly used to decide to create a platform
+ * device or not. The enabled flag for each device is conditionally
+ * set based on its corresponding Kconfig symbol.
+ */
+struct omap_rproc_pdev_data {
+	u32 enabled;
+	phys_addr_t cma_addr;
+	unsigned long cma_size;
+	struct platform_device *pdev;
+};
+
+/*
+ * Temporarily define the CMA base address explicitly.
+ *
+ * This is currently done since there are some dependencies on
+ * the remote processor firmware images for properly identifying
+ * the vring information. The base addresses will go away as
+ * soon as the vring information can be published dynamically
+ * and the remote processor firmware code can parse it properly.
+ *
+ * XXX: Adjust these values depending on your firmware needs.
+ * Placing these in Kconfig is not worth the complexity.
+ */
+#define OMAP_RPROC_CMA_BASE_IPU		(0x99000000)
+#define OMAP_RPROC_CMA_BASE_DSP		(0x98800000)
+
+#define OMAP_RPROC_CMA_SIZE_DSP		(0x800000)
+#define OMAP_RPROC_CMA_SIZE_IPU		(0x7000000)
+
+/*
+ * These data structures define platform-specific information
+ * needed for each supported remote processor.
+ */
+static struct omap_rproc_pdata omap4_rproc_data[] = {
+	{
+		.name		= "dsp",
+		.firmware	= "tesla-dsp.xe64T",
+		.mbox_name	= "mbox-dsp",
+		.oh_name	= "dsp",
+		.set_bootaddr	= omap_ctrl_write_dsp_boot_addr,
+	},
+	{
+		.name		= "ipu",
+		.firmware	= "ducati-m3-core0.xem3",
+		.mbox_name	= "mbox-ipu",
+		.oh_name	= "ipu",
+	},
+};
+
+/*
+ * These data structures define the necessary iommu binding information
+ * for the respective processor. The listing order should match the
+ * order of the platform device and data.
+ */
+static struct omap_iommu_arch_data omap4_rproc_iommu[] = {
+	{ .name = "mmu_dsp" },
+	{ .name = "mmu_ipu" },
+};
+
+/*
+ * Define the platform devices for the possible remote processors
+ * statically. This is primarily needed for tying in the CMA pools
+ * at boot time. The specific id assignment helps in identifying
+ * a specific processor during debugging, but otherwise serves no
+ * major purpose.
+ */
+static struct platform_device omap4_dsp = {
+	.name	= "omap-rproc",
+	.id	= 0,
+};
+
+static struct platform_device omap4_ipu = {
+	.name	= "omap-rproc",
+	.id	= 1,
+};
+
+/*
+ * These data structures contain the necessary information for
+ * dictating the creation of the remote processor platform devices
+ * at runtime.
+ */
+static struct omap_rproc_pdev_data omap4_rproc_pdev_data[] = {
+	{
+#ifdef CONFIG_OMAP_REMOTEPROC_DSP
+		.enabled = 1,
+#endif
+		.pdev = &omap4_dsp,
+		.cma_addr = OMAP_RPROC_CMA_BASE_DSP,
+		.cma_size = OMAP_RPROC_CMA_SIZE_DSP,
+	},
+	{
+#ifdef CONFIG_OMAP_REMOTEPROC_IPU
+		.enabled = 1,
+#endif
+		.pdev = &omap4_ipu,
+		.cma_addr = OMAP_RPROC_CMA_BASE_IPU,
+		.cma_size = OMAP_RPROC_CMA_SIZE_IPU,
+	},
+};
+
+/**
+ * omap_rproc_device_enable - enable the remoteproc device
+ * @pdev: the rproc platform device
+ *
+ * This function performs the necessary low-level functions to enable
+ * a remoteproc device to start executing. This typically includes
+ * releasing the reset lines, and enabling the clocks for the device.
+ * We do not usually expect this function to fail.
+ *
+ * Return: 0 on success, or the return code from the failed function
+ */
+static int omap_rproc_device_enable(struct platform_device *pdev)
+{
+	int ret = -EINVAL;
+	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
+
+	if (strstarts(pdata->name, "dsp")) {
+		ret = omap_device_deassert_hardreset(pdev, "dsp");
+		if (ret)
+			goto out;
+	} else if (strstarts(pdata->name, "ipu")) {
+		ret = omap_device_deassert_hardreset(pdev, "cpu0");
+		if (ret)
+			goto out;
+
+		ret = omap_device_deassert_hardreset(pdev, "cpu1");
+		if (ret)
+			goto out;
+	} else {
+		pr_err("unsupported remoteproc\n");
+		goto out;
+	}
+
+	ret = omap_device_enable(pdev);
+
+out:
+	if (ret && pdata->name)
+		pr_err("failed for proc %s\n", pdata->name);
+	return ret;
+}
+
+/**
+ * omap_rproc_device_shutdown - shutdown the remoteproc device
+ * @pdev: the rproc platform device
+ *
+ * This function performs the necessary low-level functions to shutdown
+ * a remoteproc device. This typically includes disabling the clocks
+ * for the device and asserting the associated reset lines. We do not
+ * usually expect this function to fail.
+ *
+ * Return: 0 on success, or the return code from the failed function
+ */
+static int omap_rproc_device_shutdown(struct platform_device *pdev)
+{
+	int ret = -EINVAL;
+	struct omap_rproc_pdata *pdata = pdev->dev.platform_data;
+
+	ret = omap_device_idle(pdev);
+	if (ret)
+		goto out;
+
+	if (strstarts(pdata->name, "dsp")) {
+		ret = omap_device_assert_hardreset(pdev, "dsp");
+	} else if (strstarts(pdata->name, "ipu")) {
+		ret = omap_device_assert_hardreset(pdev, "cpu1");
+		if (ret)
+			goto out;
+
+		ret = omap_device_assert_hardreset(pdev, "cpu0");
+		if (ret)
+			goto out;
+	} else {
+		pr_err("unsupported remoteproc\n");
+	}
+
+out:
+	if (ret && pdata->name)
+		pr_err("failed for proc %s\n", pdata->name);
+	return ret;
+}
+
+/**
+ * omap_rproc_reserve_cma - reserve CMA pools
+ *
+ * This function reserves the CMA pools for each of the remoteproc
+ * devices at boot time. This function needs to be called from the
+ * appropriate board .reserve function in order to define the CMA
+ * pools for all possible devices. The CMA pool is reserved only
+ * if the corresponding remoteproc platform device is being enabled.
+ * The CMA pool information is gathered from the corresponding
+ * omap_rproc_pdev_data definitions.
+ */
+void __init omap_rproc_reserve_cma(void)
+{
+	struct omap_rproc_pdev_data *rproc_pdev_data = omap4_rproc_pdev_data;
+	int rproc_size = ARRAY_SIZE(omap4_rproc_pdev_data);
+	int i, ret;
+
+	for (i = 0; i < rproc_size; i++) {
+		struct platform_device *pdev = rproc_pdev_data[i].pdev;
+
+		if (!rproc_pdev_data[i].enabled)
+			continue;
+
+		ret = dma_declare_contiguous(&pdev->dev,
+						rproc_pdev_data[i].cma_size,
+						rproc_pdev_data[i].cma_addr, 0);
+		if (ret) {
+			pr_err("dma_declare_contiguous failed for rproc pdev %d, status = %d\n",
+			       i, ret);
+		}
+	}
+}
+
+/**
+ * omap_rproc_init - build remoteproc platform devices
+ *
+ * This function constructs the platform data for the various remoteproc
+ * devices and creates the corresponding omap_devices. The function uses
+ * the individual omap_device API rather than a omap_device_build_ss API
+ * since it needs the platform devices at boot time for defining the CMA
+ * pools and also attach each remote processor device to its specific
+ * iommu device separately during init time.
+ *
+ * Return: 0 on success, or an appropriate error otherwise
+ */
+static int __init omap_rproc_init(void)
+{
+	struct omap_hwmod *oh;
+	struct omap_device *od;
+	int i, ret = 0, oh_count;
+
+	if (!cpu_is_omap44xx())
+		return 0;
+
+	for (i = 0; i < ARRAY_SIZE(omap4_rproc_pdev_data); i++) {
+		const char *oh_name = omap4_rproc_data[i].oh_name;
+		struct platform_device *pdev = omap4_rproc_pdev_data[i].pdev;
+		oh_count = 0;
+
+		if (!omap4_rproc_pdev_data[i].enabled) {
+			pr_info("skipping platform_device creation for %s\n",
+				omap4_rproc_data[i].oh_name);
+			continue;
+		}
+
+		oh = omap_hwmod_lookup(oh_name);
+		if (!oh) {
+			pr_err("could not look up hwmod info for %s\n",
+			       oh_name);
+			continue;
+		}
+		oh_count++;
+
+		omap4_rproc_data[i].device_enable = omap_rproc_device_enable;
+		omap4_rproc_data[i].device_shutdown =
+						omap_rproc_device_shutdown;
+
+		device_initialize(&pdev->dev);
+		dev_set_name(&pdev->dev, "%s.%d", pdev->name,  pdev->id);
+
+		od = omap_device_alloc(pdev, &oh, oh_count);
+		if (!od) {
+			dev_err(&pdev->dev, "omap_device_alloc failed\n");
+			put_device(&pdev->dev);
+			ret = PTR_ERR(od);
+			continue;
+		}
+
+		ret = platform_device_add_data(pdev, &omap4_rproc_data[i],
+					       sizeof(struct omap_rproc_pdata));
+		if (ret) {
+			dev_err(&pdev->dev, "can't add pdata\n");
+			omap_device_delete(od);
+			put_device(&pdev->dev);
+			continue;
+		}
+
+		pdev->dev.archdata.iommu = &omap4_rproc_iommu[i];
+
+		ret = omap_device_register(pdev);
+		if (ret) {
+			dev_err(&pdev->dev, "omap_device_register failed\n");
+			omap_device_delete(od);
+			put_device(&pdev->dev);
+			continue;
+		}
+		dev_info(&pdev->dev, "platform_device for rproc %s created\n",
+			 omap4_rproc_data[i].oh_name);
+	}
+
+	return ret;
+}
+device_initcall(omap_rproc_init);
diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index ce1743d..b61fee7 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -9,6 +9,7 @@ config REMOTEPROC
 	select VIRTIO
 	select VIRTUALIZATION
 
+# OMAP_REMOTEPROC depends on selection of IPU or DSP instances
 config OMAP_REMOTEPROC
 	tristate "OMAP remoteproc support"
 	depends on HAS_DMA
@@ -19,17 +20,42 @@ config OMAP_REMOTEPROC
 	select OMAP2PLUS_MBOX
 	select RPMSG
 	help
-	  Say y here to support OMAP's remote processors (dual M3
+	  Support for OMAP's remote processors (dual Cortex-M3
 	  and DSP on OMAP4) via the remote processor framework.
 
 	  Currently only supported on OMAP4.
 
-	  Usually you want to say y here, in order to enable multimedia
-	  use-cases to run on your platform (multimedia codecs are
-	  offloaded to remote DSP processors using this framework).
+	  It gets selected by DSP or IPU OMAP_REMOTEPROC instances,
+	  in order to enable multimedia use-cases to run on your platform
+	  (multimedia codecs are offloaded to remote DSP processors or
+	  remoteproc processors controlling other h/w accelerator devices
+	  using this framework).
+
+config OMAP_REMOTEPROC_IPU
+	bool "OMAP remoteproc support for IPU"
+	depends on OMAP_REMOTEPROC
+	help
+	  Say Y here if you want to enable OMAP's IPU remote processor.
+
+	  This option controls only the dual Cortex-M3 processor sub-system.
+	  You would want to say y here usually, as this is the sub-system
+	  where typically video & imaging codec control s/w is offloaded.
 
 	  It's safe to say n here if you're not interested in multimedia
-	  offloading or just want a bare minimum kernel.
+	  offloading (by IPU) or just want a bare minimum kernel.
+
+config OMAP_REMOTEPROC_DSP
+	bool "OMAP remoteproc support for DSP"
+	depends on OMAP_REMOTEPROC
+	help
+	  Say Y here if you want to enable OMAP's DSP remote processor.
+
+	  This option controls only the DSP processor sub-system. DSP would
+	  typically be used to offload audio codecs or other advanced
+	  processing algorithms.
+
+	  It's safe to say n here if you're not interested in offloading
+	  audio or any other algorithm (by DSP) or just want a bare minimum kernel.
 
 config STE_MODEM_RPROC
 	tristate "STE-Modem remoteproc support"
-- 
1.7.5.4

