From 3e3c6451b5c58f55bc6f868a69e4ec7000cf6ccc Mon Sep 17 00:00:00 2001
From: "Hebbar, Gururaja" <gururaja.hebbar@ti.com>
Date: Sun, 6 Oct 2013 21:14:28 -0500
Subject: [PATCH 0569/1115] ARM: OMAP2+: AM33XX: PM: Add standby support

Standby is one of the Power Modes supported on AM335x.
In Standby Mode, Everything is preserved including SDRAM. Only required
module clocks are enabled, PLLs are put in bypass and MPU is power
gated.
This Mode has higher power consumption than DeepSleep0 but better wake
latency.

Add support for standby mode
- MPU Power domain is OFF
- PER Power domain is ON
- Master Oscillator is ON

To enter standby mode, echo "standby" to PM State sysfs entry
        "echo standby > /sys/power/state"

Currently UART, GPIO & RTC wakeup events are tested on am335x-evm.

Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit fbbd84db2f094e8d6c4dc4f8c1af3d41c60fa5e8)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/pm33xx.c |   22 +++++++++++++++++++---
 arch/arm/mach-omap2/pm33xx.h |    5 +++--
 2 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index c88f879..66b2b72 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -47,6 +47,7 @@
 static void __iomem *am33xx_emif_base;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
 static struct clockdomain *gfx_l4ls_clkdm;
+static struct clockdomain *l3s_clkdm, *l4fw_clkdm, *clk_24mhz_clkdm;
 
 static struct am33xx_pm_context *am33xx_pm;
 
@@ -64,12 +65,18 @@ static int am33xx_do_sram_idle(long unsigned int unused)
 	return 0;
 }
 
-static int am33xx_pm_suspend(void)
+static int am33xx_pm_suspend(unsigned int state)
 {
 	int i, ret = 0;
 	int status = 0;
 	struct wkup_m3_wakeup_src wakeup_src;
 
+	if (state == PM_SUSPEND_STANDBY) {
+		clkdm_wakeup(l3s_clkdm);
+		clkdm_wakeup(l4fw_clkdm);
+		clkdm_wakeup(clk_24mhz_clkdm);
+	}
+
 	/* Try to put GFX to sleep */
 	omap_set_pwrdm_state(gfx_pwrdm, PWRDM_POWER_OFF);
 
@@ -127,8 +134,9 @@ static int am33xx_pm_enter(suspend_state_t suspend_state)
 	int ret = 0;
 
 	switch (suspend_state) {
+	case PM_SUSPEND_STANDBY:
 	case PM_SUSPEND_MEM:
-		ret = am33xx_pm_suspend();
+		ret = am33xx_pm_suspend(suspend_state);
 		break;
 	default:
 		ret = -EINVAL;
@@ -170,6 +178,9 @@ static int am33xx_pm_begin(suspend_state_t state)
 	case PM_SUSPEND_MEM:
 		am33xx_pm->ipc.reg1	= IPC_CMD_DS0;
 		break;
+	case PM_SUSPEND_STANDBY:
+		am33xx_pm->ipc.reg1	= IPC_CMD_STANDBY;
+		break;
 	}
 
 	am33xx_pm->ipc.reg2		= DS_IPC_DEFAULT;
@@ -206,6 +217,7 @@ static void am33xx_pm_end(void)
 static int am33xx_pm_valid(suspend_state_t state)
 {
 	switch (state) {
+	case PM_SUSPEND_STANDBY:
 	case PM_SUSPEND_MEM:
 		return 1;
 	default:
@@ -312,8 +324,12 @@ int __init am33xx_pm_init(void)
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 
 	gfx_l4ls_clkdm = clkdm_lookup("gfx_l4ls_gfx_clkdm");
+	l3s_clkdm = clkdm_lookup("l3s_clkdm");
+	l4fw_clkdm = clkdm_lookup("l4fw_clkdm");
+	clk_24mhz_clkdm = clkdm_lookup("clk_24mhz_clkdm");
 
-	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm) || (!gfx_l4ls_clkdm)) {
+	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm) || (!gfx_l4ls_clkdm) ||
+	    (!l3s_clkdm) || (!l4fw_clkdm) || (!clk_24mhz_clkdm)) {
 		ret = -ENODEV;
 		goto err;
 	}
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index 0efb5a6..dd8858e 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -44,8 +44,9 @@ struct am33xx_suspend_params {
 
 #endif
 
-#define	IPC_CMD_DS0				0x4
-#define IPC_CMD_RESET           0xe
+#define	IPC_CMD_DS0			0x4
+#define	IPC_CMD_STANDBY			0xc
+#define IPC_CMD_RESET			0xe
 #define DS_IPC_DEFAULT			0xffffffff
 #define M3_VERSION_UNKNOWN		0x0000ffff
 #define M3_BASELINE_VERSION		0x21
-- 
1.7.5.4

