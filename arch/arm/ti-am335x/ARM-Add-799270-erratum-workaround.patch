From 782c8ee18fbaa8821ed5d278b78a67501648df57 Mon Sep 17 00:00:00 2001
From: Sricharan R <r.sricharan@ti.com>
Date: Tue, 19 Nov 2013 15:32:21 +0530
Subject: [PATCH 0678/1115] ARM: Add 799270 erratum workaround
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

799270: Writing ACTLR.SMP when the L2 cache has been idle for an extended
	period may not work correctly.

Description:
If the L2 cache logic clock is stopped because of L2 inactivity, setting or
clearing the ACTLR.SMP bit might not be effective. The bit is modified in the
ACTLR, meaning a read of the register returns the updated value. However the
logic that uses that bit retains the previous value.

1) The L2 cache block has been idle for 256 or more cycles with no memory requests
   from any core, no external snoops, and no ACP requests.

2) A CPU executes an “MCR p15,0,r0,c1,c0,1” instruction (write the ACTLR register)
   that modifies ACTLR[6].

Implications:
If the errata conditions occur when the ACTLR.SMP bit is being set at boot, the
instruction cache or TLB could become incoherent, as that CPU would not receive
necessary DVM requests.

Workaround:
The following code must be executed with all interrupts disabled
r1 must contain the value of an Non-cacheable, SO, or Dev memory location
or register

(typically a memory mapped register with no read side effects would be used)
mrc p15,0,r0,c1,c0,1 ; read current value of ACTLR
orr r0,r0,#0x40 ; set/clear SMP bit (ACTLR[6])
ldr r1, [r1] ; read a device register (location guaranteed not to hit the L1 cache)
and r1,r1,#0 ;
orr r0,r0,r1 ; create dummy dependency between dummy load and MCR to write SMP
MCR p15,0,r0,c1,c0,1
; Write CP15 ACTLR
ISB
DSB

Signed-off-by: Sricharan R <r.sricharan@ti.com>
Signed-off-by: Rajendra Nayak <rnayak@ti.com>
(cherry picked from commit f4ca3dc0b69c2bd4c6a40ae1551578e2a4b1cbd3)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/Kconfig          |    8 ++++++++
 arch/arm/mm/proc-macros.S |   25 +++++++++++++++++++++++++
 arch/arm/mm/proc-v7.S     |   12 ++++++++++++
 3 files changed, 45 insertions(+), 0 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index bf67f50..887766e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1413,6 +1413,14 @@ config ARM_ERRATA_773022
 	  loop buffer may deliver incorrect instructions. This
 	  workaround disables the loop buffer to avoid the erratum.
 
+config ARM_ERRATA_799270
+	bool "ARM errata: writing ACTLR.SMP when the L2 cache has been idle for an extended period may not work correctly"
+	depends on CPU_V7 && SMP
+	help
+	 This option enables the workaround for the 799270 Cortex-A15
+	 (up to r2p4) erratum. If the L2 cache has been idle for 256 or more
+	 cycles and when the CPU executes the ACTLR to modify the SMP bit, it may
+	 not work correctly
 endmenu
 
 source "arch/arm/common/Kconfig"
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
index e3c48a3..d0ca44b 100644
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -338,3 +338,28 @@ ENTRY(\name\()_tlb_fns)
 	.globl	\x
 	.equ	\x, \y
 .endm
+
+.macro write_actlr_smp x, y
+	mrc p15, 0, \x, c1, c0, 1
+	orr \x, \x, #0x40
+	ldr \y, __temp
+	and \y, \y, #0
+	orr \x, \x, \y
+	mcr p15, 0, \x, c1, c0, 1
+	isb
+	dsb
+.endm
+
+.macro clear_actlr_smp x, y
+	mrc p15, 0, \x, c1, c0, 1
+	bic \x, \x, #0x40
+	ldr \y, __temp
+	and \y, \y, #0
+	orr \x, \x, \y
+	mcr p15, 0, \x, c1, c0, 1
+	isb
+	dsb
+.endm
+
+__temp:
+	.space 4
diff --git a/arch/arm/mm/proc-v7.S b/arch/arm/mm/proc-v7.S
index f9699e4..42a0bae 100644
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -128,7 +128,13 @@ ENTRY(cpu_v7_do_resume)
 	mcr	p15, 0, r11, c2, c0, 2	@ TTB control register
 	mrc	p15, 0, r4, c1, c0, 1	@ Read Auxiliary control register
 	teq	r4, r9			@ Is it already set?
+#ifdef CONFIG_ARM_ERRATA_799270
+	beq	1f
+	write_actlr_smp r9, r10
+#else
 	mcrne	p15, 0, r9, c1, c0, 1	@ No, so write it
+#endif
+1:
 	mcr	p15, 0, r10, c1, c0, 2	@ Co-processor access control
 	ldr	r4, =PRRR		@ PRRR
 	ldr	r5, =NMRR		@ NMRR
@@ -190,10 +196,16 @@ __v7_ca15mp_setup:
 	ALT_SMP(mrc	p15, 0, r0, c1, c0, 1)
 	ALT_UP(mov	r0, #(1 << 6))		@ fake it for UP
 	tst	r0, #(1 << 6)			@ SMP/nAMP mode enabled?
+#ifdef ARM_ERRATA_799270
+	bne	2f
+	write_actlr_smp r0, r12
+#else
 	orreq	r0, r0, #(1 << 6)		@ Enable SMP/nAMP mode
+#endif
 	orreq	r0, r0, r10			@ Enable CPU-specific SMP bits
 	mcreq	p15, 0, r0, c1, c0, 1
 #endif
+2:
 	b	__v7_setup
 
 __v7_pj4b_setup:
-- 
1.7.5.4

