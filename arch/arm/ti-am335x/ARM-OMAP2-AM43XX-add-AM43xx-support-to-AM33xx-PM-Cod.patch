From 301902be3b3ed65d9d756c2fe2e8852b7f56ac1e Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Wed, 11 Dec 2013 01:47:16 +0000
Subject: [PATCH 0714/1115] ARM: OMAP2+: AM43XX: add AM43xx support to AM33xx
 PM Code

Because am33xx and am43xx families are very similar we can reuse much
of the code needed for suspend resume. Add code for SCU control and
additional arguments to be passed to low-level asm code.

Also introduce am33xx_pm_ops to allow for operations specific to
each SoC to be executed at init, pre-suspend, and post-suspend that
can be set at init time.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Acked-by: Russ Dill <russ.dill@ti.com>
(cherry picked from commit 1c924b33fa02852acc080594b5e2161b78157bd3)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/pm.h     |    5 ++
 arch/arm/mach-omap2/pm33xx.c |  160 +++++++++++++++++++++++++++++++++---------
 arch/arm/mach-omap2/pm33xx.h |    8 ++
 arch/arm/mach-omap2/sram.h   |    2 +
 4 files changed, 142 insertions(+), 33 deletions(-)

diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 5122bb6..0a8c4f0 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -87,6 +87,11 @@ extern void am33xx_do_wfi(void);
 extern unsigned int am33xx_do_wfi_sz;
 extern unsigned int am33xx_resume_offset;
 
+/* am43xx_do_wfi function pointer and size, for copy to SRAM */
+extern void am43xx_do_wfi(void);
+extern unsigned int am43xx_do_wfi_sz;
+extern unsigned int am43xx_resume_offset;
+
 /* save_secure_ram_context function pointer and size, for copy to SRAM */
 extern int save_secure_ram_context(u32 *addr);
 extern unsigned int save_secure_ram_context_sz;
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index b87197a..e42a257 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -35,6 +35,7 @@
 #include <asm/sizes.h>
 #include <asm/fncpy.h>
 #include <asm/system_misc.h>
+#include <asm/smp_scu.h>
 
 #include "pm.h"
 #include "cm33xx.h"
@@ -46,7 +47,7 @@
 #include "sram.h"
 #include "omap_device.h"
 
-static void __iomem *am33xx_emif_base;
+static void __iomem *am33xx_emif_base, *scu_base;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
 static struct clockdomain *gfx_l4ls_clkdm;
 static struct clockdomain *l3s_clkdm, *l4fw_clkdm, *clk_24mhz_clkdm;
@@ -75,32 +76,15 @@ static int am33xx_do_sram_idle(long unsigned int unused)
 static int am33xx_pm_suspend(unsigned int state)
 {
 	int i, ret = 0;
-	int status = 0;
 	struct wkup_m3_wakeup_src wakeup_src;
 
-	if (state == PM_SUSPEND_STANDBY) {
-		clkdm_wakeup(l3s_clkdm);
-		clkdm_wakeup(l4fw_clkdm);
-		clkdm_wakeup(clk_24mhz_clkdm);
-	}
-
-	/* Try to put GFX to sleep */
 	omap_set_pwrdm_state(gfx_pwrdm, PWRDM_POWER_OFF);
 
-	ret = cpu_suspend(0, am33xx_do_sram_idle);
+	am33xx_pm->ops->pre_suspend(state);
 
-	status = pwrdm_read_pwrst(gfx_pwrdm);
-	if (status != PWRDM_POWER_OFF)
-		pr_err("PM: GFX domain did not transition\n");
+	ret = cpu_suspend(0, am33xx_do_sram_idle);
 
-	/*
-	 * BUG: GFX_L4LS clock domain needs to be woken up to
-	 * ensure thet L4LS clock domain does not get stuck in transition
-	 * If that happens L3 module does not get disabled, thereby leading
-	 * to PER power domain transition failing
-	 */
-	clkdm_wakeup(gfx_l4ls_clkdm);
-	clkdm_sleep(gfx_l4ls_clkdm);
+	am33xx_pm->ops->post_suspend(state);
 
 	if (ret) {
 		pr_err("PM: Kernel suspend failure\n");
@@ -330,6 +314,12 @@ void am33xx_push_sram_idle(void)
 					(am33xx_do_wfi, am33xx_do_wfi_sz);
 }
 
+void am43xx_push_sram_idle(void)
+{
+	am33xx_do_wfi_sram = (void *)omap_sram_push
+					(am43xx_do_wfi, am43xx_do_wfi_sz);
+}
+
 static int __init am33xx_map_emif(void)
 {
 	am33xx_emif_base = ioremap(AM33XX_EMIF_BASE, SZ_32K);
@@ -340,6 +330,16 @@ static int __init am33xx_map_emif(void)
 	return 0;
 }
 
+static int __init am43xx_map_scu(void)
+{
+	scu_base = ioremap(scu_a9_get_base(), SZ_256);
+
+	if (!scu_base)
+		return -ENOMEM;
+
+	return 0;
+}
+
 static int __init am33xx_setup_sleep_sequence(void)
 {
 	int ret;
@@ -397,30 +397,113 @@ cleanup_sleep:
 	return ret;
 }
 
+static int am33xx_suspend_init(void)
+{
+	gfx_l4ls_clkdm = clkdm_lookup("gfx_l4ls_gfx_clkdm");
+	l3s_clkdm = clkdm_lookup("l3s_clkdm");
+	l4fw_clkdm = clkdm_lookup("l4fw_clkdm");
+	clk_24mhz_clkdm = clkdm_lookup("clk_24mhz_clkdm");
+
+	if ((!gfx_l4ls_clkdm) || (!l3s_clkdm) || (!l4fw_clkdm) ||
+	    (!clk_24mhz_clkdm)) {
+		pr_err("PM: Cannot lookup clockdomains\n");
+		return -ENODEV;
+	}
+
+	/* Physical resume address to be used by ROM code */
+	am33xx_pm->ipc.reg0 = (AM33XX_OCMC_END -
+		am33xx_do_wfi_sz + am33xx_resume_offset + 0x4);
+
+	return 0;
+}
+
+static int am43xx_suspend_init(void)
+{
+	int ret = 0;
+	ret = am43xx_map_scu();
+	if (ret) {
+			pr_err("PM: Could not ioremap SCU\n");
+			return ret;
+	}
+
+	susp_params.l2_base_virt = omap4_get_l2cache_base();
+
+	/* Physical resume address to be used by ROM code */
+	am33xx_pm->ipc.reg0 = (AM33XX_OCMC_END -
+		am43xx_do_wfi_sz + am43xx_resume_offset + 0x4);
+
+	return ret;
+}
+
+static void am33xx_pre_suspend(unsigned int state)
+{
+	if (state == PM_SUSPEND_STANDBY) {
+		clkdm_wakeup(l3s_clkdm);
+		clkdm_wakeup(l4fw_clkdm);
+		clkdm_wakeup(clk_24mhz_clkdm);
+	}
+}
+
+static void am43xx_pre_suspend(unsigned int state)
+{
+	scu_power_mode(scu_base, SCU_PM_POWEROFF);
+}
+
+static void am33xx_post_suspend(unsigned int state)
+{
+	int status = 0;
+
+	status = pwrdm_read_pwrst(gfx_pwrdm);
+	if (status != PWRDM_POWER_OFF)
+		pr_err("GFX domain did not transition\n");
+
+	/*
+	 * BUG: GFX_L4LS clock domain needs to be woken up to
+	 * ensure thet L4LS clock domain does not get stuck in
+	 * transition. If that happens L3 module does not get
+	 * disabled, thereby leading to PER power domain
+	 * transition failing
+	 */
+	clkdm_wakeup(gfx_l4ls_clkdm);
+	clkdm_sleep(gfx_l4ls_clkdm);
+}
+
+static void am43xx_post_suspend(unsigned int state)
+{
+	scu_power_mode(scu_base, SCU_PM_NORMAL);
+}
+
+static struct am33xx_pm_ops am33xx_ops = {
+	.init = am33xx_suspend_init,
+	.pre_suspend = am33xx_pre_suspend,
+	.post_suspend = am33xx_post_suspend,
+};
+
+static struct am33xx_pm_ops am43xx_ops = {
+	.init = am43xx_suspend_init,
+	.pre_suspend = am43xx_pre_suspend,
+	.post_suspend = am43xx_post_suspend,
+};
+
 int __init am33xx_pm_init(void)
 {
 	int ret;
 	u32 temp;
 	struct device_node *np;
 
-	if (!soc_is_am33xx())
+	if (!soc_is_am33xx() && !soc_is_am43xx())
 		return -ENODEV;
 
 	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
 	per_pwrdm = pwrdm_lookup("per_pwrdm");
 	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
 
-	gfx_l4ls_clkdm = clkdm_lookup("gfx_l4ls_gfx_clkdm");
-	l3s_clkdm = clkdm_lookup("l3s_clkdm");
-	l4fw_clkdm = clkdm_lookup("l4fw_clkdm");
-	clk_24mhz_clkdm = clkdm_lookup("clk_24mhz_clkdm");
-
-	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm) || (!gfx_l4ls_clkdm) ||
-	    (!l3s_clkdm) || (!l4fw_clkdm) || (!clk_24mhz_clkdm)) {
+	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm)) {
 		ret = -ENODEV;
 		goto err;
 	}
 
+
 	am33xx_pm = kzalloc(sizeof(*am33xx_pm), GFP_KERNEL);
 	if (!am33xx_pm) {
 		pr_err("Memory allocation failed\n");
@@ -428,6 +511,21 @@ int __init am33xx_pm_init(void)
 		return ret;
 	}
 
+	/*
+	 * Code paths for each SoC are nearly the same but set ops
+	 * handle differences during init, pre-suspend, and post-suspend
+	 */
+
+	if (soc_is_am33xx())
+		am33xx_pm->ops = &am33xx_ops;
+	else if (soc_is_am43xx())
+		am33xx_pm->ops = &am43xx_ops;
+
+	ret = am33xx_pm->ops->init();
+
+	if (ret)
+		goto err;
+
 	ret = am33xx_map_emif();
 	if (ret) {
 		pr_err("PM: Could not ioremap EMIF\n");
@@ -482,10 +580,6 @@ int __init am33xx_pm_init(void)
 	if (wkup_m3_is_valid())
 		am33xx_m3_fw_ready_cb();
 
-	/* Physical resume address to be used by ROM code */
-	am33xx_pm->ipc.reg0 = (AM33XX_OCMC_END -
-		am33xx_do_wfi_sz + am33xx_resume_offset + 0x4);
-
 	return 0;
 
 err:
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index f0210d1..73f42a0 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -20,10 +20,17 @@
 
 #ifndef __ASSEMBLER__
 
+struct am33xx_pm_ops {
+	int (*init)(void);
+	void (*pre_suspend)(unsigned int state);
+	void (*post_suspend)(unsigned int state);
+};
+
 struct am33xx_pm_context {
 	struct am33xx_ipc_regs	ipc;
 	struct firmware		*firmware;
 	struct omap_mbox	*mbox;
+	struct am33xx_pm_ops	*ops;
 	u8			state;
 	u32			ver;
 };
@@ -39,6 +46,7 @@ struct am33xx_suspend_params {
 	void __iomem *emif_addr_virt;
 	u32 mem_type;
 	void __iomem *dram_sync;
+	void __iomem *l2_base_virt;
 };
 
 void wkup_m3_reset_data_pos(void);
diff --git a/arch/arm/mach-omap2/sram.h b/arch/arm/mach-omap2/sram.h
index 24788b5..234ce10 100644
--- a/arch/arm/mach-omap2/sram.h
+++ b/arch/arm/mach-omap2/sram.h
@@ -63,9 +63,11 @@ extern unsigned long omap3_sram_configure_core_dpll_sz;
 #ifdef CONFIG_PM
 extern void omap_push_sram_idle(void);
 extern void am33xx_push_sram_idle(void);
+extern void am43xx_push_sram_idle(void);
 #else
 static inline void omap_push_sram_idle(void) {}
 static inline void am33xx_push_sram_idle(void) {}
+static inline void am43xx_push_sram_idle(void) {}
 #endif /* CONFIG_PM */
 
 #endif /* __ASSEMBLY__ */
-- 
1.7.5.4

