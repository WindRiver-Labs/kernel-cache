From 12e93fcac63df199536fe11f0cb860ac21326774 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Fri, 6 Dec 2013 13:09:18 -0600
Subject: [PATCH 0791/1115] opp-modifier: Add ti,efuse-bit-enable-low property

Certain SoCs have an eFuse with bits that are set to indicate available
OPPs and others have an eFuse with bits that are cleared to indicate
available OPPs so make this configurable in DT to allow support for
additional parts.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit 3af5ed52e392854143193aefda828af976ddcd51)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/power/opp-modifier.txt     |    4 ++++
 drivers/power/opp/omap-opp-control.c               |   10 +++++++++-
 2 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/Documentation/devicetree/bindings/power/opp-modifier.txt b/Documentation/devicetree/bindings/power/opp-modifier.txt
index a1481f4..85aaefb 100644
--- a/Documentation/devicetree/bindings/power/opp-modifier.txt
+++ b/Documentation/devicetree/bindings/power/opp-modifier.txt
@@ -12,6 +12,10 @@ properties:
 - reg : Address and length of the registers needed to identify available
 	OPPs, here we provide efuse_sma address and device_id address
 
+Optional Properties:
+- ti,efuse-bit-enable-low: Take the complement of efuse before comparing mask
+		     defined below under opp-modifier.
+
 Sub-nodes:
 Sub-nodes are defined as a container to hold opp modifier table for a
 specific device with an operating-points table already defined
diff --git a/drivers/power/opp/omap-opp-control.c b/drivers/power/opp/omap-opp-control.c
index 252e4a8..be52e44 100644
--- a/drivers/power/opp/omap-opp-control.c
+++ b/drivers/power/opp/omap-opp-control.c
@@ -39,6 +39,7 @@ struct opp_efuse_context {
 	struct device   *dev;
 	void __iomem    *efuse;
 	void __iomem	*id;
+	bool		enable_low;
 };
 
 static struct opp_efuse_context *opp_efuse;
@@ -104,8 +105,11 @@ static int of_opp_check_availability(struct device *dev, struct device_node *np)
 
 		efuse_val = opp_omap_efuse_read(offset);
 
+		if (opp_efuse->enable_low)
+			efuse_val = ~efuse_val;
+
 		if (OPP_REV_CMP(rev, am33xx_devrev_to_opp_rev(rev_id))) {
-			if (((~efuse_val & bit) || !bit))
+			if (((efuse_val & bit) || !bit))
 				opp_enable(dev, freq);
 		}
 	}
@@ -147,6 +151,7 @@ static struct opp_modifier_dev omap_opp_modifier_dev = {
 static int opp_omap_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+	struct device_node *np = pdev->dev.of_node;
 	int ret = 0;
 
 	opp_efuse = devm_kzalloc(&pdev->dev, sizeof(*opp_efuse), GFP_KERNEL);
@@ -190,6 +195,9 @@ static int opp_omap_probe(struct platform_device *pdev)
 	rev_id = (readl(opp_efuse->id) & AM33XX_CTRL_DEVICE_ID_DEVREV_MASK)
 		  >> AM33XX_CTRL_DEVICE_ID_DEVREV_SHIFT;
 
+	if (of_get_property(np, "ti,efuse-bit-enable-low", NULL))
+		opp_efuse->enable_low = true;
+
 	omap_opp_modifier_dev.ops = &omap_opp_ops;
 	omap_opp_modifier_dev.of_node = pdev->dev.of_node;
 
-- 
1.7.5.4

