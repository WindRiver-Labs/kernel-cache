From 083668e4bdbfc0cf751c04c739620d2275059e3e Mon Sep 17 00:00:00 2001
From: Russ Dill <Russ.Dill@ti.com>
Date: Tue, 12 Nov 2013 17:22:33 -0600
Subject: [PATCH 0652/1115] ARM: OMAP2+: AM33XX: toggle to exit self refresh
 in resume from from deep sleep

When the device is in DS0, all EMIF context is lost. When the device
wakes and the EMIF clock is reenabled, the EMIF registers will be at
their default state. So we must get the EMIF back into the state it
was in during self-refresh.

When we wakeup, we restore POWER_MGMT_CTRL back to a lp_mode=2 (which
is self-refresh), then you write a lp_mode=0 to get it out of self
refresh and finally restore the original setting with which we enter
into suspend path.

As part of the change - dont use r0 as scratchpad for delay loop since
it stores the base address for emif

[nm@ti.com: minor edits and changelog]
Signed-off-by: Nishanth Menon <nm@ti.com>
Signed-off-by: Russ Dill <Russ.Dill@ti.com>
(cherry picked from commit bdf39c63366cc4552d687c196038f7286c9ac1bd)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/sleep33xx.S |   25 +++++++++++++++++++++----
 1 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
index 1ed8c87..311ea64 100644
--- a/arch/arm/mach-omap2/sleep33xx.S
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -269,10 +269,23 @@ wait_emif_enable1:
 	ldr	r1, emif_ref_ctrl_val
 	str	r1, [r0, #EMIF_SDRAM_REFRESH_CONTROL]
 	str	r1, [r0, #EMIF_SDRAM_REFRESH_CTRL_SHDW]
-	ldr	r1, emif_pmcr_val
-	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
+
 	ldr	r1, emif_pmcr_shdw_val
 	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CTRL_SHDW]
+	/*
+	 * Toggle EMIF to exit refresh mode:
+	 * if EMIF lost context, PWR_MGT_CTRL is currently 0, writing disable
+	 *   (0x0), wont do diddly squat! so do a toggle from SR(0x2) to disable
+	 *   (0x0) here.
+	 * *If* EMIF did not loose context, nothing broken as we write the same
+	 *   value(0x2) to reg before we write a disable (0x0).
+	 */
+	ldr	r1, emif_pmcr_val
+	bic	r1, r1, #EMIF_POWER_MGMT_SELF_REFRESH_MODE_MASK
+	orr	r1, r1, #EMIF_POWER_MGMT_SELF_REFRESH_MODE
+	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
+	bic	r1, r1, #EMIF_POWER_MGMT_SELF_REFRESH_MODE_MASK
+	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
 
 	/*
 	 * Output impedence calib needed only for DDR3
@@ -298,11 +311,15 @@ wait_emif_enable1:
 
 resume_to_ddr:
 	/* EMIF needs some time before read/write possible */
-	mov	r0, #EMIF_POWER_MGMT_DELAY_PERIOD
+	mov	r1, #EMIF_POWER_MGMT_DELAY_PERIOD
 wait_resume:
-	subs	r0, r0, #1
+	subs	r1, r1, #1
 	bne	wait_resume
 
+	/* All done.. so restore back enter into suspend configuration */
+	ldr	r1, emif_pmcr_val
+	str	r1, [r0, #EMIF_POWER_MANAGEMENT_CONTROL]
+
 	/* We are back. Branch to the common CPU resume routine */
 	mov	r0, #0
 	ldr	pc, resume_addr
-- 
1.7.5.4

