From 826eb7075f17183ae93a267c3317a304548e43fa Mon Sep 17 00:00:00 2001
From: Jeff Lance <j-lance1@ti.com>
Date: Wed, 11 Dec 2013 15:30:18 +0100
Subject: [PATCH 0107/1115] iio: ti_am335x_adc: Poll fifo1Thresh interrupt
 instead of ADCStatus for idle

The ADCSTATUS register can not be polled while waiting for idle while
the TSC is used because it might happen that the sequencer never gets
idle leading to -EBUSY.
Instead we setup the FIFO threshold and wait for it to fill. The wait
period takes about 500us. If we reduce the number of slots to process to
only one because we only interrested into one entry then the wait
perioud is reduced to approx. 125us.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Signed-off-by: Jeff Lance <j-lance1@ti.com>
(cherry picked from commit bba5733c26820332798a92ba525ae03466cf6d94)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/iio/adc/ti_am335x_adc.c      |   41 +++++++++++++++++++++++++++++----
 drivers/mfd/ti_am335x_tscadc.c       |   33 ++++++++++++++++++++++++---
 include/linux/mfd/ti_am335x_tscadc.h |    4 +++
 3 files changed, 69 insertions(+), 9 deletions(-)

diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c
index 4a8607e..95b43e9 100644
--- a/drivers/iio/adc/ti_am335x_adc.c
+++ b/drivers/iio/adc/ti_am335x_adc.c
@@ -56,6 +56,24 @@ static u32 get_adc_step_mask(struct tiadc_device *adc_dev)
 	return step_en;
 }
 
+static u32 get_adc_chan_step_mask(struct tiadc_device *adc_dev,
+		struct iio_chan_spec const *chan)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(adc_dev->channel_step); i++) {
+		if (chan->channel == adc_dev->channel_line[i]) {
+			u32 step;
+
+			step = adc_dev->channel_step[i];
+			/* +1 for the charger */
+			return 1 << (step + 1);
+		}
+	}
+	WARN_ON(1);
+	return 0;
+}
+
 static void tiadc_step_config(struct tiadc_device *adc_dev)
 {
 	unsigned int stepconfig;
@@ -147,13 +165,19 @@ static int tiadc_read_raw(struct iio_dev *indio_dev,
 	u32 step_en;
 	unsigned long timeout = jiffies + usecs_to_jiffies
 				(IDLE_TIMEOUT * adc_dev->channels);
-	step_en = get_adc_step_mask(adc_dev);
+
+	step_en = get_adc_chan_step_mask(adc_dev, chan);
+	if (!step_en)
+		return -EINVAL;
+
 	am335x_tsc_se_set_once(adc_dev->mfd_tscadc, step_en);
 
-	/* Wait for ADC sequencer to complete sampling */
-	while (tiadc_readl(adc_dev, REG_ADCFSM) & SEQ_STATUS) {
-		if (time_after(jiffies, timeout))
+	/* Wait for Fifo threshold interrupt */
+	while (!(tiadc_readl(adc_dev, REG_RAWIRQSTATUS) & IRQENB_FIFO1THRES)) {
+		if (time_after(jiffies, timeout)) {
+			am335x_tsc_se_adc_done(adc_dev->mfd_tscadc);
 			return -EAGAIN;
+		}
 	}
 	map_val = chan->channel + TOTAL_CHANNELS;
 
@@ -174,8 +198,10 @@ static int tiadc_read_raw(struct iio_dev *indio_dev,
 			break;
 		}
 	}
-	if (WARN_ON_ONCE(step == UINT_MAX))
+	if (WARN_ON_ONCE(step == UINT_MAX)) {
+		am335x_tsc_se_adc_done(adc_dev->mfd_tscadc);
 		return -EINVAL;
+	}
 
 	fifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);
 	for (i = 0; i < fifo1count; i++) {
@@ -190,8 +216,12 @@ static int tiadc_read_raw(struct iio_dev *indio_dev,
 		}
 	}
 
+	tiadc_writel(adc_dev, REG_IRQSTATUS, IRQENB_FIFO1THRES);
+	am335x_tsc_se_adc_done(adc_dev->mfd_tscadc);
+
 	if (found == false)
 		return -EBUSY;
+
 	return IIO_VAL_INT;
 }
 
@@ -238,6 +268,7 @@ static int tiadc_probe(struct platform_device *pdev)
 	indio_dev->info = &tiadc_info;
 
 	tiadc_step_config(adc_dev);
+	tiadc_writel(adc_dev, REG_FIFO1THR, 1 - 1);
 
 	err = tiadc_channel_init(indio_dev, adc_dev->channels);
 	if (err < 0)
diff --git a/drivers/mfd/ti_am335x_tscadc.c b/drivers/mfd/ti_am335x_tscadc.c
index c4c1a1a..7a0a4ad 100644
--- a/drivers/mfd/ti_am335x_tscadc.c
+++ b/drivers/mfd/ti_am335x_tscadc.c
@@ -50,7 +50,16 @@ static const struct regmap_config tscadc_regmap_config = {
 
 void am335x_tsc_se_update(struct ti_tscadc_dev *tsadc, u32 val)
 {
-	tscadc_writel(tsadc, REG_SE, tsadc->reg_se_cache | val);
+	unsigned long flags;
+
+	spin_lock_irqsave(&tsadc->reg_lock, flags);
+	if (tsadc->adc_pending) {
+		tsadc->tsc_pending = true;
+		tsadc->pending_tsc_val = val;
+	} else {
+		tscadc_writel(tsadc, REG_SE, tsadc->reg_se_cache | val);
+	}
+	spin_unlock_irqrestore(&tsadc->reg_lock, flags);
 }
 EXPORT_SYMBOL_GPL(am335x_tsc_se_update);
 
@@ -60,8 +69,8 @@ void am335x_tsc_se_set_cont(struct ti_tscadc_dev *tsadc, u32 val)
 
 	spin_lock_irqsave(&tsadc->reg_lock, flags);
 	tsadc->reg_se_cache |= val;
-	am335x_tsc_se_update(tsadc, 0);
 	spin_unlock_irqrestore(&tsadc->reg_lock, flags);
+	am335x_tsc_se_update(tsadc, 0);
 }
 EXPORT_SYMBOL_GPL(am335x_tsc_se_set_cont);
 
@@ -70,19 +79,35 @@ void am335x_tsc_se_set_once(struct ti_tscadc_dev *tsadc, u32 val)
 	unsigned long flags;
 
 	spin_lock_irqsave(&tsadc->reg_lock, flags);
-	am335x_tsc_se_update(tsadc, val);
+	tsadc->adc_pending = true;
+	tscadc_writel(tsadc, REG_SE, tsadc->reg_se_cache | val);
 	spin_unlock_irqrestore(&tsadc->reg_lock, flags);
 }
 EXPORT_SYMBOL_GPL(am335x_tsc_se_set_once);
 
+void am335x_tsc_se_adc_done(struct ti_tscadc_dev *tsadc)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tsadc->reg_lock, flags);
+	tsadc->adc_pending = false;
+	if (tsadc->tsc_pending) {
+		tsadc->tsc_pending = false;
+		tscadc_writel(tsadc, REG_SE, tsadc->reg_se_cache |
+				tsadc->pending_tsc_val);
+	}
+	spin_unlock_irqrestore(&tsadc->reg_lock, flags);
+}
+EXPORT_SYMBOL_GPL(am335x_tsc_se_adc_done);
+
 void am335x_tsc_se_clr(struct ti_tscadc_dev *tsadc, u32 val)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&tsadc->reg_lock, flags);
 	tsadc->reg_se_cache &= ~val;
-	am335x_tsc_se_update(tsadc, 0);
 	spin_unlock_irqrestore(&tsadc->reg_lock, flags);
+	am335x_tsc_se_update(tsadc, 0);
 }
 EXPORT_SYMBOL_GPL(am335x_tsc_se_clr);
 
diff --git a/include/linux/mfd/ti_am335x_tscadc.h b/include/linux/mfd/ti_am335x_tscadc.h
index abfa067..8389d09 100644
--- a/include/linux/mfd/ti_am335x_tscadc.h
+++ b/include/linux/mfd/ti_am335x_tscadc.h
@@ -150,6 +150,9 @@ struct ti_tscadc_dev {
 	int adc_cell;	/* -1 if not used */
 	struct mfd_cell cells[TSCADC_CELLS];
 	u32 reg_se_cache;
+	u32 pending_tsc_val;
+	bool adc_pending;
+	bool tsc_pending;
 	spinlock_t reg_lock;
 
 	/* tsc device */
@@ -168,6 +171,7 @@ static inline struct ti_tscadc_dev *ti_tscadc_dev_get(struct platform_device *p)
 
 void am335x_tsc_se_update(struct ti_tscadc_dev *tsadc, u32 val);
 void am335x_tsc_se_set_cont(struct ti_tscadc_dev *tsadc, u32 val);
+void am335x_tsc_se_adc_done(struct ti_tscadc_dev *tsadc);
 void am335x_tsc_se_set_once(struct ti_tscadc_dev *tsadc, u32 val);
 void am335x_tsc_se_clr(struct ti_tscadc_dev *tsadc, u32 val);
 
-- 
1.7.5.4

