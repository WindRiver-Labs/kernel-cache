From ff4de60fcf17e74d1c893d9cc02bfa92e6edda19 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Sun, 6 Oct 2013 21:14:27 -0500
Subject: [PATCH 0568/1115] ARM: OMAP2+: AM33XX: Improve wkup_m3 firmware
 handling

Create a wkup_m3_ops structure to handle both the pm wkup_m3 interrupt
callback and now a callback in the pm code for firmware loading. Now the
suspend ops are registered only after the wkup_m3 firmware has been
loaded and the version validated to avoid warnings during attempted
suspend if the M3 can not actually provide suspend support.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit 550473f71f280bf2ebd6fdbc0745e99a8754f27f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/pm33xx.c  |   69 +++++++++++++++++++++++++++-------------
 arch/arm/mach-omap2/wkup_m3.c |   38 +++++++++++++---------
 arch/arm/mach-omap2/wkup_m3.h |   19 ++++++++++-
 3 files changed, 85 insertions(+), 41 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index a3f0d47..c88f879 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -157,7 +157,6 @@ static void am33xx_m3_state_machine_reset(void)
 		}
 	} else {
 		pr_warn("PM: Unable to ping CM3\n");
-		return -1;
 	}
 }
 
@@ -222,20 +221,12 @@ static const struct platform_suspend_ops am33xx_pm_ops = {
 };
 #endif /* CONFIG_SUSPEND */
 
-void am33xx_txev_handler(void)
+static void am33xx_txev_handler(void)
 {
 	switch (am33xx_pm->state) {
 	case M3_STATE_RESET:
 		am33xx_pm->state = M3_STATE_INITED;
-		am33xx_pm->ver = wkup_m3_fw_version_read();
-		if (am33xx_pm->ver == M3_VERSION_UNKNOWN ||
-			am33xx_pm->ver < M3_BASELINE_VERSION) {
-			pr_warn("PM: CM3 Firmware Version %x not supported\n",
-						am33xx_pm->ver);
-		} else {
-			pr_info("PM: CM3 Firmware Version = 0x%x\n",
-						am33xx_pm->ver);
-		}
+		complete(&am33xx_pm_sync);
 		break;
 	case M3_STATE_MSG_FOR_RESET:
 		am33xx_pm->state = M3_STATE_INITED;
@@ -251,6 +242,44 @@ void am33xx_txev_handler(void)
 	return;
 }
 
+static void am33xx_m3_fw_ready_cb(void)
+{
+	int ret = 0;
+
+	ret = wkup_m3_prepare();
+	if (ret) {
+		pr_err("PM: Could not prepare WKUP_M3\n");
+		return;
+	}
+
+	ret = wait_for_completion_timeout(&am33xx_pm_sync,
+					msecs_to_jiffies(500));
+
+	if (WARN(ret == 0, "PM: MPU<->CM3 sync failure\n"))
+		return;
+
+	am33xx_pm->ver = wkup_m3_fw_version_read();
+
+	if (am33xx_pm->ver == M3_VERSION_UNKNOWN ||
+		am33xx_pm->ver < M3_BASELINE_VERSION) {
+		pr_warn("PM: CM3 Firmware Version %x not supported\n",
+					am33xx_pm->ver);
+		return;
+	} else {
+		pr_info("PM: CM3 Firmware Version = 0x%x\n",
+					am33xx_pm->ver);
+	}
+
+#ifdef CONFIG_SUSPEND
+	suspend_set_ops(&am33xx_pm_ops);
+#endif /* CONFIG_SUSPEND */
+}
+
+static struct wkup_m3_ops am33xx_wkup_m3_ops = {
+	.txev_handler = am33xx_txev_handler,
+	.firmware_loaded = am33xx_m3_fw_ready_cb,
+};
+
 /*
  * Push the minimal suspend-resume code to SRAM
  */
@@ -320,26 +349,20 @@ int __init am33xx_pm_init(void)
 	else
 		pr_err("PM: Failed to get cefuse_pwrdm\n");
 
-	wkup_m3_fw_version_clear();
-
 	am33xx_pm->state = M3_STATE_RESET;
 
-	wkup_m3_register_txev_handler(am33xx_txev_handler);
+	wkup_m3_set_ops(&am33xx_wkup_m3_ops);
 
-	ret = wkup_m3_prepare();
-	if (ret) {
-		pr_err("PM: Could not prepare WKUP_M3\n");
-		return ret;
-	}
+	/* m3 may have already loaded but ops were not set yet,
+	 * manually invoke */
+
+	if (wkup_m3_is_valid())
+		am33xx_m3_fw_ready_cb();
 
 	/* Physical resume address to be used by ROM code */
 	am33xx_pm->ipc.reg0 = (AM33XX_OCMC_END -
 		am33xx_do_wfi_sz + am33xx_resume_offset + 0x4);
 
-#ifdef CONFIG_SUSPEND
-	suspend_set_ops(&am33xx_pm_ops);
-#endif /* CONFIG_SUSPEND */
-
 	return 0;
 
 err:
diff --git a/arch/arm/mach-omap2/wkup_m3.c b/arch/arm/mach-omap2/wkup_m3.c
index 08503f0..b3d7a9d 100644
--- a/arch/arm/mach-omap2/wkup_m3.c
+++ b/arch/arm/mach-omap2/wkup_m3.c
@@ -59,8 +59,8 @@ struct wkup_m3_context {
 	struct device	*dev;
 	void __iomem	*code;
 	void __iomem	*ipc;
-	u8				is_valid;
-	void (*txev_handler)(void);
+	u8		is_valid;
+	struct wkup_m3_ops *ops;
 	struct omap_mbox *mbox;
 };
 
@@ -135,15 +135,15 @@ static void am33xx_ctrl_ipc_read(struct am33xx_ipc_regs *ipc_regs)
 					+ AM33XX_CONTROL_IPC_MSG_REG7);
 }
 
+int wkup_m3_is_valid()
+{
+	return wkup_m3->is_valid;
+}
+
 int wkup_m3_ping(void)
 {
 	int ret = 0;
 
-	if (!wkup_m3->is_valid) {
-		pr_err("PM: No M3 Firmware has been loaded.\n");
-		return -EIO;
-	}
-
 	if (!wkup_m3->mbox) {
 		pr_err("PM: No IPC channel to communicate with wkup_m3!\n");
 		return -EIO;
@@ -197,7 +197,7 @@ int wkup_m3_pm_status(void)
  * register (ipc_regs + 0x8).
  */
 
-void wkup_m3_fw_version_clear(void)
+static void wkup_m3_fw_version_clear(void)
 {
 	struct am33xx_ipc_regs ipc_regs;
 
@@ -222,16 +222,17 @@ void wkup_m3_pm_set_cmd(struct am33xx_ipc_regs *ipc_regs)
 	am33xx_ctrl_ipc_write(ipc_regs);
 }
 
-void wkup_m3_register_txev_handler(void (*txev_handler)(void))
+void wkup_m3_set_ops(struct wkup_m3_ops *ops)
 {
-	wkup_m3->txev_handler = txev_handler;
+	wkup_m3->ops = ops;
 }
 
 static irqreturn_t wkup_m3_txev_handler(int irq, void *unused)
 {
 	am33xx_txev_eoi();
 
-	wkup_m3->txev_handler();
+	if (wkup_m3->ops && wkup_m3->ops->firmware_loaded)
+		wkup_m3->ops->txev_handler();
 
 	am33xx_txev_enable();
 
@@ -251,6 +252,8 @@ int wkup_m3_prepare(void)
 		return ret;
 	}
 
+	wkup_m3_fw_version_clear();
+
 	/* check that the code is loaded */
 	ret = omap_device_deassert_hardreset(pdev, "wkup_m3");
 
@@ -279,10 +282,14 @@ static void wkup_m3_firmware_cb(const struct firmware *fw, void *context)
 
 	ret = wkup_m3_copy_code(fw->data, fw->size);
 
-	if (ret)
+	if (ret) {
 		pr_info("PM: Failed to copy firmware for M3");
-	else
+	} else {
+		if (wkup_m3->ops && wkup_m3->ops->firmware_loaded)
+			wkup_m3->ops->firmware_loaded();
+
 		wkup_m3->is_valid = true;
+	}
 
 	return;
 }
@@ -351,11 +358,10 @@ static int wkup_m3_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	pr_info("PM: Loading am335x-pm-firmware.bin");
-
-	/* first make sure is_valid flag is false */
 	wkup_m3->is_valid = false;
 
+	pr_info("PM: Loading am335x-pm-firmware.bin");
+
 	/* We don't want to delay boot */
 	ret = request_firmware_nowait(THIS_MODULE, 0, "am335x-pm-firmware.bin",
 				&pdev->dev, GFP_KERNEL, NULL,
diff --git a/arch/arm/mach-omap2/wkup_m3.h b/arch/arm/mach-omap2/wkup_m3.h
index 56b2c66..2fe60d0 100644
--- a/arch/arm/mach-omap2/wkup_m3.h
+++ b/arch/arm/mach-omap2/wkup_m3.h
@@ -16,6 +16,21 @@
 
 #ifndef __ASSEMBLER__
 
+/**
+ * struct wkup_m3_ops - Callbacks for allowing pm code to interact with wkup_m3.
+ *
+ * @txev_handler: Callback to allow pm code to react to response from wkup_m3
+ *		  after pinging it using wkup_m3_ping.
+ *
+ * @firmware_loaded: Callback invoked when the firmware has been loaded to the
+ *		     m3 to allow the pm code to enable suspend/resume ops.
+ */
+
+struct wkup_m3_ops {
+	void (*txev_handler)(void);
+	void (*firmware_loaded)(void);
+};
+
 struct wkup_m3_wakeup_src {
 	int irq_nr;
 	char src[10];
@@ -33,11 +48,11 @@ struct am33xx_ipc_regs {
 };
 
 int wkup_m3_prepare(void);
-void wkup_m3_register_txev_handler(void (*txev_handler)(void));
+void wkup_m3_set_ops(struct wkup_m3_ops *ops);
 int wkup_m3_ping(void);
 struct wkup_m3_wakeup_src wkup_m3_wake_src(void);
 int wkup_m3_pm_status(void);
-void wkup_m3_fw_version_clear(void);
+int wkup_m3_is_valid(void);
 int wkup_m3_fw_version_read(void);
 void wkup_m3_pm_set_cmd(struct am33xx_ipc_regs *ipc_regs);
 
-- 
1.7.5.4

