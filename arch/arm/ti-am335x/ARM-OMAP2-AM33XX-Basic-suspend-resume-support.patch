From 2f12cc3c87bd3636f07d876bc354fe4d1c22709b Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Sun, 6 Oct 2013 21:14:24 -0500
Subject: [PATCH 0566/1115] ARM: OMAP2+: AM33XX: Basic suspend resume support

AM335x supports various low power modes as documented
in section 8.1.4.3 of the AM335x TRM which is available
@ http://www.ti.com/litv/pdf/spruh73i

DeepSleep0 mode offers the lowest power mode with limited
wakeup sources without a system reboot and is mapped as
the suspend state in the kernel. In this state, MPU and
PER domains are turned off with the internal RAM held in
retention to facilitate resume process. As part of
the boot process, the assembly code is copied over to OCMCRAM
using the OMAP SRAM code.

AM335x has a Cortex-M3 (WKUP_M3) which assists the MPU
in DeepSleep0 and Standby entry and exit. WKUP_M3 takes care
of the clockdomain and powerdomain transitions based on the
intended low power state. MPU needs to load the appropriate
WKUP_M3 binary onto the WKUP_M3 memory space before it can
leverage any of the PM features like DeepSleep.

The IPC mechanism between MPU and WKUP_M3 uses a mailbox
sub-module and 8 IPC registers in the Control module. MPU
uses the assigned Mailbox for issuing an interrupt to
WKUP_M3 which then goes and checks the IPC registers for
the payload. WKUP_M3 has the ability to trigger an interrupt
to MPU by executing the "sev" instruction.

In the current implementation when the suspend process
is initiated, MPU interrupts the WKUP_M3 to let it know about
the intent of entering DeepSleep0 and waits for an ACK. When
the ACK is received MPU continues with its suspend process
to suspend all the drivers and then jumps to assembly in
OCMC RAM. The assembly code  puts the external RAM in self-refresh
mode and then finally execute the WFI instruction. Execution of the
WFI instruction triggers another interrupt to the WKUP_M3 which then
continues with the power down sequence wherein the clockdomain and
powerdomain transition takes place. As part of the sleep sequence,
WKUP_M3 unmasks the interrupt lines for the wakeup sources. WFI
execution on WKUP_M3 causes the hardware to disable the main
oscillator of the SoC.

When a wakeup event occurs, WKUP_M3 starts the power-up
sequence by switching on the power domains and finally
enabling the clock to MPU. Since the MPU gets powered down
as part of the sleep sequence in the resume path ROM code
starts executing. The ROM code detects a wakeup from sleep
and then jumps to the resume location in OCMC which was
populated in one of the IPC registers as part of the suspend
sequence.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit 40cc485935158d68df2a87d09f1d992f65310c92)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/pm33xx.c  |  348 +++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/pm33xx.h  |   76 ++++++++
 arch/arm/mach-omap2/wkup_m3.c |  404 +++++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/wkup_m3.h |   45 +++++
 4 files changed, 873 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-omap2/pm33xx.c
 create mode 100644 arch/arm/mach-omap2/pm33xx.h
 create mode 100644 arch/arm/mach-omap2/wkup_m3.c
 create mode 100644 arch/arm/mach-omap2/wkup_m3.h

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
new file mode 100644
index 0000000..a3f0d47
--- /dev/null
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -0,0 +1,348 @@
+/*
+ * AM33XX Power Management Routines
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ * Vaibhav Bedia <vaibhav.bedia@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/cpu.h>
+#include <linux/err.h>
+#include <linux/firmware.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+#include <linux/completion.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ti_emif.h>
+#include <linux/omap-mailbox.h>
+
+#include <asm/suspend.h>
+#include <asm/proc-fns.h>
+#include <asm/sizes.h>
+#include <asm/fncpy.h>
+#include <asm/system_misc.h>
+
+#include "pm.h"
+#include "cm33xx.h"
+#include "pm33xx.h"
+#include "common.h"
+#include "clockdomain.h"
+#include "powerdomain.h"
+#include "soc.h"
+#include "sram.h"
+
+static void __iomem *am33xx_emif_base;
+static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm, *mpu_pwrdm;
+static struct clockdomain *gfx_l4ls_clkdm;
+
+static struct am33xx_pm_context *am33xx_pm;
+
+static DECLARE_COMPLETION(am33xx_pm_sync);
+
+static void (*am33xx_do_wfi_sram)(struct am33xx_suspend_params *);
+
+static struct am33xx_suspend_params susp_params;
+
+#ifdef CONFIG_SUSPEND
+
+static int am33xx_do_sram_idle(long unsigned int unused)
+{
+	am33xx_do_wfi_sram(&susp_params);
+	return 0;
+}
+
+static int am33xx_pm_suspend(void)
+{
+	int i, ret = 0;
+	int status = 0;
+	struct wkup_m3_wakeup_src wakeup_src;
+
+	/* Try to put GFX to sleep */
+	omap_set_pwrdm_state(gfx_pwrdm, PWRDM_POWER_OFF);
+
+	ret = cpu_suspend(0, am33xx_do_sram_idle);
+
+	status = pwrdm_read_pwrst(gfx_pwrdm);
+	if (status != PWRDM_POWER_OFF)
+		pr_err("PM: GFX domain did not transition\n");
+
+	/*
+	 * BUG: GFX_L4LS clock domain needs to be woken up to
+	 * ensure thet L4LS clock domain does not get stuck in transition
+	 * If that happens L3 module does not get disabled, thereby leading
+	 * to PER power domain transition failing
+	 */
+	clkdm_wakeup(gfx_l4ls_clkdm);
+	clkdm_sleep(gfx_l4ls_clkdm);
+
+	if (ret) {
+		pr_err("PM: Kernel suspend failure\n");
+	} else {
+		i = wkup_m3_pm_status();
+		switch (i) {
+		case 0:
+			pr_info("PM: Successfully put all powerdomains to target state\n");
+
+			/*
+			 * The PRCM registers on AM335x do not contain
+			 * previous state information like those present on
+			 * OMAP4 so we must manually indicate transition so
+			 * state counters are properly incremented
+			 */
+			pwrdm_post_transition(mpu_pwrdm);
+			pwrdm_post_transition(per_pwrdm);
+			break;
+		case 1:
+			pr_err("PM: Could not transition all powerdomains to target state\n");
+			ret = -1;
+			break;
+		default:
+			pr_err("PM: CM3 returned unknown result = %d\n", i);
+			ret = -1;
+		}
+		/* print the wakeup reason */
+		wakeup_src = wkup_m3_wake_src();
+
+		pr_info("PM: Wakeup source %s\n", wakeup_src.src);
+	}
+
+	return ret;
+}
+
+static int am33xx_pm_enter(suspend_state_t suspend_state)
+{
+	int ret = 0;
+
+	switch (suspend_state) {
+	case PM_SUSPEND_MEM:
+		ret = am33xx_pm_suspend();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+
+static void am33xx_m3_state_machine_reset(void)
+{
+	int i;
+
+	am33xx_pm->ipc.reg1 = IPC_CMD_RESET;
+
+	wkup_m3_pm_set_cmd(&am33xx_pm->ipc);
+
+	am33xx_pm->state = M3_STATE_MSG_FOR_RESET;
+
+	if (!wkup_m3_ping()) {
+		i = wait_for_completion_timeout(&am33xx_pm_sync,
+					msecs_to_jiffies(500));
+		if (!i) {
+			WARN(1, "PM: MPU<->CM3 sync failure\n");
+			am33xx_pm->state = M3_STATE_UNKNOWN;
+		}
+	} else {
+		pr_warn("PM: Unable to ping CM3\n");
+		return -1;
+	}
+}
+
+static int am33xx_pm_begin(suspend_state_t state)
+{
+	int i;
+
+	cpu_idle_poll_ctrl(true);
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		am33xx_pm->ipc.reg1	= IPC_CMD_DS0;
+		break;
+	}
+
+	am33xx_pm->ipc.reg2		= DS_IPC_DEFAULT;
+	am33xx_pm->ipc.reg3		= DS_IPC_DEFAULT;
+
+	wkup_m3_pm_set_cmd(&am33xx_pm->ipc);
+
+	am33xx_pm->state = M3_STATE_MSG_FOR_LP;
+
+	if (!wkup_m3_ping()) {
+		i = wait_for_completion_timeout(&am33xx_pm_sync,
+					msecs_to_jiffies(500));
+		if (!i) {
+			WARN(1, "PM: MPU<->CM3 sync failure\n");
+			return -1;
+		}
+	} else {
+		pr_warn("PM: Unable to ping CM3\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void am33xx_pm_end(void)
+{
+	am33xx_m3_state_machine_reset();
+
+	cpu_idle_poll_ctrl(false);
+
+	return;
+}
+
+static int am33xx_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static const struct platform_suspend_ops am33xx_pm_ops = {
+	.begin		= am33xx_pm_begin,
+	.end		= am33xx_pm_end,
+	.enter		= am33xx_pm_enter,
+	.valid		= am33xx_pm_valid,
+};
+#endif /* CONFIG_SUSPEND */
+
+void am33xx_txev_handler(void)
+{
+	switch (am33xx_pm->state) {
+	case M3_STATE_RESET:
+		am33xx_pm->state = M3_STATE_INITED;
+		am33xx_pm->ver = wkup_m3_fw_version_read();
+		if (am33xx_pm->ver == M3_VERSION_UNKNOWN ||
+			am33xx_pm->ver < M3_BASELINE_VERSION) {
+			pr_warn("PM: CM3 Firmware Version %x not supported\n",
+						am33xx_pm->ver);
+		} else {
+			pr_info("PM: CM3 Firmware Version = 0x%x\n",
+						am33xx_pm->ver);
+		}
+		break;
+	case M3_STATE_MSG_FOR_RESET:
+		am33xx_pm->state = M3_STATE_INITED;
+		complete(&am33xx_pm_sync);
+		break;
+	case M3_STATE_MSG_FOR_LP:
+		complete(&am33xx_pm_sync);
+		break;
+	case M3_STATE_UNKNOWN:
+		pr_warn("PM: Unknown CM3 State\n");
+	}
+
+	return;
+}
+
+/*
+ * Push the minimal suspend-resume code to SRAM
+ */
+void am33xx_push_sram_idle(void)
+{
+	am33xx_do_wfi_sram = (void *)omap_sram_push
+					(am33xx_do_wfi, am33xx_do_wfi_sz);
+}
+
+static int __init am33xx_map_emif(void)
+{
+	am33xx_emif_base = ioremap(AM33XX_EMIF_BASE, SZ_32K);
+
+	if (!am33xx_emif_base)
+		return -ENOMEM;
+
+	return 0;
+}
+
+int __init am33xx_pm_init(void)
+{
+	int ret;
+	u32 temp;
+
+	if (!soc_is_am33xx())
+		return -ENODEV;
+
+	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
+	per_pwrdm = pwrdm_lookup("per_pwrdm");
+	mpu_pwrdm = pwrdm_lookup("mpu_pwrdm");
+
+	gfx_l4ls_clkdm = clkdm_lookup("gfx_l4ls_gfx_clkdm");
+
+	if ((!gfx_pwrdm) || (!per_pwrdm) || (!mpu_pwrdm) || (!gfx_l4ls_clkdm)) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	am33xx_pm = kzalloc(sizeof(*am33xx_pm), GFP_KERNEL);
+	if (!am33xx_pm) {
+		pr_err("Memory allocation failed\n");
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	ret = am33xx_map_emif();
+	if (ret) {
+		pr_err("PM: Could not ioremap EMIF\n");
+		goto err;
+	}
+
+	/* Determine Memory Type */
+	temp = readl(am33xx_emif_base + EMIF_SDRAM_CONFIG);
+	temp = (temp & SDRAM_TYPE_MASK) >> SDRAM_TYPE_SHIFT;
+	/* Parameters to pass to aseembly code */
+	susp_params.emif_addr_virt = am33xx_emif_base;
+	susp_params.dram_sync = am33xx_dram_sync;
+	susp_params.mem_type = temp;
+	am33xx_pm->ipc.reg4 = temp;
+
+	(void) clkdm_for_each(omap_pm_clkdms_setup, NULL);
+
+	/* CEFUSE domain can be turned off post bootup */
+	cefuse_pwrdm = pwrdm_lookup("cefuse_pwrdm");
+	if (cefuse_pwrdm)
+		omap_set_pwrdm_state(cefuse_pwrdm, PWRDM_POWER_OFF);
+	else
+		pr_err("PM: Failed to get cefuse_pwrdm\n");
+
+	wkup_m3_fw_version_clear();
+
+	am33xx_pm->state = M3_STATE_RESET;
+
+	wkup_m3_register_txev_handler(am33xx_txev_handler);
+
+	ret = wkup_m3_prepare();
+	if (ret) {
+		pr_err("PM: Could not prepare WKUP_M3\n");
+		return ret;
+	}
+
+	/* Physical resume address to be used by ROM code */
+	am33xx_pm->ipc.reg0 = (AM33XX_OCMC_END -
+		am33xx_do_wfi_sz + am33xx_resume_offset + 0x4);
+
+#ifdef CONFIG_SUSPEND
+	suspend_set_ops(&am33xx_pm_ops);
+#endif /* CONFIG_SUSPEND */
+
+	return 0;
+
+err:
+	kfree(am33xx_pm);
+	return ret;
+}
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
new file mode 100644
index 0000000..0efb5a6
--- /dev/null
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -0,0 +1,76 @@
+/*
+ * AM33XX Power Management Routines
+ *
+ * Copyright (C) 2012 Texas Instruments Inc.
+ * Vaibhav Bedia <vaibhav.bedia@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __ARCH_ARM_MACH_OMAP2_PM33XX_H
+#define __ARCH_ARM_MACH_OMAP2_PM33XX_H
+
+#include "wkup_m3.h"
+
+#ifndef __ASSEMBLER__
+
+struct am33xx_pm_context {
+	struct am33xx_ipc_regs	ipc;
+	struct firmware		*firmware;
+	struct omap_mbox	*mbox;
+	u8			state;
+	u32			ver;
+};
+
+/*
+ * Params passed to suspend routine
+ *
+ * These are used to load into registers by suspend code,
+ * entries here must always be in sync with the suspend code
+ * in arm/mach-omap2/sleep33xx.S
+ */
+struct am33xx_suspend_params {
+	void __iomem *emif_addr_virt;
+	u32 mem_type;
+	void __iomem *dram_sync;
+};
+
+
+#endif
+
+#define	IPC_CMD_DS0				0x4
+#define IPC_CMD_RESET           0xe
+#define DS_IPC_DEFAULT			0xffffffff
+#define M3_VERSION_UNKNOWN		0x0000ffff
+#define M3_BASELINE_VERSION		0x21
+
+#define M3_STATE_UNKNOWN		0
+#define M3_STATE_RESET			1
+#define M3_STATE_INITED			2
+#define M3_STATE_MSG_FOR_LP		3
+#define M3_STATE_MSG_FOR_RESET	4
+
+#define AM33XX_OCMC_END			0x40310000
+#define AM33XX_EMIF_BASE		0x4C000000
+
+#define MEM_TYPE_DDR2		2
+
+/*
+ * 9-4 = VTT GPIO PIN (6 Bits)
+ *   3 = VTT Status (1 Bit)
+ * 2-0 = Memory Type (2 Bits)
+*/
+#define MEM_TYPE_SHIFT		(0x0)
+#define MEM_TYPE_MASK		(0x7 << 0)
+#define VTT_STAT_SHIFT		(0x3)
+#define VTT_STAT_MASK		(0x1 << 3)
+#define VTT_GPIO_PIN_SHIFT	(0x4)
+#define VTT_GPIO_PIN_MASK	(0x2f << 4)
+
+#endif
diff --git a/arch/arm/mach-omap2/wkup_m3.c b/arch/arm/mach-omap2/wkup_m3.c
new file mode 100644
index 0000000..08503f0
--- /dev/null
+++ b/arch/arm/mach-omap2/wkup_m3.c
@@ -0,0 +1,404 @@
+/*
+* AM33XX Power Management Routines
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ * Vaibhav Bedia <vaibhav.bedia@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/cpu.h>
+#include <linux/err.h>
+#include <linux/firmware.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/omap-mailbox.h>
+
+#include "pm33xx.h"
+#include "omap_device.h"
+
+#define WKUP_M3_WAKE_SRC_MASK			0xFF
+
+#define WKUP_M3_STATUS_RESP_SHIFT		16
+#define WKUP_M3_STATUS_RESP_MASK		(0xffff << 16)
+
+#define WKUP_M3_FW_VERSION_SHIFT		0
+#define WKUP_M3_FW_VERSION_MASK			0xffff
+
+/* AM33XX M3_TXEV_EOI register */
+#define AM33XX_CONTROL_M3_TXEV_EOI	0x00
+
+#define AM33XX_M3_TXEV_ACK		(0x1 << 0)
+#define AM33XX_M3_TXEV_ENABLE		(0x0 << 0)
+
+/* AM33XX IPC message registers */
+#define AM33XX_CONTROL_IPC_MSG_REG0	0x04
+#define AM33XX_CONTROL_IPC_MSG_REG1	0x08
+#define AM33XX_CONTROL_IPC_MSG_REG2	0x0c
+#define AM33XX_CONTROL_IPC_MSG_REG3	0x10
+#define AM33XX_CONTROL_IPC_MSG_REG4	0x14
+#define AM33XX_CONTROL_IPC_MSG_REG5	0x18
+#define AM33XX_CONTROL_IPC_MSG_REG6	0x1c
+#define AM33XX_CONTROL_IPC_MSG_REG7	0x20
+
+struct wkup_m3_context {
+	struct device	*dev;
+	void __iomem	*code;
+	void __iomem	*ipc;
+	u8				is_valid;
+	void (*txev_handler)(void);
+	struct omap_mbox *mbox;
+};
+
+struct wkup_m3_wakeup_src wakeups[] = {
+	{.irq_nr = 35,	.src = "USB0_PHY"},
+	{.irq_nr = 36,	.src = "USB1_PHY"},
+	{.irq_nr = 40,	.src = "I2C0"},
+	{.irq_nr = 41,	.src = "RTC Timer"},
+	{.irq_nr = 42,	.src = "RTC Alarm"},
+	{.irq_nr = 43,	.src = "Timer0"},
+	{.irq_nr = 44,	.src = "Timer1"},
+	{.irq_nr = 45,	.src = "UART"},
+	{.irq_nr = 46,	.src = "GPIO0"},
+	{.irq_nr = 48,	.src = "MPU_WAKE"},
+	{.irq_nr = 49,	.src = "WDT0"},
+	{.irq_nr = 50,	.src = "WDT1"},
+	{.irq_nr = 51,	.src = "ADC_TSC"},
+	{.irq_nr = 0,	.src = "Unknown"},
+};
+
+static struct wkup_m3_context *wkup_m3;
+
+static void am33xx_txev_eoi(void)
+{
+	writel(AM33XX_M3_TXEV_ACK,
+		wkup_m3->ipc + AM33XX_CONTROL_M3_TXEV_EOI);
+}
+
+static void am33xx_txev_enable(void)
+{
+	writel(AM33XX_M3_TXEV_ENABLE,
+		wkup_m3->ipc + AM33XX_CONTROL_M3_TXEV_EOI);
+}
+
+static void am33xx_ctrl_ipc_write(struct am33xx_ipc_regs *ipc_regs)
+{
+	writel(ipc_regs->reg0,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG0);
+	writel(ipc_regs->reg1,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG1);
+	writel(ipc_regs->reg2,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG2);
+	writel(ipc_regs->reg3,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG3);
+	writel(ipc_regs->reg4,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG4);
+	writel(ipc_regs->reg5,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG5);
+	writel(ipc_regs->reg6,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG6);
+	writel(ipc_regs->reg7,
+		wkup_m3->ipc + AM33XX_CONTROL_IPC_MSG_REG7);
+}
+
+static void am33xx_ctrl_ipc_read(struct am33xx_ipc_regs *ipc_regs)
+{
+	ipc_regs->reg0 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG0);
+	ipc_regs->reg1 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG1);
+	ipc_regs->reg2 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG2);
+	ipc_regs->reg3 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG3);
+	ipc_regs->reg4 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG4);
+	ipc_regs->reg5 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG5);
+	ipc_regs->reg6 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG6);
+	ipc_regs->reg7 = readl(wkup_m3->ipc
+					+ AM33XX_CONTROL_IPC_MSG_REG7);
+}
+
+int wkup_m3_ping(void)
+{
+	int ret = 0;
+
+	if (!wkup_m3->is_valid) {
+		pr_err("PM: No M3 Firmware has been loaded.\n");
+		return -EIO;
+	}
+
+	if (!wkup_m3->mbox) {
+		pr_err("PM: No IPC channel to communicate with wkup_m3!\n");
+		return -EIO;
+	}
+
+	/*
+	 * Write a dummy message to the mailbox in order to trigger the RX
+	 * interrupt to alert the M3 that data is available in the IPC
+	 * registers.
+	 */
+	ret = omap_mbox_msg_send(wkup_m3->mbox, 0xABCDABCD);
+
+	return ret;
+}
+
+struct wkup_m3_wakeup_src wkup_m3_wake_src(void)
+{
+	struct am33xx_ipc_regs ipc_regs;
+	unsigned int wakeup_src_idx;
+	int j;
+
+	am33xx_ctrl_ipc_read(&ipc_regs);
+
+	wakeup_src_idx = ipc_regs.reg6 & WKUP_M3_WAKE_SRC_MASK;
+
+	for (j = 0; j < ARRAY_SIZE(wakeups)-1; j++) {
+		if (wakeups[j].irq_nr == wakeup_src_idx)
+			return wakeups[j];
+	}
+
+	return wakeups[j];
+}
+
+
+int wkup_m3_pm_status(void)
+{
+	unsigned int i;
+	struct am33xx_ipc_regs ipc_regs;
+
+	am33xx_ctrl_ipc_read(&ipc_regs);
+
+	i = WKUP_M3_STATUS_RESP_MASK & ipc_regs.reg1;
+	i >>= __ffs(WKUP_M3_STATUS_RESP_MASK);
+
+	return i;
+}
+
+/*
+ * Invalidate M3 firmware version before hardreset.
+ * Write invalid version in lower 4 nibbles of parameter
+ * register (ipc_regs + 0x8).
+ */
+
+void wkup_m3_fw_version_clear(void)
+{
+	struct am33xx_ipc_regs ipc_regs;
+
+	am33xx_ctrl_ipc_read(&ipc_regs);
+	ipc_regs.reg2 = 0xFFFF0000;
+	am33xx_ctrl_ipc_write(&ipc_regs);
+
+	return;
+}
+
+int wkup_m3_fw_version_read(void)
+{
+	struct am33xx_ipc_regs ipc_regs;
+
+	am33xx_ctrl_ipc_read(&ipc_regs);
+
+	return ipc_regs.reg2 & WKUP_M3_FW_VERSION_MASK;
+}
+
+void wkup_m3_pm_set_cmd(struct am33xx_ipc_regs *ipc_regs)
+{
+	am33xx_ctrl_ipc_write(ipc_regs);
+}
+
+void wkup_m3_register_txev_handler(void (*txev_handler)(void))
+{
+	wkup_m3->txev_handler = txev_handler;
+}
+
+static irqreturn_t wkup_m3_txev_handler(int irq, void *unused)
+{
+	am33xx_txev_eoi();
+
+	wkup_m3->txev_handler();
+
+	am33xx_txev_enable();
+
+	return IRQ_HANDLED;
+}
+
+int wkup_m3_prepare(void)
+{
+	int ret = 0;
+	struct platform_device *pdev = to_platform_device(wkup_m3->dev);
+
+	wkup_m3->mbox = omap_mbox_get("wkup_m3", NULL);
+
+	if (IS_ERR(wkup_m3->mbox)) {
+		ret = -EBUSY;
+		pr_err("PM: IPC Request for A8->M3 Channel failed!\n");
+		return ret;
+	}
+
+	/* check that the code is loaded */
+	ret = omap_device_deassert_hardreset(pdev, "wkup_m3");
+
+	return ret;
+}
+
+static int wkup_m3_copy_code(const u8 *data, size_t size)
+{
+	if (size > SZ_16K)
+		return -ENOMEM;
+
+	memcpy_toio(wkup_m3->code, data, size);
+
+	return 0;
+}
+
+static void wkup_m3_firmware_cb(const struct firmware *fw, void *context)
+{
+	int ret = 0;
+
+	/* no firmware found */
+	if (!fw) {
+		pr_err("PM: request_firmware failed\n");
+		return;
+	}
+
+	ret = wkup_m3_copy_code(fw->data, fw->size);
+
+	if (ret)
+		pr_info("PM: Failed to copy firmware for M3");
+	else
+		wkup_m3->is_valid = true;
+
+	return;
+}
+
+static int wkup_m3_probe(struct platform_device *pdev)
+{
+	int irq, ret = 0;
+	struct resource *res;
+
+	pm_runtime_enable(&pdev->dev);
+
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (IS_ERR_VALUE(ret)) {
+		dev_err(&pdev->dev, "pm_runtime_get_sync() failed\n");
+		return ret;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq resource\n");
+		ret = -ENXIO;
+		goto err;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "m3_umem");
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource\n");
+		ret = -ENXIO;
+		goto err;
+	}
+
+	wkup_m3 = devm_kzalloc(&pdev->dev, sizeof(*wkup_m3), GFP_KERNEL);
+	if (!wkup_m3) {
+		pr_err("Memory allocation failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	wkup_m3->dev = &pdev->dev;
+
+	wkup_m3->code = devm_request_and_ioremap(wkup_m3->dev, res);
+	if (!wkup_m3->code) {
+		dev_err(wkup_m3->dev, "could not ioremap\n");
+		ret = -EADDRNOTAVAIL;
+		goto err;
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ipc_regs");
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource for ipc\n");
+		ret = -ENXIO;
+		goto err;
+	}
+
+	wkup_m3->ipc = devm_request_and_ioremap(wkup_m3->dev, res);
+	if (!wkup_m3->ipc) {
+		dev_err(wkup_m3->dev, "could not ioremap ipc_mem\n");
+		ret = -EADDRNOTAVAIL;
+		goto err;
+	}
+
+	ret = devm_request_irq(wkup_m3->dev, irq, wkup_m3_txev_handler,
+		  IRQF_DISABLED, "wkup_m3_txev", NULL);
+	if (ret) {
+		dev_err(wkup_m3->dev, "request_irq failed\n");
+		goto err;
+	}
+
+	pr_info("PM: Loading am335x-pm-firmware.bin");
+
+	/* first make sure is_valid flag is false */
+	wkup_m3->is_valid = false;
+
+	/* We don't want to delay boot */
+	ret = request_firmware_nowait(THIS_MODULE, 0, "am335x-pm-firmware.bin",
+				&pdev->dev, GFP_KERNEL, NULL,
+				wkup_m3_firmware_cb);
+
+err:
+	return ret;
+}
+
+static int wkup_m3_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct of_device_id wkup_m3_dt_ids[] = {
+	{ .compatible = "ti,am3353-wkup-m3" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wkup_m3_dt_ids);
+
+static int wkup_m3_rpm_suspend(struct device *dev)
+{
+	return -EBUSY;
+}
+
+static int wkup_m3_rpm_resume(struct device *dev)
+{
+	return 0;
+}
+
+static const struct dev_pm_ops wkup_m3_ops = {
+	SET_RUNTIME_PM_OPS(wkup_m3_rpm_suspend, wkup_m3_rpm_resume, NULL)
+};
+
+static struct platform_driver wkup_m3_driver = {
+	.probe		= wkup_m3_probe,
+	.remove		= wkup_m3_remove,
+	.driver		= {
+		.name	= "wkup_m3",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(wkup_m3_dt_ids),
+		.pm	= &wkup_m3_ops,
+	},
+};
+
+module_platform_driver(wkup_m3_driver);
diff --git a/arch/arm/mach-omap2/wkup_m3.h b/arch/arm/mach-omap2/wkup_m3.h
new file mode 100644
index 0000000..56b2c66
--- /dev/null
+++ b/arch/arm/mach-omap2/wkup_m3.h
@@ -0,0 +1,45 @@
+/*
+ * TI Wakeup M3 Power Management Routines
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ * Dave Gerlach <d-gerlach@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASSEMBLER__
+
+struct wkup_m3_wakeup_src {
+	int irq_nr;
+	char src[10];
+};
+
+struct am33xx_ipc_regs {
+	u32 reg0;
+	u32 reg1;
+	u32 reg2;
+	u32 reg3;
+	u32 reg4;
+	u32 reg5;
+	u32 reg6;
+	u32 reg7;
+};
+
+int wkup_m3_prepare(void);
+void wkup_m3_register_txev_handler(void (*txev_handler)(void));
+int wkup_m3_ping(void);
+struct wkup_m3_wakeup_src wkup_m3_wake_src(void);
+int wkup_m3_pm_status(void);
+void wkup_m3_fw_version_clear(void);
+int wkup_m3_fw_version_read(void);
+void wkup_m3_pm_set_cmd(struct am33xx_ipc_regs *ipc_regs);
+
+#endif
+
-- 
1.7.5.4

