From 1752a285ba87aeae3cb1014203fb1722e2890976 Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Thu, 14 Nov 2013 17:02:00 -0600
Subject: [PATCH 0789/1115] opp-modifier: Add omap-opp-modifier driver

Driver to read from eFuse and device_id on TI SoC's in order to
selectively enable or disable OPPs based on DT node.

Also add dt-bindings for opp for readability and add documentation.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit fac5820525f658e1fe7ee0999a722c105ac9ed2b)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/power/opp-modifier.txt     |   71 ++++++
 drivers/power/opp/Makefile                         |    1 +
 drivers/power/opp/omap-opp-control.c               |  225 ++++++++++++++++++++
 include/dt-bindings/opp/am33xx.h                   |   26 +++
 4 files changed, 323 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/power/opp-modifier.txt
 create mode 100644 drivers/power/opp/omap-opp-control.c
 create mode 100644 include/dt-bindings/opp/am33xx.h

diff --git a/Documentation/devicetree/bindings/power/opp-modifier.txt b/Documentation/devicetree/bindings/power/opp-modifier.txt
new file mode 100644
index 0000000..a1481f4
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/opp-modifier.txt
@@ -0,0 +1,71 @@
+* OPP-Modifier - opp modifier to selectively enable operating point
+
+OMAP devices that have selectively modifiable OPPs can specify
+all available OPPs in their operating-points listing and then define
+opp_modifiers to enable or disable the OPPs that are actually available
+on the specific hardware.
+
+* OPP Modifier Provider
+
+properties:
+- compatible : Should be "ti,opp-omap"
+- reg : Address and length of the registers needed to identify available
+	OPPs, here we provide efuse_sma address and device_id address
+
+Sub-nodes:
+Sub-nodes are defined as a container to hold opp modifier table for a
+specific device with an operating-points table already defined
+
+Sub-node properties:
+- opp-modifier: A collection of rows consisting of the following entries to
+		allow specification of available OPPs:
+	-kHz: The opp to be enabled based on following criteria
+	-Rev: The revision of the part this OPP applies to, specified
+	      using OPP_REV macro
+	-offset: Offset into efuse register where relevant bits are located
+	-mask: Bit that indicates availability of OPP
+
+The OPP_REV macro defined under include/dt-bindings/opp/am33xx.h allows
+specification of specific part revision through usage:
+
+	OPP_REV([MAJOR PART REVISION], [MINOR PART REVISION]);
+
+so ES2.1 silicon for AM33XX would be indicated using OPP_REV(2,1);
+
+Example:
+
+	efuse_sma: efuse@0x44e107fc {
+		compatible = "ti,opp-omap";
+		reg = <0x44e107fc 0x04          /* EFUSE_SMA */
+		       0x44e10600 0x04>;        /* DEVICE_ID */
+
+		mpu_opp_modifier: mpu_opp_modifier {
+			opp-modifier = <
+			/* kHz   Rev		offset  mask */
+			1000000  OPP_REV(2,1)	0	BIT_1
+			720000   OPP_REV(1,0)	0	BIT_2
+			>;
+		};
+	};
+
+* OPP Modifier Consumer
+
+Properties:
+- platform-opp-modifier: phandle to the sub-node of the proper opp-modifier
+		provider that contains the appropriate opp-modifier table
+
+Example:
+
+cpu@0 {
+        compatible = "arm,cortex-a8";
+        device_type = "cpu";
+
+        operating-points = <
+                /* kHz    uV */
+                1000000 1351000
+                720000  1285000
+        >;
+
+        platform-opp-modifier = <&mpu_opp_modifier>;
+};
+
diff --git a/drivers/power/opp/Makefile b/drivers/power/opp/Makefile
index 820eb10..8f2f6ac 100644
--- a/drivers/power/opp/Makefile
+++ b/drivers/power/opp/Makefile
@@ -1 +1,2 @@
 obj-y += core.o
+obj-y += omap-opp-control.o
diff --git a/drivers/power/opp/omap-opp-control.c b/drivers/power/opp/omap-opp-control.c
new file mode 100644
index 0000000..793a6fa
--- /dev/null
+++ b/drivers/power/opp/omap-opp-control.c
@@ -0,0 +1,225 @@
+/*
+ * TI OPP Modifier Driver
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ * Dave Gerlach <d-gerlach@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/list.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/opp.h>
+#include <linux/opp-modifier.h>
+
+#include <dt-bindings/opp/am33xx.h>
+
+#define AM33XX_CTRL_DEVICE_ID_DEVREV_SHIFT		28
+#define AM33XX_CTRL_DEVICE_ID_DEVREV_MASK		0xF0000000
+
+#define AM33XX_EFUSE_SMA_MAX_FREQ_MASK			0x1fff
+
+static struct of_device_id opp_omap_of_match[];
+
+struct opp_efuse_context {
+	struct device   *dev;
+	void __iomem    *efuse;
+	void __iomem	*id;
+};
+
+static struct opp_efuse_context *opp_efuse;
+
+static unsigned long rev_id;
+
+static unsigned long opp_omap_efuse_read(int offset)
+{
+	return readl(opp_efuse->efuse + offset);
+}
+
+static unsigned long am33xx_devrev_to_opp_rev(int rev)
+{
+	if (rev_id == 0)
+		return OPP_REV(1, 0);
+	else if (rev_id == 1)
+		return OPP_REV(2, 0);
+	else if (rev_id == 2)
+		return OPP_REV(2, 1);
+	else
+		return 0;
+}
+
+static int of_opp_check_availability(struct device *dev, struct device_node *np)
+{
+	const struct property *prop;
+	const __be32 *val;
+	unsigned long efuse_val, freq, rev, offset, bit;
+	int nr;
+
+	if (!dev || !np)
+		return -EINVAL;
+
+	prop = of_find_property(np, "opp-modifier", NULL);
+	if (!prop)
+		return -EINVAL;
+	if (!prop->value)
+		return -EINVAL;
+
+	nr = prop->length / sizeof(u32);
+	if (nr % 4) {
+		pr_err("%s: Invalid OMAP OPP Available list\n", __func__);
+		return -EINVAL;
+	}
+
+	val = prop->value;
+	while (nr) {
+		freq = be32_to_cpup(val++) * 1000;
+		rev = be32_to_cpup(val++);
+		offset = be32_to_cpup(val++);
+		bit = be32_to_cpup(val++);
+
+		efuse_val = opp_omap_efuse_read(offset);
+
+		if (OPP_REV_CMP(rev, am33xx_devrev_to_opp_rev(rev_id))) {
+			if (((~efuse_val & bit) || !bit))
+				opp_enable(dev, freq);
+			else if (bit && !(~efuse_val & bit))
+				opp_disable(dev, freq);
+		} else if (!OPP_REV_CMP(rev,
+					am33xx_devrev_to_opp_rev(rev_id))) {
+			opp_disable(dev, freq);
+		} else {
+			opp_disable(dev, freq);
+		}
+
+		nr -= 4;
+	}
+
+	return 0;
+}
+
+static int omap_opp_device_modify(struct device *dev)
+{
+	struct device_node *np;
+	int ret;
+
+	if (!dev)
+		return -EINVAL;
+
+	np = of_parse_phandle(dev->of_node, "platform-opp-modifier", 0);
+
+	if (!np)
+		return -EINVAL;
+
+	ret = of_opp_check_availability(dev, np);
+
+	if (ret)
+		pr_err("Error modifying available OPPs\n");
+
+	of_node_put(np);
+
+	return ret;
+}
+
+static struct opp_modifier_ops omap_opp_ops = {
+	.modify = omap_opp_device_modify,
+};
+
+static struct opp_modifier_dev omap_opp_modifier_dev = {
+	.ops = &omap_opp_ops,
+};
+
+static int opp_omap_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int ret = 0;
+
+	opp_efuse = devm_kzalloc(&pdev->dev, sizeof(*opp_efuse), GFP_KERNEL);
+	if (!opp_efuse) {
+		dev_err(opp_efuse->dev, "efuse context memory allocation failed\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	opp_efuse->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource for id\n");
+		ret = -ENXIO;
+		goto err;
+	}
+
+	opp_efuse->id = devm_ioremap(opp_efuse->dev, res->start,
+					resource_size(res));
+	if (!opp_efuse->id) {
+		dev_err(opp_efuse->dev, "could not ioremap id\n");
+		ret = -EADDRNOTAVAIL;
+		goto err;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource for efuse\n");
+		ret = -ENXIO;
+		goto err;
+	}
+
+	opp_efuse->efuse = devm_request_and_ioremap(opp_efuse->dev, res);
+	if (!opp_efuse->efuse) {
+		dev_err(opp_efuse->dev, "could not ioremap efuse\n");
+		ret = -EADDRNOTAVAIL;
+		goto err;
+	}
+
+	rev_id = (readl(opp_efuse->id) & AM33XX_CTRL_DEVICE_ID_DEVREV_MASK)
+		  >> AM33XX_CTRL_DEVICE_ID_DEVREV_SHIFT;
+
+	omap_opp_modifier_dev.ops = &omap_opp_ops;
+	omap_opp_modifier_dev.of_node = pdev->dev.of_node;
+
+	opp_modifier_register(&omap_opp_modifier_dev);
+
+err:
+	return ret;
+}
+
+static int opp_omap_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct of_device_id opp_omap_of_match[] = {
+	{ .compatible = "ti,opp-omap",},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, opp_omap_of_match);
+
+static struct platform_driver opp_omap_driver = {
+	.probe		= opp_omap_probe,
+	.remove		= opp_omap_remove,
+	.driver = {
+		.owner		= THIS_MODULE,
+		.name		= "ti-opp",
+		.of_match_table	= opp_omap_of_match,
+	},
+};
+
+module_platform_driver(opp_omap_driver);
+
+MODULE_AUTHOR("Dave Gerlach <d-gerlach@ti.com>");
+MODULE_DESCRIPTION("OPP Modifier driver for TI SoCs");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/opp/am33xx.h b/include/dt-bindings/opp/am33xx.h
new file mode 100644
index 0000000..85347c7
--- /dev/null
+++ b/include/dt-bindings/opp/am33xx.h
@@ -0,0 +1,26 @@
+/*
+ * This header provides constants for OMAP pinctrl bindings.
+ *
+ * Copyright (C) 2013 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __DT_BINDINGS_OPP_OPP_MODIFIER_H__
+#define __DT_BINDINGS_OPP_OPP_MODIFIER_H__
+
+#define AM33XX_EFUSE_SMA_OPP_50_300MHZ_BIT              (1 << 4)
+#define AM33XX_EFUSE_SMA_OPP_100_300MHZ_BIT             (1 << 5)
+#define AM33XX_EFUSE_SMA_OPP_100_600MHZ_BIT             (1 << 6)
+#define AM33XX_EFUSE_SMA_OPP_120_720MHZ_BIT             (1 << 7)
+#define AM33XX_EFUSE_SMA_OPP_TURBO_800MHZ_BIT		(1 << 8)
+#define AM33XX_EFUSE_SMA_OPP_NITRO_1GHZ_BIT             (1 << 9)
+
+#define OPP_REV(maj, min)  (((1 << (maj)) << 16) | (1 << (min)))
+#define OPP_REV_CMP(opp1, opp2)  (((opp1) & (opp2) & 0xFFFF000) && \
+				 ((opp1) & (opp2) & 0x0000FFFF))
+
+#endif		/* __DT_BINDINGS_OPP_OPP_MODIFIER_H__ */
-- 
1.7.5.4

