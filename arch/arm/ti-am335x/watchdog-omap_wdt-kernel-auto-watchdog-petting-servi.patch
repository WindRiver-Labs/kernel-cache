From d049acd255ce32026c167249447e38e59db001d0 Mon Sep 17 00:00:00 2001
From: Todd Poynor <toddpoynor@google.com>
Date: Wed, 27 Feb 2013 18:18:08 +0530
Subject: [PATCH 0350/1115] watchdog: omap_wdt: kernel auto watchdog petting
 service

Watchdog is enabled by kernel and petting is taken care by
delay register. Whenever the value expires in delay register,
an interrupt is raised to pet the watchdog timer.
In case of a system crash, the system will reboot after the
watchdog timeout.

Signed-off-by: Todd Poynor <toddpoynor@google.com>
Signed-off-by: Colin Cross <ccross@android.com>
Signed-off-by: Sricharan R <r.sricharan@ti.com>
Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
(cherry picked from commit c9bd836853698b7fceb3f3fdf0003fa8f84fddfc)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/watchdog/omap_wdt.c |   62 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/watchdog/omap_wdt.h |    5 +++
 2 files changed, 66 insertions(+), 1 deletions(-)

diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index af88ffd..c1d575b 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -41,6 +41,7 @@
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
 #include <linux/platform_data/omap-wd-timer.h>
 
 #include "omap_wdt.h"
@@ -54,6 +55,10 @@ static unsigned timer_margin;
 module_param(timer_margin, uint, 0);
 MODULE_PARM_DESC(timer_margin, "initial watchdog timeout (in seconds)");
 
+static int kernelpet = 1;
+module_param(kernelpet, int, 0);
+MODULE_PARM_DESC(kernelpet, "pet watchdog in kernel via irq");
+
 struct omap_wdt_dev {
 	void __iomem    *base;          /* physical */
 	struct device   *dev;
@@ -112,6 +117,7 @@ static void omap_wdt_set_timer(struct omap_wdt_dev *wdev,
 				   unsigned int timeout)
 {
 	u32 pre_margin = GET_WLDR_VAL(timeout);
+	u32 delay_period = GET_WLDR_VAL(timeout / 2);
 	void __iomem *base = wdev->base;
 
 	/* just count up at 32 KHz */
@@ -121,6 +127,26 @@ static void omap_wdt_set_timer(struct omap_wdt_dev *wdev,
 	__raw_writel(pre_margin, base + OMAP_WATCHDOG_LDR);
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x04)
 		cpu_relax();
+
+	/* Set delay interrupt to half the watchdog interval. */
+	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 1 << 5)
+		cpu_relax();
+	__raw_writel(delay_period, base + OMAP_WATCHDOG_WDLY);
+}
+
+static irqreturn_t omap_wdt_interrupt(int irq, void *dev_id)
+{
+	struct watchdog_device *wdog = dev_id;
+	struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	void __iomem *base = wdev->base;
+	u32 i;
+
+	i = __raw_readl(base + OMAP_WATCHDOG_WIRQSTAT);
+	__raw_writel(i, base + OMAP_WATCHDOG_WIRQSTAT);
+
+	omap_wdt_reload(wdev);
+
+	return IRQ_HANDLED;
 }
 
 static int omap_wdt_start(struct watchdog_device *wdog)
@@ -144,6 +170,13 @@ static int omap_wdt_start(struct watchdog_device *wdog)
 
 	omap_wdt_set_timer(wdev, wdog->timeout);
 	omap_wdt_reload(wdev); /* trigger loading of new timeout value */
+
+	/* Enable delay interrupt */
+	if (kernelpet) {
+		__raw_writel(0x2, base + OMAP_WATCHDOG_WIRQENSET);
+		__raw_writel(0x2, base + OMAP_WATCHDOG_WIRQWAKEEN);
+	}
+
 	omap_wdt_enable(wdev);
 
 	mutex_unlock(&wdev->lock);
@@ -154,9 +187,16 @@ static int omap_wdt_start(struct watchdog_device *wdog)
 static int omap_wdt_stop(struct watchdog_device *wdog)
 {
 	struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	void __iomem *base = wdev->base;
 
 	mutex_lock(&wdev->lock);
 	omap_wdt_disable(wdev);
+	/* Disable delay interrupt */
+	if (kernelpet) {
+		__raw_writel(0x0, base + OMAP_WATCHDOG_WIRQWAKEEN);
+		__raw_writel(0x2, base + OMAP_WATCHDOG_WIRQENCLR);
+	}
+
 	pm_runtime_put_sync(wdev->dev);
 	wdev->omap_wdt_users = false;
 	mutex_unlock(&wdev->lock);
@@ -210,7 +250,7 @@ static int omap_wdt_probe(struct platform_device *pdev)
 	struct resource *res, *mem;
 	struct omap_wdt_dev *wdev;
 	u32 rs;
-	int ret;
+	int ret, irq;
 
 	omap_wdt = devm_kzalloc(&pdev->dev, sizeof(*omap_wdt), GFP_KERNEL);
 	if (!omap_wdt)
@@ -240,6 +280,13 @@ static int omap_wdt_probe(struct platform_device *pdev)
 	if (!wdev->base)
 		return -ENOMEM;
 
+	irq = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(&pdev->dev, irq, omap_wdt_interrupt, 0,
+			       dev_name(&pdev->dev), omap_wdt);
+	if (ret < 0)
+		dev_err(&pdev->dev, "can't get irq %d, err %d\n",
+			irq, ret);
+
 	omap_wdt->info	      = &omap_wdt_info;
 	omap_wdt->ops	      = &omap_wdt_ops;
 	omap_wdt->min_timeout = TIMER_MARGIN_MIN;
@@ -280,6 +327,12 @@ static int omap_wdt_probe(struct platform_device *pdev)
 
 	pm_runtime_put_sync(wdev->dev);
 
+	if (kernelpet) {
+		ret = omap_wdt_start(omap_wdt);
+		if (ret == 0)
+			set_bit(WDOG_ACTIVE, &omap_wdt->status);
+	}
+
 	return 0;
 }
 
@@ -300,6 +353,13 @@ static int omap_wdt_remove(struct platform_device *pdev)
 {
 	struct watchdog_device *wdog = platform_get_drvdata(pdev);
 	struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);
+	int ret;
+
+	if (kernelpet) {
+		ret = omap_wdt_stop(wdog);
+		if (ret == 0)
+			clear_bit(WDOG_ACTIVE, &wdog->status);
+	}
 
 	pm_runtime_disable(wdev->dev);
 	watchdog_unregister_device(wdog);
diff --git a/drivers/watchdog/omap_wdt.h b/drivers/watchdog/omap_wdt.h
index 09b774c..bf49146 100644
--- a/drivers/watchdog/omap_wdt.h
+++ b/drivers/watchdog/omap_wdt.h
@@ -38,7 +38,12 @@
 #define OMAP_WATCHDOG_LDR		(0x2c)
 #define OMAP_WATCHDOG_TGR		(0x30)
 #define OMAP_WATCHDOG_WPS		(0x34)
+#define OMAP_WATCHDOG_WDLY		(0x44)
 #define OMAP_WATCHDOG_SPR		(0x48)
+#define OMAP_WATCHDOG_WIRQSTAT		(0x58)
+#define OMAP_WATCHDOG_WIRQENSET		(0x5c)
+#define OMAP_WATCHDOG_WIRQENCLR		(0x60)
+#define OMAP_WATCHDOG_WIRQWAKEEN	(0x64)
 
 /* Using the prescaler, the OMAP watchdog could go for many
  * months before firing.  These limits work without scaling,
-- 
1.7.5.4

