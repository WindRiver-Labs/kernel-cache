From 73cce4dfd53e1067b530efffcb55ebdacb1a334e Mon Sep 17 00:00:00 2001
From: Peter Ujfalusi <peter.ujfalusi@ti.com>
Date: Mon, 11 Nov 2013 14:53:39 +0200
Subject: [PATCH 1011/1115] ASoC: davinci-mcasp: Data source (bus) selection
 support

The audio data to/from McASP can be sent/received via two method:
Via the data port (preferred) or via the configuration bus.
Currently the driver assumes that all data communication will be done via
the data port.
This patch adds support for selecting the configuration port as data
interface.

Signed-off-by: Peter Ujfalusi <peter.ujfalusi@ti.com>
(cherry picked from commit 40d91773ca01e6c87b812cd2ccb36cfb23b89c19)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 sound/soc/davinci/davinci-mcasp.c |   38 +++++++++++++++++++++++++++---------
 1 files changed, 28 insertions(+), 10 deletions(-)

diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c
index b95a4f8..02a12386 100644
--- a/sound/soc/davinci/davinci-mcasp.c
+++ b/sound/soc/davinci/davinci-mcasp.c
@@ -52,6 +52,8 @@ struct davinci_mcasp {
 	/* McASP FIFO related */
 	u8	txnumevt;
 	u8	rxnumevt;
+
+	bool	dat_port;
 };
 
 static inline void mcasp_set_bits(void __iomem *reg, u32 val)
@@ -470,6 +472,7 @@ static void davinci_hw_param(struct davinci_mcasp *mcasp, int stream)
 {
 	int i, active_slots;
 	u32 mask = 0;
+	u32 busel = 0;
 
 	active_slots = (mcasp->tdm_slots > 31) ? 32 : mcasp->tdm_slots;
 	for (i = 0; i < active_slots; i++)
@@ -477,11 +480,15 @@ static void davinci_hw_param(struct davinci_mcasp *mcasp, int stream)
 
 	mcasp_clr_bits(mcasp->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
 
+	if (!mcasp->dat_port)
+		busel = TXSEL;
+
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* bit stream is MSB first  with no delay */
 		/* DSP_B mode */
 		mcasp_set_reg(mcasp->base + DAVINCI_MCASP_TXTDM_REG, mask);
-		mcasp_set_bits(mcasp->base + DAVINCI_MCASP_TXFMT_REG, TXORD);
+		mcasp_set_bits(mcasp->base + DAVINCI_MCASP_TXFMT_REG,
+			       busel | TXORD);
 
 		if ((mcasp->tdm_slots >= 2) && (mcasp->tdm_slots <= 32))
 			mcasp_mod_bits(mcasp->base + DAVINCI_MCASP_TXFMCTL_REG,
@@ -492,7 +499,8 @@ static void davinci_hw_param(struct davinci_mcasp *mcasp, int stream)
 	} else {
 		/* bit stream is MSB first with no delay */
 		/* DSP_B mode */
-		mcasp_set_bits(mcasp->base + DAVINCI_MCASP_RXFMT_REG, RXORD);
+		mcasp_set_bits(mcasp->base + DAVINCI_MCASP_RXFMT_REG,
+			       busel | RXORD);
 		mcasp_set_reg(mcasp->base + DAVINCI_MCASP_RXTDM_REG, mask);
 
 		if ((mcasp->tdm_slots >= 2) && (mcasp->tdm_slots <= 32))
@@ -916,23 +924,22 @@ static int davinci_mcasp_probe(struct platform_device *pdev)
 	mcasp->version = pdata->version;
 	mcasp->txnumevt = pdata->txnumevt;
 	mcasp->rxnumevt = pdata->rxnumevt;
-	if (mcasp->version < MCASP_VERSION_3)
-		mcasp->fifo_base = DAVINCI_MCASP_V2_AFIFO_BASE;
-	else
-		mcasp->fifo_base = DAVINCI_MCASP_V3_AFIFO_BASE;
 
 	mcasp->dev = &pdev->dev;
 
 	dat = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dat");
-	if (!dat)
-		dat = mem;
+	if (dat)
+		mcasp->dat_port = true;
 
 	dma_data = &mcasp->dma_params[SNDRV_PCM_STREAM_PLAYBACK];
 	dma_data->asp_chan_q = pdata->asp_chan_q;
 	dma_data->ram_chan_q = pdata->ram_chan_q;
 	dma_data->sram_pool = pdata->sram_pool;
 	dma_data->sram_size = pdata->sram_size_playback;
-	dma_data->dma_addr = dat->start + pdata->tx_dma_offset;
+	if (dat)
+		dma_data->dma_addr = dat->start;
+	else
+		dma_data->dma_addr = mem->start + pdata->tx_dma_offset;
 
 	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
 	if (res)
@@ -945,7 +952,18 @@ static int davinci_mcasp_probe(struct platform_device *pdev)
 	dma_data->ram_chan_q = pdata->ram_chan_q;
 	dma_data->sram_pool = pdata->sram_pool;
 	dma_data->sram_size = pdata->sram_size_capture;
-	dma_data->dma_addr = dat->start + pdata->rx_dma_offset;
+	if (dat)
+		dma_data->dma_addr = dat->start;
+	else
+		dma_data->dma_addr = mem->start + pdata->rx_dma_offset;
+
+	if (mcasp->version < MCASP_VERSION_3) {
+		mcasp->fifo_base = DAVINCI_MCASP_V2_AFIFO_BASE;
+		/* dma_data->dma_addr is pointing to the data port address */
+		mcasp->dat_port = true;
+	} else {
+		mcasp->fifo_base = DAVINCI_MCASP_V3_AFIFO_BASE;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
 	if (res)
-- 
1.7.5.4

