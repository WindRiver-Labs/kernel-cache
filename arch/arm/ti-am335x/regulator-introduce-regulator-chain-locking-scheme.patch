From 76349184e8c249bacce219477aff429700e978aa Mon Sep 17 00:00:00 2001
From: Grygorii Strashko <grygorii.strashko@ti.com>
Date: Fri, 4 Oct 2013 16:37:54 +0530
Subject: [PATCH 0940/1115] regulator: introduce regulator chain locking
 scheme

In some cases the regulators may be organized in a chain like:
 ->regA->regB->regC
where regA is supplier for regB and regB is supplier for regC.

Currently it would be possible to reconfigure regA and regC at same time
form different contexts, because each regulator has it own mutex.
But in some cases, the only the whole chain is allowed be reconfigured
because of dependencies between regulators - to change regB
configuration the regA need to be updated first.

Hence, introduce regulator chain locking scheme to lock whole Regulator
chain in case if any part of it has been accessed from outside. To
achieve this goal the root Regulator (which has no supply defined, like
regA) in chain is used to protect the whole chain.

In addition, such locking scheme allows to have access to the supplier
regulator API from inside child's (consumer) regulator API.

Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
Signed-off-by: Keerthy <j-keerthy@ti.com>
(cherry picked from commit 74152d1597755c9678b52fb8086b17df14929cce)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/regulator/core.c         |   38 ++++++++++++++++++++++++++++++++++----
 include/linux/regulator/driver.h |    2 ++
 2 files changed, 36 insertions(+), 4 deletions(-)

diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c
index 8593fd5..36e6431 100644
--- a/drivers/regulator/core.c
+++ b/drivers/regulator/core.c
@@ -124,18 +124,48 @@ static const char *rdev_get_name(struct regulator_dev *rdev)
 		return "";
 }
 
-
-static inline void regulator_lock(struct regulator_dev *rdev)
+static void regulator_lock(struct regulator_dev *rdev)
 {
 	struct regulator_dev *locking_rdev = rdev;
 
-	mutex_lock(&locking_rdev->mutex);
+	while (locking_rdev->supply)
+		locking_rdev = locking_rdev->supply->rdev;
+
+	if (!mutex_trylock(&locking_rdev->mutex)) {
+		if (locking_rdev->lock_owner == current) {
+			locking_rdev->lock_count++;
+			dev_dbg(&locking_rdev->dev,
+				"Is locked. locking %s (ref=%u)\n",
+				rdev_get_name(rdev),
+				locking_rdev->lock_count);
+			return;
+		}
+		mutex_lock(&locking_rdev->mutex);
+	}
+
+	WARN_ON_ONCE(locking_rdev->lock_owner != NULL);
+	WARN_ON_ONCE(locking_rdev->lock_count != 0);
+
+	locking_rdev->lock_count = 1;
+	locking_rdev->lock_owner = current;
+	dev_dbg(&locking_rdev->dev, "Is locked. locking %s\n",
+		rdev_get_name(rdev));
 }
 
-static inline void regulator_unlock(struct regulator_dev *rdev)
+static void regulator_unlock(struct regulator_dev *rdev)
 {
 	struct regulator_dev *locking_rdev = rdev;
 
+	while (locking_rdev->supply)
+		locking_rdev = locking_rdev->supply->rdev;
+
+	dev_dbg(&locking_rdev->dev, "Is unlocked. unlocking %s (ref=%u)\n",
+		rdev_get_name(rdev), locking_rdev->lock_count);
+
+	if (--locking_rdev->lock_count)
+		return;
+
+	locking_rdev->lock_owner = NULL;
 	mutex_unlock(&locking_rdev->mutex);
 }
 
diff --git a/include/linux/regulator/driver.h b/include/linux/regulator/driver.h
index 67e13aa..c6e3ce8 100644
--- a/include/linux/regulator/driver.h
+++ b/include/linux/regulator/driver.h
@@ -314,6 +314,8 @@ struct regulator_dev {
 
 	struct blocking_notifier_head notifier;
 	struct mutex mutex; /* consumer lock */
+	struct task_struct *lock_owner;
+	int lock_count;
 	struct module *owner;
 	struct device dev;
 	struct regulation_constraints *constraints;
-- 
1.7.5.4

