From 05ea3f8db6888dbb8b848a2a052689d88a86fccc Mon Sep 17 00:00:00 2001
From: Nishanth Menon <nm@ti.com>
Date: Tue, 30 Apr 2013 14:51:06 -0500
Subject: [PATCH 0942/1115] regulator: ti-avs-class0: use regulator name based
 on device instance

Don't use the same regulator descriptor for all regulator instance,
as there will be a name conflict. Instead pick up the device name and
create the descriptor.

As part of this change, save on multiple kzallocs by moving the
descriptor allocation as part of tiavs_class0_data allocation and drop
the need for an temp descriptor.

Signed-off-by: Nishanth Menon <nm@ti.com>
Signed-off-by: Keerthy <j-keerthy@ti.com>
(cherry picked from commit 79a911744692e5a7d95e32ec7edb0d34ab1b7382)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/regulator/ti-avs-class0-regulator.c |   33 ++++++++------------------
 1 files changed, 10 insertions(+), 23 deletions(-)

diff --git a/drivers/regulator/ti-avs-class0-regulator.c b/drivers/regulator/ti-avs-class0-regulator.c
index 5495b09..e64ac29 100644
--- a/drivers/regulator/ti-avs-class0-regulator.c
+++ b/drivers/regulator/ti-avs-class0-regulator.c
@@ -31,12 +31,14 @@
 
 /**
  * struct tiavs_class0_data - class data for the regulator instance
+ * @desc:		regulator descriptor
  * @reg:		regulator that will actually set the voltage
  * @volt_set_table:	voltage to set data table
  * @current_idx:	current index
  * @voltage_tolerance:	% tolerance for voltage(optional)
  */
 struct tiavs_class0_data {
+	struct regulator_desc desc;
 	struct regulator *reg;
 	unsigned int *volt_set_table;
 	int current_idx;
@@ -134,15 +136,8 @@ static struct regulator_ops tiavs_class0_ops = {
 
 };
 
-static struct regulator_desc tiavs_class0_desc = {
-	.ops = &tiavs_class0_ops,
-	.name = "avsclass0",
-	.owner = THIS_MODULE,
-
-};
-
 static const struct of_device_id tiavs_class0_of_match[] = {
-	{.compatible = "ti,avsclass0", .data = &tiavs_class0_desc},
+	{.compatible = "ti,avsclass0",},
 	{},
 };
 
@@ -174,7 +169,6 @@ static int tiavs_class0_probe(struct platform_device *pdev)
 	struct tiavs_class0_data *data;
 	void __iomem *base;
 	const __be32 *val;
-	const void *temp;
 	unsigned int *volt_table;
 	bool efuse_is_uV = false;
 	int proplen, i, ret;
@@ -182,18 +176,12 @@ static int tiavs_class0_probe(struct platform_device *pdev)
 	int best_val = INT_MAX, choice = -EINVAL;
 
 	match = of_match_device(tiavs_class0_of_match, &pdev->dev);
-	if (match) {
-		temp = match->data;
+	if (match)
 		initdata = of_get_regulator_init_data(&pdev->dev, np);
-	}
 	if (!initdata) {
 		dev_err(&pdev->dev, "No proper OF?\n");
 		return -ENODEV;
 	}
-	if (!temp) {
-		dev_err(&pdev->dev, "No proper desc?\n");
-		return -ENODEV;
-	}
 
 	/* look for avs-supply */
 	reg = devm_regulator_get(&pdev->dev, "avs");
@@ -205,13 +193,6 @@ static int tiavs_class0_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	desc = devm_kzalloc(&pdev->dev, sizeof(*desc), GFP_KERNEL);
-	if (!desc) {
-		dev_err(&pdev->dev, "No memory to alloc desc!\n");
-		return -ENOMEM;
-	}
-	memcpy(desc, temp, sizeof(*desc));
-
 	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
 	if (!data) {
 		dev_err(&pdev->dev, "No memory to alloc data!\n");
@@ -219,6 +200,12 @@ static int tiavs_class0_probe(struct platform_device *pdev)
 	}
 	data->reg = reg;
 
+	desc = &data->desc;
+	desc->name = dev_name(&pdev->dev);
+	desc->owner = THIS_MODULE;
+	desc->type = REGULATOR_VOLTAGE;
+	desc->ops = &tiavs_class0_ops;
+
 	/* pick up optional properties */
 	of_property_read_u32(np, "voltage-tolerance", &data->voltage_tolerance);
 	efuse_is_uV = of_property_read_bool(np,
-- 
1.7.5.4

