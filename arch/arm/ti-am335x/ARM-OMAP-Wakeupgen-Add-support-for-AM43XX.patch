From 6f8aabe76442c8561b77db4b1ca31b485b7a4018 Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 11 Dec 2013 01:47:12 +0000
Subject: [PATCH 0712/1115] ARM: OMAP: Wakeupgen: Add support for AM43XX

AM43XX has the same wakeupgen IP as OMAP4/5. The only
notable difference is the presence of 7 register banks
and lack of SAR area which has been used in OMAP4/5 for
saving and restoring the context around low power states.

In case of AM43XX the context is saved and restored by
the kernel. Introduce wakeupgen_ops so that context save
and restore can be set on a per-SoC basis during init.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
Acked-by: Russ Dill <russ.dill@ti.com>
(cherry picked from commit 60362b5d44ad8d2b5214c7acb3e07c488e41e2ae)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/omap-wakeupgen.c |   76 +++++++++++++++++++++++++++++-----
 1 files changed, 65 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-omap2/omap-wakeupgen.c b/arch/arm/mach-omap2/omap-wakeupgen.c
index 86a0723..c302657 100644
--- a/arch/arm/mach-omap2/omap-wakeupgen.c
+++ b/arch/arm/mach-omap2/omap-wakeupgen.c
@@ -35,24 +35,38 @@
 
 /* maximum value correspond to that of AM43x */
 #define MAX_NR_REG_BANKS	7
-#define MAX_IRQS		224
+#define NR_IRQS_PER_BANK	32
+#define MAX_IRQS		(MAX_NR_REG_BANKS * NR_IRQS_PER_BANK)
 #define DEFAULT_NR_REG_BANKS	5
 #define DEFAULT_IRQS		160
+
 #define WKG_MASK_ALL		0x00000000
 #define WKG_UNMASK_ALL		0xffffffff
 #define CPU_ENA_OFFSET		0x400
 #define CPU0_ID			0x0
 #define CPU1_ID			0x1
+
 #define OMAP4_NR_BANKS		4
-#define OMAP4_NR_IRQS		128
+#define OMAP5_NR_BANKS		5
+#define AM43XX_NR_BANKS		7
 
 static void __iomem *wakeupgen_base;
 static void __iomem *sar_base;
 static DEFINE_RAW_SPINLOCK(wakeupgen_lock);
+
 static unsigned int irq_target_cpu[MAX_IRQS];
-static unsigned int irq_banks = DEFAULT_NR_REG_BANKS;
 static unsigned int max_irqs = DEFAULT_IRQS;
 static unsigned int omap_secure_apis, secure_api_index;
+static unsigned int irq_banks = MAX_NR_REG_BANKS;
+static unsigned int irq_target_cpu[MAX_IRQS];
+static unsigned int wakeupgen_context[MAX_NR_REG_BANKS];
+
+struct omap_wakeupgen_ops {
+	void (*save_context)(void);
+	void (*restore_context)(void);
+};
+
+static struct omap_wakeupgen_ops *wakeupgen_ops;
 
 /*
  * Static helper functions.
@@ -275,6 +289,16 @@ static inline void omap5_irq_save_context(void)
 
 }
 
+static inline void am43xx_irq_save_context(void)
+{
+	u32 i;
+
+	for (i = 0; i < irq_banks; i++) {
+		wakeupgen_context[i] = wakeupgen_readl(i, 0);
+		wakeupgen_writel(0, i, CPU0_ID);
+	}
+}
+
 /*
  * Save WakeupGen interrupt context in SAR BANK3. Restore is done by
  * ROM code. WakeupGen IP is integrated along with GIC to manage the
@@ -287,11 +311,7 @@ static void irq_save_context(void)
 {
 	if (!sar_base)
 		sar_base = omap4_get_sar_ram_base();
-
-	if (soc_is_omap54xx())
-		omap5_irq_save_context();
-	else
-		omap4_irq_save_context();
+	wakeupgen_ops->save_context();
 }
 
 /*
@@ -310,6 +330,20 @@ static void irq_sar_clear(void)
 	__raw_writel(val, sar_base + offset);
 }
 
+static void am43xx_irq_restore_context(void)
+{
+	u32 i;
+
+	for (i = 0; i < irq_banks; i++)
+		wakeupgen_writel(wakeupgen_context[i], i, CPU0_ID);
+}
+
+
+static void irq_restore_context(void)
+{
+	wakeupgen_ops->restore_context();
+}
+
 /*
  * Save GIC and Wakeupgen interrupt context using secure API
  * for HS/EMU devices.
@@ -367,7 +401,7 @@ static int irq_notifier(struct notifier_block *self, unsigned long cmd,	void *v)
 		break;
 	case CPU_CLUSTER_PM_EXIT:
 		if (omap_type() == OMAP2_DEVICE_TYPE_GP)
-			irq_sar_clear();
+			irq_restore_context();
 		break;
 	}
 	return NOTIFY_OK;
@@ -398,6 +432,23 @@ int omap_secure_apis_support(void)
 	return omap_secure_apis;
 }
 
+/* Define ops for context save and restore for each SoC */
+
+static struct omap_wakeupgen_ops omap4_wakeupgen_ops = {
+	.save_context = omap4_irq_save_context,
+	.restore_context = irq_sar_clear,
+};
+
+static struct omap_wakeupgen_ops omap5_wakeupgen_ops = {
+	.save_context = omap5_irq_save_context,
+	.restore_context = irq_sar_clear,
+};
+
+static struct omap_wakeupgen_ops am43xx_wakeupgen_ops = {
+	.save_context = am43xx_irq_save_context,
+	.restore_context = am43xx_irq_restore_context,
+};
+
 /*
  * Initialise the wakeupgen module.
  */
@@ -421,16 +472,19 @@ int __init omap_wakeupgen_init(void)
 
 	if (cpu_is_omap44xx()) {
 		irq_banks = OMAP4_NR_BANKS;
-		max_irqs = OMAP4_NR_IRQS;
 		omap_secure_apis = 1;
 		secure_api_index = OMAP4_HAL_SAVEGIC_INDEX;
+		wakeupgen_ops = &omap4_wakeupgen_ops;
 	} else if (soc_is_omap54xx()) {
 		secure_api_index = OMAP5_HAL_SAVEGIC_INDEX;
+		wakeupgen_ops = &omap5_wakeupgen_ops;
 	} else if (am43x) {
 		irq_banks = MAX_NR_REG_BANKS;
-		max_irqs = MAX_IRQS;
+		wakeupgen_ops = &am43xx_wakeupgen_ops;
 	}
 
+	max_irqs = MAX_IRQS;
+
 	/* Clear all IRQ bitmasks at wakeupGen level */
 	for (i = 0; i < irq_banks; i++) {
 		wakeupgen_writel(0, i, CPU0_ID);
-- 
1.7.5.4

