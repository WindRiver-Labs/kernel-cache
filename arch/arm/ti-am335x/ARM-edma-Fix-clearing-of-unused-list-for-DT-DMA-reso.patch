From ed23ec660a2c1448adec2a201d69fefa24e8bb02 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 30 Dec 2013 13:54:13 +0800
Subject: [PATCH 0418/1115] ARM: edma: Fix clearing of unused list for DT DMA
 resources

Upstream ID: 6cdaca481f6c415025c2687c109674919aa61934

Cause 25e26da4 is a dirty commit, so this is a new one.

HWMOD removal for MMC is breaking edma_start as the events are being manually
triggered due to unused channel list not being clear.

The above issue is fixed by reading the "dmas" property from the DT node if it
exists and clearing the bits in the unused channel list if the dma controller
used by any device is EDMA. For this purpose we use the of_* helpers to parse
the arguments in the dmas phandle list.

Also introduced is a minor clean up of a checkpatch error in old code.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/common/edma.c |   40 ++++++++++++++++++++++++----------------
 1 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 0d6d3dc..dc95efc 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -271,6 +271,11 @@ static const struct edmacc_param dummy_paramset = {
 	.ccnt = 1,
 };
 
+static const struct of_device_id edma_of_ids[] = {
+	{ .compatible = "ti,edma3", },
+	{}
+};
+
 /*****************************************************************************/
 
 static void map_dmach_queue(unsigned ctlr, unsigned ch_no,
@@ -562,25 +567,33 @@ static int reserve_contiguous_slots(int ctlr, unsigned int id,
 static int prepare_unused_channel_list(struct device *dev, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
-	int i = 0, ctlr;
-	u32 dma_chan;
-	const __be32 *dma_chan_p;
-	struct property *prop;
+	int i, count, ctlr;
+	struct of_phandle_args  dma_spec;
 
 	if (dev->of_node) {
-		of_property_for_each_u32(dev->of_node, "dmas", prop,
-					 dma_chan_p, dma_chan) {
-			if (i++ & 1) {
-				ctlr = EDMA_CTLR(dma_chan);
-				clear_bit(EDMA_CHAN_SLOT(dma_chan),
-					  edma_cc[ctlr]->edma_unused);
+		count = of_property_count_strings(dev->of_node, "dma-names");
+		if (count < 0)
+			return 0;
+		for (i = 0; i < count; i++) {
+			if (of_parse_phandle_with_args(dev->of_node, "dmas",
+						       "#dma-cells", i,
+						       &dma_spec))
+				continue;
+
+			if (!of_match_node(edma_of_ids, dma_spec.np)) {
+				of_node_put(dma_spec.np);
+				continue;
 			}
+
+			clear_bit(EDMA_CHAN_SLOT(dma_spec.args[0]),
+				  edma_cc[0]->edma_unused);
+			of_node_put(dma_spec.np);
 		}
 		return 0;
 	}
 
 	/* For non-OF case */
-	for (; i < pdev->num_resources; i++) {
+	for (i = 0; i < pdev->num_resources; i++) {
 		if ((pdev->resource[i].flags & IORESOURCE_DMA) &&
 				(int)pdev->resource[i].start >= 0) {
 			ctlr = EDMA_CTLR(pdev->resource[i].start);
@@ -1875,11 +1888,6 @@ static const struct dev_pm_ops edma_pm_ops = {
 	.resume_early = edma_pm_resume,
 };
 
-static const struct of_device_id edma_of_ids[] = {
-	{ .compatible = "ti,edma3", },
-	{}
-};
-
 static struct platform_driver edma_driver = {
 	.driver = {
 		.name	= "edma",
-- 
1.7.5.4

