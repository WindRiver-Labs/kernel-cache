From 1dd1f6aefd9574859e2754a07aa0b6e29c31cdeb Mon Sep 17 00:00:00 2001
From: Dave Gerlach <d-gerlach@ti.com>
Date: Wed, 13 Nov 2013 14:55:30 -0600
Subject: [PATCH 0659/1115] ARM: OMAP2+: omap_hwmod: Manually idle hwmods at
 suspend in omap_device

Method for manually idling hwmods that need it at every suspend cycle
that was introduced in commit 223c8a2bb48d42186f265f71cda0ad19c595a37f
does not consider if driver for hwmod is loaded as a module because
check only happens at boot. Move handling of idle to omap_device layer
so driver status can be checked at each cycle.

Signed-off-by: Dave Gerlach <d-gerlach@ti.com>
(cherry picked from commit 602ca7804618e537c7b66fb5fc7572777866ce91)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/io.c          |    3 +-
 arch/arm/mach-omap2/omap_device.c |   61 ++++++++++++++++++++++++++++--------
 arch/arm/mach-omap2/omap_device.h |    1 +
 arch/arm/mach-omap2/omap_hwmod.c  |   55 +++++----------------------------
 arch/arm/mach-omap2/omap_hwmod.h  |    3 +-
 5 files changed, 59 insertions(+), 64 deletions(-)

diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index 9532909..1c37656 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -28,6 +28,7 @@
 #include <linux/omap-dma.h>
 
 #include "omap_hwmod.h"
+#include "omap_device.h"
 #include "soc.h"
 #include "iomap.h"
 #include "voltage.h"
@@ -599,7 +600,7 @@ void __init am33xx_init_early(void)
 
 void __init am33xx_init_late(void)
 {
-	omap_hwmod_force_mstandby_repeated();
+	omap_device_force_mstandby_repeated();
 	omap2_common_pm_late_init();
 	am33xx_pm_init();
 }
diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c
index 8a0e2f7..3b3a46d 100644
--- a/arch/arm/mach-omap2/omap_device.c
+++ b/arch/arm/mach-omap2/omap_device.c
@@ -753,6 +753,53 @@ int omap_device_idle(struct platform_device *pdev)
 	return ret;
 }
 
+/*
+ * There are some IPs that do not have MSTANDBY asserted by default
+ * which is necessary for PER domain transition. If the drivers
+ * are not compiled into the kernel HWMOD code will not change the
+ * state of the IPs if the IP was never enabled, so we keep track of
+ * them here to idle them with a pm_notifier.
+ */
+
+static int _omap_mstandby_pm_notifier(struct notifier_block *self,
+					unsigned long action, void *dev)
+{
+	struct omap_hwmod_list *oh_list_item = NULL;
+	struct platform_device *pdev;
+	struct omap_device *od;
+
+	switch (action) {
+	case PM_POST_SUSPEND:
+		list_for_each_entry(oh_list_item,
+			omap_hwmod_force_mstandby_list_get(), oh_list) {
+			pdev = to_platform_device(
+					omap_device_get_by_hwmod_name(
+						  oh_list_item->oh->name));
+
+			od = to_omap_device(pdev);
+			if (od && od->_driver_status !=
+					BUS_NOTIFY_BOUND_DRIVER) {
+				omap_hwmod_enable(oh_list_item->oh);
+				omap_hwmod_idle(oh_list_item->oh);
+			}
+		}
+	}
+
+	return NOTIFY_DONE;
+}
+
+struct notifier_block pm_nb = {
+	.notifier_call = _omap_mstandby_pm_notifier,
+};
+
+int omap_device_force_mstandby_repeated(void)
+{
+	omap_hwmod_force_mstandby_repeated();
+	register_pm_notifier(&pm_nb);
+	return 0;
+}
+
+
 /**
  * omap_device_assert_hardreset - set a device's hardreset line
  * @pdev: struct platform_device * to reset
@@ -863,7 +910,6 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct omap_device *od = to_omap_device(pdev);
-	struct omap_hwmod *oh = NULL;
 	int i;
 
 	if (!od)
@@ -888,19 +934,6 @@ static int __init omap_device_late_idle(struct device *dev, void *data)
 				 __func__);
 			omap_device_idle(pdev);
 		}
-	} else {
-	/*
-	 * There are some IPs that do not have MSTANDBY asserted by default
-	 * which is necessary for PER domain transition. If the drivers
-	 * are not compiled into the kernel HWMOD code will not change the
-	 * state of the IPs if the IP was never enabled, so we keep track of
-	 * them here to idle them with a pm_notifier.
-	 */
-		for (i = 0; i < od->hwmods_cnt; i++) {
-			oh = od->hwmods[i];
-			if (oh->flags & HWMOD_FORCE_MSTANDBY_REPEATED)
-				omap_hwmod_disable_force_mstandby_repeated(oh);
-		}
 	}
 
 	return 0;
diff --git a/arch/arm/mach-omap2/omap_device.h b/arch/arm/mach-omap2/omap_device.h
index 45885b0..cac0d77 100644
--- a/arch/arm/mach-omap2/omap_device.h
+++ b/arch/arm/mach-omap2/omap_device.h
@@ -88,6 +88,7 @@ struct device *omap_device_get_by_hwmod_name(const char *oh_name);
 
 /* OMAP PM interface */
 int omap_device_get_context_loss_count(struct platform_device *pdev);
+int omap_device_force_mstandby_repeated(void);
 
 /* Other */
 
diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 5c46de9..89d9ecb 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3907,33 +3907,16 @@ int omap_hwmod_disable_wakeup(struct omap_hwmod *oh)
 	return 0;
 }
 
-/*
- * There are some IPs that do not have MSTANDBY asserted by default
- * which is necessary for PER domain transition. If the drivers
- * are not compiled into the kernel HWMOD code will not change the
- * state of the IPs if the IP was never enabled, so we keep track of
- * them here to idle them with a pm_notifier.
- */
-
-static int _omap_mstandby_pm_notifier(struct notifier_block *self,
-					unsigned long action, void *dev)
+static int omap_hwmod_enable_force_mstandby_repeated(struct omap_hwmod *oh)
 {
 	struct omap_hwmod_list *oh_list_item = NULL;
-	switch (action) {
-	case PM_POST_SUSPEND:
-		list_for_each_entry(oh_list_item,
-			&_oh_force_mstandby_repeated_list, oh_list) {
-			omap_hwmod_enable(oh_list_item->oh);
-			omap_hwmod_idle(oh_list_item->oh);
-		}
-	}
 
-	return NOTIFY_DONE;
-}
+	oh_list_item = kzalloc(sizeof(*oh_list_item), GFP_KERNEL);
+	oh_list_item->oh = oh;
+	list_add(&oh_list_item->oh_list, &_oh_force_mstandby_repeated_list);
 
-struct notifier_block pm_nb = {
-	.notifier_call = _omap_mstandby_pm_notifier,
-};
+	return 0;
+}
 
 static int _check_for_force_mstandby_repeated(struct omap_hwmod *oh, void *data)
 {
@@ -3946,34 +3929,12 @@ static int _check_for_force_mstandby_repeated(struct omap_hwmod *oh, void *data)
 int omap_hwmod_force_mstandby_repeated(void)
 {
 	omap_hwmod_for_each(_check_for_force_mstandby_repeated, NULL);
-	register_pm_notifier(&pm_nb);
 	return 0;
 }
 
-int omap_hwmod_enable_force_mstandby_repeated(struct omap_hwmod *oh)
+struct list_head *omap_hwmod_force_mstandby_list_get(void)
 {
-	struct omap_hwmod_list *oh_list_item = NULL;
-
-	oh_list_item = kzalloc(sizeof(*oh_list_item), GFP_KERNEL);
-	oh_list_item->oh = oh;
-	list_add(&oh_list_item->oh_list, &_oh_force_mstandby_repeated_list);
-
-	return 0;
-}
-
-int omap_hwmod_disable_force_mstandby_repeated(struct omap_hwmod *oh)
-{
-	struct omap_hwmod_list *oh_list_item, *tmp;
-
-	list_for_each_entry_safe(oh_list_item, tmp,
-		&_oh_force_mstandby_repeated_list, oh_list) {
-			if (oh_list_item->oh == oh) {
-				list_del(&oh_list_item->oh_list);
-				kfree(oh_list_item);
-			}
-		}
-
-	return 0;
+	return &_oh_force_mstandby_repeated_list;
 }
 
 /**
diff --git a/arch/arm/mach-omap2/omap_hwmod.h b/arch/arm/mach-omap2/omap_hwmod.h
index 6b6009b..f16afc6 100644
--- a/arch/arm/mach-omap2/omap_hwmod.h
+++ b/arch/arm/mach-omap2/omap_hwmod.h
@@ -749,8 +749,7 @@ int omap_hwmod_no_setup_reset(struct omap_hwmod *oh);
 int omap_hwmod_pad_route_irq(struct omap_hwmod *oh, int pad_idx, int irq_idx);
 
 int omap_hwmod_force_mstandby_repeated(void);
-int omap_hwmod_enable_force_mstandby_repeated(struct omap_hwmod *oh);
-int omap_hwmod_disable_force_mstandby_repeated(struct omap_hwmod *oh);
+struct list_head *omap_hwmod_force_mstandby_list_get(void);
 
 extern void __init omap_hwmod_init(void);
 
-- 
1.7.5.4

