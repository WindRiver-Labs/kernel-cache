From 09a1b59fa2b2ddfcc106496ed89cba5a4e14f673 Mon Sep 17 00:00:00 2001
From: Archit Taneja <archit@ti.com>
Date: Mon, 2 Dec 2013 19:06:26 +0530
Subject: [PATCH 0762/1115] omapdss: dra evm tpd12s015 encoder: Enable hot
 plug detect

Add hot plug detect support in the tpd encoder driver used by DRA7 EVM. Hot plug
detect on the dra7 evm became functional only after rev E. This revision has a
direct connection of the HPD_A signal from the tpd level shifter to a GPIO.

The previous EVMs had the signal going via a gpio expander, which forced us to
kepp the I2C2/HDMI demux in HDMI mode whenever possible to detect a hot plug
event. We now remove the demuxing, and limit it only to reading EDID.

Add a hpd handler which configures the LS_OE line like done in the original
tpd encoder driver.

The HPD_B signal on the level shifter shows a glitch on cable connect. The TPD
level shifter hardware is supposed to prevent these glitches using it's own
debouncing hardware. But the glitch is seen on HPD_A too, and requires us to
set debounce for the DRA7x gpio.
The nature of the glitch is an instant rise to around 3V, followed by a lot of
noise, and ending with a slow taper down of the voltage. The actual connect
event comes around 80 ms later. Keep the omap-gpio debounce time to
1 millisecond to ensure that the complete glitch duration is covered. The
reason why the glitch isn't filtered by the level shifter needs to be
investigated.

Create a DT property called "disable-hpd" to disable hot plug detect. This
should be added in the encoder's DT node for pre-revE+ boards. Having this
property prevents the driver from registering an irq-handler, and performs a
manual enable of LS_OE pin on the TPD chip. pre-revE+ boards also require a
demux as the hpd signal reaches the gpio only when we switch to the HDMI demux
mode, preform that too when the property exists.

Signed-off-by: Archit Taneja <archit@ti.com>
(cherry picked from commit afc0d59aa30655b63d3e9c04d62392df7173f850)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../omap2/displays-new/dra-evm-encoder-tpd12s015.c |  153 ++++++++++++++++----
 1 files changed, 127 insertions(+), 26 deletions(-)

diff --git a/drivers/video/omap2/displays-new/dra-evm-encoder-tpd12s015.c b/drivers/video/omap2/displays-new/dra-evm-encoder-tpd12s015.c
index 392cbef..7074705 100644
--- a/drivers/video/omap2/displays-new/dra-evm-encoder-tpd12s015.c
+++ b/drivers/video/omap2/displays-new/dra-evm-encoder-tpd12s015.c
@@ -9,6 +9,7 @@
  * the Free Software Foundation.
  */
 
+#include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -36,6 +37,9 @@
 #define SEL_I2C2	0
 #define SEL_HDMI	1
 
+/* HPD gpio debounce time in microseconds */
+#define HPD_DEBOUNCE_TIME	1000
+
 struct panel_drv_data {
 	struct omap_dss_device dssdev;
 	struct omap_dss_device *in;
@@ -44,7 +48,11 @@ struct panel_drv_data {
 	int ls_oe_gpio;
 	int hpd_gpio;
 
+	bool disable_hpd;
+
 	struct omap_video_timings timings;
+
+	struct completion hpd_completion;
 };
 
 static void config_sel_hdmi_i2c2(struct device *dev)
@@ -144,6 +152,27 @@ err_ctrl:
 
 #define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)
 
+static irqreturn_t tpd_hpd_irq_handler(int irq, void *data)
+{
+	struct panel_drv_data *ddata = data;
+	bool hpd;
+
+	hpd = gpio_get_value_cansleep(ddata->hpd_gpio);
+
+	dev_dbg(ddata->dssdev.dev, "hpd %d\n", hpd);
+
+	if (gpio_is_valid(ddata->ls_oe_gpio)) {
+		if (hpd)
+			gpio_set_value_cansleep(ddata->ls_oe_gpio, 1);
+		else
+			gpio_set_value_cansleep(ddata->ls_oe_gpio, 0);
+	}
+
+	complete_all(&ddata->hpd_completion);
+
+	return IRQ_HANDLED;
+}
+
 static int tpd_connect(struct omap_dss_device *dssdev,
 		struct omap_dss_device *dst)
 {
@@ -159,32 +188,49 @@ static int tpd_connect(struct omap_dss_device *dssdev,
 	dst->src = dssdev;
 	dssdev->dst = dst;
 
-	config_demux(dssdev->dev, SEL_I2C2);
+	INIT_COMPLETION(ddata->hpd_completion);
 
 	gpio_set_value_cansleep(ddata->ct_cp_hpd_gpio, 1);
 
-	config_demux(dssdev->dev, SEL_HDMI);
-
 	/* DC-DC converter needs at max 300us to get to 90% of 5V */
 	udelay(300);
 
-	/*
-	 * If there's a cable connected, hpd will be up, turn the level shifters
-	 * accordingly
-	 */
-	hpd = gpio_get_value_cansleep(ddata->hpd_gpio);
-
-	config_demux(dssdev->dev, SEL_I2C2);
-
-	if (gpio_is_valid(ddata->ls_oe_gpio)) {
-		if (hpd)
-			gpio_set_value_cansleep(ddata->ls_oe_gpio, 1);
-		else
-			gpio_set_value_cansleep(ddata->ls_oe_gpio, 0);
+	if (!ddata->disable_hpd) {
+		/*
+		 * if there's a cable connected, wait for the hpd irq to
+		 * trigger, which turns on the level shifters.
+		 */
+		hpd = gpio_get_value_cansleep(ddata->hpd_gpio);
+
+		if (hpd) {
+			unsigned long to;
+			to = wait_for_completion_timeout(&ddata->hpd_completion,
+					msecs_to_jiffies(250));
+			WARN_ON_ONCE(to == 0);
+		}
+	} else {
+		/*
+		 * if there's a cable connected, the hpd gpio should be up, turn
+		 * the level shifters accordingly, we don't wait for a hot plug
+		 * event here since we don't have hpd interrupts enabled. We
+		 * also need to swith the demux to HDMI mode to read hpd gpio,
+		 * and then switch back to I2C2 in order to control the level
+		 * shifter
+		 */
+		config_demux(dssdev->dev, SEL_HDMI);
+
+		hpd = gpio_get_value_cansleep(ddata->hpd_gpio);
+
+		config_demux(dssdev->dev, SEL_I2C2);
+
+		if (gpio_is_valid(ddata->ls_oe_gpio)) {
+			if (hpd)
+				gpio_set_value_cansleep(ddata->ls_oe_gpio, 1);
+			else
+				gpio_set_value_cansleep(ddata->ls_oe_gpio, 0);
+		}
 	}
 
-	config_demux(dssdev->dev, SEL_HDMI);
-
 	return 0;
 }
 
@@ -199,12 +245,8 @@ static void tpd_disconnect(struct omap_dss_device *dssdev,
 	if (dst != dssdev->dst)
 		return;
 
-	config_demux(dssdev->dev, SEL_I2C2);
-
 	gpio_set_value_cansleep(ddata->ct_cp_hpd_gpio, 0);
 
-	config_demux(dssdev->dev, SEL_HDMI);
-
 	dst->src = NULL;
 	dssdev->dst = NULL;
 
@@ -281,18 +323,43 @@ static int tpd_read_edid(struct omap_dss_device *dssdev,
 {
 	struct panel_drv_data *ddata = to_panel_data(dssdev);
 	struct omap_dss_device *in = ddata->in;
+	int r = 0;
+
+	if (ddata->disable_hpd)
+		config_demux(dssdev->dev, SEL_HDMI);
 
 	if (!gpio_get_value_cansleep(ddata->hpd_gpio))
-		return -ENODEV;
+		r = -ENODEV;
+
+	if (ddata->disable_hpd)
+		config_demux(dssdev->dev, SEL_I2C2);
+
+	if (r)
+		return r;
+
+	config_demux(dssdev->dev, SEL_HDMI);
+
+	r = in->ops.hdmi->read_edid(in, edid, len);
+
+	config_demux(dssdev->dev, SEL_I2C2);
 
-	return in->ops.hdmi->read_edid(in, edid, len);
+	return r;
 }
 
 static bool tpd_detect(struct omap_dss_device *dssdev)
 {
 	struct panel_drv_data *ddata = to_panel_data(dssdev);
+	bool hpd;
+
+	if (ddata->disable_hpd)
+		config_demux(dssdev->dev, SEL_HDMI);
+
+	hpd = gpio_get_value_cansleep(ddata->hpd_gpio);
+
+	if (ddata->disable_hpd)
+		config_demux(dssdev->dev, SEL_I2C2);
 
-	return gpio_get_value_cansleep(ddata->hpd_gpio);
+	return hpd;
 }
 
 static int tpd_audio_enable(struct omap_dss_device *dssdev)
@@ -438,6 +505,9 @@ static int tpd_probe_of(struct platform_device *pdev)
 	}
 	ddata->hpd_gpio = gpio;
 
+	if (of_find_property(node, "disable-hpd", NULL))
+		ddata->disable_hpd = true;
+
 	return 0;
 }
 
@@ -453,6 +523,8 @@ static int tpd_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, ddata);
 
+	init_completion(&ddata->hpd_completion);
+
 	if (dev_get_platdata(&pdev->dev)) {
 		r = tpd_probe_pdata(pdev);
 		if (r)
@@ -482,12 +554,39 @@ static int tpd_probe(struct platform_device *pdev)
 			goto err_gpio;
 	}
 
+	if (ddata->disable_hpd)
+		config_demux(&pdev->dev, SEL_HDMI);
+
 	r = devm_gpio_request_one(&pdev->dev, ddata->hpd_gpio,
 			GPIOF_DIR_IN, "hdmi_hpd");
+
+	if (ddata->disable_hpd)
+		config_demux(&pdev->dev, SEL_I2C2);
 	if (r)
 		goto err_gpio;
 
-	config_demux(&pdev->dev, SEL_HDMI);
+	/*
+	 * we see some low voltage glitches on the HPD_B line before it
+	 * stabalizes to around 5V. We see the effects of this glitch on the
+	 * HPD_A side, and hence on the gpio on DRA7x. The glitch is quite short
+	 * in duration, but it takes a while for the voltage to go down back to
+	 * 0 volts, we set a debounce value of 1 millisecond to prevent this,
+	 * the reason for the glitch not being taken care of by the TPD chip
+	 * needs to be investigated
+	 */
+	if (!ddata->disable_hpd) {
+		r = gpio_set_debounce(ddata->hpd_gpio, HPD_DEBOUNCE_TIME);
+		if (r)
+			goto err_debounce;
+
+		r = devm_request_threaded_irq(&pdev->dev,
+				gpio_to_irq(ddata->hpd_gpio), NULL,
+				tpd_hpd_irq_handler, IRQF_TRIGGER_RISING |
+				IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "hpd",
+				ddata);
+		if (r)
+			goto err_irq;
+	}
 
 	dssdev = &ddata->dssdev;
 	dssdev->ops.hdmi = &tpd_hdmi_ops;
@@ -506,6 +605,8 @@ static int tpd_probe(struct platform_device *pdev)
 
 	return 0;
 err_reg:
+err_debounce:
+err_irq:
 err_gpio:
 	omap_dss_put_device(ddata->in);
 	return r;
-- 
1.7.5.4

