From d21e4e1b8604c55fb7043614da6602f27c95a27c Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 15 Apr 2010 15:07:11 +0800
Subject: [PATCH 1/2] OMAP3: add gpio pad config save and restore for pm

Some devices(LAN9115 Ether chip) can't work anymore when resume from
suspending at power-off state, the cause is that we don't save and
restore gpio pad config.

[Original code taken from AM35x-OMAP35x-PSP-SDK-03.00.00.03 BSP
package:http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/ \
targetcontent/psp/AM35x-OMAP35x-PSP-SDK/03_00/index_FDS.html]

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-omap2/pm34xx.c           |    6 +-
 arch/arm/plat-omap/gpio.c              |  212 ++++++++++++++++++++++++++++++++
 arch/arm/plat-omap/include/plat/gpio.h |    1 +
 3 files changed, 218 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ea0000b..f487b18 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -454,8 +454,12 @@ void omap_sram_idle(void)
 	/* PER */
 	if (per_next_state < PWRDM_POWER_ON) {
 		per_prev_state = pwrdm_read_prev_pwrst(per_pwrdm);
-		if (per_prev_state == PWRDM_POWER_OFF)
+		if (per_prev_state == PWRDM_POWER_OFF) {
 			omap3_per_restore_context();
+			omap3_gpio_restore_pad_context(0);
+		}
+		if (per_next_state == PWRDM_POWER_OFF)
+			omap3_gpio_restore_pad_context(1);
 		omap2_gpio_resume_after_retention();
 		omap_uart_resume_idle(2);
 		if (per_state_modified)
diff --git a/arch/arm/plat-omap/gpio.c b/arch/arm/plat-omap/gpio.c
index 76a347b..5411708 100644
--- a/arch/arm/plat-omap/gpio.c
+++ b/arch/arm/plat-omap/gpio.c
@@ -21,12 +21,14 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 
 #include <mach/hardware.h>
 #include <asm/irq.h>
 #include <mach/irqs.h>
 #include <mach/gpio.h>
 #include <asm/mach/irq.h>
+#include <plat/control.h>
 
 /*
  * OMAP1510 GPIO registers
@@ -307,7 +309,68 @@ struct omap3_gpio_regs {
 	u32 setdataout;
 };
 
+#define OMAP34XX_PAD_SAFE_MODE		0x7
+#define OMAP34XX_PAD_IN_PU_GPIO		0x11c
+#define OMAP34XX_PAD_IN_PD_GPIO		0x10c
+#define OMAP3_PADCONF_WAKEUPENABLE0	(1 << 14)
+#define OMAP34XX_GPIO_AMT		(32 * OMAP34XX_NR_GPIOS)
+
 static struct omap3_gpio_regs gpio_context[OMAP34XX_NR_GPIOS];
+
+/* GPIO -> PAD init configuration struct */
+struct gpio_pad_range {
+	/* Range start GPIO # */
+	u16 min;
+	/* Range end GPIO # */
+	u16 max;
+	/* Start pad config offset */
+	u16 offset;
+};
+
+/*
+ * Defines GPIO to padconfig mapping. For example first definition tells
+ * us that there is a range of GPIOs 34...43 which have their padconfigs
+ * starting from offset 0x7a, i.e. gpio 34->0x7a, 35->0x7c, 36->0x7e ... etc.
+ */
+static const struct gpio_pad_range gpio_pads_config[] = {
+	{ 34, 43, 0x7a },
+	{ 44, 51, 0x9e },
+	{ 52, 59, 0xb0 },
+	{ 60, 62, 0xc6 },
+	{ 63, 111, 0xce },
+	{ 167, 167, 0x130 },
+	{ 126, 126, 0x132 },
+	{ 112, 166, 0x134 },
+	{ 120, 122, 0x1a2 },
+	{ 124, 125, 0x1a8 },
+	{ 130, 131, 0x1ac },
+	{ 169, 169, 0x1b0 },
+	{ 188, 191, 0x1b2 },
+	{ 168, 168, 0x1be },
+	{ 183, 185, 0x1c0 },
+	{ 170, 182, 0x1c6 },
+	{ 0, 0, 0x1e0 },
+	{ 186, 186, 0x1e2 },
+	{ 187, 187, 0x238 },
+	{ 32, 32, 0x23a },
+	{ 12, 29, 0x5d8 },
+	{ 1, 1, 0xa06 },
+	{ 30, 30, 0xa08 },
+	{ 2, 10, 0xa0a },
+	{ 11, 11, 0xa24 },
+	{ 31, 31, 0xa26 },
+};
+
+/* GPIO -> PAD config mapping for OMAP3 */
+struct gpio_pad {
+	s16 gpio;
+	u16 offset;
+	u16 save;
+};
+
+static struct gpio_pad *gpio_pads;
+static u16 gpio_pad_map[OMAP34XX_GPIO_AMT];
+
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
@@ -1647,6 +1710,61 @@ static struct clk * gpio5_fck;
 static struct clk *gpio_iclks[OMAP34XX_NR_GPIOS];
 #endif
 
+#ifdef CONFIG_ARCH_OMAP3
+/*
+ * Following pad init code in addition to the context / restore hooks are
+ * needed to fix glitches in GPIO outputs during off-mode. See OMAP3
+ * errate section 1.158
+ */
+static int __init omap3_gpio_pads_init(void)
+{
+	int i, j, min, max, gpio_amt;
+	u16 offset;
+
+	gpio_amt = 0;
+	for (i = 0; i < ARRAY_SIZE(gpio_pads_config); i++) {
+		min = gpio_pads_config[i].min;
+		max = gpio_pads_config[i].max;
+		offset = gpio_pads_config[i].offset;
+
+		for (j = min; j <= max; j++) {
+			/* Check if pad has been configured as GPIO. */
+			if ((omap_ctrl_readw(offset) &
+				0x7) == 0x4) {
+				gpio_pad_map[j] = offset;
+				if (j > 31)
+					gpio_amt++;
+			}
+			offset += 2;
+		}
+	}
+	gpio_pads = kmalloc(sizeof(struct gpio_pad) * (gpio_amt + 1),
+		GFP_KERNEL);
+
+	if (gpio_pads == NULL) {
+		printk(KERN_ERR "FATAL: Failed to allocate gpio_pads\n");
+		return -ENOMEM;
+	}
+
+	gpio_amt = 0;
+	for (i = 0; i < OMAP34XX_GPIO_AMT; i++) {
+		/*
+		 * First module (gpio 0...31) is ignored as it is
+		 * in wakeup domain and does not need special
+		 * handling during off mode.
+		 */
+		if (gpio_pad_map[i] && i > 31) {
+			gpio_pads[gpio_amt].gpio = i;
+			gpio_pads[gpio_amt].offset = gpio_pad_map[i];
+			gpio_amt++;
+		}
+	}
+	gpio_pads[gpio_amt].gpio = -1;
+	return 0;
+}
+late_initcall(omap3_gpio_pads_init);
+#endif
+
 static void __init omap_gpio_show_rev(void)
 {
 	u32 rev;
@@ -1961,6 +2079,27 @@ static int omap_gpio_suspend(struct sys_device *dev, pm_message_t mesg)
 		__raw_writel(0xffffffff, wake_clear);
 		__raw_writel(bank->suspend_wakeup, wake_set);
 		spin_unlock_irqrestore(&bank->lock, flags);
+
+#ifdef CONFIG_ARCH_OMAP3
+		if (bank->method == METHOD_GPIO_24XX) {
+			int j;
+			for (j = 0; j < 32; j++) {
+				int offset = gpio_pad_map[j + i * 32];
+				u16 v;
+
+				if (!offset)
+					continue;
+
+				v = omap_ctrl_readw(offset);
+				if (bank->suspend_wakeup & (1 << j))
+					v |= OMAP3_PADCONF_WAKEUPENABLE0;
+				else
+					v &= ~OMAP3_PADCONF_WAKEUPENABLE0;
+				omap_ctrl_writew(v, offset);
+			}
+		}
+#endif
+
 	}
 
 	return 0;
@@ -2181,6 +2320,12 @@ void omap2_gpio_resume_after_retention(void)
 void omap_gpio_save_context(void)
 {
 	int i;
+	struct gpio_bank *bank;
+	int n;
+	u16 offset, conf;
+	u32 out, pin;
+	struct gpio_pad *pad;
+	u32 tmp_oe[OMAP34XX_NR_GPIOS];
 
 	/* saving banks from 2-6 only since GPIO1 is in WKUP */
 	for (i = 1; i < gpio_bank_count; i++) {
@@ -2197,6 +2342,7 @@ void omap_gpio_save_context(void)
 			__raw_readl(bank->base + OMAP24XX_GPIO_CTRL);
 		gpio_context[i].oe =
 			__raw_readl(bank->base + OMAP24XX_GPIO_OE);
+		tmp_oe[i] = gpio_context[i].oe;
 		gpio_context[i].leveldetect0 =
 			__raw_readl(bank->base + OMAP24XX_GPIO_LEVELDETECT0);
 		gpio_context[i].leveldetect1 =
@@ -2212,6 +2358,46 @@ void omap_gpio_save_context(void)
 		gpio_context[i].setdataout =
 			__raw_readl(bank->base + OMAP24XX_GPIO_SETDATAOUT);
 	}
+
+	pad = gpio_pads;
+
+	if (pad == NULL)
+		return;
+
+	while (pad->gpio >= 0) {
+		/* n = gpio number, 0..191 */
+		n = pad->gpio;
+		/* i = gpio bank, 0..5 */
+		i = n >> 5;
+		/* offset of padconf register */
+		offset = pad->offset;
+		bank = &gpio_bank[i];
+		/* bit position of gpio in the bank 0..31 */
+		pin = 1 << (n & 0x1f);
+
+		/* check if gpio is configured as output => need hack */
+		if (!(tmp_oe[i] & pin)) {
+			/* save current padconf setting */
+			pad->save = omap_ctrl_readw(offset);
+			out = gpio_context[i].dataout;
+			if (out & pin)
+				/* High: PU + input */
+				conf = OMAP34XX_PAD_IN_PU_GPIO;
+			else
+				/* Low: PD + input */
+				conf = OMAP34XX_PAD_IN_PD_GPIO;
+			/* Set PAD to GPIO + input */
+			omap_ctrl_writew(conf, offset);
+			/* Set GPIO to input */
+			tmp_oe[i] |= pin;
+			__raw_writel(tmp_oe[i],
+					bank->base + OMAP24XX_GPIO_OE);
+			/* Set PAD to safe mode */
+			omap_ctrl_writew(conf | OMAP34XX_PAD_SAFE_MODE, offset);
+		} else
+			pad->save = 0;
+		pad++;
+	}
 }
 
 /* restore the required registers of bank 2-6 */
@@ -2249,6 +2435,32 @@ void omap_gpio_restore_context(void)
 				bank->base + OMAP24XX_GPIO_SETDATAOUT);
 	}
 }
+
+void omap3_gpio_restore_pad_context(int restore_oe)
+{
+	struct gpio_pad *pad;
+	int i;
+
+	pad = gpio_pads;
+
+	if (restore_oe) {
+		for (i = 1; i < gpio_bank_count; i++) {
+			struct gpio_bank *bank = &gpio_bank[i];
+			__raw_writel(gpio_context[i].oe,
+				     bank->base + OMAP24XX_GPIO_OE);
+		}
+	}
+
+	if (pad == NULL)
+		return;
+
+	while (pad->gpio >= 0) {
+		if (pad->save)
+			omap_ctrl_writew(pad->save, pad->offset);
+		pad++;
+	}
+}
+
 #endif
 
 /*
diff --git a/arch/arm/plat-omap/include/plat/gpio.h b/arch/arm/plat-omap/include/plat/gpio.h
index de7c547..426cca6 100644
--- a/arch/arm/plat-omap/include/plat/gpio.h
+++ b/arch/arm/plat-omap/include/plat/gpio.h
@@ -78,6 +78,7 @@ extern void omap_set_gpio_debounce(int gpio, int enable);
 extern void omap_set_gpio_debounce_time(int gpio, int enable);
 extern void omap_gpio_save_context(void);
 extern void omap_gpio_restore_context(void);
+extern void omap3_gpio_restore_pad_context(int restore_oe);
 /*-------------------------------------------------------------------------*/
 
 /* Wrappers for "new style" GPIO calls, using the new infrastructure
-- 
1.6.5.2

