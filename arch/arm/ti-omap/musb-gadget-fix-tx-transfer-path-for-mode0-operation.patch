From e404673dba1098375254e59470735241812774bd Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Thu, 13 May 2010 12:09:23 +0530
Subject: [PATCH 013/108] musb: gadget: fix tx transfer path for mode0 operation

commit 1f8703907bc5b0314815cd2472f053e5ec25fbcc from
the branch origin/OMAPPSP_03.00.01.06 of
git://arago-project.org/git/projects/linux-omap3.git

Current gadget Tx path always programs DMA in mode-1 if request length
is more than packet size. As system DMA can work only in mode-0 so
updating the DMA mode and transfer length for it.

Also fixed an issue in device Tx completion path where 'is_dma' is
getting set unconditionally. This would fail the io if Tx transfer
is done in mode-0. Fixed it by updating it based on
'request->actual' length.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/usb/musb/musb_gadget.c |   20 +++++++++++++++++++-
 1 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 180da4e..9a5cc68 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -317,6 +317,21 @@ static void txstate(struct musb *musb, struct musb_request *req)
 			else
 				musb_ep->dma->desired_mode = 1;
 
+			/*
+			 * Use system dma for unaligned buffers on RTL >= 1.8
+			 * for Inventra DMA. As system DMA can work only in
+			 * mode-0 so update the desired_mode and request_size.
+			 */
+			if (((request->dma + request->actual) & 0x3) &&
+				(musb->hwvers >= MUSB_HWVERS_1800)) {
+
+				request_size = min_t(size_t,
+					musb_ep->hw_ep->max_packet_sz_tx,
+					request->length - request->actual);
+
+				musb_ep->dma->desired_mode = 0;
+			}
+
 			use_dma = use_dma && c->channel_program(
 					musb_ep->dma, musb_ep->packet_sz,
 					musb_ep->dma->desired_mode,
@@ -463,7 +478,6 @@ void musb_g_tx(struct musb *musb, u8 epnum)
 		u8	is_dma = 0;
 
 		if (dma && (csr & MUSB_TXCSR_DMAENAB)) {
-			is_dma = 1;
 			csr |= MUSB_TXCSR_P_WZC_BITS;
 			csr &= ~(MUSB_TXCSR_DMAENAB | MUSB_TXCSR_P_UNDERRUN |
 				 MUSB_TXCSR_TXPKTRDY);
@@ -471,6 +485,10 @@ void musb_g_tx(struct musb *musb, u8 epnum)
 			/* Ensure writebuffer is empty. */
 			csr = musb_readw(epio, MUSB_TXCSR);
 			request->actual += musb_ep->dma->actual_len;
+
+			if (request->actual == request->length)
+				is_dma = 1;
+
 			DBG(4, "TXCSR%d %04x, DMA off, len %zu, req %p\n",
 				epnum, csr, musb_ep->dma->actual_len, request);
 		}
-- 
1.7.0.4

