From 3b9c85616635af2df604bd12b9b6844e253eb732 Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Thu, 1 Apr 2010 11:17:05 +0530
Subject: [PATCH 014/108] USB: musb: allow unaligned memory data transfers

commit 7b8926aa626991fa087b00f6bbc1fb6b0e8269b0 from
the branch origin/OMAPPSP_03.00.01.06 of
git://arago-project.org/git/projects/linux-omap3.git

On MUSB:IP rev RTL1.8 and above(OMAP3630, OMAP4),
DMA addresses have to be word aligned.

g-ether gadget passes unaligned buffers to the controller
For such buffers, dma fails and a fall back mechanism of interrupt
mode is used

Validated on Zoom3 with g-ether diver

Signed-off-by: Anand Gadiyar <gadiyar@ti.com>
Signed-off-by: Vikram Pandita <vikram.pandita@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/usb/musb/musb_gadget.c |    9 ++++++++-
 drivers/usb/musb/musbhsdma.c   |   11 +++++++++++
 2 files changed, 19 insertions(+), 1 deletions(-)

diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 9a5cc68..31e8336 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -708,8 +708,15 @@ static void rxstate(struct musb *musb, struct musb_request *req)
 							transfer_size);
 				}
 
-				if (use_dma)
+				if (use_dma) {
 					return;
+				} else {
+					/* Need to clear DMAENAB for the
+					 * backup PIO mode transfer to work
+					 */
+					csr &= ~MUSB_RXCSR_DMAENAB;
+					musb_writew(epio, MUSB_RXCSR, csr);
+				}
 			}
 #endif	/* Mentor's DMA */
 
diff --git a/drivers/usb/musb/musbhsdma.c b/drivers/usb/musb/musbhsdma.c
index d29e487..07d2358 100644
--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -353,6 +353,8 @@ static int dma_channel_program(struct dma_channel *channel,
 				dma_addr_t dma_addr, u32 len)
 {
 	struct musb_dma_channel *musb_channel = channel->private_data;
+	struct musb_dma_controller *controller = musb_channel->controller;
+	struct musb *musb = controller->private_data;
 
 	DBG(2, "ep%d-%s pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",
 		musb_channel->epnum,
@@ -362,6 +364,15 @@ static int dma_channel_program(struct dma_channel *channel,
 	BUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||
 		channel->status == MUSB_DMA_STATUS_BUSY);
 
+	/* On MUSB:RTL1.8 and above, DMA has to be word aligned */
+	if ((dma_addr % 4) &&
+		(musb->hwvers >= MUSB_HWVERS_1800)) {
+		/* Fail DMA for unaligned buffers:
+		 * Use PIO for such buffers
+		 */
+		return false;
+	}
+
 	channel->actual_len = 0;
 	musb_channel->start_addr = dma_addr;
 	musb_channel->len = len;
-- 
1.7.0.4

