From 4ada17daef2279c7bdd4d7603db2d6a03ca201ca Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 28 Jul 2010 10:51:48 +0800
Subject: [PATCH 003/108] OMAP3EVM: enable NAND support

Enable Nand support on OMAP3EVM.

[Picked from the commit bbaef015 of http://arago-project.org/git/\
 projects/linux-omap3.git]

Signed-off-by: Sriramakrishnan <srk@ti.com>
Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-omap2/board-omap3evm.c |   81 ++++++++++++++++++++++++++++++++++
 1 files changed, 81 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index bcffa3a..13e728f 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -43,6 +43,7 @@
 #include <plat/mcspi.h>
 #include <plat/display.h>
 #include <plat/onenand.h>
+#include <plat/nand.h>
 #include <plat/gpmc.h>
 
 #include "mux.h"
@@ -230,6 +231,85 @@ static void __init omap3_evm_onenand_init(void) {}
 
 #endif
 
+#if defined(CONFIG_MTD_NAND_OMAP2) || \
+	defined(CONFIG_MTD_NAND_OMAP2_MODULE)
+static struct mtd_partition omap3evm_nand_partitions[] = {
+	/* All the partition sizes are listed in terms of NAND block size */
+	{
+		.name           = "xloader-nand",
+		.offset         = 0,
+		.size           = 4*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "uboot-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 14*(SZ_128K),
+		.mask_flags     = MTD_WRITEABLE
+	},
+	{
+		.name           = "params-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 2*(SZ_128K)
+	},
+	{
+		.name           = "linux-nand",
+		.offset         = MTDPART_OFS_APPEND,
+		.size           = 40*(SZ_128K)
+	},
+	{
+		.name           = "jffs2-nand",
+		.size           = MTDPART_SIZ_FULL,
+		.offset         = MTDPART_OFS_APPEND,
+	},
+};
+
+static struct omap_nand_platform_data omap3evm_nand_data = {
+	.parts          = omap3evm_nand_partitions,
+	.nr_parts       = ARRAY_SIZE(omap3evm_nand_partitions),
+	.nand_setup     = NULL,
+	.dma_channel    = -1,           /* disable DMA in OMAP NAND driver */
+	.dev_ready      = NULL,
+	.devsize	= 1,	/* '0' for 8-bit, '1' for 16-bit device */
+};
+
+void __init omap3_evm_nand_init(void)
+{
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
+
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+
+			/* Found it!! */
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+
+		cs++;
+	}
+
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+		       " in GPMC\n ");
+		return;
+	}
+
+	omap3evm_nand_data.cs   = nandcs;
+	omap3evm_nand_data.gpmc_cs_baseaddr = (void *)(gpmc_base_add +
+				       GPMC_CS0_BASE + nandcs*GPMC_CS_SIZE);
+	omap3evm_nand_data.gpmc_baseaddr   = (void *) (gpmc_base_add);
+
+	gpmc_nand_init(&omap3evm_nand_data);
+}
+#else
+void __init omap3_evm_nand_init(void) {}
+#endif
+
 /*
  * OMAP3EVM LCD Panel control signals
  */
@@ -793,6 +873,7 @@ static void __init omap3_evm_init(void)
 	omap3evm_init_smsc911x();
 	omap3_evm_display_init();
 	omap3_evm_onenand_init();
+	omap3_evm_nand_init();
 }
 
 static void __init omap3_evm_map_io(void)
-- 
1.7.0.4

