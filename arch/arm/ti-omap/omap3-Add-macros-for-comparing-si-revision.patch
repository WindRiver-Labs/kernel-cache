From 3dd6c14567b3e743919838177dd7fb3032fbf204 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Fri, 22 Apr 2011 09:42:25 +0800
Subject: [PATCH 102/108] omap3: Add macros for comparing si revision

commit 9b6bdff1c68a42614bb1e06315d5c4be99c5c078 from
the branch origin/OMAPPSP_03.00.01.06 of
git://arago-project.org/git/projects/linux-omap3.git

This patch adds verbose macros for comparing silicon
revision bits. Current mechanism of comparing complete
'omap_revision' does not work/ represent the multiple
processors, and their revisions.

Existing instances of comparison via omap_rev() have
been replaced with new macros.

Signed-off-by: Sanjeev Premi <premi@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-omap2/clock3xxx_data.c  |    6 ++-
 arch/arm/mach-omap2/control.c         |    4 ++-
 arch/arm/mach-omap2/pm34xx.c          |   35 ++++++++++++++++-----
 arch/arm/plat-omap/include/plat/cpu.h |   55 +++++++++++++++++++++++++++++++++
 4 files changed, 89 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-omap2/clock3xxx_data.c b/arch/arm/mach-omap2/clock3xxx_data.c
index 7ed2e2c..734cfae 100644
--- a/arch/arm/mach-omap2/clock3xxx_data.c
+++ b/arch/arm/mach-omap2/clock3xxx_data.c
@@ -3528,7 +3528,7 @@ int __init omap3xxx_clk_init(void)
 		 * Update this if there are further clock changes between ES2
 		 * and production parts
 		 */
-		if (omap_rev() == OMAP3430_REV_ES1_0) {
+		if (cpu_is_omap34xx() && omap_rev_is_1_0()) {
 			/* No 3430ES1-only rates exist, so no RATE_IN_3430ES1 */
 			cpu_clkflg |= CK_3430ES1;
 		} else {
@@ -3618,7 +3618,9 @@ int __init omap3xxx_clk_init(void)
 	/*
 	 * Lock DPLL5 and put it in autoidle.
 	 */
-	if (omap_rev() >= OMAP3430_REV_ES2_0)
+	if ((cpu_is_omap34xx() && omap_rev_ge_2_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630())
 		omap3_clk_lock_dpll5();
 
 	/* Avoid sleeping during omap3_core_dpll_m2_set_rate() */
diff --git a/arch/arm/mach-omap2/control.c b/arch/arm/mach-omap2/control.c
index 7cf3b1e..24ef3ad 100644
--- a/arch/arm/mach-omap2/control.c
+++ b/arch/arm/mach-omap2/control.c
@@ -278,7 +278,9 @@ void omap3_save_scratchpad_contents(void)
 	 * of AUTO_CNT = 1 prior to any transition to OFF mode.
 	 */
 	if ((omap_type() != OMAP2_DEVICE_TYPE_GP)
-			&& (omap_rev() >= OMAP3430_REV_ES3_0))
+		&& ((cpu_is_omap34xx() && omap_rev_ge_3_0())
+			|| cpu_is_omap3505() || cpu_is_omap3517()
+			|| cpu_is_omap3630()))
 		sdrc_block_contents.power = (sdrc_read_reg(SDRC_POWER) &
 				~(SDRC_POWER_AUTOCOUNT_MASK|
 				SDRC_POWER_CLKCTRL_MASK)) |
diff --git a/arch/arm/mach-omap2/pm34xx.c b/arch/arm/mach-omap2/pm34xx.c
index ce20ca5..89a8257 100644
--- a/arch/arm/mach-omap2/pm34xx.c
+++ b/arch/arm/mach-omap2/pm34xx.c
@@ -30,6 +30,7 @@
 #include <linux/slab.h>
 #include <trace/pm.h>
 
+#include <plat/cpu.h>
 #include <plat/sram.h>
 #include <plat/clockdomain.h>
 #include <plat/powerdomain.h>
@@ -104,7 +105,9 @@ static void omap3_enable_io_chain(void)
 {
 	int timeout = 0;
 
-	if (omap_rev() >= OMAP3430_REV_ES3_1) {
+	if ((cpu_is_omap34xx() && omap_rev_ge_3_1())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) {
 		prm_set_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
 		/* Do a readback to assure write has been done */
 		prm_read_mod_reg(WKUP_MOD, PM_WKEN);
@@ -125,7 +128,9 @@ static void omap3_enable_io_chain(void)
 
 static void omap3_disable_io_chain(void)
 {
-	if (omap_rev() >= OMAP3430_REV_ES3_1)
+	if ((cpu_is_omap34xx() && omap_rev_ge_3_1())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630())
 		prm_clear_mod_reg_bits(OMAP3430_EN_IO_CHAIN, WKUP_MOD, PM_WKEN);
 }
 
@@ -252,7 +257,10 @@ static int _prcm_int_handle_wakeup(void)
 	c = prcm_clear_mod_irqs(WKUP_MOD, 1);
 	c += prcm_clear_mod_irqs(CORE_MOD, 1);
 	c += prcm_clear_mod_irqs(OMAP3430_PER_MOD, 1);
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
+
+	if ((cpu_is_omap34xx() && omap_rev_gt_1_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) {
 		c += prcm_clear_mod_irqs(CORE_MOD, 3);
 		c += prcm_clear_mod_irqs(OMAP3430ES2_USBHOST_MOD, 1);
 	}
@@ -435,7 +443,9 @@ void omap_sram_idle(void)
 	* of AUTO_CNT = 1 enabled. This takes care of errata 1.142.
 	* Hence store/restore the SDRC_POWER register here.
 	*/
-	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
+	if (((cpu_is_omap34xx() && omap_rev_ge_3_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) &&
 	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
 	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_pwr = sdrc_read_reg(SDRC_POWER);
@@ -449,7 +459,9 @@ void omap_sram_idle(void)
 	cpu_init();
 
 	/* Restore normal SDRC POWER settings */
-	if (omap_rev() >= OMAP3430_REV_ES3_0 &&
+	if (((cpu_is_omap34xx() && omap_rev_ge_3_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) &&
 	    omap_type() != OMAP2_DEVICE_TYPE_GP &&
 	    core_next_state == PWRDM_POWER_OFF)
 		sdrc_write_reg(sdrc_pwr, SDRC_POWER);
@@ -804,7 +816,10 @@ static void __init prcm_setup_regs(void)
 	prm_write_mod_reg(0, OMAP3430_NEON_MOD, PM_WKDEP);
 	prm_write_mod_reg(0, OMAP3430_CAM_MOD, PM_WKDEP);
 	prm_write_mod_reg(0, OMAP3430_PER_MOD, PM_WKDEP);
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
+
+	if ((cpu_is_omap34xx() && omap_rev_gt_1_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) {
 		prm_write_mod_reg(0, OMAP3430ES2_SGX_MOD, PM_WKDEP);
 		prm_write_mod_reg(0, OMAP3430ES2_USBHOST_MOD, PM_WKDEP);
 	} else
@@ -855,7 +870,9 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_AUTO_DES1,
 		CORE_MOD, CM_AUTOIDLE2);
 
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
+	if ((cpu_is_omap34xx() && omap_rev_gt_1_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) {
 		cm_write_mod_reg(
 			OMAP3430_AUTO_MAD2D |
 			OMAP3430ES2_AUTO_USBTLL,
@@ -904,7 +921,9 @@ static void __init prcm_setup_regs(void)
 		OMAP3430_PER_MOD,
 		CM_AUTOIDLE);
 
-	if (omap_rev() > OMAP3430_REV_ES1_0) {
+	if ((cpu_is_omap34xx() && omap_rev_gt_1_0())
+		|| cpu_is_omap3505() || cpu_is_omap3517()
+		|| cpu_is_omap3630()) {
 		cm_write_mod_reg(
 			OMAP3430ES2_AUTO_USBHOST,
 			OMAP3430ES2_USBHOST_MOD,
diff --git a/arch/arm/plat-omap/include/plat/cpu.h b/arch/arm/plat-omap/include/plat/cpu.h
index 2e2ae53..2b502bf 100644
--- a/arch/arm/plat-omap/include/plat/cpu.h
+++ b/arch/arm/plat-omap/include/plat/cpu.h
@@ -393,6 +393,61 @@ IS_OMAP_TYPE(3517, 0x3517)
 #define OMAP4430_REV_ES1_0	0x44300044
 
 /*
+ * Silicon revisions
+ */
+#define OMAP_ES_1_0		0x00
+#define OMAP_ES_2_0		0x10
+#define OMAP_ES_2_1		0x20
+#define OMAP_ES_3_0		0x30
+#define OMAP_ES_3_1		0x40
+
+#define OMAP_REV_MASK		0x0000ff00
+#define OMAP_REV_BITS		((omap_rev() & OMAP_REV_MASK) >> 8)
+
+#define OMAP_REV_IS(revid)					\
+static inline u8 omap_rev_is_ ##revid (void)			\
+{								\
+	return (OMAP_REV_BITS == OMAP_ES_ ##revid) ? 1 : 0;	\
+}
+
+#define OMAP_REV_LT(revid)					\
+static inline u8 omap_rev_lt_ ##revid (void)			\
+{								\
+	return (OMAP_REV_BITS < OMAP_ES_ ##revid) ? 1 : 0;	\
+}
+
+#define OMAP_REV_LE(revid)					\
+static inline u8 omap_rev_le_ ##revid (void)			\
+{								\
+	return (OMAP_REV_BITS <= OMAP_ES_ ##revid) ? 1 : 0;	\
+}
+
+#define OMAP_REV_GT(revid)					\
+static inline u8 omap_rev_gt_ ##revid (void)			\
+{								\
+	return (OMAP_REV_BITS > OMAP_ES_ ##revid) ? 1 : 0;	\
+}
+
+#define OMAP_REV_GE(revid)					\
+static inline u8 omap_rev_ge_ ##revid (void)			\
+{								\
+	return (OMAP_REV_BITS >= OMAP_ES_ ##revid) ? 1 : 0;	\
+}
+
+#define OMAP_REV_FUNCTIONS(revid)	\
+	OMAP_REV_IS(revid)		\
+	OMAP_REV_LT(revid)		\
+	OMAP_REV_LE(revid)		\
+	OMAP_REV_GT(revid)		\
+	OMAP_REV_GE(revid)
+
+OMAP_REV_FUNCTIONS(1_0)
+OMAP_REV_FUNCTIONS(2_0)
+OMAP_REV_FUNCTIONS(2_1)
+OMAP_REV_FUNCTIONS(3_0)
+OMAP_REV_FUNCTIONS(3_1)
+
+/*
  * omap_chip bits
  *
  * CHIP_IS_OMAP{2420,2430,3430} indicate that a particular structure is
-- 
1.7.0.4

