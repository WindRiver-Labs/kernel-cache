From b3c4b305c355d9790103b1bba69eaca0ea2bfcc9 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Wed, 6 Apr 2011 14:32:11 +0800
Subject: [PATCH 075/108] OMAP: Introduce API to register a device with a voltagedomain

commit 1fd74e20f624b555c8d154059690cd13b5daba94 from
git://arago-project.org/git/projects/linux-omap3.git

This patch adds an API in the voltage layer that
can be used  during omap_device_build to register the built
device with the voltage domain. This API is to be typically called
only once per device during the device registeration. This approach
makes it easy during dvfs to scale all the devices associated with
a voltage domain and then scale the voltage domain.

Signed-off-by: Thara Gopinath <thara@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-omap2/voltage.c             |   48 +++++++++++++++++++++++++++++
 arch/arm/plat-omap/include/plat/voltage.h |    7 +++-
 arch/arm/plat-omap/omap_device.c          |   12 +++++++
 3 files changed, 66 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-omap2/voltage.c b/arch/arm/mach-omap2/voltage.c
index 296a08e..311e3d4 100644
--- a/arch/arm/mach-omap2/voltage.c
+++ b/arch/arm/mach-omap2/voltage.c
@@ -130,6 +130,11 @@ struct omap_vdd_user_list {
 	u32 volt;
 };
 
+struct omap_vdd_dev_list {
+	struct device *dev;
+	struct list_head node;
+};
+
 /**
  * omap_vdd_info - Per Voltage Domain info
  *
@@ -149,6 +154,7 @@ struct omap_vdd_user_list {
  * @user_list		: the list head maintaining the various users.
  * @scaling_mutex	: the dvfs muutex.
  *			  of this vdd with the voltage requested by each user.
+ * @dev_list		: list of devices bwlonging to this voltage domain.
  * @curr_volt		: current voltage for this vdd.
  * @ocp_mod		: The prm module for accessing the prm irqstatus reg.
  * @prm_irqst_reg	: prm irqstatus register.
@@ -166,6 +172,7 @@ struct omap_vdd_info {
 	spinlock_t user_lock;
 	struct plist_head user_list;
 	struct mutex scaling_mutex;
+	struct list_head dev_list;
 	u32 curr_volt;
 	u16 ocp_mod;
 	u8 prm_irqst_reg;
@@ -991,6 +998,40 @@ int omap_voltage_add_request(struct voltagedomain *voltdm, struct device *dev,
 }
 
 
+int omap_voltage_add_dev(struct voltagedomain *voltdm, struct device *dev)
+{
+	struct omap_vdd_info *vdd;
+	struct omap_vdd_dev_list *temp_dev;
+
+	if (!voltdm || IS_ERR(voltdm)) {
+		pr_warning("%s: VDD specified does not exist!\n", __func__);
+		return -EINVAL;
+	}
+
+	vdd = container_of(voltdm, struct omap_vdd_info, voltdm);
+
+	list_for_each_entry(temp_dev, &vdd->dev_list, node) {
+		if (temp_dev->dev == dev) {
+			dev_warn(dev, "%s: Device already added to vdee_%s\n",
+				__func__, voltdm->name);
+			return -EINVAL;
+		}
+	}
+
+	temp_dev = kzalloc(sizeof(struct omap_vdd_dev_list), GFP_KERNEL);
+	if (!temp_dev) {
+		dev_err(dev, "%s: Unable to creat a new device for vdd_%s\n",
+			__func__, voltdm->name);
+		return -ENOMEM;
+	}
+
+	temp_dev->dev = dev;
+
+	list_add(&temp_dev->node, &vdd->dev_list);
+
+	return 0;
+}
+
 /**
  * omap_vp_enable() - API to enable a particular VP
  * @voltdm:	pointer to the VDD whose VP is to be enabled.
@@ -1371,6 +1412,8 @@ int __init omap_voltage_late_init(void)
  */
 static int __init omap_voltage_early_init(void)
 {
+	int i;
+
 	if (cpu_is_omap34xx()) {
 		vdd_info = omap3_vdd_info;
 		nr_scalable_vdd = OMAP3_NR_SCALABLE_VDD;
@@ -1378,8 +1421,13 @@ static int __init omap_voltage_early_init(void)
 		vdd_data_configure = omap3_vdd_data_configure;
 	} else {
 		pr_warning("%s: voltage driver support not added\n", __func__);
+		return -EINVAL;
 	}
 
+	/* Init the device list */
+	for (i = 0; i < nr_scalable_vdd; i++)
+		INIT_LIST_HEAD(&(vdd_info[i].dev_list));
+
 	return 0;
 }
 core_initcall(omap_voltage_early_init);
diff --git a/arch/arm/plat-omap/include/plat/voltage.h b/arch/arm/plat-omap/include/plat/voltage.h
index 16c5a9b..f95d8e0 100644
--- a/arch/arm/plat-omap/include/plat/voltage.h
+++ b/arch/arm/plat-omap/include/plat/voltage.h
@@ -122,7 +122,7 @@ void omap_change_voltscale_method(struct voltagedomain *voltdm,
 int omap_voltage_late_init(void);
 int omap_voltage_add_request(struct voltagedomain *voltdm, struct device *dev,
 		unsigned long *volt);
-
+int omap_voltage_add_dev(struct voltagedomain *voltdm, struct device *dev);
 #else
 static inline int omap_voltage_register_pmic(struct voltagedomain *voltdm,
 		struct omap_volt_pmic_info *pmic_info) {}
@@ -137,6 +137,11 @@ static inline int omap_voltage_add_request(struct voltagedomain *voltdm,
 {
 	return -EINVAL;
 }
+static inline int omap_voltage_add_dev(struct voltagedomain *voltdm,
+		struct device *dev)
+{
+	return -EINVAL;
+}
 #endif
 
 #endif
diff --git a/arch/arm/plat-omap/omap_device.c b/arch/arm/plat-omap/omap_device.c
index e5f3b2e..28501e8 100644
--- a/arch/arm/plat-omap/omap_device.c
+++ b/arch/arm/plat-omap/omap_device.c
@@ -86,6 +86,7 @@
 
 #include <plat/omap_device.h>
 #include <plat/omap_hwmod.h>
+#include <plat/voltage.h>
 
 /* These parameters are passed to _omap_device_{de,}activate() */
 #define USE_WAKEUP_LAT			0
@@ -460,6 +461,17 @@ struct omap_device *omap_device_build_ss(const char *pdev_name, int pdev_id,
 	for (i = 0; i < oh_cnt; i++) {
 		hwmods[i]->od = od;
 		_add_optional_clock_alias(od, hwmods[i]);
+		if (hwmods[i]->vdd_name) {
+			struct omap_hwmod *oh = hwmods[i];
+			struct voltagedomain *voltdm;
+
+			if (is_early_device)
+				continue;
+
+			voltdm = omap_voltage_domain_lookup(oh->vdd_name);
+			if (!omap_voltage_add_dev(voltdm, &od->pdev.dev))
+				oh->voltdm = voltdm;
+		}
 	}
 
 	if (ret)
-- 
1.7.0.4

