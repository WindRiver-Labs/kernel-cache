From f3b944eeb3a6b36d99fda42acfc4acb9461504a0 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Wed, 20 Apr 2011 09:54:56 +0800
Subject: [PATCH 097/108] OMAP: DSS: Fix for "System comes out of suspend immediately with enable_off_mode"

commit 4fabeaa944dcd0b630e727b23aed214889521547 from
the branch origin/OMAPPSP_03.00.01.06 of
git://arago-project.org/git/projects/linux-omap3.git

This is a WORK-AROUND for the issue,

"With enable_off_mode=1, the system comes out immediately from suspend without
any exteral trigger"

It has been found that enabling parent clock (DPLL4 M2X2) before going into
suspend, solves this issue. Although it doesn't work (comes out immediately)
at very first time, but works for sub-sequent suspend calls.

This could be hardware issue, but till actual resolution or conformation
we are maintaining this as a work-around (custom patch).

Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/video/omap2/dss/core.c    |   44 +++++++++++++++++++++++++++++++++++++
 drivers/video/omap2/dss/display.c |    9 +++++++
 drivers/video/omap2/dss/dss.h     |    3 ++
 3 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/drivers/video/omap2/dss/core.c b/drivers/video/omap2/dss/core.c
index 7ebe50b..0fac700 100644
--- a/drivers/video/omap2/dss/core.c
+++ b/drivers/video/omap2/dss/core.c
@@ -403,6 +403,50 @@ struct regulator *dss_get_vdda_dac(void)
 	return reg;
 }
 
+void dss_clk_enable_parent(enum dss_clock clks)
+{
+	struct clk *clk;
+
+	if (clks & DSS_CLK_54M) {
+		clk = clk_get_parent(core.dss_54m_fck);
+		clk_enable(clk);
+	}
+	if (clks & DSS_CLK_96M) {
+		clk = clk_get_parent(core.dss_96m_fck);
+		clk_enable(clk);
+	}
+	if (clks & DSS_CLK_FCK1) {
+		clk = clk_get_parent(core.dss1_fck);
+		clk_enable(clk);
+	}
+	if (clks & DSS_CLK_FCK2) {
+		clk = clk_get_parent(core.dss2_fck);
+		clk_enable(clk);
+	}
+}
+
+void dss_clk_disable_parent(enum dss_clock clks)
+{
+	struct clk *clk;
+
+	if (clks & DSS_CLK_54M) {
+		clk = clk_get_parent(core.dss_54m_fck);
+		clk_disable(clk);
+	}
+	if (clks & DSS_CLK_96M) {
+		clk = clk_get_parent(core.dss_96m_fck);
+		clk_disable(clk);
+	}
+	if (clks & DSS_CLK_FCK1) {
+		clk = clk_get_parent(core.dss1_fck);
+		clk_disable(clk);
+	}
+	if (clks & DSS_CLK_FCK2) {
+		clk = clk_get_parent(core.dss2_fck);
+		clk_disable(clk);
+	}
+}
+
 /* DEBUGFS */
 #if defined(CONFIG_DEBUG_FS) && defined(CONFIG_OMAP2_DSS_DEBUG_SUPPORT)
 static void dss_debug_dump_clocks(struct seq_file *s)
diff --git a/drivers/video/omap2/dss/display.c b/drivers/video/omap2/dss/display.c
index b14e9b4..7dfd434 100644
--- a/drivers/video/omap2/dss/display.c
+++ b/drivers/video/omap2/dss/display.c
@@ -505,6 +505,14 @@ int dss_suspend_all_devices(void)
 	int r;
 	struct bus_type *bus = dss_get_bus();
 
+	/*
+	 * WORK-AROUND: With enable_off_mode=1, the system comes out
+	 * immediately from suspend without any exteral trigger. It has been
+	 * found that enabling parent clock, solves this issue. Although it
+	 * doesn't work (comes out immediately) at very first time, but works
+	 * for sub-sequent suspend calls.
+	 */
+	dss_clk_enable_parent(DSS_CLK_FCK1);
 	r = bus_for_each_dev(bus, NULL, NULL, dss_suspend_device);
 	if (r) {
 		/* resume all displays that were suspended */
@@ -535,6 +543,7 @@ int dss_resume_all_devices(void)
 {
 	struct bus_type *bus = dss_get_bus();
 
+	dss_clk_disable_parent(DSS_CLK_FCK1);
 	return bus_for_each_dev(bus, NULL, NULL, dss_resume_device);
 }
 
diff --git a/drivers/video/omap2/dss/dss.h b/drivers/video/omap2/dss/dss.h
index 24326a5..9e4897a 100644
--- a/drivers/video/omap2/dss/dss.h
+++ b/drivers/video/omap2/dss/dss.h
@@ -179,6 +179,9 @@ struct regulator *dss_get_vdds_dsi(void);
 struct regulator *dss_get_vdds_sdi(void);
 struct regulator *dss_get_vdda_dac(void);
 
+void dss_clk_enable_parent(enum dss_clock clks);
+void dss_clk_disable_parent(enum dss_clock clks);
+
 /* display */
 int dss_suspend_all_devices(void);
 int dss_resume_all_devices(void);
-- 
1.7.0.4

