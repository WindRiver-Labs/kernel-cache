From a6768ee4c955188576e0da72624d6005c8dbc021 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Fri, 1 Apr 2011 17:41:11 +0800
Subject: [PATCH 08/21] TI 816x: add ti 816x io support

Add ti 816x io support in common files.

This patch refers to below commits in arago git tree.
git://arago-project.org/git/projects/linux-omap3.git

e1ea60 ti816x: Initial support for TI8168
7ff858 TI816X: Add support for TI816X GPMC
036372 ti816x: Add support for creating mapping for strongly-ordered memory for Ducati Unicache, MMU config space

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-omap2/io.c             |   35 ++++++++++++++++++++++++++++++++
 arch/arm/plat-omap/include/plat/io.h |   37 ++++++++++++++++++++++++++++++++++
 arch/arm/plat-omap/io.c              |   11 ++++++++++
 3 files changed, 83 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index 3759f72..84e60b4 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -38,6 +38,7 @@
 #include "clock2xxx.h"
 #include "clock3xxx.h"
 #include "clock44xx.h"
+#include "clock816x.h"
 
 #include <plat/omap-pm.h>
 #include <plat/powerdomain.h>
@@ -222,6 +223,30 @@ static struct map_desc omap44xx_io_desc[] __initdata = {
 };
 #endif
 
+#ifdef CONFIG_ARCH_TI816X
+#define MT_STRONGLY_ORDERED	12
+static struct map_desc ti816x_io_desc[] __initdata = {
+	{
+		.virtual	= L4_SLOW_TI816X_VIRT,
+		.pfn		= __phys_to_pfn(L4_SLOW_TI816X_PHYS),
+		.length		= L4_SLOW_TI816X_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= TI816X_GPMC_VIRT,
+		.pfn		= __phys_to_pfn(TI816X_GPMC_PHYS),
+		.length		= TI816X_GPMC_SIZE,
+		.type		= MT_DEVICE
+	},
+	{
+		.virtual	= TI816X_L2_MC_VIRT,
+		.pfn		= __phys_to_pfn(TI816X_L2_MC_PHYS),
+		.length		= TI816X_L2_MC_SIZE,
+		.type		= MT_STRONGLY_ORDERED
+	},
+};
+#endif
+
 static void __init _omap2_map_common_io(void)
 {
 	/* Normally devicemaps_init() would flush caches and tlb after
@@ -271,6 +296,14 @@ void __init omap44xx_map_common_io(void)
 }
 #endif
 
+#ifdef CONFIG_ARCH_TI816X
+void __init ti816x_map_common_io()
+{
+	iotable_init(ti816x_io_desc, ARRAY_SIZE(ti816x_io_desc));
+	_omap2_map_common_io();
+}
+#endif
+
 /*
  * omap2_init_reprogram_sdrc - reprogram SDRC timing parameters
  *
@@ -330,6 +363,8 @@ void __init omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
 		omap3xxx_clk_init();
 	else if (cpu_is_omap44xx())
 		omap4xxx_clk_init();
+	else if (cpu_is_ti816x())
+		ti816x_clk_init();
 	else
 		pr_err("Could not init clock framework - unknown CPU\n");
 
diff --git a/arch/arm/plat-omap/include/plat/io.h b/arch/arm/plat-omap/include/plat/io.h
index 128b549..4e3949d 100644
--- a/arch/arm/plat-omap/include/plat/io.h
+++ b/arch/arm/plat-omap/include/plat/io.h
@@ -83,6 +83,19 @@
 #define OMAP2_EMU_IO_ADDRESS(pa)	IOMEM((pa) + OMAP2_EMU_IO_OFFSET)
 
 /*
+ * Currently only considering L4 Slow space for TI816X.
+ *
+ * TODO:
+ *	* Add L4 fast (CPGMAC etc)?
+ *	* Add L3 - not sure about peripherals involved
+ *	* Move static mapping window up (to 0xf800000 like other OMAPs)
+ */
+#define TI816X_L4_SLOW_IO_OFFSET	0xb2000000
+#define TI816X_L4_SLOW_IO_ADDRESS(pa)	IOMEM((pa) + TI816X_L4_SLOW_IO_OFFSET)
+#define TI816X_GPMC_IO_OFFSET		0xa9000000
+#define TI816X_GPMC_IO_ADDRESS(pa)	IOMEM((pa) + TI816X_GPMC_IO_OFFSET)
+
+/*
  * ----------------------------------------------------------------------------
  * Omap1 specific IO mapping
  * ----------------------------------------------------------------------------
@@ -235,6 +248,22 @@
 						/* 0x4e000000 --> 0xfd300000 */
 #define OMAP44XX_DMM_VIRT	(OMAP44XX_DMM_PHYS + OMAP4_L3_PER_IO_OFFSET)
 #define OMAP44XX_DMM_SIZE	SZ_1M
+
+/*
+ * TI816X Specific I/O Mapping
+ */
+#define L4_SLOW_TI816X_PHYS	L4_SLOW_TI816X_BASE
+						/* 0x48000000 --> 0xd8000000 */
+#define L4_SLOW_TI816X_VIRT	(L4_SLOW_TI816X_PHYS + TI816X_L4_SLOW_IO_OFFSET)
+#define L4_SLOW_TI816X_SIZE	SZ_4M
+#define TI816X_GPMC_PHYS	TI816X_GPMC_BASE
+						/* 0x50000000 --> upto 16MB */
+#define TI816X_GPMC_VIRT	(TI816X_GPMC_PHYS + TI816X_GPMC_IO_OFFSET)
+#define TI816X_GPMC_SIZE	SZ_1M
+#define TI816X_L2_MC_PHYS	0x55000000
+						/* 0x55000000 --> upto 1MB */
+#define TI816X_L2_MC_VIRT	(TI816X_GPMC_VIRT + TI816X_GPMC_SIZE)
+#define TI816X_L2_MC_SIZE	SZ_1M
 /*
  * ----------------------------------------------------------------------------
  * Omap specific register access
@@ -291,6 +320,14 @@ static inline void omap44xx_map_common_io(void)
 }
 #endif
 
+#ifdef CONFIG_ARCH_TI816X
+extern void ti816x_map_common_io(void);
+#else
+static inline void ti816x_map_common_io(void)
+{
+}
+#endif
+
 extern void omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
 				 struct omap_sdrc_params *sdrc_cs1);
 
diff --git a/arch/arm/plat-omap/io.c b/arch/arm/plat-omap/io.c
index b0078cf..aec6eb5 100644
--- a/arch/arm/plat-omap/io.c
+++ b/arch/arm/plat-omap/io.c
@@ -124,6 +124,17 @@ void __iomem *omap_ioremap(unsigned long p, size_t size, unsigned int type)
 			return XLATE(p, L4_EMU_44XX_PHYS, L4_EMU_44XX_VIRT);
 	}
 #endif
+#ifdef CONFIG_ARCH_TI816X
+	if (cpu_is_ti816x()) {
+		if (BETWEEN(p, L4_SLOW_TI816X_PHYS, L4_SLOW_TI816X_SIZE))
+			return XLATE(p, L4_SLOW_TI816X_PHYS,
+				     L4_SLOW_TI816X_VIRT);
+		if (BETWEEN(p, TI816X_GPMC_PHYS, OMAP44XX_GPMC_SIZE))
+			return XLATE(p, TI816X_GPMC_PHYS, TI816X_GPMC_VIRT);
+		if (BETWEEN(p, TI816X_L2_MC_PHYS, TI816X_L2_MC_SIZE))
+			return XLATE(p, TI816X_L2_MC_PHYS, TI816X_L2_MC_VIRT);
+	}
+#endif
 	return __arm_ioremap_caller(p, size, type, __builtin_return_address(0));
 }
 EXPORT_SYMBOL(omap_ioremap);
-- 
1.7.0.2

