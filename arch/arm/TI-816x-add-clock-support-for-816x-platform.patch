From a578b4f4120e6407161e915069de13eefef0f7fd Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Fri, 1 Apr 2011 17:25:25 +0800
Subject: [PATCH 03/21] TI 816x: add clock support for 816x platform

1. add ti 816x clock support in common clock files.
2. create ti 816x specific clock files.

This patch refers to below commits in arago git tree.
git://arago-project.org/git/projects/linux-omap3.git

a52b79 ti816x: clock: Add ti816x specific clock enable function to test IDLEST
c45c59 ti616x: clock: Add local reset control for PCIe and USB
e1ea60 ti816x: Initial support for TI8168
1558f7 ti816x: Update colck data
14ac21 ti816x: McSPI clock addition
5401a9 ti816x: Use null clock ops for sysclk18
f49509 usb: added usb clock support for TI816x platform
7d556b sata: added sata clock support for ti816x
c24323 ti816x: Add SYSCLK5 data
69be15 TI816X: Audio support
0883b7 ti816x: clock: Avoid using idlest check
b221a6 ti816x: clock: Add PCIe related clock data
c45c59 ti616x: clock: Add local reset control for PCIe and USB
b8bf45 ti816x: Add platform hookup for EMAC driver.
0c430d ti816x: clock: Add clock data for IVAHDs
a01129 TI EMAC Driver : driver changes for supporting new IRQ ack logic
8cbb9f ti816x: SATA PHY and clock updates.
a52b79 ti816x: clock: Add ti816x specific clock enable function to test IDLEST
be02f0 ti816x: clock: Add EDMA module clocks
40c4fd ti816x: clock: Use ti816x specific clock ops to wait for module idlest
fd3cc8 ti816x: clock: Add MMU and remaining timer clocks
031ed0 ti816x: clock: Use correct clock select masks
84ed00 TI816X: Remove various warnings from baseport and clock framework

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-omap2/clkt_clksel.c             |    4 +
 arch/arm/mach-omap2/clock.c                   |  101 ++
 arch/arm/mach-omap2/clock.h                   |    3 +
 arch/arm/mach-omap2/clock816x.h               |   23 +
 arch/arm/mach-omap2/clock816x_data.c          | 1212 +++++++++++++++++++++++++
 arch/arm/mach-omap2/clockdomain.c             |   18 +-
 arch/arm/mach-omap2/clockdomains.h            |   17 +
 arch/arm/mach-omap2/clockdomains816x.h        |  155 ++++
 arch/arm/mach-omap2/cm-regbits-816x.h         |   46 +
 arch/arm/mach-omap2/cm.h                      |    3 +
 arch/arm/mach-omap2/cm816x.h                  |  312 +++++++
 arch/arm/plat-omap/include/plat/clkdev_omap.h |    1 +
 arch/arm/plat-omap/include/plat/clock.h       |    8 +-
 13 files changed, 1894 insertions(+), 9 deletions(-)
 create mode 100644 arch/arm/mach-omap2/clock816x.h
 create mode 100755 arch/arm/mach-omap2/clock816x_data.c
 create mode 100644 arch/arm/mach-omap2/clockdomains816x.h
 create mode 100644 arch/arm/mach-omap2/cm-regbits-816x.h
 create mode 100644 arch/arm/mach-omap2/cm816x.h

diff --git a/arch/arm/mach-omap2/clkt_clksel.c b/arch/arm/mach-omap2/clkt_clksel.c
index e50812d..268856f 100644
--- a/arch/arm/mach-omap2/clkt_clksel.c
+++ b/arch/arm/mach-omap2/clkt_clksel.c
@@ -82,7 +82,11 @@ static u32 _omap2_clksel_get_src_field(struct clk *src_clk, struct clk *clk,
 		return 0;
 
 	for (clkr = clks->rates; clkr->div; clkr++) {
+#if defined(CONFIG_ARCH_TI816X)
+		if (clkr->flags & cpu_mask)
+#else
 		if (clkr->flags & cpu_mask && clkr->flags & DEFAULT_RATE)
+#endif
 			break; /* Found the default rate for this platform */
 	}
 
diff --git a/arch/arm/mach-omap2/clock.c b/arch/arm/mach-omap2/clock.c
index a6d0b34..0619385 100644
--- a/arch/arm/mach-omap2/clock.c
+++ b/arch/arm/mach-omap2/clock.c
@@ -27,13 +27,16 @@
 #include <plat/clockdomain.h>
 #include <plat/cpu.h>
 #include <plat/prcm.h>
+#include <plat/common.h>
 
 #include "clock.h"
 #include "prm.h"
 #include "prm-regbits-24xx.h"
+#include "prm-regbits-816x.h"
 #include "cm.h"
 #include "cm-regbits-24xx.h"
 #include "cm-regbits-34xx.h"
+#include "cm-regbits-816x.h"
 
 u8 cpu_mask;
 
@@ -219,6 +222,89 @@ void omap2_dflt_clk_disable(struct clk *clk)
 	/* No OCP barrier needed here since it is a disable operation */
 }
 
+/**
+ * omap2_ti816x_clk_enable() - Enable a ti816x module clock
+ * @clk: Pointer to the clock to be enabled
+ *
+ * This function just wraps omap2_dflt_clk_enable with a check for module idle
+ * status. We loop till module goes to funcitonal state as the immediate access
+ * to module space will not work otherwise.
+ */
+int omap2_ti816x_clk_enable(struct clk *clk)
+{
+	omap2_dflt_clk_enable(clk);
+
+	omap2_cm_wait_idlest(clk->enable_reg, TI816X_IDLEST_MASK,
+			     TI816X_IDLEST_VAL, clk->name);
+
+	return 0;
+}
+
+int omap2_pcie_clk_enable(struct clk *clk)
+{
+#define MAX_MODULE_ENABLE_WAIT		100000
+	int i = 0;
+
+	omap2_dflt_clk_enable(clk);
+
+	/* De-assert local reset after module enable */
+	if (cpu_is_ti816x())
+		prm_clear_mod_reg_bits(TI816X_PCI_LRST_MASK,
+				       TI816X_PRM_DEFAULT_MOD,
+				       TI816X_RM_DEFAULT_RSTCTRL);
+
+	omap_test_timeout(((__raw_readl(clk->enable_reg) & 0x30000) == 0),
+			  MAX_MODULE_ENABLE_WAIT, i);
+
+	/* PCIe module remains in standby till LRST is de-asserted */
+	if (i < MAX_MODULE_ENABLE_WAIT)
+		pr_debug("cm: Module associated with clock %s ready after %d "
+			 "loops\n", clk->name, i);
+	else {
+		pr_err("cm: Module associated with clock %s didn't enable in "
+		       "%d tries\n", clk->name, MAX_MODULE_ENABLE_WAIT);
+	}
+
+	return 0;
+}
+
+void omap2_pcie_clk_disable(struct clk *clk)
+{
+	/* Assert local reset */
+	if (cpu_is_ti816x())
+		prm_set_mod_reg_bits(TI816X_PCI_LRST_MASK,
+				     TI816X_PRM_DEFAULT_MOD,
+				     TI816X_RM_DEFAULT_RSTCTRL);
+
+	omap2_dflt_clk_disable(clk);
+}
+
+int omap2_usb_clk_enable(struct clk *clk)
+{
+	omap2_dflt_clk_enable(clk);
+
+	/* De-assert local reset after module enable */
+	if (cpu_is_ti816x())
+		prm_clear_mod_reg_bits(TI816X_USB1_LRST_MASK
+			| TI816X_USB2_LRST_MASK,
+			TI816X_PRM_DEFAULT_MOD,
+			TI816X_RM_DEFAULT_RSTCTRL);
+
+	return 0;
+}
+
+void omap2_usb_clk_disable(struct clk *clk)
+{
+	/* Assert local reset */
+	if (cpu_is_ti816x())
+		prm_set_mod_reg_bits(TI816X_USB1_LRST_MASK
+		| TI816X_USB2_LRST_MASK,
+		TI816X_PRM_DEFAULT_MOD,
+		TI816X_RM_DEFAULT_RSTCTRL);
+
+	omap2_dflt_clk_disable(clk);
+}
+
 const struct clkops clkops_omap2_dflt_wait = {
 	.enable		= omap2_dflt_clk_enable,
 	.disable	= omap2_dflt_clk_disable,
@@ -231,6 +317,21 @@ const struct clkops clkops_omap2_dflt = {
 	.disable	= omap2_dflt_clk_disable,
 };
 
+const struct clkops clkops_omap2_ti816x = {
+	.enable		= omap2_ti816x_clk_enable,
+	.disable	= omap2_dflt_clk_disable,
+};
+
+const struct clkops clkops_omap2_pcie = {
+	.enable		= omap2_pcie_clk_enable,
+	.disable	= omap2_pcie_clk_disable,
+};
+
+const struct clkops clkops_omap2_usb = {
+	.enable		= omap2_usb_clk_enable,
+	.disable	= omap2_usb_clk_disable,
+};
+
 /**
  * omap2_clk_disable - disable a clock, if the system is not using it
  * @clk: struct clk * to disable
diff --git a/arch/arm/mach-omap2/clock.h b/arch/arm/mach-omap2/clock.h
index fe449f3..a3fc760 100644
--- a/arch/arm/mach-omap2/clock.h
+++ b/arch/arm/mach-omap2/clock.h
@@ -129,6 +129,9 @@ extern u8 cpu_mask;
 extern const struct clkops clkops_omap2_dflt_wait;
 extern const struct clkops clkops_dummy;
 extern const struct clkops clkops_omap2_dflt;
+extern const struct clkops clkops_omap2_ti816x;
+extern const struct clkops clkops_omap2_pcie;
+extern const struct clkops clkops_omap2_usb;
 
 extern struct clk_functions omap2_clk_functions;
 extern struct clk *vclk, *sclk;
diff --git a/arch/arm/mach-omap2/clock816x.h b/arch/arm/mach-omap2/clock816x.h
new file mode 100644
index 0000000..3e2ca99
--- /dev/null
+++ b/arch/arm/mach-omap2/clock816x.h
@@ -0,0 +1,23 @@
+/*
+ * arch/arm/mach-omap2/clock816x.h
+ *
+ * TI816X clock function prototypes and macros.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP2_CLOCK816X_H
+#define __ARCH_ARM_MACH_OMAP2_CLOCK816X_H
+
+int ti816x_clk_init(void);
+
+#endif
diff --git a/arch/arm/mach-omap2/clock816x_data.c b/arch/arm/mach-omap2/clock816x_data.c
new file mode 100755
index 0000000..73e6d46
--- /dev/null
+++ b/arch/arm/mach-omap2/clock816x_data.c
@@ -0,0 +1,1212 @@
+/*
+ * arch/arm/mach-omap2/clock816x_data.c
+ *
+ * Clock data for ti816x.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/clk.h>
+
+#include <plat/control.h>
+#include <plat/clkdev_omap.h>
+
+#include "clock.h"
+#include "clock816x.h"
+#include "cm.h"
+#include "cm-regbits-816x.h"
+#include "prm.h"
+
+/*
+ * Notes:
+ *
+ * - Various leaf modules clocks don't have separate interface and functional
+ *   clock gating controls. Moreover, interface clock parents (SYSCLKs) do not
+ *   have enable/disable controls. Thus, we can probably remove interface clocks
+ *   and use dummy clocks instead. Only issue could be related to disabling
+ *   SYSCLK parents (PLL). At present, the 'ick' are provided with clkops_null
+ *   operations for enable/disable (since they are taken care by 'fck's).
+ *
+ * - Skipping PLL data and configuration for now. All the PLL (root) clocks are
+ *   referred with their default rates.
+ *
+ * - These default rates are approximate rounded values which will be different
+ *   from the actual output of parent clock from PLL (e.g, SYSCLK3 input is
+ *   taken as 600MHz, while the actual Main PLL clk3 output would be around
+ *   531.49 MHz). Of course, these rounded values are taken from the spec.
+ *
+ * - Use 'null' operations for few SYSCLKs (such as 4, 5, 6 etc.), which do not
+ *   have software control for enable/disable (control registers are RO).
+ *
+ * - Numbering for modules such as UART, I2C, Timer etc., which have multiple
+ *   instances, starts from 1 while register definitions are maintained starting
+ *   from 0 as per spec. This is followed to avoid confusion with omaps, where
+ *   the numbering start from 1. Some exceptions include IVAHDs.
+ *
+ * - The IDLEST bit and register for many clocks (e.g., mmchs1_fck) do not match
+ *   with the default implementation as part of clkops_omap2_dflt_wait so for
+ *   now, we use ti816x clock ops for idlest wait.
+ *
+ * - Note that the above is not applicable for some modules such as Ducati, GEM
+ *   and IVAHD clocks as they do not actually get enabled even after clk_enable
+ *   as "wait for enable" throws errors. For such modules, we retain
+ *   clkops_omap2_dflt and rely on module owners to poll for enable status
+ *   before accessing respective module.
+ */
+
+static struct clk secure_32k_ck = {
+	.name		= "secure_32k_ck",
+	.ops		= &clkops_null,
+	.rate		= 32768,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk sys_32k_ck = {
+	.name		= "sys_32k_ck",
+	.ops		= &clkops_null,
+	.rate		= 32768,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk tclkin_ck = {
+	.name		= "tclkin_ck",
+	.ops		= &clkops_null,
+	.rate		= 32768,		/* TODO: Check */
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk sys_clkin_ck = {
+	.name		= "sys_clkin_ck",
+	.ops		= &clkops_null,
+	.rate		= 27000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk main_pll_clk1_ck = {
+	.name		= "main_pll_clk1_ck",
+	.ops		= &clkops_null,
+	.rate		= 800000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div8_sysclk1_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 4, .val = 3, .flags = RATE_IN_TI816X },
+	{ .div = 5, .val = 4, .flags = RATE_IN_TI816X },
+	{ .div = 6, .val = 5, .flags = RATE_IN_TI816X },
+	{ .div = 7, .val = 6, .flags = RATE_IN_TI816X },
+	{ .div = 8, .val = 7, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk1_div[] = {
+	{ .parent = &main_pll_clk1_ck, .rates = div8_sysclk1_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk1_ck = {
+	.name		= "sysclk1_ck",
+	.parent		= &main_pll_clk1_ck,
+	.clksel		= sysclk1_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK1_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gem_ick = {
+	.name           = "gem_ick",
+	.parent         = &sysclk1_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_ACTIVE_GEM_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "active_gem_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk main_pll_clk2_ck = {
+	.name		= "main_pll_clk2_ck",
+	.ops		= &clkops_null,
+	.rate		= 1000000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div8_sysclk23_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 4, .val = 3, .flags = RATE_IN_TI816X },
+	{ .div = 5, .val = 4, .flags = RATE_IN_TI816X },
+	{ .div = 6, .val = 5, .flags = RATE_IN_TI816X },
+	{ .div = 7, .val = 6, .flags = RATE_IN_TI816X },
+	{ .div = 8, .val = 7, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk23_div[] = {
+	{ .parent = &main_pll_clk2_ck, .rates = div8_sysclk23_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk23_ck = {
+	.name		= "sysclk23_ck",
+	.parent		= &main_pll_clk2_ck,
+	.clksel		= sysclk23_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK23_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk sgx_ck = {
+	.name           = "sgx_ck",
+	.parent         = &sysclk23_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_SGX_SGX_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "sgx_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk main_pll_clk3_ck = {
+	.name		= "main_pll_clk3_ck",
+	.ops		= &clkops_null,
+	.rate		= 600000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div3_sysclk3_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk3_div[] = {
+	{ .parent = &main_pll_clk3_ck, .rates = div3_sysclk3_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk3_ck = {
+	.name		= "sysclk3_ck",
+	.parent		= &main_pll_clk3_ck,
+	.clksel		= sysclk3_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK3_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk ivahd0_ck = {
+	.name           = "ivahd0_ck",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD0_IVAHD_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd0_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ivahd0_sl2_ick = {
+	.name           = "ivahd0_sl2_ick",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD0_SL2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd0_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ivahd1_ck = {
+	.name           = "ivahd1_ck",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD1_IVAHD_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd1_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ivahd1_sl2_ick = {
+	.name           = "ivahd1_sl2_ick",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD1_SL2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd1_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ivahd2_ck = {
+	.name           = "ivahd2_ck",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD2_IVAHD_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd2_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ivahd2_sl2_ick = {
+	.name           = "ivahd2_sl2_ick",
+	.parent         = &sysclk3_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_IVAHD2_SL2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "ivahd2_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk main_pll_clk4_ck = {
+	.name		= "main_pll_clk4_ck",
+	.ops		= &clkops_null,
+	.rate		= 500000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div2_sysclk4_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk4_div[] = {
+	{ .parent = &main_pll_clk4_ck, .rates = div2_sysclk4_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk4_ck = {
+	.name		= "sysclk4_ck",
+	.parent		= &main_pll_clk4_ck,
+	.clksel		= sysclk4_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK4_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_0_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk mmu_ick = {
+	.name           = "mmu_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MMUDATA_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "mmu_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ducati_ucache_ick = {
+	.name		= "ducati_ucache_ick",
+	.parent		= &sysclk4_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "default_ducati_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk tpcc_ick = {
+	.name           = "tpcc_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TPCC_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk tptc0_ick = {
+	.name           = "tptc0_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TPTC0_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk tptc1_ick = {
+	.name           = "tptc1_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TPTC1_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk tptc2_ick = {
+	.name           = "tptc2_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TPTC2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk tptc3_ick = {
+	.name           = "tptc3_ick",
+	.parent         = &sysclk4_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TPTC3_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.recalc         = &followparent_recalc,
+};
+
+static const struct clksel_rate div_4_1_rates[] = {
+	{ .div = 4, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk6_div[] = {
+	{ .parent = &sysclk4_ck, .rates = div_4_1_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk6_ck = {
+	.name		= "sysclk6_ck",
+	.parent		= &sysclk4_ck,
+	.clksel		= sysclk6_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK6_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_0_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk mmu_cfg_ick = {
+	.name           = "mmu_cfg_ick",
+	.parent         = &sysclk6_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MMUCFG_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "mmu_cfg_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk mailbox_ick = {
+	.name           = "mailbox_ick",
+	.parent         = &sysclk6_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MAILBOX_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk spinbox_ick = {
+	.name           = "spinbox_ick",
+	.parent         = &sysclk6_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_SPINBOX_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk gem_vbusp_fck = {
+	.name           = "gem_vbusp_fck",
+	.parent         = &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "active_gem_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk uart1_ick = {
+	.name		= "uart1_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk uart2_ick = {
+	.name		= "uart2_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk uart3_ick = {
+	.name		= "uart3_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk mcspi1_ick = {
+	.name		= "mcspi1_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk usbotg_ick = {
+	.name           = "usbotg_ick",
+	.parent         = &sysclk6_ck,
+	.ops            = &clkops_omap2_usb,
+	.enable_reg	= TI816X_CM_DEFAULT_USB_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "default_usb_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+/*
+ * Points to note about timer conventions:
+ * 1) We are referring dmtimers as gptimers to match omap convention
+ * 2) Skipping gptimer1 as it is secure mode timer.
+ */
+
+static struct clk gpt2_ick = {
+	.name		= "gpt2_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt3_ick = {
+	.name		= "gpt3_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt4_ick = {
+	.name		= "gpt4_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt5_ick = {
+	.name		= "gpt5_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt6_ick = {
+	.name		= "gpt6_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt7_ick = {
+	.name		= "gpt7_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpt8_ick = {
+	.name		= "gpt8_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpmc_ick = {
+	.name		= "gpmc_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk i2c1_ick = {
+	.name		= "i2c1_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk i2c2_ick = {
+	.name		= "i2c2_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk mmchs1_ick = {
+	.name		= "mmchs1_ick",
+	.parent		= &sysclk6_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static const struct clksel_rate div_2_1_rates[] = {
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk5_div[] = {
+	{ .parent = &sysclk4_ck, .rates = div_2_1_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk5_ck = {
+	.name		= "sysclk5_ck",
+	.parent		= &sysclk4_ck,
+	.clksel		= sysclk5_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK5_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_0_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk pcie_ck = {
+	.name           = "pcie_ck",
+	.parent         = &sysclk5_ck,
+	.ops            = &clkops_omap2_pcie,
+	.enable_reg	= TI816X_CM_DEFAULT_PCI_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "default_pcie_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk sata_ick = {
+	.name           = "sata_ick",
+	.parent         = &sysclk5_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_DEFAULT_SATA_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "default_l3_med_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk emac1_ick = {
+	.name           = "emac1_ick",
+	.parent         = &sysclk5_ck,
+	.ops            = &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_ETHERNET_0_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_ethernet_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ducati_ick = {
+	.name           = "ducati_ick",
+	.parent         = &sysclk5_ck,
+	.ops            = &clkops_omap2_dflt,
+	.enable_reg	= TI816X_CM_DEFAULT_DUCATI_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "default_ducati_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk gem_trc_fck = {
+	.name           = "gem_trc_fck",
+	.parent         = &sysclk5_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "active_gem_clkdm",
+	.recalc         = &followparent_recalc,
+};
+
+static struct clk ddr_pll_clk2_ck = {
+	.name		= "ddr_pll_clk2_ck",
+	.ops		= &clkops_null,
+	.rate		= 96000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div3_sysclk10_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk10_div[] = {
+	{ .parent = &ddr_pll_clk2_ck, .rates = div3_sysclk10_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk10_ck = {
+	.name		= "sysclk10_ck",
+	.parent		= &ddr_pll_clk2_ck,
+	.clksel		= sysclk10_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK10_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk uart1_fck = {
+	.name		= "uart1_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_UART_0_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk uart2_fck = {
+	.name		= "uart2_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_UART_1_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk uart3_fck = {
+	.name		= "uart3_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_UART_2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk mcspi1_fck = {
+	.name		= "mcspi1_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_SPI_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk gpmc_fck = {
+	.name		= "gpmc_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_GPMC_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk i2c1_fck = {
+	.name		= "i2c1_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_I2C_0_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk i2c2_fck = {
+	.name		= "i2c2_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_I2C_1_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk mmchs1_fck = {
+	.name		= "mmchs1_fck",
+	.parent		= &sysclk10_ck,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_SDIO_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk main_pll_clk5_ck = {
+	.name		= "main_pll_clk5_ck",
+	.ops		= &clkops_null,
+	.rate		= 125000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div3_sysclk24_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk24_div[] = {
+	{ .parent = &main_pll_clk4_ck, .rates = div3_sysclk24_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk24_ck = {
+	.name		= "sysclk24_ck",
+	.parent		= &main_pll_clk5_ck,
+	.clksel		= sysclk24_div,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK24_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk audio_pll_clk1_ck = {
+	.name		= "audio_pll_clk1_ck",
+	.ops		= &clkops_null,
+	.rate		= 32768,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk audio_pll_clk3_ck = {
+	.name		= "audio_pll_clk3_ck",
+	.ops		= &clkops_null,
+	.rate		= 196000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk audio_pll_clk4_ck = {
+	.name		= "audio_pll_clk4_ck",
+	.ops		= &clkops_null,
+	.rate		= 45000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static struct clk audio_pll_clk5_ck = {
+	.name		= "audio_pll_clk5_ck",
+	.ops		= &clkops_null,
+	.rate		= 32000000,
+	.flags		= RATE_IN_TI816X,
+};
+
+static const struct clksel_rate div3_audio_pll_a_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel audio_pll_a_div[] = {
+	{ .parent = &audio_pll_clk1_ck, .rates = div3_audio_pll_a_rates },
+	{ .parent = NULL },
+};
+
+static struct clk audio_pll_a_ck = {
+	.name		= "audio_pll_a_ck",
+	.parent		= &audio_pll_clk1_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= audio_pll_a_div,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_APA_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static const struct clksel_rate div_1_0_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel_rate div_1_1_rates[] = {
+	{ .div = 1, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel_rate div_1_2_rates[] = {
+	{ .div = 1, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk18_mux_sel[] = {
+	{ .parent = &sys_32k_ck, .rates = div_1_0_rates },
+	{ .parent = &audio_pll_a_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
+static struct clk sysclk18_ck = {
+	.name		= "sysclk18_ck",
+	.parent		= &audio_pll_a_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= sysclk18_mux_sel,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK18_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_0_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static const struct clksel_rate div_sysclk20_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk20_div[] = {
+	{ .parent = &audio_pll_clk3_ck, .rates = div_sysclk20_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk20_ck = {
+	.name		= "sysclk20_ck",
+	.parent		= &audio_pll_clk3_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= sysclk20_div,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK20_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static const struct clksel_rate div_sysclk21_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk21_div[] = {
+	{ .parent = &audio_pll_clk4_ck, .rates = div_sysclk21_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk21_ck = {
+	.name		= "sysclk21_ck",
+	.parent		= &audio_pll_clk4_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= sysclk21_div,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK21_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static const struct clksel_rate div_sysclk22_rates[] = {
+	{ .div = 1, .val = 0, .flags = RATE_IN_TI816X },
+	{ .div = 2, .val = 1, .flags = RATE_IN_TI816X },
+	{ .div = 3, .val = 2, .flags = RATE_IN_TI816X },
+	{ .div = 0 },
+};
+
+static const struct clksel sysclk22_div[] = {
+	{ .parent = &audio_pll_clk5_ck, .rates = div_sysclk22_rates },
+	{ .parent = NULL },
+};
+
+static struct clk sysclk22_ck = {
+	.name		= "sysclk22_ck",
+	.parent		= &audio_pll_clk5_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= sysclk22_div,
+	.ops		= &clkops_null,
+	.clksel_reg	= TI816X_CM_DPLL_SYSCLK22_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_2_MASK,
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static const struct clksel gpt2to8_mux_sel[] = {
+	{ .parent = &tclkin_ck, .rates = div_1_0_rates },
+	{ .parent = &sysclk18_ck, .rates = div_1_1_rates },
+	{ .parent = &sys_clkin_ck, .rates = div_1_2_rates },
+	{ .parent = NULL}
+};
+
+static const struct clksel mcasp0to2_mux_sel[] = {
+	{ .parent = &sysclk20_ck, .rates = div_1_0_rates },
+	{ .parent = &sysclk21_ck, .rates = div_1_1_rates },
+	{ .parent = &sysclk22_ck, .rates = div_1_1_rates },
+	{ .parent = NULL}
+};
+
+static struct clk gpt2_fck = {
+	.name		= "gpt2_fck",
+	.parent		= &sysclk18_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= gpt2to8_mux_sel,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_1_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER1_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt3_fck = {
+	.name		= "gpt3_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER2_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt4_fck = {
+	.name		= "gpt4_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_3_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER3_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt5_fck = {
+	.name		= "gpt5_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_4_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER4_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt6_fck = {
+	.name		= "gpt6_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_5_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER5_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt7_fck = {
+	.name		= "gpt7_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_6_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER6_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk gpt8_fck = {
+	.name		= "gpt8_fck",
+	.parent		= &sysclk18_ck,
+	.clksel		= gpt2to8_mux_sel,
+	.init		= &omap2_init_clksel_parent,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_TIMER_7_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_TIMER7_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk mmchsdb1_fck = {
+	.name		= "mmchsdb1_fck",
+	.parent		= &sysclk18_ck,
+	.ops		= &clkops_null,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &followparent_recalc,
+};
+
+static struct clk mcasp0_fck = {
+	.name		= "mcasp0_fck",
+	.parent		= &sysclk20_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= mcasp0to2_mux_sel,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MCASP0_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_AUDIOCLK_MCASP0_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk mcasp1_fck = {
+	.name		= "mcasp1_fck",
+	.parent		= &sysclk20_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= mcasp0to2_mux_sel,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MCASP1_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_AUDIOCLK_MCASP1_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+static struct clk mcasp2_fck = {
+	.name		= "mcasp2_fck",
+	.parent		= &sysclk20_ck,
+	.init		= &omap2_init_clksel_parent,
+	.clksel		= mcasp0to2_mux_sel,
+	.ops		= &clkops_omap2_ti816x,
+	.enable_reg	= TI816X_CM_ALWON_MCASP2_CLKCTRL,
+	.enable_bit	= TI816X_MODULEMODE_SWCTRL,
+	.clksel_reg	= TI816X_CM_DPLL_AUDIOCLK_MCASP2_CLKSEL,
+	.clksel_mask	= TI816X_CLKSEL_0_1_MASK,
+	.clkdm_name	= "alwon_l3_slow_clkdm",
+	.recalc		= &omap2_clksel_recalc,
+};
+
+/*
+ * clkdev
+ *
+ * FIXME: Some of the external clocks (e.g., tclk) are kept here for
+ * completeness.
+ */
+static struct omap_clk ti816x_clks[] = {
+	CLK(NULL, "secure_32k_ck",	&secure_32k_ck,		CK_TI816X),
+	CLK(NULL, "sys_32k_ck",		&sys_32k_ck,		CK_TI816X),
+	CLK(NULL, "tclkin_ck",		&tclkin_ck,		CK_TI816X),
+	CLK(NULL, "sys_clkin_ck",	&sys_clkin_ck,		CK_TI816X),
+	CLK(NULL, "main_pll_clk1_ck",	&main_pll_clk1_ck,	CK_TI816X),
+	CLK(NULL, "sysclk1_ck",		&sysclk1_ck,		CK_TI816X),
+	CLK(NULL, "gem_ick",		&gem_ick,		CK_TI816X),
+	CLK(NULL, "main_pll_clk2_ck",	&main_pll_clk2_ck,	CK_TI816X),
+	CLK(NULL, "sysclk23_ck",	&sysclk23_ck,		CK_TI816X),
+	CLK(NULL, "sgx_ck",		&sgx_ck,		CK_TI816X),
+	CLK(NULL, "main_pll_clk3_ck",	&main_pll_clk3_ck,	CK_TI816X),
+	CLK(NULL, "sysclk3_ck",		&sysclk3_ck,		CK_TI816X),
+	CLK(NULL, "ivahd0_ck",		&ivahd0_ck,		CK_TI816X),
+	CLK(NULL, "ivahd0_sl2_ick",	&ivahd0_sl2_ick,	CK_TI816X),
+	CLK(NULL, "ivahd1_ck",		&ivahd1_ck,		CK_TI816X),
+	CLK(NULL, "ivahd1_sl2_ick",	&ivahd1_sl2_ick,	CK_TI816X),
+	CLK(NULL, "ivahd2_ck",		&ivahd2_ck,		CK_TI816X),
+	CLK(NULL, "ivahd2_sl2_ick",	&ivahd2_sl2_ick,	CK_TI816X),
+	CLK(NULL, "main_pll_clk4_ck",	&main_pll_clk4_ck,	CK_TI816X),
+	CLK(NULL, "sysclk4_ck",		&sysclk4_ck,		CK_TI816X),
+	CLK(NULL, "mmu_ick",		&mmu_ick,		CK_TI816X),
+	CLK(NULL, "ducati_ucache_ick",	&ducati_ucache_ick,	CK_TI816X),
+	CLK(NULL, "tpcc_ick",		&tpcc_ick,		CK_TI816X),
+	CLK(NULL, "tptc0_ick",		&tptc0_ick,		CK_TI816X),
+	CLK(NULL, "tptc1_ick",		&tptc1_ick,		CK_TI816X),
+	CLK(NULL, "tptc2_ick",		&tptc2_ick,		CK_TI816X),
+	CLK(NULL, "tptc3_ick",		&tptc3_ick,		CK_TI816X),
+	CLK(NULL, "sysclk6_ck",		&sysclk6_ck,		CK_TI816X),
+	CLK(NULL, "mmu_cfg_ick",	&mmu_cfg_ick,		CK_TI816X),
+	CLK(NULL, "mailbox_ick",	&mailbox_ick,		CK_TI816X),
+	CLK(NULL, "spinbox_ick",	&spinbox_ick,		CK_TI816X),
+	CLK(NULL, "gem_vbusp_fck",	&gem_vbusp_fck,		CK_TI816X),
+	CLK(NULL, "uart1_ick",		&uart1_ick,		CK_TI816X),
+	CLK(NULL, "uart2_ick",		&uart2_ick,		CK_TI816X),
+	CLK(NULL, "uart3_ick",		&uart3_ick,		CK_TI816X),
+	CLK("omap2_mcspi.1", "ick",	&mcspi1_ick,		CK_TI816X),
+	CLK(NULL, "gpt2_ick",		&gpt2_ick,		CK_TI816X),
+	CLK(NULL, "gpt3_ick",		&gpt3_ick,		CK_TI816X),
+	CLK(NULL, "gpt4_ick",		&gpt4_ick,		CK_TI816X),
+	CLK(NULL, "gpt5_ick",		&gpt5_ick,		CK_TI816X),
+	CLK(NULL, "gpt6_ick",		&gpt6_ick,		CK_TI816X),
+	CLK(NULL, "gpt7_ick",		&gpt7_ick,		CK_TI816X),
+	CLK(NULL, "gpt8_ick",		&gpt8_ick,		CK_TI816X),
+	CLK(NULL, "gpmc_ick",		&gpmc_ick,		CK_TI816X),
+	CLK("i2c_omap.1", "ick",	&i2c1_ick,		CK_TI816X),
+	CLK("i2c_omap.2", "ick",	&i2c2_ick,		CK_TI816X),
+	CLK("mmci-omap-hs.0", "ick",	&mmchs1_ick,		CK_TI816X),
+	CLK(NULL, "ddr_pll_clk2_ck",	&ddr_pll_clk2_ck,	CK_TI816X),
+	CLK(NULL, "sysclk10_ck",	&sysclk10_ck,		CK_TI816X),
+	CLK(NULL, "uart1_fck",		&uart1_fck,		CK_TI816X),
+	CLK(NULL, "uart2_fck",		&uart2_fck,		CK_TI816X),
+	CLK(NULL, "uart3_fck",		&uart3_fck,		CK_TI816X),
+	CLK(NULL, "usbotg_ick",		&usbotg_ick,		CK_TI816X),
+	CLK(NULL, "sysclk5_ck",		&sysclk5_ck,		CK_TI816X),
+	CLK(NULL, "pcie_ck",		&pcie_ck,		CK_TI816X),
+	CLK(NULL, "sata_ick",		&sata_ick,		CK_TI816X),
+	CLK("davinci_emac.0", NULL,	&emac1_ick,		CK_TI816X),
+	CLK(NULL, "ducati_ick",		&ducati_ick,		CK_TI816X),
+	CLK(NULL, "gem_trc_fck",	&gem_trc_fck,		CK_TI816X),
+	CLK("omap2_mcspi.1", "fck",	&mcspi1_fck,		CK_TI816X),
+	CLK(NULL, "gpmc_fck",		&gpmc_fck,		CK_TI816X),
+	CLK("i2c_omap.1", "fck",	&i2c1_fck,		CK_TI816X),
+	CLK("i2c_omap.2", "fck",	&i2c2_fck,		CK_TI816X),
+	CLK("mmci-omap-hs.0", "fck",	&mmchs1_fck,		CK_TI816X),
+	CLK(NULL, "main_pll_clk5_ck",	&main_pll_clk5_ck,	CK_TI816X),
+	CLK(NULL, "sysclk24_ck",	&sysclk24_ck,		CK_TI816X),
+	CLK(NULL, "audio_pll_clk1_ck",	&audio_pll_clk1_ck,	CK_TI816X),
+	CLK(NULL, "audio_pll_a_ck",	&audio_pll_a_ck,	CK_TI816X),
+	CLK(NULL, "sysclk18_ck",	&sysclk18_ck,		CK_TI816X),
+	CLK(NULL, "gpt2_fck",		&gpt2_fck,		CK_TI816X),
+	CLK(NULL, "gpt3_fck",		&gpt3_fck,		CK_TI816X),
+	CLK(NULL, "gpt4_fck",		&gpt4_fck,		CK_TI816X),
+	CLK(NULL, "gpt5_fck",		&gpt5_fck,		CK_TI816X),
+	CLK(NULL, "gpt6_fck",		&gpt6_fck,		CK_TI816X),
+	CLK(NULL, "gpt7_fck",		&gpt7_fck,		CK_TI816X),
+	CLK(NULL, "gpt8_fck",		&gpt8_fck,		CK_TI816X),
+	CLK("mmci-omap-hs.0", "mmchsdb_fck", &mmchsdb1_fck,	CK_TI816X),
+	CLK(NULL, "audio_pll_clk3_ck",	&audio_pll_clk3_ck,	CK_TI816X),
+	CLK(NULL, "sysclk20_ck",	&sysclk20_ck,		CK_TI816X),
+	CLK(NULL, "audio_pll_clk4_ck",	&audio_pll_clk4_ck,	CK_TI816X),
+	CLK(NULL, "sysclk21_ck",	&sysclk21_ck,		CK_TI816X),
+	CLK(NULL, "audio_pll_clk5_ck",	&audio_pll_clk5_ck,	CK_TI816X),
+	CLK(NULL, "sysclk22_ck",	&sysclk22_ck,		CK_TI816X),
+	CLK("davinci-mcasp.0",	NULL,	&mcasp0_fck,		CK_TI816X),
+	CLK("davinci-mcasp.1",	NULL,	&mcasp1_fck,		CK_TI816X),
+	CLK("davinci-mcasp.2",	NULL,	&mcasp2_fck,		CK_TI816X),
+};
+
+int __init ti816x_clk_init(void)
+{
+	struct omap_clk *c;
+	u32 cpu_clkflg;
+
+	if (cpu_is_ti816x()) {
+		cpu_mask = RATE_IN_TI816X;
+		cpu_clkflg = CK_TI816X;
+	}
+
+	clk_init(&omap2_clk_functions);
+
+	for (c = ti816x_clks; c < ti816x_clks + ARRAY_SIZE(ti816x_clks); c++)
+		clk_preinit(c->lk.clk);
+
+	for (c = ti816x_clks; c < ti816x_clks + ARRAY_SIZE(ti816x_clks); c++)
+		if (c->cpu & cpu_clkflg) {
+			clkdev_add(&c->lk);
+			clk_register(c->lk.clk);
+			omap2_init_clk_clkdm(c->lk.clk);
+		}
+
+	recalculate_root_clocks();
+
+	/*
+	 * Only enable those clocks we will need, let the drivers
+	 * enable other clocks as necessary
+	 */
+	clk_enable_init_clocks();
+
+	return 0;
+}
diff --git a/arch/arm/mach-omap2/clockdomain.c b/arch/arm/mach-omap2/clockdomain.c
index 6e568ec..230e87f 100644
--- a/arch/arm/mach-omap2/clockdomain.c
+++ b/arch/arm/mach-omap2/clockdomain.c
@@ -1,5 +1,5 @@
 /*
- * OMAP2/3/4 clockdomain framework functions
+ * OMAP2/3/4 and TI816X clockdomain framework functions
  *
  * Copyright (C) 2008-2010 Texas Instruments, Inc.
  * Copyright (C) 2008-2010 Nokia Corporation
@@ -240,7 +240,7 @@ static void _omap2_clkdm_set_hwsup(struct clockdomain *clkdm, int enable)
 			bits = OMAP24XX_CLKSTCTRL_ENABLE_AUTO;
 		else
 			bits = OMAP24XX_CLKSTCTRL_DISABLE_AUTO;
-	} else if (cpu_is_omap34xx() || cpu_is_omap44xx()) {
+	} else if (cpu_is_omap34xx() || cpu_is_omap44xx() || cpu_is_ti816x()) {
 		if (enable)
 			bits = OMAP34XX_CLKSTCTRL_ENABLE_AUTO;
 		else
@@ -812,7 +812,7 @@ int omap2_clkdm_sleep(struct clockdomain *clkdm)
 		cm_set_mod_reg_bits(OMAP24XX_FORCESTATE,
 			    clkdm->pwrdm.ptr->prcm_offs, OMAP2_PM_PWSTCTRL);
 
-	} else if (cpu_is_omap34xx() || cpu_is_omap44xx()) {
+	} else if (cpu_is_omap34xx() || cpu_is_omap44xx() || cpu_is_ti816x()) {
 
 		u32 bits = (OMAP34XX_CLKSTCTRL_FORCE_SLEEP <<
 			 __ffs(clkdm->clktrctrl_mask));
@@ -856,7 +856,7 @@ int omap2_clkdm_wakeup(struct clockdomain *clkdm)
 		cm_clear_mod_reg_bits(OMAP24XX_FORCESTATE,
 			      clkdm->pwrdm.ptr->prcm_offs, OMAP2_PM_PWSTCTRL);
 
-	} else if (cpu_is_omap34xx() || cpu_is_omap44xx()) {
+	} else if (cpu_is_omap34xx() || cpu_is_omap44xx() || cpu_is_ti816x()) {
 
 		u32 bits = (OMAP34XX_CLKSTCTRL_FORCE_WAKEUP <<
 			 __ffs(clkdm->clktrctrl_mask));
@@ -899,11 +899,14 @@ void omap2_clkdm_allow_idle(struct clockdomain *clkdm)
 
 	/*
 	 * XXX This should be removed once TI adds wakeup/sleep
-	 * dependency code and data for OMAP4.
+	 * dependency code and data for OMAP4, TI816X
 	 */
 	if (cpu_is_omap44xx()) {
 		WARN_ONCE(1, "clockdomain: OMAP4 wakeup/sleep dependency "
 			  "support is not yet implemented\n");
+	} else if (cpu_is_ti816x()) {
+		WARN_ONCE(1, "clockdomain: TI816X wakeup/sleep dependency "
+			  "support is not yet implemented\n");
 	} else {
 		if (atomic_read(&clkdm->usecount) > 0)
 			_clkdm_add_autodeps(clkdm);
@@ -941,11 +944,14 @@ void omap2_clkdm_deny_idle(struct clockdomain *clkdm)
 
 	/*
 	 * XXX This should be removed once TI adds wakeup/sleep
-	 * dependency code and data for OMAP4.
+	 * dependency code and data for OMAP4, TI816X.
 	 */
 	if (cpu_is_omap44xx()) {
 		WARN_ONCE(1, "clockdomain: OMAP4 wakeup/sleep dependency "
 			  "support is not yet implemented\n");
+	} else if (cpu_is_ti816x()) {
+		WARN_ONCE(1, "clockdomain: TI816X wakeup/sleep dependency "
+			  "support is not yet implemented\n");
 	} else {
 		if (atomic_read(&clkdm->usecount) > 0)
 			_clkdm_del_autodeps(clkdm);
diff --git a/arch/arm/mach-omap2/clockdomains.h b/arch/arm/mach-omap2/clockdomains.h
index 8fc19ff..0a9234d 100644
--- a/arch/arm/mach-omap2/clockdomains.h
+++ b/arch/arm/mach-omap2/clockdomains.h
@@ -832,6 +832,7 @@ static struct clockdomain dpll5_clkdm = {
 #endif   /* CONFIG_ARCH_OMAP3 */
 
 #include "clockdomains44xx.h"
+#include "clockdomains816x.h"
 
 /*
  * Clockdomain hwsup dependencies (OMAP3 only)
@@ -931,6 +932,22 @@ static struct clockdomain *clockdomains_omap[] = {
 	&l3_dma_44xx_clkdm,
 #endif
 
+#ifdef CONFIG_ARCH_TI816X
+	&alwon_l3_slow_816x_clkdm,
+	&alwon_ethernet_816x_clkdm,
+	&mmu_816x_clkdm,
+	&mmu_cfg_816x_clkdm,
+	&active_gem_816x_clkdm,
+	&ivahd0_816x_clkdm,
+	&ivahd1_816x_clkdm,
+	&ivahd2_816x_clkdm,
+	&sgx_816x_clkdm,
+	&default_l3_med_816x_clkdm,
+	&default_ducati_816x_clkdm,
+	&default_pcie_816x_clkdm,
+	&default_usb_816x_clkdm,
+#endif
+
 	NULL,
 };
 
diff --git a/arch/arm/mach-omap2/clockdomains816x.h b/arch/arm/mach-omap2/clockdomains816x.h
new file mode 100644
index 0000000..5a45539
--- /dev/null
+++ b/arch/arm/mach-omap2/clockdomains816x.h
@@ -0,0 +1,155 @@
+/*
+ * arch/arm/mach-omap2/clockdomains816x.h
+ *
+ * TI816X Clock Domain data.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP2_CLOCKDOMAINS816X_H
+#define __ARCH_ARM_MACH_OMAP2_CLOCKDOMAINS816X_H
+
+#include <plat/clockdomain.h>
+
+#include "cm.h"
+#include "cm-regbits-816x.h"
+
+#if defined(CONFIG_ARCH_TI816X)
+
+/*
+ * TODO:
+ * - Add other domains as required
+ * - Fill up associated powerdomans (especially ALWON powerdomains are NULL at
+ *   the moment
+ * - Consider dependencies across domains (probably not applicable till now)
+ */
+
+static struct clockdomain alwon_l3_slow_816x_clkdm = {
+	.name		  = "alwon_l3_slow_clkdm",
+	.pwrdm		  = { .name = "alwon_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_ALWON_L3_SLOW_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain alwon_ethernet_816x_clkdm = {
+	.name		  = "alwon_ethernet_clkdm",
+	.pwrdm		  = { .name = "alwon_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_ETHERNET_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain mmu_816x_clkdm = {
+	.name		  = "mmu_clkdm",
+	.pwrdm		  = { .name = "alwon_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_MMU_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain mmu_cfg_816x_clkdm = {
+	.name		  = "mmu_cfg_clkdm",
+	.pwrdm		  = { .name = "alwon_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_MMUCFG_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain active_gem_816x_clkdm = {
+	.name		  = "active_gem_clkdm",
+	.pwrdm		  = { .name = "active_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_ACTIVE_GEM_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain ivahd0_816x_clkdm = {
+	.name		  = "ivahd0_clkdm",
+	.pwrdm		  = { .name = "ivahd0_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_IVAHD0_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain ivahd1_816x_clkdm = {
+	.name		  = "ivahd1_clkdm",
+	.pwrdm		  = { .name = "ivahd1_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_IVAHD1_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain ivahd2_816x_clkdm = {
+	.name		  = "ivahd2_clkdm",
+	.pwrdm		  = { .name = "ivahd2_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_IVAHD2_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain sgx_816x_clkdm = {
+	.name		  = "sgx_clkdm",
+	.pwrdm		  = { .name = "sgx_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_SGX_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain default_l3_med_816x_clkdm = {
+	.name		  = "default_l3_med_clkdm",
+	.pwrdm		  = { .name = "default_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_DEFAULT_L3_MED_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain default_ducati_816x_clkdm = {
+	.name		  = "default_ducati_clkdm",
+	.pwrdm		  = { .name = "default_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_DEFAULT_DUCATI_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain default_pcie_816x_clkdm = {
+	.name		  = "default_pcie_clkdm",
+	.pwrdm		  = { .name = "default_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_DEFAULT_PCI_CLKSTCTRL,
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+static struct clockdomain default_usb_816x_clkdm = {
+	.name		  = "default_usb_clkdm",
+	.pwrdm		  = { .name = "default_pwrdm" },
+	.clkstctrl_reg	  = TI816X_CM_DEFAULT_L3_SLOW_CLKSTCTRL, /* FIXME */
+	.clktrctrl_mask	  = TI816X_CLKTRCTRL_MASK,
+	.flags		  = CLKDM_CAN_HWSUP_SWSUP,
+	.omap_chip	  = OMAP_CHIP_INIT(CHIP_IS_TI816X),
+};
+
+#endif
+
+#endif
diff --git a/arch/arm/mach-omap2/cm-regbits-816x.h b/arch/arm/mach-omap2/cm-regbits-816x.h
new file mode 100644
index 0000000..8365390
--- /dev/null
+++ b/arch/arm/mach-omap2/cm-regbits-816x.h
@@ -0,0 +1,46 @@
+/*
+ * arch/arm/mach-omap2/cm-regbits-816x.h
+ *
+ * TI816X CM register bits.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP2_CM_REGBITS_816X_H
+#define __ARCH_ARM_MACH_OMAP2_CM_REGBITS_816X_H
+
+#include "cm.h"
+
+#define TI816X_CLKSEL_0_0_SHIFT					0
+#define TI816X_CLKSEL_0_0_MASK					BITFIELD(0, 0)
+
+#define TI816X_CLKSEL_0_1_SHIFT					0
+#define TI816X_CLKSEL_0_1_MASK					BITFIELD(0, 1)
+
+#define TI816X_CLKSEL_0_2_SHIFT					0
+#define TI816X_CLKSEL_0_2_MASK					BITFIELD(0, 2)
+
+/* Modulemode bit */
+#define TI816X_MODULEMODE_SWCTRL				1
+
+/* IDLEST bit */
+#define TI816X_IDLEST_SHIFT					16
+#define TI816X_IDLEST_MASK					BITFIELD(16, 17)
+#define TI816X_IDLEST_VAL					3
+
+/* Used for clockdomain control */
+#define TI816X_CLKTRCTRL_SHIFT					0
+#define TI816X_CLKTRCTRL_MASK					BITFIELD(0, 1)
+
+/* TODO: Add other specific CM register bits */
+
+#endif
diff --git a/arch/arm/mach-omap2/cm.h b/arch/arm/mach-omap2/cm.h
index 94728b1..1a2be9e 100644
--- a/arch/arm/mach-omap2/cm.h
+++ b/arch/arm/mach-omap2/cm.h
@@ -26,8 +26,11 @@
 			OMAP2_L4_IO_ADDRESS(OMAP4430_CM1_BASE + (module) + (reg))
 #define OMAP44XX_CM2_REGADDR(module, reg)				\
 			OMAP2_L4_IO_ADDRESS(OMAP4430_CM2_BASE + (module) + (reg))
+#define TI816X_CM_REGADDR(module, reg)					\
+		TI816X_L4_SLOW_IO_ADDRESS(TI816X_PRCM_BASE + (module) + (reg))
 
 #include "cm44xx.h"
+#include "cm816x.h"
 
 /*
  * Architecture-specific global CM registers
diff --git a/arch/arm/mach-omap2/cm816x.h b/arch/arm/mach-omap2/cm816x.h
new file mode 100644
index 0000000..4a32e91
--- /dev/null
+++ b/arch/arm/mach-omap2/cm816x.h
@@ -0,0 +1,312 @@
+/*
+ * arch/arm/mach-omap2/cm816x.h
+ *
+ * TI816x CM register access macros.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP2_CM816X_H
+#define __ARCH_ARM_MACH_OMAP2_CM816X_H
+
+/* CM_DPLL */
+#define TI816X_CM_DPLL_SYSCLK1_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0000)
+#define TI816X_CM_DPLL_SYSCLK2_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0004)
+#define TI816X_CM_DPLL_SYSCLK3_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0008)
+#define TI816X_CM_DPLL_SYSCLK4_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x000C)
+#define TI816X_CM_DPLL_SYSCLK5_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0010)
+#define TI816X_CM_DPLL_SYSCLK6_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0014)
+#define TI816X_CM_DPLL_SYSCLK7_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0018)
+#define TI816X_CM_DPLL_SYSCLK10_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0024)
+#define TI816X_CM_DPLL_SYSCLK11_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x002C)
+#define TI816X_CM_DPLL_SYSCLK12_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0030)
+#define TI816X_CM_DPLL_SYSCLK13_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0034)
+#define TI816X_CM_DPLL_SYSCLK15_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0038)
+#define TI816X_CM_DPLL_VPB3_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0040)
+#define TI816X_CM_DPLL_VPC1_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0044)
+#define TI816X_CM_DPLL_VPD1_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0048)
+#define TI816X_CM_DPLL_SYSCLK19_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x004C)
+#define TI816X_CM_DPLL_SYSCLK20_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0050)
+#define TI816X_CM_DPLL_SYSCLK21_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0054)
+#define TI816X_CM_DPLL_SYSCLK22_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0058)
+#define TI816X_CM_DPLL_APA_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x005C)
+#define TI816X_CM_DPLL_SYSCLK14_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0070)
+#define TI816X_CM_DPLL_SYSCLK16_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0074)
+#define TI816X_CM_DPLL_SYSCLK18_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0078)
+#define TI816X_CM_DPLL_AUDIOCLK_MCASP0_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x007C)
+#define TI816X_CM_DPLL_AUDIOCLK_MCASP1_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0080)
+#define TI816X_CM_DPLL_AUDIOCLK_MCASP2_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0084)
+#define TI816X_CM_DPLL_AUDIOCLK_MCBSP_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0088)
+#define TI816X_CM_DPLL_TIMER1_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0090)
+#define TI816X_CM_DPLL_TIMER2_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0094)
+#define TI816X_CM_DPLL_TIMER3_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x0098)
+#define TI816X_CM_DPLL_TIMER4_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x009C)
+#define TI816X_CM_DPLL_TIMER5_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00A0)
+#define TI816X_CM_DPLL_TIMER6_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00A4)
+#define TI816X_CM_DPLL_TIMER7_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00A8)
+#define TI816X_CM_DPLL_HDMI_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00AC)
+#define TI816X_CM_DPLL_SYSCLK23_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00B0)
+#define TI816X_CM_DPLL_SYSCLK24_CLKSEL	\
+				TI816X_CM_REGADDR(TI816X_CM_DPLL_MOD, 0x00B4)
+
+/* CM_DEFAULT */
+#define TI816X_CM_DEFAULT_L3_MED_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0004)
+#define TI816X_CM_DEFAULT_L3_FAST_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0008)
+#define TI816X_CM_DEFAULT_TPPSS_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x000C)
+#define TI816X_CM_DEFAULT_PCI_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0010)
+#define TI816X_CM_DEFAULT_L3_SLOW_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0014)
+#define TI816X_CM_DEFAULT_DUCATI_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0018)
+#define TI816X_CM_DEFAULT_EMIF_0_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0020)
+#define TI816X_CM_DEFAULT_EMIF_1_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0024)
+#define TI816X_CM_DEFAULT_DMM_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0028)
+#define TI816X_CM_DEFAULT_FW_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x002C)
+#define TI816X_CM_DEFAULT_TPPSS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0054)
+#define TI816X_CM_DEFAULT_USB_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0058)
+#define TI816X_CM_DEFAULT_SATA_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0060)
+#define TI816X_CM_DEFAULT_DUCATI_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0074)
+#define TI816X_CM_DEFAULT_PCI_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_DEFAULT_MOD, 0x0078)
+
+/* CM_IVAHD0 */
+#define TI816X_CM_IVAHD0_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD0_MOD, 0x0000)
+#define TI816X_CM_IVAHD0_IVAHD_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD0_MOD, 0x0020)
+#define TI816X_CM_IVAHD0_SL2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD0_MOD, 0x0024)
+
+/* CM_IVAHD1 */
+#define TI816X_CM_IVAHD1_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD1_MOD, 0x0000)
+#define TI816X_CM_IVAHD1_IVAHD_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD1_MOD, 0x0020)
+#define TI816X_CM_IVAHD1_SL2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD1_MOD, 0x0024)
+
+/* CM_IVAHD2 */
+#define TI816X_CM_IVAHD2_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD2_MOD, 0x0000)
+#define TI816X_CM_IVAHD2_IVAHD_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD2_MOD, 0x0020)
+#define TI816X_CM_IVAHD2_SL2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_IVAHD2_MOD, 0x0024)
+
+/* CM_SGX */
+#define TI816X_CM_SGX_CLKSTCTRL			\
+				TI816X_CM_REGADDR(TI816X_CM_SGX_MOD, 0x0000)
+#define TI816X_CM_SGX_SGX_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_SGX_MOD, 0x0020)
+
+/* CM_ALWON */
+#define TI816X_CM_ALWON_L3_SLOW_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0000)
+#define TI816X_CM_ETHERNET_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0004)
+#define TI816X_CM_ALWON_L3_MED_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0008)
+#define TI816X_CM_MMU_CLKSTCTRL			\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x000C)
+#define TI816X_CM_MMUCFG_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0010)
+#define TI816X_CM_ALWON_OCMC_0_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0014)
+#define TI816X_CM_ALWON_OCMC_1_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0018)
+#define TI816X_CM_ALWON_MPU_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x001C)
+#define TI816X_CM_ALWON_SYSCLK4_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0020)
+#define TI816X_CM_ALWON_SYSCLK5_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0024)
+#define TI816X_CM_ALWON_SYSCLK6_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0028)
+#define TI816X_CM_ALWON_RTC_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x002C)
+#define TI816X_CM_ALWON_L3_FAST_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0030)
+#define TI816X_CM_ALWON_MCASP0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0140)
+#define TI816X_CM_ALWON_MCASP1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0144)
+#define TI816X_CM_ALWON_MCASP2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0148)
+#define TI816X_CM_ALWON_MCBSP_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x014C)
+#define TI816X_CM_ALWON_UART_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0150)
+#define TI816X_CM_ALWON_UART_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0154)
+#define TI816X_CM_ALWON_UART_2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0158)
+#define TI816X_CM_ALWON_GPIO_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x015C)
+#define TI816X_CM_ALWON_GPIO_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0160)
+#define TI816X_CM_ALWON_I2C_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0164)
+#define TI816X_CM_ALWON_I2C_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0168)
+#define TI816X_CM_ALWON_TIMER_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x016C)
+#define TI816X_CM_ALWON_TIMER_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0170)
+#define TI816X_CM_ALWON_TIMER_2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0174)
+#define TI816X_CM_ALWON_TIMER_3_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0178)
+#define TI816X_CM_ALWON_TIMER_4_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x017C)
+#define TI816X_CM_ALWON_TIMER_5_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0180)
+#define TI816X_CM_ALWON_TIMER_6_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0184)
+#define TI816X_CM_ALWON_TIMER_7_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0188)
+#define TI816X_CM_ALWON_WDTIMER_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x018C)
+#define TI816X_CM_ALWON_SPI_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0190)
+#define TI816X_CM_ALWON_MAILBOX_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0194)
+#define TI816X_CM_ALWON_SPINBOX_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0198)
+#define TI816X_CM_ALWON_MMUDATA_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x019C)
+#define TI816X_CM_ALWON_VLYNQ_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01A0)
+#define TI816X_CM_ALWON_MMUCFG_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01A8)
+#define TI816X_CM_ALWON_SDIO_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01B0)
+#define TI816X_CM_ALWON_OCMC_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01B4)
+#define TI816X_CM_ALWON_OCMC_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01B8)
+#define TI816X_CM_ALWON_SMARTCARD_0_CLKCTR	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01BC)
+#define TI816X_CM_ALWON_SMARTCARD_1_CLKCTR	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01C0)
+#define TI816X_CM_ALWON_CONTROL_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01C4)
+#define TI816X_CM_ALWON_SECSS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01C8)
+#define TI816X_CM_ALWON_GPMC_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01D0)
+#define TI816X_CM_ALWON_ETHERNET_0_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01D4)
+#define TI816X_CM_ALWON_ETHERNET_1_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01D8)
+#define TI816X_CM_ALWON_MPU_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01DC)
+#define TI816X_CM_ALWON_DEBUGSS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01E0)
+#define TI816X_CM_ALWON_L3_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01E4)
+#define TI816X_CM_ALWON_L4HS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01E8)
+#define TI816X_CM_ALWON_L4LS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01EC)
+#define TI816X_CM_ALWON_RTC_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01F0)
+#define TI816X_CM_ALWON_TPCC_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01F4)
+#define TI816X_CM_ALWON_TPTC0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01F8)
+#define TI816X_CM_ALWON_TPTC1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x01FC)
+#define TI816X_CM_ALWON_TPTC2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0200)
+#define TI816X_CM_ALWON_TPTC3_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0204)
+#define TI816X_CM_ALWON_SR_0_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0208)
+#define TI816X_CM_ALWON_SR_1_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x020C)
+#define TI816X_CM_ALWON_SR_2_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0210)
+#define TI816X_CM_ALWON_SR_3_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0214)
+#define TI816X_CM_ALWON_SR_4_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0218)
+#define TI816X_CM_ALWON_SR_5_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x021C)
+#define TI816X_CM_ALWON_SR_6_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0220)
+#define TI816X_CM_ALWON_SR_7_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0224)
+#define TI816X_CM_ALWON_CUST_EFUSE_CLKCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ALWON_MOD, 0x0228)
+
+#define TI816X_CM_ACTIVE_GEM_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0000)
+#define TI816X_CM_ACTIVE_HDDSS_CLKSTCTRL	\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0004)
+#define TI816X_CM_ACTIVE_HDMI_CLKSTCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0008)
+#define TI816X_CM_ACTIVE_GEM_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0020)
+#define TI816X_CM_ACTIVE_HDDSS_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0024)
+#define TI816X_CM_ACTIVE_HDMI_CLKCTRL		\
+				TI816X_CM_REGADDR(TI816X_CM_ACTIVE_MOD, 0x0028)
+
+#endif
diff --git a/arch/arm/plat-omap/include/plat/clkdev_omap.h b/arch/arm/plat-omap/include/plat/clkdev_omap.h
index bb937f3..9ac1997 100644
--- a/arch/arm/plat-omap/include/plat/clkdev_omap.h
+++ b/arch/arm/plat-omap/include/plat/clkdev_omap.h
@@ -40,6 +40,7 @@ struct omap_clk {
 #define CK_3517		(1 << 11)
 #define CK_36XX		(1 << 12)	/* OMAP36xx/37xx-specific clocks */
 #define CK_443X		(1 << 13)
+#define CK_TI816X	(1 << 14)
 
 #define CK_AM35XX	(CK_3505 | CK_3517)	/* all Sitara AM35xx */
 
diff --git a/arch/arm/plat-omap/include/plat/clock.h b/arch/arm/plat-omap/include/plat/clock.h
index 7b7caae..baf3523 100644
--- a/arch/arm/plat-omap/include/plat/clock.h
+++ b/arch/arm/plat-omap/include/plat/clock.h
@@ -28,7 +28,7 @@ struct clkops {
 						  u8 *);
 };
 
-#ifdef CONFIG_ARCH_OMAP2PLUS
+#if defined(CONFIG_ARCH_OMAP2PLUS) || defined(CONFIG_ARCH_TI816X)
 
 struct clksel_rate {
 	u32			val;
@@ -101,7 +101,8 @@ struct dpll_data {
 	u8			min_divider;
 	u8			max_divider;
 	u8			modes;
-#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4)
+#if defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4) \
+			       || defined(CONFIG_ARCH_TI816X)
 	void __iomem		*autoidle_reg;
 	void __iomem		*idlest_reg;
 	u32			autoidle_mask;
@@ -133,7 +134,7 @@ struct clk {
 	__s8			usecount;
 	u8			fixed_div;
 	u8			flags;
-#ifdef CONFIG_ARCH_OMAP2PLUS
+#if defined(CONFIG_ARCH_OMAP2PLUS) || defined(CONFIG_ARCH_TI816X)
 	void __iomem		*clksel_reg;
 	u32			clksel_mask;
 	const struct clksel	*clksel;
@@ -205,6 +206,7 @@ struct clocksource *get_clocksource_32k(void);
 #define RATE_IN_3430ES2		(1 << 4)	/* 3430ES2 rates only */
 #define RATE_IN_36XX		(1 << 5)
 #define RATE_IN_4430		(1 << 6)
+#define RATE_IN_TI816X		(1 << 7)
 
 #define RATE_IN_24XX		(RATE_IN_242X | RATE_IN_243X)
 
-- 
1.7.0.2

