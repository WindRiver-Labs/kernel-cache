From e7c8e703c83e43437e431b71199d9c163305aebb Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 10 Jan 2013 14:32:23 +0800
Subject: [PATCH 22/23] mxc/pmic: add pmic drivers for mxc platforms

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add pmic core common driver and pmic mc34708 support for mxc platform.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/mxc/Kconfig                        |    1 +
 drivers/mxc/Makefile                       |    1 +
 drivers/mxc/pmic/Kconfig                   |   26 ++
 drivers/mxc/pmic/Makefile                  |    5 +
 drivers/mxc/pmic/core/Makefile             |   17 +
 drivers/mxc/pmic/core/mc34708.c            |  121 +++++++
 drivers/mxc/pmic/core/pmic.h               |  107 ++++++
 drivers/mxc/pmic/core/pmic_adc_interface.c |   57 +++
 drivers/mxc/pmic/core/pmic_common.c        |  140 ++++++++
 drivers/mxc/pmic/core/pmic_core_i2c.c      |  440 +++++++++++++++++++++++
 drivers/mxc/pmic/core/pmic_core_spi.c      |  399 +++++++++++++++++++++
 drivers/mxc/pmic/core/pmic_event.c         |  236 +++++++++++++
 drivers/mxc/pmic/core/pmic_external.c      |  338 ++++++++++++++++++
 include/linux/mfd/mc34708/core.h           |   83 +++++
 include/linux/mfd/mc34708/mc34708.h        |  134 +++++++
 include/linux/pmic_adc.h                   |  468 +++++++++++++++++++++++++
 include/linux/pmic_external.h              |  522 ++++++++++++++++++++++++++++
 include/linux/pmic_status.h                |   82 +++++
 18 files changed, 3177 insertions(+)
 create mode 100644 drivers/mxc/pmic/Kconfig
 create mode 100644 drivers/mxc/pmic/Makefile
 create mode 100644 drivers/mxc/pmic/core/Makefile
 create mode 100644 drivers/mxc/pmic/core/mc34708.c
 create mode 100644 drivers/mxc/pmic/core/pmic.h
 create mode 100644 drivers/mxc/pmic/core/pmic_adc_interface.c
 create mode 100644 drivers/mxc/pmic/core/pmic_common.c
 create mode 100644 drivers/mxc/pmic/core/pmic_core_i2c.c
 create mode 100644 drivers/mxc/pmic/core/pmic_core_spi.c
 create mode 100644 drivers/mxc/pmic/core/pmic_event.c
 create mode 100644 drivers/mxc/pmic/core/pmic_external.c
 create mode 100644 include/linux/mfd/mc34708/core.h
 create mode 100644 include/linux/mfd/mc34708/mc34708.h
 create mode 100644 include/linux/pmic_adc.h
 create mode 100644 include/linux/pmic_external.h
 create mode 100644 include/linux/pmic_status.h

diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 894c42d..dc28115 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -21,6 +21,7 @@ source "drivers/mxc/ipu3/Kconfig"
 source "drivers/mxc/gpu-viv/Kconfig"
 source "drivers/mxc/thermal/Kconfig"
 source "drivers/mxc/vpu/Kconfig"
+source "drivers/mxc/pmic/Kconfig"
 endmenu
 
 endif
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index f79ca06..1404f064 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -2,3 +2,4 @@ obj-$(CONFIG_MXC_IPU_V3)			+= ipu3/
 obj-$(CONFIG_MXC_GPU_VIV)			+= gpu-viv/
 obj-$(CONFIG_ANATOP_THERMAL)			+= thermal/
 obj-$(CONFIG_MXC_VPU)				+= vpu/
+obj-$(CONFIG_MXC_PMIC)				+= pmic/
diff --git a/drivers/mxc/pmic/Kconfig b/drivers/mxc/pmic/Kconfig
new file mode 100644
index 0000000..962f95a
--- /dev/null
+++ b/drivers/mxc/pmic/Kconfig
@@ -0,0 +1,26 @@
+#
+# PMIC device driver configuration
+#
+
+menu "MXC PMIC support"
+
+config MXC_PMIC
+	boolean
+
+config MXC_PMIC_MC34708
+	tristate "MC34708 PMIC"
+	depends on ARCH_MXC && (I2C || SPI)
+	select MXC_PMIC
+	---help---
+	  This is the MXC MC34708(PMIC) support. It include
+	  ADC, Battery, Connectivity, Light, Power and RTC.
+
+config MXC_PMIC_I2C
+	bool "Support PMIC I2C Interface"
+	depends on (MXC_PMIC_MC13892 || MXC_PMIC_MC34708) && I2C
+
+config MXC_PMIC_SPI
+	bool "Support PMIC SPI Interface"
+	depends on (MXC_PMIC_MC13892 || MXC_PMIC_MC13783 || MXC_PMIC_MC34708) && SPI
+
+endmenu
diff --git a/drivers/mxc/pmic/Makefile b/drivers/mxc/pmic/Makefile
new file mode 100644
index 0000000..b24839b
--- /dev/null
+++ b/drivers/mxc/pmic/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the MXC PMIC drivers.
+#
+
+obj-y				+= core/
diff --git a/drivers/mxc/pmic/core/Makefile b/drivers/mxc/pmic/core/Makefile
new file mode 100644
index 0000000..1b2cab5
--- /dev/null
+++ b/drivers/mxc/pmic/core/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for the PMIC core drivers.
+#
+obj-$(findstring y, $(CONFIG_MXC_PMIC_MC13892) $(CONFIG_MXC_PMIC_MC34708))	+= pmic_mxc_mod.o
+pmic_mxc_mod-objs	:= pmic_external.o pmic_event.o pmic_common.o pmic_adc_interface.o
+
+ifneq ($(CONFIG_MXC_PMIC_MC34708),)
+pmic_mxc_mod-objs	+= mc34708.o
+endif
+
+ifneq ($(CONFIG_MXC_PMIC_SPI),)
+pmic_mxc_mod-objs += pmic_core_spi.o
+endif
+
+ifneq ($(CONFIG_MXC_PMIC_I2C),)
+pmic_mxc_mod-objs += pmic_core_i2c.o
+endif
diff --git a/drivers/mxc/pmic/core/mc34708.c b/drivers/mxc/pmic/core/mc34708.c
new file mode 100644
index 0000000..0f37683
--- /dev/null
+++ b/drivers/mxc/pmic/core/mc34708.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*!
+ * @file pmic/core/mc34708.c
+ * @brief This file contains MC34708 specific PMIC code. This implementaion
+ * may differ for each PMIC chip.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/mfd/mc34708/core.h>
+
+#include <asm/mach-types.h>
+
+#include "pmic.h"
+
+/*
+ * Defines
+ */
+#define MC34708_I2C_RETRY_TIMES 10
+#define MXC_PMIC_FRAME_MASK		0x00FFFFFF
+#define MXC_PMIC_MAX_REG_NUM		0x3F
+#define MXC_PMIC_REG_NUM_SHIFT		0x19
+#define MXC_PMIC_WRITE_BIT_SHIFT		31
+
+void mc34708_power_off(void);
+
+void *mc34708_alloc_data(struct device *dev)
+{
+	struct mc34708 *mc34708;
+
+	mc34708 = kzalloc(sizeof(struct mc34708), GFP_KERNEL);
+	if (mc34708 == NULL)
+		return NULL;
+
+	mc34708->dev = dev;
+
+	return (void *)mc34708;
+}
+
+int mc34708_init_registers(void)
+{
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_MASK0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS0, 0xFFFFFF));
+	CHECK_ERROR(pmic_write(REG_INT_STATUS1, 0xFFFFFF));
+
+	pm_power_off = mc34708_power_off;
+
+	return PMIC_SUCCESS;
+}
+
+
+/*!
+ * This function returns the PMIC version in system.
+ *
+ * @param	ver	pointer to the pmic_version_t structure
+ *
+ * @return	This function returns PMIC version.
+ */
+void mc34708_get_revision(pmic_version_t *ver)
+{
+	int rev_id = 0;
+	int rev1 = 0;
+	int rev2 = 0;
+	int finid = 0;
+	int icid = 0;
+
+	ver->id = PMIC_MC34708;
+	pmic_read(REG_IDENTIFICATION, &rev_id);
+
+	rev1 = (rev_id & 0x018) >> 3;
+	rev2 = (rev_id & 0x007);
+	icid = (rev_id & 0x01C0) >> 6;
+	finid = (rev_id & 0x01E00) >> 9;
+
+	ver->revision = ((rev1 * 10) + rev2);
+	printk(KERN_INFO "mc34708 Rev %d.%d FinVer %x detected\n", rev1,
+	       rev2, finid);
+}
+
+void mc34708_power_off(void)
+{
+	unsigned int value;
+
+	pmic_read_reg(REG_POWER_CTL0, &value, 0xffffff);
+
+	value |= 0x000008;
+
+	pmic_write_reg(REG_POWER_CTL0, value, 0xffffff);
+}
diff --git a/drivers/mxc/pmic/core/pmic.h b/drivers/mxc/pmic/core/pmic.h
new file mode 100644
index 0000000..1390110
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __PMIC_H__
+#define __PMIC_H__
+
+ /*!
+  * @file pmic.h
+  * @brief This file contains prototypes of all the functions to be
+  * defined for each PMIC chip. The implementation of these may differ
+  * from PMIC chip to PMIC chip.
+  *
+  * @ingroup PMIC_CORE
+  */
+
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+
+#define MAX_ACTIVE_EVENTS		10
+
+/*!
+ * This structure is a way for the PMIC core driver to define their own
+ * \b spi_device structure. This structure includes the core \b spi_device
+ * structure that is provided by Linux SPI Framework/driver as an
+ * element and may contain other elements that are required by core driver.
+ */
+struct mxc_pmic {
+	/*!
+	 * Master side proxy for an SPI/I2C slave device(PMIC)
+	 */
+	struct spi_device *spi;
+	struct i2c_client *i2c;
+};
+
+struct pmic_internal {
+	const char *name;
+	void *(*pmic_alloc_data)(struct device *dev);
+	int (*pmic_init_registers)(void);
+	void (*pmic_get_revision)(pmic_version_t *ver);
+};
+
+#define _PMIC_INTERNAL_INITIALIZER(type)				\
+{									\
+	.name			= #type,				\
+	.pmic_alloc_data	= type ## _alloc_data,			\
+	.pmic_init_registers	= type ## _init_registers,		\
+	.pmic_get_revision	= type ## _get_revision,		\
+}
+
+/*!
+ * This function is called to transfer data to PMIC on SPI.
+ *
+ * @param    spi	the SPI slave device(PMIC)
+ * @param    buf   	the pointer to the data buffer
+ * @param    len    	the length of the data to be transferred
+ *
+ * @return   Returns 0 on success -1 on failure.
+ */
+static inline int spi_rw(struct spi_device *spi, u8 *buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+	struct spi_message m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+#ifdef CONFIG_SPI
+	if (spi_sync(spi, &m) != 0 || m.status != 0)
+		return PMIC_ERROR;
+#endif
+	return len - m.actual_length;
+}
+
+#ifdef CONFIG_MXC_PMIC_FIXARB
+extern PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi);
+#else
+static inline PMIC_STATUS pmic_fix_arbitration(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+#endif
+
+int pmic_start_event_thread(int irq_num);
+
+void pmic_stop_event_thread(void);
+
+#endif				/* __PMIC_H__ */
diff --git a/drivers/mxc/pmic/core/pmic_adc_interface.c b/drivers/mxc/pmic/core/pmic_adc_interface.c
new file mode 100644
index 0000000..ea6f0a0
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_adc_interface.c
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_adc.h>
+
+#include "pmic.h"
+
+static struct pmic_adc_api *pmic_adc_apis;
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result)
+{
+	if (pmic_adc_apis && pmic_adc_apis->pmic_adc_convert)
+		return pmic_adc_apis->pmic_adc_convert(channel, result);
+
+	return PMIC_ERROR;
+}
+EXPORT_SYMBOL(pmic_adc_convert);
+
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *ts_value, int wait)
+{
+	if (pmic_adc_apis && pmic_adc_apis->pmic_adc_get_touch_sample)
+		return pmic_adc_apis->pmic_adc_get_touch_sample(ts_value, wait);
+
+	return PMIC_ERROR;
+}
+EXPORT_SYMBOL(pmic_adc_get_touch_sample);
+
+int is_pmic_adc_ready(void)
+{
+	if (pmic_adc_apis && pmic_adc_apis->is_pmic_adc_ready)
+		return pmic_adc_apis->is_pmic_adc_ready();
+
+	return 0;
+}
+EXPORT_SYMBOL(is_pmic_adc_ready);
+
+void register_adc_apis(struct pmic_adc_api *papi)
+{
+	pmic_adc_apis = papi;
+}
diff --git a/drivers/mxc/pmic/core/pmic_common.c b/drivers/mxc/pmic/core/pmic_common.c
new file mode 100644
index 0000000..860d1c1
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_common.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2009-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_common.c
+ * @brief This is the common file for the PMIC Core/Protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include <asm/uaccess.h>
+
+#include "pmic.h"
+
+/*
+ * Global variables
+ */
+pmic_version_t mxc_pmic_version;
+unsigned int active_events[MAX_ACTIVE_EVENTS];
+
+
+static struct completion event_completion;
+static struct task_struct *tstask;
+
+static int pmic_event_thread_func(void *v)
+{
+	unsigned int loop;
+	unsigned int count = 0;
+	unsigned int irq = (int)v;
+
+	/* set_freezable_with_signal(); */
+	while (1) {
+		if (wait_for_completion_interruptible(
+				&event_completion)) {
+			/* possiblely wakeup by a freeze request*/
+			try_to_freeze();
+			/* check if irq arrives when resume*/
+			if (!try_wait_for_completion(
+				&event_completion))
+				continue;
+		}
+		if (kthread_should_stop())
+			break;
+
+		count = pmic_get_active_events(
+				active_events);
+		pr_debug("active events number %d\n", count);
+
+	do {
+		for (loop = 0; loop < count; loop++)
+			pmic_event_callback(active_events[loop]);
+
+		count = pmic_get_active_events(active_events);
+
+	} while (count != 0);
+		enable_irq(irq);
+	}
+
+	return 0;
+}
+
+int pmic_start_event_thread(int irq_num)
+{
+	int ret = 0;
+
+	if (tstask)
+		return ret;
+
+	init_completion(&event_completion);
+
+	tstask = kthread_run(pmic_event_thread_func,
+		(void *)irq_num, "pmic-event-thread");
+	ret = IS_ERR(tstask) ? -1 : 0;
+	if (IS_ERR(tstask))
+		tstask = NULL;
+	return ret;
+}
+
+void pmic_stop_event_thread(void)
+{
+	if (tstask) {
+		complete(&event_completion);
+		kthread_stop(tstask);
+	}
+}
+
+/*!
+ * This function is called when pmic interrupt occurs on the processor.
+ * It is the interrupt handler for the pmic module.
+ *
+ * @param        irq        the irq number
+ * @param        dev_id     the pointer on the device
+ *
+ * @return       The function returns IRQ_HANDLED when handled.
+ */
+irqreturn_t pmic_irq_handler(int irq, void *dev_id)
+{
+	disable_irq_nosync(irq);
+	complete(&event_completion);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+
+pmic_version_t pmic_get_version(void)
+{
+	return mxc_pmic_version;
+}
+EXPORT_SYMBOL(pmic_get_version);
diff --git a/drivers/mxc/pmic/core/pmic_core_i2c.c b/drivers/mxc/pmic/core/pmic_core_i2c.c
new file mode 100644
index 0000000..3a9b9c5
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_i2c.c
@@ -0,0 +1,440 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*!
+ * @file pmic_core_i2c.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. i2c
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/i2c.h>
+#include <linux/mfd/mc34708/core.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include <linux/uaccess.h>
+#include <mach/hardware.h>
+
+#include "pmic.h"
+
+#define MC13892_GENERATION_ID_LSH	6
+#define MC13892_IC_ID_LSH		    13
+
+#define MC13892_GENERATION_ID_WID	3
+#define MC13892_IC_ID_WID		    6
+
+#define MC13892_GEN_ID_VALUE	    0x7
+#define MC13892_IC_ID_VALUE		    1
+
+/*
+ * Global variables
+ */
+extern pmic_version_t mxc_pmic_version;
+extern irqreturn_t pmic_irq_handler(int irq, void *dev_id);
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+static struct platform_device rleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'r',
+};
+static struct platform_device gleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'g',
+};
+static struct platform_device bleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'b',
+};
+static struct platform_device pwm1_ldm = {
+	.name = "pmic_pwm",
+	.id = 0,
+};
+static struct platform_device pwm2_ldm = {
+	.name = "pmic_pwm",
+	.id = 1,
+};
+
+enum pmic_id {
+#if defined(CONFIG_MXC_PMIC_MC13892) || defined(CONFIG_MXC_PMIC_MC13892_MODULE)
+	PMIC_ID_MC13892,
+#endif
+#if defined(CONFIG_MXC_PMIC_MC34708) || defined(CONFIG_MXC_PMIC_MC34708_MODULE)
+	PMIC_ID_MC34708,
+#endif
+	PMIC_ID_INVALID,
+};
+
+static struct pmic_internal pmic_internal[] = {
+#if defined(CONFIG_MXC_PMIC_MC13892) || defined(CONFIG_MXC_PMIC_MC13892_MODULE)
+	[PMIC_ID_MC13892] = _PMIC_INTERNAL_INITIALIZER(mc13892),
+#endif
+#if defined(CONFIG_MXC_PMIC_MC34708) || defined(CONFIG_MXC_PMIC_MC34708_MODULE)
+	[PMIC_ID_MC34708] = _PMIC_INTERNAL_INITIALIZER(mc34708),
+#endif
+};
+
+static int get_index_pmic_internal(const char *name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pmic_internal); i++)
+		if (!strcmp(name, pmic_internal[i].name))
+			return i;
+
+	return PMIC_ID_INVALID;
+}
+
+static const char *get_client_device_name(const char *name, const char *format)
+{
+	char buf[30];
+	const char *client_devname;
+
+	if (snprintf(buf, sizeof(buf), format, name) > sizeof(buf))
+		return NULL;
+
+	client_devname = kmemdup(buf, strlen(buf) + 1, GFP_KERNEL);
+	if (!client_devname)
+		return NULL;
+
+	return client_devname;
+}
+
+static const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
+						const struct i2c_client *client)
+{
+	while (id->name[0]) {
+		if (strcmp(client->name, id->name) == 0)
+			return id;
+		id++;
+	}
+	return NULL;
+}
+
+static const struct i2c_device_id *i2c_get_device_id(
+		const struct i2c_client *idev)
+{
+	const struct i2c_driver *idrv = to_i2c_driver(idev->dev.driver);
+
+	return i2c_match_id(idrv->id_table, idev);
+}
+
+static const char *get_chipname(struct i2c_client *idev)
+{
+	const struct i2c_device_id *devid =
+		i2c_get_device_id(idev);
+
+	if (!devid)
+		return NULL;
+
+	return devid->name;
+}
+
+static void pmic_pdev_register(struct device *dev)
+{
+	platform_device_register(&adc_ldm);
+
+	if (!cpu_is_mx53())
+		platform_device_register(&battery_ldm);
+
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+	platform_device_register(&rleds_ldm);
+	platform_device_register(&gleds_ldm);
+	platform_device_register(&bleds_ldm);
+	platform_device_register(&pwm1_ldm);
+	platform_device_register(&pwm2_ldm);
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+	platform_device_unregister(&pwm1_ldm);
+	platform_device_unregister(&pwm2_ldm);
+}
+
+static int __devinit is_chip_onboard(struct i2c_client *client)
+{
+	unsigned int ret = 0;
+
+	/*bind the right device to the driver */
+	if (pmic_i2c_24bit_read(client, REG_IDENTIFICATION, &ret) == -1)
+		return -1;
+
+	return 0;
+}
+
+static ssize_t pmic_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	int i, value;
+	int offset = (REG_TEST4 + 1) / 4;
+
+	for (i = 0; i < offset; i++) {
+		pmic_read(i, &value);
+		pr_info("reg%02d: %06x\t\t", i, value);
+		pmic_read(i + offset, &value);
+		pr_info("reg%02d: %06x\t\t", i + offset, value);
+		pmic_read(i + offset * 2, &value);
+		pr_info("reg%02d: %06x\t\t", i + offset * 2, value);
+		pmic_read(i + offset * 3, &value);
+		pr_info("reg%02d: %06x\n", i + offset * 3, value);
+	}
+
+	return 0;
+}
+
+static ssize_t pmic_store(struct device *dev,
+			     struct device_attribute *attr, const char *buf,
+			     size_t count)
+{
+	int reg, value, ret;
+	char *p;
+
+	reg = simple_strtoul(buf, NULL, 10);
+
+	p = NULL;
+	p = memchr(buf, ' ', count);
+
+	if (p == NULL) {
+		pmic_read(reg, &value);
+		pr_debug("reg%02d: %06x\n", reg, value);
+		return count;
+	}
+
+	p += 1;
+
+	value = simple_strtoul(p, NULL, 16);
+
+	ret = pmic_write(reg, value);
+	if (ret == 0)
+		pr_debug("write reg%02d: %06x\n", reg, value);
+	else
+		pr_debug("register update failed\n");
+
+	return count;
+}
+
+static struct device_attribute pmic_dev_attr = {
+	.attr = {
+		 .name = "pmic_ctl",
+		 .mode = S_IRUSR | S_IWUSR,
+		 },
+	.show = pmic_show,
+	.store = pmic_store,
+};
+
+static int __devinit pmic_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	int ret = 0;
+	int pmic_irq;
+	struct pmic_platform_data *plat_data = client->dev.platform_data;
+	const char *name;
+	int pmic_index;
+
+	ret = is_chip_onboard(client);
+	if (ret == -1)
+		return -ENODEV;
+
+	name = get_chipname(client);
+	if (!name)
+		return PMIC_ERROR;
+	pmic_index = get_index_pmic_internal(name);
+	if (pmic_index == PMIC_ID_INVALID)
+		return PMIC_ERROR;
+
+	adc_ldm.name = get_client_device_name(name, "%s_adc");
+	battery_ldm.name = get_client_device_name(name, "%s_battery");
+	light_ldm.name = get_client_device_name(name, "%s_light");
+	rtc_ldm.name = get_client_device_name(name, "%s_rtc");
+	pwm1_ldm.name = get_client_device_name(name, "%s_pwm");
+	pwm2_ldm.name = get_client_device_name(name, "%s_pwm");
+
+	i2c_set_clientdata(client,
+		pmic_internal[pmic_index].pmic_alloc_data(&client->dev));
+
+	/* so far, we got matched chip on board */
+
+	pmic_i2c_setup(client);
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	/* gpio_pmic_active(); */
+
+	/* Get the PMIC Version */
+	pmic_internal[pmic_index].pmic_get_revision(&mxc_pmic_version);
+	if (mxc_pmic_version.revision < 0) {
+		dev_err((struct device *)client,
+			"PMIC not detected!!! Access Failed\n");
+		return -ENODEV;
+	} else {
+		dev_dbg((struct device *)client,
+			"Detected pmic core IC version number is %d\n",
+			mxc_pmic_version.revision);
+	}
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_internal[pmic_index].pmic_init_registers();
+	if (ret != PMIC_SUCCESS)
+		return PMIC_ERROR;
+
+	pmic_irq = (int)(client->irq);
+	if (pmic_irq == 0)
+		return PMIC_ERROR;
+
+	ret = pmic_start_event_thread(pmic_irq);
+	if (ret) {
+		pr_err("pmic driver init: \
+			fail to start event thread\n");
+		return PMIC_ERROR;
+	}
+
+	/* Set and install PMIC IRQ handler */
+
+	irq_set_irq_type(pmic_irq, IRQF_TRIGGER_HIGH);
+
+	ret =
+	    request_irq(pmic_irq, pmic_irq_handler, 0, "PMIC_IRQ",
+			0);
+
+	if (ret) {
+		dev_err(&client->dev, "request irq %d error!\n", pmic_irq);
+		return ret;
+	}
+	enable_irq_wake(pmic_irq);
+
+	if (plat_data && plat_data->init) {
+		ret = plat_data->init(i2c_get_clientdata(client));
+		if (ret != 0)
+			return PMIC_ERROR;
+	}
+
+	ret = device_create_file(&client->dev, &pmic_dev_attr);
+	if (ret)
+		dev_err(&client->dev, "create device file failed!\n");
+
+	pmic_pdev_register(&client->dev);
+
+	dev_info(&client->dev, "Loaded\n");
+
+	return PMIC_SUCCESS;
+}
+
+static int pmic_remove(struct i2c_client *client)
+{
+	int pmic_irq = (int)(client->irq);
+
+	pmic_stop_event_thread();
+	free_irq(pmic_irq, 0);
+	pmic_pdev_unregister();
+	return 0;
+}
+
+static int pmic_suspend(struct i2c_client *client, pm_message_t state)
+{
+	return 0;
+}
+
+static int pmic_resume(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct i2c_device_id pmic_id[] = {
+	{"mc13892", 0},
+	{"mc34708", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, pmic_id);
+
+static struct i2c_driver pmic_driver = {
+	.driver = {
+		   .name = "pmic",
+		   .bus = NULL,
+		   },
+	.probe = pmic_probe,
+	.remove = pmic_remove,
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+	.id_table = pmic_id,
+};
+
+static int __init pmic_init(void)
+{
+	return i2c_add_driver(&pmic_driver);
+}
+
+static void __exit pmic_exit(void)
+{
+	i2c_del_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall_sync(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic_core_spi.c b/drivers/mxc/pmic/core/pmic_core_spi.c
new file mode 100644
index 0000000..fcb2c0a
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_core_spi.c
@@ -0,0 +1,399 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*!
+ * @file pmic_core_spi.c
+ * @brief This is the main file for the PMIC Core/Protocol driver. SPI
+ * should be providing the interface between the PMIC and the MCU.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/spi/spi.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include <asm/uaccess.h>
+
+#include <linux/mfd/mc13892/core.h>
+#include <linux/mfd/mc34708/core.h>
+
+#include "pmic.h"
+
+/*
+ * Static functions
+ */
+static void pmic_pdev_register(void);
+static void pmic_pdev_unregister(void);
+
+/*
+ * Platform device structure for PMIC client drivers
+ */
+static struct platform_device adc_ldm = {
+	.name = "pmic_adc",
+	.id = 1,
+};
+static struct platform_device battery_ldm = {
+	.name = "pmic_battery",
+	.id = 1,
+};
+static struct platform_device power_ldm = {
+	.name = "pmic_power",
+	.id = 1,
+};
+static struct platform_device rtc_ldm = {
+	.name = "pmic_rtc",
+	.id = 1,
+};
+static struct platform_device light_ldm = {
+	.name = "pmic_light",
+	.id = 1,
+};
+static struct platform_device rleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'r',
+};
+static struct platform_device gleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'g',
+};
+static struct platform_device bleds_ldm = {
+	.name = "pmic_leds",
+	.id = 'b',
+};
+static struct platform_device pwm1_ldm = {
+	.name = "pmic_pwm",
+	.id = 0,
+};
+static struct platform_device pwm2_ldm = {
+	.name = "pmic_pwm",
+	.id = 1,
+};
+
+enum pmic_id {
+	PMIC_ID_MC13892,
+	PMIC_ID_MC34708,
+	PMIC_ID_INVALID,
+};
+
+struct pmic_internal pmic_internal[] = {
+	[PMIC_ID_MC13892] = _PMIC_INTERNAL_INITIALIZER(mc13892),
+	[PMIC_ID_MC34708] = _PMIC_INTERNAL_INITIALIZER(mc34708),
+};
+
+/*
+ * External functions
+ */
+extern void pmic_event_list_init(void);
+extern void pmic_event_callback(type_event event);
+extern void gpio_pmic_active(void);
+extern irqreturn_t pmic_irq_handler(int irq, void *dev_id);
+extern pmic_version_t mxc_pmic_version;
+
+static int get_index_pmic_internal(const char *name)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pmic_internal); i++)
+		if (!strcmp(name, pmic_internal[i].name))
+			return i;
+
+	return PMIC_ID_INVALID;
+}
+
+static const char *get_client_device_name(const char *name, const char *format)
+{
+	char buf[30];
+	const char *client_devname;
+
+	if (snprintf(buf, sizeof(buf), format, name) > sizeof(buf))
+		return NULL;
+
+	client_devname = kmemdup(buf, strlen(buf) + 1, GFP_KERNEL);
+	if (!client_devname)
+		return NULL;
+
+	return client_devname;
+}
+
+static const char *get_chipname(struct spi_device *spidev)
+{
+	const struct spi_device_id *devid =
+		spi_get_device_id(spidev);
+
+	if (!devid)
+		return NULL;
+
+	return devid->name;
+}
+
+/*!
+ * This function registers platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_register(void)
+{
+	platform_device_register(&adc_ldm);
+	platform_device_register(&battery_ldm);
+	platform_device_register(&rtc_ldm);
+	platform_device_register(&power_ldm);
+	platform_device_register(&light_ldm);
+	platform_device_register(&rleds_ldm);
+	platform_device_register(&gleds_ldm);
+	platform_device_register(&bleds_ldm);
+	platform_device_register(&pwm1_ldm);
+	platform_device_register(&pwm2_ldm);
+}
+
+/*!
+ * This function unregisters platform device structures for
+ * PMIC client drivers.
+ */
+static void pmic_pdev_unregister(void)
+{
+	platform_device_unregister(&adc_ldm);
+	platform_device_unregister(&battery_ldm);
+	platform_device_unregister(&rtc_ldm);
+	platform_device_unregister(&power_ldm);
+	platform_device_unregister(&light_ldm);
+	platform_device_unregister(&pwm1_ldm);
+	platform_device_unregister(&pwm2_ldm);
+}
+
+/*!
+ * This function puts the SPI slave device in low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ * @param	message	the power state to enter
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_suspend(struct spi_device *spi, pm_message_t message)
+{
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function brings the SPI slave device back from low-power mode/state.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int pmic_resume(struct spi_device *spi)
+{
+	return PMIC_SUCCESS;
+}
+
+static struct spi_driver pmic_driver;
+
+/*!
+ * This function is called whenever the SPI slave device is detected.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devinit pmic_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	struct pmic_platform_data *plat_data = spi->dev.platform_data;
+	const char *name;
+	int pmic_index;
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_spi_setup(spi);
+	if (ret != PMIC_SUCCESS) {
+		return PMIC_ERROR;
+	}
+
+	name = get_chipname(spi);
+	if (!name)
+		return PMIC_ERROR;
+	pmic_index = get_index_pmic_internal(name);
+	if (pmic_index == PMIC_ID_INVALID)
+		return PMIC_ERROR;
+
+	adc_ldm.name = get_client_device_name(name, "%s_adc");
+	battery_ldm.name = get_client_device_name(name, "%s_battery");
+	light_ldm.name = get_client_device_name(name, "%s_light");
+	rtc_ldm.name = get_client_device_name(name, "%s_rtc");
+	pwm1_ldm.name = get_client_device_name(name, "%s_pwm");
+	pwm2_ldm.name = get_client_device_name(name, "%s_pwm");
+
+	/* Initialize the PMIC event handling */
+	pmic_event_list_init();
+
+	/* Initialize GPIO for PMIC Interrupt */
+	gpio_pmic_active();
+
+	/* Get the PMIC Version */
+	pmic_internal[pmic_index].pmic_get_revision(&mxc_pmic_version);
+	if (mxc_pmic_version.revision < 0) {
+		dev_err((struct device *)spi,
+			"PMIC not detected!!! Access Failed\n");
+		return -ENODEV;
+	} else {
+		dev_dbg((struct device *)spi,
+			"Detected pmic core IC version number is %d\n",
+			mxc_pmic_version.revision);
+	}
+
+	spi_set_drvdata(spi,
+			pmic_internal[pmic_index].pmic_alloc_data(&(spi->dev)));
+
+	/* Initialize the PMIC parameters */
+	ret = pmic_internal[pmic_index].pmic_init_registers();
+	if (ret != PMIC_SUCCESS) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_start_event_thread(spi->irq);
+	if (ret) {
+		pr_err("pmic driver init: \
+			fail to start event thread\n");
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		return PMIC_ERROR;
+	}
+
+	/* Set and install PMIC IRQ handler */
+	set_irq_type(spi->irq, IRQF_TRIGGER_HIGH);
+	ret = request_irq(spi->irq, pmic_irq_handler, 0, "PMIC_IRQ", 0);
+	if (ret) {
+		kfree(spi_get_drvdata(spi));
+		spi_set_drvdata(spi, NULL);
+		dev_err((struct device *)spi, "gpio1: irq%d error.", spi->irq);
+		return ret;
+	}
+
+	enable_irq_wake(spi->irq);
+
+	if (plat_data && plat_data->init) {
+		ret = plat_data->init(spi_get_drvdata(spi));
+		if (ret != 0) {
+			kfree(spi_get_drvdata(spi));
+			spi_set_drvdata(spi, NULL);
+			return PMIC_ERROR;
+		}
+	}
+
+	power_ldm.dev.platform_data = spi->dev.platform_data;
+
+	pmic_pdev_register();
+
+	printk(KERN_INFO "Device %s probed\n", dev_name(&spi->dev));
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is called whenever the SPI slave device is removed.
+ *
+ * @param	spi	the SPI slave device
+ *
+ * @return 	Returns 0 on SUCCESS and error on FAILURE.
+ */
+static int __devexit pmic_remove(struct spi_device *spi)
+{
+	pmic_stop_event_thread();
+	free_irq(spi->irq, 0);
+
+	pmic_pdev_unregister();
+
+	printk(KERN_INFO "Device %s removed\n", dev_name(&spi->dev));
+
+	return PMIC_SUCCESS;
+}
+
+static const struct spi_device_id pmic_device_id[] = {
+	{
+		.name = "mc13892",
+	}, {
+		.name = "mc34708",
+	}, {
+		/* sentinel */
+	}
+};
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct spi_driver pmic_driver = {
+	.id_table = pmic_device_id,
+	.driver = {
+		   .name = "pmic_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = pmic_probe,
+	.remove = __devexit_p(pmic_remove),
+	.suspend = pmic_suspend,
+	.resume = pmic_resume,
+};
+
+/*
+ * Initialization and Exit
+ */
+
+/*!
+ * This function implements the init function of the PMIC device.
+ * This function is called when the module is loaded. It registers
+ * the PMIC Protocol driver.
+ *
+ * @return       This function returns 0.
+ */
+static int __init pmic_init(void)
+{
+	return spi_register_driver(&pmic_driver);
+}
+
+/*!
+ * This function implements the exit function of the PMIC device.
+ * This function is called when the module is unloaded. It unregisters
+ * the PMIC Protocol driver.
+ *
+ */
+static void __exit pmic_exit(void)
+{
+	pr_debug("Unregistering the PMIC Protocol Driver\n");
+	spi_unregister_driver(&pmic_driver);
+}
+
+/*
+ * Module entry points
+ */
+subsys_initcall_sync(pmic_init);
+module_exit(pmic_exit);
+
+MODULE_DESCRIPTION("Core/Protocol driver for PMIC");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mxc/pmic/core/pmic_event.c b/drivers/mxc/pmic/core/pmic_event.c
new file mode 100644
index 0000000..c8ffc63
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_event.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file pmic_event.c
+ * @brief This file manage all event of PMIC component.
+ *
+ * It contains event subscription, unsubscription and callback
+ * launch methods implemeted.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+#include "pmic.h"
+
+/*!
+ * This structure is used to keep a list of subscribed
+ * callbacks for an event.
+ */
+typedef struct {
+	/*!
+	 * Keeps a list of subscribed clients to an event.
+	 */
+	struct list_head list;
+
+	/*!
+	 * Callback function with parameter, called when event occurs
+	 */
+	pmic_event_callback_t callback;
+} pmic_event_callback_list_t;
+
+/* Create a mutex to be used to prevent concurrent access to the event list */
+static DEFINE_MUTEX(event_mutex);
+
+/* This is a pointer to the event handler array. It defines the currently
+ * active set of events and user-defined callback functions.
+ */
+static struct list_head pmic_events[PMIC_MAX_EVENTS];
+
+/*!
+ * This function initializes event list for PMIC event handling.
+ *
+ */
+void pmic_event_list_init(void)
+{
+	int i;
+
+	for (i = 0; i < PMIC_MAX_EVENTS; i++) {
+		INIT_LIST_HEAD(&pmic_events[i]);
+	}
+
+	mutex_init(&event_mutex);
+	return;
+}
+
+/*!
+ * This function is used to subscribe on an event.
+ *
+ * @param	event   the event number to be subscribed
+ * @param	callback the callback funtion to be subscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback)
+{
+	pmic_event_callback_list_t *new = NULL;
+
+	pr_debug("Event:%d Subscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Create a new linked list entry */
+	new = kmalloc(sizeof(pmic_event_callback_list_t), GFP_KERNEL);
+	if (NULL == new) {
+		return -ENOMEM;
+	}
+	/* Initialize the list node fields */
+	new->callback.func = callback.func;
+	new->callback.param = callback.param;
+	INIT_LIST_HEAD(&new->list);
+
+	/* Obtain the lock to access the list */
+	if (mutex_lock_interruptible(&event_mutex)) {
+		kfree(new);
+		return PMIC_SYSTEM_ERROR_EINTR;
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_unmask(event) != PMIC_SUCCESS) {
+			kfree(new);
+			mutex_unlock(&event_mutex);
+			return PMIC_ERROR;
+		}
+	}
+
+	/* Add this entry to the event list */
+	list_add_tail(&new->list, &pmic_events[event]);
+
+	/* Release the lock */
+	mutex_unlock(&event_mutex);
+
+	return PMIC_SUCCESS;
+}
+
+/*!
+ * This function is used to unsubscribe on an event.
+ *
+ * @param	event   the event number to be unsubscribed
+ * @param	callback the callback funtion to be unsubscribed
+ *
+ * @return       This function returns 0 on SUCCESS, error on FAILURE.
+ */
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback)
+{
+	struct list_head *p;
+	struct list_head *n;
+	pmic_event_callback_list_t *temp = NULL;
+	int ret = PMIC_EVENT_NOT_SUBSCRIBED;
+
+	pr_debug("Event:%d Unsubscribe\n", event);
+
+	/* Check whether the event & callback are valid? */
+	if (event >= PMIC_MAX_EVENTS) {
+		pr_debug("Invalid Event:%d\n", event);
+		return -EINVAL;
+	}
+
+	if (NULL == callback.func) {
+		pr_debug("Null or Invalid Callback\n");
+		return -EINVAL;
+	}
+
+	/* Obtain the lock to access the list */
+	if (mutex_lock_interruptible(&event_mutex)) {
+		return PMIC_SYSTEM_ERROR_EINTR;
+	}
+
+	/* Find the entry in the list */
+	list_for_each_safe(p, n, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		if (temp->callback.func == callback.func
+		    && temp->callback.param == callback.param) {
+			/* Remove the entry from the list */
+			list_del(p);
+			kfree(temp);
+			ret = PMIC_SUCCESS;
+			break;
+		}
+	}
+
+	/* Unmask the requested event */
+	if (list_empty(&pmic_events[event])) {
+		if (pmic_event_mask(event) != PMIC_SUCCESS) {
+			ret = PMIC_UNSUBSCRIBE_ERROR;
+		}
+	}
+
+	/* Release the lock */
+	mutex_unlock(&event_mutex);
+
+	return ret;
+}
+
+/*!
+ * This function calls all callback of a specific event.
+ *
+ * @param	event   the active event number
+ *
+ * @return 	None
+ */
+void pmic_event_callback(type_event event)
+{
+	struct list_head *p;
+	pmic_event_callback_list_t *temp = NULL;
+
+	/* Obtain the lock to access the list */
+	if (mutex_lock_interruptible(&event_mutex)) {
+		return;
+	}
+
+	if (list_empty(&pmic_events[event])) {
+		pr_debug("PMIC Event:%d detected. No callback subscribed\n",
+			 event);
+		mutex_unlock(&event_mutex);
+		return;
+	}
+
+	list_for_each(p, &pmic_events[event]) {
+		temp = list_entry(p, pmic_event_callback_list_t, list);
+		temp->callback.func(temp->callback.param);
+	}
+
+	/* Release the lock */
+	mutex_unlock(&event_mutex);
+
+	return;
+
+}
+
+EXPORT_SYMBOL(pmic_event_subscribe);
+EXPORT_SYMBOL(pmic_event_unsubscribe);
diff --git a/drivers/mxc/pmic/core/pmic_external.c b/drivers/mxc/pmic/core/pmic_external.c
new file mode 100644
index 0000000..63cc177
--- /dev/null
+++ b/drivers/mxc/pmic/core/pmic_external.c
@@ -0,0 +1,338 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*!
+ * @file pmic_external.c
+ * @brief This file contains all external functions of PMIC drivers.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*
+ * Includes
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+
+#include <linux/pmic_external.h>
+#include <linux/pmic_status.h>
+
+#include "pmic.h"
+
+#define MXC_PMIC_FRAME_MASK		0x00FFFFFF
+#define MXC_PMIC_MAX_REG_NUM		0x3F
+#define MXC_PMIC_REG_NUM_SHIFT		0x19
+#define MXC_PMIC_WRITE_BIT_SHIFT	31
+
+#define PMIC_I2C_RETRY_TIMES		10
+
+static struct mxc_pmic pmic_drv_data;
+static unsigned int events_enabled0;
+static unsigned int events_enabled1;
+
+#ifdef CONFIG_MXC_PMIC_MC34704
+extern int pmic_read(int reg_num, unsigned int *reg_val);
+extern int pmic_write(int reg_num, const unsigned int reg_val);
+#else
+int pmic_spi_setup(struct spi_device *spi)
+{
+	/* Setup the SPI slave i.e.PMIC */
+	pmic_drv_data.spi = spi;
+
+	spi->mode = SPI_MODE_0 | SPI_CS_HIGH;
+	spi->bits_per_word = 32;
+#ifdef CONFIG_SPI
+	return spi_setup(spi);
+#endif
+}
+
+int pmic_i2c_setup(struct i2c_client *i2c)
+{
+	pmic_drv_data.i2c = i2c;
+
+	return 0;
+}
+
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value)
+{
+	unsigned char buf[3];
+	int ret;
+	int i;
+
+	memset(buf, 0, 3);
+	for (i = 0; i < PMIC_I2C_RETRY_TIMES; i++) {
+		ret = i2c_smbus_read_i2c_block_data(client, reg_num, 3, buf);
+		if (ret == 3)
+			break;
+		msleep(1);
+	}
+
+	if (ret == 3) {
+		*value = buf[0] << 16 | buf[1] << 8 | buf[2];
+		return ret;
+	} else {
+		pr_err("24bit read error, ret = %d\n", ret);
+		return -1;	/* return -1 on failure */
+	}
+}
+
+int pmic_i2c_24bit_write(struct i2c_client *client,
+			 unsigned int reg_num, unsigned int reg_val)
+{
+	char buf[3];
+	int ret;
+	int i;
+
+	buf[0] = (reg_val >> 16) & 0xff;
+	buf[1] = (reg_val >> 8) & 0xff;
+	buf[2] = (reg_val) & 0xff;
+
+	for (i = 0; i < PMIC_I2C_RETRY_TIMES; i++) {
+		ret = i2c_smbus_write_i2c_block_data(client, reg_num, 3, buf);
+		if (ret == 0)
+			break;
+		msleep(1);
+	}
+	if (i == PMIC_I2C_RETRY_TIMES)
+		pr_err("24bit write error, ret = %d\n", ret);
+
+	return ret;
+}
+
+int pmic_read(int reg_num, unsigned int *reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (pmic_drv_data.spi != NULL) {
+		if (reg_num > MXC_PMIC_MAX_REG_NUM)
+			return PMIC_ERROR;
+
+		frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+		ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+		*reg_val = frame & MXC_PMIC_FRAME_MASK;
+	} else {
+		if (pmic_drv_data.i2c == NULL)
+			return PMIC_ERROR;
+
+		if (pmic_i2c_24bit_read(pmic_drv_data.i2c, reg_num, reg_val)
+			== -1)
+			return PMIC_ERROR;
+	}
+
+	return PMIC_SUCCESS;
+}
+
+int pmic_write(int reg_num, const unsigned int reg_val)
+{
+	unsigned int frame = 0;
+	int ret = 0;
+
+	if (pmic_drv_data.spi != NULL) {
+		if (reg_num > MXC_PMIC_MAX_REG_NUM)
+			return PMIC_ERROR;
+
+		frame |= (1 << MXC_PMIC_WRITE_BIT_SHIFT);
+
+		frame |= reg_num << MXC_PMIC_REG_NUM_SHIFT;
+
+		frame |= reg_val & MXC_PMIC_FRAME_MASK;
+
+		ret = spi_rw(pmic_drv_data.spi, (u8 *) &frame, 1);
+
+		return ret;
+	} else {
+		if (pmic_drv_data.i2c == NULL)
+			return PMIC_ERROR;
+
+		return pmic_i2c_24bit_write(pmic_drv_data.i2c,
+			reg_num, reg_val);
+	}
+}
+#endif
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  return value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS) {
+		return PMIC_ERROR;
+	}
+	*reg_value = (temp & reg_mask);
+
+	pr_debug("Read REG[ %d ] = 0x%x\n", reg, *reg_value);
+
+	return ret;
+}
+
+/*!
+ * This function is called by PMIC clients to write a register on PMIC.
+ *
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask)
+{
+	int ret = 0;
+	unsigned int temp = 0;
+
+	ret = pmic_read(reg, &temp);
+	if (ret != PMIC_SUCCESS) {
+		return PMIC_ERROR;
+	}
+	temp = (temp & (~reg_mask)) | reg_value;
+#ifdef CONFIG_MXC_PMIC_MC13783
+	if (reg == REG_POWER_MISCELLANEOUS)
+		temp &= 0xFFFE7FFF;
+#endif
+	ret = pmic_write(reg, temp);
+	if (ret != PMIC_SUCCESS) {
+		return PMIC_ERROR;
+	}
+
+	pr_debug("Write REG[ %d ] = 0x%x\n", reg, reg_value);
+
+	return ret;
+}
+
+#ifndef CONFIG_MXC_PMIC_MC34704
+unsigned int pmic_get_active_events(unsigned int *active_events)
+{
+	unsigned int count = 0;
+	unsigned int status0, status1;
+	int bit_set;
+
+	pmic_read(REG_INT_STATUS0, &status0);
+	pmic_read(REG_INT_STATUS1, &status1);
+	pmic_write(REG_INT_STATUS0, status0);
+	pmic_write(REG_INT_STATUS1, status1);
+	status0 &= events_enabled0;
+	status1 &= events_enabled1;
+
+	while (status0) {
+		bit_set = ffs(status0) - 1;
+		*(active_events + count) = bit_set;
+		count++;
+		status0 ^= (1 << bit_set);
+	}
+	while (status1) {
+		bit_set = ffs(status1) - 1;
+		*(active_events + count) = bit_set + 24;
+		count++;
+		status1 ^= (1 << bit_set);
+	}
+
+	return count;
+}
+EXPORT_SYMBOL(pmic_get_active_events);
+
+#define EVENT_MASK_0			0x387fff
+#define EVENT_MASK_1			0x1177ef
+
+int pmic_event_unmask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 |= event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 |= event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: unmasking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, 0, event_bit);
+
+	pr_debug("Enable Event : %d\n", event);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_event_unmask);
+
+int pmic_event_mask(type_event event)
+{
+	unsigned int event_mask = 0;
+	unsigned int mask_reg = 0;
+	unsigned int event_bit = 0;
+	int ret;
+
+	if (event < EVENT_1HZI) {
+		mask_reg = REG_INT_MASK0;
+		event_mask = EVENT_MASK_0;
+		event_bit = (1 << event);
+		events_enabled0 &= ~event_bit;
+	} else {
+		event -= 24;
+		mask_reg = REG_INT_MASK1;
+		event_mask = EVENT_MASK_1;
+		event_bit = (1 << event);
+		events_enabled1 &= ~event_bit;
+	}
+
+	if ((event_bit & event_mask) == 0) {
+		pr_debug("Error: masking a reserved/unused event\n");
+		return PMIC_ERROR;
+	}
+
+	ret = pmic_write_reg(mask_reg, event_bit, event_bit);
+
+	pr_debug("Disable Event : %d\n", event);
+
+	return ret;
+}
+EXPORT_SYMBOL(pmic_event_mask);
+#endif
+
+EXPORT_SYMBOL(pmic_read_reg);
+EXPORT_SYMBOL(pmic_write_reg);
diff --git a/include/linux/mfd/mc34708/core.h b/include/linux/mfd/mc34708/core.h
new file mode 100644
index 0000000..9da55b6
--- /dev/null
+++ b/include/linux/mfd/mc34708/core.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __LINUX_MFD_MC34708_CORE_H_
+#define __LINUX_MFD_MC34708_CORE_H_
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/pmic_external.h>
+/*!
+ * brief PMIC regulators.
+ */
+#define MC34708_SW1A		0
+#define MC34708_SW1B		1
+#define MC34708_SW2		2
+#define MC34708_SW3		3
+#define MC34708_SW4A		4
+#define MC34708_SW4B		5
+#define MC34708_SW5		6
+#define MC34708_SWBST		7
+#define MC34708_VPLL		8
+#define MC34708_VREFDDR		9
+#define MC34708_VUSB		10
+#define MC34708_VUSB2		11
+#define MC34708_VDAC		12
+#define MC34708_VGEN1		13
+#define MC34708_VGEN2		14
+#define MC34708_REG_NUM		15
+
+struct mc34708;
+struct regulator_init_data;
+
+struct mc34708_platform_data {
+	int (*init)(struct mc34708 *);
+	void *(*pmic_alloc_data)(struct device *dev);
+	int (*pmic_init_registers)(void);
+	void (*pmic_get_revision)(pmic_version_t *ver);
+};
+
+struct mc34708_pmic {
+	/* regulator devices */
+	struct platform_device *pdev[MC34708_REG_NUM];
+};
+
+struct mc34708 {
+	int rev;		/* chip revision */
+
+	struct device *dev;
+
+	/* device IO */
+	union {
+		struct i2c_client *i2c_client;
+		struct spi_device *spi_device;
+	};
+	u16 *reg_cache;
+
+	/* Client devices */
+	struct mc34708_pmic pmic;
+};
+
+int mc34708_register_regulator(struct mc34708 *mc34708, int reg,
+			       struct regulator_init_data *initdata);
+void *mc34708_alloc_data(struct device *dev);
+int mc34708_init_registers(void);
+void mc34708_get_revision(pmic_version_t *ver);
+
+#endif
diff --git a/include/linux/mfd/mc34708/mc34708.h b/include/linux/mfd/mc34708/mc34708.h
new file mode 100644
index 0000000..cf56bfe
--- /dev/null
+++ b/include/linux/mfd/mc34708/mc34708.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_MC34708_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_MC34708_EXTERNAL_H__
+
+
+enum {
+	MC34708_REG_INT_STATUS0 = 0,
+	MC34708_REG_INT_MASK0,
+	MC34708_REG_INT_SENSE0,
+	MC34708_REG_INT_STATUS1,
+	MC34708_REG_INT_MASK1,
+	MC34708_REG_INT_SENSE1,
+	MC34708_REG_POWER_UP_MODE_SENSE,
+	MC34708_REG_IDENTIFICATION,
+	MC34708_REG_REGULATOR_FAULT_SENSE,
+	MC34708_REG_ACC0,
+	MC34708_REG_ACC1,
+	MC34708_REG_UNUSED0,
+	MC34708_REG_UNUSED1,
+	MC34708_REG_POWER_CTL0,
+	MC34708_REG_POWER_CTL1,
+	MC34708_REG_POWER_CTL2,
+	MC34708_REG_MEM_A,
+	MC34708_REG_MEM_B,
+	MC34708_REG_MEM_C,
+	MC34708_REG_MEM_D,
+	MC34708_REG_RTC_TIME,
+	MC34708_REG_RTC_ALARM,
+	MC34708_REG_RTC_DAY,
+	MC34708_REG_RTC_DAY_ALARM,
+	MC34708_REG_SW1AB,
+	MC34708_REG_SW2_3,
+	MC34708_REG_SW4AB,
+	MC34708_REG_SW5,
+	MC34708_REG_SW_OP_MODE_1_2,
+	MC34708_REG_SW_OP_MODE_3_4_5,
+	MC34708_REG_REGULATOR_SETTING0,
+	MC34708_REG_SWBST_CTL,
+	MC34708_REG_REGULATOR_MODE0,
+	MC34708_REG_GPIOLV0_CTL,
+	MC34708_REG_GPIOLV1_CTL,
+	MC34708_REG_GPIOLV2_CTL,
+	MC34708_REG_GPIOLV3_CTL,
+	MC34708_REG_USB_TIMING,
+	MC34708_REG_USB_BUTTON,
+	MC34708_REG_USB_CTL,
+	MC34708_REG_USB_DEVICE_TYPE,
+	MC34708_REG_UNUSED2,
+	MC34708_REG_UNUSED3,
+	MC34708_REG_ADC0,
+	MC34708_REG_ADC1,
+	MC34708_REG_ADC2,
+	MC34708_REG_ADC3,
+	MC34708_REG_ADC4,
+	MC34708_REG_ADC5,
+	MC34708_REG_ADC6,
+	MC34708_REG_ADC7,
+	MC34708_REG_BATTERY_PROFILE,
+	MC34708_REG_CHARGER_DEBOUNCE,
+	MC34708_REG_CHARGER_SOURCE,
+	MC34708_REG_CHARGER_LED_CTL,
+	MC34708_REG_PWM_CTL,
+	MC34708_REG_UNUSED4,
+	MC34708_REG_UNUSED5,
+	MC34708_REG_UNUSED6,
+	MC34708_REG_UNUSED7,
+	MC34708_REG_UNUSED8,
+	MC34708_REG_UNUSED9,
+	MC34708_REG_UNUSED10,
+	MC34708_REG_UNUSED11,
+};
+
+enum {
+	MC34708_EVENT_ADCDONEI = 0,
+	MC34708_EVENT_TSDONEI = 1,
+	MC34708_EVENT_TSPENDET = 2,
+	MC34708_EVENT_USBDET = 3,
+	MC34708_EVENT_AUXDET = 4,
+	MC34708_EVENT_USBOVP = 5,
+	MC34708_EVENT_AUXOVP = 6,
+	MC34708_EVENT_CHRTIMEEXP = 7,
+	MC34708_EVENT_BATTOTP = 8,
+	MC34708_EVENT_BATTOVP = 9,
+	MC34708_EVENT_CHRCMPL = 10,
+	MC34708_EVENT_WKVBUSDET = 11,
+	MC34708_EVENT_WKAUXDET = 12,
+	MC34708_EVENT_LOWBATT = 13,
+	MC34708_EVENT_VBUSREGMI = 14,
+	MC34708_EVENT_ATTACH = 15,
+	MC34708_EVENT_DETACH = 16,
+	MC34708_EVENT_KP = 17,
+	MC34708_EVENT_LKP = 18,
+	MC34708_EVENT_LKR = 19,
+	MC34708_EVENT_UKNOWN_ATTA = 20,
+	MC34708_EVENT_ADC_CHANGE = 21,
+	MC34708_EVENT_STUCK_KEY = 22,
+	MC34708_EVENT_STUCK_KEY_RCV = 23,
+
+	MC34708_EVENT_1HZI = 24,
+	MC34708_EVENT_TODAI = 25,
+	MC34708_EVENT_Unused1 = 26,
+	MC34708_EVENT_PWRON1I = 27,
+	MC34708_EVENT_PWRON2I = 28,
+	MC34708_EVENT_WDIRESETI = 29,
+	MC34708_EVENT_SYSRSTI = 30,
+	MC34708_EVENT_RTCRSTI = 31,
+	MC34708_EVENT_PCI = 32,
+	MC34708_EVENT_WARMI = 33,
+	MC34708_EVENT_MEMHLDI = 34,
+	MC34708_EVENT_Unused2 = 35,
+	MC34708_EVENT_THWARNLI = 36,
+	MC34708_EVENT_THWARNHI = 37,
+	MC34708_EVENT_CLKI = 38,
+	MC34708_EVENT_Unused3 = 39,
+	MC34708_EVENT_SCPI = 40,
+};
+#endif
diff --git a/include/linux/pmic_adc.h b/include/linux/pmic_adc.h
new file mode 100644
index 0000000..86d272f
--- /dev/null
+++ b/include/linux/pmic_adc.h
@@ -0,0 +1,468 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D', 4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D', 5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum {
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum {
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum {
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct {
+/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum {
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct {
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator.
+ */
+typedef struct {
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+struct pmic_adc_api {
+	int (*is_pmic_adc_ready)(void);
+	PMIC_STATUS (*pmic_adc_convert)(t_channel, unsigned short *);
+	PMIC_STATUS (*pmic_adc_get_touch_sample)(t_touch_screen *, int);
+};
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode *touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen *ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+
+int is_pmic_adc_ready(void);
+
+void register_adc_apis(struct pmic_adc_api *papi);
+
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
diff --git a/include/linux/pmic_external.h b/include/linux/pmic_external.h
new file mode 100644
index 0000000..dd6c7c1
--- /dev/null
+++ b/include/linux/pmic_external.h
@@ -0,0 +1,522 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file arch-mxc/pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <linux/ioctl.h>
+#include <linux/pmic_status.h>
+#include <linux/spi/spi.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum {
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+	PMIC_SC55112 = 2,	/*!< SC55112 */
+	PMIC_MC13892 = 3,
+	PMIC_MC34704 = 4,
+	PMIC_MC34708 = 5
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct {
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its
+ * parameter to be used when un/registering and launching a callback
+ * for an event.
+ */
+typedef struct {
+	/*!
+	 * call back function
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct {
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for sc55112 core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#define PMIC_ARBITRATION	"NULL"
+
+
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) ||	\
+	defined(CONFIG_MXC_PMIC_MC13892) ||	\
+	defined(CONFIG_MXC_PMIC_MC34708_MODULE) || \
+	defined(CONFIG_MXC_PMIC_MC34708)
+enum {
+	REG_INT_STATUS0 = 0,
+	REG_INT_MASK0,
+	REG_INT_SENSE0,
+	REG_INT_STATUS1,
+	REG_INT_MASK1,
+	REG_INT_SENSE1,
+	REG_PU_MODE_S,
+	REG_IDENTIFICATION,
+	REG_UNUSED0,
+	REG_ACC0,
+	REG_ACC1,		/*10 */
+	REG_UNUSED1,
+	REG_UNUSED2,
+	REG_POWER_CTL0,
+	REG_POWER_CTL1,
+	REG_POWER_CTL2,
+	REG_REGEN_ASSIGN,
+	REG_UNUSED3,
+	REG_MEM_A,
+	REG_MEM_B,
+	REG_RTC_TIME,		/*20 */
+	REG_RTC_ALARM,
+	REG_RTC_DAY,
+	REG_RTC_DAY_ALARM,
+	REG_SW_0,
+	REG_SW_1,
+	REG_SW_2,
+	REG_SW_3,
+	REG_SW_4,
+	REG_SW_5,
+	REG_SETTING_0,		/*30 */
+	REG_SETTING_1,
+	REG_MODE_0,
+	REG_MODE_1,
+	REG_POWER_MISC,
+	REG_UNUSED4,
+	REG_UNUSED5,
+	REG_UNUSED6,
+	REG_UNUSED7,
+	REG_UNUSED8,
+	REG_UNUSED9,		/*40 */
+	REG_UNUSED10,
+	REG_UNUSED11,
+	REG_ADC0,
+	REG_ADC1,
+	REG_ADC2,
+	REG_ADC3,
+	REG_ADC4,
+	REG_CHARGE,
+	REG_USB0,
+	REG_USB1,		/*50 */
+	REG_LED_CTL0,
+	REG_LED_CTL1,
+	REG_LED_CTL2,
+	REG_LED_CTL3,
+	REG_UNUSED12,
+	REG_UNUSED13,
+	REG_TRIM0,
+	REG_TRIM1,
+	REG_TEST0,
+	REG_TEST1,		/*60 */
+	REG_TEST2,
+	REG_TEST3,
+	REG_TEST4,
+};
+
+typedef enum {
+	EVENT_ADCDONEI = 0,
+	EVENT_ADCBISDONEI = 1,
+	EVENT_TSI = 2,
+	EVENT_VBUSVI = 3,
+	EVENT_IDFACI = 4,
+	EVENT_USBOVI = 5,
+	EVENT_CHGDETI = 6,
+	EVENT_CHGFAULTI = 7,
+	EVENT_CHGREVI = 8,
+	EVENT_CHGRSHORTI = 9,
+	EVENT_CCCVI = 10,
+	EVENT_CHGCURRI = 11,
+	EVENT_BPONI = 12,
+	EVENT_LOBATLI = 13,
+	EVENT_LOBATHI = 14,
+	EVENT_IDFLOATI = 19,
+	EVENT_IDGNDI = 20,
+	EVENT_SE1I = 21,
+	EVENT_CKDETI = 22,
+	EVENT_1HZI = 24,
+	EVENT_TODAI = 25,
+	EVENT_PWRON3I = 26,
+	EVENT_PWRONI = 27,
+	EVENT_WDIRESETI = 29,
+	EVENT_SYSRSTI = 30,
+	EVENT_RTCRSTI = 31,
+	EVENT_PCI = 32,
+	EVENT_WARMI = 33,
+	EVENT_MEMHLDI = 34,
+	EVENT_THWARNLI = 36,
+	EVENT_THWARNHI = 37,
+	EVENT_CLKI = 38,
+	EVENT_SCPI = 40,
+	EVENT_LBPI = 44,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	SENSE_VBUSVS = 3,
+	SENSE_IDFACS = 4,
+	SENSE_USBOVS = 5,
+	SENSE_CHGDETS = 6,
+	SENSE_CHGREVS = 8,
+	SENSE_CHGRSHORTS = 9,
+	SENSE_CCCVS = 10,
+	SENSE_CHGCURRS = 11,
+	SENSE_BPONS = 12,
+	SENSE_LOBATLS = 13,
+	SENSE_LOBATHS = 14,
+	SENSE_IDFLOATS = 19,
+	SENSE_IDGNDS = 20,
+	SENSE_SE1S = 21,
+	SENSE_PWRONS = 27,
+	SENSE_THWARNLS = 36,
+	SENSE_THWARNHS = 37,
+	SENSE_CLKS = 38,
+	SENSE_LBPS = 44,
+	SENSE_NB,
+} t_sensor;
+
+typedef struct {
+	bool sense_vbusvs;
+	bool sense_idfacs;
+	bool sense_usbovs;
+	bool sense_chgdets;
+	bool sense_chgrevs;
+	bool sense_chgrshorts;
+	bool sense_cccvs;
+	bool sense_chgcurrs;
+	bool sense_bpons;
+	bool sense_lobatls;
+	bool sense_lobaths;
+	bool sense_idfloats;
+	bool sense_idgnds;
+	bool sense_se1s;
+	bool sense_pwrons;
+	bool sense_thwarnls;
+	bool sense_thwarnhs;
+	bool sense_clks;
+	bool sense_lbps;
+} t_sensor_bits;
+
+extern struct i2c_client *mc13892_client;
+int pmic_i2c_24bit_read(struct i2c_client *client, unsigned int reg_num,
+			unsigned int *value);
+int pmic_read(int reg_num, unsigned int *reg_val);
+int pmic_write(int reg_num, const unsigned int reg_val);
+void gpio_pmic_active(void);
+void pmic_event_list_init(void);
+void mc13892_power_off(void);
+
+enum {
+	REG_MC34708_INT_STATUS0 = 0,
+	REG_MC34708_INT_MASK0,
+	REG_MC34708_INT_SENSE0,
+	REG_MC34708_INT_STATUS1,
+	REG_MC34708_INT_MASK1,
+	REG_MC34708_INT_SENSE1,
+	REG_MC34708_PU_MODE_S,
+	REG_MC34708_IDENTIFICATION,
+	REG_MC34708_REGU_FAULT_S,
+	REG_MC34708_ACC0,
+	REG_MC34708_ACC1,		/*10 */
+	REG_MC34708_UNUSED1,
+	REG_MC34708_UNUSED2,
+	REG_MC34708_POWER_CTL0,
+	REG_MC34708_POWER_CTL1,
+	REG_MC34708_POWER_CTL2,
+	REG_MC34708_MEM_A,
+	REG_MC34708_MEM_B,
+	REG_MC34708_MEM_C,
+	REG_MC34708_MEM_D,
+	REG_MC34708_RTC_TIME,		/*20 */
+	REG_MC34708_RTC_ALARM,
+	REG_MC34708_RTC_DAY,
+	REG_MC34708_RTC_DAY_ALARM,
+	REG_MC34708_SW_1_A_B,
+	REG_MC34708_SW_2_3,
+	REG_MC34708_SW_4_A_B,
+	REG_MC34708_SW_5,
+	REG_MC34708_SW_1_2_OP,
+	REG_MC34708_SW_3_4_5_OP,
+	REG_MC34708_SETTING_0,		/*30 */
+	REG_MC34708_SWBST,
+	REG_MC34708_MODE_0,
+	REG_MC34708_GPIOLV0,
+	REG_MC34708_GPIOLV1,
+	REG_MC34708_GPIOLV2,
+	REG_MC34708_GPIOLV3,
+	REG_MC34708_USB_TIMING,
+	REG_MC34708_USB_BUTTON,
+	REG_MC34708_USB_CONTROL,
+	REG_MC34708_USB_DEVICE_TYPE, /*40 */
+	REG_MC34708_UNUSED3,
+	REG_MC34708_UNUSED4,
+	REG_MC34708_ADC0,
+	REG_MC34708_ADC1,
+	REG_MC34708_ADC2,
+	REG_MC34708_ADC3,
+	REG_MC34708_ADC4,
+	REG_MC34708_ADC5,
+	REG_MC34708_ADC6,
+	REG_MC34708_ADC7,		/*50 */
+	REG_MC34708_BATTERY_PRO,
+	REG_MC34708_CHARGER_DEBOUNCE,
+	REG_MC34708_CHARGER_SOURCE,
+	REG_MC34708_CHARGER_LED_CON,
+	REG_MC34708_PWM_CON,
+	REG_MC34708_UNUSED5,
+	REG_MC34708_UNUSED6,
+	REG_MC34708_UNUSED7,
+	REG_MC34708_UNUSED8,
+	REG_MC34708_UNUSED9,		/*60 */
+	REG_MC34708_UNUSED10,
+	REG_MC34708_UNUSED11,
+	REG_MC34708_UNUSED12,
+};
+
+extern struct i2c_client *mc34708_client;
+void mc34708_power_off(void);
+
+#elif defined(CONFIG_MXC_PMIC_MC34704_MODULE) || defined(CONFIG_MXC_PMIC_MC34704)
+
+typedef enum {
+	/* register names for mc34704 */
+	REG_MC34704_GENERAL1 = 0x01,
+	REG_MC34704_GENERAL2 = 0x02,
+	REG_MC34704_GENERAL3 = 0x03,
+	REG_MC34704_VGSET1 = 0x04,
+	REG_MC34704_VGSET2 = 0x05,
+	REG_MC34704_REG2SET1 = 0x06,
+	REG_MC34704_REG2SET2 = 0x07,
+	REG_MC34704_REG3SET1 = 0x08,
+	REG_MC34704_REG3SET2 = 0x09,
+	REG_MC34704_REG4SET1 = 0x0A,
+	REG_MC34704_REG4SET2 = 0x0B,
+	REG_MC34704_REG5SET1 = 0x0C,
+	REG_MC34704_REG5SET2 = 0x0D,
+	REG_MC34704_REG5SET3 = 0x0E,
+	REG_MC34704_REG6SET1 = 0x0F,
+	REG_MC34704_REG6SET2 = 0x10,
+	REG_MC34704_REG6SET3 = 0x11,
+	REG_MC34704_REG7SET1 = 0x12,
+	REG_MC34704_REG7SET2 = 0x13,
+	REG_MC34704_REG7SET3 = 0x14,
+	REG_MC34704_REG8SET1 = 0x15,
+	REG_MC34704_REG8SET2 = 0x16,
+	REG_MC34704_REG8SET3 = 0x17,
+	REG_MC34704_FAULTS = 0x18,
+	REG_MC34704_I2CSET1 = 0x19,
+	REG_MC34704_REG3DAC = 0x49,
+	REG_MC34704_REG7CR0 = 0x58,
+	REG_MC34704_REG7DAC = 0x59,
+	REG_NB = 0x60,
+} pmic_reg;
+
+typedef enum {
+	/* events for mc34704 */
+	EVENT_FLT1 = 0,
+	EVENT_FLT2,
+	EVENT_FLT3,
+	EVENT_FLT4,
+	EVENT_FLT5,
+	EVENT_FLT6,
+	EVENT_FLT7,
+	EVENT_FLT8,
+	EVENT_NB,
+} type_event;
+
+typedef enum {
+	MCU_SENSOR_NOT_SUPPORT
+} t_sensor;
+
+typedef enum {
+	MCU_SENSOR_BIT_NOT_SUPPORT
+} t_sensor_bits;
+
+#else
+typedef int type_event;
+typedef int t_sensor;
+typedef int t_sensor_bits;
+
+#endif				/* MXC_PMIC_MC34704 */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+#if defined(CONFIG_MXC_PMIC)
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback);
+/*!
+* This function is called by PMIC clients to un-subscribe on an event.
+*
+* @param        event_unsub   structure of event, it contains type of event and callback
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+/*!
+* This function is called to read all sensor bits of PMIC.
+*
+* @param        sensor    Sensor to be checked.
+*
+* @return       This function returns true if the sensor bit is high;
+*               or returns false if the sensor bit is low.
+*/
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+* This function checks one sensor of PMIC.
+*
+* @param        sensor_bits  structure of all sensor bits.
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_get_sensors(t_sensor_bits *sensor_bits);
+
+void pmic_event_callback(type_event event);
+void pmic_event_list_init(void);
+
+unsigned int pmic_get_active_events(unsigned int *active_events);
+int pmic_event_mask(type_event event);
+int pmic_event_unmask(type_event event);
+int pmic_spi_setup(struct spi_device *spi);
+int pmic_i2c_setup(struct i2c_client *i2c);
+
+#endif				/*CONFIG_MXC_PMIC*/
+#endif				/* __KERNEL__ */
+/* CONFIG_MXC_PMIC_MC13783 || CONFIG_MXC_PMIC_MC9SDZ60 */
+
+struct pmic_platform_data {
+	int (*init)(void *);
+	int power_key_irq;
+};
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
diff --git a/include/linux/pmic_status.h b/include/linux/pmic_status.h
new file mode 100644
index 0000000..08a2acb
--- /dev/null
+++ b/include/linux/pmic_status.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+#ifdef __KERNEL__
+#include <asm/uaccess.h>	/* copy_{from,to}_user() */
+#endif
+/*!
+ * @file arch-mxc/pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+/*
+ * Bitfield macros that use rely on bitfield width/shift information.
+ */
+#define BITFMASK(field) (((1U << (field ## _WID)) - 1) << (field ## _LSH))
+#define BITFVAL(field, val) ((val) << (field ## _LSH))
+#define BITFEXT(var, bit) ((var & BITFMASK(bit)) >> (bit ## _LSH))
+
+/*
+ * Macros implementing error handling
+ */
+#define CHECK_ERROR(a)			\
+do {					\
+		int ret = (a); 			\
+		if (ret != PMIC_SUCCESS)	\
+	return ret; 			\
+} while (0)
+
+#define CHECK_ERROR_KFREE(func, freeptrs) \
+do { \
+	int ret = (func); \
+	if (ret != PMIC_SUCCESS) { \
+		freeptrs;	\
+		return ret;	\
+	}	\
+} while (0);
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
-- 
1.7.9.7

