From 9e616a488436e4971f1c1129136fe0e13a6b59b7 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 10 Jan 2013 10:05:45 +0800
Subject: [PATCH 09/23] fsl_imx53: add scc platform device support

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add scc platform device support, since it is existed in mx53 and
sahara depends on scc device.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/plat-mxc/devices/Kconfig               |    3 +
 arch/arm/plat-mxc/devices/Makefile              |    1 +
 arch/arm/plat-mxc/devices/platform-imx-scc.c    |  213 +++++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/devices-common.h |    7 +
 arch/arm/plat-mxc/include/mach/mxc_scc.h        |   45 +++++
 5 files changed, 269 insertions(+)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-scc.c
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_scc.h

diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index 4ca703b..a845087 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -122,3 +122,6 @@ config IMX_HAVE_PLATFORM_IMX_DVFS
 
 config IMX_HAVE_PLATFORM_IMX_PM
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_SCC
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index 978b256..2e28b05 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -43,4 +43,5 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_VPU) +=  platform-imx_vpu.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_MIPI_CSI2) += platform-imx-mipi_csi2.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_DVFS) +=  platform-imx_dvfs.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_PM) += platform-imx-pm.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SCC) += platform-imx-scc.o
 obj-y += platform-imx-pmu.o
diff --git a/arch/arm/plat-mxc/devices/platform-imx-scc.c b/arch/arm/plat-mxc/devices/platform-imx-scc.c
new file mode 100644
index 0000000..929a6db
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-scc.c
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2010-2011 Pengutronix
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <linux/platform_device.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/mxc_scc2_driver.h>
+#include <linux/delay.h>
+
+#define imx_mxc_scc_data_entry_single(soc)				\
+	{								\
+		.iobase = soc ## _SCC_BASE_ADDR,			\
+		.iobase2 = soc ## _SCC_RAM_BASE_ADDR,			\
+	}
+
+const struct imx_mxc_scc_data imx53_mxc_scc_data __initconst =
+	imx_mxc_scc_data_entry_single(MX53);
+
+static struct resource scc_resources[] = {
+	{
+		.start = MX53_SCC_BASE_ADDR,
+		.end = MX53_SCC_BASE_ADDR + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start  = MX53_SCC_RAM_BASE_ADDR,
+		.end = MX53_SCC_RAM_BASE_ADDR + SZ_16K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device mxcscc_device = {
+	.name = "mxc_scc",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(scc_resources),
+	.resource = scc_resources,
+};
+
+/* Flag used to indicate when IRAM has been initialized */
+int iram_ready;
+
+#define SCM_RD_DELAY    1000000 /* in nanoseconds */
+#define SEC_TO_NANOSEC  1000000000 /*Second to nanoseconds */
+#define SCC_RAM_SIZE	SZ_16K
+
+static int __init mxc_init_scc_iram(void)
+{
+	uint32_t reg_value;
+	uint32_t reg_mask = 0;
+	uint32_t partition_no;
+	uint32_t scc_partno;
+	void *scm_ram_base;
+	void *scc_base;
+	uint32_t ram_partitions, ram_partition_size, ram_size;
+	uint32_t scm_version_register;
+	struct timespec stime;
+	struct timespec curtime;
+	long scm_rd_timeout = 0;
+	long cur_ns = 0;
+	long start_ns = 0;
+
+	scc_base = ioremap((uint32_t) scc_resources[0].start, 0x140);
+	if (scc_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC REGS\n");
+		return -1;
+	}
+
+	scm_version_register = __raw_readl(scc_base + SCM_VERSION_REG);
+	ram_partitions = 1 + ((scm_version_register & SCM_VER_NP_MASK)
+		>> SCM_VER_NP_SHIFT);
+	ram_partition_size = (uint32_t) (1 <<
+		((scm_version_register & SCM_VER_BPP_MASK)
+		>> SCM_VER_BPP_SHIFT));
+
+	ram_size = (uint32_t)(ram_partitions * ram_partition_size);
+
+	scm_ram_base = ioremap((uint32_t) scc_resources[1].start, ram_size);
+
+	if (scm_ram_base == NULL) {
+		printk(KERN_ERR "FAILED TO MAP SCC RAM\n");
+		return -1;
+	}
+
+	/* Wait for any running SCC operations to finish or fail */
+	getnstimeofday(&stime);
+	do {
+		reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec > stime.tv_nsec)
+			scm_rd_timeout = curtime.tv_nsec - stime.tv_nsec;
+		else{
+			/*Converted second to nanosecond and add to
+			nsec when current nanosec is less than
+			start time nanosec.*/
+			cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+			curtime.tv_nsec;
+			start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+				stime.tv_nsec;
+			scm_rd_timeout = cur_ns - start_ns;
+		}
+	} while (((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+	&& ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_FAIL));
+
+	/* Check for failures */
+	if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY) {
+		/* Special message for bad secret key fuses */
+		if (reg_value & SCM_STATUS_KST_BAD_KEY)
+			printk(KERN_ERR "INVALID SCC KEY FUSE PATTERN\n");
+		else
+			printk(KERN_ERR "SECURE RAM FAILURE\n");
+
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return -1;
+	}
+
+	scm_rd_timeout = 0;
+
+	/* Release all partitions for SCC2 driver on MX53*/
+	if (cpu_is_mx53())
+		scc_partno = 0;
+	/* Release final two partitions for SCC2 driver on MX51 */
+	else
+		scc_partno = ram_partitions -
+			(SCC_RAM_SIZE / ram_partition_size);
+
+	for (partition_no = scc_partno; partition_no < ram_partitions;
+	     partition_no++) {
+		reg_value = (((partition_no << SCM_ZCMD_PART_SHIFT) &
+			SCM_ZCMD_PART_MASK) | ((0x03 << SCM_ZCMD_CCMD_SHIFT) &
+			SCM_ZCMD_CCMD_MASK));
+		__raw_writel(reg_value, scc_base + SCM_ZCMD_REG);
+		udelay(1);
+		/* Wait for zeroization to complete */
+		getnstimeofday(&stime);
+		do {
+			reg_value = __raw_readl(scc_base + SCM_STATUS_REG);
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec > stime.tv_nsec)
+				scm_rd_timeout = curtime.tv_nsec -
+				stime.tv_nsec;
+			else {
+				/*Converted second to nanosecond and add to
+				nsec when current nanosec is less than
+				start time nanosec.*/
+				cur_ns = (curtime.tv_sec * SEC_TO_NANOSEC) +
+				curtime.tv_nsec;
+				start_ns = (stime.tv_sec * SEC_TO_NANOSEC) +
+					stime.tv_nsec;
+				scm_rd_timeout = cur_ns - start_ns;
+			}
+		} while (((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_READY) && ((reg_value & SCM_STATUS_SRS_MASK) !=
+		SCM_STATUS_SRS_FAIL) && (scm_rd_timeout <= SCM_RD_DELAY));
+
+		if (scm_rd_timeout > SCM_RD_DELAY)
+			printk(KERN_ERR "SCM Status Register Read timeout for"
+					"Partition No:%d", partition_no);
+
+		if ((reg_value & SCM_STATUS_SRS_MASK) != SCM_STATUS_SRS_READY)
+			break;
+	}
+
+	/* 4 partitions on MX53 */
+	if (cpu_is_mx53())
+		reg_mask = 0xFF;
+
+	/* Check all expected partitions released */
+	reg_value = __raw_readl(scc_base + SCM_PART_OWNERS_REG);
+	if ((reg_value & reg_mask) != 0) {
+		printk(KERN_ERR "FAILED TO RELEASE IRAM PARTITION\n");
+		iounmap(scm_ram_base);
+		iounmap(scc_base);
+		return -1;
+	}
+
+	/* we are done if this is MX53, since no sharing of IRAM and SCC_RAM */
+	if (cpu_is_mx53())
+		goto exit;
+
+exit:
+	iounmap(scm_ram_base);
+	iounmap(scc_base);
+	printk(KERN_INFO "IRAM READY\n");
+	iram_ready = 1;
+
+	return 0;
+}
+postcore_initcall(mxc_init_scc_iram);
+
+struct platform_device *__init imx_add_mxc_scc(
+		const struct imx_mxc_scc_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->iobase2,
+			.end = data->iobase2 + SZ_16K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device("mxc_scc", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index 5b090b5..53b44c8 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -498,3 +498,10 @@ struct platform_device *__init imx_add_pm_imx(
 		const struct pm_platform_data *pdata);
 
 void __init imx_add_imx_armpmu(void);
+
+struct imx_mxc_scc_data {
+	resource_size_t iobase;
+	resource_size_t iobase2;
+};
+struct platform_device *__init imx_add_mxc_scc(
+		const struct imx_mxc_scc_data *data);
diff --git a/arch/arm/plat-mxc/include/mach/mxc_scc.h b/arch/arm/plat-mxc/include/mach/mxc_scc.h
new file mode 100644
index 0000000..b803d16
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_scc.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2004-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file arch-mxc/mxc_scc.h
+ *
+ * @brief This is intended to be the file which contains all of code or changes
+ * needed to port the driver.
+ *
+ * @ingroup MXCSCC
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_H__
+#define __ASM_ARCH_MXC_SCC_H__
+
+#include <mach/hardware.h>
+
+/*!
+ * Expected to come from platform header files.
+ * This symbol must be the address of the SCC
+ */
+#define SCC_BASE        SCC_BASE_ADDR
+
+/*!
+ *  This must be the interrupt line number of the SCM interrupt.
+ */
+#define INT_SCC_SCM         MXC_INT_SCC_SCM
+
+/*!
+ *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
+ *  the SMN interrupt.
+ */
+#define INT_SCC_SMN         MXC_INT_SCC_SMN
+
+#endif
-- 
1.7.9.7

