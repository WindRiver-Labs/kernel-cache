From 739ab24b7f4de90e19c935ade6793597e467a726 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Tue, 15 Jan 2013 09:58:20 +0800
Subject: [PATCH 02/23] fsl_imx53: update clocks and set related work point

Refer to vendor-drop package, L2.6.35_11.09.01_ER_source.tar.gz

Add new clocks such as pll, bus and usb clks etc, and set related
work point for mx53.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-imx/clock-mx51-mx53.c |  629 ++++++++++++++++++++++++++++++++++-
 arch/arm/mach-imx/crm-regs-imx5.h   |   12 +-
 2 files changed, 637 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-imx/clock-mx51-mx53.c b/arch/arm/mach-imx/clock-mx51-mx53.c
index 0847050..1ec63ed 100644
--- a/arch/arm/mach-imx/clock-mx51-mx53.c
+++ b/arch/arm/mach-imx/clock-mx51-mx53.c
@@ -24,6 +24,9 @@
 #include <mach/clock.h>
 
 #include "crm-regs-imx5.h"
+#include "cpu_op-mx53.h"
+
+#define SPIN_DELAY	1000000 /* in nanoseconds */
 
 /* External clock values passed-in by the board code */
 static unsigned long external_high_reference, external_low_reference;
@@ -46,9 +49,35 @@ static struct clk mipi_hsc1_clk;
 static struct clk esdhc1_clk;
 static struct clk esdhc2_clk;
 static struct clk esdhc3_mx53_clk;
+static struct clk axi_a_clk;
+static struct clk axi_b_clk;
+static struct clk emi_slow_clk;
+
+static struct clk tmax1_clk;
+static struct clk tmax3_clk;
+
+static int cpu_curr_wp;
+static struct cpu_op *cpu_wp_tbl;
+
+static void __iomem *pll1_base;
+static void __iomem *pll2_base;
+static void __iomem *pll3_base;
+static void __iomem *pll4_base;
+
+extern int cpu_op_nr;
+extern int lp_high_freq;
+extern int lp_med_freq;
 
 #define MAX_DPLL_WAIT_TRIES	1000 /* 1000 * udelay(1) = 1ms */
 
+#define MAX_AXI_A_CLK_MX53	400000000
+#define MAX_AXI_B_CLK_MX53	200000000
+#define MAX_AHB_CLK_MX53	133333333
+#define MAX_EMI_SLOW_CLK_MX53	133333333
+
+static int cpu_clk_set_wp(int wp);
+extern struct cpu_op *(*get_cpu_op)(int *op);
+
 /* calculate best pre and post dividers to get the required divider */
 static void __calc_pre_post_dividers(u32 div, u32 *pre, u32 *post,
 	u32 max_pre, u32 max_post)
@@ -89,6 +118,35 @@ static void _clk_ccgr_setclk(struct clk *clk, unsigned mode)
 	__raw_writel(reg, clk->enable_reg);
 }
 
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(clk->enable_reg);
+	reg |= MXC_CCM_CCGRx_CG_MASK << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq++;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq++;
+
+	return 0;
+}
+
+static void _clk_disable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+
+	if (clk->flags & AHB_HIGH_SET_POINT)
+		lp_high_freq--;
+	else if (clk->flags & AHB_MED_SET_POINT)
+		lp_med_freq--;
+}
+
 static int _clk_ccgr_enable(struct clk *clk)
 {
 	_clk_ccgr_setclk(clk, MXC_CCM_CCGRx_MOD_ON);
@@ -131,6 +189,25 @@ static inline u32 _get_mux(struct clk *parent, struct clk *m0,
 	return -EINVAL;
 }
 
+static inline u32 _get_mux_ddr(struct clk *parent, struct clk *m0,
+	struct clk *m1, struct clk *m2, struct clk *m3, struct clk *m4)
+{
+	if (parent == m0)
+		return 0;
+	else if (parent == m1)
+		return 1;
+	else if (parent == m2)
+		return 2;
+	else if (parent == m3)
+		return 3;
+	else if (parent == m4)
+		return 4;
+	else
+		BUG();
+
+	return 0;
+}
+
 static inline void __iomem *_mx51_get_pll_base(struct clk *pll)
 {
 	if (pll == &pll1_main_clk)
@@ -477,6 +554,81 @@ static struct clk main_bus_clk = {
 	.set_parent = _clk_main_bus_set_parent,
 };
 
+static unsigned long _clk_axi_a_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_A_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_A_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_a_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_A_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_A_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_A_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("pll _clk_axi_a_set_rate failed\n");
+	}
+	if (emi_fast_clk.usecount == 0)
+		emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_a_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_AXI_A_CLK_MX53)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+static struct clk axi_a_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_a_get_rate,
+	.set_rate = _clk_axi_a_set_rate,
+	.round_rate = _clk_axi_a_round_rate,
+};
+
 static unsigned long clk_ahb_get_rate(struct clk *clk)
 {
 	u32 reg, div;
@@ -813,6 +965,53 @@ static struct clk periph_apm_clk = {
 	.set_parent = _clk_periph_apm_set_parent,
 };
 
+static unsigned long _clk_arm_get_rate(struct clk *clk)
+{
+	u32 cacrr, div;
+
+	cacrr = __raw_readl(MXC_CCM_CACRR);
+	div = (cacrr & MXC_CCM_CACRR_ARM_PODF_MASK) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 i;
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+	if (i >= cpu_op_nr)
+		return -EINVAL;
+	cpu_clk_set_wp(i);
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 i;
+	u32 wp;
+
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (rate == cpu_wp_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i > cpu_op_nr)
+		wp = 0;
+
+	return cpu_wp_tbl[wp].cpu_rate;
+}
+
+static struct clk mx53_cpu_clk = {
+	.parent = &pll1_sw_clk,
+	.get_rate = _clk_arm_get_rate,
+	.set_rate = _clk_cpu_set_rate,
+	.round_rate = _clk_cpu_round_rate,
+};
+
 static struct clk cpu_clk = {
 	.parent = &pll1_sw_clk,
 	.get_rate = clk_cpu_get_rate,
@@ -950,6 +1149,81 @@ static struct clk ddr_hf_clk = {
 	.get_rate = _clk_ddr_hf_get_rate,
 };
 
+static unsigned long _clk_axi_b_get_rate(struct clk *clk)
+{
+	u32 reg, div;
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	div = ((reg & MXC_CCM_CBCDR_AXI_B_PODF_MASK) >>
+	       MXC_CCM_CBCDR_AXI_B_PODF_OFFSET) + 1;
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_axi_b_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg, div;
+	struct timespec nstimeofday;
+	struct timespec curtime;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+	if (div == 0)
+		div++;
+	if (((parent_rate / div) != rate) || (div > 8))
+		return -EINVAL;
+
+	emi_fast_clk.enable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.enable(&emi_slow_clk);
+
+	reg = __raw_readl(MXC_CCM_CBCDR);
+	reg &= ~MXC_CCM_CBCDR_AXI_B_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_CBCDR_AXI_B_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_CBCDR);
+
+	getnstimeofday(&nstimeofday);
+	while (__raw_readl(MXC_CCM_CDHIPR) & MXC_CCM_CDHIPR_AXI_B_PODF_BUSY) {
+		getnstimeofday(&curtime);
+		if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+			panic("_clk_axi_b_set_rate failed\n");
+	}
+
+	emi_fast_clk.disable(&emi_fast_clk);
+	if (emi_slow_clk.usecount == 0)
+		emi_slow_clk.disable(&emi_slow_clk);
+
+	return 0;
+}
+
+static unsigned long _clk_axi_b_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	u32 div;
+	u32 parent_rate = clk_get_rate(clk->parent);
+
+	div = parent_rate / rate;
+
+	/* Make sure rate is not greater than the maximum value for the clock.
+	 * Also prevent a div of 0.
+	 */
+	if (div == 0)
+		div++;
+	if (parent_rate / div > MAX_AXI_B_CLK_MX53)
+		div++;
+
+	if (div > 8)
+		div = 8;
+
+	return parent_rate / div;
+}
+
+static struct clk axi_b_clk = {
+	.parent = &main_bus_clk,
+	.get_rate = _clk_axi_b_get_rate,
+	.set_rate = _clk_axi_b_set_rate,
+	.round_rate = _clk_axi_b_round_rate,
+};
+
 static struct clk ddr_clk = {
 	.parent = &ddr_hf_clk,
 };
@@ -1112,6 +1386,23 @@ static struct clk usboh3_clk = {
 	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
 };
 
+static struct clk mx53_usboh3_clk[] = {
+	{
+	.parent = &pll3_sw_clk,
+	.get_rate = clk_usboh3_get_rate,
+	.set_parent = clk_usboh3_set_parent,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.secondary = &mx53_usboh3_clk[1],
+	.flags = AHB_MED_SET_POINT | CPU_FREQ_TRIG_UPDATE,
+	},
+	{
+	.secondary = &emi_fast_clk,
+	},
+};
+
 static struct clk usb_ahb_clk = {
 	.parent = &ipg_clk,
 	.enable = _clk_ccgr_enable,
@@ -1134,6 +1425,40 @@ static int clk_usb_phy1_set_parent(struct clk *clk, struct clk *parent)
 	return 0;
 }
 
+static unsigned long _clk_usb_phy_get_rate(struct clk *clk)
+{
+	u32 reg, prediv, podf;
+	u32 div = 1;
+
+	if (clk->parent == &pll3_sw_clk) {
+		reg = __raw_readl(MXC_CCM_CDCDR);
+		prediv = ((reg & MXC_CCM_CDCDR_USB_PHY_PRED_MASK) >>
+			  MXC_CCM_CDCDR_USB_PHY_PRED_OFFSET) + 1;
+		podf = ((reg & MXC_CCM_CDCDR_USB_PHY_PODF_MASK) >>
+			MXC_CCM_CDCDR_USB_PHY_PODF_OFFSET) + 1;
+
+		div = (prediv * podf);
+	}
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_usb_phy_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_CSCMR1);
+	if (parent == &osc_clk)
+		reg &= ~MXC_CCM_CSCMR1_USB_PHY_CLK_SEL;
+	else if (parent == &pll3_sw_clk)
+		reg |= 1 << MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET;
+	else
+		BUG();
+
+	__raw_writel(reg, MXC_CCM_CSCMR1);
+	return 0;
+}
+
 static struct clk usb_phy1_clk = {
 	.parent = &pll3_sw_clk,
 	.set_parent = clk_usb_phy1_set_parent,
@@ -1143,6 +1468,34 @@ static struct clk usb_phy1_clk = {
 	.disable = _clk_ccgr_disable,
 };
 
+static struct clk usb_phy2_clk = {
+	.id = 1,
+	.parent = &pll3_sw_clk,
+	.secondary = &tmax3_clk,
+	.set_parent = _clk_usb_phy_set_parent,
+	.get_rate = _clk_usb_phy_get_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG6_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	return 60000000;
+}
+
+static struct clk usb_clk = {
+	.get_rate = _clk_usb_get_rate,
+};
+
+static struct clk usb_utmi_clk = {
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CSCMR1,
+	.enable_shift = MXC_CCM_CSCMR1_USB_PHY_CLK_SEL_OFFSET,
+	.disable = _clk_disable,
+};
+
 /* eCSPI */
 CLK_GET_RATE(ecspi, 2, CSPI)
 CLK_SET_PARENT(ecspi, 1, CSPI)
@@ -1280,6 +1633,24 @@ DEFINE_CLOCK(gpt_ipg_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG10_OFFSET,
 DEFINE_CLOCK(gpt_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG9_OFFSET,
 	NULL,  NULL, &ipg_clk, &gpt_ipg_clk);
 
+static struct clk mx53_gpt_ipg_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG10_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+};
+static struct clk mx53_gpt_clk = {
+	.id = 0,
+	.parent = &ipg_perclk,
+	.enable_reg = MXC_CCM_CCGR2,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	.secondary = &mx53_gpt_ipg_clk,
+};
+
 DEFINE_CLOCK(pwm1_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG6_OFFSET,
 	NULL, NULL, &ipg_perclk, NULL);
 DEFINE_CLOCK(pwm2_clk, 0, MXC_CCM_CCGR2, MXC_CCM_CCGRx_CG8_OFFSET,
@@ -1418,6 +1789,104 @@ static struct clk ahci_dma_clk = {
 	.parent = &ahb_clk,
 };
 
+static struct clk rtc_clk = {
+	.parent = &ckil_clk,
+	.secondary = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG14_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax1_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG0_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk tmax3_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.secondary = &ahb_max_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG2_OFFSET,
+	.disable = _clk_disable,
+};
+
+static void _clk_disable_inwait(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(MXC_CCM_CCGRx_CG_MASK << clk->enable_shift);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static struct clk emi_intr_clk[] = {
+	{
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR5,
+	.enable_shift = MXC_CCM_CCGRx_CG9_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	},
+	{
+	/* On MX51 - this clock is name emi_garb_clk, and controls the
+	* access of ARM to GARB.
+	*/
+	.id = 1,
+	.parent = &ahb_clk,
+	.enable_reg = MXC_CCM_CCGR6,
+	.enable_shift = MXC_CCM_CCGRx_CG4_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable_inwait,
+	}
+};
+
+static struct clk scc_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &scc_clk[1],
+	.enable_reg = MXC_CCM_CCGR1,
+	.enable_shift = MXC_CCM_CCGRx_CG15_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &scc_clk[2],
+	},
+	{
+	.parent = &emi_fast_clk,
+	.secondary = &emi_intr_clk[0],
+	}
+};
+
+static struct clk sahara_clk[] = {
+	{
+	.parent = &ahb_clk,
+	.secondary = &sahara_clk[1],
+	.enable_reg = MXC_CCM_CCGR4,
+	.enable_shift = MXC_CCM_CCGRx_CG7_OFFSET,
+	.enable = _clk_enable,
+	.disable = _clk_disable,
+	},
+	{
+	.parent = &tmax1_clk,
+	.secondary = &sahara_clk[2],
+	},
+	{
+	.parent = &scc_clk[0],
+	.secondary = &emi_fast_clk,
+	}
+};
+
 DEFINE_CLOCK(mipi_esc_clk, 0, MXC_CCM_CCGR4, MXC_CCM_CCGRx_CG5_OFFSET, NULL, NULL, NULL, &pll2_sw_clk);
 DEFINE_CLOCK(mipi_hsc2_clk, 0, MXC_CCM_CCGR4, MXC_CCM_CCGRx_CG4_OFFSET, NULL, NULL, &mipi_esc_clk, &pll2_sw_clk);
 DEFINE_CLOCK(mipi_hsc1_clk, 0, MXC_CCM_CCGR4, MXC_CCM_CCGRx_CG3_OFFSET, NULL, NULL, &mipi_hsc2_clk, &pll2_sw_clk);
@@ -1499,13 +1968,32 @@ static struct clk_lookup mx51_lookups[] = {
 };
 
 static struct clk_lookup mx53_lookups[] = {
+	_REGISTER_CLOCK(NULL, "pll1_main_clk", pll1_main_clk)
+	_REGISTER_CLOCK(NULL, "pll1_sw_clk", pll1_sw_clk)
+	_REGISTER_CLOCK(NULL, "pll2", pll2_sw_clk)
+	_REGISTER_CLOCK(NULL, "pll3", pll3_sw_clk)
+	_REGISTER_CLOCK(NULL, "pll4", mx53_pll4_sw_clk)
+	_REGISTER_CLOCK(NULL, "lp_apm", lp_apm_clk)
+	_REGISTER_CLOCK(NULL, "cpu_clk", mx53_cpu_clk)
+	_REGISTER_CLOCK(NULL, "periph_apm_clk", periph_apm_clk)
+	_REGISTER_CLOCK(NULL, "gpc_dvfs", gpc_dvfs_clk)
+	_REGISTER_CLOCK(NULL, "main_bus_clk", main_bus_clk)
+	_REGISTER_CLOCK(NULL, "axi_a_clk", axi_a_clk)
+	_REGISTER_CLOCK(NULL, "axi_b_clk", axi_b_clk)
+	_REGISTER_CLOCK(NULL, "ddr_clk", ddr_clk)
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk)
+	_REGISTER_CLOCK(NULL, "usboh3_clk", mx53_usboh3_clk[0])
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk)
+	_REGISTER_CLOCK(NULL, "usb_phy2_clk", usb_phy2_clk)
+	_REGISTER_CLOCK(NULL, "usb_utmi_clk", usb_utmi_clk)
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk)
 	/* i.mx53 has the i.mx21 type uart */
 	_REGISTER_CLOCK("imx21-uart.0", NULL, uart1_clk)
 	_REGISTER_CLOCK("imx21-uart.1", NULL, uart2_clk)
 	_REGISTER_CLOCK("imx21-uart.2", NULL, uart3_clk)
 	_REGISTER_CLOCK("imx21-uart.3", NULL, uart4_clk)
 	_REGISTER_CLOCK("imx21-uart.4", NULL, uart5_clk)
-	_REGISTER_CLOCK(NULL, "gpt", gpt_clk)
+	_REGISTER_CLOCK(NULL, "gpt", mx53_gpt_clk)
 	/* i.mx53 has the i.mx25 type fec */
 	_REGISTER_CLOCK("imx25-fec.0", NULL, fec_clk)
 	_REGISTER_CLOCK(NULL, "iim_clk", iim_clk)
@@ -1521,6 +2009,7 @@ static struct clk_lookup mx53_lookups[] = {
 	_REGISTER_CLOCK("sdhci-esdhc-imx53.1", NULL, esdhc2_mx53_clk)
 	_REGISTER_CLOCK("sdhci-esdhc-imx53.2", NULL, esdhc3_mx53_clk)
 	_REGISTER_CLOCK("sdhci-esdhc-imx53.3", NULL, esdhc4_mx53_clk)
+	_REGISTER_CLOCK(NULL, "emi_slow_clk", emi_slow_clk)
 	_REGISTER_CLOCK("imx2-wdt.0", NULL, dummy_clk)
 	_REGISTER_CLOCK("imx2-wdt.1", NULL, dummy_clk)
 	/* i.mx53 has the i.mx35 type sdma */
@@ -1529,10 +2018,15 @@ static struct clk_lookup mx53_lookups[] = {
 	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk)
 	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk)
 	_REGISTER_CLOCK("imx-keypad", NULL, dummy_clk)
+	_REGISTER_CLOCK("mxc_rtc", "rtc_clk", rtc_clk)
 	_REGISTER_CLOCK("pata_imx", NULL, pata_clk)
 	_REGISTER_CLOCK("imx53-ahci.0", "ahci", sata_clk)
 	_REGISTER_CLOCK("imx53-ahci.0", "ahci_phy", ahci_phy_clk)
 	_REGISTER_CLOCK("imx53-ahci.0", "ahci_dma", ahci_dma_clk)
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.0", emi_intr_clk[0])
+	_REGISTER_CLOCK(NULL, "emi_intr_clk.1", emi_intr_clk[1])
+	_REGISTER_CLOCK(NULL, "sahara_clk", sahara_clk[0])
+	_REGISTER_CLOCK("mxc_scc.0", NULL, scc_clk[0])
 };
 
 static void clk_tree_init(void)
@@ -1601,6 +2095,12 @@ int __init mx53_clocks_init(unsigned long ckil, unsigned long osc,
 			unsigned long ckih1, unsigned long ckih2)
 {
 	int i;
+	u32 pll1_rate;
+
+	pll1_base = ioremap(MX53_PLL1_BASE_ADDR, SZ_4K);
+	pll2_base = ioremap(MX53_PLL2_BASE_ADDR, SZ_4K);
+	pll3_base = ioremap(MX53_PLL3_BASE_ADDR, SZ_4K);
+	pll4_base = ioremap(MX53_PLL4_BASE_ADDR, SZ_4K);
 
 	external_low_reference = ckil;
 	external_high_reference = ckih1;
@@ -1613,7 +2113,7 @@ int __init mx53_clocks_init(unsigned long ckil, unsigned long osc,
 	clk_tree_init();
 
 	clk_set_parent(&uart_root_clk, &pll3_sw_clk);
-	clk_enable(&cpu_clk);
+	clk_enable(&mx53_cpu_clk);
 	clk_enable(&main_bus_clk);
 
 	clk_enable(&iim_clk);
@@ -1628,9 +2128,37 @@ int __init mx53_clocks_init(unsigned long ckil, unsigned long osc,
 	clk_set_rate(&esdhc1_clk, 200000000);
 	clk_set_rate(&esdhc3_mx53_clk, 200000000);
 
+	/* The CPU working point should be set according to part number
+	 * information. But part number information is not clear now.
+	 * So update the cpu working point table based on the PLL1 freq
+	 * at boot time
+	 */
+	pll1_rate = clk_get_rate(&pll1_main_clk);
+	if (pll1_rate > 1000000000)
+		mx53_set_cpu_part_number(IMX53_CEC_1_2G);
+	else if (pll1_rate > 800000000)
+		mx53_set_cpu_part_number(IMX53_CEC);
+	else
+		mx53_set_cpu_part_number(IMX53_AEC);
+
+	/* Set the current working point. */
+	cpu_wp_tbl = get_cpu_op(&cpu_op_nr);
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (clk_get_rate(&mx53_cpu_clk) == cpu_wp_tbl[i].cpu_rate) {
+			cpu_curr_wp = i;
+			break;
+		}
+	}
+	if (i > cpu_op_nr)
+		BUG();
+
 	/* System timer */
-	mxc_timer_init(&gpt_clk, MX53_IO_ADDRESS(MX53_GPT1_BASE_ADDR),
+	mxc_timer_init(&mx53_gpt_clk, MX53_IO_ADDRESS(MX53_GPT1_BASE_ADDR),
 		MX53_INT_GPT);
+
+	lp_med_freq = 0;
+	lp_high_freq = 0;
+
 	return 0;
 }
 
@@ -1673,3 +2201,98 @@ int __init mx53_clocks_init_dt(void)
 	return mx53_clocks_init(ckil, osc, ckih1, ckih2);
 }
 #endif
+
+/*!
+ * Setup cpu clock based on working point.
+ * @param	wp	cpu freq working point
+ * @return		0 on success or error code on failure.
+ */
+static int cpu_clk_set_wp(int wp)
+{
+	struct cpu_op *p;
+	u32 reg, pll_hfsm;
+	u32 stat;
+
+	if (wp == cpu_curr_wp)
+		return 0;
+
+	p = &cpu_wp_tbl[wp];
+
+	/*
+	 * If DDR clock is sourced from PLL1, we cannot drop PLL1 freq.
+	 * Use the ARM_PODF to change the freq of the core, leave the PLL1
+	 * freq unchanged. Meanwhile, if pll_rate is same, use the ARM_PODF
+	 * to change the freq of core
+	 */
+	if ((p->pll_rate == cpu_wp_tbl[cpu_curr_wp].pll_rate)) {
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg &= ~MXC_CCM_CACRR_ARM_PODF_MASK;
+		reg |= cpu_wp_tbl[wp].cpu_podf << MXC_CCM_CACRR_ARM_PODF_OFFSET;
+		__raw_writel(reg, MXC_CCM_CACRR);
+		cpu_curr_wp = wp;
+	} else {
+		struct timespec nstimeofday;
+		struct timespec curtime;
+
+		/* Change the ARM clock to requested frequency */
+		/* First move the ARM clock to step clock which is running
+		 * at 24MHz.
+		 */
+
+		/* Change the source of pll1_sw_clk to be the step_clk */
+		reg = __raw_readl(MXC_CCM_CCSR);
+		reg |= MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		/* Stop the PLL */
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg &= ~MXC_PLL_DP_CTL_UPEN;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		reg = __raw_readl(MXC_CCM_CACRR);
+		reg = (reg & ~MXC_CCM_CACRR_ARM_PODF_MASK)
+			| p->cpu_podf;
+		__raw_writel(reg, MXC_CCM_CACRR);
+
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		pll_hfsm = reg & MXC_PLL_DP_CTL_HFSM;
+		/* PDF and MFI */
+		reg = p->pdf | p->mfi << MXC_PLL_DP_OP_MFI_OFFSET;
+		if (pll_hfsm == 0) {
+			__raw_writel(reg, pll1_base + MXC_PLL_DP_OP);
+			__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_MFD);
+			__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_MFN);
+		} else {
+			__raw_writel(reg, pll1_base + MXC_PLL_DP_HFS_OP);
+			__raw_writel(p->mfd, pll1_base + MXC_PLL_DP_HFS_MFD);
+			__raw_writel(p->mfn, pll1_base + MXC_PLL_DP_HFS_MFN);
+		}
+
+		reg = __raw_readl(pll1_base + MXC_PLL_DP_CTL);
+		reg |= MXC_PLL_DP_CTL_UPEN;
+		/* Set the UPEN bits */
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+		/* Forcefully restart the PLL */
+		reg |= MXC_PLL_DP_CTL_RST;
+		__raw_writel(reg, pll1_base + MXC_PLL_DP_CTL);
+
+		/* Wait for the PLL to lock */
+		getnstimeofday(&nstimeofday);
+		do {
+			getnstimeofday(&curtime);
+			if ((curtime.tv_nsec - nstimeofday.tv_nsec) > SPIN_DELAY)
+				panic("pll1 relock failed\n");
+			stat = __raw_readl(pll1_base + MXC_PLL_DP_CTL) &
+			    MXC_PLL_DP_CTL_LRF;
+		} while (!stat);
+
+		reg = __raw_readl(MXC_CCM_CCSR);
+		/* Move the PLL1 back to the pll1_main_clk */
+		reg &= ~MXC_CCM_CCSR_PLL1_SW_CLK_SEL;
+		__raw_writel(reg, MXC_CCM_CCSR);
+
+		cpu_curr_wp = wp;
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-imx/crm-regs-imx5.h b/arch/arm/mach-imx/crm-regs-imx5.h
index 5e3f1f0..3df01da 100644
--- a/arch/arm/mach-imx/crm-regs-imx5.h
+++ b/arch/arm/mach-imx/crm-regs-imx5.h
@@ -24,6 +24,16 @@
 #define MX53_DPLL2_BASE		MX53_IO_ADDRESS(MX53_PLL2_BASE_ADDR)
 #define MX53_DPLL3_BASE		MX53_IO_ADDRESS(MX53_PLL3_BASE_ADDR)
 #define MX53_DPLL4_BASE		MX53_IO_ADDRESS(MX53_PLL4_BASE_ADDR)
+#define MX53_CORTEXA8_BASE	MX53_IO_ADDRESS(MX53_ARM_BASE_ADDR)
+#define MX53_CORTEXA8_PLAT_LPC	0xC
+#define MXC_GPC_BASE		MX53_IO_ADDRESS(MX53_GPC_BASE_ADDR)
+
+#define MXC_GPC_CNTR_OFFSET		0x0
+#define MXC_GPC_PGR_OFFSET		0x4
+#define MXC_GPC_VCR_OFFSET		0x8
+#define MXC_CCM_CDCR_OFFSET		0x4C
+#define MXC_CCM_CACRR_OFFSET		0x10
+#define MXC_CCM_CDHIPR_OFFSET		0x48
 
 /* PLL Register Offsets */
 #define MXC_PLL_DP_CTL			0x00
@@ -568,7 +578,7 @@
 #define MXC_EMPGCR_PCR		1
 #define MXC_PGSR_PSR		1
 
-
+#define MXC_CORTEXA8_PLAT_LPC_OFFSET	(0xc)
 #define MXC_CORTEXA8_PLAT_LPC_DSM	(1 << 0)
 #define MXC_CORTEXA8_PLAT_LPC_DBG_DSM	(1 << 1)
 
-- 
1.7.9.7

