From f4f12eac221c94caf5f2069c1f1640b6519bbdd9 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 15 Oct 2012 17:25:17 +0800
Subject: [PATCH 35/62] fsl_imx6: Add anatop thermal driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                          |    1 +
 arch/arm/mach-mx6/devices-imx6q.h                  |    5 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c            |    7 +
 arch/arm/plat-mxc/devices/Kconfig                  |    3 +
 arch/arm/plat-mxc/devices/Makefile                 |    1 +
 .../plat-mxc/devices/platform-imx-anatop-thermal.c |   47 +
 arch/arm/plat-mxc/include/mach/anatop_thermal.h    |   29 +
 arch/arm/plat-mxc/include/mach/devices-common.h    |   10 +
 drivers/mxc/Kconfig                                |    1 +
 drivers/mxc/Makefile                               |    1 +
 drivers/mxc/thermal/Kconfig                        |   20 +
 drivers/mxc/thermal/Makefile                       |    5 +
 drivers/mxc/thermal/anatop_driver.h                |  140 +++
 drivers/mxc/thermal/cooling.c                      |  274 ++++++
 drivers/mxc/thermal/thermal.c                      |  944 ++++++++++++++++++++
 drivers/thermal/thermal_sys.c                      |   32 +-
 include/linux/thermal.h                            |    3 +
 17 files changed, 1520 insertions(+), 3 deletions(-)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
 create mode 100644 arch/arm/plat-mxc/include/mach/anatop_thermal.h
 create mode 100644 drivers/mxc/thermal/Kconfig
 create mode 100644 drivers/mxc/thermal/Makefile
 create mode 100644 drivers/mxc/thermal/anatop_driver.h
 create mode 100644 drivers/mxc/thermal/cooling.c
 create mode 100644 drivers/mxc/thermal/thermal.c

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index a85fdd2..d1c51ab 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -32,6 +32,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
 	select IMX_HAVE_PLATFORM_VIV_GPU
 	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index 95eca55..8e11e60 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -106,4 +106,9 @@ extern const struct imx_viv_gpu_data imx6_gc355_data __initconst;
 extern const struct imx_spi_imx_data imx6q_ecspi_data[] __initconst;
 #define imx6q_add_ecspi(id, pdata)	\
 	imx_add_spi_imx(&imx6q_ecspi_data[id], pdata)
+
+extern const struct imx_anatop_thermal_imx_data
+imx6q_anatop_thermal_imx_data __initconst;
+#define imx6q_add_anatop_thermal_imx(id, pdata)	\
+	imx_add_anatop_thermal_imx(&imx6q_anatop_thermal_imx_data, pdata)
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index eb68bd7..059417c 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -633,6 +633,11 @@ static void __init imx6q_sabrelite_init_usb(void)
 	mx6_usb_h1_init();
 }
 
+static const struct anatop_thermal_platform_data
+	mx6q_sabrelite_anatop_thermal_data __initconst = {
+		.name = "anatop_thermal",
+};
+
 /*!
  * Board specific initialization.
  */
@@ -677,6 +682,8 @@ static void __init mx6_sabrelite_board_init(void)
 	spi_register_board_info(imx6_sabrelite_spi_nor_device,
 				ARRAY_SIZE(imx6_sabrelite_spi_nor_device));
 
+	imx6q_add_anatop_thermal_imx(1, &mx6q_sabrelite_anatop_thermal_data);
+
 	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
 	imx6q_add_mxc_hdmi(&hdmi_data);
 	imx6q_add_hdmi_soc();
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index a998aca..9bc5895 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -101,3 +101,6 @@ config IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
 
 config IMX_HAVE_PLATFORM_IMX_SNVS_RTC
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index b6043b5..a0e9cd6 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -36,3 +36,4 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_VIV_GPU) +=  platform-viv_gpu.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_OTG) += platform-fsl-usb2-otg.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_USB_WAKEUP) += platform-fsl-usb2-wakeup.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SNVS_RTC) += platform-imx_snvs_rtc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL) += platform-imx-anatop-thermal.o
diff --git a/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c b/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
new file mode 100644
index 0000000..b96bc6f
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-anatop-thermal.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_anatop_thermal_imx_data_entry_single(soc)				\
+	{								\
+		.iobase = ANATOP_BASE_ADDR,			\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_anatop_thermal_imx_data imx6q_anatop_thermal_imx_data __initconst =
+	imx_anatop_thermal_imx_data_entry_single(MX6Q);
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+struct platform_device *__init imx_add_anatop_thermal_imx(
+		const struct imx_anatop_thermal_imx_data *data,
+		const struct anatop_thermal_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device("anatop_thermal", 0,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/include/mach/anatop_thermal.h b/arch/arm/plat-mxc/include/mach/anatop_thermal.h
new file mode 100644
index 0000000..7549bc5
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/anatop_thermal.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_IMX_ANATOP_THERMAL_H
+#define __ASM_ARCH_IMX_ANATOP_THERMAL_H
+
+/**
+ * struct anatop_thermal_platform_data - optional platform data for thermal on i.MX
+ *
+ */
+
+struct anatop_thermal_platform_data {
+	char *name;
+};
+#endif /* __ASM_ARCH_IMX_ANATOP_THERMAL_H */
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index b2ce97a..ff47131 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -424,3 +424,13 @@ struct imx_viv_gpu_data {
 struct platform_device *__init imx_add_viv_gpu(
 		const struct imx_viv_gpu_data *data,
 		const struct viv_gpu_platform_data *pdata);
+
+#include <mach/anatop_thermal.h>
+struct imx_anatop_thermal_imx_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_anatop_thermal_imx(
+		const struct imx_anatop_thermal_imx_data *data,
+		const struct anatop_thermal_platform_data *pdata);
diff --git a/drivers/mxc/Kconfig b/drivers/mxc/Kconfig
index 26ab13d..10a7448 100644
--- a/drivers/mxc/Kconfig
+++ b/drivers/mxc/Kconfig
@@ -19,6 +19,7 @@ config MXC_IPU
 
 source "drivers/mxc/ipu3/Kconfig"
 source "drivers/mxc/gpu-viv/Kconfig"
+source "drivers/mxc/thermal/Kconfig"
 endmenu
 
 endif
diff --git a/drivers/mxc/Makefile b/drivers/mxc/Makefile
index a139024..1af1fea 100644
--- a/drivers/mxc/Makefile
+++ b/drivers/mxc/Makefile
@@ -1,2 +1,3 @@
 obj-$(CONFIG_MXC_IPU_V3)			+= ipu3/
 obj-$(CONFIG_MXC_GPU_VIV)			+= gpu-viv/
+obj-$(CONFIG_ANATOP_THERMAL)			+= thermal/
diff --git a/drivers/mxc/thermal/Kconfig b/drivers/mxc/thermal/Kconfig
new file mode 100644
index 0000000..9afbb1e
--- /dev/null
+++ b/drivers/mxc/thermal/Kconfig
@@ -0,0 +1,20 @@
+#
+# ANATOP Configuration
+#
+
+menu "ANATOP_THERMAL"
+
+config ANATOP_THERMAL
+	tristate "Thermal Zone"
+	depends on ARCH_MX6
+	select THERMAL
+	default y
+	help
+	  This driver supports ANATOP thermal zones. It is HIGHLY
+	  recommended that this option be enabled, as your processor(s)
+	  may be damaged without it.
+
+	  To compile this driver as a module, choose M here:
+	  the module will be called thermal.
+
+endmenu
diff --git a/drivers/mxc/thermal/Makefile b/drivers/mxc/thermal/Makefile
new file mode 100644
index 0000000..4823d6d
--- /dev/null
+++ b/drivers/mxc/thermal/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for i.MX ANATOP
+#
+
+obj-$(CONFIG_ANATOP_THERMAL)	+= thermal.o cooling.o
diff --git a/drivers/mxc/thermal/anatop_driver.h b/drivers/mxc/thermal/anatop_driver.h
new file mode 100644
index 0000000..63cbdc7
--- /dev/null
+++ b/drivers/mxc/thermal/anatop_driver.h
@@ -0,0 +1,140 @@
+/*
+ *  anatop_drivers.h
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __ANATOP_DRIVERS_H__
+#define __ANATOP_DRIVERS_H__
+
+
+typedef void *anatop_handle;	/* Actually a ptr to a NS Node */
+
+/* Device */
+#define ANATOP_MAX_HANDLES	10
+#define ANATOP_DEVICE_ID_LENGTH	0x09
+
+struct anatop_handle_list {
+	u32 count;
+	anatop_handle handles[ANATOP_MAX_HANDLES];
+};
+
+struct anatop_device {
+	struct device dev;
+	anatop_handle handle;		/* no handle for fixed hardware */
+	char name[40];
+	int id;
+	void *driver_data;
+};
+struct anatop_device_id {
+	__u8 id[ANATOP_DEVICE_ID_LENGTH];
+};
+typedef int (*anatop_op_add) (struct anatop_device *device);
+typedef int (*anatop_op_remove) (struct anatop_device *device, int type);
+typedef int (*anatop_op_start) (struct anatop_device *device);
+typedef int (*anatop_op_suspend) (struct anatop_device *device,
+				pm_message_t state);
+typedef int (*anatop_op_resume) (struct anatop_device *device);
+typedef int (*anatop_op_bind) (struct anatop_device *device);
+typedef int (*anatop_op_unbind) (struct anatop_device *device);
+typedef void (*anatop_op_notify) (struct anatop_device *device, u32 event);
+
+struct anatop_ops {
+	u32 anatop_op_add:1;
+	u32 anatop_op_start:1;
+};
+
+struct anatop_device_ops {
+	anatop_op_add add;
+	anatop_op_remove remove;
+	anatop_op_start start;
+	anatop_op_suspend suspend;
+	anatop_op_resume resume;
+	anatop_op_bind bind;
+	anatop_op_unbind unbind;
+	anatop_op_notify notify;
+};
+
+struct anatop_driver {
+	char name[80];
+	char class[80];
+	const struct anatop_device_id *ids; /* Supported Hardware IDs */
+	unsigned int flags;
+	struct anatop_device_ops ops;
+	struct device_driver drv;
+	struct module *owner;
+};
+
+
+
+typedef u32 anatop_status;	/* All ANATOP Exceptions */
+
+#define AT_OK                   (anatop_status) 0x0000
+#define AT_ERROR                (anatop_status) 0x0001
+
+
+#define ANATOP_MAX_STRING			80
+
+
+#define ANATOP_BUS_COMPONENT		0x00010000
+#define ANATOP_AC_COMPONENT		0x00020000
+#define ANATOP_BATTERY_COMPONENT		0x00040000
+#define ANATOP_BUTTON_COMPONENT		0x00080000
+#define ANATOP_SBS_COMPONENT		0x00100000
+#define ANATOP_FAN_COMPONENT		0x00200000
+#define ANATOP_PCI_COMPONENT		0x00400000
+#define ANATOP_POWER_COMPONENT		0x00800000
+#define ANATOP_CONTAINER_COMPONENT	0x01000000
+#define ANATOP_SYSTEM_COMPONENT		0x02000000
+#define ANATOP_THERMAL_COMPONENT		0x04000000
+#define ANATOP_MEMORY_DEVICE_COMPONENT	0x08000000
+#define ANATOP_VIDEO_COMPONENT		0x10000000
+#define ANATOP_PROCESSOR_COMPONENT	0x20000000
+
+
+#define ANATOP_POWER_HID			"LNXPOWER"
+#define ANATOP_PROCESSOR_OBJECT_HID	"LNXCPU"
+#define ANATOP_SYSTEM_HID			"LNXSYSTM"
+#define ANATOP_THERMAL_HID		"LNXTHERM"
+#define ANATOP_BUTTON_HID_POWERF		"LNXPWRBN"
+#define ANATOP_BUTTON_HID_SLEEPF		"LNXSLPBN"
+#define ANATOP_VIDEO_HID			"LNXVIDEO"
+#define ANATOP_BAY_HID			"LNXIOBAY"
+#define ANATOP_DOCK_HID			"LNXDOCK"
+/* Quirk for broken IBM BIOSes */
+#define ANATOP_SMBUS_IBM_HID		"SMBUSIBM"
+
+#define ANATOP_FIXED_HARDWARE_EVENT	0x100
+
+static inline void *anatop_driver_data(struct anatop_device *d)
+{
+	return d->driver_data;
+}
+
+extern void anatop_thermal_cpufreq_init(void);
+extern int anatop_thermal_cpu_hotplug(bool cpu_on);
+extern int anatop_thermal_cpufreq_up(void);
+extern int anatop_thermal_cpufreq_down(void);
+extern struct thermal_cooling_device_ops imx_processor_cooling_ops;
+extern void arch_reset(char mode, const char *cmd);
+
+#endif /*__ANATOP_DRIVERS_H__*/
diff --git a/drivers/mxc/thermal/cooling.c b/drivers/mxc/thermal/cooling.c
new file mode 100644
index 0000000..e5fda9f
--- /dev/null
+++ b/drivers/mxc/thermal/cooling.c
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/io.h>
+#include <linux/thermal.h>
+#include <linux/syscalls.h>
+#include <mach/hardware.h>
+
+#define	CPUx		"/sys/devices/system/cpu/cpu"
+#define MAX_GOVERNOR_NAME_LEN 12
+#define MAX_CPU_FREQ_LEN 7
+#define MAX_CPU_ONLINE_LEN 1
+
+/* Save the last hot point trigger temperature */
+extern unsigned long temperature_cooling;
+/* cooling device selection */
+extern bool cooling_cpuhotplug;
+extern struct cpu_op *(*get_cpu_op)(int *op);
+/* Save the string we will read/write to the sys file */
+static unsigned char cpu_sys_file[80];
+static unsigned int cpu_mask;
+static unsigned int anatop_thermal_cpufreq_is_init;
+/* Save cpu operation table and current work point */
+static struct cpu_op *cpu_op_tbl;
+static int cpu_op_nr, cpu_op_cur;
+
+/* Save the cpu freq necessray setting before thermal driver change it */
+static unsigned int saved_cpu_freq[5];
+static char saved_max_cpufreq_str[4][10];
+
+/* New cpufreq to be set */
+static unsigned int cpufreq_new;
+static char cpufreq_new_str[10];
+
+/* This variable record the cpufreq change, when we lower the
+cpufreq, it minor 1, and when we promote cpufreq, it add 1, so
+if it is 0, mean we didn't change the cpufreq */
+static int cpufreq_change_count;
+
+int anatop_thermal_get_cpufreq_cur(void)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_CPU_FREQ
+	unsigned int i, freq;
+
+	freq = cpufreq_quick_get(0);
+	saved_cpu_freq[abs(cpufreq_change_count)] = freq;
+	printk(KERN_WARNING "cooling: cpu cur freq is %d\n", freq * 1000);
+	freq *= 1000;
+
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (freq == cpu_op_tbl[i].cpu_rate)
+			break;
+	}
+
+	if (i >= cpu_op_nr) {
+		printk(KERN_WARNING "cooling: can't get cpufreq\
+			current operating point!\n");
+		return ret;
+	}
+	cpu_op_cur = i;
+#endif
+	return 0;
+
+}
+
+int anatop_thermal_cpufreq_up(void)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_CPU_FREQ
+	int fd;
+
+	anatop_thermal_get_cpufreq_cur();
+	if (cpu_op_cur == 0 || cpu_op_cur >= cpu_op_nr) {
+		printk(KERN_ERR "cooling: Bad cpu_op_cur!\n");
+		return ret;
+	}
+
+	cpufreq_new = cpu_op_tbl[cpu_op_cur - 1].cpu_rate;
+	printk(KERN_INFO "cooling: cpu max freq set to %s\n",
+		saved_max_cpufreq_str[abs(cpufreq_change_count) - 1]);
+
+	strcpy(cpu_sys_file, CPUx);
+	strcat(cpu_sys_file, "0/cpufreq/scaling_max_freq");
+
+	fd = sys_open((const char __user __force *)cpu_sys_file,
+	  O_RDWR, 0700);
+	if (fd >= 0) {
+		sys_write(fd, saved_max_cpufreq_str[abs(cpufreq_change_count) - 1],
+			strlen(saved_max_cpufreq_str[abs(cpufreq_change_count) - 1]));
+		cpufreq_update_policy(0);
+		sys_close(fd);
+		ret = 0;
+	}
+
+	cpufreq_change_count++;
+#endif
+	return ret;
+}
+int anatop_thermal_cpufreq_down(void)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_CPU_FREQ
+	int fd;
+
+	anatop_thermal_get_cpufreq_cur();
+	if (cpu_op_cur == (cpu_op_nr - 1) || cpu_op_cur >= cpu_op_nr) {
+		printk(KERN_ERR "cooling: Bad cpu_op_cur!\n");
+		return ret;
+	}
+
+	cpufreq_new = cpu_op_tbl[cpu_op_cur + 1].cpu_rate;
+
+	printk(KERN_INFO "cooling: cpu max freq set to %d\n", cpufreq_new);
+	cpufreq_new /= 1000;
+
+	strcpy(cpu_sys_file, CPUx);
+	sprintf(cpufreq_new_str, "%d", cpufreq_new);
+	strcat(cpu_sys_file, "0/cpufreq/scaling_max_freq");
+
+	fd = sys_open((const char __user __force *)cpu_sys_file,
+	  O_RDWR, 0700);
+	if (fd >= 0) {
+		sys_read(fd, saved_max_cpufreq_str[abs(cpufreq_change_count)],
+			MAX_CPU_FREQ_LEN);
+		sys_write(fd, cpufreq_new_str, strlen(cpufreq_new_str));
+		sys_close(fd);
+		ret = 0;
+	}
+
+	cpufreq_change_count--;
+	cpufreq_update_policy(0);
+#endif
+	return ret;
+}
+
+
+int anatop_thermal_cpu_hotplug(bool cpu_on)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_HOTPLUG
+	unsigned int cpu;
+	char online;
+	char cpu_number[9];
+	int fd;
+
+	if (cpu_on) {
+		for (cpu = 1; cpu < num_possible_cpus(); cpu++) {
+			strcpy(cpu_sys_file, CPUx);
+			sprintf(cpu_number, "%d%s", cpu, "/online");
+			strcat(cpu_sys_file, cpu_number);
+			fd = sys_open((const char __user __force *)cpu_sys_file,
+			  O_RDWR, 0700);
+			if (fd >= 0) {
+				sys_read(fd, &online, MAX_CPU_ONLINE_LEN);
+				if (online == '0') {
+					sys_write(fd, (char *)"1", MAX_CPU_ONLINE_LEN);
+					cpu_mask &= ~(0x1 << cpu);
+					ret = 0;
+					break;
+				}
+				sys_close(fd);
+			}
+		}
+	} else {
+		if (num_online_cpus() < 2)
+			return ret;
+
+		for (cpu = num_possible_cpus() - 1; cpu > 0; cpu--) {
+			strcpy(cpu_sys_file, CPUx);
+			sprintf(cpu_number, "%d%s", cpu, "/online");
+			strcat(cpu_sys_file, cpu_number);
+			fd = sys_open((const char __user __force *)cpu_sys_file,
+					O_RDWR, 0700);
+			if (fd >= 0) {
+				sys_read(fd, &online, 1);
+				if (online == '1') {
+					sys_write(fd, (char *)"0", MAX_CPU_ONLINE_LEN);
+					cpu_mask |= 0x1 << cpu;
+					ret = 0;
+					break;
+				}
+				sys_close(fd);
+			}
+		}
+	}
+#endif
+	return ret;
+}
+
+static int
+imx_processor_get_max_state(struct thermal_cooling_device *cdev,
+			unsigned long *state)
+{
+	*state = cpu_mask | (0x1 << 1) | (0x1 << 2) | (0x1 << 3);
+	return 0;
+}
+
+static int
+imx_processor_get_cur_state(struct thermal_cooling_device *cdev,
+			unsigned long *cur_state)
+{
+	*cur_state = cpu_mask;
+	return 0;
+}
+
+static int
+imx_processor_set_cur_state(struct thermal_cooling_device *cdev,
+			unsigned long state)
+{
+	int result = 0;
+	int i;
+
+	/* state =0 means we are at a low temp, we should try to attach the
+	secondary CPUs that detached by thermal driver */
+	if (cooling_cpuhotplug) {
+		if (!state) {
+			for (i = 1; i < 4; i++) {
+				if (cpu_mask && (0x1 << i)) {
+					anatop_thermal_cpu_hotplug(true);
+					temperature_cooling = 0;
+					break;
+				}
+			}
+		}
+	} else {
+		if (!state) {
+			if (cpufreq_change_count < 0)
+				anatop_thermal_cpufreq_up();
+			else if (cpufreq_change_count > 0)
+				anatop_thermal_cpufreq_down();
+			temperature_cooling = 0;
+		}
+	}
+
+	return result;
+}
+
+void anatop_thermal_cpufreq_init(void)
+{
+	cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+	anatop_thermal_cpufreq_is_init = 1;
+}
+
+void anatop_thermal_cpufreq_exit(void)
+{
+	anatop_thermal_cpufreq_is_init = 0;
+}
+
+struct thermal_cooling_device_ops imx_processor_cooling_ops = {
+	.get_max_state = imx_processor_get_max_state,
+	.get_cur_state = imx_processor_get_cur_state,
+	.set_cur_state = imx_processor_set_cur_state,
+};
diff --git a/drivers/mxc/thermal/thermal.c b/drivers/mxc/thermal/thermal.c
new file mode 100644
index 0000000..9ba1f67
--- /dev/null
+++ b/drivers/mxc/thermal/thermal.c
@@ -0,0 +1,944 @@
+/*
+ *  anatop_thermal.c - anatop Thermal Zone Driver ($Revision: 41 $)
+ *
+ *  Copyright (C) 2001, 2002 Andy Grover <andrew.grover@intel.com>
+ *  Copyright (C) 2001, 2002 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/dmi.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/jiffies.h>
+#include <linux/kmod.h>
+#include <linux/reboot.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <linux/thermal.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/syscalls.h>
+#include <linux/cpufreq.h>
+#include <mach/common.h>
+
+#include "anatop_driver.h"
+
+/* register define of anatop */
+#define HW_ANADIG_ANA_MISC0	(0x00000150)
+#define HW_ANADIG_ANA_MISC0_SET	(0x00000154)
+#define HW_ANADIG_ANA_MISC0_CLR	(0x00000158)
+#define HW_ANADIG_ANA_MISC0_TOG	(0x0000015c)
+
+#define HW_ANADIG_TEMPSENSE0	(0x00000180)
+#define HW_ANADIG_TEMPSENSE0_SET	(0x00000184)
+#define HW_ANADIG_TEMPSENSE0_CLR	(0x00000188)
+#define HW_ANADIG_TEMPSENSE0_TOG	(0x0000018c)
+
+#define HW_ANADIG_TEMPSENSE1	(0x00000190)
+#define HW_ANADIG_TEMPSENSE1_SET	(0x00000194)
+#define HW_ANADIG_TEMPSENSE1_CLR	(0x00000198)
+
+#define BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF 0x00000008
+
+#define BP_ANADIG_TEMPSENSE0_TEMP_VALUE      8
+#define BM_ANADIG_TEMPSENSE0_TEMP_VALUE 0x000FFF00
+#define BF_ANADIG_TEMPSENSE0_TEMP_VALUE(v)  \
+	(((v) << 8) & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
+#define BM_ANADIG_TEMPSENSE0_RSVD0 0x00000080
+#define BM_ANADIG_TEMPSENSE0_TEST 0x00000040
+#define BP_ANADIG_TEMPSENSE0_VBGADJ      3
+#define BM_ANADIG_TEMPSENSE0_VBGADJ 0x00000038
+#define BF_ANADIG_TEMPSENSE0_VBGADJ(v)  \
+	(((v) << 3) & BM_ANADIG_TEMPSENSE0_VBGADJ)
+#define BM_ANADIG_TEMPSENSE0_FINISHED 0x00000004
+#define BM_ANADIG_TEMPSENSE0_MEASURE_TEMP 0x00000002
+#define BM_ANADIG_TEMPSENSE0_POWER_DOWN 0x00000001
+
+#define BP_ANADIG_TEMPSENSE1_RSVD0      16
+#define BM_ANADIG_TEMPSENSE1_RSVD0 0xFFFF0000
+#define BF_ANADIG_TEMPSENSE1_RSVD0(v) \
+	(((v) << 16) & BM_ANADIG_TEMPSENSE1_RSVD0)
+#define BP_ANADIG_TEMPSENSE1_MEASURE_FREQ      0
+#define BM_ANADIG_TEMPSENSE1_MEASURE_FREQ 0x0000FFFF
+#define BF_ANADIG_TEMPSENSE1_MEASURE_FREQ(v)  \
+	(((v) << 0) & BM_ANADIG_TEMPSENSE1_MEASURE_FREQ)
+
+/* define */
+#define PREFIX "ANATOP: "
+#define ANATOP_THERMAL_DRIVER_NAME	"Anatop Thermal"
+#define ANATOP_THERMAL_FILE_STATE		"state"
+#define ANATOP_THERMAL_FILE_TEMPERATURE	"temperature"
+#define ANATOP_THERMAL_FILE_TRIP_POINTS	"trip_points"
+#define ANATOP_THERMAL_FILE_COOLING_MODE	"cooling_mode"
+#define ANATOP_THERMAL_FILE_POLLING_FREQ	"polling_frequency"
+#define ANATOP_THERMAL_NOTIFY_TEMPERATURE	0x80
+#define ANATOP_THERMAL_NOTIFY_THRESHOLDS	0x81
+#define ANATOP_THERMAL_NOTIFY_DEVICES	0x82
+#define ANATOP_THERMAL_NOTIFY_CRITICAL	0xF0
+#define ANATOP_THERMAL_NOTIFY_HOT		0xF1
+#define ANATOP_THERMAL_MODE_ACTIVE	0x00
+#define ANATOP_THERMAL_MAX_ACTIVE	10
+#define ANATOP_THERMAL_MAX_LIMIT_STR_LEN 65
+#define ANATOP_TRIPS_CRITICAL	0x01
+#define ANATOP_TRIPS_HOT		0x02
+#define ANATOP_TRIPS_PASSIVE	0x04
+#define ANATOP_TRIPS_ACTIVE	    0x08
+#define ANATOP_TRIPS_DEVICES	0x10
+
+#define ANATOP_TRIPS_POINT_CRITICAL	0x0
+#define ANATOP_TRIPS_POINT_HOT	    0x1
+#define ANATOP_TRIPS_POINT_ACTIVE	0x2
+
+#define ANATOP_TRIPS_INIT      (ANATOP_TRIPS_CRITICAL | \
+		ANATOP_TRIPS_HOT | ANATOP_TRIPS_ACTIVE)
+
+#define _COMPONENT		ANATOP_THERMAL_COMPONENT
+#define KELVIN_OFFSET			273
+#define POLLING_FREQ			2000 /* 2s */
+#define TEMP_CRITICAL			373 /* 100 C*/
+#define TEMP_HOT				363 /* 90 C*/
+#define TEMP_ACTIVE				353 /* 80 C*/
+#define MEASURE_FREQ			327  /* 327 RTC clocks delay, 10ms */
+#define KELVIN_TO_CEL(t, off) (((t) - (off)))
+#define CEL_TO_KELVIN(t, off) (((t) + (off)))
+#define DEFAULT_RATIO			145
+#define DEFAULT_N25C			1541
+#define REG_VALUE_TO_CEL(ratio, raw) ((raw_n25c - raw) * 100 / ratio - 25)
+#define ANATOP_DEBUG			false
+#define THERMAL_FUSE_NAME		"/sys/fsl_otp/HW_OCOTP_ANA1"
+
+/* variables */
+unsigned long anatop_base;
+unsigned int ratio;
+unsigned int raw_25c, raw_hot, hot_temp, raw_n25c;
+static bool full_run = true;
+bool cooling_cpuhotplug;
+bool cooling_device_disable;
+unsigned long temperature_cooling;
+static const struct anatop_device_id thermal_device_ids[] = {
+	{ANATOP_THERMAL_HID},
+	{""},
+};
+
+/* functions */
+static int anatop_thermal_add(struct anatop_device *device);
+static int anatop_thermal_remove(struct platform_device *pdev);
+static int anatop_thermal_suspend(struct platform_device *pdev,
+		pm_message_t state);
+static int anatop_thermal_resume(struct platform_device *pdev);
+#ifdef CONFIG_FSL_OTP
+static int anatop_thermal_get_calibration_data(unsigned int *fuse);
+static int anatop_thermal_counting_ratio(unsigned int fuse_data);
+#endif
+
+/* struct */
+struct anatop_thermal_state {
+	u8 critical:1;
+	u8 hot:1;
+	u8 passive:1;
+	u8 active:1;
+	u8 reserved:4;
+	int active_index;
+};
+
+struct anatop_thermal_state_flags {
+	u8 valid:1;
+	u8 enabled:1;
+	u8 reserved:6;
+};
+
+struct anatop_thermal_critical {
+	struct anatop_thermal_state_flags flags;
+	unsigned long temperature;
+};
+
+struct anatop_thermal_hot {
+	struct anatop_thermal_state_flags flags;
+	unsigned long temperature;
+};
+
+struct anatop_thermal_passive {
+	struct anatop_thermal_state_flags flags;
+	unsigned long temperature;
+	unsigned long tc1;
+	unsigned long tc2;
+	unsigned long tsp;
+};
+
+struct anatop_thermal_active {
+	struct anatop_thermal_state_flags flags;
+	unsigned long temperature;
+};
+
+struct anatop_thermal_trips {
+	struct anatop_thermal_critical critical;
+	struct anatop_thermal_hot hot;
+	struct anatop_thermal_passive passive;
+	struct anatop_thermal_active active;
+};
+
+struct anatop_thermal_flags {
+	u8 cooling_mode:1;
+	u8 devices:1;
+	u8 reserved:6;
+};
+
+struct anatop_thermal {
+	struct anatop_device *device;
+	long temperature;
+	unsigned long last_temperature;
+	unsigned long polling_frequency;
+	volatile u8 zombie;
+	struct anatop_thermal_flags flags;
+	struct anatop_thermal_state state;
+	struct anatop_thermal_trips trips;
+	struct anatop_handle_list devices;
+	struct thermal_zone_device *thermal_zone;
+	int tz_enabled;
+	int kelvin_offset;
+	struct mutex lock;
+};
+
+/***************************************************************
+						Function
+****************************************************************/
+static int anatop_dump_temperature_register(void)
+{
+	if (!anatop_base) {
+		pr_info("anatop_base is not initialized!!!\n");
+		return -EINVAL;
+	}
+	pr_info("HW_ANADIG_TEMPSENSE0 = 0x%x\n",
+			__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0));
+	pr_info("HW_ANADIG_TEMPSENSE1 = 0x%x\n",
+			__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE1));
+	return 0;
+}
+static int anatop_thermal_get_temp(struct thermal_zone_device *thermal,
+				   unsigned long *temp)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+	unsigned int tmp;
+	unsigned int reg;
+	unsigned int i;
+
+	if (!tz)
+		return -EINVAL;
+#ifdef CONFIG_FSL_OTP
+	if (!ratio) {
+		anatop_thermal_get_calibration_data(&tmp);
+		*temp = KELVIN_TO_CEL(TEMP_ACTIVE, KELVIN_OFFSET);
+		return 0;
+	}
+#else
+	if (!cooling_device_disable)
+		pr_info("%s: can't get calibration data, disable cooling!!!\n", __func__);
+	cooling_device_disable = true;
+	ratio = DEFAULT_RATIO;
+#endif
+
+	tz->last_temperature = tz->temperature;
+
+	/* now we only using single measure, every time we measure
+	the temperature, we will power on/down the anadig module*/
+	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
+			anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
+			anatop_base + HW_ANADIG_ANA_MISC0_SET);
+
+	/* write measure freq */
+	reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE1);
+	reg &= ~BM_ANADIG_TEMPSENSE1_MEASURE_FREQ;
+	reg |= MEASURE_FREQ;
+	__raw_writel(reg, anatop_base + HW_ANADIG_TEMPSENSE1);
+
+	__raw_writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
+		anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+	__raw_writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP,
+		anatop_base + HW_ANADIG_TEMPSENSE0_SET);
+
+	tmp = 0;
+	/* read five times of temperature values to get average*/
+	for (i = 0; i < 5; i++) {
+		while ((__raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0)
+			& BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
+			msleep(10);
+		reg = __raw_readl(anatop_base + HW_ANADIG_TEMPSENSE0);
+		tmp += (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
+				>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
+		__raw_writel(BM_ANADIG_TEMPSENSE0_FINISHED,
+			anatop_base + HW_ANADIG_TEMPSENSE0_CLR);
+		if (ANATOP_DEBUG)
+			anatop_dump_temperature_register();
+	}
+
+	tmp = tmp / 5;
+	if (tmp <= raw_n25c)
+		tz->temperature = REG_VALUE_TO_CEL(ratio, tmp);
+	else
+		tz->temperature = -25;
+	pr_debug("Temperature is %lu C\n", tz->temperature);
+	/* power down anatop thermal sensor */
+	__raw_writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN,
+			anatop_base + HW_ANADIG_TEMPSENSE0_SET);
+	__raw_writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF,
+			anatop_base + HW_ANADIG_ANA_MISC0_CLR);
+
+	*temp = (cooling_device_disable && tz->temperature >= KELVIN_TO_CEL(TEMP_CRITICAL, KELVIN_OFFSET)) ?
+			KELVIN_TO_CEL(TEMP_CRITICAL - 1, KELVIN_OFFSET) : tz->temperature;
+
+	return 0;
+}
+
+static int anatop_thermal_set_cooling_mode(struct anatop_thermal *tz, int mode)
+{
+	return 0;
+}
+
+static int anatop_thermal_trips_update(struct anatop_thermal *tz, int flag)
+{
+	/* Critical Shutdown */
+	if (flag & ANATOP_TRIPS_CRITICAL) {
+		tz->trips.critical.temperature = TEMP_CRITICAL;
+		tz->trips.critical.flags.valid = 1;
+	}
+
+	/* Hot */
+	if (flag & ANATOP_TRIPS_HOT) {
+			tz->trips.hot.temperature = TEMP_HOT;
+			tz->trips.hot.flags.valid = 1;
+	}
+
+	/* Active */
+	if (flag & ANATOP_TRIPS_ACTIVE) {
+			tz->trips.active.temperature = TEMP_ACTIVE;
+			tz->trips.active.flags.valid = 1;
+	}
+
+	return 0;
+}
+
+static int anatop_thermal_get_trip_points(struct anatop_thermal *tz)
+{
+	int valid, ret;
+
+	ret = anatop_thermal_trips_update(tz, ANATOP_TRIPS_INIT);
+
+	valid = tz->trips.critical.flags.valid |
+		tz->trips.hot.flags.valid |
+		tz->trips.active.flags.valid;
+
+	if (!valid) {
+		printk(KERN_WARNING "No valid trip found\n");
+		ret = -ENODEV;
+	}
+	return ret;
+}
+
+static const char enabled[] = "kernel";
+static const char disabled[] = "user";
+static int anatop_thermal_get_mode(struct thermal_zone_device *thermal,
+				enum thermal_device_mode *mode)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (!tz)
+		return -EINVAL;
+
+	*mode = tz->tz_enabled ? THERMAL_DEVICE_ENABLED :
+		THERMAL_DEVICE_DISABLED;
+
+	return 0;
+}
+
+static int anatop_thermal_set_mode(struct thermal_zone_device *thermal,
+				enum thermal_device_mode mode)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+	int enable;
+
+	if (!tz)
+		return -EINVAL;
+
+	/* enable/disable thermal management from thermal driver */
+	if (mode == THERMAL_DEVICE_ENABLED)
+		enable = 1;
+	else if (mode == THERMAL_DEVICE_DISABLED)
+		enable = 0;
+	else
+		return -EINVAL;
+
+	if (enable != tz->tz_enabled) {
+		tz->tz_enabled = enable;
+		printk(KERN_INFO "%s anatop thermal control\n",
+			tz->tz_enabled ? enabled : disabled);
+		thermal_zone_device_update(tz->thermal_zone);
+	}
+	return 0;
+}
+
+static int anatop_thermal_get_trip_type(struct thermal_zone_device *thermal,
+				 int trip, enum thermal_trip_type *type)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (!tz || trip < 0)
+		return -EINVAL;
+
+	if (tz->trips.critical.flags.valid) {
+		if (!trip) {
+			*type = THERMAL_TRIP_CRITICAL;
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.hot.flags.valid) {
+		if (!trip) {
+			*type = THERMAL_TRIP_HOT;
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.passive.flags.valid) {
+		if (!trip) {
+			*type = THERMAL_TRIP_PASSIVE;
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.active.flags.valid) {
+		if (!trip) {
+			*type = THERMAL_TRIP_ACTIVE;
+			return 0;
+		}
+		trip--;
+	}
+
+	return -EINVAL;
+}
+
+static int anatop_thermal_set_trip_temp(struct thermal_zone_device *thermal,
+				 int trip, unsigned long *temp)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (!tz || trip < 0)
+		return -EINVAL;
+
+	switch (trip) {
+	case ANATOP_TRIPS_POINT_CRITICAL:
+		/* Critical Shutdown */
+		if (tz->trips.critical.flags.valid)
+			tz->trips.critical.temperature = CEL_TO_KELVIN(
+				*temp, tz->kelvin_offset);
+		break;
+	case ANATOP_TRIPS_POINT_HOT:
+		/* Hot */
+		if (tz->trips.hot.flags.valid)
+				tz->trips.hot.temperature = CEL_TO_KELVIN(
+				*temp, tz->kelvin_offset);
+		break;
+	case ANATOP_TRIPS_POINT_ACTIVE:
+		/* Active */
+		if (tz->trips.active.flags.valid)
+				tz->trips.active.temperature = CEL_TO_KELVIN(
+				*temp, tz->kelvin_offset);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int anatop_thermal_get_trip_temp(struct thermal_zone_device *thermal,
+				 int trip, unsigned long *temp)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (!tz || trip < 0)
+		return -EINVAL;
+	if (tz->trips.critical.flags.valid) {
+		if (!trip) {
+			*temp = KELVIN_TO_CEL(
+				tz->trips.critical.temperature,
+				tz->kelvin_offset);
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.hot.flags.valid) {
+		if (!trip) {
+			*temp = KELVIN_TO_CEL(
+				tz->trips.hot.temperature,
+				tz->kelvin_offset);
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.passive.flags.valid) {
+		if (!trip) {
+			*temp = KELVIN_TO_CEL(
+				tz->trips.passive.temperature,
+				tz->kelvin_offset);
+			return 0;
+		}
+		trip--;
+	}
+
+	if (tz->trips.active.flags.valid) {
+		if (!trip) {
+			*temp = KELVIN_TO_CEL(
+				tz->trips.active.temperature,
+				tz->kelvin_offset);
+			return 0;
+		}
+		trip--;
+	}
+
+	return -EINVAL;
+}
+
+static int anatop_thermal_get_crit_temp(struct thermal_zone_device *thermal,
+				unsigned long *temperature) {
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (tz->trips.critical.flags.valid) {
+		*temperature = KELVIN_TO_CEL(
+				tz->trips.critical.temperature,
+				tz->kelvin_offset);
+		return 0;
+	} else
+		return -EINVAL;
+}
+
+static int anatop_thermal_notify(struct thermal_zone_device *thermal, int trip,
+			   enum thermal_trip_type trip_type)
+{
+	int ret = 0;
+	u8 type = 0;
+	char mode = 'r';
+	const char *cmd = "reboot";
+	struct anatop_thermal *tz = thermal->devdata;
+
+	if (cooling_device_disable)
+		return ret;
+
+	if (trip_type == THERMAL_TRIP_CRITICAL) {
+		type = ANATOP_THERMAL_NOTIFY_CRITICAL;
+		printk(KERN_WARNING "thermal_notify: trip_critical reached!\n");
+		mxc_restart(mode, cmd);
+	} else if (trip_type == THERMAL_TRIP_HOT) {
+		printk(KERN_DEBUG "thermal_notify: trip_hot reached!\n");
+		type = ANATOP_THERMAL_NOTIFY_HOT;
+		/* if temperature increase, continue to detach secondary CPUs*/
+		if (tz->temperature > (temperature_cooling + 1)) {
+			if (cooling_cpuhotplug)
+				anatop_thermal_cpu_hotplug(false);
+			else
+				anatop_thermal_cpufreq_down();
+			temperature_cooling = tz->temperature;
+		}
+		if (ret)
+			printk(KERN_INFO "No secondary CPUs detached!\n");
+		full_run = false;
+	} else {
+		if (!full_run) {
+			temperature_cooling = 0;
+			if (cooling_cpuhotplug)
+				anatop_thermal_cpu_hotplug(true);
+			else
+				anatop_thermal_cpufreq_up();
+			if (ret)
+				printk(KERN_INFO "No secondary CPUs attached!\n");
+		}
+	}
+
+	return 0;
+}
+
+typedef int (*cb)(struct thermal_zone_device *, int,
+		  struct thermal_cooling_device *);
+static int anatop_thermal_cooling_device_cb(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev,
+					cb action)
+{
+	struct anatop_thermal *tz = thermal->devdata;
+	anatop_handle handle;
+	int i;
+	int trip = -1;
+	int result = 0;
+
+	if (tz->trips.critical.flags.valid)
+		trip++;
+
+	if (tz->trips.hot.flags.valid)
+		trip++;
+
+	if (tz->trips.passive.flags.valid) {
+		trip++;
+		result = action(thermal, trip, cdev);
+		if (result)
+			goto failed;
+	}
+
+	if (tz->trips.active.flags.valid) {
+		trip++;
+		result = action(thermal, trip, cdev);
+		if (result)
+			goto failed;
+	}
+
+	for (i = 0; i < tz->devices.count; i++) {
+		handle = tz->devices.handles[i];
+		result = action(thermal, -1, cdev);
+		if (result)
+			goto failed;
+	}
+
+failed:
+	return result;
+
+}
+
+static int
+anatop_thermal_bind_cooling_device(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev)
+{
+	return anatop_thermal_cooling_device_cb(thermal, cdev,
+				thermal_zone_bind_cooling_device);
+}
+
+static int
+anatop_thermal_unbind_cooling_device(struct thermal_zone_device *thermal,
+					struct thermal_cooling_device *cdev)
+{
+	return anatop_thermal_cooling_device_cb(thermal, cdev,
+				thermal_zone_unbind_cooling_device);
+}
+
+static struct thermal_zone_device_ops anatop_thermal_zone_ops = {
+	.bind = anatop_thermal_bind_cooling_device,
+	.unbind	= anatop_thermal_unbind_cooling_device,
+	.get_temp = anatop_thermal_get_temp,
+	.get_mode = anatop_thermal_get_mode,
+	.set_mode = anatop_thermal_set_mode,
+	.get_trip_type = anatop_thermal_get_trip_type,
+	.get_trip_temp = anatop_thermal_get_trip_temp,
+	.set_trip_temp = anatop_thermal_set_trip_temp,
+	.get_crit_temp = anatop_thermal_get_crit_temp,
+	.notify = anatop_thermal_notify,
+};
+
+static int anatop_thermal_register_thermal_zone(struct anatop_thermal *tz)
+{
+	int trips = 0;
+
+	if (tz->trips.critical.flags.valid)
+		trips++;
+
+	if (tz->trips.hot.flags.valid)
+		trips++;
+
+	if (tz->trips.passive.flags.valid)
+		trips++;
+
+	if (tz->trips.active.flags.valid)
+		trips++;
+
+	if (tz->trips.passive.flags.valid)
+		tz->thermal_zone =
+			thermal_zone_device_register("anatoptz", trips, tz,
+						     &anatop_thermal_zone_ops,
+						     tz->trips.passive.tc1,
+						     tz->trips.passive.tc2,
+						     tz->trips.passive.tsp*100,
+						     tz->polling_frequency*100);
+	else
+		tz->thermal_zone =
+			thermal_zone_device_register("anatoptz", trips, tz,
+						     &anatop_thermal_zone_ops,
+						     0, 0, 0,
+						     tz->polling_frequency);
+	tz->tz_enabled = 1;
+
+	printk(KERN_INFO "%s registered as thermal_zone%d\n",
+		 tz->device->name, tz->thermal_zone->id);
+	return 0;
+}
+
+static void anatop_thermal_unregister_thermal_zone(struct anatop_thermal *tz)
+{
+	sysfs_remove_link(&tz->device->dev.kobj, "thermal_zone");
+	sysfs_remove_link(&tz->thermal_zone->device.kobj, "device");
+	thermal_zone_device_unregister(tz->thermal_zone);
+	tz->thermal_zone = NULL;
+}
+
+/* --------------------------------------------------------------
+						Driver Interface
+   ------------------------------------------------------------- */
+static int anatop_thermal_get_info(struct anatop_thermal *tz)
+{
+	int result = 0;
+
+	if (!tz)
+		return -EINVAL;
+
+	/* Get trip points [_CRT, _PSV, etc.] (required) */
+	result = anatop_thermal_get_trip_points(tz);
+	if (result)
+		return result;
+
+	/* Set the cooling mode [_SCP] to active cooling (default) */
+	result = anatop_thermal_set_cooling_mode(tz,
+			ANATOP_THERMAL_MODE_ACTIVE);
+	if (!result)
+		tz->flags.cooling_mode = 1;
+
+	/* Get default polling frequency [_TZP] (optional) */
+	tz->polling_frequency = POLLING_FREQ;
+
+	return 0;
+}
+static int anatop_thermal_add(struct anatop_device *device)
+{
+	int result = 0;
+	struct anatop_thermal *tz = NULL;
+	struct thermal_cooling_device *cd = NULL;
+
+	if (!device)
+		return -EINVAL;
+
+	tz = kzalloc(sizeof(struct anatop_thermal), GFP_KERNEL);
+	if (!tz)
+		return -ENOMEM;
+
+	cd = kzalloc(sizeof(struct thermal_cooling_device), GFP_KERNEL);
+	if (!cd)
+		return -ENOMEM;
+
+	tz->device = device;
+	strcpy(device->name, ANATOP_THERMAL_DRIVER_NAME);
+	device->driver_data = tz;
+	mutex_init(&tz->lock);
+
+	result = anatop_thermal_get_info(tz);
+	if (result)
+		goto free_memory;
+
+	tz->kelvin_offset = KELVIN_OFFSET;
+
+	result = anatop_thermal_register_thermal_zone(tz);
+	if (result)
+		goto free_memory;
+
+	cd = thermal_cooling_device_register("i.mx_processor", device,
+						&imx_processor_cooling_ops);
+	if (IS_ERR(cd)) {
+		result = PTR_ERR(cd);
+		goto free_memory;
+	}
+	goto end;
+
+free_memory:
+	kfree(tz);
+	kfree(cd);
+end:
+	return result;
+}
+
+static int __init anatop_thermal_cooling_device_setup(char *str)
+{
+	if (!strcmp(str, "cpuhotplug")) {
+		cooling_cpuhotplug = 1;
+		pr_info("%s: cooling device set to hotplug!\n", __func__);
+	}
+	return 1;
+}
+__setup("cooling_device=", anatop_thermal_cooling_device_setup);
+
+static int __init anatop_thermal_cooling_device_disable(char *str)
+{
+	cooling_device_disable = 1;
+	pr_info("%s: cooling device is disabled!\n", __func__);
+	return 1;
+}
+__setup("no_cooling_device", anatop_thermal_cooling_device_disable);
+
+#ifdef CONFIG_FSL_OTP
+static int anatop_thermal_get_calibration_data(unsigned int *fuse)
+{
+	int ret = -EINVAL;
+	int fd;
+	char fuse_data[11];
+
+	if (fuse == NULL) {
+		printk(KERN_ERR "%s: NULL pointer!\n", __func__);
+		return ret;
+	}
+
+	fd = sys_open((const char __user __force *)THERMAL_FUSE_NAME,
+		O_RDWR, 0700);
+	if (fd < 0)
+		return ret;
+
+	sys_read(fd, fuse_data, sizeof(fuse_data));
+	sys_close(fd);
+	ret = 0;
+
+	*fuse = simple_strtol(fuse_data, NULL, 0);
+	pr_info("Thermal: fuse data 0x%x\n", *fuse);
+	anatop_thermal_counting_ratio(*fuse);
+
+	return ret;
+}
+
+static int anatop_thermal_counting_ratio(unsigned int fuse_data)
+{
+	int ret = -EINVAL;
+
+	if (fuse_data == 0 || fuse_data == 0xffffffff) {
+		pr_info("%s: invalid calibration data, disable cooling!!!\n", __func__);
+		cooling_device_disable = true;
+		ratio = DEFAULT_RATIO;
+		return ret;
+	}
+
+	ret = 0;
+	/* Fuse data layout:
+	 * [31:20] sensor value @ 25C
+	 * [19:8] sensor value of hot
+	 * [7:0] hot temperature value */
+	raw_25c = fuse_data >> 20;
+	raw_hot = (fuse_data & 0xfff00) >> 8;
+	hot_temp = fuse_data & 0xff;
+
+	ratio = ((raw_25c - raw_hot) * 100) / (hot_temp - 25);
+	raw_n25c = raw_25c + ratio / 2;
+
+	return ret;
+}
+#endif
+
+static int anatop_thermal_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	struct resource *res;
+	void __iomem *base;
+	struct anatop_device *device;
+
+	device = kzalloc(sizeof(*device), GFP_KERNEL);
+	if (!device) {
+		retval = -ENOMEM;
+		goto device_alloc_failed;
+	}
+
+	platform_set_drvdata(pdev, device);
+
+	/* ioremap the base address */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "No anatop base address provided!\n");
+		goto anatop_failed;
+	}
+
+	base = ioremap(res->start, res->end - res->start);
+	if (base == NULL) {
+		dev_err(&pdev->dev, "failed to remap anatop base address!\n");
+		goto anatop_failed;
+	}
+	anatop_base = (unsigned long)base;
+	raw_n25c = DEFAULT_N25C;
+
+	anatop_thermal_add(device);
+	anatop_thermal_cpufreq_init();
+	pr_info("%s: default cooling device is cpufreq!\n", __func__);
+
+	goto success;
+anatop_failed:
+	kfree(device);
+device_alloc_failed:
+success:
+
+	return retval;
+}
+
+static int anatop_thermal_remove(struct platform_device *pdev)
+{
+	struct anatop_thermal *tz;
+
+	if (!pdev)
+		return -EINVAL;
+
+	tz = platform_get_drvdata(pdev);
+
+	anatop_thermal_unregister_thermal_zone(tz);
+
+	mutex_destroy(&tz->lock);
+	kfree(tz);
+	return 0;
+}
+static int anatop_thermal_suspend(struct platform_device *pdev,
+		pm_message_t state)
+{
+	return 0;
+}
+static int anatop_thermal_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver anatop_thermal_driver_ldm = {
+	.driver = {
+		   .name = "anatop_thermal",
+		   .bus = &platform_bus_type,
+		   },
+	.probe = anatop_thermal_probe,
+	.remove = anatop_thermal_remove,
+	.suspend = anatop_thermal_suspend,
+	.resume = anatop_thermal_resume,
+};
+
+static int __init anatop_thermal_init(void)
+{
+	pr_debug("Anatop Thermal driver loading\n");
+	return platform_driver_register(&anatop_thermal_driver_ldm);
+}
+
+static void __exit anatop_thermal_exit(void)
+{
+	platform_driver_unregister(&anatop_thermal_driver_ldm);
+	pr_debug("Anatop Thermal driver successfully unloaded\n");
+}
+
+module_init(anatop_thermal_init);
+module_exit(anatop_thermal_exit);
diff --git a/drivers/thermal/thermal_sys.c b/drivers/thermal/thermal_sys.c
index 022bacb..c318fe5 100644
--- a/drivers/thermal/thermal_sys.c
+++ b/drivers/thermal/thermal_sys.c
@@ -218,6 +218,29 @@ trip_point_temp_show(struct device *dev, struct device_attribute *attr,
 }
 
 static ssize_t
+trip_point_temp_store(struct device *dev, struct device_attribute *attr,
+		      const char *buf, size_t count)
+{
+	struct thermal_zone_device *tz = to_thermal_zone(dev);
+	int trip, ret;
+	long temperature;
+
+	if (!tz->ops->set_trip_temp)
+		return -EPERM;
+
+	if (!sscanf(attr->attr.name, "trip_point_%d_temp", &trip))
+		return -EINVAL;
+
+	ret = sscanf(buf, "%lu", &temperature);
+
+	ret = tz->ops->set_trip_temp(tz, trip, &temperature);
+	if (ret)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t
 passive_store(struct device *dev, struct device_attribute *attr,
 		    const char *buf, size_t count)
 {
@@ -285,11 +308,14 @@ static DEVICE_ATTR(passive, S_IRUGO | S_IWUSR, passive_show, passive_store);
 
 static struct device_attribute trip_point_attrs[] = {
 	__ATTR(trip_point_0_type, 0444, trip_point_type_show, NULL),
-	__ATTR(trip_point_0_temp, 0444, trip_point_temp_show, NULL),
+	__ATTR(trip_point_0_temp, 0644, trip_point_temp_show,
+			trip_point_temp_store),
 	__ATTR(trip_point_1_type, 0444, trip_point_type_show, NULL),
-	__ATTR(trip_point_1_temp, 0444, trip_point_temp_show, NULL),
+	__ATTR(trip_point_1_temp, 0644, trip_point_temp_show,
+			trip_point_temp_store),
 	__ATTR(trip_point_2_type, 0444, trip_point_type_show, NULL),
-	__ATTR(trip_point_2_temp, 0444, trip_point_temp_show, NULL),
+	__ATTR(trip_point_2_temp, 0644, trip_point_temp_show,
+			trip_point_temp_store),
 	__ATTR(trip_point_3_type, 0444, trip_point_type_show, NULL),
 	__ATTR(trip_point_3_temp, 0444, trip_point_temp_show, NULL),
 	__ATTR(trip_point_4_type, 0444, trip_point_type_show, NULL),
diff --git a/include/linux/thermal.h b/include/linux/thermal.h
index 796f1ff..3e175e7 100644
--- a/include/linux/thermal.h
+++ b/include/linux/thermal.h
@@ -4,6 +4,7 @@
  *  Copyright (C) 2008  Intel Corp
  *  Copyright (C) 2008  Zhang Rui <rui.zhang@intel.com>
  *  Copyright (C) 2008  Sujith Thomas <sujith.thomas@intel.com>
+ *  Copyright (C) 2011 Freescale Semiconductor, Inc.
  *
  * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  *  This program is free software; you can redistribute it and/or modify
@@ -58,6 +59,8 @@ struct thermal_zone_device_ops {
 		enum thermal_trip_type *);
 	int (*get_trip_temp) (struct thermal_zone_device *, int,
 			      unsigned long *);
+	int (*set_trip_temp) (struct thermal_zone_device *, int,
+			      unsigned long *);
 	int (*get_crit_temp) (struct thermal_zone_device *, unsigned long *);
 	int (*notify) (struct thermal_zone_device *, int,
 		       enum thermal_trip_type);
-- 
1.7.9.7

