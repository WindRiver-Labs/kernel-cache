From 9e9cbd24c60c87f9afda12a79b876d783c84e6aa Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 15 Oct 2012 17:11:04 +0800
Subject: [PATCH 36/62] fsl_imx6: Add freescale On-Chip OTP memory support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                       |    1 +
 arch/arm/plat-mxc/devices/Kconfig               |    3 +
 arch/arm/plat-mxc/devices/Makefile              |    1 +
 arch/arm/plat-mxc/devices/platform-imx-ocotp.c  |  102 +++++++
 arch/arm/plat-mxc/include/mach/devices-common.h |    8 +
 drivers/char/Kconfig                            |   16 +
 drivers/char/Makefile                           |    1 +
 drivers/char/fsl_otp.c                          |  260 ++++++++++++++++
 drivers/char/fsl_otp.h                          |  369 +++++++++++++++++++++++
 drivers/char/regs-ocotp-v2.h                    |  239 +++++++++++++++
 drivers/char/regs-ocotp-v3.h                    |  367 ++++++++++++++++++++++
 include/linux/fsl_devices.h                     |    9 +
 12 files changed, 1376 insertions(+)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-ocotp.c
 create mode 100644 drivers/char/fsl_otp.c
 create mode 100644 drivers/char/fsl_otp.h
 create mode 100644 drivers/char/regs-ocotp-v2.h
 create mode 100644 drivers/char/regs-ocotp-v3.h

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index d1c51ab..e4205cc 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -32,6 +32,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_SNVS_RTC
 	select IMX_HAVE_PLATFORM_VIV_GPU
 	select IMX_HAVE_PLATFORM_SPI_IMX
+	select IMX_HAVE_PLATFORM_IMX_OCOTP
 	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index 9bc5895..44b26af 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -104,3 +104,6 @@ config IMX_HAVE_PLATFORM_IMX_SNVS_RTC
 
 config IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_OCOTP
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index a0e9cd6..cfd7f3d 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -36,4 +36,5 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_VIV_GPU) +=  platform-viv_gpu.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_OTG) += platform-fsl-usb2-otg.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_USB_WAKEUP) += platform-fsl-usb2-wakeup.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_SNVS_RTC) += platform-imx_snvs_rtc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_OCOTP) += platform-imx-ocotp.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL) += platform-imx-anatop-thermal.o
diff --git a/arch/arm/plat-mxc/devices/platform-imx-ocotp.c b/arch/arm/plat-mxc/devices/platform-imx-ocotp.c
new file mode 100644
index 0000000..01d0c48
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-ocotp.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#include <linux/fsl_devices.h>
+
+#ifdef CONFIG_SOC_IMX50
+#define BANK(a, b, c, d, e, f, g, h)   \
+	{\
+	("HW_OCOTP_"#a), ("HW_OCOTP_"#b), ("HW_OCOTP_"#c), ("HW_OCOTP_"#d), \
+	("HW_OCOTP_"#e), ("HW_OCOTP_"#f), ("HW_OCOTP_"#g), ("HW_OCOTP_"#h) \
+	}
+
+#define BANKS          (5)
+#define BANK_ITEMS     (8)
+static const char *bank_reg_desc[BANKS][BANK_ITEMS] = {
+	BANK(LOCK, CFG0, CFG1, CFG2, CFG3, CFG4, CFG5, CFG6),
+	BANK(MEM0, MEM1, MEM2, MEM3, MEM4, MEM5, GP0, GP1),
+	BANK(SCC0, SCC1, SCC2, SCC3, SCC4, SCC5, SCC6, SCC7),
+	BANK(SRK0, SRK1, SRK2, SRK3, SRK4, SRK5, SRK6, SRK7),
+	BANK(SJC0, SJC1, MAC0, MAC1, HWCAP0, HWCAP1, HWCAP2, SWCAP),
+};
+
+static const struct mxc_otp_platform_data imx50_otp_platform_data = {
+	.fuse_name = (char **)bank_reg_desc,
+	.clock_name = "ocotp_ctrl_ahb_clk",
+	.fuse_num = BANKS * BANK_ITEMS,
+};
+
+const struct imx_otp_data imx50_otp_data = {
+	.iobase = MX50_OCOTP_CTRL_BASE_ADDR,
+	.pdata = &imx50_otp_platform_data,
+};
+#undef BANK
+#undef BANKS
+#undef BANK_ITEMS
+#endif /* ifdef CONFIG_SOC_IMX50 */
+
+#ifdef CONFIG_SOC_IMX6Q
+#define BANK(a, b, c, d, e, f, g, h)   \
+	{\
+	("HW_OCOTP_"#a), ("HW_OCOTP_"#b), ("HW_OCOTP_"#c), ("HW_OCOTP_"#d), \
+	("HW_OCOTP_"#e), ("HW_OCOTP_"#f), ("HW_OCOTP_"#g), ("HW_OCOTP_"#h) \
+	}
+
+#define BANKS          (16)
+#define BANK_ITEMS     (8)
+static const char *bank_reg_desc[BANKS][BANK_ITEMS] = {
+	BANK(LOCK, CFG0, CFG1, CFG2, CFG3, CFG4, CFG5, CFG6),
+	BANK(MEM0, MEM1, MEM2, MEM3, MEM4, ANA0, ANA1, ANA2),
+	BANK(OTPMK0, SOTPMK1, OTPMK2, OTPMK3, OTPMK4, OTPMK5, OTPMK6, OTPMK7),
+	BANK(SRK0, SRK1, SRK2, SRK3, SRK4, SRK5, SRK6, SRK7),
+	BANK(RESP0, HSJC_RESP1, MAC0, MAC1, HDCP_KSV0, HDCP_KSV1, GP1, GP2),
+	BANK(DTCP_KEY0,  DTCP_KEY1,  DTCP_KEY2,  DTCP_KEY3,  DTCP_KEY4,  MISC_CONF,  FIELD_RETURN, SRK_REVOKE),
+	BANK(HDCP_KEY0,  HDCP_KEY1,  HDCP_KEY2,  HDCP_KEY3,  HDCP_KEY4,  HDCP_KEY5,  HDCP_KEY6,  HDCP_KEY7),
+	BANK(HDCP_KEY8,  HDCP_KEY9,  HDCP_KEY10, HDCP_KEY11, HDCP_KEY12, HDCP_KEY13, HDCP_KEY14, HDCP_KEY15),
+	BANK(HDCP_KEY16, HDCP_KEY17, HDCP_KEY18, HDCP_KEY19, HDCP_KEY20, HDCP_KEY21, HDCP_KEY22, HDCP_KEY23),
+	BANK(HDCP_KEY24, HDCP_KEY25, HDCP_KEY26, HDCP_KEY27, HDCP_KEY28, HDCP_KEY29, HDCP_KEY30, HDCP_KEY31),
+	BANK(HDCP_KEY32, HDCP_KEY33, HDCP_KEY34, HDCP_KEY35, HDCP_KEY36, HDCP_KEY37, HDCP_KEY38, HDCP_KEY39),
+	BANK(HDCP_KEY40, HDCP_KEY41, HDCP_KEY42, HDCP_KEY43, HDCP_KEY44, HDCP_KEY45, HDCP_KEY46, HDCP_KEY47),
+	BANK(HDCP_KEY48, HDCP_KEY49, HDCP_KEY50, HDCP_KEY51, HDCP_KEY52, HDCP_KEY53, HDCP_KEY54, HDCP_KEY55),
+	BANK(HDCP_KEY56, HDCP_KEY57, HDCP_KEY58, HDCP_KEY59, HDCP_KEY60, HDCP_KEY61, HDCP_KEY62, HDCP_KEY63),
+	BANK(HDCP_KEY64, HDCP_KEY65, HDCP_KEY66, HDCP_KEY67, HDCP_KEY68, HDCP_KEY69, HDCP_KEY70, HDCP_KEY71),
+	BANK(CRC0, CRC1, CRC2, CRC3, CRC4, CRC5, CRC6, CRC7),
+};
+
+static const struct mxc_otp_platform_data imx6q_otp_platform_data = {
+	.fuse_name = (char **)bank_reg_desc,
+	.clock_name = "iim_clk",
+	.fuse_num = BANKS * BANK_ITEMS,
+};
+
+const struct imx_otp_data imx6q_otp_data = {
+	.iobase = OCOTP_BASE_ADDR,
+	.pdata = (struct mxc_otp_platform_data *)&imx6q_otp_platform_data,
+};
+#undef BANK
+#undef BANKS
+#undef BANK_ITEMS
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+
+struct platform_device *__init imx_add_otp(
+		const struct imx_otp_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_16 - 1,
+			.flags = IORESOURCE_MEM,
+		}
+	};
+
+	return imx_add_platform_device("imx-ocotp", 0,
+			res, ARRAY_SIZE(res), data->pdata,
+			sizeof(struct mxc_otp_platform_data));
+}
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index ff47131..83b69e0 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -434,3 +434,11 @@ struct imx_anatop_thermal_imx_data {
 struct platform_device *__init imx_add_anatop_thermal_imx(
 		const struct imx_anatop_thermal_imx_data *data,
 		const struct anatop_thermal_platform_data *pdata);
+
+struct imx_otp_data {
+	resource_size_t iobase;
+	struct mxc_otp_platform_data *pdata;
+};
+
+struct platform_device *__init imx_add_otp(
+		const struct imx_otp_data *data);
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index ee94686..a16c927 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -94,6 +94,22 @@ config BFIN_OTP_WRITE_ENABLE
 
 	  If unsure, say N.
 
+config FSL_OTP
+	tristate "Freescale On-Chip OTP Memory Support"
+	depends on (ARCH_MX23 || ARCH_MX28 || ARCH_MX50 || ARCH_MX6)
+	default n
+	help
+	  If you say Y here, you will get support for a character device
+	  interface into the One Time Programmable memory pages that are
+	  stored on the iMX23/28/50 processor.  This will not get you access
+	  to the secure memory pages however.  You will need to write your
+	  own secure code and reader for that.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called fsl_otp.
+
+	  If unsure, it is safe to say Y.
+
 config PRINTER
 	tristate "Parallel printer support"
 	depends on PARPORT
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 0dc5d7c..2f843ba 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_IBM_BSR)		+= bsr.o
 obj-$(CONFIG_SGI_MBCS)		+= mbcs.o
 obj-$(CONFIG_BFIN_OTP)		+= bfin-otp.o
+obj-$(CONFIG_FSL_OTP)		+= fsl_otp.o
 
 obj-$(CONFIG_PRINTER)		+= lp.o
 
diff --git a/drivers/char/fsl_otp.c b/drivers/char/fsl_otp.c
new file mode 100644
index 0000000..05ad55e
--- /dev/null
+++ b/drivers/char/fsl_otp.c
@@ -0,0 +1,260 @@
+/*
+ * Freescale On-Chip OTP driver
+ *
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/fcntl.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+
+#include "fsl_otp.h"
+
+static DEFINE_MUTEX(otp_mutex);
+static struct kobject *otp_kobj;
+static struct attribute **attrs;
+static struct kobj_attribute *kattr;
+static struct attribute_group attr_group;
+static struct mxc_otp_platform_data *otp_data;
+static struct clk *otp_clk;
+
+static inline unsigned int get_reg_index(struct kobj_attribute *tmp)
+{
+	return tmp - kattr;
+}
+
+static int otp_wait_busy(u32 flags)
+{
+	int count;
+	u32 c;
+
+	for (count = 10000; count >= 0; count--) {
+		c = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+		if (!(c & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR | flags)))
+			break;
+		cpu_relax();
+	}
+	if (count < 0)
+		return -ETIMEDOUT;
+	return 0;
+}
+
+static ssize_t otp_show(struct kobject *kobj, struct kobj_attribute *attr,
+		      char *buf)
+{
+	unsigned int index = get_reg_index(attr);
+	u32 value = 0;
+
+	/* sanity check */
+	if (index >= otp_data->fuse_num)
+		return 0;
+
+	mutex_lock(&otp_mutex);
+
+	if (otp_read_prepare(otp_data)) {
+		mutex_unlock(&otp_mutex);
+		return 0;
+	}
+	value = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CUSTn(index));
+	otp_read_post(otp_data);
+
+	mutex_unlock(&otp_mutex);
+	return sprintf(buf, "0x%x\n", value);
+}
+
+static int otp_write_bits(int addr, u32 data, u32 magic)
+{
+	u32 c; /* for control register */
+
+	/* init the control register */
+	c = __raw_readl(REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+	c &= ~BM_OCOTP_CTRL_ADDR;
+	c |= BF(addr, OCOTP_CTRL_ADDR);
+	c |= BF(magic, OCOTP_CTRL_WR_UNLOCK);
+	__raw_writel(c, REGS_OCOTP_BASE + HW_OCOTP_CTRL);
+
+	/* init the data register */
+	__raw_writel(data, REGS_OCOTP_BASE + HW_OCOTP_DATA);
+	otp_wait_busy(0);
+
+	mdelay(2); /* Write Postamble */
+	return 0;
+}
+
+static ssize_t otp_store(struct kobject *kobj, struct kobj_attribute *attr,
+		       const char *buf, size_t count)
+{
+	unsigned int index = get_reg_index(attr);
+	int value;
+
+	/* sanity check */
+	if (index >= otp_data->fuse_num)
+		return 0;
+
+	sscanf(buf, "0x%x", &value);
+
+	mutex_lock(&otp_mutex);
+	if (otp_write_prepare(otp_data)) {
+		mutex_unlock(&otp_mutex);
+		return 0;
+	}
+	otp_write_bits(index, value, 0x3e77);
+	otp_write_post(otp_data);
+	mutex_unlock(&otp_mutex);
+	return count;
+}
+
+static void free_otp_attr(void)
+{
+	kfree(attrs);
+	attrs = NULL;
+
+	kfree(kattr);
+	kattr = NULL;
+}
+
+static int __init alloc_otp_attr(struct mxc_otp_platform_data *pdata)
+{
+	int i;
+
+	otp_data = pdata; /* get private data */
+
+	/* The last one is NULL, which is used to detect the end */
+	attrs = kzalloc((otp_data->fuse_num + 1) * sizeof(attrs[0]),
+			GFP_KERNEL);
+	kattr = kzalloc(otp_data->fuse_num * sizeof(struct kobj_attribute),
+			GFP_KERNEL);
+
+	if (!attrs || !kattr)
+		goto error_out;
+
+	for (i = 0; i < otp_data->fuse_num; i++) {
+		kattr[i].attr.name = pdata->fuse_name[i];
+		kattr[i].attr.mode = 0600;
+		kattr[i].show  = otp_show;
+		kattr[i].store = otp_store;
+
+		attrs[i] = &kattr[i].attr;
+	}
+	memset(&attr_group, 0, sizeof(attr_group));
+	attr_group.attrs = attrs;
+	return 0;
+
+error_out:
+	free_otp_attr();
+	return -ENOMEM;
+}
+
+static int __devinit fsl_otp_probe(struct platform_device *pdev)
+{
+	int retval;
+	struct mxc_otp_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL)
+		return -ENODEV;
+
+	/* Enable clock */
+	if (pdata->clock_name) {
+		otp_clk = clk_get(&pdev->dev, pdata->clock_name);
+		clk_enable(otp_clk);
+	}
+
+	retval = alloc_otp_attr(pdata);
+	if (retval)
+		return retval;
+
+	retval = map_ocotp_addr(pdev);
+	if (retval)
+		goto error;
+
+	otp_kobj = kobject_create_and_add("fsl_otp", NULL);
+	if (!otp_kobj) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	retval = sysfs_create_group(otp_kobj, &attr_group);
+	if (retval)
+		goto error;
+
+	mutex_init(&otp_mutex);
+	return 0;
+error:
+	kobject_put(otp_kobj);
+	otp_kobj = NULL;
+	free_otp_attr();
+	unmap_ocotp_addr();
+	return retval;
+}
+
+static int otp_remove(struct platform_device *pdev)
+{
+	struct mxc_otp_platform_data *pdata;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL)
+		return -ENODEV;
+
+	kobject_put(otp_kobj);
+	otp_kobj = NULL;
+
+	free_otp_attr();
+	unmap_ocotp_addr();
+
+	if (pdata->clock_name) {
+		clk_disable(otp_clk);
+		clk_put(otp_clk);
+	}
+
+	return 0;
+}
+
+static struct platform_driver ocotp_driver = {
+	.probe		= fsl_otp_probe,
+	.remove		= otp_remove,
+	.driver		= {
+		.name   = "imx-ocotp",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init fsl_otp_init(void)
+{
+	return platform_driver_register(&ocotp_driver);
+}
+
+static void __exit fsl_otp_exit(void)
+{
+	platform_driver_unregister(&ocotp_driver);
+}
+module_init(fsl_otp_init);
+module_exit(fsl_otp_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Huang Shijie <b32955@freescale.com>");
+MODULE_DESCRIPTION("Common driver for OTP controller");
diff --git a/drivers/char/fsl_otp.h b/drivers/char/fsl_otp.h
new file mode 100644
index 0000000..5f779e5
--- /dev/null
+++ b/drivers/char/fsl_otp.h
@@ -0,0 +1,369 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __FREESCALE_OTP__
+#define __FREESCALE_OTP__
+
+#define log(a, ...) printk(KERN_INFO "[ %s : %.3d ] "a"\n", \
+			__func__, __LINE__,  ## __VA_ARGS__)
+
+static u32 otp_voltage_saved;
+struct regulator *regu;
+
+static int otp_wait_busy(u32 flags);
+
+/* IMX23 and IMX28 share most of the defination ========================= */
+#if (defined(CONFIG_ARCH_MX23) || defined(CONFIG_ARCH_MX28))
+
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/device.h>
+#include <mach/regs-ocotp.h>
+#include <mach/regs-power.h>
+
+#if defined(CONFIG_ARCH_MX23)
+#include <mach/mx23.h>
+#else
+#include <mach/mx28.h>
+#endif
+
+#define REGS_OCOTP_BASE		(IO_ADDRESS(OCOTP_PHYS_ADDR))
+#define BF(value, field)	(((value) << BP_##field) & BM_##field)
+
+static unsigned long otp_hclk_saved;
+
+/* open the bank for the imx23/imx28 */
+static int otp_read_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	int r;
+
+	/* [1] set the HCLK */
+	/* [2] check BUSY and ERROR bit */
+	r = otp_wait_busy(0);
+	if (r < 0)
+		goto error;
+
+	/* [3] open bank */
+	__raw_writel(BM_OCOTP_CTRL_RD_BANK_OPEN,
+			REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+	udelay(10);
+
+	/* [4] wait for BUSY */
+	r = otp_wait_busy(0);
+	return 0;
+error:
+	return r;
+}
+
+static int otp_read_post(struct mxc_otp_platform_data *otp_data)
+{
+	/* [5] close bank */
+	__raw_writel(BM_OCOTP_CTRL_RD_BANK_OPEN,
+			REGS_OCOTP_BASE + HW_OCOTP_CTRL_CLR);
+	return 0;
+}
+
+static int otp_write_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	struct clk *hclk;
+	int err = 0;
+
+	/* [1] HCLK to 24MHz. */
+	hclk = clk_get(NULL, otp_data->clock_name);
+	if (IS_ERR(hclk)) {
+		err = PTR_ERR(hclk);
+		goto out;
+	}
+	/*
+	   WARNING  ACHTUNG  UWAGA
+
+	   the code below changes HCLK clock rate to 24M. This is
+	   required to write OTP bits (7.2.2 in STMP378x Target
+	   Specification), and might affect LCD operation, for example.
+	   Moreover, this hacky code changes VDDIO to 2.8V; and resto-
+	   res it only on otp_close(). This may affect... anything.
+
+	   You are warned now.
+	 */
+	otp_hclk_saved = clk_get_rate(hclk);
+	clk_set_rate(hclk, 24000);
+
+	/* [2] The voltage is set to 2.8V */
+	if (otp_data->regulator_name) {
+		regu = regulator_get(NULL, otp_data->regulator_name);
+		otp_voltage_saved = regulator_get_voltage(regu);
+		regulator_set_voltage(regu, otp_data->min_volt, otp_data->max_volt);
+	}
+
+	/* [3] wait for BUSY and ERROR */
+	err = otp_wait_busy(BM_OCOTP_CTRL_RD_BANK_OPEN);
+out:
+	return err;
+}
+
+static int otp_write_post(struct mxc_otp_platform_data *otp_data)
+{
+	struct clk *hclk;
+
+	hclk = clk_get(NULL, otp_data->clock_name);
+
+	/* restore the clock and voltage */
+	clk_set_rate(hclk, otp_hclk_saved);
+	if (otp_data->regulator_name)
+		regulator_set_voltage(regu, otp_voltage_saved, otp_voltage_saved);
+	otp_wait_busy(0);
+
+	/* reset */
+	__raw_writel(BM_OCOTP_CTRL_RELOAD_SHADOWS,
+			REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+	otp_wait_busy(BM_OCOTP_CTRL_RELOAD_SHADOWS);
+	return 0;
+}
+
+static int __init map_ocotp_addr(struct platform_device *pdev)
+{
+	return 0;
+}
+static void unmap_ocotp_addr(void)
+{
+}
+
+#elif defined(CONFIG_ARCH_MX5) /* IMX5 below ============================= */
+
+#include <mach/hardware.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include "regs-ocotp-v2.h"
+
+static void *otp_base;
+#define REGS_OCOTP_BASE		((unsigned long)otp_base)
+#define HW_OCOTP_CUSTn(n)	(0x00000030 + (n) * 0x10)
+#define BF(value, field) 	(((value) << BP_##field) & BM_##field)
+
+#define DEF_RELEX	(15)	/* > 10.5ns */
+
+static int set_otp_timing(struct mxc_otp_platform_data *otp_data)
+{
+	struct clk *apb_clk;
+	unsigned long clk_rate = 0;
+	unsigned long relex, sclk_count, rd_busy;
+	u32 timing = 0;
+
+	if (!otp_data->clock_name)
+		return -1;
+
+	/* [1] get the clock. It needs the AHB clock,though doc writes APB.*/
+	apb_clk = clk_get(NULL, otp_data->clock_name);
+	if (IS_ERR(apb_clk)) {
+		log("we can not find the clock");
+		return -1;
+	}
+	clk_rate = clk_get_rate(apb_clk);
+
+	/* do optimization for too many zeros */
+	relex	= clk_rate / (1000000000 / DEF_RELEX) + 1;
+	sclk_count = clk_rate / (1000000000 / 5000) + 1 + DEF_RELEX;
+	rd_busy	= clk_rate / (1000000000 / 300)	+ 1;
+
+	timing = BF(relex, OCOTP_TIMING_RELAX);
+	timing |= BF(sclk_count, OCOTP_TIMING_SCLK_COUNT);
+	timing |= BF(rd_busy, OCOTP_TIMING_RD_BUSY);
+
+	__raw_writel(timing, REGS_OCOTP_BASE + HW_OCOTP_TIMING);
+	return 0;
+}
+
+/* IMX5 does not need to open the bank anymore */
+static int otp_read_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	return set_otp_timing(otp_data);
+}
+static int otp_read_post(struct mxc_otp_platform_data *otp_data)
+{
+	return 0;
+}
+
+static int otp_write_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	int ret = 0;
+
+	/* [1] set timing */
+	ret = set_otp_timing(otp_data);
+	if (ret)
+		return ret;
+
+	/* [2] wait */
+	otp_wait_busy(0);
+	return 0;
+}
+static int otp_write_post(struct mxc_otp_platform_data *otp_data)
+{
+	/* Reload all the shadow registers */
+	__raw_writel(BM_OCOTP_CTRL_RELOAD_SHADOWS,
+			REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+	udelay(1);
+	otp_wait_busy(BM_OCOTP_CTRL_RELOAD_SHADOWS);
+	return 0;
+}
+
+static int __init map_ocotp_addr(struct platform_device *pdev)
+{
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	otp_base = ioremap(res->start, SZ_8K);
+	if (!otp_base) {
+		log("Can not remap the OTP iomem!");
+		return -1;
+	}
+	return 0;
+}
+
+static void unmap_ocotp_addr(void)
+{
+	iounmap(otp_base);
+	otp_base = NULL;
+}
+
+#elif defined(CONFIG_ARCH_MX6) /* IMX6 below ============================= */
+
+#include <mach/hardware.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+#include "regs-ocotp-v3.h"
+
+static void *otp_base;
+
+#define REGS_OCOTP_BASE		((unsigned long)otp_base)
+#define HW_OCOTP_CUSTn(n)	(0x00000400 + (n) * 0x10)
+#define BF(value, field) 	(((value) << BP_##field) & BM_##field)
+
+#define DEF_RELEX	(20)	/* > 16.5ns */
+
+static int set_otp_timing(struct mxc_otp_platform_data *otp_data)
+{
+	struct clk *ocotp_clk;
+	unsigned long clk_rate = 0;
+	unsigned long strobe_read, relex, strobe_prog;
+	u32 timing = 0;
+
+	/* [1] get the clock. It needs the IPG clock,though doc writes IPG.*/
+	if (!otp_data->clock_name)
+		return -1;
+
+	ocotp_clk = clk_get(NULL, otp_data->clock_name);
+	if (IS_ERR(ocotp_clk)) {
+		log("we can not find the clock");
+		return -1;
+	}
+	clk_rate = clk_get_rate(ocotp_clk);
+
+	/* do optimization for too many zeros */
+	relex = clk_rate / (1000000000 / DEF_RELEX) - 1;
+	strobe_prog = clk_rate / (1000000000 / 10000) + 2 * (DEF_RELEX + 1) - 1;
+	strobe_read = clk_rate / (1000000000 / 40) + 2 * (DEF_RELEX + 1) - 1;
+
+	timing = BF(relex, OCOTP_TIMING_RELAX);
+	timing |= BF(strobe_read, OCOTP_TIMING_STROBE_READ);
+	timing |= BF(strobe_prog, OCOTP_TIMING_STROBE_PROG);
+
+	__raw_writel(timing, REGS_OCOTP_BASE + HW_OCOTP_TIMING);
+
+	return 0;
+}
+
+/* IMX5 does not need to open the bank anymore */
+static int otp_read_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	int ret = 0;
+	/* [1] set the HCLK */
+	set_otp_timing(otp_data);
+
+	/* [2] check BUSY and ERROR bit */
+	ret = otp_wait_busy(0);
+
+	return ret;
+}
+static int otp_read_post(struct mxc_otp_platform_data *otp_data)
+{
+	return 0;
+}
+
+static int otp_write_prepare(struct mxc_otp_platform_data *otp_data)
+{
+	int ret = 0;
+
+	/* [1] set timing */
+	ret = set_otp_timing(otp_data);
+	if (ret)
+		return ret;
+
+	/* [2] wait */
+	ret = otp_wait_busy(0);
+	if (ret < 0)
+		return ret;
+
+	/* [3] The voltage is set to 2.8V, if needed */
+	if (otp_data->regulator_name) {
+		regu = regulator_get(NULL, otp_data->regulator_name);
+		otp_voltage_saved = regulator_get_voltage(regu);
+		regulator_set_voltage(regu, otp_data->min_volt, otp_data->max_volt);
+		/* [4] wait for BUSY and ERROR */
+		ret = otp_wait_busy(0);
+
+	}
+
+	return ret;
+}
+static int otp_write_post(struct mxc_otp_platform_data *otp_data)
+{
+	/* restore the clock and voltage */
+	if (otp_data->regulator_name) {
+		regulator_set_voltage(regu, otp_voltage_saved, otp_voltage_saved);
+		otp_wait_busy(0);
+	}
+
+	/* Reload all the shadow registers */
+	__raw_writel(BM_OCOTP_CTRL_RELOAD_SHADOWS,
+			REGS_OCOTP_BASE + HW_OCOTP_CTRL_SET);
+	udelay(1);
+	otp_wait_busy(BM_OCOTP_CTRL_RELOAD_SHADOWS);
+
+	return 0;
+}
+
+static int __init map_ocotp_addr(struct platform_device *pdev)
+{
+	struct resource *res;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	otp_base = ioremap(res->start, SZ_8K);
+	if (!otp_base) {
+		log("Can not remap the OTP iomem!");
+		return -1;
+	}
+	return 0;
+}
+
+static void unmap_ocotp_addr(void)
+{
+	iounmap(otp_base);
+	otp_base = NULL;
+}
+#endif /* CONFIG_ARCH_MX6 */
+
+#endif
diff --git a/drivers/char/regs-ocotp-v2.h b/drivers/char/regs-ocotp-v2.h
new file mode 100644
index 0000000..559c8e7
--- /dev/null
+++ b/drivers/char/regs-ocotp-v2.h
@@ -0,0 +1,239 @@
+/*
+ * Freescale OCOTP Register Definitions
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.12
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___OCOTP_H
+#define __ARCH_ARM___OCOTP_H
+
+
+#define HW_OCOTP_CTRL	(0x00000000)
+#define HW_OCOTP_CTRL_SET	(0x00000004)
+#define HW_OCOTP_CTRL_CLR	(0x00000008)
+#define HW_OCOTP_CTRL_TOG	(0x0000000c)
+
+#define BP_OCOTP_CTRL_WR_UNLOCK      16
+#define BM_OCOTP_CTRL_WR_UNLOCK 0xFFFF0000
+#define BF_OCOTP_CTRL_WR_UNLOCK(v) \
+	(((v) << 16) & BM_OCOTP_CTRL_WR_UNLOCK)
+#define BV_OCOTP_CTRL_WR_UNLOCK__KEY 0x3E77
+#define BP_OCOTP_CTRL_RSRVD2      14
+#define BM_OCOTP_CTRL_RSRVD2 0x0000C000
+#define BF_OCOTP_CTRL_RSRVD2(v)  \
+	(((v) << 14) & BM_OCOTP_CTRL_RSRVD2)
+#define BM_OCOTP_CTRL_RELOAD_SHADOWS 0x00002000
+#define BM_OCOTP_CTRL_RD_BANK_OPEN 0x00001000
+#define BP_OCOTP_CTRL_RSRVD1      10
+#define BM_OCOTP_CTRL_RSRVD1 0x00000C00
+#define BF_OCOTP_CTRL_RSRVD1(v)  \
+	(((v) << 10) & BM_OCOTP_CTRL_RSRVD1)
+#define BM_OCOTP_CTRL_ERROR 0x00000200
+#define BM_OCOTP_CTRL_BUSY 0x00000100
+#define BP_OCOTP_CTRL_RSRVD0      6
+#define BM_OCOTP_CTRL_RSRVD0 0x000000C0
+#define BF_OCOTP_CTRL_RSRVD0(v)  \
+	(((v) << 6) & BM_OCOTP_CTRL_RSRVD0)
+#define BP_OCOTP_CTRL_ADDR      0
+#define BM_OCOTP_CTRL_ADDR 0x0000003F
+#define BF_OCOTP_CTRL_ADDR(v)  \
+	(((v) << 0) & BM_OCOTP_CTRL_ADDR)
+
+#define HW_OCOTP_TIMING	(0x00000010)
+
+#define BP_OCOTP_TIMING_RSRVD0      22
+#define BM_OCOTP_TIMING_RSRVD0 0xFFC00000
+#define BF_OCOTP_TIMING_RSRVD0(v) \
+	(((v) << 22) & BM_OCOTP_TIMING_RSRVD0)
+#define BP_OCOTP_TIMING_RD_BUSY      16
+#define BM_OCOTP_TIMING_RD_BUSY 0x003F0000
+#define BF_OCOTP_TIMING_RD_BUSY(v)  \
+	(((v) << 16) & BM_OCOTP_TIMING_RD_BUSY)
+#define BP_OCOTP_TIMING_RELAX      12
+#define BM_OCOTP_TIMING_RELAX 0x0000F000
+#define BF_OCOTP_TIMING_RELAX(v)  \
+	(((v) << 12) & BM_OCOTP_TIMING_RELAX)
+#define BP_OCOTP_TIMING_SCLK_COUNT      0
+#define BM_OCOTP_TIMING_SCLK_COUNT 0x00000FFF
+#define BF_OCOTP_TIMING_SCLK_COUNT(v)  \
+	(((v) << 0) & BM_OCOTP_TIMING_SCLK_COUNT)
+
+#define HW_OCOTP_DATA	(0x00000020)
+
+#define BP_OCOTP_DATA_DATA      0
+#define BM_OCOTP_DATA_DATA 0xFFFFFFFF
+#define BF_OCOTP_DATA_DATA(v)   (v)
+
+#define HW_OCOTP_LOCK	(0x00000030)
+
+#define BP_OCOTP_LOCK_UNALLOCATED      26
+#define BM_OCOTP_LOCK_UNALLOCATED 0xFC000000
+#define BF_OCOTP_LOCK_UNALLOCATED(v) \
+	(((v) << 26) & BM_OCOTP_LOCK_UNALLOCATED)
+#define BM_OCOTP_LOCK_PIN 0x02000000
+#define BM_OCOTP_LOCK_DCPKEY_ALT 0x01000000
+#define BM_OCOTP_LOCK_SCC_ALT 0x00800000
+#define BM_OCOTP_LOCK_DCPKEY 0x00400000
+#define BM_OCOTP_LOCK_SWCAP_SHADOW 0x00200000
+#define BM_OCOTP_LOCK_SWCAP 0x00100000
+#define BM_OCOTP_LOCK_HWCAP_SHADOW 0x00080000
+#define BM_OCOTP_LOCK_HWCAP 0x00040000
+#define BM_OCOTP_LOCK_MAC_SHADOW 0x00020000
+#define BM_OCOTP_LOCK_MAC 0x00010000
+#define BM_OCOTP_LOCK_SJC_SHADOW 0x00008000
+#define BM_OCOTP_LOCK_SJC 0x00004000
+#define BM_OCOTP_LOCK_SRK_SHADOW 0x00002000
+#define BM_OCOTP_LOCK_SRK 0x00001000
+#define BM_OCOTP_LOCK_SCC_SHADOW 0x00000800
+#define BM_OCOTP_LOCK_SCC 0x00000400
+#define BM_OCOTP_LOCK_GP_SHADOW 0x00000200
+#define BM_OCOTP_LOCK_GP 0x00000100
+#define BM_OCOTP_LOCK_MEM_MISC_SHADOW 0x00000080
+#define BM_OCOTP_LOCK_MEM_TRIM_SHADOW 0x00000040
+#define BM_OCOTP_LOCK_MEM_TRIM 0x00000020
+#define BM_OCOTP_LOCK_CFG_MISC_SHADOW 0x00000010
+#define BM_OCOTP_LOCK_CFG_BOOT_SHADOW 0x00000008
+#define BM_OCOTP_LOCK_CFG_BOOT 0x00000004
+#define BM_OCOTP_LOCK_CFG_TESTER_SHADOW 0x00000002
+#define BM_OCOTP_LOCK_CFG_TESTER 0x00000001
+
+/*
+ *  multi-register-define name HW_OCOTP_CFGn
+ *              base 0x00000040
+ *              count 7
+ *              offset 0x10
+ */
+#define HW_OCOTP_CFGn(n)	(0x00000040 + (n) * 0x10)
+#define BP_OCOTP_CFGn_BITS      0
+#define BM_OCOTP_CFGn_BITS 0xFFFFFFFF
+#define BF_OCOTP_CFGn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_MEMn
+ *              base 0x000000B0
+ *              count 6
+ *              offset 0x10
+ */
+#define HW_OCOTP_MEMn(n)	(0x000000b0 + (n) * 0x10)
+#define BP_OCOTP_MEMn_BITS      0
+#define BM_OCOTP_MEMn_BITS 0xFFFFFFFF
+#define BF_OCOTP_MEMn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_GPn
+ *              base 0x00000110
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_GPn(n)	(0x00000110 + (n) * 0x10)
+#define BP_OCOTP_GPn_BITS      0
+#define BM_OCOTP_GPn_BITS 0xFFFFFFFF
+#define BF_OCOTP_GPn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_SCCn
+ *              base 0x00000130
+ *              count 8
+ *              offset 0x10
+ */
+#define HW_OCOTP_SCCn(n)	(0x00000130 + (n) * 0x10)
+#define BP_OCOTP_SCCn_BITS      0
+#define BM_OCOTP_SCCn_BITS 0xFFFFFFFF
+#define BF_OCOTP_SCCn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_SRKn
+ *              base 0x000001B0
+ *              count 8
+ *              offset 0x10
+ */
+#define HW_OCOTP_SRKn(n)	(0x000001b0 + (n) * 0x10)
+#define BP_OCOTP_SRKn_BITS      0
+#define BM_OCOTP_SRKn_BITS 0xFFFFFFFF
+#define BF_OCOTP_SRKn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_SJC_RESPn
+ *              base 0x00000230
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_SJC_RESPn(n)	(0x00000230 + (n) * 0x10)
+#define BP_OCOTP_SJC_RESPn_BITS      0
+#define BM_OCOTP_SJC_RESPn_BITS 0xFFFFFFFF
+#define BF_OCOTP_SJC_RESPn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_MACn
+ *              base 0x00000250
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_MACn(n)	(0x00000250 + (n) * 0x10)
+#define BP_OCOTP_MACn_BITS      0
+#define BM_OCOTP_MACn_BITS 0xFFFFFFFF
+#define BF_OCOTP_MACn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_HWCAPn
+ *              base 0x00000270
+ *              count 3
+ *              offset 0x10
+ */
+#define HW_OCOTP_HWCAPn(n)	(0x00000270 + (n) * 0x10)
+#define BP_OCOTP_HWCAPn_BITS      0
+#define BM_OCOTP_HWCAPn_BITS 0xFFFFFFFF
+#define BF_OCOTP_HWCAPn_BITS(v)   (v)
+
+#define HW_OCOTP_SWCAP	(0x000002a0)
+
+#define BP_OCOTP_SWCAP_BITS      0
+#define BM_OCOTP_SWCAP_BITS 0xFFFFFFFF
+#define BF_OCOTP_SWCAP_BITS(v)   (v)
+
+#define HW_OCOTP_SCS	(0x000002b0)
+#define HW_OCOTP_SCS_SET	(0x000002b4)
+#define HW_OCOTP_SCS_CLR	(0x000002b8)
+#define HW_OCOTP_SCS_TOG	(0x000002bc)
+
+#define BM_OCOTP_SCS_LOCK 0x80000000
+#define BP_OCOTP_SCS_SPARE      1
+#define BM_OCOTP_SCS_SPARE 0x7FFFFFFE
+#define BF_OCOTP_SCS_SPARE(v)  \
+	(((v) << 1) & BM_OCOTP_SCS_SPARE)
+#define BM_OCOTP_SCS_HAB_JDE 0x00000001
+
+#define HW_OCOTP_VERSION	(0x000002c0)
+
+#define BP_OCOTP_VERSION_MAJOR      24
+#define BM_OCOTP_VERSION_MAJOR 0xFF000000
+#define BF_OCOTP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_OCOTP_VERSION_MAJOR)
+#define BP_OCOTP_VERSION_MINOR      16
+#define BM_OCOTP_VERSION_MINOR 0x00FF0000
+#define BF_OCOTP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_OCOTP_VERSION_MINOR)
+#define BP_OCOTP_VERSION_STEP      0
+#define BM_OCOTP_VERSION_STEP 0x0000FFFF
+#define BF_OCOTP_VERSION_STEP(v)  \
+	(((v) << 0) & BM_OCOTP_VERSION_STEP)
+#endif /* __ARCH_ARM___OCOTP_H */
diff --git a/drivers/char/regs-ocotp-v3.h b/drivers/char/regs-ocotp-v3.h
new file mode 100644
index 0000000..d3c8de9
--- /dev/null
+++ b/drivers/char/regs-ocotp-v3.h
@@ -0,0 +1,367 @@
+/*
+ * Freescale OCOTP Register Definitions
+ *
+ * Copyright 2008-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.12
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___OCOTP_H
+#define __ARCH_ARM___OCOTP_H
+
+
+#define HW_OCOTP_CTRL	(0x00000000)
+#define HW_OCOTP_CTRL_SET	(0x00000004)
+#define HW_OCOTP_CTRL_CLR	(0x00000008)
+#define HW_OCOTP_CTRL_TOG	(0x0000000c)
+
+#define BP_OCOTP_CTRL_WR_UNLOCK      16
+#define BM_OCOTP_CTRL_WR_UNLOCK 0xFFFF0000
+#define BF_OCOTP_CTRL_WR_UNLOCK(v) \
+	(((v) << 16) & BM_OCOTP_CTRL_WR_UNLOCK)
+#define BV_OCOTP_CTRL_WR_UNLOCK__KEY 0x3E77
+#define BP_OCOTP_CTRL_RSVD1      13
+#define BM_OCOTP_CTRL_RSVD1 0x0000E000
+#define BF_OCOTP_CTRL_RSVD1(v)  \
+	(((v) << 13) & BM_OCOTP_CTRL_RSVD1)
+#define BM_OCOTP_CTRL_CRC_FAIL 0x00001000
+#define BM_OCOTP_CTRL_CRC_TEST 0x00000800
+#define BM_OCOTP_CTRL_RELOAD_SHADOWS 0x00000400
+#define BM_OCOTP_CTRL_ERROR 0x00000200
+#define BM_OCOTP_CTRL_BUSY 0x00000100
+#define BM_OCOTP_CTRL_RSVD0 0x00000080
+#define BP_OCOTP_CTRL_ADDR      0
+#define BM_OCOTP_CTRL_ADDR 0x0000007F
+#define BF_OCOTP_CTRL_ADDR(v)  \
+	(((v) << 0) & BM_OCOTP_CTRL_ADDR)
+
+#define HW_OCOTP_TIMING	(0x00000010)
+
+#define BP_OCOTP_TIMING_RSRVD0      28
+#define BM_OCOTP_TIMING_RSRVD0 0xF0000000
+#define BF_OCOTP_TIMING_RSRVD0(v) \
+	(((v) << 28) & BM_OCOTP_TIMING_RSRVD0)
+#define BP_OCOTP_TIMING_WAIT      22
+#define BM_OCOTP_TIMING_WAIT 0x0FC00000
+#define BF_OCOTP_TIMING_WAIT(v)  \
+	(((v) << 22) & BM_OCOTP_TIMING_WAIT)
+#define BP_OCOTP_TIMING_STROBE_READ      16
+#define BM_OCOTP_TIMING_STROBE_READ 0x003F0000
+#define BF_OCOTP_TIMING_STROBE_READ(v)  \
+	(((v) << 16) & BM_OCOTP_TIMING_STROBE_READ)
+#define BP_OCOTP_TIMING_RELAX      12
+#define BM_OCOTP_TIMING_RELAX 0x0000F000
+#define BF_OCOTP_TIMING_RELAX(v)  \
+	(((v) << 12) & BM_OCOTP_TIMING_RELAX)
+#define BP_OCOTP_TIMING_STROBE_PROG      0
+#define BM_OCOTP_TIMING_STROBE_PROG 0x00000FFF
+#define BF_OCOTP_TIMING_STROBE_PROG(v)  \
+	(((v) << 0) & BM_OCOTP_TIMING_STROBE_PROG)
+
+#define HW_OCOTP_DATA	(0x00000020)
+
+#define BP_OCOTP_DATA_DATA      0
+#define BM_OCOTP_DATA_DATA 0xFFFFFFFF
+#define BF_OCOTP_DATA_DATA(v)   (v)
+
+#define HW_OCOTP_READ_CTRL	(0x00000030)
+
+#define BP_OCOTP_READ_CTRL_RSVD0      1
+#define BM_OCOTP_READ_CTRL_RSVD0 0xFFFFFFFE
+#define BF_OCOTP_READ_CTRL_RSVD0(v) \
+	(((v) << 1) & BM_OCOTP_READ_CTRL_RSVD0)
+#define BM_OCOTP_READ_CTRL_READ_FUSE 0x00000001
+
+#define HW_OCOTP_READ_FUSE_DATA	(0x00000040)
+
+#define BP_OCOTP_READ_FUSE_DATA_DATA      0
+#define BM_OCOTP_READ_FUSE_DATA_DATA 0xFFFFFFFF
+#define BF_OCOTP_READ_FUSE_DATA_DATA(v)   (v)
+
+#define HW_OCOTP_SW_STICKY	(0x00000050)
+
+#define BP_OCOTP_SW_STICKY_RSVD0      5
+#define BM_OCOTP_SW_STICKY_RSVD0 0xFFFFFFE0
+#define BF_OCOTP_SW_STICKY_RSVD0(v) \
+	(((v) << 5) & BM_OCOTP_SW_STICKY_RSVD0)
+#define BM_OCOTP_SW_STICKY_JTAG_BLOCK_RELEASE 0x00000010
+#define BM_OCOTP_SW_STICKY_BLOCK_ROM_PART 0x00000008
+#define BM_OCOTP_SW_STICKY_FIELD_RETURN_LOCK 0x00000004
+#define BM_OCOTP_SW_STICKY_SRK_REVOKE_LOCK 0x00000002
+#define BM_OCOTP_SW_STICKY_BLOCK_DTCP_KEY 0x00000001
+
+#define HW_OCOTP_SCS	(0x00000060)
+#define HW_OCOTP_SCS_SET	(0x00000064)
+#define HW_OCOTP_SCS_CLR	(0x00000068)
+#define HW_OCOTP_SCS_TOG	(0x0000006c)
+
+#define BM_OCOTP_SCS_LOCK 0x80000000
+#define BP_OCOTP_SCS_SPARE      1
+#define BM_OCOTP_SCS_SPARE 0x7FFFFFFE
+#define BF_OCOTP_SCS_SPARE(v)  \
+	(((v) << 1) & BM_OCOTP_SCS_SPARE)
+#define BM_OCOTP_SCS_HAB_JDE 0x00000001
+
+#define HW_OCOTP_CRC_ADDR	(0x00000070)
+
+#define BP_OCOTP_CRC_ADDR_RSVD0      19
+#define BM_OCOTP_CRC_ADDR_RSVD0 0xFFF80000
+#define BF_OCOTP_CRC_ADDR_RSVD0(v) \
+	(((v) << 19) & BM_OCOTP_CRC_ADDR_RSVD0)
+#define BP_OCOTP_CRC_ADDR_CRC_ADDR      16
+#define BM_OCOTP_CRC_ADDR_CRC_ADDR 0x00070000
+#define BF_OCOTP_CRC_ADDR_CRC_ADDR(v)  \
+	(((v) << 16) & BM_OCOTP_CRC_ADDR_CRC_ADDR)
+#define BP_OCOTP_CRC_ADDR_DATA_END_ADDR      8
+#define BM_OCOTP_CRC_ADDR_DATA_END_ADDR 0x0000FF00
+#define BF_OCOTP_CRC_ADDR_DATA_END_ADDR(v)  \
+	(((v) << 8) & BM_OCOTP_CRC_ADDR_DATA_END_ADDR)
+#define BP_OCOTP_CRC_ADDR_DATA_START_ADDR      0
+#define BM_OCOTP_CRC_ADDR_DATA_START_ADDR 0x000000FF
+#define BF_OCOTP_CRC_ADDR_DATA_START_ADDR(v)  \
+	(((v) << 0) & BM_OCOTP_CRC_ADDR_DATA_START_ADDR)
+
+#define HW_OCOTP_CRC_VALUE	(0x00000080)
+
+#define BP_OCOTP_CRC_VALUE_DATA      0
+#define BM_OCOTP_CRC_VALUE_DATA 0xFFFFFFFF
+#define BF_OCOTP_CRC_VALUE_DATA(v)   (v)
+
+#define HW_OCOTP_VERSION	(0x00000090)
+
+#define BP_OCOTP_VERSION_MAJOR      24
+#define BM_OCOTP_VERSION_MAJOR 0xFF000000
+#define BF_OCOTP_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_OCOTP_VERSION_MAJOR)
+#define BP_OCOTP_VERSION_MINOR      16
+#define BM_OCOTP_VERSION_MINOR 0x00FF0000
+#define BF_OCOTP_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_OCOTP_VERSION_MINOR)
+#define BP_OCOTP_VERSION_STEP      0
+#define BM_OCOTP_VERSION_STEP 0x0000FFFF
+#define BF_OCOTP_VERSION_STEP(v)  \
+	(((v) << 0) & BM_OCOTP_VERSION_STEP)
+
+#define HW_OCOTP_LOCK	(0x00000400)
+
+#define BP_OCOTP_LOCK_UNALLOCATED      30
+#define BM_OCOTP_LOCK_UNALLOCATED 0xC0000000
+#define BF_OCOTP_LOCK_UNALLOCATED(v) \
+	(((v) << 30) & BM_OCOTP_LOCK_UNALLOCATED)
+#define BP_OCOTP_LOCK_CRC_GP_HI_LOCK      28
+#define BM_OCOTP_LOCK_CRC_GP_HI_LOCK 0x30000000
+#define BF_OCOTP_LOCK_CRC_GP_HI_LOCK(v)  \
+	(((v) << 28) & BM_OCOTP_LOCK_CRC_GP_HI_LOCK)
+#define BP_OCOTP_LOCK_CRC_GP_LO_LOCK      26
+#define BM_OCOTP_LOCK_CRC_GP_LO_LOCK 0x0C000000
+#define BF_OCOTP_LOCK_CRC_GP_LO_LOCK(v)  \
+	(((v) << 26) & BM_OCOTP_LOCK_CRC_GP_LO_LOCK)
+#define BM_OCOTP_LOCK_PIN 0x02000000
+#define BM_OCOTP_LOCK_RSVD2 0x01000000
+#define BM_OCOTP_LOCK_DTCP_DEV_CERT 0x00800000
+#define BM_OCOTP_LOCK_MISC_CONF 0x00400000
+#define BM_OCOTP_LOCK_HDCP_KEYS 0x00200000
+#define BM_OCOTP_LOCK_HDCP_KSV 0x00100000
+#define BP_OCOTP_LOCK_ANALOG      18
+#define BM_OCOTP_LOCK_ANALOG 0x000C0000
+#define BF_OCOTP_LOCK_ANALOG(v)  \
+	(((v) << 18) & BM_OCOTP_LOCK_ANALOG)
+#define BM_OCOTP_LOCK_OTPMK 0x00020000
+#define BM_OCOTP_LOCK_DTCP_KEY 0x00010000
+#define BM_OCOTP_LOCK_RSVD1 0x00008000
+#define BM_OCOTP_LOCK_SRK 0x00004000
+#define BP_OCOTP_LOCK_GP2      12
+#define BM_OCOTP_LOCK_GP2 0x00003000
+#define BF_OCOTP_LOCK_GP2(v)  \
+	(((v) << 12) & BM_OCOTP_LOCK_GP2)
+#define BP_OCOTP_LOCK_GP1      10
+#define BM_OCOTP_LOCK_GP1 0x00000C00
+#define BF_OCOTP_LOCK_GP1(v)  \
+	(((v) << 10) & BM_OCOTP_LOCK_GP1)
+#define BP_OCOTP_LOCK_MAC_ADDR      8
+#define BM_OCOTP_LOCK_MAC_ADDR 0x00000300
+#define BF_OCOTP_LOCK_MAC_ADDR(v)  \
+	(((v) << 8) & BM_OCOTP_LOCK_MAC_ADDR)
+#define BM_OCOTP_LOCK_RSVD0 0x00000080
+#define BM_OCOTP_LOCK_SJC_RESP 0x00000040
+#define BP_OCOTP_LOCK_MEM_TRIM      4
+#define BM_OCOTP_LOCK_MEM_TRIM 0x00000030
+#define BF_OCOTP_LOCK_MEM_TRIM(v)  \
+	(((v) << 4) & BM_OCOTP_LOCK_MEM_TRIM)
+#define BP_OCOTP_LOCK_BOOT_CFG      2
+#define BM_OCOTP_LOCK_BOOT_CFG 0x0000000C
+#define BF_OCOTP_LOCK_BOOT_CFG(v)  \
+	(((v) << 2) & BM_OCOTP_LOCK_BOOT_CFG)
+#define BP_OCOTP_LOCK_TESTER      0
+#define BM_OCOTP_LOCK_TESTER 0x00000003
+#define BF_OCOTP_LOCK_TESTER(v)  \
+	(((v) << 0) & BM_OCOTP_LOCK_TESTER)
+
+/*
+ *  multi-register-define name HW_OCOTP_CFGn
+ *              base 0x00000410
+ *              count 7
+ *              offset 0x10
+ */
+#define HW_OCOTP_CFGn(n)	(0x00000410 + (n) * 0x10)
+#define BP_OCOTP_CFGn_BITS      0
+#define BM_OCOTP_CFGn_BITS 0xFFFFFFFF
+#define BF_OCOTP_CFGn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_MEMn
+ *              base 0x00000480
+ *              count 5
+ *              offset 0x10
+ */
+#define HW_OCOTP_MEMn(n)	(0x00000480 + (n) * 0x10)
+#define BP_OCOTP_MEMn_BITS      0
+#define BM_OCOTP_MEMn_BITS 0xFFFFFFFF
+#define BF_OCOTP_MEMn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_ANAn
+ *              base 0x000004D0
+ *              count 3
+ *              offset 0x10
+ */
+#define HW_OCOTP_ANAn(n)	(0x000004d0 + (n) * 0x10)
+#define BP_OCOTP_ANAn_BITS      0
+#define BM_OCOTP_ANAn_BITS 0xFFFFFFFF
+#define BF_OCOTP_ANAn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_OTPMKn
+ *              base 0x00000500
+ *              count 8
+ *              offset 0x10
+ */
+#define HW_OCOTP_OTPMKn(n)	(0x00000500 + (n) * 0x10)
+#define BP_OCOTP_OTPMKn_BITS      0
+#define BM_OCOTP_OTPMKn_BITS 0xFFFFFFFF
+#define BF_OCOTP_OTPMKn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_SRKn
+ *              base 0x00000580
+ *              count 8
+ *              offset 0x10
+ */
+#define HW_OCOTP_SRKn(n)	(0x00000580 + (n) * 0x10)
+#define BP_OCOTP_SRKn_BITS      0
+#define BM_OCOTP_SRKn_BITS 0xFFFFFFFF
+#define BF_OCOTP_SRKn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_SJC_RESPn
+ *              base 0x00000600
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_SJC_RESPn(n)	(0x00000600 + (n) * 0x10)
+#define BP_OCOTP_SJC_RESPn_BITS      0
+#define BM_OCOTP_SJC_RESPn_BITS 0xFFFFFFFF
+#define BF_OCOTP_SJC_RESPn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_MACn
+ *              base 0x00000620
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_MACn(n)	(0x00000620 + (n) * 0x10)
+#define BP_OCOTP_MACn_BITS      0
+#define BM_OCOTP_MACn_BITS 0xFFFFFFFF
+#define BF_OCOTP_MACn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_HDCP_KSVn
+ *              base 0x00000640
+ *              count 2
+ *              offset 0x10
+ */
+#define HW_OCOTP_HDCP_KSVn(n)	(0x00000640 + (n) * 0x10)
+#define BP_OCOTP_HDCP_KSVn_BITS      0
+#define BM_OCOTP_HDCP_KSVn_BITS 0xFFFFFFFF
+#define BF_OCOTP_HDCP_KSVn_BITS(v)   (v)
+
+#define HW_OCOTP_GP1	(0x00000660)
+
+#define BP_OCOTP_GP1_BITS      0
+#define BM_OCOTP_GP1_BITS 0xFFFFFFFF
+#define BF_OCOTP_GP1_BITS(v)   (v)
+
+#define HW_OCOTP_GP2	(0x00000670)
+
+#define BP_OCOTP_GP2_BITS      0
+#define BM_OCOTP_GP2_BITS 0xFFFFFFFF
+#define BF_OCOTP_GP2_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_DTCP_KEYn
+ *              base 0x00000680
+ *              count 5
+ *              offset 0x10
+ */
+#define HW_OCOTP_DTCP_KEYn(n)	(0x00000680 + (n) * 0x10)
+#define BP_OCOTP_DTCP_KEYn_BITS      0
+#define BM_OCOTP_DTCP_KEYn_BITS 0xFFFFFFFF
+#define BF_OCOTP_DTCP_KEYn_BITS(v)   (v)
+
+#define HW_OCOTP_MISC_CONF	(0x000006d0)
+
+#define BP_OCOTP_MISC_CONF_BITS      0
+#define BM_OCOTP_MISC_CONF_BITS 0xFFFFFFFF
+#define BF_OCOTP_MISC_CONF_BITS(v)   (v)
+
+#define HW_OCOTP_FIELD_RETURN	(0x000006e0)
+
+#define BP_OCOTP_FIELD_RETURN_BITS      0
+#define BM_OCOTP_FIELD_RETURN_BITS 0xFFFFFFFF
+#define BF_OCOTP_FIELD_RETURN_BITS(v)   (v)
+
+#define HW_OCOTP_SRK_REVOKE	(0x000006f0)
+
+#define BP_OCOTP_SRK_REVOKE_BITS      0
+#define BM_OCOTP_SRK_REVOKE_BITS 0xFFFFFFFF
+#define BF_OCOTP_SRK_REVOKE_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_HDCP_KEYn
+ *              base 0x00000800
+ *              count 72
+ *              offset 0x10
+ */
+#define HW_OCOTP_HDCP_KEYn(n)	(0x00000800 + (n) * 0x10)
+#define BP_OCOTP_HDCP_KEYn_BITS      0
+#define BM_OCOTP_HDCP_KEYn_BITS 0xFFFFFFFF
+#define BF_OCOTP_HDCP_KEYn_BITS(v)   (v)
+
+/*
+ *  multi-register-define name HW_OCOTP_CRCn
+ *              base 0x00000D00
+ *              count 8
+ *              offset 0x10
+ */
+#define HW_OCOTP_CRCn(n)	(0x00000d00 + (n) * 0x10)
+#define BP_OCOTP_CRCn_BITS      0
+#define BM_OCOTP_CRCn_BITS 0xFFFFFFFF
+#define BF_OCOTP_CRCn_BITS(v)   (v)
+#endif /* __ARCH_ARM___OCOTP_H */
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 6b19624..e44a57a 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -19,6 +19,15 @@
 
 #include <linux/types.h>
 
+struct mxc_otp_platform_data {
+	char    **fuse_name;
+	char    *regulator_name;
+	char    *clock_name;
+	unsigned int min_volt;
+	unsigned int max_volt;
+	unsigned int    fuse_num;
+};
+
 /*
  * Some conventions on how we handle peripherals on Freescale chips
  *
-- 
1.7.9.7

