From 8a64be0490ae811cae6baba05a10b2e395bc37de Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 11:34:31 +0800
Subject: [PATCH 21/62] fsl_imx6: Add HDMI display driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                          |    1 +
 arch/arm/mach-mx6/devices-imx6q.h                  |   13 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c            |   60 +
 arch/arm/plat-mxc/devices/Kconfig                  |    3 +
 arch/arm/plat-mxc/devices/Makefile                 |    4 +
 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c  |   28 +
 arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c |   50 +
 arch/arm/plat-mxc/devices/platform-mxc_hdmi.c      |   49 +
 arch/arm/plat-mxc/include/mach/devices-common.h    |   27 +
 arch/arm/plat-mxc/include/mach/mxc_edid.h          |   78 +
 arch/arm/plat-mxc/include/mach/mxc_hdmi.h          |    8 +
 arch/arm/plat-mxc/iomux-v3.c                       |   15 +
 drivers/mfd/Kconfig                                |    7 +
 drivers/mfd/Makefile                               |    1 +
 drivers/mfd/mxc-hdmi-core.c                        |  730 ++++++
 drivers/video/Kconfig                              |    7 +
 drivers/video/Makefile                             |    1 +
 drivers/video/mxc/Kconfig                          |    5 +
 drivers/video/mxc/Makefile                         |    1 +
 drivers/video/mxc/mxc_dvi.c                        |  383 ++++
 drivers/video/mxc/mxc_edid.c                       |  564 +++++
 drivers/video/mxc_hdmi.c                           | 2408 ++++++++++++++++++++
 include/linux/fsl_devices.h                        |   21 +
 23 files changed, 4464 insertions(+)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_edid.h
 create mode 100644 drivers/mfd/mxc-hdmi-core.c
 create mode 100644 drivers/video/mxc/mxc_dvi.c
 create mode 100644 drivers/video/mxc/mxc_edid.c
 create mode 100644 drivers/video/mxc_hdmi.c

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 5dd6e3f..c8ac860 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -18,6 +18,7 @@ config MACH_MX6Q_SABRELITE
 	bool "Support i.MX 6Quad SABRE Lite platform"
 	select ARCH_MX6Q
 	select SOC_IMX6Q
+	select IMX_HAVE_PLATFORM_MXC_HDMI
 	select IMX_HAVE_PLATFORM_IMX_IPUV3
 	select IMX_HAVE_PLATFORM_IMX_UART
 	select IMX_HAVE_PLATFORM_IMX_I2C
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index f6f08cd..8073474 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -50,4 +50,17 @@ extern const struct imx_ipuv3_data imx6q_ipuv3_data[] __initconst;
 #define imx6q_add_lcdif(pdata)	\
 	platform_device_register_resndata(NULL, "mxc_lcdif",\
 			0, NULL, 0, pdata, sizeof(*pdata));
+
+extern const struct imx_mxc_hdmi_data imx6q_mxc_hdmi_data __initconst;
+#define imx6q_add_mxc_hdmi(pdata)	\
+	imx_add_mxc_hdmi(&imx6q_mxc_hdmi_data, pdata)
+
+extern const struct imx_mxc_hdmi_core_data imx6q_mxc_hdmi_core_data __initconst;
+#define imx6q_add_mxc_hdmi_core(pdata)	\
+	imx_add_mxc_hdmi_core(&imx6q_mxc_hdmi_core_data, pdata)
+
+#define imx6q_add_hdmi_soc() imx_add_hdmi_soc()
+extern const struct imx_hdmi_soc_data imx6q_imx_hdmi_soc_dai_data __initconst;
+#define imx6q_add_hdmi_soc_dai() \
+	imx_add_hdmi_soc_dai(&imx6q_imx_hdmi_soc_dai_data)
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index efbba64..d4cf4e3 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -51,6 +51,7 @@
 #include <mach/imx-uart.h>
 #include <mach/ahci_sata.h>
 #include <mach/mxc_hdmi.h>
+#include <mach/iomux-v3.h>
 #include "devices-imx6q.h"
 #include "crm_regs.h"
 #include "cpu_op-mx6.h"
@@ -263,6 +264,42 @@ static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	MX6Q_PAD_NANDF_D7__GPIO_2_7,		/* SD4_WP */
 };
 
+static void hdmi_init(int ipu_id, int disp_id)
+{
+	int hdmi_mux_setting;
+
+	if ((ipu_id > 1) || (ipu_id < 0)) {
+		pr_err("Invalid IPU select for HDMI: %d. Set to 0\n", ipu_id);
+		ipu_id = 0;
+	}
+
+	if ((disp_id > 1) || (disp_id < 0)) {
+		pr_err("Invalid DI select for HDMI: %d. Set to 0\n", disp_id);
+		disp_id = 0;
+	}
+
+	/* Configure the connection between IPU1/2 and HDMI */
+	hdmi_mux_setting = 2*ipu_id + disp_id;
+
+	/* GPR3, bits 2-3 = HDMI_MUX_CTL */
+	mxc_iomux_set_gpr_register(3, 2, 2, hdmi_mux_setting);
+}
+
+static struct fsl_mxc_hdmi_platform_data hdmi_data = {
+	.init = hdmi_init,
+};
+
+static struct fsl_mxc_hdmi_core_platform_data hdmi_core_data = {
+	.ipu_id = 0,
+	.disp_id = 0,
+};
+
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("mxc_hdmi_i2c", 0x50),
+	},
+};
+
 static struct ipuv3_fb_platform_data sabrelite_fb_data[] = {
 	{ /*fb0*/
 		.disp_dev	= "ldb",
@@ -514,6 +551,9 @@ static void __init mx6_soc_init(void)
 static void __init mx6_sabrelite_board_init(void)
 {
 	int i;
+	struct clk *clko2;
+	struct clk *new_parent;
+	int rate;
 
 	mxc_iomux_v3_setup_multiple_pads(mx6q_sabrelite_pads,
 					ARRAY_SIZE(mx6q_sabrelite_pads));
@@ -538,11 +578,31 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_imx_i2c(0, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabrelite_i2c_data);
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+			ARRAY_SIZE(mxc_i2c1_board_info));
+
+	imx6q_add_mxc_hdmi_core(&hdmi_core_data);
+	imx6q_add_mxc_hdmi(&hdmi_data);
+	imx6q_add_hdmi_soc();
+	imx6q_add_hdmi_soc_dai();
 
 	/* SD/MMC */
 	platform_device_register(&sabrelite_vmmc_reg_devices);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6q_sabrelite_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabrelite_sd3_data);
+
+	clko2 = clk_get(NULL, "clko2_clk");
+	if (IS_ERR(clko2))
+		pr_err("can't get CLKO2 clock.\n");
+
+	new_parent = clk_get(NULL, "osc_clk");
+	if (!IS_ERR(new_parent)) {
+		clk_set_parent(clko2, new_parent);
+		clk_put(new_parent);
+	}
+	rate = clk_round_rate(clko2, 24000000);
+	clk_set_rate(clko2, rate);
+	clk_enable(clko2);
 }
 
 static void __init mx6_sabrelite_timer_init(void)
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index 839b4f8..629172b 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -86,3 +86,6 @@ config IMX_HAVE_PLATFORM_IMX_IPUV3
 config IMX_HAVE_PLATFORM_AHCI
 	bool
 	default y if ARCH_MX53
+
+config IMX_HAVE_PLATFORM_MXC_HDMI
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index 3f0e934..d129ff2 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -28,3 +28,7 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX) += platform-sdhci-esdhc-imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_SPI_IMX) +=  platform-spi_imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_AHCI) +=  platform-ahci-imx.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_IPUV3) +=  platform-imx-ipuv3.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-mxc_hdmi.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-mxc-hdmi-core.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-imx-hdmi-soc.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-imx-hdmi-soc-dai.o
diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
new file mode 100644
index 0000000..bd0b8ad
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+struct platform_device *__init imx_add_hdmi_soc(void)
+{
+	return imx_add_platform_device("mxc_hdmi_soc", 0,
+				       NULL, 0, NULL, 0);
+}
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
new file mode 100644
index 0000000..e0c1906
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-mxc-hdmi-core.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx6_mxc_hdmi_core_data_entry_single(soc, size)	\
+	{								\
+		.iobase = soc ## _HDMI_ARB_BASE_ADDR,			\
+		.iosize = size,						\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_mxc_hdmi_core_data imx6q_mxc_hdmi_core_data __initconst =
+	imx6_mxc_hdmi_core_data_entry_single(MX6Q, SZ_32K + SZ_4K);
+#endif
+
+struct platform_device *__init imx_add_mxc_hdmi_core(
+		const struct imx_mxc_hdmi_core_data *data,
+		const struct fsl_mxc_hdmi_core_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + data->iosize - 1,
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxc_hdmi_core", -1,
+		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
new file mode 100644
index 0000000..25cf313
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-mxc_hdmi.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx6_mxc_hdmi_data_entry_single(soc)				\
+	{								\
+		.irq = soc ## _INT_HDMI_TX,				\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_mxc_hdmi_data imx6q_mxc_hdmi_data __initconst =
+			imx6_mxc_hdmi_data_entry_single(MX6Q);
+#endif
+
+struct platform_device *__init imx_add_mxc_hdmi(
+		const struct imx_mxc_hdmi_data *data,
+		const struct fsl_mxc_hdmi_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device_dmamask("mxc_hdmi", -1,
+		res, ARRAY_SIZE(res), pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index dae8bc0..15dba61 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -259,6 +259,33 @@ struct platform_device *__init imx_add_mxc_ehci(
 		const struct imx_mxc_ehci_data *data,
 		const struct mxc_usbh_platform_data *pdata);
 
+#include <mach/mxc_hdmi.h>
+struct imx_mxc_hdmi_data {
+	resource_size_t irq;
+	resource_size_t irq_wakeup;
+};
+
+struct platform_device *__init imx_add_mxc_hdmi(
+		const struct imx_mxc_hdmi_data *data,
+		const struct fsl_mxc_hdmi_platform_data *pdata);
+
+struct imx_mxc_hdmi_core_data {
+	resource_size_t iobase;
+	resource_size_t iosize;
+};
+
+struct platform_device *__init imx_add_mxc_hdmi_core(
+		const struct imx_mxc_hdmi_core_data *data,
+		const struct fsl_mxc_hdmi_core_platform_data *pdata);
+
+struct imx_hdmi_soc_data {
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_hdmi_soc(void);
+
+struct platform_device *__init imx_add_hdmi_soc_dai(
+		const struct imx_hdmi_soc_data *data);
+
 #include <mach/mmc.h>
 struct imx_mxc_mmc_data {
 	int id;
diff --git a/arch/arm/plat-mxc/include/mach/mxc_edid.h b/arch/arm/plat-mxc/include/mach/mxc_edid.h
new file mode 100644
index 0000000..10baa01
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_edid.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxc_edid.h
+ *
+ * @brief MXC EDID tools
+ *
+ * @ingroup Framebuffer
+ */
+
+#ifndef MXC_EDID_H
+#define MXC_EDID_H
+
+#include <linux/fb.h>
+
+#define FB_VMODE_ASPECT_4_3	0x10
+#define FB_VMODE_ASPECT_16_9	0x20
+#define FB_VMODE_ASPECT_MASK	(FB_VMODE_ASPECT_4_3 | FB_VMODE_ASPECT_16_9)
+
+enum cea_audio_coding_types {
+	AUDIO_CODING_TYPE_REF_STREAM_HEADER	=  0,
+	AUDIO_CODING_TYPE_LPCM			=  1,
+	AUDIO_CODING_TYPE_AC3			=  2,
+	AUDIO_CODING_TYPE_MPEG1			=  3,
+	AUDIO_CODING_TYPE_MP3			=  4,
+	AUDIO_CODING_TYPE_MPEG2			=  5,
+	AUDIO_CODING_TYPE_AACLC			=  6,
+	AUDIO_CODING_TYPE_DTS			=  7,
+	AUDIO_CODING_TYPE_ATRAC			=  8,
+	AUDIO_CODING_TYPE_SACD			=  9,
+	AUDIO_CODING_TYPE_EAC3			= 10,
+	AUDIO_CODING_TYPE_DTS_HD		= 11,
+	AUDIO_CODING_TYPE_MLP			= 12,
+	AUDIO_CODING_TYPE_DST			= 13,
+	AUDIO_CODING_TYPE_WMAPRO		= 14,
+	AUDIO_CODING_TYPE_RESERVED		= 15,
+};
+
+struct mxc_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+
+	/*VSD*/
+	bool vsd_dc_48bit;
+	bool vsd_dc_36bit;
+	bool vsd_dc_30bit;
+	bool vsd_dc_y444;
+	bool vsd_dvi_dual;
+
+	u8 max_channels;
+	u8 sample_sizes;
+	u8 sample_rates;
+};
+
+int mxc_edid_var_to_vic(struct fb_var_screeninfo *var);
+int mxc_edid_mode_to_vic(const struct fb_videomode *mode);
+int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi);
+
+#endif
diff --git a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
index 02a413f..6001ca8 100644
--- a/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
+++ b/arch/arm/plat-mxc/include/mach/mxc_hdmi.h
@@ -587,6 +587,14 @@ enum {
 	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
 	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
 
+/* IH_PHY_STAT0 field values */
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE3 = 0x20,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE2 = 0x10,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE1 = 0x8,
+	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE0 = 0x4,
+	HDMI_IH_MUTE_PHY_STAT0_TX_PHY_LOCK = 0x2,
+	HDMI_IH_MUTE_PHY_STAT0_HPD = 0x1,
+
 /* IH_AHBDMAAUD_STAT0 field values */
 	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
 	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
diff --git a/arch/arm/plat-mxc/iomux-v3.c b/arch/arm/plat-mxc/iomux-v3.c
index 99a9cdb..9ce15ce 100644
--- a/arch/arm/plat-mxc/iomux-v3.c
+++ b/arch/arm/plat-mxc/iomux-v3.c
@@ -56,6 +56,21 @@ int mxc_iomux_v3_setup_pad(iomux_v3_cfg_t pad)
 }
 EXPORT_SYMBOL(mxc_iomux_v3_setup_pad);
 
+void mxc_iomux_set_gpr_register(int group, int start_bit, int num_bits, int value)
+{
+	int i = 0;
+	u32 reg;
+	reg = __raw_readl(base + group * 4);
+	while (num_bits) {
+		reg &= ~(1<<(start_bit + i));
+		i++;
+		num_bits--;
+	}
+	reg |= (value << start_bit);
+	__raw_writel(reg, base + group * 4);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr_register);
+
 int mxc_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t *pad_list, unsigned count)
 {
 	iomux_v3_cfg_t *p = pad_list;
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index 11e4438..855ae8e 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -888,6 +888,13 @@ config MFD_ANATOP
 	  MFD controller. This controller embeds regulator and
 	  thermal devices for Freescale i.MX platforms.
 
+config MFD_MXC_HDMI
+	tristate "MXC HDMI Core"
+	select MFD_CORE
+	default y
+	help
+	  This is the core driver for the i.Mx on-chip HDMI.  This MFD
+	  driver connects with the video and audio drivers for HDMI.
 endmenu
 endif
 
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 05fa538..53b594b 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -116,3 +116,4 @@ obj-$(CONFIG_MFD_INTEL_MSIC)	+= intel_msic.o
 obj-$(CONFIG_MFD_RC5T583)	+= rc5t583.o rc5t583-irq.o
 obj-$(CONFIG_MFD_S5M_CORE)	+= s5m-core.o s5m-irq.o
 obj-$(CONFIG_MFD_ANATOP)	+= anatop-mfd.o
+obj-$(CONFIG_MFD_MXC_HDMI)       += mxc-hdmi-core.o
diff --git a/drivers/mfd/mxc-hdmi-core.c b/drivers/mfd/mxc-hdmi-core.c
new file mode 100644
index 0000000..726cefb
--- /dev/null
+++ b/drivers/mfd/mxc-hdmi-core.c
@@ -0,0 +1,730 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+
+#include <linux/platform_device.h>
+#include <linux/regulator/machine.h>
+#include <asm/mach-types.h>
+
+#include <mach/clock.h>
+#include <mach/mxc_hdmi.h>
+#include <mach/ipu-v3.h>
+#include <mach/mxc_edid.h>
+#include "../mxc/ipu3/ipu_prv.h"
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <linux/fsl_devices.h>
+
+struct mxc_hdmi_data {
+	struct platform_device *pdev;
+	unsigned long __iomem *reg_base;
+	unsigned long reg_phys_base;
+	struct device *dev;
+};
+
+static unsigned long hdmi_base;
+static struct clk *isfr_clk;
+static struct clk *iahb_clk;
+static spinlock_t irq_spinlock;
+static spinlock_t edid_spinlock;
+static unsigned int sample_rate;
+static unsigned long pixel_clk_rate;
+static struct clk *pixel_clk;
+static int hdmi_ratio;
+int mxc_hdmi_ipu_id;
+int mxc_hdmi_disp_id;
+static struct mxc_edid_cfg hdmi_core_edid_cfg;
+static int hdmi_core_init;
+static unsigned int hdmi_dma_running;
+static struct snd_pcm_substream *hdmi_audio_stream_playback;
+static unsigned int hdmi_cable_state;
+static unsigned int hdmi_blank_state;
+static spinlock_t hdmi_audio_lock, hdmi_blank_state_lock, hdmi_cable_state_lock;
+
+
+unsigned int hdmi_set_cable_state(unsigned int state)
+{
+	unsigned long flags;
+	struct snd_pcm_substream *substream = hdmi_audio_stream_playback;
+
+	spin_lock_irqsave(&hdmi_cable_state_lock, flags);
+	hdmi_cable_state = state;
+	spin_unlock_irqrestore(&hdmi_cable_state_lock, flags);
+
+	if (check_hdmi_state() && substream)
+		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);
+	return 0;
+}
+
+unsigned int hdmi_set_blank_state(unsigned int state)
+{
+	unsigned long flags;
+	struct snd_pcm_substream *substream = hdmi_audio_stream_playback;
+
+	spin_lock_irqsave(&hdmi_blank_state_lock, flags);
+	hdmi_blank_state = state;
+	spin_unlock_irqrestore(&hdmi_blank_state_lock, flags);
+
+	if (check_hdmi_state() && substream)
+		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_START);
+
+	return 0;
+}
+
+static void hdmi_audio_abort_stream(struct snd_pcm_substream *substream)
+{
+	unsigned long flags;
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+
+	if (snd_pcm_running(substream))
+		substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_STOP);
+
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+}
+
+int mxc_hdmi_abort_stream(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&hdmi_audio_lock, flags);
+	if (hdmi_audio_stream_playback)
+		hdmi_audio_abort_stream(hdmi_audio_stream_playback);
+	spin_unlock_irqrestore(&hdmi_audio_lock, flags);
+
+	return 0;
+}
+
+int check_hdmi_state(void)
+{
+	unsigned long flags1, flags2;
+	unsigned int ret;
+
+	spin_lock_irqsave(&hdmi_cable_state_lock, flags1);
+	spin_lock_irqsave(&hdmi_blank_state_lock, flags2);
+
+	ret = hdmi_cable_state && hdmi_blank_state;
+
+	spin_unlock_irqrestore(&hdmi_blank_state_lock, flags2);
+	spin_unlock_irqrestore(&hdmi_cable_state_lock, flags1);
+
+	return ret;
+}
+
+int mxc_hdmi_register_audio(struct snd_pcm_substream *substream)
+{
+	unsigned long flags, flags1;
+	int ret = 0;
+
+	snd_pcm_stream_lock_irqsave(substream, flags);
+
+	if (substream && check_hdmi_state()) {
+		spin_lock_irqsave(&hdmi_audio_lock, flags1);
+		if (hdmi_audio_stream_playback) {
+			pr_err("%s unconsist hdmi auido stream!\n", __func__);
+			ret = -EINVAL;
+		}
+		hdmi_audio_stream_playback = substream;
+		spin_unlock_irqrestore(&hdmi_audio_lock, flags1);
+	} else
+		ret = -EINVAL;
+
+	snd_pcm_stream_unlock_irqrestore(substream, flags);
+
+	return ret;
+}
+
+void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdmi_audio_lock, flags);
+	hdmi_audio_stream_playback = NULL;
+	spin_unlock_irqrestore(&hdmi_audio_lock, flags);
+}
+
+u8 hdmi_readb(unsigned int reg)
+{
+	u8 value;
+
+	value = __raw_readb(hdmi_base + reg);
+
+/*	pr_debug("hdmi rd: 0x%04x = 0x%02x\n", reg, value);*/
+
+	return value;
+}
+
+#ifdef DEBUG
+static bool overflow_lo;
+static bool overflow_hi;
+
+bool hdmi_check_overflow(void)
+{
+	u8 val, lo, hi;
+
+	val = hdmi_readb(HDMI_IH_FC_STAT2);
+	lo = (val & HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW) != 0;
+	hi = (val & HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW) != 0;
+
+	if ((lo != overflow_lo) || (hi != overflow_hi)) {
+		pr_debug("%s LowPriority=%d HighPriority=%d  <=======================\n",
+			__func__, lo, hi);
+		overflow_lo = lo;
+		overflow_hi = hi;
+		return true;
+	}
+	return false;
+}
+#else
+bool hdmi_check_overflow(void)
+{
+	return false;
+}
+#endif
+
+void hdmi_writeb(u8 value, unsigned int reg)
+{
+	hdmi_check_overflow();
+/*	pr_debug("hdmi wr: 0x%04x = 0x%02x\n", reg, value);*/
+	__raw_writeb(value, hdmi_base + reg);
+	hdmi_check_overflow();
+}
+
+void hdmi_mask_writeb(u8 data, unsigned int reg, u8 shift, u8 mask)
+{
+	u8 value = hdmi_readb(reg) & ~mask;
+	value |= (data << shift) & mask;
+	hdmi_writeb(value, reg);
+}
+
+unsigned int hdmi_read4(unsigned int reg)
+{
+	/* read a four byte address from registers */
+	return (hdmi_readb(reg + 3) << 24) |
+		(hdmi_readb(reg + 2) << 16) |
+		(hdmi_readb(reg + 1) << 8) |
+		hdmi_readb(reg);
+}
+
+void hdmi_write4(unsigned int value, unsigned int reg)
+{
+	/* write a four byte address to hdmi regs */
+	hdmi_writeb(value & 0xff, reg);
+	hdmi_writeb((value >> 8) & 0xff, reg + 1);
+	hdmi_writeb((value >> 16) & 0xff, reg + 2);
+	hdmi_writeb((value >> 24) & 0xff, reg + 3);
+}
+
+static void initialize_hdmi_ih_mutes(void)
+{
+	u8 ih_mute;
+
+	/*
+	 * Boot up defaults are:
+	 * HDMI_IH_MUTE   = 0x03 (disabled)
+	 * HDMI_IH_MUTE_* = 0x00 (enabled)
+	 */
+
+	/* Disable top level interrupt bits in HDMI block */
+	ih_mute = hdmi_readb(HDMI_IH_MUTE) |
+		  HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
+		  HDMI_IH_MUTE_MUTE_ALL_INTERRUPT;
+
+	hdmi_writeb(ih_mute, HDMI_IH_MUTE);
+
+	/* by default mask all interrupts */
+	hdmi_writeb(0xff, HDMI_VP_MASK);
+	hdmi_writeb(0xff, HDMI_FC_MASK0);
+	hdmi_writeb(0xff, HDMI_FC_MASK1);
+	hdmi_writeb(0xff, HDMI_FC_MASK2);
+	hdmi_writeb(0xff, HDMI_PHY_MASK0);
+	hdmi_writeb(0xff, HDMI_PHY_I2CM_INT_ADDR);
+	hdmi_writeb(0xff, HDMI_PHY_I2CM_CTLINT_ADDR);
+	hdmi_writeb(0xff, HDMI_AUD_INT);
+	hdmi_writeb(0xff, HDMI_AUD_SPDIFINT);
+	hdmi_writeb(0xff, HDMI_AUD_HBR_MASK);
+	hdmi_writeb(0xff, HDMI_GP_MASK);
+	hdmi_writeb(0xff, HDMI_A_APIINTMSK);
+	hdmi_writeb(0xff, HDMI_CEC_MASK);
+	hdmi_writeb(0xff, HDMI_I2CM_INT);
+	hdmi_writeb(0xff, HDMI_I2CM_CTLINT);
+
+	/* Disable interrupts in the IH_MUTE_* registers */
+	hdmi_writeb(0xff, HDMI_IH_MUTE_FC_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_FC_STAT1);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_FC_STAT2);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_AS_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_PHY_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_I2CM_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_CEC_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_VP_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);
+	hdmi_writeb(0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+
+	/* Enable top level interrupt bits in HDMI block */
+	ih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
+		    HDMI_IH_MUTE_MUTE_ALL_INTERRUPT);
+	hdmi_writeb(ih_mute, HDMI_IH_MUTE);
+}
+
+static void hdmi_set_clock_regenerator_n(unsigned int value)
+{
+	u8 val;
+
+	if (!hdmi_dma_running) {
+		hdmi_writeb(value & 0xff, HDMI_AUD_N1);
+		hdmi_writeb(0, HDMI_AUD_N2);
+		hdmi_writeb(0, HDMI_AUD_N3);
+	}
+
+	hdmi_writeb(value & 0xff, HDMI_AUD_N1);
+	hdmi_writeb((value >> 8) & 0xff, HDMI_AUD_N2);
+	hdmi_writeb((value >> 16) & 0x0f, HDMI_AUD_N3);
+
+	/* nshift factor = 0 */
+	val = hdmi_readb(HDMI_AUD_CTS3);
+	val &= ~HDMI_AUD_CTS3_N_SHIFT_MASK;
+	hdmi_writeb(val, HDMI_AUD_CTS3);
+}
+
+static void hdmi_set_clock_regenerator_cts(unsigned int cts)
+{
+	u8 val;
+
+	if (!hdmi_dma_running) {
+		hdmi_writeb(cts & 0xff, HDMI_AUD_CTS1);
+		hdmi_writeb(0, HDMI_AUD_CTS2);
+		hdmi_writeb(0, HDMI_AUD_CTS3);
+	}
+
+	/* Must be set/cleared first */
+	val = hdmi_readb(HDMI_AUD_CTS3);
+	val &= ~HDMI_AUD_CTS3_CTS_MANUAL;
+	hdmi_writeb(val, HDMI_AUD_CTS3);
+
+	hdmi_writeb(cts & 0xff, HDMI_AUD_CTS1);
+	hdmi_writeb((cts >> 8) & 0xff, HDMI_AUD_CTS2);
+	hdmi_writeb(((cts >> 16) & HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
+		    HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
+}
+
+static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk,
+				   unsigned int ratio)
+{
+	unsigned int n = (128 * freq) / 1000;
+
+	switch (freq) {
+	case 32000:
+		if (pixel_clk == 25174000)
+			n = (ratio == 150) ? 9152 : 4576;
+		else if (pixel_clk == 27020000)
+			n = (ratio == 150) ? 8192 : 4096;
+		else if (pixel_clk == 74170000 || pixel_clk == 148350000)
+			n = 11648;
+		else if (pixel_clk == 297000000)
+			n = (ratio == 150) ? 6144 : 3072;
+		else
+			n = 4096;
+		break;
+
+	case 44100:
+		if (pixel_clk == 25174000)
+			n = 7007;
+		else if (pixel_clk == 74170000)
+			n = 17836;
+		else if (pixel_clk == 148350000)
+			n = (ratio == 150) ? 17836 : 8918;
+		else if (pixel_clk == 297000000)
+			n = (ratio == 150) ? 9408 : 4704;
+		else
+			n = 6272;
+		break;
+
+	case 48000:
+		if (pixel_clk == 25174000)
+			n = (ratio == 150) ? 9152 : 6864;
+		else if (pixel_clk == 27020000)
+			n = (ratio == 150) ? 8192 : 6144;
+		else if (pixel_clk == 74170000)
+			n = 11648;
+		else if (pixel_clk == 148350000)
+			n = (ratio == 150) ? 11648 : 5824;
+		else if (pixel_clk == 297000000)
+			n = (ratio == 150) ? 10240 : 5120;
+		else
+			n = 6144;
+		break;
+
+	case 88200:
+		n = hdmi_compute_n(44100, pixel_clk, ratio) * 2;
+		break;
+
+	case 96000:
+		n = hdmi_compute_n(48000, pixel_clk, ratio) * 2;
+		break;
+
+	case 176400:
+		n = hdmi_compute_n(44100, pixel_clk, ratio) * 4;
+		break;
+
+	case 192000:
+		n = hdmi_compute_n(48000, pixel_clk, ratio) * 4;
+		break;
+
+	default:
+		break;
+	}
+
+	return n;
+}
+
+static unsigned int hdmi_compute_cts(unsigned int freq, unsigned long pixel_clk,
+				     unsigned int ratio)
+{
+	unsigned int cts = 0;
+	switch (freq) {
+	case 32000:
+		if (pixel_clk == 297000000) {
+			cts = 222750;
+			break;
+		} else if (pixel_clk == 25174000) {
+			cts = 28125;
+			break;
+		}
+	case 48000:
+	case 96000:
+	case 192000:
+		switch (pixel_clk) {
+		case 25200000:
+		case 27000000:
+		case 54000000:
+		case 74250000:
+		case 148500000:
+			cts = pixel_clk / 1000;
+			break;
+		case 297000000:
+			cts = 247500;
+			break;
+		case 25174000:
+			cts = 28125l;
+			break;
+		/*
+		 * All other TMDS clocks are not supported by
+		 * DWC_hdmi_tx. The TMDS clocks divided or
+		 * multiplied by 1,001 coefficients are not
+		 * supported.
+		 */
+		default:
+			break;
+		}
+		break;
+	case 44100:
+	case 88200:
+	case 176400:
+		switch (pixel_clk) {
+		case 25200000:
+			cts = 28000;
+			break;
+		case 25174000:
+			cts = 31250;
+			break;
+		case 27000000:
+			cts = 30000;
+			break;
+		case 54000000:
+			cts = 60000;
+			break;
+		case 74250000:
+			cts = 82500;
+			break;
+		case 148500000:
+			cts = 165000;
+			break;
+		case 297000000:
+			cts = 247500;
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+	if (ratio == 100)
+		return cts;
+	else
+		return (cts * ratio) / 100;
+}
+
+static void hdmi_set_clk_regenerator(void)
+{
+	unsigned int clk_n, clk_cts;
+
+	clk_n = hdmi_compute_n(sample_rate, pixel_clk_rate, hdmi_ratio);
+	clk_cts = hdmi_compute_cts(sample_rate, pixel_clk_rate, hdmi_ratio);
+
+	if (clk_cts == 0) {
+		pr_debug("%s: pixel clock not supported: %d\n",
+			__func__, (int)pixel_clk_rate);
+		return;
+	}
+
+	pr_debug("%s: samplerate=%d  ratio=%d  pixelclk=%d  N=%d  cts=%d\n",
+		__func__, sample_rate, hdmi_ratio, (int)pixel_clk_rate,
+		clk_n, clk_cts);
+
+	hdmi_set_clock_regenerator_cts(clk_cts);
+	hdmi_set_clock_regenerator_n(clk_n);
+}
+
+/* Need to run this before phy is enabled the first time to prevent
+ * overflow condition in HDMI_IH_FC_STAT2 */
+void hdmi_init_clk_regenerator(void)
+{
+	if (pixel_clk_rate == 0) {
+		pixel_clk_rate = 74250000;
+		hdmi_set_clk_regenerator();
+	}
+}
+
+void hdmi_clk_regenerator_update_pixel_clock(u32 pixclock)
+{
+
+	/* Translate pixel clock in ps (pico seconds) to Hz  */
+	pixel_clk_rate = PICOS2KHZ(pixclock) * 1000UL;
+	hdmi_set_clk_regenerator();
+}
+
+void hdmi_set_dma_mode(unsigned int dma_running)
+{
+	hdmi_dma_running = dma_running;
+	hdmi_set_clk_regenerator();
+}
+
+void hdmi_set_sample_rate(unsigned int rate)
+{
+	sample_rate = rate;
+}
+
+void hdmi_set_edid_cfg(struct mxc_edid_cfg *cfg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&edid_spinlock, flags);
+	memcpy(&hdmi_core_edid_cfg, cfg, sizeof(struct mxc_edid_cfg));
+	spin_unlock_irqrestore(&edid_spinlock, flags);
+}
+
+void hdmi_get_edid_cfg(struct mxc_edid_cfg *cfg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&edid_spinlock, flags);
+	memcpy(cfg, &hdmi_core_edid_cfg, sizeof(struct mxc_edid_cfg));
+	spin_unlock_irqrestore(&edid_spinlock, flags);
+}
+
+void hdmi_set_registered(int registered)
+{
+	hdmi_core_init = registered;
+}
+
+int hdmi_get_registered(void)
+{
+	return hdmi_core_init;
+}
+
+static int mxc_hdmi_core_probe(struct platform_device *pdev)
+{
+	struct fsl_mxc_hdmi_core_platform_data *pdata = pdev->dev.platform_data;
+	struct mxc_hdmi_data *hdmi_data;
+	struct resource *res;
+	unsigned long flags;
+	int ret = 0;
+
+#ifdef DEBUG
+	overflow_lo = false;
+	overflow_hi = false;
+#endif
+
+	hdmi_core_init = 0;
+	hdmi_dma_running = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENOENT;
+
+	hdmi_data = kzalloc(sizeof(struct mxc_hdmi_data), GFP_KERNEL);
+	if (!hdmi_data) {
+		dev_err(&pdev->dev, "Couldn't allocate mxc hdmi mfd device\n");
+		return -ENOMEM;
+	}
+	hdmi_data->pdev = pdev;
+
+	pixel_clk = NULL;
+	sample_rate = 48000;
+	pixel_clk_rate = 0;
+	hdmi_ratio = 100;
+
+	spin_lock_init(&irq_spinlock);
+	spin_lock_init(&edid_spinlock);
+
+
+	spin_lock_init(&hdmi_cable_state_lock);
+	spin_lock_init(&hdmi_blank_state_lock);
+	spin_lock_init(&hdmi_audio_lock);
+
+	spin_lock_irqsave(&hdmi_cable_state_lock, flags);
+	hdmi_cable_state = 0;
+	spin_unlock_irqrestore(&hdmi_cable_state_lock, flags);
+
+	spin_lock_irqsave(&hdmi_blank_state_lock, flags);
+	hdmi_blank_state = 0;
+	spin_unlock_irqrestore(&hdmi_blank_state_lock, flags);
+
+	spin_lock_irqsave(&hdmi_audio_lock, flags);
+	hdmi_audio_stream_playback = NULL;
+	spin_unlock_irqrestore(&hdmi_audio_lock, flags);
+
+	isfr_clk = clk_get(&hdmi_data->pdev->dev, "hdmi_isfr_clk");
+	if (IS_ERR(isfr_clk)) {
+		ret = PTR_ERR(isfr_clk);
+		dev_err(&hdmi_data->pdev->dev,
+			"Unable to get HDMI isfr clk: %d\n", ret);
+		goto eclkg;
+	}
+
+	ret = clk_enable(isfr_clk);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Cannot enable HDMI clock: %d\n", ret);
+		goto eclke;
+	}
+
+	pr_debug("%s isfr_clk:%d\n", __func__,
+		(int)clk_get_rate(isfr_clk));
+
+	iahb_clk = clk_get(&hdmi_data->pdev->dev, "hdmi_iahb_clk");
+	if (IS_ERR(iahb_clk)) {
+		ret = PTR_ERR(iahb_clk);
+		dev_err(&hdmi_data->pdev->dev,
+			"Unable to get HDMI iahb clk: %d\n", ret);
+		goto eclkg2;
+	}
+
+	ret = clk_enable(iahb_clk);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Cannot enable HDMI clock: %d\n", ret);
+		goto eclke2;
+	}
+
+	hdmi_data->reg_phys_base = res->start;
+	if (!request_mem_region(res->start, resource_size(res),
+				dev_name(&pdev->dev))) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		ret = -EBUSY;
+		goto emem;
+	}
+
+	hdmi_data->reg_base = ioremap(res->start, resource_size(res));
+	if (!hdmi_data->reg_base) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		ret = -ENOMEM;
+		goto eirq;
+	}
+	hdmi_base = (unsigned long)hdmi_data->reg_base;
+
+	pr_debug("\n%s hdmi hw base = 0x%08x\n\n", __func__, (int)res->start);
+
+	mxc_hdmi_ipu_id = pdata->ipu_id;
+	mxc_hdmi_disp_id = pdata->disp_id;
+
+	initialize_hdmi_ih_mutes();
+
+	/* Disable HDMI clocks until video/audio sub-drivers are initialized */
+	clk_disable(isfr_clk);
+	clk_disable(iahb_clk);
+
+	/* Replace platform data coming in with a local struct */
+	platform_set_drvdata(pdev, hdmi_data);
+
+	return ret;
+
+eirq:
+	release_mem_region(res->start, resource_size(res));
+emem:
+	clk_disable(iahb_clk);
+eclke2:
+	clk_put(iahb_clk);
+eclkg2:
+	clk_disable(isfr_clk);
+eclke:
+	clk_put(isfr_clk);
+eclkg:
+	kfree(hdmi_data);
+	return ret;
+}
+
+
+static int __exit mxc_hdmi_core_remove(struct platform_device *pdev)
+{
+	struct mxc_hdmi_data *hdmi_data = platform_get_drvdata(pdev);
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	iounmap(hdmi_data->reg_base);
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(hdmi_data);
+
+	return 0;
+}
+
+static struct platform_driver mxc_hdmi_core_driver = {
+	.driver = {
+		.name = "mxc_hdmi_core",
+		.owner = THIS_MODULE,
+	},
+	.remove = __exit_p(mxc_hdmi_core_remove),
+};
+
+static int __init mxc_hdmi_core_init(void)
+{
+	return platform_driver_probe(&mxc_hdmi_core_driver,
+				     mxc_hdmi_core_probe);
+}
+
+static void __exit mxc_hdmi_core_exit(void)
+{
+	platform_driver_unregister(&mxc_hdmi_core_driver);
+}
+
+subsys_initcall(mxc_hdmi_core_init);
+module_exit(mxc_hdmi_core_exit);
+
+MODULE_DESCRIPTION("Core driver for Freescale i.Mx on-chip HDMI");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 23d34b8..45c992f 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -2483,6 +2483,13 @@ source "drivers/video/omap2/Kconfig"
 source "drivers/video/exynos/Kconfig"
 source "drivers/video/backlight/Kconfig"
 
+config FB_MXC_HDMI
+	tristate "MXC HDMI driver support"
+	depends on FB_MXC_SYNC_PANEL && I2C
+	select MFD_MXC_HDMI
+	help
+	  Driver for the on-chip MXC HDMI controller.
+
 if ARCH_MXC
 source "drivers/video/mxc/Kconfig"
 endif
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 93a80e1..b9d6f71 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -148,6 +148,7 @@ obj-$(CONFIG_FB_MSM)              += msm/
 obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
 obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
 obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
+obj-$(CONFIG_FB_MXC_HDMI)         += mxc_hdmi.o
 obj-$(CONFIG_FB_MXC)              += mxc/
 
 # Platform or fallback drivers go here
diff --git a/drivers/video/mxc/Kconfig b/drivers/video/mxc/Kconfig
index de8ac02..eead741 100644
--- a/drivers/video/mxc/Kconfig
+++ b/drivers/video/mxc/Kconfig
@@ -14,6 +14,11 @@ config FB_MXC
 	  If you plan to use the LCD display with your MXC system, say
 	  Y here.
 
+config FB_MXC_EDID
+	depends on FB_MXC && I2C
+	tristate "MXC EDID support"
+	default y
+
 config FB_MXC_SYNC_PANEL
 	depends on FB_MXC
 	tristate "Synchronous Panel Framebuffer"
diff --git a/drivers/video/mxc/Makefile b/drivers/video/mxc/Makefile
index 66ec8ca..a10318c 100644
--- a/drivers/video/mxc/Makefile
+++ b/drivers/video/mxc/Makefile
@@ -1,3 +1,4 @@
+obj-$(CONFIG_FB_MXC_EDID)			+= mxc_edid.o mxc_dvi.o
 ifeq ($(CONFIG_ARCH_MX6Q),y)
 	obj-$(CONFIG_FB_MXC_SYNC_PANEL) += mxc_dispdrv.o mxc_lcdif.o mxc_ipuv3_fb.o
 endif
diff --git a/drivers/video/mxc/mxc_dvi.c b/drivers/video/mxc/mxc_dvi.c
new file mode 100644
index 0000000..479ecfe
--- /dev/null
+++ b/drivers/video/mxc/mxc_dvi.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxc_dvi.c
+ *
+ * @brief MXC DVI driver
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/fb.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ipu.h>
+#include <linux/mxcfb.h>
+#include <linux/fsl_devices.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/regulator/consumer.h>
+#include <mach/mxc_edid.h>
+#include "mxc_dispdrv.h"
+#include "../edid.h"
+
+#define MXC_EDID_LENGTH (EDID_LENGTH*4)
+
+#define DISPDRV_DVI	"dvi"
+
+struct mxc_dvi_data {
+	struct i2c_client *client;
+	struct platform_device *pdev;
+	struct mxc_dispdrv_handle *disp_dvi;
+	struct delayed_work det_work;
+	struct fb_info *fbi;
+	struct mxc_edid_cfg edid_cfg;
+	u8 cable_plugin;
+	u8 edid[MXC_EDID_LENGTH];
+
+	u32 ipu;
+	u32 di;
+	void (*init)(void);
+	int (*update)(void);
+	struct regulator *analog_reg;
+};
+
+static ssize_t mxc_dvi_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_dvi_data *dvi = dev_get_drvdata(dev);
+
+	if (dvi->cable_plugin == 0)
+		strcpy(buf, "plugout\n");
+	else
+		strcpy(buf, "plugin\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(cable_state, S_IRUGO, mxc_dvi_show_state, NULL);
+
+static ssize_t mxc_dvi_show_name(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_dvi_data *dvi = dev_get_drvdata(dev);
+
+	strcpy(buf, dvi->fbi->fix.id);
+	sprintf(buf+strlen(buf), "\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(fb_name, S_IRUGO, mxc_dvi_show_name, NULL);
+
+static ssize_t mxc_dvi_show_edid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_dvi_data *dvi = dev_get_drvdata(dev);
+	int i, j, len = 0;
+
+	for (j = 0; j < MXC_EDID_LENGTH/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					dvi->edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(edid, S_IRUGO, mxc_dvi_show_edid, NULL);
+
+static void det_worker(struct work_struct *work)
+{
+	struct delayed_work *delay_work = to_delayed_work(work);
+	struct mxc_dvi_data *dvi =
+		container_of(delay_work, struct mxc_dvi_data, det_work);
+	char event_string[16];
+	char *envp[] = { event_string, NULL };
+
+	/* cable connection changes */
+	if (dvi->update()) {
+		u8 edid_old[MXC_EDID_LENGTH];
+		dvi->cable_plugin = 1;
+		sprintf(event_string, "EVENT=plugin");
+
+		memcpy(edid_old, dvi->edid, MXC_EDID_LENGTH);
+
+		if (mxc_edid_read(dvi->client->adapter, dvi->client->addr,
+				dvi->edid, &dvi->edid_cfg, dvi->fbi) < 0)
+			dev_err(&dvi->client->dev,
+					"MXC dvi: read edid fail\n");
+		else {
+			if (!memcmp(edid_old, dvi->edid, MXC_EDID_LENGTH))
+				dev_info(&dvi->client->dev,
+					"Sii902x: same edid\n");
+			else if (dvi->fbi->monspecs.modedb_len > 0) {
+				int i;
+				const struct fb_videomode *mode;
+				struct fb_videomode m;
+
+				fb_destroy_modelist(&dvi->fbi->modelist);
+
+				for (i = 0; i < dvi->fbi->monspecs.modedb_len; i++)
+					/*FIXME now we do not support interlaced mode */
+					if (!(dvi->fbi->monspecs.modedb[i].vmode & FB_VMODE_INTERLACED))
+						fb_add_videomode(&dvi->fbi->monspecs.modedb[i],
+								&dvi->fbi->modelist);
+
+				fb_var_to_videomode(&m, &dvi->fbi->var);
+				mode = fb_find_nearest_mode(&m,
+						&dvi->fbi->modelist);
+
+				fb_videomode_to_var(&dvi->fbi->var, mode);
+
+				dvi->fbi->var.activate |= FB_ACTIVATE_FORCE;
+				console_lock();
+				dvi->fbi->flags |= FBINFO_MISC_USEREVENT;
+				fb_set_var(dvi->fbi, &dvi->fbi->var);
+				dvi->fbi->flags &= ~FBINFO_MISC_USEREVENT;
+				console_unlock();
+			}
+		}
+	} else {
+		dvi->cable_plugin = 0;
+		sprintf(event_string, "EVENT=plugout");
+	}
+
+	kobject_uevent_env(&dvi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+}
+
+static irqreturn_t mxc_dvi_detect_handler(int irq, void *data)
+{
+	struct mxc_dvi_data *dvi = data;
+	schedule_delayed_work(&(dvi->det_work), msecs_to_jiffies(300));
+	return IRQ_HANDLED;
+}
+
+static int dvi_init(struct mxc_dispdrv_handle *disp,
+	struct mxc_dispdrv_setting *setting)
+{
+	int ret = 0;
+	struct mxc_dvi_data *dvi = mxc_dispdrv_getdata(disp);
+	struct fsl_mxc_dvi_platform_data *plat = dvi->client->dev.platform_data;
+
+	setting->dev_id = dvi->ipu = plat->ipu_id;
+	setting->disp_id = dvi->di = plat->disp_id;
+	setting->if_fmt = IPU_PIX_FMT_RGB24;
+	dvi->fbi = setting->fbi;
+	dvi->init = plat->init;
+	dvi->update = plat->update;
+
+	dvi->analog_reg = regulator_get(&dvi->pdev->dev, plat->analog_regulator);
+	if (!IS_ERR(dvi->analog_reg)) {
+		regulator_set_voltage(dvi->analog_reg, 2775000, 2775000);
+		regulator_enable(dvi->analog_reg);
+	}
+
+	if (dvi->init)
+		dvi->init();
+
+	/* get video mode from edid */
+	if (!dvi->update)
+		return -EINVAL;
+	else {
+		bool found = false;
+
+		INIT_LIST_HEAD(&dvi->fbi->modelist);
+		if (dvi->update()) {
+			dvi->cable_plugin = 1;
+			/* try to read edid */
+			if (mxc_edid_read(dvi->client->adapter, dvi->client->addr,
+					dvi->edid, &dvi->edid_cfg, dvi->fbi) < 0)
+				dev_warn(&dvi->client->dev, "Can not read edid\n");
+			else if (dvi->fbi->monspecs.modedb_len > 0) {
+				int i;
+				const struct fb_videomode *mode;
+				struct fb_videomode m;
+
+				for (i = 0; i < dvi->fbi->monspecs.modedb_len; i++) {
+					/*FIXME now we do not support interlaced mode */
+					if (!(dvi->fbi->monspecs.modedb[i].vmode
+						& FB_VMODE_INTERLACED))
+						fb_add_videomode(
+							&dvi->fbi->monspecs.modedb[i],
+							&dvi->fbi->modelist);
+				}
+
+				fb_find_mode(&dvi->fbi->var, dvi->fbi, setting->dft_mode_str,
+						NULL, 0, NULL, setting->default_bpp);
+
+				fb_var_to_videomode(&m, &dvi->fbi->var);
+				mode = fb_find_nearest_mode(&m,
+						&dvi->fbi->modelist);
+				fb_videomode_to_var(&dvi->fbi->var, mode);
+				found = 1;
+			}
+		} else
+			dvi->cable_plugin = 0;
+
+		if (!found) {
+			ret = fb_find_mode(&dvi->fbi->var, dvi->fbi, setting->dft_mode_str,
+					NULL, 0, NULL, setting->default_bpp);
+			if (!ret)
+				return -EINVAL;
+		}
+	}
+
+	/* cable detection */
+	if (dvi->client->irq) {
+		ret = request_irq(dvi->client->irq, mxc_dvi_detect_handler,
+				IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
+				"dvi_det", dvi);
+		if (ret < 0) {
+			dev_warn(&dvi->client->dev,
+				"MXC dvi: cound not request det irq %d\n",
+				dvi->client->irq);
+			goto err;
+		} else {
+			INIT_DELAYED_WORK(&(dvi->det_work), det_worker);
+			ret = device_create_file(&dvi->pdev->dev, &dev_attr_fb_name);
+			if (ret < 0)
+				dev_warn(&dvi->client->dev,
+					"MXC dvi: cound not create sys node for fb name\n");
+			ret = device_create_file(&dvi->pdev->dev, &dev_attr_cable_state);
+			if (ret < 0)
+				dev_warn(&dvi->client->dev,
+					"MXC dvi: cound not create sys node for cable state\n");
+			ret = device_create_file(&dvi->pdev->dev, &dev_attr_edid);
+			if (ret < 0)
+				dev_warn(&dvi->client->dev,
+					"MXC dvi: cound not create sys node for edid\n");
+
+			dev_set_drvdata(&dvi->pdev->dev, dvi);
+		}
+	}
+
+err:
+	return ret;
+}
+
+static void dvi_deinit(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_dvi_data *dvi = mxc_dispdrv_getdata(disp);
+
+	if (!IS_ERR(dvi->analog_reg))
+		regulator_disable(dvi->analog_reg);
+
+	free_irq(dvi->client->irq, dvi);
+}
+
+static struct mxc_dispdrv_driver dvi_drv = {
+	.name 	= DISPDRV_DVI,
+	.init 	= dvi_init,
+	.deinit	= dvi_deinit,
+};
+
+static int __devinit mxc_dvi_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct mxc_dvi_data *dvi;
+	int ret = 0;
+
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))
+		return -ENODEV;
+
+	dvi = kzalloc(sizeof(struct mxc_dvi_data), GFP_KERNEL);
+	if (!dvi) {
+		ret = -ENOMEM;
+		goto alloc_failed;
+	}
+
+	dvi->pdev = platform_device_register_simple("mxc_dvi", 0, NULL, 0);
+	if (IS_ERR(dvi->pdev)) {
+		printk(KERN_ERR
+				"Unable to register MXC DVI as a platform device\n");
+		ret = PTR_ERR(dvi->pdev);
+		goto pdev_reg_failed;
+	}
+
+	dvi->client = client;
+	dvi->disp_dvi = mxc_dispdrv_register(&dvi_drv);
+	mxc_dispdrv_setdata(dvi->disp_dvi, dvi);
+
+	i2c_set_clientdata(client, dvi);
+
+	return ret;
+
+pdev_reg_failed:
+	kfree(dvi);
+alloc_failed:
+	return ret;
+}
+
+static int __devexit mxc_dvi_remove(struct i2c_client *client)
+{
+	struct mxc_dvi_data *dvi = i2c_get_clientdata(client);
+
+	mxc_dispdrv_puthandle(dvi->disp_dvi);
+	mxc_dispdrv_unregister(dvi->disp_dvi);
+	platform_device_unregister(dvi->pdev);
+	kfree(dvi);
+	return 0;
+}
+
+static const struct i2c_device_id mxc_dvi_id[] = {
+	{ "mxc_dvi", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mxc_dvi_id);
+
+static struct i2c_driver mxc_dvi_i2c_driver = {
+	.driver = {
+		   .name = "mxc_dvi",
+		   },
+	.probe = mxc_dvi_probe,
+	.remove = mxc_dvi_remove,
+	.id_table = mxc_dvi_id,
+};
+
+static int __init mxc_dvi_init(void)
+{
+	return i2c_add_driver(&mxc_dvi_i2c_driver);
+}
+
+static void __exit mxc_dvi_exit(void)
+{
+	i2c_del_driver(&mxc_dvi_i2c_driver);
+}
+
+module_init(mxc_dvi_init);
+module_exit(mxc_dvi_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC DVI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/mxc/mxc_edid.c b/drivers/video/mxc/mxc_edid.c
new file mode 100644
index 0000000..0907653
--- /dev/null
+++ b/drivers/video/mxc/mxc_edid.c
@@ -0,0 +1,564 @@
+/*
+ * Copyright 2009-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxc_edid.c
+ *
+ * @brief MXC EDID driver
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/i2c.h>
+#include <linux/fb.h>
+#include <mach/mxc_edid.h>
+#include "../edid.h"
+
+#undef DEBUG  /* define this for verbose EDID parsing output */
+#ifdef DEBUG
+#define DPRINTK(fmt, args...) printk(fmt, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+const struct fb_videomode mxc_cea_mode[64] = {
+	/* #1: 640x480p@59.94/60Hz 4:3 */
+	[1] = {
+		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #2: 720x480p@59.94/60Hz 4:3 */
+	[2] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #3: 720x480p@59.94/60Hz 16:9 */
+	[3] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #4: 1280x720p@59.94/60Hz 16:9 */
+	[4] = {
+		NULL, 60, 1280, 720, 13468, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #5: 1920x1080i@59.94/60Hz 16:9 */
+	[5] = {
+		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
+	[6] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
+	[7] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
+	[8] = {
+		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
+	[9] = {
+		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #16: 1920x1080p@60Hz 16:9 */
+	[16] = {
+		NULL, 60, 1920, 1080, 6734, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #17: 720x576pH@50Hz 4:3 */
+	[17] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #18: 720x576pH@50Hz 16:9 */
+	[18] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #19: 1280x720p@50Hz */
+	[19] = {
+		NULL, 50, 1280, 720, 13468, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #20: 1920x1080i@50Hz */
+	[20] = {
+		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #31: 1920x1080p@50Hz */
+	[31] = {
+		NULL, 50, 1920, 1080, 6734, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #32: 1920x1080p@23.98/24Hz */
+	[32] = {
+		NULL, 24, 1920, 1080, 13468, 148, 638, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #35: (2880)x480p4x@59.94/60Hz */
+	[35] = {
+		NULL, 60, 2880, 480, 9250, 240, 64, 30, 9, 248, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+};
+
+/*
+ * We have a special version of fb_mode_is_equal that ignores
+ * pixclock, since for many CEA modes, 2 frequencies are supported
+ * e.g. 640x480 @ 60Hz or 59.94Hz
+ */
+int mxc_edid_fb_mode_is_equal(bool use_aspect,
+			const struct fb_videomode *mode1,
+			const struct fb_videomode *mode2)
+{
+	u32 mask;
+
+	if (use_aspect)
+		mask = ~0;
+	else
+		mask = ~FB_VMODE_ASPECT_MASK;
+
+	return (mode1->xres         == mode2->xres &&
+		mode1->yres         == mode2->yres &&
+		mode1->hsync_len    == mode2->hsync_len &&
+		mode1->vsync_len    == mode2->vsync_len &&
+		mode1->left_margin  == mode2->left_margin &&
+		mode1->right_margin == mode2->right_margin &&
+		mode1->upper_margin == mode2->upper_margin &&
+		mode1->lower_margin == mode2->lower_margin &&
+		mode1->sync         == mode2->sync &&
+		(mode1->vmode & mask) == (mode2->vmode & mask));
+}
+
+static void get_detailed_timing(unsigned char *block,
+				struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+	mode->pixclock /= 1000;
+	mode->pixclock = KHZ2PICOS(mode->pixclock);
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
+				     (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	if ((H_SIZE / 16) == (V_SIZE / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((H_SIZE / 4) == (V_SIZE / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+	else if ((mode->xres / 16) == (mode->yres / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((mode->xres / 4) == (mode->yres / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+
+	if (mode->vmode & FB_VMODE_ASPECT_16_9)
+		DPRINTK("Aspect ratio: 16:9\n");
+	if (mode->vmode & FB_VMODE_ASPECT_4_3)
+		DPRINTK("Aspect ratio: 4:3\n");
+	DPRINTK("      %d MHz ",  PIXEL_CLOCK/1000000);
+	DPRINTK("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	DPRINTK("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	DPRINTK("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	       (VSYNC_POSITIVE) ? "+" : "-");
+}
+
+int mxc_edid_parse_ext_blk(unsigned char *edid,
+		struct mxc_edid_cfg *cfg,
+		struct fb_monspecs *specs)
+{
+	char detail_timing_desc_offset;
+	struct fb_videomode *mode, *m;
+	unsigned char index = 0x0;
+	unsigned char *block;
+	int i, num = 0, revision;
+
+	if (edid[index++] != 0x2) /* only support cea ext block now */
+		return -1;
+	revision = edid[index++];
+	DPRINTK("cea extent revision %d\n", revision);
+	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
+	if (mode == NULL)
+		return -1;
+
+	detail_timing_desc_offset = edid[index++];
+
+	if (revision >= 2) {
+		cfg->cea_underscan = (edid[index] >> 7) & 0x1;
+		cfg->cea_basicaudio = (edid[index] >> 6) & 0x1;
+		cfg->cea_ycbcr444 = (edid[index] >> 5) & 0x1;
+		cfg->cea_ycbcr422 = (edid[index] >> 4) & 0x1;
+
+		DPRINTK("CEA underscan %d\n", cfg->cea_underscan);
+		DPRINTK("CEA basicaudio %d\n", cfg->cea_basicaudio);
+		DPRINTK("CEA ycbcr444 %d\n", cfg->cea_ycbcr444);
+		DPRINTK("CEA ycbcr422 %d\n", cfg->cea_ycbcr422);
+	}
+
+	if (revision >= 3) {
+		/* short desc */
+		DPRINTK("CEA Short desc timmings\n");
+		index++;
+		while (index < detail_timing_desc_offset) {
+			unsigned char tagcode, blklen;
+
+			tagcode = (edid[index] >> 5) & 0x7;
+			blklen = (edid[index]) & 0x1f;
+
+			DPRINTK("Tagcode %x Len %d\n", tagcode, blklen);
+
+			switch (tagcode) {
+			case 0x2: /*Video data block*/
+				{
+					int cea_idx;
+					i = 0;
+					while (i < blklen) {
+						index++;
+						cea_idx = edid[index] & 0x7f;
+						if (cea_idx < ARRAY_SIZE(mxc_cea_mode) &&
+								(mxc_cea_mode[cea_idx].xres)) {
+							DPRINTK("Support CEA Format #%d\n", cea_idx);
+							mode[num] = mxc_cea_mode[cea_idx];
+							mode[num].flag |= FB_MODE_IS_STANDARD;
+							num++;
+						}
+						i++;
+					}
+					break;
+				}
+			case 0x3: /*Vendor specific data*/
+				{
+					unsigned char IEEE_reg_iden[3];
+					unsigned char deep_color;
+					IEEE_reg_iden[0] = edid[index+1];
+					IEEE_reg_iden[1] = edid[index+2];
+					IEEE_reg_iden[2] = edid[index+3];
+					deep_color = edid[index+6];
+
+					if ((IEEE_reg_iden[0] == 0x03) &&
+							(IEEE_reg_iden[1] == 0x0c) &&
+							(IEEE_reg_iden[2] == 0x00))
+						cfg->hdmi_cap = 1;
+
+					if (deep_color & 0x40)
+						cfg->vsd_dc_48bit = true;
+					if (deep_color & 0x20)
+						cfg->vsd_dc_36bit = true;
+					if (deep_color & 0x10)
+						cfg->vsd_dc_30bit = true;
+					if (deep_color & 0x08)
+						cfg->vsd_dc_y444 = true;
+					if (deep_color & 0x01)
+						cfg->vsd_dvi_dual = true;
+
+					DPRINTK("VSD hdmi capability %d\n", cfg->hdmi_cap);
+					DPRINTK("VSD support deep color 48bit %d\n", cfg->vsd_dc_48bit);
+					DPRINTK("VSD support deep color 36bit %d\n", cfg->vsd_dc_36bit);
+					DPRINTK("VSD support deep color 30bit %d\n", cfg->vsd_dc_30bit);
+					DPRINTK("VSD support deep color y444 %d\n", cfg->vsd_dc_y444);
+					DPRINTK("VSD support dvi dual %d\n", cfg->vsd_dvi_dual);
+
+					index += blklen;
+					break;
+				}
+			case 0x1: /*Audio data block*/
+				{
+					u8 audio_format, max_ch, byte1, byte2, byte3;
+
+					i = 0;
+					cfg->max_channels = 0;
+					cfg->sample_rates = 0;
+					cfg->sample_sizes = 0;
+
+					while (i < blklen) {
+						byte1 = edid[index + 1];
+						byte2 = edid[index + 2];
+						byte3 = edid[index + 3];
+						index += 3;
+						i += 3;
+
+						audio_format = byte1 >> 3;
+						max_ch = (byte1 & 0x07) + 1;
+
+						DPRINTK("Audio Format Descriptor : %2d\n", audio_format);
+						DPRINTK("Max Number of Channels  : %2d\n", max_ch);
+						DPRINTK("Sample Rates            : %02x\n", byte2);
+
+						/* ALSA can't specify specific compressed
+						 * formats, so only care about PCM for now. */
+						if (audio_format == AUDIO_CODING_TYPE_LPCM) {
+							if (max_ch > cfg->max_channels)
+								cfg->max_channels = max_ch;
+
+							cfg->sample_rates |= byte2;
+							cfg->sample_sizes |= byte3 & 0x7;
+							DPRINTK("Sample Sizes            : %02x\n",
+								byte3 & 0x7);
+						}
+					}
+					break;
+				}
+			case 0x4: /*Speaker allocation block*/
+			case 0x7: /*User extended block*/
+			default:
+				/* skip */
+				index += blklen;
+				break;
+			}
+
+			index++;
+		}
+	}
+
+	/* long desc */
+	DPRINTK("CEA long desc timmings\n");
+	index = detail_timing_desc_offset;
+	block = edid + index;
+	while (index < (EDID_LENGTH - DETAILED_TIMING_DESCRIPTION_SIZE)) {
+		if (!(block[0] == 0x00 && block[1] == 0x00)) {
+			get_detailed_timing(block, &mode[num]);
+			num++;
+		}
+		block += DETAILED_TIMING_DESCRIPTION_SIZE;
+		index += DETAILED_TIMING_DESCRIPTION_SIZE;
+	}
+
+	if (!num) {
+		kfree(mode);
+		return 0;
+	}
+
+	m = kmalloc((num + specs->modedb_len) *
+			sizeof(struct fb_videomode), GFP_KERNEL);
+	if (!m)
+		return 0;
+
+	if (specs->modedb_len) {
+		memmove(m, specs->modedb,
+			specs->modedb_len * sizeof(struct fb_videomode));
+		kfree(specs->modedb);
+	}
+	memmove(m+specs->modedb_len, mode,
+		num * sizeof(struct fb_videomode));
+	kfree(mode);
+
+	specs->modedb_len += num;
+	specs->modedb = m;
+
+	return 0;
+}
+
+static int mxc_edid_readblk(struct i2c_adapter *adp,
+		unsigned short addr, unsigned char *edid)
+{
+	int ret = 0, extblknum = 0;
+	unsigned char regaddr = 0x0;
+	struct i2c_msg msg[2] = {
+		{
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block\n");
+		return -EIO;
+	}
+
+	if (edid[1] == 0x00)
+		return -ENOENT;
+
+	extblknum = edid[0x7E];
+
+	if (extblknum) {
+		regaddr = 128;
+		msg[1].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID ext block\n");
+			return -EIO;
+		}
+	}
+
+	return extblknum;
+}
+
+static int mxc_edid_readsegblk(struct i2c_adapter *adp, unsigned short addr,
+			unsigned char *edid, int seg_num)
+{
+	int ret = 0;
+	unsigned char segment = 0x1, regaddr = 0;
+	struct i2c_msg msg[3] = {
+		{
+		.addr	= 0x30,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &segment,
+		}, {
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block\n");
+		return -EIO;
+	}
+
+	if (seg_num == 2) {
+		regaddr = 128;
+		msg[2].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID block\n");
+			return -EIO;
+		}
+	}
+
+	return ret;
+}
+
+int mxc_edid_var_to_vic(struct fb_var_screeninfo *var)
+{
+	int i;
+	struct fb_videomode m;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		fb_var_to_videomode(&m, var);
+		if (mxc_edid_fb_mode_is_equal(false, &m, &mxc_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(mxc_cea_mode))
+		return 0;
+
+	return i;
+}
+
+EXPORT_SYMBOL(mxc_edid_var_to_vic);
+
+int mxc_edid_mode_to_vic(const struct fb_videomode *mode)
+{
+	int i;
+	bool use_aspect = (mode->vmode & FB_VMODE_ASPECT_MASK);
+
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		if (mxc_edid_fb_mode_is_equal(use_aspect, mode, &mxc_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(mxc_cea_mode))
+		return 0;
+
+	return i;
+}
+EXPORT_SYMBOL(mxc_edid_mode_to_vic);
+
+/* make sure edid has 512 bytes*/
+int mxc_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct mxc_edid_cfg *cfg, struct fb_info *fbi)
+{
+	int ret = 0, extblknum;
+	if (!adp || !edid || !cfg || !fbi)
+		return -EINVAL;
+
+	memset(edid, 0, EDID_LENGTH*4);
+	memset(cfg, 0, sizeof(struct mxc_edid_cfg));
+
+	extblknum = mxc_edid_readblk(adp, addr, edid);
+	if (extblknum < 0)
+		return extblknum;
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	if (extblknum) {
+		int i;
+
+		/* need read segment block? */
+		if (extblknum > 1) {
+			ret = mxc_edid_readsegblk(adp, addr,
+				edid + EDID_LENGTH*2, extblknum - 1);
+			if (ret < 0)
+				return ret;
+		}
+
+		for (i = 1; i <= extblknum; i++)
+			/* edid ext block parsing */
+			mxc_edid_parse_ext_blk(edid + i*EDID_LENGTH,
+					cfg, &fbi->monspecs);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(mxc_edid_read);
diff --git a/drivers/video/mxc_hdmi.c b/drivers/video/mxc_hdmi.c
new file mode 100644
index 0000000..069f309
--- /dev/null
+++ b/drivers/video/mxc_hdmi.c
@@ -0,0 +1,2408 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+/*
+ * SH-Mobile High-Definition Multimedia Interface (HDMI) driver
+ * for SLISHDMI13T and SLIPHDMIT IP cores
+ *
+ * Copyright (C) 2010, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/clock.h>
+#include <linux/uaccess.h>
+#include <linux/cpufreq.h>
+#include <linux/firmware.h>
+#include <linux/kthread.h>
+#include <linux/regulator/driver.h>
+#include <linux/fsl_devices.h>
+#include <linux/ipu.h>
+
+#include <linux/console.h>
+#include <linux/types.h>
+
+#include <mach/mxc_edid.h>
+#include "mxc/mxc_dispdrv.h"
+
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <mach/mxc_hdmi.h>
+
+#define DISPDRV_HDMI	"hdmi"
+#define HDMI_EDID_LEN		512
+
+/* status codes for reading edid */
+#define HDMI_EDID_SUCCESS	0
+#define HDMI_EDID_FAIL		-1
+#define HDMI_EDID_SAME		-2
+#define HDMI_EDID_NO_MODES	-3
+
+#define NUM_CEA_VIDEO_MODES	64
+#define DEFAULT_VIDEO_MODE	16 /* 1080P */
+
+#define RGB			0
+#define YCBCR444		1
+#define YCBCR422_16BITS		2
+#define YCBCR422_8BITS		3
+#define XVYCC444            4
+
+/*
+ * We follow a flowchart which is in the "Synopsys DesignWare Courses
+ * HDMI Transmitter Controller User Guide, 1.30a", section 3.1
+ * (dwc_hdmi_tx_user.pdf)
+ *
+ * Below are notes that say "HDMI Initialization Step X"
+ * These correspond to the flowchart.
+ */
+
+/*
+ * We are required to configure VGA mode before reading edid
+ * in HDMI Initialization Step B
+ */
+static const struct fb_videomode vga_mode = {
+	/* 640x480 @ 60 Hz, 31.5 kHz hsync */
+	NULL, 60, 640, 480, 39721, 48, 16, 33, 10, 96, 2, 0,
+	FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+};
+
+static const struct fb_videomode xga_mode = {
+	/* 13 1024x768-60 VESA */
+	NULL, 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+	0, FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+static const struct fb_videomode sxga_mode = {
+	/* 20 1280x1024-60 VESA */
+	NULL, 60, 1280, 1024, 9259, 248, 48, 38, 1, 112, 3,
+	FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+	FB_VMODE_NONINTERLACED, FB_MODE_IS_VESA
+};
+
+enum hdmi_datamap {
+	RGB444_8B = 0x01,
+	RGB444_10B = 0x03,
+	RGB444_12B = 0x05,
+	RGB444_16B = 0x07,
+	YCbCr444_8B = 0x09,
+	YCbCr444_10B = 0x0B,
+	YCbCr444_12B = 0x0D,
+	YCbCr444_16B = 0x0F,
+	YCbCr422_8B = 0x16,
+	YCbCr422_10B = 0x14,
+	YCbCr422_12B = 0x12,
+};
+
+enum hdmi_colorimetry {
+	eITU601,
+	eITU709,
+};
+
+struct hdmi_vmode {
+	bool mDVI;
+	bool mHSyncPolarity;
+	bool mVSyncPolarity;
+	bool mInterlaced;
+	bool mDataEnablePolarity;
+
+	unsigned int mPixelClock;
+	unsigned int mPixelRepetitionInput;
+	unsigned int mPixelRepetitionOutput;
+};
+
+struct hdmi_data_info {
+	unsigned int enc_in_format;
+	unsigned int enc_out_format;
+	unsigned int enc_color_depth;
+	unsigned int colorimetry;
+	unsigned int pix_repet_factor;
+	unsigned int hdcp_enable;
+	struct hdmi_vmode video_mode;
+};
+
+struct mxc_hdmi {
+	struct platform_device *pdev;
+	struct platform_device *core_pdev;
+	struct mxc_dispdrv_handle *disp_mxc_hdmi;
+	struct fb_info *fbi;
+	struct clk *hdmi_isfr_clk;
+	struct clk *hdmi_iahb_clk;
+	struct delayed_work hotplug_work;
+	struct notifier_block nb;
+
+	struct hdmi_data_info hdmi_data;
+	int vic;
+	struct mxc_edid_cfg edid_cfg;
+	u8 edid[HDMI_EDID_LEN];
+	bool fb_reg;
+	bool cable_plugin;
+	u8  blank;
+	bool dft_mode_set;
+	char *dft_mode_str;
+	int default_bpp;
+	u8 latest_intr_stat;
+	bool irq_enabled;
+	spinlock_t irq_lock;
+	bool phy_enabled;
+	struct fb_videomode previous_mode;
+	struct fb_videomode previous_non_vga_mode;
+	bool requesting_vga_for_initialization;
+};
+
+struct i2c_client *hdmi_i2c;
+
+static bool hdmi_inited;
+
+extern const struct fb_videomode mxc_cea_mode[64];
+
+#ifdef DEBUG
+static void dump_fb_videomode(struct fb_videomode *m)
+{
+	pr_debug("fb_videomode = %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
+		m->refresh, m->xres, m->yres, m->pixclock, m->left_margin,
+		m->right_margin, m->upper_margin, m->lower_margin,
+		m->hsync_len, m->vsync_len, m->sync, m->vmode, m->flag);
+}
+#else
+static void dump_fb_videomode(struct fb_videomode *m)
+{}
+#endif
+
+static ssize_t mxc_hdmi_show_name(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	strcpy(buf, hdmi->fbi->fix.id);
+	sprintf(buf+strlen(buf), "\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(fb_name, S_IRUGO, mxc_hdmi_show_name, NULL);
+
+static ssize_t mxc_hdmi_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+
+	if (hdmi->cable_plugin == false)
+		strcpy(buf, "plugout\n");
+	else
+		strcpy(buf, "plugin\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(cable_state, S_IRUGO, mxc_hdmi_show_state, NULL);
+
+static ssize_t mxc_hdmi_show_edid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxc_hdmi *hdmi = dev_get_drvdata(dev);
+	int i, j, len = 0;
+
+	for (j = 0; j < HDMI_EDID_LEN/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					hdmi->edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(edid, S_IRUGO, mxc_hdmi_show_edid, NULL);
+
+/*!
+ * this submodule is responsible for the video data synchronization.
+ * for example, for RGB 4:4:4 input, the data map is defined as
+ *			pin{47~40} <==> R[7:0]
+ *			pin{31~24} <==> G[7:0]
+ *			pin{15~8}  <==> B[7:0]
+ */
+static void hdmi_video_sample(struct mxc_hdmi *hdmi)
+{
+	int color_format = 0;
+	u8 val;
+
+	if (hdmi->hdmi_data.enc_in_format == RGB) {
+		if (hdmi->hdmi_data.enc_color_depth == 8)
+			color_format = 0x01;
+		else if (hdmi->hdmi_data.enc_color_depth == 10)
+			color_format = 0x03;
+		else if (hdmi->hdmi_data.enc_color_depth == 12)
+			color_format = 0x05;
+		else if (hdmi->hdmi_data.enc_color_depth == 16)
+			color_format = 0x07;
+		else
+			return;
+	} else if (hdmi->hdmi_data.enc_in_format == YCBCR444) {
+		if (hdmi->hdmi_data.enc_color_depth == 8)
+			color_format = 0x09;
+		else if (hdmi->hdmi_data.enc_color_depth == 10)
+			color_format = 0x0B;
+		else if (hdmi->hdmi_data.enc_color_depth == 12)
+			color_format = 0x0D;
+		else if (hdmi->hdmi_data.enc_color_depth == 16)
+			color_format = 0x0F;
+		else
+			return;
+	} else if (hdmi->hdmi_data.enc_in_format == YCBCR422_8BITS) {
+		if (hdmi->hdmi_data.enc_color_depth == 8)
+			color_format = 0x16;
+		else if (hdmi->hdmi_data.enc_color_depth == 10)
+			color_format = 0x14;
+		else if (hdmi->hdmi_data.enc_color_depth == 12)
+			color_format = 0x12;
+		else
+			return;
+	}
+
+	val = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |
+		((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
+		HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
+	hdmi_writeb(val, HDMI_TX_INVID0);
+
+	/* Enable TX stuffing: When DE is inactive, fix the output data to 0 */
+	val = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |
+		HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
+		HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
+	hdmi_writeb(val, HDMI_TX_INSTUFFING);
+	hdmi_writeb(0x0, HDMI_TX_GYDATA0);
+	hdmi_writeb(0x0, HDMI_TX_GYDATA1);
+	hdmi_writeb(0x0, HDMI_TX_RCRDATA0);
+	hdmi_writeb(0x0, HDMI_TX_RCRDATA1);
+	hdmi_writeb(0x0, HDMI_TX_BCBDATA0);
+	hdmi_writeb(0x0, HDMI_TX_BCBDATA1);
+}
+
+static int isColorSpaceConversion(struct mxc_hdmi *hdmi)
+{
+	return (hdmi->hdmi_data.enc_in_format !=
+		hdmi->hdmi_data.enc_out_format);
+}
+
+static int isColorSpaceDecimation(struct mxc_hdmi *hdmi)
+{
+	return ((hdmi->hdmi_data.enc_out_format == YCBCR422_8BITS) &&
+		(hdmi->hdmi_data.enc_in_format == RGB ||
+		hdmi->hdmi_data.enc_in_format == YCBCR444));
+}
+
+static int isColorSpaceInterpolation(struct mxc_hdmi *hdmi)
+{
+	return ((hdmi->hdmi_data.enc_in_format == YCBCR422_8BITS) &&
+		(hdmi->hdmi_data.enc_out_format == RGB
+		|| hdmi->hdmi_data.enc_out_format == YCBCR444));
+}
+
+/*!
+ * update the color space conversion coefficients.
+ */
+static void update_csc_coeffs(struct mxc_hdmi *hdmi)
+{
+	unsigned short csc_coeff[3][4];
+	unsigned int csc_scale = 1;
+	u8 val;
+	bool coeff_selected = false;
+
+	if (isColorSpaceConversion(hdmi)) { /* csc needed */
+		if (hdmi->hdmi_data.enc_out_format == RGB) {
+			if (hdmi->hdmi_data.colorimetry == eITU601) {
+				csc_coeff[0][0] = 0x2000;
+				csc_coeff[0][1] = 0x6926;
+				csc_coeff[0][2] = 0x74fd;
+				csc_coeff[0][3] = 0x010e;
+
+				csc_coeff[1][0] = 0x2000;
+				csc_coeff[1][1] = 0x2cdd;
+				csc_coeff[1][2] = 0x0000;
+				csc_coeff[1][3] = 0x7e9a;
+
+				csc_coeff[2][0] = 0x2000;
+				csc_coeff[2][1] = 0x0000;
+				csc_coeff[2][2] = 0x38b4;
+				csc_coeff[2][3] = 0x7e3b;
+
+				csc_scale = 1;
+				coeff_selected = true;
+			} else if (hdmi->hdmi_data.colorimetry == eITU709) {
+				csc_coeff[0][0] = 0x2000;
+				csc_coeff[0][1] = 0x7106;
+				csc_coeff[0][2] = 0x7a02;
+				csc_coeff[0][3] = 0x00a7;
+
+				csc_coeff[1][0] = 0x2000;
+				csc_coeff[1][1] = 0x3264;
+				csc_coeff[1][2] = 0x0000;
+				csc_coeff[1][3] = 0x7e6d;
+
+				csc_coeff[2][0] = 0x2000;
+				csc_coeff[2][1] = 0x0000;
+				csc_coeff[2][2] = 0x3b61;
+				csc_coeff[2][3] = 0x7e25;
+
+				csc_scale = 1;
+				coeff_selected = true;
+			}
+		} else if (hdmi->hdmi_data.enc_in_format == RGB) {
+			if (hdmi->hdmi_data.colorimetry == eITU601) {
+				csc_coeff[0][0] = 0x2591;
+				csc_coeff[0][1] = 0x1322;
+				csc_coeff[0][2] = 0x074b;
+				csc_coeff[0][3] = 0x0000;
+
+				csc_coeff[1][0] = 0x6535;
+				csc_coeff[1][1] = 0x2000;
+				csc_coeff[1][2] = 0x7acc;
+				csc_coeff[1][3] = 0x0200;
+
+				csc_coeff[2][0] = 0x6acd;
+				csc_coeff[2][1] = 0x7534;
+				csc_coeff[2][2] = 0x2000;
+				csc_coeff[2][3] = 0x0200;
+
+				csc_scale = 0;
+				coeff_selected = true;
+			} else if (hdmi->hdmi_data.colorimetry == eITU709) {
+				csc_coeff[0][0] = 0x2dc5;
+				csc_coeff[0][1] = 0x0d9b;
+				csc_coeff[0][2] = 0x049e;
+				csc_coeff[0][3] = 0x0000;
+
+				csc_coeff[1][0] = 0x62f0;
+				csc_coeff[1][1] = 0x2000;
+				csc_coeff[1][2] = 0x7d11;
+				csc_coeff[1][3] = 0x0200;
+
+				csc_coeff[2][0] = 0x6756;
+				csc_coeff[2][1] = 0x78ab;
+				csc_coeff[2][2] = 0x2000;
+				csc_coeff[2][3] = 0x0200;
+
+				csc_scale = 0;
+				coeff_selected = true;
+			}
+		}
+	}
+
+	if (!coeff_selected) {
+		csc_coeff[0][0] = 0x2000;
+		csc_coeff[0][1] = 0x0000;
+		csc_coeff[0][2] = 0x0000;
+		csc_coeff[0][3] = 0x0000;
+
+		csc_coeff[1][0] = 0x0000;
+		csc_coeff[1][1] = 0x2000;
+		csc_coeff[1][2] = 0x0000;
+		csc_coeff[1][3] = 0x0000;
+
+		csc_coeff[2][0] = 0x0000;
+		csc_coeff[2][1] = 0x0000;
+		csc_coeff[2][2] = 0x2000;
+		csc_coeff[2][3] = 0x0000;
+
+		csc_scale = 1;
+	}
+
+	/* Update CSC parameters in HDMI CSC registers */
+	hdmi_writeb((unsigned char)(csc_coeff[0][0] & 0xFF),
+		HDMI_CSC_COEF_A1_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][0] >> 8),
+		HDMI_CSC_COEF_A1_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][1] & 0xFF),
+		HDMI_CSC_COEF_A2_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][1] >> 8),
+		HDMI_CSC_COEF_A2_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][2] & 0xFF),
+		HDMI_CSC_COEF_A3_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][2] >> 8),
+		HDMI_CSC_COEF_A3_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][3] & 0xFF),
+		HDMI_CSC_COEF_A4_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[0][3] >> 8),
+		HDMI_CSC_COEF_A4_MSB);
+
+	hdmi_writeb((unsigned char)(csc_coeff[1][0] & 0xFF),
+		HDMI_CSC_COEF_B1_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][0] >> 8),
+		HDMI_CSC_COEF_B1_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][1] & 0xFF),
+		HDMI_CSC_COEF_B2_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][1] >> 8),
+		HDMI_CSC_COEF_B2_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][2] & 0xFF),
+		HDMI_CSC_COEF_B3_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][2] >> 8),
+		HDMI_CSC_COEF_B3_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][3] & 0xFF),
+		HDMI_CSC_COEF_B4_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[1][3] >> 8),
+		HDMI_CSC_COEF_B4_MSB);
+
+	hdmi_writeb((unsigned char)(csc_coeff[2][0] & 0xFF),
+		HDMI_CSC_COEF_C1_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][0] >> 8),
+		HDMI_CSC_COEF_C1_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][1] & 0xFF),
+		HDMI_CSC_COEF_C2_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][1] >> 8),
+		HDMI_CSC_COEF_C2_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][2] & 0xFF),
+		HDMI_CSC_COEF_C3_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][2] >> 8),
+		HDMI_CSC_COEF_C3_MSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][3] & 0xFF),
+		HDMI_CSC_COEF_C4_LSB);
+	hdmi_writeb((unsigned char)(csc_coeff[2][3] >> 8),
+		HDMI_CSC_COEF_C4_MSB);
+
+	val = hdmi_readb(HDMI_CSC_SCALE);
+	val &= ~HDMI_CSC_SCALE_CSCSCALE_MASK;
+	val |= csc_scale & HDMI_CSC_SCALE_CSCSCALE_MASK;
+	hdmi_writeb(val, HDMI_CSC_SCALE);
+}
+
+static void hdmi_video_csc(struct mxc_hdmi *hdmi)
+{
+	int color_depth = 0;
+	int interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;
+	int decimation = 0;
+	u8 val;
+
+	/* YCC422 interpolation to 444 mode */
+	if (isColorSpaceInterpolation(hdmi))
+		interpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;
+	else if (isColorSpaceDecimation(hdmi))
+		decimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;
+
+	if (hdmi->hdmi_data.enc_color_depth == 8)
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;
+	else if (hdmi->hdmi_data.enc_color_depth == 10)
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;
+	else if (hdmi->hdmi_data.enc_color_depth == 12)
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;
+	else if (hdmi->hdmi_data.enc_color_depth == 16)
+		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;
+	else
+		return;
+
+	/*configure the CSC registers */
+	hdmi_writeb(interpolation | decimation, HDMI_CSC_CFG);
+	val = hdmi_readb(HDMI_CSC_SCALE);
+	val &= ~HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK;
+	val |= color_depth;
+	hdmi_writeb(val, HDMI_CSC_SCALE);
+
+	update_csc_coeffs(hdmi);
+}
+
+/*!
+ * HDMI video packetizer is used to packetize the data.
+ * for example, if input is YCC422 mode or repeater is used,
+ * data should be repacked this module can be bypassed.
+ */
+static void hdmi_video_packetize(struct mxc_hdmi *hdmi)
+{
+	unsigned int color_depth = 0;
+	unsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;
+	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
+	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
+	u8 val;
+
+	if (hdmi_data->enc_out_format == RGB
+		|| hdmi_data->enc_out_format == YCBCR444) {
+		if (hdmi_data->enc_color_depth == 0)
+			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
+		else if (hdmi_data->enc_color_depth == 8) {
+			color_depth = 4;
+			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
+		} else if (hdmi_data->enc_color_depth == 10)
+			color_depth = 5;
+		else if (hdmi_data->enc_color_depth == 12)
+			color_depth = 6;
+		else if (hdmi_data->enc_color_depth == 16)
+			color_depth = 7;
+		else
+			return;
+	} else if (hdmi_data->enc_out_format == YCBCR422_8BITS) {
+		if (hdmi_data->enc_color_depth == 0 ||
+			hdmi_data->enc_color_depth == 8)
+			remap_size = HDMI_VP_REMAP_YCC422_16bit;
+		else if (hdmi_data->enc_color_depth == 10)
+			remap_size = HDMI_VP_REMAP_YCC422_20bit;
+		else if (hdmi_data->enc_color_depth == 12)
+			remap_size = HDMI_VP_REMAP_YCC422_24bit;
+		else
+			return;
+		output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;
+	} else
+		return;
+
+	/* HDMI not support deep color,
+	 * because IPU MAX support color depth is 24bit */
+	color_depth = 0;
+
+	/* set the packetizer registers */
+	val = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
+		HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
+		((hdmi_data->pix_repet_factor <<
+		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
+		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
+	hdmi_writeb(val, HDMI_VP_PR_CD);
+
+	val = hdmi_readb(HDMI_VP_STUFF);
+	val &= ~HDMI_VP_STUFF_PR_STUFFING_MASK;
+	val |= HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE;
+	hdmi_writeb(val, HDMI_VP_STUFF);
+
+	/* Data from pixel repeater block */
+	if (hdmi_data->pix_repet_factor > 1) {
+		val = hdmi_readb(HDMI_VP_CONF);
+		val &= ~(HDMI_VP_CONF_PR_EN_MASK |
+			HDMI_VP_CONF_BYPASS_SELECT_MASK);
+		val |= HDMI_VP_CONF_PR_EN_ENABLE |
+			HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;
+		hdmi_writeb(val, HDMI_VP_CONF);
+	} else { /* data from packetizer block */
+		val = hdmi_readb(HDMI_VP_CONF);
+		val &= ~(HDMI_VP_CONF_PR_EN_MASK |
+			HDMI_VP_CONF_BYPASS_SELECT_MASK);
+		val |= HDMI_VP_CONF_PR_EN_DISABLE |
+			HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;
+		hdmi_writeb(val, HDMI_VP_CONF);
+	}
+
+	val = hdmi_readb(HDMI_VP_STUFF);
+	val &= ~HDMI_VP_STUFF_IDEFAULT_PHASE_MASK;
+	val |= 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET;
+	hdmi_writeb(val, HDMI_VP_STUFF);
+
+	hdmi_writeb(remap_size, HDMI_VP_REMAP);
+
+	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
+		val = hdmi_readb(HDMI_VP_CONF);
+		val &= ~(HDMI_VP_CONF_BYPASS_EN_MASK |
+			HDMI_VP_CONF_PP_EN_ENMASK |
+			HDMI_VP_CONF_YCC422_EN_MASK);
+		val |= HDMI_VP_CONF_BYPASS_EN_DISABLE |
+			HDMI_VP_CONF_PP_EN_ENABLE |
+			HDMI_VP_CONF_YCC422_EN_DISABLE;
+		hdmi_writeb(val, HDMI_VP_CONF);
+	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {
+		val = hdmi_readb(HDMI_VP_CONF);
+		val &= ~(HDMI_VP_CONF_BYPASS_EN_MASK |
+			HDMI_VP_CONF_PP_EN_ENMASK |
+			HDMI_VP_CONF_YCC422_EN_MASK);
+		val |= HDMI_VP_CONF_BYPASS_EN_DISABLE |
+			HDMI_VP_CONF_PP_EN_DISABLE |
+			HDMI_VP_CONF_YCC422_EN_ENABLE;
+		hdmi_writeb(val, HDMI_VP_CONF);
+	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {
+		val = hdmi_readb(HDMI_VP_CONF);
+		val &= ~(HDMI_VP_CONF_BYPASS_EN_MASK |
+			HDMI_VP_CONF_PP_EN_ENMASK |
+			HDMI_VP_CONF_YCC422_EN_MASK);
+		val |= HDMI_VP_CONF_BYPASS_EN_ENABLE |
+			HDMI_VP_CONF_PP_EN_DISABLE |
+			HDMI_VP_CONF_YCC422_EN_DISABLE;
+		hdmi_writeb(val, HDMI_VP_CONF);
+	} else {
+		return;
+	}
+
+	val = hdmi_readb(HDMI_VP_STUFF);
+	val &= ~(HDMI_VP_STUFF_PP_STUFFING_MASK |
+		HDMI_VP_STUFF_YCC422_STUFFING_MASK);
+	val |= HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
+		HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE;
+	hdmi_writeb(val, HDMI_VP_STUFF);
+
+	val = hdmi_readb(HDMI_VP_CONF);
+	val &= ~HDMI_VP_CONF_OUTPUT_SELECTOR_MASK;
+	val |= output_select;
+	hdmi_writeb(val, HDMI_VP_CONF);
+}
+
+#if 0
+/* Force a fixed color screen */
+static void hdmi_video_force_output(struct mxc_hdmi *hdmi, unsigned char force)
+{
+	u8 val;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	if (force) {
+		hdmi_writeb(0x00, HDMI_FC_DBGTMDS2);   /* R */
+		hdmi_writeb(0x00, HDMI_FC_DBGTMDS1);   /* G */
+		hdmi_writeb(0xFF, HDMI_FC_DBGTMDS0);   /* B */
+		val = hdmi_readb(HDMI_FC_DBGFORCE);
+		val |= HDMI_FC_DBGFORCE_FORCEVIDEO;
+		hdmi_writeb(val, HDMI_FC_DBGFORCE);
+	} else {
+		val = hdmi_readb(HDMI_FC_DBGFORCE);
+		val &= ~HDMI_FC_DBGFORCE_FORCEVIDEO;
+		hdmi_writeb(val, HDMI_FC_DBGFORCE);
+		hdmi_writeb(0x00, HDMI_FC_DBGTMDS2);   /* R */
+		hdmi_writeb(0x00, HDMI_FC_DBGTMDS1);   /* G */
+		hdmi_writeb(0x00, HDMI_FC_DBGTMDS0);   /* B */
+	}
+}
+#endif
+
+static inline void hdmi_phy_test_clear(struct mxc_hdmi *hdmi,
+						unsigned char bit)
+{
+	u8 val = hdmi_readb(HDMI_PHY_TST0);
+	val &= ~HDMI_PHY_TST0_TSTCLR_MASK;
+	val |= (bit << HDMI_PHY_TST0_TSTCLR_OFFSET) &
+		HDMI_PHY_TST0_TSTCLR_MASK;
+	hdmi_writeb(val, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_enable(struct mxc_hdmi *hdmi,
+						unsigned char bit)
+{
+	u8 val = hdmi_readb(HDMI_PHY_TST0);
+	val &= ~HDMI_PHY_TST0_TSTEN_MASK;
+	val |= (bit << HDMI_PHY_TST0_TSTEN_OFFSET) &
+		HDMI_PHY_TST0_TSTEN_MASK;
+	hdmi_writeb(val, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_clock(struct mxc_hdmi *hdmi,
+						unsigned char bit)
+{
+	u8 val = hdmi_readb(HDMI_PHY_TST0);
+	val &= ~HDMI_PHY_TST0_TSTCLK_MASK;
+	val |= (bit << HDMI_PHY_TST0_TSTCLK_OFFSET) &
+		HDMI_PHY_TST0_TSTCLK_MASK;
+	hdmi_writeb(val, HDMI_PHY_TST0);
+}
+
+static inline void hdmi_phy_test_din(struct mxc_hdmi *hdmi,
+						unsigned char bit)
+{
+	hdmi_writeb(bit, HDMI_PHY_TST1);
+}
+
+static inline void hdmi_phy_test_dout(struct mxc_hdmi *hdmi,
+						unsigned char bit)
+{
+	hdmi_writeb(bit, HDMI_PHY_TST2);
+}
+
+static bool hdmi_phy_wait_i2c_done(struct mxc_hdmi *hdmi, int msec)
+{
+	unsigned char val = 0;
+	val = hdmi_readb(HDMI_IH_I2CMPHY_STAT0) & 0x3;
+	while (val == 0) {
+		udelay(1000);
+		if (msec-- == 0)
+			return false;
+		val = hdmi_readb(HDMI_IH_I2CMPHY_STAT0) & 0x3;
+	}
+	return true;
+}
+
+static void hdmi_phy_i2c_write(struct mxc_hdmi *hdmi, unsigned short data,
+			      unsigned char addr)
+{
+	hdmi_writeb(0xFF, HDMI_IH_I2CMPHY_STAT0);
+	hdmi_writeb(addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
+	hdmi_writeb((unsigned char)(data >> 8),
+		HDMI_PHY_I2CM_DATAO_1_ADDR);
+	hdmi_writeb((unsigned char)(data >> 0),
+		HDMI_PHY_I2CM_DATAO_0_ADDR);
+	hdmi_writeb(HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,
+		HDMI_PHY_I2CM_OPERATION_ADDR);
+	hdmi_phy_wait_i2c_done(hdmi, 1000);
+}
+
+#if 0
+static unsigned short hdmi_phy_i2c_read(struct mxc_hdmi *hdmi,
+					unsigned char addr)
+{
+	unsigned short data;
+	unsigned char msb = 0, lsb = 0;
+	hdmi_writeb(0xFF, HDMI_IH_I2CMPHY_STAT0);
+	hdmi_writeb(addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
+	hdmi_writeb(HDMI_PHY_I2CM_OPERATION_ADDR_READ,
+		HDMI_PHY_I2CM_OPERATION_ADDR);
+	hdmi_phy_wait_i2c_done(hdmi, 1000);
+	msb = hdmi_readb(HDMI_PHY_I2CM_DATAI_1_ADDR);
+	lsb = hdmi_readb(HDMI_PHY_I2CM_DATAI_0_ADDR);
+	data = (msb << 8) | lsb;
+	return data;
+}
+
+static int hdmi_phy_i2c_write_verify(struct mxc_hdmi *hdmi, unsigned short data,
+				     unsigned char addr)
+{
+	unsigned short val = 0;
+	hdmi_phy_i2c_write(hdmi, data, addr);
+	val = hdmi_phy_i2c_read(hdmi, addr);
+	return (val == data);
+}
+#endif
+
+/* "Power-down enable (active low)"
+ * That mean that power up == 1! */
+static void mxc_hdmi_phy_enable_power(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_PDZ_OFFSET,
+			HDMI_PHY_CONF0_PDZ_MASK);
+}
+
+static void mxc_hdmi_phy_enable_tmds(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_ENTMDS_OFFSET,
+			HDMI_PHY_CONF0_ENTMDS_MASK);
+}
+
+static void mxc_hdmi_phy_gen2_pddq(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,
+			HDMI_PHY_CONF0_GEN2_PDDQ_MASK);
+}
+
+static void mxc_hdmi_phy_gen2_txpwron(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,
+			HDMI_PHY_CONF0_GEN2_TXPWRON_MASK);
+}
+
+#if 0
+static void mxc_hdmi_phy_gen2_enhpdrxsense(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET,
+			HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK);
+}
+#endif
+
+static void mxc_hdmi_phy_sel_data_en_pol(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_SELDATAENPOL_OFFSET,
+			HDMI_PHY_CONF0_SELDATAENPOL_MASK);
+}
+
+static void mxc_hdmi_phy_sel_interface_control(u8 enable)
+{
+	hdmi_mask_writeb(enable, HDMI_PHY_CONF0,
+			HDMI_PHY_CONF0_SELDIPIF_OFFSET,
+			HDMI_PHY_CONF0_SELDIPIF_MASK);
+}
+
+static int hdmi_phy_configure(struct mxc_hdmi *hdmi, unsigned char pRep,
+			      unsigned char cRes, int cscOn)
+{
+	u8 val;
+	u8 msec;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* color resolution 0 is 8 bit colour depth */
+	if (cRes == 0)
+		cRes = 8;
+
+	if (pRep != 0)
+		return false;
+	else if (cRes != 8 && cRes != 12)
+		return false;
+
+	/* Enable csc path */
+	if (cscOn)
+		val = HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH;
+	else
+		val = HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS;
+
+	hdmi_writeb(val, HDMI_MC_FLOWCTRL);
+
+	/* gen2 tx power off */
+	mxc_hdmi_phy_gen2_txpwron(0);
+
+	/* gen2 pddq */
+	mxc_hdmi_phy_gen2_pddq(1);
+
+	/* PHY reset */
+	hdmi_writeb(HDMI_MC_PHYRSTZ_DEASSERT, HDMI_MC_PHYRSTZ);
+	hdmi_writeb(HDMI_MC_PHYRSTZ_ASSERT, HDMI_MC_PHYRSTZ);
+
+	hdmi_writeb(HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
+
+	hdmi_phy_test_clear(hdmi, 1);
+	hdmi_writeb(HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2,
+			HDMI_PHY_I2CM_SLAVE_ADDR);
+	hdmi_phy_test_clear(hdmi, 0);
+
+	if (hdmi->hdmi_data.video_mode.mPixelClock < 0) {
+		dev_dbg(&hdmi->pdev->dev, "Pixel clock (%d) must be positive\n",
+			hdmi->hdmi_data.video_mode.mPixelClock);
+		return false;
+	}
+
+	if (hdmi->hdmi_data.video_mode.mPixelClock <= 45250000) {
+		switch (cRes) {
+		case 8:
+			/* PLL/MPLL Cfg */
+			hdmi_phy_i2c_write(hdmi, 0x01e0, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0000, 0x15);  /* GMPCTRL */
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x21e1, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0000, 0x15);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x41e2, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0000, 0x15);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 92500000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x0140, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0005, 0x15);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x2141, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0005, 0x15);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x4142, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x0005, 0x15);
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 148500000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x00a0, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x20a1, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x40a2, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
+		default:
+			return false;
+		}
+	} else {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x00a0, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000a, 0x15);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x2001, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000f, 0x15);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x4002, 0x06);
+			hdmi_phy_i2c_write(hdmi, 0x000f, 0x15);
+		default:
+			return false;
+		}
+	}
+
+	if (hdmi->hdmi_data.video_mode.mPixelClock <= 54000000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);  /* CURRCTRL */
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 58400000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 72000000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 74250000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x0b5c, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 118800000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else if (hdmi->hdmi_data.video_mode.mPixelClock <= 216000000) {
+		switch (cRes) {
+		case 8:
+			hdmi_phy_i2c_write(hdmi, 0x06dc, 0x10);
+			break;
+		case 10:
+			hdmi_phy_i2c_write(hdmi, 0x0b5c, 0x10);
+			break;
+		case 12:
+			hdmi_phy_i2c_write(hdmi, 0x091c, 0x10);
+			break;
+		default:
+			return false;
+		}
+	} else {
+		dev_err(&hdmi->pdev->dev,
+				"Pixel clock %d - unsupported by HDMI\n",
+				hdmi->hdmi_data.video_mode.mPixelClock);
+		return false;
+	}
+
+	hdmi_phy_i2c_write(hdmi, 0x0000, 0x13);  /* PLLPHBYCTRL */
+	hdmi_phy_i2c_write(hdmi, 0x0006, 0x17);
+	/* RESISTANCE TERM 133Ohm Cfg */
+	hdmi_phy_i2c_write(hdmi, 0x0005, 0x19);  /* TXTERM */
+	/* PREEMP Cgf 0.00 */
+	hdmi_phy_i2c_write(hdmi, 0x8009, 0x09);  /* CKSYMTXCTRL */
+	/* TX/CK LVL 10 */
+	hdmi_phy_i2c_write(hdmi, 0x0210, 0x0E);  /* VLEVCTRL */
+	/* REMOVE CLK TERM */
+	hdmi_phy_i2c_write(hdmi, 0x8000, 0x05);  /* CKCALCTRL */
+
+	if (hdmi->hdmi_data.video_mode.mPixelClock > 148500000) {
+			hdmi_phy_i2c_write(hdmi, 0x800b, 0x09);
+			hdmi_phy_i2c_write(hdmi, 0x0129, 0x0E);
+	}
+
+	mxc_hdmi_phy_enable_power(1);
+
+	/* toggle TMDS enable */
+	mxc_hdmi_phy_enable_tmds(0);
+	mxc_hdmi_phy_enable_tmds(1);
+
+	/* gen2 tx power on */
+	mxc_hdmi_phy_gen2_txpwron(1);
+	mxc_hdmi_phy_gen2_pddq(0);
+
+	/*Wait for PHY PLL lock */
+	msec = 4;
+	val = hdmi_readb(HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
+	while (val == 0) {
+		udelay(1000);
+		if (msec-- == 0) {
+			dev_err(&hdmi->pdev->dev, "PHY PLL not locked\n");
+			return false;
+		}
+		val = hdmi_readb(HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
+	}
+
+	return true;
+}
+
+static void mxc_hdmi_phy_init(struct mxc_hdmi *hdmi)
+{
+	int i;
+	bool cscon = false;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Never do phy init if pixel clock is gated.
+	 * Otherwise HDMI PHY will get messed up and generate an overflow
+	 * interrupt that can't be cleared or detected by accessing the
+	 * status register. */
+	if (!hdmi->fb_reg || !hdmi->cable_plugin
+			|| (hdmi->blank != FB_BLANK_UNBLANK))
+		return;
+
+	/*check csc whether needed activated in HDMI mode */
+	cscon = (isColorSpaceConversion(hdmi) &&
+			!hdmi->hdmi_data.video_mode.mDVI);
+
+	/* HDMI Phy spec says to do the phy initialization sequence twice */
+	for (i = 0 ; i < 2 ; i++) {
+		mxc_hdmi_phy_sel_data_en_pol(1);
+		mxc_hdmi_phy_sel_interface_control(0);
+		mxc_hdmi_phy_enable_tmds(0);
+		mxc_hdmi_phy_enable_power(0);
+
+		/* Enable CSC */
+		hdmi_phy_configure(hdmi, 0, 8, cscon);
+	}
+
+	hdmi->phy_enabled = true;
+}
+
+static void hdmi_tx_hdcp_config(struct mxc_hdmi *hdmi)
+{
+	u8 de, val;
+
+	if (hdmi->hdmi_data.video_mode.mDataEnablePolarity)
+		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
+	else
+		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;
+
+	/* disable rx detect */
+	val = hdmi_readb(HDMI_A_HDCPCFG0);
+	val &= HDMI_A_HDCPCFG0_RXDETECT_MASK;
+	val |= HDMI_A_HDCPCFG0_RXDETECT_DISABLE;
+	hdmi_writeb(val, HDMI_A_HDCPCFG0);
+
+	val = hdmi_readb(HDMI_A_VIDPOLCFG);
+	val &= HDMI_A_VIDPOLCFG_DATAENPOL_MASK;
+	val |= de;
+	hdmi_writeb(val, HDMI_A_VIDPOLCFG);
+
+	val = hdmi_readb(HDMI_A_HDCPCFG1);
+	val &= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK;
+	val |= HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE;
+	hdmi_writeb(val, HDMI_A_HDCPCFG1);
+}
+
+static void hdmi_config_AVI(struct mxc_hdmi *hdmi)
+{
+	u8 val;
+	u8 pix_fmt;
+	u8 under_scan;
+	u8 act_ratio, coded_ratio, colorimetry, ext_colorimetry;
+	struct fb_videomode mode;
+	const struct fb_videomode *edid_mode;
+	bool aspect_16_9;
+
+	dev_dbg(&hdmi->pdev->dev, "set up AVI frame\n");
+
+	fb_var_to_videomode(&mode, &hdmi->fbi->var);
+	/* Use mode from list extracted from EDID to get aspect ratio */
+	if (!list_empty(&hdmi->fbi->modelist)) {
+		edid_mode = fb_find_nearest_mode(&mode, &hdmi->fbi->modelist);
+		if (edid_mode->vmode & FB_VMODE_ASPECT_16_9)
+			aspect_16_9 = true;
+		else
+			aspect_16_9 = false;
+	} else
+		aspect_16_9 = false;
+
+	/********************************************
+	 * AVI Data Byte 1
+	 ********************************************/
+	if (hdmi->hdmi_data.enc_out_format == YCBCR444)
+		pix_fmt = HDMI_FC_AVICONF0_PIX_FMT_YCBCR444;
+	else if (hdmi->hdmi_data.enc_out_format == YCBCR422_8BITS)
+		pix_fmt = HDMI_FC_AVICONF0_PIX_FMT_YCBCR422;
+	else
+		pix_fmt = HDMI_FC_AVICONF0_PIX_FMT_RGB;
+
+	if (hdmi->edid_cfg.cea_underscan)
+		under_scan = HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN;
+	else
+		under_scan =  HDMI_FC_AVICONF0_SCAN_INFO_NODATA;
+
+	/*
+	 * Active format identification data is present in the AVI InfoFrame.
+	 * Under scan info, no bar data
+	 */
+	val = pix_fmt | under_scan |
+		HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT |
+		HDMI_FC_AVICONF0_BAR_DATA_NO_DATA;
+
+	hdmi_writeb(val, HDMI_FC_AVICONF0);
+
+	/********************************************
+	 * AVI Data Byte 2
+	 ********************************************/
+
+	/*  Set the Aspect Ratio */
+	if (aspect_16_9) {
+		act_ratio = HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9;
+		coded_ratio = HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9;
+	} else {
+		act_ratio = HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3;
+		coded_ratio = HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3;
+	}
+
+	/* Set up colorimetry */
+	if (hdmi->hdmi_data.enc_out_format == XVYCC444) {
+		colorimetry = HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO;
+		if (hdmi->hdmi_data.colorimetry == eITU601)
+			ext_colorimetry =
+				HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;
+		else /* hdmi->hdmi_data.colorimetry == eITU709 */
+			ext_colorimetry =
+				HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709;
+	} else if (hdmi->hdmi_data.enc_out_format != RGB) {
+		if (hdmi->hdmi_data.colorimetry == eITU601)
+			colorimetry = HDMI_FC_AVICONF1_COLORIMETRY_SMPTE;
+		else /* hdmi->hdmi_data.colorimetry == eITU709 */
+			colorimetry = HDMI_FC_AVICONF1_COLORIMETRY_ITUR;
+		ext_colorimetry = HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;
+	} else { /* Carries no data */
+		colorimetry = HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA;
+		ext_colorimetry = HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601;
+	}
+
+	val = colorimetry | coded_ratio | act_ratio;
+	hdmi_writeb(val, HDMI_FC_AVICONF1);
+
+	/********************************************
+	 * AVI Data Byte 3
+	 ********************************************/
+
+	val = HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA | ext_colorimetry |
+		HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT |
+		HDMI_FC_AVICONF2_SCALING_NONE;
+	hdmi_writeb(val, HDMI_FC_AVICONF2);
+
+	/********************************************
+	 * AVI Data Byte 4
+	 ********************************************/
+	hdmi_writeb(hdmi->vic, HDMI_FC_AVIVID);
+
+	/********************************************
+	 * AVI Data Byte 5
+	 ********************************************/
+
+	/* Set up input and output pixel repetition */
+	val = (((hdmi->hdmi_data.video_mode.mPixelRepetitionInput + 1) <<
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK) |
+		((hdmi->hdmi_data.video_mode.mPixelRepetitionOutput <<
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET) &
+		HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK);
+	hdmi_writeb(val, HDMI_FC_PRCONF);
+
+	/* IT Content and quantization range = don't care */
+	val = HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS |
+		HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED;
+	hdmi_writeb(val, HDMI_FC_AVICONF3);
+
+	/********************************************
+	 * AVI Data Bytes 6-13
+	 ********************************************/
+	hdmi_writeb(0, HDMI_FC_AVIETB0);
+	hdmi_writeb(0, HDMI_FC_AVIETB1);
+	hdmi_writeb(0, HDMI_FC_AVISBB0);
+	hdmi_writeb(0, HDMI_FC_AVISBB1);
+	hdmi_writeb(0, HDMI_FC_AVIELB0);
+	hdmi_writeb(0, HDMI_FC_AVIELB1);
+	hdmi_writeb(0, HDMI_FC_AVISRB0);
+	hdmi_writeb(0, HDMI_FC_AVISRB1);
+}
+
+/*!
+ * this submodule is responsible for the video/audio data composition.
+ */
+static void hdmi_av_composer(struct mxc_hdmi *hdmi)
+{
+	u8 inv_val;
+	struct fb_info *fbi = hdmi->fbi;
+	struct fb_videomode fb_mode;
+	struct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;
+	int hblank, vblank;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	fb_var_to_videomode(&fb_mode, &fbi->var);
+
+	vmode->mHSyncPolarity = ((fb_mode.sync & FB_SYNC_HOR_HIGH_ACT) != 0);
+	vmode->mVSyncPolarity = ((fb_mode.sync & FB_SYNC_VERT_HIGH_ACT) != 0);
+	vmode->mInterlaced = ((fb_mode.vmode & FB_VMODE_INTERLACED) != 0);
+	vmode->mPixelClock = (fb_mode.xres + fb_mode.left_margin +
+		fb_mode.right_margin + fb_mode.hsync_len) * (fb_mode.yres +
+		fb_mode.upper_margin + fb_mode.lower_margin +
+		fb_mode.vsync_len) * fb_mode.refresh;
+
+	dev_dbg(&hdmi->pdev->dev, "final pixclk = %d\n", vmode->mPixelClock);
+
+	/* Set up HDMI_FC_INVIDCONF */
+	inv_val = (hdmi->hdmi_data.hdcp_enable ?
+		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :
+		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);
+
+	inv_val |= (vmode->mVSyncPolarity ?
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW);
+
+	inv_val |= (vmode->mHSyncPolarity ?
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW);
+
+	inv_val |= (vmode->mDataEnablePolarity ?
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
+		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
+
+	if (hdmi->vic == 39)
+		inv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;
+	else
+		inv_val |= (vmode->mInterlaced ?
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
+			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW);
+
+	inv_val |= (vmode->mInterlaced ?
+		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
+		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE);
+
+	inv_val |= (vmode->mDVI ?
+		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE :
+		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE);
+
+	hdmi_writeb(inv_val, HDMI_FC_INVIDCONF);
+
+	/* Set up horizontal active pixel region width */
+	hdmi_writeb(fb_mode.xres >> 8, HDMI_FC_INHACTV1);
+	hdmi_writeb(fb_mode.xres, HDMI_FC_INHACTV0);
+
+	/* Set up vertical blanking pixel region width */
+	hdmi_writeb(fb_mode.yres >> 8, HDMI_FC_INVACTV1);
+	hdmi_writeb(fb_mode.yres, HDMI_FC_INVACTV0);
+
+	/* Set up horizontal blanking pixel region width */
+	hblank = fb_mode.left_margin + fb_mode.right_margin +
+		fb_mode.hsync_len;
+	hdmi_writeb(hblank >> 8, HDMI_FC_INHBLANK1);
+	hdmi_writeb(hblank, HDMI_FC_INHBLANK0);
+
+	/* Set up vertical blanking pixel region width */
+	vblank = fb_mode.upper_margin + fb_mode.lower_margin +
+		fb_mode.vsync_len;
+	hdmi_writeb(vblank, HDMI_FC_INVBLANK);
+
+	/* Set up HSYNC active edge delay width (in pixel clks) */
+	hdmi_writeb(fb_mode.right_margin >> 8, HDMI_FC_HSYNCINDELAY1);
+	hdmi_writeb(fb_mode.right_margin, HDMI_FC_HSYNCINDELAY0);
+
+	/* Set up VSYNC active edge delay (in pixel clks) */
+	hdmi_writeb(fb_mode.lower_margin, HDMI_FC_VSYNCINDELAY);
+
+	/* Set up HSYNC active pulse width (in pixel clks) */
+	hdmi_writeb(fb_mode.hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);
+	hdmi_writeb(fb_mode.hsync_len, HDMI_FC_HSYNCINWIDTH0);
+
+	/* Set up VSYNC active edge delay (in pixel clks) */
+	hdmi_writeb(fb_mode.vsync_len, HDMI_FC_VSYNCINWIDTH);
+
+	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
+}
+
+static int mxc_hdmi_read_edid(struct mxc_hdmi *hdmi)
+{
+	int ret;
+	u8 edid_old[HDMI_EDID_LEN];
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* save old edid */
+	memcpy(edid_old, hdmi->edid, HDMI_EDID_LEN);
+
+	ret = mxc_edid_read(hdmi_i2c->adapter, hdmi_i2c->addr, hdmi->edid,
+			    &hdmi->edid_cfg, hdmi->fbi);
+
+	if (ret < 0)
+		return HDMI_EDID_FAIL;
+
+	/* Save edid cfg for audio driver */
+	hdmi_set_edid_cfg(&hdmi->edid_cfg);
+
+	if (!memcmp(edid_old, hdmi->edid, HDMI_EDID_LEN)) {
+		dev_info(&hdmi->pdev->dev, "same edid\n");
+		return HDMI_EDID_SAME;
+	}
+
+	if (hdmi->fbi->monspecs.modedb_len == 0) {
+		dev_info(&hdmi->pdev->dev, "No modes read from edid\n");
+		return HDMI_EDID_NO_MODES;
+	}
+
+	return HDMI_EDID_SUCCESS;
+}
+
+static void mxc_hdmi_phy_disable(struct mxc_hdmi *hdmi)
+{
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	if (!hdmi->phy_enabled)
+		return;
+
+	/* Setting PHY to reset status */
+	hdmi_writeb(HDMI_MC_PHYRSTZ_DEASSERT, HDMI_MC_PHYRSTZ);
+
+	/* Power down PHY */
+	mxc_hdmi_phy_enable_tmds(0);
+	mxc_hdmi_phy_enable_power(0);
+	mxc_hdmi_phy_gen2_txpwron(0);
+	mxc_hdmi_phy_gen2_pddq(1);
+
+	hdmi->phy_enabled = false;
+	dev_dbg(&hdmi->pdev->dev, "%s - exit\n", __func__);
+}
+
+/* HDMI Initialization Step B.4 */
+static void mxc_hdmi_enable_video_path(struct mxc_hdmi *hdmi)
+{
+	u8 clkdis;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* control period minimum duration */
+	hdmi_writeb(12, HDMI_FC_CTRLDUR);
+	hdmi_writeb(32, HDMI_FC_EXCTRLDUR);
+	hdmi_writeb(1, HDMI_FC_EXCTRLSPAC);
+
+	/* Set to fill TMDS data channels */
+	hdmi_writeb(0x0B, HDMI_FC_CH0PREAM);
+	hdmi_writeb(0x16, HDMI_FC_CH1PREAM);
+	hdmi_writeb(0x21, HDMI_FC_CH2PREAM);
+
+	/* Enable pixel clock and tmds data path */
+	clkdis = 0x7F;
+	clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
+	hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+
+	clkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
+	hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+
+	/* Enable csc path */
+	if (isColorSpaceConversion(hdmi)) {
+		clkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;
+		hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+	}
+}
+
+static void hdmi_enable_audio_clk(struct mxc_hdmi *hdmi)
+{
+	u8 clkdis;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	clkdis = hdmi_readb(HDMI_MC_CLKDIS);
+	clkdis &= ~HDMI_MC_CLKDIS_AUDCLK_DISABLE;
+	hdmi_writeb(clkdis, HDMI_MC_CLKDIS);
+}
+
+/* Workaround to clear the overflow condition */
+static void mxc_hdmi_clear_overflow(void)
+{
+	int count;
+	u8 val;
+
+	val = hdmi_readb(HDMI_FC_INVIDCONF);
+
+	for (count = 0 ; count < 5 ; count++)
+		hdmi_writeb(val, HDMI_FC_INVIDCONF);
+
+	/* TMDS software reset */
+	hdmi_writeb((u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
+}
+
+static void hdmi_enable_overflow_interrupts(void)
+{
+	pr_debug("%s\n", __func__);
+	hdmi_writeb(0, HDMI_FC_MASK2);
+	hdmi_writeb(0, HDMI_IH_MUTE_FC_STAT2);
+}
+
+static void hdmi_disable_overflow_interrupts(void)
+{
+	pr_debug("%s\n", __func__);
+	hdmi_writeb(HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,
+		    HDMI_IH_MUTE_FC_STAT2);
+}
+
+static void mxc_hdmi_notify_fb(struct mxc_hdmi *hdmi)
+{
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Don't notify if we aren't registered yet */
+	WARN_ON(!hdmi->fb_reg);
+
+	/* disable the phy before ipu changes mode */
+	mxc_hdmi_phy_disable(hdmi);
+
+	/*
+	 * Note that fb_set_var will block.  During this time,
+	 * FB_EVENT_MODE_CHANGE callback will happen.
+	 * So by the end of this function, mxc_hdmi_setup()
+	 * will be done.
+	 */
+	hdmi->fbi->var.activate |= FB_ACTIVATE_FORCE;
+	console_lock();
+	hdmi->fbi->flags |= FBINFO_MISC_USEREVENT;
+	fb_set_var(hdmi->fbi, &hdmi->fbi->var);
+	hdmi->fbi->flags &= ~FBINFO_MISC_USEREVENT;
+	console_unlock();
+
+	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
+}
+
+static void mxc_hdmi_edid_rebuild_modelist(struct mxc_hdmi *hdmi)
+{
+	int i;
+	struct fb_videomode *mode;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	console_lock();
+
+	fb_destroy_modelist(&hdmi->fbi->modelist);
+	fb_add_videomode(&vga_mode, &hdmi->fbi->modelist);
+
+	for (i = 0; i < hdmi->fbi->monspecs.modedb_len; i++) {
+		/*
+		 * We might check here if mode is supported by HDMI.
+		 * We do not currently support interlaced modes.
+		 * And add CEA modes in the modelist.
+		 */
+		mode = &hdmi->fbi->monspecs.modedb[i];
+
+		if (!(mode->vmode & FB_VMODE_INTERLACED) &&
+				(mxc_edid_mode_to_vic(mode) != 0)) {
+
+			dev_dbg(&hdmi->pdev->dev, "Added mode %d:", i);
+			dev_dbg(&hdmi->pdev->dev,
+				"xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+				hdmi->fbi->monspecs.modedb[i].xres,
+				hdmi->fbi->monspecs.modedb[i].yres,
+				hdmi->fbi->monspecs.modedb[i].refresh,
+				hdmi->fbi->monspecs.modedb[i].vmode,
+				hdmi->fbi->monspecs.modedb[i].flag);
+
+			fb_add_videomode(mode, &hdmi->fbi->modelist);
+		}
+	}
+
+	console_unlock();
+}
+
+static void  mxc_hdmi_default_modelist(struct mxc_hdmi *hdmi)
+{
+	u32 i;
+	const struct fb_videomode *mode;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* If not EDID data read, set up default modelist  */
+	dev_info(&hdmi->pdev->dev, "No modes read from edid\n");
+	dev_info(&hdmi->pdev->dev, "create default modelist\n");
+
+	console_lock();
+
+	fb_destroy_modelist(&hdmi->fbi->modelist);
+
+	/*Add all no interlaced CEA mode to default modelist */
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		mode = &mxc_cea_mode[i];
+		if (!(mode->vmode & FB_VMODE_INTERLACED) && (mode->xres != 0))
+			fb_add_videomode(mode, &hdmi->fbi->modelist);
+	}
+
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
+
+	console_unlock();
+}
+
+static void mxc_hdmi_set_mode_to_vga_dvi(struct mxc_hdmi *hdmi)
+{
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi_disable_overflow_interrupts();
+
+	fb_videomode_to_var(&hdmi->fbi->var, &vga_mode);
+
+	hdmi->requesting_vga_for_initialization = true;
+	mxc_hdmi_notify_fb(hdmi);
+	hdmi->requesting_vga_for_initialization = false;
+}
+
+static void mxc_hdmi_set_mode(struct mxc_hdmi *hdmi)
+{
+	const struct fb_videomode *mode;
+	struct fb_videomode m;
+	struct fb_var_screeninfo var;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Set the default mode only once. */
+	if (!hdmi->dft_mode_set) {
+		dev_dbg(&hdmi->pdev->dev, "%s: setting to default=%s bpp=%d\n",
+			__func__, hdmi->dft_mode_str, hdmi->default_bpp);
+
+		fb_find_mode(&var, hdmi->fbi,
+			     hdmi->dft_mode_str, NULL, 0, NULL,
+			     hdmi->default_bpp);
+
+		hdmi->dft_mode_set = true;
+	} else
+		fb_videomode_to_var(&var, &hdmi->previous_non_vga_mode);
+
+	fb_var_to_videomode(&m, &var);
+	dump_fb_videomode(&m);
+
+	mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
+	if (!mode) {
+		pr_err("%s: could not find mode in modelist\n", __func__);
+		return;
+	}
+
+	/* If video mode same as previous, init HDMI PHY and return */
+	if (fb_mode_is_equal(&hdmi->previous_non_vga_mode, mode)) {
+		dev_dbg(&hdmi->pdev->dev,
+				"%s: Video mode same as previous\n", __func__);
+		/* update fbi mode in case modelist is updated */
+		hdmi->fbi->mode = (struct fb_videomode *)mode;
+		mxc_hdmi_phy_init(hdmi);
+	} else {
+		dev_dbg(&hdmi->pdev->dev, "%s: New video mode\n", __func__);
+		mxc_hdmi_set_mode_to_vga_dvi(hdmi);
+
+		fb_videomode_to_var(&hdmi->fbi->var, mode);
+		dump_fb_videomode((struct fb_videomode *)mode);
+		mxc_hdmi_notify_fb(hdmi);
+	}
+
+}
+
+static void mxc_hdmi_cable_connected(struct mxc_hdmi *hdmi)
+{
+	int edid_status;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi->cable_plugin = true;
+
+	/* HDMI Initialization Step C */
+	edid_status = mxc_hdmi_read_edid(hdmi);
+
+	/* HDMI Initialization Steps D, E, F */
+	switch (edid_status) {
+	case HDMI_EDID_SUCCESS:
+		mxc_hdmi_edid_rebuild_modelist(hdmi);
+		break;
+
+	/* Nothing to do if EDID same */
+	case HDMI_EDID_SAME:
+		break;
+
+	case HDMI_EDID_NO_MODES:
+	case HDMI_EDID_FAIL:
+	default:
+		mxc_hdmi_default_modelist(hdmi);
+		break;
+	}
+
+	/* Setting video mode */
+	mxc_hdmi_set_mode(hdmi);
+
+	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
+}
+
+static int mxc_hdmi_power_on(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+	mxc_hdmi_phy_init(hdmi);
+	return 0;
+}
+
+static void mxc_hdmi_power_off(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+	mxc_hdmi_phy_disable(hdmi);
+}
+
+static void mxc_hdmi_cable_disconnected(struct mxc_hdmi *hdmi)
+{
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi_disable_overflow_interrupts();
+
+	mxc_hdmi_phy_disable(hdmi);
+
+	hdmi->cable_plugin = false;
+}
+
+static void hotplug_worker(struct work_struct *work)
+{
+	struct delayed_work *delay_work = to_delayed_work(work);
+	struct mxc_hdmi *hdmi =
+		container_of(delay_work, struct mxc_hdmi, hotplug_work);
+	u32 phy_int_stat, phy_int_pol, phy_int_mask;
+	u8 val;
+	unsigned long flags;
+	char event_string[16];
+	char *envp[] = { event_string, NULL };
+
+	phy_int_stat = hdmi->latest_intr_stat;
+	phy_int_pol = hdmi_readb(HDMI_PHY_POL0);
+
+	dev_dbg(&hdmi->pdev->dev, "phy_int_stat=0x%x, phy_int_pol=0x%x\n",
+			phy_int_stat, phy_int_pol);
+
+	/* check cable status */
+	if (phy_int_stat & HDMI_IH_PHY_STAT0_HPD) {
+		/* cable connection changes */
+		if (phy_int_pol & HDMI_PHY_HPD) {
+			/* Plugin event */
+			dev_dbg(&hdmi->pdev->dev, "EVENT=plugin\n");
+			mxc_hdmi_cable_connected(hdmi);
+
+			/* Make HPD intr active low to capture unplug event */
+			val = hdmi_readb(HDMI_PHY_POL0);
+			val &= ~HDMI_PHY_HPD;
+			hdmi_writeb(val, HDMI_PHY_POL0);
+
+			sprintf(event_string, "EVENT=plugin");
+			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+			hdmi_set_cable_state(1);
+		} else if (!(phy_int_pol & HDMI_PHY_HPD)) {
+			/* Plugout event */
+			dev_dbg(&hdmi->pdev->dev, "EVENT=plugout\n");
+			hdmi_set_cable_state(0);
+			mxc_hdmi_abort_stream();
+			mxc_hdmi_cable_disconnected(hdmi);
+
+			/* Make HPD intr active high to capture plugin event */
+			val = hdmi_readb(HDMI_PHY_POL0);
+			val |= HDMI_PHY_HPD;
+			hdmi_writeb(val, HDMI_PHY_POL0);
+
+			sprintf(event_string, "EVENT=plugout");
+			kobject_uevent_env(&hdmi->pdev->dev.kobj, KOBJ_CHANGE, envp);
+
+		} else
+			dev_dbg(&hdmi->pdev->dev, "EVENT=none?\n");
+	}
+
+	/* Lock here to ensure full powerdown sequence
+	 * completed before next interrupt processed */
+	spin_lock_irqsave(&hdmi->irq_lock, flags);
+
+	/* Re-enable HPD interrupts */
+	phy_int_mask = hdmi_readb(HDMI_PHY_MASK0);
+	phy_int_mask &= ~HDMI_PHY_HPD;
+	hdmi_writeb(phy_int_mask, HDMI_PHY_MASK0);
+
+	/* Unmute interrupts */
+	hdmi_writeb(~HDMI_IH_MUTE_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);
+
+	if (hdmi_readb(HDMI_IH_FC_STAT2) & HDMI_IH_FC_STAT2_OVERFLOW_MASK)
+		mxc_hdmi_clear_overflow();
+
+	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
+}
+
+static irqreturn_t mxc_hdmi_hotplug(int irq, void *data)
+{
+	struct mxc_hdmi *hdmi = data;
+	u8 val, intr_stat;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hdmi->irq_lock, flags);
+
+	/* Check and clean packet overflow interrupt.*/
+	if (hdmi_readb(HDMI_IH_FC_STAT2) &
+			HDMI_IH_FC_STAT2_OVERFLOW_MASK) {
+		mxc_hdmi_clear_overflow();
+
+		dev_dbg(&hdmi->pdev->dev, "Overflow interrupt received\n");
+		/* clear irq status */
+		hdmi_writeb(HDMI_IH_FC_STAT2_OVERFLOW_MASK,
+			    HDMI_IH_FC_STAT2);
+	}
+
+	/*
+	 * We could not disable the irq.  Probably the audio driver
+	 * has enabled it. Masking off the HDMI interrupts using
+	 * HDMI registers.
+	 */
+	/* Capture status - used in hotplug_worker ISR */
+	intr_stat = hdmi_readb(HDMI_IH_PHY_STAT0);
+
+	if (intr_stat & HDMI_IH_PHY_STAT0_HPD) {
+
+		dev_dbg(&hdmi->pdev->dev, "Hotplug interrupt received\n");
+		hdmi->latest_intr_stat = intr_stat;
+
+		/* Mute interrupts until handled */
+
+		val = hdmi_readb(HDMI_IH_MUTE_PHY_STAT0);
+		val |= HDMI_IH_MUTE_PHY_STAT0_HPD;
+		hdmi_writeb(val, HDMI_IH_MUTE_PHY_STAT0);
+
+		val = hdmi_readb(HDMI_PHY_MASK0);
+		val |= HDMI_PHY_HPD;
+		hdmi_writeb(val, HDMI_PHY_MASK0);
+
+		/* Clear Hotplug interrupts */
+		hdmi_writeb(HDMI_IH_PHY_STAT0_HPD, HDMI_IH_PHY_STAT0);
+
+		schedule_delayed_work(&(hdmi->hotplug_work), msecs_to_jiffies(20));
+	}
+
+	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
+	return IRQ_HANDLED;
+}
+
+static void mxc_hdmi_setup(struct mxc_hdmi *hdmi, unsigned long event)
+{
+	struct fb_videomode m;
+	const struct fb_videomode *edid_mode;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	fb_var_to_videomode(&m, &hdmi->fbi->var);
+	dump_fb_videomode(&m);
+
+	/* Exit the setup if we get mode change and are already set to
+	 * this video mode */
+	if ((event == FB_EVENT_MODE_CHANGE) &&
+		fb_mode_is_equal(&hdmi->previous_mode, &m)) {
+		dev_dbg(&hdmi->pdev->dev,
+			"%s video mode did not change.\n", __func__);
+		mxc_hdmi_phy_init(hdmi);
+		return;
+	}
+	dev_dbg(&hdmi->pdev->dev, "%s - video mode changed\n", __func__);
+
+	/* Save mode as 'previous_mode' so that we can know if mode changed. */
+	memcpy(&hdmi->previous_mode, &m, sizeof(struct fb_videomode));
+
+	hdmi->vic = 0;
+	if (!hdmi->requesting_vga_for_initialization) {
+		/* Save mode if this isn't the result of requesting
+		 * vga default. */
+		memcpy(&hdmi->previous_non_vga_mode, &m,
+		       sizeof(struct fb_videomode));
+		if (!list_empty(&hdmi->fbi->modelist)) {
+			edid_mode = fb_find_nearest_mode(&m, &hdmi->fbi->modelist);
+			pr_debug("edid mode ");
+			dump_fb_videomode((struct fb_videomode *)edid_mode);
+			hdmi->vic = mxc_edid_mode_to_vic(edid_mode);
+		}
+	}
+
+	hdmi_disable_overflow_interrupts();
+
+	if (hdmi->vic == 0) {
+		dev_dbg(&hdmi->pdev->dev, "Non-CEA mode used in HDMI\n");
+		hdmi->hdmi_data.video_mode.mDVI = true;
+	} else {
+		dev_dbg(&hdmi->pdev->dev, "CEA mode used vic=%d\n", hdmi->vic);
+		hdmi->hdmi_data.video_mode.mDVI = false;
+	}
+
+	if ((hdmi->vic == 6) || (hdmi->vic == 7) ||
+		(hdmi->vic == 21) || (hdmi->vic == 22) ||
+		(hdmi->vic == 2) || (hdmi->vic == 3) ||
+		(hdmi->vic == 17) || (hdmi->vic == 18))
+		hdmi->hdmi_data.colorimetry = eITU601;
+	else
+		hdmi->hdmi_data.colorimetry = eITU709;
+
+	if ((hdmi->vic == 10) || (hdmi->vic == 11) ||
+		(hdmi->vic == 12) || (hdmi->vic == 13) ||
+		(hdmi->vic == 14) || (hdmi->vic == 15) ||
+		(hdmi->vic == 25) || (hdmi->vic == 26) ||
+		(hdmi->vic == 27) || (hdmi->vic == 28) ||
+		(hdmi->vic == 29) || (hdmi->vic == 30) ||
+		(hdmi->vic == 35) || (hdmi->vic == 36) ||
+		(hdmi->vic == 37) || (hdmi->vic == 38))
+		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 1;
+	else
+		hdmi->hdmi_data.video_mode.mPixelRepetitionOutput = 0;
+
+	hdmi->hdmi_data.video_mode.mPixelRepetitionInput = 0;
+
+	/* TODO: Get input format from IPU (via FB driver iface) */
+	hdmi->hdmi_data.enc_in_format = RGB;
+
+	hdmi->hdmi_data.enc_out_format = RGB;
+	/*DVI mode not support non-RGB */
+	if (!hdmi->hdmi_data.video_mode.mDVI)
+		if (hdmi->edid_cfg.hdmi_cap) {
+			if (hdmi->edid_cfg.cea_ycbcr444)
+				hdmi->hdmi_data.enc_out_format = YCBCR444;
+			else if (hdmi->edid_cfg.cea_ycbcr422)
+				hdmi->hdmi_data.enc_out_format = YCBCR422_8BITS;
+		}
+
+	/* IPU not support depth color output */
+	hdmi->hdmi_data.enc_color_depth = 8;
+	hdmi->hdmi_data.pix_repet_factor = 0;
+	hdmi->hdmi_data.hdcp_enable = 0;
+	hdmi->hdmi_data.video_mode.mDataEnablePolarity = true;
+
+	/* HDMI Initialization Step B.1 */
+	hdmi_av_composer(hdmi);
+
+	/* HDMI Initializateion Step B.2 */
+	mxc_hdmi_phy_init(hdmi);
+
+	/* HDMI Initialization Step B.3 */
+	mxc_hdmi_enable_video_path(hdmi);
+
+	/* not for DVI mode */
+	if (hdmi->hdmi_data.video_mode.mDVI)
+		dev_dbg(&hdmi->pdev->dev, "%s DVI mode\n", __func__);
+	else {
+		dev_dbg(&hdmi->pdev->dev, "%s CEA mode\n", __func__);
+
+		/* HDMI Initialization Step E - Configure audio */
+		hdmi_clk_regenerator_update_pixel_clock(hdmi->fbi->var.pixclock);
+		hdmi_enable_audio_clk(hdmi);
+
+		/* HDMI Initialization Step F - Configure AVI InfoFrame */
+		hdmi_config_AVI(hdmi);
+	}
+
+	hdmi_video_packetize(hdmi);
+	hdmi_video_csc(hdmi);
+	hdmi_video_sample(hdmi);
+	hdmi_tx_hdcp_config(hdmi);
+
+	mxc_hdmi_clear_overflow();
+
+	if (!hdmi->hdmi_data.video_mode.mDVI)
+		hdmi_enable_overflow_interrupts();
+
+	dev_dbg(&hdmi->pdev->dev, "%s exit\n\n", __func__);
+}
+
+/* Wait until we are registered to enable interrupts */
+static void mxc_hdmi_fb_registered(struct mxc_hdmi *hdmi)
+{
+	unsigned long flags;
+
+	if (hdmi->fb_reg)
+		return;
+
+	spin_lock_irqsave(&hdmi->irq_lock, flags);
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	hdmi_writeb(HDMI_PHY_I2CM_INT_ADDR_DONE_POL,
+		    HDMI_PHY_I2CM_INT_ADDR);
+
+	hdmi_writeb(HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |
+		    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,
+		    HDMI_PHY_I2CM_CTLINT_ADDR);
+
+	/* enable cable hot plug irq */
+	hdmi_writeb((u8)~HDMI_PHY_HPD, HDMI_PHY_MASK0);
+
+	/* Clear Hotplug interrupts */
+	hdmi_writeb(HDMI_IH_PHY_STAT0_HPD, HDMI_IH_PHY_STAT0);
+
+	/* Unmute interrupts */
+	hdmi_writeb(~HDMI_IH_MUTE_PHY_STAT0_HPD, HDMI_IH_MUTE_PHY_STAT0);
+
+	hdmi->fb_reg = true;
+
+	spin_unlock_irqrestore(&hdmi->irq_lock, flags);
+
+}
+
+static int mxc_hdmi_fb_event(struct notifier_block *nb,
+					unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+	struct mxc_hdmi *hdmi = container_of(nb, struct mxc_hdmi, nb);
+
+	if (strcmp(event->info->fix.id, hdmi->fbi->fix.id))
+		return 0;
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_FB_REGISTERED\n");
+		mxc_hdmi_fb_registered(hdmi);
+		hdmi_set_registered(1);
+		break;
+
+	case FB_EVENT_FB_UNREGISTERED:
+		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_FB_UNREGISTERED\n");
+		hdmi->fb_reg = false;
+		hdmi_set_registered(0);
+		break;
+
+	case FB_EVENT_MODE_CHANGE:
+		dev_dbg(&hdmi->pdev->dev, "event=FB_EVENT_MODE_CHANGE\n");
+		if (hdmi->fb_reg)
+			mxc_hdmi_setup(hdmi, val);
+		break;
+
+	case FB_EVENT_BLANK:
+		if ((*((int *)event->data) == FB_BLANK_UNBLANK) &&
+			(*((int *)event->data) != hdmi->blank)) {
+			dev_dbg(&hdmi->pdev->dev,
+				"event=FB_EVENT_BLANK - UNBLANK\n");
+
+			hdmi->blank = *((int *)event->data);
+
+			if (hdmi->fb_reg && hdmi->cable_plugin)
+				mxc_hdmi_setup(hdmi, val);
+			hdmi_set_blank_state(1);
+
+		} else if (*((int *)event->data) != hdmi->blank) {
+			dev_dbg(&hdmi->pdev->dev,
+				"event=FB_EVENT_BLANK - BLANK\n");
+			hdmi_set_blank_state(0);
+			mxc_hdmi_abort_stream();
+
+			mxc_hdmi_phy_disable(hdmi);
+
+			hdmi->blank = *((int *)event->data);
+		} else
+			dev_dbg(&hdmi->pdev->dev,
+				"FB BLANK state no changed!\n");
+
+		break;
+
+	case FB_EVENT_SUSPEND:
+		dev_dbg(&hdmi->pdev->dev,
+			"event=FB_EVENT_SUSPEND\n");
+
+		if (hdmi->blank == FB_BLANK_UNBLANK) {
+			mxc_hdmi_phy_disable(hdmi);
+			clk_disable(hdmi->hdmi_iahb_clk);
+			clk_disable(hdmi->hdmi_isfr_clk);
+		}
+		break;
+
+	case FB_EVENT_RESUME:
+		dev_dbg(&hdmi->pdev->dev,
+			"event=FB_EVENT_RESUME\n");
+
+		if (hdmi->blank == FB_BLANK_UNBLANK) {
+			clk_enable(hdmi->hdmi_iahb_clk);
+			clk_enable(hdmi->hdmi_isfr_clk);
+			mxc_hdmi_phy_init(hdmi);
+		}
+		break;
+
+	}
+	return 0;
+}
+
+/* HDMI Initialization Step A */
+static int mxc_hdmi_disp_init(struct mxc_dispdrv_handle *disp,
+			      struct mxc_dispdrv_setting *setting)
+{
+	int ret = 0;
+	u32 i;
+	const struct fb_videomode *mode;
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+	int irq = platform_get_irq(hdmi->pdev, 0);
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	/* Check hdmi disp init once */
+	if (hdmi_inited) {
+		dev_err(&hdmi->pdev->dev,
+				"Error only one HDMI output support now!\n");
+		return -1;
+	}
+
+	if (!plat || irq < 0)
+		return -ENODEV;
+
+	hdmi->dft_mode_set = false;
+
+	/* Setting HDMI default to blank state */
+	hdmi->blank = FB_BLANK_POWERDOWN;
+
+	setting->dev_id = mxc_hdmi_ipu_id;
+	setting->disp_id = mxc_hdmi_disp_id;
+	setting->if_fmt = IPU_PIX_FMT_RGB24;
+
+	hdmi->dft_mode_str = setting->dft_mode_str;
+	hdmi->default_bpp = setting->default_bpp;
+	dev_dbg(&hdmi->pdev->dev, "%s - default mode %s bpp=%d\n",
+		__func__, hdmi->dft_mode_str, hdmi->default_bpp);
+
+	hdmi->fbi = setting->fbi;
+
+	/* Claim HDMI pins */
+	if (plat->get_pins)
+		if (!plat->get_pins()) {
+			ret = -EACCES;
+			goto egetpins;
+		}
+
+	/* Initialize HDMI */
+	if (plat->init)
+		plat->init(mxc_hdmi_ipu_id, mxc_hdmi_disp_id);
+
+	hdmi->hdmi_isfr_clk = clk_get(&hdmi->pdev->dev, "hdmi_isfr_clk");
+	if (IS_ERR(hdmi->hdmi_isfr_clk)) {
+		ret = PTR_ERR(hdmi->hdmi_isfr_clk);
+		dev_err(&hdmi->pdev->dev,
+			"Unable to get HDMI clk: %d\n", ret);
+		goto egetclk1;
+	}
+
+	ret = clk_enable(hdmi->hdmi_isfr_clk);
+	if (ret < 0) {
+		dev_err(&hdmi->pdev->dev,
+			"Cannot enable HDMI isfr clock: %d\n", ret);
+		goto erate1;
+	}
+
+	hdmi->hdmi_iahb_clk = clk_get(&hdmi->pdev->dev, "hdmi_iahb_clk");
+	if (IS_ERR(hdmi->hdmi_iahb_clk)) {
+		ret = PTR_ERR(hdmi->hdmi_iahb_clk);
+		dev_err(&hdmi->pdev->dev,
+			"Unable to get HDMI clk: %d\n", ret);
+		goto egetclk2;
+	}
+
+	ret = clk_enable(hdmi->hdmi_iahb_clk);
+	if (ret < 0) {
+		dev_err(&hdmi->pdev->dev,
+			"Cannot enable HDMI iahb clock: %d\n", ret);
+		goto erate2;
+	}
+
+	dev_dbg(&hdmi->pdev->dev, "Enabled HDMI clocks\n");
+
+	/* Product and revision IDs */
+	dev_info(&hdmi->pdev->dev,
+		"Detected HDMI controller 0x%x:0x%x:0x%x:0x%x\n",
+		hdmi_readb(HDMI_DESIGN_ID),
+		hdmi_readb(HDMI_REVISION_ID),
+		hdmi_readb(HDMI_PRODUCT_ID0),
+		hdmi_readb(HDMI_PRODUCT_ID1));
+
+	/* To prevent overflows in HDMI_IH_FC_STAT2, set the clk regenerator
+	 * N and cts values before enabling phy */
+	hdmi_init_clk_regenerator();
+
+	INIT_LIST_HEAD(&hdmi->fbi->modelist);
+
+	spin_lock_init(&hdmi->irq_lock);
+
+	/* Set the default mode and modelist when disp init. */
+	fb_find_mode(&hdmi->fbi->var, hdmi->fbi,
+		     hdmi->dft_mode_str, NULL, 0, NULL,
+		     hdmi->default_bpp);
+
+	console_lock();
+
+	fb_destroy_modelist(&hdmi->fbi->modelist);
+
+	/*Add all no interlaced CEA mode to default modelist */
+	for (i = 0; i < ARRAY_SIZE(mxc_cea_mode); i++) {
+		mode = &mxc_cea_mode[i];
+		if (!(mode->vmode & FB_VMODE_INTERLACED) && (mode->xres != 0))
+			fb_add_videomode(mode, &hdmi->fbi->modelist);
+	}
+
+	/*Add XGA and SXGA to default modelist */
+	fb_add_videomode(&xga_mode, &hdmi->fbi->modelist);
+	fb_add_videomode(&sxga_mode, &hdmi->fbi->modelist);
+
+	console_unlock();
+
+	INIT_DELAYED_WORK(&hdmi->hotplug_work, hotplug_worker);
+
+	/* Configure registers related to HDMI interrupt
+	 * generation before registering IRQ. */
+	hdmi_writeb(HDMI_PHY_HPD, HDMI_PHY_POL0);
+
+	/* Clear Hotplug interrupts */
+	hdmi_writeb(HDMI_IH_PHY_STAT0_HPD, HDMI_IH_PHY_STAT0);
+
+	hdmi->nb.notifier_call = mxc_hdmi_fb_event;
+	ret = fb_register_client(&hdmi->nb);
+	if (ret < 0)
+		goto efbclient;
+
+	memset(&hdmi->hdmi_data, 0, sizeof(struct hdmi_data_info));
+
+	ret = request_irq(irq, mxc_hdmi_hotplug, IRQF_SHARED,
+			  dev_name(&hdmi->pdev->dev), hdmi);
+	if (ret < 0) {
+		dev_err(&hdmi->pdev->dev,
+			"Unable to request irq: %d\n", ret);
+		goto ereqirq;
+	}
+
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_fb_name);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for fb name\n");
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_cable_state);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for cable state\n");
+	ret = device_create_file(&hdmi->pdev->dev, &dev_attr_edid);
+	if (ret < 0)
+		dev_warn(&hdmi->pdev->dev,
+			"cound not create sys node for edid\n");
+
+	dev_dbg(&hdmi->pdev->dev, "%s exit\n", __func__);
+
+	hdmi_inited = true;
+
+	return ret;
+
+efbclient:
+	free_irq(irq, hdmi);
+ereqirq:
+	clk_disable(hdmi->hdmi_iahb_clk);
+erate2:
+	clk_put(hdmi->hdmi_iahb_clk);
+egetclk2:
+	clk_disable(hdmi->hdmi_isfr_clk);
+erate1:
+	clk_put(hdmi->hdmi_isfr_clk);
+egetclk1:
+	plat->put_pins();
+egetpins:
+	dev_dbg(&hdmi->pdev->dev, "%s error exit\n", __func__);
+
+	return ret;
+}
+
+static void mxc_hdmi_disp_deinit(struct mxc_dispdrv_handle *disp)
+{
+	struct mxc_hdmi *hdmi = mxc_dispdrv_getdata(disp);
+	struct fsl_mxc_hdmi_platform_data *plat = hdmi->pdev->dev.platform_data;
+
+	dev_dbg(&hdmi->pdev->dev, "%s\n", __func__);
+
+	fb_unregister_client(&hdmi->nb);
+
+	clk_disable(hdmi->hdmi_isfr_clk);
+	clk_put(hdmi->hdmi_isfr_clk);
+	clk_disable(hdmi->hdmi_iahb_clk);
+	clk_put(hdmi->hdmi_iahb_clk);
+
+	/* Release HDMI pins */
+	if (plat->put_pins)
+		plat->put_pins();
+
+	platform_device_unregister(hdmi->pdev);
+
+	hdmi_inited = false;
+
+	kfree(hdmi);
+}
+
+static struct mxc_dispdrv_driver mxc_hdmi_drv = {
+	.name	= DISPDRV_HDMI,
+	.init	= mxc_hdmi_disp_init,
+	.deinit	= mxc_hdmi_disp_deinit,
+	.enable = mxc_hdmi_power_on,
+	.disable = mxc_hdmi_power_off,
+};
+
+static int __devinit mxc_hdmi_probe(struct platform_device *pdev)
+{
+	struct mxc_hdmi *hdmi;
+	int ret = 0;
+
+	/* Check that I2C driver is loaded and available */
+	if (!hdmi_i2c)
+		return -ENODEV;
+
+	hdmi = kzalloc(sizeof(*hdmi), GFP_KERNEL);
+	if (!hdmi) {
+		dev_err(&pdev->dev, "Cannot allocate device data\n");
+		ret = -ENOMEM;
+		goto ealloc;
+	}
+
+	hdmi->pdev = pdev;
+
+	hdmi->core_pdev = platform_device_alloc("mxc_hdmi_core", -1);
+	if (!hdmi->core_pdev) {
+		pr_err("%s failed platform_device_alloc for hdmi core\n",
+			__func__);
+		ret = -ENOMEM;
+		goto ecore;
+	}
+
+	hdmi_inited = false;
+
+	hdmi->disp_mxc_hdmi = mxc_dispdrv_register(&mxc_hdmi_drv);
+	if (IS_ERR(hdmi->disp_mxc_hdmi)) {
+		dev_err(&pdev->dev, "Failed to register dispdrv - 0x%x\n",
+			(int)hdmi->disp_mxc_hdmi);
+		ret = (int)hdmi->disp_mxc_hdmi;
+		goto edispdrv;
+	}
+	mxc_dispdrv_setdata(hdmi->disp_mxc_hdmi, hdmi);
+
+	platform_set_drvdata(pdev, hdmi);
+
+	return 0;
+edispdrv:
+	platform_device_put(hdmi->core_pdev);
+ecore:
+	kfree(hdmi);
+ealloc:
+	return ret;
+}
+
+static int mxc_hdmi_remove(struct platform_device *pdev)
+{
+	struct mxc_hdmi *hdmi = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+
+	fb_unregister_client(&hdmi->nb);
+
+	mxc_dispdrv_puthandle(hdmi->disp_mxc_hdmi);
+	mxc_dispdrv_unregister(hdmi->disp_mxc_hdmi);
+	/* No new work will be scheduled, wait for running ISR */
+	free_irq(irq, hdmi);
+	kfree(hdmi);
+
+	return 0;
+}
+
+static struct platform_driver mxc_hdmi_driver = {
+	.probe = mxc_hdmi_probe,
+	.remove = mxc_hdmi_remove,
+	.driver = {
+		   .name = "mxc_hdmi",
+		   .owner = THIS_MODULE,
+	},
+};
+
+static int __init mxc_hdmi_init(void)
+{
+	return platform_driver_register(&mxc_hdmi_driver);
+}
+module_init(mxc_hdmi_init);
+
+static void __exit mxc_hdmi_exit(void)
+{
+	platform_driver_unregister(&mxc_hdmi_driver);
+}
+module_exit(mxc_hdmi_exit);
+
+static int __devinit mxc_hdmi_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	if (!i2c_check_functionality(client->adapter,
+				I2C_FUNC_SMBUS_BYTE | I2C_FUNC_I2C))
+		return -ENODEV;
+
+	hdmi_i2c = client;
+
+	return 0;
+}
+
+static int __devexit mxc_hdmi_i2c_remove(struct i2c_client *client)
+{
+	hdmi_i2c = NULL;
+	return 0;
+}
+
+static const struct i2c_device_id mxc_hdmi_i2c_id[] = {
+	{ "mxc_hdmi_i2c", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mxc_hdmi_i2c_id);
+
+static struct i2c_driver mxc_hdmi_i2c_driver = {
+	.driver = {
+		   .name = "mxc_hdmi_i2c",
+		   },
+	.probe = mxc_hdmi_i2c_probe,
+	.remove = mxc_hdmi_i2c_remove,
+	.id_table = mxc_hdmi_i2c_id,
+};
+
+static int __init mxc_hdmi_i2c_init(void)
+{
+	return i2c_add_driver(&mxc_hdmi_i2c_driver);
+}
+
+static void __exit mxc_hdmi_i2c_exit(void)
+{
+	i2c_del_driver(&mxc_hdmi_i2c_driver);
+}
+
+module_init(mxc_hdmi_i2c_init);
+module_exit(mxc_hdmi_i2c_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index a3e41ef..237b71b 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -134,6 +134,27 @@ struct fsl_mxc_lcd_platform_data {
 	int disp_id;
 };
 
+struct fsl_mxc_dvi_platform_data {
+	void (*init) (void);
+	int (*update) (void);
+	char *analog_regulator;
+	int ipu_id;
+	int disp_id;
+};
+
+struct fsl_mxc_hdmi_platform_data {
+	void (*init) (int, int);
+	int (*get_pins) (void);
+	void (*put_pins) (void);
+	void (*enable_pins) (void);
+	void (*disable_pins) (void);
+};
+
+struct fsl_mxc_hdmi_core_platform_data {
+	int ipu_id;
+	int disp_id;
+};
+
 struct mpc8xx_pcmcia_ops {
 	void(*hw_ctrl)(int slot, int enable);
 	int(*voltage_set)(int slot, int vcc, int vpp);
-- 
1.7.9.7

