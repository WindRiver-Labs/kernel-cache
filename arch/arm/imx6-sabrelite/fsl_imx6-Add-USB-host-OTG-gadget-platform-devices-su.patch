From b5e61b9faf4ceac90dcebd195d64b56dbaa625fe Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 11:37:23 +0800
Subject: [PATCH 23/62] fsl_imx6: Add USB host, OTG, gadget platform devices
 support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                          |    5 +
 arch/arm/mach-mx6/Makefile                         |    3 +-
 arch/arm/mach-mx6/devices-imx6q.h                  |   24 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c            |   38 +
 arch/arm/mach-mx6/usb.h                            |   62 ++
 arch/arm/mach-mx6/usb_dr.c                         |  621 +++++++++++++
 arch/arm/mach-mx6/usb_h1.c                         |  383 ++++++++
 arch/arm/mach-mx6/usb_h2.c                         |  241 +++++
 arch/arm/mach-mx6/usb_h3.c                         |  243 +++++
 arch/arm/plat-mxc/Makefile                         |    7 +-
 arch/arm/plat-mxc/devices/Kconfig                  |    6 +
 arch/arm/plat-mxc/devices/Makefile                 |    2 +
 arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c  |   45 +
 arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c  |    5 +
 .../plat-mxc/devices/platform-fsl-usb2-wakeup.c    |   48 +
 arch/arm/plat-mxc/devices/platform-mxc-ehci.c      |   31 +
 arch/arm/plat-mxc/include/mach/arc_otg.h           |  341 +++++++
 arch/arm/plat-mxc/include/mach/devices-common.h    |   21 +
 arch/arm/plat-mxc/include/mach/fsl_usb.h           |  109 +++
 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h    |   40 +
 arch/arm/plat-mxc/include/mach/regs-usbphy-mx6.h   |  480 ++++++++++
 .../arm/plat-mxc/include/mach/regs-usbphy-others.h |  161 ++++
 arch/arm/plat-mxc/isp1504xc.c                      |  275 ++++++
 arch/arm/plat-mxc/usb_common.c                     |  933 ++++++++++++++++++++
 arch/arm/plat-mxc/usb_hsic_xcvr.c                  |   55 ++
 arch/arm/plat-mxc/usb_wakeup.c                     |  238 +++++
 arch/arm/plat-mxc/utmixc.c                         |   90 ++
 include/linux/fsl_devices.h                        |   78 ++
 include/linux/usb/fsl_xcvr.h                       |   58 ++
 29 files changed, 4641 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-mx6/usb.h
 create mode 100644 arch/arm/mach-mx6/usb_dr.c
 create mode 100644 arch/arm/mach-mx6/usb_h1.c
 create mode 100644 arch/arm/mach-mx6/usb_h2.c
 create mode 100644 arch/arm/mach-mx6/usb_h3.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
 create mode 100644 arch/arm/plat-mxc/include/mach/arc_otg.h
 create mode 100644 arch/arm/plat-mxc/include/mach/fsl_usb.h
 create mode 100644 arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
 create mode 100644 arch/arm/plat-mxc/include/mach/regs-usbphy-mx6.h
 create mode 100644 arch/arm/plat-mxc/include/mach/regs-usbphy-others.h
 create mode 100644 arch/arm/plat-mxc/isp1504xc.c
 create mode 100644 arch/arm/plat-mxc/usb_common.c
 create mode 100644 arch/arm/plat-mxc/usb_hsic_xcvr.c
 create mode 100644 arch/arm/plat-mxc/usb_wakeup.c
 create mode 100644 arch/arm/plat-mxc/utmixc.c
 create mode 100644 include/linux/usb/fsl_xcvr.h

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index c8ac860..897b666 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -2,6 +2,7 @@ if ARCH_MX6
 
 config ARCH_MX6Q
 	bool
+	select USB_ARCH_HAS_EHCI
 	select ARM_CPU_SUSPEND if PM
 	select ARM_GIC
 	select CPU_V7
@@ -23,6 +24,10 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_UART
 	select IMX_HAVE_PLATFORM_IMX_I2C
 	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
+	select IMX_HAVE_PLATFORM_FSL_USB2_UDC
+	select IMX_HAVE_PLATFORM_MXC_EHCI
+	select IMX_HAVE_PLATFORM_FSL_OTG
+	select IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 0595557..80356fd 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -4,7 +4,8 @@
 
 # Object file lists.
 obj-y   := cpu.o mm.o system.o irq.o bus_freq.o cpu_op-mx6.o mx6_wfi.o mx6_mmdc.o \
-		mx6_ddr_freq.o mx6_anatop_regulator.o cpu_regulator-mx6.o
+		mx6_ddr_freq.o mx6_anatop_regulator.o cpu_regulator-mx6.o \
+		usb_dr.o usb_h1.o usb_h2.o usb_h3.o
 
 obj-$(CONFIG_ARCH_MX6) += clock.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += mach-mx6q_sabrelite.o
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index 8073474..6f8e361 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -43,6 +43,30 @@ extern const struct imx_imx_i2c_data imx6q_imx_i2c_data[] __initconst;
 #define imx6q_add_imx_i2c(id, pdata)	\
 	imx_add_imx_i2c(&imx6q_imx_i2c_data[id], pdata)
 
+extern const struct imx_fsl_usb2_udc_data imx6q_fsl_usb2_udc_data __initconst;
+#define imx6q_add_fsl_usb2_udc(pdata)	\
+	imx_add_fsl_usb2_udc(&imx6q_fsl_usb2_udc_data, pdata)
+
+extern const struct imx_mxc_ehci_data imx6q_mxc_ehci_otg_data __initconst;
+#define imx6q_add_fsl_ehci_otg(pdata)	\
+	imx_add_fsl_ehci(&imx6q_mxc_ehci_otg_data, pdata)
+
+extern const struct imx_mxc_ehci_data imx6q_mxc_ehci_hs_data[] __initconst;
+#define imx6q_add_fsl_ehci_hs(id, pdata)	\
+	imx_add_fsl_ehci(&imx6q_mxc_ehci_hs_data[id - 1], pdata)
+
+extern const struct imx_fsl_usb2_otg_data imx6q_fsl_usb2_otg_data __initconst;
+#define imx6q_add_fsl_usb2_otg(pdata)	\
+	imx_add_fsl_usb2_otg(&imx6q_fsl_usb2_otg_data, pdata)
+
+extern const struct imx_fsl_usb2_wakeup_data imx6q_fsl_otg_wakeup_data __initconst;
+#define imx6q_add_fsl_usb2_otg_wakeup(pdata)	\
+	imx_add_fsl_usb2_wakeup(&imx6q_fsl_otg_wakeup_data, pdata)
+
+extern const struct imx_fsl_usb2_wakeup_data imx6q_fsl_hs_wakeup_data[] __initconst;
+#define imx6q_add_fsl_usb2_hs_wakeup(id, pdata)	\
+	imx_add_fsl_usb2_wakeup(&imx6q_fsl_hs_wakeup_data[id - 1], pdata)
+
 extern const struct imx_ipuv3_data imx6q_ipuv3_data[] __initconst;
 #define imx6q_add_ipuv3(id, pdata)	imx_add_ipuv3(id, &imx6q_ipuv3_data[id], pdata)
 #define imx6q_add_ipuv3fb(id, pdata)	imx_add_ipuv3_fb(id, pdata)
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index d4cf4e3..5a01d0b 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -26,6 +26,7 @@
 #include <linux/input.h>
 #include <linux/nodemask.h>
 #include <linux/clk.h>
+#include <linux/gpio.h>
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/regulator/consumer.h>
@@ -55,11 +56,14 @@
 #include "devices-imx6q.h"
 #include "crm_regs.h"
 #include "cpu_op-mx6.h"
+#include "usb.h"
 
 #define MX6Q_SABRELITE_SD3_CD		IMX_GPIO_NR(7, 0)
 #define MX6Q_SABRELITE_SD3_WP		IMX_GPIO_NR(7, 1)
 #define MX6Q_SABRELITE_SD4_CD		IMX_GPIO_NR(2, 6)
 #define MX6Q_SABRELITE_SD4_WP		IMX_GPIO_NR(2, 7)
+#define MX6Q_SABRELITE_USB_OTG_PWR	IMX_GPIO_NR(3, 22)
+#define MX6Q_SABRELITE_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
 
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
@@ -545,6 +549,36 @@ static void __init mx6_soc_init(void)
 	imx_add_imx_sdma("imx35-sdma", MX6Q_SDMA_BASE_ADDR, MX6Q_INT_SDMA, &imx6q_sdma_pdata);
 }
 
+static void imx6q_sabrelite_usbotg_vbus(bool on)
+{
+	if (on)
+		gpio_set_value(MX6Q_SABRELITE_USB_OTG_PWR, 1);
+	else
+		gpio_set_value(MX6Q_SABRELITE_USB_OTG_PWR, 0);
+}
+
+static void __init imx6q_sabrelite_init_usb(void)
+{
+	int ret = 0;
+
+	imx_otg_base = MX6_IO_ADDRESS(MX6Q_USB_OTG_BASE_ADDR);
+	/* disable external charger detect,
+	 * or it will affect signal quality at dp .
+	 */
+	ret = gpio_request(MX6Q_SABRELITE_USB_OTG_PWR, "usb-pwr");
+	if (ret) {
+		pr_err("failed to get GPIO MX6Q_SABRELITE_USB_OTG_PWR: %d\n",
+			ret);
+		return;
+	}
+	gpio_direction_output(MX6Q_SABRELITE_USB_OTG_PWR, 0);
+	mxc_iomux_set_gpr_register(1, 13, 1, 1);
+
+	mx6_set_otghost_vbus_func(imx6q_sabrelite_usbotg_vbus);
+	mx6_usb_dr_init();
+	mx6_usb_h1_init();
+}
+
 /*!
  * Board specific initialization.
  */
@@ -590,6 +624,10 @@ static void __init mx6_sabrelite_board_init(void)
 	platform_device_register(&sabrelite_vmmc_reg_devices);
 	imx6q_add_sdhci_usdhc_imx(3, &mx6q_sabrelite_sd4_data);
 	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabrelite_sd3_data);
+	imx6q_sabrelite_init_usb();
+
+	/* release USB Hub reset */
+	gpio_set_value(MX6Q_SABRELITE_USB_HUB_RESET, 1);
 
 	clko2 = clk_get(NULL, "clko2_clk");
 	if (IS_ERR(clko2))
diff --git a/arch/arm/mach-mx6/usb.h b/arch/arm/mach-mx6/usb.h
new file mode 100644
index 0000000..145cfbf
--- /dev/null
+++ b/arch/arm/mach-mx6/usb.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/common.h>
+
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern struct platform_device *host_pdev_register(struct resource *res,
+		  int n_res, struct fsl_usb2_platform_data *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+
+extern void __init mx6_usb_dr_init(void);
+extern void __init mx6_usb_h1_init(void);
+extern void __init mx6_usb_h2_init(void);
+extern void __init mx6_usb_h3_init(void);
+
+typedef void (*driver_vbus_func)(bool);
+extern void mx6_set_host3_vbus_func(driver_vbus_func);
+extern void mx6_set_host2_vbus_func(driver_vbus_func);
+extern void mx6_set_host1_vbus_func(driver_vbus_func);
+extern void mx6_set_otghost_vbus_func(driver_vbus_func);
+extern struct platform_device anatop_thermal_device;
+extern struct platform_device mxc_usbdr_otg_device;
+extern struct platform_device mxc_usbdr_udc_device;
+extern struct platform_device mxc_usbdr_host_device;
+extern struct platform_device mxc_usbdr_wakeup_device;
+extern struct platform_device mxc_usbh1_device;
+extern struct platform_device mxc_usbh1_wakeup_device;
+
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+extern void __iomem *imx_otg_base;
diff --git a/arch/arm/mach-mx6/usb_dr.c b/arch/arm/mach-mx6/usb_dr.c
new file mode 100644
index 0000000..8f4431b
--- /dev/null
+++ b/arch/arm/mach-mx6/usb_dr.c
@@ -0,0 +1,621 @@
+/*
+ * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include "devices-imx6q.h"
+#include "regs-anadig.h"
+#include "usb.h"
+
+DEFINE_MUTEX(otg_wakeup_enable_mutex);
+static int usbotg_init_ext(struct platform_device *pdev);
+static void usbotg_uninit_ext(struct platform_device *pdev);
+static void usbotg_clock_gate(bool on);
+static void _dr_discharge_line(bool enable);
+
+/* The usb_phy1_clk do not have enable/disable function at clock.c
+ * and PLL output for usb1's phy should be always enabled.
+ * usb_phy1_clk only stands for usb uses pll3 as its parent.
+ */
+static struct clk *usb_phy1_clk;
+static struct clk *usb_oh3_clk;
+static u8 otg_used;
+
+static void usbotg_wakeup_event_clear(void);
+extern int clk_get_usecount(struct clk *clk);
+/* Beginning of Common operation for DR port */
+
+/*
+ * platform data structs
+ * 	- Which one to use is determined by CONFIG options in usb.h
+ * 	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data dr_utmi_config = {
+	.name              = "DR",
+	.init              = usbotg_init_ext,
+	.exit              = usbotg_uninit_ext,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* 500 mA max power */
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.transceiver       = "utmi",
+	.phy_regs = USB_PHY0_BASE_ADDR,
+	.dr_discharge_line = _dr_discharge_line,
+};
+
+/* Platform data for wakeup operation */
+static struct fsl_usb2_wakeup_platform_data dr_wakeup_config = {
+	.name = "DR wakeup",
+	.usb_clock_for_pm  = usbotg_clock_gate,
+	.usb_wakeup_exhandle = usbotg_wakeup_event_clear,
+};
+
+static void fsl_platform_otg_set_usb_phy_dis(
+		struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	u32 usb_phy_ctrl_dcdt = 0;
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usb_phy_ctrl_dcdt = __raw_readl(
+			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
+			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	if (enable) {
+		if (usb_phy_ctrl_dcdt == 0) {
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_CLR);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
+
+			udelay(300);
+
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_SET);
+
+			UOG_USBSTS |= (1 << 7);
+
+			while ((UOG_USBSTS & (1 << 7)) == 0)
+				;
+
+			udelay(2);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
+
+			__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+
+		}
+	} else {
+		if (usb_phy_ctrl_dcdt
+				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_CLR);
+	}
+}
+
+static void usbotg_internal_phy_clock_gate(bool on)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	if (on) {
+		__raw_writel(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_CLR);
+	} else {
+		__raw_writel(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_SET);
+	}
+}
+
+static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
+{
+	u32 tmp;
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	void __iomem *phy_ctrl;
+
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+	/* Reset USBPHY module */
+	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
+	tmp = __raw_readl(phy_ctrl);
+	tmp |= BM_USBPHY_CTRL_SFTRST;
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	tmp = __raw_readl(phy_ctrl);
+	tmp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Power up the PHY */
+	__raw_writel(0, phy_reg + HW_USBPHY_PWD);
+	if ((pdata->operating_mode == FSL_USB2_DR_HOST) ||
+			(pdata->operating_mode == FSL_USB2_DR_OTG)) {
+		/* enable FS/LS device */
+		__raw_writel(BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3
+				, phy_reg + HW_USBPHY_CTRL_SET);
+	}
+
+	return 0;
+}
+/* Notes: configure USB clock*/
+static int usbotg_init_ext(struct platform_device *pdev)
+{
+	struct clk *usb_clk;
+	u32 ret;
+
+	/* at mx6q: this clock is AHB clock for usb core */
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_phy1_clk");
+	clk_enable(usb_clk);
+	usb_phy1_clk = usb_clk;
+
+	ret = usbotg_init(pdev);
+	if (ret) {
+		printk(KERN_ERR "otg init fails......\n");
+		return ret;
+	}
+	if (!otg_used) {
+		usbotg_internal_phy_clock_gate(true);
+		usb_phy_enable(pdev->dev.platform_data);
+		/*after the phy reset,can not read the readingvalue for id/vbus at
+		* the register of otgsc ,cannot  read at once ,need delay 3 ms
+		*/
+		mdelay(3);
+	}
+	otg_used++;
+
+	return ret;
+}
+
+static void usbotg_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	clk_disable(usb_phy1_clk);
+	clk_put(usb_phy1_clk);
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+	usbotg_uninit(pdata);
+	otg_used--;
+}
+
+static void usbotg_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy1_clk);
+	} else {
+		clk_disable(usb_phy1_clk);
+		clk_disable(usb_oh3_clk);
+	}
+	pr_debug("usb_oh3_clk:%d, usb_phy_clk1_ref_count:%d\n", clk_get_usecount(usb_oh3_clk), clk_get_usecount(usb_phy1_clk));
+}
+
+static void dr_platform_phy_power_on(void)
+{
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	__raw_writel(BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG,
+				anatop_base_addr + HW_ANADIG_ANA_MISC0_SET);
+}
+
+void mx6_set_otghost_vbus_func(driver_vbus_func driver_vbus)
+{
+	dr_utmi_config.platform_driver_vbus = driver_vbus;
+}
+
+static void _dr_discharge_line(bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	if (enable) {
+		__raw_writel(BF_USBPHY_DEBUG_ENHSTPULLDOWN(0x3), phy_reg + HW_USBPHY_DEBUG_SET);
+		__raw_writel(BF_USBPHY_DEBUG_HSTPULLDOWN(0x3), phy_reg + HW_USBPHY_DEBUG_SET);
+	} else {
+		__raw_writel(BF_USBPHY_DEBUG_ENHSTPULLDOWN(0x3), phy_reg + HW_USBPHY_DEBUG_CLR);
+		__raw_writel(BF_USBPHY_DEBUG_HSTPULLDOWN(0x3), phy_reg + HW_USBPHY_DEBUG_CLR);
+	}
+
+}
+
+/* Below two macros are used at otg mode to indicate usb mode*/
+#define ENABLED_BY_HOST   (0x1 << 0)
+#define ENABLED_BY_DEVICE (0x1 << 1)
+static u32 low_power_enable_src; /* only useful at otg mode */
+static void enter_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	u32 tmp;
+	pr_debug("DR: %s begins, enable is %d\n", __func__, enable);
+
+	if (enable) {
+		UOG_PORTSC1 |= PORTSC_PHCD;
+		tmp = (BM_USBPHY_PWD_TXPWDFS
+			| BM_USBPHY_PWD_TXPWDIBIAS
+			| BM_USBPHY_PWD_TXPWDV2I
+			| BM_USBPHY_PWD_RXPWDENV
+			| BM_USBPHY_PWD_RXPWD1PT1
+			| BM_USBPHY_PWD_RXPWDDIFF
+			| BM_USBPHY_PWD_RXPWDRX);
+		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_SET);
+		usbotg_internal_phy_clock_gate(false);
+
+	} else {
+		if (UOG_PORTSC1 & PORTSC_PHCD) {
+			UOG_PORTSC1 &= ~PORTSC_PHCD;
+			mdelay(1);
+		}
+		usbotg_internal_phy_clock_gate(true);
+		tmp = (BM_USBPHY_PWD_TXPWDFS
+			| BM_USBPHY_PWD_TXPWDIBIAS
+			| BM_USBPHY_PWD_TXPWDV2I
+			| BM_USBPHY_PWD_RXPWDENV
+			| BM_USBPHY_PWD_RXPWD1PT1
+			| BM_USBPHY_PWD_RXPWDDIFF
+			| BM_USBPHY_PWD_RXPWDRX);
+		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+
+	}
+	pr_debug("DR: %s ends, enable is %d\n", __func__, enable);
+}
+
+static void __phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable, int source)
+{
+	if (enable) {
+		low_power_enable_src |= source;
+#ifdef CONFIG_USB_OTG
+		if (low_power_enable_src == (ENABLED_BY_HOST | ENABLED_BY_DEVICE)) {
+			pr_debug("phy lowpower enabled\n");
+			enter_phy_lowpower_suspend(pdata, enable);
+		}
+#else
+		enter_phy_lowpower_suspend(pdata, enable);
+#endif
+	} else {
+		pr_debug("phy lowpower disable\n");
+		enter_phy_lowpower_suspend(pdata, enable);
+		low_power_enable_src &= ~source;
+	}
+}
+
+static void otg_wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+
+	pr_debug("%s, enable is %d\n", __func__, enable);
+	if (enable) {
+		__raw_writel(BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
+		USB_OTG_CTRL |= UCTRL_OWIE;
+	} else {
+		USB_OTG_CTRL &= ~UCTRL_OWIE;
+		/* The interrupt must be disabled for at least 3 clock
+		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static u32 wakeup_irq_enable_src; /* only useful at otg mode */
+static void __wakeup_irq_enable(struct fsl_usb2_platform_data *pdata, bool on, int source)
+ {
+	/* otg host and device share the OWIE bit, only when host and device
+	 * all enable the wakeup irq, we can enable the OWIE bit
+	 */
+	mutex_lock(&otg_wakeup_enable_mutex);
+	if (on) {
+#ifdef CONFIG_USB_OTG
+		wakeup_irq_enable_src |= source;
+		if (wakeup_irq_enable_src == (ENABLED_BY_HOST | ENABLED_BY_DEVICE)) {
+			otg_wake_up_enable(pdata, on);
+		}
+#else
+		otg_wake_up_enable(pdata, on);
+#endif
+	} else {
+		otg_wake_up_enable(pdata, on);
+		wakeup_irq_enable_src &= ~source;
+		/* The interrupt must be disabled for at least 3 clock
+		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+	mutex_unlock(&otg_wakeup_enable_mutex);
+}
+
+/* The wakeup operation for DR port, it will clear the wakeup irq status
+ * and re-enable the wakeup
+ */
+static void usbotg_wakeup_event_clear(void)
+{
+	int wakeup_req = USB_OTG_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req != 0) {
+		printk(KERN_INFO "Unknown wakeup.(OTGSC 0x%x)\n", UOG_OTGSC);
+		/* Disable OWIE to clear OWIR, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USB_OTG_CTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USB_OTG_CTRL |= UCTRL_OWIE;
+	}
+}
+
+/* End of Common operation for DR port */
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+/* Beginning of host related operation for DR port */
+static void _host_platform_rh_suspend(struct fsl_usb2_platform_data *pdata)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	u32 tmp;
+	u32 index = 0;
+
+	/* before we set and then clear PWD bit,
+	 * we must wait LS to be suspend */
+	if ((UOG_PORTSC1 & (3 << 26)) != (1 << 26)) {
+		while (((UOG_PORTSC1 & PORTSC_LS_MASK) != PORTSC_LS_J_STATE) &&
+				(index < 1000)) {
+			index++;
+			udelay(4);
+		}
+	} else {
+		while (((UOG_PORTSC1 & PORTSC_LS_MASK) != PORTSC_LS_K_STATE) &&
+				(index < 1000)) {
+			index++;
+			udelay(4);
+		}
+	}
+
+	if (index >= 1000)
+		printk(KERN_INFO "%s big error\n", __func__);
+
+	tmp = (BM_USBPHY_PWD_TXPWDFS
+		| BM_USBPHY_PWD_TXPWDIBIAS
+		| BM_USBPHY_PWD_TXPWDV2I
+		| BM_USBPHY_PWD_RXPWDENV
+		| BM_USBPHY_PWD_RXPWD1PT1
+		| BM_USBPHY_PWD_RXPWDDIFF
+		| BM_USBPHY_PWD_RXPWDRX);
+	__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_SET);
+
+	__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+
+	fsl_platform_otg_set_usb_phy_dis(pdata, 0);
+}
+
+static void _host_platform_rh_resume(struct fsl_usb2_platform_data *pdata)
+{
+	u32 index = 0;
+
+	if ((UOG_PORTSC1 & (3 << 26)) != (2 << 26))
+		return ;
+
+	while ((UOG_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
+			&& (index < 1000)) {
+		udelay(500);
+		index++;
+	}
+
+	if (index >= 1000)
+		printk(KERN_INFO "%s big error\n", __func__);
+
+	udelay(500);
+	fsl_platform_otg_set_usb_phy_dis(pdata, 1);
+}
+
+static void _host_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__phy_lowpower_suspend(pdata, enable, ENABLED_BY_HOST);
+}
+
+static void _host_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	__wakeup_irq_enable(pdata, enable, ENABLED_BY_HOST);
+	if (enable) {
+		pr_debug("host wakeup enable\n");
+		USB_OTG_CTRL |= UCTRL_WKUP_ID_EN;
+		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP, phy_reg + HW_USBPHY_CTRL_SET);
+	} else {
+		pr_debug("host wakeup disable\n");
+		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP, phy_reg + HW_USBPHY_CTRL_CLR);
+		USB_OTG_CTRL &= ~UCTRL_WKUP_ID_EN;
+		/* The interrupt must be disabled for at least 3 clock
+		 * cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+	pr_debug("the otgsc is 0x%x, usbsts is 0x%x, portsc is 0x%x, otgctrl: 0x%x\n", UOG_OTGSC, UOG_USBSTS, UOG_PORTSC1, USB_OTG_CTRL);
+}
+
+static enum usb_wakeup_event _is_host_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	u32 wakeup_req = USB_OTG_CTRL & UCTRL_OWIR;
+	u32 otgsc = UOG_OTGSC;
+
+	if (wakeup_req) {
+		pr_debug("the otgsc is 0x%x, usbsts is 0x%x, portsc is 0x%x, wakeup_irq is 0x%x\n", UOG_OTGSC, UOG_USBSTS, UOG_PORTSC1, wakeup_req);
+	}
+	/* if ID change sts, it is a host wakeup event */
+	if (wakeup_req && (otgsc & OTGSC_IS_USB_ID)) {
+		pr_debug("otg host ID wakeup\n");
+		/* if host ID wakeup, we must clear the b session change sts */
+		otgsc &= (~OTGSC_IS_USB_ID);
+		return WAKEUP_EVENT_ID;
+	}
+	if (wakeup_req  && (!(otgsc & OTGSC_STS_USB_ID))) {
+		pr_debug("otg host Remote wakeup\n");
+		return WAKEUP_EVENT_DPDM;
+	}
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void host_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_host_phy_lowpower_suspend(pdata, false);
+	_host_wakeup_enable(pdata, false);
+}
+/* End of host related operation for DR port */
+#endif /* CONFIG_USB_EHCI_ARC_OTG */
+
+
+#if defined(CONFIG_USB_GADGET_ARC) || defined(CONFIG_USB_OTG)
+/* Beginning of device related operation for DR port */
+static void _device_phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	__phy_lowpower_suspend(pdata, enable, ENABLED_BY_DEVICE);
+}
+
+static void _device_wakeup_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY0_BASE_ADDR);
+	__wakeup_irq_enable(pdata, enable, ENABLED_BY_DEVICE);
+	/* if udc is not used by any gadget, we can not enable the vbus wakeup */
+	if (!pdata->port_enables) {
+		USB_OTG_CTRL &= ~UCTRL_WKUP_VBUS_EN;
+		return;
+	}
+	if (enable) {
+		pr_debug("device wakeup enable\n");
+		USB_OTG_CTRL |= UCTRL_WKUP_VBUS_EN;
+		__raw_writel(BM_USBPHY_CTRL_ENVBUSCHG_WKUP, phy_reg + HW_USBPHY_CTRL_SET);
+	} else {
+		pr_debug("device wakeup disable\n");
+		__raw_writel(BM_USBPHY_CTRL_ENVBUSCHG_WKUP, phy_reg + HW_USBPHY_CTRL_CLR);
+		USB_OTG_CTRL &= ~UCTRL_WKUP_VBUS_EN;
+	}
+}
+
+static enum usb_wakeup_event _is_device_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	int wakeup_req = USB_OTG_CTRL & UCTRL_OWIR;
+	pr_debug("%s\n", __func__);
+
+	/* if ID=1, it is a device wakeup event */
+	if (wakeup_req && (UOG_OTGSC & OTGSC_STS_USB_ID) && (UOG_USBSTS & USBSTS_URI)) {
+		printk(KERN_INFO "otg udc wakeup, host sends reset signal\n");
+		return WAKEUP_EVENT_DPDM;
+	}
+	if (wakeup_req && (UOG_OTGSC & OTGSC_STS_USB_ID) &&  \
+		((UOG_USBSTS & USBSTS_PCI) || (UOG_PORTSC1 & PORTSC_PORT_FORCE_RESUME))) {
+		/*
+		 * When the line state from J to K, the Port Change Detect bit
+		 * in the USBSTS register is also set to '1'.
+		 */
+		printk(KERN_INFO "otg udc wakeup, host sends resume signal\n");
+		return WAKEUP_EVENT_DPDM;
+	}
+	if (wakeup_req && (UOG_OTGSC & OTGSC_STS_USB_ID) && (UOG_OTGSC & OTGSC_STS_A_VBUS_VALID) \
+		&& (UOG_OTGSC & OTGSC_IS_B_SESSION_VALID)) {
+		printk(KERN_INFO "otg udc vbus rising wakeup\n");
+		return WAKEUP_EVENT_VBUS;
+	}
+	if (wakeup_req && (UOG_OTGSC & OTGSC_STS_USB_ID) && !(UOG_OTGSC & OTGSC_STS_A_VBUS_VALID)) {
+		printk(KERN_INFO "otg udc vbus falling wakeup\n");
+		return WAKEUP_EVENT_VBUS;
+	}
+
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void device_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_device_phy_lowpower_suspend(pdata, false);
+	_device_wakeup_enable(pdata, false);
+}
+
+/* end of device related operation for DR port */
+#endif /* CONFIG_USB_GADGET_ARC */
+
+void __init mx6_usb_dr_init(void)
+{
+	struct platform_device *pdev, *pdev_wakeup;
+	static void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+#ifdef CONFIG_USB_OTG
+	/* wake_up_enable is useless, just for usb_register_remote_wakeup execution*/
+	dr_utmi_config.wake_up_enable = _device_wakeup_enable;
+	dr_utmi_config.operating_mode = FSL_USB2_DR_OTG;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	pdev = imx6q_add_fsl_usb2_otg(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
+#endif
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+	dr_utmi_config.operating_mode = DR_HOST_MODE;
+	dr_utmi_config.wake_up_enable = _host_wakeup_enable;
+	dr_utmi_config.platform_rh_suspend = _host_platform_rh_suspend;
+	dr_utmi_config.platform_rh_resume  = _host_platform_rh_resume;
+	dr_utmi_config.platform_set_disconnect_det = fsl_platform_otg_set_usb_phy_dis;
+	dr_utmi_config.phy_lowpower_suspend = _host_phy_lowpower_suspend;
+	dr_utmi_config.is_wakeup_event = _is_host_wakeup;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	dr_utmi_config.wakeup_handler = host_wakeup_handler;
+	dr_utmi_config.platform_phy_power_on = dr_platform_phy_power_on;
+	pdev = imx6q_add_fsl_ehci_otg(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[1] = pdev->dev.platform_data;
+#endif
+#ifdef CONFIG_USB_GADGET_ARC
+	dr_utmi_config.operating_mode = DR_UDC_MODE;
+	dr_utmi_config.wake_up_enable = _device_wakeup_enable;
+	dr_utmi_config.platform_rh_suspend = NULL;
+	dr_utmi_config.platform_rh_resume  = NULL;
+	dr_utmi_config.platform_set_disconnect_det = NULL;
+	dr_utmi_config.phy_lowpower_suspend = _device_phy_lowpower_suspend;
+	dr_utmi_config.is_wakeup_event = _is_device_wakeup;
+	dr_utmi_config.wakeup_pdata = &dr_wakeup_config;
+	dr_utmi_config.wakeup_handler = device_wakeup_handler;
+	dr_utmi_config.platform_phy_power_on = dr_platform_phy_power_on;
+	pdev = imx6q_add_fsl_usb2_udc(&dr_utmi_config);
+	dr_wakeup_config.usb_pdata[2] = pdev->dev.platform_data;
+#endif
+	/* register wakeup device */
+	pdev_wakeup = imx6q_add_fsl_usb2_otg_wakeup(&dr_wakeup_config);
+	if (pdev != NULL)
+		((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
+			(struct fsl_usb2_wakeup_platform_data *)(pdev_wakeup->dev.platform_data);
+
+	/* Some phy and power's special controls for otg
+	 * 1. The external charger detector needs to be disabled
+	 * or the signal at DP will be poor
+	 * 2. The EN_USB_CLKS is always enabled.
+	 * The PLL's power is controlled by usb and others who
+	 * use pll3 too.
+	 */
+	__raw_writel(BM_ANADIG_USB1_CHRG_DETECT_EN_B  \
+			| BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B,  \
+			anatop_base_addr + HW_ANADIG_USB1_CHRG_DETECT);
+	__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+}
diff --git a/arch/arm/mach-mx6/usb_h1.c b/arch/arm/mach-mx6/usb_h1.c
new file mode 100644
index 0000000..94bb4f5
--- /dev/null
+++ b/arch/arm/mach-mx6/usb_h1.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include "devices-imx6q.h"
+#include "regs-anadig.h"
+#include "usb.h"
+
+static struct clk *usb_oh3_clk;
+extern int clk_get_usecount(struct clk *clk);
+static struct fsl_usb2_platform_data usbh1_config;
+
+static void fsl_platform_h1_set_usb_phy_dis(
+		struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	u32 usb_phy_ctrl_dcdt = 0;
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usb_phy_ctrl_dcdt = __raw_readl(
+			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
+			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	if (enable) {
+		if (usb_phy_ctrl_dcdt == 0) {
+			__raw_writel(BM_ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_CLR);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_SET);
+
+			udelay(300);
+
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_SET);
+
+			UH1_USBSTS |= (1 << 7);
+
+			while ((UH1_USBSTS & (1 << 7)) == 0)
+				;
+
+			udelay(2);
+
+			__raw_writel(BM_USBPHY_PWD_RXPWDENV,
+					MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_PWD_CLR);
+
+			__raw_writel(BM_ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS,
+					anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_SET);
+
+		}
+	} else {
+		if (usb_phy_ctrl_dcdt
+				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_CLR);
+	}
+}
+
+static void usbh1_internal_phy_clock_gate(bool on)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+	if (on) {
+		__raw_writel(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_CLR);
+	} else {
+		__raw_writel(BM_USBPHY_CTRL_CLKGATE, phy_reg + HW_USBPHY_CTRL_SET);
+	}
+}
+
+static void usbh1_platform_phy_power_on(void)
+{
+	void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	__raw_writel(BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG,
+				anatop_base_addr + HW_ANADIG_ANA_MISC0_SET);
+}
+
+static int usb_phy_enable(struct fsl_usb2_platform_data *pdata)
+{
+	u32 tmp;
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+	void __iomem *phy_ctrl;
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while ((UH1_USBCMD) & (UCMD_RESET))
+		;
+	/* Reset USBPHY module */
+	phy_ctrl = phy_reg + HW_USBPHY_CTRL;
+	tmp = __raw_readl(phy_ctrl);
+	tmp |= BM_USBPHY_CTRL_SFTRST;
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	tmp = __raw_readl(phy_ctrl);
+	tmp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
+	__raw_writel(tmp, phy_ctrl);
+	udelay(10);
+
+	/* Power up the PHY */
+	__raw_writel(0, phy_reg + HW_USBPHY_PWD);
+	/* enable FS/LS device */
+	tmp = __raw_readl(phy_reg + HW_USBPHY_CTRL);
+	tmp |= (BM_USBPHY_CTRL_ENUTMILEVEL2 | BM_USBPHY_CTRL_ENUTMILEVEL3);
+	__raw_writel(tmp, phy_reg + HW_USBPHY_CTRL);
+
+	return 0;
+}
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret) {
+		printk(KERN_ERR "host1 init fails......\n");
+		return ret;
+	}
+	usbh1_internal_phy_clock_gate(true);
+	usb_phy_enable(pdev->dev.platform_data);
+
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	fsl_usb_host_uninit(pdata);
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+}
+
+static void usbh1_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_oh3_clk);
+	} else {
+		clk_disable(usb_oh3_clk);
+	}
+}
+
+void mx6_set_host1_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh1_config.platform_driver_vbus = driver_vbus;
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable) {
+		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP | BM_USBPHY_CTRL_ENVBUSCHG_WKUP
+				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP
+				| BM_USBPHY_CTRL_ENAUTOSET_USBCLKS
+				| BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD
+				| BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE
+				| BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE
+				| BM_USBPHY_CTRL_ENAUTO_PWRON_PLL , phy_reg + HW_USBPHY_CTRL_SET);
+		USB_H1_CTRL |= (UCTRL_OWIE);
+	} else {
+		USB_H1_CTRL &= ~(UCTRL_OWIE);
+		__raw_writel(BM_USBPHY_CTRL_ENIDCHG_WKUP | BM_USBPHY_CTRL_ENVBUSCHG_WKUP
+				| BM_USBPHY_CTRL_ENDPDMCHG_WKUP, phy_reg + HW_USBPHY_CTRL_CLR);
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void usbh1_platform_rh_suspend(struct fsl_usb2_platform_data *pdata)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+	u32 tmp;
+	u32 index = 0;
+
+	/* before we set and then clear PWD bit,
+	 * we must wait LS to be J */
+	if ((UH1_PORTSC1 & (3 << 26)) != (1 << 26)) {
+		while (((UH1_PORTSC1 & PORTSC_LS_MASK) != PORTSC_LS_J_STATE) &&
+				(index < 1000)) {
+			index++;
+			udelay(4);
+		}
+	} else {
+		while (((UH1_PORTSC1 & PORTSC_LS_MASK) != PORTSC_LS_K_STATE) &&
+				(index < 1000)) {
+			index++;
+			udelay(4);
+		}
+	}
+
+	if (index >= 1000)
+		printk(KERN_INFO "%s big error\n", __func__);
+
+	tmp = (BM_USBPHY_PWD_TXPWDFS
+		| BM_USBPHY_PWD_TXPWDIBIAS
+		| BM_USBPHY_PWD_TXPWDV2I
+		| BM_USBPHY_PWD_RXPWDENV
+		| BM_USBPHY_PWD_RXPWD1PT1
+		| BM_USBPHY_PWD_RXPWDDIFF
+		| BM_USBPHY_PWD_RXPWDRX);
+	__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_SET);
+
+	__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+
+	fsl_platform_h1_set_usb_phy_dis(pdata, 0);
+}
+
+static void usbh1_platform_rh_resume(struct fsl_usb2_platform_data *pdata)
+{
+	u32 index = 0;
+
+	if ((UH1_PORTSC1 & (3 << 26)) != (2 << 26))
+		return ;
+
+	while ((UH1_PORTSC1 & PORTSC_PORT_FORCE_RESUME)
+			&& (index < 1000)) {
+		udelay(500);
+		index++;
+	}
+
+	if (index >= 1000)
+		printk(KERN_INFO "%s big error\n", __func__);
+
+	udelay(500);
+	fsl_platform_h1_set_usb_phy_dis(pdata, 1);
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	u32 tmp;
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+	pr_debug("host1, %s, enable is %d\n", __func__, enable);
+	if (enable) {
+		UH1_PORTSC1 |= PORTSC_PHCD;
+
+		pr_debug("%s, Poweroff UTMI \n", __func__);
+
+		tmp = (BM_USBPHY_PWD_TXPWDFS
+			| BM_USBPHY_PWD_TXPWDIBIAS
+			| BM_USBPHY_PWD_TXPWDV2I
+			| BM_USBPHY_PWD_RXPWDENV
+			| BM_USBPHY_PWD_RXPWD1PT1
+			| BM_USBPHY_PWD_RXPWDDIFF
+			| BM_USBPHY_PWD_RXPWDRX);
+		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_SET);
+
+		usbh1_internal_phy_clock_gate(false);
+	} else {
+		if (UH1_PORTSC1 & PORTSC_PHCD) {
+			UH1_PORTSC1 &= ~PORTSC_PHCD;
+			mdelay(1);
+		}
+		usbh1_internal_phy_clock_gate(true);
+		tmp = (BM_USBPHY_PWD_TXPWDFS
+			| BM_USBPHY_PWD_TXPWDIBIAS
+			| BM_USBPHY_PWD_TXPWDV2I
+			| BM_USBPHY_PWD_RXPWDENV
+			| BM_USBPHY_PWD_RXPWD1PT1
+			| BM_USBPHY_PWD_RXPWDDIFF
+			| BM_USBPHY_PWD_RXPWDRX);
+		__raw_writel(tmp, phy_reg + HW_USBPHY_PWD_CLR);
+
+	}
+}
+
+static enum usb_wakeup_event _is_usbh1_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	u32 wakeup_req = USB_H1_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req)
+		return WAKEUP_EVENT_DPDM;
+	pr_err("host1, %s, invalid wake up\n", __func__);
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void h1_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+}
+
+static void usbh1_wakeup_event_clear(void)
+{
+	void __iomem *phy_reg = MX6_IO_ADDRESS(USB_PHY1_BASE_ADDR);
+	u32 wakeup_irq_bits;
+
+	wakeup_irq_bits = BM_USBPHY_CTRL_RESUME_IRQ | BM_USBPHY_CTRL_WAKEUP_IRQ;
+	if (__raw_readl(phy_reg + HW_USBPHY_CTRL) && wakeup_irq_bits) {
+		/* clear the wakeup interrupt status */
+		__raw_writel(wakeup_irq_bits, phy_reg + HW_USBPHY_CTRL_CLR);
+	}
+}
+
+static struct fsl_usb2_platform_data usbh1_config = {
+	.name		= "Host 1",
+	.init		= fsl_usb_host_init_ext,
+	.exit		= fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbh1_clock_gate,
+	.platform_rh_suspend  = usbh1_platform_rh_suspend,
+	.platform_rh_resume   = usbh1_platform_rh_resume,
+	.platform_set_disconnect_det = fsl_platform_h1_set_usb_phy_dis,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.is_wakeup_event = _is_usbh1_wakeup,
+	.wakeup_handler = h1_wakeup_handler,
+	.platform_phy_power_on = usbh1_platform_phy_power_on,
+	.transceiver = "utmi",
+	.phy_regs = USB_PHY1_BASE_ADDR,
+};
+static struct fsl_usb2_wakeup_platform_data usbh1_wakeup_config = {
+		.name = "USBH1 wakeup",
+		.usb_clock_for_pm  = usbh1_clock_gate,
+		.usb_pdata = {&usbh1_config, NULL, NULL},
+		.usb_wakeup_exhandle = usbh1_wakeup_event_clear,
+};
+
+void __init mx6_usb_h1_init(void)
+{
+	struct platform_device *pdev, *pdev_wakeup;
+	static void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+
+	usbh1_config.wakeup_pdata = &usbh1_wakeup_config;
+	pdev = imx6q_add_fsl_ehci_hs(1, &usbh1_config);
+	usbh1_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
+	pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(1, &usbh1_wakeup_config);
+	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
+		(struct fsl_usb2_wakeup_platform_data *)(pdev_wakeup->dev.platform_data);
+	/* Some phy and power's special controls for host1
+	 * 1. The external charger detector needs to be disabled
+	 * or the signal at DP will be poor
+	 * 2. The PLL's power and output to usb for host 1
+	 * is totally controlled by IC, so the Software only needs
+	 * to enable them at initializtion.
+	 */
+	__raw_writel(BM_ANADIG_USB2_CHRG_DETECT_EN_B  \
+			| BM_ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B, \
+			anatop_base_addr + HW_ANADIG_USB2_CHRG_DETECT);
+	__raw_writel(BM_ANADIG_USB2_PLL_480_CTRL_BYPASS,
+			anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_CLR);
+	__raw_writel(BM_ANADIG_USB2_PLL_480_CTRL_ENABLE  \
+			| BM_ANADIG_USB2_PLL_480_CTRL_POWER \
+			| BM_ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS, \
+			anatop_base_addr + HW_ANADIG_USB2_PLL_480_CTRL_SET);
+}
diff --git a/arch/arm/mach-mx6/usb_h2.c b/arch/arm/mach-mx6/usb_h2.c
new file mode 100644
index 0000000..a671a95
--- /dev/null
+++ b/arch/arm/mach-mx6/usb_h2.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * High Speed Inter Chip code for i.MX6, this file is for HSIC port 1
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx6q.h>
+#include <mach/iomux-mx6dl.h>
+#include "devices-imx6q.h"
+#include "regs-anadig.h"
+#include "usb.h"
+
+static struct clk *usb_oh3_clk;
+static struct clk *usb_phy3_clk;
+
+extern int clk_get_usecount(struct clk *clk);
+static struct fsl_usb2_platform_data usbh2_config;
+
+static void usbh2_internal_phy_clock_gate(bool on)
+{
+	if (on) {
+		/* must turn on the 480M clock, otherwise
+		 * there will be a 10ms delay before host
+		 * controller send out resume signal*/
+		USB_H2_CTRL |= UCTRL_UTMI_ON_CLOCK;
+		USB_UH2_HSIC_CTRL |= HSIC_CLK_ON;
+	} else {
+		USB_UH2_HSIC_CTRL &= ~HSIC_CLK_ON;
+		/* can't turn off this clock, otherwise
+		 * there will be a 10ms delay before host
+		 * controller send out resume signal*/
+		/*USB_H2_CTRL &= ~UCTRL_UTMI_ON_CLOCK*/;
+	}
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_phy3_clk");
+	clk_enable(usb_clk);
+	usb_phy3_clk = usb_clk;
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret) {
+		printk(KERN_ERR "host1 init fails......\n");
+		return ret;
+	}
+	usbh2_internal_phy_clock_gate(true);
+	 /* Host2 HSIC enable */
+	USB_UH2_HSIC_CTRL |= HSIC_EN;
+
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	fsl_usb_host_uninit(pdata);
+
+	usbh2_internal_phy_clock_gate(false);
+
+	clk_disable(usb_phy3_clk);
+	clk_put(usb_phy3_clk);
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+}
+
+static void usbh2_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy3_clk);
+		usbh2_internal_phy_clock_gate(true);
+	} else {
+		usbh2_internal_phy_clock_gate(false);
+		clk_disable(usb_phy3_clk);
+		clk_disable(usb_oh3_clk);
+	}
+}
+
+void mx6_set_host2_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh2_config.platform_driver_vbus = driver_vbus;
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host2, %s, enable is %d\n", __func__, enable);
+	/* for HSIC, no disconnect nor connect
+	 * we need to disable the WKDS, WKCN */
+	UH2_PORTSC1 &= ~(PORTSC_WKDC | PORTSC_WKCN);
+
+	if (enable) {
+		USB_H2_CTRL |= (UCTRL_OWIE);
+	} else {
+		USB_H2_CTRL &= ~(UCTRL_OWIE);
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host2, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		UH2_PORTSC1 |= PORTSC_PHCD;
+	else
+		UH2_PORTSC1 &= ~PORTSC_PHCD;
+
+}
+
+static enum usb_wakeup_event _is_usbh2_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	u32 wakeup_req = USB_H2_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req)
+		return WAKEUP_EVENT_DPDM;
+	pr_err("host2, %s, invalid wake up\n", __func__);
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void h2_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+}
+
+static void usbh2_wakeup_event_clear(void)
+{
+	u32 wakeup_req = USB_H2_CTRL & UCTRL_OWIR;
+	pr_debug("%s\n", __func__);
+
+	if (wakeup_req != 0) {
+		/* Disable H2 wakeup enable to clear H2 wakeup request, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USB_H2_CTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USB_H2_CTRL |= UCTRL_OWIE;
+	}
+}
+
+static void hsic_start(void)
+{
+	pr_debug("%s\n", __func__);
+	/* strobe 47K pull up */
+	if (cpu_is_mx6q())
+		mxc_iomux_v3_setup_pad(
+				MX6Q_PAD_RGMII_TX_CTL__USBOH3_H2_STROBE_START);
+	else if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_pad(
+				MX6DL_PAD_RGMII_TX_CTL__USBOH3_H2_STROBE_START);
+}
+
+static void hsic_device_connected(void)
+{
+	pr_debug("%s\n", __func__);
+	if (!(USB_UH2_HSIC_CTRL & HSIC_DEV_CONN))
+		USB_UH2_HSIC_CTRL |= HSIC_DEV_CONN;
+}
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name		= "Host 2",
+	.init		= fsl_usb_host_init_ext,
+	.exit		= fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_HSIC,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbh2_clock_gate,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.is_wakeup_event = _is_usbh2_wakeup,
+	.wakeup_handler = h2_wakeup_handler,
+	.transceiver = "hsic_xcvr",
+	.hsic_post_ops = hsic_start,
+	.hsic_device_connected = hsic_device_connected,
+};
+
+static struct fsl_usb2_wakeup_platform_data usbh2_wakeup_config = {
+		.name = "usbh2 wakeup",
+		.usb_clock_for_pm  = usbh2_clock_gate,
+		.usb_pdata = {&usbh2_config, NULL, NULL},
+		.usb_wakeup_exhandle = usbh2_wakeup_event_clear,
+};
+
+void __init mx6_usb_h2_init(void)
+{
+	struct platform_device *pdev, *pdev_wakeup;
+	static void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usbh2_config.wakeup_pdata = &usbh2_wakeup_config;
+	pdev = imx6q_add_fsl_ehci_hs(2, &usbh2_config);
+	usbh2_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
+	pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(2, &usbh2_wakeup_config);
+	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
+		pdev_wakeup->dev.platform_data;
+	/* Some phy and power's special controls for host2
+	 * 1. Its 480M is from OTG's 480M
+	 * 2. EN_USB_CLKS should always be opened
+	 */
+	__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+	/* must change the clkgate delay to 2 or 3 to avoid
+	 * 24M OSCI clock not stable issue */
+	__raw_writel(BF_ANADIG_ANA_MISC0_CLKGATE_DELAY(3),
+			anatop_base_addr + HW_ANADIG_ANA_MISC0);
+}
diff --git a/arch/arm/mach-mx6/usb_h3.c b/arch/arm/mach-mx6/usb_h3.c
new file mode 100644
index 0000000..820ecd9
--- /dev/null
+++ b/arch/arm/mach-mx6/usb_h3.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * High Speed Inter Chip code for i.MX6, this file is for HSIC port 2
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/iomux-mx6q.h>
+#include <mach/iomux-mx6dl.h>
+#include "devices-imx6q.h"
+#include "regs-anadig.h"
+#include "usb.h"
+
+static struct clk *usb_oh3_clk;
+static struct clk *usb_phy4_clk;
+
+extern int clk_get_usecount(struct clk *clk);
+static struct fsl_usb2_platform_data usbh3_config;
+
+static void usbh3_internal_phy_clock_gate(bool on)
+{
+	if (on) {
+		/* must turn on the 480M clock, otherwise
+		 * there will be a 10ms delay before host
+		 * controller send out resume signal*/
+		USB_H3_CTRL |= UCTRL_UTMI_ON_CLOCK;
+		USB_UH3_HSIC_CTRL |= HSIC_CLK_ON;
+	} else {
+		USB_UH3_HSIC_CTRL &= ~HSIC_CLK_ON;
+		/* can't turn off this clock, otherwise
+		 * there will be a 10ms delay before host
+		 * controller send out resume signal*/
+		/*USB_H3_CTRL &= ~UCTRL_UTMI_ON_CLOCK;*/
+	}
+}
+
+static int fsl_usb_host_init_ext(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *usb_clk;
+	usb_clk = clk_get(NULL, "usboh3_clk");
+	clk_enable(usb_clk);
+	usb_oh3_clk = usb_clk;
+
+	usb_clk = clk_get(NULL, "usb_phy4_clk");
+	clk_enable(usb_clk);
+	usb_phy4_clk = usb_clk;
+
+	ret = fsl_usb_host_init(pdev);
+	if (ret) {
+		printk(KERN_ERR "host1 init fails......\n");
+		return ret;
+	}
+	usbh3_internal_phy_clock_gate(true);
+
+	 /* Host3 HSIC enable */
+	USB_UH3_HSIC_CTRL |= HSIC_EN;
+
+	return 0;
+}
+
+static void fsl_usb_host_uninit_ext(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	fsl_usb_host_uninit(pdata);
+
+	usbh3_internal_phy_clock_gate(false);
+
+	clk_disable(usb_phy4_clk);
+	clk_put(usb_phy4_clk);
+
+	clk_disable(usb_oh3_clk);
+	clk_put(usb_oh3_clk);
+
+}
+
+static void usbh3_clock_gate(bool on)
+{
+	pr_debug("%s: on is %d\n", __func__, on);
+	if (on) {
+		clk_enable(usb_oh3_clk);
+		clk_enable(usb_phy4_clk);
+		usbh3_internal_phy_clock_gate(true);
+	} else {
+		usbh3_internal_phy_clock_gate(false);
+		clk_disable(usb_phy4_clk);
+		clk_disable(usb_oh3_clk);
+	}
+}
+
+void mx6_set_host3_vbus_func(driver_vbus_func driver_vbus)
+{
+	usbh3_config.platform_driver_vbus = driver_vbus;
+}
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host3, %s, enable is %d\n", __func__, enable);
+	/* for HSIC, no disconnect nor connect
+	 * we need to disable the WKDS, WKCN */
+	UH3_PORTSC1 &= ~(PORTSC_WKDC | PORTSC_WKCN);
+
+	if (enable) {
+		USB_H3_CTRL |= (UCTRL_OWIE);
+	} else {
+		USB_H3_CTRL &= ~(UCTRL_OWIE);
+		/* The interrupt must be disabled for at least 3
+		* cycles of the standby clock(32k Hz) , that is 0.094 ms*/
+		udelay(100);
+	}
+}
+
+static void _phy_lowpower_suspend(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	pr_debug("host3, %s, enable is %d\n", __func__, enable);
+	if (enable)
+		UH3_PORTSC1 |= PORTSC_PHCD;
+	else
+		UH3_PORTSC1 &= ~PORTSC_PHCD;
+
+}
+
+static enum usb_wakeup_event _is_usbh3_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	u32 wakeup_req = USB_H3_CTRL & UCTRL_OWIR;
+
+	if (wakeup_req)
+		return WAKEUP_EVENT_DPDM;
+	pr_err("host3, %s, invalid wake up\n", __func__);
+	return WAKEUP_EVENT_INVALID;
+}
+
+static void usbh3_wakeup_handler(struct fsl_usb2_platform_data *pdata)
+{
+	_wake_up_enable(pdata, false);
+	_phy_lowpower_suspend(pdata, false);
+}
+
+static void usbh3_wakeup_event_clear(void)
+{
+	u32 wakeup_req = USB_H3_CTRL & UCTRL_OWIR;
+	pr_debug("%s\n", __func__);
+
+	if (wakeup_req != 0) {
+		/* Disable H3 wakeup enable to clear H3 wakeup request, wait 3 clock
+		 * cycles of standly clock(32KHz)
+		 */
+		USB_H3_CTRL &= ~UCTRL_OWIE;
+		udelay(100);
+		USB_H3_CTRL |= UCTRL_OWIE;
+	}
+}
+
+static void hsic_start(void)
+{
+	pr_debug("%s", __func__);
+	/* strobe 47K pull up */
+	if (cpu_is_mx6q())
+		mxc_iomux_v3_setup_pad(
+				MX6Q_PAD_RGMII_RXC__USBOH3_H3_STROBE_START);
+	else if (cpu_is_mx6dl())
+		mxc_iomux_v3_setup_pad(
+				MX6DL_PAD_RGMII_RXC__USBOH3_H3_STROBE_START);
+}
+
+static void hsic_device_connected(void)
+{
+	pr_debug("%s\n", __func__);
+	if (!(USB_UH3_HSIC_CTRL & HSIC_DEV_CONN))
+		USB_UH3_HSIC_CTRL |= HSIC_DEV_CONN;
+}
+
+static struct fsl_usb2_platform_data usbh3_config = {
+	.name		= "Host 3",
+	.init		= fsl_usb_host_init_ext,
+	.exit		= fsl_usb_host_uninit_ext,
+	.operating_mode = FSL_USB2_MPH_HOST,
+	.phy_mode = FSL_USB2_PHY_HSIC,
+	.power_budget = 500,	/* 500 mA max power */
+	.wake_up_enable = _wake_up_enable,
+	.usb_clock_for_pm  = usbh3_clock_gate,
+	.phy_lowpower_suspend = _phy_lowpower_suspend,
+	.is_wakeup_event = _is_usbh3_wakeup,
+	.wakeup_handler = usbh3_wakeup_handler,
+	.transceiver = "hsic_xcvr",
+	.hsic_post_ops = hsic_start,
+	.hsic_device_connected = hsic_device_connected,
+};
+
+static struct fsl_usb2_wakeup_platform_data usbh3_wakeup_config = {
+		.name = "usbh3 wakeup",
+		.usb_clock_for_pm  = usbh3_clock_gate,
+		.usb_pdata = {&usbh3_config, NULL, NULL},
+		.usb_wakeup_exhandle = usbh3_wakeup_event_clear,
+};
+
+void __init mx6_usb_h3_init(void)
+{
+	struct platform_device *pdev, *pdev_wakeup;
+	static void __iomem *anatop_base_addr = MX6_IO_ADDRESS(ANATOP_BASE_ADDR);
+	usbh3_config.wakeup_pdata = &usbh3_wakeup_config;
+	pdev = imx6q_add_fsl_ehci_hs(3, &usbh3_config);
+	usbh3_wakeup_config.usb_pdata[0] = pdev->dev.platform_data;
+	pdev_wakeup = imx6q_add_fsl_usb2_hs_wakeup(3, &usbh3_wakeup_config);
+	((struct fsl_usb2_platform_data *)(pdev->dev.platform_data))->wakeup_pdata =
+		pdev_wakeup->dev.platform_data;
+
+	/* Some phy and power's special controls for host3
+	 * 1. Its 480M is from OTG's 480M
+	 * 2. EN_USB_CLKS should always be opened
+	 */
+	__raw_writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+			anatop_base_addr + HW_ANADIG_USB1_PLL_480_CTRL_SET);
+	/* must change the clkgate delay to 2 or 3 to avoid
+	 * 24M OSCI clock not stable issue */
+	__raw_writel(BF_ANADIG_ANA_MISC0_CLKGATE_DELAY(3),
+			anatop_base_addr + HW_ANADIG_ANA_MISC0);
+}
diff --git a/arch/arm/plat-mxc/Makefile b/arch/arm/plat-mxc/Makefile
index e81290c..85564ec 100644
--- a/arch/arm/plat-mxc/Makefile
+++ b/arch/arm/plat-mxc/Makefile
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := clock.o time.o devices.o cpu.o system.o irq-common.o
+obj-y := clock.o time.o devices.o cpu.o system.o irq-common.o usb_common.o usb_wakeup.o
 
 obj-$(CONFIG_MXC_TZIC) += tzic.o
 obj-$(CONFIG_MXC_AVIC) += avic.o
@@ -22,3 +22,8 @@ obj-y += ssi-fiq-ksym.o
 endif
 
 obj-y += devices/
+
+# USB support
+obj-$(CONFIG_ISP1504_MXC) += isp1504xc.o
+obj-$(CONFIG_USB) += utmixc.o
+obj-$(CONFIG_USB) += usb_hsic_xcvr.o
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index 629172b..05c8bb2 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -89,3 +89,9 @@ config IMX_HAVE_PLATFORM_AHCI
 
 config IMX_HAVE_PLATFORM_MXC_HDMI
 	bool
+
+config IMX_HAVE_PLATFORM_FSL_OTG
+	bool
+
+config IMX_HAVE_PLATFORM_FSL_USB_WAKEUP
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index d129ff2..a957597 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -32,3 +32,5 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-mxc_hdmi.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-mxc-hdmi-core.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-imx-hdmi-soc.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_MXC_HDMI) += platform-imx-hdmi-soc-dai.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_OTG) += platform-fsl-usb2-otg.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_FSL_USB_WAKEUP) += platform-fsl-usb2-wakeup.o
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
new file mode 100644
index 0000000..f32593c
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-otg.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Based on Uwe Kleine-Koenig's platform-fsl-usb2-udc.c
+ * Copyright (C) 2010 Pengutronix
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_fsl_usb2_otg_data_entry_single(soc)				\
+	{								\
+		.iobase = soc ## _USB_OTG_BASE_ADDR,			\
+		.irq = soc ## _INT_USB_OTG,				\
+	}
+
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_fsl_usb2_otg_data imx6q_fsl_usb2_otg_data __initconst =
+	imx_fsl_usb2_otg_data_entry_single(MX6Q);
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+struct platform_device *__init imx_add_fsl_usb2_otg(
+		const struct imx_fsl_usb2_otg_data *data,
+		const struct fsl_usb2_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_512 - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+	return imx_add_platform_device_dmamask("fsl-usb2-otg", -1,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
index 848038f..2f1e238f 100644
--- a/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-udc.c
@@ -41,6 +41,11 @@ const struct imx_fsl_usb2_udc_data imx51_fsl_usb2_udc_data __initconst =
 	imx_fsl_usb2_udc_data_entry_single(MX51);
 #endif
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_fsl_usb2_udc_data imx6q_fsl_usb2_udc_data __initconst =
+	imx_fsl_usb2_udc_data_entry_single(MX6Q);
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
 struct platform_device *__init imx_add_fsl_usb2_udc(
 		const struct imx_fsl_usb2_udc_data *data,
 		const struct fsl_usb2_platform_data *pdata)
diff --git a/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c b/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
new file mode 100644
index 0000000..523c5d4
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-fsl-usb2-wakeup.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Copyright (C) 2010 Pengutronix
+ * Uwe Kleine-Koenig <u.kleine-koenig@pengutronix.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation.
+ */
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+#define imx_fsl_usb2_wakeup_data_entry_single(soc, _id, hs)			\
+	{								\
+		.id = _id,						\
+		.irq_phy = soc ## _INT_USB_PHY ## _id,		\
+		.irq_core = soc ## _INT_USB_ ## hs,				\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_fsl_usb2_wakeup_data imx6q_fsl_otg_wakeup_data __initconst =
+	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 0, OTG);
+const struct imx_fsl_usb2_wakeup_data imx6q_fsl_hs_wakeup_data[] __initconst = {
+	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 1, HS1),
+	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 2, HS2),
+	imx_fsl_usb2_wakeup_data_entry_single(MX6Q, 3, HS3),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
+struct platform_device *__init imx_add_fsl_usb2_wakeup(
+		const struct imx_fsl_usb2_wakeup_data *data,
+		const struct fsl_usb2_wakeup_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->irq_phy,
+			.end = data->irq_phy,
+			.flags = IORESOURCE_IRQ,
+		}, {
+			.start = data->irq_core,
+			.end = data->irq_core,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+	return imx_add_platform_device_dmamask("usb-wakeup", data->id,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
index 35851d8..e9eb76b 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc-ehci.c
@@ -58,6 +58,16 @@ const struct imx_mxc_ehci_data imx51_mxc_ehci_hs_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_mxc_ehci_data imx6q_mxc_ehci_otg_data __initconst =
+	imx_mxc_ehci_data_entry_single(MX6Q, 0, OTG);
+const struct imx_mxc_ehci_data imx6q_mxc_ehci_hs_data[] __initconst = {
+	imx_mxc_ehci_data_entry_single(MX6Q, 1, HS1),
+	imx_mxc_ehci_data_entry_single(MX6Q, 2, HS2),
+	imx_mxc_ehci_data_entry_single(MX6Q, 3, HS3),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
 struct platform_device *__init imx_add_mxc_ehci(
 		const struct imx_mxc_ehci_data *data,
 		const struct mxc_usbh_platform_data *pdata)
@@ -77,3 +87,24 @@ struct platform_device *__init imx_add_mxc_ehci(
 			res, ARRAY_SIZE(res),
 			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
 }
+
+/* FSL internal non-upstream code */
+struct platform_device *__init imx_add_fsl_ehci(
+		const struct imx_mxc_ehci_data *data,
+		const struct fsl_usb2_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_512 - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+	return imx_add_platform_device_dmamask("fsl-ehci", data->id,
+			res, ARRAY_SIZE(res),
+			pdata, sizeof(*pdata), DMA_BIT_MASK(32));
+}
diff --git a/arch/arm/plat-mxc/include/mach/arc_otg.h b/arch/arm/plat-mxc/include/mach/arc_otg.h
new file mode 100644
index 0000000..0d7b163
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/arc_otg.h
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+#ifdef CONFIG_ARCH_MX3
+extern volatile u32 *mx3_usb_otg_addr;
+#define OTG_BASE_ADDR		mx3_usb_otg_addr
+#else
+extern void __iomem *imx_otg_base;
+#define OTG_BASE_ADDR           imx_otg_base
+#endif
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#if (defined CONFIG_ARCH_MX5 | defined CONFIG_ARCH_MX6)
+#define USB_H3REGS_BASE		(OTG_BASE_ADDR + 0x600)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x800)
+#else
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+#endif
+
+#define USBOTG_REG32(offset)	(*((volatile u32 __force *)(USB_OTGREGS_BASE + (offset))))
+#define USBOTG_REG16(offset)	(*((volatile u16 __force *)(USB_OTGREGS_BASE + (offset))))
+
+#define USBH1_REG32(offset)	(*((volatile u32 __force *)(USB_H1REGS_BASE + (offset))))
+#define USBH1_REG16(offset)	(*((volatile u16 __force *)(USB_H1REGS_BASE + (offset))))
+
+#define USBH2_REG32(offset)	(*((volatile u32 __force *)(USB_H2REGS_BASE + (offset))))
+#define USBH2_REG16(offset)	(*((volatile u16 __force *)(USB_H2REGS_BASE + (offset))))
+
+#define USBH3_REG32(offset)	(*((volatile u32 __force *)(USB_H3REGS_BASE + (offset))))
+#define USBH3_REG16(offset)	(*((volatile u16 __force *)(USB_H3REGS_BASE + (offset))))
+
+#define USBOTHER_REG(offset)	(*((volatile u32 __force *)(USB_OTHERREGS_BASE + (offset))))
+
+/*
+ * OTG registers
+ */
+#define UOG_ID			USBOTG_REG32(0x00)	/* Host ID */
+#define UOG_HWGENERAL		USBOTG_REG32(0x04)	/* Host General */
+#define UOG_HWHOST		USBOTG_REG32(0x08)	/* Host h/w params */
+#define UOG_HWTXBUF		USBOTG_REG32(0x10)	/* TX buffer h/w params */
+#define UOG_HWRXBUF		USBOTG_REG32(0x14)	/* RX buffer h/w params */
+#define UOG_CAPLENGTH		USBOTG_REG16(0x100)	/* Capability register length */
+#define UOG_HCIVERSION		USBOTG_REG16(0x102)	/* Host Interface version */
+#define UOG_HCSPARAMS		USBOTG_REG32(0x104)	/* Host control structural params */
+#define UOG_HCCPARAMS		USBOTG_REG32(0x108)	/* control capability params */
+#define UOG_DCIVERSION		USBOTG_REG32(0x120)	/* device interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		USBOTG_REG32(0x140)	/* USB command register */
+#define UOG_USBSTS		USBOTG_REG32(0x144)	/* USB status register */
+#define UOG_USBINTR		USBOTG_REG32(0x148)	/* interrupt enable register */
+#define UOG_FRINDEX		USBOTG_REG32(0x14c)	/* USB frame index */
+/*      segment                             (0x150)	   addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	USBOTG_REG32(0x154)	/* host crtlr frame list base addr */
+#define UOG_DEVICEADDR		USBOTG_REG32(0x154)	/* device crtlr device address */
+#define UOG_ASYNCLISTADDR	USBOTG_REG32(0x158)	/* host ctrlr next async addr */
+#define UOG_EPLISTADDR		USBOTG_REG32(0x158)	/* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		USBOTG_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UOG_TXFILLTUNING	USBOTG_REG32(0x164)	/* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		USBOTG_REG32(0x170)	/* ULPI viewport */
+#define UOG_CFGFLAG		USBOTG_REG32(0x180)	/* configflag (supports HS) */
+#define UOG_PORTSC1		USBOTG_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		USBOTG_REG32(0x1a4)	/* OTG status and control */
+#define UOG_USBMODE		USBOTG_REG32(0x1a8)	/* USB device mode */
+#define UOG_ENDPTSETUPSTAT	USBOTG_REG32(0x1ac)	/* endpoint setup status */
+#define UOG_ENDPTPRIME		USBOTG_REG32(0x1b0)	/* endpoint initialization */
+#define UOG_ENDPTFLUSH		USBOTG_REG32(0x1b4)	/* endpoint de-initialize */
+#define UOG_ENDPTSTAT		USBOTG_REG32(0x1b8)	/* endpoint status */
+#define UOG_ENDPTCOMPLETE	USBOTG_REG32(0x1bc)	/* endpoint complete */
+#define UOG_EPCTRL0		USBOTG_REG32(0x1c0)	/* endpoint control0 */
+#define UOG_EPCTRL1		USBOTG_REG32(0x1c4)	/* endpoint control1 */
+#define UOG_EPCTRL2		USBOTG_REG32(0x1c8)	/* endpoint control2 */
+#define UOG_EPCTRL3		USBOTG_REG32(0x1cc)	/* endpoint control3 */
+#define UOG_EPCTRL4		USBOTG_REG32(0x1d0)	/* endpoint control4 */
+#define UOG_EPCTRL5		USBOTG_REG32(0x1d4)	/* endpoint control5 */
+#define UOG_EPCTRL6		USBOTG_REG32(0x1d8)	/* endpoint control6 */
+#define UOG_EPCTRL7		USBOTG_REG32(0x1dc)	/* endpoint control7 */
+
+/*
+ * Host 1 registers
+ */
+#define UH1_ID			USBH1_REG32(0x00)	/* Host ID */
+#define UH1_HWGENERAL		USBH1_REG32(0x04)	/* Host General */
+#define UH1_HWHOST		USBH1_REG32(0x08)	/* Host h/w params */
+#define UH1_HWTXBUF		USBH1_REG32(0x10)	/* TX buffer h/w params */
+#define UH1_HWRXBUF		USBH1_REG32(0x14)	/* RX buffer h/w params */
+#define UH1_CAPLENGTH		USBH1_REG16(0x100)	/* Capability register length */
+#define UH1_HCIVERSION		USBH1_REG16(0x102)	/* Host Interface version */
+#define UH1_HCSPARAMS		USBH1_REG32(0x104)	/* Host control structural params */
+#define UH1_HCCPARAMS		USBH1_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH1_USBCMD		USBH1_REG32(0x140)	/* USB command register */
+#define UH1_USBSTS		USBH1_REG32(0x144)	/* USB status register */
+#define UH1_USBINTR		USBH1_REG32(0x148)	/* interrupt enable register */
+#define UH1_FRINDEX		USBH1_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH1_PERIODICLISTBASE	USBH1_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH1_ASYNCLISTADDR	USBH1_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH1_BURSTSIZE		USBH1_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH1_TXFILLTUNING	USBH1_REG32(0x164)	/* TX FIFO fill tuning */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * Host 2 registers
+ */
+#define UH2_ID			USBH2_REG32(0x00)	/* Host ID */
+#define UH2_HWGENERAL		USBH2_REG32(0x04)	/* Host General */
+#define UH2_HWHOST		USBH2_REG32(0x08)	/* Host h/w params */
+#define UH2_HWTXBUF		USBH2_REG32(0x10)	/* TX buffer h/w params */
+#define UH2_HWRXBUF		USBH2_REG32(0x14)	/* RX buffer h/w params */
+#define UH2_CAPLENGTH		USBH2_REG16(0x100)	/* Capability register length */
+#define UH2_HCIVERSION		USBH2_REG16(0x102)	/* Host Interface version */
+#define UH2_HCSPARAMS		USBH2_REG32(0x104)	/* Host control structural params */
+#define UH2_HCCPARAMS		USBH2_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH2_USBCMD		USBH2_REG32(0x140)	/* USB command register */
+#define UH2_USBSTS		USBH2_REG32(0x144)	/* USB status register */
+#define UH2_USBINTR		USBH2_REG32(0x148)	/* interrupt enable register */
+#define UH2_FRINDEX		USBH2_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH2_USBMODE		USBH2_REG32(0x1a8)	/* USB device mode */
+/*
+ * Host 2 registers
+ */
+#define UH2_ID			USBH2_REG32(0x00)	/* Host ID */
+#define UH2_HWGENERAL		USBH2_REG32(0x04)	/* Host General */
+#define UH2_HWHOST		USBH2_REG32(0x08)	/* Host h/w params */
+#define UH2_HWTXBUF		USBH2_REG32(0x10)	/* TX buffer h/w params */
+#define UH2_HWRXBUF		USBH2_REG32(0x14)	/* RX buffer h/w params */
+#define UH2_CAPLENGTH		USBH2_REG16(0x100)	/* Capability register length */
+#define UH2_HCIVERSION		USBH2_REG16(0x102)	/* Host Interface version */
+#define UH2_HCSPARAMS		USBH2_REG32(0x104)	/* Host control structural params */
+#define UH2_HCCPARAMS		USBH2_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH2_USBCMD		USBH2_REG32(0x140)	/* USB command register */
+#define UH2_USBSTS		USBH2_REG32(0x144)	/* USB status register */
+#define UH2_USBINTR		USBH2_REG32(0x148)	/* interrupt enable register */
+#define UH2_FRINDEX		USBH2_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH2_USBMODE		USBH2_REG32(0x1a8)	/* USB device mode */
+/*
+ * Host 2 registers
+ */
+#define UH3_ID			USBH3_REG32(0x00)	/* Host ID */
+#define UH3_HWGENERAL		USBH3_REG32(0x04)	/* Host General */
+#define UH3_HWHOST		USBH3_REG32(0x08)	/* Host h/w params */
+#define UH3_HWTXBUF		USBH3_REG32(0x10)	/* TX buffer h/w params */
+#define UH3_HWRXBUF		USBH3_REG32(0x14)	/* RX buffer h/w params */
+#define UH3_CAPLENGTH		USBH3_REG16(0x100)	/* Capability register length */
+#define UH3_HCIVERSION		USBH3_REG16(0x102)	/* Host Interface version */
+#define UH3_HCSPARAMS		USBH3_REG32(0x104)	/* Host control structural params */
+#define UH3_HCCPARAMS		USBH3_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH3_USBCMD		USBH3_REG32(0x140)	/* USB command register */
+#define UH3_USBSTS		USBH3_REG32(0x144)	/* USB status register */
+#define UH3_USBINTR		USBH3_REG32(0x148)	/* interrupt enable register */
+#define UH3_FRINDEX		USBH3_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH3_PERIODICLISTBASE	USBH3_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH3_ASYNCLISTADDR	USBH3_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH3_BURSTSIZE		USBH3_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH3_TXFILLTUNING	USBH3_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH3_ULPIVIEW		USBH3_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH3_PORTSC1		USBH3_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH3_USBMODE		USBH3_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * other regs (not part of ARC core)
+ */
+#define USBCTRL			USBOTHER_REG(0x00)	/* USB Control register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)	/* USB OTG mirror register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG(0x08)      /* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG(0x0c)      /* OTG UTMI PHY Function Control register */
+#define USB_CTRL_1		USBOTHER_REG(0x10)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST2		USBOTHER_REG(0x14)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)      /* USB Clock on/off Control Register */
+
+/* mx6x other regs */
+#define USB_OTG_CTRL			USBOTHER_REG(0x00)	/* USB OTG Control register */
+#define USB_H1_CTRL			USBOTHER_REG(0x04)	/* USB H1 Control register */
+#define USB_H2_CTRL			USBOTHER_REG(0x08)	/* USB H2 Control register */
+#define USB_H3_CTRL			USBOTHER_REG(0x0c)	/* USB H3 Control register */
+#define USB_UH2_HSIC_CTRL		USBOTHER_REG(0x10)	/* USB Host2 HSIC Control Register */
+#define USB_UH3_HSIC_CTRL		USBOTHER_REG(0x14)	/* USB Host3 HSIC Control Register */
+#define USB_OTG_PHY_CTRL_0		USBOTHER_REG(0x18)	/* OTG UTMI PHY Control 0 Register */
+#define USB_H1_PHY_CTRL_0		USBOTHER_REG(0x1c)	/* OTG UTMI PHY Control 1 Register */
+#define USB_UH2_HSIC_DLL_CFG1		USBOTHER_REG(0x20)      /* USB Host2 HSIC DLL Configuration Register 1 */
+#define USB_UH2_HSIC_DLL_CFG2		USBOTHER_REG(0x24)      /* USB Host2 HSIC DLL Configuration Register 2 */
+#define USB_UH2_HSIC_DLL_CFG3		USBOTHER_REG(0x28)      /* USB Host2 HSIC DLL Configuration Register 3 */
+#define USB_UH3_HSIC_DLL_CFG1		USBOTHER_REG(0x30)      /* USB Host3 HSIC DLL Configuration Register 1 */
+#define USB_UH3_HSIC_DLL_CFG2		USBOTHER_REG(0x34)      /* USB Host3 HSIC DLL Configuration Register 2 */
+#define USB_UH3_HSIC_DLL_CFG3		USBOTHER_REG(0x38)      /* USB Host3 HSIC DLL Configuration Register 3 */
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30)	/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI			(0 << 30)	/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30)	/* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30)	/* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30)	/* serial */
+#define PORTSC_STS			(1 << 29)	/* serial xcvr select */
+#define PORTSC_PTW                      (1 << 28)       /* UTMI width */
+#define PORTSC_HSIC_MODE                (1 << 25)       /* Only for HSIC */
+#define PORTSC_PHCD                     (1 << 23)       /* Low Power Suspend */
+#define PORTSC_WKDC			(1 << 21)	/* wakeup on discnt*/
+#define PORTSC_WKCN			(1 << 20)	/* wakeup on connect*/
+#define PORTSC_PORT_POWER		(1 << 12)	/* port power */
+#define PORTSC_LS_MASK			(3 << 10)	/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)	/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)	/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)	/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)	/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)	/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)	/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)	/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)	/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)	/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)	/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)	/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)	/* current connect status */
+
+#define PORTSC_W1C_BITS                     \
+	(PORTSC_CONNECT_STATUS_CHANGE | \
+	PORTSC_PORT_EN_DIS_CHANGE | \
+	PORTSC_OVER_CURRENT_CHG)
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)	/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)	/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)	/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 29)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+/* UOG_USBSTS bits */
+#define USBSTS_PCI                     (1 << 2) /* Port Change Detect */
+#define USBSTS_URI                     (1 << 6) /* USB Reset Received */
+
+/* USBCMD */
+#define UCMD_RUN_STOP           (1 << 0)        /* controller run/stop */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+#define UCMD_ITC_NO_THRESHOLD	 (~(0xff << 16))	/* Interrupt Threshold Control */
+
+#if 1				/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+
+#define HCSPARAMS_PPC           (0x1<<4)        /* Port Power Control */
+extern enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata);
+#ifdef CONFIG_ARCH_MX6
+#include "regs-usbphy-mx6.h"
+#else
+#include "regs-usbphy-others.h"
+#endif
+
+#endif /* __ASM_ARCH_MXC_ARC_OTG_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index 15dba61..0865c3b 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -144,6 +144,23 @@ struct platform_device *__init imx_add_imx_ssi(
 		const struct imx_imx_ssi_data *data,
 		const struct imx_ssi_platform_data *pdata);
 
+struct imx_fsl_usb2_otg_data {
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_fsl_usb2_otg(
+		const struct imx_fsl_usb2_otg_data *data,
+		const struct fsl_usb2_platform_data *pdata);
+
+struct imx_fsl_usb2_wakeup_data {
+	int id;
+	resource_size_t irq_phy;
+	resource_size_t irq_core;
+};
+struct platform_device *__init imx_add_fsl_usb2_wakeup(
+		const struct imx_fsl_usb2_wakeup_data *data,
+		const struct fsl_usb2_wakeup_platform_data *pdata);
+
 #include <mach/imx-uart.h>
 struct imx_imx_uart_3irq_data {
 	int id;
@@ -259,6 +276,10 @@ struct platform_device *__init imx_add_mxc_ehci(
 		const struct imx_mxc_ehci_data *data,
 		const struct mxc_usbh_platform_data *pdata);
 
+struct platform_device *__init imx_add_fsl_ehci(
+		const struct imx_mxc_ehci_data *data,
+		const struct fsl_usb2_platform_data *pdata);
+
 #include <mach/mxc_hdmi.h>
 struct imx_mxc_hdmi_data {
 	resource_size_t irq;
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb.h b/arch/arm/plat-mxc/include/mach/fsl_usb.h
new file mode 100644
index 0000000..d5d387e
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2005-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Host side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/mxc.h>
+
+static void fsl_setup_phy(struct ehci_hcd *ehci,
+			  enum fsl_usb2_phy_modes phy_mode,
+			  int port_offset);
+
+static inline void fsl_platform_usb_setup(struct ehci_hcd *ehci)
+{
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = ehci_to_hcd(ehci)->self.controller->platform_data;
+	fsl_setup_phy(ehci, pdata->phy_mode, 0);
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+	struct fsl_usb2_platform_data *pdata;
+
+	pdata = hcd->self.controller->platform_data;
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_host)
+		pdata->xcvr_ops->set_host();
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
+
+/* Needed for enable PP and i2c/serial transceivers */
+static inline void
+fsl_platform_set_vbus_power(struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 temp;
+
+	/* HCSPARAMS */
+	temp = readl(pdata->regs + 0x104);
+	/* Port Power Control */
+	if (temp & HCSPARAMS_PPC) {
+		temp = readl(pdata->regs + FSL_SOC_USB_PORTSC1);
+		if (on)
+			temp |= PORT_POWER;
+		else
+			temp &= ~PORT_POWER;
+
+		writel(temp, pdata->regs + FSL_SOC_USB_PORTSC1);
+	}
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_vbus_power)
+		pdata->xcvr_ops->set_vbus_power(pdata->xcvr_ops, pdata, on);
+}
+
+/* Set USB AHB burst length for host */
+static inline void fsl_platform_set_ahb_burst(struct usb_hcd *hcd)
+{
+	struct fsl_usb2_platform_data *pdata;
+	unsigned int temp;
+
+	pdata = hcd->self.controller->platform_data;
+	if (pdata->change_ahb_burst) {
+		temp = readl(hcd->regs + FSL_SOC_USB_SBUSCFG);
+		writel((temp & (~(0x7))) | pdata->ahb_burst_mode,
+			hcd->regs + FSL_SOC_USB_SBUSCFG);
+	}
+
+	/* Increase TX fifo threshold for USB+ATA for i.mx35 2.0 */
+	if (cpu_is_mx35() && (imx_cpu_ver() >= IMX_CHIP_REVISION_2_0)) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x20 */
+		writel((temp & (~(0x3f << 16))) | (0x20 << 16),
+			hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+
+	/* Increase TX fifo threshold for USB+SD in Hostx */
+	if (cpu_is_mx53() && (strcmp("DR", pdata->name))) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x08 */
+		writel((temp & (~(0x3f << 16))) | (0x08 << 16),
+				hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+
+	/* Increase TX fifo threshold for in Hostx */
+	if (cpu_is_mx6()) {
+		temp = readl(hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+		/* Change TX FIFO threshold to be 0x08 */
+		writel((temp & (~(0x3f << 16))) | (0x08 << 16),
+				hcd->regs + FSL_SOC_USB_TXFILLTUNING);
+	}
+}
diff --git a/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
new file mode 100644
index 0000000..53f9b05
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/fsl_usb_gadget.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*
+ * USB Gadget side, platform-specific functionality.
+ */
+
+#include <linux/usb/fsl_xcvr.h>
+
+/* Needed for i2c/serial transceivers */
+static inline void
+fsl_platform_set_device_mode(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_device)
+		pdata->xcvr_ops->set_device();
+}
+
+static inline void
+fsl_platform_pullup_enable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(1);
+}
+
+static inline void
+fsl_platform_pullup_disable(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->pullup)
+		pdata->xcvr_ops->pullup(0);
+}
diff --git a/arch/arm/plat-mxc/include/mach/regs-usbphy-mx6.h b/arch/arm/plat-mxc/include/mach/regs-usbphy-mx6.h
new file mode 100644
index 0000000..473d16c
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/regs-usbphy-mx6.h
@@ -0,0 +1,480 @@
+/*
+ * Freescale USBPHY Register Definitions
+ *
+ * Copyright 2008-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * This file is created by xml file. Don't Edit it.
+ *
+ * Xml Revision: 1.2
+ * Template revision: 1.3
+ */
+
+#ifndef __ARCH_ARM___USBPHY_H
+#define __ARCH_ARM___USBPHY_H
+
+
+#define HW_USBPHY_PWD	(0x00000000)
+#define HW_USBPHY_PWD_SET	(0x00000004)
+#define HW_USBPHY_PWD_CLR	(0x00000008)
+#define HW_USBPHY_PWD_TOG	(0x0000000c)
+
+#define BP_USBPHY_PWD_RSVD2      21
+#define BM_USBPHY_PWD_RSVD2 0xFFE00000
+#define BF_USBPHY_PWD_RSVD2(v) \
+	(((v) << 21) & BM_USBPHY_PWD_RSVD2)
+#define BM_USBPHY_PWD_RXPWDRX 0x00100000
+#define BM_USBPHY_PWD_RXPWDDIFF 0x00080000
+#define BM_USBPHY_PWD_RXPWD1PT1 0x00040000
+#define BM_USBPHY_PWD_RXPWDENV 0x00020000
+#define BP_USBPHY_PWD_RSVD1      13
+#define BM_USBPHY_PWD_RSVD1 0x0001E000
+#define BF_USBPHY_PWD_RSVD1(v)  \
+	(((v) << 13) & BM_USBPHY_PWD_RSVD1)
+#define BM_USBPHY_PWD_TXPWDV2I 0x00001000
+#define BM_USBPHY_PWD_TXPWDIBIAS 0x00000800
+#define BM_USBPHY_PWD_TXPWDFS 0x00000400
+#define BP_USBPHY_PWD_RSVD0      0
+#define BM_USBPHY_PWD_RSVD0 0x000003FF
+#define BF_USBPHY_PWD_RSVD0(v)  \
+	(((v) << 0) & BM_USBPHY_PWD_RSVD0)
+
+#define HW_USBPHY_TX	(0x00000010)
+#define HW_USBPHY_TX_SET	(0x00000014)
+#define HW_USBPHY_TX_CLR	(0x00000018)
+#define HW_USBPHY_TX_TOG	(0x0000001c)
+
+#define BP_USBPHY_TX_RSVD5      29
+#define BM_USBPHY_TX_RSVD5 0xE0000000
+#define BF_USBPHY_TX_RSVD5(v) \
+	(((v) << 29) & BM_USBPHY_TX_RSVD5)
+#define BP_USBPHY_TX_USBPHY_TX_EDGECTRL      26
+#define BM_USBPHY_TX_USBPHY_TX_EDGECTRL 0x1C000000
+#define BF_USBPHY_TX_USBPHY_TX_EDGECTRL(v)  \
+	(((v) << 26) & BM_USBPHY_TX_USBPHY_TX_EDGECTRL)
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_INVERT 0x02000000
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_MUX 0x01000000
+#define BP_USBPHY_TX_RSVD4      22
+#define BM_USBPHY_TX_RSVD4 0x00C00000
+#define BF_USBPHY_TX_RSVD4(v)  \
+	(((v) << 22) & BM_USBPHY_TX_RSVD4)
+#define BM_USBPHY_TX_TXENCAL45DP 0x00200000
+#define BM_USBPHY_TX_RSVD3 0x00100000
+#define BP_USBPHY_TX_TXCAL45DP      16
+#define BM_USBPHY_TX_TXCAL45DP 0x000F0000
+#define BF_USBPHY_TX_TXCAL45DP(v)  \
+	(((v) << 16) & BM_USBPHY_TX_TXCAL45DP)
+#define BP_USBPHY_TX_RSVD2      14
+#define BM_USBPHY_TX_RSVD2 0x0000C000
+#define BF_USBPHY_TX_RSVD2(v)  \
+	(((v) << 14) & BM_USBPHY_TX_RSVD2)
+#define BM_USBPHY_TX_TXENCAL45DN 0x00002000
+#define BM_USBPHY_TX_RSVD1 0x00001000
+#define BP_USBPHY_TX_TXCAL45DN      8
+#define BM_USBPHY_TX_TXCAL45DN 0x00000F00
+#define BF_USBPHY_TX_TXCAL45DN(v)  \
+	(((v) << 8) & BM_USBPHY_TX_TXCAL45DN)
+#define BP_USBPHY_TX_RSVD0      4
+#define BM_USBPHY_TX_RSVD0 0x000000F0
+#define BF_USBPHY_TX_RSVD0(v)  \
+	(((v) << 4) & BM_USBPHY_TX_RSVD0)
+#define BP_USBPHY_TX_D_CAL      0
+#define BM_USBPHY_TX_D_CAL 0x0000000F
+#define BF_USBPHY_TX_D_CAL(v)  \
+	(((v) << 0) & BM_USBPHY_TX_D_CAL)
+
+#define HW_USBPHY_RX	(0x00000020)
+#define HW_USBPHY_RX_SET	(0x00000024)
+#define HW_USBPHY_RX_CLR	(0x00000028)
+#define HW_USBPHY_RX_TOG	(0x0000002c)
+
+#define BP_USBPHY_RX_RSVD2      23
+#define BM_USBPHY_RX_RSVD2 0xFF800000
+#define BF_USBPHY_RX_RSVD2(v) \
+	(((v) << 23) & BM_USBPHY_RX_RSVD2)
+#define BM_USBPHY_RX_RXDBYPASS 0x00400000
+#define BP_USBPHY_RX_RSVD1      7
+#define BM_USBPHY_RX_RSVD1 0x003FFF80
+#define BF_USBPHY_RX_RSVD1(v)  \
+	(((v) << 7) & BM_USBPHY_RX_RSVD1)
+#define BP_USBPHY_RX_DISCONADJ      4
+#define BM_USBPHY_RX_DISCONADJ 0x00000070
+#define BF_USBPHY_RX_DISCONADJ(v)  \
+	(((v) << 4) & BM_USBPHY_RX_DISCONADJ)
+#define BM_USBPHY_RX_RSVD0 0x00000008
+#define BP_USBPHY_RX_ENVADJ      0
+#define BM_USBPHY_RX_ENVADJ 0x00000007
+#define BF_USBPHY_RX_ENVADJ(v)  \
+	(((v) << 0) & BM_USBPHY_RX_ENVADJ)
+
+#define HW_USBPHY_CTRL	(0x00000030)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define HW_USBPHY_CTRL_CLR	(0x00000038)
+#define HW_USBPHY_CTRL_TOG	(0x0000003c)
+
+#define BM_USBPHY_CTRL_SFTRST 0x80000000
+#define BM_USBPHY_CTRL_CLKGATE 0x40000000
+#define BM_USBPHY_CTRL_UTMI_SUSPENDM 0x20000000
+#define BM_USBPHY_CTRL_HOST_FORCE_LS_SE0 0x10000000
+#define BM_USBPHY_CTRL_OTG_ID_VALUE 0x08000000
+#define BM_USBPHY_CTRL_ENAUTOSET_USBCLKS 0x04000000
+#define BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE 0x02000000
+#define BM_USBPHY_CTRL_FSDLL_RST_EN 0x01000000
+#define BM_USBPHY_CTRL_ENVBUSCHG_WKUP 0x00800000
+#define BM_USBPHY_CTRL_ENIDCHG_WKUP 0x00400000
+#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP 0x00200000
+#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD 0x00100000
+#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE 0x00080000
+#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL 0x00040000
+#define BM_USBPHY_CTRL_WAKEUP_IRQ 0x00020000
+#define BM_USBPHY_CTRL_ENIRQWAKEUP 0x00010000
+#define BM_USBPHY_CTRL_ENUTMILEVEL3 0x00008000
+#define BM_USBPHY_CTRL_ENUTMILEVEL2 0x00004000
+#define BM_USBPHY_CTRL_DATA_ON_LRADC 0x00002000
+#define BM_USBPHY_CTRL_DEVPLUGIN_IRQ 0x00001000
+#define BM_USBPHY_CTRL_ENIRQDEVPLUGIN 0x00000800
+#define BM_USBPHY_CTRL_RESUME_IRQ 0x00000400
+#define BM_USBPHY_CTRL_ENIRQRESUMEDETECT 0x00000200
+#define BM_USBPHY_CTRL_RESUMEIRQSTICKY 0x00000100
+#define BM_USBPHY_CTRL_ENOTGIDDETECT 0x00000080
+#define BM_USBPHY_CTRL_OTG_ID_CHG_IRQ 0x00000040
+#define BM_USBPHY_CTRL_DEVPLUGIN_POLARITY 0x00000020
+#define BM_USBPHY_CTRL_ENDEVPLUGINDETECT 0x00000010
+#define BM_USBPHY_CTRL_HOSTDISCONDETECT_IRQ 0x00000008
+#define BM_USBPHY_CTRL_ENIRQHOSTDISCON 0x00000004
+#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT 0x00000002
+#define BM_USBPHY_CTRL_ENOTG_ID_CHG_IRQ 0x00000001
+
+#define HW_USBPHY_STATUS	(0x00000040)
+
+#define BP_USBPHY_STATUS_RSVD4      11
+#define BM_USBPHY_STATUS_RSVD4 0xFFFFF800
+#define BF_USBPHY_STATUS_RSVD4(v) \
+	(((v) << 11) & BM_USBPHY_STATUS_RSVD4)
+#define BM_USBPHY_STATUS_RESUME_STATUS 0x00000400
+#define BM_USBPHY_STATUS_RSVD3 0x00000200
+#define BM_USBPHY_STATUS_OTGID_STATUS 0x00000100
+#define BM_USBPHY_STATUS_RSVD2 0x00000080
+#define BM_USBPHY_STATUS_DEVPLUGIN_STATUS 0x00000040
+#define BP_USBPHY_STATUS_RSVD1      4
+#define BM_USBPHY_STATUS_RSVD1 0x00000030
+#define BF_USBPHY_STATUS_RSVD1(v)  \
+	(((v) << 4) & BM_USBPHY_STATUS_RSVD1)
+#define BM_USBPHY_STATUS_HOSTDISCONDETECT_STATUS 0x00000008
+#define BP_USBPHY_STATUS_RSVD0      0
+#define BM_USBPHY_STATUS_RSVD0 0x00000007
+#define BF_USBPHY_STATUS_RSVD0(v)  \
+	(((v) << 0) & BM_USBPHY_STATUS_RSVD0)
+
+#define HW_USBPHY_DEBUG	(0x00000050)
+#define HW_USBPHY_DEBUG_SET	(0x00000054)
+#define HW_USBPHY_DEBUG_CLR	(0x00000058)
+#define HW_USBPHY_DEBUG_TOG	(0x0000005c)
+
+#define BM_USBPHY_DEBUG_RSVD3 0x80000000
+#define BM_USBPHY_DEBUG_CLKGATE 0x40000000
+#define BM_USBPHY_DEBUG_HOST_RESUME_DEBUG 0x20000000
+#define BP_USBPHY_DEBUG_SQUELCHRESETLENGTH      25
+#define BM_USBPHY_DEBUG_SQUELCHRESETLENGTH 0x1E000000
+#define BF_USBPHY_DEBUG_SQUELCHRESETLENGTH(v)  \
+	(((v) << 25) & BM_USBPHY_DEBUG_SQUELCHRESETLENGTH)
+#define BM_USBPHY_DEBUG_ENSQUELCHRESET 0x01000000
+#define BP_USBPHY_DEBUG_RSVD2      21
+#define BM_USBPHY_DEBUG_RSVD2 0x00E00000
+#define BF_USBPHY_DEBUG_RSVD2(v)  \
+	(((v) << 21) & BM_USBPHY_DEBUG_RSVD2)
+#define BP_USBPHY_DEBUG_SQUELCHRESETCOUNT      16
+#define BM_USBPHY_DEBUG_SQUELCHRESETCOUNT 0x001F0000
+#define BF_USBPHY_DEBUG_SQUELCHRESETCOUNT(v)  \
+	(((v) << 16) & BM_USBPHY_DEBUG_SQUELCHRESETCOUNT)
+#define BP_USBPHY_DEBUG_RSVD1      13
+#define BM_USBPHY_DEBUG_RSVD1 0x0000E000
+#define BF_USBPHY_DEBUG_RSVD1(v)  \
+	(((v) << 13) & BM_USBPHY_DEBUG_RSVD1)
+#define BM_USBPHY_DEBUG_ENTX2RXCOUNT 0x00001000
+#define BP_USBPHY_DEBUG_TX2RXCOUNT      8
+#define BM_USBPHY_DEBUG_TX2RXCOUNT 0x00000F00
+#define BF_USBPHY_DEBUG_TX2RXCOUNT(v)  \
+	(((v) << 8) & BM_USBPHY_DEBUG_TX2RXCOUNT)
+#define BP_USBPHY_DEBUG_RSVD0      6
+#define BM_USBPHY_DEBUG_RSVD0 0x000000C0
+#define BF_USBPHY_DEBUG_RSVD0(v)  \
+	(((v) << 6) & BM_USBPHY_DEBUG_RSVD0)
+#define BP_USBPHY_DEBUG_ENHSTPULLDOWN      4
+#define BM_USBPHY_DEBUG_ENHSTPULLDOWN 0x00000030
+#define BF_USBPHY_DEBUG_ENHSTPULLDOWN(v)  \
+	(((v) << 4) & BM_USBPHY_DEBUG_ENHSTPULLDOWN)
+#define BP_USBPHY_DEBUG_HSTPULLDOWN      2
+#define BM_USBPHY_DEBUG_HSTPULLDOWN 0x0000000C
+#define BF_USBPHY_DEBUG_HSTPULLDOWN(v)  \
+	(((v) << 2) & BM_USBPHY_DEBUG_HSTPULLDOWN)
+#define BM_USBPHY_DEBUG_DEBUG_INTERFACE_HOLD 0x00000002
+#define BM_USBPHY_DEBUG_OTGIDPIOLOCK 0x00000001
+
+#define HW_USBPHY_DEBUG0_STATUS	(0x00000060)
+
+#define BP_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT      26
+#define BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT 0xFC000000
+#define BF_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT(v) \
+	(((v) << 26) & BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT      16
+#define BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT 0x03FF0000
+#define BF_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(v)  \
+	(((v) << 16) & BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT      0
+#define BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT 0x0000FFFF
+#define BF_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(v)  \
+	(((v) << 0) & BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT)
+
+#define HW_USBPHY_DEBUG1	(0x00000070)
+#define HW_USBPHY_DEBUG1_SET	(0x00000074)
+#define HW_USBPHY_DEBUG1_CLR	(0x00000078)
+#define HW_USBPHY_DEBUG1_TOG	(0x0000007c)
+
+#define BP_USBPHY_DEBUG1_RSVD1      15
+#define BM_USBPHY_DEBUG1_RSVD1 0xFFFF8000
+#define BF_USBPHY_DEBUG1_RSVD1(v) \
+	(((v) << 15) & BM_USBPHY_DEBUG1_RSVD1)
+#define BP_USBPHY_DEBUG1_ENTAILADJVD      13
+#define BM_USBPHY_DEBUG1_ENTAILADJVD 0x00006000
+#define BF_USBPHY_DEBUG1_ENTAILADJVD(v)  \
+	(((v) << 13) & BM_USBPHY_DEBUG1_ENTAILADJVD)
+#define BM_USBPHY_DEBUG1_ENTX2TX 0x00001000
+#define BP_USBPHY_DEBUG1_RSVD0      4
+#define BM_USBPHY_DEBUG1_RSVD0 0x00000FF0
+#define BF_USBPHY_DEBUG1_RSVD0(v)  \
+	(((v) << 4) & BM_USBPHY_DEBUG1_RSVD0)
+#define BP_USBPHY_DEBUG1_DBG_ADDRESS      0
+#define BM_USBPHY_DEBUG1_DBG_ADDRESS 0x0000000F
+#define BF_USBPHY_DEBUG1_DBG_ADDRESS(v)  \
+	(((v) << 0) & BM_USBPHY_DEBUG1_DBG_ADDRESS)
+
+#define HW_USBPHY_VERSION	(0x00000080)
+
+#define BP_USBPHY_VERSION_MAJOR      24
+#define BM_USBPHY_VERSION_MAJOR 0xFF000000
+#define BF_USBPHY_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_USBPHY_VERSION_MAJOR)
+#define BP_USBPHY_VERSION_MINOR      16
+#define BM_USBPHY_VERSION_MINOR 0x00FF0000
+#define BF_USBPHY_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_USBPHY_VERSION_MINOR)
+#define BP_USBPHY_VERSION_STEP      0
+#define BM_USBPHY_VERSION_STEP 0x0000FFFF
+#define BF_USBPHY_VERSION_STEP(v)  \
+	(((v) << 0) & BM_USBPHY_VERSION_STEP)
+
+#define HW_USBPHY_IP	(0x00000090)
+#define HW_USBPHY_IP_SET	(0x00000094)
+#define HW_USBPHY_IP_CLR	(0x00000098)
+#define HW_USBPHY_IP_TOG	(0x0000009c)
+
+#define BP_USBPHY_IP_RSVD1      25
+#define BM_USBPHY_IP_RSVD1 0xFE000000
+#define BF_USBPHY_IP_RSVD1(v) \
+	(((v) << 25) & BM_USBPHY_IP_RSVD1)
+#define BP_USBPHY_IP_DIV_SEL      23
+#define BM_USBPHY_IP_DIV_SEL 0x01800000
+#define BF_USBPHY_IP_DIV_SEL(v)  \
+	(((v) << 23) & BM_USBPHY_IP_DIV_SEL)
+#define BV_USBPHY_IP_DIV_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_DIV_SEL__LOWER     0x1
+#define BV_USBPHY_IP_DIV_SEL__LOWEST    0x2
+#define BV_USBPHY_IP_DIV_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_LFR_SEL      21
+#define BM_USBPHY_IP_LFR_SEL 0x00600000
+#define BF_USBPHY_IP_LFR_SEL(v)  \
+	(((v) << 21) & BM_USBPHY_IP_LFR_SEL)
+#define BV_USBPHY_IP_LFR_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_LFR_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_LFR_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_LFR_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_CP_SEL      19
+#define BM_USBPHY_IP_CP_SEL 0x00180000
+#define BF_USBPHY_IP_CP_SEL(v)  \
+	(((v) << 19) & BM_USBPHY_IP_CP_SEL)
+#define BV_USBPHY_IP_CP_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_CP_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_CP_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_CP_SEL__UNDEFINED 0x3
+#define BM_USBPHY_IP_TSTI_TX_DP 0x00040000
+#define BM_USBPHY_IP_TSTI_TX_DM 0x00020000
+#define BM_USBPHY_IP_ANALOG_TESTMODE 0x00010000
+#define BP_USBPHY_IP_RSVD0      3
+#define BM_USBPHY_IP_RSVD0 0x0000FFF8
+#define BF_USBPHY_IP_RSVD0(v)  \
+	(((v) << 3) & BM_USBPHY_IP_RSVD0)
+#define BM_USBPHY_IP_EN_USB_CLKS 0x00000004
+#define BM_USBPHY_IP_PLL_LOCKED 0x00000002
+#define BM_USBPHY_IP_PLL_POWER 0x00000001
+
+/* The register definition for usbphy which includes at usb core's register set
+ * (from USB_CORE_BASE + 0x800)
+ */
+#define USB_CTRL			USBOTHER_REG(0x00)	/* USB OTG Control register */
+#define USB_H1_CTRL			USBOTHER_REG(0x04)	/* USB H1 Control register */
+#define USB_H2_CTRL			USBOTHER_REG(0x08)	/* USB H2 Control register */
+#define USB_H3_CTRL			USBOTHER_REG(0x0c)	/* USB H3 Control register */
+#define USB_UH2_HSIC_CTRL		USBOTHER_REG(0x10)	/* USB Host2 HSIC Control Register */
+#define USB_UH3_HSIC_CTRL		USBOTHER_REG(0x14)	/* USB Host3 HSIC Control Register */
+#define USB_OTG_PHY_CTRL_0		USBOTHER_REG(0x18)	/* OTG UTMI PHY Control 0 Register */
+#define USB_H1_PHY_CTRL_0		USBOTHER_REG(0x1c)	/* OTG UTMI PHY Control 1 Register */
+#define USB_UH2_HSIC_DLL_CFG1		USBOTHER_REG(0x20)      /* USB Host2 HSIC DLL Configuration Register 1 */
+#define USB_UH2_HSIC_DLL_CFG2		USBOTHER_REG(0x24)      /* USB Host2 HSIC DLL Configuration Register 2 */
+#define USB_UH2_HSIC_DLL_CFG3		USBOTHER_REG(0x28)      /* USB Host2 HSIC DLL Configuration Register 3 */
+#define USB_UH3_HSIC_DLL_CFG1		USBOTHER_REG(0x30)      /* USB Host3 HSIC DLL Configuration Register 1 */
+#define USB_UH3_HSIC_DLL_CFG2		USBOTHER_REG(0x34)      /* USB Host3 HSIC DLL Configuration Register 2 */
+#define USB_UH3_HSIC_DLL_CFG3		USBOTHER_REG(0x38)      /* USB Host3 HSIC DLL Configuration Register 3 */
+
+/*
+ * register bits
+ */
+
+/* USBCTRL */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
+#define UCTRL_H2WIR		(1 << 17)	/* HOST2 wakeup intr request received */
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_H2UIE		(1 << 8)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)	/* HOST2 power mask */
+#define UCTRL_H2OVBWK_EN	(1 << 6) /* OTG VBUS Wakeup Enable */
+#define UCTRL_H2OIDWK_EN	(1 << 5) /* OTG ID Wakeup Enable */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)	/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)	/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)	/* Host1 ULPI interrupt enable */
+
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2             (1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+#define UCTRL_IP_PULIDP         (1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP         (1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN       (1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_USBTE             (1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL             (1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE               (1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS             (1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)	/* OTG TLL Disable */
+#define UCTRL_OOCS              (1 <<  0)       /* OTG OverCurrent State */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+/* PHY control0 Register Bit Masks */
+#define USB_UTMI_PHYCTRL_CONF2	(1 << 26)
+
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE (1 << 24)
+#define USB_UTMI_PHYCTRL_CHGRDETEN (1 << 24)    /* Enable Charger Detector */
+#define USB_UTMI_PHYCTRL_CHGRDETON (1 << 23)    /* Charger Detector Power On Control */
+#define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
+#define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_MASK		0x3
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT	19
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN			(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN			(1 << 26)
+#define USB_CTRL_UH2_CLK_FROM_ULPI_PHY  	(1 << 2)
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
+
+/* mx6q's register bit begins*/
+
+/* OTG CTRL - H3 CTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+/* bit 18 - bit 30 is reserved at mx6q */
+#define UCTRL_WKUP_VBUS_EN	(1 << 17)	/* OTG wake-up on VBUS change enable */
+#define UCTRL_WKUP_ID_EN	(1 << 16)	/* OTG wake-up on ID change enable */
+#define UCTRL_WKUP_SW		(1 << 15)	/* OTG Software Wake-up */
+#define UCTRL_WKUP_SW_EN	(1 << 14)	/* OTG Software Wake-up enable */
+#define UCTRL_UTMI_ON_CLOCK	(1 << 13)	/* Force OTG UTMI PHY clock output on even if suspend mode */
+#define UCTRL_SUSPENDM		(1 << 12)	/* Force OTG UTMI PHY Suspend */
+#define UCTRL_RESET		(1 << 11)	/* Force OTG UTMI PHY Reset */
+#define UCTRL_OWIE		(1 << 10)	/* OTG wakeup intr request received */
+#define UCTRL_PM		(1 << 9)	/* OTG Power Mask */
+#define UCTRL_OVER_CUR_POL	(1 << 8)	/* OTG Polarity of Overcurrent */
+#define UCTRL_OVER_CUR_DIS	(1 << 7)	/* Disable OTG Overcurrent Detection */
+/* bit 0 - bit 6 is reserved at mx6q */
+
+/* Host2/3 HSIC Ctrl */
+#define CLK_VLD		(1 << 31)	/* Indicating whether HSIC clock is valid */
+#define HSIC_DEV_CONN		(1 << 21)	/* set after device connected */
+#define HSIC_EN		(1 << 12)	/* HSIC enable */
+#define HSIC_CLK_ON		(1 << 11)	/* Force HSIC module 480M clock on,
+						 * even when in Host is in suspend mode
+						 */
+/* OTG/HOST1 Phy Ctrl */
+#define PHY_UTMI_CLK_VLD	(1 << 31)	/* Indicating whether OTG UTMI PHY Clock Valida */
+
+#define NOP_XCVR		(0xffffffff)	/* Indicate it is no usb phy */
+#endif /* __ARCH_ARM___USBPHY_H */
diff --git a/arch/arm/plat-mxc/include/mach/regs-usbphy-others.h b/arch/arm/plat-mxc/include/mach/regs-usbphy-others.h
new file mode 100644
index 0000000..7d8d1ff
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/regs-usbphy-others.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_USB_PHY_OTHERS_H__
+#define __ASM_ARCH_MXC_USB_PHY_OTHERS_H__
+
+/*
+ * This file describes the registers of chipidea's phy
+ * This file can be used for i.MX1x, i.MX21. i.MX25. i.MX3x. i.MX5x.
+ */
+
+#define USBCTRL			USBOTHER_REG(0x00)	/* USB Control register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)	/* USB OTG mirror register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG(0x08)      /* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG(0x0c)      /* OTG UTMI PHY Function Control register */
+#define USB_CTRL_1		USBOTHER_REG(0x10)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST2		USBOTHER_REG(0x14)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)      /* USB Clock on/off Control Register */
+
+/*
+ * register bits
+ */
+
+/* USBCTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OWIE		(1 << 27)	/* OTG wakeup intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
+#ifdef CONFIG_ARCH_MX5
+#define UCTRL_H2WIR		(1 << 17)	/* HOST2 wakeup intr request received */
+#else
+#define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
+#endif
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+
+#ifdef CONFIG_ARCH_MX5
+#define UCTRL_H2UIE		(1 << 8)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)	/* HOST2 power mask */
+#else
+#define UCTRL_H2UIE		(1 << 20)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 19)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		(1 << 18)	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 16)	/* HOST2 power mask */
+#endif
+#define UCTRL_H2OVBWK_EN	(1 << 6) /* OTG VBUS Wakeup Enable */
+#define UCTRL_H2OIDWK_EN	(1 << 5) /* OTG ID Wakeup Enable */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)	/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)	/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)	/* Host1 ULPI interrupt enable */
+
+#if defined(CONFIG_ARCH_MX37)
+/* VBUS wakeup enable, UTMI only */
+#define UCTRL_VBUS_WKUP_EN	(1 << 12)
+#elif defined(CONFIG_ARCH_MX25) || defined(CONFIG_ARCH_MX35)
+#define UCTRL_VBUS_WKUP_EN      (1 << 15)
+#endif
+
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2             (1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+#define UCTRL_IP_PULIDP         (1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP         (1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN       (1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_USBTE             (1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL             (1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE               (1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS             (1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)	/* OTG TLL Disable */
+#define UCTRL_OOCS              (1 <<  0)       /* OTG OverCurrent State */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+/* PHY control0 Register Bit Masks */
+#define USB_UTMI_PHYCTRL_CONF2	(1 << 26)
+
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE (1 << 24)
+#define USB_UTMI_PHYCTRL_CHGRDETEN (1 << 24)    /* Enable Charger Detector */
+#define USB_UTMI_PHYCTRL_CHGRDETON (1 << 23)    /* Charger Detector Power On Control */
+#define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
+#define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_MASK		0x3
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT	19
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN			(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN			(1 << 26)
+#define USB_CTRL_UH2_CLK_FROM_ULPI_PHY  	(1 << 2)
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
+#endif /* __ASM_ARCH_MXC_USB_PHY_OTHERS_H__ */
diff --git a/arch/arm/plat-mxc/isp1504xc.c b/arch/arm/plat-mxc/isp1504xc.c
new file mode 100644
index 0000000..8fd7bf2
--- /dev/null
+++ b/arch/arm/plat-mxc/isp1504xc.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/delay.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_FUNC		0x04	/* Function Control */
+#define ISP1504_ITFCTL		0x07	/* Interface Control */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+/* 1504 OTG Function Control Register bits */
+#define SUSPENDM		(1 << 6)	/* places the PHY into
+						   low-power mode      */
+#define DRV_RESET		(1 << 5)	/* Active HIGH transceiver
+						   reset                  */
+
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+static u8 isp1504_read(int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_set(u8 bits, int reg, volatile u32 *view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+static void isp1504_clear(u8 bits, int reg, volatile u32 *view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+
+static void isp1508_fix(u32 *view)
+{
+	/* Set bits IND_PASS_THRU and IND_COMPL */
+	isp1504_set(0x60, ISP1504_ITFCTL, view);
+
+	/* Set bit USE_EXT_VBUS_IND */
+	isp1504_set(USE_EXT_VBUS_IND, ISP1504_OTGCTL, view);
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void isp1504_set_vbus_power(struct fsl_xcvr_ops *this,
+				   struct fsl_usb2_platform_data *pdata, int on)
+{
+	u32 *view = pdata->regs + ULPIVW_OFF;
+
+	pr_debug("real %s(on=%d) view=0x%p\n", __FUNCTION__, on, view);
+
+	pr_debug("ULPI Vendor ID 0x%x    Product ID 0x%x\n",
+		 (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_VID_LOW, view),
+		 (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+		 isp1504_read(ISP1504_PID_LOW, view));
+
+	pr_debug("OTG Control before=0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1508_fix(view);
+
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	pr_debug("OTG Control after = 0x%x\n",
+		 isp1504_read(ISP1504_OTGCTL, view));
+}
+
+/*!
+ * set remote wakeup
+ *
+ * @param       view  viewport register
+ */
+static void isp1504_set_remote_wakeup(u32 *view)
+{
+	__raw_writel(~ULPIVW_WRITE & __raw_readl(view), view);
+	__raw_writel((1 << ULPIVW_PORT_SHIFT) | __raw_readl(view), view);
+	__raw_writel(ULPIVW_RUN | __raw_readl(view), view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+static void isp1504_init(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static void isp1504_uninit(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s:\n", __FUNCTION__);
+}
+
+static void isp1504_suspend(struct fsl_xcvr_ops *this)
+{
+	pr_debug("%s\n", __func__);
+
+	/* send suspend command */
+	isp1504_clear(SUSPENDM, ISP1504_FUNC, &UOG_ULPIVIEW);
+	pr_debug("%s.\n", __func__);
+}
+
+/*!
+ * Set the 1504 transceiver to the proper mode for testing purposes.
+ *
+ * @param       view  the ULPI VIEWPORT register address
+ * @param       test_mode Set the 1504 transceiver to disable bit stuffing and NRZI
+ */
+ static void isp1504_set_test_mode(u32 *view, enum usb_test_mode test_mode)
+{
+	if (test_mode == USB_TEST_J || test_mode == USB_TEST_K) {
+		printk(KERN_INFO "udc: disable bit stuffing and NRZI\n");
+		/* Disable bit-stuffing and NRZI encoding. */
+		isp1504_set(0x10, 0x04, view);
+	}
+}
+
+static struct fsl_xcvr_ops isp1504_ops = {
+	.name = "isp1504",
+	.xcvr_type = PORTSC_PTS_ULPI,
+	.init = isp1504_init,
+	.uninit = isp1504_uninit,
+	.suspend = isp1504_suspend,
+	.set_vbus_power = isp1504_set_vbus_power,
+	.set_remote_wakeup = isp1504_set_remote_wakeup,
+	.set_test_mode = isp1504_set_test_mode,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+extern int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init isp1504xc_init(void)
+{
+	pr_debug("%s\n", __FUNCTION__);
+
+	fsl_usb_xcvr_register(&isp1504_ops);
+
+	/* suspend isp1504 */
+	if (fsl_usb_xcvr_suspend(&isp1504_ops))
+		pr_debug("%s: failed to suspend isp1504\n", __func__);
+
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit isp1504xc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&isp1504_ops);
+}
+
+subsys_initcall(isp1504xc_init);
+module_exit(isp1504xc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("isp1504 xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/usb_common.c b/arch/arm/plat-mxc/usb_common.c
new file mode 100644
index 0000000..04d0cdf
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_common.c
@@ -0,0 +1,933 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb_common.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <linux/io.h>
+#include <asm/mach-types.h>
+#include <mach/arc_otg.h>
+#include <mach/hardware.h>
+#include <mach/mxc.h>
+
+void __iomem *imx_otg_base;
+
+#define MXC_NUMBER_USB_TRANSCEIVER 6
+struct fsl_xcvr_ops *g_xc_ops[MXC_NUMBER_USB_TRANSCEIVER] = { NULL };
+
+enum fsl_usb2_modes get_usb_mode(struct fsl_usb2_platform_data *pdata)
+{
+	enum fsl_usb2_modes mode;
+	mode = FSL_USB_UNKNOWN;
+
+	if (!strcmp("DR", pdata->name)) {
+		if ((UOG_USBMODE & 0x3) == 0x2)
+			mode = FSL_USB_DR_DEVICE;
+		else if ((UOG_USBMODE & 0x3) == 0x3)
+			mode = FSL_USB_DR_HOST;
+	} else if (!strcmp("Host 1", pdata->name))
+		mode = FSL_USB_MPH_HOST1;
+	else if (!strcmp("Host 2", pdata->name))
+		mode = FSL_USB_MPH_HOST2;
+
+	if (mode == FSL_USB_UNKNOWN)
+		printk(KERN_ERR "unknow usb mode,name is %s\n", pdata->name);
+	return mode;
+}
+
+static struct clk *usb_clk;
+static struct clk *usb_ahb_clk;
+
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int fsl_check_usbclk(void)
+{
+	unsigned long freq;
+
+	usb_ahb_clk = clk_get(NULL, "usb_ahb_clk");
+	if (clk_enable(usb_ahb_clk)) {
+		if (cpu_is_mx6q() || cpu_is_mx6dl())
+			return 0; /* there is no ahb clock at mx6 */
+		printk(KERN_ERR "clk_enable(usb_ahb_clk) failed\n");
+		return -EINVAL;
+	}
+	clk_put(usb_ahb_clk);
+
+	usb_clk = clk_get(NULL, "usb_clk");
+	if (clk_enable(usb_clk)) {
+		if (cpu_is_mx6q() || cpu_is_mx6dl())
+			return 0; /* there is usb_clk at mx6 */
+		printk(KERN_ERR "clk_enable(usb_clk) failed\n");
+		return -EINVAL;
+	}
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
+		return -1;
+	}
+
+	return 0;
+}
+
+void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == NULL) {
+			g_xc_ops[i] = xcvr_ops;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_register);
+
+void fsl_platform_set_test_mode (struct fsl_usb2_platform_data *pdata, enum usb_test_mode mode)
+{
+	if (pdata->xcvr_ops && pdata->xcvr_ops->set_test_mode)
+		pdata->xcvr_ops->set_test_mode((u32 *)(pdata->regs + ULPIVW_OFF), mode);
+}
+EXPORT_SYMBOL(fsl_platform_set_test_mode);
+
+void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (g_xc_ops[i] == xcvr_ops) {
+			g_xc_ops[i] = NULL;
+			return;
+		}
+	}
+
+	pr_debug("Failed %s\n", __func__);
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_unregister);
+
+static struct fsl_xcvr_ops *fsl_usb_get_xcvr(char *name)
+{
+	int i;
+
+	pr_debug("%s\n", __func__);
+	if (name == NULL) {
+		printk(KERN_ERR "get_xcvr(): No tranceiver name\n");
+		return NULL;
+	}
+
+	for (i = 0; i < MXC_NUMBER_USB_TRANSCEIVER; i++) {
+		if (strcmp(g_xc_ops[i]->name, name) == 0) {
+			return g_xc_ops[i];
+		}
+	}
+	pr_debug("Failed %s\n", __func__);
+	return NULL;
+}
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int usb_mxc_instance_id;
+__init struct platform_device *host_pdev_register(struct resource *res, int n_res,
+					   struct fsl_usb2_platform_data *config)
+{
+	struct platform_device *pdev;
+	int rc;
+
+	pr_debug("register host res=0x%p, size=%d\n", res, n_res);
+
+	pdev = platform_device_register_simple("fsl-ehci",
+			 usb_mxc_instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %ld\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+
+	/*
+	 * platform_device_add_data() makes a copy of
+	 * the platform_data passed in.  That makes it
+	 * impossible to share the same config struct for
+	 * all OTG devices (host,gadget,otg).  So, just
+	 * set the platorm_data pointer ourselves.
+	 */
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct fsl_usb2_platform_data));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s host (%s) registered\n", config->name,
+	       config->transceiver);
+	pr_debug("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p\n",
+		 pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+
+	usb_mxc_instance_id++;
+
+	return pdev;
+}
+
+static void usbh1_set_serial_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE); /* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |		/* single-ended / unidir. */
+		   UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+		   UCTRL_H1PM;			/* power mask */
+}
+
+static void usbh1_set_ulpi_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while (UH1_USBCMD & UCMD_RESET)
+		;
+
+	/* Select the clock from external PHY */
+	USB_CTRL_1 |= USB_CTRL_UH1_EXT_CLK_EN;
+
+	/* select ULPI PHY PTS=2 */
+	UH1_PORTSC1 = (UH1_PORTSC1 & ~PORTSC_PTS_MASK) | PORTSC_PTS_ULPI;
+
+	USBCTRL &= ~UCTRL_H1WIE; /* HOST1 wakeup intr disable */
+	USBCTRL &= ~UCTRL_H1UIE; /* Host1 ULPI interrupt disable */
+	USBCTRL |= UCTRL_H1PM; /* HOST1 power mask */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* OC is not used */
+
+	/* Interrupt Threshold Control:Immediate (no threshold) */
+	UH1_USBCMD &= UCMD_ITC_NO_THRESHOLD;
+
+	UH1_USBCMD |= UCMD_RESET;       /* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	* the ULPI transceiver to reset too.
+	*/
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh1_set_utmi_xcvr(void)
+{
+	u32 tmp;
+
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while ((UH1_USBCMD) & (UCMD_RESET))
+		;
+
+	/* For OC and PWR, it is board level setting
+	 * The default setting is for mx53 evk
+	 */
+	USBCTRL &= ~UCTRL_H1PM;	/* Host1 Power Mask */
+	USBCTRL &= ~UCTRL_H1WIE; /* Host1 Wakeup Intr Disable */
+	USB_PHY_CTR_FUNC |= USB_UH1_OC_DIS; /* Over current disable */
+
+	if (cpu_is_mx50()) {
+		USBCTRL |= UCTRL_H1PM; /* Host1 Power Mask */
+		USB_PHY_CTR_FUNC &= ~USB_UH1_OC_DIS; /* Over current enable */
+		/* Over current polarity low active */
+		USB_PHY_CTR_FUNC |= USB_UH1_OC_POL;
+	}
+	/* set UTMI xcvr */
+	tmp = UH1_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_UTMI;
+	UH1_PORTSC1 = tmp;
+
+	/* Set the PHY clock to 24MHz */
+	USBH1_PHY_CTRL1 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
+	USBH1_PHY_CTRL1 |= 0x01;
+
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	UH1_PORTSC1 |= PORTSC_PTW;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	/* Stop then Reset */
+	UH1_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH1_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH1_USBCMD |= UCMD_RESET;
+	while ((UH1_USBCMD) & (UCMD_RESET))
+		;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for UTMI tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh2_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+
+	UH2_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH2_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+
+	USBCTRL_HOST2 &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);
+	USBCTRL_HOST2 &= ~UCTRL_H2WIE;	/* wakeup intr enable */
+	USBCTRL_HOST2 &= ~UCTRL_H2UIE;	/* ULPI intr enable */
+	USB_CTRL_1 |= USB_CTRL_UH2_EXT_CLK_EN;
+	if (cpu_is_mx53())
+		USB_CTRL_1 |= USB_CTRL_UH2_CLK_FROM_ULPI_PHY;
+	if (cpu_is_mx51())/* not tested */
+		USBCTRL_HOST2 |= (1 << 12);
+	/* must set ULPI phy before turning off clock */
+	tmp = UH2_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UH2_PORTSC1 = tmp;
+	if (cpu_is_mx53()) {
+		/* turn off the internal 60MHZ clk  */
+		USB_CLKONOFF_CTRL |= (1 << 21);
+	}
+	UH2_USBCMD |= UCMD_RESET;	/* reset the controller */
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+static void usbh2_set_serial_xcvr(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	/* Stop then Reset */
+	UH2_USBCMD &= ~UCMD_RUN_STOP;
+	while (UH2_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	USBCTRL &= ~(UCTRL_H2SIC_MASK);	/* Disable bypass mode */
+	USBCTRL &= ~(UCTRL_H2PM);	/* Power Mask */
+	USBCTRL &= ~UCTRL_H2OCPOL;	/* OverCurrent Polarity is Low Active */
+	USBCTRL &= ~UCTRL_H2WIE;	/* Wakeup intr disable */
+	USBCTRL |= UCTRL_IP_PUE_DOWN |	/* ipp_pue_pulldwn_dpdm */
+	    UCTRL_USBTE |	/* USBT is enabled */
+	    UCTRL_H2DT;		/* Disable H2 TLL */
+
+	if (cpu_is_mx25()) {
+		/*
+		 * USBH2_PWR and USBH2_OC are active high.
+		 * Must force xcvr clock to "internal" so that
+		 * we can write to PTS field after it's been
+		 * cleared by ehci_turn_off_all_ports().
+		 */
+		USBCTRL |= UCTRL_H2PP | UCTRL_H2OCPOL | UCTRL_XCSH2;
+		/* Disable Host2 bus Lock */
+		USBCTRL |= UCTRL_H2LOCKD;
+	}
+
+	USBCTRL &= ~(UCTRL_PP);
+	UH2_PORTSC1 = (UH2_PORTSC1 & (~PORTSC_PTS_MASK)) | PORTSC_PTS_SERIAL;
+
+	if (UH2_HCSPARAMS & HCSPARAMS_PPC)
+		UH2_PORTSC1 |= PORTSC_PORT_POWER;
+
+	/* Reset controller before set host mode */
+	UH2_USBCMD |= UCMD_RESET;
+	while (UH2_USBCMD & UCMD_RESET)
+		;
+
+	msleep(100);
+}
+
+/*!
+ * Register remote wakeup by this usb controller
+ *
+ * @param pdev: platform_device for this usb controller
+ *
+ * @return 0 or negative error code in case not supportted.
+ */
+static int usb_register_remote_wakeup(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res;
+	int irq;
+
+	pr_debug("%s: pdev=0x%p \n", __func__, pdev);
+	if (!(pdata->wake_up_enable))
+		return -ECANCELED;
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+		"Found HC with no IRQ. Check %s setup!\n",
+		dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+	device_set_wakeup_capable(&pdev->dev, true);
+	enable_irq_wake(irq);
+
+	return 0;
+}
+
+int fsl_usb_host_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "%s transceiver ops missing\n", pdata->name);
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+
+	pr_debug("%s: grab pins\n", __func__);
+	if (pdata->gpio_usb_active && pdata->gpio_usb_active())
+		return -EINVAL;
+
+	if (cpu_is_mx50())
+		/* Turn on AHB CLK for H1*/
+		USB_CLKONOFF_CTRL &= ~H1_AHBCLK_OFF;
+
+	/* enable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_enable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_enable(pdata->xcvr_pwr->regu2);
+	}
+
+	if (xops->init)
+		xops->init(xops);
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("%s port is not a wakeup source.\n", pdata->name);
+	if (!(cpu_is_mx6q() || cpu_is_mx6dl())) {
+		if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+			if (cpu_is_mx35()) {
+				usbh2_set_serial_xcvr();
+				/* Close the internal 60Mhz */
+				USBCTRL &= ~UCTRL_XCSH2;
+			} else if (cpu_is_mx25())
+				usbh2_set_serial_xcvr();
+			else
+				usbh1_set_serial_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+			if (!strcmp("Host 1", pdata->name))
+				usbh1_set_ulpi_xcvr();
+			if (!strcmp("Host 2", pdata->name))
+				usbh2_set_ulpi_xcvr();
+		} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
+			usbh1_set_utmi_xcvr();
+		}
+	} else {
+#ifdef CONFIG_ARCH_MX6
+		if (!strcmp("Host 1", pdata->name)) {
+			if (machine_is_mx6q_arm2())
+				USB_H1_CTRL &= ~UCTRL_OVER_CUR_POL;
+			else if (machine_is_mx6q_sabrelite())
+				USB_H1_CTRL |= UCTRL_OVER_CUR_POL;
+			USB_H1_CTRL |= UCTRL_OVER_CUR_DIS;
+		}
+#endif
+	}
+
+	pr_debug("%s: %s success\n", __func__, pdata->name);
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_host_init);
+
+void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+		pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+	pdata->regs = NULL;
+
+	if (pdata->gpio_usb_inactive)
+		pdata->gpio_usb_inactive();
+	if (pdata->xcvr_type == PORTSC_PTS_SERIAL) {
+		/* Workaround an IC issue for ehci driver.
+		 * when turn off root hub port power, EHCI set
+		 * PORTSC reserved bits to be 0, but PTS with 0
+		 * means UTMI interface, so here force the Host2
+		 * port use the internal 60Mhz.
+		 */
+		if (cpu_is_mx35())
+			USBCTRL |= UCTRL_XCSH2;
+		clk_disable(usb_clk);
+	}
+
+	/* disable board power supply for xcvr */
+	if (pdata->xcvr_pwr) {
+		if (pdata->xcvr_pwr->regu1)
+			regulator_disable(pdata->xcvr_pwr->regu1);
+		if (pdata->xcvr_pwr->regu2)
+			regulator_disable(pdata->xcvr_pwr->regu2);
+	}
+
+	clk_disable(usb_ahb_clk);
+}
+EXPORT_SYMBOL(fsl_usb_host_uninit);
+
+static void otg_set_serial_xcvr(void)
+{
+	pr_debug("%s\n", __func__);
+}
+
+void otg_set_serial_host(void)
+{
+	pr_debug("%s\n", __func__);
+	/* set USBCTRL for host operation
+	 * disable: bypass mode,
+	 * set: single-ended/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_ASESVLD;	/* 0xa */
+}
+EXPORT_SYMBOL(otg_set_serial_host);
+
+void otg_set_serial_peripheral(void)
+{
+	/* set USBCTRL for device operation
+	 * disable: bypass mode
+	 * set: differential/unidir/6 wire, OTG wakeup intr enable,
+	 *      power mask
+	 */
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+
+#if defined(CONFIG_MXC_USB_SB3)
+	USBCTRL |= UCTRL_OSIC_SB3 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_SU6)
+	USBCTRL |= UCTRL_OSIC_SU6 | UCTRL_OWIE | UCTRL_OPM;
+#elif defined(CONFIG_MXC_USB_DB4)
+	USBCTRL |= UCTRL_OSIC_DB4 | UCTRL_OWIE | UCTRL_OPM;
+#else
+	USBCTRL |= UCTRL_OSIC_DU6 | UCTRL_OWIE | UCTRL_OPM;
+#endif
+
+	USB_OTG_MIRROR = OTGM_VBUSVAL | OTGM_BSESVLD | OTGM_IDIDG;	/* oxd */
+}
+EXPORT_SYMBOL(otg_set_serial_peripheral);
+
+static void otg_set_ulpi_xcvr(void)
+{
+	u32 tmp;
+
+	pr_debug("%s\n", __func__);
+	USBCTRL &= ~UCTRL_OSIC_MASK;
+#if defined(CONFIG_ARCH_MX27) || defined(CONFIG_ARCH_MX3)
+	USBCTRL &= ~UCTRL_BPE;
+#endif
+	USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* must set ULPI phy before turning off clock */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+	/* Turn off the usbpll for ulpi tranceivers */
+	clk_disable(usb_clk);
+}
+
+int fsl_usb_xcvr_suspend(struct fsl_xcvr_ops *xcvr_ops)
+{
+	if (!machine_is_mx31_3ds())
+		return -ECANCELED;
+
+	if (xcvr_ops->xcvr_type == PORTSC_PTS_ULPI) {
+		if (fsl_check_usbclk() != 0)
+			return -EINVAL;
+		clk_enable(usb_clk);
+
+		otg_set_ulpi_xcvr();
+
+		if (xcvr_ops->suspend)
+			/* suspend transceiver */
+			xcvr_ops->suspend(xcvr_ops);
+
+		clk_disable(usb_clk);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(fsl_usb_xcvr_suspend);
+
+static void otg_set_utmi_xcvr(void)
+{
+	u32 tmp;
+
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	if (cpu_is_mx53())
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+
+	if (cpu_is_mx51()) {
+		if (machine_is_mx51_3ds()) {
+			/* OTG Polarity of Overcurrent is Low active */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_POL;
+			/* Enable OTG Overcurrent Event */
+			USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_OC_DIS;
+		} else {
+			/* BBG is not using OC */
+			USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+		}
+	} else if (cpu_is_mx25()) {
+		USBCTRL |= UCTRL_OCPOL;
+		USBCTRL &= ~UCTRL_PP;
+	} else if (cpu_is_mx50()) {
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_OC_DIS;
+	} else {
+		/* USBOTG_PWR low active */
+		USBCTRL &= ~UCTRL_PP;
+		/* OverCurrent Polarity is Low Active */
+		USBCTRL &= ~UCTRL_OCPOL;
+
+		if (cpu_is_mx35() && (imx_cpu_ver() < IMX_CHIP_REVISION_2_0))
+			/* OTG Lock Disable */
+			USBCTRL |= UCTRL_OLOCKD;
+	}
+
+	if (cpu_is_mx51())
+		USBCTRL &= ~UCTRL_OPM;	/* OTG Power Mask */
+
+	USBCTRL &= ~UCTRL_OWIE;	/* OTG Wakeup Intr Disable */
+
+	/* set UTMI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_UTMI;
+	UOG_PORTSC1 = tmp;
+
+	if (cpu_is_mx51()) {
+		/* Set the PHY clock to 19.2MHz */
+		USB_PHY_CTR_FUNC2 &= ~USB_UTMI_PHYCTRL2_PLLDIV_MASK;
+		USB_PHY_CTR_FUNC2 |= 0x01;
+	}
+
+	/* Workaround an IC issue for ehci driver:
+	 * when turn off root hub port power, EHCI set
+	 * PORTSC reserved bits to be 0, but PTW with 0
+	 * means 8 bits tranceiver width, here change
+	 * it back to be 16 bits and do PHY diable and
+	 * then enable.
+	 */
+	UOG_PORTSC1 |= PORTSC_PTW;
+
+	if (cpu_is_mx35() || cpu_is_mx25()) {
+		/* Enable UTMI interface in PHY control Reg */
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_UTMI_ENABLE;
+		USB_PHY_CTR_FUNC |= USB_UTMI_PHYCTRL_UTMI_ENABLE;
+	}
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	/* Stop then Reset */
+	UOG_USBCMD &= ~UCMD_RUN_STOP;
+	while (UOG_USBCMD & UCMD_RUN_STOP)
+		;
+
+	UOG_USBCMD |= UCMD_RESET;
+	while ((UOG_USBCMD) & (UCMD_RESET))
+		;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	msleep(100);
+
+#ifdef CONFIG_ARCH_MX37
+	if (cpu_is_mx37()) {
+		/* fix USB PHY Power Gating leakage issue for i.MX37 */
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CHGRDETON;
+		USB_PHY_CTR_FUNC &= ~USB_UTMI_PHYCTRL_CHGRDETEN;
+	}
+#endif
+	/* Turn off the usbpll for UTMI tranceivers */
+	clk_disable(usb_clk);
+}
+
+static int mxc_otg_used;
+
+int usbotg_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+	struct fsl_xcvr_ops *xops;
+
+	pr_debug("%s: pdev=0x%p  pdata=0x%p\n", __func__, pdev, pdata);
+
+	xops = fsl_usb_get_xcvr(pdata->transceiver);
+	if (!xops) {
+		printk(KERN_ERR "DR transceiver ops missing\n");
+		return -EINVAL;
+	}
+	pdata->xcvr_ops = xops;
+	pdata->xcvr_type = xops->xcvr_type;
+	pdata->pdev = pdev;
+
+	if (fsl_check_usbclk() != 0)
+		return -EINVAL;
+	if (!mxc_otg_used) {
+		if (cpu_is_mx50())
+			/* Turn on AHB CLK for OTG*/
+			USB_CLKONOFF_CTRL &= ~OTG_AHBCLK_OFF;
+
+		pr_debug("%s: grab pins\n", __func__);
+		if (pdata->gpio_usb_active && pdata->gpio_usb_active())
+			return -EINVAL;
+		if (xops->init)
+			xops->init(xops);
+		if (!((cpu_is_mx6q() || cpu_is_mx6dl()))) {
+			UOG_PORTSC1 = UOG_PORTSC1 & ~PORTSC_PHCD;
+
+
+			if (xops->xcvr_type == PORTSC_PTS_SERIAL) {
+				if (pdata->operating_mode == FSL_USB2_DR_HOST) {
+					otg_set_serial_host();
+					/* need reset */
+					UOG_USBCMD |= UCMD_RESET;
+					msleep(100);
+				} else if (pdata->operating_mode == FSL_USB2_DR_DEVICE)
+					otg_set_serial_peripheral();
+				otg_set_serial_xcvr();
+			} else if (xops->xcvr_type == PORTSC_PTS_ULPI) {
+				otg_set_ulpi_xcvr();
+			} else if (xops->xcvr_type == PORTSC_PTS_UTMI) {
+				otg_set_utmi_xcvr();
+			}
+		} else {
+#ifdef CONFIG_ARCH_MX6
+			if (machine_is_mx6q_arm2())
+				USB_OTG_CTRL &= ~UCTRL_OVER_CUR_POL;
+			else if (machine_is_mx6q_sabrelite())
+				USB_OTG_CTRL |= UCTRL_OVER_CUR_POL;
+			USB_OTG_CTRL |= UCTRL_OVER_CUR_DIS;
+#endif
+		}
+	}
+
+	if (usb_register_remote_wakeup(pdev))
+		pr_debug("DR is not a wakeup source.\n");
+
+	mxc_otg_used++;
+	pr_debug("%s: success\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(usbotg_init);
+
+void usbotg_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	mxc_otg_used--;
+	if (!mxc_otg_used) {
+		if (pdata->xcvr_ops && pdata->xcvr_ops->uninit)
+			pdata->xcvr_ops->uninit(pdata->xcvr_ops);
+
+		pdata->regs = NULL;
+
+		if (machine_is_mx31_3ds()) {
+			if (pdata->xcvr_ops && pdata->xcvr_ops->suspend)
+				pdata->xcvr_ops->suspend(pdata->xcvr_ops);
+			clk_disable(usb_clk);
+		}
+		msleep(1);
+		UOG_PORTSC1 = UOG_PORTSC1 | PORTSC_PHCD;
+		if (pdata->gpio_usb_inactive)
+			pdata->gpio_usb_inactive();
+		if (pdata->xcvr_type == PORTSC_PTS_SERIAL)
+			clk_disable(usb_clk);
+		clk_disable(usb_ahb_clk);
+	}
+}
+EXPORT_SYMBOL(usbotg_uninit);
+
+/*
+ * This function is used to debounce the reading value for id/vbus at
+ * the register of otgsc
+ */
+void usb_debounce_id_vbus(void)
+{
+	msleep(3);
+}
+EXPORT_SYMBOL(usb_debounce_id_vbus);
+
+int usb_event_is_otg_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	return (USBCTRL & UCTRL_OWIR) ? true : false;
+}
+EXPORT_SYMBOL(usb_event_is_otg_wakeup);
+
+#ifdef CONFIG_ARCH_MX6
+/* enable/disable high-speed disconnect detector of phy ctrl */
+void fsl_platform_set_usb_phy_dis(struct fsl_usb2_platform_data *pdata,
+				  bool enable)
+{
+	u32 usb_phy_ctrl_dcdt = 0;
+	/* for HSIC, we do not need to enable disconnect detection */
+	if (pdata->phy_mode == FSL_USB2_PHY_HSIC)
+		return;
+	usb_phy_ctrl_dcdt = __raw_readl(
+			MX6_IO_ADDRESS(pdata->phy_regs) + HW_USBPHY_CTRL) &
+			BM_USBPHY_CTRL_ENHOSTDISCONDETECT;
+	if (enable) {
+		if (usb_phy_ctrl_dcdt == 0)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_SET);
+	} else {
+		if (usb_phy_ctrl_dcdt
+				== BM_USBPHY_CTRL_ENHOSTDISCONDETECT)
+			__raw_writel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,
+				MX6_IO_ADDRESS(pdata->phy_regs)
+				+ HW_USBPHY_CTRL_CLR);
+	}
+}
+EXPORT_SYMBOL(fsl_platform_set_usb_phy_dis);
+#endif
+
+void usb_host_set_wakeup(struct device *wkup_dev, bool para)
+{
+	struct fsl_usb2_platform_data *pdata = wkup_dev->platform_data;
+	if (pdata->wake_up_enable)
+		pdata->wake_up_enable(pdata, para);
+}
+EXPORT_SYMBOL(usb_host_set_wakeup);
diff --git a/arch/arm/plat-mxc/usb_hsic_xcvr.c b/arch/arm/plat-mxc/usb_hsic_xcvr.c
new file mode 100644
index 0000000..fd2dfc3
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_hsic_xcvr.c
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ * For HSIC, there is no usb phy, so the operation at this file is noop
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+static struct fsl_xcvr_ops hsic_xcvr_ops = {
+	.name = "hsic_xcvr",
+	.xcvr_type = PORTSC_HSIC_MODE,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init hsic_xcvr_init(void)
+{
+	fsl_usb_xcvr_register(&hsic_xcvr_ops);
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit hsic_xcvr_exit(void)
+{
+	fsl_usb_xcvr_unregister(&hsic_xcvr_ops);
+}
+
+subsys_initcall(hsic_xcvr_init);
+module_exit(hsic_xcvr_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("nop xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/usb_wakeup.c b/arch/arm/plat-mxc/usb_wakeup.c
new file mode 100644
index 0000000..3c84a25
--- /dev/null
+++ b/arch/arm/plat-mxc/usb_wakeup.c
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/kthread.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fsl_devices.h>
+#include <linux/suspend.h>
+#include <linux/io.h>
+#include <mach/arc_otg.h>
+
+struct wakeup_ctrl {
+	int wakeup_irq;
+	int usb_irq;
+	struct fsl_usb2_wakeup_platform_data *pdata;
+	struct task_struct *thread;
+	struct completion  event;
+};
+static struct wakeup_ctrl *g_ctrl;
+
+extern int usb_event_is_otg_wakeup(struct fsl_usb2_platform_data *pdata);
+extern void usb_debounce_id_vbus(void);
+
+static void wakeup_clk_gate(struct fsl_usb2_wakeup_platform_data *pdata, bool on)
+{
+	if (pdata->usb_clock_for_pm)
+		pdata->usb_clock_for_pm(on);
+}
+
+static bool usb2_is_in_lowpower(struct wakeup_ctrl *ctrl)
+{
+	int i;
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	/* all the usb module related the wakeup is in lowpower mode */
+	for (i = 0; i < 3; i++) {
+		if (pdata->usb_pdata[i]) {
+			if (pdata->usb_pdata[i]->phy_lowpower_suspend && !pdata->usb_pdata[i]->lowpower)
+				return false;
+		}
+	}
+
+	return true;
+}
+
+static void delay_process_wakeup(struct wakeup_ctrl *ctrl)
+{
+	int i;
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	disable_irq_nosync(ctrl->wakeup_irq);
+	if ((ctrl->usb_irq > 0) && (ctrl->wakeup_irq != ctrl->usb_irq))
+		disable_irq_nosync(ctrl->usb_irq);
+
+	for (i = 0; i < 3; i++) {
+		if (pdata->usb_pdata[i]) {
+			pdata->usb_pdata[i]->irq_delay = 1;
+		}
+	}
+
+	pdata->usb_wakeup_is_pending = true;
+	complete(&ctrl->event);
+}
+
+static irqreturn_t usb_wakeup_handler(int irq, void *_dev)
+{
+	struct wakeup_ctrl *ctrl = (struct wakeup_ctrl *)_dev;
+	irqreturn_t ret = IRQ_NONE;
+	if (usb2_is_in_lowpower(ctrl)) {
+		pr_debug("usb wakeup is here\n");
+		delay_process_wakeup(ctrl);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static enum usb_wakeup_event is_wakeup(struct fsl_usb2_platform_data *pdata)
+{
+	if (pdata->is_wakeup_event)
+		return pdata->is_wakeup_event(pdata);
+	else
+		return WAKEUP_EVENT_INVALID;
+}
+
+static void wakeup_event_handler(struct wakeup_ctrl *ctrl)
+{
+	struct fsl_usb2_wakeup_platform_data *pdata = ctrl->pdata;
+	int already_waked = 0;
+	enum usb_wakeup_event wakeup_evt;
+	int i;
+
+	wakeup_clk_gate(ctrl->pdata, true);
+
+	for (i = 0; i < 3; i++) {
+		struct fsl_usb2_platform_data *usb_pdata = pdata->usb_pdata[i];
+		if (usb_pdata) {
+			/* In order to get the real id/vbus value */
+			if (usb_event_is_otg_wakeup(usb_pdata))
+				usb_debounce_id_vbus();
+
+			usb_pdata->irq_delay = 0;
+			wakeup_evt = is_wakeup(usb_pdata);
+			usb_pdata->wakeup_event = wakeup_evt;
+			if (wakeup_evt != WAKEUP_EVENT_INVALID) {
+				if (usb2_is_in_lowpower(ctrl))
+					if (usb_pdata->usb_clock_for_pm)
+						usb_pdata->usb_clock_for_pm(true);
+				usb_pdata->lowpower = 0;
+				already_waked = 1;
+				if (usb_pdata->wakeup_handler) {
+					usb_pdata->wakeup_handler(usb_pdata);
+				}
+			}
+		}
+	}
+
+	/* If nothing to wakeup, clear wakeup event */
+	if ((already_waked == 0) && pdata->usb_wakeup_exhandle)
+		pdata->usb_wakeup_exhandle();
+
+	wakeup_clk_gate(ctrl->pdata, false);
+	pdata->usb_wakeup_is_pending = false;
+	wake_up(&pdata->wq);
+}
+
+static int wakeup_event_thread(void *param)
+{
+	struct wakeup_ctrl *ctrl = (struct wakeup_ctrl *)param;
+	struct sched_param sch_param = {.sched_priority = 1};
+
+	sched_setscheduler(current, SCHED_RR, &sch_param);
+	while (1) {
+		wait_for_completion_interruptible(&ctrl->event);
+		if (kthread_should_stop())
+			break;
+		wakeup_event_handler(ctrl);
+		enable_irq(ctrl->wakeup_irq);
+		if ((ctrl->usb_irq > 0) && (ctrl->wakeup_irq != ctrl->usb_irq))
+			enable_irq(ctrl->usb_irq);
+	}
+	return 0;
+}
+
+static int wakeup_dev_probe(struct platform_device *pdev)
+{
+	struct fsl_usb2_wakeup_platform_data *pdata;
+	struct wakeup_ctrl *ctrl = NULL;
+	int status;
+	unsigned long interrupt_flag;
+
+	printk(KERN_INFO "IMX usb wakeup probe\n");
+
+	if (!pdev || !pdev->dev.platform_data)
+		return -ENODEV;
+	ctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);
+	if (!ctrl)
+		return -ENOMEM;
+	pdata = pdev->dev.platform_data;
+	ctrl->pdata = pdata;
+	init_waitqueue_head(&pdata->wq);
+	pdata->usb_wakeup_is_pending = false;
+
+	init_completion(&ctrl->event);
+	/* Currently, both mx5x and mx6q uses usb controller's irq
+	 * as wakeup irq.
+	 */
+	ctrl->wakeup_irq = platform_get_irq(pdev, 1);
+	ctrl->usb_irq = platform_get_irq(pdev, 1);
+	if (ctrl->wakeup_irq != ctrl->usb_irq)
+		interrupt_flag = IRQF_DISABLED;
+	else
+		interrupt_flag = IRQF_SHARED;
+	status = request_irq(ctrl->wakeup_irq, usb_wakeup_handler, interrupt_flag, "usb_wakeup", (void *)ctrl);
+	if (status)
+		goto error1;
+
+	ctrl->thread = kthread_run(wakeup_event_thread, (void *)ctrl, "usb_wakeup thread");
+	status = IS_ERR(ctrl->thread) ? -1 : 0;
+	if (status)
+		goto error2;
+	g_ctrl = ctrl;
+
+	printk(KERN_DEBUG "the wakeup pdata is 0x%p\n", pdata);
+	return 0;
+error2:
+	free_irq(ctrl->wakeup_irq, (void *)ctrl);
+error1:
+	kfree(ctrl);
+	return status;
+}
+
+static int  wakeup_dev_exit(struct platform_device *pdev)
+{
+	if (g_ctrl->thread) {
+		complete(&g_ctrl->event);
+		kthread_stop(g_ctrl->thread);
+	}
+	free_irq(g_ctrl->wakeup_irq, (void *)g_ctrl);
+	kfree(g_ctrl);
+	return 0;
+}
+static struct platform_driver wakeup_d = {
+	.probe   = wakeup_dev_probe,
+	.remove  = wakeup_dev_exit,
+	.driver = {
+		.name = "usb-wakeup",
+	},
+};
+
+static int __init wakeup_dev_init(void)
+{
+	return platform_driver_register(&wakeup_d);
+}
+static void __exit wakeup_dev_uninit(void)
+{
+	platform_driver_unregister(&wakeup_d);
+}
+
+subsys_initcall(wakeup_dev_init);
+module_exit(wakeup_dev_uninit);
diff --git a/arch/arm/plat-mxc/utmixc.c b/arch/arm/plat-mxc/utmixc.c
new file mode 100644
index 0000000..1768b63
--- /dev/null
+++ b/arch/arm/plat-mxc/utmixc.c
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2005-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <asm/mach-types.h>
+
+static void usb_utmi_init(struct fsl_xcvr_ops *this)
+{
+#if defined(CONFIG_MXC_PMIC_MC13892_MODULE) || defined(CONFIG_MXC_PMIC_MC13892)
+	if (machine_is_mx51_3ds()) {
+		unsigned int value;
+
+		/* VUSBIN */
+		pmic_read_reg(REG_USB1, &value, 0xffffff);
+		value |= 0x1;
+		value |= (0x1 << 3);
+		pmic_write_reg(REG_USB1, value, 0xffffff);
+	}
+#endif
+}
+
+static void usb_utmi_uninit(struct fsl_xcvr_ops *this)
+{
+}
+
+/*!
+ * set vbus power
+ *
+ * @param       view  viewport register
+ * @param       on    power on or off
+ */
+static void set_power(struct fsl_xcvr_ops *this,
+		      struct fsl_usb2_platform_data *pdata, int on)
+{
+	pr_debug("real %s(on=%d) pdata=0x%p\n", __func__, on, pdata);
+	if (pdata && pdata->platform_driver_vbus)
+		pdata->platform_driver_vbus(on);
+}
+
+static struct fsl_xcvr_ops utmi_ops = {
+	.name = "utmi",
+	.xcvr_type = PORTSC_PTS_UTMI,
+	.init = usb_utmi_init,
+	.uninit = usb_utmi_uninit,
+	.set_vbus_power = set_power,
+};
+
+extern void fsl_usb_xcvr_register(struct fsl_xcvr_ops *xcvr_ops);
+
+static int __init utmixc_init(void)
+{
+	fsl_usb_xcvr_register(&utmi_ops);
+	return 0;
+}
+
+extern void fsl_usb_xcvr_unregister(struct fsl_xcvr_ops *xcvr_ops);
+
+static void __exit utmixc_exit(void)
+{
+	fsl_usb_xcvr_unregister(&utmi_ops);
+}
+
+subsys_initcall(utmixc_init);
+module_exit(utmixc_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("utmi xcvr driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 237b71b..6b19624 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -50,16 +50,34 @@ enum fsl_usb2_operating_modes {
 	FSL_USB2_DR_OTG,
 };
 
+/* this used for usb port type */
+enum fsl_usb2_modes {
+	FSL_USB_DR_HOST,
+	FSL_USB_DR_DEVICE,
+	FSL_USB_MPH_HOST1,
+	FSL_USB_MPH_HOST2,
+	FSL_USB_UNKNOWN, /* unkonwn status */
+};
+
 enum fsl_usb2_phy_modes {
 	FSL_USB2_PHY_NONE,
 	FSL_USB2_PHY_ULPI,
 	FSL_USB2_PHY_UTMI,
 	FSL_USB2_PHY_UTMI_WIDE,
 	FSL_USB2_PHY_SERIAL,
+	FSL_USB2_PHY_HSIC,
+};
+
+enum usb_wakeup_event {
+	WAKEUP_EVENT_INVALID,
+	WAKEUP_EVENT_VBUS,
+	WAKEUP_EVENT_ID,
+	WAKEUP_EVENT_DPDM, /* for remote wakeup */
 };
 
 struct clk;
 struct platform_device;
+struct fsl_usb2_wakeup_platform_data;
 
 struct fsl_usb2_platform_data {
 	/* board specific information */
@@ -84,6 +102,50 @@ struct fsl_usb2_platform_data {
 	unsigned	suspended:1;
 	unsigned	already_suspended:1;
 
+	/* Freescale private */
+	char		*name;
+	u32		phy_regs;	/* usb phy register base */
+	u32 		xcvr_type;	/* PORTSC_PTS_* */
+	char 		*transceiver;	/* transceiver name */
+	u32		id_gpio;
+
+	struct fsl_xcvr_ops *xcvr_ops;
+	struct fsl_xcvr_power *xcvr_pwr;
+	int (*gpio_usb_active) (void);
+	void (*gpio_usb_inactive) (void);
+	void (*usb_clock_for_pm) (bool);
+	void (*platform_suspend)(struct fsl_usb2_platform_data *);
+	void (*platform_resume)(struct fsl_usb2_platform_data *);
+	void (*wake_up_enable)(struct fsl_usb2_platform_data *, bool);
+	void (*phy_lowpower_suspend)(struct fsl_usb2_platform_data *, bool);
+	void (*platform_driver_vbus)(bool on); /* for vbus shutdown/open */
+	enum usb_wakeup_event (*is_wakeup_event)(struct fsl_usb2_platform_data *);
+	void (*wakeup_handler)(struct fsl_usb2_platform_data *);
+	void (*hsic_post_ops)(void);
+	void (*hsic_device_connected)(void);
+	/*
+	 * Some platforms, like i.mx6x needs to discharge dp/dm at device mode
+	 * or there is wakeup interrupt caused by dp/dm change when the cable
+	 * is disconnected with Host.
+	 */
+	void (*dr_discharge_line) (bool);
+	/* only set it when vbus lower very slow during OTG switch */
+	bool need_discharge_vbus;
+	void (*platform_rh_suspend)(struct fsl_usb2_platform_data *);
+	void (*platform_rh_resume)(struct fsl_usb2_platform_data *);
+	void (*platform_set_disconnect_det)(struct fsl_usb2_platform_data *, bool);
+	void (*platform_phy_power_on)(void);
+
+	struct fsl_usb2_wakeup_platform_data *wakeup_pdata;
+	struct platform_device *pdev;
+	unsigned	change_ahb_burst:1;
+	unsigned	ahb_burst_mode:3;
+	unsigned	lowpower:1;
+	unsigned	irq_delay:1;
+	enum usb_wakeup_event	wakeup_event;
+	u32		pmflags;	/* PM from otg or system */
+	spinlock_t lock;
+
 	/* register save area for suspend/resume */
 	u32		pm_command;
 	u32		pm_status;
@@ -97,6 +159,22 @@ struct fsl_usb2_platform_data {
 	u32		pm_usbgenctrl;
 };
 
+struct fsl_usb2_wakeup_platform_data {
+	char *name;
+	void (*usb_clock_for_pm) (bool);
+	void (*usb_wakeup_exhandle) (void);
+	struct fsl_usb2_platform_data *usb_pdata[3];
+	/* This waitqueue is used to wait "usb_wakeup thread" to finish
+	 * during system resume routine. "usb_wakeup theard" should be finished
+	 * prior to usb resume routine.
+	 */
+	wait_queue_head_t wq;
+	/* This flag is used to indicate the "usb_wakeup thread" is finished during
+	 * usb wakeup routine.
+	 */
+	bool usb_wakeup_is_pending;
+};
+
 /* Flags in fsl_usb2_mph_platform_data */
 #define FSL_USB2_PORT0_ENABLED	0x00000001
 #define FSL_USB2_PORT1_ENABLED	0x00000002
diff --git a/include/linux/usb/fsl_xcvr.h b/include/linux/usb/fsl_xcvr.h
new file mode 100644
index 0000000..4c57e03
--- /dev/null
+++ b/include/linux/usb/fsl_xcvr.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General
+ * Public License.  You may obtain a copy of the GNU Lesser General
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __LINUX_USB_FSL_XCVR_H
+#define __LINUX_USB_FSL_XCVR_H
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+
+struct fsl_usb2_platform_data;
+
+enum usb_test_mode{
+	USB_TEST_J = 1,
+	USB_TEST_K = 2,
+};
+
+/**
+ * @name: transceiver name
+ * @xcvr_type: one of PORTSC_PTS_{UTMI,SERIAL,ULPI}
+ * @init: transceiver- and board-specific initialization function
+ * @uninit: transceiver- and board-specific uninitialization function
+ * @set_host:
+ * @set_device:
+ * @pullup: enable or disable D+ pullup
+ *
+ */
+struct fsl_xcvr_ops {
+	char *name;
+	u32 xcvr_type;
+
+	void (*init)(struct fsl_xcvr_ops *ops);
+	void (*uninit)(struct fsl_xcvr_ops *ops);
+	void (*suspend)(struct fsl_xcvr_ops *ops);
+	void (*set_host)(void);
+	void (*set_device)(void);
+	void (*set_vbus_power)(struct fsl_xcvr_ops *ops,
+			       struct fsl_usb2_platform_data *pdata, int on);
+	void (*set_vbus_draw)(struct fsl_xcvr_ops *ops,
+			struct fsl_usb2_platform_data *pdata, unsigned mA);
+	void (*set_remote_wakeup)(u32 *view);
+	void (*pullup)(int on);
+	void(*set_test_mode)(u32 *view, enum usb_test_mode mode);
+};
+
+struct fsl_xcvr_power {
+	struct platform_device *usb_pdev;
+	struct regulator *regu1;
+	struct regulator *regu2;
+};
+#endif
-- 
1.7.9.7

