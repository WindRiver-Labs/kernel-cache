From 7d1eff0b2a0c1e9684af4ace65d61f81a97b6d79 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 15 Oct 2012 18:22:43 +0800
Subject: [PATCH 41/62] fsl_imx6: Add egalax touchscreen device support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c |   15 +++++++++++++++
 drivers/input/touchscreen/egalax_ts.c   |   26 ++++++++++++++++++++++----
 include/linux/fsl_devices.h             |    4 ++++
 3 files changed, 41 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 0ac0261..8b06f76 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -71,6 +71,7 @@
 #define MX6Q_SABRELITE_USB_OTG_PWR	IMX_GPIO_NR(3, 22)
 #define MX6Q_SABRELITE_USB_HUB_RESET	IMX_GPIO_NR(7, 12)
 #define MX6Q_SABRELITE_ECSPI1_CS1	IMX_GPIO_NR(3, 19)
+#define MX6Q_SABRELITE_CAP_TCH_INT1	IMX_GPIO_NR(1, 9)
 
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
@@ -311,6 +312,17 @@ static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
 	},
 };
 
+static struct egalax_ts_data i2c_egalax_ts_data = {
+		.irq_gpio = MX6Q_SABRELITE_CAP_TCH_INT1,
+};
+
+static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("egalax_ts", 0x4),
+		.platform_data = (void *)&i2c_egalax_ts_data,
+	},
+};
+
 static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
 	.reserved_mem_size = SZ_128M,
 };
@@ -702,11 +714,14 @@ static void __init mx6_sabrelite_board_init(void)
 
 	imx6q_add_imx_snvs_rtc();
 
+	mxc_i2c2_board_info[0].irq = gpio_to_irq(MX6Q_SABRELITE_CAP_TCH_INT1),
 	imx6q_add_imx_i2c(0, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabrelite_i2c_data);
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 			ARRAY_SIZE(mxc_i2c1_board_info));
+	i2c_register_board_info(2, mxc_i2c2_board_info,
+			ARRAY_SIZE(mxc_i2c2_board_info));
 
 	/* SPI */
 	imx6q_add_ecspi(0, &mx6q_sabrelite_spi_data);
diff --git a/drivers/input/touchscreen/egalax_ts.c b/drivers/input/touchscreen/egalax_ts.c
index 70524dd..3d55648 100644
--- a/drivers/input/touchscreen/egalax_ts.c
+++ b/drivers/input/touchscreen/egalax_ts.c
@@ -28,6 +28,7 @@
 #include <linux/slab.h>
 #include <linux/bitops.h>
 #include <linux/input/mt.h>
+#include <linux/fsl_devices.h>
 
 /*
  * Mouse Mode: some panel may configure the controller to mouse mode,
@@ -62,6 +63,7 @@
 struct egalax_ts {
 	struct i2c_client		*client;
 	struct input_dev		*input_dev;
+	unsigned int			irq_gpio;
 };
 
 static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
@@ -120,9 +122,8 @@ static irqreturn_t egalax_ts_interrupt(int irq, void *dev_id)
 }
 
 /* wake up controller by an falling edge of interrupt gpio.  */
-static int egalax_wake_up_device(struct i2c_client *client)
+static int egalax_wake_up_device(struct i2c_client *client, unsigned int gpio)
 {
-	int gpio = irq_to_gpio(client->irq);
 	int ret;
 
 	ret = gpio_request(gpio, "egalax_irq");
@@ -134,6 +135,7 @@ static int egalax_wake_up_device(struct i2c_client *client)
 	}
 
 	/* wake up controller via an falling edge on IRQ gpio. */
+	gpio_direction_output(gpio, 1);
 	gpio_direction_output(gpio, 0);
 	gpio_set_value(gpio, 1);
 
@@ -161,6 +163,7 @@ static int __devinit egalax_ts_probe(struct i2c_client *client,
 {
 	struct egalax_ts *ts;
 	struct input_dev *input_dev;
+	struct egalax_ts_data *egalax_platform = client->dev.platform_data;
 	int ret;
 	int error;
 
@@ -180,9 +183,23 @@ static int __devinit egalax_ts_probe(struct i2c_client *client,
 	ts->client = client;
 	ts->input_dev = input_dev;
 
+	if(egalax_platform) {
+		ts->irq_gpio = egalax_platform->irq_gpio;
+		client->irq = gpio_to_irq(ts->irq_gpio);
+	}
+
 	/* controller may be in sleep, wake it up. */
-	egalax_wake_up_device(client);
+	ret = egalax_wake_up_device(client, ts->irq_gpio);
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to wake up the controller\n");
+		error = ret;
+		goto err_free_dev;
+	}
 
+	msleep(10);
+	/* the controller needs some time to wakeup, otherwise the
+	 * following firmware version read will be failed.
+	 */
 	ret = egalax_firmware_version(client);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to read firmware version\n");
@@ -267,8 +284,9 @@ static int egalax_ts_suspend(struct device *dev)
 static int egalax_ts_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
+	struct egalax_ts *ts = i2c_get_clientdata(client);
 
-	return egalax_wake_up_device(client);
+	return egalax_wake_up_device(client, ts->irq_gpio);
 }
 #endif
 
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 8c6d478..74c8386 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -267,6 +267,10 @@ struct mpc8xx_pcmcia_ops {
 	int(*voltage_set)(int slot, int vcc, int vpp);
 };
 
+struct egalax_ts_data {
+	unsigned int irq_gpio;
+};
+
 /* Returns non-zero if the current suspend operation would
  * lead to a deep sleep (i.e. power removed from the core,
  * instead of just the clock).
-- 
1.7.9.7

