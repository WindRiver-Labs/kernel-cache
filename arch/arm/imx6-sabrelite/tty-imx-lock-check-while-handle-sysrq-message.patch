From a2fbb6ca68d3144e3ca210890a8b53c988bdf50b Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Sat, 1 Dec 2012 17:45:44 +0800
Subject: [PATCH] tty/imx: lock check while handle sysrq message

Since the port->lock has already been hold when enter rx_interrupt,
and thus hold it on during handle_sysrq. We need check whether the
current console_write is for the sysrq message output or not and use
the correct lock mechanism.

Source: Extracted from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo<hongbo.zhong@windriver.com>

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 525ce24..b4e76fe 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -470,8 +470,13 @@ static irqreturn_t imx_rtsint(int irq, void *dev_id)
 	struct imx_port *sport = dev_id;
 	unsigned int val;
 	unsigned long flags;
+	int locked = 1;
 
-	spin_lock_irqsave(&sport->port.lock, flags);
+	local_irq_save(flags);
+	if (sport->port.sysrq)
+		locked = 0;
+	else
+		spin_lock(&sport->port.lock);
 
 	writel(USR1_RTSD, sport->port.membase + USR1);
 	val = readl(sport->port.membase + USR1) & USR1_RTSS;
@@ -533,10 +538,8 @@ static irqreturn_t imx_rxint(int irq, void *dev_id)
 				continue;
 		}
 
-		spin_unlock_irqrestore(&sport->port.lock, flags);
 		if (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))
 			continue;
-		spin_lock_irqsave(&sport->port.lock, flags);
 
 		if (unlikely(rx & URXD_ERR)) {
 			if (rx & URXD_BRK)
@@ -1037,7 +1040,9 @@ imx_set_termios(struct uart_port *port, struct ktermios *termios,
 	if (UART_ENABLE_MS(&sport->port, termios->c_cflag))
 		imx_enable_ms(&sport->port);
 
-	spin_unlock_irqrestore(&sport->port.lock, flags);
+	if (locked)
+		spin_unlock(&sport->port.lock);
+	local_irq_restore(flags);
 }
 
 static const char *imx_type(struct uart_port *port)
-- 
1.8.3.1

