From 3bf0e3d5643f68a5308e8a28449c5395e271a65a Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Sat, 1 Dec 2012 17:45:44 +0800
Subject: [PATCH 58/62] tty/imx: lock check while handle sysrq message

Since the port->lock has already been hold when enter rx_interrupt,
and thus hold it on during handle_sysrq. We need check whether the
current console_write is for the sysrq message output or not and use
the correct lock mechanism.

Source: Extracted from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo<hongbo.zhong@windriver.com>
---
 drivers/tty/serial/imx.c |   13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index dae1087..9b4773a 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -533,10 +533,8 @@ static irqreturn_t imx_rxint(int irq, void *dev_id)
 				continue;
 		}
 
-		spin_unlock_irqrestore(&sport->port.lock, flags);
 		if (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))
 			continue;
-		spin_lock_irqsave(&sport->port.lock, flags);
 
 		if (unlikely(rx & URXD_ERR)) {
 			if (rx & URXD_BRK)
@@ -1227,8 +1225,13 @@ imx_console_write(struct console *co, const char *s, unsigned int count)
 	struct imx_port_ucrs old_ucr;
 	unsigned int ucr1;
 	unsigned long flags;
+	int locked = 1;
 
-	spin_lock_irqsave(&sport->port.lock, flags);
+	local_irq_save(flags);
+	if (sport->port.sysrq)
+		locked = 0;
+	else
+		spin_lock(&sport->port.lock);
 
 	/*
 	 *	First, save UCR1/2/3 and then disable interrupts
@@ -1255,7 +1258,9 @@ imx_console_write(struct console *co, const char *s, unsigned int count)
 
 	imx_port_ucrs_restore(&sport->port, &old_ucr);
 
-	spin_unlock_irqrestore(&sport->port.lock, flags);
+	if (locked)
+		spin_unlock(&sport->port.lock);
+	local_irq_restore(flags);
 }
 
 /*
-- 
1.7.9.7

