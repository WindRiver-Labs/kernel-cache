From 8510e4d879ee739867726ca4f0b3baa58d77bf2c Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 11:25:30 +0800
Subject: [PATCH 14/62] Add platform device register for anatop regulator

The anatop driver in kernel adopt anatop mfd driver and anatop
regulator driver to implement regulation function. And this drivers
use the OF driver. Add platform device register method.

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Makefile                 |    2 +-
 arch/arm/mach-mx6/cpu_regulator-mx6.c      |   97 +++++++++++
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c    |    9 +
 arch/arm/mach-mx6/mx6_anatop_regulator.c   |  259 ++++++++++++++++++++++++++++
 drivers/mfd/anatop-mfd.c                   |   28 ++-
 drivers/regulator/anatop-regulator.c       |   32 ++--
 include/linux/regulator/anatop-regulator.h |   53 ++++++
 7 files changed, 462 insertions(+), 18 deletions(-)
 create mode 100644 arch/arm/mach-mx6/cpu_regulator-mx6.c
 create mode 100644 arch/arm/mach-mx6/mx6_anatop_regulator.c
 create mode 100644 include/linux/regulator/anatop-regulator.h

diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 0fac1af..0595557 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -4,7 +4,7 @@
 
 # Object file lists.
 obj-y   := cpu.o mm.o system.o irq.o bus_freq.o cpu_op-mx6.o mx6_wfi.o mx6_mmdc.o \
-		mx6_ddr_freq.o
+		mx6_ddr_freq.o mx6_anatop_regulator.o cpu_regulator-mx6.o
 
 obj-$(CONFIG_ARCH_MX6) += clock.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += mach-mx6q_sabrelite.o
diff --git a/arch/arm/mach-mx6/cpu_regulator-mx6.c b/arch/arm/mach-mx6/cpu_regulator-mx6.c
new file mode 100644
index 0000000..46d9652
--- /dev/null
+++ b/arch/arm/mach-mx6/cpu_regulator-mx6.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/jiffies.h>
+#include <linux/regulator/consumer.h>
+#include <linux/clk.h>
+#if defined(CONFIG_CPU_FREQ)
+#include <linux/cpufreq.h>
+#endif
+#include <asm/cpu.h>
+
+#include <mach/clock.h>
+#include <mach/hardware.h>
+
+struct regulator *cpu_regulator;
+char *gp_reg_id;
+static struct clk *cpu_clk;
+static int cpu_op_nr;
+static struct cpu_op *cpu_op_tbl;
+extern struct cpu_op *(*get_cpu_op)(int *op);
+
+extern unsigned long loops_per_jiffy;
+
+static inline unsigned long mx6_cpu_jiffies(unsigned long old, u_int div,
+					      u_int mult)
+{
+#if BITS_PER_LONG == 32
+	u64 result = ((u64) old) * ((u64) mult);
+	do_div(result, div);
+	return (unsigned long) result;
+#elif BITS_PER_LONG == 64
+	unsigned long result = old * ((u64) mult);
+	result /= div;
+	return result;
+#endif
+}
+
+
+void mx6_cpu_regulator_init(void)
+{
+	int cpu;
+	u32 curr_cpu = 0;
+
+	cpu_regulator = regulator_get(NULL, gp_reg_id);
+	if (IS_ERR(cpu_regulator))
+		printk(KERN_ERR "%s: failed to get cpu regulator\n", __func__);
+	else {
+		cpu_clk = clk_get(NULL, "cpu_clk");
+		if (IS_ERR(cpu_clk)) {
+			printk(KERN_ERR "%s: failed to get cpu clock\n",
+			       __func__);
+		} else {
+			curr_cpu = clk_get_rate(cpu_clk);
+			cpu_op_tbl = get_cpu_op(&cpu_op_nr);
+			/* Set the core to max frequency requested. */
+			regulator_set_voltage(cpu_regulator,
+					      cpu_op_tbl[0].cpu_voltage,
+					      cpu_op_tbl[0].cpu_voltage);
+			clk_set_rate(cpu_clk, cpu_op_tbl[0].cpu_rate);
+
+			/*Fix loops-per-jiffy */
+#ifdef CONFIG_SMP
+			for_each_online_cpu(cpu)
+				per_cpu(cpu_data, cpu).loops_per_jiffy =
+				mx6_cpu_jiffies(
+					per_cpu(cpu_data, cpu).loops_per_jiffy,
+					curr_cpu / 1000,
+					clk_get_rate(cpu_clk) / 1000);
+#else
+			u32 old_loops_per_jiffy = loops_per_jiffy;
+
+			loops_per_jiffy =
+				mx6_cpu_jiffies(old_loops_per_jiffy,
+						curr_cpu/1000,
+						clk_get_rate(cpu_clk) / 1000);
+#endif
+#if defined(CONFIG_CPU_FREQ)
+			/* Fix CPU frequency for CPUFREQ. */
+			for (cpu = 0; cpu < num_online_cpus(); cpu++)
+				cpufreq_get(cpu);
+#endif
+		}
+	}
+}
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 5353718..5b716b7 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -29,6 +29,10 @@
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
 #include <linux/regulator/consumer.h>
+#include <linux/regulator/anatop-regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
 #include <linux/pwm_backlight.h>
 #include <linux/fec.h>
 #include <linux/phy.h>
@@ -56,6 +60,10 @@
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+extern struct regulator *(*get_cpu_regulator)(void);
+extern void (*put_cpu_regulator)(void);
+extern void mx6_cpu_regulator_init(void);
+
 static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	/* AUDMUX */
 	MX6Q_PAD_SD2_DAT0__AUDMUX_AUD4_RXD,
@@ -337,6 +345,7 @@ static void __init mx6_sabrelite_board_init(void)
 
 	mx6q_sabrelite_init_uart();
 	imx6q_add_fec(&fec_data);
+	mx6_cpu_regulator_init();
 
 }
 
diff --git a/arch/arm/mach-mx6/mx6_anatop_regulator.c b/arch/arm/mach-mx6/mx6_anatop_regulator.c
new file mode 100644
index 0000000..1f1f140
--- /dev/null
+++ b/arch/arm/mach-mx6/mx6_anatop_regulator.c
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*
+ * mx6_anatop_regulator.c  --  i.MX6 Driver for Anatop regulators
+ */
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/anatop-regulator.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regulator/machine.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#include "crm_regs.h"
+#include "regs-anadig.h"
+
+static struct anatop_regulator vddpu_reg = {
+	.name		= "vddpu",
+	.control_reg	= (u32)(HW_ANADIG_REG_CORE),
+	.vol_bit_shift	= 9,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 1,
+	.min_voltage	= 725000,
+	.max_voltage	= 1300000,
+};
+
+static struct anatop_regulator vddcore_reg = {
+	.name		= "vddcore",
+	.control_reg	= (u32)(HW_ANADIG_REG_CORE),
+	.vol_bit_shift	= 0,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 1,
+	.min_voltage	= 725000,
+	.max_voltage	= 1300000,
+};
+
+static struct anatop_regulator vddsoc_reg = {
+	.name		= "vddsoc",
+	.control_reg	= (u32)(HW_ANADIG_REG_CORE),
+	.vol_bit_shift	= 18,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 1,
+	.min_voltage	= 725000,
+	.max_voltage	= 1300000,
+};
+
+static struct anatop_regulator vdd2p5_reg = {
+	.name		= "vdd2p5",
+	.control_reg	= (u32)(HW_ANADIG_REG_2P5),
+	.vol_bit_shift	= 8,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 0,
+	.min_voltage	= 2000000,
+	.max_voltage	= 2775000,
+};
+
+static struct anatop_regulator vdd1p1_reg = {
+	.name		= "vdd1p1",
+	.control_reg	= (u32)(HW_ANADIG_REG_1P1),
+	.vol_bit_shift	= 8,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 4,
+	.min_voltage	= 800000,
+	.max_voltage	= 1400000,
+};
+
+static struct anatop_regulator vdd3p0_reg = {
+	.name		= "vdd3p0",
+	.control_reg	= (u32)(HW_ANADIG_REG_3P0),
+	.vol_bit_shift	= 8,
+	.vol_bit_width	= 5,
+	.min_bit_val	= 7,
+	.min_voltage	= 2800000,
+	.max_voltage	= 3150000,
+};
+
+/* CPU */
+static struct regulator_consumer_supply vddcore_consumers[] = {
+	{
+		.supply = "cpu_vddgp",
+	}
+};
+
+static struct regulator_init_data vddpu_init = {
+	.constraints = {
+		.name			= "vddpu",
+		.min_uV			= 725000,
+		.max_uV			= 1300000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = 0,
+	.consumer_supplies = NULL,
+};
+
+static struct regulator_init_data vddcore_init = {
+	.constraints = {
+		.name			= "vddcore",
+		.min_uV			= 725000,
+		.max_uV			= 1300000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vddcore_consumers),
+	.consumer_supplies = vddcore_consumers,
+};
+
+static struct regulator_init_data vddsoc_init = {
+	.constraints = {
+		.name			= "vddsoc",
+		.min_uV			= 725000,
+		.max_uV			= 1300000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = 0,
+	.consumer_supplies = NULL,
+};
+
+static struct regulator_init_data vdd2p5_init = {
+	.constraints = {
+		.name			= "vdd2p5",
+		.min_uV			= 2000000,
+		.max_uV			= 2775000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = 0,
+	.consumer_supplies = NULL,
+};
+
+
+static struct regulator_init_data vdd1p1_init = {
+	.constraints = {
+		.name			= "vdd1p1",
+		.min_uV			= 800000,
+		.max_uV			= 1400000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.input_uV		= 5000000,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = 0,
+	.consumer_supplies = NULL,
+};
+
+
+static struct regulator_init_data vdd3p0_init = {
+	.constraints = {
+		.name			= "vdd3p0",
+		.min_uV			= 2800000,
+		.max_uV			= 3150000,
+		.valid_modes_mask	= REGULATOR_MODE_FAST |
+					  REGULATOR_MODE_NORMAL,
+		.valid_ops_mask		= REGULATOR_CHANGE_VOLTAGE |
+					  REGULATOR_CHANGE_MODE,
+		.always_on		= 1,
+	},
+	.num_consumer_supplies = 0,
+	.consumer_supplies = NULL,
+};
+
+struct platform_device *anatom_mfd_device;
+
+int anatop_register_regulator(
+		struct anatop_regulator *reg_data, int reg,
+			      struct regulator_init_data *initdata)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	pdev = platform_device_alloc("anatop_regulator", reg);
+	if (!pdev)
+		return -ENOMEM;
+
+	pdev->dev.platform_data = initdata;
+
+	platform_set_drvdata(pdev, reg_data);
+
+	if(anatom_mfd_device)
+		pdev->dev.parent = &anatom_mfd_device->dev;
+
+	ret = platform_device_add(pdev);
+	if (ret != 0) {
+		pr_debug("Failed to register regulator %d: %d\n",
+			reg, ret);
+		platform_device_del(pdev);
+	}
+	pr_debug("register regulator %s, %d: %d\n",
+			reg_data->name, reg, ret);
+
+	return ret;
+}
+
+struct platform_device *__init imx_add_anatop_mfd(void)
+{
+	struct resource res[] = {
+		{
+			.start	= ANATOP_BASE_ADDR,
+			.end	= ANATOP_BASE_ADDR + SZ_4K - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device("anatop-mfd", -1,
+			res, ARRAY_SIZE(res), NULL, 0);
+}
+
+static int __init regulators_init(void)
+{
+	anatom_mfd_device = imx_add_anatop_mfd();
+	if(!anatom_mfd_device)
+		printk("imx_add_anatop_mfd is fail\n");
+	anatop_register_regulator(&vddpu_reg, ANATOP_VDDPU, &vddpu_init);
+	anatop_register_regulator(&vddcore_reg, ANATOP_VDDCORE, &vddcore_init);
+	anatop_register_regulator(&vddsoc_reg, ANATOP_VDDSOC, &vddsoc_init);
+	anatop_register_regulator(&vdd2p5_reg, ANATOP_VDD2P5, &vdd2p5_init);
+	anatop_register_regulator(&vdd1p1_reg, ANATOP_VDD1P1, &vdd1p1_init);
+	anatop_register_regulator(&vdd3p0_reg, ANATOP_VDD3P0, &vdd3p0_init);
+
+	return 0;
+}
+postcore_initcall(regulators_init);
diff --git a/drivers/mfd/anatop-mfd.c b/drivers/mfd/anatop-mfd.c
index 2af4248..5ffbfdd 100644
--- a/drivers/mfd/anatop-mfd.c
+++ b/drivers/mfd/anatop-mfd.c
@@ -86,17 +86,39 @@ static int __devinit of_anatop_probe(struct platform_device *pdev)
 	struct device_node *np = dev->of_node;
 	void *ioreg;
 	struct anatop *drvdata;
+	struct resource *res;
 
 	ioreg = of_iomap(np, 0);
-	if (!ioreg)
-		return -EADDRNOTAVAIL;
+	if (!ioreg) {
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_dbg(&pdev->dev, "failed to determine base address\n");
+			return -ENODEV;
+		}
+
+		res = request_mem_region(res->start, resource_size(res), pdev->name);
+		if (!res) {
+			dev_err(&pdev->dev, "cannot request memory region\n");
+			return -EBUSY;
+		}
+
+		ioreg = ioremap(res->start, resource_size(res));
+		if (!ioreg) {
+			dev_err(&pdev->dev, "failed to map memory\n");
+			return -ENODEV;
+		}
+	}
+
 	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
 	if (!drvdata)
 		return -ENOMEM;
 	drvdata->ioreg = ioreg;
 	spin_lock_init(&drvdata->reglock);
 	platform_set_drvdata(pdev, drvdata);
+
+#ifdef CONFIG_OF
 	of_platform_populate(np, of_anatop_match, NULL, dev);
+#endif
 
 	return 0;
 }
@@ -124,7 +146,7 @@ static int __init anatop_init(void)
 {
 	return platform_driver_register(&anatop_of_driver);
 }
-postcore_initcall(anatop_init);
+core_initcall(anatop_init);
 
 static void __exit anatop_exit(void)
 {
diff --git a/drivers/regulator/anatop-regulator.c b/drivers/regulator/anatop-regulator.c
index 81fd606..9c2f314 100644
--- a/drivers/regulator/anatop-regulator.c
+++ b/drivers/regulator/anatop-regulator.c
@@ -29,19 +29,9 @@
 #include <linux/mfd/anatop.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/of_regulator.h>
-
-struct anatop_regulator {
-	const char *name;
-	u32 control_reg;
-	struct anatop *mfd;
-	int vol_bit_shift;
-	int vol_bit_width;
-	int min_bit_val;
-	int min_voltage;
-	int max_voltage;
-	struct regulator_desc rdesc;
-	struct regulator_init_data *initdata;
-};
+#include <linux/regulator/anatop-regulator.h>
+#include <mach/hardware.h>
+#include <mach/mx6q.h>
 
 static int anatop_set_voltage(struct regulator_dev *reg, int min_uV,
 				  int max_uV, unsigned *selector)
@@ -71,6 +61,7 @@ static int anatop_set_voltage(struct regulator_dev *reg, int min_uV,
 	val = anatop_reg->min_bit_val + sel;
 	*selector = sel;
 	dev_dbg(&reg->dev, "%s: calculated val %d\n", __func__, val);
+
 	anatop_set_bits(anatop_reg->mfd,
 			anatop_reg->control_reg,
 			anatop_reg->vol_bit_shift,
@@ -125,12 +116,22 @@ static int __devinit anatop_regulator_probe(struct platform_device *pdev)
 	int ret = 0;
 
 	initdata = of_get_regulator_init_data(dev, np);
+	if(!initdata)
+		initdata = pdev->dev.platform_data;
+
+#ifdef CONFIG_OF
 	sreg = devm_kzalloc(dev, sizeof(*sreg), GFP_KERNEL);
 	if (!sreg)
 		return -ENOMEM;
-	sreg->initdata = initdata;
+
 	sreg->name = kstrdup(of_get_property(np, "regulator-name", NULL),
 			     GFP_KERNEL);
+#else
+	sreg = platform_get_drvdata(pdev);
+#endif
+
+	sreg->initdata = initdata;
+
 	rdesc = &sreg->rdesc;
 	memset(rdesc, 0, sizeof(*rdesc));
 	rdesc->name = sreg->name;
@@ -138,6 +139,8 @@ static int __devinit anatop_regulator_probe(struct platform_device *pdev)
 	rdesc->type = REGULATOR_VOLTAGE;
 	rdesc->owner = THIS_MODULE;
 	sreg->mfd = anatopmfd;
+
+#ifdef CONFIG_OF
 	ret = of_property_read_u32(np, "anatop-reg-offset",
 				   &sreg->control_reg);
 	if (ret) {
@@ -174,6 +177,7 @@ static int __devinit anatop_regulator_probe(struct platform_device *pdev)
 		dev_err(dev, "no anatop-max-voltage property set\n");
 		goto anatop_probe_end;
 	}
+#endif
 
 	rdesc->n_voltages = (sreg->max_voltage - sreg->min_voltage)
 		/ 25000 + 1;
diff --git a/include/linux/regulator/anatop-regulator.h b/include/linux/regulator/anatop-regulator.h
new file mode 100644
index 0000000..c761cc6
--- /dev/null
+++ b/include/linux/regulator/anatop-regulator.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __ANATOP_REGULATOR_H
+#define __ANATOP_REGULATOR_H
+#include <linux/regulator/driver.h>
+
+/* regulator supplies for Anatop */
+enum anatop_regulator_supplies {
+	ANATOP_VDDPU,
+	ANATOP_VDDCORE,
+	ANATOP_VDDSOC,
+	ANATOP_VDD2P5,
+	ANATOP_VDD1P1,
+	ANATOP_VDD3P0,
+	ANATOP_SUPPLY_NUM
+};
+
+struct anatop_regulator {
+	const char name[80];
+	u32 control_reg;
+	struct anatop *mfd;
+	int vol_bit_shift;
+	int vol_bit_width;
+	int min_bit_val;
+	int min_voltage;
+	int max_voltage;
+	struct regulator_desc rdesc;
+	struct regulator_init_data *initdata;
+};
+
+int anatop_register_regulator(
+		struct anatop_regulator *reg_data, int reg,
+		      struct regulator_init_data *initdata);
+
+#endif /* __ANATOP_REGULATOR_H */
-- 
1.7.9.7

