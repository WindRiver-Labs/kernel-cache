From ca5c6df25af7c05757a562c8ca58a5834939dd9d Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 12:53:11 +0800
Subject: [PATCH 37/62] fsl_imx6: Add pwm device support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                    |    1 +
 arch/arm/mach-mx6/devices-imx6q.h            |    4 ++++
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c      |    5 +++++
 arch/arm/plat-mxc/devices/platform-mxc_pwm.c |   11 +++++++++++
 arch/arm/plat-mxc/pwm.c                      |   11 +++++++++--
 5 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index e4205cc..08aeabe 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -34,6 +34,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_SPI_IMX
 	select IMX_HAVE_PLATFORM_IMX_OCOTP
 	select IMX_HAVE_PLATFORM_IMX_ANATOP_THERMAL
+	select IMX_HAVE_PLATFORM_MXC_PWM
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index 8e11e60..48e30ea 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -111,4 +111,8 @@ extern const struct imx_anatop_thermal_imx_data
 imx6q_anatop_thermal_imx_data __initconst;
 #define imx6q_add_anatop_thermal_imx(id, pdata)	\
 	imx_add_anatop_thermal_imx(&imx6q_anatop_thermal_imx_data, pdata)
+
+extern const struct imx_mxc_pwm_data imx6q_mxc_pwm_data[] __initconst;
+#define imx6q_add_mxc_pwm(id)	\
+	imx_add_mxc_pwm(&imx6q_mxc_pwm_data[id])
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 059417c..ca2f801 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -701,6 +701,11 @@ static void __init mx6_sabrelite_board_init(void)
 	/* release USB Hub reset */
 	gpio_set_value(MX6Q_SABRELITE_USB_HUB_RESET, 1);
 
+	imx6q_add_mxc_pwm(0);
+	imx6q_add_mxc_pwm(1);
+	imx6q_add_mxc_pwm(2);
+	imx6q_add_mxc_pwm(3);
+
 	clko2 = clk_get(NULL, "clko2_clk");
 	if (IS_ERR(clko2))
 		pr_err("can't get CLKO2 clock.\n");
diff --git a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
index b0c4ae2..dffa1b7 100644
--- a/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
+++ b/arch/arm/plat-mxc/devices/platform-mxc_pwm.c
@@ -49,6 +49,17 @@ const struct imx_mxc_pwm_data imx51_mxc_pwm_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX51 */
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_mxc_pwm_data imx6q_mxc_pwm_data[] __initconst = {
+#define imx6q_mxc_pwm_data_entry(_id, _hwid)				\
+	imx_mxc_pwm_data_entry(MX6Q, _id, _hwid, SZ_16K)
+	imx6q_mxc_pwm_data_entry(0, 1),
+	imx6q_mxc_pwm_data_entry(1, 2),
+	imx6q_mxc_pwm_data_entry(2, 3),
+	imx6q_mxc_pwm_data_entry(3, 4),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
 struct platform_device *__init imx_add_mxc_pwm(
 		const struct imx_mxc_pwm_data *data)
 {
diff --git a/arch/arm/plat-mxc/pwm.c b/arch/arm/plat-mxc/pwm.c
index c0cab22..f6689ff 100644
--- a/arch/arm/plat-mxc/pwm.c
+++ b/arch/arm/plat-mxc/pwm.c
@@ -37,6 +37,7 @@
 #define MX3_PWMCR_DBGEN			(1 << 22)
 #define MX3_PWMCR_CLKSRC_IPG_HIGH (2 << 16)
 #define MX3_PWMCR_CLKSRC_IPG      (1 << 16)
+#define MX3_PWMCR_SWR             (1 << 3)
 #define MX3_PWMCR_EN              (1 << 0)
 
 
@@ -73,7 +74,11 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 		prescale = period_cycles / 0x10000 + 1;
 
 		period_cycles /= prescale;
-		c = (unsigned long long)period_cycles * duty_ns;
+		/* the chip document says the counter counts up to
+		 * period_cycles + 1 and then is reset to 0, so the
+		 *  actual period of the PWM wave is period_cycles + 2
+		 */
+		c = (unsigned long long)(period_cycles + 2) * duty_ns;
 		do_div(c, period_ns);
 		duty_cycles = c;
 
@@ -142,7 +147,9 @@ EXPORT_SYMBOL(pwm_enable);
 
 void pwm_disable(struct pwm_device *pwm)
 {
-	writel(0, pwm->mmio_base + MX3_PWMCR);
+	writel(MX3_PWMCR_SWR, pwm->mmio_base + MX3_PWMCR);
+	while (readl(pwm->mmio_base + MX3_PWMCR) & MX3_PWMCR_SWR)
+		;
 
 	if (pwm->clk_enabled) {
 		clk_disable_unprepare(pwm->clk);
-- 
1.7.9.7

