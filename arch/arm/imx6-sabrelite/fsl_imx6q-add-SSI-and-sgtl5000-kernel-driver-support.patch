From 1ce7b5b16c87bd326a0cd280cb15bbb561fc82d4 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 13:55:50 +0800
Subject: [PATCH 50/62] fsl_imx6q: add SSI and sgtl5000 kernel driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                    |    1 +
 arch/arm/mach-mx6/devices-imx6q.h            |    4 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c      |  161 +++++++++++
 arch/arm/plat-mxc/devices.c                  |   14 +
 arch/arm/plat-mxc/devices/platform-imx-ssi.c |   10 +
 arch/arm/plat-mxc/include/mach/common.h      |    1 +
 include/linux/fsl_devices.h                  |   36 +++
 sound/soc/imx/Kconfig                        |   12 +
 sound/soc/imx/Makefile                       |    2 +
 sound/soc/imx/imx-sgtl5000.c                 |  394 ++++++++++++++++++++++++++
 10 files changed, 635 insertions(+)
 create mode 100644 sound/soc/imx/imx-sgtl5000.c

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index e8c37e2..ba3d964 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -42,6 +42,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_DVFS
 	select IMX_HAVE_PLATFORM_IMX_PM
 	select IMX_HAVE_PLATFORM_FLEXCAN
+	select IMX_HAVE_PLATFORM_IMX_SSI
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index 5f91102..59d6521 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -154,4 +154,8 @@ extern const struct imx_flexcan_data imx6q_flexcan_data[] __initconst;
 	imx_add_flexcan(&imx6q_flexcan_data[id], pdata)
 #define imx6q_add_flexcan0(pdata)	imx6q_add_flexcan(0, pdata)
 #define imx6q_add_flexcan1(pdata)	imx6q_add_flexcan(1, pdata)
+
+extern const struct imx_imx_ssi_data imx6_imx_ssi_data[];
+#define imx6q_add_imx_ssi(id, pdata)	\
+	imx_add_imx_ssi(&imx6_imx_ssi_data[id], pdata)
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index e56a749..242ca4b 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -621,6 +621,163 @@ static struct platform_pwm_backlight_data mx6_sabrelite_pwm_backlight_data = {
 	.check_fb = check_fb,
 };
 
+#ifdef CONFIG_SND_SOC_SGTL5000
+static struct regulator_consumer_supply sgtl5000_sabrelite_consumer_vdda[] = {
+	REGULATOR_SUPPLY("VDDA", "0-000a"),  /* sgtl5000 */
+};
+
+static struct regulator_consumer_supply sgtl5000_sabrelite_consumer_vddio[] = {
+	REGULATOR_SUPPLY("VDDIO", "0-000a"),  /* sgtl5000 */
+};
+
+static struct regulator_consumer_supply sgtl5000_sabrelite_consumer_vddd[] = {
+	REGULATOR_SUPPLY("VDDD", "0-000a"),  /* sgtl5000 */
+};
+
+static struct regulator_init_data sgtl5000_sabrelite_vdda_reg_initdata = {
+	.constraints = {
+		.name = "VDDA",
+		.min_uV = 2500000,
+		.max_uV = 2500000,
+		.apply_uV = 0,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sgtl5000_sabrelite_consumer_vdda),
+	.consumer_supplies = sgtl5000_sabrelite_consumer_vdda,
+};
+
+static struct regulator_init_data sgtl5000_sabrelite_vddio_reg_initdata = {
+	.constraints = {
+		.name = "VDDIO",
+		.min_uV = 3300000,
+		.max_uV = 3300000,
+		.apply_uV = 0,
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sgtl5000_sabrelite_consumer_vddio),
+	.consumer_supplies = sgtl5000_sabrelite_consumer_vddio,
+};
+
+static struct regulator_init_data sgtl5000_sabrelite_vddd_reg_initdata = {
+	.constraints = {
+		.always_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sgtl5000_sabrelite_consumer_vddd),
+	.consumer_supplies = sgtl5000_sabrelite_consumer_vddd,
+};
+
+static struct fixed_voltage_config sgtl5000_sabrelite_vdda_reg_config = {
+	.supply_name		= "VDDA",
+	.microvolts		= 2500000,
+	.gpio			= -EINVAL,
+	.init_data		= &sgtl5000_sabrelite_vdda_reg_initdata,
+};
+
+static struct fixed_voltage_config sgtl5000_sabrelite_vddd_reg_config = {
+	.supply_name		= "VDDD",
+	.microvolts		= 0,
+	.gpio			= -EINVAL,
+	.init_data		= &sgtl5000_sabrelite_vddd_reg_initdata,
+};
+
+static struct fixed_voltage_config sgtl5000_sabrelite_vddio_reg_config = {
+	.supply_name		= "VDDIO",
+	.microvolts		= 3300000,
+	.gpio			= -EINVAL,
+	.init_data		= &sgtl5000_sabrelite_vddio_reg_initdata,
+};
+
+static struct platform_device sgtl5000_sabrelite_vdda_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &sgtl5000_sabrelite_vdda_reg_config,
+	},
+};
+
+static struct platform_device sgtl5000_sabrelite_vddio_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 1,
+	.dev	= {
+		.platform_data = &sgtl5000_sabrelite_vddio_reg_config,
+	},
+};
+
+static struct platform_device sgtl5000_sabrelite_vddd_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 2,
+	.dev	= {
+		.platform_data = &sgtl5000_sabrelite_vddd_reg_config,
+	},
+};
+#endif /* CONFIG_SND_SOC_SGTL5000 */
+
+static struct mxc_audio_platform_data mx6_sabrelite_audio_data;
+
+static int mx6_sabrelite_sgtl5000_init(void)
+{
+	struct clk *clko;
+	struct clk *new_parent;
+	int rate;
+
+	clko = clk_get(NULL, "clko_clk");
+	if (IS_ERR(clko)) {
+		pr_err("can't get CLKO clock.\n");
+		return PTR_ERR(clko);
+	}
+	new_parent = clk_get(NULL, "ahb");
+	if (!IS_ERR(new_parent)) {
+		clk_set_parent(clko, new_parent);
+		clk_put(new_parent);
+	}
+	rate = clk_round_rate(clko, 16000000);
+	if (rate < 8000000 || rate > 27000000) {
+		pr_err("Error:SGTL5000 mclk freq %d out of range!\n", rate);
+		clk_put(clko);
+		return -1;
+	}
+	printk("mx6_sabrelite_sgtl5000_init: %d\n", rate);
+	mx6_sabrelite_audio_data.sysclk = rate;
+	clk_set_rate(clko, rate);
+	clk_enable(clko);
+	return 0;
+}
+
+static struct imx_ssi_platform_data mx6_sabrelite_ssi_pdata = {
+	.flags = IMX_SSI_DMA | IMX_SSI_SYN,
+};
+
+static struct mxc_audio_platform_data mx6_sabrelite_audio_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 4,
+	.init = mx6_sabrelite_sgtl5000_init,
+	.hp_gpio = -1,
+};
+
+static struct platform_device mx6_sabrelite_audio_device = {
+	.name = "imx-sgtl5000",
+};
+
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("sgtl5000", 0x0a),
+	},
+};
+
+static int imx6q_init_audio(void)
+{
+	mxc_register_device(&mx6_sabrelite_audio_device,
+			    &mx6_sabrelite_audio_data);
+	imx6q_add_imx_ssi(1, &mx6_sabrelite_ssi_pdata);
+#ifdef CONFIG_SND_SOC_SGTL5000
+	platform_device_register(&sgtl5000_sabrelite_vdda_reg_devices);
+	platform_device_register(&sgtl5000_sabrelite_vddio_reg_devices);
+	platform_device_register(&sgtl5000_sabrelite_vddd_reg_devices);
+#endif
+	return 0;
+}
+
 /* Serial ports */
 static const struct imxuart_platform_data uart_pdata __initconst = {
 	.flags = IMXUART_HAVE_RTSCTS,
@@ -867,6 +1024,8 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_imx_i2c(0, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabrelite_i2c_data);
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+			ARRAY_SIZE(mxc_i2c0_board_info));
 	i2c_register_board_info(1, mxc_i2c1_board_info,
 			ARRAY_SIZE(mxc_i2c1_board_info));
 	i2c_register_board_info(2, mxc_i2c2_board_info,
@@ -912,6 +1071,8 @@ static void __init mx6_sabrelite_board_init(void)
 	else
 		imx6q_add_flexcan0(&mx6q_sabrelite_flexcan0_pdata);
 
+	imx6q_init_audio();
+
 	clko2 = clk_get(NULL, "clko2_clk");
 	if (IS_ERR(clko2))
 		pr_err("can't get CLKO2 clock.\n");
diff --git a/arch/arm/plat-mxc/devices.c b/arch/arm/plat-mxc/devices.c
index 4d55a7a..a34b2ae 100644
--- a/arch/arm/plat-mxc/devices.c
+++ b/arch/arm/plat-mxc/devices.c
@@ -23,6 +23,20 @@
 #include <linux/platform_device.h>
 #include <mach/common.h>
 
+int __init mxc_register_device(struct platform_device *pdev, void *data)
+{
+	int ret;
+
+	pdev->dev.platform_data = data;
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		pr_debug("Unable to register platform device '%s': %d\n",
+			 pdev->name, ret);
+
+	return ret;
+}
+
 struct device mxc_aips_bus = {
 	.init_name	= "mxc_aips",
 	.parent		= &platform_bus,
diff --git a/arch/arm/plat-mxc/devices/platform-imx-ssi.c b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
index 21c6f30..3676d82 100644
--- a/arch/arm/plat-mxc/devices/platform-imx-ssi.c
+++ b/arch/arm/plat-mxc/devices/platform-imx-ssi.c
@@ -86,6 +86,16 @@ const struct imx_imx_ssi_data imx53_imx_ssi_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX53 */
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_imx_ssi_data imx6_imx_ssi_data[] __initconst = {
+#define imx6q_imx_ssi_data_entry(_id, _hwid)				\
+	imx_imx_ssi_data_entry(MX6Q, _id, _hwid, SZ_4K)
+	imx6q_imx_ssi_data_entry(0, 1),
+	imx6q_imx_ssi_data_entry(1, 2),
+	imx6q_imx_ssi_data_entry(2, 3),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
 struct platform_device *__init imx_add_imx_ssi(
 		const struct imx_imx_ssi_data *data,
 		const struct imx_ssi_platform_data *pdata)
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index b035176..052d8a1 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -151,6 +151,7 @@ extern void imx53_smd_common_init(void);
 extern int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode);
 extern void imx6q_clock_map_io(void);
 extern void early_console_setup(unsigned long base, struct clk *clk);
+extern int mxc_register_device(struct platform_device *pdev, void *data);
 
 #ifdef CONFIG_PM
 extern void imx6q_pm_init(void);
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index ab6762a..a316524 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -273,6 +273,42 @@ struct fsl_mxc_hdmi_core_platform_data {
 	int disp_id;
 };
 
+/*
+ * This struct is to define the number of SSIs on a platform,
+ * DAM source port config, DAM external port config,
+ * regulator names, and other stuff audio needs.
+ */
+struct mxc_audio_platform_data {
+	int ssi_num;
+	int src_port;
+	int ext_port;
+
+	int intr_id_hp;
+	int ext_ram;
+	struct clk *ssi_clk[2];
+
+	int hp_gpio;
+	int hp_active_low;	/* headphone irq is active low */
+
+	int mic_gpio;
+	int mic_active_low;	/* micphone irq is active low */
+
+	int sysclk;
+	const char *codec_name;
+
+	int (*init) (void);	/* board specific init */
+	int (*amp_enable) (int enable);
+	int (*clock_enable) (int enable);
+	int (*finit) (void);	/* board specific finit */
+	void *priv;		/* used by board specific functions */
+};
+
+/* Generic parameters for audio codecs
+ */
+struct mxc_audio_codec_platform_data {
+	int rates; /* codec platform data */
+};
+
 struct mpc8xx_pcmcia_ops {
 	void(*hw_ctrl)(int slot, int enable);
 	int(*voltage_set)(int slot, int vcc, int vpp);
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index f975d8a..f09bb2e 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -76,6 +76,18 @@ config SND_SOC_EUKREA_TLV320
 	  Enable I2S based access to the TLV320AIC23B codec attached
 	  to the SSI interface
 
+config SND_SOC_IMX_SGTL5000
+	tristate "SoC Audio support for i.MX boards with sgtl5000"
+	depends on I2C && (MACH_MX35_3DS || MACH_MX51_BABBAGE \
+			|| MACH_MX6Q_SABRELITE || MACH_MX6Q_ARM2)
+	select SND_SOC_SGTL5000
+	select SND_MXC_SOC_MX2
+	select SND_SOC_IMX_SSI
+	select SND_SOC_IMX_AUDMUX
+	help
+	  Say Y if you want to add support for SoC audio on an i.MX board with
+	  a sgtl5000 codec.
+
 config SND_SOC_IMX_HDMI
 	tristate "SoC Audio support for IMX - HDMI"
 	default n
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index 139e666..d6626bc 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -16,11 +16,13 @@ snd-soc-phycore-ac97-objs := phycore-ac97.o
 snd-soc-mx27vis-aic32x4-objs := mx27vis-aic32x4.o
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
 snd-soc-imx-hdmi-objs := imx-hdmi.o imx-hdmi-dai.o imx-hdmi-dma.o hdmi_pcm.o
+snd-soc-imx-sgtl5000-objs := imx-sgtl5000.o
 
 obj-$(CONFIG_SND_SOC_EUKREA_TLV320) += snd-soc-eukrea-tlv320.o
 obj-$(CONFIG_SND_SOC_PHYCORE_AC97) += snd-soc-phycore-ac97.o
 obj-$(CONFIG_SND_SOC_MX27VIS_AIC32X4) += snd-soc-mx27vis-aic32x4.o
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
 obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
+obj-$(CONFIG_SND_SOC_IMX_SGTL5000) += snd-soc-imx-sgtl5000.o
 
 AFLAGS_hdmi_pcm.o := -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
diff --git a/sound/soc/imx/imx-sgtl5000.c b/sound/soc/imx/imx-sgtl5000.c
new file mode 100644
index 0000000..412fc85
--- /dev/null
+++ b/sound/soc/imx/imx-sgtl5000.c
@@ -0,0 +1,394 @@
+/*
+ * sound/soc/imx/3ds-sgtl5000.c --  SoC audio for i.MX 3ds boards with
+ *                                  sgtl5000 codec
+ *
+ * Copyright 2009 Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <sound/soc-dapm.h>
+#include <asm/mach-types.h>
+
+#include "../codecs/sgtl5000.h"
+#include "imx-ssi.h"
+#include "imx-audmux.h"
+
+static struct imx_sgtl5000_priv {
+	int sysclk;
+	int hw;
+	struct platform_device *pdev;
+} card_priv;
+
+static struct snd_soc_jack hs_jack;
+static struct snd_soc_card imx_sgtl5000;
+
+/* Headphones jack detection DAPM pins */
+static struct snd_soc_jack_pin hs_jack_pins[] = {
+	{
+		.pin = "Headphone Jack",
+		.mask = SND_JACK_HEADPHONE,
+	},
+};
+
+/* Headphones jack detection gpios */
+static struct snd_soc_jack_gpio hs_jack_gpios[] = {
+	[0] = {
+		/* gpio is set on per-platform basis */
+		.name           = "hp-gpio",
+		.report         = SND_JACK_HEADPHONE,
+		.debounce_time	= 200,
+	},
+};
+
+static int sgtl5000_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	u32 dai_format;
+	int ret;
+	unsigned int channels = params_channels(params);
+
+	snd_soc_dai_set_sysclk(codec_dai, SGTL5000_SYSCLK, card_priv.sysclk, SND_SOC_CLOCK_IN);
+
+	snd_soc_dai_set_sysclk(codec_dai, SGTL5000_LRCLK, params_rate(params), SND_SOC_CLOCK_IN);
+
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+
+	/* TODO: The SSI driver should figure this out for us */
+	switch (channels) {
+	case 2:
+		snd_soc_dai_set_tdm_slot(cpu_dai, 0xfffffffc, 0xfffffffc, 2, 0);
+		break;
+	case 1:
+		snd_soc_dai_set_tdm_slot(cpu_dai, 0xfffffffe, 0xfffffffe, 1, 0);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* set cpu DAI configuration */
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF |
+		SND_SOC_DAIFMT_CBM_CFM;
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops imx_sgtl5000_hifi_ops = {
+	.hw_params = sgtl5000_params,
+};
+
+static int sgtl5000_jack_func;
+static int sgtl5000_spk_func;
+static int sgtl5000_line_in_func;
+
+static const char *jack_function[] = { "off", "on"};
+
+static const char *spk_function[] = { "off", "on" };
+
+static const char *line_in_function[] = { "off", "on" };
+
+static const struct soc_enum sgtl5000_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+	SOC_ENUM_SINGLE_EXT(2, line_in_function),
+};
+
+static int sgtl5000_get_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sgtl5000_jack_func;
+	return 0;
+}
+
+static int sgtl5000_set_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	sgtl5000_jack_func = ucontrol->value.integer.value[0];
+	if (sgtl5000_jack_func)
+		snd_soc_dapm_enable_pin(&card->dapm, "Headphone Jack");
+	else
+		snd_soc_dapm_disable_pin(&card->dapm, "Headphone Jack");
+
+	snd_soc_dapm_sync(&card->dapm);
+	return 1;
+}
+
+static int sgtl5000_get_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sgtl5000_spk_func;
+	return 0;
+}
+
+static int sgtl5000_set_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	sgtl5000_spk_func = ucontrol->value.integer.value[0];
+	if (sgtl5000_spk_func)
+		snd_soc_dapm_enable_pin(&card->dapm, "Ext Spk");
+	else
+		snd_soc_dapm_disable_pin(&card->dapm, "Ext Spk");
+
+	snd_soc_dapm_sync(&card->dapm);
+	return 1;
+}
+
+static int sgtl5000_get_line_in(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = sgtl5000_line_in_func;
+	return 0;
+}
+
+static int sgtl5000_set_line_in(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_line_in_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	sgtl5000_line_in_func = ucontrol->value.integer.value[0];
+	if (sgtl5000_line_in_func)
+		snd_soc_dapm_enable_pin(&card->dapm, "Line In Jack");
+	else
+		snd_soc_dapm_disable_pin(&card->dapm, "Line In Jack");
+
+	snd_soc_dapm_sync(&card->dapm);
+	return 1;
+}
+
+/* imx_3stack card dapm widgets */
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+static const struct snd_kcontrol_new sgtl5000_machine_controls[] = {
+	SOC_ENUM_EXT("Jack Function", sgtl5000_enum[0], sgtl5000_get_jack,
+		     sgtl5000_set_jack),
+	SOC_ENUM_EXT("Speaker Function", sgtl5000_enum[1], sgtl5000_get_spk,
+		     sgtl5000_set_spk),
+	SOC_ENUM_EXT("Line In Function", sgtl5000_enum[2], sgtl5000_get_line_in,
+		     sgtl5000_set_line_in),
+};
+
+/* imx_3stack machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* Mic Jack --> MIC_IN (with automatic bias) */
+	{"MIC_IN", NULL, "Mic Jack"},
+
+	/* Line in Jack --> LINE_IN */
+	{"LINE_IN", NULL, "Line In Jack"},
+
+	/* HP_OUT --> Headphone Jack */
+	{"Headphone Jack", NULL, "HP_OUT"},
+
+	/* LINE_OUT --> Ext Speaker */
+	{"Ext Spk", NULL, "LINE_OUT"},
+};
+
+static int imx_3stack_sgtl5000_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	int ret;
+
+	snd_soc_dapm_disable_pin(&codec->dapm, "Line In Jack");
+	snd_soc_dapm_enable_pin(&codec->dapm, "Headphone Jack");
+	snd_soc_dapm_sync(&codec->dapm);
+
+	if (hs_jack_gpios[0].gpio != -1) {
+		/* Jack detection API stuff */
+		ret = snd_soc_jack_new(codec, "Headphone Jack",
+				       SND_JACK_HEADPHONE, &hs_jack);
+		if (ret)
+			return ret;
+
+		ret = snd_soc_jack_add_pins(&hs_jack, ARRAY_SIZE(hs_jack_pins),
+					hs_jack_pins);
+		if (ret) {
+			printk(KERN_ERR "failed to call  snd_soc_jack_add_pins\n");
+			return ret;
+		}
+
+		ret = snd_soc_jack_add_gpios(&hs_jack,
+					ARRAY_SIZE(hs_jack_gpios), hs_jack_gpios);
+		if (ret)
+			printk(KERN_WARNING "failed to call snd_soc_jack_add_gpios\n");
+	}
+
+	return 0;
+}
+
+static struct snd_soc_dai_link imx_sgtl5000_dai[] = {
+	{
+		.name		= "HiFi",
+		.stream_name	= "HiFi",
+		.codec_dai_name	= "sgtl5000",
+		.codec_name	= "sgtl5000.1-000a",
+		.cpu_dai_name	= "imx-ssi.1",
+		.platform_name	= "imx-pcm-audio.1",
+		.init		= imx_3stack_sgtl5000_init,
+		.ops		= &imx_sgtl5000_hifi_ops,
+	},
+};
+
+static struct snd_soc_card imx_sgtl5000 = {
+	.name		= "sgtl5000-audio",
+	.dai_link	= imx_sgtl5000_dai,
+	.num_links	= ARRAY_SIZE(imx_sgtl5000_dai),
+	.dapm_widgets = imx_3stack_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(imx_3stack_dapm_widgets),
+	.dapm_routes = audio_map,
+	.num_dapm_routes = ARRAY_SIZE(audio_map),
+	.controls = sgtl5000_machine_controls,
+	.num_controls = ARRAY_SIZE(sgtl5000_machine_controls),
+};
+
+static struct platform_device *imx_sgtl5000_snd_device;
+
+static int imx_audmux_config(int int_port, int ext_port)
+{
+	/*
+	 * The port numbering in the hardware manual starts at 1, while
+	 * the audmux API expects it starts at 0.
+	 */
+	int_port--;
+	ext_port--;
+
+	imx_audmux_v2_configure_port(int_port,
+			IMX_AUDMUX_V2_PTCR_SYN |
+			IMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |
+			IMX_AUDMUX_V2_PTCR_TFSDIR |
+			IMX_AUDMUX_V2_PTCR_TCLKDIR,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));
+
+	imx_audmux_v2_configure_port(ext_port,
+			IMX_AUDMUX_V2_PTCR_SYN,
+			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
+
+	return 0;
+}
+
+static int __devinit imx_sgtl5000_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	int ret = 0;
+
+	card_priv.pdev = pdev;
+
+	imx_audmux_config(plat->src_port, plat->ext_port);
+
+	ret = -EINVAL;
+	if (plat->init && plat->init())
+		return ret;
+
+	card_priv.sysclk = plat->sysclk;
+
+	hs_jack_gpios[0].gpio = plat->hp_gpio;
+	hs_jack_gpios[0].invert = plat->hp_active_low;
+
+	return 0;
+}
+
+static int imx_sgtl5000_remove(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat->finit)
+		plat->finit();
+
+	return 0;
+}
+
+static struct platform_driver imx_sgtl5000_audio_driver = {
+	.probe = imx_sgtl5000_probe,
+	.remove = imx_sgtl5000_remove,
+	.driver = {
+		   .name = "imx-sgtl5000",
+		   },
+};
+
+static int __init imx_sgtl5000_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_sgtl5000_audio_driver);
+	if (ret)
+		return -ENOMEM;
+
+	if (machine_is_mx35_3ds() || machine_is_mx6q_sabrelite())
+		imx_sgtl5000_dai[0].codec_name = "sgtl5000.0-000a";
+	else
+		imx_sgtl5000_dai[0].codec_name = "sgtl5000.1-000a";
+
+	imx_sgtl5000_snd_device = platform_device_alloc("soc-audio", 1);
+	if (!imx_sgtl5000_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(imx_sgtl5000_snd_device, &imx_sgtl5000);
+
+	ret = platform_device_add(imx_sgtl5000_snd_device);
+
+	if (ret) {
+		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+		platform_device_put(imx_sgtl5000_snd_device);
+	}
+
+	return ret;
+}
+
+static void __exit imx_sgtl5000_exit(void)
+{
+	platform_driver_unregister(&imx_sgtl5000_audio_driver);
+	platform_device_unregister(imx_sgtl5000_snd_device);
+}
+
+module_init(imx_sgtl5000_init);
+module_exit(imx_sgtl5000_exit);
+
+MODULE_AUTHOR("Sascha Hauer <s.hauer@pengutronix.de>");
+MODULE_DESCRIPTION("PhyCORE ALSA SoC driver");
+MODULE_LICENSE("GPL");
-- 
1.7.9.7

