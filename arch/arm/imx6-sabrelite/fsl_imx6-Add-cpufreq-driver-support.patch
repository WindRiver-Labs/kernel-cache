From 502f9a9d1492f57b1c2ebaeb03290b0fc7325608 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 28 Sep 2012 16:21:40 +0800
Subject: [PATCH 46/62] fsl_imx6: Add cpufreq driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig   |    1 +
 arch/arm/plat-mxc/cpufreq.c |  174 +++++++++++++++++++++++++++++++++++--------
 2 files changed, 145 insertions(+), 30 deletions(-)

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 1bebaaf..c8a91bb 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -11,6 +11,7 @@ config ARCH_MX6Q
 	select ARCH_MXC_IOMUX_V3
 	select ARCH_MXC_AUDMUX_V2
 	select IRAM_ALLOC
+	select ARCH_HAS_CPUFREQ
 
 config	SOC_IMX6Q
 	bool
diff --git a/arch/arm/plat-mxc/cpufreq.c b/arch/arm/plat-mxc/cpufreq.c
index 73db34b..61d314f 100644
--- a/arch/arm/plat-mxc/cpufreq.c
+++ b/arch/arm/plat-mxc/cpufreq.c
@@ -22,6 +22,10 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <asm/smp_plat.h>
+#include <asm/cpu.h>
 #include <mach/hardware.h>
 #include <mach/clock.h>
 
@@ -38,28 +42,70 @@ static struct cpufreq_frequency_table *imx_freq_table;
 
 static int cpu_op_nr;
 static struct cpu_op *cpu_op_tbl;
+static u32 pre_suspend_rate;
 
-static int set_cpu_freq(int freq)
+extern struct regulator *cpu_regulator;
+extern int dvfs_core_is_active;
+extern int low_bus_freq_mode;
+extern int high_bus_freq_mode;
+extern int set_low_bus_freq(void);
+extern int set_high_bus_freq(int high_bus_speed);
+extern int low_freq_bus_used(void);
+
+int set_cpu_freq(int freq)
 {
 	int ret = 0;
 	int org_cpu_rate;
+	int i, gp_volt = 0;
 
 	org_cpu_rate = clk_get_rate(cpu_clk);
 	if (org_cpu_rate == freq)
 		return ret;
 
+	for (i = 0; i < cpu_op_nr; i++) {
+		if (freq == cpu_op_tbl[i].cpu_rate)
+			gp_volt = cpu_op_tbl[i].cpu_voltage;
+	}
+
+	if (gp_volt == 0)
+		return ret;
+
+	/*Set the voltage for the GP domain. */
+	if (freq > org_cpu_rate) {
+		if (low_bus_freq_mode)
+			set_high_bus_freq(0);
+		ret = regulator_set_voltage(cpu_regulator, gp_volt,
+					    gp_volt);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
+			return ret;
+		}
+		udelay(50);
+	}
+
 	ret = clk_set_rate(cpu_clk, freq);
 	if (ret != 0) {
 		printk(KERN_DEBUG "cannot set CPU clock rate\n");
 		return ret;
 	}
 
+	if (freq < org_cpu_rate) {
+		ret = regulator_set_voltage(cpu_regulator, gp_volt,
+					    gp_volt);
+		if (ret < 0) {
+			printk(KERN_DEBUG "COULD NOT SET GP VOLTAGE!!!!\n");
+			return ret;
+		}
+		if (low_freq_bus_used() && !low_bus_freq_mode)
+			set_low_bus_freq();
+	}
+
 	return ret;
 }
 
 static int mxc_verify_speed(struct cpufreq_policy *policy)
 {
-	if (policy->cpu != 0)
+	if (policy->cpu > num_possible_cpus())
 		return -EINVAL;
 
 	return cpufreq_frequency_table_verify(policy, imx_freq_table);
@@ -67,7 +113,7 @@ static int mxc_verify_speed(struct cpufreq_policy *policy)
 
 static unsigned int mxc_get_speed(unsigned int cpu)
 {
-	if (cpu)
+	if (cpu > num_possible_cpus())
 		return 0;
 
 	return clk_get_rate(cpu_clk) / 1000;
@@ -80,6 +126,25 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 	int freq_Hz;
 	int ret = 0;
 	unsigned int index;
+	int i, num_cpus;
+
+	num_cpus = num_possible_cpus();
+	if (policy->cpu > num_cpus)
+		return 0;
+
+	if (dvfs_core_is_active) {
+		struct cpufreq_freqs freqs;
+
+		freqs.old = policy->cur;
+		freqs.new = clk_get_rate(cpu_clk) / 1000;
+		freqs.cpu = policy->cpu;
+		freqs.flags = 0;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+		pr_debug("DVFS core is active, cannot change FREQ using CPUFREQ\n");
+		return ret;
+	}
 
 	cpufreq_frequency_table_target(policy, imx_freq_table,
 			target_freq, relation, &index);
@@ -87,25 +152,61 @@ static int mxc_set_target(struct cpufreq_policy *policy,
 
 	freqs.old = clk_get_rate(cpu_clk) / 1000;
 	freqs.new = freq_Hz / 1000;
-	freqs.cpu = 0;
+	freqs.cpu = policy->cpu;
 	freqs.flags = 0;
-	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	for (i = 0; i < num_cpus; i++) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	}
 
 	ret = set_cpu_freq(freq_Hz);
 
-	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+#ifdef CONFIG_SMP
+	/* Loops per jiffy is not updated by the CPUFREQ driver for SMP systems.
+	  * So update it for all CPUs.
+	  */
+
+	for_each_cpu(i, policy->cpus)
+		per_cpu(cpu_data, i).loops_per_jiffy =
+		cpufreq_scale(per_cpu(cpu_data, i).loops_per_jiffy,
+					freqs.old, freqs.new);
+#endif
+	for (i = 0; i < num_cpus; i++) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+
 
 	return ret;
 }
 
-static int mxc_cpufreq_init(struct cpufreq_policy *policy)
+static int mxc_cpufreq_suspend(struct cpufreq_policy *policy)
+{
+	pre_suspend_rate = clk_get_rate(cpu_clk);
+	/* Set to max freq and voltage */
+	if (pre_suspend_rate != (imx_freq_table[0].frequency * 1000))
+		set_cpu_freq(imx_freq_table[0].frequency);
+
+	return 0;
+}
+
+static int mxc_cpufreq_resume(struct cpufreq_policy *policy)
+{
+	if (clk_get_rate(cpu_clk) != pre_suspend_rate)
+		set_cpu_freq(pre_suspend_rate);
+
+	return 0;
+}
+
+static int __devinit mxc_cpufreq_init(struct cpufreq_policy *policy)
 {
 	int ret;
 	int i;
 
 	printk(KERN_INFO "i.MXC CPU frequency driver\n");
 
-	if (policy->cpu != 0)
+	if (policy->cpu >= num_possible_cpus())
 		return -EINVAL;
 
 	if (!get_cpu_op)
@@ -122,32 +223,41 @@ static int mxc_cpufreq_init(struct cpufreq_policy *policy)
 	cpu_freq_khz_min = cpu_op_tbl[0].cpu_rate / 1000;
 	cpu_freq_khz_max = cpu_op_tbl[0].cpu_rate / 1000;
 
-	imx_freq_table = kmalloc(
-		sizeof(struct cpufreq_frequency_table) * (cpu_op_nr + 1),
-			GFP_KERNEL);
-	if (!imx_freq_table) {
-		ret = -ENOMEM;
-		goto err1;
-	}
+	if (imx_freq_table == NULL) {
+		imx_freq_table = kmalloc(
+			sizeof(struct cpufreq_frequency_table) * (cpu_op_nr + 1),
+				GFP_KERNEL);
+		if (!imx_freq_table) {
+			ret = -ENOMEM;
+			goto err1;
+		}
 
-	for (i = 0; i < cpu_op_nr; i++) {
-		imx_freq_table[i].index = i;
-		imx_freq_table[i].frequency = cpu_op_tbl[i].cpu_rate / 1000;
-
-		if ((cpu_op_tbl[i].cpu_rate / 1000) < cpu_freq_khz_min)
-			cpu_freq_khz_min = cpu_op_tbl[i].cpu_rate / 1000;
+		for (i = 0; i < cpu_op_nr; i++) {
+			imx_freq_table[i].index = i;
+			imx_freq_table[i].frequency = cpu_op_tbl[i].cpu_rate / 1000;
 
-		if ((cpu_op_tbl[i].cpu_rate / 1000) > cpu_freq_khz_max)
-			cpu_freq_khz_max = cpu_op_tbl[i].cpu_rate / 1000;
-	}
+			if ((cpu_op_tbl[i].cpu_rate / 1000) < cpu_freq_khz_min)
+				cpu_freq_khz_min = cpu_op_tbl[i].cpu_rate / 1000;
 
-	imx_freq_table[i].index = i;
-	imx_freq_table[i].frequency = CPUFREQ_TABLE_END;
+			if ((cpu_op_tbl[i].cpu_rate / 1000) > cpu_freq_khz_max)
+				cpu_freq_khz_max = cpu_op_tbl[i].cpu_rate / 1000;
+		}
 
+		imx_freq_table[i].index = i;
+		imx_freq_table[i].frequency = CPUFREQ_TABLE_END;
+	}
 	policy->cur = clk_get_rate(cpu_clk) / 1000;
 	policy->min = policy->cpuinfo.min_freq = cpu_freq_khz_min;
 	policy->max = policy->cpuinfo.max_freq = cpu_freq_khz_max;
 
+	/* All processors share the same frequency and voltage.
+	  * So all frequencies need to be scaled together.
+	  */
+	 if (is_smp()) {
+		policy->shared_type = CPUFREQ_SHARED_TYPE_ANY;
+		cpumask_setall(policy->cpus);
+	}
+
 	/* Manual states, that PLL stabilizes in two CLK32 periods */
 	policy->cpuinfo.transition_latency = 2 * NANOSECOND / CLK32_FREQ;
 
@@ -172,9 +282,11 @@ static int mxc_cpufreq_exit(struct cpufreq_policy *policy)
 {
 	cpufreq_frequency_table_put_attr(policy->cpu);
 
-	set_cpu_freq(cpu_freq_khz_max * 1000);
-	clk_put(cpu_clk);
-	kfree(imx_freq_table);
+	if (policy->cpu == 0) {
+		set_cpu_freq(cpu_freq_khz_max * 1000);
+		clk_put(cpu_clk);
+		kfree(imx_freq_table);
+	}
 	return 0;
 }
 
@@ -185,10 +297,12 @@ static struct cpufreq_driver mxc_driver = {
 	.get = mxc_get_speed,
 	.init = mxc_cpufreq_init,
 	.exit = mxc_cpufreq_exit,
+	.suspend = mxc_cpufreq_suspend,
+	.resume = mxc_cpufreq_resume,
 	.name = "imx",
 };
 
-static int __devinit mxc_cpufreq_driver_init(void)
+static int __init mxc_cpufreq_driver_init(void)
 {
 	return cpufreq_register_driver(&mxc_driver);
 }
-- 
1.7.9.7

