From 07d233a34dce937a4aaff76b98a31482a4fdcd18 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 13:54:39 +0800
Subject: [PATCH 48/62] fsl_imx6: Add power manage driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                       |    1 +
 arch/arm/mach-mx6/Makefile                      |    4 +-
 arch/arm/mach-mx6/devices-imx6q.h               |    4 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c         |   17 +
 arch/arm/mach-mx6/mx6q_suspend.S                |  664 +++++++++++++++++++++++
 arch/arm/mach-mx6/pm.c                          |  440 +++++++++++++++
 arch/arm/plat-mxc/devices/Kconfig               |    3 +
 arch/arm/plat-mxc/devices/Makefile              |    1 +
 arch/arm/plat-mxc/devices/platform-imx-pm.c     |   47 ++
 arch/arm/plat-mxc/include/mach/devices-common.h |   10 +
 arch/arm/plat-mxc/include/mach/imx-pm.h         |   31 ++
 11 files changed, 1220 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-mx6/mx6q_suspend.S
 create mode 100644 arch/arm/mach-mx6/pm.c
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-pm.c
 create mode 100644 arch/arm/plat-mxc/include/mach/imx-pm.h

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index c8a91bb..2adcf44 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -40,6 +40,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_VPU
 	select IMX_HAVE_PLATFORM_IMX_MIPI_CSI2
 	select IMX_HAVE_PLATFORM_IMX_DVFS
+	select IMX_HAVE_PLATFORM_IMX_PM
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 80356fd..15cfd8b 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -5,9 +5,9 @@
 # Object file lists.
 obj-y   := cpu.o mm.o system.o irq.o bus_freq.o cpu_op-mx6.o mx6_wfi.o mx6_mmdc.o \
 		mx6_ddr_freq.o mx6_anatop_regulator.o cpu_regulator-mx6.o \
-		usb_dr.o usb_h1.o usb_h2.o usb_h3.o
+		usb_dr.o usb_h1.o usb_h2.o usb_h3.o pm.o
 
-obj-$(CONFIG_ARCH_MX6) += clock.o
+obj-$(CONFIG_ARCH_MX6) += clock.o mx6q_suspend.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += mach-mx6q_sabrelite.o
 obj-$(CONFIG_CPU_V7) += headsmp.o
 AFLAGS_headsmp.o :=-Wa,-march=armv7-a
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index b13d2d8..ac168b4 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -144,4 +144,8 @@ extern const struct imx_dvfs_core_data imx6q_dvfs_core_data __initconst;
 	imx_add_dvfs_core(&imx6q_dvfs_core_data, pdata)
 
 #define imx6q_add_busfreq(pdata)	imx_add_busfreq(pdata)
+
+extern const struct imx_pm_imx_data imx6q_pm_imx_data __initconst;
+#define imx6q_add_pm_imx(id, pdata)	\
+	imx_add_pm_imx(&imx6q_pm_imx_data, pdata)
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 86f1cb0..5a84552 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -785,6 +785,21 @@ static const struct anatop_thermal_platform_data
 		.name = "anatop_thermal",
 };
 
+static void sabrelite_suspend_enter(void)
+{
+	/* suspend preparation */
+}
+
+static void sabrelite_suspend_exit(void)
+{
+	/* resume restore */
+}
+static const struct pm_platform_data mx6q_sabrelite_pm_data __initconst = {
+	.name = "imx_pm",
+	.suspend_enter = sabrelite_suspend_enter,
+	.suspend_exit = sabrelite_suspend_exit,
+};
+
 /*!
  * Board specific initialization.
  */
@@ -865,6 +880,8 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_mxc_pwm(3);
 	imx6q_add_mxc_pwm_backlight(3, &mx6_sabrelite_pwm_backlight_data);
 
+	imx6q_add_pm_imx(0, &mx6q_sabrelite_pm_data);
+
 	clko2 = clk_get(NULL, "clko2_clk");
 	if (IS_ERR(clko2))
 		pr_err("can't get CLKO2 clock.\n");
diff --git a/arch/arm/mach-mx6/mx6q_suspend.S b/arch/arm/mach-mx6/mx6q_suspend.S
new file mode 100644
index 0000000..72446e8
--- /dev/null
+++ b/arch/arm/mach-mx6/mx6q_suspend.S
@@ -0,0 +1,664 @@
+/*
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <mach/hardware.h>
+#include <asm/memory.h>
+#include <asm/hardware/cache-l2x0.h>
+#include "src-reg.h"
+
+#define ARM_CTRL_DCACHE		(1 << 2)
+#define ARM_CTRL_ICACHE		(1 << 12)
+#define ARM_AUXCR_L2EN		(1 << 1)
+#define TTRBIT_MASK 		0xffffc000
+#define TABLE_INDEX_MASK 	0xfff00000
+#define TABLE_ENTRY 		0x00000c02
+#define CACHE_DISABLE_MASK 	0xffffe7fb
+#define MMDC_MAPSR_OFFSET 	0x404
+#define MMDC_MAPSR_PSS 		(1 << 4)
+#define MMDC_MAPSR_PSD 		(1 << 0)
+#define IRAM_SUSPEND_SIZE 	(1 << 12)
+#define MX6_PHYS_OFFSET         UL(0x10000000)
+
+/*************************************************************
+mx6q_suspend:
+
+Suspend the processor (eg, wait for interrupt).
+Set the DDR into Self Refresh
+IRQs are already disabled.
+
+The following code contain both standby and
+dormant mode for MX6, decided by the parameter
+passed in r0:
+see define in include/linux/suspend.h
+1 -> cpu enter stop mode;
+3 -> cpu enter dormant mode.
+r1: iram_paddr
+r2: suspend_iram_base
+*************************************************************/
+	.macro	ddr_io_save
+
+	ldr	r4, [r1, #0x5ac] /* DRAM_DQM0 */
+	ldr	r5, [r1, #0x5b4] /* DRAM_DQM1 */
+	ldr	r6, [r1, #0x528] /* DRAM_DQM2 */
+	ldr	r7, [r1, #0x520] /* DRAM_DQM3 */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r1, #0x514] /* DRAM_DQM4 */
+	ldr	r5, [r1, #0x510] /* DRAM_DQM5 */
+	ldr	r6, [r1, #0x5bc] /* DRAM_DQM6 */
+	ldr	r7, [r1, #0x5c4] /* DRAM_DQM7 */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r1, #0x56c] /* DRAM_CAS */
+	ldr	r5, [r1, #0x578] /* DRAM_RAS */
+	ldr	r6, [r1, #0x588] /* DRAM_SDCLK_0 */
+	ldr	r7, [r1, #0x594] /* DRAM_SDCLK_1 */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r5, [r1, #0x750] /* DDRMODE_CTL */
+	ldr	r6, [r1, #0x774] /* DDRMODE */
+	stmfd	r0!, {r5-r6}
+
+	ldr	r4, [r1, #0x5a8] /* DRAM_SDQS0 */
+	ldr	r5, [r1, #0x5b0] /* DRAM_SDQS1 */
+	ldr	r6, [r1, #0x524] /* DRAM_SDQS2 */
+	ldr	r7, [r1, #0x51c] /* DRAM_SDQS3 */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r1, #0x518] /* DRAM_SDQS4 */
+	ldr	r5, [r1, #0x50c] /* DRAM_SDQS5 */
+	ldr	r6, [r1, #0x5b8] /* DRAM_SDQS6 */
+	ldr	r7, [r1, #0x5c0] /* DRAM_SDQS7 */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r1, #0x784] /* GPR_B0DS */
+	ldr	r5, [r1, #0x788] /* GPR_B1DS */
+	ldr	r6, [r1, #0x794] /* GPR_B2DS */
+	ldr	r7, [r1, #0x79c] /* GPR_B3DS */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r1, #0x7a0] /* GPR_B4DS */
+	ldr	r5, [r1, #0x7a4] /* GPR_B5DS */
+	ldr	r6, [r1, #0x7a8] /* GPR_B6DS */
+	ldr	r7, [r1, #0x748] /* GPR_B7DS */
+	stmfd	r0!, {r4-r7}
+
+	ldr	r5, [r1, #0x74c] /* GPR_ADDS*/
+	ldr	r6, [r1, #0x59c] /* DRAM_SODT0*/
+	ldr	r7, [r1, #0x5a0] /* DRAM_SODT1*/
+	stmfd	r0!, {r5-r7}
+
+	.endm
+
+	.macro	ddr_io_restore
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x5ac] /* DRAM_DQM0 */
+	str	r5, [r1, #0x5b4] /* DRAM_DQM1 */
+	str	r6, [r1, #0x528] /* DRAM_DQM2 */
+	str	r7, [r1, #0x520] /* DRAM_DQM3 */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x514] /* DRAM_DQM4 */
+	str	r5, [r1, #0x510] /* DRAM_DQM5 */
+	str	r6, [r1, #0x5bc] /* DRAM_DQM6 */
+	str	r7, [r1, #0x5c4] /* DRAM_DQM7 */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x56c] /* DRAM_CAS */
+	str	r5, [r1, #0x578] /* DRAM_RAS */
+	str	r6, [r1, #0x588] /* DRAM_SDCLK_0 */
+	str	r7, [r1, #0x594] /* DRAM_SDCLK_1 */
+
+	ldmea	r0!, {r5-r6}
+	str	r5, [r1, #0x750] /* DDRMODE_CTL */
+	str	r6, [r1, #0x774] /* DDRMODE */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x5a8] /* DRAM_SDQS0 */
+	str	r5, [r1, #0x5b0] /* DRAM_SDQS1 */
+	str	r6, [r1, #0x524] /* DRAM_SDQS2 */
+	str	r7, [r1, #0x51c] /* DRAM_SDQS3 */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x518] /* DRAM_SDQS4 */
+	str	r5, [r1, #0x50c] /* DRAM_SDQS5 */
+	str	r6, [r1, #0x5b8] /* DRAM_SDQS6 */
+	str	r7, [r1, #0x5c0] /* DRAM_SDQS7 */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x784] /* GPR_B0DS */
+	str	r5, [r1, #0x788] /* GPR_B1DS */
+	str	r6, [r1, #0x794] /* GPR_B2DS */
+	str	r7, [r1, #0x79c] /* GPR_B3DS */
+
+	ldmea	r0!, {r4-r7}
+	str	r4, [r1, #0x7a0] /* GPR_B4DS */
+	str	r5, [r1, #0x7a4] /* GPR_B5DS */
+	str	r6, [r1, #0x7a8] /* GPR_B6DS */
+	str	r7, [r1, #0x748] /* GPR_B7DS */
+
+	ldmea	r0!, {r5-r7}
+	str	r5, [r1, #0x74c] /* GPR_ADDS*/
+	str	r6, [r1, #0x59c] /* DRAM_SODT0*/
+	str	r7, [r1, #0x5a0] /* DRAM_SODT1*/
+
+	.endm
+
+	.macro	ddr_io_set_lpm
+
+	mov	r0, #0
+	str	r0, [r1, #0x5ac] /* DRAM_DQM0 */
+	str	r0, [r1, #0x5b4] /* DRAM_DQM1 */
+	str	r0, [r1, #0x528] /* DRAM_DQM2 */
+	str	r0, [r1, #0x520] /* DRAM_DQM3 */
+
+	str	r0, [r1, #0x514] /* DRAM_DQM4 */
+	str	r0, [r1, #0x510] /* DRAM_DQM5 */
+	str	r0, [r1, #0x5bc] /* DRAM_DQM6 */
+	str	r0, [r1, #0x5c4] /* DRAM_DQM7 */
+
+	str	r0, [r1, #0x56c] /* DRAM_CAS */
+	str	r0, [r1, #0x578] /* DRAM_RAS */
+	str	r0, [r1, #0x588] /* DRAM_SDCLK_0 */
+	str	r0, [r1, #0x594] /* DRAM_SDCLK_1 */
+
+	str	r0, [r1, #0x750] /* DDRMODE_CTL */
+	str	r0, [r1, #0x774] /* DDRMODE */
+
+	str	r0, [r1, #0x5a8] /* DRAM_SDQS0 */
+	str	r0, [r1, #0x5b0] /* DRAM_SDQS1 */
+	str	r0, [r1, #0x524] /* DRAM_SDQS2 */
+	str	r0, [r1, #0x51c] /* DRAM_SDQS3 */
+
+	str	r0, [r1, #0x518] /* DRAM_SDQS4 */
+	str	r0, [r1, #0x50c] /* DRAM_SDQS5 */
+	str	r0, [r1, #0x5b8] /* DRAM_SDQS6 */
+	str	r0, [r1, #0x5c0] /* DRAM_SDQS7 */
+
+	str	r0, [r1, #0x784] /* GPR_B0DS */
+	str	r0, [r1, #0x788] /* GPR_B1DS */
+	str	r0, [r1, #0x794] /* GPR_B2DS */
+	str	r0, [r1, #0x79c] /* GPR_B3DS */
+
+	str	r0, [r1, #0x7a0] /* GPR_B4DS */
+	str	r0, [r1, #0x7a4] /* GPR_B5DS */
+	str	r0, [r1, #0x7a8] /* GPR_B6DS */
+	str	r0, [r1, #0x748] /* GPR_B7DS */
+
+	str	r0, [r1, #0x74c] /* GPR_ADDS*/
+	str	r0, [r1, #0x59c] /* DRAM_SODT0*/
+	str	r0, [r1, #0x5a0] /* DRAM_SODT1*/
+
+	.endm
+
+ENTRY(mx6q_suspend)
+	stmfd	sp!, {r0-r12}     @ Save registers
+/*************************************************************
+suspend mode entry
+*************************************************************/
+
+	cmp	r0, #0x1
+	bne	dormant		/* dormant mode */
+
+	dsb
+	wfi
+
+	nop
+	nop
+	nop
+	nop
+	/* Due to the L2 cache errata(TKT065875)
+	, need to wait at least 170ns, each IO read
+	takes about 76ns, but the actual wait time
+	to make system more stable is about 380ns */
+	ldr	r0, =SRC_BASE_ADDR
+	add 	r0, r0, #PERIPBASE_VIRT
+	ldr	r1, [r0]
+	ldr	r1, [r0, #0x4]
+	ldr	r1, [r0, #0x8]
+	ldr	r1, [r0, #0xc]
+	ldr	r1, [r0, #0x10]
+/***********************************************************
+never run to here
+************************************************************/
+	b 	out	/* exit standby */
+
+/************************************************************
+dormant entry, data save in stack, save sp in the src_gpr2
+************************************************************/
+dormant:
+	mov 	r3, r1
+	mov 	r0, r1
+	add 	r0, r0, #IRAM_SUSPEND_SIZE /* 4K */
+	ldr 	r4, =SRC_BASE_ADDR
+	add 	r4, r4, #PERIPBASE_VIRT
+	str 	r0, [r4, #SRC_GPR2_OFFSET] /* set src_gpr2 */
+/************************************************************
+saved register and context as below:
+	ddr_iomux set
+	sp
+	spsr
+	lr
+	CPACR
+	TTBR0
+	TTBR1
+	TTBCR
+	DACR
+	PRRR
+	NMRR
+	ACTLR
+	Context ID
+	User r/w thread ID
+	Secure or NS VBAR
+	CPSR
+	SCTLR
+************************************************************/
+ddr_iomux_save:
+	/* save mmdc iomux setting, stack is from the tail of
+	iram_suspend base */
+
+	mov	r0, r2 		/* get suspend_iram_base */
+	add	r0, r0, #IRAM_SUSPEND_SIZE	/* 4K */
+	ldr	r1, =MX6Q_IOMUXC_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+
+	ddr_io_save
+
+	mov	r4, sp			@ Store sp
+	mrs	r5, spsr		@ Store spsr
+	mov	r6, lr			@ Store lr
+	stmfd	r0!, {r4-r6}
+
+	/* c1 and c2 registers */
+	mrc	p15, 0, r4, c1, c0, 2	@ CPACR
+	mrc	p15, 0, r5, c2, c0, 0	@ TTBR0
+	mrc	p15, 0, r6, c2, c0, 1	@ TTBR1
+	mrc	p15, 0, r7, c2, c0, 2	@ TTBCR
+	stmfd	r0!, {r4-r7}
+
+	/* c3 and c10 registers */
+	mrc	p15, 0, r4, c3, c0, 0	@ DACR
+	mrc	p15, 0, r5, c10, c2, 0	@ PRRR
+	mrc	p15, 0, r6, c10, c2, 1	@ NMRR
+	mrc	p15, 0, r7, c1, c0, 1	@ ACTLR
+	stmfd	r0!,{r4-r7}
+
+	/* c12, c13 and CPSR registers */
+	mrc	p15, 0, r4, c13, c0, 1	@ Context ID
+	mrc	p15, 0, r5, c13, c0, 2	@ User r/w thread ID
+	mrc	p15, 0, r6, c12, c0, 0	@ Secure or NS VBAR
+	mrs	r7, cpsr		@ Store CPSR
+	stmfd	r0!, {r4-r7}
+
+	/* c1 control register */
+	mrc	p15, 0, r4, c1, c0, 0	@ SCTLR
+	stmfd	r0!, {r4}
+
+#ifdef CONFIG_CACHE_L2X0
+	ldr r2, =L2_BASE_ADDR
+	add r2, r2, #PERIPBASE_VIRT
+
+	ldr	r4, [r2, #L2X0_CTRL]
+	ldr	r5, [r2, #L2X0_AUX_CTRL]
+	ldr	r6, [r2, #L2X0_TAG_LATENCY_CTRL]
+	ldr	r7, [r2, #L2X0_DATA_LATENCY_CTRL]
+	stmfd	r0!, {r4-r7}
+
+	ldr	r4, [r2, #L2X0_PREFETCH_CTRL]
+	ldr	r5, [r2, #L2X0_POWER_CTRL]
+	stmfd	r0!, {r4-r5}
+#endif
+	/*
+	 * Flush all data from the L1 data cache before disabling
+	 * SCTLR.C bit.
+	 */
+	push	{r0-r12, lr}
+	ldr	r0, =v7_flush_dcache_all
+	mov	lr, pc
+	mov	pc, r0
+	pop	{r0-r12, lr}
+
+	/*
+	 * Clear the SCTLR.C bit to prevent further data cache
+	 * allocation. Clearing SCTLR.C would make all the data accesses
+	 * strongly ordered and would not hit the cache.
+	 */
+	mrc	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #(1 << 2)	@ Disable the C bit
+	mcr	p15, 0, r0, c1, c0, 0
+	isb
+
+	/*
+	 * Invalidate L1 data cache. Even though only invalidate is
+	 * necessary exported flush API is used here. Doing clean
+	 * on already clean cache would be almost NOP.
+	 */
+	push	{r0-r12, lr}
+	ldr	r0, =v7_flush_dcache_all
+	mov	lr, pc
+	mov	pc, r0
+	pop	{r0-r12, lr}
+
+	/*
+	 * Execute an ISB instruction to ensure that all of the
+	 * CP15 register changes have been committed.
+	 */
+	isb
+
+	/*
+	 * Execute a barrier instruction to ensure that all cache,
+	 * TLB and branch predictor maintenance operations issued
+	 * by any CPU in the cluster have completed.
+	 */
+	dsb
+	dmb
+
+	/* Clean L2 cache to write the dirty data into DRAM to make
+	sure the data alignment between DRAM and L2 cache.
+	*/
+#ifdef CONFIG_CACHE_L2X0
+	/* Clean L2 cache here */
+	ldr	r1, =L2_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+	/* Make way to 0xFFFF 16 ways */
+	mov	r0, #0x10000
+	sub	r0, r0, #0x1
+	/* 0x7BC is L2X0_CLEAN_WAY */
+	mov	r4, #0x700
+	orr	r4, #0xBC
+	str	r0, [r1, r4]
+wait:
+	ldr	r2, [r1, r4]
+	ands	r2, r2, r0
+	bne	wait
+l2x0_sync:
+	mov	r2, #0x0
+	/* 0x730 is L2X0_CACHE_SYNC */
+	mov	r4, #0x700
+	orr	r4, #0x30
+	str	r2, [r1, r4]
+sync:
+	ldr	r2, [r1, r4]
+	ands	r2, r2, #0x1
+	bne	sync
+#endif
+/****************************************************************
+set ddr iomux to low power mode
+****************************************************************/
+	ldr	r1, =MMDC_P0_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+	ldr	r0, [r1, #MMDC_MAPSR_OFFSET]
+	bic	r0, #MMDC_MAPSR_PSD 		/* enable lpm */
+	str	r0, [r1, #MMDC_MAPSR_OFFSET]
+refresh:
+	ldr	r0, [r1, #MMDC_MAPSR_OFFSET] 	/* MMDC_MAPSR */
+	and	r0, r0, #MMDC_MAPSR_PSS 	/* PSS bit */
+	cmp	r0, #0
+	beq	refresh
+
+	/* set mmdc iomux to low power mode */
+	ldr	r1, =MX6Q_IOMUXC_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+
+	ddr_io_set_lpm
+/****************************************************************
+save resume pointer into SRC_GPR1
+****************************************************************/
+	ldr	r0, =mx6q_suspend
+	ldr	r1, =resume
+	sub	r1, r1, r0
+	add	r3, r3, r1
+	ldr	r1, =SRC_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+	str	r3, [r1, #SRC_GPR1_OFFSET]
+/****************************************************************
+execute a wfi instruction to let SOC go into stop mode.
+****************************************************************/
+	wfi
+
+	nop
+	nop
+	nop
+	nop
+
+/****************************************************************
+if go here, means there is a wakeup irq pending, we should resume
+system immediately.
+****************************************************************/
+	mov	r0, r2 		/* get suspend_iram_base */
+	add	r0, r0, #IRAM_SUSPEND_SIZE	/* 4K */
+
+	ldr	r1, =MX6Q_IOMUXC_BASE_ADDR
+	add	r1, r1, #PERIPBASE_VIRT
+
+	ddr_io_restore
+
+	mrc	p15, 0, r1, c1, c0, 0
+	orr	r1, r1, #(1 << 2)	@ Enable the C bit
+	mcr	p15, 0, r1, c1, c0, 0
+
+	b 	out	/* exit standby */
+
+/****************************************************************
+when SOC exit stop mode, arm core restart from here, currently
+are running with MMU off.
+****************************************************************/
+resume:
+	/* Invalidate L1 I-cache first */
+	mov	r1,	#0x0
+	mcr p15, 0, r1, c7, c5, 0 @ Invalidate I-Cache
+	ldr	r0, =SRC_BASE_ADDR
+	str	r1, [r0, #SRC_GPR1_OFFSET] /* clear SRC_GPR1 */
+	ldr	r0, [r0, #SRC_GPR2_OFFSET]
+
+	ldr	r1, =MX6Q_IOMUXC_BASE_ADDR
+	ddr_io_restore
+
+	/* Restore cp15 registers */
+	ldmea	r0!, {r4-r6}
+	mov	sp, r4
+	msr	spsr_cxsf, r5		@ Restore spsr
+	mov	lr, r6			@ Restore lr
+
+	/* c1 and c2 registers */
+	ldmea	r0!, {r4-r7}
+	mcr	p15, 0, r4, c1, c0, 2	@ CPACR
+	mcr	p15, 0, r5, c2, c0, 0	@ TTBR0
+	mcr	p15, 0, r6, c2, c0, 1	@ TTBR1
+	mcr	p15, 0, r7, c2, c0, 2	@ TTBCR
+
+	/* c3 and c10 registers */
+	ldmea	r0!,{r4-r7}
+	mcr	p15, 0, r4, c3, c0, 0	@ DACR
+	mcr	p15, 0, r5, c10, c2, 0	@ PRRR
+	mcr	p15, 0, r6, c10, c2, 1	@ NMRR
+	mcr	p15, 0, r7, c1, c0, 1	@ ACTLR
+
+	/* c12, c13 and CPSR registers */
+	ldmea	r0!,{r4-r7}
+	mcr	p15, 0, r4, c13, c0, 1	@ Context ID
+	mcr	p15, 0, r5, c13, c0, 2	@ User r/w thread ID
+	mrc	p15, 0, r6, c12, c0, 0	@ Secure or NS VBAR
+	msr	cpsr, r7		@ store cpsr
+
+	/*
+	 * Enabling MMU here. Page entry needs to be altered
+	 * to create temporary 1:1 map and then resore the entry
+	 * ones MMU is enabled
+	 */
+	mrc	p15, 0, r7, c2, c0, 2	@ Read TTBRControl
+	and	r7, #0x7		@ Extract N (0:2) to decide
+	cmp	r7, #0x0		@ TTBR0/TTBR1
+	beq	use_ttbr0
+ttbr_error:
+	b	ttbr_error		@ Only N = 0 supported
+use_ttbr0:
+	mrc	p15, 0, r2, c2, c0, 0	@ Read TTBR0
+	ldr	r5, =TTRBIT_MASK
+	and	r2, r5
+	mov	r4, pc
+	ldr	r5, =TABLE_INDEX_MASK
+	and	r4, r5			@ r4 = 31 to 20 bits of pc
+	ldr	r1, =TABLE_ENTRY
+	add	r1, r1, r4		@ r1 has value of table entry
+	lsr	r4, #18			@ Address of table entry
+	add	r2, r4			@ r2 - location to be modified
+
+	/* Storing previous entry of location being modified */
+	ldr	r4, [r2]
+	mov	r9, r4
+	str	r1, [r2]
+
+	/*
+	 * Storing address of entry being modified
+	 * It will be restored after enabling MMU
+	 */
+	mov 	r10, r2
+
+	mov	r1, #0
+	mcr	p15, 0, r1, c7, c5, 4	@ Flush prefetch buffer
+	mcr	p15, 0, r1, c7, c5, 6	@ Invalidate BTB
+	mcr	p15, 0, r1, c8, c5, 0	@ Invalidate ITLB
+	mcr	p15, 0, r1, c8, c6, 0	@ Invalidate DTLB
+
+	/*
+	 * Restore control register  but don't enable Data caches here.
+	 * Caches will be enabled after restoring MMU table entry.
+	 */
+	ldmea	r0!, {r4}
+	mov r11, r4
+	ldr	r2, =CACHE_DISABLE_MASK
+	and	r4, r4, r2
+	mcr	p15, 0, r4, c1, c0, 0
+	isb
+	dsb
+	ldr	r1, =mmu_on_label
+	bx	r1
+mmu_on_label:
+	mov 	r8, lr
+	push	{r0}
+
+	/* Set up the per-CPU stacks */
+	bl	cpu_init
+	pop	{r0}
+
+#ifdef CONFIG_CACHE_L2X0
+	ldr r2, =L2_BASE_ADDR
+	add r2, r2, #PERIPBASE_VIRT
+
+	ldmea	r0!, {r4-r7}
+	/* L2 will be enabled after L1 is enabled */
+	mov r4, #0x0
+	str	r4, [r2, #L2X0_CTRL]
+	str	r5, [r2, #L2X0_AUX_CTRL]
+	str	r6, [r2, #L2X0_TAG_LATENCY_CTRL]
+	str	r7, [r2, #L2X0_DATA_LATENCY_CTRL]
+
+	ldmea	r0!, {r4-r5}
+	str	r4, [r2, #L2X0_PREFETCH_CTRL]
+	str	r5, [r2, #L2X0_POWER_CTRL]
+#endif
+	/*
+	 * Restore the MMU table entry that was modified for
+	 * enabling MMU.
+	 */
+	ldr	r4, =PAGE_OFFSET
+	ldr	r5, =MX6_PHYS_OFFSET
+	sub	r4, r4, r5
+	add	r4, r4, r10
+	str	r9, [r4]
+
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c1, 6	@ flush TLB and issue barriers
+	mcr	p15, 0, r0, c7, c5, 4	@ Flush prefetch buffer
+	mcr	p15, 0, r0, c7, c5, 6	@ Invalidate BTB
+	mcr	p15, 0, r0, c8, c5, 0	@ Invalidate ITLB
+	mcr	p15, 0, r0, c8, c6, 0	@ Invalidate DTLB
+	dsb
+	isb
+
+/******************************************************************
+invalidate l1 dcache, r0-r4, r6, r7 used
+******************************************************************/
+	mov     r0, #0
+	mcr     p15, 2, r0, c0, c0, 0
+	mrc     p15, 1, r0, c0, c0, 0
+
+	ldr     r1, =0x7fff
+	and     r2, r1, r0, lsr #13
+
+	ldr     r1, =0x3ff
+
+	and     r3, r1, r0, lsr #3	@ NumWays - 1
+	add     r2, r2, #1		@ NumSets
+
+	and     r0, r0, #0x7
+	add     r0, r0, #4		@ SetShift
+
+	clz     r1, r3			@ WayShift
+	add     r4, r3, #1		@ NumWays
+1:
+	sub     r2, r2, #1		@ NumSets--
+	mov     r3, r4			@ Temp = NumWays
+2:
+	subs    r3, r3, #1		@ Temp--
+	mov     r7, r3, lsl r1
+	mov     r6, r2, lsl r0
+	orr     r7, r7, r6
+	mcr     p15, 0, r7, c7, c6, 2
+	bgt     2b
+	cmp     r2, #0
+	bgt     1b
+	dsb
+	isb
+
+/************************************************************
+restore control register to enable cache
+************************************************************/
+	mov	r0, r11
+	mcr	p15, 0, r0, c1, c0, 0	@ with caches enabled.
+	dsb
+	isb
+
+#ifdef CONFIG_CACHE_L2X0
+	/* Enable L2 cache here */
+	ldr r2, =L2_BASE_ADDR
+	add r2, r2, #PERIPBASE_VIRT
+	mov r4, #0x1
+	str	r4, [r2, #L2X0_CTRL]
+#endif
+/***********************************************************
+return back to mx6_suspend_enter for dormant
+***********************************************************/
+	mov	lr, r8
+	ldmfd	sp!, {r0-r12}
+	mov	pc, lr
+/************************************************
+return back to mx6_suspend_enter for suspend
+*************************************************/
+out:
+	ldmfd	sp!, {r0-r12}
+	mov	pc, lr
+
+	.equ    va2pa_offset, (PAGE_OFFSET - MX6_PHYS_OFFSET)
+	.type	mx6q_do_suspend, #object
+ENTRY(mx6q_do_suspend)
+	.word	mx6q_suspend
+	.size	mx6q_suspend, . - mx6q_suspend
diff --git a/arch/arm/mach-mx6/pm.c b/arch/arm/mach-mx6/pm.c
new file mode 100644
index 0000000..c3f3e3f
--- /dev/null
+++ b/arch/arm/mach-mx6/pm.c
@@ -0,0 +1,440 @@
+/*
+ *  Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
+#include <linux/regulator/machine.h>
+#include <linux/proc_fs.h>
+#include <linux/iram_alloc.h>
+#include <linux/fsl_devices.h>
+#include <asm/mach-types.h>
+#include <asm/cacheflush.h>
+#include <asm/tlb.h>
+#include <asm/delay.h>
+#include <asm/mach/map.h>
+#include <mach/hardware.h>
+#include <mach/imx-pm.h>
+#include <mach/arc_otg.h>
+#include <mach/common.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
+#ifdef CONFIG_ARCH_MX6Q
+#include <mach/iomux-mx6q.h>
+#endif
+#include "crm_regs.h"
+#include "src-reg.h"
+
+#define SCU_CTRL_OFFSET				0x00
+#define GPC_IMR1_OFFSET				0x08
+#define GPC_IMR2_OFFSET				0x0c
+#define GPC_IMR3_OFFSET				0x10
+#define GPC_IMR4_OFFSET				0x14
+#define GPC_ISR1_OFFSET				0x18
+#define GPC_ISR2_OFFSET				0x1c
+#define GPC_ISR3_OFFSET				0x20
+#define GPC_ISR4_OFFSET				0x24
+#define GPC_CNTR_OFFSET				0x0
+#define GPC_PGC_GPU_PGCR_OFFSET		0x260
+#define GPC_PGC_CPU_PDN_OFFSET		0x2a0
+#define GPC_PGC_CPU_PUPSCR_OFFSET	0x2a4
+#define GPC_PGC_CPU_PDNSCR_OFFSET	0x2a8
+#define UART_UCR3_OFFSET			0x88
+#define UART_USR1_OFFSET			0x94
+#define UART_UCR3_AWAKEN			(1 << 4)
+#define UART_USR1_AWAKE				(1 << 4)
+#define LOCAL_TWD_LOAD_OFFSET		0x0
+#define LOCAL_TWD_COUNT_OFFSET		0x4
+#define LOCAL_TWD_CONTROL_OFFSET	0x8
+#define LOCAL_TWD_INT_OFFSET		0xc
+#define ANATOP_REG_2P5_OFFSET		0x130
+#define ANATOP_REG_CORE_OFFSET		0x140
+
+static struct clk *cpu_clk;
+static struct pm_platform_data *pm_data;
+
+#if defined(CONFIG_CPU_FREQ)
+extern int set_cpu_freq(int wp);
+#endif
+extern void mx6q_suspend(suspend_state_t state);
+extern void mx6_init_irq(void);
+extern unsigned int gpc_wake_irq[4];
+
+static struct device *pm_dev;
+struct clk *gpc_dvfs_clk;
+static void __iomem *scu_base;
+static void __iomem *gpc_base;
+static void __iomem *src_base;
+static void __iomem *local_twd_base;
+static void __iomem *gic_dist_base;
+static void __iomem *gic_cpu_base;
+static void __iomem *anatop_base;
+
+static void *suspend_iram_base;
+static void (*suspend_in_iram)(suspend_state_t state,
+	unsigned long iram_paddr, unsigned long suspend_iram_base) = NULL;
+static unsigned long iram_paddr, cpaddr;
+
+static u32 ccm_ccr, ccm_clpcr, scu_ctrl;
+static u32 gpc_imr[4], gpc_cpu_pup, gpc_cpu_pdn, gpc_cpu, gpc_ctr;
+static u32 anatop[2], ccgr1, ccgr2, ccgr3, ccgr6;
+static u32 ccm_analog_pfd528;
+static bool usb_vbus_wakeup_enabled;
+
+
+/*
+ * The USB VBUS wakeup should be disabled to avoid vbus wake system
+ * up due to vbus comparator is closed at weak 2p5 mode.
+ */
+static void usb_power_down_handler(void)
+{
+	u32 temp;
+	bool usb_oh3_clk_already_on;
+	/* enable usb oh3 clock if needed*/
+	temp = __raw_readl(MXC_CCM_CCGR6);
+	usb_oh3_clk_already_on =	\
+		((temp & (MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET))  \
+		== (MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET));
+	if (!usb_oh3_clk_already_on) {
+		temp |= MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET;
+		__raw_writel(temp, MXC_CCM_CCGR6);
+	}
+	/* disable vbus wakeup */
+	usb_vbus_wakeup_enabled = !!(USB_OTG_CTRL & UCTRL_WKUP_VBUS_EN);
+	if (usb_vbus_wakeup_enabled) {
+		USB_OTG_CTRL &= ~UCTRL_WKUP_VBUS_EN;
+	}
+	/* disable usb oh3 clock */
+	if (!usb_oh3_clk_already_on) {
+		temp = __raw_readl(MXC_CCM_CCGR6);
+		temp &= ~(MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET);
+		__raw_writel(temp, MXC_CCM_CCGR6);
+	}
+}
+
+static void usb_power_up_handler(void)
+{
+	/* enable vbus wakeup at runtime if needed */
+	if (usb_vbus_wakeup_enabled) {
+		u32 temp;
+		bool usb_oh3_clk_already_on;
+		/* enable usb oh3 clock if needed*/
+		temp = __raw_readl(MXC_CCM_CCGR6);
+		usb_oh3_clk_already_on =	\
+			((temp & (MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET))  \
+			== (MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET));
+		if (!usb_oh3_clk_already_on) {
+			temp |= MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET;
+			__raw_writel(temp, MXC_CCM_CCGR6);
+		}
+
+		/* restore usb wakeup enable setting */
+		USB_OTG_CTRL |= UCTRL_WKUP_VBUS_EN;
+
+		/* disable usb oh3 clock */
+		if (!usb_oh3_clk_already_on) {
+			temp = __raw_readl(MXC_CCM_CCGR6);
+			temp &= ~(MXC_CCM_CCGRx_CG_MASK << MXC_CCM_CCGRx_CG0_OFFSET);
+			__raw_writel(temp, MXC_CCM_CCGR6);
+		}
+	}
+}
+
+static void gpu_power_down(void)
+{
+	int reg;
+
+	/* enable power down request */
+	reg = __raw_readl(gpc_base + GPC_PGC_GPU_PGCR_OFFSET);
+	__raw_writel(reg | 0x1, gpc_base + GPC_PGC_GPU_PGCR_OFFSET);
+	/* power down request */
+	reg = __raw_readl(gpc_base + GPC_CNTR_OFFSET);
+	__raw_writel(reg | 0x1, gpc_base + GPC_CNTR_OFFSET);
+	/* disable clocks */
+	__raw_writel(ccgr1 &
+		     ~MXC_CCM_CCGRx_CG12_MASK &
+		     ~MXC_CCM_CCGRx_CG13_MASK, MXC_CCM_CCGR1);
+	__raw_writel(ccgr3 & ~MXC_CCM_CCGRx_CG15_MASK, MXC_CCM_CCGR3);
+	__raw_writel(ccgr6 & ~MXC_CCM_CCGRx_CG7_MASK, MXC_CCM_CCGR6);
+	/* power off pu */
+	reg = __raw_readl(anatop_base + ANATOP_REG_CORE_OFFSET);
+	reg &= ~0x0003fe00;
+	__raw_writel(reg, anatop_base + ANATOP_REG_CORE_OFFSET);
+}
+
+static void gpu_power_up(void)
+{
+	int reg;
+	/* power on pu */
+	reg = __raw_readl(anatop_base + ANATOP_REG_CORE_OFFSET);
+	reg &= ~0x0003fe00;
+	reg |= 0x10 << 9; /* 1.1v */
+	__raw_writel(reg, anatop_base + ANATOP_REG_CORE_OFFSET);
+	mdelay(10);
+
+	/* enable clocks */
+	/* PLL2 PFD0 and PFD1 clock enable */
+	__raw_writel(ccm_analog_pfd528 &
+		     ~ANADIG_PFD0_CLKGATE &
+		     ~ANADIG_PFD1_CLKGATE, PFD_528_BASE_ADDR);
+	/* gpu3d and gpu2d clock enable */
+	__raw_writel(ccgr1 |
+		     MXC_CCM_CCGRx_CG12_MASK |
+		     MXC_CCM_CCGRx_CG13_MASK, MXC_CCM_CCGR1);
+	/* tzasrc1 clock enable for gpu3d core clock */
+	__raw_writel(ccgr2 | MXC_CCM_CCGRx_CG11_MASK, MXC_CCM_CCGR2);
+	/* openvgaxi clock enable, mmdc_core_ipg_clk_p0 clock and
+	mmdc_core_aclk_fast_core_p0 clock enable for gpu3d core clock */
+	__raw_writel(ccgr3 |
+		     MXC_CCM_CCGRx_CG15_MASK |
+		     MXC_CCM_CCGRx_CG12_MASK |
+		     MXC_CCM_CCGRx_CG10_MASK, MXC_CCM_CCGR3);
+	/* vpu clock enable */
+	__raw_writel(ccgr6 | MXC_CCM_CCGRx_CG7_MASK, MXC_CCM_CCGR6);
+
+	/* enable power up request */
+	reg = __raw_readl(gpc_base + GPC_PGC_GPU_PGCR_OFFSET);
+	__raw_writel(reg | 0x1, gpc_base + GPC_PGC_GPU_PGCR_OFFSET);
+	/* power up request */
+	reg = __raw_readl(gpc_base + GPC_CNTR_OFFSET);
+	__raw_writel(reg | 0x2, gpc_base + GPC_CNTR_OFFSET);
+	udelay(10);
+}
+
+
+
+static void mx6_suspend_store(void)
+{
+	/* save some settings before suspend */
+	ccm_ccr = __raw_readl(MXC_CCM_CCR);
+	ccm_clpcr = __raw_readl(MXC_CCM_CLPCR);
+	ccm_analog_pfd528 = __raw_readl(PFD_528_BASE_ADDR);
+	ccgr1 = __raw_readl(MXC_CCM_CCGR1);
+	ccgr2 = __raw_readl(MXC_CCM_CCGR2);
+	ccgr3 = __raw_readl(MXC_CCM_CCGR3);
+	ccgr6 = __raw_readl(MXC_CCM_CCGR6);
+	scu_ctrl = __raw_readl(scu_base + SCU_CTRL_OFFSET);
+	gpc_imr[0] = __raw_readl(gpc_base + GPC_IMR1_OFFSET);
+	gpc_imr[1] = __raw_readl(gpc_base + GPC_IMR2_OFFSET);
+	gpc_imr[2] = __raw_readl(gpc_base + GPC_IMR3_OFFSET);
+	gpc_imr[3] = __raw_readl(gpc_base + GPC_IMR4_OFFSET);
+	gpc_cpu_pup = __raw_readl(gpc_base + GPC_PGC_CPU_PUPSCR_OFFSET);
+	gpc_cpu_pdn = __raw_readl(gpc_base + GPC_PGC_CPU_PDNSCR_OFFSET);
+	gpc_cpu = __raw_readl(gpc_base + GPC_PGC_CPU_PDN_OFFSET);
+	gpc_ctr = __raw_readl(gpc_base + GPC_CNTR_OFFSET);
+	anatop[0] = __raw_readl(anatop_base + ANATOP_REG_2P5_OFFSET);
+	anatop[1] = __raw_readl(anatop_base + ANATOP_REG_CORE_OFFSET);
+}
+
+static void mx6_suspend_restore(void)
+{
+	/* restore settings after suspend */
+	__raw_writel(anatop[0], anatop_base + ANATOP_REG_2P5_OFFSET);
+	__raw_writel(anatop[1], anatop_base + ANATOP_REG_CORE_OFFSET);
+	/* Per spec, the count needs to be zeroed and reconfigured on exit from
+	 * low power mode
+	 */
+	__raw_writel(ccm_ccr & ~MXC_CCM_CCR_REG_BYPASS_CNT_MASK &
+		~MXC_CCM_CCR_WB_COUNT_MASK, MXC_CCM_CCR);
+	udelay(50);
+	__raw_writel(ccm_ccr, MXC_CCM_CCR);
+	__raw_writel(ccm_clpcr, MXC_CCM_CLPCR);
+	__raw_writel(scu_ctrl, scu_base + SCU_CTRL_OFFSET);
+	__raw_writel(gpc_imr[0], gpc_base + GPC_IMR1_OFFSET);
+	__raw_writel(gpc_imr[1], gpc_base + GPC_IMR2_OFFSET);
+	__raw_writel(gpc_imr[2], gpc_base + GPC_IMR3_OFFSET);
+	__raw_writel(gpc_imr[3], gpc_base + GPC_IMR4_OFFSET);
+	__raw_writel(gpc_cpu_pup, gpc_base + GPC_PGC_CPU_PUPSCR_OFFSET);
+	__raw_writel(gpc_cpu_pdn, gpc_base + GPC_PGC_CPU_PDNSCR_OFFSET);
+	__raw_writel(gpc_cpu, gpc_base + GPC_PGC_CPU_PDN_OFFSET);
+
+	__raw_writel(ccgr1, MXC_CCM_CCGR1);
+	__raw_writel(ccgr2, MXC_CCM_CCGR2);
+	__raw_writel(ccgr3, MXC_CCM_CCGR3);
+	__raw_writel(ccgr6, MXC_CCM_CCGR6);
+	__raw_writel(ccm_analog_pfd528, PFD_528_BASE_ADDR);
+}
+
+static int mx6_suspend_enter(suspend_state_t state)
+{
+	unsigned int wake_irq_isr[4];
+
+	wake_irq_isr[0] = __raw_readl(gpc_base +
+			GPC_ISR1_OFFSET) & gpc_wake_irq[0];
+	wake_irq_isr[1] = __raw_readl(gpc_base +
+			GPC_ISR2_OFFSET) & gpc_wake_irq[1];
+	wake_irq_isr[2] = __raw_readl(gpc_base +
+			GPC_ISR3_OFFSET) & gpc_wake_irq[2];
+	wake_irq_isr[3] = __raw_readl(gpc_base +
+			GPC_ISR4_OFFSET) & gpc_wake_irq[3];
+	if (wake_irq_isr[0] | wake_irq_isr[1] |
+			wake_irq_isr[2] | wake_irq_isr[3]) {
+		printk(KERN_INFO "There are wakeup irq pending,system resume!\n");
+		printk(KERN_INFO "wake_irq_isr[0-3]: 0x%x, 0x%x, 0x%x, 0x%x\n",
+				wake_irq_isr[0], wake_irq_isr[1],
+				wake_irq_isr[2], wake_irq_isr[3]);
+		return 0;
+	}
+	mx6_suspend_store();
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		gpu_power_down();
+		usb_power_down_handler();
+		mxc_cpu_lp_set(ARM_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY) {
+		if (pm_data && pm_data->suspend_enter)
+			pm_data->suspend_enter();
+
+		local_flush_tlb_all();
+		flush_cache_all();
+
+		suspend_in_iram(state, (unsigned long)iram_paddr,
+			(unsigned long)suspend_iram_base);
+
+		if (state == PM_SUSPEND_MEM) {
+			usb_power_up_handler();
+			gpu_power_up();
+		}
+		mx6_suspend_restore();
+
+		if (pm_data && pm_data->suspend_exit)
+			pm_data->suspend_exit();
+	} else {
+			cpu_do_idle();
+	}
+
+	return 0;
+}
+
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx6_suspend_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Called before devices are re-setup.
+ */
+static void mx6_suspend_finish(void)
+{
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx6_suspend_end(void)
+{
+}
+
+static int mx6_pm_valid(suspend_state_t state)
+{
+	return (state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX);
+}
+
+struct platform_suspend_ops mx6_suspend_ops = {
+	.valid = mx6_pm_valid,
+	.prepare = mx6_suspend_prepare,
+	.enter = mx6_suspend_enter,
+	.finish = mx6_suspend_finish,
+	.end = mx6_suspend_end,
+};
+
+static int __devinit mx6_pm_probe(struct platform_device *pdev)
+{
+	pm_dev = &pdev->dev;
+	pm_data = pdev->dev.platform_data;
+
+	return 0;
+}
+
+static struct platform_driver mx6_pm_driver = {
+	.driver = {
+		   .name = "imx_pm",
+		   },
+	.probe = mx6_pm_probe,
+};
+
+static int __init pm_init(void)
+{
+	scu_base = IO_ADDRESS(SCU_BASE_ADDR);
+	gpc_base = IO_ADDRESS(GPC_BASE_ADDR);
+	src_base = IO_ADDRESS(SRC_BASE_ADDR);
+	gic_dist_base = IO_ADDRESS(IC_DISTRIBUTOR_BASE_ADDR);
+	gic_cpu_base = IO_ADDRESS(IC_INTERFACES_BASE_ADDR);
+	local_twd_base = IO_ADDRESS(LOCAL_TWD_ADDR);
+	anatop_base = IO_ADDRESS(ANATOP_BASE_ADDR);
+
+	pr_info("Static Power Management for Freescale i.MX6\n");
+
+	if (platform_driver_register(&mx6_pm_driver) != 0) {
+		printk(KERN_ERR "mx6_pm_driver register failed\n");
+		return -ENODEV;
+	}
+
+	suspend_set_ops(&mx6_suspend_ops);
+	/* Move suspend routine into iRAM */
+	cpaddr = (unsigned long)iram_alloc(SZ_4K, &iram_paddr);
+	/* Need to remap the area here since we want the memory region
+		 to be executable. */
+	suspend_iram_base = __arm_ioremap(iram_paddr, SZ_4K,
+					  MT_MEMORY_NONCACHED);
+	pr_info("cpaddr = %x suspend_iram_base=%x\n",
+		(unsigned int)cpaddr, (unsigned int)suspend_iram_base);
+
+	/*
+	 * Need to run the suspend code from IRAM as the DDR needs
+	 * to be put into low power mode manually.
+	 */
+	memcpy((void *)cpaddr, mx6q_suspend, SZ_4K);
+
+	suspend_in_iram = (void *)suspend_iram_base;
+
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(cpu_clk)) {
+		printk(KERN_DEBUG "%s: failed to get cpu_clk\n", __func__);
+		return PTR_ERR(cpu_clk);
+	}
+	printk(KERN_INFO "PM driver module loaded\n");
+
+	return 0;
+}
+
+static void __exit pm_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&mx6_pm_driver);
+}
+
+module_init(pm_init);
+module_exit(pm_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("PM driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-mxc/devices/Kconfig b/arch/arm/plat-mxc/devices/Kconfig
index e5938d8..4ca703b 100644
--- a/arch/arm/plat-mxc/devices/Kconfig
+++ b/arch/arm/plat-mxc/devices/Kconfig
@@ -119,3 +119,6 @@ config IMX_HAVE_PLATFORM_IMX_MIPI_CSI2
 
 config IMX_HAVE_PLATFORM_IMX_DVFS
 	bool
+
+config IMX_HAVE_PLATFORM_IMX_PM
+	bool
diff --git a/arch/arm/plat-mxc/devices/Makefile b/arch/arm/plat-mxc/devices/Makefile
index 9a23d7f..552f9b4 100644
--- a/arch/arm/plat-mxc/devices/Makefile
+++ b/arch/arm/plat-mxc/devices/Makefile
@@ -42,3 +42,4 @@ obj-$(CONFIG_IMX_HAVE_PLATFORM_LDB) += platform-imx_ldb.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_VPU) +=  platform-imx_vpu.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_MIPI_CSI2) += platform-imx-mipi_csi2.o
 obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_DVFS) +=  platform-imx_dvfs.o
+obj-$(CONFIG_IMX_HAVE_PLATFORM_IMX_PM) += platform-imx-pm.o
diff --git a/arch/arm/plat-mxc/devices/platform-imx-pm.c b/arch/arm/plat-mxc/devices/platform-imx-pm.c
new file mode 100644
index 0000000..f901e18
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-pm.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#include <asm/sizes.h>
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_pm_imx_data_entry_single(soc)		\
+	{					\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_pm_imx_data imx6q_pm_imx_data[] __initconst =
+	imx_pm_imx_data_entry_single(MX6Q);
+#endif
+
+struct platform_device *__init imx_add_pm_imx(
+		const struct imx_pm_imx_data *data,
+		const struct pm_platform_data *pdata)
+{
+	struct resource res[] = {
+		{
+			.start = data->iobase,
+			.end = data->iobase + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+	};
+
+	return imx_add_platform_device("imx_pm", 0,
+			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
+}
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index 62a7444..bc3443f 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -485,3 +485,13 @@ struct platform_device *__init imx_add_dvfs_core(
 		const struct mxc_dvfs_platform_data *pdata);
 
 struct platform_device *__init imx_add_busfreq(void);
+
+#include <mach/imx-pm.h>
+struct imx_pm_imx_data {
+	int id;
+	resource_size_t iobase;
+	resource_size_t irq;
+};
+struct platform_device *__init imx_add_pm_imx(
+		const struct imx_pm_imx_data *data,
+		const struct pm_platform_data *pdata);
diff --git a/arch/arm/plat-mxc/include/mach/imx-pm.h b/arch/arm/plat-mxc/include/mach/imx-pm.h
new file mode 100644
index 0000000..f6d375a4
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/imx-pm.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+#ifndef __ASM_ARCH_IMX_PM_H
+#define __ASM_ARCH_IMX_PM_H
+
+/**
+ * struct pm_platform_data - optional platform data for pm on i.MX
+ *
+ */
+
+struct pm_platform_data {
+	char *name;
+	void (*suspend_enter) (void);
+	void (*suspend_exit) (void);
+};
+#endif /* __ASM_ARCH_IMX_PM_H */
-- 
1.7.9.7

