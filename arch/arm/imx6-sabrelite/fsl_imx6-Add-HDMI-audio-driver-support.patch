From 230c4712210c0ac2fa298a3c2bf93e2bc6b3ff04 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Fri, 14 Sep 2012 18:19:14 +0800
Subject: [PATCH 22/62] fsl_imx6: Add HDMI audio driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-mxc/devices/platform-imx-hdmi-soc-dai.c   |   47 +
 include/linux/mfd/mxc-hdmi-core.h                  |   63 +
 sound/soc/codecs/Kconfig                           |    3 +
 sound/soc/codecs/Makefile                          |    2 +
 sound/soc/codecs/mxc_hdmi.c                        |  442 +++++++
 sound/soc/imx/Kconfig                              |    8 +
 sound/soc/imx/Makefile                             |    4 +
 sound/soc/imx/hdmi_pcm.S                           |  237 ++++
 sound/soc/imx/imx-hdmi-dai.c                       |  129 ++
 sound/soc/imx/imx-hdmi-dma.c                       | 1248 ++++++++++++++++++++
 sound/soc/imx/imx-hdmi.c                           |   87 ++
 sound/soc/imx/imx-hdmi.h                           |   95 ++
 12 files changed, 2365 insertions(+)
 create mode 100644 arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
 create mode 100644 include/linux/mfd/mxc-hdmi-core.h
 create mode 100644 sound/soc/codecs/mxc_hdmi.c
 create mode 100644 sound/soc/imx/hdmi_pcm.S
 create mode 100644 sound/soc/imx/imx-hdmi-dai.c
 create mode 100644 sound/soc/imx/imx-hdmi-dma.c
 create mode 100644 sound/soc/imx/imx-hdmi.c
 create mode 100644 sound/soc/imx/imx-hdmi.h

diff --git a/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
new file mode 100644
index 0000000..813f954
--- /dev/null
+++ b/arch/arm/plat-mxc/devices/platform-imx-hdmi-soc-dai.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <mach/hardware.h>
+#include <mach/devices-common.h>
+
+#define imx_hdmi_soc_data_entry_single(soc)				\
+	{								\
+		.irq = soc ## _INT_HDMI_TX,				\
+	}
+
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_hdmi_soc_data imx6q_imx_hdmi_soc_dai_data __initconst =
+			imx_hdmi_soc_data_entry_single(MX6Q);
+#endif
+
+struct platform_device *__init imx_add_hdmi_soc_dai(
+		const struct imx_hdmi_soc_data *data)
+{
+	struct resource res[] = {
+		{
+			.start = data->irq,
+			.end = data->irq,
+			.flags = IORESOURCE_IRQ,
+		},
+	};
+
+	return imx_add_platform_device("imx-hdmi-soc-dai", 0,
+				res, ARRAY_SIZE(res), NULL, 0);
+}
diff --git a/include/linux/mfd/mxc-hdmi-core.h b/include/linux/mfd/mxc-hdmi-core.h
new file mode 100644
index 0000000..cf87502
--- /dev/null
+++ b/include/linux/mfd/mxc-hdmi-core.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+#ifndef __LINUX_MXC_HDMI_CORE_H_
+#define __LINUX_MXC_HDMI_CORE_H_
+
+#include <mach/mxc_edid.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#define IRQ_DISABLE_SUCCEED	0
+#define IRQ_DISABLE_FAIL	1
+
+bool hdmi_check_overflow(void);
+
+u8 hdmi_readb(unsigned int reg);
+void hdmi_writeb(u8 value, unsigned int reg);
+void hdmi_mask_writeb(u8 data, unsigned int addr, u8 shift, u8 mask);
+unsigned int hdmi_read4(unsigned int reg);
+void hdmi_write4(unsigned int value, unsigned int reg);
+
+void hdmi_irq_init(void);
+void hdmi_irq_enable(int irq);
+unsigned int hdmi_irq_disable(int irq);
+
+void hdmi_set_sample_rate(unsigned int rate);
+void hdmi_set_dma_mode(unsigned int dma_running);
+void hdmi_init_clk_regenerator(void);
+void hdmi_clk_regenerator_update_pixel_clock(u32 pixclock);
+
+void hdmi_set_edid_cfg(struct mxc_edid_cfg *cfg);
+void hdmi_get_edid_cfg(struct mxc_edid_cfg *cfg);
+
+extern int mxc_hdmi_ipu_id;
+extern int mxc_hdmi_disp_id;
+
+void hdmi_set_registered(int registered);
+int hdmi_get_registered(void);
+int mxc_hdmi_abort_stream(void);
+int mxc_hdmi_register_audio(struct snd_pcm_substream *substream);
+void mxc_hdmi_unregister_audio(struct snd_pcm_substream *substream);
+unsigned int hdmi_set_cable_state(unsigned int state);
+unsigned int hdmi_set_blank_state(unsigned int state);
+int check_hdmi_state(void);
+#endif
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index bff4601..33784b7 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -237,6 +237,9 @@ config SND_SOC_RT5631
 config SND_SOC_SGTL5000
 	tristate
 
+config SND_SOC_MXC_HDMI
+       tristate
+
 config SND_SOC_SIGMADSP
 	tristate
 	select CRC32
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index cb9919d..d6c1fea 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -21,6 +21,7 @@ snd-soc-cs4271-objs := cs4271.o
 snd-soc-cx20442-objs := cx20442.o
 snd-soc-da7210-objs := da7210.o
 snd-soc-dfbmcs320-objs := dfbmcs320.o
+snd-soc-mxc-hdmi-objs := mxc_hdmi.o
 snd-soc-dmic-objs := dmic.o
 snd-soc-jz4740-codec-objs := jz4740.o
 snd-soc-l3-objs := l3.o
@@ -118,6 +119,7 @@ obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
 obj-$(CONFIG_SND_SOC_AK4641)	+= snd-soc-ak4641.o
 obj-$(CONFIG_SND_SOC_AK4642)	+= snd-soc-ak4642.o
 obj-$(CONFIG_SND_SOC_AK4671)	+= snd-soc-ak4671.o
+obj-$(CONFIG_SND_SOC_MXC_HDMI)	+= snd-soc-mxc-hdmi.o
 obj-$(CONFIG_SND_SOC_ALC5623)    += snd-soc-alc5623.o
 obj-$(CONFIG_SND_SOC_ALC5632)	+= snd-soc-alc5632.o
 obj-$(CONFIG_SND_SOC_CQ0093VC) += snd-soc-cq93vc.o
diff --git a/sound/soc/codecs/mxc_hdmi.c b/sound/soc/codecs/mxc_hdmi.c
new file mode 100644
index 0000000..8c78676
--- /dev/null
+++ b/sound/soc/codecs/mxc_hdmi.c
@@ -0,0 +1,442 @@
+/*
+ * MXC HDMI ALSA Soc Codec Driver
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/fsl_devices.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/asoundef.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <mach/hardware.h>
+
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <mach/mxc_edid.h>
+#include <mach/mxc_hdmi.h>
+#include "../imx/imx-hdmi.h"
+
+struct mxc_hdmi_priv {
+	struct snd_soc_codec codec;
+	struct snd_card *card;	/* ALSA HDMI sound card handle */
+	struct snd_pcm *pcm;	/* ALSA hdmi driver type handle */
+	struct clk *isfr_clk;
+	struct clk *iahb_clk;
+};
+
+static struct mxc_edid_cfg edid_cfg;
+
+static unsigned int playback_rates[HDMI_MAX_RATES];
+static unsigned int playback_sample_size[HDMI_MAX_SAMPLE_SIZE];
+static unsigned int playback_channels[HDMI_MAX_CHANNEL_CONSTRAINTS];
+
+static struct snd_pcm_hw_constraint_list playback_constraint_rates;
+static struct snd_pcm_hw_constraint_list playback_constraint_bits;
+static struct snd_pcm_hw_constraint_list playback_constraint_channels;
+
+#ifdef DEBUG
+static void dumpregs(void)
+{
+	int n, cts;
+
+	cts = (hdmi_readb(HDMI_AUD_CTS3) << 16) |
+	      (hdmi_readb(HDMI_AUD_CTS2) << 8) |
+	      hdmi_readb(HDMI_AUD_CTS1);
+
+	n = (hdmi_readb(HDMI_AUD_N3) << 16) |
+	    (hdmi_readb(HDMI_AUD_N2) << 8) |
+	    hdmi_readb(HDMI_AUD_N1);
+
+	pr_debug("\n");
+	pr_debug("HDMI_PHY_CONF0      0x%02x\n", hdmi_readb(HDMI_PHY_CONF0));
+	pr_debug("HDMI_MC_CLKDIS      0x%02x\n", hdmi_readb(HDMI_MC_CLKDIS));
+	pr_debug("HDMI_AUD_N[1-3]     0x%06x (decimal %d)\n", n, n);
+	pr_debug("HDMI_AUD_CTS[1-3]   0x%06x (decimal %d)\n", cts, cts);
+	pr_debug("HDMI_FC_AUDSCONF    0x%02x\n", hdmi_readb(HDMI_FC_AUDSCONF));
+}
+#else
+static void dumpregs(void) {}
+#endif
+
+static void hdmi_set_audio_flat(u8 value)
+{
+	/* Indicates the subpacket represents a flatline sample */
+	hdmi_mask_writeb(value, HDMI_FC_AUDSCONF,
+			 HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET,
+			 HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK);
+}
+
+static void hdmi_set_layout(unsigned int channels)
+{
+	hdmi_mask_writeb((channels > 2) ? 1 : 0, HDMI_FC_AUDSCONF,
+			HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET,
+			HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK);
+}
+
+static void hdmi_set_audio_infoframe(void)
+{
+	/* set to 0: means "refer to stream header" */
+	hdmi_writeb(0x00, HDMI_FC_AUDICONF0);
+	hdmi_writeb(0x00, HDMI_FC_AUDICONF1);
+	hdmi_writeb(0x00, HDMI_FC_AUDICONF2);
+}
+
+static int cea_audio_rates[HDMI_MAX_RATES] = {
+	32000,
+	44100,
+	48000,
+	88200,
+	96000,
+	176400,
+	192000,
+};
+
+static void mxc_hdmi_get_playback_rates(void)
+{
+	int i, count = 0;
+	u8 rates;
+
+	/* always assume basic audio support */
+	rates = edid_cfg.sample_rates | 0x7;
+
+	for (i = 0 ; i < HDMI_MAX_RATES ; i++)
+		if ((rates & (1 << i)) != 0)
+			playback_rates[count++] = cea_audio_rates[i];
+
+	playback_constraint_rates.list = playback_rates;
+	playback_constraint_rates.count = count;
+
+#ifdef DEBUG
+	for (i = 0 ; i < playback_constraint_rates.count ; i++)
+		pr_debug("%s: constraint = %d Hz\n", __func__,
+			 playback_rates[i]);
+#endif
+}
+
+static void mxc_hdmi_get_playback_sample_size(void)
+{
+	int i = 0;
+
+	/* always assume basic audio support */
+	playback_sample_size[i++] = 16;
+
+	if (edid_cfg.sample_sizes & 0x4)
+		playback_sample_size[i++] = 24;
+
+	playback_constraint_bits.list = playback_sample_size;
+	playback_constraint_bits.count = i;
+
+#ifdef DEBUG
+	for (i = 0 ; i < playback_constraint_bits.count ; i++)
+		pr_debug("%s: constraint = %d bits\n", __func__,
+			 playback_sample_size[i]);
+#endif
+}
+
+static void mxc_hdmi_get_playback_channels(void)
+{
+	int channels = 2, i = 0;
+
+	/* always assume basic audio support */
+	playback_channels[i++] = channels;
+	channels += 2;
+
+	while ((i < HDMI_MAX_CHANNEL_CONSTRAINTS) &&
+		(channels <= edid_cfg.max_channels)) {
+		playback_channels[i++] = channels;
+		channels += 2;
+	}
+
+	playback_constraint_channels.list = playback_channels;
+	playback_constraint_channels.count = i;
+
+#ifdef DEBUG
+	for (i = 0 ; i < playback_constraint_channels.count ; i++)
+		pr_debug("%s: constraint = %d channels\n", __func__,
+			 playback_channels[i]);
+#endif
+}
+
+static int mxc_hdmi_update_constraints(struct mxc_hdmi_priv *priv,
+				       struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	hdmi_get_edid_cfg(&edid_cfg);
+
+	mxc_hdmi_get_playback_rates();
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					SNDRV_PCM_HW_PARAM_RATE,
+					&playback_constraint_rates);
+	if (ret < 0)
+		return ret;
+
+	mxc_hdmi_get_playback_sample_size();
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+					&playback_constraint_bits);
+	if (ret < 0)
+		return ret;
+
+	mxc_hdmi_get_playback_channels();
+	ret = snd_pcm_hw_constraint_list(runtime, 0,
+					SNDRV_PCM_HW_PARAM_CHANNELS,
+					&playback_constraint_channels);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int mxc_hdmi_codec_startup(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct mxc_hdmi_priv *hdmi_priv = snd_soc_dai_get_drvdata(dai);
+	int ret;
+
+	clk_enable(hdmi_priv->isfr_clk);
+	clk_enable(hdmi_priv->iahb_clk);
+
+	pr_debug("%s hdmi clks: isfr:%d iahb:%d\n", __func__,
+		(int)clk_get_rate(hdmi_priv->isfr_clk),
+		(int)clk_get_rate(hdmi_priv->iahb_clk));
+
+	ret = mxc_hdmi_update_constraints(hdmi_priv, substream);
+	if (ret < 0)
+		return ret;
+
+	hdmi_set_audio_flat(0);
+	hdmi_set_audio_infoframe();
+
+	return 0;
+}
+
+static int mxc_hdmi_codec_prepare(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	hdmi_set_layout(runtime->channels);
+	hdmi_set_sample_rate(runtime->rate);
+	dumpregs();
+
+	return 0;
+}
+
+static void mxc_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
+				   struct snd_soc_dai *dai)
+{
+	struct mxc_hdmi_priv *hdmi_priv = snd_soc_dai_get_drvdata(dai);
+
+	clk_disable(hdmi_priv->iahb_clk);
+	clk_disable(hdmi_priv->isfr_clk);
+}
+
+/*
+ * IEC60958 status functions
+ */
+static int mxc_hdmi_iec_info(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;
+	uinfo->count = 1;
+
+	return 0;
+}
+
+static int mxc_hdmi_iec_get(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+
+	for (i = 0 ; i < 4 ; i++)
+		uvalue->value.iec958.status[i] = iec_header.status[i];
+
+	return 0;
+}
+
+static int mxc_hdmi_iec_put(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *uvalue)
+{
+	int i;
+
+	/* Do not allow professional mode */
+	if (uvalue->value.iec958.status[0] & IEC958_AES0_PROFESSIONAL)
+		return -EPERM;
+
+	for (i = 0 ; i < 4 ; i++) {
+		iec_header.status[i] = uvalue->value.iec958.status[i];
+		pr_debug("%s status[%d]=0x%02x\n", __func__, i,
+			 iec_header.status[i]);
+	}
+
+	return 0;
+}
+
+static struct snd_kcontrol_new mxc_hdmi_ctrls[] = {
+	/* status cchanel controller */
+	{
+	 .iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
+	 .access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_WRITE |
+		SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = mxc_hdmi_iec_info,
+	 .get = mxc_hdmi_iec_get,
+	 .put = mxc_hdmi_iec_put,
+	 },
+};
+
+static struct snd_soc_dai_ops mxc_hdmi_codec_dai_ops = {
+	.startup = mxc_hdmi_codec_startup,
+	.prepare = mxc_hdmi_codec_prepare,
+	.shutdown = mxc_hdmi_codec_shutdown,
+};
+
+static struct snd_soc_dai_driver mxc_hdmi_codec_dai = {
+	.name = "mxc-hdmi-soc",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = MXC_HDMI_RATES_PLAYBACK,
+		.formats = MXC_HDMI_FORMATS_PLAYBACK,
+	},
+	.ops = &mxc_hdmi_codec_dai_ops,
+};
+
+static int mxc_hdmi_codec_soc_probe(struct snd_soc_codec *codec)
+{
+	struct mxc_hdmi_priv *hdmi_priv;
+	int ret = 0;
+
+	if (!hdmi_get_registered())
+		return -ENOMEM;
+
+	hdmi_priv = kzalloc(sizeof(struct mxc_hdmi_priv), GFP_KERNEL);
+	if (hdmi_priv == NULL)
+		return -ENOMEM;
+
+	hdmi_priv->isfr_clk = clk_get(NULL, "hdmi_isfr_clk");
+	if (IS_ERR(hdmi_priv->isfr_clk)) {
+		ret = PTR_ERR(hdmi_priv->isfr_clk);
+		pr_err("%s Unable to get HDMI isfr clk: %d\n", __func__, ret);
+		goto e_clk_get1;
+	}
+
+	hdmi_priv->iahb_clk = clk_get(NULL, "hdmi_iahb_clk");
+	if (IS_ERR(hdmi_priv->iahb_clk)) {
+		ret = PTR_ERR(hdmi_priv->iahb_clk);
+		pr_err("%s Unable to get HDMI iahb clk: %d\n", __func__, ret);
+		goto e_clk_get2;
+	}
+
+	ret = snd_soc_add_codec_controls(codec, mxc_hdmi_ctrls,
+			     ARRAY_SIZE(mxc_hdmi_ctrls));
+	if (ret)
+		goto e_add_ctrls;
+
+	snd_soc_codec_set_drvdata(codec, hdmi_priv);
+
+	return 0;
+
+e_add_ctrls:
+	clk_put(hdmi_priv->iahb_clk);
+e_clk_get2:
+	clk_put(hdmi_priv->isfr_clk);
+e_clk_get1:
+	kfree(hdmi_priv);
+	return ret;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_hdmi = {
+	.probe = mxc_hdmi_codec_soc_probe,
+};
+
+static int __devinit mxc_hdmi_codec_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+
+	dev_info(&pdev->dev, "MXC HDMI Audio\n");
+
+	ret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_hdmi,
+				     &mxc_hdmi_codec_dai, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register codec\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int __devexit mxc_hdmi_codec_remove(struct platform_device *pdev)
+{
+	struct mxc_hdmi_priv *hdmi_priv = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_codec(&pdev->dev);
+	platform_set_drvdata(pdev, NULL);
+	kfree(hdmi_priv);
+
+	return 0;
+}
+
+struct platform_driver mxc_hdmi_driver = {
+	.driver = {
+		   .name = "mxc_hdmi_soc",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mxc_hdmi_codec_probe,
+	.remove = __devexit_p(mxc_hdmi_codec_remove),
+};
+
+static int __init mxc_hdmi_codec_init(void)
+{
+	return platform_driver_register(&mxc_hdmi_driver);
+}
+
+static void __exit mxc_hdmi_codec_exit(void)
+{
+	return platform_driver_unregister(&mxc_hdmi_driver);
+}
+
+module_init(mxc_hdmi_codec_init);
+module_exit(mxc_hdmi_codec_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC HDMI Audio");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 810acaa..f975d8a 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -76,4 +76,12 @@ config SND_SOC_EUKREA_TLV320
 	  Enable I2S based access to the TLV320AIC23B codec attached
 	  to the SSI interface
 
+config SND_SOC_IMX_HDMI
+	tristate "SoC Audio support for IMX - HDMI"
+	default n
+	select SND_SOC_MXC_HDMI
+	select MFD_MXC_HDMI
+	help
+	  Say Y if you want to add support for SoC audio through IMX HDMI.
+
 endif	# SND_IMX_SOC
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index f5db3e9..139e666 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -15,8 +15,12 @@ snd-soc-eukrea-tlv320-objs := eukrea-tlv320.o
 snd-soc-phycore-ac97-objs := phycore-ac97.o
 snd-soc-mx27vis-aic32x4-objs := mx27vis-aic32x4.o
 snd-soc-wm1133-ev1-objs := wm1133-ev1.o
+snd-soc-imx-hdmi-objs := imx-hdmi.o imx-hdmi-dai.o imx-hdmi-dma.o hdmi_pcm.o
 
 obj-$(CONFIG_SND_SOC_EUKREA_TLV320) += snd-soc-eukrea-tlv320.o
 obj-$(CONFIG_SND_SOC_PHYCORE_AC97) += snd-soc-phycore-ac97.o
 obj-$(CONFIG_SND_SOC_MX27VIS_AIC32X4) += snd-soc-mx27vis-aic32x4.o
 obj-$(CONFIG_SND_MXC_SOC_WM1133_EV1) += snd-soc-wm1133-ev1.o
+obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
+
+AFLAGS_hdmi_pcm.o := -march=armv7-a -mtune=cortex-a8 -mfpu=neon -mfloat-abi=softfp
diff --git a/sound/soc/imx/hdmi_pcm.S b/sound/soc/imx/hdmi_pcm.S
new file mode 100644
index 0000000..770a584
--- /dev/null
+++ b/sound/soc/imx/hdmi_pcm.S
@@ -0,0 +1,237 @@
+/*
+*  Copyright (C) 2010-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+
+* You should have received a copy of the GNU General Public License along
+* with this program; if not, write to the Free Software Foundation, Inc.,
+* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+*/
+
+.section .text
+
+.global hdmi_dma_copy_16_neon_lut
+.global hdmi_dma_copy_16_neon_fast
+.global hdmi_dma_copy_24_neon_lut
+.global hdmi_dma_copy_24_neon_fast
+
+
+/* hdmi_dma_copy_16_neon_lut
+ * Convert pcm sample to iec sample. Pcm sample is 16 bits.
+ * Frame index is between 0 and 47 inclusively. Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4. Sample count should be multipliable by 8.
+ *
+ * C Prototype
+ *   void hdmi_dma_copy_16_neon_lut(unsigned short *src, unsigned int *dst,
+ *							int samples, unsigned char *lookup_table);
+ * Return value
+ *   None
+ * Parameters
+ *   src                     Source PCM16 samples
+ *   dst                     Dest buffer to store pcm with header
+ *   samples             Contains sample count (=frame_count * channel_count)
+ *   lookup_table       Preconstructed header table. Channels interleaved.
+ */
+
+hdmi_dma_copy_16_neon_lut:
+	mov     r12, #1               /* construct vector(1) */
+	vdup.8 d6, r12
+
+hdmi_dma_copy_16_neon_lut_start:
+
+	/* get 8 samples to q0 */
+	vld1.16 {d0, d1}, [r0]! /* TODO: aligned */
+
+/*	pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q1, q0              /* count of 1s */
+	vpadd.i8 d2, d2, d3         /* only care about the least bit in every element */
+	vand       d2, d2, d6       /* clear other bits while keep the least bit */
+	vshl.u8    d2, d2, #3      /* bit p: d2 = d2 << 3 */
+
+	/* get packet header */
+	vld1.8       {d5}, [r3]!
+	veor        d4, d5, d2       /* xor bit c */
+
+	/* store: (d4 << 16 | q0) << 8 */
+	vmovl.u8  q2, d4          /* expand from char to short */
+	vzip.16     q0, q2
+	vshl.u32   q0, q0, #8
+	vshl.u32   q1, q2, #8
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_16_neon_lut_start
+
+	mov pc, lr
+
+/* hdmi_dma_copy_16_neon_fast
+ * Convert pcm sample to iec sample. Pcm sample is 16 bits.
+ * Frame index is between 48 and 191 inclusively. Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4. Sample count should be multipliable by 8.
+ *
+ * C Prototype
+ * void hdmi_dma_copy_16_neon_fast(unsigned short *src, unsigned int *dst, int samples);
+ * Return value
+ *   None
+ * Parameters
+ *   src                     Source PCM16 samples
+ *   dst                     Dest buffer to store pcm with header
+ *   samples             Contains sample count (=frame_count * channel_count)
+ */
+
+hdmi_dma_copy_16_neon_fast:
+	mov     r12, #1               /* construct vector(1) */
+	vdup.8 d6, r12
+
+hdmi_dma_copy_16_neon_fast_start:
+	/* get 8 samples to q0 */
+	vld1.16 {d0, d1}, [r0]!   /* TODO: aligned */
+
+/*	pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q1, q0             /* count of 1s */
+	vpadd.i8 d2, d2, d3
+	vand       d2, d2, d6       /* clear other bits while keep the least bit */
+	vshl.u8    d4, d2, #3      /* bit p: d2 = d2 << 3 */ /* finally we construct packet header */
+
+	/* get packet header: always 0 */
+
+	/* store: (d4 << 16 | q0) << 8 */
+	vmovl.u8  q2, d4          /* expand from char to short */
+	vzip.16     q0, q2
+	vshl.u32   q0, q0, #8
+	vshl.u32   q1, q2, #8
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_16_neon_fast_start
+
+	mov pc, lr
+
+
+
+/* hdmi_dma_copy_24_neon_lut
+ * Convert pcm sample to iec sample. Pcm sample is 24 bits.
+ * Frame index is between 0 and 47 inclusively. Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4. Sample count should be multipliable by 8.
+ *
+ * C Prototype
+ *   void hdmi_dma_copy_24_neon_lut(unsigned int *src, unsigned int *dst,
+ *						int samples, unsigned char *lookup_table);
+ * Return value
+ *   None
+ * Parameters
+ *   src                     Source PCM24 samples
+ *   dst                     Dest buffer to store pcm with header
+ *   samples             Contains sample count (=frame_count * channel_count)
+ *   lookup_table       Preconstructed header table. Channels interleaved.
+ */
+
+hdmi_dma_copy_24_neon_lut:
+	vpush   {d8}
+
+	mov     r12, #1               /* construct vector(1) */
+	vdup.8 d8, r12
+
+hdmi_dma_copy_24_neon_lut_start:
+
+	/* get 8 samples to q0 and q1 */
+	vld1.32 {d0, d1, d2, d3}, [r0]! /* TODO: aligned */
+
+/*	pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q2, q0              /* count of 1s */
+	vpadd.i8 d4, d4, d5         /* only care about the least bit in every element */
+	vcnt.8     q3, q1
+	vpadd.i8 d6, d6, d7
+	vpadd.i8 d4, d4, d6         /* d4: contains xor result and other dirty bits */
+	vand       d4, d4, d8       /* clear other bits while keep the least bit */
+	vshl.u8    d4, d4, #3      /* bit p: d4 = d4 << 3 */
+
+	/* get packet header */
+	vld1.8       {d5}, [r3]!    /* d5: original header */
+	veor        d5, d5, d4       /* fix bit p */
+
+	/* store: (d5 << 24 | q0) */
+	vmovl.u8  q3, d5          /* expand from char to short */
+	vmovl.u16 q2, d6         /* expand from short to int */
+	vmovl.u16 q3, d7
+	vshl.u32    q2, q2, #24
+	vshl.u32    q3, q3, #24
+	vorr          q0, q0, q2
+	vorr          q1, q1, q3
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_24_neon_lut_start
+
+	vpop {d8}
+	mov pc, lr
+
+/* hdmi_dma_copy_24_neon_fast
+ * Convert pcm sample to iec sample. Pcm sample is 24 bits.
+ * Frame index is between 48 and 191 inclusively. Channel count can be 1, 2, 4 or 8.
+ * Frame count should be multipliable by 4. Sample count should be multipliable by 8.
+ *
+ * C Prototype
+ * void hdmi_dma_copy_24_neon_fast(unsigned int *src, unsigned int *dst, int samples);
+ * Return value
+ *   None
+ * Parameters
+ *   src                     Source PCM24 samples
+ *   dst                     Dest buffer to store pcm with header
+ *   samples             Contains sample count (=frame_count * channel_count)
+ */
+
+hdmi_dma_copy_24_neon_fast:
+	vpush   {d8}
+
+	mov     r12, #1               /* construct vector(1) */
+	vdup.8 d8, r12
+
+hdmi_dma_copy_24_neon_fast_start:
+	/* get 8 samples to q0 and q1 */
+	vld1.32 {d0, d1, d2, d3}, [r0]! /* TODO: aligned */
+
+/*	pld [r1, #(64*4)] */
+
+	/* xor every bit */
+	vcnt.8     q2, q0              /* count of 1s */
+	vpadd.i8 d4, d4, d5         /* only care about the least bit in every element */
+	vcnt.8     q3, q1
+	vpadd.i8 d6, d6, d7
+	vpadd.i8 d4, d4, d6         /* d4: contains xor result and other dirty bits */
+	vand       d4, d4, d8       /* clear other bits while keep the least bit */
+	vshl.u8    d4, d4, #3      /* bit p: d4 = d4 << 3 */
+
+	/* store: (d4 << 24 | q0)  */
+	vmovl.u8  q3, d4          /* expand from char to short */
+	vmovl.u16 q2, d6         /* expand from short to int */
+	vmovl.u16 q3, d7
+	vshl.u32    q2, q2, #24
+	vshl.u32    q3, q3, #24
+	vorr          q0, q0, q2
+	vorr          q1, q1, q3
+	vst1.32     {d0, d1, d2, d3}, [r1]!
+
+	/* decrease sample count */
+	subs  r2, r2, #8
+	bne   hdmi_dma_copy_24_neon_fast_start
+
+	vpop {d8}
+	mov pc, lr
diff --git a/sound/soc/imx/imx-hdmi-dai.c b/sound/soc/imx/imx-hdmi-dai.c
new file mode 100644
index 0000000..6993e5c
--- /dev/null
+++ b/sound/soc/imx/imx-hdmi-dai.c
@@ -0,0 +1,129 @@
+/*
+ * ALSA SoC HDMI Audio Layer for MXS
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * Based on stmp3xxx_spdif_dai.c
+ * Vladimir Barinov <vbarinov@embeddedalley.com>
+ * Copyright 2008 SigmaTel, Inc
+ * Copyright 2008 Embedded Alley Solutions, Inc
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program  is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+#include <linux/mfd/mxc-hdmi-core.h>
+#include "imx-hdmi.h"
+
+static struct snd_soc_dai_driver imx_hdmi_dai = {
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = MXC_HDMI_RATES_PLAYBACK,
+		.formats = MXC_HDMI_FORMATS_PLAYBACK,
+	},
+};
+
+static int imx_hdmi_dai_probe(struct platform_device *pdev)
+{
+	struct imx_hdmi *hdmi_data;
+	int ret = 0;
+
+	if (!hdmi_get_registered())
+		return -ENOMEM;
+
+	hdmi_data = kzalloc(sizeof(*hdmi_data), GFP_KERNEL);
+	if (!hdmi_data)
+		return -ENOMEM;
+
+	dev_set_drvdata(&pdev->dev, hdmi_data);
+	hdmi_data->pdev = pdev;
+
+	hdmi_data->irq = platform_get_irq(pdev, 0);
+	if (hdmi_data->irq <= 0) {
+		dev_err(&pdev->dev, "MXC hdmi: invalid irq number (%d)\n",
+			hdmi_data->irq);
+		goto e_reg_dai;
+	}
+
+	ret = snd_soc_register_dai(&pdev->dev, &imx_hdmi_dai);
+	if (ret) {
+		dev_err(&pdev->dev, "register DAI failed\n");
+		goto e_reg_dai;
+	}
+
+	hdmi_data->soc_platform_pdev =
+		platform_device_alloc("imx-hdmi-soc-audio", 0);
+
+	if (!hdmi_data->soc_platform_pdev) {
+		dev_err(&pdev->dev, "failed platform_device_alloc\n");
+		goto e_alloc_dai;
+	}
+
+	platform_set_drvdata(hdmi_data->soc_platform_pdev, hdmi_data);
+
+	ret = platform_device_add(hdmi_data->soc_platform_pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add platform device\n");
+		platform_device_put(hdmi_data->soc_platform_pdev);
+		goto e_pdev_add;
+	}
+	printk("imx_hdmi_dai_probe probe finish\n");
+	return 0;
+e_pdev_add:
+	platform_device_put(hdmi_data->soc_platform_pdev);
+e_alloc_dai:
+	snd_soc_unregister_dai(&pdev->dev);
+e_reg_dai:
+	kfree(hdmi_data);
+	return ret;
+}
+
+static int __devexit imx_hdmi_dai_remove(struct platform_device *pdev)
+{
+	struct imx_hdmi *hdmi_data = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_dai(&pdev->dev);
+	kfree(hdmi_data);
+
+	return 0;
+}
+
+static struct platform_driver imx_hdmi_driver = {
+	.probe = imx_hdmi_dai_probe,
+	.remove = __devexit_p(imx_hdmi_dai_remove),
+	.driver = {
+		.name = "imx-hdmi-soc-dai",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init imx_hdmi_dai_init(void)
+{
+	return platform_driver_register(&imx_hdmi_driver);
+}
+
+static void __exit imx_hdmi_dai_exit(void)
+{
+	platform_driver_unregister(&imx_hdmi_driver);
+}
+
+module_init(imx_hdmi_dai_init);
+module_exit(imx_hdmi_dai_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX HDMI TX DAI");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-hdmi-dma.c b/sound/soc/imx/imx-hdmi-dma.c
new file mode 100644
index 0000000..e79fb41
--- /dev/null
+++ b/sound/soc/imx/imx-hdmi-dma.c
@@ -0,0 +1,1248 @@
+/*
+ * imx-hdmi-dma.c  --  HDMI DMA driver for ALSA Soc Audio Layer
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * based on imx-pcm-dma-mx2.c
+ * Copyright 2009 Sascha Hauer <s.hauer@pengutronix.de>
+ *
+ * This code is based on code copyrighted by Freescale,
+ * Liam Girdwood, Javier Martin and probably others.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <linux/mfd/mxc-hdmi-core.h>
+#include <mach/mxc_hdmi.h>
+#include "imx-hdmi.h"
+
+
+#define HDMI_DMA_BURST_UNSPECIFIED_LEGNTH	0
+#define HDMI_DMA_BURST_INCR4			1
+#define HDMI_DMA_BURST_INCR8			2
+#define HDMI_DMA_BURST_INCR16			3
+
+struct imx_hdmi_dma_runtime_data {
+	struct snd_pcm_substream *tx_substream;
+
+	unsigned long buffer_bytes;
+	struct snd_dma_buffer hw_buffer;
+	unsigned long appl_bytes;
+	int period_time;
+
+	int periods;
+	int period_bytes;
+	int dma_period_bytes;
+	int buffer_ratio;
+
+	unsigned long offset;
+
+	int channels;
+	snd_pcm_format_t format;
+	int rate;
+	int sample_align;
+	int sample_bits;
+
+	int frame_idx;
+
+	int irq;
+	struct clk *isfr_clk;
+	struct clk *iahb_clk;
+
+	bool tx_active;
+	spinlock_t irq_lock;
+};
+
+/* bit 0:0:0:b:p(0):c:(u)0:(v)0*/
+/* max 8 channels supported; channels are interleaved*/
+static unsigned char g_packet_head_table[48*8];
+
+void hdmi_dma_copy_16_neon_lut(unsigned short *src, unsigned int *dst,
+			int samples, unsigned char *lookup_table);
+void hdmi_dma_copy_16_neon_fast(unsigned short *src, unsigned int *dst,
+			int samples);
+void hdmi_dma_copy_24_neon_lut(unsigned int *src, unsigned int *dst,
+			int samples, unsigned char *lookup_table);
+void hdmi_dma_copy_24_neon_fast(unsigned int *src, unsigned int *dst,
+			int samples);
+
+hdmi_audio_header_t iec_header;
+
+/*
+ * Note that the period size for DMA != period size for ALSA because the
+ * driver adds iec frame info to the audio samples (in hdmi_dma_copy).
+ *
+ * Each 4 byte subframe = 1 byte of iec data + 3 byte audio sample.
+ *
+ * A 16 bit audio sample becomes 32 bits including the frame info. Ratio=2
+ * A 24 bit audio sample becomes 32 bits including the frame info. Ratio=3:4
+ * If the 24 bit raw audio is in 32 bit words, the
+ *
+ *  Original  Packed into  subframe  Ratio of size        Format
+ *   sample    how many      size    of DMA buffer
+ *   (bits)      bits                to ALSA buffer
+ *  --------  -----------  --------  --------------  ------------------------
+ *     16         16          32          2          SNDRV_PCM_FORMAT_S16_LE
+ *     24         24          32          1.33       SNDRV_PCM_FORMAT_S24_3LE*
+ *     24         32          32          1          SNDRV_PCM_FORMAT_S24_LE
+ *
+ * *so SNDRV_PCM_FORMAT_S24_3LE is not supported.
+ */
+
+/*
+ * The minimum dma period is one IEC audio frame (192 * 4 * channels).
+ * The maximum dma period for the HDMI DMA is 8K.
+ *
+ *   channels       minimum          maximum
+ *                 dma period       dma period
+ *   --------  ------------------   ----------
+ *       2     192 * 4 * 2 = 1536   * 4 = 6144
+ *       4     192 * 4 * 4 = 3072   * 2 = 6144
+ *       6     192 * 4 * 6 = 4608   * 1 = 4608
+ *       8     192 * 4 * 8 = 6144   * 1 = 6144
+ *
+ * Bottom line:
+ * 1. Must keep the ratio of DMA buffer to ALSA buffer consistent.
+ * 2. frame_idx is saved in the private data, so even if a frame cannot be
+ *    transmitted in a period, it can be continued in the next period.  This
+ *    is necessary for 6 ch.
+ */
+#define HDMI_DMA_PERIOD_BYTES		(6144)
+#define HDMI_DMA_BUF_SIZE		(64 * 1024)
+#define HDMI_PCM_BUF_SIZE		(64 * 1024)
+
+struct imx_hdmi_dma_runtime_data *hdmi_dma_priv;
+
+#ifdef DEBUG
+static void dumpregs(void)
+{
+	pr_debug("\n");
+	pr_debug("HDMI_AHB_DMA_CONF0           0x%02x\n", hdmi_readb(HDMI_AHB_DMA_CONF0));
+	pr_debug("HDMI_AHB_DMA_START           0x%02x\n", hdmi_readb(HDMI_AHB_DMA_START));
+	pr_debug("HDMI_AHB_DMA_STOP            0x%02x\n", hdmi_readb(HDMI_AHB_DMA_STOP));
+	pr_debug("HDMI_AHB_DMA_THRSLD          0x%02x\n", hdmi_readb(HDMI_AHB_DMA_THRSLD));
+	pr_debug("HDMI_AHB_DMA_STRADDR[0-3]    0x%08x\n", hdmi_read4(HDMI_AHB_DMA_STRADDR0));
+	pr_debug("HDMI_AHB_DMA_STPADDR[0-3]    0x%08x\n", hdmi_read4(HDMI_AHB_DMA_STPADDR0));
+	pr_debug("HDMI_AHB_DMA_BSTADDR[0-3]    0x%08x\n", hdmi_read4(HDMI_AHB_DMA_BSTADDR0));
+	pr_debug("HDMI_AHB_DMA_MBLENGTH0       0x%02x\n", hdmi_readb(HDMI_AHB_DMA_MBLENGTH0));
+	pr_debug("HDMI_AHB_DMA_MBLENGTH1       0x%02x\n", hdmi_readb(HDMI_AHB_DMA_MBLENGTH1));
+	pr_debug("HDMI_AHB_DMA_STAT            0x%02x\n", hdmi_readb(HDMI_AHB_DMA_STAT));
+	pr_debug("HDMI_AHB_DMA_INT             0x%02x\n", hdmi_readb(HDMI_AHB_DMA_INT));
+	pr_debug("HDMI_AHB_DMA_MASK            0x%02x\n", hdmi_readb(HDMI_AHB_DMA_MASK));
+	pr_debug("HDMI_AHB_DMA_POL             0x%02x\n", hdmi_readb(HDMI_AHB_DMA_POL));
+	pr_debug("HDMI_AHB_DMA_CONF1           0x%02x\n", hdmi_readb(HDMI_AHB_DMA_CONF1));
+	pr_debug("HDMI_AHB_DMA_BUFFSTAT        0x%02x\n", hdmi_readb(HDMI_AHB_DMA_BUFFSTAT));
+	pr_debug("HDMI_AHB_DMA_BUFFINT         0x%02x\n", hdmi_readb(HDMI_AHB_DMA_BUFFINT));
+	pr_debug("HDMI_AHB_DMA_BUFFMASK        0x%02x\n", hdmi_readb(HDMI_AHB_DMA_BUFFMASK));
+	pr_debug("HDMI_AHB_DMA_BUFFPOL         0x%02x\n", hdmi_readb(HDMI_AHB_DMA_BUFFPOL));
+	pr_debug("HDMI_IH_MUTE_AHBDMAAUD_STAT0 0x%02x\n", hdmi_readb(HDMI_IH_MUTE_AHBDMAAUD_STAT0));
+	pr_debug("HDMI_IH_AHBDMAAUD_STAT0      0x%02x\n", hdmi_readb(HDMI_IH_AHBDMAAUD_STAT0));
+	pr_debug("HDMI_IH_MUTE                 0x%02x\n", hdmi_readb(HDMI_IH_MUTE));
+	pr_debug("\n");
+}
+
+static void dumprtd(struct imx_hdmi_dma_runtime_data *rtd)
+{
+	pr_debug("\n");
+	pr_debug("channels         = %d\n", rtd->channels);
+	pr_debug("periods          = %d\n", rtd->periods);
+	pr_debug("period_bytes     = %d\n", rtd->period_bytes);
+	pr_debug("dma period_bytes = %d\n", rtd->dma_period_bytes);
+	pr_debug("buffer_ratio     = %d\n", rtd->buffer_ratio);
+	pr_debug("hw dma buffer    = 0x%08x\n", (int)rtd->hw_buffer.addr);
+	pr_debug("dma buf size     = %d\n", (int)rtd->buffer_bytes);
+	pr_debug("sample_rate      = %d\n", (int)rtd->rate);
+}
+#else
+static void dumpregs(void)
+{
+}
+
+static void dumprtd(struct imx_hdmi_dma_runtime_data *rtd)
+{
+}
+#endif
+
+static void hdmi_dma_start(void)
+{
+	hdmi_mask_writeb(1, HDMI_AHB_DMA_START,
+			HDMI_AHB_DMA_START_START_OFFSET,
+			HDMI_AHB_DMA_START_START_MASK);
+}
+
+static void hdmi_dma_stop(void)
+{
+	hdmi_mask_writeb(1, HDMI_AHB_DMA_STOP,
+			HDMI_AHB_DMA_STOP_STOP_OFFSET,
+			HDMI_AHB_DMA_STOP_STOP_MASK);
+}
+
+static void hdmi_fifo_reset(void)
+{
+	hdmi_mask_writeb(1, HDMI_AHB_DMA_CONF0,
+			 HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET,
+			 HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK);
+}
+
+/*
+ * Conditions for DMA to work:
+ * ((final_addr - initial_addr)>>2)+1) < 2k.  So max period is 8k.
+ * (inital_addr & 0x3) == 0
+ * (final_addr  & 0x3) == 0x3
+ *
+ * The DMA Period should be an integer multiple of the IEC 60958 audio
+ * frame size, which is 768 bytes (192 * 4).
+ */
+static void hdmi_dma_set_addr(int start_addr, int dma_period_bytes)
+{
+	int final_addr = start_addr + dma_period_bytes - 1;
+
+	hdmi_write4(start_addr, HDMI_AHB_DMA_STRADDR0);
+	hdmi_write4(final_addr, HDMI_AHB_DMA_STPADDR0);
+}
+
+static u8 hdmi_dma_get_irq_status(void)
+{
+	return hdmi_readb(HDMI_IH_AHBDMAAUD_STAT0);
+}
+
+static void hdmi_dma_clear_irq_status(u8 status)
+{
+	hdmi_writeb(status, HDMI_IH_AHBDMAAUD_STAT0);
+}
+
+static void hdmi_dma_irq_mask(int mask)
+{
+	u8 regvalue;
+	regvalue = hdmi_readb(HDMI_AHB_DMA_MASK);
+
+	if (mask) {
+		regvalue |= HDMI_AHB_DMA_DONE;
+		hdmi_writeb(regvalue, HDMI_AHB_DMA_MASK);
+	} else {
+		regvalue &= (u8)~HDMI_AHB_DMA_DONE;
+		hdmi_writeb(regvalue, HDMI_AHB_DMA_MASK);
+	}
+}
+
+static void hdmi_mask(int mask)
+{
+	u8 regvalue;
+	regvalue = hdmi_readb(HDMI_AHB_DMA_MASK);
+
+	if (mask) {
+		regvalue |= HDMI_AHB_DMA_ERROR | HDMI_AHB_DMA_FIFO_EMPTY;
+		hdmi_writeb(regvalue, HDMI_AHB_DMA_MASK);
+	} else {
+		regvalue &= (u8)~(HDMI_AHB_DMA_ERROR | HDMI_AHB_DMA_FIFO_EMPTY);
+		hdmi_writeb(regvalue, HDMI_AHB_DMA_MASK);
+	}
+}
+
+
+static void hdmi_dma_irq_mute(int mute)
+{
+	if (mute)
+		hdmi_writeb(0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+	else
+		hdmi_writeb(0x00, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
+}
+
+int odd_ones(unsigned a)
+{
+	a ^= a >> 8;
+	a ^= a >> 4;
+	a ^= a >> 2;
+	a ^= a >> 1;
+
+	return a & 1;
+}
+
+/* Add frame information for one pcm subframe */
+static u32 hdmi_dma_add_frame_info(struct imx_hdmi_dma_runtime_data *rtd,
+				   u32 pcm_data, int subframe_idx)
+{
+	hdmi_audio_dma_data_t subframe;
+
+	subframe.U = 0;
+	iec_header.B.channel = subframe_idx;
+
+	/* fill b (start-of-block) */
+	subframe.B.b = (rtd->frame_idx == 0) ? 1 : 0;
+
+	/* fill c (channel status) */
+	if (rtd->frame_idx < 42)
+		subframe.B.c = (iec_header.U >> rtd->frame_idx) & 0x1;
+	else
+		subframe.B.c = 0;
+
+	subframe.B.p = odd_ones(pcm_data);
+	subframe.B.p ^= subframe.B.c;
+	subframe.B.p ^= subframe.B.u;
+	subframe.B.p ^= subframe.B.v;
+
+	/* fill data */
+	if (rtd->sample_bits == 16)
+		subframe.B.data = pcm_data << 8;
+	else
+		subframe.B.data = pcm_data;
+
+	return subframe.U;
+}
+
+/* Increment the frame index.  We save frame_idx in case a frame
+ * spans more than one dma period. */
+static void hdmi_dma_incr_frame_idx(struct imx_hdmi_dma_runtime_data *rtd)
+{
+	rtd->frame_idx++;
+	if (rtd->frame_idx == 192)
+		rtd->frame_idx = 0;
+}
+
+static void init_table(int channels)
+{
+	int i;
+	int ch = 0;
+	unsigned char *p = g_packet_head_table;
+
+	for (i = 0; i < 48; i++) {
+		int b = 0;
+		if (i == 0)
+			b = 1;
+
+		for (ch = 0; ch < channels; ch++) {
+			int c = 0;
+			if (i < 42) {
+				iec_header.B.channel = ch+1;
+				c = (iec_header.U >> i) & 0x1;
+			}
+			/* preset bit p as c */
+			*p++ = (b << 4) | (c << 2) | (c << 3);
+		}
+	}
+}
+
+#if 1
+
+/* C code optimization for IEC head */
+static void hdmi_dma_copy_16_c_lut(unsigned short *src, unsigned int *dst, int samples, unsigned char *lookup_table)
+{
+	int i;
+	unsigned int sample;
+	unsigned int p;
+	unsigned int head;
+
+	for (i = 0; i < samples; i++) {
+		/* get source sample */
+		sample = *src++;
+
+		/* xor every bit */
+		p = sample ^ (sample >> 8);
+		p ^= (p >> 4);
+		p ^= (p >> 2);
+		p ^= (p >> 1);
+		p &= 1;	/* only want last bit */
+		p <<= 3; /* bit p */
+
+		/* get packet header */
+		head = *lookup_table++;
+
+		/* fix head */
+		head ^= p;
+
+		/* store */
+		*dst++ = (head << 24) | (sample << 8);
+	}
+}
+
+static void hdmi_dma_copy_16_c_fast(unsigned short *src, unsigned int *dst, int samples)
+{
+	int i;
+	unsigned int sample;
+	unsigned int p;
+
+	for (i = 0; i < samples; i++) {
+		/* get source sample */
+		sample = *src++;
+
+		/* xor every bit */
+		p = sample ^ (sample >> 8);
+		p ^= (p >> 4);
+		p ^= (p >> 2);
+		p ^= (p >> 1);
+		p &= 1;	/* only want last bit */
+		p <<= 3; /* bit p */
+
+		/* store */
+		*dst++ = (p << 24) | (sample << 8);
+	}
+}
+
+static void hdmi_dma_copy_16(unsigned short *src, unsigned int *dest, int framecount, int channelcount)
+{
+	/* split input frames into 192-frame each */
+	int count_in_192 = (framecount + 191) / 192;
+	int i;
+
+	for (i = 0; i < count_in_192; i++) {
+		int count;
+		int samples;
+
+		/* handles frame index [0, 48) */
+		count = (framecount < 48) ? framecount : 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_16_c_lut(src, dest, samples, g_packet_head_table);
+		framecount -= count;
+		if (framecount == 0)
+			break;
+
+		src  += samples;
+		dest += samples;
+
+		/* handles frame index [48, 192) */
+		count = (framecount < 192 - 48) ? framecount : 192 - 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_16_c_fast(src, dest, samples);
+		framecount -= count;
+		src  += samples;
+		dest += samples;
+	}
+}
+
+#else
+
+/* NEON optimization for IEC head*/
+
+/* Convert pcm samples to iec samples suitable for HDMI transfer.
+* PCM sample is 16 bits length.
+* Frame index always starts from 0.
+* Channel count can be 1, 2, 4, 6, or 8
+* Sample count (frame_count * channel_count) is multipliable by 8.
+*/
+static void hdmi_dma_copy_16(u16 *src, u32 *dest, int framecount, int channelcount)
+{
+	/* split input frames into 192-frame each */
+	int count_in_192 = (framecount + 191) / 192;
+	int i;
+
+	for (i = 0; i < count_in_192; i++) {
+		int count;
+		int samples;
+
+		/* handles frame index [0, 48) */
+		count = (framecount < 48) ? framecount : 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_16_neon_lut(src, dest, samples, g_packet_head_table);
+		framecount -= count;
+		if (framecount == 0)
+			break;
+
+		src  += samples;
+		dest += samples;
+
+		/* handles frame index [48, 192) */
+		count = (framecount < 192 - 48) ? framecount : 192 - 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_16_neon_fast(src, dest, samples);
+		framecount -= count;
+		src  += samples;
+		dest += samples;
+	}
+}
+
+/* Convert pcm samples to iec samples suitable for HDMI transfer.
+* PCM sample is 24 bits length.
+* Frame index always starts from 0.
+* Channel count can be 1, 2, 4, 6, or 8
+* Sample count (frame_count * channel_count) is multipliable by 8.
+*/
+static void hdmi_dma_copy_24(u32 *src, u32 *dest, int framecount, int channelcount)
+{
+	/* split input frames into 192-frame each */
+	int count_in_192 = (framecount + 191) / 192;
+	int i;
+
+	for (i = 0; i < count_in_192; i++) {
+		int count;
+		int samples;
+
+		/* handles frame index [0, 48) */
+		count = (framecount < 48) ? framecount : 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_24_neon_lut(src, dest, samples, g_packet_head_table);
+		framecount -= count;
+		if (framecount == 0)
+			break;
+
+		src  += samples;
+		dest += samples;
+
+		/* handles frame index [48, 192) */
+		count = (framecount < 192 - 48) ? framecount : 192 - 48;
+		samples = count * channelcount;
+		hdmi_dma_copy_24_neon_fast(src, dest, samples);
+		framecount -= count;
+		src  += samples;
+		dest += samples;
+	}
+}
+#endif
+
+static void hdmi_dma_mmap_copy(struct snd_pcm_substream *substream,
+			       int offset, int count)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+	u32 framecount;
+	u32 *src32, *dest;
+	u16 *src16;
+
+	framecount =  count/(rtd->sample_align * rtd->channels);
+
+	/* hw_buffer is the destination for pcm data plus frame info. */
+	dest = (u32 *)(rtd->hw_buffer.area + (offset * rtd->buffer_ratio));
+
+	switch (rtd->format) {
+
+	case SNDRV_PCM_FORMAT_S16_LE:
+		/* dma_buffer is the mmapped buffer we are copying pcm from. */
+		src16 = (u16 *)(runtime->dma_area + offset);
+		hdmi_dma_copy_16(src16, dest, framecount, rtd->channels);
+		break;
+
+/* 24bit not support now. */
+/*
+	case SNDRV_PCM_FORMAT_S24_LE:
+		src32 = (u32 *)(runtime->dma_area + offset);
+		hdmi_dma_copy_24(src32, dest, framecount, rtd->channels);
+		break;
+*/
+	default:
+		pr_err("%s HDMI Audio invalid sample format (%d)\n",
+						__func__, rtd->format);
+		return;
+	}
+}
+
+static irqreturn_t hdmi_dma_isr(int irq, void *dev_id)
+{
+	struct imx_hdmi_dma_runtime_data *rtd = dev_id;
+	struct snd_pcm_substream *substream = rtd->tx_substream;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	unsigned long offset,  count, space_to_end, appl_bytes;
+	unsigned long flags;
+	unsigned int status;
+
+	spin_lock_irqsave(&rtd->irq_lock, flags);
+
+	hdmi_dma_irq_mute(1);
+	status = hdmi_dma_get_irq_status();
+	hdmi_dma_clear_irq_status(status);
+
+	if (rtd->tx_active && (status & HDMI_IH_AHBDMAAUD_STAT0_DONE)) {
+		rtd->offset += rtd->period_bytes;
+		rtd->offset %= rtd->period_bytes * rtd->periods;
+
+		/* For mmap access, need to copy data from dma_buffer
+		 * to hw_buffer and add the frame info. */
+		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
+			appl_bytes = frames_to_bytes(runtime,
+						runtime->control->appl_ptr);
+
+			if (rtd->appl_bytes > appl_bytes) {
+				if (appl_bytes > rtd->buffer_bytes)
+					rtd->appl_bytes =
+						appl_bytes - rtd->buffer_bytes;
+				else
+					rtd->appl_bytes = 0;
+			} else {
+				if ((appl_bytes - rtd->appl_bytes) >
+						rtd->buffer_bytes)
+					rtd->appl_bytes =
+						appl_bytes - rtd->buffer_bytes;
+
+			}
+
+			offset = rtd->appl_bytes % rtd->buffer_bytes;
+			space_to_end = rtd->buffer_bytes - offset;
+			count = appl_bytes - rtd->appl_bytes;
+			if (count > rtd->buffer_bytes)
+				count = rtd->buffer_bytes;
+
+			rtd->appl_bytes = appl_bytes;
+
+			if (count <= space_to_end) {
+				hdmi_dma_mmap_copy(substream, offset, count);
+			} else {
+				hdmi_dma_mmap_copy(substream, offset, space_to_end);
+				hdmi_dma_mmap_copy(substream, 0, count - space_to_end);
+			}
+		}
+		snd_pcm_period_elapsed(substream);
+
+		hdmi_dma_set_addr(rtd->hw_buffer.addr +
+				(rtd->offset * rtd->buffer_ratio),
+				rtd->dma_period_bytes);
+		hdmi_dma_start();
+	}
+
+	hdmi_dma_irq_mute(0);
+
+	spin_unlock_irqrestore(&rtd->irq_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void hdmi_dma_enable_hlock(int enable)
+{
+	hdmi_mask_writeb(enable, HDMI_AHB_DMA_CONF0,
+			 HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET,
+			 HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK);
+}
+
+static void hdmi_dma_set_incr_type(int incr_type)
+{
+	u8 value = hdmi_readb(HDMI_AHB_DMA_CONF0) &
+			~(HDMI_AHB_DMA_CONF0_BURST_MODE |
+			  HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK);
+
+	switch (incr_type) {
+	case HDMI_DMA_BURST_UNSPECIFIED_LEGNTH:
+		break;
+	case HDMI_DMA_BURST_INCR4:
+		value |= HDMI_AHB_DMA_CONF0_BURST_MODE;
+		break;
+	case HDMI_DMA_BURST_INCR8:
+		value |= HDMI_AHB_DMA_CONF0_BURST_MODE |
+			 HDMI_AHB_DMA_CONF0_INCR8;
+		break;
+	case HDMI_DMA_BURST_INCR16:
+		value |= HDMI_AHB_DMA_CONF0_BURST_MODE |
+			 HDMI_AHB_DMA_CONF0_INCR16;
+		break;
+	default:
+		pr_err("%s: invalid increment type: %d", __func__, incr_type);
+		BUG();
+		return;
+	}
+
+	hdmi_writeb(value, HDMI_AHB_DMA_CONF0);
+}
+
+static void hdmi_dma_enable_channels(int channels)
+{
+	switch (channels) {
+	case 2:
+		hdmi_writeb(0x03, HDMI_AHB_DMA_CONF1);
+		break;
+	case 4:
+		hdmi_writeb(0x0f, HDMI_AHB_DMA_CONF1);
+		break;
+	case 6:
+		hdmi_writeb(0x3f, HDMI_AHB_DMA_CONF1);
+		break;
+	case 8:
+		hdmi_writeb(0xff, HDMI_AHB_DMA_CONF1);
+		break;
+	default:
+		WARN(1, "%s - invalid audio channels number: %d\n",
+			__func__, channels);
+		break;
+	}
+}
+
+static void hdmi_dma_configure_dma(int channels)
+{
+	hdmi_dma_enable_hlock(1);
+
+	switch (channels) {
+	case 2:
+		hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
+		hdmi_writeb(126, HDMI_AHB_DMA_THRSLD);
+		break;
+	case 4:
+	case 6:
+	case 8:
+		hdmi_dma_set_incr_type(HDMI_DMA_BURST_INCR4);
+		hdmi_writeb(124, HDMI_AHB_DMA_THRSLD);
+		break;
+	default:
+		pr_err("%s %dunsupport channel!\r\n", __func__, __LINE__);
+	}
+
+	hdmi_dma_enable_channels(channels);
+}
+
+
+static void hdmi_dma_init_iec_header(void)
+{
+	iec_header.U = 0;
+
+	iec_header.B.consumer = 0;		/* Consumer use */
+	iec_header.B.linear_pcm = 0;		/* linear pcm audio */
+	iec_header.B.copyright = 1;		/* no copyright */
+	iec_header.B.pre_emphasis = 0;		/* 2 channels without pre-emphasis */
+	iec_header.B.mode = 0;			/* Mode 0 */
+
+	iec_header.B.category_code = 0;
+
+	iec_header.B.source = 2;		/* stereo */
+	iec_header.B.channel = 0;
+
+	iec_header.B.sample_freq = 0x02;	/* 48 KHz */
+	iec_header.B.clock_acc = 0;		/* Level II */
+
+	iec_header.B.word_length = 0x02;	/* 16 bits */
+	iec_header.B.org_sample_freq = 0x0D;	/* 48 KHz */
+
+	iec_header.B.cgms_a = 0;	/* Copying is permitted without restriction */
+}
+
+static int hdmi_dma_update_iec_header(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+
+	iec_header.B.source = rtd->channels;
+
+	switch (rtd->rate) {
+	case 32000:
+		iec_header.B.sample_freq = 0x03;
+		iec_header.B.org_sample_freq = 0x0C;
+		break;
+	case 44100:
+		iec_header.B.sample_freq = 0x00;
+		iec_header.B.org_sample_freq = 0x0F;
+		break;
+	case 48000:
+		iec_header.B.sample_freq = 0x02;
+		iec_header.B.org_sample_freq = 0x0D;
+		break;
+	case 88200:
+		iec_header.B.sample_freq = 0x08;
+		iec_header.B.org_sample_freq = 0x07;
+		break;
+	case 96000:
+		iec_header.B.sample_freq = 0x0A;
+		iec_header.B.org_sample_freq = 0x05;
+		break;
+	case 176400:
+		iec_header.B.sample_freq = 0x0C;
+		iec_header.B.org_sample_freq = 0x03;
+		break;
+	case 192000:
+		iec_header.B.sample_freq = 0x0E;
+		iec_header.B.org_sample_freq = 0x01;
+		break;
+	default:
+		pr_err("HDMI Audio sample rate error");
+		return -EFAULT;
+	}
+
+	switch (rtd->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		iec_header.B.word_length = 0x02;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		iec_header.B.word_length = 0x0b;
+		break;
+	default:
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * The HDMI block transmits the audio data without adding any of the audio
+ * frame bits.  So we have to copy the raw dma data from the ALSA buffer
+ * to the DMA buffer, adding the frame information.
+ */
+static int hdmi_dma_copy(struct snd_pcm_substream *substream, int channel,
+			snd_pcm_uframes_t pos, void __user *buf,
+			snd_pcm_uframes_t frames)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+	unsigned int count = frames_to_bytes(runtime, frames);
+	unsigned int pos_bytes = frames_to_bytes(runtime, pos);
+	u32 *hw_buf;
+	int subframe_idx;
+	u32 pcm_data;
+
+	/* Copy pcm data from userspace and add frame info.
+	 * Destination is hw_buffer. */
+	hw_buf = (u32 *)(rtd->hw_buffer.area + (pos_bytes * rtd->buffer_ratio));
+
+	while (count > 0) {
+		for (subframe_idx = 1 ; subframe_idx <= rtd->channels ; subframe_idx++) {
+
+			if (copy_from_user(&pcm_data, buf, rtd->sample_align))
+				return -EFAULT;
+
+			buf += rtd->sample_align;
+			count -= rtd->sample_align;
+
+			/* Save the header info to the audio dma buffer */
+			*hw_buf++ = hdmi_dma_add_frame_info(rtd, pcm_data, subframe_idx);
+		}
+		hdmi_dma_incr_frame_idx(rtd);
+	}
+
+	return 0;
+}
+
+static int hdmi_dma_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+
+	rtd->buffer_bytes = params_buffer_bytes(params);
+	rtd->periods = params_periods(params);
+	rtd->period_bytes = params_period_bytes(params);
+	rtd->channels = params_channels(params);
+	rtd->format = params_format(params);
+	rtd->rate = params_rate(params);
+
+	rtd->offset = 0;
+	rtd->period_time = HZ / (params_rate(params) / params_period_size(params));
+
+	switch (rtd->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		rtd->buffer_ratio = 2;
+		rtd->sample_align = 2;
+		rtd->sample_bits = 16;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:	/* 24 bit audio in 32 bit word */
+		rtd->buffer_ratio = 1;
+		rtd->sample_align = 4;
+		rtd->sample_bits = 24;
+		break;
+	default:
+		pr_err("%s HDMI Audio invalid sample format (%d)\n",
+			__func__, rtd->format);
+		return -EINVAL;
+	}
+
+	rtd->dma_period_bytes = rtd->period_bytes * rtd->buffer_ratio;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	hdmi_dma_configure_dma(rtd->channels);
+	hdmi_dma_set_addr(rtd->hw_buffer.addr, rtd->dma_period_bytes);
+
+	dumprtd(rtd);
+
+	hdmi_dma_update_iec_header(substream);
+
+	/* Init par for mmap optimizate */
+	init_table(rtd->channels);
+
+	rtd->appl_bytes = 0;
+
+	return 0;
+}
+
+static int hdmi_dma_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+	unsigned long offset,  count, space_to_end, appl_bytes;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!check_hdmi_state())
+			return 0;
+		rtd->frame_idx = 0;
+		if (runtime->access == SNDRV_PCM_ACCESS_MMAP_INTERLEAVED) {
+			appl_bytes = frames_to_bytes(runtime,
+						runtime->control->appl_ptr);
+			/* If resume, the rtd->appl_bytes may stil
+			 * keep the old value but the control->
+			 * appl_ptr is clear. Reset it if this
+			 * misalignment happens*/
+			if (rtd->appl_bytes > appl_bytes) {
+				if (appl_bytes > rtd->buffer_bytes)
+					rtd->appl_bytes =
+						appl_bytes - rtd->buffer_bytes;
+				else
+					rtd->appl_bytes = 0;
+			} else {
+				if ((appl_bytes - rtd->appl_bytes) >
+						rtd->buffer_bytes)
+					rtd->appl_bytes =
+						appl_bytes - rtd->buffer_bytes;
+
+			}
+
+			offset = rtd->appl_bytes % rtd->buffer_bytes;
+			space_to_end = rtd->buffer_bytes - offset;
+			count = appl_bytes - rtd->appl_bytes;
+
+			if (count > rtd->buffer_bytes) {
+				pr_err("Error Count,ring buffer size[%ld], count[%ld]!\n",
+						rtd->buffer_bytes, count);
+				return -EINVAL;
+			}
+
+			rtd->appl_bytes = appl_bytes;
+
+			if (count <= space_to_end) {
+				hdmi_dma_mmap_copy(substream, offset, count);
+			} else {
+				hdmi_dma_mmap_copy(substream,
+						offset, space_to_end);
+				hdmi_dma_mmap_copy(substream,
+						0, count - space_to_end);
+			}
+
+		}
+		dumpregs();
+
+		hdmi_fifo_reset();
+		udelay(1);
+
+		hdmi_dma_priv->tx_active = true;
+		hdmi_dma_start();
+		hdmi_dma_irq_mask(0);
+		hdmi_set_dma_mode(1);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		hdmi_dma_priv->tx_active = false;
+		hdmi_dma_stop();
+		hdmi_set_dma_mode(0);
+		hdmi_dma_irq_mask(1);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static snd_pcm_uframes_t hdmi_dma_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+
+	return bytes_to_frames(substream->runtime, rtd->offset);
+}
+
+static struct snd_pcm_hardware snd_imx_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE |
+		SNDRV_PCM_INFO_RESUME,
+	.formats = MXC_HDMI_FORMATS_PLAYBACK,
+	.rate_min = 32000,
+	.channels_min = 2,
+	.channels_max = 8,
+	.buffer_bytes_max = HDMI_PCM_BUF_SIZE,
+	.period_bytes_min = HDMI_DMA_PERIOD_BYTES / 2,
+	.period_bytes_max = HDMI_DMA_PERIOD_BYTES / 2,
+	.periods_min = 8,
+	.periods_max = 8,
+	.fifo_size = 0,
+};
+
+static void hdmi_dma_irq_enable(struct imx_hdmi_dma_runtime_data *rtd)
+{
+	unsigned long flags;
+
+	hdmi_writeb(0xff, HDMI_AHB_DMA_POL);
+	hdmi_writeb(0xff, HDMI_AHB_DMA_BUFFPOL);
+
+	spin_lock_irqsave(&hdmi_dma_priv->irq_lock, flags);
+
+	hdmi_dma_clear_irq_status(0xff);
+	hdmi_dma_irq_mute(0);
+	hdmi_dma_irq_mask(0);
+
+	hdmi_mask(0);
+
+	spin_unlock_irqrestore(&hdmi_dma_priv->irq_lock, flags);
+
+}
+
+static void hdmi_dma_irq_disable(struct imx_hdmi_dma_runtime_data *rtd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtd->irq_lock, flags);
+
+	hdmi_dma_irq_mask(1);
+	hdmi_dma_irq_mute(1);
+	hdmi_dma_clear_irq_status(0xff);
+
+	hdmi_mask(1);
+
+	spin_unlock_irqrestore(&rtd->irq_lock, flags);
+}
+
+static int hdmi_dma_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	int ret;
+
+	runtime->private_data = hdmi_dma_priv;
+
+	clk_enable(hdmi_dma_priv->isfr_clk);
+	clk_enable(hdmi_dma_priv->iahb_clk);
+
+	pr_debug("%s hdmi clks: isfr:%d iahb:%d\n", __func__,
+		(int)clk_get_rate(hdmi_dma_priv->isfr_clk),
+		(int)clk_get_rate(hdmi_dma_priv->iahb_clk));
+
+	ret = mxc_hdmi_register_audio(substream);
+	if (ret < 0) {
+		pr_err("ERROR: HDMI is not ready!\n");
+		return ret;
+	}
+
+	hdmi_fifo_reset();
+
+	ret = snd_pcm_hw_constraint_integer(substream->runtime,
+			SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	snd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);
+
+	hdmi_dma_irq_enable(hdmi_dma_priv);
+
+	return 0;
+}
+
+static int hdmi_dma_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct imx_hdmi_dma_runtime_data *rtd = runtime->private_data;
+
+	hdmi_dma_irq_disable(rtd);
+	mxc_hdmi_unregister_audio(substream);
+
+	clk_disable(rtd->iahb_clk);
+	clk_disable(rtd->isfr_clk);
+
+	return 0;
+}
+
+static struct snd_pcm_ops imx_hdmi_dma_pcm_ops = {
+	.open		= hdmi_dma_open,
+	.close		= hdmi_dma_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= hdmi_dma_hw_params,
+	.trigger	= hdmi_dma_trigger,
+	.pointer	= hdmi_dma_pointer,
+	.copy		= hdmi_dma_copy,
+};
+
+static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_dma_buffer *hw_buffer = &hdmi_dma_priv->hw_buffer;
+
+	/* The 'dma_buffer' is the buffer alsa knows about.
+	 * It contains only raw audio. */
+	buf->area = dma_alloc_writecombine(pcm->card->dev,
+					   HDMI_PCM_BUF_SIZE,
+					   &buf->addr, GFP_KERNEL);
+
+	if (!buf->area) {
+		printk("Dma_alloc_writecombine: alloc buffer fail\n");
+		return -ENOMEM;
+	}
+
+	buf->bytes = HDMI_PCM_BUF_SIZE;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	hdmi_dma_priv->tx_substream = substream;
+
+	/* For mmap access, isr will copy from
+	 * the dma_buffer to the hw_buffer */
+	hw_buffer->area = dma_alloc_writecombine(pcm->card->dev,
+						HDMI_DMA_BUF_SIZE,
+						&hw_buffer->addr, GFP_KERNEL);
+	if (!hw_buffer->area)
+		return -ENOMEM;
+
+	hw_buffer->bytes = HDMI_DMA_BUF_SIZE;
+
+	return 0;
+}
+
+static u64 hdmi_dmamask = DMA_BIT_MASK(32);
+
+static int imx_hdmi_dma_pcm_new(struct snd_soc_pcm_runtime *rtd)
+
+{
+	struct snd_card *card = rtd->card->snd_card;
+	struct snd_pcm *pcm = rtd->pcm;
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &hdmi_dmamask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+	ret = imx_pcm_preallocate_dma_buffer(pcm,
+		SNDRV_PCM_STREAM_PLAYBACK);
+	if (ret)
+		goto out;
+out:
+	return ret;
+}
+
+static void imx_hdmi_dma_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	/* free each dma_buffer */
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+
+	/* free the hw_buffer */
+	buf = &hdmi_dma_priv->hw_buffer;
+	if (buf->area) {
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static struct snd_soc_platform_driver imx_soc_platform_mx2 = {
+	.ops		= &imx_hdmi_dma_pcm_ops,
+	.pcm_new	= imx_hdmi_dma_pcm_new,
+	.pcm_free	= imx_hdmi_dma_pcm_free,
+};
+
+static int __devinit imx_soc_platform_probe(struct platform_device *pdev)
+{
+	struct imx_hdmi *hdmi_drvdata = platform_get_drvdata(pdev);
+	int ret = 0;
+
+	hdmi_dma_priv = kzalloc(sizeof(*hdmi_dma_priv), GFP_KERNEL);
+	if (hdmi_dma_priv == NULL)
+		return -ENOMEM;
+	/*To alloc a buffer non cacheable for hdmi script use*/
+
+	hdmi_dma_priv->tx_active = false;
+	spin_lock_init(&hdmi_dma_priv->irq_lock);
+	hdmi_dma_priv->irq = hdmi_drvdata->irq;
+
+	hdmi_dma_init_iec_header();
+
+	hdmi_dma_priv->isfr_clk = clk_get(&pdev->dev, "hdmi_isfr_clk");
+	if (IS_ERR(hdmi_dma_priv->isfr_clk)) {
+		ret = PTR_ERR(hdmi_dma_priv->isfr_clk);
+		dev_err(&pdev->dev, "Unable to get HDMI isfr clk: %d\n", ret);
+		goto e_clk_get1;
+	}
+
+	hdmi_dma_priv->iahb_clk = clk_get(&pdev->dev, "hdmi_iahb_clk");
+	if (IS_ERR(hdmi_dma_priv->iahb_clk)) {
+		ret = PTR_ERR(hdmi_dma_priv->iahb_clk);
+		dev_err(&pdev->dev, "Unable to get HDMI ahb clk: %d\n", ret);
+		goto e_clk_get2;
+	}
+
+	if (request_irq(hdmi_dma_priv->irq, hdmi_dma_isr, IRQF_SHARED,
+			"hdmi dma", hdmi_dma_priv)) {
+		dev_err(&pdev->dev, "MXC hdmi: failed to request irq %d\n",
+		       hdmi_dma_priv->irq);
+		ret = -EBUSY;
+		goto e_irq;
+	}
+	ret = snd_soc_register_platform(&pdev->dev, &imx_soc_platform_mx2);
+	if (ret)
+		goto e_irq;
+
+	printk("imx_soc_platform_probe probe successful\n");
+	return 0;
+
+e_irq:
+	clk_put(hdmi_dma_priv->iahb_clk);
+e_clk_get2:
+	clk_put(hdmi_dma_priv->isfr_clk);
+e_clk_get1:
+	kfree(hdmi_dma_priv);
+
+	return ret;
+}
+
+static int __devexit imx_soc_platform_remove(struct platform_device *pdev)
+{
+	free_irq(hdmi_dma_priv->irq, hdmi_dma_priv);
+	snd_soc_unregister_platform(&pdev->dev);
+	kfree(hdmi_dma_priv);
+	return 0;
+}
+
+static struct platform_driver imx_hdmi_dma_driver = {
+	.driver = {
+			.name = "imx-hdmi-soc-audio",
+			.owner = THIS_MODULE,
+	},
+	.probe = imx_soc_platform_probe,
+	.remove = __devexit_p(imx_soc_platform_remove),
+};
+
+static int __init hdmi_dma_init(void)
+{
+	return platform_driver_register(&imx_hdmi_dma_driver);
+}
+module_init(hdmi_dma_init);
+
+static void __exit hdmi_dma_exit(void)
+{
+	platform_driver_unregister(&imx_hdmi_dma_driver);
+}
+module_exit(hdmi_dma_exit);
diff --git a/sound/soc/imx/imx-hdmi.c b/sound/soc/imx/imx-hdmi.c
new file mode 100644
index 0000000..0e12acf
--- /dev/null
+++ b/sound/soc/imx/imx-hdmi.c
@@ -0,0 +1,87 @@
+/*
+ * ASoC HDMI Transmitter driver for IMX development boards
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ *
+ * based on stmp3780_devb_spdif.c
+ *
+ * Vladimir Barinov <vbarinov@embeddedalley.com>
+ *
+ * Copyright 2008 SigmaTel, Inc
+ * Copyright 2008 Embedded Alley Solutions, Inc
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program  is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+
+#include <mach/mxc_hdmi.h>
+#include <linux/mfd/mxc-hdmi-core.h>
+#include "imx-hdmi.h"
+
+/* imx digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link imx_hdmi_dai_link[] = {
+	{
+		.name = "IMX HDMI TX",
+		.stream_name = "IMX HDMI TX",
+		.codec_dai_name = "mxc-hdmi-soc",
+		.codec_name = "mxc_hdmi_soc.0",
+		.cpu_dai_name = "imx-hdmi-soc-dai.0",
+		.platform_name = "imx-hdmi-soc-audio.0",
+	},
+};
+
+static struct snd_soc_card snd_soc_card_imx_hdmi = {
+	.name		= "imx-hdmi-soc",
+	.dai_link	= imx_hdmi_dai_link,
+	.num_links	= ARRAY_SIZE(imx_hdmi_dai_link),
+};
+
+static struct platform_device *imx_snd_device;
+
+static int __init imx_audio_init(void)
+{
+	int ret;
+
+	if (!hdmi_get_registered())
+		return -ENOMEM;
+
+	imx_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!imx_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(imx_snd_device, &snd_soc_card_imx_hdmi);
+
+	ret = platform_device_add(imx_snd_device);
+	if (ret)
+		platform_device_put(imx_snd_device);
+
+	return ret;
+}
+module_init(imx_audio_init);
+
+static void __exit imx_audio_exit(void)
+{
+	platform_device_unregister(imx_snd_device);
+}
+module_exit(imx_audio_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("IMX HDMI TX ASoC driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-hdmi.h b/sound/soc/imx/imx-hdmi.h
new file mode 100644
index 0000000..1173757
--- /dev/null
+++ b/sound/soc/imx/imx-hdmi.h
@@ -0,0 +1,95 @@
+/*
+ * MXC HDMI ALSA Soc Codec Driver
+ *
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef __IMX_HDMI_H
+#define __IMX_HDMI_H
+
+#define DRV_NAME "imx-hdmi"
+
+struct imx_hdmi {
+	int irq;
+	struct platform_device *pdev;
+	struct platform_device *soc_platform_pdev;
+};
+
+#define HDMI_MAX_RATES 7
+#define HDMI_MAX_SAMPLE_SIZE 3
+#define HDMI_MAX_CHANNEL_CONSTRAINTS 4
+
+#define MXC_HDMI_RATES_PLAYBACK			(SNDRV_PCM_RATE_32000 | \
+						 SNDRV_PCM_RATE_44100 | \
+						 SNDRV_PCM_RATE_48000 | \
+						 SNDRV_PCM_RATE_88200 | \
+						 SNDRV_PCM_RATE_96000 | \
+						 SNDRV_PCM_RATE_176400 | \
+						 SNDRV_PCM_RATE_192000)
+
+#define MXC_HDMI_FORMATS_PLAYBACK		(SNDRV_PCM_FMTBIT_S16_LE | \
+						 SNDRV_PCM_FMTBIT_S24_LE)
+
+typedef union {
+	uint64_t  U;
+	struct {
+		unsigned consumer:1;
+		unsigned linear_pcm:1;
+		unsigned copyright:1;
+		unsigned pre_emphasis:3;
+		unsigned mode:2;
+
+		unsigned category_code:8;
+
+		unsigned source:4;
+		unsigned channel:4;
+
+		unsigned sample_freq:4;
+		unsigned clock_acc:2;
+		unsigned reserved0:2;
+
+		unsigned word_length:4;
+		unsigned org_sample_freq:4;
+
+		unsigned cgms_a:2;
+		unsigned reserved1:6;
+
+		unsigned reserved2:8;
+
+		unsigned reserved3:8;
+	} B;
+	unsigned char status[8];
+} hdmi_audio_header_t;
+
+typedef union {
+	uint32_t  U;
+	struct {
+		unsigned data:24;
+		unsigned v:1;
+		unsigned u:1;
+		unsigned c:1;
+		unsigned p:1;
+		unsigned b:1;
+		unsigned reserved:3;
+	} B;
+} hdmi_audio_dma_data_t;
+
+extern hdmi_audio_header_t iec_header;
+
+#endif /* __IMX_HDMI_H */
-- 
1.7.9.7

