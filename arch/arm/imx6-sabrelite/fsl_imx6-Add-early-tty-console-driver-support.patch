From 0571541f6dcbdb52b161766a5a1cfbc57a93bc0d Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 13:41:59 +0800
Subject: [PATCH 47/62] fsl_imx6: Add early tty console driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c   |    6 +
 arch/arm/plat-mxc/cpu.c                   |   19 ++
 arch/arm/plat-mxc/include/mach/common.h   |    1 +
 arch/arm/plat-mxc/include/mach/mxc_uart.h |  268 +++++++++++++++++++++++++++++
 drivers/tty/serial/Makefile               |    1 +
 drivers/tty/serial/imx.c                  |    2 +
 drivers/tty/serial/mxc_uart_early.c       |  190 ++++++++++++++++++++
 7 files changed, 487 insertions(+)
 create mode 100644 arch/arm/plat-mxc/include/mach/mxc_uart.h
 create mode 100644 drivers/tty/serial/mxc_uart_early.c

diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index a99cb449..86f1cb0 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -79,6 +79,7 @@
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
 		PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
+void __init early_console_setup(unsigned long base, struct clk *clk);
 extern char *gp_reg_id;
 extern struct regulator *(*get_cpu_regulator)(void);
 extern void (*put_cpu_regulator)(void);
@@ -880,7 +881,12 @@ static void __init mx6_sabrelite_board_init(void)
 
 static void __init mx6_sabrelite_timer_init(void)
 {
+	struct clk *uart_clk;
+
 	mx6_clocks_init(32768, 24000000, 0, 0);
+
+	uart_clk = clk_get_sys("imx21-uart.0", NULL);
+	early_console_setup(UART2_BASE_ADDR, uart_clk);
 }
 
 static struct sys_timer mx6_sabrelite_timer = {
diff --git a/arch/arm/plat-mxc/cpu.c b/arch/arm/plat-mxc/cpu.c
index a4d29d8..3b416234 100644
--- a/arch/arm/plat-mxc/cpu.c
+++ b/arch/arm/plat-mxc/cpu.c
@@ -1,5 +1,6 @@
 
 #include <linux/module.h>
+#include <mach/mxc_uart.h>
 #include <linux/io.h>
 #include <mach/hardware.h>
 
@@ -65,3 +66,21 @@ void __init imx_set_aips(void __iomem *base)
 	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
 	__raw_writel(reg, base + 0x50);
 }
+
+/**
+ * early_console_setup - setup debugging console
+ *
+ * Consoles started here require little enough setup that we can start using
+ * them very early in the boot process, either right after the machine
+ * vector initialization, or even before if the drivers can detect their hw.
+ *
+ * Returns non-zero if a console couldn't be setup.
+ * This function is developed based on
+ * early_console_setup function as defined in arch/ia64/kernel/setup.c
+ */
+void __init early_console_setup(unsigned long base, struct clk *clk)
+{
+#ifdef CONFIG_SERIAL_IMX_CONSOLE
+	mxc_early_serial_console_init(base, clk);
+#endif
+}
diff --git a/arch/arm/plat-mxc/include/mach/common.h b/arch/arm/plat-mxc/include/mach/common.h
index 89eaeb7..b035176 100644
--- a/arch/arm/plat-mxc/include/mach/common.h
+++ b/arch/arm/plat-mxc/include/mach/common.h
@@ -150,6 +150,7 @@ extern void imx53_qsb_common_init(void);
 extern void imx53_smd_common_init(void);
 extern int imx6q_set_lpm(enum mxc_cpu_pwr_mode mode);
 extern void imx6q_clock_map_io(void);
+extern void early_console_setup(unsigned long base, struct clk *clk);
 
 #ifdef CONFIG_PM
 extern void imx6q_pm_init(void);
diff --git a/arch/arm/plat-mxc/include/mach/mxc_uart.h b/arch/arm/plat-mxc/include/mach/mxc_uart.h
new file mode 100644
index 0000000..29ed95d
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/mxc_uart.h
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2004-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup UART Universal Asynchronous Receiver Transmitter (UART) Driver
+ */
+
+/*!
+ * @file arch-mxc/mxc_uart.h
+ *
+ * @brief This file contains the UART configuration structure definition.
+ *
+ *
+ * @ingroup UART
+ */
+
+#ifndef __ASM_ARCH_MXC_UART_H__
+#define __ASM_ARCH_MXC_UART_H__
+
+#ifdef __KERNEL__
+
+#include <linux/serial_core.h>
+
+/*
+ * The modes of the UART ports
+ */
+#define MODE_DTE                0
+#define MODE_DCE                1
+/*
+ * Is the UART configured to be a IR port
+ */
+#define IRDA                    0
+#define NO_IRDA                 1
+
+/*!
+ * This structure is used to store the the physical and virtual
+ * addresses of the UART DMA receive buffer.
+ */
+typedef struct {
+	/*!
+	 * DMA Receive buffer virtual address
+	 */
+	char *rx_buf;
+	/*!
+	 * DMA Receive buffer physical address
+	 */
+	dma_addr_t rx_handle;
+} mxc_uart_rxdmamap;
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b uart_port structure. This structure includes the core \b uart_port
+ * structure that is provided by Linux as an element and has other
+ * elements that are specifically required by this low-level driver.
+ */
+typedef struct {
+	/*!
+	 * The port structure holds all the information about the UART
+	 * port like base address, and so on.
+	 */
+	struct uart_port port;
+	/*!
+	 * Flag to determine if the interrupts are muxed.
+	 */
+	int ints_muxed;
+	/*!
+	 * Array that holds the receive and master interrupt numbers
+	 * when the interrupts are not muxed.
+	 */
+	int irqs[2];
+	/*!
+	 * Flag to determine the DTE/DCE mode.
+	 */
+	int mode;
+	/*!
+	 * Flag to hold the IR mode of the port.
+	 */
+	int ir_mode;
+	/*!
+	 * Flag to enable/disable the UART port.
+	 */
+	int enabled;
+	/*!
+	 * Flag to indicate if we wish to use hardware-driven hardware
+	 * flow control.
+	 */
+	int hardware_flow;
+	/*!
+	 * Holds the threshold value at which the CTS line is deasserted in
+	 * case we use hardware-driven hardware flow control.
+	 */
+	unsigned int cts_threshold;
+	/*!
+	 * Flag to enable/disable DMA data transfer.
+	 */
+	int dma_enabled;
+	/*!
+	 * Holds the DMA receive buffer size.
+	 */
+	int dma_rxbuf_size;
+	/*!
+	 * DMA Receive buffers information
+	 */
+	mxc_uart_rxdmamap *rx_dmamap;
+	/*!
+	 * DMA RX buffer id
+	 */
+	int dma_rxbuf_id;
+	/*!
+	 * DMA Transmit buffer virtual address
+	 */
+	char *tx_buf;
+	/*!
+	 * DMA Transmit buffer physical address
+	 */
+	dma_addr_t tx_handle;
+	/*!
+	 * Holds the RxFIFO threshold value.
+	 */
+	unsigned int rx_threshold;
+	/*!
+	 * Holds the TxFIFO threshold value.
+	 */
+	unsigned int tx_threshold;
+	/*!
+	 * Information whether this is a shared UART
+	 */
+	unsigned int shared;
+	/*!
+	 * Clock id for UART clock
+	 */
+	struct clk *clk;
+	/*!
+	 * Information whether RXDMUXSEL must be set or not for IR port
+	 */
+	int rxd_mux;
+	int ir_tx_inv;
+	int ir_rx_inv;
+} uart_mxc_port;
+
+/* Address offsets of the UART registers */
+#define MXC_UARTURXD            0x000	/* Receive reg */
+#define MXC_UARTUTXD            0x040	/* Transmitter reg */
+#define	MXC_UARTUCR1            0x080	/* Control reg 1 */
+#define MXC_UARTUCR2            0x084	/* Control reg 2 */
+#define MXC_UARTUCR3            0x088	/* Control reg 3 */
+#define MXC_UARTUCR4            0x08C	/* Control reg 4 */
+#define MXC_UARTUFCR            0x090	/* FIFO control reg */
+#define MXC_UARTUSR1            0x094	/* Status reg 1 */
+#define MXC_UARTUSR2            0x098	/* Status reg 2 */
+#define MXC_UARTUESC            0x09C	/* Escape character reg */
+#define MXC_UARTUTIM            0x0A0	/* Escape timer reg */
+#define MXC_UARTUBIR            0x0A4	/* BRM incremental reg */
+#define MXC_UARTUBMR            0x0A8	/* BRM modulator reg */
+#define MXC_UARTUBRC            0x0AC	/* Baud rate count reg */
+#define MXC_UARTONEMS           0x0B0	/* One millisecond reg */
+#define MXC_UARTUTS             0x0B4	/* Test reg */
+#define MXC_UARTUMCR            0x0B8	/* RS485 Mode control */
+
+/* Bit definations of UCR1 */
+#define MXC_UARTUCR1_ADEN       0x8000
+#define MXC_UARTUCR1_ADBR       0x4000
+#define MXC_UARTUCR1_TRDYEN     0x2000
+#define MXC_UARTUCR1_IDEN       0x1000
+#define MXC_UARTUCR1_RRDYEN     0x0200
+#define MXC_UARTUCR1_RXDMAEN    0x0100
+#define MXC_UARTUCR1_IREN       0x0080
+#define MXC_UARTUCR1_TXMPTYEN   0x0040
+#define MXC_UARTUCR1_RTSDEN     0x0020
+#define MXC_UARTUCR1_SNDBRK     0x0010
+#define MXC_UARTUCR1_TXDMAEN    0x0008
+#define MXC_UARTUCR1_ATDMAEN    0x0004
+#define MXC_UARTUCR1_DOZE       0x0002
+#define MXC_UARTUCR1_UARTEN     0x0001
+
+/* Bit definations of UCR2 */
+#define MXC_UARTUCR2_ESCI       0x8000
+#define MXC_UARTUCR2_IRTS       0x4000
+#define MXC_UARTUCR2_CTSC       0x2000
+#define MXC_UARTUCR2_CTS        0x1000
+#define MXC_UARTUCR2_PREN       0x0100
+#define MXC_UARTUCR2_PROE       0x0080
+#define MXC_UARTUCR2_STPB       0x0040
+#define MXC_UARTUCR2_WS         0x0020
+#define MXC_UARTUCR2_RTSEN      0x0010
+#define MXC_UARTUCR2_ATEN       0x0008
+#define MXC_UARTUCR2_TXEN       0x0004
+#define MXC_UARTUCR2_RXEN       0x0002
+#define MXC_UARTUCR2_SRST       0x0001
+
+/* Bit definations of UCR3 */
+#define MXC_UARTUCR3_DTREN      0x2000
+#define MXC_UARTUCR3_PARERREN   0x1000
+#define MXC_UARTUCR3_FRAERREN   0x0800
+#define MXC_UARTUCR3_DSR        0x0400
+#define MXC_UARTUCR3_DCD        0x0200
+#define MXC_UARTUCR3_RI         0x0100
+#define MXC_UARTUCR3_RXDSEN     0x0040
+#define MXC_UARTUCR3_AWAKEN     0x0010
+#define MXC_UARTUCR3_DTRDEN     0x0008
+#define MXC_UARTUCR3_RXDMUXSEL  0x0004
+#define MXC_UARTUCR3_INVT       0x0002
+
+/* Bit definations of UCR4 */
+#define MXC_UARTUCR4_CTSTL_OFFSET       10
+#define MXC_UARTUCR4_CTSTL_MASK         (0x3F << 10)
+#define MXC_UARTUCR4_INVR               0x0200
+#define MXC_UARTUCR4_ENIRI              0x0100
+#define MXC_UARTUCR4_REF16              0x0040
+#define MXC_UARTUCR4_IRSC               0x0020
+#define MXC_UARTUCR4_TCEN               0x0008
+#define MXC_UARTUCR4_OREN               0x0002
+#define MXC_UARTUCR4_DREN               0x0001
+
+/* Bit definations of UFCR */
+#define MXC_UARTUFCR_RFDIV              0x0200	/* Ref freq div is set to 2 */
+#define MXC_UARTUFCR_RFDIV_OFFSET       7
+#define MXC_UARTUFCR_RFDIV_MASK         (0x7 << 7)
+#define MXC_UARTUFCR_TXTL_OFFSET        10
+#define MXC_UARTUFCR_DCEDTE             0x0040
+
+/* Bit definations of URXD */
+#define MXC_UARTURXD_ERR        0x4000
+#define MXC_UARTURXD_OVRRUN     0x2000
+#define MXC_UARTURXD_FRMERR     0x1000
+#define MXC_UARTURXD_BRK        0x0800
+#define MXC_UARTURXD_PRERR      0x0400
+
+/* Bit definations of USR1 */
+#define MXC_UARTUSR1_PARITYERR  0x8000
+#define MXC_UARTUSR1_RTSS       0x4000
+#define MXC_UARTUSR1_TRDY       0x2000
+#define MXC_UARTUSR1_RTSD       0x1000
+#define MXC_UARTUSR1_FRAMERR    0x0400
+#define MXC_UARTUSR1_RRDY       0x0200
+#define MXC_UARTUSR1_AGTIM      0x0100
+#define MXC_UARTUSR1_DTRD       0x0080
+#define MXC_UARTUSR1_AWAKE      0x0010
+
+/* Bit definations of USR2 */
+#define MXC_UARTUSR2_TXFE       0x4000
+#define MXC_UARTUSR2_IDLE       0x1000
+#define MXC_UARTUSR2_RIDELT     0x0400
+#define MXC_UARTUSR2_RIIN       0x0200
+#define MXC_UARTUSR2_DCDDELT    0x0040
+#define MXC_UARTUSR2_DCDIN      0x0020
+#define MXC_UARTUSR2_TXDC       0x0008
+#define MXC_UARTUSR2_ORE        0x0002
+#define MXC_UARTUSR2_RDR        0x0001
+#define MXC_UARTUSR2_BRCD       0x0004
+
+/* Bit definations of UTS */
+#define MXC_UARTUTS_LOOP        0x1000
+
+extern int mxc_early_serial_console_init(unsigned long base, struct clk *clk);
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_UART_H__ */
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index 7257c5d..5319510 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -79,3 +79,4 @@ obj-$(CONFIG_SERIAL_XILINX_PS_UART) += xilinx_uartps.o
 obj-$(CONFIG_SERIAL_SIRFSOC) += sirfsoc_uart.o
 obj-$(CONFIG_SERIAL_AR933X)   += ar933x_uart.o
 obj-$(CONFIG_SERIAL_EFM32_UART) += efm32-uart.o
+obj-$(CONFIG_SERIAL_IMX_CONSOLE) += mxc_uart_early.o
diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 0de7ed7..dae1087 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -533,8 +533,10 @@ static irqreturn_t imx_rxint(int irq, void *dev_id)
 				continue;
 		}
 
+		spin_unlock_irqrestore(&sport->port.lock, flags);
 		if (uart_handle_sysrq_char(&sport->port, (unsigned char)rx))
 			continue;
+		spin_lock_irqsave(&sport->port.lock, flags);
 
 		if (unlikely(rx & URXD_ERR)) {
 			if (rx & URXD_BRK)
diff --git a/drivers/tty/serial/mxc_uart_early.c b/drivers/tty/serial/mxc_uart_early.c
new file mode 100644
index 0000000..c970dc6
--- /dev/null
+++ b/drivers/tty/serial/mxc_uart_early.c
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @file drivers/serial/mxc_uart_early.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC serial ports based on
+ * drivers/char/8250_early.c,
+ * Copyright 2004 Hewlett-Packard Development Company,
+ * L.P.by Bjorn Helgaasby.
+ *
+ * Early serial console for MXC UARTS.
+ *
+ * This is for use before the serial driver has initialized, in
+ * particular, before the UARTs have been discovered and named.
+ * Instead of specifying the console device as, e.g., "ttymxc0",
+ * we locate the device directly by its MMIO or I/O port address.
+ *
+ * The user can specify the device directly, e.g.,
+ *	console=mxcuart,0x43f90000,115200n8
+ * or platform code can call early_uart_console_init() to set
+ * the early UART device.
+ *
+ * After the normal serial driver starts, we try to locate the
+ * matching ttymxc device and start a console there.
+ */
+
+/*
+ * Include Files
+ */
+
+#include <linux/tty.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/clk.h>
+#include <mach/mxc_uart.h>
+
+struct mxc_early_uart_device {
+	struct uart_port port;
+	char options[16];	/* e.g., 115200n8 */
+	unsigned int baud;
+	struct clk *clk;
+};
+static struct mxc_early_uart_device mxc_early_device __initdata;
+
+/*
+ * Write out a character once the UART is ready
+ */
+static void __init mxcuart_console_write_char(struct uart_port *port, int ch)
+{
+	unsigned int status;
+
+	do {
+		status = readl(port->membase + MXC_UARTUSR2);
+	} while ((status & MXC_UARTUSR2_TXFE) == 0);
+	writel(ch, port->membase + MXC_UARTUTXD);
+}
+
+/*!
+ * This function is called to write the console messages through the UART port.
+ *
+ * @param   co    the console structure
+ * @param   s     the log message to be written to the UART
+ * @param   count length of the message
+ */
+void __init early_mxcuart_console_write(struct console *co, const char *s,
+					u_int count)
+{
+	struct uart_port *port = &mxc_early_device.port;
+	unsigned int status, oldcr1, oldcr2, oldcr3, cr2, cr3;
+
+	/*
+	 * First save the control registers and then disable the interrupts
+	 */
+	oldcr1 = readl(port->membase + MXC_UARTUCR1);
+	oldcr2 = readl(port->membase + MXC_UARTUCR2);
+	oldcr3 = readl(port->membase + MXC_UARTUCR3);
+	cr2 =
+	    oldcr2 & ~(MXC_UARTUCR2_ATEN | MXC_UARTUCR2_RTSEN |
+		       MXC_UARTUCR2_ESCI);
+	cr3 =
+	    oldcr3 & ~(MXC_UARTUCR3_DCD | MXC_UARTUCR3_RI |
+		       MXC_UARTUCR3_DTRDEN);
+	writel(MXC_UARTUCR1_UARTEN, port->membase + MXC_UARTUCR1);
+	writel(cr2, port->membase + MXC_UARTUCR2);
+	writel(cr3, port->membase + MXC_UARTUCR3);
+
+	/* Transmit string */
+	uart_console_write(port, s, count, mxcuart_console_write_char);
+
+	/*
+	 * Finally, wait for the transmitter to become empty
+	 */
+	do {
+		status = readl(port->membase + MXC_UARTUSR2);
+	} while (!(status & MXC_UARTUSR2_TXDC));
+
+	/*
+	 * Restore the control registers
+	 */
+	writel(oldcr1, port->membase + MXC_UARTUCR1);
+	writel(oldcr2, port->membase + MXC_UARTUCR2);
+	writel(oldcr3, port->membase + MXC_UARTUCR3);
+}
+
+static unsigned int __init probe_baud(struct uart_port *port)
+{
+	/* FIXME Return Default Baud Rate */
+	return 115200;
+}
+
+static int __init mxc_early_uart_setup(struct console *console, char *options)
+{
+	struct mxc_early_uart_device *device = &mxc_early_device;
+	struct uart_port *port = &device->port;
+	int length;
+
+	if (device->port.membase || device->port.iobase)
+		return -ENODEV;
+
+	/* Enable Early MXC UART Clock */
+	clk_enable(device->clk);
+
+	port->uartclk = 5600000;
+	port->iotype = UPIO_MEM;
+	port->membase = ioremap(port->mapbase, SZ_4K);
+
+	if (options) {
+		device->baud = simple_strtoul(options, NULL, 0);
+		length = min(strlen(options), sizeof(device->options));
+		strncpy(device->options, options, length);
+	} else {
+		device->baud = probe_baud(port);
+		snprintf(device->options, sizeof(device->options), "%u",
+			 device->baud);
+	}
+	printk(KERN_INFO
+	       "MXC_Early serial console at MMIO 0x%x (options '%s')\n",
+	       port->mapbase, device->options);
+	return 0;
+}
+
+static struct console mxc_early_uart_console __initdata = {
+	.name = "ttymxc",
+	.write = early_mxcuart_console_write,
+	.setup = mxc_early_uart_setup,
+	.flags = CON_PRINTBUFFER | CON_BOOT,
+	.index = -1,
+};
+
+int __init mxc_early_serial_console_init(unsigned long base, struct clk *clk)
+{
+	mxc_early_device.clk = clk;
+	mxc_early_device.port.mapbase = base;
+
+	register_console(&mxc_early_uart_console);
+	return 0;
+}
+
+int __init mxc_early_uart_console_disable(void)
+{
+	struct mxc_early_uart_device *device = &mxc_early_device;
+	struct uart_port *port = &device->port;
+
+	if (mxc_early_uart_console.index >= 0) {
+		iounmap(port->membase);
+		clk_disable(device->clk);
+		clk_put(device->clk);
+	}
+	return 0;
+}
+late_initcall(mxc_early_uart_console_disable);
-- 
1.7.9.7

