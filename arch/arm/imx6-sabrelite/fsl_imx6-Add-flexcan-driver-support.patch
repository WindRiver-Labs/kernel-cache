From 0007bfc1466aeef197056b9ca6d6adc0028ec4b7 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 15 Nov 2012 13:55:12 +0800
Subject: [PATCH 49/62] fsl_imx6: Add flexcan driver support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                       |    1 +
 arch/arm/mach-mx6/devices-imx6q.h               |    6 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c         |   32 ++++-
 arch/arm/plat-mxc/devices/platform-flexcan.c    |   22 +++-
 arch/arm/plat-mxc/include/mach/devices-common.h |    1 +
 drivers/net/can/flexcan.c                       |  145 ++++++++++++++++++++++-
 6 files changed, 198 insertions(+), 9 deletions(-)

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 2adcf44..e8c37e2 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -41,6 +41,7 @@ config MACH_MX6Q_SABRELITE
 	select IMX_HAVE_PLATFORM_IMX_MIPI_CSI2
 	select IMX_HAVE_PLATFORM_IMX_DVFS
 	select IMX_HAVE_PLATFORM_IMX_PM
+	select IMX_HAVE_PLATFORM_FLEXCAN
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index ac168b4..5f91102 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -148,4 +148,10 @@ extern const struct imx_dvfs_core_data imx6q_dvfs_core_data __initconst;
 extern const struct imx_pm_imx_data imx6q_pm_imx_data __initconst;
 #define imx6q_add_pm_imx(id, pdata)	\
 	imx_add_pm_imx(&imx6q_pm_imx_data, pdata)
+
+extern const struct imx_flexcan_data imx6q_flexcan_data[] __initconst;
+#define imx6q_add_flexcan(id, pdata)	\
+	imx_add_flexcan(&imx6q_flexcan_data[id], pdata)
+#define imx6q_add_flexcan0(pdata)	imx6q_add_flexcan(0, pdata)
+#define imx6q_add_flexcan1(pdata)	imx6q_add_flexcan(1, pdata)
 #endif
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 5a84552..e56a749 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -74,6 +74,8 @@
 #define MX6Q_SABRELITE_CAP_TCH_INT1	IMX_GPIO_NR(1, 9)
 #define MX6Q_SABRELITE_CSI0_RST		IMX_GPIO_NR(1, 8)
 #define MX6Q_SABRELITE_CSI0_PWN		IMX_GPIO_NR(1, 6)
+#define MX6Q_SABRELITE_CAN1_STBY	IMX_GPIO_NR(1, 2)
+#define MX6Q_SABRELITE_CAN1_EN		IMX_GPIO_NR(1, 4)
 
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
@@ -395,6 +397,27 @@ static struct i2c_board_info mxc_i2c2_board_info[] __initdata = {
 	},
 };
 
+static struct gpio mx6q_sabrelite_flexcan_gpios[] = {
+	{ MX6Q_SABRELITE_CAN1_EN, GPIOF_OUT_INIT_LOW, "flexcan1-en" },
+	{ MX6Q_SABRELITE_CAN1_STBY, GPIOF_OUT_INIT_LOW, "flexcan1-stby" },
+};
+
+static void mx6q_sabrelite_flexcan0_switch(int enable)
+{
+	if (enable) {
+		gpio_set_value(MX6Q_SABRELITE_CAN1_EN, 1);
+		gpio_set_value(MX6Q_SABRELITE_CAN1_STBY, 1);
+	} else {
+		gpio_set_value(MX6Q_SABRELITE_CAN1_EN, 0);
+		gpio_set_value(MX6Q_SABRELITE_CAN1_STBY, 0);
+	}
+}
+
+static const struct flexcan_platform_data
+	mx6q_sabrelite_flexcan0_pdata __initconst = {
+	.transceiver_switch = mx6q_sabrelite_flexcan0_switch,
+};
+
 static struct viv_gpu_platform_data imx6q_gpu_pdata __initdata = {
 	.reserved_mem_size = SZ_128M,
 };
@@ -808,7 +831,7 @@ static void __init mx6_sabrelite_board_init(void)
 	int i;
 	struct clk *clko2;
 	struct clk *new_parent;
-	int rate;
+	int rate, ret;
 
 	mxc_iomux_v3_setup_multiple_pads(mx6q_sabrelite_pads,
 					ARRAY_SIZE(mx6q_sabrelite_pads));
@@ -882,6 +905,13 @@ static void __init mx6_sabrelite_board_init(void)
 
 	imx6q_add_pm_imx(0, &mx6q_sabrelite_pm_data);
 
+	ret = gpio_request_array(mx6q_sabrelite_flexcan_gpios,
+			ARRAY_SIZE(mx6q_sabrelite_flexcan_gpios));
+	if (ret)
+		pr_err("failed to request flexcan1-gpios: %d\n", ret);
+	else
+		imx6q_add_flexcan0(&mx6q_sabrelite_flexcan0_pdata);
+
 	clko2 = clk_get(NULL, "clko2_clk");
 	if (IS_ERR(clko2))
 		pr_err("can't get CLKO2 clock.\n");
diff --git a/arch/arm/plat-mxc/devices/platform-flexcan.c b/arch/arm/plat-mxc/devices/platform-flexcan.c
index 4e8497a..f942ab4 100644
--- a/arch/arm/plat-mxc/devices/platform-flexcan.c
+++ b/arch/arm/plat-mxc/devices/platform-flexcan.c
@@ -8,21 +8,22 @@
 #include <mach/hardware.h>
 #include <mach/devices-common.h>
 
-#define imx_flexcan_data_entry_single(soc, _id, _hwid, _size)		\
+#define imx_flexcan_data_entry_single(soc, _devid, _id, _hwid, _size)	\
 	{								\
+		.devid = _devid,					\
 		.id = _id,						\
 		.iobase = soc ## _CAN ## _hwid ## _BASE_ADDR,		\
 		.iosize = _size,					\
 		.irq = soc ## _INT_CAN ## _hwid,			\
 	}
 
-#define imx_flexcan_data_entry(soc, _id, _hwid, _size)			\
-	[_id] = imx_flexcan_data_entry_single(soc, _id, _hwid, _size)
+#define imx_flexcan_data_entry(soc, _devid, _id, _hwid, _size)         \
+	[_id] = imx_flexcan_data_entry_single(soc, _devid, _id, _hwid, _size)
 
 #ifdef CONFIG_SOC_IMX25
 const struct imx_flexcan_data imx25_flexcan_data[] __initconst = {
 #define imx25_flexcan_data_entry(_id, _hwid)				\
-	imx_flexcan_data_entry(MX25, _id, _hwid, SZ_16K)
+	imx_flexcan_data_entry(MX25, "imx25-flexcan", _id, _hwid, SZ_16K)
 	imx25_flexcan_data_entry(0, 1),
 	imx25_flexcan_data_entry(1, 2),
 };
@@ -31,12 +32,21 @@ const struct imx_flexcan_data imx25_flexcan_data[] __initconst = {
 #ifdef CONFIG_SOC_IMX35
 const struct imx_flexcan_data imx35_flexcan_data[] __initconst = {
 #define imx35_flexcan_data_entry(_id, _hwid)				\
-	imx_flexcan_data_entry(MX35, _id, _hwid, SZ_16K)
+	imx_flexcan_data_entry(MX35, "imx35-flexcan", _id, _hwid, SZ_16K)
 	imx35_flexcan_data_entry(0, 1),
 	imx35_flexcan_data_entry(1, 2),
 };
 #endif /* ifdef CONFIG_SOC_IMX35 */
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_flexcan_data imx6q_flexcan_data[] __initconst = {
+#define imx6q_flexcan_data_entry(_id, _hwid)				\
+	imx_flexcan_data_entry(MX6Q, "imx6q-flexcan", _id, _hwid, SZ_16K)
+	imx6q_flexcan_data_entry(0, 1),
+	imx6q_flexcan_data_entry(1, 2),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q*/
+
 struct platform_device *__init imx_add_flexcan(
 		const struct imx_flexcan_data *data,
 		const struct flexcan_platform_data *pdata)
@@ -53,6 +63,6 @@ struct platform_device *__init imx_add_flexcan(
 		},
 	};
 
-	return imx_add_platform_device("flexcan", data->id,
+	return imx_add_platform_device(data->devid, data->id,
 			res, ARRAY_SIZE(res), pdata, sizeof(*pdata));
 }
diff --git a/arch/arm/plat-mxc/include/mach/devices-common.h b/arch/arm/plat-mxc/include/mach/devices-common.h
index bc3443f..42b26b1 100644
--- a/arch/arm/plat-mxc/include/mach/devices-common.h
+++ b/arch/arm/plat-mxc/include/mach/devices-common.h
@@ -52,6 +52,7 @@ struct platform_device *__init imx_add_fec(
 
 #include <linux/can/platform/flexcan.h>
 struct imx_flexcan_data {
+	const char *devid;
 	int id;
 	resource_size_t iobase;
 	resource_size_t iosize;
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 00baa7e..3b5c704 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -36,6 +36,10 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 
+#ifdef CONFIG_ARCH_MXC
+#include <mach/iomux-v3.h>
+#endif
+
 #define DRV_NAME			"flexcan"
 
 /* 8 for RX fifo and 2 error handling */
@@ -164,10 +168,22 @@ struct flexcan_regs {
 	u32 imask1;		/* 0x28 */
 	u32 iflag2;		/* 0x2c */
 	u32 iflag1;		/* 0x30 */
-	u32 _reserved2[19];
+	u32 crl2;		/* 0x34 */
+	u32 esr2;		/* 0x38 */
+	u32 _reserved2[2];
+	u32 crcr;		/* 0x44 */
+	u32 rxfgmask;		/* 0x48 */
+	u32 rxfir;		/* 0x4c */
+	u32 _reserved3[12];
 	struct flexcan_mb cantxfg[64];
 };
 
+enum flexcan_ip_version {
+	FLEXCAN_VER_3_0_0,
+	FLEXCAN_VER_3_0_4,
+	FLEXCAN_VER_10_0_12,
+};
+
 struct flexcan_priv {
 	struct can_priv can;
 	struct net_device *dev;
@@ -179,6 +195,8 @@ struct flexcan_priv {
 
 	struct clk *clk;
 	struct flexcan_platform_data *pdata;
+	enum flexcan_ip_version version;
+	int id;
 };
 
 static struct can_bittiming_const flexcan_bittiming_const = {
@@ -234,6 +252,31 @@ static inline int flexcan_has_and_handle_berr(const struct flexcan_priv *priv,
 		(reg_esr & FLEXCAN_ESR_ERR_BUS);
 }
 
+#ifdef CONFIG_ARCH_MXC
+static inline void flexcan_enter_stop(struct flexcan_priv *priv)
+{
+	/* enable stop request for wakeup */
+	if (priv->version >= FLEXCAN_VER_10_0_12)
+		/* CAN1/CAN2_STOP_REQ bit 28/29 in group 13 */
+		mxc_iomux_set_gpr_register(13, 28 + priv->id, 1, 1);
+
+	udelay(10);
+}
+
+static inline void flexcan_exit_stop(struct flexcan_priv *priv)
+{
+	/* remove stop request */
+	if (priv->version >= FLEXCAN_VER_10_0_12)
+		/* CAN1/CAN2_STOP_REQ bit 28/29 in group 13 */
+		mxc_iomux_set_gpr_register(13, 28 + priv->id, 1, 0);
+
+	udelay(10);
+}
+#else
+static inline void flexcan_enter_stop(struct flexcan_priv *priv) {}
+static inline void flexcan_exit_stop(struct flexcan_priv *priv) {}
+#endif
+
 static inline void flexcan_chip_enable(struct flexcan_priv *priv)
 {
 	struct flexcan_regs __iomem *regs = priv->base;
@@ -444,11 +487,15 @@ static void do_state(struct net_device *dev,
 static int flexcan_poll_state(struct net_device *dev, u32 reg_esr)
 {
 	struct flexcan_priv *priv = netdev_priv(dev);
+	struct flexcan_regs __iomem *regs = priv->base;
 	struct sk_buff *skb;
 	struct can_frame *cf;
 	enum can_state new_state;
 	int flt;
 
+	/* clear state error if any (write 1 to clear)*/
+	flexcan_write(reg_esr, &regs->esr);
+
 	flt = reg_esr & FLEXCAN_ESR_FLT_CONF_MASK;
 	if (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {
 		if (likely(!(reg_esr & (FLEXCAN_ESR_TX_WRN |
@@ -580,6 +627,10 @@ static irqreturn_t flexcan_irq(int irq, void *dev_id)
 	if (reg_esr & FLEXCAN_ESR_ALL_INT)
 		flexcan_write(reg_esr & FLEXCAN_ESR_ALL_INT, &regs->esr);
 
+	if (reg_esr & FLEXCAN_ESR_WAK_INT) {
+		flexcan_exit_stop(netdev_priv(dev));
+		writel(FLEXCAN_ESR_WAK_INT, &regs->esr);
+	}
 	/*
 	 * schedule NAPI in case of:
 	 * - rx IRQ
@@ -698,12 +749,15 @@ static int flexcan_chip_start(struct net_device *dev)
 	 * enable warning int
 	 * choose format C
 	 * disable local echo
+	 * enable self wakeup
 	 *
 	 */
 	reg_mcr = flexcan_read(&regs->mcr);
 	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_FEN | FLEXCAN_MCR_HALT |
 		FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN |
-		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_SRX_DIS;
+		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_SRX_DIS |
+		FLEXCAN_MCR_WAK_MSK | FLEXCAN_MCR_SLF_WAK;
+
 	netdev_dbg(dev, "%s: writing mcr=0x%08x", __func__, reg_mcr);
 	flexcan_write(reg_mcr, &regs->mcr);
 
@@ -749,6 +803,10 @@ static int flexcan_chip_start(struct net_device *dev)
 	flexcan_write(0x0, &regs->rx14mask);
 	flexcan_write(0x0, &regs->rx15mask);
 
+	/* clear rx fifo global mask */
+	if (priv->version >= FLEXCAN_VER_10_0_12)
+		flexcan_write(0x0, &regs->rxfgmask);
+
 	flexcan_transceiver_switch(priv, 1);
 
 	/* synchronize with the can bus */
@@ -921,6 +979,25 @@ static void __devexit unregister_flexcandev(struct net_device *dev)
 	unregister_candev(dev);
 }
 
+static struct platform_device_id flexcan_devtype[] = {
+	{
+		.name = "imx25-flexcan",
+		.driver_data = FLEXCAN_VER_3_0_0,
+	}, {
+		.name = "imx28-flexcan",
+		.driver_data = FLEXCAN_VER_3_0_4,
+	}, {
+		.name = "imx35-flexcan",
+		.driver_data = FLEXCAN_VER_3_0_0,
+	}, {
+		.name = "imx53-flexcan",
+		.driver_data = FLEXCAN_VER_3_0_0,
+	}, {
+		.name = "imx6q-flexcan",
+		.driver_data = FLEXCAN_VER_10_0_12,
+	},
+};
+
 static int __devinit flexcan_probe(struct platform_device *pdev)
 {
 	struct net_device *dev;
@@ -932,6 +1009,9 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 	int err, irq;
 	u32 clock_freq = 0;
 
+	if (pdev->id < 0)
+		return -ENODEV;
+
 	if (pdev->dev.of_node) {
 		const __be32 *clock_freq_p;
 
@@ -991,7 +1071,9 @@ static int __devinit flexcan_probe(struct platform_device *pdev)
 	priv->base = base;
 	priv->dev = dev;
 	priv->clk = clk;
+	priv->id = pdev->id;
 	priv->pdata = pdev->dev.platform_data;
+	priv->version = pdev->id_entry->driver_data;
 
 	netif_napi_add(dev, &priv->napi, flexcan_poll, FLEXCAN_NAPI_WEIGHT);
 
@@ -1043,6 +1125,62 @@ static int __devexit flexcan_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int flexcan_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct flexcan_priv *priv = netdev_priv(dev);
+	int ret;
+
+	flexcan_chip_disable(priv);
+
+	if (netif_running(dev)) {
+		netif_stop_queue(dev);
+		netif_device_detach(dev);
+
+		/* enter stop mode if device is up */
+		flexcan_enter_stop(priv);
+#ifdef CONFIG_ARCH_MXC
+		ret = irq_set_irq_wake(dev->irq, 1);
+		if (ret)
+			return ret;
+#endif
+	}
+
+	priv->can.state = CAN_STATE_SLEEPING;
+
+	return 0;
+}
+
+static int flexcan_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct flexcan_priv *priv = netdev_priv(dev);
+	int ret;
+
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	if (netif_running(dev)) {
+#ifdef CONFIG_ARCH_MXC
+		ret = irq_set_irq_wake(dev->irq, 0);
+		if (ret)
+			return ret;
+#endif
+		flexcan_exit_stop(priv);
+
+		netif_device_attach(dev);
+		netif_start_queue(dev);
+	}
+
+	flexcan_chip_enable(priv);
+
+	return 0;
+}
+#else
+#define flexcan_suspend NULL
+#define flexcan_resume NULL
+#endif
+
 static struct of_device_id flexcan_of_match[] = {
 	{
 		.compatible = "fsl,p1010-flexcan",
@@ -1057,7 +1195,10 @@ static struct platform_driver flexcan_driver = {
 		.of_match_table = flexcan_of_match,
 	},
 	.probe = flexcan_probe,
+	.id_table = flexcan_devtype,
 	.remove = __devexit_p(flexcan_remove),
+	.suspend = flexcan_suspend,
+	.resume = flexcan_resume,
 };
 
 module_platform_driver(flexcan_driver);
-- 
1.7.9.7

