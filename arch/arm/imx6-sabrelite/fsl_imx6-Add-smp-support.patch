From e9381e2532acf69284ee92a709fe1ebbfd298802 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 9 Aug 2012 09:13:22 +0800
Subject: [PATCH 02/62] fsl_imx6: Add smp support

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Makefile           |    4 +
 arch/arm/mach-mx6/headsmp.S          |   80 ++++++++++++++++++
 arch/arm/mach-mx6/plat_hotplug.c     |   97 ++++++++++++++++++++++
 arch/arm/mach-mx6/platsmp.c          |  152 ++++++++++++++++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/smp.h |   18 ++++
 5 files changed, 351 insertions(+)
 create mode 100644 arch/arm/mach-mx6/headsmp.S
 create mode 100644 arch/arm/mach-mx6/plat_hotplug.c
 create mode 100644 arch/arm/mach-mx6/platsmp.c
 create mode 100644 arch/arm/plat-mxc/include/mach/smp.h

diff --git a/arch/arm/mach-mx6/Makefile b/arch/arm/mach-mx6/Makefile
index 17c786e..0fac1af 100644
--- a/arch/arm/mach-mx6/Makefile
+++ b/arch/arm/mach-mx6/Makefile
@@ -8,3 +8,7 @@ obj-y   := cpu.o mm.o system.o irq.o bus_freq.o cpu_op-mx6.o mx6_wfi.o mx6_mmdc.
 
 obj-$(CONFIG_ARCH_MX6) += clock.o
 obj-$(CONFIG_MACH_MX6Q_SABRELITE) += mach-mx6q_sabrelite.o
+obj-$(CONFIG_CPU_V7) += headsmp.o
+AFLAGS_headsmp.o :=-Wa,-march=armv7-a
+obj-$(CONFIG_SMP) += platsmp.o
+obj-$(CONFIG_HOTPLUG_CPU) += plat_hotplug.o
diff --git a/arch/arm/mach-mx6/headsmp.S b/arch/arm/mach-mx6/headsmp.S
new file mode 100644
index 0000000..864d23d
--- /dev/null
+++ b/arch/arm/mach-mx6/headsmp.S
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+ENTRY(v7_invalidate_l1)
+	mov     r0, #0
+	mcr	p15, 0, r0, c7, c5, 0	@ invalidate I cache
+	mcr     p15, 2, r0, c0, c0, 0
+	mrc     p15, 1, r0, c0, c0, 0
+
+	ldr     r1, =0x7fff
+	and     r2, r1, r0, lsr #13
+
+	ldr     r1, =0x3ff
+
+	and     r3, r1, r0, lsr #3  @ NumWays - 1
+	add     r2, r2, #1          @ NumSets
+
+	and     r0, r0, #0x7
+	add     r0, r0, #4          @ SetShift
+
+	clz     r1, r3              @ WayShift
+	add     r4, r3, #1          @ NumWays
+1:	sub     r2, r2, #1          @ NumSets--
+	mov     r3, r4              @ Temp = NumWays
+2:	subs    r3, r3, #1          @ Temp--
+	mov     r5, r3, lsl r1
+	mov     r6, r2, lsl r0
+	orr     r5, r5, r6          @ Reg = (Temp<<WayShift)|(NumSets<<SetShift)
+	mcr     p15, 0, r5, c7, c6, 2
+	bgt     2b
+	cmp     r2, #0
+	bgt     1b
+	dsb
+	isb
+	mov     pc, lr
+ENDPROC(v7_invalidate_l1)
+
+	__CPUINIT
+ENTRY(mx6_secondary_startup)
+
+	/* Invalidate L1 I-cache first */
+	mov	r1,	#0x0
+	mcr p15, 0, r1, c7, c5, 0 @ Invalidate I-Cache
+	/* Invalidate L1 D-cache */
+	bl      v7_invalidate_l1
+	/* Set ARM working mode */
+	msr     cpsr_fsxc, #0xd3
+
+	mrc p15, 0, r0, c0, c0, 5
+	and r0, r0, #15
+	ldr r1, = 0x020d8020
+	add r1, r0, LSL#3
+
+	/*Clear SRC_GPR register */
+	mov r0, #0
+	str r0, [r1]
+	str r0, [r1, #0x4]
+
+	/* Jump to secondary_startup */
+	b secondary_startup
+
+ENDPROC(mx6_secondary_startup)
diff --git a/arch/arm/mach-mx6/plat_hotplug.c b/arch/arm/mach-mx6/plat_hotplug.c
new file mode 100644
index 0000000..4ae4676
--- /dev/null
+++ b/arch/arm/mach-mx6/plat_hotplug.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <linux/io.h>
+#include "src-reg.h"
+#include <linux/sched.h>
+#include <asm/cacheflush.h>
+
+static atomic_t cpu_die_done = ATOMIC_INIT(0);
+int platform_cpu_kill(unsigned int cpu)
+{
+	void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
+	unsigned int val;
+
+	val = jiffies;
+	/* wait secondary cpu to die, timeout is 50ms */
+	while (atomic_read(&cpu_die_done) == 0) {
+		if (time_after(jiffies, (unsigned long)(val + HZ / 20))) {
+			printk(KERN_WARNING "cpu %d: cpu could not die\n", cpu);
+			break;
+		}
+	}
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	val = __raw_readl(src_base + SRC_SCR_OFFSET);
+	val &= ~(1 << (BP_SRC_SCR_CORES_DBG_RST + cpu));
+	val |= (1 << (BP_SRC_SCR_CORE0_RST + cpu));
+	__raw_writel(val, src_base + SRC_SCR_OFFSET);
+
+	val = jiffies;
+	/* wait secondary cpu reset done, timeout is 10ms */
+	while ((__raw_readl(src_base + SRC_SCR_OFFSET) &
+		(1 << (BP_SRC_SCR_CORE0_RST + cpu))) != 0) {
+		if (time_after(jiffies, (unsigned long)(val + HZ / 100))) {
+			printk(KERN_WARNING "cpu %d: cpu reset fail\n", cpu);
+			break;
+		}
+	}
+
+	atomic_set(&cpu_die_done, 0);
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+	if (cpu == 0) {
+		printk(KERN_ERR "CPU0 can't be disabled!\n");
+		return;
+	}
+
+	flush_cache_all();
+	dsb();
+
+	/* tell cpu0 to kill me */
+	atomic_set(&cpu_die_done, 1);
+	for (;;) {
+		/*
+		 * Execute WFI
+		 */
+		cpu_do_idle();
+	}
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-mx6/platsmp.c b/arch/arm/mach-mx6/platsmp.c
new file mode 100644
index 0000000..aef9dcb
--- /dev/null
+++ b/arch/arm/mach-mx6/platsmp.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2011-2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <asm/cacheflush.h>
+#include <asm/mach-types.h>
+#include <asm/localtimer.h>
+#include <asm/smp_scu.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/mx6q.h>
+#include <mach/smp.h>
+#include "src-reg.h"
+
+static DEFINE_SPINLOCK(boot_lock);
+
+static void __iomem *scu_base_addr(void)
+{
+	return IO_ADDRESS(SCU_BASE_ADDR);
+}
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+
+	spin_lock(&boot_lock);
+	/*
+	* if any interrupts are already enabled for the primary
+	* core (e.g. timer irq), then they will not have been enabled
+	* for us: do so
+	*/
+	gic_secondary_init(0);
+
+	/*
+	* Synchronise with the boot thread.
+	*/
+
+	spin_unlock(&boot_lock);
+
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long boot_entry;
+	void __iomem *src_base = IO_ADDRESS(SRC_BASE_ADDR);
+	unsigned int val;
+
+	 /*
+	  * set synchronisation state between this boot processor
+	  * and the secondary one
+	  */
+	spin_lock(&boot_lock);
+
+	/* set entry point for cpu1-cpu3*/
+	boot_entry = virt_to_phys(mx6_secondary_startup);
+
+	writel(boot_entry, src_base + SRC_GPR1_OFFSET + 4 * 2 * cpu);
+	writel(0, src_base + SRC_GPR1_OFFSET + 4 * 2 * cpu + 4);
+
+	smp_wmb();
+	dsb();
+	flush_cache_all();
+
+	/* reset cpu<n> */
+	val = readl(src_base + SRC_SCR_OFFSET);
+	val |= 1 << (BP_SRC_SCR_CORE0_RST + cpu);
+	val |= 1 << (BP_SRC_SCR_CORES_DBG_RST + cpu);
+	writel(val, src_base + SRC_SCR_OFFSET);
+
+	/*
+	* now the secondary core is starting up let it run its
+	* calibrations, then wait for it to finish
+	*/
+	spin_unlock(&boot_lock);
+
+	return 0;
+
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	void __iomem *scu_base = scu_base_addr();
+	unsigned int i, ncores;
+
+	ncores = scu_base ? scu_get_core_count(scu_base) : 1;
+
+	/* sanity check */
+	if (ncores == 0) {
+		pr_err("mx6: strange CM count of 0? Default to 1\n");
+		ncores = 1;
+	}
+	if (ncores > NR_CPUS) {
+		pr_warning("mx6: no. of cores (%d) greater than configured "
+			"maximum of %d - clipping\n",
+			ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+static void __init wakeup_secondary(void)
+{
+
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+	void __iomem *scu_base = scu_base_addr();
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	/*
+	 * Initialise the SCU and wake up the secondary core using
+	 * wakeup_secondary().
+	 */
+	scu_enable(scu_base);
+	wakeup_secondary();
+}
diff --git a/arch/arm/plat-mxc/include/mach/smp.h b/arch/arm/plat-mxc/include/mach/smp.h
new file mode 100644
index 0000000..fcc4253
--- /dev/null
+++ b/arch/arm/plat-mxc/include/mach/smp.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef FSL_ARCH_SMP_H
+#define FSL_ARCH_SMP_H
+
+#include <asm/hardware/gic.h>
+
+/* Needed for secondary core boot */
+extern void mx6_secondary_startup(void);
+
+#endif
-- 
1.7.9.7

