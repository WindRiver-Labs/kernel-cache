From b9568a6c05c286e562a74579fdefecd380ac6a64 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Mon, 24 Dec 2012 13:22:14 +0800
Subject: [PATCH 18/62] fsl_imx6: add platform device register for SDHC device

Source: Extract from vendor-drop package, L3.0.15_12.04.01_ER_source.tar.gz
(May,2012).

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx6/Kconfig                          |    1 +
 arch/arm/mach-mx6/clock.c                          |    8 +-
 arch/arm/mach-mx6/devices-imx6q.h                  |    5 +
 arch/arm/mach-mx6/mach-mx6q_sabrelite.c            |  134 ++++++++++++++++++++
 .../plat-mxc/devices/platform-sdhci-esdhc-imx.c    |   23 ++++
 arch/arm/plat-mxc/include/mach/esdhc.h             |    2 +
 drivers/mmc/host/Kconfig                           |    2 +-
 drivers/mmc/host/sdhci-esdhc-imx.c                 |    3 +
 drivers/mmc/host/sdhci-esdhc.h                     |   11 ++
 9 files changed, 184 insertions(+), 5 deletions(-)

diff --git a/arch/arm/mach-mx6/Kconfig b/arch/arm/mach-mx6/Kconfig
index 91fe424..de7a096 100644
--- a/arch/arm/mach-mx6/Kconfig
+++ b/arch/arm/mach-mx6/Kconfig
@@ -20,6 +20,7 @@ config MACH_MX6Q_SABRELITE
 	select SOC_IMX6Q
 	select IMX_HAVE_PLATFORM_IMX_UART
 	select IMX_HAVE_PLATFORM_IMX_I2C
+	select IMX_HAVE_PLATFORM_SDHCI_ESDHC_IMX
 	help
 	  Include support for i.MX 6Quad SABRE Lite platform. This includes specific
 	  configurations for the board and its peripherals.
diff --git a/arch/arm/mach-mx6/clock.c b/arch/arm/mach-mx6/clock.c
index 03751b9..aca252c 100644
--- a/arch/arm/mach-mx6/clock.c
+++ b/arch/arm/mach-mx6/clock.c
@@ -5044,10 +5044,10 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK(NULL, "vpu_clk", vpu_clk[0]),
 	_REGISTER_CLOCK(NULL, "ipu1_clk", ipu1_clk),
 	_REGISTER_CLOCK(NULL, "ipu2_clk", ipu2_clk),
-	_REGISTER_CLOCK("sdhci-esdhc-imx.0", NULL, usdhc1_clk),
-	_REGISTER_CLOCK("sdhci-esdhc-imx.1", NULL, usdhc2_clk),
-	_REGISTER_CLOCK("sdhci-esdhc-imx.2", NULL, usdhc3_clk),
-	_REGISTER_CLOCK("sdhci-esdhc-imx.3", NULL, usdhc4_clk),
+	_REGISTER_CLOCK("sdhci-usdhc-imx6q.0", NULL, usdhc1_clk),
+	_REGISTER_CLOCK("sdhci-usdhc-imx6q.1", NULL, usdhc2_clk),
+	_REGISTER_CLOCK("sdhci-usdhc-imx6q.2", NULL, usdhc3_clk),
+	_REGISTER_CLOCK("sdhci-usdhc-imx6q.3", NULL, usdhc4_clk),
 	_REGISTER_CLOCK("imx-ssi.0", NULL, ssi1_clk),
 	_REGISTER_CLOCK("imx-ssi.1", NULL, ssi2_clk),
 	_REGISTER_CLOCK("imx-ssi.2", NULL, ssi3_clk),
diff --git a/arch/arm/mach-mx6/devices-imx6q.h b/arch/arm/mach-mx6/devices-imx6q.h
index 028185c..3ee69b2 100644
--- a/arch/arm/mach-mx6/devices-imx6q.h
+++ b/arch/arm/mach-mx6/devices-imx6q.h
@@ -34,6 +34,11 @@ extern const struct imx_fec_data imx6q_fec_data;
 #define imx6q_add_fec(pdata)	\
 	imx_add_fec(&imx6q_fec_data, pdata)
 
+extern const struct imx_sdhci_esdhc_imx_data
+imx6q_sdhci_usdhc_imx_data[] __initconst;
+#define imx6q_add_sdhci_usdhc_imx(id, pdata)   \
+	imx_add_sdhci_esdhc_imx(&imx6q_sdhci_usdhc_imx_data[id], pdata)
+
 extern const struct imx_imx_i2c_data imx6q_imx_i2c_data[] __initconst;
 #define imx6q_add_imx_i2c(id, pdata)	\
 	imx_add_imx_i2c(&imx6q_imx_i2c_data[id], pdata)
diff --git a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
index 3cd52af..4e82023 100644
--- a/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
+++ b/arch/arm/mach-mx6/mach-mx6q_sabrelite.c
@@ -55,6 +55,10 @@
 #include "crm_regs.h"
 #include "cpu_op-mx6.h"
 
+#define MX6Q_SABRELITE_SD3_CD		IMX_GPIO_NR(7, 0)
+#define MX6Q_SABRELITE_SD3_WP		IMX_GPIO_NR(7, 1)
+#define MX6Q_SABRELITE_SD4_CD		IMX_GPIO_NR(2, 6)
+#define MX6Q_SABRELITE_SD4_WP		IMX_GPIO_NR(2, 7)
 
 #define MX6Q_SABRELITE_SD3_WP_PADCFG	(PAD_CTL_PKE | PAD_CTL_PUE |	\
 		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |	\
@@ -259,6 +263,131 @@ static iomux_v3_cfg_t mx6q_sabrelite_pads[] = {
 	MX6Q_PAD_NANDF_D7__GPIO_2_7,		/* SD4_WP */
 };
 
+static struct regulator_consumer_supply sabrelite_vmmc_consumers[] = {
+	REGULATOR_SUPPLY("vmmc", "sdhci-usdhc-imx6q.2"),
+	REGULATOR_SUPPLY("vmmc", "sdhci-usdhc-imx6q.3"),
+};
+
+static struct regulator_init_data sabrelite_vmmc_init = {
+	.constraints = {
+		.always_on = true,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sabrelite_vmmc_consumers),
+	.consumer_supplies = sabrelite_vmmc_consumers,
+};
+
+static struct fixed_voltage_config sabrelite_vmmc_reg_config = {
+	.supply_name		= "vmmc",
+	.microvolts		= 3300000,
+	.gpio			= -EINVAL,
+	.init_data		= &sabrelite_vmmc_init,
+};
+
+static struct platform_device sabrelite_vmmc_reg_devices = {
+	.name	= "reg-fixed-voltage",
+	.id	= 3,
+	.dev	= {
+		.platform_data = &sabrelite_vmmc_reg_config,
+	},
+};
+
+#define MX6Q_USDHC_PAD_SETTING(id, speed)	\
+mx6q_sd##id##_##speed##mhz[] = {		\
+	MX6Q_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
+	MX6Q_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
+}
+
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 50);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 100);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(3, 200);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 50);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 100);
+static iomux_v3_cfg_t MX6Q_USDHC_PAD_SETTING(4, 200);
+
+enum sd_pad_mode {
+	SD_PAD_MODE_LOW_SPEED,
+	SD_PAD_MODE_MED_SPEED,
+	SD_PAD_MODE_HIGH_SPEED,
+};
+
+static int plt_sd3_pad_change(int clock)
+{
+	static enum sd_pad_mode pad_mode = SD_PAD_MODE_LOW_SPEED;
+
+	if (clock > 100000000) {
+		if (pad_mode == SD_PAD_MODE_HIGH_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_HIGH_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_200mhz,
+					ARRAY_SIZE(mx6q_sd3_200mhz));
+	} else if (clock > 52000000) {
+		if (pad_mode == SD_PAD_MODE_MED_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_MED_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_100mhz,
+					ARRAY_SIZE(mx6q_sd3_100mhz));
+	} else {
+		if (pad_mode == SD_PAD_MODE_LOW_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_LOW_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd3_50mhz,
+					ARRAY_SIZE(mx6q_sd3_50mhz));
+	}
+}
+
+static int plt_sd4_pad_change(int clock)
+{
+	static enum sd_pad_mode pad_mode = SD_PAD_MODE_LOW_SPEED;
+
+	if (clock > 100000000) {
+		if (pad_mode == SD_PAD_MODE_HIGH_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_HIGH_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_200mhz,
+					ARRAY_SIZE(mx6q_sd4_200mhz));
+	} else if (clock > 52000000) {
+		if (pad_mode == SD_PAD_MODE_MED_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_MED_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_100mhz,
+					ARRAY_SIZE(mx6q_sd4_100mhz));
+	} else {
+		if (pad_mode == SD_PAD_MODE_LOW_SPEED)
+			return 0;
+
+		pad_mode = SD_PAD_MODE_LOW_SPEED;
+		return mxc_iomux_v3_setup_multiple_pads(mx6q_sd4_50mhz,
+					ARRAY_SIZE(mx6q_sd4_50mhz));
+	}
+}
+
+static const struct esdhc_platform_data mx6q_sabrelite_sd3_data __initconst = {
+	.cd_gpio = MX6Q_SABRELITE_SD3_CD,
+	.wp_gpio = MX6Q_SABRELITE_SD3_WP,
+	.cd_type = ESDHC_CD_GPIO,
+	.wp_type = ESDHC_WP_GPIO,
+	.keep_power_at_suspend = 1,
+	.platform_pad_change = plt_sd3_pad_change,
+};
+
+static const struct esdhc_platform_data mx6q_sabrelite_sd4_data __initconst = {
+	.cd_gpio = MX6Q_SABRELITE_SD4_CD,
+	.wp_gpio = MX6Q_SABRELITE_SD4_WP,
+	.cd_type = ESDHC_CD_GPIO,
+	.wp_type = ESDHC_WP_GPIO,
+	.keep_power_at_suspend = 1,
+	.platform_pad_change = plt_sd4_pad_change,
+};
+
 /* Serial ports */
 static const struct imxuart_platform_data uart_pdata __initconst = {
 	.flags = IMXUART_HAVE_RTSCTS,
@@ -354,6 +483,11 @@ static void __init mx6_sabrelite_board_init(void)
 	imx6q_add_imx_i2c(0, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(1, &mx6q_sabrelite_i2c_data);
 	imx6q_add_imx_i2c(2, &mx6q_sabrelite_i2c_data);
+
+	/* SD/MMC */
+	platform_device_register(&sabrelite_vmmc_reg_devices);
+	imx6q_add_sdhci_usdhc_imx(3, &mx6q_sabrelite_sd4_data);
+	imx6q_add_sdhci_usdhc_imx(2, &mx6q_sabrelite_sd3_data);
 }
 
 static void __init mx6_sabrelite_timer_init(void)
diff --git a/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c b/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
index 5955f5d..6a8b8d4 100644
--- a/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
+++ b/arch/arm/plat-mxc/devices/platform-sdhci-esdhc-imx.c
@@ -18,9 +18,20 @@
 		.irq = soc ## _INT_ESDHC ## hwid,			\
 	}
 
+#define imx_sdhci_usdhc_imx_data_entry_single(soc, _devid, _id, hwid) \
+	{								\
+		.devid = _devid,					\
+		.id = _id,						\
+		.iobase = soc ## _USDHC ## hwid ## _BASE_ADDR,	\
+		.irq = soc ## _INT_USDHC ## hwid,			\
+	}
+
 #define imx_sdhci_esdhc_imx_data_entry(soc, devid, id, hwid)	\
 	[id] = imx_sdhci_esdhc_imx_data_entry_single(soc, devid, id, hwid)
 
+#define imx_sdhci_usdhc_imx_data_entry(soc, devid, id, hwid)	\
+	[id] = imx_sdhci_usdhc_imx_data_entry_single(soc, devid, id, hwid)
+
 #ifdef CONFIG_SOC_IMX25
 const struct imx_sdhci_esdhc_imx_data
 imx25_sdhci_esdhc_imx_data[] __initconst = {
@@ -66,6 +77,18 @@ imx53_sdhci_esdhc_imx_data[] __initconst = {
 };
 #endif /* ifdef CONFIG_SOC_IMX53 */
 
+#ifdef CONFIG_SOC_IMX6Q
+const struct imx_sdhci_esdhc_imx_data
+imx6q_sdhci_usdhc_imx_data[] __initconst = {
+#define imx6q_sdhci_usdhc_imx_data_entry(_id, _hwid)			\
+	imx_sdhci_usdhc_imx_data_entry(MX6Q, "sdhci-usdhc-imx6q", _id, _hwid)
+	imx6q_sdhci_usdhc_imx_data_entry(0, 1),
+	imx6q_sdhci_usdhc_imx_data_entry(1, 2),
+	imx6q_sdhci_usdhc_imx_data_entry(2, 3),
+	imx6q_sdhci_usdhc_imx_data_entry(3, 4),
+};
+#endif /* ifdef CONFIG_SOC_IMX6Q */
+
 static const struct esdhc_platform_data default_esdhc_pdata __initconst = {
 	.wp_type = ESDHC_WP_NONE,
 	.cd_type = ESDHC_CD_NONE,
diff --git a/arch/arm/plat-mxc/include/mach/esdhc.h b/arch/arm/plat-mxc/include/mach/esdhc.h
index aaf9748..5590282 100644
--- a/arch/arm/plat-mxc/include/mach/esdhc.h
+++ b/arch/arm/plat-mxc/include/mach/esdhc.h
@@ -39,5 +39,7 @@ struct esdhc_platform_data {
 	unsigned int cd_gpio;
 	enum wp_types wp_type;
 	enum cd_types cd_type;
+	unsigned int keep_power_at_suspend;
+	int (*platform_pad_change)(int clock);
 };
 #endif /* __ASM_ARCH_IMX_ESDHC_H */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 2bc06e7..e4da82e 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -131,7 +131,7 @@ config MMC_SDHCI_CNS3XXX
 
 config MMC_SDHCI_ESDHC_IMX
 	tristate "SDHCI support for the Freescale eSDHC/uSDHC i.MX controller"
-	depends on ARCH_MXC
+	depends on ARCH_MXC || ARCH_MX6
 	depends on MMC_SDHCI_PLTFM
 	select MMC_SDHCI_IO_ACCESSORS
 	help
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index 8abdaf6..e937424 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -495,6 +495,9 @@ static int __devinit sdhci_esdhc_imx_probe(struct platform_device *pdev)
 					host->mmc->parent->platform_data);
 	}
 
+	if (boarddata->keep_power_at_suspend)
+		host->mmc->pm_caps |= MMC_PM_KEEP_POWER;
+
 	/* write_protect */
 	if (boarddata->wp_type == ESDHC_WP_GPIO) {
 		err = gpio_request_one(boarddata->wp_gpio, GPIOF_IN, "ESDHC_WP");
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index d25f9ab..b534959 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -47,6 +47,9 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	int pre_div = 2;
 	int div = 1;
 	u32 temp;
+	struct esdhc_platform_data *boarddata;
+
+	boarddata = host->mmc->parent->platform_data;
 
 	if (clock == 0)
 		goto out;
@@ -74,6 +77,14 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 		| (pre_div << ESDHC_PREDIV_SHIFT));
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 	mdelay(1);
+
+	/* if there's board callback function
+	 * for pad setting change, that means
+	 * board needs to reconfig its pad for
+	 * corresponding sd bus frequency
+	 */
+	if (boarddata->platform_pad_change)
+		boarddata->platform_pad_change(clock);
 out:
 	host->clock = clock;
 }
-- 
1.7.9.7

