From 6162fda5f796ea132550259f65f56dedbd9db283 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Tue, 3 Jul 2012 16:23:05 +0800
Subject: [PATCH 21/28] SPEAr: add missing include files

Copy missing include files from st git tree:

git://git.stlinux.com/spear/linux-2.6.git next-3.3
commit a642f8da Input: stmpe-ts: Add runtime power management support

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 include/linux/ad9889b.h            |   18 +++
 include/linux/can/platform/c_can.h |   46 ++++++
 include/linux/designware_i2s.h     |   63 +++++++++
 include/linux/i2c/i2c-designware.h |   33 +++++
 include/linux/i2c/l3g4200d.h       |   63 +++++++++
 include/linux/i2c/lsm303dlh.h      |   59 ++++++++
 include/linux/spear_adc_usr.h      |  132 +++++++++++++++++
 include/linux/spear_dma.h          |   35 +++++
 include/linux/usb/dwc_otg.h        |  274 ++++++++++++++++++++++++++++++++++++
 include/media/vip.h                |  139 ++++++++++++++++++
 10 files changed, 862 insertions(+)
 create mode 100644 include/linux/ad9889b.h
 create mode 100644 include/linux/can/platform/c_can.h
 create mode 100644 include/linux/designware_i2s.h
 create mode 100644 include/linux/i2c/i2c-designware.h
 create mode 100644 include/linux/i2c/l3g4200d.h
 create mode 100644 include/linux/i2c/lsm303dlh.h
 create mode 100644 include/linux/spear_adc_usr.h
 create mode 100644 include/linux/spear_dma.h
 create mode 100644 include/linux/usb/dwc_otg.h
 create mode 100644 include/media/vip.h

diff --git a/include/linux/ad9889b.h b/include/linux/ad9889b.h
new file mode 100644
index 0000000..dac670e
--- /dev/null
+++ b/include/linux/ad9889b.h
@@ -0,0 +1,18 @@
+#ifndef __AD9889B_H
+#define __AD9889B_H
+
+#include <linux/fb.h>
+
+enum hdmi_audio_input {
+	HDMI_AUDIO_IN_SPDIF,
+	HDMI_AUDIO_IN_I2S,
+};
+
+struct ad9889b_pdata {
+	u32 irq_gpio;
+	u32 irq_type;
+	int fb;
+	enum hdmi_audio_input ain;
+};
+#endif /* __AD9889B_H */
+
diff --git a/include/linux/can/platform/c_can.h b/include/linux/can/platform/c_can.h
new file mode 100644
index 0000000..7ee7e96
--- /dev/null
+++ b/include/linux/can/platform/c_can.h
@@ -0,0 +1,46 @@
+/*
+ * CAN bus driver platform header for Bosch C_CAN controller
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __CAN_PLATFORM_C_CAN_H__
+#define __CAN_PLATFORM_C_CAN_H__
+
+#include <linux/types.h>
+
+/**
+ * struct c_can_devtype_data - Depending on the underlying platform,
+ *                             the message object configuration
+ *                             for c_can controller can change
+ * @rx_first: first RX object out of possible 32 msg objs
+ * @rx_split: defines the split point for the lower and upper Rx msg
+ *            object buckets.
+ * @rx_last: last RX object out of possible 32 msg objs
+ * @tx_num: number of objs kept aside for TX purposes
+ */
+struct c_can_devtype_data {
+	unsigned int rx_first;
+	unsigned int rx_split;
+	unsigned int rx_last;
+	unsigned int tx_num;
+};
+
+/**
+ * struct c_can_platform_data - C_CAN Platform Data
+ * @is_quirk_required: Depending on the SoC being used
+ *                     determine if a SW fix (/quirk) is required
+ *                     for the c_can controller.
+ * @devtype_data: c_can device specific data
+ */
+struct c_can_platform_data {
+	bool is_quirk_required;
+	struct c_can_devtype_data devtype_data;
+};
+
+#endif /* __CAN_PLATFORM_C_CAN_H__ */
diff --git a/include/linux/designware_i2s.h b/include/linux/designware_i2s.h
new file mode 100644
index 0000000..908e560
--- /dev/null
+++ b/include/linux/designware_i2s.h
@@ -0,0 +1,63 @@
+/*
+* linux/designware_i2s.h
+*
+* Copyright (ST) 2011 Rajeev Kumar (rajeev-dlh.kumar@st.com)
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*/
+
+#ifndef DESIGNWARE_I2S_H
+#define DESIGNWARE_I2S_H
+
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+/*
+ * struct i2s_clk_config_data - represent i2s clk configuration data
+ * @chan_nr: number of channel
+ * @data_width: number of bits per sample (8/16/24/32 bit)
+ * @sample_rate: sampling frequency (8Khz, 16Khz, 32Khz, 44Khz, 48Khz)
+ */
+struct i2s_clk_config_data {
+	int chan_nr;
+	u32 data_width;
+	u32 sample_rate;
+};
+
+struct i2s_platform_data {
+	#define PLAY	(1 << 0)
+	#define RECORD	(1 << 1)
+	unsigned int cap;
+	int channel;
+	u32 snd_fmts;
+	u32 snd_rates;
+
+	void *play_dma_data;
+	void *capture_dma_data;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config);
+};
+
+/* I2S DMA registers */
+#define I2S_RXDMA		0x01C0
+#define I2S_TXDMA		0x01C8
+
+#define TWO_CHANNEL_SUPPORT	2	/* up to 2.0 */
+#define FOUR_CHANNEL_SUPPORT	4	/* up to 3.1 */
+#define SIX_CHANNEL_SUPPORT	6	/* up to 5.1 */
+#define EIGHT_CHANNEL_SUPPORT	8	/* up to 7.1 */
+
+#endif /* DESIGNWARE_I2S_H */
diff --git a/include/linux/i2c/i2c-designware.h b/include/linux/i2c/i2c-designware.h
new file mode 100644
index 0000000..e40ad85
--- /dev/null
+++ b/include/linux/i2c/i2c-designware.h
@@ -0,0 +1,33 @@
+/*
+ * Synopsys DesignWare I2C adapter driver's platform data
+ *
+ * Copyright (C) 2012 ST Microelectronics.
+ * Author: Vincenzo Frascino <vincenzo.frascino@st.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef I2C_DESIGNWARE_H
+#define I2C_DESIGNWARE_H
+
+#include <linux/platform_device.h>
+
+/* I2C Designware Platform Data */
+struct i2c_dw_pdata {
+	/*
+	 * The scope of this routine is to define i2c bus recovery procedure
+	 * as specified in the i2c protocol Rev. 03 section 3.16 titled
+	 * "Bus clear".
+	 * Its implementation is platform dependant.
+	 */
+	void (*i2c_recover_bus)(void *);
+};
+
+#endif /* I2C_DESIGNWARE_H */
diff --git a/include/linux/i2c/l3g4200d.h b/include/linux/i2c/l3g4200d.h
new file mode 100644
index 0000000..3985114
--- /dev/null
+++ b/include/linux/i2c/l3g4200d.h
@@ -0,0 +1,63 @@
+/*
+ * include/linux/i2c/l3g4200d.h
+ *
+ * ST Microelectronics L3G4200D digital output gyroscope header file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ *
+ * Developed by:
+ * Carmine Iascone <carmine.iascone@st.com>
+ * Matteo Dameno <matteo.dameno@st.com>
+ *
+ * Currently maintained by:
+ * Amit Virdi <amit.virdi@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __L3G4200D_H__
+#define __L3G4200D_H__
+
+#define L3G4200D_DEV_NAME	"l3g4200d_gyr"
+
+#define L3G4200D_RANGE_250DPS	250
+#define L3G4200D_RANGE_500DPS	500
+#define L3G4200D_RANGE_2000DPS	2000
+
+#define L3G4200D_ENABLED	1
+#define L3G4200D_DISABLED	0
+
+#ifdef __KERNEL__
+
+/**
+ * struct l3g4200d_gyr_platform_data - L3G4200D gyroscope platform data
+ * @poll_interval: The polling interval (in ms)
+ * @min_interval: Minimum permitted polling interval
+ * @fs_range: Full scale output range selection
+ * @axis_map_x, _y, _z: used to map the x, y, z axis to some other plane of
+ *	reference
+ * @negate_x, _y, _z: flags to negate the output of x, y, z registers
+ *
+ * l3g4200d_gyr_platform_data specifies the parameters to be used to
+ * configure the gyroscope device.
+ */
+struct l3g4200d_gyr_platform_data {
+	int poll_interval;
+	int min_interval;
+
+	int fs_range;
+
+	u8 axis_map_x;
+	u8 axis_map_y;
+	u8 axis_map_z;
+
+	u8 negate_x;
+	u8 negate_y;
+	u8 negate_z;
+};
+
+#endif /* __KERNEL__ */
+
+#endif  /* __L3G4200D_H__ */
diff --git a/include/linux/i2c/lsm303dlh.h b/include/linux/i2c/lsm303dlh.h
new file mode 100644
index 0000000..a2ee2c4
--- /dev/null
+++ b/include/linux/i2c/lsm303dlh.h
@@ -0,0 +1,59 @@
+/*
+ * lsm303dlh.h
+ * ST 3-Axis Accelerometer/Magnetometer header file
+ *
+ * Copyright (C) 2010 STMicroelectronics
+ * Author: Carmine Iascone (carmine.iascone@st.com)
+ * Author: Matteo Dameno (matteo.dameno@st.com)
+ *
+ * Copyright (C) 2010 STEricsson
+ * Author: Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>
+ * Updated:Preetham Rao Kaskurthi <preetham.rao@stericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __LSM303DLH_H__
+#define __LSM303DLH_H__
+
+#include <linux/ioctl.h>
+
+#ifdef __KERNEL__
+struct lsm303dlh_platform_data {
+
+	/* name of device for regulator */
+
+	const char *name_a; /* acelerometer name */
+	const char *name_m; /* magnetometer name */
+
+	/* interrupt data */
+	u32 irq_a1;	/* interrupt line 1 of accelrometer*/
+	u32 irq_a2;	/* interrupt line 2 of accelrometer*/
+	u32 irq_m;	/* interrupt line of magnetometer*/
+
+	/* position of x, y and z axis */
+	u8 axis_map_x; /* [0-2] */
+	u8 axis_map_y; /* [0-2] */
+	u8 axis_map_z; /* [0-2] */
+
+	/* orientation of x, y and z axis */
+	u8 negative_x; /* [0-1] */
+	u8 negative_y; /* [0-1] */
+	u8 negative_z; /* [0-1] */
+
+	/*  set this for poll device */
+	u8  input_poll_dev;
+};
+#endif /* __KERNEL__ */
+
+#endif /* __LSM303DLH_H__ */
diff --git a/include/linux/spear_adc_usr.h b/include/linux/spear_adc_usr.h
new file mode 100644
index 0000000..6fdbe4f
--- /dev/null
+++ b/include/linux/spear_adc_usr.h
@@ -0,0 +1,132 @@
+/*
+* linux/spr_adc_st10_usr.h
+* ST ADC driver - user header file
+*
+* Copyright (ST) 2009 Viresh Kumar (viresh.kumar@st.com)
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*
+*/
+
+#ifndef SPEAR_ADC_USR_H
+#define SPEAR_ADC_USR_H
+
+#define ADC_NAME 'A'
+#define ADCIOC_CONFIG _IOW(ADC_NAME, 1, struct adc_config)
+#define ADCIOC_CHAN_CONFIG _IOW(ADC_NAME, 2, struct adc_chan_config)
+#define ADCIOC_GET_CONFIG _IOR(ADC_NAME, 3, struct adc_config)
+#define ADCIOC_GET_CHAN_CONFIG _IOR(ADC_NAME, 4, struct adc_chan_config)
+
+/* channel list */
+enum adc_chan_id {
+	ADC_CHANNEL0,
+	ADC_CHANNEL1,
+	ADC_CHANNEL2,
+	ADC_CHANNEL3,
+	ADC_CHANNEL4,
+	ADC_CHANNEL5,
+	ADC_CHANNEL6,
+	ADC_CHANNEL7,
+	ADC_CHANNEL_NONE
+};
+
+/* sample rates */
+enum adc_avg_samples {
+	SAMPLE1,
+	SAMPLE2,
+	SAMPLE4,
+	SAMPLE8,
+	SAMPLE16,
+	SAMPLE32,
+	SAMPLE64,
+	SAMPLE128
+};
+
+/* adc conversion modes */
+enum adc_conv_mode {
+	SINGLE_CONVERSION,
+	CONTINUOUS_CONVERSION,
+	CONVERSION_NONE
+};
+
+#ifndef CONFIG_ARCH_SPEAR6XX
+/* adc resolution */
+enum adc_resolution {
+	NORMAL_RESOLUTION,
+	HIGH_RESOLUTION,
+	RESOLUTION_NONE
+};
+#else
+/**
+* struct adc_output: structure representing data output from adc
+* @integral: integral part of data
+* @fractional: fractional part of data
+*/
+struct adc_output {
+	short int integral;
+	short int fractional;
+};
+#endif
+
+/* scan rate reference */
+enum adc_scan_ref {
+	INTERNAL_SCAN,
+	EXTERNAL_SCAN
+};
+
+/* reference voltage */
+enum adc_volt_ref {
+	EXTERNAL_VOLT,
+	INTERNAL_VOLT
+};
+
+/**
+* struct adc_config: adc configuration structure
+* @mode: mode to be configured, can be single or continuous
+* @volt_ref: reference of voltage, can be internal or external
+* @mvolt: reference voltage in millivolts
+* @scan_ref: reference of scan rate, can be internal or external
+* @resolution: resolution of output data, can be normal or high, for SPEAR300
+* @req_clk: adc clk requested, in Hz
+* @avail_clk: closest clk less than equal to req_clk possible, in Hz
+*/
+struct adc_config {
+	enum adc_conv_mode mode;
+	enum adc_volt_ref volt_ref;
+	unsigned int mvolt;
+	enum adc_scan_ref scan_ref;
+#ifndef CONFIG_ARCH_SPEAR6XX
+	enum adc_resolution resolution;
+#endif
+	unsigned int req_clk;
+	unsigned int avail_clk;
+};
+
+/**
+* struct adc_chan_config: adc channel configuration structure
+* @chan_id: channel to be configured
+* @avg_samples: number of average samples
+* @scan_rate: rate at which adc converts data, in microseconds
+* @scan_rate_fixed: if 1 configured scan rate should be equal to requested
+* scan rate else if FALSE configured scan rate can be less than equal to
+* requsted scan rate
+*/
+struct adc_chan_config {
+	enum adc_chan_id chan_id;
+	enum adc_avg_samples avg_samples;
+	unsigned int scan_rate;
+	int scan_rate_fixed;
+};
+#endif /* SPEAR_ADC_USR_H */
diff --git a/include/linux/spear_dma.h b/include/linux/spear_dma.h
new file mode 100644
index 0000000..695e4c4
--- /dev/null
+++ b/include/linux/spear_dma.h
@@ -0,0 +1,35 @@
+/*
+* linux/spear_dma.h
+*
+* Copyright (ST) 2011 Rajeev Kumar (rajeev-dlh.kumar@st.com)
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*/
+
+#ifndef SPEAR_DMA_H
+#define SPEAR_DMA_H
+
+#include <linux/dmaengine.h>
+
+struct dma_data {
+	void *data;
+	dma_addr_t addr;
+	u32 max_burst;
+	enum dma_slave_buswidth addr_width;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+};
+
+#endif /* SPEAR_DMA_H */
diff --git a/include/linux/usb/dwc_otg.h b/include/linux/usb/dwc_otg.h
new file mode 100644
index 0000000..aa86adc
--- /dev/null
+++ b/include/linux/usb/dwc_otg.h
@@ -0,0 +1,274 @@
+/* DWC OTG (On The Go) defines */
+
+#ifndef __LINUX_DWC_OTG_H
+#define __LINUX_DWC_OTG_H
+
+/*
+ * The following parameters may be specified when starting the module. These
+ * parameters define how the DWC_otg controller should be configured.  Parameter
+ * values are passed to the CIL initialization function dwc_otg_cil_init.
+ */
+struct core_params {
+	/*
+	 * Specifies the OTG capabilities. The driver will automatically
+	 * detect the value for this parameter if none is specified.
+	 * 0 - HNP and SRP capable (default)
+	 * 1 - SRP Only capable
+	 * 2 - No HNP/SRP capable
+	 */
+	int otg_cap;
+#define DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE		0
+#define DWC_OTG_CAP_PARAM_SRP_ONLY_CAPABLE		1
+#define DWC_OTG_CAP_PARAM_NO_HNP_SRP_CAPABLE		2
+
+#define dwc_param_otg_cap_default	DWC_OTG_CAP_PARAM_HNP_SRP_CAPABLE
+
+	/*
+	 * Specifies whether to use slave or DMA mode for accessing the data
+	 * FIFOs. The driver will automatically detect the value for this
+	 * parameter if none is specified.
+	 * 0 - Slave
+	 * 1 - DMA (default, if available)
+	 */
+	int dma_enable;
+#ifdef CONFIG_DWC_SLAVE
+#define dwc_param_dma_enable_default			0
+#else
+#define dwc_param_dma_enable_default			1
+#endif
+
+	/*
+	 * The DMA Burst size (applicable only for External DMA Mode).
+	 * 1, 4, 8 16, 32, 64, 128, 256 (default 32)
+	 */
+	int dma_burst_size;	/* Translate this to GAHBCFG values */
+#define dwc_param_dma_burst_size_default		32
+
+	/*
+	 * Specifies the maximum speed of operation in host and device mode.
+	 * The actual speed depends on the speed of the attached device and
+	 * the value of phy_type. The actual speed depends on the speed of the
+	 * attached device.
+	 *      0 - High Speed (default)
+	 *      1 - Full Speed
+	 */
+	int speed;
+#define dwc_param_speed_default				0
+#define DWC_SPEED_PARAM_HIGH				0
+#define DWC_SPEED_PARAM_FULL				1
+
+	/*
+	 * Specifies whether low power mode is supported when attached to a Full
+	 * Speed or Low Speed device in host mode.
+	 *      0 - Don't support low power mode (default)
+	 *      1 - Support low power mode
+	 */
+	int host_support_fs_ls_low_power;
+#define dwc_param_host_support_fs_ls_low_power_default	0
+
+	/*
+	 * Specifies the PHY clock rate in low power mode when connected to a
+	 * Low Speed device in host mode. This parameter is applicable only if
+	 * HOST_SUPPORT_FS_LS_LOW_POWER is enabled. If PHY_TYPE is set to FS
+	 * then defaults to 6 MHZ otherwise 48 MHZ.
+	 *
+	 *      0 - 48 MHz
+	 *      1 - 6 MHz
+	 */
+	int host_ls_low_power_phy_clk;
+#define dwc_param_host_ls_low_power_phy_clk_default	0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_48MHZ	0
+#define DWC_HOST_LS_LOW_POWER_PHY_CLK_PARAM_6MHZ	1
+
+	/*
+	 * 0 - Use cC FIFO size parameters
+	 * 1 - Allow dynamic FIFO sizing (default)
+	 */
+	int enable_dynamic_fifo;
+#define dwc_param_enable_dynamic_fifo_default		1
+
+	/*
+	 * Number of 4-byte words in the Rx FIFO in device mode when dynamic
+	 * FIFO sizing is enabled.  16 to 32768 (default 1064)
+	 */
+	int dev_rx_fifo_size;
+#define dwc_param_dev_rx_fifo_size_default		1064
+
+	/*
+	 * Number of 4-byte words in the non-periodic Tx FIFO in device mode
+	 * when dynamic FIFO sizing is enabled.  16 to 32768 (default 1024)
+	 */
+	int dev_nperio_tx_fifo_size;
+#define dwc_param_dev_nperio_tx_fifo_size_default	1024
+
+	/*
+	 * Number of 4-byte words in each of the periodic Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled.  4 to 768 (default 256)
+	 */
+#define MAX_TX_FIFOS			15	/* Max periodic FIFOs */
+	u32 dev_perio_tx_fifo_size[MAX_TX_FIFOS];
+#define dwc_param_dev_perio_tx_fifo_size_default	256
+
+	/*
+	 * Number of 4-byte words in the Rx FIFO in host mode when dynamic
+	 * FIFO sizing is enabled.  16 to 32768 (default 1024)
+	 */
+	int host_rx_fifo_size;
+#define dwc_param_host_rx_fifo_size_default		1024
+
+	/*
+	 * Number of 4-byte words in the non-periodic Tx FIFO in host mode
+	 * when Dynamic FIFO sizing is enabled in the core.  16 to 32768
+	 * (default 1024)
+	 */
+	int host_nperio_tx_fifo_size;
+#define dwc_param_host_nperio_tx_fifo_size_default	1024
+
+	/*
+	   Number of 4-byte words in the host periodic Tx FIFO when dynamic
+	   * FIFO sizing is enabled.  16 to 32768 (default 1024)
+	 */
+	int host_perio_tx_fifo_size;
+#define dwc_param_host_perio_tx_fifo_size_default	1024
+
+	/*
+	 * The maximum transfer size supported in bytes. 2047 to 65,535
+	 * (default 65,535)
+	 */
+	int max_transfer_size;
+#define dwc_param_max_transfer_size_default		65535
+
+	/*
+	 * The maximum number of packets in a transfer. 15 to 511  (default 511)
+	 */
+	int max_packet_count;
+#define dwc_param_max_packet_count_default		511
+
+	/*
+	 * The number of host channel registers to use.
+	 * 1 to 16 (default 12)
+	 * Note: The FPGA configuration supports a maximum of 12 host channels.
+	 */
+	int host_channels;
+#define dwc_param_host_channels_default			12
+
+	/*
+	 * The number of endpoints in addition to EP0 available for device
+	 * mode operations.
+	 * 1 to 15 (default 6 IN and OUT)
+	 * Note: The FPGA configuration supports a maximum of 6 IN and OUT
+	 * endpoints in addition to EP0.
+	 */
+	int dev_endpoints;
+#define dwc_param_dev_endpoints_default			6
+
+	/*
+	 * Specifies the type of PHY interface to use. By default, the driver
+	 * will automatically detect the phy_type.
+	 *
+	 *      0 - Full Speed PHY
+	 *      1 - UTMI+ (default)
+	 *      2 - ULPI
+	 */
+	int phy_type;
+#define DWC_PHY_TYPE_PARAM_FS			0
+#define DWC_PHY_TYPE_PARAM_UTMI			1
+#define DWC_PHY_TYPE_PARAM_ULPI			2
+#define dwc_param_phy_type_default		DWC_PHY_TYPE_PARAM_UTMI
+
+	/*
+	 * Specifies the UTMI+ Data Width.  This parameter is applicable for a
+	 * PHY_TYPE of UTMI+ or ULPI. (For a ULPI PHY_TYPE, this parameter
+	 * indicates the data width between the MAC and the ULPI Wrapper.) Also,
+	 * this parameter is applicable only if the OTG_HSPHY_WIDTH cC parameter
+	 * was set to "8 and 16 bits", meaning that the core has been configured
+	 * to work at either data path width.
+	 *
+	 * 8 or 16 bits (default 16)
+	 */
+	int phy_utmi_width;
+#define dwc_param_phy_utmi_width_default	16
+
+	/*
+	 * Specifies whether the ULPI operates at double or single
+	 * data rate. This parameter is only applicable if PHY_TYPE is
+	 * ULPI.
+	 *
+	 *      0 - single data rate ULPI interface with 8 bit wide data
+	 *              bus (default)
+	 *      1 - double data rate ULPI interface with 4 bit wide data
+	 *              bus
+	 */
+	int phy_ulpi_ddr;
+#define dwc_param_phy_ulpi_ddr_default		0
+
+	/*
+	 * Specifies whether to use the internal or external supply to
+	 * drive the vbus with a ULPI phy.
+	 */
+	int phy_ulpi_ext_vbus;
+#define DWC_PHY_ULPI_INTERNAL_VBUS		0
+#define DWC_PHY_ULPI_EXTERNAL_VBUS		1
+#define dwc_param_phy_ulpi_ext_vbus_default	DWC_PHY_ULPI_INTERNAL_VBUS
+
+	/*
+	 * Specifies whether to use the I2Cinterface for full speed PHY. This
+	 * parameter is only applicable if PHY_TYPE is FS.
+	 *      0 - No (default)
+	 *      1 - Yes
+	 */
+	int i2c_enable;
+#define dwc_param_i2c_enable_default		0
+
+	int ulpi_fs_ls;
+#define dwc_param_ulpi_fs_ls_default		0
+
+	int ts_dline;
+#define dwc_param_ts_dline_default		0
+
+	/*
+	 * Specifies whether dedicated transmit FIFOs are enabled for non
+	 * periodic IN endpoints in device mode
+	 *      0 - No
+	 *      1 - Yes
+	 */
+	int en_multiple_tx_fifo;
+#define dwc_param_en_multiple_tx_fifo_default	1
+
+	/*
+	 * Number of 4-byte words in each of the Tx FIFOs in device
+	 * mode when dynamic FIFO sizing is enabled. 4 to 768 (default 256)
+	 */
+	u32 dev_tx_fifo_size[MAX_TX_FIFOS];
+	u32 fifo_number;
+#define dwc_param_dev_tx_fifo_size_default	256
+
+	/*
+	 * Thresholding enable flag
+	 *      bit 0 - enable non-ISO Tx thresholding
+	 *      bit 1 - enable ISO Tx thresholding
+	 *      bit 2 - enable Rx thresholding
+	 */
+	u32 thr_ctl;
+#define dwc_param_thr_ctl_default		0
+
+	/* Thresholding length for Tx FIFOs in 32 bit DWORDs */
+	u32 tx_thr_length;
+#define dwc_param_tx_thr_length_default		64
+
+	/* Thresholding length for Rx FIFOs in 32 bit DWORDs */
+	u32 rx_thr_length;
+#define dwc_param_rx_thr_length_default		64
+
+};
+
+
+/**
+ * struct dwc_otg_plat_data - device.platform_data for dwc otg driver.
+ */
+struct dwc_otg_plat_data {
+	int (*phy_init)(void);
+	int (*param_init)(struct core_params *);
+};
+
+#endif /* __LINUX_DWC_OTG_H */
diff --git a/include/media/vip.h b/include/media/vip.h
new file mode 100644
index 0000000..5346b61
--- /dev/null
+++ b/include/media/vip.h
@@ -0,0 +1,139 @@
+/*
+ * SPEAr VIP platform specific code
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __VIP_H
+#define __VIP_H
+
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <mach/generic.h>
+
+/* vip supports HD frame */
+#define VIP_MAX_WIDTH		1920
+#define VIP_MAX_HEIGHT		1080
+
+/* vip minimum resolution */
+#define VIP_MIN_WIDTH		0
+#define VIP_MIN_HEIGHT		0
+
+/* vip bits-per-pixel settings */
+#define VIP_MAX_BITS_PER_PIXEL	32	/* set for 32bpp slave */
+#define VIP_MAX_BYTES_PER_PIXEL	(VIP_MAX_BITS_PER_PIXEL / 8)
+
+/* vip buffer count and size */
+#define VIP_MIN_BUFFER_CNT	3
+#define VIP_OPTIMAL_BUFFER_CNT	(VIP_MIN_BUFFER_CNT + 1)
+#define VIP_OPTIMAL_BUFFER_SIZE	(VIP_MAX_WIDTH * VIP_MAX_HEIGHT * \
+				VIP_MAX_BYTES_PER_PIXEL)
+/* Allocated Three buffers of size 8 MB each to support 1080p */
+#define VIP_TOTAL_BUFFER_SIZE	(24 * 1024 * 1024)
+
+/* vip polarity settings : common for hsync, vsync and pixclk */
+enum vip_polarity {
+	POL_ACTIVE_LOW = 0,
+	POL_ACTIVE_HIGH,
+};
+
+/* vip rgb width settings */
+enum vip_rgb_width {
+	SIXTEEN_BIT = 16,
+	TWENTYFOUR_BIT = 24,
+	THIRTYTWO_BIT = 32,
+};
+
+/* vip video modes */
+enum vip_video_modes {
+	SINGLE_PORT = 0,
+	DUAL_PORT,
+};
+
+/**
+ * struct vip_config - configuration data for vip instance.
+ * @vsync_pol: polarity of vsync signal
+ * @hsync_pol: polarity of hsync signal
+ * @pix_clk_pol: polarity of pixel clock signal
+ * @rgb_width: selects the rgb width
+ * @vdo_mode: selects the video mode
+ */
+struct vip_config {
+	enum vip_polarity vsync_pol;
+	enum vip_polarity hsync_pol;
+	enum vip_polarity pix_clk_pol;
+	enum vip_rgb_width rgb_width;
+	enum vip_video_modes vdo_mode;
+};
+
+/**
+ * struct vip_subdev_route - routing info of subdevs connected to vip
+ * @input: input source to be selected out of the possible ones
+ * @output: output to be selected out of the possible ones
+ * @subdev_count: number of subdevs connected to this bridge driver
+ */
+struct vip_subdev_route {
+	u32 input;
+	u32 output;
+};
+
+/**
+ * struct vip_subdev_info - info of subdevs connected to vip
+ * @name: sub-device name
+ * @grp_id: sub-device group id
+ * @num_inputs: number of inputs supported
+ * @inputs: inputs available at the sub device
+ * @routes: sub-dev routing information for each input
+ * @can_route: check if sub-dev supports routing
+ * @board_info: i2c subdev board info
+ */
+struct vip_subdev_info {
+	char name[32];
+	int grp_id;
+	int num_inputs;
+	struct v4l2_input *inputs;
+	struct vip_subdev_route *routes;
+	int can_route;
+	struct i2c_board_info board_info;
+};
+
+/**
+ * struct vip_plat_data - platform structure for configuring vip
+ * @card_name: evm card info
+ * @config: configuration specific to this vip instance
+ * @subdev_info: info of attached subdevs
+ * @subdev_count: number of subdevs connected to this bridge driver
+ * @i2c_adapter_id: i2c bus adapter no
+ * @is_field_end_gpio_based: tells whether some gpio will be used
+ *      as a source of field-end interrupt to the CPU.
+ * @gpio_for_frame_end_intr: gpio available for asserting frame end
+ * @vb_base: base address of the videobuf area allocated using _fixup_
+ * @vb_size: size of the videobuf area allocated using _fixup_
+ */
+struct vip_plat_data {
+	char *card_name;
+	struct vip_config *config;
+	struct vip_subdev_info *subdev_info;
+	int subdev_count;
+	int i2c_adapter_id;
+	bool is_field_end_gpio_based;
+	int gpio_for_frame_end_intr;
+	unsigned long vb_base;
+	unsigned long vb_size;
+};
+
+static inline void vip_set_plat_data(struct platform_device *pdev,
+		struct vip_plat_data *pdata)
+{
+	pdev->dev.platform_data = pdata;
+}
+
+unsigned long vip_buffer_fixup(struct meminfo *mi);
+void vip_set_vb_base(struct vip_plat_data *pdata);
+
+#endif /* __VIP_H */
-- 
1.7.9.7

