From 11c0ccf180bed9c66e2347fd2b4cb656d66aca4d Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Mon, 6 Aug 2012 18:01:32 +0800
Subject: [PATCH 01/28] SPEAr: add spear13xx plat files to new diretory
 arch/arm/plat-spear13xx

Copy spear13xx plat files to a new directory arch/arm/plat-spear13xx/
from arch/arm/plat-spear/ of st git tree:

git://git.stlinux.com/spear/linux-2.6.git next-3.3
commit a642f8da Input: stmpe-ts: Add runtime power management support

Note: this also corresponds to the commits bf976b51..966ae210
      on arch/arm/plat-spear/ at st git tree.

And remove unrelated files: pl080.c, pm.c and sleep.S. Also modify
Makefile to remove compiling of the files.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/plat-spear13xx/Kconfig                    |   57 +
 arch/arm/plat-spear13xx/Makefile                   |   23 +
 arch/arm/plat-spear13xx/clcd.c                     |  192 +++
 arch/arm/plat-spear13xx/clock.c                    | 1223 ++++++++++++++++++++
 arch/arm/plat-spear13xx/cpu_suspend.S              |   44 +
 arch/arm/plat-spear13xx/cpufreq.c                  |  351 ++++++
 arch/arm/plat-spear13xx/i2c_eval_board.c           |   32 +
 arch/arm/plat-spear13xx/include/plat/adc.h         |   34 +
 arch/arm/plat-spear13xx/include/plat/camif.h       |  110 ++
 arch/arm/plat-spear13xx/include/plat/clock.h       |  276 +++++
 arch/arm/plat-spear13xx/include/plat/cpufreq.h     |   26 +
 arch/arm/plat-spear13xx/include/plat/debug-macro.S |   36 +
 arch/arm/plat-spear13xx/include/plat/gpio.h        |   88 ++
 arch/arm/plat-spear13xx/include/plat/hardware.h    |   93 ++
 arch/arm/plat-spear13xx/include/plat/hdlc.h        |   48 +
 arch/arm/plat-spear13xx/include/plat/i2c.h         |   21 +
 arch/arm/plat-spear13xx/include/plat/io.h          |   22 +
 arch/arm/plat-spear13xx/include/plat/jpeg.h        |   33 +
 arch/arm/plat-spear13xx/include/plat/keyboard.h    |  162 +++
 arch/arm/plat-spear13xx/include/plat/padmux.h      |  103 ++
 arch/arm/plat-spear13xx/include/plat/pl080.h       |   23 +
 arch/arm/plat-spear13xx/include/plat/plug_board.h  |  120 ++
 arch/arm/plat-spear13xx/include/plat/shirq.h       |   73 ++
 arch/arm/plat-spear13xx/include/plat/spi.h         |  123 ++
 arch/arm/plat-spear13xx/include/plat/system.h      |   35 +
 arch/arm/plat-spear13xx/include/plat/timex.h       |   19 +
 arch/arm/plat-spear13xx/include/plat/touchscreen.h |   22 +
 arch/arm/plat-spear13xx/include/plat/udc.h         |   36 +
 arch/arm/plat-spear13xx/include/plat/uncompress.h  |   43 +
 arch/arm/plat-spear13xx/padmux.c                   |  170 +++
 arch/arm/plat-spear13xx/plgpio.c                   |  649 +++++++++++
 arch/arm/plat-spear13xx/pll_clk.S                  |  187 +++
 arch/arm/plat-spear13xx/plug_boards.c              |  258 +++++
 arch/arm/plat-spear13xx/pwm.c                      |  613 ++++++++++
 arch/arm/plat-spear13xx/restart.c                  |   45 +
 arch/arm/plat-spear13xx/shirq.c                    |  118 ++
 arch/arm/plat-spear13xx/smi.c                      |   63 +
 arch/arm/plat-spear13xx/time.c                     |  263 +++++
 arch/arm/plat-spear13xx/udc.c                      |   59 +
 39 files changed, 5893 insertions(+)
 create mode 100644 arch/arm/plat-spear13xx/Kconfig
 create mode 100644 arch/arm/plat-spear13xx/Makefile
 create mode 100644 arch/arm/plat-spear13xx/clcd.c
 create mode 100644 arch/arm/plat-spear13xx/clock.c
 create mode 100644 arch/arm/plat-spear13xx/cpu_suspend.S
 create mode 100644 arch/arm/plat-spear13xx/cpufreq.c
 create mode 100644 arch/arm/plat-spear13xx/i2c_eval_board.c
 create mode 100644 arch/arm/plat-spear13xx/include/plat/adc.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/camif.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/clock.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/cpufreq.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/debug-macro.S
 create mode 100644 arch/arm/plat-spear13xx/include/plat/gpio.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/hardware.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/hdlc.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/i2c.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/io.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/jpeg.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/keyboard.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/padmux.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/pl080.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/plug_board.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/shirq.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/spi.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/system.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/timex.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/touchscreen.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/udc.h
 create mode 100644 arch/arm/plat-spear13xx/include/plat/uncompress.h
 create mode 100644 arch/arm/plat-spear13xx/padmux.c
 create mode 100644 arch/arm/plat-spear13xx/plgpio.c
 create mode 100644 arch/arm/plat-spear13xx/pll_clk.S
 create mode 100644 arch/arm/plat-spear13xx/plug_boards.c
 create mode 100644 arch/arm/plat-spear13xx/pwm.c
 create mode 100644 arch/arm/plat-spear13xx/restart.c
 create mode 100644 arch/arm/plat-spear13xx/shirq.c
 create mode 100644 arch/arm/plat-spear13xx/smi.c
 create mode 100644 arch/arm/plat-spear13xx/time.c
 create mode 100644 arch/arm/plat-spear13xx/udc.c

diff --git a/arch/arm/plat-spear13xx/Kconfig b/arch/arm/plat-spear13xx/Kconfig
new file mode 100644
index 0000000..8deab16
--- /dev/null
+++ b/arch/arm/plat-spear13xx/Kconfig
@@ -0,0 +1,57 @@
+#
+# SPEAr Platform configuration file
+#
+
+if PLAT_SPEAR
+
+choice
+	prompt "ST SPEAr Family"
+	default ARCH_SPEAR3XX
+
+config ARCH_SPEAR13XX
+	bool "SPEAr13XX"
+	select ARM_GIC
+	select CPU_V7
+	select ARCH_SUPPORTS_MSI
+	select HAVE_SMP
+	select MIGHT_HAVE_CACHE_L2X0
+	select ARCH_SUPPORTS_MSI
+	select MIGHT_HAVE_PCI
+
+	help
+	  Supports for ARM's SPEAR13XX family
+
+config ARCH_SPEAR3XX
+	bool "SPEAr3XX"
+	select ARM_VIC
+	select CPU_ARM926T
+	help
+	  Supports for ARM's SPEAR3XX family
+
+config ARCH_SPEAR6XX
+	bool "SPEAr6XX"
+	select ARM_VIC
+	select CPU_ARM926T
+	help
+	  Supports for ARM's SPEAR6XX family
+
+endchoice
+
+config SPEAR_PLUG_BOARDS
+	bool "SPEAr Plug Boards"
+	help
+	  Supports ST SPEAr Plug boards
+
+# Adding SPEAr machine specific configuration files
+source "arch/arm/mach-spear13xx/Kconfig"
+source "arch/arm/mach-spear3xx/Kconfig"
+source "arch/arm/mach-spear6xx/Kconfig"
+
+config SPEAR_PWM
+	tristate "SPEAr Pulse Width Modulator"
+	depends on CPU_SPEAR320 || CPU_SPEAR1340
+	default y
+	help
+	  Support for ST Microelectronics Pulse Width Modulator present on SPEAr Platform.
+
+endif
diff --git a/arch/arm/plat-spear13xx/Makefile b/arch/arm/plat-spear13xx/Makefile
new file mode 100644
index 0000000..ae02da6
--- /dev/null
+++ b/arch/arm/plat-spear13xx/Makefile
@@ -0,0 +1,23 @@
+#
+# SPEAr Platform specific Makefile
+#
+
+# Common support
+obj-y	:= clcd.o clock.o pll_clk.o restart.o smi.o time.o
+
+obj-$(CONFIG_ARCH_SPEAR13XX)	+= padmux.o
+obj-$(CONFIG_CPU_FREQ)		+= cpufreq.o
+obj-$(CONFIG_CPU_SPEAR1310_REVA) += plgpio.o udc.o
+obj-$(CONFIG_CPU_SPEAR1310)	+= plgpio.o
+obj-$(CONFIG_CPU_SPEAR1340)	+= plgpio.o
+obj-$(CONFIG_SPEAR_HDLC)	+= e1phy.o
+obj-$(CONFIG_SPEAR_PWM)		+= pwm.o
+
+obj-$(CONFIG_MACH_SPEAR1310_REVA_EVB)	+= i2c_eval_board.o
+obj-$(CONFIG_MACH_SPEAR1310_EVB)	+= i2c_eval_board.o
+obj-$(CONFIG_MACH_SPEAR1340_EVB)	+= i2c_eval_board.o
+obj-$(CONFIG_SPEAR_PLUG_BOARDS)		+= plug_boards.o
+
+ifeq ($(CONFIG_PM),y)
+obj-$(CONFIG_ARCH_SPEAR13XX)	+= cpu_suspend.o
+endif
diff --git a/arch/arm/plat-spear13xx/clcd.c b/arch/arm/plat-spear13xx/clcd.c
new file mode 100644
index 0000000..1d59f79
--- /dev/null
+++ b/arch/arm/plat-spear13xx/clcd.c
@@ -0,0 +1,192 @@
+/*
+* arch/arm/plat-spear/clcd.c
+*
+* Copyright (C) 2009 ST Microelectronics
+* Shiraz Hashim<shiraz.hashim@st.com>
+* Ashish Priyadarshi<ashish.priyadarshi@st.com>
+*
+* This file is licensed under the terms of the GNU General Public
+* License version 2. This program is licensed "as is" without any
+* warranty of any kind, whether express or implied.
+*/
+
+#include <linux/dma-mapping.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+
+/* This is enough for the size of 800x480 (1.5 MB) */
+#define FRAMESIZE 0x00180000
+
+#ifdef CONFIG_FB_ARMCLCD_SHARP_LQ043T1DG01
+static struct clcd_panel sharp_LQ043T1DG01_in = {
+	.mode = {
+		.name = "Sharp LQ043T1DG01",
+		.refresh = 0,
+		.xres = 480,
+		.yres = 272,
+		.pixclock = 48000,
+		.left_margin = 2,
+		.right_margin = 2,
+		.upper_margin = 2,
+		.lower_margin = 2,
+		.hsync_len = 41,
+		.vsync_len = 11,
+		.sync = 0,/* FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT */
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = TIM2_IOE | TIM2_CLKSEL | 3,
+	.cntl = CNTL_LCDTFT | CNTL_BGR,
+	.bpp = 32,
+};
+#endif
+
+#ifdef CONFIG_FB_ARMCLCD_SAMSUNG_LMS700
+static struct clcd_panel samsung_LMS700_in = {
+	.mode = {
+		.name = "Samsung LMS700",
+		.refresh = 0,
+		.xres = 800,
+		.yres = 480,
+		.pixclock = 48000,
+		.left_margin = 16,
+		.right_margin = 8,
+		.upper_margin = 6,
+		.lower_margin = 5,
+		.hsync_len = 3,
+		.vsync_len = 2,
+		.sync = 0,
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = TIM2_CLKSEL,
+	.cntl = CNTL_LCDTFT | CNTL_BGR,
+	.bpp = 32,
+};
+#endif
+
+#ifdef CONFIG_FB_ARMCLCD_ET057010_640x480
+static struct clcd_panel et057010_640x480_in = {
+	.mode = {
+		.name = "ET057010 640x480",
+		.refresh = 0,
+		.xres = 640,
+		.yres = 480,
+		.pixclock = 48000,
+		.left_margin = 144,
+		.right_margin = 16,
+		.upper_margin = 33,
+		.lower_margin = 10,
+		.hsync_len = 30,
+		.vsync_len = 3,
+		.sync = 0,
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = TIM2_CLKSEL | TIM2_IPC,	/* This display requires 24MHz */
+	.cntl = CNTL_LCDTFT | CNTL_BGR,
+	.bpp = 32,
+};
+#endif
+
+static int clcd_setup(struct clcd_fb *fb)
+{
+	dma_addr_t dma;
+
+	/* Detect which LCD panel is connected */
+#ifdef CONFIG_FB_ARMCLCD_SHARP_LQ043T1DG01
+	fb->panel = &sharp_LQ043T1DG01_in;
+#endif
+#ifdef CONFIG_FB_ARMCLCD_SAMSUNG_LMS700
+	fb->panel = &samsung_LMS700_in;
+#endif
+#ifdef CONFIG_FB_ARMCLCD_ET057010_640x480
+	fb->panel = &et057010_640x480_in;
+#endif
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev, FRAMESIZE,
+			&dma, GFP_KERNEL);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+	fb->fb.fix.smem_start = dma;
+	fb->fb.fix.smem_len = FRAMESIZE;
+
+	return 0;
+}
+
+static int clcd_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
+{
+	var->xres_virtual = var->xres = (var->xres + 15) & ~15;
+	var->yres_virtual = var->yres = (var->yres + 1) & ~1;
+
+#define CHECK(e, l, h) (var->e < l || var->e > h)
+	if (CHECK(right_margin, (1), 256) ||	/* back porch */
+			CHECK(left_margin, (1), 256) ||	/* front porch */
+			CHECK(hsync_len, (1), 256) ||
+			var->xres > 4096 ||
+			var->lower_margin > 255 ||	/* back porch */
+			var->upper_margin > 255 ||	/* front porch */
+			var->vsync_len > 32 ||
+			var->yres > 1024)
+		return -EINVAL;
+#undef CHECK
+
+	/* single panel mode: PCD = max(PCD, 1) */
+	/* dual panel mode: PCD = max(PCD, 5) */
+
+	/*
+	 * You can't change the grayscale setting, and
+	 * we can only do non-interlaced video.
+	 */
+	if (var->grayscale != fb->fb.var.grayscale ||
+			(var->vmode & FB_VMODE_MASK) != FB_VMODE_NONINTERLACED)
+		return -EINVAL;
+
+#define CHECK(e) (var->e != fb->fb.var.e)
+	if (fb->panel->fixedtimings &&
+			(CHECK(xres)		||
+			 CHECK(yres)		||
+			 CHECK(bits_per_pixel)	||
+			 CHECK(pixclock)	||
+			 CHECK(left_margin)	||
+			 CHECK(right_margin)	||
+			 CHECK(upper_margin)	||
+			 CHECK(lower_margin)	||
+			 CHECK(hsync_len)	||
+			 CHECK(vsync_len)	||
+			 CHECK(sync)))
+		return -EINVAL;
+#undef CHECK
+
+	var->nonstd = 0;
+	var->accel_flags = 0;
+
+	return 0;
+}
+
+static void clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+static int clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+			fb->fb.screen_base,
+			fb->fb.fix.smem_start,
+			fb->fb.fix.smem_len);
+}
+
+struct clcd_board clcd_plat_data = {
+	.name = "spear-clcd",
+	.check = clcd_check,
+	.decode = clcdfb_decode,
+	.setup = clcd_setup,
+	.mmap = clcd_mmap,
+	.remove = clcd_remove,
+};
diff --git a/arch/arm/plat-spear13xx/clock.c b/arch/arm/plat-spear13xx/clock.c
new file mode 100644
index 0000000..1dd08f0
--- /dev/null
+++ b/arch/arm/plat-spear13xx/clock.c
@@ -0,0 +1,1223 @@
+/*
+ * arch/arm/plat-spear/clock.c
+ *
+ * Clock framework for SPEAr platform
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/bug.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <plat/clock.h>
+#include <mach/misc_regs.h>
+
+/* pointer to ddr clock structure */
+static struct clk *ddr_clk;
+static DEFINE_SPINLOCK(clocks_lock);
+static LIST_HEAD(root_clks);
+#ifdef CONFIG_DEBUG_FS
+static LIST_HEAD(clocks);
+#endif
+
+static void propagate_rate(struct clk *, int on_init);
+#ifdef CONFIG_DEBUG_FS
+static int clk_debugfs_reparent(struct clk *c, struct clk *old_pclk);
+#endif
+
+static int generic_clk_enable(struct clk *clk)
+{
+	unsigned int val;
+
+	if (!clk->en_reg)
+		return -EFAULT;
+
+	val = readl(clk->en_reg);
+	if (unlikely(clk->flags & RESET_TO_ENABLE))
+		val &= ~(1 << clk->en_reg_bit);
+	else
+		val |= 1 << clk->en_reg_bit;
+
+	writel(val, clk->en_reg);
+
+	return 0;
+}
+
+static void generic_clk_disable(struct clk *clk)
+{
+	unsigned int val;
+
+	if (!clk->en_reg)
+		return;
+
+	val = readl(clk->en_reg);
+	if (unlikely(clk->flags & RESET_TO_ENABLE))
+		val |= 1 << clk->en_reg_bit;
+	else
+		val &= ~(1 << clk->en_reg_bit);
+
+	writel(val, clk->en_reg);
+}
+
+/* generic clk ops */
+static struct clkops generic_clkops = {
+	.enable = generic_clk_enable,
+	.disable = generic_clk_disable,
+};
+
+/* returns current programmed clocks clock info structure */
+static struct pclk_info *pclk_info_get(struct clk *clk)
+{
+	unsigned int val, i;
+	struct pclk_info *info = &clk->pclk_sel->pclk_info[0];
+
+	if (clk->pclk_sel->pclk_sel_reg) {
+		val = readl(clk->pclk_sel->pclk_sel_reg) >> clk->pclk_sel_shift;
+		val &= clk->pclk_sel->pclk_sel_mask;
+
+		for (i = 0; i < clk->pclk_sel->pclk_count; i++) {
+			if (clk->pclk_sel->pclk_info[i].pclk_val == val)
+				info = &clk->pclk_sel->pclk_info[i];
+		}
+	}
+
+	return info;
+}
+
+/*
+ * Set Update pclk, and pclk_info of clk and add clock sibling node to current
+ * parents children list
+ */
+static void clk_reparent(struct clk *clk, struct pclk_info *pclk_info)
+{
+	unsigned long flags;
+	struct clk *old_pclk = clk->pclk;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	list_del(&clk->sibling);
+	list_add(&clk->sibling, &pclk_info->pclk->children);
+
+	clk->pclk = pclk_info->pclk;
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+#ifdef CONFIG_DEBUG_FS
+	clk_debugfs_reparent(clk, old_pclk);
+#endif
+}
+
+static void do_clk_disable(struct clk *clk)
+{
+	if (!clk)
+		return;
+
+	if (!clk->usage_count) {
+		WARN_ON(1);
+		return;
+	}
+
+	clk->usage_count--;
+
+	if (clk->usage_count == 0) {
+		/*
+		 * Surely, there are no active childrens or direct users
+		 * of this clock
+		 */
+		if (clk->pclk)
+			do_clk_disable(clk->pclk);
+
+		if (clk->ops && clk->ops->disable)
+			clk->ops->disable(clk);
+	}
+}
+
+static int do_clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	if (!clk)
+		return -EFAULT;
+
+	if (clk->usage_count == 0) {
+		if (clk->pclk) {
+			ret = do_clk_enable(clk->pclk);
+			if (ret)
+				goto err;
+		}
+		if (clk->ops && clk->ops->enable) {
+			ret = clk->ops->enable(clk);
+			if (ret) {
+				if (clk->pclk)
+					do_clk_disable(clk->pclk);
+				goto err;
+			}
+		}
+		/*
+		 * Since the clock is going to be used for the first
+		 * time please reclac
+		 */
+		if (clk->recalc) {
+			ret = clk->recalc(clk, &clk->rate, clk->pclk->rate);
+			if (ret) {
+				if (clk->ops && clk->ops->disable)
+					clk->ops->disable(clk);
+				if (clk->pclk)
+					do_clk_disable(clk->pclk);
+
+				goto err;
+			}
+		}
+	}
+	clk->usage_count++;
+err:
+	return ret;
+}
+
+/*
+ * clk_enable - inform the system when the clock source should be running.
+ * @clk: clock source
+ *
+ * If the clock can not be enabled/disabled, this should return success.
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	ret = do_clk_enable(clk);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+/*
+ * clk_disable - inform the system when the clock source is no longer required.
+ * @clk: clock source
+ *
+ * Inform the system that a clock source is no longer required by
+ * a driver and may be shut down.
+ *
+ * Implementation detail: if the clock source is shared between
+ * multiple drivers, clk_enable() calls must be balanced by the
+ * same number of clk_disable() calls for the clock source to be
+ * disabled.
+ */
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	do_clk_disable(clk);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+/**
+ * clk_get_rate - obtain the current clock rate (in Hz) for a clock source.
+ *		 This is only valid once the clock source has been enabled.
+ * @clk: clock source
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long flags, rate;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	rate = clk->rate;
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+/**
+ * clk_get_parent - get the parent clock source for this clock
+ * @clk: clock source
+ *
+ * Returns struct clk corresponding to parent clock source, or
+ * valid IS_ERR() condition containing errno.
+ */
+struct clk *clk_get_parent(struct clk *clk)
+{
+	if (!clk || !clk->pclk)
+		return ERR_PTR(-ENOENT);
+
+	return clk->pclk;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+/**
+ * clk_set_parent - set the parent clock source for this clock
+ * @clk: clock source
+ * @parent: parent clock source
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	int i, found = 0, val = 0;
+	unsigned long flags;
+
+	if (!clk || !parent)
+		return -EFAULT;
+	if (clk->pclk == parent)
+		return 0;
+	if (!clk->pclk_sel)
+		return -EPERM;
+
+	/* check if requested parent is in clk parent list */
+	for (i = 0; i < clk->pclk_sel->pclk_count; i++) {
+		if (clk->pclk_sel->pclk_info[i].pclk == parent) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return -EINVAL;
+
+	/*
+	 * It may happen that there is no real address associated with a
+	 * parent clock selection. This can be true for virtual clocks
+	 * and in some cases clocks where the selection is in the domain
+	 * of device itself (example clcd)
+	 * In those cases there would not be a register (and a value)
+	 * associated which can select a parent. We only would reflect
+	 * properly all s/w status
+	 */
+	if (clk->pclk_sel->pclk_sel_reg) {
+		spin_lock_irqsave(&clocks_lock, flags);
+
+		val = readl(clk->pclk_sel->pclk_sel_reg);
+		val &= ~(clk->pclk_sel->pclk_sel_mask << clk->pclk_sel_shift);
+		val |= clk->pclk_sel->pclk_info[i].pclk_val
+			<< clk->pclk_sel_shift;
+		writel(val, clk->pclk_sel->pclk_sel_reg);
+
+		spin_unlock_irqrestore(&clocks_lock, flags);
+	}
+
+	/* reflect parent change in software */
+	clk_reparent(clk, &clk->pclk_sel->pclk_info[i]);
+
+	if (clk->recalc)
+		BUG_ON(clk->recalc(clk, &clk->rate, clk->pclk->rate));
+
+	propagate_rate(clk, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+int clk_set_parent_sys(char *dev_id, char *con_id, char *pdev_id, char *pcon_id)
+{
+	struct clk *clk, *pclk;
+	int ret = 0;
+
+	clk = clk_get_sys(dev_id, con_id);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	pclk = clk_get_sys(pdev_id, pcon_id);
+	if (IS_ERR(pclk)) {
+		ret = PTR_ERR(pclk);
+		goto put_clk;
+	}
+
+	ret = clk_set_parent(clk, pclk);
+	clk_put(pclk);
+
+put_clk:
+	clk_put(clk);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent_sys);
+
+/**
+ * clk_set_rate - set the clock rate for a clock source
+ * @clk: clock source
+ * @rate: desired clock rate in Hz
+ *
+ * Returns success (0) or negative errno.
+ */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (!clk || !rate)
+		return -EFAULT;
+
+	if (clk->set_rate) {
+		spin_lock_irqsave(&clocks_lock, flags);
+		ret = clk->set_rate(clk, rate);
+		if (!ret)
+			/* if successful -> propagate */
+			propagate_rate(clk, 0);
+		spin_unlock_irqrestore(&clocks_lock, flags);
+	} else if (clk->pclk) {
+		u32 mult;
+		/*
+		 * if pclk is SYSTEM_CLK and clk is not SYSTEM_CLK then return
+		 * error
+		 */
+		if (clk->pclk->flags & SYSTEM_CLK)
+			if (!(clk->flags & SYSTEM_CLK))
+				return -EPERM;
+
+		mult = clk->div_factor ? clk->div_factor : 1;
+		ret = clk_set_rate(clk->pclk, mult * rate);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+int clk_set_rate_sys(char *dev_id, char *con_id, unsigned long rate)
+{
+	struct clk *clk;
+	int ret = 0;
+
+	clk = clk_get_sys(dev_id, con_id);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	ret = clk_set_rate(clk, rate);
+	clk_put(clk);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate_sys);
+
+/* registers clock in platform clock framework */
+void clk_register(struct clk_lookup *cl)
+{
+	struct clk *clk;
+	unsigned long flags;
+
+	if (!cl || !cl->clk)
+		return;
+	clk = cl->clk;
+
+	/*
+	 * There can be multiple clk_lookups associated with single clk
+	 * structure. So if this clk is iterated once, then don't do following
+	 * steps next time.
+	 */
+#ifdef CONFIG_DEBUG_FS
+	if (clk->cl)
+		goto clkdev_add;
+#endif
+
+	spin_lock_irqsave(&clocks_lock, flags);
+
+	INIT_LIST_HEAD(&clk->children);
+	if (clk->flags & ALWAYS_ENABLED)
+		clk->ops = NULL;
+	else if (!clk->ops)
+		clk->ops = &generic_clkops;
+
+	/* root clock don't have any parents */
+	if (!clk->pclk && !clk->pclk_sel) {
+		list_add(&clk->sibling, &root_clks);
+	} else if (clk->pclk && !clk->pclk_sel) {
+		/* add clocks with only one parent to parent's children list */
+		list_add(&clk->sibling, &clk->pclk->children);
+	} else {
+		/* clocks with more than one parent */
+		struct pclk_info *pclk_info;
+
+		pclk_info = pclk_info_get(clk);
+		if (!pclk_info) {
+			pr_err("CLKDEV: invalid pclk info of clk with"
+					" %s dev_id and %s con_id\n",
+					cl->dev_id, cl->con_id);
+		} else {
+			clk->pclk = pclk_info->pclk;
+			list_add(&clk->sibling, &pclk_info->pclk->children);
+		}
+	}
+
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	/* debugfs specific */
+#ifdef CONFIG_DEBUG_FS
+	list_add(&clk->node, &clocks);
+	clk->cl = cl;
+#endif
+
+clkdev_add:
+	/* add clock to arm clockdev framework */
+	clkdev_add(cl);
+}
+
+/**
+ * propagate_rate - recalculate and propagate all clocks to children
+ * @pclk: parent clock required to be propogated
+ * @on_init: flag for enabling clocks which are ENABLED_ON_INIT.
+ *
+ * Recalculates all children clocks
+ */
+void propagate_rate(struct clk *pclk, int on_init)
+{
+	struct clk *clk, *_temp;
+	int ret = 0;
+
+	list_for_each_entry_safe(clk, _temp, &pclk->children, sibling) {
+		if (clk->recalc) {
+			ret = clk->recalc(clk, &clk->rate, clk->pclk->rate);
+			/*
+			 * recalc will return error if clk out is not programmed
+			 * In this case configure default rate.
+			 */
+			if (ret && clk->set_rate)
+				clk->set_rate(clk, 0);
+		}
+		propagate_rate(clk, on_init);
+
+		if (!on_init)
+			continue;
+
+		/* Enable clks enabled on init, in software view */
+		if (clk->flags & ENABLED_ON_INIT)
+			do_clk_enable(clk);
+	}
+}
+
+/* updates "rate" pointer with current_clk's output for input "rate" */
+static void rate_calc(struct clk *current_clk, struct clk *ancestor_clk,
+		unsigned long *rate)
+{
+	if (current_clk->pclk != ancestor_clk)
+		rate_calc(current_clk->pclk, ancestor_clk, rate);
+
+	if (current_clk->recalc)
+		current_clk->recalc(current_clk, rate, *rate);
+}
+
+/*
+ * Check if ancestor clk rate is acceptable to ddr or not.
+ * This will call recursive rate_calc function, starting from ddr upto ancestor
+ * clk mentioned. This will calculate divisions / multiplications by all
+ * intermediate ancestor clocks and return the final rate of ddr if ancestor clk
+ * sets its rate to "rate", value passed in function.
+ */
+static int ddr_rate_acceptable(struct clk *aclk, unsigned long rate)
+{
+	struct ddr_rate_tbl *tbl = ddr_clk->private_data;
+
+	rate_calc(ddr_clk, aclk, &rate);
+	if ((rate >= tbl->minrate) && (rate <= tbl->maxrate))
+		return true;
+
+	return false;
+}
+
+/* mark all ddr ancestors with DDR_ANCESTOR flag */
+static void mark_ddr_ancestors(struct clk *dclk)
+{
+	struct clk *clk = dclk->pclk;
+
+	/* mark all ancestors of DDR */
+	while (clk != NULL) {
+		clk->flags |= DDR_ANCESTOR;
+		clk = clk->pclk;
+	}
+}
+
+/**
+ * round_rate_index - return closest programmable rate index in rate_config tbl
+ * @clk: ptr to clock structure
+ * @drate: desired rate
+ * @rate: final rate will be returned in this variable only.
+ *
+ * Finds index in rate_config for highest clk rate which is less than
+ * requested rate. If there is no clk rate lesser than requested rate then
+ * -EINVAL is returned. This routine assumes that rate_config is written
+ * in incrementing order of clk rates.
+ * If drate passed is zero then default rate is programmed.
+ */
+static int
+round_rate_index(struct clk *clk, unsigned long drate, unsigned long *rate)
+{
+	unsigned long tmp = 0, prev_rate = 0;
+	int index;
+
+	if (!clk->calc_rate)
+		return -EFAULT;
+
+	/* Set default rate if desired rate is 0 */
+	if (!drate) {
+		index = clk->rate_config.default_index;
+		*rate = clk->calc_rate(clk, index);
+		return index;
+	}
+
+	/*
+	 * This loops ends on two conditions:
+	 * - as soon as clk is found with rate greater than requested rate.
+	 * - if all clks in rate_config are smaller than requested rate.
+	 */
+	for (index = 0; index < clk->rate_config.count; index++) {
+		prev_rate = tmp;
+		tmp = clk->calc_rate(clk, index);
+		if (drate < tmp) {
+			index--;
+			break;
+		}
+	}
+	/* return if can't find suitable clock */
+	if (index < 0) {
+		index = -EINVAL;
+		*rate = 0;
+	} else if (index == clk->rate_config.count) {
+		/* program with highest clk rate possible */
+		index = clk->rate_config.count - 1;
+		*rate = tmp;
+	} else
+		*rate = prev_rate;
+
+	return index;
+}
+
+/**
+ * clk_round_rate - adjust a rate to the exact rate a clock can provide
+ * @clk: clock source
+ * @rate: desired clock rate in Hz
+ *
+ * Returns rounded clock rate in Hz, or negative errno.
+ */
+long clk_round_rate(struct clk *clk, unsigned long drate)
+{
+	long rate = 0;
+	int index;
+
+	/* propage call to parent who supports calc_rate */
+	if (!clk->calc_rate) {
+		u32 mult;
+		if (!clk->pclk)
+			return clk->rate;
+
+		mult = clk->div_factor ? clk->div_factor : 1;
+		return clk_round_rate(clk->pclk, mult * drate) / mult;
+	}
+
+	index = round_rate_index(clk, drate, &rate);
+	if (index >= 0)
+		return rate;
+	else
+		return index;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+/*All below functions are called with lock held */
+
+/*
+ * In normal mode
+ * rate = (2 * M[15:8] * Fin)/N
+ *
+ * In Dithered mode
+ * rate = (2 * M[15:0] * Fin)/(256 * N)
+ *
+ * pll_rate = vco/2^p
+ *
+ * vco and pll are very closely bound to each other,
+ * "vco needs to program: mode, m & n" and "pll needs to program p", both share
+ * common enable/disable logic.
+ * In clock framework all programming is left on vco and pll will be always
+ * enabled. Moreover vco_set_rate will expect desired_rate as desired_rate of
+ * pll instead of vco, so that all m, n, p can be configured here only. pll will
+ * only support clk_recalc based on programmed value of vco and p.
+ */
+
+/* Calculates vco clk rate for specific value of mode, m, n and p */
+unsigned long vco_calc_rate(struct clk *clk, int index)
+{
+	unsigned long rate = clk->pclk->rate;
+	struct vco_rate_tbl *tbls = clk->rate_config.tbls;
+	unsigned int mode;
+
+	mode = tbls[index].mode ? 256 : 1;
+	return (((2 * rate / 10000) * tbls[index].m) /
+			(mode * tbls[index].n * (1 << tbls[index].p))) * 10000;
+}
+
+/* calculates current programmed rate of vco */
+int vco_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	struct vco_clk_config *config = clk->private_data;
+	unsigned int num = 2, den = 0, val, mode = 0;
+
+	mode = (readl(config->mode_reg) >> config->masks->mode_shift) &
+		config->masks->mode_mask;
+
+	val = readl(config->cfg_reg);
+	/* calculate denominator */
+	den = (val >> config->masks->div_n_shift) & config->masks->div_n_mask;
+
+	/* calculate numerator & denominator */
+	if (!mode) {
+		/* Normal mode */
+		num *= (val >> config->masks->norm_fdbk_m_shift) &
+			config->masks->norm_fdbk_m_mask;
+	} else {
+		/* Dithered mode */
+		num *= (val >> config->masks->dith_fdbk_m_shift) &
+			config->masks->dith_fdbk_m_mask;
+		den *= 256;
+	}
+
+	if (!den)
+		return -EINVAL;
+
+	*rate = (((prate/10000) * num) / den) * 10000;
+	return 0;
+}
+
+/* Configures new clock rate of vco */
+int vco_clk_set_rate(struct clk *clk, unsigned long desired_rate)
+{
+	struct vco_rate_tbl *tbls = clk->rate_config.tbls;
+	struct vco_clk_config *config = clk->private_data;
+	struct vco_clk_masks *masks = config->masks;
+	struct clk *pll_clk, *_tmp;
+	unsigned long val, rate, finish;
+	int i;
+
+	i = round_rate_index(clk, desired_rate, &rate);
+	if (i < 0)
+		return i;
+
+	/* if clk is ddrs ancestor, check if rate is acceptable to ddr */
+	if (ddr_clk && (clk->flags & DDR_ANCESTOR)) {
+		int ret;
+
+		/*
+		 * Since desired_rate is rate of pll instead of vco, we
+		 * need to send pll's clk struct to ddr_rate_acceptable.
+		 */
+		list_for_each_entry_safe(pll_clk, _tmp, &clk->children, sibling)
+			if (pll_clk->flags & DDR_ANCESTOR)
+				break;
+
+		ret = ddr_rate_acceptable(pll_clk, rate);
+		if (ret == false)
+			return -EPERM;
+		else {
+			/*
+			 * call routine to put ddr in refresh mode, and
+			 * configure vco.
+			 */
+			vco_set_rate(tbls[i].m, tbls[i].p, tbls[i].n);
+			clk->rate = rate * (1 << tbls[i].p);
+		}
+		return 0;
+	}
+
+	/* disable PLL */
+	generic_clk_disable(clk);
+
+	val = readl(config->mode_reg);
+	val &= ~(masks->mode_mask << masks->mode_shift);
+	val |= (tbls[i].mode & masks->mode_mask) << masks->mode_shift;
+	writel(val, config->mode_reg);
+
+	val = readl(config->cfg_reg);
+	val &= ~(masks->div_p_mask << masks->div_p_shift);
+	val |= (tbls[i].p & masks->div_p_mask) << masks->div_p_shift;
+	val &= ~(masks->div_n_mask << masks->div_n_shift);
+	val |= (tbls[i].n & masks->div_n_mask) << masks->div_n_shift;
+	val &= ~(masks->dith_fdbk_m_mask << masks->dith_fdbk_m_shift);
+	if (tbls[i].mode)
+		val |= (tbls[i].m & masks->dith_fdbk_m_mask) <<
+			masks->dith_fdbk_m_shift;
+	else
+		val |= (tbls[i].m & masks->norm_fdbk_m_mask) <<
+			masks->norm_fdbk_m_shift;
+
+	writel(val, config->cfg_reg);
+	clk->rate = rate * (1 << tbls[i].p);
+
+	/* enable PLL1 */
+	generic_clk_enable(clk);
+
+	/* wait for PLL lock */
+	finish = jiffies + HZ;
+	do {
+		val = readl(config->mode_reg);
+		val &= masks->pll_lock_mask << masks->pll_lock_shift;
+		if (val)
+			break;
+		udelay(1000);
+	} while (!time_after_eq(jiffies, finish));
+
+	BUG_ON(!val);
+
+	return 0;
+}
+
+/* calculates current programmed rate of pll = vco/2^p */
+int pll_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	struct vco_clk_config *config = clk->pclk->private_data;
+	unsigned int p;
+
+	p = readl(config->cfg_reg);
+	p = (p >> config->masks->div_p_shift) & config->masks->div_p_mask;
+
+	*rate = prate / (1 << p);
+	return 0;
+}
+
+/*
+ * Calculates ahb, apb clk rate for specific value of div
+ */
+unsigned long bus_calc_rate(struct clk *clk, int index)
+{
+	unsigned long rate = clk->pclk->rate;
+	struct bus_rate_tbl *tbls = clk->rate_config.tbls;
+
+	return rate / (tbls[index].div + 1);
+}
+
+/* calculates current programmed rate of ahb or apb bus */
+int bus_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	struct bus_clk_config *config = clk->private_data;
+	unsigned int div;
+
+	div = ((readl(config->reg) >> config->masks->shift) &
+			config->masks->mask) + 1;
+
+	if (!div)
+		return -EINVAL;
+
+	*rate = prate / div;
+	return 0;
+}
+
+/* Configures new clock rate of AHB OR APB bus */
+int bus_clk_set_rate(struct clk *clk, unsigned long desired_rate)
+{
+	struct bus_rate_tbl *tbls = clk->rate_config.tbls;
+	struct bus_clk_config *config = clk->private_data;
+	unsigned long val, rate;
+	int i;
+
+	i = round_rate_index(clk, desired_rate, &rate);
+	if (i < 0)
+		return i;
+
+	val = readl(config->reg) &
+		~(config->masks->mask << config->masks->shift);
+	val |= (tbls[i].div & config->masks->mask) << config->masks->shift;
+	writel(val, config->reg);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+/* calculates current programmed rate of ahbmult2 */
+int
+ahbmult2_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	*rate = prate * 2;
+	return 0;
+}
+
+/*
+ * gives rate for different values of eq, x and y
+ *
+ * Fout from synthesizer can be given from two equations:
+ * Fout1 = (Fin * X/Y)/2		EQ1
+ * Fout2 = Fin * X/Y			EQ2
+ */
+unsigned long aux_calc_rate(struct clk *clk, int index)
+{
+	unsigned long rate = clk->pclk->rate;
+	struct aux_rate_tbl *tbls = clk->rate_config.tbls;
+	u8 eq = tbls[index].eq ? 1 : 2;
+
+	return (((rate/10000) * tbls[index].xscale) /
+			(tbls[index].yscale * eq)) * 10000;
+}
+
+/*
+ * calculates current programmed rate of auxiliary synthesizers
+ * used by: UART, FIRDA
+ *
+ * Fout from synthesizer can be given from two equations:
+ * Fout1 = (Fin * X/Y)/2
+ * Fout2 = Fin * X/Y
+ *
+ * Selection of eqn 1 or 2 is programmed in register
+ */
+int aux_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	struct aux_clk_config *config = clk->private_data;
+	unsigned int num = 1, den = 1, val, eqn;
+
+	val = readl(config->synth_reg);
+
+	eqn = (val >> config->masks->eq_sel_shift) &
+		config->masks->eq_sel_mask;
+	if (eqn == config->masks->eq1_mask)
+		den *= 2;
+
+	/* calculate numerator */
+	num = (val >> config->masks->xscale_sel_shift) &
+		config->masks->xscale_sel_mask;
+
+	/* calculate denominator */
+	den *= (val >> config->masks->yscale_sel_shift) &
+		config->masks->yscale_sel_mask;
+
+	if (!den)
+		return -EINVAL;
+
+	*rate = (((prate / 10000) * num) / den) * 10000;
+	return 0;
+}
+
+/* Configures new clock rate of auxiliary synthesizers used by: UART, FIRDA*/
+int aux_clk_set_rate(struct clk *clk, unsigned long desired_rate)
+{
+	struct aux_rate_tbl *tbls = clk->rate_config.tbls;
+	struct aux_clk_config *config = clk->private_data;
+	unsigned long val, rate;
+	int i;
+
+	i = round_rate_index(clk, desired_rate, &rate);
+	if (i < 0)
+		return i;
+
+	val = readl(config->synth_reg) &
+		~(config->masks->eq_sel_mask << config->masks->eq_sel_shift);
+	val |= (tbls[i].eq & config->masks->eq_sel_mask) <<
+		config->masks->eq_sel_shift;
+	val &= ~(config->masks->xscale_sel_mask <<
+			config->masks->xscale_sel_shift);
+	val |= (tbls[i].xscale & config->masks->xscale_sel_mask) <<
+		config->masks->xscale_sel_shift;
+	val &= ~(config->masks->yscale_sel_mask <<
+			config->masks->yscale_sel_shift);
+	val |= (tbls[i].yscale & config->masks->yscale_sel_mask) <<
+		config->masks->yscale_sel_shift;
+	writel(val, config->synth_reg);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+/*
+ * Calculates gpt clk rate for different values of mscale and nscale
+ *
+ * Fout= Fin/((2 ^ (N+1)) * (M+1))
+ */
+unsigned long gpt_calc_rate(struct clk *clk, int index)
+{
+	unsigned long rate = clk->pclk->rate;
+	struct gpt_rate_tbl *tbls = clk->rate_config.tbls;
+
+	return rate / ((1 << (tbls[index].nscale + 1)) *
+			(tbls[index].mscale + 1));
+}
+
+/*
+ * calculates current programmed rate of gpt synthesizers
+ * Fout from synthesizer can be given from below equations:
+ * Fout= Fin/((2 ^ (N+1)) * (M+1))
+ */
+int gpt_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	struct gpt_clk_config *config = clk->private_data;
+	unsigned int div = 1, val;
+
+	val = readl(config->synth_reg);
+	div += (val >> config->masks->mscale_sel_shift) &
+		config->masks->mscale_sel_mask;
+	div *= 1 << (((val >> config->masks->nscale_sel_shift) &
+				config->masks->nscale_sel_mask) + 1);
+
+	if (!div)
+		return -EINVAL;
+
+	*rate = prate / div;
+	return 0;
+}
+
+/* Configures new clock rate of gptiliary synthesizers used by: UART, FIRDA*/
+int gpt_clk_set_rate(struct clk *clk, unsigned long desired_rate)
+{
+	struct gpt_rate_tbl *tbls = clk->rate_config.tbls;
+	struct gpt_clk_config *config = clk->private_data;
+	unsigned long val, rate;
+	int i;
+
+	i = round_rate_index(clk, desired_rate, &rate);
+	if (i < 0)
+		return i;
+
+	val = readl(config->synth_reg) & ~(config->masks->mscale_sel_mask <<
+			config->masks->mscale_sel_shift);
+	val |= (tbls[i].mscale & config->masks->mscale_sel_mask) <<
+		config->masks->mscale_sel_shift;
+	val &= ~(config->masks->nscale_sel_mask <<
+			config->masks->nscale_sel_shift);
+	val |= (tbls[i].nscale & config->masks->nscale_sel_mask) <<
+		config->masks->nscale_sel_shift;
+	writel(val, config->synth_reg);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+/*
+ * Fout from synthesizer can be given from below equation:
+ * Fout= Fin/2*div (division factor)
+ * div is 17 bits:-
+ *	0-13 (fractional part)
+ *	14-16 (integer part)
+ *	div is (16-14 bits).(13-0 bits) (in binary)
+ *
+ *	Fout = Fin/(2 * div)
+ *	Fout = ((Fin / 10000)/(2 * div)) * 10000
+ *	Fout = (2^14 * (Fin / 10000)/(2^14 * (2 * div))) * 10000
+ *	Fout = (((Fin / 10000) << 14)/(2 * (div << 14))) * 10000
+ *
+ * div << 14 simply 17 bit value written at register.
+ * Max error due to scaling down by 10000 is 10 KHz
+ */
+
+/* Calculates Synthesizer clk rate for different values of div */
+unsigned long frac_synth_calc_rate(struct clk *clk, int index)
+{
+	unsigned long rate = clk->pclk->rate;
+	struct frac_synth_rate_tbl *tbls = clk->rate_config.tbls;
+
+	rate /= 10000;
+	rate <<= 14;
+	rate /= (2 * tbls[index].div);
+	rate *= 10000;
+
+	return rate;
+}
+
+/* calculates current programmed rate of synthesizer */
+int frac_synth_clk_recalc(struct clk *clk, unsigned long *rate,
+		unsigned long prate)
+{
+	struct frac_synth_clk_config *config = clk->private_data;
+	unsigned int div = 1;
+	unsigned int val;
+
+	val = readl(config->synth_reg);
+	div = (val >> config->masks->div_factor_shift) &
+		config->masks->div_factor_mask;
+
+	if (!div)
+		return -EINVAL;
+
+	prate = prate / 10000;
+
+	*rate = ((unsigned long)prate << 14) / (2 * div);
+	*rate *= 10000;
+	return 0;
+}
+
+/* Configures new clock rate of auxiliary synthesizers used by: UART, FIRDA*/
+int frac_synth_clk_set_rate(struct clk *clk, unsigned long desired_rate)
+{
+	struct frac_synth_rate_tbl *tbls = clk->rate_config.tbls;
+	struct frac_synth_clk_config *config = clk->private_data;
+	unsigned long val, rate;
+	int i;
+
+	i = round_rate_index(clk, desired_rate, &rate);
+	if (i < 0)
+		return i;
+
+	val = readl(config->synth_reg) & ~(config->masks->div_factor_mask <<
+			config->masks->div_factor_shift);
+	val |= (tbls[i].div & config->masks->div_factor_mask) <<
+		config->masks->div_factor_shift;
+	writel(val, config->synth_reg);
+
+	clk->rate = rate;
+
+	return 0;
+}
+
+/*
+ * Used for clocks that always have value as the parent clock divided by a
+ * fixed divisor
+ */
+int follow_parent(struct clk *clk, unsigned long *rate, unsigned long prate)
+{
+	unsigned int div_factor = (clk->div_factor < 1) ? 1 : clk->div_factor;
+
+	*rate = prate / div_factor;
+	return 0;
+}
+
+/**
+ * recalc_root_clocks - recalculate and propagate all root clocks
+ *
+ * Recalculates all root clocks (clocks with no parent), which if the
+ * clock's .recalc is set correctly, should also propagate their rates.
+ */
+void recalc_root_clocks(void)
+{
+	struct clk *pclk;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	list_for_each_entry(pclk, &root_clks, sibling) {
+		if (pclk->recalc) {
+			ret = pclk->recalc(pclk, &pclk->rate, pclk->pclk->rate);
+			/*
+			 * recalc will return error if clk out is not programmed
+			 * In this case configure default clock.
+			 */
+			if (ret && pclk->set_rate)
+				pclk->set_rate(pclk, 0);
+		}
+		propagate_rate(pclk, 1);
+		/* Enable clks enabled on init, in software view */
+		if (pclk->flags & ENABLED_ON_INIT)
+			do_clk_enable(pclk);
+	}
+	spin_unlock_irqrestore(&clocks_lock, flags);
+}
+
+void __init clk_init(struct clk *dclk)
+{
+	recalc_root_clocks();
+
+	/* Mark all ancestors of DDR with special flag */
+	if (dclk) {
+		ddr_clk = dclk;
+		mark_ddr_ancestors(dclk);
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+/*
+ *	debugfs support to trace clock tree hierarchy and attributes
+ */
+static struct dentry *clk_debugfs_root;
+static int clk_debugfs_register_one(struct clk *c)
+{
+	int err;
+	struct dentry *d;
+	struct clk *pa = c->pclk;
+	char s[255];
+	char *p = s;
+
+	if (c) {
+		if (c->cl->con_id) {
+			p += sprintf(p, "%s", c->cl->con_id);
+
+			if (c->cl->dev_id)
+				p += sprintf(p, "%s", "-");
+		}
+		if (c->cl->dev_id)
+			p += sprintf(p, "%s", c->cl->dev_id);
+	}
+	d = debugfs_create_dir(s, pa ? pa->dent : clk_debugfs_root);
+	if (!d)
+		return -ENOMEM;
+	c->dent = d;
+
+	d = debugfs_create_u32("usage_count", S_IRUGO, c->dent,
+			(u32 *)&c->usage_count);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_u32("rate", S_IRUGO, c->dent, (u32 *)&c->rate);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_x32("flags", S_IRUGO, c->dent, (u32 *)&c->flags);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	return 0;
+
+err_out:
+	debugfs_remove_recursive(c->dent);
+	return err;
+}
+
+static int clk_debugfs_register(struct clk *c)
+{
+	int err;
+	struct clk *pa = c->pclk;
+
+	if (pa && !pa->dent) {
+		err = clk_debugfs_register(pa);
+		if (err)
+			return err;
+	}
+
+	if (!c->dent) {
+		err = clk_debugfs_register_one(c);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int __init clk_debugfs_init(void)
+{
+	struct clk *c;
+	struct dentry *d;
+	int err;
+
+	d = debugfs_create_dir("clock", NULL);
+	if (!d)
+		return -ENOMEM;
+	clk_debugfs_root = d;
+
+	list_for_each_entry(c, &clocks, node) {
+		err = clk_debugfs_register(c);
+		if (err)
+			goto err_out;
+	}
+	return 0;
+err_out:
+	debugfs_remove_recursive(clk_debugfs_root);
+	return err;
+}
+late_initcall(clk_debugfs_init);
+
+static int clk_debugfs_reparent(struct clk *c, struct clk *old_pclk)
+{
+	if (c->dent)
+		debugfs_rename(old_pclk->dent, c->dent, c->pclk->dent,
+				c->dent->d_iname);
+
+	return 0;
+}
+#endif /* CONFIG_DEBUG_FS */
diff --git a/arch/arm/plat-spear13xx/cpu_suspend.S b/arch/arm/plat-spear13xx/cpu_suspend.S
new file mode 100644
index 0000000..5671c22
--- /dev/null
+++ b/arch/arm/plat-spear13xx/cpu_suspend.S
@@ -0,0 +1,44 @@
+/*
+ * linux/arch/arm/plat-spear/cpu_suspend.S
+ *
+ * SPEAR6xx/3xx specific functions that will call the kernel handlers to
+ * put the latch the cpu specific configurations on the DDR before
+ * moving into sleep.
+ * The functions are used in power management.
+ *
+ * Copyright (C) 2010 ST MicroElectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/suspend.h>
+
+.text
+/*
+ * spear_cpu_suspend()
+ * Put the CPU into suspend mode.
+ */
+ENTRY(spear_cpu_suspend)
+	stmfd	sp!, {r4-r12, lr}		@ save registers on stack
+	ldr	r8, =IO_ADDRESS(SPEAR_SRAM_STACK_PA)
+	stmia	r8!, {r0}
+	ldr	r3, =resume_with_mmu
+	bl	cpu_suspend
+
+	/*
+	 * Do the necessary platform specific power management
+	 * from the SRAM.
+	 */
+	ldr	r3, =IO_ADDRESS(SPEAR_SRAM_STACK_PA)
+	ldmia	r3!, {r0}
+	bl	spear_sys_suspend
+
+resume_with_mmu:
+	ldmfd	sp!, {r4-r12, pc}		@ restore regs and return
+	nop
+	.ltorg
diff --git a/arch/arm/plat-spear13xx/cpufreq.c b/arch/arm/plat-spear13xx/cpufreq.c
new file mode 100644
index 0000000..c835b1b
--- /dev/null
+++ b/arch/arm/plat-spear13xx/cpufreq.c
@@ -0,0 +1,351 @@
+/*
+ * arch/arm/plat-spear/cpufreq.c
+ *
+ * CPU Frequency Scaling for SPEAr platform
+ *
+ * Copyright (C) 2010-2012 ST Microelectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <asm/system.h>
+#include <plat/cpufreq.h>
+#include <mach/hardware.h>
+#include <mach/system.h>
+
+struct {
+	struct clk *cpu_clk;
+	struct cpufreq_frequency_table *freq_tbl;
+	u32 freq_tbl_len;
+	unsigned int min_freq;
+	unsigned int max_freq;
+	unsigned int transition_latency;
+} spear_cpufreq;
+
+int spear_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, spear_cpufreq.freq_tbl);
+}
+
+static unsigned int spear_cpufreq_get(unsigned int cpu)
+{
+	return cpu ? 0 : clk_get_rate(spear_cpufreq.cpu_clk) / 1000;
+}
+
+static struct clk *spear1340_cpu_get_possible_parent(unsigned long newfreq)
+{
+	int pclk;
+	struct clk *sys_pclk;
+	/*
+	 * In SPEAr1340, cpu clk's parent sys clk can take input from
+	 * following sources
+	 */
+	const char *sys_clk_src[] = {
+		"sys_synth_clk",
+		"pll1_clk",
+		"pll2_clk",
+		"pll3_clk",
+	};
+
+	/*
+	 * As sys clk can have multiple source with their own range
+	 * limitation so we choose possible sources accordingly
+	 */
+	if (newfreq <= 250000000)
+		pclk = 0; /* src is sys_synth_clk */
+	else if (newfreq <= 600000000)
+		pclk = 3; /* src is pll3_clk */
+	else
+		return ERR_PTR(-EINVAL);
+
+	/* Get parent to sys clock */
+	sys_pclk = clk_get(NULL, sys_clk_src[pclk]);
+	if (IS_ERR(sys_pclk))
+		pr_err("SPEAr1340: Failed to get %s clock\n",
+				sys_clk_src[pclk]);
+
+	return sys_pclk;
+}
+
+static int spear1340_set_cpu_rate(struct clk *sys_pclk, unsigned long newfreq)
+{
+	struct clk *sys_clk;
+	int ret = 0;
+
+	sys_clk = clk_get_parent(spear_cpufreq.cpu_clk);
+	if (IS_ERR(sys_clk)) {
+		pr_err("failed to get cpu's parent (sys) clock\n");
+		return PTR_ERR(sys_clk);
+	}
+
+	/*
+	 * Set the rate of the source clock before changing the parent
+	 * Note: newfreq = intended cpu_clk * 2 in case of SPEAr1340
+	 */
+	ret = clk_set_rate(sys_pclk, newfreq);
+	if (ret) {
+		pr_err("SPEAr1340: Failed to set sys clk rate to %lu\n",
+				newfreq);
+		return ret;
+	}
+
+	ret = clk_set_parent(sys_clk, sys_pclk);
+	if (ret) {
+		pr_err("SPEAr1340: Failed to set sys clk parent\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static bool slow_mode_required(struct clk *clk)
+{
+	struct clk *sys_pclk;
+
+	if (cpu_is_spear1340()) {
+		sys_pclk = clk_get(NULL, "sys_synth_clk");
+		if (IS_ERR(sys_pclk))
+			WARN(1, "couldn't get system synthesizer clk");
+		else
+			clk_put(sys_pclk);
+		/*
+		 * slow mode not required if cpu is on synth.
+		 * Also to be on safe side let system change to slow
+		 * mode if sys_pclk has error
+		 */
+		return (clk == sys_pclk) ? false: true;
+	} else if (arch_is_spear13xx()) {
+		return true;
+	} else {
+		/*
+		 * case of spear3xx/6xx is separatly handled as we need
+		 * to put ddr into self refresh before changing pll rate
+		 */
+		return false;
+	}
+}
+
+static int spear_cpufreq_target(struct cpufreq_policy *policy,
+		unsigned int target_freq, unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	int index, ret, slow_mode;
+	unsigned long newfreq, srcfreq;
+	struct clk *srcclk;
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	if (cpufreq_frequency_table_target(policy, spear_cpufreq.freq_tbl,
+				target_freq, relation, &index))
+		return -EINVAL;
+
+	freqs.old = spear_cpufreq_get(0);
+	freqs.cpu = policy->cpu;
+
+	if (freqs.old == target_freq)
+		return 0;
+
+	newfreq = spear_cpufreq.freq_tbl[index].frequency * 1000;
+	if (cpu_is_spear1340()) {
+		/*
+		 * SPEAr1340 is special in the sense that due to the
+		 * possibility of multiple clock sources for cpu clk's
+		 * parent we can have different clock source for
+		 * different frequency of cpu clk.
+		 * Hence we need to choose one from amongst these
+		 * possible clock sources.
+		 */
+		srcclk = spear1340_cpu_get_possible_parent(newfreq);
+		if (IS_ERR(srcclk)) {
+			pr_err("Failed to get src clk\n");
+			return PTR_ERR(srcclk);
+		}
+
+		/* SPEAr1340: src clk is always 2 * intended cpu clk */
+		srcfreq = newfreq * 2;
+	} else {
+		/*
+		 * Rest: src clock to be altered is ancestor of cpu
+		 * clock. Hence we can directly work on cpu clk
+		 */
+		srcclk = spear_cpufreq.cpu_clk;
+		srcfreq = newfreq;
+	}
+
+	/*
+	 * In SPEAr1340, we cannot use newfreq directly because we need
+	 * to actually access a source clock (clk) which might not be
+	 * ancestor of cpu at present.
+	 * Hence in SPEAr1340 we would operate on source clock directly
+	 * before switching cpu clock to it.
+	 */
+	srcfreq = clk_round_rate(srcclk, srcfreq);
+	if (srcfreq < 0) {
+		pr_err("CPU Freq: clk_round_rate failed for cpu src clock\n");
+		return srcfreq;
+	}
+
+	freqs.new = srcfreq / 1000;
+	freqs.new /= cpu_is_spear1340() ? 2 : 1;
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	slow_mode = slow_mode_required(srcclk);
+	if (slow_mode) {
+		ret = arch_change_mode(SYS_MODE_SLOW);
+		if (ret) {
+			pr_err("couldn't cange system to slow mode\n");
+			return ret;
+		}
+	}
+
+	if (cpu_is_spear1340())
+		ret = spear1340_set_cpu_rate(srcclk, srcfreq);
+	else
+		ret = clk_set_rate(spear_cpufreq.cpu_clk, srcfreq);
+
+	/* Get current rate after clk_set_rate, in case of failure */
+	if (ret) {
+		pr_err("CPU Freq: cpu clk_set_rate failed: %d\n", ret);
+		freqs.new = clk_get_rate(spear_cpufreq.cpu_clk) / 1000;
+	}
+
+	/* Now switch back to normal mode */
+	if (slow_mode) {
+		ret = arch_change_mode(SYS_MODE_NORMAL);
+		if (ret) {
+			pr_err("Couldnot change back to normal mode\n");
+			BUG();
+		}
+	}
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int spear_cpufreq_suspend(struct cpufreq_policy *policy)
+{
+	return 0;
+}
+
+static int spear_cpufreq_resume(struct cpufreq_policy *policy)
+{
+	return 0;
+}
+#endif
+
+static int spear_cpufreq_init(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	policy->cpuinfo.min_freq = spear_cpufreq.min_freq;
+	policy->cpuinfo.max_freq = spear_cpufreq.max_freq;
+
+	policy->cur = policy->min = policy->max = spear_cpufreq_get(0);
+
+	if (!cpufreq_frequency_table_cpuinfo(policy, spear_cpufreq.freq_tbl))
+		cpufreq_frequency_table_get_attr(spear_cpufreq.freq_tbl,
+				policy->cpu);
+
+	policy->cpuinfo.transition_latency = spear_cpufreq.transition_latency;
+
+	return 0;
+}
+
+static struct freq_attr *spear_cpufreq_attr[] = {
+	 &cpufreq_freq_attr_scaling_available_freqs,
+	 NULL,
+};
+
+static struct cpufreq_driver spear_cpufreq_driver = {
+	.flags		= CPUFREQ_STICKY,
+	.verify		= spear_cpufreq_verify,
+	.target		= spear_cpufreq_target,
+	.get		= spear_cpufreq_get,
+	.init		= spear_cpufreq_init,
+	.name		= "spear_cpufreq",
+	.attr		= spear_cpufreq_attr,
+#ifdef CONFIG_PM
+	.suspend	= spear_cpufreq_suspend,
+	.resume		= spear_cpufreq_resume,
+#endif
+};
+
+static int __init spear_cpufreq_probe(struct platform_device *pdev)
+{
+	struct spear_cpufreq_pdata *pdata = dev_get_platdata(&pdev->dev);
+	int i;
+
+	if (!pdata || !pdata->cpu_freq_table)
+		return -EINVAL;
+
+	spear_cpufreq.freq_tbl = kmalloc(sizeof(*spear_cpufreq.freq_tbl) *
+			pdata->tbl_len, GFP_KERNEL);
+	if (!spear_cpufreq.freq_tbl) {
+		dev_err(&pdev->dev, "kzalloc fail\n");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pdata->tbl_len; i++) {
+		spear_cpufreq.freq_tbl[i].index = i;
+		spear_cpufreq.freq_tbl[i].frequency = pdata->cpu_freq_table[i];
+	}
+
+	spear_cpufreq.min_freq = spear_cpufreq.freq_tbl[0].frequency;
+	spear_cpufreq.max_freq = spear_cpufreq.freq_tbl[i-1].frequency;
+	spear_cpufreq.freq_tbl[i].index = i;
+	spear_cpufreq.freq_tbl[i].frequency = CPUFREQ_TABLE_END;
+	spear_cpufreq.transition_latency = pdata->transition_latency;
+	if (pdata->transition_latency)
+		spear_cpufreq.transition_latency = pdata->transition_latency;
+	else
+		spear_cpufreq.transition_latency = 300 * 1000; /*300 us*/
+
+	spear_cpufreq.cpu_clk = clk_get(NULL, "cpu_clk");
+	if (IS_ERR(spear_cpufreq.cpu_clk)) {
+		dev_err(&pdev->dev, "Unable to get CPU clock\n");
+		return PTR_ERR(spear_cpufreq.cpu_clk);
+	}
+
+	return cpufreq_register_driver(&spear_cpufreq_driver);
+}
+
+static int __exit spear_cpufreq_remove(struct platform_device *pdev)
+{
+	clk_put(spear_cpufreq.cpu_clk);
+
+	return cpufreq_unregister_driver(&spear_cpufreq_driver);
+}
+
+static struct platform_driver spear_cpufreq_pdrv = {
+	.probe = spear_cpufreq_probe,
+	.remove = __exit_p(spear_cpufreq_remove),
+	.driver = {
+		.name	 = "cpufreq-spear",
+		.owner	 = THIS_MODULE,
+	},
+};
+
+static int __init spear_cpufreq_register(void)
+{
+	return platform_driver_register(&spear_cpufreq_pdrv);
+}
+arch_initcall(spear_cpufreq_register);
diff --git a/arch/arm/plat-spear13xx/i2c_eval_board.c b/arch/arm/plat-spear13xx/i2c_eval_board.c
new file mode 100644
index 0000000..68c0c19
--- /dev/null
+++ b/arch/arm/plat-spear13xx/i2c_eval_board.c
@@ -0,0 +1,32 @@
+/*
+ * arch/arm/plat-spear/i2c_eval_board.c
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar<rajeev-dlh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+
+static struct i2c_board_info __initdata i2c_board_info[] = {
+	{
+		.type = "eeprom",
+		.addr = 0x50,
+	}, {
+		.type = "eeprom",
+		.addr = 0x51,
+	}, {
+		.type = "sta529",
+		.addr = 0x1a,
+	},
+};
+
+void __init i2c_register_default_devices(void)
+{
+	i2c_register_board_info(0, i2c_board_info,
+				ARRAY_SIZE(i2c_board_info));
+}
diff --git a/arch/arm/plat-spear13xx/include/plat/adc.h b/arch/arm/plat-spear13xx/include/plat/adc.h
new file mode 100644
index 0000000..31f6268
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/adc.h
@@ -0,0 +1,34 @@
+/*
+ * arch/arm/plat-spear/include/plat/adc.h
+ *
+ * ADC definitions for SPEAr platform
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_ADC_H
+#define __PLAT_ADC_H
+
+#include <linux/types.h>
+#include <linux/spear_adc_usr.h>
+
+#ifdef CONFIG_ARCH_SPEAR13XX
+#define ADC_DMA_MAX_COUNT	2048
+#else
+#include <asm/hardware/pl080.h>
+
+#define ADC_DMA_MAX_COUNT	PL080_CONTROL_TRANSFER_SIZE_MASK
+#endif
+
+struct dma_chan;
+struct adc_plat_data {
+	struct adc_config config;
+	void *dma_data;
+	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
+};
+#endif /* __PLAT_ADC_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/camif.h b/arch/arm/plat-spear13xx/include/plat/camif.h
new file mode 100644
index 0000000..28155a4
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/camif.h
@@ -0,0 +1,110 @@
+/*
+ * SPEAr camera platform initialization
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_CAMIF_H
+#define __PLAT_CAMIF_H
+
+#include <linux/platform_device.h>
+
+/* camif video buffer offset */
+#define CAMIF_MEM_BUFFER	0x3000
+
+/* camif synchronization methods */
+enum camif_synhcro {
+	EXTERNAL_SYNC = 0,	/* hsync/vsync are used to recover data */
+	EMBEDDED_SYNC,
+};
+
+/* camif polarity settings : common for hsync, vsync and pixclk */
+enum camif_polarity {
+	ACTIVE_LOW = 0,
+	ACTIVE_HIGH,
+};
+
+/* camif capture modes */
+enum camif_capture_modes {
+	NO_CAPTURE = 0,
+	PHOTO_MODE_1,
+	PHOTO_MODE_2,
+	PHOTO_MODE_3,
+	PHOTO_MODE_4,
+	PHOTO_MODE_8,
+	PHOTO_MODE_16,
+	PHOTO_MODE_32,
+	VIDEO_MODE_ALL_FRAMES,
+	VIDEO_MODE_1_FRAME_ON_2,
+	VIDEO_MODE_1_FRAME_ON_4,
+	VIDEO_MODE_1_FRAME_ON_8,
+	VIDEO_MODE_1_FRAME_ON_16,
+	VIDEO_MODE_1_FRAME_ON_32,
+	VIDEO_MODE_1_FRAME_ON_64,
+	VIDEO_MODE_1_FRAME_ON_128,
+};
+
+/* camif supported storage swappings */
+enum camif_dma_burst_size {
+	BURST_SIZE_1 = 0,
+	BURST_SIZE_4,
+	BURST_SIZE_8,
+	BURST_SIZE_16,
+	BURST_SIZE_32,
+	BURST_SIZE_64,
+	BURST_SIZE_128,
+	BURST_SIZE_256,
+};
+
+/* camif dma channel types */
+enum camif_channel_type {
+	EVEN_CHANNEL,
+	BOTH_ODD_EVEN_CHANNELS,
+};
+
+/**
+ * struct camif_config_data - configuration specific params for
+ * camif
+ *
+ * @sync_type: embedded or external sync
+ * @vsync_polarity: ploarity of vsync signal
+ * @hsync_polarity: polarity of hsync signal
+ * @pclk_polarity: polarity of pixel clock signal
+ * @capture_mode: photo or video mode
+ * @burst_size: DMA burst size
+ * (should be programmed consistently with the DMA IP burst size used)
+ * @channel: DMA channel type to use
+ */
+struct camif_config_data {
+	enum camif_synhcro sync_type;
+	enum camif_polarity vsync_polarity;
+	enum camif_polarity hsync_polarity;
+	enum camif_polarity pclk_polarity;
+	enum camif_capture_modes capture_mode;
+	enum camif_dma_burst_size burst_size;
+	enum camif_channel_type channel;
+	/* callback to reset the CAMIF module */
+	void (*camif_module_enable)(int, bool);
+};
+
+/**
+ * struct camif_controller - platform_data for camif controller devices
+ *
+ * @enable_dma: if true enables DMA driven transfers
+ * @dma_even_param: parameter to locate an DMA channel for even lines
+ * @dma_odd_param: parameter to locate a DMA channel for odd lines
+ * @config: configuration parameter for this camif instance
+ */
+struct camif_controller {
+	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
+	void *dma_even_param;
+	void *dma_odd_param;
+	struct camif_config_data *config;
+};
+
+#endif /* __PLAT_CAMIF_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/clock.h b/arch/arm/plat-spear13xx/include/plat/clock.h
new file mode 100644
index 0000000..04aaa23
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/clock.h
@@ -0,0 +1,276 @@
+/*
+ * arch/arm/plat-spear/include/plat/clock.h
+ *
+ * Clock framework definitions for SPEAr platform
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_CLOCK_H
+#define __PLAT_CLOCK_H
+
+#include <linux/list.h>
+#include <linux/clkdev.h>
+#include <linux/types.h>
+
+/* clk structure flags */
+#define ALWAYS_ENABLED		(1 << 0) /* clock always enabled */
+#define RESET_TO_ENABLE		(1 << 1) /* reset register bit to enable clk */
+#define ENABLED_ON_INIT		(1 << 2) /* clocks enabled at init */
+/* Only System clocks can call other sytem clocks set rate function */
+#define SYSTEM_CLK		(1 << 3)
+#define DDR_ANCESTOR		(1 << 4) /* ancestor clks of DDR */
+
+/**
+ * struct clkops - clock operations
+ * @enable: pointer to clock enable function
+ * @disable: pointer to clock disable function
+ */
+struct clkops {
+	int (*enable) (struct clk *);
+	void (*disable) (struct clk *);
+};
+
+/**
+ * struct pclk_info - parents info
+ * @pclk: pointer to parent clk
+ * @pclk_val: value to be written for selecting this parent
+ */
+struct pclk_info {
+	struct clk *pclk;
+	u8 pclk_val;
+};
+
+/**
+ * struct pclk_sel - parents selection configuration
+ * @pclk_info: pointer to array of parent clock info
+ * @pclk_count: number of parents
+ * @pclk_sel_reg: register for selecting a parent
+ * @pclk_sel_mask: mask for selecting parent (can be used to clear bits also)
+ */
+struct pclk_sel {
+	struct pclk_info *pclk_info;
+	u8 pclk_count;
+	void __iomem *pclk_sel_reg;
+	unsigned int pclk_sel_mask;
+};
+
+/**
+ * struct rate_config - clk rate configurations
+ * @tbls: array of device specific clk rate tables, in ascending order of rates
+ * @count: size of tbls array
+ * @default_index: default setting when originally disabled
+ */
+struct rate_config {
+	void *tbls;
+	u8 count;
+	u8 default_index;
+};
+
+/**
+ * struct clk - clock structure
+ * @usage_count: num of users who enabled this clock
+ * @flags: flags for clock properties
+ * @rate: programmed clock rate in Hz
+ * @en_reg: clk enable/disable reg
+ * @en_reg_bit: clk enable/disable bit
+ * @ops: clk enable/disable ops - generic_clkops selected if NULL
+ * @recalc: pointer to clock rate recalculate function
+ * @set_rate: pointer to clock set rate function
+ * @calc_rate: pointer to clock get rate function for index
+ * @rate_config: rate configuration information, used by set_rate
+ * @div_factor: division factor to parent clock.
+ * @pclk: current parent clk
+ * @pclk_sel: pointer to parent selection structure
+ * @pclk_sel_shift: register shift for selecting parent of this clock
+ * @children: list for childrens or this clock
+ * @sibling: node for list of clocks having same parents
+ * @private_data: clock specific private data
+ * @node: list to maintain clocks linearly
+ * @cl: clocklook up associated with this clock
+ * @dent: object for debugfs
+ */
+struct clk {
+	unsigned int usage_count;
+	unsigned int flags;
+	unsigned long rate;
+	void __iomem *en_reg;
+	u8 en_reg_bit;
+	const struct clkops *ops;
+	int (*recalc) (struct clk *clk, unsigned long *rate,
+			unsigned long prate);
+	int (*set_rate) (struct clk *clk, unsigned long rate);
+	unsigned long (*calc_rate)(struct clk *, int index);
+	struct rate_config rate_config;
+	unsigned int div_factor;
+
+	struct clk *pclk;
+	struct pclk_sel *pclk_sel;
+	unsigned int pclk_sel_shift;
+
+	struct list_head children;
+	struct list_head sibling;
+	void *private_data;
+#ifdef CONFIG_DEBUG_FS
+	struct list_head node;
+	struct clk_lookup *cl;
+	struct dentry *dent;
+#endif
+};
+
+/* vco configuration structure */
+struct vco_clk_masks {
+	u32 mode_mask;
+	u32 mode_shift;
+
+	u32 norm_fdbk_m_mask;
+	u32 norm_fdbk_m_shift;
+	u32 dith_fdbk_m_mask;
+	u32 dith_fdbk_m_shift;
+	u32 div_p_mask;
+	u32 div_p_shift;
+	u32 div_n_mask;
+	u32 div_n_shift;
+	u32 pll_lock_mask;
+	u32 pll_lock_shift;
+};
+
+struct vco_clk_config {
+	void __iomem *mode_reg;
+	void __iomem *cfg_reg;
+	struct vco_clk_masks *masks;
+};
+
+/* vco clk rate config structure */
+struct vco_rate_tbl {
+	u8 mode;
+	u16 m;
+	u8 n;
+	u8 p;
+};
+
+/* ahb and apb bus configuration structure */
+struct bus_clk_masks {
+	u32 mask;
+	u32 shift;
+};
+
+struct bus_clk_config {
+	void __iomem *reg;
+	struct bus_clk_masks *masks;
+};
+
+/* ahb and apb clk bus rate config structure */
+struct bus_rate_tbl {
+	u8 div;
+};
+
+/* Aux clk configuration structure: applicable to UART and FIRDA */
+struct aux_clk_masks {
+	u32 eq_sel_mask;
+	u32 eq_sel_shift;
+	u32 eq1_mask;
+	u32 eq2_mask;
+	u32 xscale_sel_mask;
+	u32 xscale_sel_shift;
+	u32 yscale_sel_mask;
+	u32 yscale_sel_shift;
+};
+
+struct aux_clk_config {
+	void __iomem *synth_reg;
+	struct aux_clk_masks *masks;
+};
+
+/* aux clk rate config structure */
+struct aux_rate_tbl {
+	u16 xscale;
+	u16 yscale;
+	u8 eq;
+};
+
+/* GPT clk configuration structure */
+struct gpt_clk_masks {
+	u32 mscale_sel_mask;
+	u32 mscale_sel_shift;
+	u32 nscale_sel_mask;
+	u32 nscale_sel_shift;
+};
+
+struct gpt_clk_config {
+	void __iomem *synth_reg;
+	struct gpt_clk_masks *masks;
+};
+
+/* gpt clk rate config structure */
+struct gpt_rate_tbl {
+	u16 mscale;
+	u16 nscale;
+};
+
+/* synthesizer clk configuration structure */
+struct frac_synth_masks {
+	u32 div_factor_mask;
+	u32 div_factor_shift;
+};
+
+struct frac_synth_clk_config {
+	void __iomem *synth_reg;
+	struct frac_synth_masks *masks;
+};
+
+/* synthesizer clk rate config structure */
+struct frac_synth_rate_tbl {
+	u32 div;
+};
+
+/* ddr min, max clk rate table */
+struct ddr_rate_tbl {
+	unsigned long minrate;
+	unsigned long maxrate;
+};
+
+/* platform specific clock functions */
+/*
+ * must be called from machine clock.c file, dclk is pointer to ddr_clk
+ * strucutre. Which is required by clock framework.
+ *
+ * Actually before changing rate of DDRs ancestor, we must put ddr in refresh
+ * state and then change parent.
+ */
+void __init clk_init(struct clk *dclk);
+void clk_register(struct clk_lookup *cl);
+int clk_set_parent_sys(char *dev_id, char *con_id, char *pdev_id, char
+		*pcon_id);
+int clk_set_rate_sys(char *dev_id, char *con_id, unsigned long rate);
+void recalc_root_clocks(void);
+
+/* clock recalc & set rate functions */
+int follow_parent(struct clk *clk, unsigned long *rate, unsigned long prate);
+unsigned long vco_calc_rate(struct clk *clk, int index);
+int vco_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate);
+int vco_clk_set_rate(struct clk *clk, unsigned long desired_rate);
+int pll_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate);
+unsigned long bus_calc_rate(struct clk *clk, int index);
+int bus_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate);
+int bus_clk_set_rate(struct clk *clk, unsigned long desired_rate);
+int ahbmult2_clk_recalc(struct clk *clk, unsigned long *rate,
+		unsigned long prate);
+unsigned long gpt_calc_rate(struct clk *clk, int index);
+int gpt_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate);
+int gpt_clk_set_rate(struct clk *clk, unsigned long desired_rate);
+unsigned long aux_calc_rate(struct clk *clk, int index);
+int aux_clk_recalc(struct clk *clk, unsigned long *rate, unsigned long prate);
+int aux_clk_set_rate(struct clk *clk, unsigned long desired_rate);
+unsigned long frac_synth_calc_rate(struct clk *clk, int index);
+int frac_synth_clk_recalc(struct clk *clk, unsigned long *rate,
+		unsigned long prate);
+int frac_synth_clk_set_rate(struct clk *clk, unsigned long desired_rate);
+void vco_set_rate(u16 m, u8 p, u8 n);
+
+#endif /* __PLAT_CLOCK_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/cpufreq.h b/arch/arm/plat-spear13xx/include/plat/cpufreq.h
new file mode 100644
index 0000000..61f7621
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/cpufreq.h
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/plat-spear/include/plat/cpufreq.h
+ *
+ * CPU Frequency Scaling definitions for SPEAr platform
+ *
+ * Copyright (C) 2010-2012 ST Microelectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _MACH_SPEAR_CPUFREQ_H
+#define _MACH_SPEAR_CPUFREQ_H
+
+#include <linux/cpufreq.h>
+
+/* Entry in the table must be in ascending order */
+struct spear_cpufreq_pdata {
+	unsigned int *cpu_freq_table;
+	unsigned int tbl_len;
+	unsigned int transition_latency;
+};
+#endif
diff --git a/arch/arm/plat-spear13xx/include/plat/debug-macro.S b/arch/arm/plat-spear13xx/include/plat/debug-macro.S
new file mode 100644
index 0000000..02b160a
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/debug-macro.S
@@ -0,0 +1,36 @@
+/*
+ * arch/arm/plat-spear/include/plat/debug-macro.S
+ *
+ * Debugging macro include header for spear platform
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/amba/serial.h>
+#include <mach/hardware.h>
+
+		.macro	addruart, rp, rv, tmp
+		mov	\rp, #SPEAR_DBG_UART_BASE		@ Physical base
+		mov	\rv, #VA_SPEAR_DBG_UART_BASE		@ Virtual base
+		.endm
+
+		.macro	senduart, rd, rx
+		strb	\rd, [\rx, #UART01x_DR]			@ ASC_TX_BUFFER
+		.endm
+
+		.macro	waituart, rd, rx
+1001:		ldr	\rd, [\rx, #UART01x_FR]			@ FLAG REGISTER
+		tst	\rd, #UART01x_FR_TXFF			@ TX_FULL
+		bne	1001b
+		.endm
+
+		.macro	busyuart, rd, rx
+1002:		ldr	\rd, [\rx, #UART01x_FR]			@ FLAG REGISTER
+		tst	\rd, #UART011_FR_TXFE			@ TX_EMPTY
+		beq	1002b
+		.endm
diff --git a/arch/arm/plat-spear13xx/include/plat/gpio.h b/arch/arm/plat-spear13xx/include/plat/gpio.h
new file mode 100644
index 0000000..973d608
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/gpio.h
@@ -0,0 +1,88 @@
+/*
+ * arch/arm/plat-spear/include/plat/gpio.h
+ *
+ * GPIO macros for SPEAr platform
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_GPIO_H
+#define __PLAT_GPIO_H
+
+#include <asm-generic/gpio.h>
+#include <linux/types.h>
+
+/* plgpio driver declarations */
+/*
+ * plgpio pins in all machines are not one to one mapped, bitwise with
+ * registers bits. These set of macros define register masks for which below
+ * functions (pin_to_offset and offset_to_pin) are required to be called.
+ */
+#define PTO_ENB_REG		0x001
+#define PTO_WDATA_REG		0x002
+#define PTO_DIR_REG		0x004
+#define PTO_IE_REG		0x008
+#define PTO_RDATA_REG		0x010
+#define PTO_MIS_REG		0x020
+
+struct plgpio_regs {
+	u32 enb;		/* enable register */
+	u32 wdata;		/* write data register */
+	u32 dir;		/* direction set register */
+	u32 rdata;		/* read data register */
+	u32 ie;			/* interrupt enable register */
+	u32 mis;		/* mask interrupt status register */
+	u32 eit;		/* edge interrupt type */
+};
+
+/* functions for converting pin to correct offset in register and vice versa */
+/**
+ * struct plgpio_platform_data: plgpio driver platform data
+ *
+ * gpio_base: gpio start number of plgpios
+ * irq_base: irq number of plgpio0
+ * gpio_count: total count of plgpios
+ * grp_size: number of gpio's in a group for interrupt registers
+ * p2o: function ptr for pin to offset conversion. This is required only for
+ * machines where mapping b/w pin and offset is not 1-to-1.
+ * o2p: function ptr for offset to pin conversion. This is required only for
+ * machines where mapping b/w pin and offset is not 1-to-1.
+ * p2o_regs: mask of registers for which p2o and o2p are applicable
+ */
+struct plgpio_platform_data {
+	u32 gpio_base;
+	u32 irq_base;
+	u32 gpio_count;
+	u32 grp_size;
+	int (*p2o)(int pin);		/* pin_to_offset */
+	int (*o2p)(int offset);		/* offset_to_pin */
+	u32 p2o_regs;
+	struct plgpio_regs regs;
+};
+
+struct gpio_req_list {
+	int start;
+	int end;
+};
+
+static inline int request_gpio(struct gpio_req_list *gpio_list,
+		unsigned long flags, int cnt)
+{
+	int i, j, err;
+
+	for (j = 0; j < cnt; j++) {
+		for (i = gpio_list[j].start; i <= gpio_list[j].end; i++) {
+			err = gpio_request_one(i, flags, "gpio");
+			if (err)
+				pr_err("GPIO request is fail %d", i);
+		}
+	}
+	return 0;
+}
+
+#endif /* __PLAT_GPIO_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/hardware.h b/arch/arm/plat-spear13xx/include/plat/hardware.h
new file mode 100644
index 0000000..615586d
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/hardware.h
@@ -0,0 +1,93 @@
+/*
+ * arch/arm/plat-spear/include/plat/hardware.h
+ *
+ * Hardware definitions for SPEAr
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_HARDWARE_H
+#define __PLAT_HARDWARE_H
+
+#include <linux/types.h>
+#include <asm/mach-types.h>
+
+#ifndef __ASSEMBLY__
+#define IOMEM(x)	((void __iomem __force *)(x))
+#else
+#define IOMEM(x)	(x)
+#endif
+
+#ifndef __ASSEMBLY__
+/* cpu related runtime routines */
+static inline bool cpu_is_spear300(void)
+{
+	return machine_is_spear300_evb();
+}
+
+static inline bool cpu_is_spear310(void)
+{
+	return machine_is_spear310_evb();
+}
+
+static inline bool cpu_is_spear320(void)
+{
+	return machine_is_spear320_evb() || machine_is_spear320_hmi();
+}
+
+static inline bool cpu_is_spear600(void)
+{
+	return machine_is_spear600_evb();
+}
+
+static inline bool cpu_is_spear1300(void)
+{
+	return machine_is_spear1300_evb();
+}
+
+static inline bool cpu_is_spear1310(void)
+{
+	return machine_is_spear1310_evb();
+}
+
+static inline bool cpu_is_spear1310_reva(void)
+{
+	return machine_is_spear1310_reva_evb() || machine_is_r1801e();
+}
+
+static inline bool cpu_is_spear1340(void)
+{
+	return machine_is_spear1340_evb() || machine_is_spear_hurricane() ||
+		machine_is_spear1340_lcad();
+}
+
+static inline bool cpu_is_spear900(void)
+{
+	return machine_is_spear900_evb();
+}
+
+/* arch related runtime routines */
+static inline bool arch_is_spear3xx(void)
+{
+	return cpu_is_spear300() || cpu_is_spear310() || cpu_is_spear320();
+}
+
+static inline bool arch_is_spear6xx(void)
+{
+	return cpu_is_spear600();
+}
+
+static inline bool arch_is_spear13xx(void)
+{
+	return cpu_is_spear1300() || cpu_is_spear1310_reva() ||
+		cpu_is_spear1310() || cpu_is_spear900() ||
+		cpu_is_spear1340();
+}
+#endif /* __ASSEMBLY__ */
+
+#endif /* __PLAT_HARDWARE_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/hdlc.h b/arch/arm/plat-spear13xx/include/plat/hdlc.h
new file mode 100644
index 0000000..c37e94b
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/hdlc.h
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/plat-spear/include/plat/hdlc.h
+ *
+ * HDLC definitions for SPEAr platform
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Frank Shi<frank.shi@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_HDLC_H
+#define __PLAT_HDLC_H
+
+#include <linux/platform_device.h>
+
+#define SPEAR1310_REVA_TDM_HDLC	0
+#define SPEAR310_TDM_HDLC	1
+#define SPEAR1310_TDM_HDLC	2
+
+struct tdm_hdlc_platform_data {
+	int			ip_type;
+	int			nr_channel;
+	int			nr_timeslot;
+	int			tx_falling_edge;
+	int			rx_rising_edge;
+	int			ts0_delay;
+};
+
+struct rs485_hdlc_platform_data {
+	int			tx_falling_edge;
+	int			rx_rising_edge;
+	int			cts_enable;
+	int			cts_delay;
+};
+
+int e1phy_init(u32 base, int shift);
+
+static inline void tdm_hdlc_set_plat_data(struct platform_device *pdev, int tsn)
+{
+	struct tdm_hdlc_platform_data *pdata = dev_get_platdata(&pdev->dev);
+
+	pdata->nr_timeslot = tsn;
+}
+
+#endif /* __PLAT_HDLC_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/i2c.h b/arch/arm/plat-spear13xx/include/plat/i2c.h
new file mode 100644
index 0000000..71806ee
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/i2c.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/plat-spear/include/mach/i2c.h
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_I2C_H
+#define __PLAT_I2C_H
+
+#include <linux/i2c.h>
+
+struct i2c_dev_info {
+	struct i2c_board_info *board;
+	int busnum;
+};
+#endif /* __PLAT_I2C_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/io.h b/arch/arm/plat-spear13xx/include/plat/io.h
new file mode 100644
index 0000000..4d4ba82
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/io.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/plat-spear/include/plat/io.h
+ *
+ * IO definitions for SPEAr platform
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_IO_H
+#define __PLAT_IO_H
+
+#define IO_SPACE_LIMIT		0xFFFFFFFF
+
+#define __io(a)			__typesafe_io(a)
+#define __mem_pci(a)		(a)
+
+#endif /* __PLAT_IO_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/jpeg.h b/arch/arm/plat-spear13xx/include/plat/jpeg.h
new file mode 100644
index 0000000..3608ba4
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/jpeg.h
@@ -0,0 +1,33 @@
+/*
+ * arch/arm/plat-spear/include/plat/jpeg.h
+ *
+ * JPEG definitions for SPEAr platform
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_JPEG_H
+#define __PLAT_JPEG_H
+
+#include <linux/types.h>
+
+#ifdef CONFIG_ARCH_SPEAR13XX
+#define JPEG_DMA_MAX_COUNT	2048
+#else
+#include <asm/hardware/pl080.h>
+#define JPEG_DMA_MAX_COUNT	PL080_CONTROL_TRANSFER_SIZE_MASK
+#endif
+
+struct dma_chan;
+struct jpeg_plat_data {
+	bool (*dma_filter)(struct dma_chan *chan, void *filter_param);
+	void *mem2jpeg_slave;
+	void *jpeg2mem_slave;
+};
+
+#endif /* __PLAT_JPEG_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/keyboard.h b/arch/arm/plat-spear13xx/include/plat/keyboard.h
new file mode 100644
index 0000000..0562f13
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/keyboard.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar<rajeev-dlh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_KEYBOARD_H
+#define __PLAT_KEYBOARD_H
+
+#include <linux/bitops.h>
+#include <linux/input.h>
+#include <linux/input/matrix_keypad.h>
+#include <linux/types.h>
+
+#define DECLARE_9x9_KEYMAP(_name) \
+int _name[] = { \
+	KEY(0, 0, KEY_ESC), \
+	KEY(0, 1, KEY_1), \
+	KEY(0, 2, KEY_2), \
+	KEY(0, 3, KEY_3), \
+	KEY(0, 4, KEY_4), \
+	KEY(0, 5, KEY_5), \
+	KEY(0, 6, KEY_6), \
+	KEY(0, 7, KEY_7), \
+	KEY(0, 8, KEY_8), \
+	KEY(1, 0, KEY_9), \
+	KEY(1, 1, KEY_MINUS), \
+	KEY(1, 2, KEY_EQUAL), \
+	KEY(1, 3, KEY_BACKSPACE), \
+	KEY(1, 4, KEY_TAB), \
+	KEY(1, 5, KEY_Q), \
+	KEY(1, 6, KEY_W), \
+	KEY(1, 7, KEY_E), \
+	KEY(1, 8, KEY_R), \
+	KEY(2, 0, KEY_T), \
+	KEY(2, 1, KEY_Y), \
+	KEY(2, 2, KEY_U), \
+	KEY(2, 3, KEY_I), \
+	KEY(2, 4, KEY_O), \
+	KEY(2, 5, KEY_P), \
+	KEY(2, 6, KEY_LEFTBRACE), \
+	KEY(2, 7, KEY_RIGHTBRACE), \
+	KEY(2, 8, KEY_ENTER), \
+	KEY(3, 0, KEY_LEFTCTRL), \
+	KEY(3, 1, KEY_A), \
+	KEY(3, 2, KEY_S), \
+	KEY(3, 3, KEY_D), \
+	KEY(3, 4, KEY_F), \
+	KEY(3, 5, KEY_G), \
+	KEY(3, 6, KEY_H), \
+	KEY(3, 7, KEY_J), \
+	KEY(3, 8, KEY_K), \
+	KEY(4, 0, KEY_L), \
+	KEY(4, 1, KEY_SEMICOLON), \
+	KEY(4, 2, KEY_APOSTROPHE), \
+	KEY(4, 3, KEY_GRAVE), \
+	KEY(4, 4, KEY_LEFTSHIFT), \
+	KEY(4, 5, KEY_BACKSLASH), \
+	KEY(4, 6, KEY_Z), \
+	KEY(4, 7, KEY_X), \
+	KEY(4, 8, KEY_C), \
+	KEY(5, 0, KEY_V), \
+	KEY(5, 1, KEY_B), \
+	KEY(5, 2, KEY_N), \
+	KEY(5, 3, KEY_M), \
+	KEY(5, 4, KEY_COMMA), \
+	KEY(5, 5, KEY_DOT), \
+	KEY(5, 6, KEY_SLASH), \
+	KEY(5, 7, KEY_RIGHTSHIFT), \
+	KEY(5, 8, KEY_KPASTERISK), \
+	KEY(6, 0, KEY_LEFTALT), \
+	KEY(6, 1, KEY_SPACE), \
+	KEY(6, 2, KEY_CAPSLOCK), \
+	KEY(6, 3, KEY_F1), \
+	KEY(6, 4, KEY_F2), \
+	KEY(6, 5, KEY_F3), \
+	KEY(6, 6, KEY_F4), \
+	KEY(6, 7, KEY_F5), \
+	KEY(6, 8, KEY_F6), \
+	KEY(7, 0, KEY_F7), \
+	KEY(7, 1, KEY_F8), \
+	KEY(7, 2, KEY_F9), \
+	KEY(7, 3, KEY_F10), \
+	KEY(7, 4, KEY_NUMLOCK), \
+	KEY(7, 5, KEY_SCROLLLOCK), \
+	KEY(7, 6, KEY_KP7), \
+	KEY(7, 7, KEY_KP8), \
+	KEY(7, 8, KEY_KP9), \
+	KEY(8, 0, KEY_KPMINUS), \
+	KEY(8, 1, KEY_KP4), \
+	KEY(8, 2, KEY_KP5), \
+	KEY(8, 3, KEY_KP6), \
+	KEY(8, 4, KEY_KPPLUS), \
+	KEY(8, 5, KEY_KP1), \
+	KEY(8, 6, KEY_KP2), \
+	KEY(8, 7, KEY_KP3), \
+	KEY(8, 8, KEY_KP0), \
+}
+
+#define DECLARE_6x6_KEYMAP(_name) \
+int _name[] = { \
+	KEY(0, 0, KEY_RESERVED), \
+	KEY(0, 1, KEY_1), \
+	KEY(0, 2, KEY_2), \
+	KEY(0, 3, KEY_3), \
+	KEY(0, 4, KEY_4), \
+	KEY(0, 5, KEY_5), \
+	KEY(1, 0, KEY_Q), \
+	KEY(1, 1, KEY_W), \
+	KEY(1, 2, KEY_E), \
+	KEY(1, 3, KEY_R), \
+	KEY(1, 4, KEY_T), \
+	KEY(1, 5, KEY_Y), \
+	KEY(2, 0, KEY_D), \
+	KEY(2, 1, KEY_F), \
+	KEY(2, 2, KEY_G), \
+	KEY(2, 3, KEY_H), \
+	KEY(2, 4, KEY_J), \
+	KEY(2, 5, KEY_K), \
+	KEY(3, 0, KEY_B), \
+	KEY(3, 1, KEY_N), \
+	KEY(3, 2, KEY_M), \
+	KEY(3, 3, KEY_COMMA), \
+	KEY(3, 4, KEY_DOT), \
+	KEY(3, 5, KEY_SLASH), \
+	KEY(4, 0, KEY_F6), \
+	KEY(4, 1, KEY_F7), \
+	KEY(4, 2, KEY_F8), \
+	KEY(4, 3, KEY_F9), \
+	KEY(4, 4, KEY_F10), \
+	KEY(4, 5, KEY_NUMLOCK), \
+	KEY(5, 0, KEY_KP2), \
+	KEY(5, 1, KEY_KP3), \
+	KEY(5, 2, KEY_KP0), \
+	KEY(5, 3, KEY_KPDOT), \
+	KEY(5, 4, KEY_RO), \
+	KEY(5, 5, KEY_ZENKAKUHANKAKU), \
+}
+
+#define KEYPAD_9x9     0
+#define KEYPAD_6x6     1
+#define KEYPAD_2x2     2
+
+/**
+ * struct kbd_platform_data - spear keyboard platform data
+ * keymap: pointer to keymap data (table and size)
+ * rep: enables key autorepeat
+ * mode: choose keyboard support(9x9, 6x6, 2x2)
+ *
+ * This structure is supposed to be used by platform code to supply
+ * keymaps to drivers that implement keyboards.
+ */
+struct kbd_platform_data {
+	const struct matrix_keymap_data *keymap;
+	bool rep;
+	unsigned int mode;
+};
+
+#endif /* __PLAT_KEYBOARD_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/padmux.h b/arch/arm/plat-spear13xx/include/plat/padmux.h
new file mode 100644
index 0000000..fe4b459
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/padmux.h
@@ -0,0 +1,103 @@
+/*
+ * arch/arm/plat-spear/include/plat/padmux.h
+ *
+ * SPEAr platform specific gpio pads muxing file
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_PADMUX_H
+#define __PLAT_PADMUX_H
+
+#include <linux/types.h>
+
+/*
+ * struct pmx_reg: configuration structure for mode reg and mux reg
+ *
+ * address: physical address of mode reg
+ * mask: mask of mode reg
+ */
+struct pmx_reg {
+	u32 address;
+	u32 mask;
+};
+
+/*
+ * struct pmx_mux_reg: configuration structure every group of modes of a device
+ *
+ * address: physical address of multiplexing register
+ * mask: mask for supported mode
+ * value: value to be written
+ */
+struct pmx_mux_reg {
+	u32 address;
+	u32 mask;
+	u32 value;
+};
+
+/*
+ * struct pmx_dev_mode: configuration structure every group of modes of a device
+ *
+ * ids: all modes for this configuration
+ * mux_regs: array of mux registers, masks and values to enable the device in
+ *		this group of modes
+ * mux_reg_cnt: count of mux_regs elements
+ */
+struct pmx_dev_mode {
+	u32 ids;
+	struct pmx_mux_reg *mux_regs;
+	u8 mux_reg_cnt;
+};
+
+/*
+ * struct pmx_mode: mode definition structure
+ *
+ * name: mode name
+ * value: mode value
+ */
+struct pmx_mode {
+	char *name;
+	u32 id;
+	u32 value;
+};
+
+/*
+ * struct pmx_dev: device definition structure
+ *
+ * name: device name
+ * modes: device configuration array for different modes supported
+ * mode_count: size of modes array
+ * is_active: is peripheral active/enabled
+ */
+struct pmx_dev {
+	char *name;
+	struct pmx_dev_mode *modes;
+	u8 mode_count;
+	bool is_active;
+};
+
+/*
+ * struct pmx_driver: driver definition structure
+ *
+ * mode: mode to be set
+ * devs: array of pointer to pmx devices
+ * devs_count: ARRAY_SIZE of devs
+ * mode_reg: structure of mode config register
+ */
+struct pmx_driver {
+	struct pmx_mode *mode;
+	struct pmx_dev **devs;
+	u8 devs_count;
+	struct pmx_reg mode_reg;
+};
+
+/* pmx functions */
+int pmx_register(struct pmx_driver *driver);
+int pmx_devs_enable(struct pmx_dev **devs, u8 count);
+
+#endif /* __PLAT_PADMUX_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/pl080.h b/arch/arm/plat-spear13xx/include/plat/pl080.h
new file mode 100644
index 0000000..6de24c8
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/pl080.h
@@ -0,0 +1,23 @@
+/*
+ * arch/arm/plat-spear/include/plat/pl080.h
+ *
+ * DMAC pl080 definitions for SPEAr platform
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_PL080_H
+#define __PLAT_PL080_H
+
+struct amba_device;
+struct pl08x_channel_data;
+
+void pl080_set_slaveinfo(struct amba_device *pl080,
+		struct pl08x_channel_data *cd, u32 num);
+
+#endif /* __PLAT_PL080_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/plug_board.h b/arch/arm/plat-spear13xx/include/plat/plug_board.h
new file mode 100644
index 0000000..0b57ca3
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/plug_board.h
@@ -0,0 +1,120 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/plug_board.h
+ *
+ * spear13xx machine family plug board header file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_PLUG_BOARD_H
+#define __MACH_PLUG_BOARD_H
+
+#include <linux/amba/bus.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <plat/i2c.h>
+
+/* name of an individual plug-board is limited to 10 chars */
+#define PB_NAME_LIMIT	10
+
+/* max plug-boards which can be requested via bootargs is limited to 50 */
+#define MAX_REQ_PB	50
+
+#ifdef DEBUG
+#undef DEBUG
+#define DEBUG 1
+#endif
+
+struct plug_board_info {
+	struct platform_device **pdevs;
+	u8 pcnt;
+	struct amba_device **adevs;
+	u8 acnt;
+	struct spi_board_info **spi_devs;
+	u8 spi_cnt;
+	struct i2c_dev_info **i2c_devs;
+	u8 i2c_cnt;
+};
+
+struct plug_board {
+	struct pmx_dev **pmx_devs;
+	struct amba_device **rm_adevs;
+	struct amba_device **add_adevs;
+	struct platform_device **rm_pdevs;
+	struct platform_device **add_pdevs;
+	struct spi_board_info **rm_spi_devs;
+	struct spi_board_info **add_spi_devs;
+	struct i2c_dev_info **rm_i2c_devs;
+	struct i2c_dev_info **add_i2c_devs;
+	u32 pmx_cnt;
+	u32 rm_acnt;
+	u32 add_acnt;
+	u32 rm_pcnt;
+	u32 add_pcnt;
+	u32 rm_spi_cnt;
+	u32 add_spi_cnt;
+	u32 rm_i2c_cnt;
+	u32 add_i2c_cnt;
+	void (*pb_init)(void);
+
+	struct list_head node;
+	char name[PB_NAME_LIMIT];
+};
+
+enum skip_device_type {
+	SKIP_AMBA_DEVICE,
+	SKIP_PLAT_DEVICE,
+	SKIP_SPI_DEVICE,
+	SKIP_I2C_DEVICE
+};
+
+#define INIT_PB(pb_name, pb)						\
+	do {								\
+		if (strlen(#pb_name) > PB_NAME_LIMIT) {			\
+			pr_err("Error: name choosen for plug board is "	\
+				"more than 10 chars, use a smaller "	\
+				"name instead\n");			\
+			continue;					\
+		}							\
+									\
+		pb = kmalloc(sizeof(struct plug_board), GFP_KERNEL);	\
+		if (!pb) {						\
+			pr_err("Error allocating memory for pb: %s\n",	\
+				#pb_name);				\
+			continue;					\
+		}							\
+									\
+		strcpy(pb->name, #pb_name);				\
+		pb->pmx_devs = (struct pmx_dev **) pb_name##_pb_pmx_devs;		\
+		pb->rm_adevs = (struct amba_device **) pb_name##_pb_rm_adevs;		\
+		pb->add_adevs = (struct amba_device **) pb_name##_pb_add_adevs;		\
+		pb->rm_pdevs = (struct platform_device **) pb_name##_pb_rm_pdevs;	\
+		pb->add_pdevs = (struct platform_device **) pb_name##_pb_add_pdevs;	\
+		pb->rm_spi_devs = (struct spi_board_info **) pb_name##_pb_rm_spi_devs;	\
+		pb->add_spi_devs = (struct spi_board_info **) pb_name##_pb_add_spi_devs;\
+		pb->rm_i2c_devs = (struct i2c_dev_info **) pb_name##_pb_rm_i2c_devs;	\
+		pb->add_i2c_devs = (struct i2c_dev_info **) pb_name##_pb_add_i2c_devs;	\
+		pb->pmx_cnt = ARRAY_SIZE(pb_name##_pb_pmx_devs);	\
+		pb->rm_acnt = ARRAY_SIZE(pb_name##_pb_rm_adevs);	\
+		pb->add_acnt = ARRAY_SIZE(pb_name##_pb_add_adevs);	\
+		pb->rm_pcnt = ARRAY_SIZE(pb_name##_pb_rm_pdevs);	\
+		pb->add_pcnt = ARRAY_SIZE(pb_name##_pb_add_pdevs);	\
+		pb->rm_spi_cnt = ARRAY_SIZE(pb_name##_pb_rm_spi_devs);	\
+		pb->add_spi_cnt = ARRAY_SIZE(pb_name##_pb_add_spi_devs); \
+		pb->rm_i2c_cnt = ARRAY_SIZE(pb_name##_pb_rm_i2c_devs);	\
+		pb->add_i2c_cnt = ARRAY_SIZE(pb_name##_pb_add_i2c_devs); \
+		pb->pb_init = pb_name##_pb_init;			\
+									\
+		pr_info("Adding plug board: %s\n", #pb_name);		\
+	} while (0)
+
+bool spear_pb_present(void);
+char *get_spear_pb(void);
+int __init spear_pb_init(struct plug_board_info *pb_info,
+		int (*make_pb_list)(struct list_head *pb_list));
+#endif
diff --git a/arch/arm/plat-spear13xx/include/plat/shirq.h b/arch/arm/plat-spear13xx/include/plat/shirq.h
new file mode 100644
index 0000000..03ed8b5
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/shirq.h
@@ -0,0 +1,73 @@
+/*
+ * arch/arm/plat-spear/include/plat/shirq.h
+ *
+ * SPEAr platform shared irq layer header file
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_SHIRQ_H
+#define __PLAT_SHIRQ_H
+
+#include <linux/irq.h>
+#include <linux/types.h>
+
+/*
+ * struct shirq_dev_config: shared irq device configuration
+ *
+ * virq: virtual irq number of device
+ * enb_mask: enable mask of device
+ * status_mask: status mask of device
+ * clear_mask: clear mask of device
+ */
+struct shirq_dev_config {
+	u32 virq;
+	u32 enb_mask;
+	u32 status_mask;
+	u32 clear_mask;
+};
+
+/*
+ * struct shirq_regs: shared irq register configuration
+ *
+ * base: base address of shared irq register
+ * enb_reg: enable register offset
+ * reset_to_enb: val 1 indicates, we need to clear bit for enabling interrupt
+ * status_reg: status register offset
+ * status_reg_mask: status register valid mask
+ * clear_reg: clear register offset
+ * reset_to_clear: val 1 indicates, we need to clear bit for clearing interrupt
+ */
+struct shirq_regs {
+	void __iomem *base;
+	u32 enb_reg;
+	u32 reset_to_enb;
+	u32 status_reg;
+	u32 status_reg_mask;
+	u32 clear_reg;
+	u32 reset_to_clear;
+};
+
+/*
+ * struct spear_shirq: shared irq structure
+ *
+ * irq: hardware irq number
+ * dev_config: array of device config structures which are using "irq" line
+ * dev_count: size of dev_config array
+ * regs: register configuration for shared irq block
+ */
+struct spear_shirq {
+	u32 irq;
+	struct shirq_dev_config *dev_config;
+	u32 dev_count;
+	struct shirq_regs regs;
+};
+
+int spear_shirq_register(struct spear_shirq *shirq);
+
+#endif /* __PLAT_SHIRQ_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/spi.h b/arch/arm/plat-spear13xx/include/plat/spi.h
new file mode 100644
index 0000000..0199a78
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/spi.h
@@ -0,0 +1,123 @@
+/*
+ * arch/arm/plat-spear/include/plat/spi.h
+ *
+ * SPI board specific definitions common to multiple boards on multiple
+ * machines.
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_SPI_H
+#define __PLAT_SPI_H
+
+#include <linux/amba/pl022.h>
+#include <linux/gpio.h>
+#include <linux/types.h>
+
+/* Chip select control using SSP peripherals inbuilt chip select lines */
+/*
+ * DECLARE_SPI_CS_CFG: chip select configuration routine for spi master
+ * @id: ssp id
+ * @reg: virtual address of register for configuring
+ * @cs_sel_mask: chip select lines selection bit mask
+ * @cs_sel_shift: chip select lines selection bit shift
+ * @cs_ctl_mask: chip selection ctl mask (h/w or s/w)
+ * @cs_ctl_shift: chip selection ctl shift (h/w or s/w)
+ * @cs_val_mask: chip selection value bit mask
+ * @cs_val_shift: chip selection value bit shift
+ */
+#define DECLARE_SPI_CS_CFG(id, reg, cs_sel_mask, cs_sel_shift, cs_ctl_mask, \
+		cs_ctl_shift, cs_ctl_val, cs_val_mask, cs_val_shift)	\
+/* cs_sel: cs line to select, val: value to write on cs line */		\
+static void spi##id##_cs_cfg(u32 cs_sel, u32 val)			\
+{									\
+	static int count;						\
+	u32 tmp = readl(reg);						\
+									\
+	if (unlikely(!count)) {						\
+		count++;						\
+		tmp &= ~(cs_ctl_mask << cs_ctl_shift);			\
+		tmp |= cs_ctl_val << cs_ctl_shift;			\
+		writel(tmp, reg);					\
+	}								\
+									\
+	tmp &= ~(cs_sel_mask << cs_sel_shift);				\
+	tmp |= cs_sel << cs_sel_shift;					\
+	writel(tmp, reg);						\
+	tmp &= ~(cs_val_mask << cs_val_shift);				\
+	tmp |= val << cs_val_shift;					\
+	writel(tmp, reg);						\
+}
+
+/*
+ * cs_control function for a specific spi slave using spi's cs signals
+ * @id: spi master id
+ * @type: slave type, will used in routines name
+ * @cs_sel: chip select number
+ */
+#define DECLARE_SPI_CS_CONTROL(id, type, cs_sel)	\
+static void spi##id##_##type##_cs_control(u32 control)	\
+{							\
+	spi##id##_cs_cfg(cs_sel, control);		\
+}
+
+/* Chip select control using external GPIO pins */
+/* spi board information */
+static inline int spi_cs_gpio_request(u32 gpio_pin)
+{
+	int ret;
+
+	ret = gpio_request(gpio_pin, "SPI_CS");
+	if (ret < 0) {
+		printk(KERN_ERR "SPI: gpio:%d request fail\n", gpio_pin);
+		return ret;
+	} else {
+		ret = gpio_direction_output(gpio_pin, 1);
+		if (ret) {
+			printk(KERN_ERR "SPI: gpio:%d direction set fail\n",
+					gpio_pin);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+/* This will define cs_control function for a specific spi slave using gpios */
+#define DECLARE_SPI_CS_GPIO_CONTROL(id, type, gpio)	\
+static void spi##id##_##type##_cs_gpio_control(u32 control)	\
+{							\
+	static int count, ret;				\
+							\
+	if (unlikely(!count)) {				\
+		count++;				\
+		ret = spi_cs_gpio_request(gpio);	\
+	}						\
+							\
+	if (!ret)					\
+		gpio_set_value(gpio, control);		\
+}
+
+/* This will define CHIP_INFO structure for a specific spi slave */
+#define DECLARE_SPI_CHIP_INFO(id, type, chip_select_control)	\
+static struct pl022_config_chip spi##id##_##type##_chip_info = {\
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,		\
+	.hierarchy = SSP_MASTER,			\
+	.slave_tx_disable = 0,				\
+	.com_mode = DMA_TRANSFER,			\
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,		\
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,	\
+	.ctrl_len = SSP_BITS_12,			\
+	.wait_state = SSP_MWIRE_WAIT_ZERO,		\
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,	\
+	.cs_control = chip_select_control,		\
+};
+
+#define DECLARE_SPI_CHIP_INFO_NULL_ID(chip_select_control)	\
+DECLARE_SPI_CHIP_INFO(, chip_select_control)
+
+#endif /* __PLAT_SPI_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/system.h b/arch/arm/plat-spear13xx/include/plat/system.h
new file mode 100644
index 0000000..ff4f028
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/system.h
@@ -0,0 +1,35 @@
+/*
+ * arch/arm/plat-spear/include/plat/system.h
+ *
+ * SPEAr platform specific architecture functions
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_SYSTEM_H
+#define __PLAT_SYSTEM_H
+
+#include <asm/hardware/sp810.h>
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline int arch_change_mode(int mode)
+{
+	return sysctl_change_mode((void __iomem *)VA_SPEAR_SYS_CTRL_BASE, mode);
+}
+
+#endif /* __PLAT_SYSTEM_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/timex.h b/arch/arm/plat-spear13xx/include/plat/timex.h
new file mode 100644
index 0000000..914d09d
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/timex.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/plat-spear/include/plat/timex.h
+ *
+ * SPEAr platform specific timex definitions
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __PLAT_TIMEX_H
+#define __PLAT_TIMEX_H
+
+#define CLOCK_TICK_RATE			48000000
+
+#endif /* __PLAT_TIMEX_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/touchscreen.h b/arch/arm/plat-spear13xx/include/plat/touchscreen.h
new file mode 100644
index 0000000..0eed0a0
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/touchscreen.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/plat-spear/include/plat/touchscreen.h
+ *
+ * Header file for touchscreen present on SPEAr platform
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Vipul Kumar Samar <vipulkumar.samar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __PLAT_TOUCHSCREEN_H
+#define __PLAT_TOUCHSCREEN_H
+
+struct spear_touchscreen {
+	u32 adc_channel_x;
+	u32 adc_channel_y;
+	u32 gpio_pin;
+};
+
+#endif /* _TOUCHSCREEN_SPEAR_H */
diff --git a/arch/arm/plat-spear13xx/include/plat/udc.h b/arch/arm/plat-spear13xx/include/plat/udc.h
new file mode 100644
index 0000000..c3f10e4
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/udc.h
@@ -0,0 +1,36 @@
+/*
+ * arch/arm/plat-spear/include/plat/udc.h
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar<rajeev-dlh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+*/
+
+#ifndef __PLAT_UDC_H
+#define __PLAT_UDC_H
+
+#include <linux/platform_device.h>
+
+#define UDC_MAX_ENDPOINT	16
+
+/*
+ * Platform data definitions for synopsys gadget driver.
+ */
+struct udc_ep_data {
+	char	*name;
+	int	fifo_size;
+	int	maxpacket;
+	u8	addr;
+	u8	attrib;
+};
+
+struct udc_platform_data {
+	int num_ep;
+	struct udc_ep_data ep[0];
+};
+
+void set_udc_plat_data(struct platform_device *pdev);
+#endif
diff --git a/arch/arm/plat-spear13xx/include/plat/uncompress.h b/arch/arm/plat-spear13xx/include/plat/uncompress.h
new file mode 100644
index 0000000..1bf8452
--- /dev/null
+++ b/arch/arm/plat-spear13xx/include/plat/uncompress.h
@@ -0,0 +1,43 @@
+/*
+ * arch/arm/plat-spear/include/plat/uncompress.h
+ *
+ * Serial port stubs for kernel decompress status messages
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/io.h>
+#include <linux/amba/serial.h>
+#include <mach/hardware.h>
+
+#ifndef __PLAT_UNCOMPRESS_H
+#define __PLAT_UNCOMPRESS_H
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	void __iomem *base = (void __iomem *)SPEAR_DBG_UART_BASE;
+
+	while (readl_relaxed(base + UART01x_FR) & UART01x_FR_TXFF)
+		barrier();
+
+	writel_relaxed(c, base + UART01x_DR);
+}
+
+static inline void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif /* __PLAT_UNCOMPRESS_H */
diff --git a/arch/arm/plat-spear13xx/padmux.c b/arch/arm/plat-spear13xx/padmux.c
new file mode 100644
index 0000000..b7f4c3a
--- /dev/null
+++ b/arch/arm/plat-spear13xx/padmux.c
@@ -0,0 +1,170 @@
+/*
+ * arch/arm/plat-spear/include/plat/padmux.c
+ *
+ * SPEAr platform specific gpio pads muxing source file
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <plat/padmux.h>
+
+/*
+ * struct pmx: pmx definition structure
+ *
+ * mode_reg: mode configurations
+ * active_mode: pointer to current active mode
+ */
+struct pmx {
+	struct pmx_reg mode_reg;
+	struct pmx_mode *active_mode;
+};
+
+static struct pmx *pmx;
+
+/**
+ * pmx_mode_set - Enables an multiplexing mode
+ * @mode - pointer to pmx mode
+ *
+ * It will set mode of operation in hardware.
+ * Returns -ve on Err otherwise 0
+ */
+static int pmx_mode_set(struct pmx_mode *mode)
+{
+	u32 val, *address;
+
+	if (!mode->name)
+		return -EFAULT;
+
+	pmx->active_mode = mode;
+
+	address = ioremap(pmx->mode_reg.address, SZ_16);
+	if (address) {
+		val = readl(address);
+		val &= ~pmx->mode_reg.mask;
+		val |= mode->value & pmx->mode_reg.mask;
+		writel(val, address);
+
+		iounmap(address);
+	}
+
+	return 0;
+}
+
+void enable_dev_for_mode(struct pmx_dev_mode *mode)
+{
+	int k;
+	struct pmx_mux_reg *mux_reg;
+	u32 *address, val;
+
+	/* enable peripheral */
+	for (k = 0; k < mode->mux_reg_cnt; k++) {
+		mux_reg = &mode->mux_regs[k];
+
+		address = ioremap(mux_reg->address, SZ_16);
+		if (address) {
+			val = readl(address);
+			val &= ~mux_reg->mask;
+			val |= mux_reg->value & mux_reg->mask;
+			writel(val, address);
+
+			iounmap(address);
+		}
+	}
+}
+
+/**
+ * pmx_devs_enable - Enables list of devices
+ * @devs - pointer to pmx device array
+ * @count - number of devices to enable
+ *
+ * It will enable pads for all required peripherals once and only once.
+ * If peripheral is not supported by current mode then request is rejected.
+ * Conflicts between peripherals are not handled and peripherals will be
+ * enabled in the order they are present in pmx_dev array.
+ * In case of conflicts last peripheral enabled will remain present.
+ * Returns -ve on Err otherwise 0
+ */
+int pmx_devs_enable(struct pmx_dev **devs, u8 count)
+{
+	u32 i, j;
+	bool found;
+
+	if (!count)
+		return -EINVAL;
+
+	for (i = 0, j = 0; i < count; i++) {
+		if (!devs[i]->name || !devs[i]->modes) {
+			printk(KERN_ERR "padmux: dev name or modes is null\n");
+			continue;
+		}
+
+		found = false;
+
+		/* Enable dev for all struct modes which support current mode */
+		for (j = 0; j < devs[i]->mode_count; j++) {
+			if (!pmx->active_mode || (devs[i]->modes[j].ids &
+						pmx->active_mode->id)) {
+				found = true;
+				enable_dev_for_mode(&devs[i]->modes[j]);
+			}
+		}
+
+		if (found) {
+			devs[i]->is_active = true;
+			continue;
+		}
+
+		printk(KERN_ERR "%s device not available in %s mode\n",
+				devs[i]->name, pmx->active_mode->name);
+	}
+
+	return 0;
+}
+
+/**
+ * pmx_register - registers a platform requesting pad mux feature
+ * @driver - pointer to driver structure containing driver specific parameters
+ *
+ * Also this must be called only once. This will allocate memory for pmx
+ * structure, will call pmx_mode_set, will call pmx_devs_enable.
+ * Returns -ve on Err otherwise 0
+ */
+int pmx_register(struct pmx_driver *driver)
+{
+	int ret = 0;
+
+	if (pmx)
+		return -EPERM;
+	if (!driver->devs)
+		return -EFAULT;
+
+	pmx = kzalloc(sizeof(*pmx), GFP_KERNEL);
+	if (!pmx)
+		return -ENOMEM;
+
+	pmx->mode_reg.address = driver->mode_reg.address;
+	pmx->mode_reg.mask = driver->mode_reg.mask;
+
+	/* choose mode to enable */
+	if (driver->mode) {
+		ret = pmx_mode_set(driver->mode);
+		if (ret)
+			goto pmx_fail;
+	}
+	ret = pmx_devs_enable(driver->devs, driver->devs_count);
+	if (ret)
+		goto pmx_fail;
+
+	return 0;
+
+pmx_fail:
+	return ret;
+}
diff --git a/arch/arm/plat-spear13xx/plgpio.c b/arch/arm/plat-spear13xx/plgpio.c
new file mode 100644
index 0000000..58fc0fd
--- /dev/null
+++ b/arch/arm/plat-spear13xx/plgpio.c
@@ -0,0 +1,649 @@
+/*
+ * arch/arm/plat-spear/plgpio.c
+ *
+ * SPEAr platform PLGPIO driver source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <asm/mach-types.h>
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+
+#define MAX_GPIO_PER_REG		32
+#define PIN_OFFSET(pin)			(pin % MAX_GPIO_PER_REG)
+#define REG_OFFSET(base, reg, pin)	(base + reg + (pin / MAX_GPIO_PER_REG)\
+		* sizeof(int *))
+
+/*
+ * struct plgpio: plgpio driver specific structure
+ *
+ * lock: lock for guarding gpio registers
+ * base: base address of plgpio block
+ * irq_base: irq number of plgpio0
+ * chip: gpio framework specific chip information structure
+ * grp_size: number of gpio's in a group for interrupt registers
+ * p2o: function ptr for pin to offset conversion. This is required only for
+ * machines where mapping b/w pin and offset is not 1-to-1.
+ * o2p: function ptr for offset to pin conversion. This is required only for
+ * machines where mapping b/w pin and offset is not 1-to-1.
+ * p2o_regs: mask of registers for which p2o and o2p are applicable
+ * regs: register offsets
+ */
+struct plgpio {
+	spinlock_t		lock;
+	void __iomem		*base;
+	struct clk		*clk;
+	unsigned		irq_base;
+	struct gpio_chip	chip;
+	u32			grp_size;
+	int			(*p2o)(int pin);	/* pin_to_offset */
+	int			(*o2p)(int offset);	/* offset_to_pin */
+	u32			p2o_regs;
+	struct plgpio_regs	regs;
+#ifdef CONFIG_PM
+	struct plgpio_regs	*csave_regs;
+#endif
+};
+
+/* register manipulation inline functions */
+static inline u32 is_plgpio_set(void __iomem *base, u32 pin, u32 reg)
+{
+	u32 offset = PIN_OFFSET(pin);
+	void __iomem *reg_off = REG_OFFSET(base, reg, pin);
+	u32 val = readl(reg_off);
+
+	return !!(val & (1 << offset));
+}
+
+static inline void plgpio_reg_set(void __iomem *base, u32 pin, u32 reg)
+{
+	u32 offset = PIN_OFFSET(pin);
+	void __iomem *reg_off = REG_OFFSET(base, reg, pin);
+	u32 val = readl(reg_off);
+
+	writel(val | (1 << offset), reg_off);
+}
+
+static inline void plgpio_reg_reset(void __iomem *base, u32 pin, u32 reg)
+{
+	u32 offset = PIN_OFFSET(pin);
+	void __iomem *reg_off = REG_OFFSET(base, reg, pin);
+	u32 val = readl(reg_off);
+
+	writel(val & ~(1 << offset), reg_off);
+}
+
+/* gpio framework specific routines */
+static int plgpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+	unsigned long flags;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_DIR_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return -EINVAL;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_set(plgpio->base, offset, plgpio->regs.dir);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+
+	return 0;
+}
+
+static int plgpio_direction_output(struct gpio_chip *chip, unsigned offset,
+		int value)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+	unsigned long flags;
+	unsigned dir_offset = offset, wdata_offset = offset, tmp;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & (PTO_DIR_REG | PTO_WDATA_REG))) {
+		tmp = plgpio->p2o(offset);
+		if (tmp == -1)
+			return -EINVAL;
+
+		if (plgpio->p2o_regs & PTO_DIR_REG)
+			dir_offset = tmp;
+		if (plgpio->p2o_regs & PTO_WDATA_REG)
+			wdata_offset = tmp;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_reset(plgpio->base, dir_offset, plgpio->regs.dir);
+	if (value)
+		plgpio_reg_set(plgpio->base, wdata_offset,
+				plgpio->regs.wdata);
+	else
+		plgpio_reg_reset(plgpio->base, wdata_offset,
+				plgpio->regs.wdata);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+
+	return 0;
+}
+
+static int plgpio_get_value(struct gpio_chip *chip, unsigned offset)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_RDATA_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return -EINVAL;
+	}
+
+	return is_plgpio_set(plgpio->base, offset, plgpio->regs.rdata);
+}
+
+static void plgpio_set_value(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+
+	if (offset >= chip->ngpio)
+		return;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_WDATA_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return;
+	}
+
+	if (value)
+		plgpio_reg_set(plgpio->base, offset, plgpio->regs.wdata);
+	else
+		plgpio_reg_reset(plgpio->base, offset, plgpio->regs.wdata);
+}
+
+static int plgpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+	unsigned long flags;
+	int ret = 0;
+
+	if (offset >= chip->ngpio)
+		return -EINVAL;
+
+	if (plgpio->clk) {
+		ret = clk_enable(plgpio->clk);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * put gpio in IN mode before enabling it. This make enabling gpio safe
+	 */
+	ret = plgpio_direction_input(chip, offset);
+	if (ret)
+		return ret;
+
+	if (plgpio->regs.enb == -1)
+		return 0;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return -EINVAL;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_set(plgpio->base, offset, plgpio->regs.enb);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+	return 0;
+}
+
+static void plgpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+	unsigned long flags;
+
+	if (offset >= chip->ngpio)
+		return;
+
+	if (plgpio->clk)
+		clk_disable(plgpio->clk);
+
+	if (plgpio->regs.enb == -1)
+		return;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_ENB_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_reset(plgpio->base, offset, plgpio->regs.enb);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+}
+
+static int plgpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct plgpio *plgpio = container_of(chip, struct plgpio, chip);
+	int size = plgpio->grp_size ? plgpio->grp_size : 1;
+
+	if (plgpio->irq_base == (unsigned) -1)
+		return -EINVAL;
+
+	return plgpio->irq_base + offset / size;
+}
+
+/* PLGPIO IRQ */
+static void plgpio_irq_disable(struct irq_data *d)
+{
+	struct plgpio *plgpio = irq_data_get_irq_chip_data(d);
+	int offset = d->irq - plgpio->irq_base;
+	unsigned long flags;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_set(plgpio->base, offset, plgpio->regs.ie);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+}
+
+static void plgpio_irq_enable(struct irq_data *d)
+{
+	struct plgpio *plgpio = irq_data_get_irq_chip_data(d);
+	int offset = d->irq - plgpio->irq_base;
+	unsigned long flags;
+
+	/* get correct offset for "offset" pin */
+	if (plgpio->p2o && (plgpio->p2o_regs & PTO_IE_REG)) {
+		offset = plgpio->p2o(offset);
+		if (offset == -1)
+			return;
+	}
+
+	spin_lock_irqsave(&plgpio->lock, flags);
+	plgpio_reg_reset(plgpio->base, offset, plgpio->regs.ie);
+	spin_unlock_irqrestore(&plgpio->lock, flags);
+}
+
+static int plgpio_irq_type(struct irq_data *d, unsigned trigger)
+{
+	struct plgpio *plgpio = irq_data_get_irq_chip_data(d);
+	int offset = d->irq - plgpio->irq_base;
+	int size = plgpio->grp_size ? plgpio->grp_size : 1;
+	void __iomem *reg_off;
+	unsigned int supported_type = 0, val;
+
+	if (offset >= DIV_ROUND_UP(plgpio->chip.ngpio, size))
+		return -EINVAL;
+
+#ifdef CONFIG_ARCH_SPEAR13XX
+	supported_type = IRQ_TYPE_EDGE_RISING;
+
+	if (cpu_is_spear1310() || cpu_is_spear1340())
+		supported_type |= IRQ_TYPE_EDGE_FALLING;
+#else
+	if (cpu_is_spear320() && (plgpio->regs.eit != -1))
+		supported_type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
+	else
+		supported_type = IRQ_TYPE_LEVEL_HIGH;
+#endif
+
+	if (!(trigger & supported_type))
+		return -EINVAL;
+
+	if (plgpio->regs.eit == -1)
+		return 0;
+
+	reg_off = REG_OFFSET(plgpio->base, plgpio->regs.eit, offset);
+	val = readl(reg_off);
+
+	offset = PIN_OFFSET(offset);
+	if (trigger & IRQ_TYPE_EDGE_RISING)
+		writel(val | (1 << offset), reg_off);
+	else
+		writel(val & ~(1 << offset), reg_off);
+
+	return 0;
+}
+
+static struct irq_chip plgpio_irqchip = {
+	.name		= "PLGPIO",
+	.irq_enable	= plgpio_irq_enable,
+	.irq_disable	= plgpio_irq_disable,
+	.irq_set_type	= plgpio_irq_type,
+};
+
+static void plgpio_irq_handler(unsigned irq, struct irq_desc *desc)
+{
+	struct plgpio *plgpio = irq_get_handler_data(irq);
+	unsigned long pending;
+	int regs_count, size, count, pin, offset, i = 0;
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+
+	size = plgpio->grp_size ? plgpio->grp_size : 1;
+	count = DIV_ROUND_UP(plgpio->chip.ngpio, size);
+	regs_count = DIV_ROUND_UP(count, MAX_GPIO_PER_REG);
+
+	chained_irq_enter(irqchip, desc);
+	/* check all plgpio MIS registers for a possible interrupt */
+	for (; i < regs_count; i++) {
+		pending = readl(plgpio->base + plgpio->regs.mis +
+				i * sizeof(int *));
+		if (!pending)
+			continue;
+
+		/* clear interrupts */
+		writel(~pending, plgpio->base + plgpio->regs.mis +
+				i * sizeof(int *));
+		/*
+		 * clear extra bits in last register having gpios < MAX/REG
+		 * ex: Suppose there are max 102 plgpios. then last register
+		 * must have only (102 - MAX_GPIO_PER_REG * 3) = 6 relevant bits
+		 * so, we must not take other 28 bits into consideration for
+		 * checking interrupt. so clear those bits.
+		 */
+		count = count - i * MAX_GPIO_PER_REG;
+		if (count < MAX_GPIO_PER_REG)
+			pending &= (1 << count) - 1;
+
+		for_each_set_bit(offset, &pending, MAX_GPIO_PER_REG) {
+			/* get correct pin for "offset" */
+			if (plgpio->o2p && (plgpio->p2o_regs & PTO_MIS_REG)) {
+				pin = plgpio->o2p(offset);
+				if (pin == -1)
+					continue;
+			} else
+				pin = offset;
+
+			/* get correct irq line number */
+			pin = i * MAX_GPIO_PER_REG + pin;
+			/* get correct gpio pin number */
+			pin *= size;
+			generic_handle_irq(plgpio_to_irq(&plgpio->chip, pin));
+		}
+	}
+	chained_irq_exit(irqchip, desc);
+}
+
+static int __devinit plgpio_probe(struct platform_device *pdev)
+{
+	struct plgpio_platform_data *pdata;
+	struct plgpio *plgpio;
+	int ret, irq, i, count;
+	struct resource *res;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "invalid platform data\n");
+		goto fail;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -EBUSY;
+		dev_dbg(&pdev->dev, "invalid IORESOURCE_MEM\n");
+		goto fail;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res), "plgpio")) {
+		ret = -EBUSY;
+		dev_dbg(&pdev->dev, "request mem region fail\n");
+		goto fail;
+	}
+
+	plgpio = kzalloc(sizeof(*plgpio), GFP_KERNEL);
+	if (!plgpio) {
+		ret = -ENOMEM;
+		dev_dbg(&pdev->dev, "memory allocation fail\n");
+		goto release_region;
+	}
+
+#ifdef CONFIG_PM
+	plgpio->csave_regs = kzalloc(sizeof(*plgpio->csave_regs) *
+			DIV_ROUND_UP(pdata->gpio_count, MAX_GPIO_PER_REG),
+			GFP_KERNEL);
+	if (!plgpio->csave_regs) {
+		ret = -ENOMEM;
+		dev_dbg(&pdev->dev, "csave registers memory allocation fail\n");
+		goto kfree_plgpio;
+	}
+#endif
+	plgpio->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(plgpio->clk)) {
+		dev_warn(&pdev->dev, "could not retrieve clock\n");
+		plgpio->clk = NULL;
+	}
+
+	plgpio->base = ioremap(res->start, resource_size(res));
+	if (!plgpio->base) {
+		ret = -ENOMEM;
+		dev_dbg(&pdev->dev, "ioremap fail\n");
+		goto kfree_csave_reg;
+	}
+
+	spin_lock_init(&plgpio->lock);
+
+	plgpio->chip.request = plgpio_request;
+	plgpio->chip.free = plgpio_free;
+	plgpio->chip.direction_input = plgpio_direction_input;
+	plgpio->chip.direction_output = plgpio_direction_output;
+	plgpio->chip.get = plgpio_get_value;
+	plgpio->chip.set = plgpio_set_value;
+	plgpio->chip.to_irq = plgpio_to_irq;
+	plgpio->chip.base = pdata->gpio_base;
+	plgpio->chip.ngpio = pdata->gpio_count;
+	plgpio->chip.label = dev_name(&pdev->dev);
+	plgpio->chip.dev = &pdev->dev;
+	plgpio->chip.owner = THIS_MODULE;
+	plgpio->irq_base = pdata->irq_base;
+	plgpio->grp_size = pdata->grp_size;
+	plgpio->p2o = pdata->p2o;
+	plgpio->o2p = pdata->o2p;
+	plgpio->p2o_regs = pdata->p2o_regs;
+	plgpio->regs.enb = pdata->regs.enb;
+	plgpio->regs.wdata = pdata->regs.wdata;
+	plgpio->regs.dir = pdata->regs.dir;
+	plgpio->regs.ie = pdata->regs.ie;
+	plgpio->regs.rdata = pdata->regs.rdata;
+	plgpio->regs.mis = pdata->regs.mis;
+	plgpio->regs.eit = pdata->regs.eit;
+
+	ret = gpiochip_add(&plgpio->chip);
+	if (ret) {
+		dev_dbg(&pdev->dev, "unable to add gpio chip\n");
+		goto iounmap;
+	}
+
+	/* irq_chip support */
+	if (pdata->irq_base == (unsigned) -1) {
+		dev_info(&pdev->dev, "Initialization successful\n");
+		return 0;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "invalid irq number\n");
+		goto remove_gpiochip;
+	}
+
+	count = pdata->grp_size ? pdata->grp_size : 1;
+	count = DIV_ROUND_UP(pdata->gpio_count, count);
+	irq_set_chained_handler(irq, plgpio_irq_handler);
+	for (i = 0; i < count; i++) {
+		irq_set_chip_and_handler(i + plgpio->irq_base, &plgpio_irqchip,
+					 handle_simple_irq);
+		set_irq_flags(i+plgpio->irq_base, IRQF_VALID);
+		irq_set_chip_data(i + plgpio->irq_base, plgpio);
+	}
+	irq_set_handler_data(irq, plgpio);
+
+	platform_set_drvdata(pdev, plgpio);
+	dev_info(&pdev->dev, "Initialization successful\n");
+
+	return 0;
+
+remove_gpiochip:
+	if (gpiochip_remove(&plgpio->chip))
+		dev_dbg(&pdev->dev, "unable to remove gpiochip\n");
+iounmap:
+	iounmap(plgpio->base);
+kfree_csave_reg:
+#ifdef CONFIG_PM
+	kfree(plgpio->csave_regs);
+#endif
+kfree_plgpio:
+	if (plgpio->clk)
+		clk_put(plgpio->clk);
+	kfree(plgpio);
+release_region:
+	release_mem_region(res->start, resource_size(res));
+fail:
+	dev_err(&pdev->dev, "probe fail: %d\n", ret);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int plgpio_suspend(struct device *dev)
+{
+	struct plgpio *plgpio = dev_get_drvdata(dev);
+	int i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);
+	void __iomem *off;
+
+	for (i = 0; i < reg_count; i++) {
+		off = plgpio->base + i * sizeof(int *);
+
+		if (plgpio->regs.enb != -1)
+			plgpio->csave_regs[i].enb = readl(plgpio->regs.enb +
+					off);
+		if (plgpio->regs.eit != -1)
+			plgpio->csave_regs[i].eit = readl(plgpio->regs.eit +
+					off);
+		plgpio->csave_regs[i].wdata = readl(plgpio->regs.wdata + off);
+		plgpio->csave_regs[i].dir = readl(plgpio->regs.dir + off);
+		plgpio->csave_regs[i].ie = readl(plgpio->regs.ie + off);
+	}
+
+	return 0;
+}
+
+/*
+ * This is used to correct the values in end registers. End registers contain
+ * extra bits that might be used for other purpose in platform. So, we shouldn't
+ * overwrite these bits. This macro, reads given register again, preserves other
+ * bit values (non-plgpio bits), and retain captured value (plgpio bits).
+ */
+#define plgpio_prepare_reg(__reg, _off, _mask, _tmp)		\
+{								\
+	_tmp = readl(plgpio->regs.__reg + _off);		\
+	_tmp &= ~_mask;						\
+	plgpio->csave_regs[i].__reg =				\
+		_tmp | (plgpio->csave_regs[i].__reg & _mask);	\
+}
+
+static int plgpio_resume(struct device *dev)
+{
+	struct plgpio *plgpio = dev_get_drvdata(dev);
+	int i, reg_count = DIV_ROUND_UP(plgpio->chip.ngpio, MAX_GPIO_PER_REG);
+	void __iomem *off;
+	u32 mask, tmp;
+
+	for (i = 0; i < reg_count; i++) {
+		off = plgpio->base + i * sizeof(int *);
+
+		if (i == reg_count - 1) {
+			mask = (1 << (plgpio->chip.ngpio - i *
+						MAX_GPIO_PER_REG)) - 1;
+
+			if (plgpio->regs.enb != -1)
+				plgpio_prepare_reg(enb, off, mask, tmp);
+
+			if (plgpio->regs.eit != -1)
+				plgpio_prepare_reg(eit, off, mask, tmp);
+
+			plgpio_prepare_reg(wdata, off, mask, tmp);
+			plgpio_prepare_reg(dir, off, mask, tmp);
+			plgpio_prepare_reg(ie, off, mask, tmp);
+		}
+
+		writel(plgpio->csave_regs[i].wdata, plgpio->regs.wdata + off);
+		writel(plgpio->csave_regs[i].dir, plgpio->regs.dir + off);
+
+		if (plgpio->regs.eit != -1)
+			writel(plgpio->csave_regs[i].eit, plgpio->regs.eit +
+					off);
+
+		writel(plgpio->csave_regs[i].ie, plgpio->regs.ie + off);
+
+		if (plgpio->regs.enb != -1)
+			writel(plgpio->csave_regs[i].enb, plgpio->regs.enb +
+					off);
+	}
+
+	return 0;
+}
+
+static const struct dev_pm_ops plgpio_dev_pm_ops = {
+	.suspend = plgpio_suspend,
+	.resume = plgpio_resume,
+	.freeze = plgpio_suspend,
+	.restore = plgpio_resume,
+};
+#endif
+
+static struct platform_driver plgpio_driver = {
+	.probe		= plgpio_probe,
+	.driver		= {
+		.name	= "plgpio",
+#ifdef CONFIG_PM
+		.pm	= &plgpio_dev_pm_ops,
+#endif
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init plgpio_init(void)
+{
+	return platform_driver_register(&plgpio_driver);
+}
+subsys_initcall(plgpio_init);
+
+MODULE_AUTHOR("Viresh Kumar <viresh.kumar@st.com>");
+MODULE_DESCRIPTION("SPEAr PLGPIO driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-spear13xx/pll_clk.S b/arch/arm/plat-spear13xx/pll_clk.S
new file mode 100644
index 0000000..adcd6b0
--- /dev/null
+++ b/arch/arm/plat-spear13xx/pll_clk.S
@@ -0,0 +1,187 @@
+/*
+ * arch/arm/plat-spear/pll_clk.S
+ *
+ * SPEAR3xx and SPEAR6xx specific functions that will run in
+ * cache. These funstions intend to configure the PLL.
+ *
+ * Copyright (ST) 2010 Deepak Sikri <deepak.sikri@.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/hardware.h>
+#include <mach/suspend.h>
+
+#if defined(CONFIG_ARCH_SPEAR3XX) || defined(CONFIG_ARCH_SPEAR6XX)
+.text
+ENTRY(vco_set_rate)
+	stmfd	sp!, {r0-r12, lr}
+
+	/* Lock down the TLB entry to the current victim */
+	mrc	p15, 0, r3, c10, c0, 0	/* read the lockdown register */
+	orr	r3, r3, #1		/* set the preserved bit */
+	mcr	p15, 0, r3, c10, c0, 0	/* write to the lockdown register */
+
+	/*
+	 * set r4 to the value of the address to be locked down.
+	 * Invalidate the TLB single entry in TLB to ensure that
+	 * the locked address is not already in TLB.
+	 * MPMC, System Controller & Miscellaneous register address
+	 * are locked down below.
+	 */
+
+	ldr	r4, MPMC_BASE_VA
+	/* Invalidate the MPMC virtual address in TLB. */
+	mcr	p15, 0, r4, c8, c7, 1
+	/* TLB will miss and entry will be reloaded */
+	ldr	r4, [r4]
+	/* read the lockdown register (victim will have rloaded) */
+	mrc	p15, 0, r3, c10, c0, 0
+
+	ldr	r4, SYS_CTRL_BASE_VA
+	/* Invalidate the System controller virtual address in TLB */
+	mcr	p15, 0, r4, c8, c7, 1
+	/* TLB will miss and entry will be reloaded */
+	ldr	r4, [r4]
+	/* read the lockdown register (victim will have rloaded) */
+	mrc	p15, 0, r3, c10, c0, 0
+
+	ldr	r4, MISC_BASE_VA
+	/* Invalidate the Miscellaneous registers virtual address in TLB */
+	mcr	p15, 0, r4, c8, c7, 1
+	/* TLB will miss and entry will be reloaded */
+	ldr	r4, [r4]
+	/* read the lockdown register (victim will have rloaded) */
+	mrc	p15, 0, r3, c10, c0, 0
+
+	/* clear preserve bit */
+	bic	r3, r3, #1
+	/* write to the lockdown register */
+	mcr	p15, 0, r3, c10, c0, 0
+
+	ldr	r7, MPMC_BASE_VA
+	ldr	r8, SYS_CTRL_BASE_VA
+	ldr	r6, MISC_BASE_VA
+	/* Prefetch certain instructions in the cache. */
+	adr	r4, cache_prefetch_start1
+	adr	r5, cache_prefetch_end1
+	mvn	r3, #0x1F
+	ands	r4, r3, r4
+	/* Lock Instructions in i-cache */
+fetch_loop:
+	/*
+	 * copy a cache-line-sized block of main memory to a cache
+	 * line in the I-cache.
+	 */
+	mcr	p15, 0, r4, c7, c13, 1
+	cmp	r4, r5
+	addls	r4, r4, #0x20
+	bls	fetch_loop
+cache_prefetch_start1:
+	/* Put SDRAM in self-refresh mode */
+	ldr	r3, [r7, #0x1c]
+	/* Clear START bit(24) of MEMCTL_GP_03 register in MPMC */
+	ldr	r4, =0x1000000
+	bic	r3, r3, r4
+	str	r3, [r7, #0x1c]
+
+	ldr	r3, [r7, #0xe4]
+	ldr	r4, =0xffff0000
+	/* Latch the current self refresh time */
+	mov	r9, r3
+	/* Increase the self refresh exit time */
+	bic	r3, r3, r4
+	ldr	r4, =0xffff
+	/* Program the SDRAM self refresh exit time on read command */
+	orr	r3, r3, r4, LSL #16
+	str	r3, [r7, #0xe4]
+
+	ldr	r3, [r7, #0x1c]
+	/* Set the SREFRESH bit(16) */
+	ldr	r4, =0x10000
+	orr	r3, r3, r4
+	str	r3, [r7, #0x1c]
+
+	/* Put the system in slow mode, use system controller */
+	ldr	r3, [r8]
+	bic	r3, r3, #0x7
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	orr	r3, r3, #0x2
+	str	r3, [r8]
+
+wait_till_slow_mode:
+	ldr	r3, [r8]
+	and	r3, r3, #0x78	/* Wait for the mode to be updated */
+	cmp	r3, #0x10	/* Poll the SCCTRL register status bits (6:3) */
+	bne wait_till_slow_mode
+
+	/*
+	 * reprogram the m(r0), p(r2), n(r1) values in the PLL
+	 * control registers (PLL_FRQ register in misc space).
+	 */
+	ldr	r3, [r6, #0x0c]
+	bic	r3, r3, #0x00ff
+	/* Program the PLL post divisor: p */
+	orr	r3, r3, r2
+	str	r3, [r6, #0x0c]
+
+	ldr	r3, [r6, #0x0c]
+	ldr	r4, =0xffff0000
+	bic	r3, r3, r4
+	bic	r3, r3, #0x0700
+	/* Program the PLL pre divisor: n */
+	orr	r3, r3, r1, LSL #8
+	/* Program the PLL feedback divisor: m */
+	orr	r3, r3, r0, LSL #24
+	str	r3, [r6, #0x0c]
+
+	/* Move the system in Normal mode, use system controller */
+	ldr	r3, [r8, #0x0]
+	ldr	r4, =0xfffffff8
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	and	r3, r3, r4
+	orr	r3, r3, #0x4
+	str	r3, [r8, #0x0]
+
+wait_till_normal_mode:
+	ldr	r3, [r8, #0x0]
+	and	r3, r3, #0x78
+	cmp	r3, #0x20	/* Poll the SCCTRL register status bits (6:3) */
+	bne wait_till_normal_mode
+
+	/* Exit DDR-SDRAM from self-refresh mode */
+	ldr	r10, MPMC_BASE_VA
+	/* Clear the SREFRESH bit(16) */
+	ldr	r3, [r10, #0x1c]
+	ldr	r4, =0x10000
+	bic	r3, r3, r4
+	str	r3, [r10, #0x1c]
+	/* Restore the SDRAM self refresh exit time on read command */
+	mov	r3, r9
+	str	r3, [r7, #0xe4]
+	/* Begin the command processing in controller */
+	ldr	r4, =0x1000000
+	orr	r3, r3, r4
+	/* Set START bit(24) of MEMCTL_GP_03 register in MPMC*/
+	str	r3, [r10, #0x1c]
+
+	ldmfd	sp!, {r0-r12, pc}
+
+/* This is the end of the code to be copied */
+
+SYS_CTRL_BASE_VA :
+	.word IO_ADDRESS(SYS_CTRL_BASE_PA)
+MPMC_BASE_VA :
+	.word IO_ADDRESS(MPMC_BASE_PA)
+MISC_BASE_VA :
+	.word IO_ADDRESS(MISC_BASE_PA)
+cache_prefetch_end1 :
+
+#elif defined(CONFIG_ARCH_SPEAR13XX)
+.text
+ENTRY(vco_set_rate)
+#endif
diff --git a/arch/arm/plat-spear13xx/plug_boards.c b/arch/arm/plat-spear13xx/plug_boards.c
new file mode 100644
index 0000000..61d0725
--- /dev/null
+++ b/arch/arm/plat-spear13xx/plug_boards.c
@@ -0,0 +1,258 @@
+/*
+ * arch/arm/mach-spear13xx/plug_boards_common.c
+ *
+ * SPEAr plug boards common source file
+ *
+ * Copyright (C) 2011-12 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+/*
+ * This file includes all the common function to be used by all the plug
+ * board files.
+ * Plug boards allow the different standard test and debug procedures on the
+ * same physical interface without the need to develop a specific board and use
+ * a different manufacturers chips. They are connected to the main board
+ * through small high speed shielded connectors to avoid quality degradation of
+ * the signals. Each plug has the interface connectors on different positions to
+ * prevent any insertions errors.
+ *
+ * The philosophy picked for maintaining them in software is as follows. Firstly
+ * device arrays will be prepared in respective evb file and these will be
+ * passed to plug board init routine, if plug boards are passed from bootargs.
+ * This routine may:
+ * - override the padmux settings done earlier by evb board
+ * - skip registeration of some devices passed from evb_init()
+ * - add new amba/plat devs, etc devices
+ * - If multiple boards are passed from bootargs, then boards will be
+ *   initialized in the order they are mentioned in bootargs.
+ *
+ * Passing param from bootargs
+ * ---------------------------
+ * "pb=" must be used to pass plug boards request from bootargs. This variable
+ * can contain string values mentioned above in board descriptions"
+ *
+ * More than one board can be requested by passing ',' separated board list, eg:
+ * bootargs: console=ttyAMA0,115200 pb=rgmii,hdmi_tx,cam0
+ */
+
+
+#include <linux/bug.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <plat/plug_board.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+
+/* string specifying which plug boards are requested */
+static char __initdata spear_plug_board[MAX_REQ_PB] = {'\0', };
+
+static int __init spear_pb_select(char *boards)
+{
+	strcpy(spear_plug_board, boards);
+
+	return 0;
+}
+__setup("pb=", spear_pb_select);
+
+static bool skip_device(struct list_head *pb_list, void *dev,
+		enum skip_device_type skip)
+{
+	struct plug_board *pb;
+	int i;
+
+	list_for_each_entry(pb, pb_list, node) {
+		switch (skip) {
+		case SKIP_PLAT_DEVICE:
+			for (i = 0; i < pb->rm_pcnt; i++) {
+				if (dev == pb->rm_pdevs[i]) {
+					pr_debug("%s: skip %s.%d\n",
+						pb->name, pb->rm_pdevs[i]->name,
+						pb->rm_pdevs[i]->id == -1 ? 0 :
+						pb->rm_pdevs[i]->id);
+					return true;
+				}
+			}
+			break;
+		case SKIP_AMBA_DEVICE:
+			for (i = 0; i < pb->rm_acnt; i++) {
+				if (dev == pb->rm_adevs[i]) {
+					pr_debug("%s: skip %s\n", pb->name,
+						pb->rm_adevs[i]->dev.init_name);
+					return true;
+				}
+			}
+			break;
+		case SKIP_SPI_DEVICE:
+			for (i = 0; i < pb->rm_spi_cnt; i++) {
+				if (dev == pb->rm_spi_devs[i]) {
+					pr_debug("%s: skip %s\n", pb->name,
+						pb->rm_spi_devs[i]->modalias);
+					return true;
+				}
+			}
+			break;
+		case SKIP_I2C_DEVICE:
+			for (i = 0; i < pb->rm_i2c_cnt; i++) {
+				if (dev == pb->rm_i2c_devs[i]) {
+					pr_debug("%s: skip %s\n", pb->name,
+					pb->rm_i2c_devs[i]->board->type);
+					return true;
+				}
+			}
+			break;
+
+		default:
+			return false;
+		}
+	}
+
+	return false;
+}
+
+bool spear_pb_present(void)
+{
+	if (spear_plug_board[0] != '\0')
+		return true;
+	else
+		return false;
+}
+
+char *get_spear_pb(void)
+{
+	static char *str = spear_plug_board;
+
+	return strsep((char **)&str, ",");
+}
+
+int __init spear_pb_init(struct plug_board_info *pb_info,
+		int (*make_pb_list)(struct list_head *pb_list))
+{
+	struct platform_device **pdevs;
+	struct amba_device **adevs;
+	struct plug_board *pb;
+	struct spi_board_info **spi_devs;
+	struct i2c_dev_info **i2c_devs;
+	int ret, i;
+	u8 pcnt, acnt, spi_cnt, i2c_cnt;
+	LIST_HEAD(pb_list);
+
+	if (!pb_info)
+		return -EINVAL;
+
+	pr_debug("%s: Plug board string passed from bootargs: %s\n", __func__,
+			spear_plug_board);
+
+	pdevs = pb_info->pdevs;
+	pcnt = pb_info->pcnt;
+	adevs = pb_info->adevs;
+	acnt = pb_info->acnt;
+	spi_devs = pb_info->spi_devs;
+	spi_cnt = pb_info->spi_cnt;
+	i2c_devs = pb_info->i2c_devs;
+	i2c_cnt = pb_info->i2c_cnt;
+
+	ret = (*make_pb_list)(&pb_list);
+	if (ret) {
+		pr_err("Error creating pb_list: %d\n", ret);
+		return ret;
+	}
+
+	/* Call board specific init routine */
+	list_for_each_entry(pb, &pb_list, node) {
+		pr_debug("%s: Initializing plug board\n", pb->name);
+
+		if (pb->pb_init)
+			pb->pb_init();
+	}
+
+	list_for_each_entry(pb, &pb_list, node) {
+		if (!pb->pmx_cnt)
+			continue;
+
+		ret = pmx_devs_enable(pb->pmx_devs, pb->pmx_cnt);
+		if (ret)
+			pr_err("padmux: Failed adding pmx devs: %d\n", ret);
+
+		pr_debug("%s: Added %d pmx devices\n", pb->name, pb->pmx_cnt);
+	}
+
+	/* Add SPI Devices passed from evb.c */
+	for (i = 0; i < spi_cnt; i++) {
+		if (skip_device(&pb_list, spi_devs[i], SKIP_SPI_DEVICE))
+			continue;
+
+		spi_register_board_info(spi_devs[i], 1);
+	}
+
+	/* Add SPI Devices requested by plug boards */
+	list_for_each_entry(pb, &pb_list, node) {
+		for (i = 0; i < pb->add_spi_cnt; i++)
+			spi_register_board_info(pb->add_spi_devs[i], 1);
+
+		pr_debug("%s: Added %d SPI devices\n",
+				pb->name, pb->add_spi_cnt);
+	}
+
+	/* Add I2C Devices passed from evb.c */
+	for (i = 0; i < i2c_cnt; i++) {
+		if (skip_device(&pb_list, i2c_devs[i], SKIP_I2C_DEVICE))
+			continue;
+
+		i2c_register_board_info(i2c_devs[i]->busnum,
+				i2c_devs[i]->board, 1);
+	}
+
+	/* Add I2C Devices requested by plug boards */
+	list_for_each_entry(pb, &pb_list, node) {
+		for (i = 0; i < pb->add_i2c_cnt; i++)
+			i2c_register_board_info(pb->add_i2c_devs[i]->busnum,
+				pb->add_i2c_devs[i]->board, 1);
+
+		pr_debug("%s: Added %d I2C devices\n",
+				pb->name, pb->add_i2c_cnt);
+	}
+
+	/* Add Amba Devices passed from evb.c */
+	for (i = 0; i < acnt; i++) {
+		if (skip_device(&pb_list, adevs[i], SKIP_AMBA_DEVICE))
+			continue;
+
+		amba_device_register(adevs[i], &iomem_resource);
+	}
+
+	/* Add Amba Devices requested by plug boards */
+	list_for_each_entry(pb, &pb_list, node) {
+		for (i = 0; i < pb->add_acnt; i++)
+			amba_device_register(pb->add_adevs[i], &iomem_resource);
+
+		pr_debug("%s: Added %d amba devices\n", pb->name, pb->add_acnt);
+	}
+
+	/* Add Platform Devices passed from evb.c */
+	for (i = 0; i < pcnt; i++) {
+		if (skip_device(&pb_list, pdevs[i], SKIP_PLAT_DEVICE))
+			continue;
+
+		platform_device_register(pdevs[i]);
+	}
+
+	/* Add Platform Devices requested by plug boards */
+	list_for_each_entry(pb, &pb_list, node) {
+		for (i = 0; i < pb->add_pcnt; i++)
+			platform_device_register(pb->add_pdevs[i]);
+
+		pr_debug("%s: Added %d plat devices\n", pb->name, pb->add_pcnt);
+	}
+
+	list_for_each_entry(pb, &pb_list, node)
+		kfree(pb);
+
+	return 0;
+}
diff --git a/arch/arm/plat-spear13xx/pwm.c b/arch/arm/plat-spear13xx/pwm.c
new file mode 100644
index 0000000..f13a826
--- /dev/null
+++ b/arch/arm/plat-spear13xx/pwm.c
@@ -0,0 +1,613 @@
+/*
+ * arch/arm/plat-spear/pwm.c
+ *
+ * ST Microelectronics SPEAr Pulse Width Modulator driver
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <mach/hardware.h>
+
+/* PWM registers and bits definitions */
+#define PWMCR			0x00
+#define PWMDCR			0x04
+#define PWMPCR			0x08
+#define SPEAR13XX_PWMMCR	0x3C
+
+#define PWM_EN_MASK		0x1
+#define MIN_PRESCALE		0x00
+#define MAX_PRESCALE		0x3FFF
+#define PRESCALE_SHIFT		2
+#define MIN_DUTY		0x0001
+#define MAX_DUTY		0xFFFF
+#define MAX_PERIOD		0xFFFF
+#define MIN_PERIOD		0x0001
+#define SPEAR13XX_MIN_PERIOD	0x0000
+
+#define PWM_DEVICE_PER_IP	4
+#define PWM_DEVICE_OFFSET	0x10
+
+/* lock for pwm_list */
+static DEFINE_SPINLOCK(list_lock);
+/* list of all pwm ips available in system */
+static LIST_HEAD(pwm_list);
+
+/**
+ * struct pwm_device: struct representing pwm device/channel
+ *
+ * pwmd_id: id of pwm device
+ * pwm: pointer to parent pwm ip
+ * label: used for storing label passed in pwm_request
+ * offset: base address offset from parent pwm mmio_base
+ * busy: represents usage status of a pwm device
+ * lock: lock specific to a pwm device
+ * node: node for adding device to parent pwm's devices list
+ *
+ * Each pwm IP contains four independent pwm device/channels. Some or all of
+ * which may be present in our configuration.
+ */
+struct pwm_device {
+	unsigned pwmd_id;
+	struct pwm *pwm;
+	const char *label;
+	unsigned offset;
+	unsigned busy;
+	spinlock_t lock;
+	struct list_head node;
+	u32 csave_reg_PWMCR;
+	u32 csave_reg_PWMDCR;
+	u32 csave_reg_PWMPCR;
+};
+
+/**
+ * struct pwm: struct representing pwm ip
+ *
+ * id: id of pwm ip
+ * mmio_base: base address of pwm
+ * clk: pointer to clk structure of pwm ip
+ * clk_enabled: clock enable status
+ * pwmd_enabled: pwm devices enabled
+ * pdev: pointer to pdev structure of pwm
+ * lock: lock specific to current pwm ip
+ * devices: list of devices/childrens of pwm ip
+ * node: node for adding pwm to global list of all pwm ips
+ */
+struct pwm {
+	unsigned id;
+	void __iomem *mmio_base;
+	struct clk *clk;
+	int clk_enabled;
+	int pwmd_enabled;
+	struct platform_device *pdev;
+	spinlock_t lock;
+	struct list_head devices;
+	struct list_head node;
+};
+
+/*
+ * For SPEAr3xx:
+ * period_ns = 10^9 * (PRESCALE + 1) * PV / PWM_CLK_RATE
+ * PV = (PWM_CLK_RATE * period_ns)/ (10^9 * (PRESCALE + 1))
+ * For SPEAr13xx:
+ * period_ns = 10^9 * (PRESCALE + 1) * (PV + 1) / PWM_CLK_RATE
+ * PV = ((PWM_CLK_RATE * period_ns)/ (10^9 * (PRESCALE + 1))) - 1
+ *
+ * duty_ns = 10^9 * (PRESCALE + 1) * DC / PWM_CLK_RATE
+ * DC = (PWM_CLK_RATE * duty_ns)/ (10^9 * (PRESCALE + 1))
+ */
+int pwm_config(struct pwm_device *pwmd, int duty_ns, int period_ns)
+{
+	u64 val, div, clk_rate;
+	unsigned long prescale = MIN_PRESCALE, pv, dc, min_period;
+	int ret = -EINVAL;
+
+	if (!pwmd) {
+		pr_err("pwm: config - NULL pwm device pointer\n");
+		return -EFAULT;
+	}
+
+	if (period_ns == 0 || duty_ns > period_ns)
+		goto err;
+
+	min_period = cpu_is_spear1340() ? SPEAR13XX_MIN_PERIOD : MIN_PERIOD;
+
+	/* TODO: Need to optimize this loop */
+	while (1) {
+		div = 1000000000;
+		div *= 1 + prescale;
+		clk_rate = clk_get_rate(pwmd->pwm->clk);
+		val = clk_rate * period_ns;
+		pv = div64_u64(val, div);
+		if (!pv)
+			goto err;
+
+		if (cpu_is_spear1340())
+			pv -= 1;
+
+		val = clk_rate * duty_ns;
+		dc = div64_u64(val, div);
+		if (!dc || dc < MIN_DUTY || pv < min_period)
+			goto err;
+
+		if ((pv > MAX_PERIOD) || (dc > MAX_DUTY)) {
+			prescale++;
+			if (prescale > MAX_PRESCALE)
+				goto err;
+			continue;
+		}
+		break;
+	}
+
+	/*
+	 * NOTE: the clock to PWM has to be enabled first
+	 * before writing to the registers
+	 */
+	spin_lock(&pwmd->pwm->lock);
+	ret = clk_enable(pwmd->pwm->clk);
+	if (ret) {
+		spin_unlock(&pwmd->pwm->lock);
+		goto err;
+	}
+
+	spin_lock(&pwmd->lock);
+	writel(prescale << PRESCALE_SHIFT, pwmd->pwm->mmio_base +
+			pwmd->offset + PWMCR);
+	writel(dc, pwmd->pwm->mmio_base + pwmd->offset + PWMDCR);
+	writel(pv, pwmd->pwm->mmio_base + pwmd->offset + PWMPCR);
+	spin_unlock(&pwmd->lock);
+	clk_disable(pwmd->pwm->clk);
+	spin_unlock(&pwmd->pwm->lock);
+
+	return 0;
+err:
+	dev_err(&pwmd->pwm->pdev->dev, "pwm config fail\n");
+	return ret;
+}
+EXPORT_SYMBOL(pwm_config);
+
+int pwm_enable(struct pwm_device *pwmd)
+{
+	int ret = 0;
+	u32 val = 0;
+
+	if (!pwmd) {
+		pr_err("pwm: enable - NULL pwm device pointer\n");
+		return -EFAULT;
+	}
+
+	spin_lock(&pwmd->pwm->lock);
+	ret = clk_enable(pwmd->pwm->clk);
+	if (!ret)
+		pwmd->pwm->clk_enabled++;
+	else {
+		spin_unlock(&pwmd->pwm->lock);
+		goto err;
+	}
+
+	if (cpu_is_spear1340()) {
+		if (!pwmd->pwm->pwmd_enabled)
+			writel(1, pwmd->pwm->mmio_base + SPEAR13XX_PWMMCR);
+		pwmd->pwm->pwmd_enabled++;
+	}
+
+	spin_lock(&pwmd->lock);
+	val = readl(pwmd->pwm->mmio_base + pwmd->offset + PWMCR);
+	writel(val | PWM_EN_MASK, pwmd->pwm->mmio_base + pwmd->offset + PWMCR);
+	spin_unlock(&pwmd->lock);
+	spin_unlock(&pwmd->pwm->lock);
+	return 0;
+err:
+	dev_err(&pwmd->pwm->pdev->dev, "pwm enable fail\n");
+	return ret;
+}
+EXPORT_SYMBOL(pwm_enable);
+
+void pwm_disable(struct pwm_device *pwmd)
+{
+	if (!pwmd) {
+		pr_err("pwm: disable - NULL pwm device pointer\n");
+		return;
+	}
+
+	spin_lock(&pwmd->pwm->lock);
+	spin_lock(&pwmd->lock);
+	writel(0, pwmd->pwm->mmio_base + pwmd->offset + PWMCR);
+	spin_unlock(&pwmd->lock);
+
+	if (cpu_is_spear1340()) {
+		pwmd->pwm->pwmd_enabled--;
+		if (!pwmd->pwm->pwmd_enabled)
+			writel(0, pwmd->pwm->mmio_base + SPEAR13XX_PWMMCR);
+	}
+
+	if (pwmd->pwm->clk_enabled) {
+		clk_disable(pwmd->pwm->clk);
+		pwmd->pwm->clk_enabled--;
+	}
+	spin_unlock(&pwmd->pwm->lock);
+}
+EXPORT_SYMBOL(pwm_disable);
+
+struct pwm_device *pwm_request(int pwmd_id, const char *label)
+{
+	int found = 0;
+	struct pwm *pwm;
+	struct pwm_device *pwmd = NULL;
+
+	spin_lock(&list_lock);
+	list_for_each_entry(pwm, &pwm_list, node) {
+		spin_lock(&pwm->lock);
+		list_for_each_entry(pwmd, &pwm->devices, node) {
+			if (pwmd->pwmd_id == pwmd_id) {
+				found = 1;
+				break;
+			}
+		}
+		spin_unlock(&pwm->lock);
+		if (found)
+			break;
+	}
+	spin_unlock(&list_lock);
+
+	if (found) {
+		spin_lock(&pwmd->lock);
+		if (pwmd->busy == 0) {
+			pwmd->busy++;
+			pwmd->label = label;
+		} else
+			pwmd = ERR_PTR(-EBUSY);
+		spin_unlock(&pwmd->lock);
+	} else
+		pwmd = ERR_PTR(-ENOENT);
+
+	if (IS_ERR(pwmd))
+		pr_err("pwm: request fail\n");
+
+	return pwmd;
+}
+EXPORT_SYMBOL(pwm_request);
+
+void pwm_free(struct pwm_device *pwmd)
+{
+	if (!pwmd) {
+		pr_err("pwm: disable - NULL pwm device pointer\n");
+		return;
+	}
+
+	spin_lock(&pwmd->lock);
+	if (pwmd->busy) {
+		pwmd->busy--;
+		pwmd->label = NULL;
+	} else {
+		spin_unlock(&pwmd->lock);
+		dev_warn(&pwmd->pwm->pdev->dev, "pwm device already freed\n");
+		return;
+	}
+
+	spin_unlock(&pwmd->lock);
+}
+EXPORT_SYMBOL(pwm_free);
+
+/* creates and add pwmd device to parent pwm's devices list */
+static int add_pwm_device(unsigned int pwmd_id, struct pwm *pwm)
+{
+	struct pwm_device *pwmd;
+
+	pwmd = kzalloc(sizeof(*pwmd), GFP_KERNEL);
+	if (!pwmd)
+		return -ENOMEM;
+
+	pwmd->pwm = pwm;
+	pwmd->busy = 0;
+	pwmd->pwmd_id = pwmd_id + pwm->id * PWM_DEVICE_PER_IP;
+	pwmd->offset = pwmd_id * PWM_DEVICE_OFFSET;
+	spin_lock_init(&pwmd->lock);
+
+	spin_lock(&pwm->lock);
+	list_add_tail(&pwmd->node, &pwm->devices);
+	spin_unlock(&pwm->lock);
+
+	return 0;
+}
+
+/* removes all pwmd devices from parent pwm's devices list */
+static void remove_pwm_devices(struct pwm *pwm)
+{
+	struct pwm_device *pwmd;
+
+	spin_lock(&pwm->lock);
+	list_for_each_entry(pwmd, &pwm->devices, node) {
+		list_del(&pwmd->node);
+		kfree(pwmd);
+	}
+	spin_unlock(&pwm->lock);
+}
+
+static int __devinit spear_pwm_probe(struct platform_device *pdev)
+{
+	struct pwm *pwm = NULL;
+	struct resource *res;
+	int ret = 0, pwmd_id = 0;
+
+	pwm = kzalloc(sizeof(*pwm), GFP_KERNEL);
+	if (!pwm) {
+		ret = -ENOMEM;
+		dev_dbg(&pdev->dev, "failed to allocate memory\n");
+		goto err;
+	}
+
+	pwm->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pwm->clk)) {
+		ret = PTR_ERR(pwm->clk);
+		dev_dbg(&pdev->dev, "Error getting clock\n");
+		goto err_free;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "no memory resource defined\n");
+		goto err_free_clk;
+	}
+
+	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
+		ret = -EBUSY;
+		dev_dbg(&pdev->dev, "failed to request memory resource\n");
+		goto err_free_clk;
+	}
+
+	pwm->mmio_base = ioremap(res->start, resource_size(res));
+	if (!pwm->mmio_base) {
+		ret = -ENOMEM;
+		dev_dbg(&pdev->dev, "failed to ioremap\n");
+		goto err_free_mem;
+	}
+
+	/* initialize pwm structure */
+	pwm->clk_enabled = 0;
+	pwm->pdev = pdev;
+	/* if pdev->id is -1, only one pwm ip is present */
+	if (pdev->id == -1)
+		pwm->id = 0;
+	else
+		pwm->id = pdev->id;
+
+	spin_lock_init(&pwm->lock);
+	INIT_LIST_HEAD(&pwm->devices);
+	platform_set_drvdata(pdev, pwm);
+
+	/* add pwm to pwm list */
+	spin_lock(&list_lock);
+	list_add_tail(&pwm->node, &pwm_list);
+	spin_unlock(&list_lock);
+
+	/* add pwm devices */
+	for (pwmd_id = 0; pwmd_id < PWM_DEVICE_PER_IP; pwmd_id++) {
+		ret = add_pwm_device(pwmd_id, pwm);
+		if (!ret)
+			continue;
+		dev_err(&pdev->dev, "Add device fail for pwm device id: %d\n",
+				pwmd_id);
+	}
+
+	if (list_empty(&pwm->node))
+		goto err_remove_pwm;
+
+	dev_info(&pdev->dev, "Initialization successful\n");
+	return 0;
+
+err_remove_pwm:
+	spin_lock(&list_lock);
+	list_del(&pwm->node);
+	spin_unlock(&list_lock);
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(pwm->mmio_base);
+err_free_mem:
+	release_mem_region(res->start, resource_size(res));
+err_free_clk:
+	clk_put(pwm->clk);
+err_free:
+	kfree(pwm);
+err:
+	dev_err(&pdev->dev, "Initialization Fail. Error: %d\n", ret);
+
+	return ret;
+}
+
+static int __devexit spear_pwm_remove(struct platform_device *pdev)
+{
+	struct pwm *pwm;
+	struct resource *res;
+	int ret = 0;
+
+	pwm = platform_get_drvdata(pdev);
+	if (pwm == NULL) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "Remove: get_drvdata fail\n");
+		goto err;
+	}
+	platform_set_drvdata(pdev, NULL);
+
+	/* remove pwm devices */
+	remove_pwm_devices(pwm);
+
+	/* remove pwm from pwm_list */
+	spin_lock(&list_lock);
+	list_del(&pwm->node);
+	spin_unlock(&list_lock);
+
+	iounmap(pwm->mmio_base);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENODEV;
+		dev_dbg(&pdev->dev, "Remove: get_resource fail\n");
+		goto err;
+	}
+	release_mem_region(res->start, resource_size(res));
+
+	if (pwm->clk_enabled)
+		clk_disable(pwm->clk);
+	clk_put(pwm->clk);
+
+	kfree(pwm);
+	return 0;
+
+err:
+	dev_err(&pdev->dev, "Remove: Fail - %d\n", ret);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int pwm_suspend(struct device *dev, bool csave)
+{
+	struct pwm *pwm = dev_get_drvdata(dev);
+	struct pwm_device *pwmd;
+
+	if (cpu_is_spear1340()) {
+		if (pwm->pwmd_enabled)
+			writel(0, pwm->mmio_base + SPEAR13XX_PWMMCR);
+	}
+
+	if (!csave)
+		goto sus_clk_dis;
+
+	list_for_each_entry(pwmd, &pwm->devices, node) {
+		if (pwmd->busy) {
+			pwmd->csave_reg_PWMCR =
+				readl(pwm->mmio_base + pwmd->offset + PWMCR);
+			pwmd->csave_reg_PWMDCR =
+				readl(pwm->mmio_base + pwmd->offset + PWMDCR);
+			pwmd->csave_reg_PWMPCR =
+				readl(pwm->mmio_base + pwmd->offset + PWMPCR);
+		}
+	}
+
+sus_clk_dis:
+	/* disable clock */
+	if (pwm->clk_enabled)
+		clk_disable(pwm->clk);
+
+	return 0;
+}
+
+static int spear_pwm_suspend(struct device *dev)
+{
+	return pwm_suspend(dev, true);
+}
+
+static int spear_pwm_poweroff(struct device *dev)
+{
+	return pwm_suspend(dev, false);
+}
+
+static int pwm_resume(struct device *dev, bool csave)
+{
+	struct pwm *pwm = dev_get_drvdata(dev);
+	struct pwm_device *pwmd;
+	int ret = 0;
+
+	if (pwm->clk_enabled) {
+		ret = clk_enable(pwm->clk);
+		if (ret) {
+			dev_err(dev, "clk enable failed%d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!csave)
+		goto res_pwm_enable;
+
+	list_for_each_entry(pwmd, &pwm->devices, node) {
+		if (pwmd->busy) {
+			writel(pwmd->csave_reg_PWMDCR,
+					pwm->mmio_base + pwmd->offset + PWMDCR);
+			writel(pwmd->csave_reg_PWMPCR,
+					pwm->mmio_base + pwmd->offset + PWMPCR);
+			writel(pwmd->csave_reg_PWMCR,
+					pwm->mmio_base + pwmd->offset + PWMCR);
+		}
+	}
+
+res_pwm_enable:
+	if (cpu_is_spear1340()) {
+		if (pwm->pwmd_enabled)
+			writel(1, pwm->mmio_base + SPEAR13XX_PWMMCR);
+	}
+
+	return ret;
+}
+
+static int spear_pwm_resume(struct device *dev)
+{
+	return pwm_resume(dev, true);
+}
+
+static int spear_pwm_thaw(struct device *dev)
+{
+	return pwm_resume(dev, false);
+}
+
+static const struct dev_pm_ops spear_pwm_dev_pm_ops = {
+	.suspend = spear_pwm_suspend,
+	.resume = spear_pwm_resume,
+	.freeze = spear_pwm_suspend,
+	.thaw = spear_pwm_thaw,
+	.poweroff = spear_pwm_poweroff,
+	.restore = spear_pwm_resume,
+};
+
+#define SPEAR_PWM_DEV_PM_OPS (&spear_pwm_dev_pm_ops)
+#else
+#define SPEAR_PWM_DEV_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver spear_pwm_driver = {
+	.driver = {
+		.name = "pwm",
+		.bus = &platform_bus_type,
+		.owner = THIS_MODULE,
+		.pm = SPEAR_PWM_DEV_PM_OPS,
+	},
+	.probe = spear_pwm_probe,
+	.remove = __devexit_p(spear_pwm_remove)
+};
+
+static int __init spear_pwm_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&spear_pwm_driver);
+	if (ret)
+		pr_err("failed to register spear_pwm_driver\n");
+
+	return ret;
+}
+module_init(spear_pwm_init);
+
+static void __exit spear_pwm_exit(void)
+{
+	platform_driver_unregister(&spear_pwm_driver);
+}
+module_exit(spear_pwm_exit);
+
+MODULE_AUTHOR("Viresh Kumar");
+MODULE_DESCRIPTION("SPEAr PWM Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-spear13xx/restart.c b/arch/arm/plat-spear13xx/restart.c
new file mode 100644
index 0000000..7f75a27
--- /dev/null
+++ b/arch/arm/plat-spear13xx/restart.c
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/plat-spear/restart.c
+ *
+ * SPEAr platform specific restart functions
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/io.h>
+#ifndef CONFIG_ARCH_SPEAR13XX
+#include <asm/hardware/sp810.h>
+#else
+#include <mach/misc_regs.h>
+#endif
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <asm/system_misc.h>
+
+void spear_restart(char mode, const char *cmd)
+{
+	if (mode == 's') {
+		/* software reset, Jump into ROM at address 0 */
+		soft_restart(0);
+	} else {
+#ifndef CONFIG_ARCH_SPEAR13XX
+		/* hardware reset, Use on-chip reset capability */
+		sysctl_soft_reset((void __iomem *)VA_SPEAR_SYS_CTRL_BASE);
+#else
+		if (cpu_is_spear1340()) {
+	#ifdef CONFIG_CPU_SPEAR1340
+			writel_relaxed(0x01, VA_SPEAR1340_SYS_SW_RES);
+	#endif
+		} else if (cpu_is_spear1310()) {
+	#ifdef CONFIG_CPU_SPEAR1310
+			writel_relaxed(0x01, VA_SPEAR1310_SYS_SW_RES);
+	#endif
+		} else
+			writel_relaxed(0x01, VA_SYS_SW_RES);
+#endif
+	}
+}
diff --git a/arch/arm/plat-spear13xx/shirq.c b/arch/arm/plat-spear13xx/shirq.c
new file mode 100644
index 0000000..961fb72
--- /dev/null
+++ b/arch/arm/plat-spear13xx/shirq.c
@@ -0,0 +1,118 @@
+/*
+ * arch/arm/plat-spear/shirq.c
+ *
+ * SPEAr platform shared irq layer source file
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Viresh Kumar<viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/spinlock.h>
+#include <plat/shirq.h>
+
+struct spear_shirq *shirq;
+static DEFINE_SPINLOCK(lock);
+
+static void shirq_irq_mask(struct irq_data *d)
+{
+	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
+	u32 val, id = d->irq - shirq->dev_config[0].virq;
+	unsigned long flags;
+
+	if ((shirq->regs.enb_reg == -1) || shirq->dev_config[id].enb_mask == -1)
+		return;
+
+	spin_lock_irqsave(&lock, flags);
+	val = readl(shirq->regs.base + shirq->regs.enb_reg);
+	if (shirq->regs.reset_to_enb)
+		val |= shirq->dev_config[id].enb_mask;
+	else
+		val &= ~(shirq->dev_config[id].enb_mask);
+	writel(val, shirq->regs.base + shirq->regs.enb_reg);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static void shirq_irq_unmask(struct irq_data *d)
+{
+	struct spear_shirq *shirq = irq_data_get_irq_chip_data(d);
+	u32 val, id = d->irq - shirq->dev_config[0].virq;
+	unsigned long flags;
+
+	if ((shirq->regs.enb_reg == -1) || shirq->dev_config[id].enb_mask == -1)
+		return;
+
+	spin_lock_irqsave(&lock, flags);
+	val = readl(shirq->regs.base + shirq->regs.enb_reg);
+	if (shirq->regs.reset_to_enb)
+		val &= ~(shirq->dev_config[id].enb_mask);
+	else
+		val |= shirq->dev_config[id].enb_mask;
+	writel(val, shirq->regs.base + shirq->regs.enb_reg);
+	spin_unlock_irqrestore(&lock, flags);
+}
+
+static struct irq_chip shirq_chip = {
+	.name		= "spear_shirq",
+	.irq_ack	= shirq_irq_mask,
+	.irq_mask	= shirq_irq_mask,
+	.irq_unmask	= shirq_irq_unmask,
+};
+
+static void shirq_handler(unsigned irq, struct irq_desc *desc)
+{
+	u32 i, val, mask;
+	struct spear_shirq *shirq = irq_get_handler_data(irq);
+
+	desc->irq_data.chip->irq_ack(&desc->irq_data);
+	while ((val = readl(shirq->regs.base + shirq->regs.status_reg) &
+				shirq->regs.status_reg_mask)) {
+		for (i = 0; (i < shirq->dev_count) && val; i++) {
+			if (!(shirq->dev_config[i].status_mask & val))
+				continue;
+
+			generic_handle_irq(shirq->dev_config[i].virq);
+
+			/* clear interrupt */
+			val &= ~shirq->dev_config[i].status_mask;
+			if ((shirq->regs.clear_reg == -1) ||
+					shirq->dev_config[i].clear_mask == -1)
+				continue;
+			mask = readl(shirq->regs.base + shirq->regs.clear_reg);
+			if (shirq->regs.reset_to_clear)
+				mask &= ~shirq->dev_config[i].clear_mask;
+			else
+				mask |= shirq->dev_config[i].clear_mask;
+			writel(mask, shirq->regs.base + shirq->regs.clear_reg);
+		}
+	}
+	desc->irq_data.chip->irq_unmask(&desc->irq_data);
+}
+
+int spear_shirq_register(struct spear_shirq *shirq)
+{
+	int i;
+
+	if (!shirq || !shirq->dev_config || !shirq->regs.base)
+		return -EFAULT;
+
+	if (!shirq->dev_count)
+		return -EINVAL;
+
+	irq_set_chained_handler(shirq->irq, shirq_handler);
+	for (i = 0; i < shirq->dev_count; i++) {
+		irq_set_chip_and_handler(shirq->dev_config[i].virq,
+					 &shirq_chip, handle_simple_irq);
+		set_irq_flags(shirq->dev_config[i].virq, IRQF_VALID);
+		irq_set_chip_data(shirq->dev_config[i].virq, shirq);
+	}
+
+	irq_set_handler_data(shirq->irq, shirq);
+	return 0;
+}
diff --git a/arch/arm/plat-spear13xx/smi.c b/arch/arm/plat-spear13xx/smi.c
new file mode 100644
index 0000000..253a417
--- /dev/null
+++ b/arch/arm/plat-spear13xx/smi.c
@@ -0,0 +1,63 @@
+/*
+ * arch/arm/plat-spear/smi.c
+ *
+ * spear smi platform intialization
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/mtd/spear_smi.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+/*
+ * physical base address of flash/bank mem map base associated with smi
+ * depends on SoC
+ */
+
+#if defined(CONFIG_ARCH_SPEAR13XX)
+#define FLASH_MEM_BASE	SPEAR13XX_SMI_MEM0_BASE
+
+#elif defined(CONFIG_ARCH_SPEAR3XX)
+#define FLASH_MEM_BASE	SPEAR3XX_ICM3_SMEM_BASE
+
+#elif defined(CONFIG_ARCH_SPEAR6XX)
+#define FLASH_MEM_BASE	SPEAR6XX_ICM3_SMEM_BASE
+
+#endif
+
+/* serial nor flash specific board data */
+static struct mtd_partition m25p64_partition_info[] = {
+	DEFINE_PARTS("Xloader", 0x00, 0x10000),
+	DEFINE_PARTS("UBoot", 0x10000, 0x40000),
+	DEFINE_PARTS("Kernel", 0x50000, 0x2C0000),
+	DEFINE_PARTS("Root File System", 0x310000, 0x4F0000),
+};
+
+static struct spear_smi_flash_info nor_flash_info[] = {
+	{
+		.name = "m25p64",
+		.mem_base = FLASH_MEM_BASE,
+		.size = 8 * 1024 * 1024,
+		.partitions = m25p64_partition_info,
+		.nr_partitions = ARRAY_SIZE(m25p64_partition_info),
+		.fast_mode = 1,
+	},
+};
+
+/* smi specific board data */
+static struct spear_smi_plat_data smi_plat_data = {
+	.clk_rate = 50000000,	/* 50MHz */
+	.num_flashes = ARRAY_SIZE(nor_flash_info),
+	.board_flash_info = nor_flash_info,
+};
+
+void smi_init_board_info(struct platform_device *pdev)
+{
+	pdev->dev.platform_data = &smi_plat_data;
+}
diff --git a/arch/arm/plat-spear13xx/time.c b/arch/arm/plat-spear13xx/time.c
new file mode 100644
index 0000000..eee6e86
--- /dev/null
+++ b/arch/arm/plat-spear13xx/time.c
@@ -0,0 +1,263 @@
+/*
+ * arch/arm/plat-spear/time.c
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim<shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/time.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+/*
+ * We would use TIMER0 and TIMER1 as clockevent and clocksource.
+ * Timer0 and Timer1 both belong to same gpt block in cpu subbsystem. Further
+ * they share same functional clock. Any change in one's functional clock will
+ * also affect other timer.
+ */
+
+#define CLKEVT	0	/* gpt0, channel0 as clockevent */
+#define CLKSRC	1	/* gpt0, channel1 as clocksource */
+
+/* Register offsets, x is channel number */
+#define CR(x)		((x) * 0x80 + 0x80)
+#define IR(x)		((x) * 0x80 + 0x84)
+#define LOAD(x)		((x) * 0x80 + 0x88)
+#define COUNT(x)	((x) * 0x80 + 0x8C)
+
+/* Reg bit definitions */
+#define CTRL_INT_ENABLE		0x0100
+#define CTRL_ENABLE		0x0020
+#define CTRL_ONE_SHOT		0x0010
+
+#define CTRL_PRESCALER1		0x0
+#define CTRL_PRESCALER2		0x1
+#define CTRL_PRESCALER4		0x2
+#define CTRL_PRESCALER8		0x3
+#define CTRL_PRESCALER16	0x4
+#define CTRL_PRESCALER32	0x5
+#define CTRL_PRESCALER64	0x6
+#define CTRL_PRESCALER128	0x7
+#define CTRL_PRESCALER256	0x8
+
+#define INT_STATUS		0x1
+
+/*
+ * Minimum clocksource/clockevent timer range in seconds
+ */
+#define SPEAR_MIN_RANGE 4
+
+static __iomem void *gpt_base;
+static struct clk *gpt_clk;
+
+static void clockevent_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *clk_event_dev);
+static int clockevent_next_event(unsigned long evt,
+				 struct clock_event_device *clk_event_dev);
+
+#ifdef CONFIG_PM
+static u16 gpt_ctrl_reg;
+
+void spear_clocksource_suspend(void)
+{
+	/* latch the control register */
+	gpt_ctrl_reg = readw(gpt_base + CR(CLKSRC));
+	gpt_ctrl_reg &= ~CTRL_ENABLE ;
+	/* Stop the timer */
+	writew(gpt_ctrl_reg, gpt_base + CR(CLKSRC));
+}
+
+void spear_clocksource_resume(void)
+{
+	writew(0xffff, gpt_base + LOAD(CLKSRC));
+	gpt_ctrl_reg |= CTRL_ENABLE;
+	/* Restore the control register and start the timer */
+	writew(gpt_ctrl_reg, gpt_base + CR(CLKSRC));
+
+}
+#endif
+
+static void spear_clocksource_init(void)
+{
+	u32 tick_rate;
+	u16 val;
+
+	/* program the prescaler (/256)*/
+	writew(CTRL_PRESCALER256, gpt_base + CR(CLKSRC));
+
+	/* find out actual clock driving Timer */
+	tick_rate = clk_get_rate(gpt_clk);
+	tick_rate >>= CTRL_PRESCALER256;
+
+	writew(0xFFFF, gpt_base + LOAD(CLKSRC));
+
+	val = readw(gpt_base + CR(CLKSRC));
+	val &= ~CTRL_ONE_SHOT;	/* autoreload mode */
+	val |= CTRL_ENABLE ;
+	writew(val, gpt_base + CR(CLKSRC));
+
+	/* register the clocksource */
+	clocksource_mmio_init(gpt_base + COUNT(CLKSRC), "tmr1", tick_rate,
+		200, 16, clocksource_mmio_readw_up);
+}
+
+static struct clock_event_device clkevt = {
+	.name = "tmr0",
+	.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = clockevent_set_mode,
+	.set_next_event = clockevent_next_event,
+	.shift = 0,	/* to be computed */
+};
+
+static void clockevent_set_mode(enum clock_event_mode mode,
+				struct clock_event_device *clk_event_dev)
+{
+	u32 period;
+	u16 val;
+
+	/* stop the timer */
+	val = readw(gpt_base + CR(CLKEVT));
+	val &= ~CTRL_ENABLE;
+	writew(val, gpt_base + CR(CLKEVT));
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		period = clk_get_rate(gpt_clk) / HZ;
+		period >>= CTRL_PRESCALER16;
+		writew(period, gpt_base + LOAD(CLKEVT));
+
+		val = readw(gpt_base + CR(CLKEVT));
+		val &= ~CTRL_ONE_SHOT;
+		val |= CTRL_ENABLE | CTRL_INT_ENABLE;
+		writew(val, gpt_base + CR(CLKEVT));
+
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		val = readw(gpt_base + CR(CLKEVT));
+		val |= CTRL_ONE_SHOT;
+		writew(val, gpt_base + CR(CLKEVT));
+
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		val |= CTRL_PRESCALER16;
+		writew(val, gpt_base + CR(CLKEVT));
+		break;
+	default:
+		pr_err("Invalid mode requested\n");
+		break;
+	}
+}
+
+static int clockevent_next_event(unsigned long cycles,
+				 struct clock_event_device *clk_event_dev)
+{
+	u16 val = readw(gpt_base + CR(CLKEVT));
+
+	if (val & CTRL_ENABLE)
+		writew(val & ~CTRL_ENABLE, gpt_base + CR(CLKEVT));
+
+	writew(cycles, gpt_base + LOAD(CLKEVT));
+
+	val |= CTRL_ENABLE | CTRL_INT_ENABLE;
+	writew(val, gpt_base + CR(CLKEVT));
+
+	return 0;
+}
+
+static irqreturn_t spear_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &clkevt;
+
+	writew(INT_STATUS, gpt_base + IR(CLKEVT));
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction spear_timer_irq = {
+	.name = "timer",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = spear_timer_interrupt
+};
+
+static void __init spear_clockevent_init(void)
+{
+	u32 tick_rate;
+
+	/* program the prescaler */
+	writew(CTRL_PRESCALER16, gpt_base + CR(CLKEVT));
+
+	tick_rate = clk_get_rate(gpt_clk);
+	tick_rate >>= CTRL_PRESCALER16;
+
+	clockevents_calc_mult_shift(&clkevt, tick_rate, SPEAR_MIN_RANGE);
+
+	clkevt.max_delta_ns = clockevent_delta2ns(0xfff0,
+			&clkevt);
+	clkevt.min_delta_ns = clockevent_delta2ns(3, &clkevt);
+
+	clkevt.cpumask = cpumask_of(0);
+
+	clockevents_register_device(&clkevt);
+
+	setup_irq(SPEAR_GPT0_CHAN0_IRQ, &spear_timer_irq);
+}
+
+void __init spear_setup_timer(void)
+{
+	int ret;
+
+	if (!request_mem_region(SPEAR_GPT0_BASE, SZ_1K, "gpt0")) {
+		pr_err("%s:cannot get IO addr\n", __func__);
+		return;
+	}
+
+	gpt_base = (void __iomem *)ioremap(SPEAR_GPT0_BASE, SZ_1K);
+	if (!gpt_base) {
+		pr_err("%s:ioremap failed for gpt\n", __func__);
+		goto err_mem;
+	}
+
+	gpt_clk = clk_get_sys("gpt0", NULL);
+	if (!gpt_clk) {
+		pr_err("%s:couldn't get clk for gpt\n", __func__);
+		goto err_iomap;
+	}
+
+	ret = clk_enable(gpt_clk);
+	if (ret < 0) {
+		pr_err("%s:couldn't enable gpt clock\n", __func__);
+		goto err_clk;
+	}
+
+	spear_clockevent_init();
+	spear_clocksource_init();
+
+	return;
+
+err_clk:
+	clk_put(gpt_clk);
+err_iomap:
+	iounmap(gpt_base);
+err_mem:
+	release_mem_region(SPEAR_GPT0_BASE, SZ_1K);
+}
diff --git a/arch/arm/plat-spear13xx/udc.c b/arch/arm/plat-spear13xx/udc.c
new file mode 100644
index 0000000..2d3131b
--- /dev/null
+++ b/arch/arm/plat-spear13xx/udc.c
@@ -0,0 +1,59 @@
+/*
+ * arch/arm/plat-spear/udc.c
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar<rajeev-dlh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/usb/ch9.h>
+#include <plat/udc.h>
+
+#define EP(idx, nam, size, maxpkt, address)	\
+	[idx] = {				\
+		.name		= nam,		\
+		.fifo_size	= size,		\
+		.maxpacket	= maxpkt,	\
+		.addr		= address,	\
+	}
+
+static struct udc_ep_data udc_ep[] __initdata = {
+	EP(0, "ep0-ctrl", 64/4 , 64 , 0),
+	EP(1, "ep1in"   , 512/4, 512, USB_DIR_IN  | 1),
+	EP(2, "ep2out"  , 512/4, 512, USB_DIR_OUT | 2),
+	EP(3, "ep3in"   , 512/4, 512, USB_DIR_IN  | 3),
+	EP(4, "ep4out"  , 512/4, 512, USB_DIR_OUT | 4),
+	EP(5, "ep5in"   , 512/4, 512, USB_DIR_IN  | 5),
+	EP(6, "ep6out"  , 512/4, 512, USB_DIR_OUT | 6),
+	EP(7, "ep7in"   , 512/4, 512, USB_DIR_IN  | 7),
+	EP(8, "ep8out"  , 512/4, 512, USB_DIR_OUT | 8),
+	EP(9, "ep9in"   , 512/4, 512, USB_DIR_IN  | 9),
+	EP(10, "ep10out"   , 512/4, 512, USB_DIR_OUT | 10),
+	EP(11, "ep11in"   , 512/4, 512, USB_DIR_IN  | 11),
+	EP(12, "ep12out"   , 512/4, 512, USB_DIR_OUT | 12),
+	EP(13, "ep13in"   , 512/4, 512, USB_DIR_IN  | 13),
+	EP(14, "ep14out"   , 512/4, 512, USB_DIR_OUT | 14),
+	EP(15, "ep15in"   , 512/4, 512, USB_DIR_IN  | 15),
+};
+
+struct udc_plat_data {
+	int num_ep;
+	struct udc_ep_data ep[UDC_MAX_ENDPOINT];
+};
+
+static __initdata struct udc_plat_data pdata;
+
+void __init set_udc_plat_data(struct platform_device *pdev)
+{
+	pdata.num_ep = 16;
+	memcpy(pdata.ep, udc_ep, sizeof(udc_ep));;
+
+	if (platform_device_add_data(pdev, (struct udc_platform_data *)&pdata,
+				sizeof(pdata)))
+		pr_err("usb device: Error setting plat data");
+}
-- 
1.7.9.7

