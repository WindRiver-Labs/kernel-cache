From 662eb4a72d2e06bb3c1e6bc5eb19468acfcf00a4 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Tue, 22 May 2012 18:08:57 +0800
Subject: [PATCH 02/28] SPEAr: add mach-spear13xx to arch/arm/

Copy arch/arm/mach-spear13xx directory directly from st git tree based on
following commit:

git://git.stlinux.com/spear/linux-2.6.git next-3.3
commit a642f8da Input: stmpe-ts: Add runtime power management support

Note: this also corresponds to the commits 151c5a0b..966ae210
      on arch/arm/mach-spear13xx/ at st git tree.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/mach-spear13xx/Kconfig                    |  115 +
 arch/arm/mach-spear13xx/Makefile                   |   51 +
 arch/arm/mach-spear13xx/Makefile.boot              |    3 +
 arch/arm/mach-spear13xx/clock.c                    | 1710 +++++++++++++
 arch/arm/mach-spear13xx/db9000_lcd.c               |  170 ++
 arch/arm/mach-spear13xx/dw_pcie.c                  |  814 ++++++
 arch/arm/mach-spear13xx/fsmc-nor.c                 |   75 +
 arch/arm/mach-spear13xx/headsmp.S                  |   45 +
 arch/arm/mach-spear13xx/hotplug.c                  |  121 +
 arch/arm/mach-spear13xx/include/mach/bitfield.h    |  113 +
 arch/arm/mach-spear13xx/include/mach/debug-macro.S |   14 +
 arch/arm/mach-spear13xx/include/mach/dma.h         |  148 ++
 arch/arm/mach-spear13xx/include/mach/dw_pcie.h     |  122 +
 arch/arm/mach-spear13xx/include/mach/entry-macro.S |   16 +
 arch/arm/mach-spear13xx/include/mach/generic.h     |  663 +++++
 arch/arm/mach-spear13xx/include/mach/gpio.h        |  324 +++
 arch/arm/mach-spear13xx/include/mach/hardware.h    |   40 +
 arch/arm/mach-spear13xx/include/mach/io.h          |   19 +
 arch/arm/mach-spear13xx/include/mach/irqs.h        |  287 +++
 arch/arm/mach-spear13xx/include/mach/misc_regs.h   |  461 ++++
 arch/arm/mach-spear13xx/include/mach/spdif.h       |   29 +
 arch/arm/mach-spear13xx/include/mach/spear.h       |  119 +
 arch/arm/mach-spear13xx/include/mach/spear1300.h   |   21 +
 arch/arm/mach-spear13xx/include/mach/spear1310.h   |  201 ++
 .../include/mach/spear1310_misc_regs.h             |  545 ++++
 .../mach-spear13xx/include/mach/spear1310_reva.h   |   78 +
 arch/arm/mach-spear13xx/include/mach/spear1340.h   |   59 +
 .../include/mach/spear1340_misc_regs.h             |  563 +++++
 arch/arm/mach-spear13xx/include/mach/spear900.h    |   21 +
 arch/arm/mach-spear13xx/include/mach/spear_pcie.h  |  160 ++
 .../include/mach/spear_pcie_rev_341.h              |   21 +
 .../include/mach/spear_pcie_rev_370.h              |   21 +
 arch/arm/mach-spear13xx/include/mach/suspend.h     |  106 +
 arch/arm/mach-spear13xx/include/mach/system.h      |   85 +
 arch/arm/mach-spear13xx/include/mach/timex.h       |   19 +
 arch/arm/mach-spear13xx/include/mach/uncompress.h  |   19 +
 arch/arm/mach-spear13xx/localtimer.c               |   26 +
 arch/arm/mach-spear13xx/platsmp.c                  |  130 +
 arch/arm/mach-spear13xx/pm.c                       |  295 +++
 arch/arm/mach-spear13xx/r1801e.c                   |  314 +++
 arch/arm/mach-spear13xx/sleep_1340.S               |  565 +++++
 arch/arm/mach-spear13xx/sleep_13xx.S               |  481 ++++
 arch/arm/mach-spear13xx/spear1300.c                |   37 +
 arch/arm/mach-spear13xx/spear1300_evb.c            |  386 +++
 arch/arm/mach-spear13xx/spear1310.c                | 1441 +++++++++++
 arch/arm/mach-spear13xx/spear1310_clock.c          | 1899 ++++++++++++++
 arch/arm/mach-spear13xx/spear1310_evb.c            |  367 +++
 arch/arm/mach-spear13xx/spear1310_reva.c           |  982 +++++++
 arch/arm/mach-spear13xx/spear1310_reva_evb.c       |  613 +++++
 arch/arm/mach-spear13xx/spear1340.c                | 2671 ++++++++++++++++++++
 arch/arm/mach-spear13xx/spear1340_clock.c          | 1786 +++++++++++++
 arch/arm/mach-spear13xx/spear1340_evb.c            |  706 ++++++
 arch/arm/mach-spear13xx/spear1340_lcad.c           |  474 ++++
 arch/arm/mach-spear13xx/spear1340_plug_boards.c    |  435 ++++
 arch/arm/mach-spear13xx/spear13xx.c                | 2329 +++++++++++++++++
 arch/arm/mach-spear13xx/spear900.c                 |   37 +
 arch/arm/mach-spear13xx/spear900_evb.c             |  409 +++
 arch/arm/mach-spear13xx/spear_hurricane_board.c    |  445 ++++
 arch/arm/mach-spear13xx/spear_pcie_rev_341.c       |  581 +++++
 arch/arm/mach-spear13xx/spear_pcie_rev_370.c       |  588 +++++
 arch/arm/mach-spear13xx/wakeup.S                   |  152 ++
 61 files changed, 25527 insertions(+)
 create mode 100644 arch/arm/mach-spear13xx/Kconfig
 create mode 100644 arch/arm/mach-spear13xx/Makefile
 create mode 100644 arch/arm/mach-spear13xx/Makefile.boot
 create mode 100644 arch/arm/mach-spear13xx/clock.c
 create mode 100644 arch/arm/mach-spear13xx/db9000_lcd.c
 create mode 100644 arch/arm/mach-spear13xx/dw_pcie.c
 create mode 100644 arch/arm/mach-spear13xx/fsmc-nor.c
 create mode 100644 arch/arm/mach-spear13xx/headsmp.S
 create mode 100644 arch/arm/mach-spear13xx/hotplug.c
 create mode 100644 arch/arm/mach-spear13xx/include/mach/bitfield.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-spear13xx/include/mach/dma.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/dw_pcie.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-spear13xx/include/mach/generic.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/gpio.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/hardware.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/io.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/irqs.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/misc_regs.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spdif.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1300.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1310.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1310_misc_regs.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1310_reva.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1340.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear1340_misc_regs.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear900.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear_pcie.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_341.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_370.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/suspend.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/system.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/timex.h
 create mode 100644 arch/arm/mach-spear13xx/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-spear13xx/localtimer.c
 create mode 100644 arch/arm/mach-spear13xx/platsmp.c
 create mode 100644 arch/arm/mach-spear13xx/pm.c
 create mode 100644 arch/arm/mach-spear13xx/r1801e.c
 create mode 100644 arch/arm/mach-spear13xx/sleep_1340.S
 create mode 100644 arch/arm/mach-spear13xx/sleep_13xx.S
 create mode 100644 arch/arm/mach-spear13xx/spear1300.c
 create mode 100644 arch/arm/mach-spear13xx/spear1300_evb.c
 create mode 100644 arch/arm/mach-spear13xx/spear1310.c
 create mode 100644 arch/arm/mach-spear13xx/spear1310_clock.c
 create mode 100644 arch/arm/mach-spear13xx/spear1310_evb.c
 create mode 100644 arch/arm/mach-spear13xx/spear1310_reva.c
 create mode 100644 arch/arm/mach-spear13xx/spear1310_reva_evb.c
 create mode 100644 arch/arm/mach-spear13xx/spear1340.c
 create mode 100644 arch/arm/mach-spear13xx/spear1340_clock.c
 create mode 100644 arch/arm/mach-spear13xx/spear1340_evb.c
 create mode 100644 arch/arm/mach-spear13xx/spear1340_lcad.c
 create mode 100644 arch/arm/mach-spear13xx/spear1340_plug_boards.c
 create mode 100644 arch/arm/mach-spear13xx/spear13xx.c
 create mode 100644 arch/arm/mach-spear13xx/spear900.c
 create mode 100644 arch/arm/mach-spear13xx/spear900_evb.c
 create mode 100644 arch/arm/mach-spear13xx/spear_hurricane_board.c
 create mode 100644 arch/arm/mach-spear13xx/spear_pcie_rev_341.c
 create mode 100644 arch/arm/mach-spear13xx/spear_pcie_rev_370.c
 create mode 100644 arch/arm/mach-spear13xx/wakeup.S

diff --git a/arch/arm/mach-spear13xx/Kconfig b/arch/arm/mach-spear13xx/Kconfig
new file mode 100644
index 0000000..10b507f
--- /dev/null
+++ b/arch/arm/mach-spear13xx/Kconfig
@@ -0,0 +1,115 @@
+#
+# SPEAr13XX Machine configuration file
+#
+
+if ARCH_SPEAR13XX
+
+menu "SPEAr13xx Implementations"
+config MACH_SPEAR1300_EVB
+	bool "SPEAr1300 Evaluation Board"
+	select CPU_SPEAR1300
+	help
+	  Supports ST SPEAr1300 Evaluation Board
+
+config MACH_SPEAR1310_REVA_EVB
+	bool "SPEAr1310 RevA Evaluation Board"
+	select CPU_SPEAR1310_REVA
+	help
+	  Supports ST SPEAr1310 RevA Evaluation Board
+
+config MACH_R1801E
+	bool "ZT R1801E SOM board, based upon SPEAr1310 RevA Device"
+	select CPU_SPEAR1310_REVA
+	help
+	  Supports ZT's R1801E SOM board based upon ST SPEAr1310 RevA
+	  device
+
+config MACH_SPEAR1310_EVB
+	bool "SPEAr1310 Evaluation Board"
+	select CPU_SPEAR1310
+	help
+	  Supports ST SPEAr1310 Evaluation Board
+
+config MACH_SPEAR1340_EVB
+	bool "SPEAr1340 Evaluation Board"
+	select CPU_SPEAR1340
+	help
+	  Supports ST SPEAr1340 Evaluation Board
+
+config MACH_SPEAR_HURRICANE
+	bool "NComputing SPEAr Hurricane Board"
+	select CPU_SPEAR1340
+	help
+	  Supports NComputing SPEAr Hurricane Board
+
+config MACH_SPEAR1340_LCAD
+	bool "SPEAr1340 Low Cost Access Device (LCAD) Board"
+	select CPU_SPEAR1340
+	help
+	  Supports SPEAr1340 Low Cost Access Device (LCAD) Board
+
+config SPEAR1340_PLUG_BOARDS
+	bool "SPEAr1340 Plug Boards"
+	depends on MACH_SPEAR1340_EVB && SPEAR_PLUG_BOARDS
+	help
+	  Supports ST SPEAr1340 Plug boards
+
+config MACH_SPEAR900_EVB
+	bool "SPEAr900 Evaluation Board"
+	select CPU_SPEAR900
+	help
+	  Supports ST SPEAr900 Evaluation Board
+
+endmenu
+
+config CPU_SPEAR1300
+	bool "SPEAr1300"
+	help
+	  Supports ST SPEAr1300 Machine
+
+config CPU_SPEAR1310_REVA
+	bool "SPEAr1310 RevA"
+	help
+	  Supports ST SPEAr1310 RevA Machine
+
+config CPU_SPEAR1310
+	bool "SPEAr1310"
+	help
+	  Supports ST SPEAr1310 Machine
+
+config CPU_SPEAR1340
+	bool "SPEAr1340"
+	help
+	  Supports ST SPEAr1340 Machine
+
+config CPU_SPEAR900
+	bool "SPEAr900"
+	help
+	  Supports ST SPEAr900 Machine
+
+config DW_PCIE
+	bool "Synopsys Designware PCIe Host Controller"
+	depends on PCIEPORTBUS
+	help
+	  Supports Synopsys Designware PCIe Dual mode controller as a Host
+
+config SPEAR_PCIE_REV341
+	depends on DW_PCIE
+	bool "SPEAr PCIe REV 3.41"
+	help
+	  Supports ST SPEAr PCIe Rev 3.41
+
+config SPEAR_PCIE_REV370
+	depends on DW_PCIE
+	bool "SPEAr PCIe REV 3.70"
+	help
+	  Supports ST SPEAr PCIe Rev 3.70
+
+config USE_PLGPIO
+	bool "Use PLGPIOs for power control on ZT R1801E SOM board"
+	depends on MACH_R1801E
+	help
+	  Enable this to use pl-gpios on ZT's R1801E SOM board for
+	  power control device
+
+endif #ARCH_SPEAR13XX
diff --git a/arch/arm/mach-spear13xx/Makefile b/arch/arm/mach-spear13xx/Makefile
new file mode 100644
index 0000000..80c815f
--- /dev/null
+++ b/arch/arm/mach-spear13xx/Makefile
@@ -0,0 +1,51 @@
+#
+# Makefile for SPEAr13XX machine series
+#
+
+# common files
+obj-y					+= spear13xx.o fsmc-nor.o
+obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+obj-$(CONFIG_HOTPLUG_CPU)		+= hotplug.o
+obj-$(CONFIG_LOCAL_TIMERS)		+= localtimer.o
+obj-$(CONFIG_DW_PCIE)			+= dw_pcie.o
+obj-$(CONFIG_SPEAR_PCIE_REV341)		+= spear_pcie_rev_341.o
+obj-$(CONFIG_SPEAR_PCIE_REV370)		+= spear_pcie_rev_370.o
+obj-$(CONFIG_PM)			+= pm.o wakeup.o sleep_1340.o sleep_13xx.o
+obj-y					+= db9000_lcd.o
+
+# spear1300 specific files
+obj-$(CONFIG_CPU_SPEAR1300)		+= clock.o spear1300.o
+
+# spear1300 boards files
+obj-$(CONFIG_MACH_SPEAR1300_EVB)	+= spear1300_evb.o
+
+# spear1310_reva specific files
+obj-$(CONFIG_CPU_SPEAR1310_REVA)	+= clock.o spear1310_reva.o
+
+# spear1310_reva boards files
+obj-$(CONFIG_MACH_SPEAR1310_REVA_EVB)	+= spear1310_reva_evb.o
+
+# spear1310 specific files
+obj-$(CONFIG_CPU_SPEAR1310)		+= spear1310_clock.o spear1310.o
+
+# spear1310 boards files
+obj-$(CONFIG_MACH_SPEAR1310_EVB)	+= spear1310_evb.o
+obj-$(CONFIG_MACH_R1801E)		+= r1801e.o
+
+# spear1340 specific files
+obj-$(CONFIG_CPU_SPEAR1340)		+= spear1340_clock.o spear1340.o
+
+# spear1340 boards files
+obj-$(CONFIG_MACH_SPEAR1340_EVB)	+= spear1340_evb.o
+obj-$(CONFIG_SPEAR1340_PLUG_BOARDS)	+= spear1340_plug_boards.o
+
+# NComputing spear hurricane boards files
+obj-$(MACH_SPEAR_HURRICANE)		+= spear_hurricane_board.o
+
+# SPEAr1340 LCAD Board
+obj-$(CONFIG_MACH_SPEAR1340_LCAD)	+= spear1340_lcad.o
+
+# spear900 specific files
+obj-$(CONFIG_CPU_SPEAR900)		+= clock.o spear900.o
+# spear900 boards files
+obj-$(CONFIG_MACH_SPEAR900_EVB)	+= spear900_evb.o
diff --git a/arch/arm/mach-spear13xx/Makefile.boot b/arch/arm/mach-spear13xx/Makefile.boot
new file mode 100644
index 0000000..4674a4c
--- /dev/null
+++ b/arch/arm/mach-spear13xx/Makefile.boot
@@ -0,0 +1,3 @@
+zreladdr-y	+= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
diff --git a/arch/arm/mach-spear13xx/clock.c b/arch/arm/mach-spear13xx/clock.c
new file mode 100644
index 0000000..b33ed69
--- /dev/null
+++ b/arch/arm/mach-spear13xx/clock.c
@@ -0,0 +1,1710 @@
+/*
+ * arch/arm/mach-spear13xx/clock.c
+ *
+ * SPEAr13xx machines clock framework source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * shiraz hashim<shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <plat/clock.h>
+#include <mach/hardware.h>
+#include <mach/misc_regs.h>
+
+/* root clks */
+/* 24 MHz oscillator clock */
+static struct clk osc1_24m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 24000000,
+};
+
+/* 32 KHz oscillator clock */
+static struct clk osc2_32k_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 32000,
+};
+
+/* 25 MHz MIPHY oscillator clock */
+static struct clk osc3_25m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 25000000,
+};
+
+/* clock derived from 32 KHz osc clk */
+/* rtc clock */
+static struct clk rtc_clk = {
+	.pclk = &osc2_32k_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = RTC_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from osc1 or osc3 */
+/* vco[1-3] parents */
+static struct pclk_info vco_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = OSC_24M_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = OSC_25M_VAL,
+	},
+};
+
+/* vco[1-3] parent select structure */
+static struct pclk_sel vco_pclk_sel = {
+	.pclk_info = vco_pclk_info,
+	.pclk_count = ARRAY_SIZE(vco_pclk_info),
+	.pclk_sel_reg = VA_PLL_CFG,
+	.pclk_sel_mask = PLL_CLK_MASK,
+};
+
+/* vco masks structure */
+static struct vco_clk_masks vco_masks = {
+	.mode_mask = PLL_MODE_MASK,
+	.mode_shift = PLL_MODE_SHIFT,
+	.norm_fdbk_m_mask = PLL_NORM_FDBK_M_MASK,
+	.norm_fdbk_m_shift = PLL_NORM_FDBK_M_SHIFT,
+	.dith_fdbk_m_mask = PLL_DITH_FDBK_M_MASK,
+	.dith_fdbk_m_shift = PLL_DITH_FDBK_M_SHIFT,
+	.div_p_mask = PLL_DIV_P_MASK,
+	.div_p_shift = PLL_DIV_P_SHIFT,
+	.div_n_mask = PLL_DIV_N_MASK,
+	.div_n_shift = PLL_DIV_N_SHIFT,
+	.pll_lock_mask = PLL_LOCK_MASK,
+	.pll_lock_shift = PLL_LOCK_SHIFT,
+};
+/* vco1 configuration structure */
+static struct vco_clk_config vco1_config = {
+	.mode_reg = VA_PLL1_CTR,
+	.cfg_reg = VA_PLL1_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco_rtbl[] = {
+	/* PCLK 24MHz */
+	{.mode = 0, .m = 0x83, .n = 0x04, .p = 0x5}, /* vco 1572, pll 49.125 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x3}, /* vco 1000, pll 125 MHz */
+	{.mode = 0, .m = 0x64, .n = 0x06, .p = 0x1}, /* vco 800, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x1}, /* vco 1000, pll 500 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x1}, /* vco 1328, pll 664 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x1}, /* vco 1600, pll 800 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+};
+
+/* vco1 clock */
+static struct clk vco1_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = PLL1_CLK_SHIFT,
+	.en_reg = VA_PLL1_CTR,
+	.en_reg_bit = PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco1_config,
+};
+
+/* thermal clock */
+static struct clk thermal_clk = {
+	.en_reg = VA_PERIP2_CLK_ENB,
+	.en_reg_bit = THSENS_CLK_ENB,
+	.pclk = &osc1_24m_clk,
+	.div_factor = 128,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from vco1 clock */
+/* pll1 clock */
+static struct clk pll1_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco1div2 clock */
+static struct clk vco1div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco1div4 clock */
+static struct clk vco1div4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 4,
+	.recalc = &follow_parent,
+};
+
+/* vco2 configuration structure */
+static struct vco_clk_config vco2_config = {
+	.mode_reg = VA_PLL2_CTR,
+	.cfg_reg = VA_PLL2_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco2 clock */
+static struct clk vco2_clk = {
+	.flags = SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = PLL2_CLK_SHIFT,
+	.en_reg = VA_PLL2_CTR,
+	.en_reg_bit = PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco2_config,
+};
+
+/* clock derived from vco2 clock */
+/* pll2 clock */
+static struct clk pll2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco2div2 clock */
+static struct clk vco2div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco3 configuration structure */
+static struct vco_clk_config vco3_config = {
+	.mode_reg = VA_PLL3_CTR,
+	.cfg_reg = VA_PLL3_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco3 clock */
+static struct clk vco3_clk = {
+	.flags = SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = PLL3_CLK_SHIFT,
+	.en_reg = VA_PLL3_CTR,
+	.en_reg_bit = PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 0},
+	.private_data = &vco3_config,
+};
+
+/* clock derived from vco3 clock */
+/* pll3 clock */
+static struct clk pll3_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco3div2 clock */
+static struct clk vco3div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco4 (DDR) configuration structure */
+static struct vco_clk_config vco4_config = {
+	.mode_reg = VA_PLL4_CTR,
+	.cfg_reg = VA_PLL4_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco4 rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco4_rtbl[] = {
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x2}, /* vco 1000, pll 250 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x2}, /* vco 1328, pll 332 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x2}, /* vco 1600, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+};
+
+/* vco4 (DDR) clock */
+static struct clk vco4_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.pclk = &osc1_24m_clk,
+	.en_reg = VA_PLL4_CTR,
+	.en_reg_bit = PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco4_rtbl, ARRAY_SIZE(vco4_rtbl), 3},
+	.private_data = &vco4_config,
+};
+
+/* clock derived from vco4 clock */
+/* pll4 clock */
+static struct clk pll4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco4_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* pll5 USB 48 MHz clock */
+static struct clk pll5_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc1_24m_clk,
+	.rate = 48000000,
+};
+
+/* pll6 (MIPHY) clock */
+static struct clk pll6_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc3_25m_clk,
+	.rate = 25000000,
+};
+
+/* clocks derived from pll1 clk */
+/* ddr clock */
+static struct ddr_rate_tbl ddr_rate_tbl = {
+	.minrate = 332000000,
+	.maxrate = 500000000,
+};
+
+static struct pclk_info ddr_pclk_info[] = {
+	{
+		.pclk = &pll1_clk,
+		.pclk_val = MCTR_CLK_PLL1_VAL,
+	}, {
+		.pclk = &pll4_clk,
+		.pclk_val = MCTR_CLK_PLL4_VAL,
+	},
+};
+
+/* ddr parent select structure */
+static struct pclk_sel ddr_pclk_sel = {
+	.pclk_info = ddr_pclk_info,
+	.pclk_count = ARRAY_SIZE(ddr_pclk_info),
+	.pclk_sel_reg = VA_PERIP_CLK_CFG,
+	.pclk_sel_mask = MCTR_CLK_MASK,
+};
+
+static struct clk ddr_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.recalc = &follow_parent,
+	.pclk_sel = &ddr_pclk_sel,
+	.pclk_sel_shift = MCTR_CLK_SHIFT,
+	.private_data = &ddr_rate_tbl,
+};
+
+/* cpu clock */
+static struct clk cpu_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* ahb clock */
+static struct clk ahb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 6,
+	.recalc = &follow_parent,
+};
+
+/* apb clock */
+static struct clk apb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 12,
+	.recalc = &follow_parent,
+};
+
+/* clocks derived from osc1, ahb or apb */
+/* gpt[0-3] parents */
+static struct pclk_info gpt_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = GPT_OSC24_VAL,
+	}, {
+		.pclk = &apb_clk,
+		.pclk_val = GPT_APB_VAL,
+	},
+};
+
+/* gpt[0-3] parent select structure */
+static struct pclk_sel gpt_pclk_sel = {
+	.pclk_info = gpt_pclk_info,
+	.pclk_count = ARRAY_SIZE(gpt_pclk_info),
+	.pclk_sel_reg = VA_PERIP_CLK_CFG,
+	.pclk_sel_mask = GPT_CLK_MASK,
+};
+
+/* gpt0 timer clock */
+static struct clk gpt0_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = GPT0_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = GPT0_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt1 timer clock */
+static struct clk gpt1_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = GPT1_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = GPT1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt2 timer clock */
+static struct clk gpt2_clk = {
+	.en_reg = VA_PERIP2_CLK_ENB,
+	.en_reg_bit = GPT2_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = GPT2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt3 timer clock */
+static struct clk gpt3_clk = {
+	.en_reg = VA_PERIP2_CLK_ENB,
+	.en_reg_bit = GPT3_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = GPT3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* watch dog timer clock */
+static struct clk wdt_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &cpu_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* auxiliary synthesizers masks */
+static struct aux_clk_masks aux_masks = {
+	.eq_sel_mask = AUX_EQ_SEL_MASK,
+	.eq_sel_shift = AUX_EQ_SEL_SHIFT,
+	.eq1_mask = AUX_EQ1_SEL,
+	.eq2_mask = AUX_EQ2_SEL,
+	.xscale_sel_mask = AUX_XSCALE_MASK,
+	.xscale_sel_shift = AUX_XSCALE_SHIFT,
+	.yscale_sel_mask = AUX_YSCALE_MASK,
+	.yscale_sel_shift = AUX_YSCALE_SHIFT,
+};
+
+/* clocks derived multiple parents (pll1, pll5, synthesizers or others) */
+/* uart configurations */
+static struct aux_clk_config uart_synth_config = {
+	.synth_reg = VA_UART_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl aux_rtbl[] = {
+	/* For VCO1div2 = 500 MHz */
+	{.xscale = 10, .yscale = 204, .eq = 0}, /* 12.29 MHz */
+	{.xscale = 4, .yscale = 21, .eq = 0}, /* 48 MHz */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* 83 MHz */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* 125 MHz */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* 166 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* 250 MHz */
+};
+
+/* uart synth clock */
+static struct clk uart_synth_clk = {
+	.en_reg = VA_UART_CLK_SYNT,
+	.en_reg_bit = AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &uart_synth_config,
+};
+
+/* uart parents */
+static struct pclk_info uart_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &uart_synth_clk,
+		.pclk_val = AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* uart parent select structure */
+static struct pclk_sel uart_pclk_sel = {
+	.pclk_info = uart_pclk_info,
+	.pclk_count = ARRAY_SIZE(uart_pclk_info),
+	.pclk_sel_reg = VA_PERIP_CLK_CFG,
+	.pclk_sel_mask = UART_CLK_MASK,
+};
+
+/* uart clock */
+static struct clk uart_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = UART_CLK_ENB,
+	.pclk_sel = &uart_pclk_sel,
+	.pclk_sel_shift = UART_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* sdhci configurations */
+static struct aux_clk_config sdhci_synth_config = {
+	.synth_reg = VA_SDHCI_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* sdhci synth clock */
+static struct clk sdhci_synth_clk = {
+	.en_reg = VA_SDHCI_CLK_SYNT,
+	.en_reg_bit = AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 1},
+	.private_data = &sdhci_synth_config,
+};
+
+/* sdhci clock */
+static struct clk sdhci_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = SDHCI_CLK_ENB,
+	.pclk = &sdhci_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* cfxd configurations */
+static struct aux_clk_config cfxd_synth_config = {
+	.synth_reg = VA_CFXD_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* cfxd synth clock */
+static struct clk cfxd_synth_clk = {
+	.en_reg = VA_CFXD_CLK_SYNT,
+	.en_reg_bit = AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 4},
+	.private_data = &cfxd_synth_config,
+};
+
+/* cfxd clock */
+static struct clk cfxd_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = CFXD_CLK_ENB,
+	.pclk = &cfxd_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* C3 clk configurations */
+static struct aux_clk_config c3_synth_config = {
+	.synth_reg = VA_C3_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* c3 synth clock */
+static struct clk c3_synth_clk = {
+	.en_reg = VA_C3_CLK_SYNT,
+	.en_reg_bit = AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &c3_synth_config,
+};
+
+/* c3 parents */
+static struct pclk_info c3_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &c3_synth_clk,
+		.pclk_val = AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* c3 parent select structure */
+static struct pclk_sel c3_pclk_sel = {
+	.pclk_info = c3_pclk_info,
+	.pclk_count = ARRAY_SIZE(c3_pclk_info),
+	.pclk_sel_reg = VA_PERIP_CLK_CFG,
+	.pclk_sel_mask = C3_CLK_MASK,
+};
+
+/* c3 clock */
+static struct clk c3_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = C3_CLK_ENB,
+	.pclk_sel = &c3_pclk_sel,
+	.pclk_sel_shift = C3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac phy clk configurations */
+static struct aux_clk_config gmac_phy_synth_config = {
+	.synth_reg = VA_GMAC_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* gmii external pad clock for phy operation */
+static struct clk gmii_125m_pad = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 125000000,
+};
+
+/* gmac phy set of input clks*/
+static struct pclk_info gmac_phy_input_pclk_info[] = {
+	{
+		.pclk = &gmii_125m_pad,
+		.pclk_val = GMAC_PHY_125M_PAD_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = GMAC_PHY_PLL2_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = GMAC_PHY_OSC3_VAL,
+	},
+};
+
+static struct pclk_sel gmac_phy_input_pclk_sel = {
+	.pclk_info = gmac_phy_input_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_input_pclk_info),
+	.pclk_sel_reg = VA_GMAC_CLK_CFG,
+	.pclk_sel_mask = GMAC_PHY_INPUT_CLK_MASK,
+};
+
+static struct clk gmac_phy_input_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_input_pclk_sel,
+	.pclk_sel_shift = GMAC_PHY_INPUT_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl gmac_rtbl[] = {
+	/* For gmac phy input clk */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* divided by 6 */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* divided by 4 */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* divided by 3 */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* divided by 2 */
+};
+
+static struct clk gmac_phy_synth_clk = {
+	.en_reg = VA_GMAC_CLK_SYNT,
+	.en_reg_bit = AUX_SYNT_ENB,
+	.pclk = &gmac_phy_input_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {gmac_rtbl, ARRAY_SIZE(gmac_rtbl), 0},
+	.private_data = &gmac_phy_synth_config,
+};
+
+/* gmac phy parents */
+static struct pclk_info gmac_phy_pclk_info[] = {
+	{
+		.pclk = &gmac_phy_input_clk,
+		.pclk_val = GMAC_PHY_INPUT_ENB_VAL,
+	}, {
+		.pclk = &gmac_phy_synth_clk,
+		.pclk_val = GMAC_PHY_SYNT_ENB_VAL,
+	}
+};
+
+/* gmac phy parent select structure */
+static struct pclk_sel gmac_phy_pclk_sel = {
+	.pclk_info = gmac_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_pclk_info),
+	.pclk_sel_reg = VA_GMAC_CLK_CFG,
+	.pclk_sel_mask = GMAC_PHY_CLK_MASK,
+};
+
+/* gmac phy clock */
+static struct clk gmac_phy0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_pclk_sel,
+	.pclk_sel_shift = GMAC_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* clcd fractional synthesizers masks */
+static struct frac_synth_masks clcd_masks = {
+	.div_factor_mask = FRAC_SYNT_DIV_FACTOR_MASK,
+	.div_factor_shift = FRAC_SYNT_DIV_FACTOR_SHIFT,
+};
+
+static struct frac_synth_clk_config clcd_synth_config = {
+	.synth_reg = VA_CLCD_CLK_SYNT,
+	.masks = &clcd_masks,
+};
+
+/* clcd fractional synthesizer parents */
+static struct pclk_info clcd_synth_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = CLCD_SYNT_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = CLCD_SYNT_PLL2_VAL,
+	},
+};
+
+/* clcd fractional synthesizer parent select structure */
+static struct pclk_sel clcd_synth_pclk_sel = {
+	.pclk_info = clcd_synth_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_synth_pclk_info),
+	.pclk_sel_reg = VA_PLL_CFG,
+	.pclk_sel_mask = CLCD_SYNT_CLK_MASK,
+};
+
+/* clcd rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl clcd_rtbl[] = {
+	{.div = 0x14000}, /* 25 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x1284B}, /* 27 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0D8D3}, /* 58 Mhz , for vco1div4 = 393 MHz */
+	{.div = 0x0B72C}, /* 58 Mhz , for vco1div4 = 332 MHz */
+	{.div = 0x089EE}, /* 58 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06f1C}, /* 72 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06E58}, /* 58 Mhz , for vco1div4 = 200 MHz */
+	{.div = 0x06c1B}, /* 74 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x04A12}, /* 108 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0378E}, /* 144 Mhz , for vc01div4 = 250 MHz*/
+	/*
+	 * TODO : 1080p should work on 148 Mhz. But we see lots of
+	 * flickering at 148 Mhz.So, commenting this entry till we
+	 * resolve this issue
+	 */
+	/* {.div = 0x0360D}, */ /* 148 Mhz , for vc01div4 = 250 MHz*/
+};
+
+/* clcd fractional synthesizer clock */
+static struct clk clcd_synth_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &clcd_synth_pclk_sel,
+	.pclk_sel_shift = CLCD_SYNT_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {clcd_rtbl, ARRAY_SIZE(clcd_rtbl), 2},
+	.private_data = &clcd_synth_config,
+};
+
+/*
+ * clcd clock parents
+ * This would select to use pll5_clk or clcd_synth_clk as a parent clock
+ * of clcd (called as pixel clock in CLCD documentation).
+ * For selection of any of these two parent, check the combination of
+ * 3-2 bit of clcdclk_sel misc register
+ */
+static struct pclk_info clcd_pixel_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &clcd_synth_clk,
+		.pclk_val = AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* clcd parent select structure */
+static struct pclk_sel clcd_pixel_pclk_sel = {
+	.pclk_info = clcd_pixel_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pixel_pclk_info),
+	.pclk_sel_reg = VA_PERIP_CLK_CFG,
+	.pclk_sel_mask = CLCD_CLK_MASK,
+};
+
+static struct clk clcd_pixel_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &clcd_pixel_pclk_sel,
+	.pclk_sel_shift = CLCD_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/*
+ * clcd clock
+ * There are 2 options for clcd clock,
+ *  - derived from AHB (bus clk)
+ *  - dervied from Pixel Clock Input (pixel clk)
+ * The selection bit for these clock is in device itself, hence treating
+ * them as virtual clocks without selection register.
+ * Controller driver on itself needs to program proper selection
+ */
+
+static struct pclk_info clcd_pclk_info[] = {
+	{
+		.pclk = &clcd_pixel_clk,
+	}, {
+		.pclk = &ahb_clk,
+	},
+};
+
+static struct pclk_sel clcd_pclk_sel = {
+	.pclk_info = clcd_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pclk_info),
+	.pclk_sel_reg = 0, /* no select register */
+};
+
+/* clcd clock */
+static struct clk clcd_clk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = CLCD_CLK_ENB,
+	.pclk_sel = &clcd_pclk_sel,
+	.recalc = &follow_parent,
+};
+
+/* i2s related clocks */
+/* i2s source clock parents */
+static struct clk i2s_src_pad_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 12288000,
+};
+
+static struct pclk_info i2s_src_pclk_info[] = {
+	{
+		.pclk = &vco1div2_clk,
+		.pclk_val = I2S_SRC_VCODIV2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = I2S_SRC_PLL3_VAL,
+	}, {
+		.pclk = &i2s_src_pad_clk,
+		.pclk_val = I2S_SRC_PL_CLK1_VAL,
+	},
+};
+
+static struct pclk_sel i2s_src_pclk_sel = {
+	.pclk_info = i2s_src_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_src_pclk_info),
+	.pclk_sel_reg = VA_I2S_CLK_CFG,
+	.pclk_sel_mask = I2S_SRC_CLK_MASK,
+};
+
+/* i2s src clock */
+static struct clk i2s_src_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_src_pclk_sel,
+	.pclk_sel_shift = I2S_SRC_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s prescaler1 masks */
+static struct aux_clk_masks i2s_prs1_aux_masks = {
+	.eq_sel_mask = AUX_EQ_SEL_MASK,
+	.eq_sel_shift = I2S_PRS1_EQ_SEL_SHIFT,
+	.eq1_mask = AUX_EQ1_SEL,
+	.eq2_mask = AUX_EQ2_SEL,
+	.xscale_sel_mask = I2S_PRS1_CLK_X_MASK,
+	.xscale_sel_shift = I2S_PRS1_CLK_X_SHIFT,
+	.yscale_sel_mask = I2S_PRS1_CLK_Y_MASK,
+	.yscale_sel_shift = I2S_PRS1_CLK_Y_SHIFT,
+};
+
+/* i2s prs1 clk configurations */
+static struct aux_clk_config i2s_prs1_config = {
+	.synth_reg = VA_I2S_CLK_CFG,
+	.masks = &i2s_prs1_aux_masks,
+};
+
+/* i2s prs1 aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_prs1_aux_rtbl[] = {
+	/* For parent clk = 49.152 MHz */
+	{.xscale = 1, .yscale = 12, .eq = 0}, /* 2.048 MHz, smp freq = 8Khz */
+	{.xscale = 11, .yscale = 96, .eq = 0}, /* 2.816 MHz, smp freq = 11Khz */
+	{.xscale = 1, .yscale = 6, .eq = 0}, /* 4.096 MHz, smp freq = 16Khz */
+	{.xscale = 11, .yscale = 48, .eq = 0}, /* 5.632 MHz, smp freq = 22Khz */
+
+	/*
+	 * with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz
+	 * with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz
+	 */
+	{.xscale = 1, .yscale = 3, .eq = 0},
+
+	/* For parent clk = 49.152 MHz */
+	{.xscale = 17, .yscale = 37, .eq = 0}, /* 11.289 MHz, smp freq = 44Khz*/
+	{.xscale = 1, .yscale = 2, .eq = 0}, /* 12.288 MHz, smp freq = 48Khz*/
+};
+
+/* i2s prs1 clock */
+static struct clk i2s_prs1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &i2s_src_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_prs1_aux_rtbl, ARRAY_SIZE(i2s_prs1_aux_rtbl), 6},
+	.private_data = &i2s_prs1_config,
+};
+
+/* i2s ref clk configuration */
+static struct pclk_info i2s_ref_pclk_info[] = {
+	{
+		.pclk = &i2s_src_clk,
+		.pclk_val = I2S_REF_SRC_VAL,
+	}, {
+		.pclk = &i2s_prs1_clk,
+		.pclk_val = I2S_REF_PRS1_VAL,
+	},
+};
+
+/* i2s ref clock parent select structure */
+static struct pclk_sel i2s_ref_pclk_sel = {
+	.pclk_info = i2s_ref_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_ref_pclk_info),
+	.pclk_sel_reg = VA_I2S_CLK_CFG,
+	.pclk_sel_mask = I2S_REF_SEL_MASK,
+};
+
+/* i2s ref clock */
+static struct clk i2s_ref_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_ref_pclk_sel,
+	.pclk_sel_shift = I2S_REF_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s ref pad clock: for codec */
+static struct clk i2s_ref_pad_clk = {
+	.en_reg = VA_PERIP2_CLK_ENB,
+	.en_reg_bit = I2S_REF_PAD_CLK_ENB,
+	.pclk = &i2s_ref_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s sclk aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_sclk_aux_rtbl[] = {
+	/* For sclk = ref_clk * x/2/y */
+	{.xscale = 1, .yscale = 4, .eq = 0},
+	{.xscale = 1, .yscale = 2, .eq = 0},
+};
+
+/* i2s sclk (bit clock) syynthesizers masks */
+static struct aux_clk_masks i2s_sclk_aux_masks = {
+	.eq_sel_mask = AUX_EQ_SEL_MASK,
+	.eq_sel_shift = I2S_SCLK_EQ_SEL_SHIFT,
+	.eq1_mask = AUX_EQ1_SEL,
+	.eq2_mask = AUX_EQ2_SEL,
+	.xscale_sel_mask = I2S_SCLK_X_MASK,
+	.xscale_sel_shift = I2S_SCLK_X_SHIFT,
+	.yscale_sel_mask = I2S_SCLK_Y_MASK,
+	.yscale_sel_shift = I2S_SCLK_Y_SHIFT,
+};
+
+/* i2s sclk synth configurations */
+static struct aux_clk_config i2s_sclk_synth_config = {
+	.synth_reg = VA_I2S_CLK_CFG,
+	.masks = &i2s_sclk_aux_masks,
+};
+
+/* i2s sclk (bit clock) */
+static struct clk i2s_sclk_clk = {
+	.en_reg = VA_I2S_CLK_CFG,
+	.en_reg_bit = I2S_SCLK_SYNTH_ENB,
+	.pclk = &i2s_ref_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_sclk_aux_rtbl, ARRAY_SIZE(i2s_sclk_aux_rtbl), 0},
+	.private_data = &i2s_sclk_synth_config,
+};
+
+/* clock derived from ahb clk */
+
+/* i2c clock */
+static struct clk i2c_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = I2C_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* dma clock */
+static struct clk dma_pclk = {
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = DMA_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+/* jpeg clock */
+static struct clk jpeg_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = JPEG_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* gmac clock :Fixed Part*/
+static struct clk gmac0_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = GMAC_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* fsmc clock */
+static struct clk fsmc_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = FSMC_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nand clock */
+static struct clk fsmc_nand_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nor clock */
+static struct clk fsmc_nor_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* smi clock */
+static struct clk smi_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = SMI_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* uhc0 clock */
+static struct clk uhci0_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = UHC0_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* uhc1 clock */
+static struct clk uhci1_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = UHC1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* usbd clock */
+static struct clk usbd_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = USBD_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* pci clocks */
+static struct clk pcie0_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = PCIE0_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie1_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = PCIE1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie2_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = PCIE2_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* sysram clocks */
+static struct clk sysram0_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = SYSRAM0_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+static struct clk sysram1_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = SYSRAM1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from apb clk */
+/* adc clock */
+static struct clk adc_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = ADC_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* ssp clock */
+static struct clk ssp_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = SSP_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio0_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = GPIO0_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio1_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = GPIO1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* i2s0 clock */
+static struct clk i2s0_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = I2S0_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* i2s1 clock */
+static struct clk i2s1_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP1_CLK_ENB,
+	.en_reg_bit = I2S1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* keyboard clock */
+static struct clk kbd_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_PERIP2_CLK_ENB,
+	.en_reg_bit = KBD_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* RAS CLOCKS */
+
+/* RAS fractional synthesizers masks */
+static struct frac_synth_masks ras_synth_masks = {
+	.div_factor_mask = FRAC_SYNT_DIV_FACTOR_MASK,
+	.div_factor_shift = FRAC_SYNT_DIV_FACTOR_SHIFT,
+};
+
+static struct frac_synth_clk_config ras_synth0_config = {
+	.synth_reg = VA_RAS_CLK_SYNT0,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth1_config = {
+	.synth_reg = VA_RAS_CLK_SYNT1,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth2_config = {
+	.synth_reg = VA_RAS_CLK_SYNT2,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth3_config = {
+	.synth_reg = VA_RAS_CLK_SYNT3,
+	.masks = &ras_synth_masks,
+};
+
+/* RAS Fractional Synthesizer parents */
+static struct pclk_info ras_synth0_1_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = RAS_SYNT0_1_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco3div2_clk,
+		.pclk_val = RAS_SYNT0_1_VCO3_DIV2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = RAS_SYNT0_1_PLL3_VAL,
+	},
+};
+
+/* RAS Fractional Synthesizer-0 and 1 parent select structure */
+static struct pclk_sel ras_synth0_1_pclk_sel = {
+	.pclk_info = ras_synth0_1_pclk_info,
+	.pclk_count = ARRAY_SIZE(ras_synth0_1_pclk_info),
+	.pclk_sel_reg = VA_PLL_CFG,
+	.pclk_sel_mask = RAS_SYNT0_1_CLK_MASK,
+};
+
+static struct pclk_info ras_synth2_3_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = RAS_SYNT2_3_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco2div2_clk,
+		.pclk_val = RAS_SYNT2_3_VCO2_DIV2_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = RAS_SYNT2_3_PLL2_VAL,
+	},
+};
+
+/* RAS Fractional Synthesizer-2 and 3 parent select structure */
+static struct pclk_sel ras_synth2_3_pclk_sel = {
+	.pclk_info = ras_synth2_3_pclk_info,
+	.pclk_count = ARRAY_SIZE(ras_synth2_3_pclk_info),
+	.pclk_sel_reg = VA_PLL_CFG,
+	.pclk_sel_mask = RAS_SYNT2_3_CLK_MASK,
+};
+
+/* RAS rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl ras_rtbl[] = {
+	/* For vco1div4 = 250 MHz */
+	{.div = 0x14000}, /* 25 MHz */
+	{.div = 0x0A000}, /* 50 MHz */
+	{.div = 0x05000}, /* 100 MHz */
+	{.div = 0x02000}, /* 250 MHz */
+};
+
+/* RAS Fractional Synthesizer-0 Clock */
+static struct clk ras_synth0_clk = {
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = SYNT0_CLK_ENB,
+	.pclk_sel = &ras_synth0_1_pclk_sel,
+	.pclk_sel_shift = RAS_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth0_config,
+};
+
+/* RAS Fractional Synthesizer1 Clock */
+static struct clk ras_synth1_clk = {
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = SYNT1_CLK_ENB,
+	.pclk_sel = &ras_synth0_1_pclk_sel,
+	.pclk_sel_shift = RAS_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth1_config,
+};
+
+/* RAS Fractional Synthesizer2 Clock */
+static struct clk ras_synth2_clk = {
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = SYNT2_CLK_ENB,
+	.pclk_sel = &ras_synth2_3_pclk_sel,
+	.pclk_sel_shift = RAS_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth2_config,
+};
+
+/* RAS Fractional Synthesizer3 Clock */
+static struct clk ras_synth3_clk = {
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = SYNT3_CLK_ENB,
+	.pclk_sel = &ras_synth2_3_pclk_sel,
+	.pclk_sel_shift = RAS_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth3_config,
+};
+
+/* pll2 generated clock */
+static struct clk ras_pll2_clk = {
+	.pclk = &pll2_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = PLL2_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* pll3 generated clock */
+static struct clk ras_pll3_clk = {
+	.pclk = &pll3_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = PLL3_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* 125MHz clock generated on Tx pad */
+static struct clk ras_tx125_clk = {
+	.pclk = &gmii_125m_pad,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = C125M_PAD_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* 30 MHz clock generated by USB PHy Pll */
+static struct clk ras_30Mhz_clk = {
+	.rate = 30000000,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = C30M_CLK_ENB,
+};
+
+/* 48 MHz clock generated by USB PHy Pll */
+static struct clk ras_48Mhz_clk = {
+	.pclk = &pll5_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = C48M_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* osc3 generated clock */
+static struct clk ras_osc3_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = OSC3_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* osc2 generated clock */
+static struct clk ras_osc2_clk = {
+	.pclk = &osc2_32k_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = OSC2_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* osc1 generated clock */
+static struct clk ras_osc1_clk = {
+	.pclk = &osc1_24m_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = OSC1_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* apb generated clock */
+static struct clk ras_pclk_clk = {
+	.pclk = &apb_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = PCLK_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* ahb generated clock */
+static struct clk ras_aclk_clk = {
+	.pclk = &ahb_clk,
+	.en_reg = VA_RAS_CLK_ENB,
+	.en_reg_bit = ACLK_CLK_ENB,
+	.recalc = &follow_parent,
+};
+
+/* External pad 50 MHz clock for phy operation */
+static struct clk ras_tx50_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 50000000,
+};
+
+/* spear1300 machine specific clock structures */
+#ifdef CONFIG_CPU_SPEAR1300
+
+#endif
+
+/* spear1310_reva machine specific clock structures */
+#ifdef CONFIG_CPU_SPEAR1310_REVA
+/* can0 clock */
+static struct clk can0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* can1 clock */
+static struct clk can1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gmac clocks :RAS part*/
+static struct clk gmac_ras1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk gmac_ras2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk gmac_ras3_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk gmac_ras4_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* phy clock parent select */
+static struct pclk_info rmii_phy_pclk_info[] = {
+	{
+		.pclk = &ras_tx50_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_TX50M_VAL,
+	}, {
+		.pclk = &ras_pll2_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_PLL2_VAL,
+	}, {
+		.pclk = &ras_synth0_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_SYNTH0_VAL,
+	},
+};
+
+static struct pclk_info smii_rgmii_phy_pclk_info[] = {
+	{
+		.pclk = &ras_tx125_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_TX125M_PAD_VAL,
+	}, {
+		.pclk = &ras_pll2_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_PLL2_VAL,
+	}, {
+		.pclk = &ras_synth0_clk,
+		.pclk_val = SPEAR1310_REVA_RAS_SYNTH0_VAL,
+	},
+};
+
+/* RMII interface is driven by 50 MHz clock source */
+static struct pclk_sel phy_rmii_pclk_sel = {
+	.pclk_info = rmii_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(rmii_phy_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_REVA_RAS_CTRL_REG1)),
+	.pclk_sel_mask = SPEAR1310_REVA_PHY_CLK_MASK,
+};
+
+/* SMII and RGMII are both driven by 125 MHz clock source */
+static struct pclk_sel phy_smii_rgmii_pclk_sel = {
+	.pclk_info = smii_rgmii_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(smii_rgmii_phy_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_REVA_RAS_CTRL_REG1)),
+	.pclk_sel_mask = SPEAR1310_REVA_PHY_CLK_MASK,
+};
+
+/* Phy 1 Clock */
+static struct clk gmac_phy1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_REVA_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 2 Clock */
+static struct clk gmac_phy2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_REVA_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 3 Clock */
+static struct clk gmac_phy3_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_rmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_REVA_RMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 4 Clock */
+static struct clk gmac_phy4_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_REVA_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart1 clock */
+static struct clk uart1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* uart2 clock */
+static struct clk uart2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* uart3 clock */
+static struct clk uart3_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* uart4 clock */
+static struct clk uart4_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* uart5 clock */
+static struct clk uart5_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2c1 clock */
+static struct clk i2c1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &ras_pclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* tdm_hdlc clock */
+static struct pclk_info tdm_pclk_info[] = {
+	{
+		.pclk = &pll3_clk,
+		.pclk_val = TDM_CLK_PLL3,
+	}, {
+		.pclk = &ras_synth1_clk,
+		.pclk_val = TDM_CLK_RAS_SYNT1,
+	},
+};
+
+static struct pclk_sel tdm_pclk_sel = {
+	.pclk_info = tdm_pclk_info,
+	.pclk_count = ARRAY_SIZE(tdm_pclk_info),
+	.pclk_sel_reg =
+		(unsigned int *)(IO_ADDRESS(SPEAR1310_REVA_RAS_CTRL_REG0)),
+	.pclk_sel_mask = TDM_CLK_MASK,
+};
+
+static struct clk tdm_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &tdm_pclk_sel,
+	.pclk_sel_shift = TDM_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+#endif
+
+static struct clk dummy_apb_pclk;
+
+/* array of all spear 13xx clock lookups */
+static struct clk_lookup spear_clk_lookups[] = {
+	{ .con_id = "apb_pclk",		.clk = &dummy_apb_pclk},
+	/* root clks */
+	{.con_id = "osc1_24m_clk",	.clk = &osc1_24m_clk},
+	{.con_id = "osc2_32k_clk",	.clk = &osc2_32k_clk},
+	{.con_id = "osc3_25m_clk",	.clk = &osc3_25m_clk},
+
+	/* clock derived from 32 KHz osc clk */
+	{.dev_id = "rtc-spear",		.clk = &rtc_clk},
+
+	/* clock derived from 24/25 MHz osc1/osc3 clk */
+	{.con_id = "vco1_clk",		.clk = &vco1_clk},
+	{.con_id = "vco2_clk",		.clk = &vco2_clk},
+	{.con_id = "vco3_clk",		.clk = &vco3_clk},
+	{.con_id = "vco4_clk",		.clk = &vco4_clk},
+	{.con_id = "pll5_clk",		.clk = &pll5_clk},
+	{.con_id = "pll6_clk",		.clk = &pll6_clk},
+
+	/* clock derived from vco1-5 clk */
+	{.con_id = "pll1_clk",		.clk = &pll1_clk},
+	{.con_id = "pll2_clk",		.clk = &pll2_clk},
+	{.con_id = "pll3_clk",		.clk = &pll3_clk},
+	{.con_id = "pll4_clk",		.clk = &pll4_clk},
+	{.con_id = "vco1div2_clk",	.clk = &vco1div2_clk},
+	{.con_id = "vco1div4_clk",	.clk = &vco1div4_clk},
+	{.con_id = "vco2div2_clk",	.clk = &vco2div2_clk},
+	{.con_id = "vco3div2_clk",	.clk = &vco3div2_clk},
+
+	/* clock derived from pll1 clk */
+	{.con_id = "ddr_clk",		.clk = &ddr_clk},
+	{.con_id = "cpu_clk",		.clk = &cpu_clk},
+	{.con_id = "ahb_clk",		.clk = &ahb_clk},
+	{.con_id = "apb_clk",		.clk = &apb_clk},
+
+	/* synthesizers/prescaled clocks */
+	{.con_id = "c3_synth_clk",		.clk = &c3_synth_clk},
+	{.con_id = "gmii_125m_pad_clk",		.clk = &gmii_125m_pad},
+	{.con_id = "clcd_synth_clk",		.clk = &clcd_synth_clk},
+	{.con_id = "uart_synth_clk",		.clk = &uart_synth_clk},
+	{.con_id = "sdhci_synth_clk",		.clk = &sdhci_synth_clk},
+	{.con_id = "cfxd_synth_clk",		.clk = &cfxd_synth_clk},
+	{.con_id = "gmac_phy_input_clk",	.clk = &gmac_phy_input_clk},
+	{.con_id = "gmac_phy_synth_clk",	.clk = &gmac_phy_synth_clk},
+	{.con_id = "stmmacphy.0",		.clk = &gmac_phy0_clk},
+
+	/* RAS clocks */
+	{.con_id = "ras_synth0_clk",		.clk = &ras_synth0_clk},
+	{.con_id = "ras_synth1_clk",		.clk = &ras_synth1_clk},
+	{.con_id = "ras_synth2_clk",		.clk = &ras_synth2_clk},
+	{.con_id = "ras_synth3_clk",		.clk = &ras_synth3_clk},
+	{.con_id = "ras_pll3_clk",		.clk = &ras_pll3_clk},
+	{.con_id = "ras_pll2_clk",		.clk = &ras_pll2_clk},
+	{.con_id = "ras_tx125_clk",		.clk = &ras_tx125_clk},
+	{.con_id = "ras_30Mhz_clk",		.clk = &ras_30Mhz_clk},
+	{.con_id = "ras_48Mhz_clk",		.clk = &ras_48Mhz_clk},
+	{.con_id = "ras_osc3_clk",		.clk = &ras_osc3_clk},
+	{.con_id = "ras_osc2_clk",		.clk = &ras_osc2_clk},
+	{.con_id = "ras_osc1_clk",		.clk = &ras_osc1_clk},
+	{.con_id = "ras_pclk_clk",		.clk = &ras_pclk_clk},
+	{.con_id = "ras_aclk_clk",		.clk = &ras_aclk_clk},
+	{.con_id = "ras_tx50_clk",		.clk = &ras_tx50_clk},
+	/* i2s refout and sclk clks */
+	{.con_id = "i2s_src_pad_clk",		.clk = &i2s_src_pad_clk},
+	{.con_id = "i2s_src_clk",		.clk = &i2s_src_clk},
+	{.con_id = "i2s_prs1_clk",		.clk = &i2s_prs1_clk},
+	{.con_id = "i2s_ref_clk",		.clk = &i2s_ref_clk},
+	{.con_id = "i2s_ref_pad_clk",		.clk = &i2s_ref_pad_clk},
+	{.con_id = "i2s_sclk_clk",		.clk = &i2s_sclk_clk},
+
+	/* clocks having multiple parent source from above clocks */
+	{.dev_id = "clcd_pixel_clk",	.clk = &clcd_pixel_clk},
+	{.dev_id = "clcd-db9000",	.clk = &clcd_clk},
+	{.dev_id = "gpt0",		.clk = &gpt0_clk},
+	{.dev_id = "gpt1",		.clk = &gpt1_clk},
+	{.dev_id = "gpt2",		.clk = &gpt2_clk},
+	{.dev_id = "gpt3",		.clk = &gpt3_clk},
+	{.dev_id = "uart",		.clk = &uart_clk},
+
+	/* clock derived from ahb clk */
+	{.dev_id = "smi",		.clk = &smi_clk},
+	{.con_id = "usbh.0_clk",	.clk = &uhci0_clk},
+	{.con_id = "usbh.1_clk",	.clk = &uhci1_clk},
+	{.dev_id = "designware_udc",	.clk = &usbd_clk},
+	{.dev_id = "i2c_designware.0",	.clk = &i2c_clk},
+	{.con_id = "dmac_pclk",		.clk = &dma_pclk},
+	{.dev_id = "dw_dmac.0",		.clk = &dma0_clk},
+	{.dev_id = "dw_dmac.1",		.clk = &dma1_clk},
+	{.dev_id = "jpeg-designware",	.clk = &jpeg_clk},
+	{.dev_id = "stmmaceth.0",	.clk = &gmac0_clk},
+	{.dev_id = "c3",		.clk = &c3_clk},
+	{.dev_id = "dw_pcie.0",		.clk = &pcie0_clk},
+	{.dev_id = "dw_pcie.1",		.clk = &pcie1_clk},
+	{.dev_id = "dw_pcie.2",		.clk = &pcie2_clk},
+	{.dev_id = "sdhci",		.clk = &sdhci_clk},
+	{.con_id = "fsmc",		.clk = &fsmc_clk},
+	{.dev_id = "fsmc-nand",		.clk = &fsmc_nand_clk},
+	{.dev_id = "fsmc-nor",		.clk = &fsmc_nor_clk},
+	{.dev_id = "sysram0",		.clk = &sysram0_clk},
+	{.dev_id = "sysram1",		.clk = &sysram1_clk},
+	{.dev_id = "arasan_cf",		.clk = &cfxd_clk},
+	{.dev_id = "arasan_xd",		.clk = &cfxd_clk},
+
+	/* clock derived from apb clk */
+	{.dev_id = "adc",		.clk = &adc_clk},
+	{.dev_id = "designware-i2s.0",	.clk = &i2s0_clk},
+	{.dev_id = "designware-i2s.1",	.clk = &i2s1_clk},
+	{.dev_id = "ssp-pl022",		.clk = &ssp_clk},
+	{.dev_id = "gpio0",		.clk = &gpio0_clk},
+	{.dev_id = "gpio1",		.clk = &gpio1_clk},
+	{.dev_id = "keyboard",		.clk = &kbd_clk},
+	{.dev_id = "cortexa9-wdt",	.clk = &wdt_clk},
+	{.dev_id = "spear_thermal",	.clk = &thermal_clk},
+};
+
+/* array of all spear 1300 clock lookups */
+static struct clk_lookup spear1300_clk_lookups[] = {
+#ifdef CONFIG_CPU_SPEAR1300
+#endif
+};
+
+/* array of all spear 1310 clock lookups */
+static struct clk_lookup spear1310_reva_clk_lookups[] = {
+#ifdef CONFIG_CPU_SPEAR1310_REVA
+	{.dev_id = "c_can_platform.0",	.clk = &can0_clk},
+	{.dev_id = "c_can_platform.1",	.clk = &can1_clk},
+	{.dev_id = "stmmaceth.1",	.clk = &gmac_ras1_clk},
+	{.dev_id = "stmmaceth.2",	.clk = &gmac_ras2_clk},
+	{.dev_id = "stmmaceth.3",	.clk = &gmac_ras3_clk},
+	{.dev_id = "stmmaceth.4",	.clk = &gmac_ras4_clk},
+	{.con_id = "stmmacphy.1",	.clk = &gmac_phy1_clk},
+	{.con_id = "stmmacphy.2",	.clk = &gmac_phy2_clk},
+	{.con_id = "stmmacphy.3",	.clk = &gmac_phy3_clk},
+	{.con_id = "stmmacphy.4",	.clk = &gmac_phy4_clk},
+	{.dev_id = "uart1",		.clk = &uart1_clk},
+	{.dev_id = "uart2",		.clk = &uart2_clk},
+	{.dev_id = "uart3",		.clk = &uart3_clk},
+	{.dev_id = "uart4",		.clk = &uart4_clk},
+	{.dev_id = "uart5",		.clk = &uart5_clk},
+	{.dev_id = "i2c_designware.1",	.clk = &i2c1_clk},
+	{.con_id = "tdm_hdlc",		.clk = &tdm_clk},
+#endif
+};
+
+/* array of all spear 900 clock lookups */
+static struct clk_lookup spear900_clk_lookups[] = {
+#ifdef CONFIG_CPU_SPEAR900
+#endif
+};
+
+/* machine clk init */
+void __init spear13xx_clk_init(void)
+{
+	int i, cnt;
+	struct clk_lookup *lookups;
+
+	if (cpu_is_spear1300()) {
+		cnt = ARRAY_SIZE(spear1300_clk_lookups);
+		lookups = spear1300_clk_lookups;
+	} else if (cpu_is_spear1310_reva()) {
+		cnt = ARRAY_SIZE(spear1310_reva_clk_lookups);
+		lookups = spear1310_reva_clk_lookups;
+	} else {
+		cnt = ARRAY_SIZE(spear900_clk_lookups);
+		lookups = spear900_clk_lookups;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(spear_clk_lookups); i++)
+		clk_register(&spear_clk_lookups[i]);
+
+	for (i = 0; i < cnt; i++)
+		clk_register(&lookups[i]);
+
+	clk_init(&ddr_clk);
+}
diff --git a/arch/arm/mach-spear13xx/db9000_lcd.c b/arch/arm/mach-spear13xx/db9000_lcd.c
new file mode 100644
index 0000000..13295e1
--- /dev/null
+++ b/arch/arm/mach-spear13xx/db9000_lcd.c
@@ -0,0 +1,170 @@
+/*
+* arch/arm/mach-spear13xx/db9000_lcd.c
+* Copyright (C) 2010 Digital Blocks
+*
+* Based on arch/arm/mach-pxa/devices.c
+*
+* This file is licensed under the terms of the GNU General Public License
+* version 2. This program is licensed "as is" without any warranty of any kind,
+* whether express or implied.
+*/
+
+#include <linux/amba/bus.h>
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <video/db9000fb.h>
+
+#include <asm/setup.h>
+#include <plat/clock.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+
+static struct fb_videomode def_modelist[] = {
+	{
+		"480x272-32@0", 0, 480, 272, 111000, 2, 2, 2, 2, 40, 10, 0,
+		FB_VMODE_NONINTERLACED
+	}, {
+		"800x480-32@0", 0, 800, 480, 33333, 40, 40, 29, 13, 48, 3, 0,
+		FB_VMODE_NONINTERLACED
+	}, {
+		"1024x768-32@60", 60, 1024, 768, 15384, 160, 24, 29, 3, 136, 6,
+		0, FB_VMODE_NONINTERLACED
+	}, {
+		"1280x720-32@60", 60, 1280, 720, 13468, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED
+	}, {
+		"1920x540-32@60", 60, 1920, 540, 13468, 148, 88, 15, 2, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED
+	}, {
+		"1920x1080-32@60", 60, 1920, 1080, 6734, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED
+	},
+};
+
+static struct db9000fb_ctrl_info ctrl_info = {
+	.bpp = 32,
+	.cr1 = DB9000_CR1_EBO | DB9000_CR1_DEP | DB9000_CR1_HSP |
+		DB9000_CR1_VSP | DB9000_CR1_OPS(1) | DB9000_CR1_FDW(2),
+	.pwmfr = DB9000_PWMFR_PWM_FCD(24),
+	.pctr = DB9000_PCTR_PCI,
+	.dear = 0,
+};
+
+static struct db9000fb_mach_info clcd_plat_info = {
+	.modes		= def_modelist,
+	.num_modes	= ARRAY_SIZE(def_modelist),
+	.ctrl_info	= &ctrl_info,
+	.lcd_conn	= LCD_PCLK_EDGE_FALL,
+	.mem_size	= 0,
+	.cmap_static	= 0,
+	.cmap_inverse	= 0,
+};
+
+static void clcd_set_plat_data(struct platform_device *pdev,
+		struct db9000fb_mach_info *data)
+{
+	struct clk *clcd_pclk, *fb_clk, *ah_clk;
+	int ret;
+
+	pdev->dev.platform_data = data;
+
+	if (cpu_is_spear1340())
+		data->clcd_mux_selection = &config_clcd_gpio_pads;
+
+	ret = clk_set_parent_sys(NULL, "clcd_synth_clk", NULL, "vco1div4_clk");
+	if (ret) {
+		pr_err("%s:failed to set vco1div4 as parent of clcd_synth\n",
+				__func__);
+		return ;
+	}
+
+	ret = clk_set_parent_sys("clcd_pixel_clk", NULL, NULL,
+			"clcd_synth_clk");
+	if (ret) {
+		pr_err("%s:failed to set clcd_synth as parent of pixel clk\n",
+				__func__);
+		return ;
+	}
+
+	clcd_pclk = clk_get_sys("clcd_pixel_clk", NULL);
+	if (IS_ERR(clcd_pclk)) {
+		pr_err("%s:clcd-pixel clock get fail\n", __func__);
+		return;
+	}
+
+	ah_clk = clk_get(NULL, "ahb_clk");
+	if (IS_ERR(ah_clk)) {
+		pr_err("%s:enabling ahb_clk fail\n", __func__);
+		goto free_clcd_pclk;
+	}
+
+	fb_clk = clk_get_sys("clcd-db9000", NULL);
+	if (IS_ERR(fb_clk)) {
+		pr_err("%s:enabling fb_clk fail\n", __func__);
+		goto free_ah_clk;
+	}
+
+	/*
+	 * set pixel clk on bus clk by default, would be changed by
+	 * driver as per the need
+	 */
+	ret = clk_set_parent(fb_clk, clcd_pclk);
+	if (ret) {
+		pr_err("%s:failed to set pixel clk as parent of clcd\n",
+				__func__);
+		goto free_fb_clk;
+	}
+
+	data->pixel_clk = clcd_pclk;
+	data->bus_clk = ah_clk;
+
+	/* SPEAr1340 uses different pll for cpu and clcd */
+	if (cpu_is_spear1340())
+		data->ignore_cpufreq_notification = 1;
+	else
+		data->ignore_cpufreq_notification = 0;
+
+free_fb_clk:
+	clk_put(fb_clk);
+free_ah_clk:
+	clk_put(ah_clk);
+free_clcd_pclk:
+	clk_put(clcd_pclk);
+}
+
+static unsigned long frame_buf_base;
+static unsigned long frame_buf_size;
+
+void spear13xx_panel_fixup(struct meminfo *mi)
+{
+	frame_buf_size = (NUM_OF_FRAMEBUFFERS * PANEL_MAX_XRES *
+			PANEL_MAX_YRES * PANEL_MAX_BPP / 8);
+	frame_buf_base = reserve_mem(mi, ALIGN(frame_buf_size, SZ_1M));
+	if (frame_buf_base == ~0)
+		pr_err("Unable to allocate fb buffer\n");
+}
+
+void spear13xx_panel_init(struct platform_device *pdev)
+{
+	struct db9000fb_mach_info *mach_info;
+	mach_info = &clcd_plat_info;
+
+	if (!mach_info) {
+		pr_err("Invalid panel requested:\n");
+		return;
+	}
+	if (machine_is_spear1340_evb() || machine_is_spear900_evb())
+		mach_info->def_mode = "1024x768-32@60";
+	else
+		mach_info->def_mode = "480x272-32@0";
+
+	mach_info->frame_buf_base = frame_buf_base;
+	mach_info->mem_size = frame_buf_size;
+	clcd_set_plat_data(&spear13xx_db9000_clcd_device, mach_info);
+}
diff --git a/arch/arm/mach-spear13xx/dw_pcie.c b/arch/arm/mach-spear13xx/dw_pcie.c
new file mode 100644
index 0000000..bf113fc
--- /dev/null
+++ b/arch/arm/mach-spear13xx/dw_pcie.c
@@ -0,0 +1,814 @@
+/*
+ * arch/arm/mach-spear13xx/dw_pcie.c
+ *
+ * PCIe functions for Synopsys DW controllers
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/msi.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/platform_device.h>
+#include <linux/resource.h>
+#include <linux/slab.h>
+#include <mach/dw_pcie.h>
+static struct list_head	pcie_port_list;
+static struct hw_pci pci;
+
+#define PCI_FIND_CAP_TTL	48
+
+static int pci_find_own_next_cap_ttl(struct pcie_port *pp,
+		u32 pos, int cap, int *ttl)
+{
+	u32 id;
+
+	while ((*ttl)--) {
+		pp->ops.rd_own(pp, pos, 1, &pos);
+		if (pos < 0x40)
+			break;
+		pos &= ~3;
+		pp->ops.rd_own(pp, pos + PCI_CAP_LIST_ID, 1, &id);
+		if (id == 0xff)
+			break;
+		if (id == cap)
+			return pos;
+		pos += PCI_CAP_LIST_NEXT;
+	}
+	return 0;
+}
+
+static int pci_find_own_next_cap(struct pcie_port *pp, u32 pos, int cap)
+{
+	int ttl = PCI_FIND_CAP_TTL;
+
+	return pci_find_own_next_cap_ttl(pp, pos, cap, &ttl);
+}
+
+static int pci_find_own_cap_start(struct pcie_port *pp, u8 hdr_type)
+{
+	u32 status;
+
+	pp->ops.rd_own(pp, PCI_STATUS, 2, &status);
+	if (!(status & PCI_STATUS_CAP_LIST))
+		return 0;
+
+	switch (hdr_type) {
+	case PCI_HEADER_TYPE_NORMAL:
+	case PCI_HEADER_TYPE_BRIDGE:
+		return PCI_CAPABILITY_LIST;
+	case PCI_HEADER_TYPE_CARDBUS:
+		return PCI_CB_CAPABILITY_LIST;
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Tell if a device supports a given PCI capability.
+ * Returns the address of the requested capability structure within the
+ * device's PCI configuration space or 0 in case the device does not
+ * support it. Possible values for @cap:
+ *
+ * %PCI_CAP_ID_PM	Power Management
+ * %PCI_CAP_ID_AGP	Accelerated Graphics Port
+ * %PCI_CAP_ID_VPD	Vital Product Data
+ * %PCI_CAP_ID_SLOTID	Slot Identification
+ * %PCI_CAP_ID_MSI	Message Signalled Interrupts
+ * %PCI_CAP_ID_CHSWP	CompactPCI HotSwap
+ * %PCI_CAP_ID_PCIX	PCI-X
+ * %PCI_CAP_ID_EXP	PCI Express
+ */
+int pci_find_own_capability(struct pcie_port *pp, int cap)
+{
+	u32 pos, hdr_type;
+
+	pp->ops.rd_own(pp, PCI_HEADER_TYPE, 1, &hdr_type);
+
+	pos = pci_find_own_cap_start(pp, hdr_type);
+	if (pos)
+		pos = pci_find_own_next_cap(pp, pos, cap);
+
+	return pos;
+}
+
+struct pcie_port *portno_to_port(int port)
+{
+	struct pcie_port *pp;
+
+	list_for_each_entry(pp, &pcie_port_list, next) {
+		if (pp->port == port)
+			return pp;
+	}
+	return NULL;
+}
+
+static struct pcie_port *controller_to_port(int controller)
+{
+	struct pcie_port *pp;
+
+	if (controller >= pci.nr_controllers)
+		return NULL;
+
+	list_for_each_entry(pp, &pcie_port_list, next) {
+		if (pp->controller == controller)
+			return pp;
+	}
+	return NULL;
+}
+
+static struct pcie_port *bus_to_port(int bus)
+{
+	int i;
+	int rbus;
+	struct pcie_port *pp;
+
+	for (i = pci.nr_controllers - 1 ; i >= 0; i--) {
+		pp = controller_to_port(i);
+		rbus = pp->root_bus_nr;
+		if (rbus != -1 && rbus <= bus)
+			break;
+	}
+
+	return i >= 0 ? pp : NULL;
+}
+
+#ifdef CONFIG_PCI_MSI
+static DECLARE_BITMAP(msi_irq_in_use[MAX_PCIE_PORT_SUPPORTED],
+		NUM_MSI_IRQS);
+unsigned int msi_data[MAX_PCIE_PORT_SUPPORTED];
+
+/* MSI int handler */
+void handle_msi(struct pcie_port *pp)
+{
+	unsigned long val;
+	int i, pos;
+
+	for (i = 0; i < 8; i++) {
+		pp->ops.rd_own(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4,
+				(u32 *)&val);
+		if (val) {
+			pos = 0;
+			while ((pos = find_next_bit(&val, 32, pos)) != 32) {
+				generic_handle_irq(MSI0_INT_BASE
+					+ pp->port * NUM_MSI_IRQS
+					+ (i * 32) + pos);
+				pos++;
+			}
+		}
+		pp->ops.wr_own(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4, val);
+	}
+}
+
+static int find_valid_pos0(int port, int nvec, int pos, int *pos0)
+{
+	int flag = 1;
+	do {
+		pos = find_next_zero_bit(msi_irq_in_use[port],
+				NUM_MSI_IRQS, pos);
+		/*if you have reached to the end then get out from here.*/
+		if (pos == NUM_MSI_IRQS)
+			return -ENOSPC;
+		/*
+		 * Check if this position is at correct offset.nvec is always a
+		 * power of two. pos0 must be nvec bit alligned.
+		 */
+		if (pos % nvec)
+			pos += nvec - (pos % nvec);
+		else
+			flag = 0;
+	} while (flag);
+
+	*pos0 = pos;
+	return 0;
+}
+
+static void msi_nop(struct irq_data *data)
+{
+	return;
+}
+
+static struct irq_chip msi_chip = {
+	.name = "PCI-MSI",
+	.irq_ack = msi_nop,
+	.irq_enable = unmask_msi_irq,
+	.irq_disable = mask_msi_irq,
+	.irq_mask = mask_msi_irq,
+	.irq_unmask = unmask_msi_irq,
+};
+
+/* Dynamic irq allocate and deallocation */
+static int get_irq(int nvec, struct msi_desc *desc, int *pos)
+{
+	int res, bit, irq, pos0, pos1, i;
+	u32 val;
+	struct pcie_port *pp = bus_to_port(desc->dev->bus->number);
+
+	if (!pp) {
+		BUG();
+		return -EINVAL;
+	}
+
+	pos0 = find_first_zero_bit(msi_irq_in_use[pp->port],
+			NUM_MSI_IRQS);
+	if (pos0 % nvec) {
+		if (find_valid_pos0(pp->port, nvec, pos0, &pos0))
+			goto no_valid_irq;
+	}
+	if (nvec > 1) {
+		pos1 = find_next_bit(msi_irq_in_use[pp->port],
+				NUM_MSI_IRQS, pos0);
+		/* there must be nvec number of consecutive free bits */
+		while ((pos1 - pos0) < nvec) {
+			if (find_valid_pos0(pp->port, nvec, pos1, &pos0))
+				goto no_valid_irq;
+			pos1 = find_next_bit(msi_irq_in_use[pp->port],
+					NUM_MSI_IRQS, pos0);
+		}
+	}
+
+	irq = (MSI0_INT_BASE + (pp->port * NUM_MSI_IRQS)) + pos0;
+
+	if ((irq + nvec) > (MSI0_INT_END
+				+ (pp->port * NUM_MSI_IRQS)))
+		goto no_valid_irq;
+
+	i = 0;
+	while (i < nvec) {
+		set_bit(pos0 + i, msi_irq_in_use[pp->port]);
+		dynamic_irq_init(irq + i);
+		irq_set_msi_desc(irq + i, desc);
+		irq_set_chip_and_handler(irq + i, &msi_chip,
+				handle_simple_irq);
+		set_irq_flags(irq + i, IRQF_VALID);
+
+		/*
+		 * Enable corresponding interrupt on MSI interrupt
+		 * controller.
+		 */
+		res = ((pos0 + i) / 32) * 12;
+		bit = (pos0 + i) % 32;
+		pp->ops.rd_own(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);
+		val |= 1 << bit;
+		pp->ops.wr_own(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);
+		i++;
+	}
+
+	*pos = pos0;
+	return irq;
+no_valid_irq:
+	*pos = pos0;
+	return -ENOSPC;
+}
+
+static void clean_irq(unsigned int irq)
+{
+	int res, bit, val, pos;
+	struct irq_desc *desc = irq_to_desc(irq);
+	struct msi_desc *msi_desc = irq_desc_get_msi_desc(desc);
+	struct pcie_port *pp = bus_to_port(msi_desc->dev->bus->number);
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	pos = irq - (MSI0_INT_BASE + (pp->port * NUM_MSI_IRQS));
+
+	dynamic_irq_cleanup(irq);
+
+	clear_bit(pos, msi_irq_in_use[pp->port]);
+
+	/*
+	 * Disable corresponding interrupt on MSI interrupt
+	 * controller.
+	 */
+	res = (pos / 32) * 12;
+	bit = pos % 32;
+	pp->ops.rd_own(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);
+	val &= ~(1 << bit);
+	pp->ops.wr_own(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);
+}
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int cvec, rvec, irq, pos;
+	struct msi_msg msg;
+	uint16_t control;
+	struct pcie_port *pp = bus_to_port(pdev->bus->number);
+
+	if (!pp) {
+		BUG();
+		return -EINVAL;
+	}
+
+	/*
+	 * Read the MSI config to figure out how many IRQs this device
+	 * wants.Most devices only want 1, which will give
+	 * configured_private_bits and request_private_bits equal 0.
+	 */
+	pci_read_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
+			&control);
+
+	/*
+	 * If the number of private bits has been configured then use
+	 * that value instead of the requested number. This gives the
+	 * driver the chance to override the number of interrupts
+	 * before calling pci_enable_msi().
+	 */
+
+	cvec = (control & PCI_MSI_FLAGS_QSIZE) >> 4;
+
+	if (cvec == 0) {
+		/* Nothing is configured, so use the hardware requested size */
+		rvec = (control & PCI_MSI_FLAGS_QMASK) >> 1;
+	} else {
+		/*
+		 * Use the number of configured bits, assuming the
+		 * driver wanted to override the hardware request
+		 * value.
+		 */
+		rvec = cvec;
+	}
+
+	/*
+	 * The PCI 2.3 spec mandates that there are at most 32
+	 * interrupts. If this device asks for more, only give it one.
+	 */
+	if (rvec > 5)
+		rvec = 0;
+
+	irq = get_irq((1 << rvec), desc, &pos);
+
+	 if (irq < 0)
+		return irq;
+
+	 /* Update the number of IRQs the device has available to it */
+	 control &= ~PCI_MSI_FLAGS_QSIZE;
+	 control |= rvec << 4;
+	 pci_write_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
+			 control);
+	 desc->msi_attrib.multiple = rvec;
+
+	/*
+	 * An EP will modify lower 8 bits(max) of msi data while
+	 * sending any msi interrupt
+	 */
+	msg.address_hi = 0x0;
+	msg.address_lo = __virt_to_phys((u32)(&msi_data[pp->port]));
+	msg.data = pos;
+	write_msi_msg(irq, &msg);
+
+	return 0;
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	clean_irq(irq);
+}
+
+#endif
+
+static void __init pcie_preinit(void)
+{
+	int i;
+	struct pcie_port *pp;
+
+	for (i = 0; i < pci.nr_controllers; i++) {
+		pp = controller_to_port(i);
+		if (!pp) {
+			BUG();
+			return ;
+		}
+		snprintf(pp->mem_space_name, sizeof(pp->mem_space_name),
+			"PCIe %d MEM", pp->port);
+		pp->mem_space_name[sizeof(pp->mem_space_name) - 1] = 0;
+		pp->res[0].name = pp->mem_space_name;
+		pp->res[0].start = (resource_size_t)pp->mem_base;
+		pp->res[0].end = (resource_size_t)pp->mem_base
+			+ (pp->config.mem_size - 1);
+		pp->res[0].flags = IORESOURCE_MEM;
+
+		snprintf(pp->io_space_name, sizeof(pp->io_space_name),
+			"PCIe %d I/O", pp->port);
+		pp->io_space_name[sizeof(pp->io_space_name) - 1] = 0;
+		pp->res[1].name = pp->io_space_name;
+		pp->res[1].start =
+			__phys_to_pfn((u32)pp->io_base);
+		pp->res[1].end = pp->res[1].start + (pp->config.io_size - 1);
+		pp->res[1].flags = IORESOURCE_IO;
+
+		if (request_resource(&iomem_resource, &pp->res[0]))
+			panic("can't allocate PCIe Mem space");
+		if (request_resource(&ioport_resource, &pp->res[1]))
+			panic("can't allocate PCIe IO space");
+	}
+}
+
+static int pcie_get_payload(struct pci_dev *dev)
+{
+	int ret, cap;
+	u16 ctl;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!cap)
+		return -EINVAL;
+
+	ret = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (!ret)
+		ret = 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
+
+	return ret;
+}
+
+static int pcie_set_payload(struct pci_dev *dev, int rq)
+{
+	int cap, err = -EINVAL;
+	u16 ctl, v;
+
+	if (rq < 128 || rq > 4096 || !is_power_of_2(rq))
+		goto out;
+
+	v = (ffs(rq) - 8) << 5;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!cap)
+		goto out;
+
+	err = pci_read_config_word(dev, cap + PCI_EXP_DEVCTL, &ctl);
+	if (err)
+		goto out;
+
+	if ((ctl & PCI_EXP_DEVCTL_PAYLOAD) != v) {
+		ctl &= ~PCI_EXP_DEVCTL_PAYLOAD;
+		ctl |= v;
+		err = pci_write_config_dword(dev, cap + PCI_EXP_DEVCTL, ctl);
+	}
+
+out:
+	return err;
+}
+
+static void set_readrq(struct pci_bus *bus, int rq)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (rq < pcie_get_readrq(dev))
+			pcie_set_readrq(dev, rq);
+		if (dev->subordinate)
+			set_readrq(dev->subordinate, rq);
+	}
+}
+
+static int get_max_payload(struct pci_bus *bus, int rq)
+{
+	struct pci_dev *dev;
+	int payload;
+	int max_payload = rq;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		payload = pcie_get_payload(dev);
+		if (payload < max_payload)
+			max_payload = payload;
+		if (dev->subordinate)
+			max_payload = get_max_payload(dev->subordinate,
+					max_payload);
+	}
+	return max_payload;
+}
+
+static void set_payload(struct pci_bus *bus, int rq)
+{
+	struct pci_dev *dev;
+
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		pcie_set_payload(dev, rq);
+		if (dev->subordinate)
+			set_payload(dev->subordinate, rq);
+	}
+}
+
+static void __init pcie_postinit(void)
+{
+	struct hw_pci *hw = &pci;
+	struct pci_sys_data *sys;
+	struct pci_bus *bus;
+	int cap, ctl, payload, readrq;
+	int max_payload = 4096;
+	struct pcie_port *pp;
+
+	/*
+	 * allign Max_Payload_Size for all devices to the minimum
+	 * Max_Payload_Size of any of the device in tree.
+	 * Max_Read_Request_Size of any of the DS device should be less
+	 * than or equal to that of RC's Max_Read_Request_Size.
+	 */
+
+	list_for_each_entry(sys, &hw->buses, node) {
+		bus = sys->bus;
+		pp = bus_to_port(bus->number);
+		if (!pp) {
+			BUG();
+			return;
+		}
+		cap = pci_find_own_capability(pp, PCI_CAP_ID_EXP);
+		pp->ops.rd_own(pp, cap + PCI_EXP_DEVCTL, 2, &ctl);
+		payload = 128 << ((ctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
+		if (payload < max_payload)
+			max_payload = payload;
+		readrq = 128 << ((ctl & PCI_EXP_DEVCTL_READRQ) >> 12);
+		max_payload = get_max_payload(bus, max_payload);
+		set_payload(bus, max_payload);
+		set_readrq(bus, readrq);
+	}
+}
+
+static int __init pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct pcie_port *pp;
+
+	pp = controller_to_port(nr);
+
+	if (!pp)
+		return 0;
+
+	pp->root_bus_nr = sys->busnr;
+
+	pci_add_resource(&sys->resources, &pp->res[0]);
+	pci_add_resource(&sys->resources, &pp->res[1]);
+
+	return 1;
+}
+
+static int pcie_valid_config(struct pcie_port *pp, struct pci_bus *bus, int dev)
+{
+	/*If there is no link, then there is no device*/
+	if (bus->number != pp->root_bus_nr) {
+		if (!pp->ops.link_up(pp->va_app_base))
+			return 0;
+	}
+	/*
+	 * Don't go out when trying to access nonexisting devices
+	 * on the local bus.
+	 * we have only one slot on each root port.
+	 */
+	if (bus->number == pp->root_bus_nr && dev > 0)
+		return 0;
+
+	/*
+	 * do not read more than one device on the bus directly attached
+	 * to RC's (Virtual Bridge's) DS side.
+	 */
+	if (bus->primary == pp->root_bus_nr && dev > 0)
+		return 0;
+
+	return 1;
+}
+
+static int pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (!pp) {
+		BUG();
+		return -EINVAL;
+	}
+
+	if (pcie_valid_config(pp, bus, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	if (bus->number != pp->root_bus_nr)
+		ret = pp->ops.rd_other(pp, bus, devfn, where, size, val);
+	else {
+		pp->ops.rd_own(pp, where, size, val);
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static int pcie_wr_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	struct pcie_port *pp = bus_to_port(bus->number);
+	unsigned long flags;
+	int ret;
+
+	if (!pp) {
+		BUG();
+		return -EINVAL;
+	}
+
+	if (pcie_valid_config(pp, bus, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	spin_lock_irqsave(&pp->conf_lock, flags);
+	if (bus->number != pp->root_bus_nr)
+		ret = pp->ops.wr_other(pp, bus, devfn, where, size, val);
+	else {
+		pp->ops.wr_own(pp, where, size, val);
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&pp->conf_lock, flags);
+
+	return ret;
+}
+
+static struct pci_ops pcie_ops = {
+	.read = pcie_rd_conf,
+	.write = pcie_wr_conf,
+};
+
+static struct pci_bus __init *
+pcie_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus;
+	struct pcie_port *pp = controller_to_port(nr);
+
+	if (pp) {
+		bus = pci_scan_root_bus(NULL, sys->busnr, &pcie_ops, sys,
+					&sys->resources);
+	} else {
+		bus = NULL;
+		BUG();
+	}
+
+	return bus;
+}
+
+static int __init pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	struct pcie_port *pp = bus_to_port(dev->bus->number);
+	int irq;
+
+	if (!pp) {
+		BUG();
+		return -EINVAL;
+	}
+
+	irq = (INTX0_BASE + pp->port * NUM_INTX_IRQS + pin - 1);
+
+	return irq;
+}
+
+static struct hw_pci pci = {
+	.preinit	= pcie_preinit,
+	.postinit	= pcie_postinit,
+	.swizzle	= pci_std_swizzle,
+	.setup		= pcie_setup,
+	.scan		= pcie_scan_bus,
+	.map_irq	= pcie_map_irq,
+};
+
+#ifdef CONFIG_PM
+int spear_pcie_suspend(void)
+{
+	struct pcie_port *pp;
+	int i;
+
+	for (i = 0; i < pci.nr_controllers; i++) {
+		pp = controller_to_port(i);
+		if (pp->ops.link_up(pp->va_app_base)) {
+			pp->ops.host_exit(pp);
+			pp->ops.clk_exit(pp);
+			pp->susp_state = 1;
+		}
+	}
+
+	return 0;
+}
+
+int spear_pcie_resume(void)
+{
+	struct pcie_port *pp;
+	int i;
+
+	for (i = 0; i < pci.nr_controllers; i++) {
+		pp = controller_to_port(i);
+		if (pp->susp_state) {
+			pp->ops.clk_init(pp);
+			pp->susp_state = 0;
+			if (!pp->ops.link_up(pp->va_app_base))
+				pp->ops.host_init(pp);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static int __init pcie_probe(struct platform_device *pdev)
+{
+	int err;
+	struct clk *clk;
+	struct pcie_port *pp;
+
+	if (!pdev->dev.platform_data)
+		return -EINVAL;
+
+	if (!((struct pcie_port_info *)pdev->dev.platform_data)->is_host)
+		return -EINVAL;
+
+	pp = kzalloc(sizeof(*pp), GFP_KERNEL);
+	if (!pp) {
+		dev_err(&pdev->dev, "no memory for pcie port\n");
+		return -ENOMEM;
+	}
+
+	memcpy(&pp->config, pdev->dev.platform_data, (sizeof(pp->config)));
+
+	switch (pp->config.vendor) {
+#ifdef CONFIG_SPEAR_PCIE_REV341
+	case 341:
+		spear_pcie_341_add_ops(pp);
+		break;
+#endif
+#ifdef CONFIG_SPEAR_PCIE_REV370
+	case 370:
+		spear_pcie_370_add_ops(pp);
+		break;
+#endif
+	default:
+		dev_err(&pdev->dev, "ops not defined for this vendor\n");
+		err = -EINVAL;
+		goto free_mem;
+	}
+
+	if (pp->ops.clk_init(pp)) {
+		err = -EINVAL;
+		goto free_mem;
+	}
+
+	clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "couldn't get clk for pcie\n");
+		err = PTR_ERR(clk);;
+		goto free_mem;
+	}
+
+	if (clk_enable(clk)) {
+		dev_err(&pdev->dev, "couldn't enable clk for pcie\n");
+		err = -EINVAL;
+		goto clk_put;
+	}
+
+	if (!pp->ops.add_port(pp, pdev)) {
+		pp->controller = pci.nr_controllers;
+		pci.nr_controllers++;
+		list_add_tail(&pp->next, &pcie_port_list);
+		return 0;
+	}
+clk_put:
+	clk_put(clk);
+free_mem:
+	kfree(pp);
+	return err;
+}
+
+static struct platform_driver pcie_driver = {
+	.probe = pcie_probe,
+	.driver = {
+		.name	= "dw_pcie",
+	},
+};
+
+static int __init pcie_init(void)
+{
+	INIT_LIST_HEAD(&pcie_port_list);
+	platform_driver_register(&pcie_driver);
+	if (pci.nr_controllers) {
+		pci_common_init(&pci);
+		pci_assign_unassigned_resources();
+		pr_info("pcie init successful\n");
+	}
+
+	return 0;
+}
+subsys_initcall(pcie_init);
+
+static void __exit pcie_exit(void)
+{
+	platform_driver_unregister(&pcie_driver);
+}
+module_exit(pcie_exit);
+
diff --git a/arch/arm/mach-spear13xx/fsmc-nor.c b/arch/arm/mach-spear13xx/fsmc-nor.c
new file mode 100644
index 0000000..5033727
--- /dev/null
+++ b/arch/arm/mach-spear13xx/fsmc-nor.c
@@ -0,0 +1,75 @@
+/*
+ * arch/arm/mach-spear13xx/fsmc-nor.c
+ *
+ * FSMC (Flexible Static Memory Controller) interface for NOR
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Vipin Kumar<vipin.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/platform_device.h>
+
+int __init fsmc_nor_init(struct platform_device *pdev, unsigned long base,
+		u32 bank, u32 width)
+{
+	void __iomem *fsmc_nor_base;
+	struct clk *clk;
+	int ret;
+	u32 ctrl;
+
+	if (bank > (FSMC_MAX_NOR_BANKS - 1))
+		return -EINVAL;
+
+	fsmc_nor_base = ioremap(base, FSMC_NOR_REG_SIZE);
+	if (!fsmc_nor_base)
+		return -ENOMEM;
+
+	clk = clk_get_sys("fsmc-nor", NULL);
+	if (IS_ERR(clk)) {
+		iounmap(fsmc_nor_base);
+		return PTR_ERR(clk);
+	}
+
+	ret = clk_enable(clk);
+	if (ret) {
+		iounmap(fsmc_nor_base);
+		return ret;
+	}
+
+	ctrl = WAIT_ENB | WRT_ENABLE | WPROT | NOR_DEV | BANK_ENABLE;
+
+	switch (width) {
+	case FSMC_FLASH_WIDTH8:
+		ctrl |= WIDTH_8;
+		break;
+
+	case FSMC_FLASH_WIDTH16:
+		ctrl |= WIDTH_16;
+		break;
+
+	case FSMC_FLASH_WIDTH32:
+		ctrl |= WIDTH_32;
+		break;
+
+	default:
+		ctrl |= WIDTH_8;
+		break;
+	}
+
+	writel(ctrl, FSMC_NOR_REG(fsmc_nor_base, bank, CTRL));
+	writel(0x0FFFFFFF, FSMC_NOR_REG(fsmc_nor_base, bank, CTRL_TIM));
+	writel(ctrl | RSTPWRDWN, FSMC_NOR_REG(fsmc_nor_base, bank, CTRL));
+
+	iounmap(fsmc_nor_base);
+
+	return 0;
+}
diff --git a/arch/arm/mach-spear13xx/headsmp.S b/arch/arm/mach-spear13xx/headsmp.S
new file mode 100644
index 0000000..a998c32
--- /dev/null
+++ b/arch/arm/mach-spear13xx/headsmp.S
@@ -0,0 +1,45 @@
+/*
+ * arch/arm/mach-spear13XX/headsmp.S
+ *
+ * Picked from realview
+ * Copyright (c) 2010 ST Microelectronics Limited
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+/*
+ * spear13xx specific entry point for secondary CPUs. This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(spear13xx_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/* re-enable coherency */
+	mrc	p15, 0, r0, c1, c0, 1
+	orr	r0, r0, #(1 << 6) | (1 << 0)
+	mcr	p15, 0, r0, c1, c0, 1
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+	.align
+1:	.long	.
+	.long	pen_release
+ENDPROC(spear13xx_secondary_startup)
diff --git a/arch/arm/mach-spear13xx/hotplug.c b/arch/arm/mach-spear13xx/hotplug.c
new file mode 100644
index 0000000..ee6b06d
--- /dev/null
+++ b/arch/arm/mach-spear13xx/hotplug.c
@@ -0,0 +1,121 @@
+/*
+ * linux/arch/arm/mach-spear13xx/hotplug.c
+ *
+ * Copyright (C) 2010 ST Microelectronics Ltd.
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * based upon linux/arch/arm/mach-realview/hotplug.c
+ *
+ * Copyright (C) 2002 ARM Ltd.
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <asm/cacheflush.h>
+#include <asm/system.h>
+
+extern volatile int pen_release;
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+	"	mcr	p15, 0, %1, c7, c5, 0\n"
+	"	dsb\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	: "=&r" (v)
+	: "r" (0), "Ir" (CR_C)
+	: "cc", "memory");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile("mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, #0x20\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	: "=&r" (v)
+	: "Ir" (CR_C)
+	: "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu, int *spurious)
+{
+	for (;;) {
+		wfi();
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * Getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * Just note it happening - when we're woken, we can report
+		 * its occurrence.
+		 */
+		(*spurious)++;
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void __cpuinit platform_cpu_die(unsigned int cpu)
+{
+	int spurious = 0;
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu, &spurious);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+
+	if (spurious)
+		pr_warn("CPU%u: %u spurious wakeup calls\n", cpu, spurious);
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-spear13xx/include/mach/bitfield.h b/arch/arm/mach-spear13xx/include/mach/bitfield.h
new file mode 100644
index 0000000..87b566e
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/bitfield.h
@@ -0,0 +1,113 @@
+/*
+ *	FILE    	bitfield.h
+ *
+ *	Version 	1.1
+ *	Author  	Copyright (c) Marc A. Viredaz, 1998
+ *	        	DEC Western Research Laboratory, Palo Alto, CA
+ *	Date    	April 1998 (April 1997)
+ *	System  	Advanced RISC Machine (ARM)
+ *	Language	C or ARM Assembly
+ *	Purpose 	Definition of macros to operate on bit fields.
+ */
+
+
+
+#ifndef __BITFIELD_H
+#define __BITFIELD_H
+
+#ifndef __ASSEMBLY__
+#define UData(Data)	((unsigned long) (Data))
+#else
+#define UData(Data)	(Data)
+#endif
+
+
+/*
+ * MACRO: Fld
+ *
+ * Purpose
+ *    The macro "Fld" encodes a bit field, given its size and its shift value
+ *    with respect to bit 0.
+ *
+ * Note
+ *    A more intuitive way to encode bit fields would have been to use their
+ *    mask. However, extracting size and shift value information from a bit
+ *    field's mask is cumbersome and might break the assembler (255-character
+ *    line-size limit).
+ *
+ * Input
+ *    Size      	Size of the bit field, in number of bits.
+ *    Shft      	Shift value of the bit field with respect to bit 0.
+ *
+ * Output
+ *    Fld       	Encoded bit field.
+ */
+
+#define Fld(Size, Shft)	(((Size) << 16) + (Shft))
+
+
+/*
+ * MACROS: FSize, FShft, FMsk, FAlnMsk, F1stBit
+ *
+ * Purpose
+ *    The macros "FSize", "FShft", "FMsk", "FAlnMsk", and "F1stBit" return
+ *    the size, shift value, mask, aligned mask, and first bit of a
+ *    bit field.
+ *
+ * Input
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FSize     	Size of the bit field, in number of bits.
+ *    FShft     	Shift value of the bit field with respect to bit 0.
+ *    FMsk      	Mask for the bit field.
+ *    FAlnMsk   	Mask for the bit field, aligned on bit 0.
+ *    F1stBit   	First bit of the bit field.
+ */
+
+#define FSize(Field)	((Field) >> 16)
+#define FShft(Field)	((Field) & 0x0000FFFF)
+#define FMsk(Field)	(((UData(1) << FSize(Field)) - 1) << FShft(Field))
+#define FAlnMsk(Field)	((UData(1) << FSize(Field)) - 1)
+#define F1stBit(Field)	(UData(1) << FShft(Field))
+
+
+/*
+ * MACRO: FInsrt
+ *
+ * Purpose
+ *    The macro "FInsrt" inserts a value into a bit field by shifting the
+ *    former appropriately.
+ *
+ * Input
+ *    Value     	Bit-field value.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FInsrt    	Bit-field value positioned appropriately.
+ */
+
+#define FInsrt(Value, Field) \
+		(UData(Value) << FShft(Field))
+
+
+/*
+ * MACRO: FExtr
+ *
+ * Purpose
+ *    The macro "FExtr" extracts the value of a bit field by masking and
+ *    shifting it appropriately.
+ *
+ * Input
+ *    Data      	Data containing the bit-field to be extracted.
+ *    Field     	Encoded bit field (using the macro "Fld").
+ *
+ * Output
+ *    FExtr     	Bit-field value.
+ */
+
+#define FExtr(Data, Field) \
+		((UData(Data) >> FShft(Field)) & FAlnMsk(Field))
+
+
+#endif /* __BITFIELD_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/debug-macro.S b/arch/arm/mach-spear13xx/include/mach/debug-macro.S
new file mode 100644
index 0000000..3933edc
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/debug-macro.S
@@ -0,0 +1,14 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/debug-macro.S
+ *
+ * Debugging macro include header spear13xx machine family
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <plat/debug-macro.S>
diff --git a/arch/arm/mach-spear13xx/include/mach/dma.h b/arch/arm/mach-spear13xx/include/mach/dma.h
new file mode 100644
index 0000000..a8e6a74
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/dma.h
@@ -0,0 +1,148 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/dma.h
+ *
+ * DMA information for SPEAr13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_DMA_H
+#define __MACH_DMA_H
+
+#define MAX_DMA_ADDRESS		0xffffffff
+
+/* request id of all the peripherals */
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310) || \
+	defined(CONFIG_CPU_SPEAR1310_REVA) || defined(CONFIG_CPU_SPEAR900)
+enum dma_master_info {
+	SPEAR13XX_DMA_MASTER_MCIF = 0,
+	SPEAR13XX_DMA_MASTER_FSMC = 1,
+	SPEAR13XX_DMA_MASTER_JPEG = 1,
+
+	/* Accessible from both 0 & 1 */
+	SPEAR13XX_DMA_MASTER_MEMORY = 0,
+	SPEAR13XX_DMA_MASTER_ADC = 0,
+	SPEAR13XX_DMA_MASTER_I2S = 0,
+	SPEAR13XX_DMA_MASTER_UART0 = 0,
+	SPEAR13XX_DMA_MASTER_SSP0 = 0,
+	SPEAR13XX_DMA_MASTER_I2C = 0,
+
+#ifdef CONFIG_CPU_SPEAR1310
+	/* RAS IP's */
+	/* Accessible from both 0 & 1 */
+	SPEAR1310_DMA_MASTER_UART1 = 0,
+	SPEAR1310_DMA_MASTER_UART2 = 0,
+	SPEAR1310_DMA_MASTER_UART3 = 0,
+	SPEAR1310_DMA_MASTER_UART4 = 0,
+	SPEAR1310_DMA_MASTER_UART5 = 0,
+	SPEAR1310_DMA_MASTER_I2C1 = 0,
+	SPEAR1310_DMA_MASTER_I2C2 = 0,
+	SPEAR1310_DMA_MASTER_I2C3 = 0,
+	SPEAR1310_DMA_MASTER_I2C4 = 0,
+	SPEAR1310_DMA_MASTER_I2C5 = 0,
+	SPEAR1310_DMA_MASTER_I2C6 = 0,
+	SPEAR1310_DMA_MASTER_I2C7 = 0,
+	SPEAR1310_DMA_MASTER_SSP1 = 0,
+#endif /* CONFIG_CPU_SPEAR1310 */
+};
+
+enum request_id {
+	/* Scheme 00 */
+	SPEAR13XX_DMA_REQ_ADC = 0,
+	SPEAR13XX_DMA_REQ_FROM_JPEG = 2,
+	SPEAR13XX_DMA_REQ_TO_JPEG = 3,
+	SPEAR13XX_DMA_REQ_SSP0_TX = 4,
+	SPEAR13XX_DMA_REQ_SSP0_RX = 5,
+	SPEAR13XX_DMA_REQ_UART0_TX = 6,
+	SPEAR13XX_DMA_REQ_UART0_RX = 7,
+	SPEAR13XX_DMA_REQ_I2C_TX = 8,
+	SPEAR13XX_DMA_REQ_I2C_RX = 9,
+	SPEAR13XX_DMA_REQ_I2S_TX = 10,
+	SPEAR13XX_DMA_REQ_I2S_RX = 11,
+
+#ifdef CONFIG_CPU_SPEAR1310
+	/* RAS IP's */
+	SPEAR1310_DMA_REQ_I2C1_RX = 0,
+	SPEAR1310_DMA_REQ_I2C1_TX = 1,
+	SPEAR1310_DMA_REQ_I2C2_RX = 2,
+	SPEAR1310_DMA_REQ_I2C2_TX = 3,
+	SPEAR1310_DMA_REQ_I2C3_RX = 4,
+	SPEAR1310_DMA_REQ_I2C3_TX = 5,
+	SPEAR1310_DMA_REQ_I2C4_RX = 6,
+	SPEAR1310_DMA_REQ_I2C4_TX = 7,
+	SPEAR1310_DMA_REQ_I2C5_RX = 8,
+	SPEAR1310_DMA_REQ_I2C5_TX = 9,
+	SPEAR1310_DMA_REQ_I2C6_RX = 10,
+	SPEAR1310_DMA_REQ_I2C6_TX = 11,
+	SPEAR1310_DMA_REQ_UART1_RX = 12,
+	SPEAR1310_DMA_REQ_UART1_TX = 13,
+	SPEAR1310_DMA_REQ_UART2_RX = 14,
+	SPEAR1310_DMA_REQ_UART2_TX = 15,
+	SPEAR1310_DMA_REQ_UART5_RX = 16,
+	SPEAR1310_DMA_REQ_UART5_TX = 17,
+	SPEAR1310_DMA_REQ_SSP1_RX = 18,
+	SPEAR1310_DMA_REQ_SSP1_TX = 19,
+	SPEAR1310_DMA_REQ_I2C7_RX = 20,
+	SPEAR1310_DMA_REQ_I2C7_TX = 21,
+	SPEAR1310_DMA_REQ_UART3_RX = 28,
+	SPEAR1310_DMA_REQ_UART3_TX = 29,
+	SPEAR1310_DMA_REQ_UART4_RX = 30,
+	SPEAR1310_DMA_REQ_UART4_TX = 31,
+#endif /* CONFIG_CPU_SPEAR1310 */
+};
+#endif
+
+#ifdef CONFIG_CPU_SPEAR1340
+enum spear1340_request_id {
+	SPEAR1340_DMA_REQ_ADC = 0,
+	SPEAR1340_DMA_REQ_SPDIF_TX = 2,
+	SPEAR1340_DMA_REQ_SPDIF_RX = 3,
+	SPEAR1340_DMA_REQ_SSP0_TX = 4,
+	SPEAR1340_DMA_REQ_SSP0_RX = 5,
+	SPEAR1340_DMA_REQ_UART0_TX = 6,
+	SPEAR1340_DMA_REQ_UART0_RX = 7,
+	SPEAR1340_DMA_REQ_I2C0_TX = 8,
+	SPEAR1340_DMA_REQ_I2C0_RX = 9,
+	SPEAR1340_DMA_REQ_I2S_TX = 10,
+	SPEAR1340_DMA_REQ_I2S_RX = 11,
+	SPEAR1340_DMA_REQ_UART1_TX = 12,
+	SPEAR1340_DMA_REQ_UART1_RX = 13,
+	SPEAR1340_DMA_REQ_I2C1_TX = 14,
+	SPEAR1340_DMA_REQ_I2C1_RX = 15,
+	SPEAR1340_DMA_REQ_CAM0_EVEN = 0,
+	SPEAR1340_DMA_REQ_CAM0_ODD = 1,
+	SPEAR1340_DMA_REQ_CAM1_EVEN = 2,
+	SPEAR1340_DMA_REQ_CAM1_ODD = 3,
+	SPEAR1340_DMA_REQ_CAM2_EVEN = 4,
+	SPEAR1340_DMA_REQ_CAM2_ODD = 5,
+	SPEAR1340_DMA_REQ_CAM3_EVEN = 6,
+	SPEAR1340_DMA_REQ_CAM3_ODD = 7,
+};
+
+enum spear1340_dma_master_info {
+	SPEAR1340_DMA_MASTER_MCIF = 0,
+	SPEAR1340_DMA_MASTER_FSMC = 1,
+	SPEAR1340_DMA_MASTER_I2S_PLAY = 1,
+	SPEAR1340_DMA_MASTER_I2S_REC = 1,
+	SPEAR1340_DMA_MASTER_I2C1 = 1,
+	SPEAR1340_DMA_MASTER_UART1 = 1,
+
+	/* following are accessible from both master 0 & 1 */
+	SPEAR1340_DMA_MASTER_MEMORY = 0,
+	SPEAR1340_DMA_MASTER_UART0 = 0,
+	SPEAR1340_DMA_MASTER_ADC = 0,
+	SPEAR1340_DMA_MASTER_SSP = 0,
+	SPEAR1340_DMA_MASTER_I2C0 = 0,
+	SPEAR1340_DMA_MASTER_SPDIF = 0,
+	SPEAR1340_DMA_MASTER_CAM = 1,
+	SPEAR1340_DMA_MASTER_VIDEO_IN = 0,
+	SPEAR1340_DMA_MASTER_MALI = 0,
+};
+#endif /* CONFIG_CPU_SPEAR1340 */
+
+#endif /* __MACH_DMA_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/dw_pcie.h b/arch/arm/mach-spear13xx/include/mach/dw_pcie.h
new file mode 100644
index 0000000..924ac93
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/dw_pcie.h
@@ -0,0 +1,122 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/dw_pcie.h
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __DW_PCIE_H
+#define __DW_PCIE_H
+
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+
+#define MAX_LINK_UP_WAIT_MS	2
+/* Max port defined can be changed if required */
+#define MAX_PCIE_PORT_SUPPORTED	3
+struct pcie_port;
+
+struct pcie_port_info {
+	u32	vendor;
+	u8	is_host;
+	u8	is_gen1;
+	u32	mem_size;
+	u32	io_size;
+	u32	cfg0_size;
+	u32	cfg1_size;
+	u32	msg_size;
+	u32	in_mem_size;
+};
+
+struct pcie_private_ops {
+	void (*rd_own)(struct pcie_port *pp, int where, int size, u32 *val);
+	void (*wr_own)(struct pcie_port *pp, int where, int size, u32 val);
+	int (*rd_other)(struct pcie_port *pp, struct pci_bus *bus,
+			u32 devfn, int where, int size, u32 *val);
+	int (*wr_other)(struct pcie_port *pp, struct pci_bus *bus,
+			u32 devfn, int where, int size, u32 val);
+	int (*add_port)(struct pcie_port *pp, struct platform_device *pdev);
+	int (*link_up)(void __iomem *va_app_base);
+	void (*host_init)(struct pcie_port *pp);
+	void (*host_exit)(struct pcie_port *pp);
+	int (*clk_init)(struct pcie_port *pp);
+	int (*clk_exit)(struct pcie_port *pp);
+};
+
+struct pcie_port {
+	u8			port;
+	u8			controller;
+	u8			root_bus_nr;
+	void __iomem		*base;
+	void __iomem		*app_base;
+	void __iomem		*cfg0_base;
+	void __iomem		*cfg1_base;
+	void __iomem		*mem_base;
+	void __iomem		*io_base;
+	void __iomem		*va_base;
+	void __iomem		*va_app_base;
+	void __iomem		*va_cfg0_base;
+	void __iomem		*va_cfg1_base;
+	spinlock_t		conf_lock;
+	char			mem_space_name[16];
+	char			io_space_name[16];
+	struct resource		res[2];
+	struct pcie_port_info	config;
+	struct list_head	next;
+	struct pcie_private_ops	ops;
+	struct clk *clk;
+	int	susp_state;
+};
+
+/* synopsis specific PCIE configuration registers*/
+#define PCIE_PORT_LOGIC			0x80C
+#define PORT_LOGIC_SPD_CHANGE_ID	17
+
+#define PCIE_MSI_ADDR_LO		0x820
+#define PCIE_MSI_ADDR_HI		0x824
+#define PCIE_MSI_INTR0_ENABLE		0x828
+#define PCIE_MSI_INTR0_MASK		0x82C
+#define PCIE_MSI_INTR0_STATUS		0x830
+
+#define PCIE_ATU_VIEWPORT		0x900
+#define PCIE_ATU_REGION_INBOUND		(1 << 31)
+#define PCIE_ATU_REGION_OUTBOUND	(0 << 31)
+#define PCIE_ATU_CR1			0x904
+#define PCIE_ATU_TYPE_MEM		0
+#define PCIE_ATU_TYPE_IO		2
+#define PCIE_ATU_TYPE_CFG0		4
+#define PCIE_ATU_TYPE_CFG1		5
+#define PCIE_ATU_CR2			0x908
+#define PCIE_ATU_ENABLE			(1 << 31)
+#define PCIE_ATU_BAR_MODE_ENABLE	(1 << 30)
+#define PCIE_ATU_LOWER_BASE		0x90C
+#define PCIE_ATU_UPPER_BASE		0x910
+#define PCIE_ATU_LIMIT			0x914
+#define PCIE_ATU_LOWER_TARGET		0x918
+#define PCIE_ATU_UPPER_TARGET		0x91C
+
+/*BAR MASK registers*/
+#define PCIE_BAR0_MASK_REG		0x1010
+
+#ifdef CONFIG_ARCH_SPEAR13XX
+#define INTX0_BASE			SPEAR_INTX0_BASE
+#define NUM_INTX_IRQS			SPEAR_NUM_INTX_IRQS
+#define IRQ_PCIE0			SPEAR13XX_IRQ_PCIE0
+#define NUM_MSI_IRQS			SPEAR_NUM_MSI_IRQS
+#define MSI0_INT_BASE			SPEAR_MSI0_INT_BASE
+#define MSI0_INT_END			SPEAR_MSI0_INT_END
+
+int enable_pcie0_clk(void);
+void spear_pcie_341_add_ops(struct pcie_port *pp);
+void spear_pcie_370_add_ops(struct pcie_port *pp);
+#endif
+
+int pci_find_own_capability(struct pcie_port *pp, int cap);
+struct pcie_port *portno_to_port(int port);
+void handle_msi(struct pcie_port *pp);
+#endif
diff --git a/arch/arm/mach-spear13xx/include/mach/entry-macro.S b/arch/arm/mach-spear13xx/include/mach/entry-macro.S
new file mode 100644
index 0000000..04be5cc
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/entry-macro.S
@@ -0,0 +1,16 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/entry-macro.S
+ *
+ * Copyright (C) 2009 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
diff --git a/arch/arm/mach-spear13xx/include/mach/generic.h b/arch/arm/mach-spear13xx/include/mach/generic.h
new file mode 100644
index 0000000..55c51bd
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/generic.h
@@ -0,0 +1,663 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/generic.h
+ *
+ * spear13xx machine family generic header file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_GENERIC_H
+#define __MACH_GENERIC_H
+
+#include <linux/designware_i2s.h>
+#include <linux/dmaengine.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/amba/bus.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+#include <asm/setup.h>
+#include <plat/padmux.h>
+#include <plat/plug_board.h>
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+/*
+ * Function enable (Pad multiplexing register) offsets
+ */
+/* pad mux declarations */
+#define SPEAR13XX_PMX_I2S1_MASK		(1 << 3)
+#define SPEAR13XX_PMX_I2S2_MASK		(1 << 16)	/* Offset 4 */
+#define SPEAR13XX_PMX_CLCD1_MASK	(1 << 5)
+#define SPEAR13XX_PMX_CLCD2_MASK	(1 << 3)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO00_MASK	(1 << 6)
+#define SPEAR13XX_PMX_EGPIO01_MASK	(1 << 7)
+#define SPEAR13XX_PMX_EGPIO02_MASK	(1 << 8)
+#define SPEAR13XX_PMX_EGPIO03_MASK	(1 << 9)
+#define SPEAR13XX_PMX_EGPIO04_MASK	(1 << 10)
+#define SPEAR13XX_PMX_EGPIO05_MASK	(1 << 11)
+#define SPEAR13XX_PMX_EGPIO06_MASK	(1 << 12)
+#define SPEAR13XX_PMX_EGPIO07_MASK	(1 << 13)
+#define SPEAR13XX_PMX_EGPIO08_MASK	(1 << 14)
+#define SPEAR13XX_PMX_EGPIO09_MASK	(1 << 15)
+#define SPEAR13XX_PMX_EGPIO10_MASK	(1 << 5)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO11_MASK	(1 << 6)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO12_MASK	(1 << 7)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO13_MASK	(1 << 8)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO14_MASK	(1 << 9)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO15_MASK	(1 << 10)	/* Offset 4 */
+#define SPEAR13XX_PMX_EGPIO_0_GRP_MASK (SPEAR13XX_PMX_EGPIO00_MASK | \
+		SPEAR13XX_PMX_EGPIO01_MASK | SPEAR13XX_PMX_EGPIO02_MASK | \
+		SPEAR13XX_PMX_EGPIO03_MASK | SPEAR13XX_PMX_EGPIO04_MASK | \
+		SPEAR13XX_PMX_EGPIO05_MASK | SPEAR13XX_PMX_EGPIO06_MASK | \
+		SPEAR13XX_PMX_EGPIO07_MASK | SPEAR13XX_PMX_EGPIO08_MASK | \
+		SPEAR13XX_PMX_EGPIO09_MASK)
+#define SPEAR13XX_PMX_EGPIO_1_GRP_MASK (SPEAR13XX_PMX_EGPIO10_MASK | \
+		SPEAR13XX_PMX_EGPIO11_MASK | SPEAR13XX_PMX_EGPIO12_MASK | \
+		SPEAR13XX_PMX_EGPIO13_MASK | SPEAR13XX_PMX_EGPIO14_MASK | \
+		SPEAR13XX_PMX_EGPIO15_MASK)
+
+#define SPEAR13XX_PMX_SMI_MASK		(1 << 16)
+#define SPEAR13XX_PMX_SMINCS2_MASK	(1 << 1)	/* Offset 4 */
+#define SPEAR13XX_PMX_SMINCS3_MASK	(1 << 2)	/* Offset 4 */
+
+#define SPEAR13XX_PMX_GMIICLK_MASK			(1 << 18)
+#define SPEAR13XX_PMX_GMIICOL_CRS_XFERER_MIITXCLK_MASK	(1 << 19)
+#define SPEAR13XX_PMX_RXCLK_RDV_TXEN_D03_MASK		(1 << 20)
+#define SPEAR13XX_PMX_GMIID47_MASK			(1 << 21)
+#define SPEAR13XX_PMX_MDC_MDIO_MASK			(1 << 22)
+#define SPEAR13XX_PMX_MCI_DATA8_15_MASK			(1 << 23)
+
+#define SPEAR13XX_PMX_GMII_MASK (SPEAR13XX_PMX_GMIICLK_MASK | \
+		SPEAR13XX_PMX_GMIICOL_CRS_XFERER_MIITXCLK_MASK | \
+		SPEAR13XX_PMX_RXCLK_RDV_TXEN_D03_MASK | \
+		SPEAR13XX_PMX_GMIID47_MASK | SPEAR13XX_PMX_MDC_MDIO_MASK)
+
+#define SPEAR13XX_PMX_NAND8_MASK	(1 << 17)
+#define SPEAR13XX_PMX_NFAD023_MASK	(1 << 24)
+#define SPEAR13XX_PMX_NFAD24_MASK	(1 << 25)
+#define SPEAR13XX_PMX_NFAD25_MASK	(1 << 26)
+#define SPEAR13XX_PMX_NFWPRT1_MASK	(1 << 24)	/* Offset 4 */
+#define SPEAR13XX_PMX_NFWPRT2_MASK	(1 << 26)	/* Offset 4 */
+#define SPEAR13XX_PMX_NFWPRT3_MASK	(1 << 28)
+#define SPEAR13XX_PMX_NFRSTPWDWN0_MASK	(1 << 29)
+#define SPEAR13XX_PMX_NFRSTPWDWN1_MASK	(1 << 30)
+#define SPEAR13XX_PMX_NFRSTPWDWN2_MASK	(1 << 31)
+#define SPEAR13XX_PMX_NFRSTPWDWN3_MASK	(1 << 0)	/* Offset 4 */
+#define SPEAR13XX_PMX_NFCE1_MASK	(1 << 20)	/* Offset 4 */
+#define SPEAR13XX_PMX_NFCE2_MASK	(1 << 22)	/* Offset 4 */
+#define SPEAR13XX_PMX_NFCE3_MASK	(1 << 27)
+#define SPEAR13XX_PMX_NFIO815_MASK	(1 << 18)	/* Offset 4 */
+
+#define SPEAR13XX_PMX_NAND8BIT_0_MASK (SPEAR13XX_PMX_NAND8_MASK | \
+		SPEAR13XX_PMX_NFAD023_MASK | SPEAR13XX_PMX_NFAD24_MASK | \
+		SPEAR13XX_PMX_NFAD25_MASK | SPEAR13XX_PMX_NFWPRT3_MASK | \
+		SPEAR13XX_PMX_NFRSTPWDWN0_MASK | SPEAR13XX_PMX_NFRSTPWDWN1_MASK\
+		| SPEAR13XX_PMX_NFRSTPWDWN2_MASK | SPEAR13XX_PMX_NFCE3_MASK)
+#define SPEAR13XX_PMX_NAND8BIT_1_MASK	(SPEAR13XX_PMX_NFRSTPWDWN3_MASK)
+
+#define SPEAR13XX_PMX_NAND8BIT4DEV_0_MASK	SPEAR13XX_PMX_NAND8BIT_0_MASK
+#define SPEAR13XX_PMX_NAND8BIT4DEV_1_MASK	(SPEAR13XX_PMX_NAND8BIT_1_MASK\
+		| SPEAR13XX_PMX_NFCE1_MASK | SPEAR13XX_PMX_NFCE2_MASK | \
+		SPEAR13XX_PMX_NFWPRT1_MASK | SPEAR13XX_PMX_NFWPRT2_MASK)
+
+#define SPEAR13XX_PMX_NAND16BIT_0_MASK	(SPEAR13XX_PMX_NAND8BIT_0_MASK)
+#define SPEAR13XX_PMX_NAND16BIT_1_MASK	(SPEAR13XX_PMX_NAND8BIT_1_MASK | \
+		SPEAR13XX_PMX_NFIO815_MASK)
+#define SPEAR13XX_PMX_NAND16BIT4DEV_0_MASK SPEAR13XX_PMX_NAND8BIT4DEV_0_MASK
+#define SPEAR13XX_PMX_NAND16BIT4DEV_1_MASK	\
+	(SPEAR13XX_PMX_NAND8BIT4DEV_1_MASK | SPEAR13XX_PMX_NFIO815_MASK)
+
+#define SPEAR13XX_PMX_KBD_ROW0_MASK	(1 << 25)	/* Offset 4 */
+#define SPEAR13XX_PMX_KBD_ROW1_MASK	(1 << 23)	/* Offset 4 */
+#define SPEAR13XX_PMX_KBD_ROWCOL25_MASK	(1 << 17)	/* Offset 4 */
+#define SPEAR13XX_PMX_KBD_ROWCOL68_MASK	(1 << 4)	/* Offset 4 */
+#define SPEAR13XX_PMX_KBD_COL0_MASK	(1 << 21)	/* Offset 4 */
+#define SPEAR13XX_PMX_KBD_COL1_MASK	(1 << 19)	/* Offset 4 */
+#define SPEAR13XX_PMX_KEYBOARD_6X6_MASK	(SPEAR13XX_PMX_KBD_ROW0_MASK | \
+		SPEAR13XX_PMX_KBD_ROW1_MASK | SPEAR13XX_PMX_KBD_ROWCOL25_MASK \
+		| SPEAR13XX_PMX_KBD_COL0_MASK | SPEAR13XX_PMX_KBD_COL1_MASK)
+
+#define SPEAR13XX_PMX_UART0_MASK	(1 << 1)
+#define SPEAR13XX_PMX_I2C_MASK		(1 << 2)
+#define SPEAR13XX_PMX_SSP_MASK		(1 << 4)
+#define SPEAR13XX_PMX_UART0_MODEM_MASK	(1 << 11)	/* Offset 4 */
+#define SPEAR13XX_PMX_GPT0_TMR1_MASK	(1 << 12)	/* Offset 4 */
+#define SPEAR13XX_PMX_GPT0_TMR2_MASK	(1 << 13)	/* Offset 4 */
+#define SPEAR13XX_PMX_GPT1_TMR1_MASK	(1 << 14)	/* Offset 4 */
+#define SPEAR13XX_PMX_GPT1_TMR2_MASK	(1 << 15)	/* Offset 4 */
+
+#define SPEAR13XX_PMX_MCIDATA0_MASK	(1 << 27)	/* Offset 4 */
+#define SPEAR13XX_PMX_MCIDATA1_MASK	(1 << 28)	/* Offset 4 */
+#define SPEAR13XX_PMX_MCIDATA2_MASK	(1 << 29)	/* Offset 4 */
+#define SPEAR13XX_PMX_MCIDATA3_MASK	(1 << 30)	/* Offset 4 */
+#define SPEAR13XX_PMX_MCIDATA4_MASK	(1 << 31)	/* Offset 4 */
+#define SPEAR13XX_PMX_MCIDATA5_MASK	(1 << 0)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATA6_MASK	(1 << 1)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATA7_MASK	(1 << 2)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATA1SD_MASK	(1 << 3)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATA2SD_MASK	(1 << 4)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATA3SD_MASK	(1 << 5)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIADDR0ALE_MASK	(1 << 6)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIADDR1CLECLK_MASK (1 << 7)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIADDR2_MASK	(1 << 8)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICECF_MASK	(1 << 9)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICEXD_MASK	(1 << 10)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICESDMMC_MASK	(1 << 11)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICDCF1_MASK	(1 << 12)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICDCF2_MASK	(1 << 13)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICDXD_MASK	(1 << 14)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICDSDMMC_MASK	(1 << 15)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDATADIR_MASK	(1 << 16)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDMARQWP_MASK	(1 << 17)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIIORDRE_MASK	(1 << 18)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIIOWRWE_MASK	(1 << 19)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIRESETCF_MASK	(1 << 20)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICS0CE_MASK	(1 << 21)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICFINTR_MASK	(1 << 22)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIIORDY_MASK	(1 << 23)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCICS1_MASK	(1 << 24)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCIDMAACK_MASK	(1 << 25)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCISDCMD_MASK	(1 << 26)	/* Offset 8 */
+#define SPEAR13XX_PMX_MCILEDS_MASK	(1 << 27)	/* Offset 8 */
+#define SPEAR13XX_PMX_TOUCH_XY_MASK	(1 << 28)	/* Offset 8 */
+#define SPEAR13XX_PMX_SSP0_CS0_MASK	(1 << 29)	/* Offset 8 */
+#define SPEAR13XX_PMX_SSP0_CS1_2_MASK	(1 << 30)	/* Offset 8 */
+
+#define SPEAR13XX_PMX_MCIFALL_1_MASK	(0xF8000000)
+#define SPEAR13XX_PMX_MCIFALL_2_MASK	(0x0FFFFFFF)
+
+/* pad mux devices */
+extern struct pmx_dev spear13xx_pmx_i2c;
+extern struct pmx_dev spear13xx_pmx_ssp;
+extern struct pmx_dev spear13xx_pmx_i2s1;
+extern struct pmx_dev spear13xx_pmx_i2s2;
+extern struct pmx_dev spear13xx_pmx_clcd;
+extern struct pmx_dev spear13xx_pmx_clcd_hires;
+extern struct pmx_dev spear13xx_pmx_egpio_grp;
+extern struct pmx_dev spear13xx_pmx_smi_2_chips;
+extern struct pmx_dev spear13xx_pmx_smi_4_chips;
+extern struct pmx_dev spear13xx_pmx_gmii;
+extern struct pmx_dev spear13xx_pmx_nand_8bit;
+extern struct pmx_dev spear13xx_pmx_nand_16bit;
+extern struct pmx_dev spear13xx_pmx_keyboard_6x6;
+extern struct pmx_dev spear13xx_pmx_keyboard_9x9;
+extern struct pmx_dev spear13xx_pmx_uart0;
+extern struct pmx_dev spear13xx_pmx_uart0_modem;
+extern struct pmx_dev spear13xx_pmx_gpt_0_1;
+extern struct pmx_dev spear13xx_pmx_gpt_0_2;
+extern struct pmx_dev spear13xx_pmx_gpt_1_1;
+extern struct pmx_dev spear13xx_pmx_gpt_1_2;
+extern struct pmx_dev spear13xx_pmx_mcif;
+extern struct pmx_dev spear13xx_pmx_sdhci;
+extern struct pmx_dev spear13xx_pmx_cf;
+extern struct pmx_dev spear13xx_pmx_xd;
+#endif
+
+#if defined(CONFIG_CPU_SPEAR1310_REVA)
+#define SPEAR1310_REVA_FUNC_CNTL_0	UL(0x6C800000)
+
+#define SPEAR1310_REVA_PMX_SMII_MASK	(1 << 24)	/* Func cntl reg0 */
+#define SPEAR1310_REVA_PMX_EGPIO7_MASK	(1 << 2)	/* Pcm cfg reg */
+
+extern struct pmx_dev spear1310_reva_pmx_uart1_modem;
+extern struct pmx_dev spear1310_reva_pmx_uart_1;
+extern struct pmx_dev spear1310_reva_pmx_uart_2;
+extern struct pmx_dev spear1310_reva_pmx_uart_3_4_5;
+extern struct pmx_dev spear1310_reva_pmx_rs485_hdlc_1_2;
+extern struct pmx_dev spear1310_reva_pmx_tdm_hdlc_1_2;
+extern struct pmx_dev spear1310_reva_pmx_nand32bit;
+extern struct pmx_dev spear1310_reva_pmx_fsmc16bit_4_chips;
+extern struct pmx_dev spear1310_reva_pmx_fsmc32bit_4_chips;
+extern struct pmx_dev spear1310_reva_pmx_gmii1;
+extern struct pmx_dev spear1310_reva_pmx_rgmii;
+extern struct pmx_dev spear1310_reva_pmx_i2c1;
+extern struct pmx_dev spear1310_reva_pmx_smii_0_1_2;
+extern struct pmx_dev spear1310_reva_pmx_can;
+#endif
+
+#ifdef CONFIG_CPU_SPEAR1310
+
+/* PCI Macros */
+#define SPEAR1310_PMX_PCI_REG0_MASK (SPEAR13XX_PMX_MCI_DATA8_15_MASK)
+#define SPEAR1310_PMX_PCI_REG1_MASK (SPEAR13XX_PMX_SMINCS2_MASK | \
+		SPEAR13XX_PMX_SMINCS3_MASK | SPEAR13XX_PMX_CLCD2_MASK | \
+		SPEAR13XX_PMX_KBD_ROWCOL68_MASK | \
+		SPEAR13XX_PMX_EGPIO_1_GRP_MASK | SPEAR13XX_PMX_GPT0_TMR1_MASK |\
+		SPEAR13XX_PMX_GPT0_TMR2_MASK | SPEAR13XX_PMX_GPT1_TMR1_MASK | \
+		SPEAR13XX_PMX_GPT1_TMR2_MASK | SPEAR13XX_PMX_I2S2_MASK | \
+		SPEAR13XX_PMX_NFCE2_MASK)
+#define SPEAR1310_PMX_PCI_REG2_MASK (SPEAR13XX_PMX_TOUCH_XY_MASK | \
+		SPEAR13XX_PMX_SSP0_CS0_MASK | SPEAR13XX_PMX_SSP0_CS1_2_MASK)
+
+/* SMII Macros */
+#define SPEAR1310_PMX_SMII_0_1_2_MASK (SPEAR13XX_PMX_CLCD2_MASK | \
+		SPEAR13XX_PMX_KBD_ROWCOL68_MASK)
+
+/* RGMII Macros */
+#define SPEAR1310_PMX_RGMII_REG0_MASK (SPEAR13XX_PMX_MCI_DATA8_15_MASK | \
+		SPEAR13XX_PMX_GMIICOL_CRS_XFERER_MIITXCLK_MASK | \
+		SPEAR13XX_PMX_GMIID47_MASK)
+#define SPEAR1310_PMX_RGMII_REG1_MASK (SPEAR13XX_PMX_KBD_ROWCOL68_MASK | \
+		SPEAR13XX_PMX_EGPIO_1_GRP_MASK | SPEAR13XX_PMX_KBD_ROW1_MASK | \
+		SPEAR13XX_PMX_KBD_ROW0_MASK | SPEAR13XX_PMX_NFCE2_MASK)
+#define SPEAR1310_PMX_RGMII_REG2_MASK (SPEAR13XX_PMX_TOUCH_XY_MASK | \
+		SPEAR13XX_PMX_SSP0_CS0_MASK | SPEAR13XX_PMX_SSP0_CS1_2_MASK)
+
+extern struct pmx_dev spear1310_pmx_uart_1_dis_i2c;
+extern struct pmx_dev spear1310_pmx_uart_1_dis_sd;
+extern struct pmx_dev spear1310_pmx_uart_2_3;
+extern struct pmx_dev spear1310_pmx_uart_4;
+extern struct pmx_dev spear1310_pmx_uart_5;
+extern struct pmx_dev spear1310_pmx_rs485_0_1_tdm_0_1;
+extern struct pmx_dev spear1310_pmx_i2c_1_2;
+extern struct pmx_dev spear1310_pmx_i2c3_dis_smi_clcd;
+extern struct pmx_dev spear1310_pmx_i2c3_dis_sd_i2s1;
+extern struct pmx_dev spear1310_pmx_i2c_4_5_dis_smi;
+extern struct pmx_dev spear1310_pmx_i2c4_dis_sd;
+extern struct pmx_dev spear1310_pmx_i2c5_dis_sd;
+extern struct pmx_dev spear1310_pmx_i2c_6_7_dis_kbd;
+extern struct pmx_dev spear1310_pmx_i2c6_dis_sd;
+extern struct pmx_dev spear1310_pmx_i2c7_dis_sd;
+extern struct pmx_dev spear1310_pmx_rgmii;
+extern struct pmx_dev spear1310_pmx_can0_dis_nor;
+extern struct pmx_dev spear1310_pmx_can0_dis_sd;
+extern struct pmx_dev spear1310_pmx_can1_dis_sd;
+extern struct pmx_dev spear1310_pmx_can1_dis_kbd;
+extern struct pmx_dev spear1310_pmx_pci;
+extern struct pmx_dev spear1310_pmx_smii_0_1_2;
+extern struct pmx_dev spear1310_pmx_ssp1_dis_kbd;
+extern struct pmx_dev spear1310_pmx_ssp1_dis_sd;
+extern struct pmx_dev spear1310_pmx_gpt64;
+extern struct pmx_dev spear1310_pmx_ras_mii_txclk;
+extern struct pmx_dev spear1310_pmx_pcie0;
+extern struct pmx_dev spear1310_pmx_pcie1;
+extern struct pmx_dev spear1310_pmx_pcie2;
+extern struct pmx_dev spear1310_pmx_sata0;
+extern struct pmx_dev spear1310_pmx_sata1;
+extern struct pmx_dev spear1310_pmx_sata2;
+#endif
+
+#if defined(CONFIG_CPU_SPEAR1340)
+/* pad mux declarations */
+/*
+ * In SPEAr1340 there are two levels of pad muxing
+ * - pads as gpio OR peripherals
+ * - If peripherals, then primary OR alternate peripheral.
+ */
+
+/*
+ * Macro's for first level of pmx - pads as gpio OR peripherals
+ * There are 8 registers with 32 bits each for handling gpio pads, register 8
+ * has only 26 relevant bits
+ */
+#define SPEAR1340_PMX_FSMC_16_BIT_AND_KBD_ROW_COL_REG1_MASK	0x00000FFE
+#define SPEAR1340_PMX_UART0_ENH_AND_GPT_REG1_MASK		0x0003F000
+#define SPEAR1340_PMX_PWM1_AND_KBD_COL5_REG1_MASK		0x00040000
+#define SPEAR1340_PMX_I2C1_REG1_MASK				0x01080000
+#define SPEAR1340_PMX_SPDIF_IN_REG1_MASK			0x00100000
+#define SPEAR1340_PMX_PWM2_AND_GPT0_TMR0_CPT_REG1_MASK		0x00400000
+#define SPEAR1340_PMX_PWM3_AND_GPT0_TMR1_CLK_REG1_MASK		0x00800000
+#define SPEAR1340_PMX_PWM0_AND_SSP0_CS1_REG1_MASK		0x02000000
+#define SPEAR1340_PMX_VIP_AND_CAM3_REG1_MASK			0xFC200000
+#define SPEAR1340_PMX_VIP_AND_CAM3_REG2_MASK			0x0000000F
+#define SPEAR1340_PMX_VIP_REG2_MASK				0x00001EF0
+#define SPEAR1340_PMX_VIP_AND_CAM2_REG2_MASK			0x007FE100
+#define SPEAR1340_PMX_VIP_AND_CAM1_REG2_MASK			0xFF800000
+#define SPEAR1340_PMX_VIP_AND_CAM1_REG3_MASK			0x00000003
+#define SPEAR1340_PMX_VIP_AND_CAM0_REG3_MASK			0x00001FFC
+#define SPEAR1340_PMX_SMI_REG3_MASK				0x0021E000
+#define SPEAR1340_PMX_SSP0_REG3_MASK				0x001E0000
+#define SPEAR1340_PMX_TS_AND_SSP0_CS2_REG3_MASK			0x00400000
+#define SPEAR1340_PMX_UART0_REG3_MASK				0x01800000
+#define SPEAR1340_PMX_UART1_REG3_MASK				0x06000000
+#define SPEAR1340_PMX_I2S_IN_REG3_MASK				0xF8000000
+#define SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG4_MASK		0x000001FE
+#define SPEAR1340_PMX_I2S_OUT_REG4_MASK				0x000001EF
+#define SPEAR1340_PMX_I2S_IN_REG4_MASK				0x00000010
+#define SPEAR1340_PMX_GMAC_REG4_MASK				0xFFFFFE00
+#define SPEAR1340_PMX_GMAC_REG5_MASK				0x0000001F
+#define SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG5_MASK		0x7FFFFF20
+#define SPEAR1340_PMX_SSP0_CS3_REG5_MASK			0x00000020
+#define SPEAR1340_PMX_I2C0_REG5_MASK				0x000000C0
+#define SPEAR1340_PMX_CEC0_REG5_MASK				0x00000100
+#define SPEAR1340_PMX_CEC1_REG5_MASK				0x00000200
+#define SPEAR1340_PMX_SPDIF_OUT_REG5_MASK			0x00000400
+#define SPEAR1340_PMX_CLCD_REG5_MASK				0x7FFFF800
+#define SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG5_MASK		0x80000000
+#define SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG6_MASK		0xFFFFFFFF
+#define SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG7_MASK		0x00000001
+#define SPEAR1340_PMX_FSMC_PNOR_AND_MCIF_REG7_MASK		0x073FFFFE
+#define SPEAR1340_PMX_MCIF_REG7_MASK				0xF8C00000
+#define SPEAR1340_PMX_MCIF_REG8_MASK				0x000043FF
+#define SPEAR1340_PMX_FSMC_8BIT_REG8_MASK			0x07FFBC00
+
+/* macro's for making pads as gpio's */
+#define SPEAR1340_PMX_PADS_AS_GPIO_REG1_MASK			0xFFFFFFFE
+#define SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK			0xFFFFFFFF
+#define SPEAR1340_PMX_PADS_AS_GPIO_REG8_MASK			0x07FFFFFF
+
+/* Macro's for second level of pmx - pads as primary OR alternate peripheral */
+/* Write 0 to enable FSMC_16_BIT */
+#define SPEAR1340_PMX_KBD_ROW_COL_MASK		(1 << 0)
+
+/* Write 0 to enable UART0_ENH */
+#define SPEAR1340_PMX_GPT_MASK			(1 << 1) /* Only clk & cpt */
+
+/* Write 0 to enable PWM1 */
+#define SPEAR1340_PMX_KBD_COL5_MASK		(1 << 2)
+
+/* Write 0 to enable PWM2 */
+#define SPEAR1340_PMX_GPT0_TMR0_CPT_MASK	(1 << 3) /* Only clk & cpt */
+
+/* Write 0 to enable PWM3 */
+#define SPEAR1340_PMX_GPT0_TMR1_CLK_MASK	(1 << 4) /* Only clk & cpt */
+
+/* Write 0 to enable PWM0 */
+#define SPEAR1340_PMX_SSP0_CS1_MASK		(1 << 5)
+
+/* Write 0 to enable VIP */
+#define SPEAR1340_PMX_CAM3_MASK			(1 << 6)
+
+/* Write 0 to enable VIP */
+#define SPEAR1340_PMX_CAM2_MASK			(1 << 7)
+
+/* Write 0 to enable VIP */
+#define SPEAR1340_PMX_CAM1_MASK			(1 << 8)
+
+/* Write 0 to enable VIP */
+#define SPEAR1340_PMX_CAM0_MASK			(1 << 9)
+
+/* Write 0 to enable TS */
+#define SPEAR1340_PMX_SSP0_CS2_MASK		(1 << 10)
+
+/* Write 0 to enable FSMC PNOR */
+#define SPEAR1340_PMX_MCIF_MASK			(1 << 11)
+
+/* Write 0 to enable CLCD */
+#define SPEAR1340_PMX_ARM_TRACE_MASK		(1 << 12)
+
+/* Write 0 to enable I2S, SSP0_CS2, CEC0, 1, SPDIF out, CLCD */
+#define SPEAR1340_PMX_MIPHY_DBG_MASK		(1 << 13)
+
+extern struct pmx_dev clcd_pmx_plgpios;
+extern struct pmx_dev spear1340_pmx_pads_as_gpio;
+extern struct pmx_dev spear1340_pmx_fsmc_8bit;
+extern struct pmx_dev spear1340_pmx_fsmc_16bit;
+extern struct pmx_dev spear1340_pmx_keyboard_row_col;
+extern struct pmx_dev spear1340_pmx_keyboard_col5;
+extern struct pmx_dev spear1340_pmx_uart0_enh;
+extern struct pmx_dev spear1340_pmx_i2c1;
+extern struct pmx_dev spear1340_pmx_spdif_in;
+extern struct pmx_dev spear1340_pmx_gpt_0_1;
+extern struct pmx_dev spear1340_pmx_pwm0;
+extern struct pmx_dev spear1340_pmx_pwm1;
+extern struct pmx_dev spear1340_pmx_pwm2;
+extern struct pmx_dev spear1340_pmx_pwm3;
+extern struct pmx_dev spear1340_pmx_ssp0_cs1;
+extern struct pmx_dev spear1340_pmx_vip_mux_cam0;
+extern struct pmx_dev spear1340_pmx_vip_mux_cam1;
+extern struct pmx_dev spear1340_pmx_vip_mux_cam2;
+extern struct pmx_dev spear1340_pmx_vip_mux_cam3;
+extern struct pmx_dev spear1340_pmx_cam0;
+extern struct pmx_dev spear1340_pmx_cam1;
+extern struct pmx_dev spear1340_pmx_cam2;
+extern struct pmx_dev spear1340_pmx_cam3;
+extern struct pmx_dev spear1340_pmx_smi;
+extern struct pmx_dev spear1340_pmx_ssp0;
+extern struct pmx_dev spear1340_pmx_ssp0_cs2;
+extern struct pmx_dev spear1340_pmx_uart0;
+extern struct pmx_dev spear1340_pmx_uart1;
+extern struct pmx_dev spear1340_pmx_i2s_in;
+extern struct pmx_dev spear1340_pmx_i2s_out;
+extern struct pmx_dev spear1340_pmx_gmac;
+extern struct pmx_dev spear1340_pmx_ssp0_cs3;
+extern struct pmx_dev spear1340_pmx_i2c0;
+extern struct pmx_dev spear1340_pmx_cec0;
+extern struct pmx_dev spear1340_pmx_cec1;
+extern struct pmx_dev spear1340_pmx_spdif_out;
+extern struct pmx_dev spear1340_pmx_fsmc_pnor;
+extern struct pmx_dev spear1340_pmx_mcif;
+extern struct pmx_dev spear1340_pmx_sdhci;
+extern struct pmx_dev spear1340_pmx_cf;
+extern struct pmx_dev spear1340_pmx_xd;
+extern struct pmx_dev spear1340_pmx_clcd;
+extern struct pmx_dev spear1340_pmx_clcd_gpio_pd;
+extern struct pmx_dev spear1340_pmx_arm_trace;
+extern struct pmx_dev spear1340_pmx_devs_grp;
+extern struct pmx_dev spear1340_pmx_miphy_dbg;
+extern struct pmx_dev spear1340_pmx_gmii;
+extern struct pmx_dev spear1340_pmx_rgmii;
+extern struct pmx_dev spear1340_pmx_rmii;
+extern struct pmx_dev spear1340_pmx_sgmii;
+extern struct pmx_dev spear1340_pmx_pcie;
+extern struct pmx_dev spear1340_pmx_sata;
+#endif
+
+/*
+ * Each GPT has 2 timer channels
+ * Following GPT channels will be used as clock source and clockevent
+ */
+#define SPEAR_GPT0_BASE		SPEAR13XX_GPT0_BASE
+#define SPEAR_GPT0_CHAN0_IRQ	SPEAR13XX_IRQ_GPT0_TMR0
+#define SPEAR_GPT0_CHAN1_IRQ	SPEAR13XX_IRQ_GPT0_TMR1
+
+/* Add spear13xx family device structure declarations here */
+extern struct amba_device spear13xx_gpio_device[];
+extern struct amba_device spear13xx_ssp_device;
+extern struct amba_device spear13xx_uart_device;
+extern struct platform_device spear13xx_adc_device;
+extern struct platform_device spear13xx_cf_device;
+extern struct platform_device spear13xx_db9000_clcd_device;
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+extern struct platform_device spear13xx_device_gpiokeys;
+#endif
+extern struct platform_device spear13xx_dmac_device[];
+extern struct platform_device spear13xx_ehci0_device;
+extern struct platform_device spear13xx_ehci1_device;
+extern struct platform_device spear13xx_eth_device;
+extern struct platform_device spear13xx_fsmc_nor_device;
+extern struct platform_device spear13xx_i2c_device;
+extern struct platform_device spear13xx_kbd_device;
+extern struct platform_device spear13xx_nand_device;
+extern struct platform_device spear13xx_ohci0_device;
+extern struct platform_device spear13xx_ohci1_device;
+extern struct platform_device spear13xx_pmu_device;
+extern struct platform_device spear13xx_pcie_gadget0_device;
+extern struct platform_device spear13xx_pcie_host0_device;
+extern struct platform_device spear13xx_pcm_device;
+extern struct platform_device spear13xx_rtc_device;
+extern struct platform_device spear13xx_sdhci_device;
+extern struct platform_device spear13xx_smi_device;
+extern struct platform_device spear13xx_thermal_device;
+extern struct platform_device spear13xx_wdt_device;
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+extern struct platform_device spear13xx_cpufreq_device;
+extern struct platform_device spear13xx_i2s0_device;
+extern struct platform_device spear13xx_i2s1_device;
+extern struct platform_device spear13xx_jpeg_device;
+extern struct platform_device spear13xx_pcie_gadget1_device;
+extern struct platform_device spear13xx_pcie_gadget2_device;
+extern struct platform_device spear13xx_pcie_host1_device;
+extern struct platform_device spear13xx_pcie_host2_device;
+#endif
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900)
+extern struct platform_device spear13xx_udc_device;
+#endif
+
+extern struct sys_timer spear13xx_timer;
+
+/* Add spear13xx structure declarations here */
+extern struct dw_dma_slave cf_dma_priv;
+extern struct dw_dma_slave nand_read_dma_priv;
+extern struct dw_dma_slave nand_write_dma_priv;
+
+/* Add spear13xx family function declarations here */
+int audio_clk_config(struct i2s_clk_config_data *config);
+bool dw_dma_filter(struct dma_chan *chan, void *slave);
+void __init spear13xx_clk_init(void);
+void __init i2c_register_default_devices(void);
+void spear_restart(char, const char *);
+void __init spear_setup_timer(void);
+void __init spear13xx_map_io(void);
+void __init spear13xx_init_irq(void);
+void __init spear13xx_init(void);
+void __init nand_mach_init(u32 busw);
+void nand_select_bank(u32 bank, u32 busw);
+void spear13xx_l2x0_init(void);
+int spear13xx_eth_phy_clk_cfg(struct platform_device *);
+void spear13xx_secondary_startup(void);
+void spear13xx_panel_fixup(struct meminfo *mi);
+void spear13xx_panel_init(struct platform_device *pdev);
+unsigned long reserve_mem(struct meminfo *mi, unsigned long size);
+
+/* spear1300 declarations */
+#ifdef CONFIG_CPU_SPEAR1300
+/* Add spear1300 machine function declarations here */
+void __init spear1300_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count);
+
+#endif /* CONFIG_CPU_SPEAR1300 */
+
+/* spear1310_reva declarations */
+#ifdef CONFIG_CPU_SPEAR1310_REVA
+/* Add spear1310_reva machine device structure declarations here */
+extern struct amba_device spear1310_reva_uart1_device;
+extern struct amba_device spear1310_reva_uart2_device;
+extern struct amba_device spear1310_reva_uart3_device;
+extern struct amba_device spear1310_reva_uart4_device;
+extern struct amba_device spear1310_reva_uart5_device;
+extern struct platform_device spear1310_reva_can0_device;
+extern struct platform_device spear1310_reva_can1_device;
+extern struct platform_device spear1310_reva_eth1_device;
+extern struct platform_device spear1310_reva_eth2_device;
+extern struct platform_device spear1310_reva_eth3_device;
+extern struct platform_device spear1310_reva_eth4_device;
+extern struct platform_device spear1310_reva_i2c1_device;
+extern struct platform_device spear1310_reva_plgpio_device;
+extern struct platform_device spear1310_reva_ras_fsmc_nor_device;
+extern struct platform_device spear1310_reva_rs485_0_device;
+extern struct platform_device spear1310_reva_rs485_1_device;
+extern struct platform_device spear1310_reva_tdm_hdlc_0_device;
+extern struct platform_device spear1310_reva_tdm_hdlc_1_device;
+
+/* Add spear1310_reva machine function declarations here */
+void __init spear1310_reva_init(struct pmx_mode *pmx_mode,
+		struct pmx_dev **pmx_devs, u8 pmx_dev_count);
+void __init spear1310_reva_map_io(void);
+int spear1310_reva_eth_phy_clk_cfg(struct platform_device *);
+
+#endif /* CONFIG_CPU_SPEAR1310_REVA */
+
+/* spear1310 declarations */
+#ifdef CONFIG_CPU_SPEAR1310
+/* Add spear1310 machine device structure declarations here */
+extern struct amba_device spear1310_ssp1_device;
+extern struct amba_device spear1310_uart1_device;
+extern struct amba_device spear1310_uart2_device;
+extern struct amba_device spear1310_uart3_device;
+extern struct amba_device spear1310_uart4_device;
+extern struct amba_device spear1310_uart5_device;
+extern struct platform_device spear1310_can0_device;
+extern struct platform_device spear1310_can1_device;
+extern struct platform_device spear1310_i2c1_device;
+extern struct platform_device spear1310_i2c2_device;
+extern struct platform_device spear1310_i2c3_device;
+extern struct platform_device spear1310_i2c4_device;
+extern struct platform_device spear1310_i2c5_device;
+extern struct platform_device spear1310_i2c6_device;
+extern struct platform_device spear1310_i2c7_device;
+extern struct platform_device spear1310_nand_device;
+extern struct platform_device spear1310_otg_device;
+extern struct platform_device spear1310_plgpio_device;
+extern struct platform_device spear1310_rs485_0_device;
+extern struct platform_device spear1310_rs485_1_device;
+extern struct platform_device spear1310_sata0_device;
+extern struct platform_device spear1310_sata1_device;
+extern struct platform_device spear1310_sata2_device;
+extern struct platform_device spear1310_tdm_hdlc_0_device;
+extern struct platform_device spear1310_tdm_hdlc_1_device;
+
+/* Add spear1310 machine function declarations here */
+void __init spear1310_clk_init(void);
+void __init spear1310_init(struct pmx_mode *pmx_mode,
+		struct pmx_dev **pmx_devs, u8 pmx_dev_count);
+void __init spear1310_map_io(void);
+void spear1310_nand_select_bank(u32 bank, u32 busw);
+
+#endif /* CONFIG_CPU_SPEAR1310 */
+
+/* spear1340 declarations */
+#ifdef CONFIG_CPU_SPEAR1340
+/* Add spear1340 machine device structure declarations here */
+extern struct amba_device spear1340_uart1_device;
+extern struct platform_device spear1340_camif0_device;
+extern struct platform_device spear1340_camif1_device;
+extern struct platform_device spear1340_camif2_device;
+extern struct platform_device spear1340_camif3_device;
+extern struct platform_device spear1340_cec0_device;
+extern struct platform_device spear1340_cec1_device;
+extern struct platform_device spear1340_cpufreq_device;
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+extern struct platform_device spear1340_gpiokeys_device;
+#endif
+extern struct platform_device spear1340_i2c1_device;
+extern struct platform_device spear1340_i2s_play_device;
+extern struct platform_device spear1340_i2s_record_device;
+extern struct platform_device spear1340_nand_device;
+extern struct platform_device spear1340_otg_device;
+extern struct platform_device spear1340_phy0_device;
+extern struct platform_device spear1340_plgpio_device;
+extern struct platform_device spear1340_pwm_device;
+extern struct platform_device spear1340_sata0_device;
+extern struct platform_device spear1340_spdif_in_device;
+extern struct platform_device spear1340_spdif_out_device;
+extern struct platform_device spear1340_thermal_device;
+extern struct platform_device spear1340_vip_device;
+extern struct platform_device spear1340_device_mali_drm;
+extern struct platform_device spear1340_video_dec_device;
+
+/* Add spear1340 spi devices structure declaration */
+extern struct spi_board_info spear1340_evb_spi_m25p80;
+extern struct spi_board_info spear1340_evb_spi_stmpe610;
+extern struct spi_board_info spear1340_evb_spi_spidev;
+
+/* Add spear1340 i2c devices structure declaration */
+extern struct i2c_dev_info spear1340_evb_i2c_l3g4200d_gyr;
+extern struct i2c_dev_info spear1340_evb_i2c_eeprom0;
+extern struct i2c_dev_info spear1340_evb_i2c_eeprom1;
+extern struct i2c_dev_info spear1340_evb_i2c_sta529;
+
+int __init spear1340_pb_init(struct plug_board_info *pb_info);
+
+/* Add spear1340 machine function declarations here */
+void __init spear1340_clk_init(void);
+void __init spear1340_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count);
+void __init spear1340_map_io(void);
+void __init spear1340_pcie_board_init(struct device *dev);
+void config_clcd_gpio_pads(bool);
+
+#endif /* CONFIG_CPU_SPEAR1340 */
+
+/* spear900 declarations */
+#ifdef CONFIG_CPU_SPEAR900
+/* Add spear900 machine function declarations here */
+void __init spear900_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count);
+
+#endif /* CONFIG_CPU_SPEAR900 */
+
+#endif /* __MACH_GENERIC_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/gpio.h b/arch/arm/mach-spear13xx/include/mach/gpio.h
new file mode 100644
index 0000000..e858b39
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/gpio.h
@@ -0,0 +1,324 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/gpio.h
+ *
+ * GPIO macros for spear13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_GPIO_H
+#define __MACH_GPIO_H
+
+#ifdef CONFIG_MACH_SPEAR1340_EVB
+#include <linux/mfd/stmpe.h>
+#endif
+
+/**
+ * In Arch SPEAr13xx, plgpio gpio pins are grouped in number of four for
+ * interrupt registers. Every group of four gpio's is represented by one bit
+ * in IE and MIS registers. This routine returns same irq number for every pin
+ * belonging to same group.
+ * For arm gpio pins, this routine directly calls __gpio_to_irq routine.
+ * It returns the number of the IRQ signaled by this (input) GPIO,
+ * or a negative errno.
+ */
+#define PLGPIO_GROUP_SIZE	4
+
+#define GPIO0_0			0
+#define GPIO0_1			1
+#define GPIO0_2			2
+#define GPIO0_3			3
+#define GPIO0_4			4
+#define GPIO0_5			5
+#define GPIO0_6			6
+#define GPIO0_7			7
+
+#define GPIO1_0			8
+#define GPIO1_1			9
+#define GPIO1_2			10
+#define GPIO1_3			11
+#define GPIO1_4			12
+#define GPIO1_5			13
+#define GPIO1_6			14
+#define GPIO1_7			15
+
+#if defined(CONFIG_CPU_SPEAR1310_REVA) || defined(CONFIG_CPU_SPEAR1310) || \
+		defined(CONFIG_CPU_SPEAR1340)
+#define PLGPIO_0		16
+#define PLGPIO_1		17
+#define PLGPIO_2		18
+#define PLGPIO_3		19
+#define PLGPIO_4		20
+#define PLGPIO_5		21
+#define PLGPIO_6		22
+#define PLGPIO_7		23
+#define PLGPIO_8		24
+#define PLGPIO_9		25
+#define PLGPIO_10		26
+#define PLGPIO_11		27
+#define PLGPIO_12		28
+#define PLGPIO_13		29
+#define PLGPIO_14		30
+#define PLGPIO_15		31
+#define PLGPIO_16		32
+#define PLGPIO_17		33
+#define PLGPIO_18		34
+#define PLGPIO_19		35
+#define PLGPIO_20		36
+#define PLGPIO_21		37
+#define PLGPIO_22		38
+#define PLGPIO_23		39
+#define PLGPIO_24		40
+#define PLGPIO_25		41
+#define PLGPIO_26		42
+#define PLGPIO_27		43
+#define PLGPIO_28		44
+#define PLGPIO_29		45
+#define PLGPIO_30		46
+#define PLGPIO_31		47
+#define PLGPIO_32		48
+#define PLGPIO_33		49
+#define PLGPIO_34		50
+#define PLGPIO_35		51
+#define PLGPIO_36		52
+#define PLGPIO_37		53
+#define PLGPIO_38		54
+#define PLGPIO_39		55
+#define PLGPIO_40		56
+#define PLGPIO_41		57
+#define PLGPIO_42		58
+#define PLGPIO_43		59
+#define PLGPIO_44		60
+#define PLGPIO_45		61
+#define PLGPIO_46		62
+#define PLGPIO_47		63
+#define PLGPIO_48		64
+#define PLGPIO_49		65
+#define PLGPIO_50		66
+#define PLGPIO_51		67
+#define PLGPIO_52		68
+#define PLGPIO_53		69
+#define PLGPIO_54		70
+#define PLGPIO_55		71
+#define PLGPIO_56		72
+#define PLGPIO_57		73
+#define PLGPIO_58		74
+#define PLGPIO_59		75
+#define PLGPIO_60		76
+#define PLGPIO_61		77
+#define PLGPIO_62		78
+#define PLGPIO_63		79
+#define PLGPIO_64		80
+#define PLGPIO_65		81
+#define PLGPIO_66		82
+#define PLGPIO_67		83
+#define PLGPIO_68		84
+#define PLGPIO_69		85
+#define PLGPIO_70		86
+#define PLGPIO_71		87
+#define PLGPIO_72		88
+#define PLGPIO_73		89
+#define PLGPIO_74		90
+#define PLGPIO_75		91
+#define PLGPIO_76		92
+#define PLGPIO_77		93
+#define PLGPIO_78		94
+#define PLGPIO_79		95
+#define PLGPIO_80		96
+#define PLGPIO_81		97
+#define PLGPIO_82		98
+#define PLGPIO_83		99
+#define PLGPIO_84		100
+#define PLGPIO_85		101
+#define PLGPIO_86		102
+#define PLGPIO_87		103
+#define PLGPIO_88		104
+#define PLGPIO_89		105
+#define PLGPIO_90		106
+#define PLGPIO_91		107
+#define PLGPIO_92		108
+#define PLGPIO_93		109
+#define PLGPIO_94		110
+#define PLGPIO_95		111
+#define PLGPIO_96		112
+#define PLGPIO_97		113
+#define PLGPIO_98		114
+#define PLGPIO_99		115
+#define PLGPIO_100		116
+#define PLGPIO_101		117
+#define PLGPIO_102		118
+#define PLGPIO_103		119
+#define PLGPIO_104		120
+#define PLGPIO_105		121
+#define PLGPIO_106		122
+#define PLGPIO_107		123
+#define PLGPIO_108		124
+#define PLGPIO_109		125
+#define PLGPIO_110		126
+#define PLGPIO_111		127
+#define PLGPIO_112		128
+#define PLGPIO_113		129
+#define PLGPIO_114		130
+#define PLGPIO_115		131
+#define PLGPIO_116		132
+#define PLGPIO_117		133
+#define PLGPIO_118		134
+#define PLGPIO_119		135
+#define PLGPIO_120		136
+#define PLGPIO_121		137
+#define PLGPIO_122		138
+#define PLGPIO_123		139
+#define PLGPIO_124		140
+#define PLGPIO_125		141
+#define PLGPIO_126		142
+#define PLGPIO_127		143
+#define PLGPIO_128		144
+#define PLGPIO_129		145
+#define PLGPIO_130		146
+#define PLGPIO_131		147
+#define PLGPIO_132		148
+#define PLGPIO_133		149
+#define PLGPIO_134		150
+#define PLGPIO_135		151
+#define PLGPIO_136		152
+#define PLGPIO_137		153
+#define PLGPIO_138		154
+#define PLGPIO_139		155
+#define PLGPIO_140		156
+#define PLGPIO_141		157
+#define PLGPIO_142		158
+#define PLGPIO_143		159
+#define PLGPIO_144		160
+#define PLGPIO_145		161
+#define PLGPIO_146		162
+#define PLGPIO_147		163
+#define PLGPIO_148		164
+#define PLGPIO_149		165
+#define PLGPIO_150		166
+#define PLGPIO_151		167
+#define PLGPIO_152		168
+#define PLGPIO_153		169
+#define PLGPIO_154		170
+#define PLGPIO_155		171
+#define PLGPIO_156		172
+#define PLGPIO_157		173
+#define PLGPIO_158		174
+#define PLGPIO_159		175
+#define PLGPIO_160		176
+#define PLGPIO_161		177
+#define PLGPIO_162		178
+#define PLGPIO_163		179
+#define PLGPIO_164		180
+#define PLGPIO_165		181
+#define PLGPIO_166		182
+#define PLGPIO_167		183
+#define PLGPIO_168		184
+#define PLGPIO_169		185
+#define PLGPIO_170		186
+#define PLGPIO_171		187
+#define PLGPIO_172		188
+#define PLGPIO_173		189
+#define PLGPIO_174		190
+#define PLGPIO_175		191
+#define PLGPIO_176		192
+#define PLGPIO_177		193
+#define PLGPIO_178		194
+#define PLGPIO_179		195
+#define PLGPIO_180		196
+#define PLGPIO_181		197
+#define PLGPIO_182		198
+#define PLGPIO_183		199
+#define PLGPIO_184		200
+#define PLGPIO_185		201
+#define PLGPIO_186		202
+#define PLGPIO_187		203
+#define PLGPIO_188		204
+#define PLGPIO_189		205
+#define PLGPIO_190		206
+#define PLGPIO_191		207
+#define PLGPIO_192		208
+#define PLGPIO_193		209
+#define PLGPIO_194		210
+#define PLGPIO_195		211
+#define PLGPIO_196		212
+#define PLGPIO_197		213
+#define PLGPIO_198		214
+#define PLGPIO_199		215
+#define PLGPIO_200		216
+#define PLGPIO_201		217
+#define PLGPIO_202		218
+#define PLGPIO_203		219
+#define PLGPIO_204		220
+#define PLGPIO_205		221
+#define PLGPIO_206		222
+#define PLGPIO_207		223
+#define PLGPIO_208		224
+#define PLGPIO_209		225
+#define PLGPIO_210		226
+#define PLGPIO_211		227
+#define PLGPIO_212		228
+#define PLGPIO_213		229
+#define PLGPIO_214		230
+#define PLGPIO_215		231
+#define PLGPIO_216		232
+#define PLGPIO_217		233
+#define PLGPIO_218		234
+#define PLGPIO_219		235
+#define PLGPIO_220		236
+#define PLGPIO_221		237
+#define PLGPIO_222		238
+#define PLGPIO_223		239
+#define PLGPIO_224		240
+#define PLGPIO_225		241
+#define PLGPIO_226		242
+#define PLGPIO_227		243
+#define PLGPIO_228		244
+#define PLGPIO_229		245
+#define PLGPIO_230		246
+#define PLGPIO_231		247
+#define PLGPIO_232		248
+#define PLGPIO_233		249
+#define PLGPIO_234		250
+#define PLGPIO_235		251
+#define PLGPIO_236		252
+#define PLGPIO_237		253
+#define PLGPIO_238		254
+#define PLGPIO_239		255
+#define PLGPIO_240		256
+#define PLGPIO_241		257
+#define PLGPIO_242		258
+#define PLGPIO_243		259
+#define PLGPIO_244		260
+#define PLGPIO_245		261
+#define PLGPIO_246		262
+#define PLGPIO_247		263
+#define PLGPIO_248		264
+#define PLGPIO_249		265
+
+#endif /* CPU_SPEAR1310_REVA, CPU_SPEAR1310, CPU_SPEAR1340 */
+
+#ifdef CONFIG_MACH_SPEAR1340_EVB
+#define SPEAR_STMPE801_GPIO_BASE	(PLGPIO_249 + 1)
+#define SPEAR_STMPE801_GPIO_END	(SPEAR_STMPE801_GPIO_BASE + STMPE_NR_GPIOS - 1)
+#define STMPE801_GPIO_0		(SPEAR_STMPE801_GPIO_BASE + 0)
+#define STMPE801_GPIO_1		(SPEAR_STMPE801_GPIO_BASE + 1)
+#define STMPE801_GPIO_2		(SPEAR_STMPE801_GPIO_BASE + 2)
+#define STMPE801_GPIO_3		(SPEAR_STMPE801_GPIO_BASE + 3)
+#define STMPE801_GPIO_4		(SPEAR_STMPE801_GPIO_BASE + 4)
+#define STMPE801_GPIO_5		(SPEAR_STMPE801_GPIO_BASE + 5)
+#define STMPE801_GPIO_6		(SPEAR_STMPE801_GPIO_BASE + 6)
+#define STMPE801_GPIO_7		(SPEAR_STMPE801_GPIO_BASE + 7)
+#define ARCH_NR_GPIOS		(SPEAR_STMPE801_GPIO_END + 1)
+#else
+/* spear 13xx have 266 gpio pins */
+#define ARCH_NR_GPIOS		(PLGPIO_249 + 1)
+#endif
+
+#include <plat/gpio.h>
+
+#endif /* __MACH_GPIO_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/hardware.h b/arch/arm/mach-spear13xx/include/mach/hardware.h
new file mode 100644
index 0000000..153fc16
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/hardware.h
@@ -0,0 +1,40 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/hardware.h
+ *
+ * Hardware definitions for spear13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_HARDWARE_H
+#define __MACH_HARDWARE_H
+
+#include <plat/hardware.h>
+#include <mach/spear.h>
+
+/* Vitual to physical translation of statically mapped space
+ *
+ * Physical			Virtual
+ * 0x6C800000-0X6C801000	0xF6C80000-0XF6C81000
+ * 0x80000000-0X80010000	0xF8000000-0XF8010000
+ * 0x90000000-0X90010000	0xF9000000-0XF9010000
+ * 0xB3800000-0XB3808000	0xFB380000-0XFB388000
+ * 0xE0000000-0XE0001000	0xFE000000-0XFE001000
+ * 0xE0700000-0XE0702000	0xFE070000-0XFE072000
+ * 0xE0800000-0XE0801000	0xFE080000-0XFE081000
+ * 0xEC800000-0XEC802000	0xFEC80000-0XFEC82000
+ * 0xED000000-0XED001000	0xFED00000-0XFED01000
+ */
+
+#define IO_ADDRESS(x)		(((x) & 0x0000FFFF) | (((x) & 0xFFF00000) >> 4) | \
+				0xF0000000)
+
+/* typesafe io address */
+#define __io_address(n)		__io(IO_ADDRESS(n))
+
+#endif /* __MACH_HARDWARE_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/io.h b/arch/arm/mach-spear13xx/include/mach/io.h
new file mode 100644
index 0000000..2fe3503
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/io.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/io.h
+ *
+ * IO definitions for spear13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_IO_H
+#define __MACH_IO_H
+
+#include <plat/io.h>
+
+#endif /* __MACH_IO_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/irqs.h b/arch/arm/mach-spear13xx/include/mach/irqs.h
new file mode 100644
index 0000000..727b790
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/irqs.h
@@ -0,0 +1,287 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/irqs.h
+ *
+ * IRQ helper macros for spear13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_IRQS_H
+#define __MACH_IRQS_H
+
+#include <linux/kernel.h>
+#include <linux/mfd/stmpe.h>
+#include <mach/gpio.h>
+
+/* IRQ definitions */
+/*
+ * SGI : ID0 - ID15
+ * PPI : ID16 - ID31
+ * SHPI : ID32 - ID224
+ */
+
+#define IRQ_LOCALTIMER		29
+#define IRQ_LOCALWDOG		30
+
+/* Shared Peripheral Interrupt (SHPI) */
+#define IRQ_SHPI_START		32
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+#define SPEAR13XX_IRQ_PLAY_I2S0		(IRQ_SHPI_START + 10)
+#define SPEAR13XX_IRQ_REC_I2S0		(IRQ_SHPI_START + 11)
+#endif
+
+#define SPEAR13XX_IRQ_PMU0		(IRQ_SHPI_START + 6)
+#define SPEAR13XX_IRQ_PMU1		(IRQ_SHPI_START + 7)
+
+#define SPEAR13XX_IRQ_ADC		(IRQ_SHPI_START + 12)
+#define SPEAR13XX_IRQ_CLCD		(IRQ_SHPI_START + 13)
+#define SPEAR13XX_IRQ_DMAC0_FLAG_0	(IRQ_SHPI_START + 14)
+#define SPEAR13XX_IRQ_DMAC0_FLAG_1	(IRQ_SHPI_START + 15)
+#define SPEAR13XX_IRQ_DMAC0_FLAG_2	(IRQ_SHPI_START + 16)
+#define SPEAR13XX_IRQ_DMAC0_FLAG_3	(IRQ_SHPI_START + 17)
+#define SPEAR13XX_IRQ_DMAC0_FLAG_4	(IRQ_SHPI_START + 18)
+#define SPEAR13XX_IRQ_DMAC0_COMBINED	(IRQ_SHPI_START + 19)
+#define SPEAR13XX_IRQ_FSMC0		(IRQ_SHPI_START + 20)
+#define SPEAR13XX_IRQ_FSMC1		(IRQ_SHPI_START + 21)
+#define SPEAR13XX_IRQ_FSMC2		(IRQ_SHPI_START + 22)
+#define SPEAR13XX_IRQ_FSMC3		(IRQ_SHPI_START + 23)
+#define SPEAR13XX_IRQ_GPIO0		(IRQ_SHPI_START + 24)
+#define SPEAR13XX_IRQ_GPIO1		(IRQ_SHPI_START + 25)
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+#define SPEAR13XX_IRQ_PLAY_I2S1		(IRQ_SHPI_START + 26)
+#define SPEAR13XX_IRQ_JPEG		(IRQ_SHPI_START + 27)
+#endif
+
+#define SPEAR13XX_IRQ_SDHCI		(IRQ_SHPI_START + 28)
+#define SPEAR13XX_IRQ_CF		(IRQ_SHPI_START + 29)
+#define SPEAR13XX_IRQ_SMI		(IRQ_SHPI_START + 30)
+#define SPEAR13XX_IRQ_SSP		(IRQ_SHPI_START + 31)
+#define SPEAR13XX_IRQ_C3		(IRQ_SHPI_START + 32)
+#define SPEAR13XX_IRQ_GETH_SBD		(IRQ_SHPI_START + 33)
+#define SPEAR13XX_IRQ_GETH_PMT		(IRQ_SHPI_START + 34)
+#define SPEAR13XX_IRQ_UART		(IRQ_SHPI_START + 35)
+#define SPEAR13XX_IRQ_RTC		(IRQ_SHPI_START + 36)
+#define SPEAR13XX_IRQ_GPT0_TMR0		(IRQ_SHPI_START + 37)
+#define SPEAR13XX_IRQ_GPT0_TMR1		(IRQ_SHPI_START + 38)
+#define SPEAR13XX_IRQ_GPT1_TMR0		(IRQ_SHPI_START + 39)
+#define SPEAR13XX_IRQ_GPT1_TMR1		(IRQ_SHPI_START + 40)
+#define SPEAR13XX_IRQ_I2C		(IRQ_SHPI_START + 41)
+#define SPEAR13XX_IRQ_GPT2_TMR0		(IRQ_SHPI_START + 42)
+#define SPEAR13XX_IRQ_GPT2_TMR1		(IRQ_SHPI_START + 43)
+#define SPEAR13XX_IRQ_GPT3_TMR0		(IRQ_SHPI_START + 44)
+#define SPEAR13XX_IRQ_GPT3_TMR1		(IRQ_SHPI_START + 45)
+
+#define SPEAR13XX_IRQ_KBD		(IRQ_SHPI_START + 52)
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+#define SPEAR13XX_IRQ_REC_I2S1		(IRQ_SHPI_START + 53)
+#endif
+
+#define SPEAR13XX_IRQ_DMAC1_FLAG_0	(IRQ_SHPI_START + 54)
+#define SPEAR13XX_IRQ_DMAC1_FLAG_1	(IRQ_SHPI_START + 55)
+#define SPEAR13XX_IRQ_DMAC1_FLAG_2	(IRQ_SHPI_START + 56)
+#define SPEAR13XX_IRQ_DMAC1_FLAG_3	(IRQ_SHPI_START + 57)
+#define SPEAR13XX_IRQ_DMAC1_FLAG_4	(IRQ_SHPI_START + 58)
+#define SPEAR13XX_IRQ_DMAC1_COMBINED	(IRQ_SHPI_START + 59)
+
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900)
+#define SPEAR13XX_IRQ_UDC		(IRQ_SHPI_START + 62)
+#define SPEAR13XX_IRQ_UPD		(IRQ_SHPI_START + 63)
+#endif
+
+#define SPEAR13XX_IRQ_USBH_EHCI0	(IRQ_SHPI_START + 64)
+#define SPEAR13XX_IRQ_USBH_OHCI0	(IRQ_SHPI_START + 65)
+#define SPEAR13XX_IRQ_USBH_EHCI1	(IRQ_SHPI_START + 66)
+#define SPEAR13XX_IRQ_USBH_OHCI1	(IRQ_SHPI_START + 67)
+#define SPEAR13XX_IRQ_PCIE0		(IRQ_SHPI_START + 68)
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+#define SPEAR13XX_IRQ_PCIE1		(IRQ_SHPI_START + 69)
+#define SPEAR13XX_IRQ_PCIE2		(IRQ_SHPI_START + 70)
+#endif
+
+/* Add spear1310_reva specific IRQs here */
+#ifdef CONFIG_CPU_SPEAR1310_REVA
+#define SPEAR1310_REVA_IRQ_FSMC_PC1		(IRQ_SHPI_START + 76)
+#define SPEAR1310_REVA_IRQ_FSMC_PC2		(IRQ_SHPI_START + 77)
+#define SPEAR1310_REVA_IRQ_FSMC_PC3		(IRQ_SHPI_START + 78)
+#define SPEAR1310_REVA_IRQ_FSMC_PC4		(IRQ_SHPI_START + 79)
+#define SPEAR1310_REVA_IRQ_RS4850		(IRQ_SHPI_START + 80)
+#define SPEAR1310_REVA_IRQ_RS4851		(IRQ_SHPI_START + 81)
+#define SPEAR1310_REVA_IRQ_CCAN0		(IRQ_SHPI_START + 82)
+#define SPEAR1310_REVA_IRQ_CCAN1		(IRQ_SHPI_START + 83)
+#define SPEAR1310_REVA_IRQ_TDM0			(IRQ_SHPI_START + 84)
+#define SPEAR1310_REVA_IRQ_TDM1			(IRQ_SHPI_START + 85)
+#define SPEAR1310_REVA_IRQ_UART1		(IRQ_SHPI_START + 86)
+#define SPEAR1310_REVA_IRQ_UART2		(IRQ_SHPI_START + 87)
+#define SPEAR1310_REVA_IRQ_UART3		(IRQ_SHPI_START + 88)
+#define SPEAR1310_REVA_IRQ_UART4		(IRQ_SHPI_START + 89)
+#define SPEAR1310_REVA_IRQ_UART5		(IRQ_SHPI_START + 90)
+#define SPEAR1310_REVA_IRQ_I2C_CNTR		(IRQ_SHPI_START + 91)
+#define SPEAR1310_REVA_IRQ_GETH1_SBD		(IRQ_SHPI_START + 92)
+#define SPEAR1310_REVA_IRQ_GETH1_PMT		(IRQ_SHPI_START + 93)
+#define SPEAR1310_REVA_IRQ_GETH2_SBD		(IRQ_SHPI_START + 94)
+#define SPEAR1310_REVA_IRQ_GETH2_PMT		(IRQ_SHPI_START + 95)
+#define SPEAR1310_REVA_IRQ_GETH3_SBD		(IRQ_SHPI_START + 96)
+#define SPEAR1310_REVA_IRQ_GETH3_PMT		(IRQ_SHPI_START + 97)
+#define SPEAR1310_REVA_IRQ_GETH4_SBD		(IRQ_SHPI_START + 98)
+#define SPEAR1310_REVA_IRQ_GETH4_PMT		(IRQ_SHPI_START + 99)
+#define SPEAR1310_REVA_IRQ_PLGPIO		(IRQ_SHPI_START + 100)
+#define SPEAR1310_REVA_IRQ_PCI_BRDG_HOST_FATAL	(IRQ_SHPI_START + 101)
+#define SPEAR1310_REVA_IRQ_PCI_INTA		(IRQ_SHPI_START + 102)
+#define SPEAR1310_REVA_IRQ_PCI_INTB		(IRQ_SHPI_START + 103)
+#define SPEAR1310_REVA_IRQ_PCI_INTC		(IRQ_SHPI_START + 104)
+#define SPEAR1310_REVA_IRQ_PCI_INTD		(IRQ_SHPI_START + 105)
+#define SPEAR1310_REVA_IRQ_PCI_ME_TO_ARM	(IRQ_SHPI_START + 106)
+#define SPEAR1310_REVA_IRQ_PCI_SERR_TO_ARM	(IRQ_SHPI_START + 107)
+#endif /* CONFIG_CPU_SPEAR1310_REVA */
+
+/* Add spear1310 specific IRQs here */
+#ifdef CONFIG_CPU_SPEAR1310
+#define SPEAR1310_IRQ_FSMC_FF		(IRQ_SHPI_START + 51) /* Fill FIFO */
+#define SPEAR1310_IRQ_UOC		(IRQ_SHPI_START + 62)
+#define SPEAR1310_IRQ_FSMC_CR		(IRQ_SHPI_START + 63) /* Code Ready */
+#define SPEAR1310_IRQ_SATA0		(IRQ_SHPI_START + 68)
+#define SPEAR1310_IRQ_SATA1		(IRQ_SHPI_START + 69)
+#define SPEAR1310_IRQ_SATA2		(IRQ_SHPI_START + 70)
+#define SPEAR1310_IRQ_GMAC		(IRQ_SHPI_START + 71)
+
+#define SPEAR1310_IRQ_CAN0		(IRQ_SHPI_START + 76)
+#define SPEAR1310_IRQ_CAN1		(IRQ_SHPI_START + 77)
+#define SPEAR1310_IRQ_RS485_0		(IRQ_SHPI_START + 78)
+#define SPEAR1310_IRQ_RS485_1		(IRQ_SHPI_START + 79)
+#define SPEAR1310_IRQ_TDM0		(IRQ_SHPI_START + 80)
+#define SPEAR1310_IRQ_TDM1		(IRQ_SHPI_START + 81)
+#define SPEAR1310_IRQ_UART1		(IRQ_SHPI_START + 82)
+#define SPEAR1310_IRQ_UART2		(IRQ_SHPI_START + 83)
+#define SPEAR1310_IRQ_UART3		(IRQ_SHPI_START + 84)
+#define SPEAR1310_IRQ_UART4		(IRQ_SHPI_START + 85)
+#define SPEAR1310_IRQ_UART5		(IRQ_SHPI_START + 86)
+#define SPEAR1310_IRQ_I2C1		(IRQ_SHPI_START + 87)
+#define SPEAR1310_IRQ_I2C2		(IRQ_SHPI_START + 88)
+#define SPEAR1310_IRQ_I2C3		(IRQ_SHPI_START + 89)
+#define SPEAR1310_IRQ_I2C4		(IRQ_SHPI_START + 90)
+#define SPEAR1310_IRQ_I2C5		(IRQ_SHPI_START + 91)
+#define SPEAR1310_IRQ_I2C6		(IRQ_SHPI_START + 92)
+#define SPEAR1310_IRQ_I2C7		(IRQ_SHPI_START + 93)
+#define SPEAR1310_IRQ_GPT64		(IRQ_SHPI_START + 94)
+#define SPEAR1310_IRQ_MAC1		(IRQ_SHPI_START + 95)
+#define SPEAR1310_IRQ_MAC2		(IRQ_SHPI_START + 96)
+#define SPEAR1310_IRQ_MAC3		(IRQ_SHPI_START + 97)
+#define SPEAR1310_IRQ_MAC4		(IRQ_SHPI_START + 98)
+#define SPEAR1310_IRQ_SSP1		(IRQ_SHPI_START + 99)
+#define SPEAR1310_IRQ_PLGPIO		(IRQ_SHPI_START + 100)
+#define SPEAR1310_IRQ_PCI_BRIDGE	(IRQ_SHPI_START + 101)
+#define SPEAR1310_IRQ_PCI_RST_IN	(IRQ_SHPI_START + 102)
+#define SPEAR1310_IRQ_PCI_BRIDGE_RDY	(IRQ_SHPI_START + 103)
+#define SPEAR1310_IRQ_PCI_INT_ABCD	(IRQ_SHPI_START + 104)
+#define SPEAR1310_IRQ_PCI_ME_TO_ARM	(IRQ_SHPI_START + 105)
+#define SPEAR1310_IRQ_PCI_SERR_TO_ARM	(IRQ_SHPI_START + 106)
+#endif /* CONFIG_CPU_SPEAR1310 */
+
+/* Add spear1340 specific IRQs here */
+#ifdef CONFIG_CPU_SPEAR1340
+#define SPEAR1340_IRQ_FSMC_FF		(IRQ_SHPI_START + 51) /* Fill FIFO */
+#define SPEAR1340_IRQ_UOC		(IRQ_SHPI_START + 62)
+#define SPEAR1340_IRQ_FSMC_CR		(IRQ_SHPI_START + 63) /* Code Ready */
+#define SPEAR1340_IRQ_GMAC		(IRQ_SHPI_START + 71)
+#define SPEAR1340_IRQ_SATA		(IRQ_SHPI_START + 72) /* SATA */
+#define SPEAR1340_IRQ_VIDEO_DEC		(IRQ_SHPI_START + 81)
+#define SPEAR1340_IRQ_VIDEO_ENC		(IRQ_SHPI_START + 82)
+#define SPEAR1340_IRQ_SPDIF_IN		(IRQ_SHPI_START + 84)
+#define SPEAR1340_IRQ_SPDIF_OUT		(IRQ_SHPI_START + 85)
+#define SPEAR1340_IRQ_VIP		(IRQ_SHPI_START + 86)
+#define SPEAR1340_IRQ_CAM0_CE		(IRQ_SHPI_START + 87) /* Camline End */
+#define SPEAR1340_IRQ_CAM0_FVE		(IRQ_SHPI_START + 88) /* Frame vsync */
+#define SPEAR1340_IRQ_CAM1_CE		(IRQ_SHPI_START + 89) /* Camline End */
+#define SPEAR1340_IRQ_CAM1_FVE		(IRQ_SHPI_START + 90) /* Frame vsync */
+#define SPEAR1340_IRQ_CAM2_CE		(IRQ_SHPI_START + 91) /* Camline End */
+#define SPEAR1340_IRQ_CAM2_FVE		(IRQ_SHPI_START + 92) /* Frame vsync */
+#define SPEAR1340_IRQ_CAM3_CE		(IRQ_SHPI_START + 93) /* Camline End */
+#define SPEAR1340_IRQ_CAM3_FVE		(IRQ_SHPI_START + 94) /* Frame vsync */
+#define SPEAR1340_IRQ_MALI_GPU_M200	(IRQ_SHPI_START + 95) /* M200 */
+#define SPEAR1340_IRQ_MALI_GPU_MGP2	(IRQ_SHPI_START + 96) /* MGP2 */
+#define SPEAR1340_IRQ_MALI_GPU_MMU	(IRQ_SHPI_START + 97) /* MMU */
+#define SPEAR1340_IRQ_I2S_PLAY_EMP_M	(IRQ_SHPI_START + 98) /* Empty */
+#define SPEAR1340_IRQ_I2S_PLAY_OR_M	(IRQ_SHPI_START + 99) /* Over Run */
+#define SPEAR1340_IRQ_I2S_REC_DA_S	(IRQ_SHPI_START + 100) /* Data Avail */
+#define SPEAR1340_IRQ_I2S_REC_OR_S	(IRQ_SHPI_START + 101) /* Over Run */
+#define SPEAR1340_IRQ_CEC0		(IRQ_SHPI_START + 102)
+#define SPEAR1340_IRQ_CEC1		(IRQ_SHPI_START + 103)
+#define SPEAR1340_IRQ_I2C1		(IRQ_SHPI_START + 104)
+#define SPEAR1340_IRQ_UART1		(IRQ_SHPI_START + 105)
+#define SPEAR1340_IRQ_PLGPIO		(IRQ_SHPI_START + 107)
+#define SPEAR1340_IRQ_MIPHY		(IRQ_SHPI_START + 110)
+#endif /* CONFIG_CPU_SPEAR1340 */
+
+#define IRQ_GIC_END		(IRQ_SHPI_START + 128)
+
+#define VIRQ_START		IRQ_GIC_END
+
+/* GPIO pins virtual irqs */
+#define SPEAR_GPIO0_INT_BASE	(VIRQ_START + 0)
+#define SPEAR_GPIO1_INT_BASE	(SPEAR_GPIO0_INT_BASE + 8)
+
+#define SPEAR_PLGPIO_COUNT	250
+#if defined(CONFIG_CPU_SPEAR1310_REVA) || defined(CONFIG_CPU_SPEAR1310) || \
+		defined(CONFIG_CPU_SPEAR1340)
+#define SPEAR_PLGPIO_INT_BASE	(SPEAR_GPIO1_INT_BASE + 8)
+#define SPEAR_GPIO_INT_END	(SPEAR_PLGPIO_INT_BASE + \
+				DIV_ROUND_UP(SPEAR_PLGPIO_COUNT,\
+					PLGPIO_GROUP_SIZE))
+#else
+#define SPEAR_GPIO_INT_END	(SPEAR_GPIO1_INT_BASE + 8)
+#endif
+
+/* PCIE MSI virtual irqs */
+#define SPEAR_NUM_MSI_IRQS	64
+#define SPEAR_MSI0_INT_BASE	(SPEAR_GPIO_INT_END + 0)
+#define SPEAR_MSI0_INT_END	(SPEAR_MSI0_INT_BASE + SPEAR_NUM_MSI_IRQS)
+#define SPEAR_MSI1_INT_BASE	(SPEAR_MSI0_INT_END + 0)
+#define SPEAR_MSI1_INT_END	(SPEAR_MSI1_INT_BASE + SPEAR_NUM_MSI_IRQS)
+#define SPEAR_MSI2_INT_BASE	(SPEAR_MSI1_INT_END + 0)
+#define SPEAR_MSI2_INT_END	(SPEAR_MSI2_INT_BASE + SPEAR_NUM_MSI_IRQS)
+
+#define SPEAR_NUM_INTX_IRQS	4
+#define SPEAR_INTX0_BASE	(SPEAR_MSI2_INT_END + 0)
+#define SPEAR_INTX0_END		(SPEAR_INTX0_BASE + SPEAR_NUM_INTX_IRQS)
+#define SPEAR_INTX1_BASE	(SPEAR_INTX0_END + 0)
+#define SPEAR_INTX1_END		(SPEAR_INTX1_BASE + SPEAR_NUM_INTX_IRQS)
+#define SPEAR_INTX2_BASE	(SPEAR_INTX1_END + 0)
+#define SPEAR_INTX2_END		(SPEAR_INTX2_BASE + SPEAR_NUM_INTX_IRQS)
+
+#ifdef CONFIG_ARCH_SPEAR13XX
+ #ifdef CONFIG_MACH_SPEAR1340_EVB
+  #define SPEAR_STMPE801_GPIO_INT_BASE	SPEAR_INTX2_END
+  #define SPEAR_STMPE801_GPIO_INT_END	(SPEAR_STMPE801_GPIO_INT_BASE + STMPE_NR_IRQS)
+  #define SPEAR_STMPE610_INT_BASE	SPEAR_STMPE801_GPIO_INT_END
+ #else
+  #define SPEAR_STMPE610_INT_BASE	SPEAR_INTX2_END
+ #endif
+
+ #define VIRQ_END			(SPEAR_STMPE610_INT_BASE + STMPE_NR_INTERNAL_IRQS)
+#else
+ #define VIRQ_END			SPEAR_INTX2_END
+#endif
+
+#define NR_IRQS			VIRQ_END
+
+#endif /* __MACH_IRQS_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/misc_regs.h b/arch/arm/mach-spear13xx/include/mach/misc_regs.h
new file mode 100644
index 0000000..59130f5
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/misc_regs.h
@@ -0,0 +1,461 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/misc_regs.h
+ *
+ * Miscellaneous registers definitions for spear13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_MISC_REGS_H
+#define __MACH_MISC_REGS_H
+
+#include <mach/hardware.h>
+
+#ifdef CONFIG_CPU_SPEAR1340
+#include <mach/spear1340_misc_regs.h>
+#undef VA_MISC_BASE
+#endif
+
+#ifdef CONFIG_CPU_SPEAR1310
+#include <mach/spear1310_misc_regs.h>
+#undef VA_MISC_BASE
+#endif
+
+#define VA_MISC_BASE			IOMEM(VA_SPEAR13XX_MISC_BASE)
+
+/* General Configuration */
+#define VA_SOC_CFG			(VA_MISC_BASE + 0x000)
+#define VA_BOOTSTRAP_CFG		(VA_MISC_BASE + 0x004)
+
+/* Power Management Registers */
+#define VA_PCM_CFG			(VA_MISC_BASE + 0x100)
+#define PCM_CFG				(SPEAR13XX_MISC_BASE + 0x100)
+#define VA_PCM_WKUP_CFG			(VA_MISC_BASE + 0x104)
+#define VA_SWITCH_CTR			(VA_MISC_BASE + 0x108)
+
+/* Clock Configuration Registers */
+#define VA_SYS_CLK_CTRL			(VA_MISC_BASE + 0x200)
+	#define SYS_MODE_MASK			(0x7 << 0)
+	#define SYS_MODE_DOZE			(0x1 << 0)
+	#define SYS_MODE_SLOW			(0x2 << 0)
+	#define SYS_MODE_NORMAL			(0x4 << 0)
+
+	#define SYS_MODE_STS_MASK		(0xF << 16)
+	#define SYS_MODE_STS_DOZE		(0x0 << 16)
+	#define SYS_MODE_STS_SLOW		(0xA << 16)
+	#define SYS_MODE_STS_NORMAL		(0xF << 16)
+
+#define VA_SYS_SW_RES			(VA_MISC_BASE + 0x204)
+#define VA_SYS_CLK_PLLTIMER		(VA_MISC_BASE + 0x208)
+#define VA_SYS_CLK_OSCITIMER		(VA_MISC_BASE + 0x20C)
+
+/* PLL related registers and bit values */
+#define VA_PLL_CFG			(VA_MISC_BASE + 0x210)
+	/* PLL_CFG bit values */
+	#define CLCD_SYNT_VCO1_DIV4_VAL		0
+	#define CLCD_SYNT_PLL2_VAL		1
+	#define CLCD_SYNT_CLK_MASK		1
+	#define CLCD_SYNT_CLK_SHIFT		31
+	#define RAS_SYNT2_3_VCO1_DIV4_VAL	0
+	#define RAS_SYNT2_3_VCO2_DIV2_VAL	1
+	#define RAS_SYNT2_3_PLL2_VAL		2
+	#define RAS_SYNT2_3_CLK_MASK		3
+	#define RAS_SYNT2_3_CLK_SHIFT		29
+	#define RAS_SYNT0_1_VCO1_DIV4_VAL	0
+	#define RAS_SYNT0_1_VCO3_DIV2_VAL	1
+	#define RAS_SYNT0_1_PLL3_VAL		2
+	#define RAS_SYNT0_1_CLK_MASK		3
+	#define RAS_SYNT0_1_CLK_SHIFT		27
+	#define OSC_24M_VAL			0
+	#define OSC_25M_VAL			1
+	#define PLL_CLK_MASK			3
+	#define PLL3_CLK_SHIFT			24
+	#define PLL2_CLK_SHIFT			22
+	#define PLL1_CLK_SHIFT			20
+
+#define VA_PLL1_CTR			(VA_MISC_BASE + 0x214)
+#define VA_PLL1_FRQ			(VA_MISC_BASE + 0x218)
+#define VA_PLL1_MOD			(VA_MISC_BASE + 0x21C)
+#define VA_PLL2_CTR			(VA_MISC_BASE + 0x220)
+#define VA_PLL2_FRQ			(VA_MISC_BASE + 0x224)
+#define VA_PLL2_MOD			(VA_MISC_BASE + 0x228)
+#define VA_PLL3_CTR			(VA_MISC_BASE + 0x22C)
+#define VA_PLL3_FRQ			(VA_MISC_BASE + 0x230)
+#define VA_PLL3_MOD			(VA_MISC_BASE + 0x234)
+#define VA_PLL4_CTR			(VA_MISC_BASE + 0x238)
+	/* PLL_CTR register masks */
+	#define PLL_MODE_NORMAL		0
+	#define PLL_MODE_FRACTION	1
+	#define PLL_MODE_DITH_DSM	2
+	#define PLL_MODE_DITH_SSM	3
+	#define PLL_MODE_MASK		3
+	#define PLL_MODE_SHIFT		3
+	#define PLL_ENABLE		1
+
+	#define PLL_LOCK_SHIFT		0
+	#define PLL_LOCK_MASK		1
+
+#define VA_PLL4_FRQ			(VA_MISC_BASE + 0x23C)
+	/* PLL FRQ register masks */
+	#define PLL_NORM_FDBK_M_MASK	0xFF
+	#define PLL_NORM_FDBK_M_SHIFT	24
+	#define PLL_DITH_FDBK_M_MASK	0xFFFF
+	#define PLL_DITH_FDBK_M_SHIFT	16
+	#define PLL_DIV_P_MASK		0x7
+	#define PLL_DIV_P_SHIFT		8
+	#define PLL_DIV_N_MASK		0xFF
+	#define PLL_DIV_N_SHIFT		0
+
+#define VA_PLL4_MOD			(VA_MISC_BASE + 0x240)
+#define VA_PERIP_CLK_CFG		(VA_MISC_BASE + 0x244)
+	/* PERIP_CLK_CFG bit values */
+	#define GPT3_CLK_SHIFT		13
+	#define GPT2_CLK_SHIFT		12
+	#define MCTR_CLK_PLL1_VAL	0x0
+	#define MCTR_CLK_PLL4_VAL	0x1
+	#define MCTR_CLK_MASK		0x1
+	#define MCTR_CLK_SHIFT		10
+	#define GPT_APB_VAL		1
+	#define GPT_OSC24_VAL		0
+	#define GPT_CLK_MASK		1
+	#define GPT1_CLK_SHIFT		9
+	#define GPT0_CLK_SHIFT		8
+
+	#define AUX_CLK_PLL5_VAL	0
+	#define AUX_CLK_SYNT_VAL	1
+	#define UART_CLK_MASK		1
+	#define UART_CLK_SHIFT		4
+	#define CLCD_CLK_MASK		3
+	#define CLCD_CLK_SHIFT		2
+	#define C3_CLK_MASK		1
+	#define C3_CLK_SHIFT		1
+
+#define VA_GMAC_CLK_CFG			(VA_MISC_BASE + 0x248)
+	#define GMAC_PHY_IF_GMII_VAL		0
+	#define GMAC_PHY_IF_RGMII_VAL		1
+	#define GMAC_PHY_IF_RMII_VAL		4
+	#define GMAC_PHY_IF_SEL_MASK		7
+	#define GMAC_PHY_IF_SEL_SHIFT		4
+	#define GMAC_PHY_INPUT_ENB_VAL		0
+	#define GMAC_PHY_SYNT_ENB_VAL		1
+	#define GMAC_PHY_CLK_MASK		1
+	#define GMAC_PHY_CLK_SHIFT		3
+	#define GMAC_PHY_125M_PAD_VAL		0
+	#define GMAC_PHY_PLL2_VAL		1
+	#define GMAC_PHY_OSC3_VAL		2
+	#define GMAC_PHY_INPUT_CLK_MASK		3
+	#define GMAC_PHY_INPUT_CLK_SHIFT	1
+
+#define VA_C3_CLK_SYNT			(VA_MISC_BASE + 0x24C)
+	/* refer AUX_* macros for reg masks */
+#define VA_CLCD_CLK_SYNT		(VA_MISC_BASE + 0x250)
+	/* Fractional synthesizer reg masks */
+	#define FRAC_SYNT_DIV_FACTOR_MASK	0x1FFFF
+	#define FRAC_SYNT_DIV_FACTOR_SHIFT	0
+
+#define VA_UART_CLK_SYNT		(VA_MISC_BASE + 0x254)
+#define VA_GMAC_CLK_SYNT		(VA_MISC_BASE + 0x258)
+#define VA_SDHCI_CLK_SYNT		(VA_MISC_BASE + 0x25C)
+#define VA_CFXD_CLK_SYNT		(VA_MISC_BASE + 0x260)
+	/* aux clk synthesizer register masks */
+	#define AUX_SYNT_ENB		31
+	#define AUX_EQ_SEL_SHIFT	30
+	#define AUX_EQ_SEL_MASK		1
+	#define AUX_EQ1_SEL		0
+	#define AUX_EQ2_SEL		1
+	#define AUX_XSCALE_SHIFT	16
+	#define AUX_XSCALE_MASK		0xFFF
+	#define AUX_YSCALE_SHIFT	0
+	#define AUX_YSCALE_MASK		0xFFF
+
+#define VA_RAS_CLK_SYNT0		(VA_MISC_BASE + 0x264)
+#define VA_RAS_CLK_SYNT1		(VA_MISC_BASE + 0x268)
+#define VA_RAS_CLK_SYNT2		(VA_MISC_BASE + 0x26C)
+#define VA_RAS_CLK_SYNT3		(VA_MISC_BASE + 0x270)
+	/* Check Fractional synthesizer reg masks */
+
+#define VA_PERIP1_CLK_ENB		(VA_MISC_BASE + 0x274)
+	/* PERIP1_CLK_ENB register masks */
+	#define RTC_CLK_ENB		31
+	#define ADC_CLK_ENB		30
+	#define C3_CLK_ENB		29
+	#define JPEG_CLK_ENB		28
+	#define CLCD_CLK_ENB		27
+	#define DMA_CLK_ENB		25
+	#define GPIO1_CLK_ENB		24
+	#define GPIO0_CLK_ENB		23
+	#define GPT1_CLK_ENB		22
+	#define GPT0_CLK_ENB		21
+	#define I2S0_CLK_ENB		20
+	#define I2S1_CLK_ENB		19
+	#define I2C_CLK_ENB		18
+	#define SSP_CLK_ENB		17
+	#define UART_CLK_ENB		15
+	#define PCIE2_CLK_ENB		14
+	#define PCIE1_CLK_ENB		13
+	#define PCIE0_CLK_ENB		12
+	#define USBD_CLK_ENB		11
+	#define UHC1_CLK_ENB		10
+	#define UHC0_CLK_ENB		9
+	#define GMAC_CLK_ENB		8
+	#define CFXD_CLK_ENB		7
+	#define SDHCI_CLK_ENB		6
+	#define SMI_CLK_ENB		5
+	#define FSMC_CLK_ENB		4
+	#define SYSRAM0_CLK_ENB		3
+	#define SYSRAM1_CLK_ENB		2
+	#define SYSROM_CLK_ENB		1
+	#define BUS_CLK_ENB		0
+
+#define VA_PERIP2_CLK_ENB		(VA_MISC_BASE + 0x278)
+	/* PERIP2_CLK_ENB register masks */
+	#define THSENS_CLK_ENB		8
+	#define I2S_REF_PAD_CLK_ENB	7
+	#define ACP_CLK_ENB		6
+	#define GPT3_CLK_ENB		5
+	#define GPT2_CLK_ENB		4
+	#define KBD_CLK_ENB		3
+	#define CPU_DBG_CLK_ENB		2
+	#define DDR_CORE_CLK_ENB	1
+	#define DDR_CTRL_CLK_ENB	0
+
+#define VA_PERIP1_SW_RST		(VA_MISC_BASE + 0x27C)
+	#define JPEG_SOF_RST		28
+#define VA_PERIP2_SW_RST		(VA_MISC_BASE + 0x280)
+#define VA_RAS_CLK_ENB			(VA_MISC_BASE + 0x284)
+	/* RAS_CLK_ENB register masks */
+	#define SYNT3_CLK_ENB		17
+	#define SYNT2_CLK_ENB		16
+	#define SYNT1_CLK_ENB		15
+	#define SYNT0_CLK_ENB		14
+	#define PCLK3_CLK_ENB		13
+	#define PCLK2_CLK_ENB		12
+	#define PCLK1_CLK_ENB		11
+	#define PCLK0_CLK_ENB		10
+	#define PLL3_CLK_ENB		9
+	#define PLL2_CLK_ENB		8
+	#define C125M_PAD_CLK_ENB	7
+	#define C30M_CLK_ENB		6
+	#define C48M_CLK_ENB		5
+	#define OSC3_CLK_ENB		4
+	#define OSC2_CLK_ENB		3
+	#define OSC1_CLK_ENB		2
+	#define PCLK_CLK_ENB		1
+	#define ACLK_CLK_ENB		0
+#define VA_RAS_SW_RST			(VA_MISC_BASE + 0x288)
+#define VA_PLL1_SYNT			(VA_MISC_BASE + 0x28C)
+	/* Check Fractional synthesizer reg masks */
+
+#define VA_I2S_CLK_CFG			(VA_MISC_BASE + 0x290)
+	/* I2S_CLK_CFG register mask */
+	#define I2S_SCLK_X_MASK		0x1F
+	#define I2S_SCLK_X_SHIFT	27
+	#define I2S_SCLK_Y_MASK		0x1F
+	#define I2S_SCLK_Y_SHIFT	22
+	#define I2S_SCLK_EQ_SEL_SHIFT	21
+	#define I2S_SCLK_SYNTH_ENB	20
+	#define I2S_PRS1_CLK_X_MASK	0xFF
+	#define I2S_PRS1_CLK_X_SHIFT	12
+	#define I2S_PRS1_CLK_Y_MASK	0xFF
+	#define I2S_PRS1_CLK_Y_SHIFT	4
+	#define I2S_PRS1_EQ_SEL_SHIFT	3
+	#define I2S_REF_SRC_VAL		0
+	#define I2S_REF_PRS1_VAL	1
+	#define I2S_REF_SEL_MASK	1
+	#define I2S_REF_SHIFT		2
+	#define I2S_SRC_VCODIV2_VAL	0
+	#define I2S_SRC_PLL3_VAL	1
+	#define I2S_SRC_PL_CLK1_VAL	2
+	#define I2S_SRC_CLK_MASK	3
+	#define I2S_SRC_CLK_SHIFT	0
+
+/* Peripheral Configuration Registers */
+#define VA_DMAC_HS_SEL			(VA_MISC_BASE + 0x300)
+#define VA_DMAC_SEL			(VA_MISC_BASE + 0x304)
+#define VA_DMAC_FLOW_SEL		(VA_MISC_BASE + 0x308)
+#define VA_DMAC_DIR_SEL			(VA_MISC_BASE + 0x30C)
+#define VA_DMAC_CFG			(VA_MISC_BASE + 0x310)
+#define VA_USBPHY_GEN_CFG		(VA_MISC_BASE + 0x314)
+#define VA_USBPHY_P1_CFG		(VA_MISC_BASE + 0x318)
+#define VA_USBPHY_P2_CFG		(VA_MISC_BASE + 0x31C)
+#define VA_USBPHY_P3_CFG		(VA_MISC_BASE + 0x320)
+#define VA_PCIE_CFG			(VA_MISC_BASE + 0x324)
+	/* PCIE CFG MASks */
+	#define PCIE0_CFG_DEVICE_PRESENT	(1 << 11)
+	#define PCIE1_CFG_DEVICE_PRESENT	(1 << 10)
+	#define PCIE2_CFG_DEVICE_PRESENT	(1 << 9)
+	#define PCIE0_CFG_POWERUP_RESET	(1 << 8)
+	#define PCIE1_CFG_POWERUP_RESET	(1 << 7)
+	#define PCIE2_CFG_POWERUP_RESET	(1 << 6)
+	#define PCIE0_CFG_CORE_CLK_EN	(1 << 5)
+	#define PCIE1_CFG_CORE_CLK_EN	(1 << 4)
+	#define PCIE2_CFG_CORE_CLK_EN	(1 << 3)
+	#define PCIE0_CFG_AUX_CLK_EN	(1 << 2)
+	#define PCIE1_CFG_AUX_CLK_EN	(1 << 1)
+	#define PCIE2_CFG_AUX_CLK_EN	(1 << 0)
+	#define PCIE0_CFG_VAL	(PCIE0_CFG_AUX_CLK_EN | PCIE0_CFG_CORE_CLK_EN \
+			| PCIE0_CFG_POWERUP_RESET | PCIE0_CFG_DEVICE_PRESENT)
+	#define PCIE1_CFG_VAL	(PCIE1_CFG_AUX_CLK_EN | PCIE1_CFG_CORE_CLK_EN \
+			| PCIE1_CFG_POWERUP_RESET | PCIE1_CFG_DEVICE_PRESENT)
+	#define PCIE2_CFG_VAL	(PCIE2_CFG_AUX_CLK_EN | PCIE2_CFG_CORE_CLK_EN \
+			| PCIE2_CFG_POWERUP_RESET | PCIE2_CFG_DEVICE_PRESENT)
+
+#define VA_PCIE_MIPHY_CFG		(VA_MISC_BASE + 0x328)
+#define VA_PERIP_CFG			(VA_MISC_BASE + 0x32C)
+#define PERIP_CFG		(SPEAR13XX_MISC_BASE + 0x32C)
+	/* PERIP_CFG register masks */
+	#define MCIF_SEL_SD	(0x1 << MCIF_SEL_SHIFT)
+	#define MCIF_SEL_CF	(0x2 << MCIF_SEL_SHIFT)
+	#define MCIF_SEL_XD	(0x3 << MCIF_SEL_SHIFT)
+	#define MCIF_SEL_MASK	(0x3 << MCIF_SEL_SHIFT)
+	#define MCIF_SEL_SHIFT	3
+
+	#define I2S_MODE_I2S2_ONE_PORT	(0 << 0)
+	#define I2S_MODE_I2S1_ONE_PORT	(1 << 0)
+	#define I2S_MODE_I2S2_TWO_PORT	(2 << 0)
+	#define I2S_MODE_I2S1_TWO_PORT	(3 << 0)
+	#define I2S_MODE_BOTH_ONE_PORT	(4 << 0)
+	#define I2S_MODE_MASK		(7 << 0)
+
+#define VA_FSMC_CFG			(VA_MISC_BASE + 0x330)
+	/* FSMC_CFG register masks */
+	#define NAND_DEV_WIDTH16	4
+	#define NAND_BANK_MASK		3
+	#define NAND_BANK_SHIFT		2
+	#define FSMC_MEM_NOR		0
+	#define FSMC_MEM_NAND		1
+	#define FSMC_MEM_SRAM		2
+	#define FSMC_MEMSEL_MASK	3
+	#define FSMC_MEMSEL_SHIFT	0
+
+#define VA_MPMC_CTR_STS			(VA_MISC_BASE + 0x334)
+
+/* Inter-Processor Communication Registers */
+#define VA_PRC1_LOCK_CTR		(VA_MISC_BASE + 0x500)
+#define VA_PRC2_LOCK_CTR		(VA_MISC_BASE + 0x504)
+#define VA_PRC1_IRQ_CTR			(VA_MISC_BASE + 0x508)
+#define VA_PRC2_IRQ_CTR			(VA_MISC_BASE + 0x51C)
+
+/* Pad Configuration Registers */
+#define VA_PAD_PU_CFG_1			(VA_MISC_BASE + 0x600)
+#define VA_PAD_PU_CFG_2			(VA_MISC_BASE + 0x604)
+#define VA_PAD_PU_CFG_3			(VA_MISC_BASE + 0x608)
+#define VA_PAD_PU_CFG_4			(VA_MISC_BASE + 0x60C)
+#define VA_PAD_PU_CFG_5			(VA_MISC_BASE + 0x610)
+#define VA_PAD_PU_CFG_6			(VA_MISC_BASE + 0x614)
+#define VA_PAD_PU_CFG_7			(VA_MISC_BASE + 0x618)
+#define VA_PAD_PU_CFG_8			(VA_MISC_BASE + 0x61C)
+#define VA_PAD_PD_CFG_1			(VA_MISC_BASE + 0x620)
+#define VA_PAD_PD_CFG_2			(VA_MISC_BASE + 0x624)
+#define VA_PAD_PD_CFG_3			(VA_MISC_BASE + 0x628)
+#define VA_PAD_PD_CFG_4			(VA_MISC_BASE + 0x62C)
+#define VA_PAD_PD_CFG_5			(VA_MISC_BASE + 0x630)
+#define VA_PAD_PD_CFG_6			(VA_MISC_BASE + 0x634)
+#define VA_PAD_PD_CFG_7			(VA_MISC_BASE + 0x638)
+#define VA_PAD_PD_CFG_8			(VA_MISC_BASE + 0x63C)
+#define VA_PAD_SLEEP_CFG		(VA_MISC_BASE + 0x640)
+#define VA_PAD_HYST_CFG			(VA_MISC_BASE + 0x644)
+#define VA_PAD_DRV_CFG			(VA_MISC_BASE + 0x648)
+#define VA_PAD_SLEW_CFG			(VA_MISC_BASE + 0x64C)
+#define VA_PAD_FUNCTION_EN_1		(VA_MISC_BASE + 0x650)
+#define PAD_FUNCTION_EN_1		(SPEAR13XX_MISC_BASE + 0x650)
+#define VA_PAD_FUNCTION_EN_2		(VA_MISC_BASE + 0x654)
+#define PAD_FUNCTION_EN_2		(SPEAR13XX_MISC_BASE + 0x654)
+#define VA_PAD_FUNCTION_EN_3		(VA_MISC_BASE + 0x658)
+#define PAD_FUNCTION_EN_3		(SPEAR13XX_MISC_BASE + 0x658)
+#define VA_DDR_PAD_CFG			(VA_MISC_BASE + 0x65C)
+#define THSENS_CFG			(SPEAR13XX_MISC_BASE + 0x6C4)
+#define VA_THSENS_CFG			(VA_MISC_BASE + 0x6C4)
+	#define THERMAL_CONFIG_FLAGS		0x7000
+
+/* Compensation Configuration Registers */
+#define VA_COMP_1V8_2V5_3V3__1_CFG	(VA_MISC_BASE + 0x700)
+#define VA_COMP_1V8_2V5_3V3__2_CFG	(VA_MISC_BASE + 0x704)
+#define VA_COMP_3V3_1_CFG		(VA_MISC_BASE + 0x708)
+#define VA_COMP_3V3_2_CFG		(VA_MISC_BASE + 0x70C)
+#define VA_COMP_DDR_CFG			(VA_MISC_BASE + 0x710)
+
+/* OTP Programming Registers */
+#define VA_OTP_PROG_CTR			(VA_MISC_BASE + 0x800)
+#define VA_OTP_WDATA1_1			(VA_MISC_BASE + 0x804)
+#define VA_OTP_WDATA1_2			(VA_MISC_BASE + 0x808)
+#define VA_OTP_WDATA1_3			(VA_MISC_BASE + 0x80C)
+#define VA_OTP_WDATA1_4			(VA_MISC_BASE + 0x810)
+#define VA_OTP_WDATA1_5			(VA_MISC_BASE + 0x814)
+#define VA_OTP_WDATA1_6			(VA_MISC_BASE + 0x818)
+#define VA_OTP_WDATA1_7			(VA_MISC_BASE + 0x81C)
+#define VA_OTP_WDATA1_8			(VA_MISC_BASE + 0x820)
+#define VA_OTP_WDATA2_1			(VA_MISC_BASE + 0x824)
+#define VA_OTP_WDATA2_2			(VA_MISC_BASE + 0x828)
+#define VA_OTP_WDATA2_3			(VA_MISC_BASE + 0x82C)
+#define VA_OTP_WDATA2_4			(VA_MISC_BASE + 0x830)
+#define VA_OTP_WDATA2_5			(VA_MISC_BASE + 0x834)
+#define VA_OTP_WDATA2_6			(VA_MISC_BASE + 0x838)
+#define VA_OTP_WDATA2_7			(VA_MISC_BASE + 0x83C)
+#define VA_OTP_WDATA2_8			(VA_MISC_BASE + 0x840)
+#define VA_OTP_MASK_1			(VA_MISC_BASE + 0x844)
+#define VA_OTP_MASK_2			(VA_MISC_BASE + 0x848)
+#define VA_OTP_MASK_3			(VA_MISC_BASE + 0x84C)
+#define VA_OTP_MASK_4			(VA_MISC_BASE + 0x850)
+#define VA_OTP_MASK_5			(VA_MISC_BASE + 0x854)
+#define VA_OTP_MASK_6			(VA_MISC_BASE + 0x858)
+#define VA_OTP_MASK_7			(VA_MISC_BASE + 0x85C)
+#define VA_OTP_MASK_8			(VA_MISC_BASE + 0x860)
+#define VA_OTP_RDATA1_1			(VA_MISC_BASE + 0x864)
+#define VA_OTP_RDATA1_2			(VA_MISC_BASE + 0x868)
+#define VA_OTP_RDATA1_3			(VA_MISC_BASE + 0x86C)
+#define VA_OTP_RDATA1_4			(VA_MISC_BASE + 0x870)
+#define VA_OTP_RDATA1_5			(VA_MISC_BASE + 0x874)
+#define VA_OTP_RDATA1_6			(VA_MISC_BASE + 0x878)
+#define VA_OTP_RDATA1_7			(VA_MISC_BASE + 0x87C)
+#define VA_OTP_RDATA1_8			(VA_MISC_BASE + 0x880)
+#define VA_OTP_RDATA2_1			(VA_MISC_BASE + 0x884)
+#define VA_OTP_RDATA2_2			(VA_MISC_BASE + 0x888)
+#define VA_OTP_RDATA2_3			(VA_MISC_BASE + 0x88C)
+#define VA_OTP_RDATA2_4			(VA_MISC_BASE + 0x890)
+#define VA_OTP_RDATA2_5			(VA_MISC_BASE + 0x894)
+#define VA_OTP_RDATA2_6			(VA_MISC_BASE + 0x898)
+#define VA_OTP_RDATA2_7			(VA_MISC_BASE + 0x89C)
+#define VA_OTP_RDATA2_8			(VA_MISC_BASE + 0x8A0)
+#define VA_OTP_RDATAM_1			(VA_MISC_BASE + 0x8A4)
+#define VA_OTP_RDATAM_2			(VA_MISC_BASE + 0x8A8)
+#define VA_OTP_RDATAM_3			(VA_MISC_BASE + 0x8AC)
+#define VA_OTP_RDATAM_4			(VA_MISC_BASE + 0x8B0)
+#define VA_OTP_RDATAM_5			(VA_MISC_BASE + 0x8B4)
+#define VA_OTP_RDATAM_6			(VA_MISC_BASE + 0x8B8)
+#define VA_OTP_RDATAM_7			(VA_MISC_BASE + 0x8BC)
+#define VA_OTP_RDATAM_8			(VA_MISC_BASE + 0x8C0)
+
+/* A9SM Registers */
+#define VA_A9SM_CLUSTERID		(VA_MISC_BASE + 0x900)
+#define VA_A9SM_STATUS			(VA_MISC_BASE + 0x904)
+#define VA_A9SM_DEBUG			(VA_MISC_BASE + 0x908)
+#define VA_A9SM_FILTER			(VA_MISC_BASE + 0x90C)
+#define VA_A9SM_PARITY_CFG		(VA_MISC_BASE + 0x910)
+#define VA_A9SM_PARITY_ERR		(VA_MISC_BASE + 0x914)
+
+/* SOC ID Registers */
+#define VA_DIE_ID_1			(VA_MISC_BASE + 0xA00)
+#define VA_DIE_ID_2			(VA_MISC_BASE + 0xA04)
+#define VA_DIE_ID_3			(VA_MISC_BASE + 0xA08)
+#define VA_DIE_ID_4			(VA_MISC_BASE + 0xA0C)
+#define VA_DIE_ID_VALID			(VA_MISC_BASE + 0xA10)
+
+/* SOC TEST & DEBUG Registers */
+#define VA_MIPHY_TEST			(VA_MISC_BASE + 0x1000)
+#define VA_PCIE_MSTR_P0			(VA_MISC_BASE + 0x1004)
+#define VA_PCIE_AWMISC_P0		(VA_MISC_BASE + 0x1008)
+#define VA_PCIE_ARMISC_P0		(VA_MISC_BASE + 0x100C)
+#define VA_PCIE_MSTR_P1			(VA_MISC_BASE + 0x1010)
+#define VA_PCIE_AWMISC_P1		(VA_MISC_BASE + 0x1014)
+#define VA_PCIE_ARMISC_P1		(VA_MISC_BASE + 0x1018)
+#define VA_PCIE_MSTR_P2			(VA_MISC_BASE + 0x101C)
+#define VA_PCIE_AWMISC_P2		(VA_MISC_BASE + 0x1020)
+#define VA_PCIE_ARMISC_P2		(VA_MISC_BASE + 0x1024)
+
+#endif /* __MACH_MISC_REGS_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/spdif.h b/arch/arm/mach-spear13xx/include/mach/spdif.h
new file mode 100644
index 0000000..d961f110
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spdif.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (ST) 2011 Vipin Kumar (vipin.kumar@st.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef MACH_SPDIF_H
+#define MACH_SPDIF_H
+
+struct spdif_platform_data {
+	/* DMA params */
+	void *dma_params;
+	bool (*filter)(struct dma_chan *chan, void *slave);
+	void (*reset_perip)(void);
+};
+
+#endif /* MACH_SPDIF_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear.h b/arch/arm/mach-spear13xx/include/mach/spear.h
new file mode 100644
index 0000000..19d8a8f
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear.h
@@ -0,0 +1,119 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear.h
+ *
+ * spear13xx Machine family specific definition
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SPEAR13XX_H
+#define __MACH_SPEAR13XX_H
+
+#include <asm/memory.h>
+#include <mach/spear1300.h>
+#include <mach/spear1310_reva.h>
+#include <mach/spear1310.h>
+#include <mach/spear1340.h>
+
+#define SPEAR13XX_L2CC_BASE		UL(0xED000000)
+
+/* ARM9SMP peripheral base address */
+#define SPEAR13XX_A9SM_PERIP_BASE	UL(0xEC800000)
+#define VA_SPEAR13XX_A9SM_PERIP_BASE	IO_ADDRESS(SPEAR13XX_A9SM_PERIP_BASE)
+/* A9SM peripheral offsets */
+#define SPEAR13XX_SCU_BASE		(SPEAR13XX_A9SM_PERIP_BASE + 0x00)
+#define SPEAR13XX_GIC_CPU_BASE		(SPEAR13XX_A9SM_PERIP_BASE + 0x100)
+#define SPEAR13XX_GLOBAL_TMR_BASE	(SPEAR13XX_A9SM_PERIP_BASE + 0x200)
+#define SPEAR13XX_LOCAL_TMR_BASE	(SPEAR13XX_A9SM_PERIP_BASE + 0x600)
+#define SPEAR13XX_WDT_BASE		(SPEAR13XX_A9SM_PERIP_BASE + 0x620)
+#define SPEAR13XX_GIC_DIST_BASE		(SPEAR13XX_A9SM_PERIP_BASE + 0x1000)
+
+#define SPEAR13XX_UART_BASE		UL(0xE0000000)
+#define VA_SPEAR13XX_UART_BASE		IO_ADDRESS(SPEAR13XX_UART_BASE)
+
+#define SPEAR13XX_ADC_BASE		UL(0xE0080000)
+#define SPEAR13XX_SSP_BASE		UL(0xE0100000)
+#define SPEAR13XX_I2C_BASE		UL(0xE0280000)
+#define SPEAR13XX_KBD_BASE		UL(0xE0300000)
+#define SPEAR13XX_GPT0_BASE		UL(0xE0380000)
+#define SPEAR13XX_GPT1_BASE		UL(0xE0400000)
+#define SPEAR13XX_GPT2_BASE		UL(0xE0480000)
+#define SPEAR13XX_GPT3_BASE		UL(0xE0500000)
+#define SPEAR13XX_RTC_BASE		UL(0xE0580000)
+#define SPEAR13XX_GPIO0_BASE		UL(0xE0600000)
+#define SPEAR13XX_GPIO1_BASE		UL(0xE0680000)
+#define SPEAR13XX_MISC_BASE		UL(0xE0700000)
+#define VA_SPEAR13XX_MISC_BASE		IO_ADDRESS(SPEAR13XX_MISC_BASE)
+
+#define SPEAR13XX_SYSRAM0_BASE		UL(0xB3800000)
+#define SPEAR13XX_SYSRAM0_SIZE		0x00800000
+
+/*
+ * The system location which is polled by secondary cpus to find the
+ * jump address
+ */
+#define SPEAR13XX_SYS_LOCATION		(SPEAR13XX_SYSRAM0_BASE + 0x600)
+
+#define SPEAR13XX_SYSRAM1_BASE		UL(0xE0800000)
+#define SPEAR13XX_SYSRAM1_SIZE		0x00001000
+#define SPEAR13XX_CLCD_BASE		UL(0xE1000000)
+#define SPEAR13XX_C3_BASE		UL(0xE1800000)
+#define SPEAR13XX_GETH_BASE		UL(0xE2000000)
+#define SPEAR13XX_UHC0_OHCI_BASE	UL(0xE4000000)
+#define SPEAR13XX_UHC0_EHCI_BASE	UL(0xE4800000)
+#define SPEAR13XX_UHC1_OHCI_BASE	UL(0xE5000000)
+#define SPEAR13XX_UHC1_EHCI_BASE	UL(0xE5800000)
+#define SPEAR13XX_SMI_MEM0_BASE		UL(0xE6000000)
+#define SPEAR13XX_SMI_MEM1_BASE		UL(0xE7000000)
+#define SPEAR13XX_SMI_CTRL_BASE		UL(0xEA000000)
+#define SPEAR13XX_DMAC0_BASE		UL(0xEA800000)
+#define SPEAR13XX_DMAC1_BASE		UL(0xEB000000)
+#define SPEAR13XX_MII_PHY_BASE		UL(0xEB800000)
+#define SPEAR13XX_MPMC_BASE		UL(0xEC000000)
+#define SPEAR13XX_PCIE0_BASE		UL(0x80000000)
+#define SPEAR13XX_PCIE0_APP_BASE	UL(0xB1000000)
+#define SPEAR13XX_FSMC_MEM_BASE		UL(0xA0000000)
+#define SPEAR13XX_FSMC_BASE		UL(0xB0000000)
+	#define PLAT_NAND_CLE		(1 << 16)
+	#define PLAT_NAND_ALE		(1 << 17)
+#define SPEAR13XX_MCIF_CF_BASE		UL(0xB2800000)
+#define SPEAR13XX_MCIF_SDHCI_BASE	UL(0xB3000000)
+
+/* Devices not present in SPEAr1340 & are present in all other variants */
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+#define SPEAR13XX_I2S0_BASE		UL(0xE0180000)
+#define SPEAR13XX_I2S1_BASE		UL(0xE0200000)
+#define SPEAR13XX_PCIE1_APP_BASE	UL(0xB1800000)
+#define SPEAR13XX_PCIE1_BASE		UL(0x90000000)
+#define SPEAR13XX_PCIE2_APP_BASE	UL(0xB4000000)
+#define SPEAR13XX_PCIE2_BASE		UL(0xC0000000)
+#define SPEAR13XX_JPEG_BASE		UL(0xB2000000)
+#endif
+
+/* Devices not present in SPEAr1340 & are present in all other variants */
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900)
+#define SPEAR13XX_UPD_BASE		UL(0xE2800000)
+#define SPEAR13XX_UDC_BASE		UL(0xE3800000)
+#endif
+
+/* Debug uart for linux, will be used for debug and uncompress messages */
+#define SPEAR_DBG_UART_BASE		SPEAR13XX_UART_BASE
+#define VA_SPEAR_DBG_UART_BASE		VA_SPEAR13XX_UART_BASE
+
+/* PLGPIO register offsets */
+	#define SPEAR13XX_PLGPIO_RDATA_OFF	0x0010
+	#define SPEAR13XX_PLGPIO_WDATA_OFF	0x0030
+	#define SPEAR13XX_PLGPIO_DIR_OFF	0x0050
+	#define SPEAR13XX_PLGPIO_MIS_OFF	0x0070
+	#define SPEAR13XX_PLGPIO_IE_OFF		0x0078
+	#define SPEAR13XX_PLGPIO_ENB_OFF	0x0090
+
+#endif /* __MACH_SPEAR13XX_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1300.h b/arch/arm/mach-spear13xx/include/mach/spear1300.h
new file mode 100644
index 0000000..3b9c348
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1300.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1300.h
+ *
+ * SPEAr1300 Machine specific definition
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifdef	CONFIG_CPU_SPEAR1300
+
+#ifndef __MACH_SPEAR1300_H
+#define __MACH_SPEAR1300_H
+
+#endif /* __MACH_SPEAR1300_H */
+
+#endif /* CONFIG_CPU_SPEAR1300 */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1310.h b/arch/arm/mach-spear13xx/include/mach/spear1310.h
new file mode 100644
index 0000000..f32a00d
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1310.h
@@ -0,0 +1,201 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1310.h
+ *
+ * SPEAr1310 Machine specific definition
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifdef CONFIG_CPU_SPEAR1310
+
+#ifndef __MACH_SPEAR1310_H
+#define __MACH_SPEAR1310_H
+
+#define SPEAR1310_NAND_MEM_BASE			UL(0xB0800000)
+#define SPEAR1310_UOC_BASE			UL(0xE3800000)
+#define SPEAR1310_SATA0_BASE			UL(0xB1000000)
+#define SPEAR1310_SATA1_BASE			UL(0xB1800000)
+#define SPEAR1310_SATA2_BASE			UL(0xB4000000)
+#define SPEAR1310_PCI_CACHEABLE_BASE		UL(0x40000000)
+#define SPEAR1310_PCI_NON_CACHEABLE_BASE	UL(0x50000000)
+#define SPEAR1310_PCI_IO_BASE			UL(0x5c000000)
+#define SPEAR1310_PCI_CSR_BASE			UL(0x5c100000)
+#define SPEAR1310_ESRAM_BASE			UL(0x5c200000)
+#define SPEAR1310_SMII0_BASE			UL(0x5c400000)
+#define SPEAR1310_SMII1_BASE			UL(0x5c500000)
+#define SPEAR1310_SMII2_BASE			UL(0x5c600000)
+#define SPEAR1310_RGMII_BASE			UL(0x5c700000)
+#define SPEAR1310_UART1_BASE			UL(0x5c800000)
+#define SPEAR1310_UART2_BASE			UL(0x5c900000)
+#define SPEAR1310_UART3_BASE			UL(0x5cA00000)
+#define SPEAR1310_UART4_BASE			UL(0x5cB00000)
+#define SPEAR1310_UART5_BASE			UL(0x5cC00000)
+#define SPEAR1310_I2C1_BASE			UL(0x5cD00000)
+#define SPEAR1310_I2C2_BASE			UL(0x5cE00000)
+#define SPEAR1310_I2C3_BASE			UL(0x5cF00000)
+#define SPEAR1310_I2C4_BASE			UL(0x5D000000)
+#define SPEAR1310_I2C5_BASE			UL(0x5D100000)
+#define SPEAR1310_I2C6_BASE			UL(0x5D200000)
+#define SPEAR1310_I2C7_BASE			UL(0x5D300000)
+#define SPEAR1310_SSP1_BASE			UL(0x5D400000)
+#define SPEAR1310_CAN0_BASE			UL(0x5D500000)
+#define SPEAR1310_CAN1_BASE			UL(0x5D600000)
+#define SPEAR1310_GPT64_BASE			UL(0x5D700000)
+#define SPEAR1310_RS485_0_BASE			UL(0xD8000000)
+#define SPEAR1310_RS485_1_BASE			UL(0xD8100000)
+#define SPEAR1310_TDM_E1_0_BASE			UL(0xD8200000)
+#define SPEAR1310_TDM_E1_1_BASE			UL(0xD8300000)
+#define SPEAR1310_RAS_BASE			UL(0xD8400000)
+#define VA_SPEAR1310_RAS_BASE			IO_ADDRESS(SPEAR1310_RAS_BASE)
+
+
+/* RAS Area Control Register */
+#define SPEAR1310_RAS_CTRL_REG0		(SPEAR1310_RAS_BASE + 0x000)
+	#define SPEAR1310_GPT64_SYNC_ENB		0
+	#define SPEAR1310_GPT64_SYNC_ENB_MASK		1
+	#define SPEAR1310_GPT64_SYNC_ENB_SHIFT		31
+	#define SPEAR1310_SSP1_CS_SEL_CS0		0
+	#define SPEAR1310_SSP1_CS_SEL_CS1		1
+	#define SPEAR1310_SSP1_CS_SEL_MASK		3
+	#define SPEAR1310_SSP1_CS_SEL_SHIFT		30
+	#define SPEAR1310_SSP1_CS_VAL_MASK		1
+	#define SPEAR1310_SSP1_CS_VAL_SHIFT		28
+	#define SPEAR1310_SSP1_CS_CTL_HW		0
+	#define SPEAR1310_SSP1_CS_CTL_SW		1
+	#define SPEAR1310_SSP1_CS_CTL_MASK		1
+	#define SPEAR1310_SSP1_CS_CTL_SHIFT		27
+	#define SPEAR1310_SSP1_CLK_PCLK_VAL		0
+	#define SPEAR1310_SSP1_CLK_RAS_SYNT1_VAL	1
+	#define SPEAR1310_SSP1_CLK_RAS_PLCLK0_VAL	2
+	#define SPEAR1310_SSP1_CLK_MASK			3
+	#define SPEAR1310_SSP1_CLK_SHIFT		26
+	#define SPEAR1310_TDM_CLK_PLL3_VAL		0
+	#define SPEAR1310_TDM_CLK_RAS_SYNT1_VAL		1
+	#define SPEAR1310_TDM_CLK_MASK			1
+	#define SPEAR1310_TDM2_CLK_SHIFT		24
+	#define SPEAR1310_TDM1_CLK_SHIFT		23
+	#define SPEAR1310_I2C_CLK_PCLK_VAL		0
+	#define SPEAR1310_I2C_CLK_RAS_SYNT1_VAL		1
+	#define SPEAR1310_I2C_CLK_MASK			1
+	#define SPEAR1310_I2C7_CLK_SHIFT		22
+	#define SPEAR1310_I2C6_CLK_SHIFT		21
+	#define SPEAR1310_I2C5_CLK_SHIFT		20
+	#define SPEAR1310_I2C4_CLK_SHIFT		19
+	#define SPEAR1310_I2C3_CLK_SHIFT		18
+	#define SPEAR1310_I2C2_CLK_SHIFT		17
+	#define SPEAR1310_I2C1_CLK_SHIFT		16
+	#define SPEAR1310_GPT64_CLK_RAS_48M_VAL		0
+	#define SPEAR1310_GPT64_CLK_PCLK_VAL		1
+	#define SPEAR1310_GPT64_CLK_MASK		1
+	#define SPEAR1310_GPT64_CLK_SHIFT		15
+	#define SPEAR1310_UART_CLK_PCLK_VAL		0
+	#define SPEAR1310_UART_CLK_RAS_CLK_SYNT3	1
+	#define SPEAR1310_RAS_UART_CLK_MASK		1
+	#define SPEAR1310_UART5_CLK_SHIFT		14
+	#define SPEAR1310_UART4_CLK_SHIFT		13
+	#define SPEAR1310_UART3_CLK_SHIFT		12
+	#define SPEAR1310_UART2_CLK_SHIFT		11
+	#define SPEAR1310_UART1_CLK_SHIFT		10
+	#define SPEAR1310_PMX_GMAC_PCI_SEL_MASK		9 /* 0: GMAC, 1: PCI */
+	#define SPEAR1310_PCI_EXT_ARBITER_ENB		(1 << 8)
+	#define SPEAR1310_PCI_BUS_INT_ENB		7
+	#define SPEAR1310_PCI_INTR_STATUS		6
+	#define SPEAR1310_PCI_INTRX_ENB			5 /* 0: enb, 1: dsb */
+	#define SPEAR1310_PCI_PWR_STATE_CHG_ACK		4 /* 1: can change */
+	#define SPEAR1310_PCI_PME_VOLT_LEVEL		3 /* 0: Vaux, 1: Vcc */
+	#define SPEAR1310_PCI_INT_ARBITER_ENB		(1 << 2)
+	#define SPEAR1310_PCI_PME_STATUS		1
+	#define SPEAR1310_PCI_CLK_PLL3_VAL		0
+	#define SPEAR1310_PCI_CLK_RAS_SYNT2_VAL		1
+	#define SPEAR1310_PCI_CLK_MASK			1
+	#define SPEAR1310_PCI_CLK_SHIFT			0
+
+#define SPEAR1310_RAS_CTRL_REG1		(SPEAR1310_RAS_BASE + 0x004)
+	#define SPEAR1310_RAS_TX50M_VAL			0x0	/* Only RMII */
+	#define SPEAR1310_RAS_TX125M_PAD_VAL		0x1	/* Only SMII */
+	#define SPEAR1310_RAS_PLL2_VAL			0x2
+	#define SPEAR1310_RAS_SYNTH0_VAL		0x3
+	#define SPEAR1310_PHY_CLK_MASK			0x3
+	#define SPEAR1310_RMII_PHY_CLK_SHIFT		0
+	#define SPEAR1310_SMII_RGMII_PHY_CLK_SHIFT	2
+
+#define SPEAR1310_RAS_INTR		(SPEAR1310_RAS_BASE + 0x008)
+#define SPEAR1310_RAS_INTR_MASK		(SPEAR1310_RAS_BASE + 0x00C)
+
+/* PLGPIO Registers offset */
+/* Masked interrupt status */
+#define SPEAR1310_PLGPIO_MIS_OFF	0x010
+/* interrupt enable */
+#define SPEAR1310_PLGPIO_IE_OFF		0x030
+/* edge interrupt type, 0: falling, 1: rising */
+#define SPEAR1310_PLGPIO_EIT_OFF	0x050
+/* read data */
+#define SPEAR1310_PLGPIO_RDATA_OFF	0x070
+/* write data */
+#define SPEAR1310_PLGPIO_WDATA_OFF	0x090
+/* gpio direction */
+#define SPEAR1310_PLGPIO_DIR_OFF	0x0B0
+/* gpio enable, 0: IP, 1: plgpio */
+#define SPEAR1310_PLGPIO_ENB_OFF	0x0D0
+
+#define SPEAR1310_RAS_PCI_AHB_CFG0	(SPEAR1310_RAS_BASE + 0x0F0)
+#define SPEAR1310_RAS_PCI_AHB_CFG1	(SPEAR1310_RAS_BASE + 0x00F4)
+#define SPEAR1310_RAS_PCI_AHB_CFG2	(SPEAR1310_RAS_BASE + 0x00F8)
+#define SPEAR1310_RAS_PCI_AHB_CFG3	(SPEAR1310_RAS_BASE + 0x00FC)
+#define SPEAR1310_RAS_PCI_AHB_CFG4	(SPEAR1310_RAS_BASE + 0x0100)
+#define SPEAR1310_RAS_PCI_AHB_CFG5	(SPEAR1310_RAS_BASE + 0x0104)
+#define SPEAR1310_RAS_PCI_AHB_CFG6	(SPEAR1310_RAS_BASE + 0x0108)
+#define SPEAR1310_RAS_PCI_MEM_BAR0	(SPEAR1310_RAS_BASE + 0x010C)
+#define SPEAR1310_RAS_PCI_MEM_BAR1	(SPEAR1310_RAS_BASE + 0x0110)
+#define SPEAR1310_RAS_PCI_MEM_BAR2	(SPEAR1310_RAS_BASE + 0x0114)
+#define SPEAR1310_RAS_PCI_MEM0_MASK	(SPEAR1310_RAS_BASE + 0x0118)
+#define SPEAR1310_RAS_PCI_MEM1_MASK	(SPEAR1310_RAS_BASE + 0x011C)
+#define SPEAR1310_RAS_PCI_MEM2_MASK	(SPEAR1310_RAS_BASE + 0x0120)
+#define SPEAR1310_RAS_PCI_STATUS	(SPEAR1310_RAS_BASE + 0x0124)
+#define SPEAR1310_RAS_I2C1_DEBUG	(SPEAR1310_RAS_BASE + 0x0128)
+#define SPEAR1310_RAS_I2C2_DEBUG	(SPEAR1310_RAS_BASE + 0x012C)
+#define SPEAR1310_RAS_I2C3_DEBUG	(SPEAR1310_RAS_BASE + 0x0130)
+#define SPEAR1310_RAS_I2C4_DEBUG	(SPEAR1310_RAS_BASE + 0x0134)
+#define SPEAR1310_RAS_I2C5_DEBUG	(SPEAR1310_RAS_BASE + 0x0138)
+#define SPEAR1310_RAS_I2C6_DEBUG	(SPEAR1310_RAS_BASE + 0x013C)
+#define SPEAR1310_RAS_I2C7_DEBUG	(SPEAR1310_RAS_BASE + 0x0140)
+#define SPEAR1310_RAS_GPT64_DEBUG	(SPEAR1310_RAS_BASE + 0x0144)
+#define SPEAR1310_RAS_SW_CLK_CTRL	(SPEAR1310_RAS_BASE + 0x0148)
+	#define SPEAR1310_CAN1_CLK_ENB			25
+	#define SPEAR1310_CAN0_CLK_ENB			24
+	#define SPEAR1310_GPT64_CLK_ENB			23
+	#define SPEAR1310_SSP1_CLK_ENB			22
+	#define SPEAR1310_I2C7_CLK_ENB			21
+	#define SPEAR1310_I2C6_CLK_ENB			20
+	#define SPEAR1310_I2C5_CLK_ENB			19
+	#define SPEAR1310_I2C4_CLK_ENB			18
+	#define SPEAR1310_I2C3_CLK_ENB			17
+	#define SPEAR1310_I2C2_CLK_ENB			16
+	#define SPEAR1310_I2C1_CLK_ENB			15
+	#define SPEAR1310_UART5_CLK_ENB			14
+	#define SPEAR1310_UART4_CLK_ENB			13
+	#define SPEAR1310_UART3_CLK_ENB			12
+	#define SPEAR1310_UART2_CLK_ENB			11
+	#define SPEAR1310_UART1_CLK_ENB			10
+	#define SPEAR1310_RS485_1_CLK_ENB		9
+	#define SPEAR1310_RS485_0_CLK_ENB		8
+	#define SPEAR1310_TDM_E1_1_CLK_ENB		7
+	#define SPEAR1310_TDM_E1_0_CLK_ENB		6
+	#define SPEAR1310_PCI_CLK_ENB			5
+	#define SPEAR1310_GMII_CLK_ENB			4
+	#define SPEAR1310_MII2_CLK_ENB			3
+	#define SPEAR1310_MII1_CLK_ENB			2
+	#define SPEAR1310_MII0_CLK_ENB			1
+	#define SPEAR1310_ESRAM_CLK_ENB			0
+
+#define SPEAR1310_RAS_SW_RST_CTRL	(SPEAR1310_RAS_BASE + 0x014C)
+#define SPEAR1310_RAS_IP_PORT_SEL	(SPEAR1310_RAS_BASE + 0x0150)
+
+#endif /* __MACH_SPEAR1310_H */
+
+#endif /* CONFIG_CPU_SPEAR1310 */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1310_misc_regs.h b/arch/arm/mach-spear13xx/include/mach/spear1310_misc_regs.h
new file mode 100644
index 0000000..5c23eac
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1310_misc_regs.h
@@ -0,0 +1,545 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1310_misc_regs.h
+ *
+ * Miscellaneous registers definitions for spear13xx machine family
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SPEAR1310_MISC_REGS_H
+#define __MACH_SPEAR1310_MISC_REGS_H
+
+#include <mach/hardware.h>
+
+#define VA_MISC_BASE				IOMEM(VA_SPEAR13XX_MISC_BASE)
+
+/* General Configuration */
+#define VA_SPEAR1310_SOC_CFG			(VA_MISC_BASE + 0x000)
+#define VA_SPEAR1310_BOOTSTRAP_CFG		(VA_MISC_BASE + 0x004)
+
+/* Power Management Registers */
+#define VA_SPEAR1310_PCM_CFG			(VA_MISC_BASE + 0x100)
+#define VA_SPEAR1310_PCM_WKUP_CFG		(VA_MISC_BASE + 0x104)
+#define VA_SPEAR1310_SWITCH_CTR			(VA_MISC_BASE + 0x108)
+
+/* Clock Configuration Registers */
+/*
+ * Some of the individual defines (mode related) for this register is
+ * present in generic misc_regs.h as it is common across 13xx variants
+ */
+#define VA_SPEAR1310_SYS_CLK_CTRL		(VA_MISC_BASE + 0x200)
+#define VA_SPEAR1310_SYS_SW_RES			(VA_MISC_BASE + 0x204)
+#define VA_SPEAR1310_SYS_CLK_PLLTIMER		(VA_MISC_BASE + 0x208)
+#define VA_SPEAR1310_SYS_CLK_OSCITIMER		(VA_MISC_BASE + 0x20C)
+
+/* PLL related registers and bit values */
+#define VA_SPEAR1310_PLL_CFG			(VA_MISC_BASE + 0x210)
+	/* PLL_CFG bit values */
+	#define SPEAR1310_CLCD_SYNT_VCO1_DIV4_VAL	0
+	#define SPEAR1310_CLCD_SYNT_PLL2_VAL		1
+	#define SPEAR1310_CLCD_SYNT_CLK_MASK		1
+	#define SPEAR1310_CLCD_SYNT_CLK_SHIFT		31
+	#define SPEAR1310_RAS_SYNT2_3_VCO1_DIV4_VAL	0
+	#define SPEAR1310_RAS_SYNT2_3_VCO2_DIV2_VAL	1
+	#define SPEAR1310_RAS_SYNT2_3_PLL2_VAL		2
+	#define SPEAR1310_RAS_SYNT2_3_CLK_MASK		3
+	#define SPEAR1310_RAS_SYNT2_3_CLK_SHIFT		29
+	#define SPEAR1310_RAS_SYNT0_1_VCO1_DIV4_VAL	0
+	#define SPEAR1310_RAS_SYNT0_1_VCO3_DIV2_VAL	1
+	#define SPEAR1310_RAS_SYNT0_1_PLL3_VAL		2
+	#define SPEAR1310_RAS_SYNT0_1_CLK_MASK		3
+	#define SPEAR1310_RAS_SYNT0_1_CLK_SHIFT		27
+	#define SPEAR1310_OSC_24M_VAL			0
+	#define SPEAR1310_OSC_25M_VAL			1
+	#define SPEAR1310_PLL_CLK_MASK			3
+	#define SPEAR1310_PLL3_CLK_SHIFT		24
+	#define SPEAR1310_PLL2_CLK_SHIFT		22
+	#define SPEAR1310_PLL1_CLK_SHIFT		20
+
+#define VA_SPEAR1310_PLL1_CTR			(VA_MISC_BASE + 0x214)
+#define VA_SPEAR1310_PLL1_FRQ			(VA_MISC_BASE + 0x218)
+#define VA_SPEAR1310_PLL1_MOD			(VA_MISC_BASE + 0x21C)
+#define VA_SPEAR1310_PLL2_CTR			(VA_MISC_BASE + 0x220)
+#define VA_SPEAR1310_PLL2_FRQ			(VA_MISC_BASE + 0x224)
+#define VA_SPEAR1310_PLL2_MOD			(VA_MISC_BASE + 0x228)
+#define VA_SPEAR1310_PLL3_CTR			(VA_MISC_BASE + 0x22C)
+#define VA_SPEAR1310_PLL3_FRQ			(VA_MISC_BASE + 0x230)
+#define VA_SPEAR1310_PLL3_MOD			(VA_MISC_BASE + 0x234)
+#define VA_SPEAR1310_PLL4_CTR			(VA_MISC_BASE + 0x238)
+	/* PLL_CTR register masks */
+	#define SPEAR1310_PLL_MODE_NORMAL		0
+	#define SPEAR1310_PLL_MODE_FRACTION		1
+	#define SPEAR1310_PLL_MODE_DITH_DSM		2
+	#define SPEAR1310_PLL_MODE_DITH_SSM		3
+	#define SPEAR1310_PLL_MODE_MASK			3
+	#define SPEAR1310_PLL_MODE_SHIFT		4
+	#define SPEAR1310_PLL_ENABLE			2
+
+	#define SPEAR1310_PLL_LOCK_SHIFT		0
+	#define SPEAR1310_PLL_LOCK_MASK			1
+
+#define VA_SPEAR1310_PLL4_FRQ			(VA_MISC_BASE + 0x23C)
+	/* PLL FRQ register masks */
+	#define SPEAR1310_PLL_NORM_FDBK_M_MASK		0xFF
+	#define SPEAR1310_PLL_NORM_FDBK_M_SHIFT		24
+	#define SPEAR1310_PLL_DITH_FDBK_M_MASK		0xFFFF
+	#define SPEAR1310_PLL_DITH_FDBK_M_SHIFT		16
+	#define SPEAR1310_PLL_DIV_P_MASK		0x7
+	#define SPEAR1310_PLL_DIV_P_SHIFT		8
+	#define SPEAR1310_PLL_DIV_N_MASK		0xFF
+	#define SPEAR1310_PLL_DIV_N_SHIFT		0
+
+#define VA_SPEAR1310_PLL4_MOD			(VA_MISC_BASE + 0x240)
+#define VA_SPEAR1310_PERIP_CLK_CFG		(VA_MISC_BASE + 0x244)
+	/* PERIP_CLK_CFG bit values */
+	#define SPEAR1310_GPT_OSC24_VAL			0
+	#define SPEAR1310_GPT_APB_VAL			1
+	#define SPEAR1310_GPT_CLK_MASK			1
+	#define SPEAR1310_GPT3_CLK_SHIFT		11
+	#define SPEAR1310_GPT2_CLK_SHIFT		10
+	#define SPEAR1310_GPT1_CLK_SHIFT		9
+	#define SPEAR1310_GPT0_CLK_SHIFT		8
+	#define SPEAR1310_UART_CLK_PLL5_VAL		0
+	#define SPEAR1310_UART_CLK_OSC24_VAL		1
+	#define SPEAR1310_UART_CLK_SYNT_VAL		2
+	#define SPEAR1310_UART_CLK_MASK			3
+	#define SPEAR1310_UART_CLK_SHIFT		4
+
+	#define SPEAR1310_AUX_CLK_PLL5_VAL		0
+	#define SPEAR1310_AUX_CLK_SYNT_VAL		1
+	#define SPEAR1310_CLCD_CLK_MASK			3
+	#define SPEAR1310_CLCD_CLK_SHIFT		2
+	#define SPEAR1310_C3_CLK_MASK			1
+	#define SPEAR1310_C3_CLK_SHIFT			1
+
+#define VA_SPEAR1310_GMAC_CLK_CFG		(VA_MISC_BASE + 0x248)
+	#define SPEAR1310_GMAC_PHY_IF_GMII_VAL		0
+	#define SPEAR1310_GMAC_PHY_IF_RGMII_VAL		1
+	#define SPEAR1310_GMAC_PHY_IF_SGMII_VAL		2
+	#define SPEAR1310_GMAC_PHY_IF_RMII_VAL		4
+	#define SPEAR1310_GMAC_PHY_IF_SEL_MASK		7
+	#define SPEAR1310_GMAC_PHY_IF_SEL_SHIFT		4
+	#define SPEAR1310_GMAC_PHY_INPUT_ENB_VAL	0
+	#define SPEAR1310_GMAC_PHY_SYNT_ENB_VAL		1
+	#define SPEAR1310_GMAC_PHY_CLK_MASK		1
+	#define SPEAR1310_GMAC_PHY_CLK_SHIFT		3
+	#define SPEAR1310_GMAC_PHY_125M_PAD_VAL		0
+	#define SPEAR1310_GMAC_PHY_PLL2_VAL		1
+	#define SPEAR1310_GMAC_PHY_OSC3_VAL		2
+	#define SPEAR1310_GMAC_PHY_INPUT_CLK_MASK	3
+	#define SPEAR1310_GMAC_PHY_INPUT_CLK_SHIFT	1
+
+#define VA_SPEAR1310_I2S_CLK_CFG		(VA_MISC_BASE + 0x24C)
+	/* I2S_CLK_CFG register mask */
+	#define SPEAR1310_I2S_SCLK_X_MASK		0x1F
+	#define SPEAR1310_I2S_SCLK_X_SHIFT		27
+	#define SPEAR1310_I2S_SCLK_Y_MASK		0x1F
+	#define SPEAR1310_I2S_SCLK_Y_SHIFT		22
+	#define SPEAR1310_I2S_SCLK_EQ_SEL_SHIFT		21
+	#define SPEAR1310_I2S_SCLK_SYNTH_ENB		20
+	#define SPEAR1310_I2S_PRS1_CLK_X_MASK		0xFF
+	#define SPEAR1310_I2S_PRS1_CLK_X_SHIFT		12
+	#define SPEAR1310_I2S_PRS1_CLK_Y_MASK		0xFF
+	#define SPEAR1310_I2S_PRS1_CLK_Y_SHIFT		4
+	#define SPEAR1310_I2S_PRS1_EQ_SEL_SHIFT		3
+	#define SPEAR1310_I2S_REF_SRC_VAL		0
+	#define SPEAR1310_I2S_REF_PRS1_VAL		1
+	#define SPEAR1310_I2S_REF_SEL_MASK		1
+	#define SPEAR1310_I2S_REF_SHIFT			2
+	#define SPEAR1310_I2S_SRC_VCO1DIV2_VAL		0
+	#define SPEAR1310_I2S_SRC_PLL2_VAL		1
+	#define SPEAR1310_I2S_SRC_PLL3_VAL		2
+	#define SPEAR1310_I2S_SRC_PL_CLK0_VAL		3
+	#define SPEAR1310_I2S_SRC_CLK_MASK		3
+	#define SPEAR1310_I2S_SRC_CLK_SHIFT		0
+
+#define VA_SPEAR1310_C3_CLK_SYNT		(VA_MISC_BASE + 0x250)
+#define VA_SPEAR1310_UART_CLK_SYNT		(VA_MISC_BASE + 0x254)
+#define VA_SPEAR1310_GMAC_CLK_SYNT		(VA_MISC_BASE + 0x258)
+#define VA_SPEAR1310_SDHCI_CLK_SYNT		(VA_MISC_BASE + 0x25C)
+#define VA_SPEAR1310_CFXD_CLK_SYNT		(VA_MISC_BASE + 0x260)
+#define VA_SPEAR1310_ADC_CLK_SYNT		(VA_MISC_BASE + 0x264)
+	/* aux clk synthesizer register masks */
+	#define SPEAR1310_AUX_SYNT_ENB			31
+	#define SPEAR1310_AUX_EQ_SEL_SHIFT		30
+	#define SPEAR1310_AUX_EQ_SEL_MASK		1
+	#define SPEAR1310_AUX_EQ1_SEL			0
+	#define SPEAR1310_AUX_EQ2_SEL			1
+	#define SPEAR1310_AUX_XSCALE_SHIFT		16
+	#define SPEAR1310_AUX_XSCALE_MASK		0xFFF
+	#define SPEAR1310_AUX_YSCALE_SHIFT		0
+	#define SPEAR1310_AUX_YSCALE_MASK		0xFFF
+
+#define VA_SPEAR1310_AMBA_CLK_SYNT		(VA_MISC_BASE + 0x268)
+	/* Fractional synthesizer reg masks */
+	#define SPEAR1310_FRAC_SYNT_ENB			18
+	#define SPEAR1310_FRAC_SYNT_DIV_FACTOR_MASK	0x1ffff
+	#define SPEAR1310_FRAC_SYNT_DIV_FACTOR_SHIFT	0
+
+#define VA_SPEAR1310_AMBA_SYNT_MOD		(VA_MISC_BASE + 0x26C)
+#define VA_SPEAR1310_CLCD_CLK_SYNT		(VA_MISC_BASE + 0x270)
+#define VA_SPEAR1310_CLCD_CLK_SYNT_MOD		(VA_MISC_BASE + 0x274)
+#define VA_SPEAR1310_EXPI_CPU_SYNT		(VA_MISC_BASE + 0x278)
+#define VA_SPEAR1310_EXPI_CPU_SYNT_MOD		(VA_MISC_BASE + 0x27C)
+#define VA_SPEAR1310_RAS_CLK_SYNT0		(VA_MISC_BASE + 0x280)
+#define VA_SPEAR1310_RAS_CLK_SYNT0_MOD		(VA_MISC_BASE + 0x284)
+#define VA_SPEAR1310_RAS_CLK_SYNT1		(VA_MISC_BASE + 0x288)
+#define VA_SPEAR1310_RAS_CLK_SYNT1_MOD		(VA_MISC_BASE + 0x28C)
+#define VA_SPEAR1310_RAS_CLK_SYNT2		(VA_MISC_BASE + 0x290)
+#define VA_SPEAR1310_RAS_CLK_SYNT2_MOD		(VA_MISC_BASE + 0x294)
+#define VA_SPEAR1310_RAS_CLK_SYNT3		(VA_MISC_BASE + 0x298)
+#define VA_SPEAR1310_RAS_CLK_SYNT3_MOD		(VA_MISC_BASE + 0x29C)
+	/* Check Fractional synthesizer reg masks */
+
+#define VA_SPEAR1310_PERIP1_CLK_ENB		(VA_MISC_BASE + 0x300)
+	/* PERIP1_CLK_ENB register masks */
+	#define SPEAR1310_RTC_CLK_ENB			31
+	#define SPEAR1310_ADC_CLK_ENB			30
+	#define SPEAR1310_C3_CLK_ENB			29
+	#define SPEAR1310_JPEG_CLK_ENB			28
+	#define SPEAR1310_CLCD_CLK_ENB			27
+	#define SPEAR1310_DMA_CLK_ENB			25
+	#define SPEAR1310_GPIO1_CLK_ENB			24
+	#define SPEAR1310_GPIO0_CLK_ENB			23
+	#define SPEAR1310_GPT1_CLK_ENB			22
+	#define SPEAR1310_GPT0_CLK_ENB			21
+	#define SPEAR1310_I2S0_CLK_ENB			20
+	#define SPEAR1310_I2S1_CLK_ENB			19
+	#define SPEAR1310_I2C0_CLK_ENB			18
+	#define SPEAR1310_SSP_CLK_ENB			17
+	#define SPEAR1310_UART_CLK_ENB			15
+	#define SPEAR1310_PCIE_SATA_2_CLK_ENB		14
+	#define SPEAR1310_PCIE_SATA_1_CLK_ENB		13
+	#define SPEAR1310_PCIE_SATA_0_CLK_ENB		12
+	#define SPEAR1310_UOC_CLK_ENB			11
+	#define SPEAR1310_UHC1_CLK_ENB			10
+	#define SPEAR1310_UHC0_CLK_ENB			9
+	#define SPEAR1310_GMAC_CLK_ENB			8
+	#define SPEAR1310_CFXD_CLK_ENB			7
+	#define SPEAR1310_SDHCI_CLK_ENB			6
+	#define SPEAR1310_SMI_CLK_ENB			5
+	#define SPEAR1310_FSMC_CLK_ENB			4
+	#define SPEAR1310_SYSRAM0_CLK_ENB		3
+	#define SPEAR1310_SYSRAM1_CLK_ENB		2
+	#define SPEAR1310_SYSROM_CLK_ENB		1
+	#define SPEAR1310_BUS_CLK_ENB			0
+
+#define VA_SPEAR1310_PERIP2_CLK_ENB		(VA_MISC_BASE + 0x304)
+	/* PERIP2_CLK_ENB register masks */
+	#define SPEAR1310_THSENS_CLK_ENB		8
+	#define SPEAR1310_I2S_REF_PAD_CLK_ENB		7
+	#define SPEAR1310_ACP_CLK_ENB			6
+	#define SPEAR1310_GPT3_CLK_ENB			5
+	#define SPEAR1310_GPT2_CLK_ENB			4
+	#define SPEAR1310_KBD_CLK_ENB			3
+	#define SPEAR1310_CPU_DBG_CLK_ENB		2
+	#define SPEAR1310_DDR_CORE_CLK_ENB		1
+	#define SPEAR1310_DDR_CTRL_CLK_ENB		0
+
+#define VA_SPEAR1310_PERIP1_SW_RST		(VA_MISC_BASE + 0x308)
+#define VA_SPEAR1310_PERIP2_SW_RST		(VA_MISC_BASE + 0x30C)
+#define VA_SPEAR1310_RAS_CLK_ENB		(VA_MISC_BASE + 0x310)
+	/* RAS_CLK_ENB register masks */
+	#define SPEAR1310_SYNT3_CLK_ENB			17
+	#define SPEAR1310_SYNT2_CLK_ENB			16
+	#define SPEAR1310_SYNT1_CLK_ENB			15
+	#define SPEAR1310_SYNT0_CLK_ENB			14
+	#define SPEAR1310_PCLK3_CLK_ENB			13
+	#define SPEAR1310_PCLK2_CLK_ENB			12
+	#define SPEAR1310_PCLK1_CLK_ENB			11
+	#define SPEAR1310_PCLK0_CLK_ENB			10
+	#define SPEAR1310_PLL3_CLK_ENB			9
+	#define SPEAR1310_PLL2_CLK_ENB			8
+	#define SPEAR1310_C125M_PAD_CLK_ENB		7
+	#define SPEAR1310_C30M_CLK_ENB			6
+	#define SPEAR1310_C48M_CLK_ENB			5
+	#define SPEAR1310_OSC3_CLK_ENB			4
+	#define SPEAR1310_OSC2_CLK_ENB			3
+	#define SPEAR1310_OSC1_CLK_ENB			2
+	#define SPEAR1310_PCLK_CLK_ENB			1
+	#define SPEAR1310_ACLK_CLK_ENB			0
+#define VA_SPEAR1310_RAS_SW_RST			(VA_MISC_BASE + 0x314)
+
+/* Peripherial Configuration Registers */
+#define VA_SPEAR1310_DMAC_HS_SEL		(VA_MISC_BASE + 0x380)
+#define VA_SPEAR1310_DMAC_SEL			(VA_MISC_BASE + 0x384)
+#define VA_SPEAR1310_DMAC_FLOW_SEL		(VA_MISC_BASE + 0x388)
+#define VA_SPEAR1310_DMAC_DIR_SEL		(VA_MISC_BASE + 0x38C)
+#define VA_SPEAR1310_ENDIANESS_CFG		(VA_MISC_BASE + 0x390)
+#define VA_SPEAR1310_USBPHY_RAS_CFG		(VA_MISC_BASE + 0x394)
+#define VA_SPEAR1310_USBPHY_P1_CFG		(VA_MISC_BASE + 0x398)
+#define VA_SPEAR1310_USBPHY_P2_CFG		(VA_MISC_BASE + 0x39C)
+#define VA_SPEAR1310_USBPHY_P3_CFG		(VA_MISC_BASE + 0x3A0)
+#define SPEAR1310_PCIE_SATA_CFG			(SPEAR13XX_MISC_BASE + 0x3A4)
+#define VA_SPEAR1310_PCIE_SATA_CFG		(VA_MISC_BASE + 0x3A4)
+	/* PCIE CFG MASks */
+	#define SPEAR1310_PCIE_SATA2_SEL_PCIE		(0 << 31)
+	#define SPEAR1310_PCIE_SATA1_SEL_PCIE		(0 << 30)
+	#define SPEAR1310_PCIE_SATA0_SEL_PCIE		(0 << 29)
+	#define SPEAR1310_PCIE_SATA2_SEL_SATA		(1 << 31)
+	#define SPEAR1310_PCIE_SATA1_SEL_SATA		(1 << 30)
+	#define SPEAR1310_PCIE_SATA0_SEL_SATA		(1 << 29)
+	#define SPEAR1310_SATA2_CFG_TX_CLK_EN		(1 << 27)
+	#define SPEAR1310_SATA2_CFG_RX_CLK_EN		(1 << 26)
+	#define SPEAR1310_SATA2_CFG_POWERUP_RESET	(1 << 25)
+	#define SPEAR1310_SATA2_CFG_PM_CLK_EN		(1 << 24)
+	#define SPEAR1310_SATA1_CFG_TX_CLK_EN		(1 << 23)
+	#define SPEAR1310_SATA1_CFG_RX_CLK_EN		(1 << 22)
+	#define SPEAR1310_SATA1_CFG_POWERUP_RESET	(1 << 21)
+	#define SPEAR1310_SATA1_CFG_PM_CLK_EN		(1 << 20)
+	#define SPEAR1310_SATA0_CFG_TX_CLK_EN		(1 << 19)
+	#define SPEAR1310_SATA0_CFG_RX_CLK_EN		(1 << 18)
+	#define SPEAR1310_SATA0_CFG_POWERUP_RESET	(1 << 17)
+	#define SPEAR1310_SATA0_CFG_PM_CLK_EN		(1 << 16)
+	#define SPEAR1310_PCIE2_CFG_DEVICE_PRESENT	(1 << 11)
+	#define SPEAR1310_PCIE2_CFG_POWERUP_RESET	(1 << 10)
+	#define SPEAR1310_PCIE2_CFG_CORE_CLK_EN		(1 << 9)
+	#define SPEAR1310_PCIE2_CFG_AUX_CLK_EN		(1 << 8)
+	#define SPEAR1310_PCIE1_CFG_DEVICE_PRESENT	(1 << 7)
+	#define SPEAR1310_PCIE1_CFG_POWERUP_RESET	(1 << 6)
+	#define SPEAR1310_PCIE1_CFG_CORE_CLK_EN		(1 << 5)
+	#define SPEAR1310_PCIE1_CFG_AUX_CLK_EN		(1 << 4)
+	#define SPEAR1310_PCIE0_CFG_DEVICE_PRESENT	(1 << 3)
+	#define SPEAR1310_PCIE0_CFG_POWERUP_RESET	(1 << 2)
+	#define SPEAR1310_PCIE0_CFG_CORE_CLK_EN		(1 << 1)
+	#define SPEAR1310_PCIE0_CFG_AUX_CLK_EN		(1 << 0)
+
+	#define SPEAR1310_PCIE_CFG_VAL(x) \
+			(SPEAR1310_PCIE_SATA##x##_SEL_PCIE | \
+			SPEAR1310_PCIE##x##_CFG_AUX_CLK_EN | \
+			SPEAR1310_PCIE##x##_CFG_CORE_CLK_EN | \
+			SPEAR1310_PCIE##x##_CFG_POWERUP_RESET | \
+			SPEAR1310_PCIE##x##_CFG_DEVICE_PRESENT)
+	#define SPEAR1310_SATA_CFG_VAL(x) \
+			(SPEAR1310_PCIE_SATA##x##_SEL_SATA | \
+			SPEAR1310_SATA##x##_CFG_PM_CLK_EN | \
+			SPEAR1310_SATA##x##_CFG_POWERUP_RESET | \
+			SPEAR1310_SATA##x##_CFG_RX_CLK_EN | \
+			SPEAR1310_SATA##x##_CFG_TX_CLK_EN)
+
+#define VA_SPEAR1310_PCIE_MIPHY_CFG_1		(VA_MISC_BASE + 0x3A8)
+	#define SPEAR1310_MIPHY_DUAL_OSC_BYPASS_EXT	(1 << 31)
+	#define SPEAR1310_MIPHY_DUAL_CLK_REF_DIV2	(1 << 28)
+	#define SPEAR1310_MIPHY_DUAL_PLL_RATIO_TOP(x)	(x << 16)
+	#define SPEAR1310_MIPHY_SINGLE_OSC_BYPASS_EXT	(1 << 15)
+	#define SPEAR1310_MIPHY_SINGLE_CLK_REF_DIV2	(1 << 12)
+	#define SPEAR1310_MIPHY_SINGLE_PLL_RATIO_TOP(x)	(x << 0)
+	#define SPEAR1310_PCIE_SATA_MIPHY_CFG_SATA \
+			(SPEAR1310_MIPHY_DUAL_OSC_BYPASS_EXT | \
+			SPEAR1310_MIPHY_DUAL_CLK_REF_DIV2 | \
+			SPEAR1310_MIPHY_DUAL_PLL_RATIO_TOP(60) | \
+			SPEAR1310_MIPHY_SINGLE_OSC_BYPASS_EXT | \
+			SPEAR1310_MIPHY_SINGLE_CLK_REF_DIV2 | \
+			SPEAR1310_MIPHY_SINGLE_PLL_RATIO_TOP(60))
+	#define SPEAR1310_PCIE_SATA_MIPHY_CFG_PCIE \
+			(SPEAR1310_MIPHY_DUAL_OSC_BYPASS_EXT | \
+			SPEAR1310_MIPHY_DUAL_PLL_RATIO_TOP(25) | \
+			SPEAR1310_MIPHY_SINGLE_OSC_BYPASS_EXT | \
+			SPEAR1310_MIPHY_SINGLE_PLL_RATIO_TOP(25))
+
+#define VA_SPEAR1310_PCIE_MIPHY_CFG_2		(VA_MISC_BASE + 0x3AC)
+#define VA_SPEAR1310_PERIP_CFG			(VA_MISC_BASE + 0x3B0)
+#define SPEAR1310_PERIP_CFG			(SPEAR13XX_MISC_BASE + 0x3B0)
+	/* PERIP_CFG register masks */
+	#define SPEAR1310_SSP0_CS_CTL_HW		0
+	#define SPEAR1310_SSP0_CS_CTL_SW		1
+	#define SPEAR1310_SSP0_CS_CTL_MASK		1
+	#define SPEAR1310_SSP0_CS_CTL_SHIFT		12
+	#define SPEAR1310_SSP0_CS_VAL_MASK		1
+	#define SPEAR1310_SSP0_CS_VAL_SHIFT		11
+	#define SPEAR1310_SSP0_CS_SEL_CS0		0
+	#define SPEAR1310_SSP0_CS_SEL_CS1		1
+	#define SPEAR1310_SSP0_CS_SEL_CS2		2
+	#define SPEAR1310_SSP0_CS_SEL_MASK		3
+	#define SPEAR1310_SSP0_CS_SEL_SHIFT		8
+
+	#define SPEAR1310_MCIF_SEL_SD			1
+	#define SPEAR1310_MCIF_SEL_CF			2
+	#define SPEAR1310_MCIF_SEL_XD			3
+	#define SPEAR1310_MCIF_SEL_MASK			3
+	#define SPEAR1310_MCIF_SEL_SHIFT		5
+	#define SPEAR1310_I2S0_1TX_1RX_PORT		0
+	#define SPEAR1310_I2S1_1TX_1RX_PORT		1
+	#define SPEAR1310_I2S0_2TX_2RX_PORT		2
+	#define SPEAR1310_I2S1_2TX_2RX_PORT		3
+	#define SPEAR1310_I2S0_2TX_1_2RX_PORT		4
+	#define SPEAR1310_I2S0_2RX_1_2TX_PORT		5
+	#define SPEAR1310_I2S_MODE_MASK			7
+	#define SPEAR1310_I2S_MODE_SHIFT		0
+
+#define VA_SPEAR1310_FSMC_CFG			(VA_MISC_BASE + 0x3B4)
+	/* FSMC_CFG register masks */
+	#define SPEAR1310_BYTE_LANE_SEL_SRAM		0
+	#define SPEAR1310_BYTE_LANE_SEL_NOR		1
+	#define SPEAR1310_BYTE_LANE_SEL_MASK		1
+	#define SPEAR1310_BYTE_LANE_SEL_SHIFT		6
+	#define SPEAR1310_NOR_4BANK_64MB		0
+	#define SPEAR1310_NOR_1BANK_128MB_2BANK_64MB	1
+	#define SPEAR1310_NOR_2BANK_128MB		2
+	#define SPEAR1310_NOR_1BANK_256MB		3
+	#define SPEAR1310_NOR_CFG_MASK			3
+	#define SPEAR1310_NOR_CFG_SHIFT			4
+	#define SPEAR1310_FSMC_MEM_NAND			0
+	#define SPEAR1310_FSMC_MEM_NOR_SRAM		1
+	#define SPEAR1310_FSMC_CS_MEMSEL_MASK		1
+	#define SPEAR1310_FSMC_CS3_MEMSEL_SHIFT		3
+	#define SPEAR1310_FSMC_CS2_MEMSEL_SHIFT		2
+	#define SPEAR1310_FSMC_CS1_MEMSEL_SHIFT		1
+	#define SPEAR1310_FSMC_CS0_MEMSEL_SHIFT		0
+
+#define VA_SPEAR1310_MPMC_CFG			(VA_MISC_BASE + 0x3B8)
+#define VA_SPEAR1310_MPMC_CTR_STS		(VA_MISC_BASE + 0x3BC)
+#define VA_SPEAR1310_EXPIF_CLK_CFG		(VA_MISC_BASE + 0x400)
+#define VA_SPEAR1310_EXPIF_CFG			(VA_MISC_BASE + 0x404)
+#define VA_SPEAR1310_EXPIF_DMACHS_FLEX		(VA_MISC_BASE + 0x408)
+#define VA_SPEAR1310_EXPIF_DMACHS_SIMPLE	(VA_MISC_BASE + 0x41C)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_0	(VA_MISC_BASE + 0x420)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_1	(VA_MISC_BASE + 0x424)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_2	(VA_MISC_BASE + 0x428)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_3	(VA_MISC_BASE + 0x42C)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_4	(VA_MISC_BASE + 0x430)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_5	(VA_MISC_BASE + 0x434)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_6	(VA_MISC_BASE + 0x438)
+#define VA_SPEAR1310_EXPIF_ADD_EXP_TBL_7	(VA_MISC_BASE + 0x43C)
+
+/* Inter-Processor Communication Register */
+#define VA_SPEAR1310_PRC1_LOCK_CTR		(VA_MISC_BASE + 0x500)
+#define VA_SPEAR1310_PRC2_LOCK_CTR		(VA_MISC_BASE + 0x504)
+#define VA_SPEAR1310_PRC1_IRQ_CTR		(VA_MISC_BASE + 0x508)
+#define VA_SPEAR1310_PRC2_IRQ_CTR		(VA_MISC_BASE + 0x51C)
+
+/* Pad Configuration Registers */
+#define VA_SPEAR1310_PAD_PU_CFG_1		(VA_MISC_BASE + 0x600)
+#define VA_SPEAR1310_PAD_PU_CFG_2		(VA_MISC_BASE + 0x604)
+#define VA_SPEAR1310_PAD_PU_CFG_3		(VA_MISC_BASE + 0x608)
+#define VA_SPEAR1310_PAD_PU_CFG_4		(VA_MISC_BASE + 0x60C)
+#define VA_SPEAR1310_PAD_PU_CFG_5		(VA_MISC_BASE + 0x610)
+#define VA_SPEAR1310_PAD_PU_CFG_6		(VA_MISC_BASE + 0x614)
+#define VA_SPEAR1310_PAD_PU_CFG_7		(VA_MISC_BASE + 0x618)
+#define VA_SPEAR1310_PAD_PU_CFG_8		(VA_MISC_BASE + 0x61C)
+#define VA_SPEAR1310_PAD_PD_CFG_1		(VA_MISC_BASE + 0x620)
+#define VA_SPEAR1310_PAD_PD_CFG_2		(VA_MISC_BASE + 0x624)
+#define VA_SPEAR1310_PAD_PD_CFG_3		(VA_MISC_BASE + 0x628)
+#define VA_SPEAR1310_PAD_PD_CFG_4		(VA_MISC_BASE + 0x62C)
+#define VA_SPEAR1310_PAD_PD_CFG_5		(VA_MISC_BASE + 0x630)
+#define VA_SPEAR1310_PAD_PD_CFG_6		(VA_MISC_BASE + 0x634)
+#define VA_SPEAR1310_PAD_PD_CFG_7		(VA_MISC_BASE + 0x638)
+#define VA_SPEAR1310_PAD_PD_CFG_8		(VA_MISC_BASE + 0x63C)
+#define VA_SPEAR1310_PAD_SLEEP_CFG		(VA_MISC_BASE + 0x640)
+#define VA_SPEAR1310_PAD_HYST_CFG		(VA_MISC_BASE + 0x644)
+#define VA_SPEAR1310_PAD_DRV_CFG		(VA_MISC_BASE + 0x648)
+#define VA_SPEAR1310_PAD_SLEW_CFG		(VA_MISC_BASE + 0x64C)
+#define VA_SPEAR1310_PAD_FUNCTION_EN_1		(VA_MISC_BASE + 0x650)
+#define SPEAR1310_PAD_FUNCTION_EN_1		(SPEAR13XX_MISC_BASE + 0x650)
+#define VA_SPEAR1310_PAD_FUNCTION_EN_2		(VA_MISC_BASE + 0x654)
+#define SPEAR1310_PAD_FUNCTION_EN_2		(SPEAR13XX_MISC_BASE + 0x654)
+#define VA_SPEAR1310_PAD_FUNCTION_EN_3		(VA_MISC_BASE + 0x658)
+#define SPEAR1310_PAD_FUNCTION_EN_3		(SPEAR13XX_MISC_BASE + 0x658)
+#define VA_SPEAR1310_PAD_DIR_SEL_1		(VA_MISC_BASE + 0x65C)
+#define VA_SPEAR1310_PAD_DIR_SEL_2		(VA_MISC_BASE + 0x660)
+#define VA_SPEAR1310_PAD_DIR_SEL_3		(VA_MISC_BASE + 0x664)
+#define VA_SPEAR1310_DDR_PAD_CFG		(VA_MISC_BASE + 0x668)
+
+/* Compensation Configuration Register */
+#define VA_SPEAR1310_COMP_1V8_2V5_3V3__1_CFG	(VA_MISC_BASE + 0x700)
+#define VA_SPEAR1310_COMP_1V8_2V5_3V3__2_CFG	(VA_MISC_BASE + 0x704)
+#define VA_SPEAR1310_COMP_3V3_1_CFG		(VA_MISC_BASE + 0x708)
+#define VA_SPEAR1310_COMP_3V3_2_CFG		(VA_MISC_BASE + 0x70C)
+#define VA_SPEAR1310_COMP_3V3_3_CFG		(VA_MISC_BASE + 0x710)
+#define VA_SPEAR1310_COMP_DDR_CFG		(VA_MISC_BASE + 0x714)
+
+/* OTP  and  THSENS Programming Register */
+#define VA_SPEAR1310_OTP_PROG_CTR		(VA_MISC_BASE + 0x800)
+#define VA_SPEAR1310_OTP_WDATA1_1		(VA_MISC_BASE + 0x804)
+#define VA_SPEAR1310_OTP_WDATA1_2		(VA_MISC_BASE + 0x808)
+#define VA_SPEAR1310_OTP_WDATA1_3		(VA_MISC_BASE + 0x80c)
+#define VA_SPEAR1310_OTP_WDATA1_4		(VA_MISC_BASE + 0x810)
+#define VA_SPEAR1310_OTP_WDATA1_5		(VA_MISC_BASE + 0x814)
+#define VA_SPEAR1310_OTP_WDATA1_6		(VA_MISC_BASE + 0x818)
+#define VA_SPEAR1310_OTP_WDATA1_7		(VA_MISC_BASE + 0x81c)
+#define VA_SPEAR1310_OTP_WDATA1_8		(VA_MISC_BASE + 0x820)
+#define VA_SPEAR1310_OTP_WDATA2_1		(VA_MISC_BASE + 0x824)
+#define VA_SPEAR1310_OTP_WDATA2_2		(VA_MISC_BASE + 0x828)
+#define VA_SPEAR1310_OTP_WDATA2_3		(VA_MISC_BASE + 0x82c)
+#define VA_SPEAR1310_OTP_WDATA2_4		(VA_MISC_BASE + 0x830)
+#define VA_SPEAR1310_OTP_WDATA2_5		(VA_MISC_BASE + 0x834)
+#define VA_SPEAR1310_OTP_WDATA2_6		(VA_MISC_BASE + 0x838)
+#define VA_SPEAR1310_OTP_WDATA2_7		(VA_MISC_BASE + 0x83c)
+#define VA_SPEAR1310_OTP_WDATA2_8		(VA_MISC_BASE + 0x840)
+#define VA_SPEAR1310_OTP_MASK_1			(VA_MISC_BASE + 0x844)
+#define VA_SPEAR1310_OTP_MASK_2			(VA_MISC_BASE + 0x848)
+#define VA_SPEAR1310_OTP_MASK_3			(VA_MISC_BASE + 0x84c)
+#define VA_SPEAR1310_OTP_MASK_4			(VA_MISC_BASE + 0x850)
+#define VA_SPEAR1310_OTP_MASK_5			(VA_MISC_BASE + 0x854)
+#define VA_SPEAR1310_OTP_MASK_6			(VA_MISC_BASE + 0x858)
+#define VA_SPEAR1310_OTP_MASK_7			(VA_MISC_BASE + 0x85c)
+#define VA_SPEAR1310_OTP_MASK_8			(VA_MISC_BASE + 0x860)
+#define VA_SPEAR1310_OTP_RDATA1_1		(VA_MISC_BASE + 0x864)
+#define VA_SPEAR1310_OTP_RDATA1_2		(VA_MISC_BASE + 0x868)
+#define VA_SPEAR1310_OTP_RDATA1_3		(VA_MISC_BASE + 0x86c)
+#define VA_SPEAR1310_OTP_RDATA1_4		(VA_MISC_BASE + 0x870)
+#define VA_SPEAR1310_OTP_RDATA1_5		(VA_MISC_BASE + 0x874)
+#define VA_SPEAR1310_OTP_RDATA1_6		(VA_MISC_BASE + 0x878)
+#define VA_SPEAR1310_OTP_RDATA1_7		(VA_MISC_BASE + 0x87c)
+#define VA_SPEAR1310_OTP_RDATA1_8		(VA_MISC_BASE + 0x880)
+#define VA_SPEAR1310_OTP_RDATA2_1		(VA_MISC_BASE + 0x884)
+#define VA_SPEAR1310_OTP_RDATA2_2		(VA_MISC_BASE + 0x888)
+#define VA_SPEAR1310_OTP_RDATA2_3		(VA_MISC_BASE + 0x88c)
+#define VA_SPEAR1310_OTP_RDATA2_4		(VA_MISC_BASE + 0x890)
+#define VA_SPEAR1310_OTP_RDATA2_5		(VA_MISC_BASE + 0x894)
+#define VA_SPEAR1310_OTP_RDATA2_6		(VA_MISC_BASE + 0x898)
+#define VA_SPEAR1310_OTP_RDATA2_7		(VA_MISC_BASE + 0x89c)
+#define VA_SPEAR1310_OTP_RDATA2_8		(VA_MISC_BASE + 0x8a0)
+#define VA_SPEAR1310_OTP_RDATAM_1		(VA_MISC_BASE + 0x8a4)
+#define VA_SPEAR1310_OTP_RDATAM_2		(VA_MISC_BASE + 0x8a8)
+#define VA_SPEAR1310_OTP_RDATAM_3		(VA_MISC_BASE + 0x8ac)
+#define VA_SPEAR1310_OTP_RDATAM_4		(VA_MISC_BASE + 0x8b0)
+#define VA_SPEAR1310_OTP_RDATAM_5		(VA_MISC_BASE + 0x8b4)
+#define VA_SPEAR1310_OTP_RDATAM_6		(VA_MISC_BASE + 0x8b8)
+#define VA_SPEAR1310_OTP_RDATAM_7		(VA_MISC_BASE + 0x8bc)
+#define VA_SPEAR1310_OTP_RDATAM_8		(VA_MISC_BASE + 0x8c0)
+#define VA_SPEAR1310_THSENS_CFG			(VA_MISC_BASE + 0x8c4)
+
+/* A9SM Register */
+#define VA_SPEAR1310_A9SM_CLUSTERID		(VA_MISC_BASE + 0x900)
+#define VA_SPEAR1310_A9SM_STATUS		(VA_MISC_BASE + 0x904)
+#define VA_SPEAR1310_A9SM_DEBUG			(VA_MISC_BASE + 0x908)
+#define VA_SPEAR1310_A9SM_FILTER		(VA_MISC_BASE + 0x90C)
+#define VA_SPEAR1310_A9SM_PARITY_CFG		(VA_MISC_BASE + 0x910)
+#define VA_SPEAR1310_A9SM_PARITY_ERR		(VA_MISC_BASE + 0x914)
+/* SOC ID Register */
+#define VA_SPEAR1310_DIE_ID_1			(VA_MISC_BASE + 0xa00)
+#define VA_SPEAR1310_DIE_ID_2			(VA_MISC_BASE + 0xa04)
+#define VA_SPEAR1310_DIE_ID_3			(VA_MISC_BASE + 0xa08)
+#define VA_SPEAR1310_DIE_ID_4			(VA_MISC_BASE + 0xa0C)
+
+/* RAS Configuration Registers */
+#define VA_SPEAR1310_RAS1_GPP_INP		(VA_MISC_BASE + 0xb00)
+#define VA_SPEAR1310_RAS2_GPP_INP		(VA_MISC_BASE + 0xb04)
+#define VA_SPEAR1310_RAS1_GPP_OUT		(VA_MISC_BASE + 0xb08)
+#define VA_SPEAR1310_RAS2_GPP_OUT		(VA_MISC_BASE + 0xb0c)
+
+/* MASTERS Trnsaction tagging Register */
+#define VA_SPEAR1310_AXI_CACHE_USER_CTRL_0	(VA_MISC_BASE + 0xc00)
+#define VA_SPEAR1310_AXI_CACHE_USER_CTRL_1	(VA_MISC_BASE + 0xc04)
+#define VA_SPEAR1310_AXI_CACHE_USER_CTRL_2	(VA_MISC_BASE + 0xc08)
+#define VA_SPEAR1310_AXI_CACHE_USER_CTRL_3	(VA_MISC_BASE + 0xc0c)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_0	(VA_MISC_BASE + 0xc10)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_1	(VA_MISC_BASE + 0xc14)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_2	(VA_MISC_BASE + 0xc18)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_3	(VA_MISC_BASE + 0xc1c)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_4	(VA_MISC_BASE + 0xc20)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_5	(VA_MISC_BASE + 0xc24)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_6	(VA_MISC_BASE + 0xc28)
+#define VA_SPEAR1310_AHB_CACHE_USER_CTRL_7	(VA_MISC_BASE + 0xc2c)
+
+/* SOC TEST and  DEBUG Register */
+#define VA_SPEAR1310_USB_TEST			(VA_MISC_BASE + 0x1000)
+#define VA_SPEAR1310_MISC_CFG			(VA_MISC_BASE + 0x1004)
+
+#endif /* __MACH_SPEAR1310_MISC_REGS_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1310_reva.h b/arch/arm/mach-spear13xx/include/mach/spear1310_reva.h
new file mode 100644
index 0000000..94c8ab5
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1310_reva.h
@@ -0,0 +1,78 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1310_reva.h
+ *
+ * SPEAr1310 Machine specific definition
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifdef CONFIG_CPU_SPEAR1310_REVA
+
+#ifndef __MACH_SPEAR1310_REVA_H
+#define __MACH_SPEAR1310_REVA_H
+
+#define SPEAR1310_REVA_TDM_E1_0_BASE		UL(0x6C200000)
+#define SPEAR1310_REVA_TDM_E1_1_BASE		UL(0x6C300000)
+#define SPEAR1310_REVA_RS485_0_BASE		UL(0x6C400000)
+#define SPEAR1310_REVA_RS485_1_BASE		UL(0x6C500000)
+#define SPEAR1310_REVA_GETH1_BASE		UL(0x6D000000)
+#define SPEAR1310_REVA_GETH2_BASE		UL(0x6D100000)
+#define SPEAR1310_REVA_GETH3_BASE		UL(0x6D200000)
+#define SPEAR1310_REVA_GETH4_BASE		UL(0x6D300000)
+#define SPEAR1310_REVA_UART1_BASE		UL(0x6D400000)
+#define SPEAR1310_REVA_UART2_BASE		UL(0x6D500000)
+#define SPEAR1310_REVA_UART3_BASE		UL(0x6D600000)
+#define SPEAR1310_REVA_UART4_BASE		UL(0x6D700000)
+#define SPEAR1310_REVA_UART5_BASE		UL(0x6D800000)
+#define SPEAR1310_REVA_I2C1_BASE		UL(0x6D900000)
+#define SPEAR1310_REVA_CAN0_BASE		UL(0x6DA00000)
+#define SPEAR1310_REVA_CAN1_BASE		UL(0x6DB00000)
+#define SPEAR1310_REVA_RAS_BASE			UL(0x6C800000)
+#define SPEAR1310_REVA_FSMC1_CS0_BASE		UL(0x70000000)
+#define SPEAR1310_REVA_FSMC1_CS1_BASE		UL(0x74000000)
+#define SPEAR1310_REVA_FSMC1_CS2_BASE		UL(0x78000000)
+#define SPEAR1310_REVA_FSMC1_CS3_BASE		UL(0x7C000000)
+#define SPEAR1310_REVA_FSMC1_BASE		UL(0x6FF00000)
+
+/* RAS Area Control Register */
+#define SPEAR1310_REVA_RAS_CTRL_REG0		(SPEAR1310_REVA_RAS_BASE + 0x0)
+	#define TDM_CLK_PLL3		0
+	#define TDM_CLK_RAS_SYNT1	1
+	#define TDM_CLK_MASK		3
+	#define TDM_CLK_SHIFT		25
+#define SPEAR1310_REVA_RAS_CTRL_REG1		(SPEAR1310_REVA_RAS_BASE + 0x4)
+
+#define SPEAR1310_REVA_RAS_TX50M_VAL		0x0	/* Only for RMII */
+#define SPEAR1310_REVA_RAS_TX125M_PAD_VAL	0x1	/* Only for SMII */
+#define SPEAR1310_REVA_RAS_PLL2_VAL		0x2
+#define SPEAR1310_REVA_RAS_SYNTH0_VAL		0x3
+#define SPEAR1310_REVA_PHY_CLK_MASK		0x3
+#define SPEAR1310_REVA_RMII_PHY_CLK_SHIFT	0
+#define SPEAR1310_REVA_SMII_RGMII_PHY_CLK_SHIFT	2
+
+#define SPEAR1310_REVA_GETH1_PHY_INTF_MASK	(0x7 << 4)
+#define SPEAR1310_REVA_GETH2_PHY_INTF_MASK	(0x7 << 7)
+#define SPEAR1310_REVA_GETH3_PHY_INTF_MASK	(0x7 << 10)
+#define SPEAR1310_REVA_GETH4_PHY_INTF_MASK	(0x7 << 13)
+#define SPEAR1310_REVA_PHY_RGMII_VAL		0x1
+#define SPEAR1310_REVA_PHY_RMII_VAL		0x4
+#define SPEAR1310_REVA_PHY_SMII_VAL		0x6
+
+#define RAS_FSMC_MODE_MASK		0x3
+#define RAS_FSMC_MODE_NOR		0
+#define RAS_FSMC_MODE_NAND		1
+#define RAS_FSMC_MODE_SRAM		2
+#define RAS_FSMC_WIDTH_MASK		0x30
+#define RAS_FSMC_WIDTH_8		0x00
+#define RAS_FSMC_WIDTH_16		0x10
+#define RAS_FSMC_WIDTH_32		0x20
+#define RAS_FSMC_CS_SPLIT		0x40
+
+#endif /* __MACH_SPEAR1310_REVA_H */
+
+#endif /* CONFIG_CPU_SPEAR1310_REVA */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1340.h b/arch/arm/mach-spear13xx/include/mach/spear1340.h
new file mode 100644
index 0000000..a13a9dd
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1340.h
@@ -0,0 +1,59 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1340.h
+ *
+ * SPEAr1340 Machine specific definition
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifdef CONFIG_CPU_SPEAR1340
+
+#ifndef __MACH_SPEAR1340_H
+#define __MACH_SPEAR1340_H
+
+#define SPEAR1340_FSMC_NAND_BASE	UL(0xB0800000)
+#define SPEAR1340_SATA_BASE		UL(0xB1000000) /* Configuration space */
+#define SPEAR1340_I2S_REC_BASE		UL(0xB2000000)
+#define SPEAR1340_I2S_PLAY_BASE		UL(0xB2400000)
+#define SPEAR1340_I2C1_BASE		UL(0xB4000000)
+#define SPEAR1340_UART1_BASE		UL(0xB4100000)
+#define SPEAR1340_SPDIF_OUT_BASE	UL(0xD0000000)
+#define SPEAR1340_SPDIF_IN_BASE		UL(0xD0100000)
+#define SPEAR1340_SPDIF_IN_FIFO_BASE	UL(0xD0110000)
+#define SPEAR1340_CAM0_BASE		UL(0xD0200000)
+#define SPEAR1340_CAM1_BASE		UL(0xD0300000)
+#define SPEAR1340_CAM2_BASE		UL(0xD0400000)
+#define SPEAR1340_CAM3_BASE		UL(0xD0500000)
+#define SPEAR1340_CEC0_BASE		UL(0xD0600000)
+#define SPEAR1340_CEC1_BASE		UL(0xD0700000)
+#define SPEAR1340_VIP_BASE		UL(0xD0800000)
+#define SPEAR1340_GPU_BASE		UL(0xD0900000)
+#define SPEAR1340_PWM_BASE		UL(0xE0180000)
+
+#define SPEAR1340_PLGPIO_BASE		UL(0xE2800000)
+/* PLGPIO Registers */
+/* gpio direction */
+#define SPEAR1340_PLGPIO_DIR_OFF	0x000
+/* read data */
+#define SPEAR1340_PLGPIO_RDATA_OFF	0x020
+/* write data */
+#define SPEAR1340_PLGPIO_WDATA_OFF	0x040
+/* edge interrupt type, 0: falling, 1: rising */
+#define SPEAR1340_PLGPIO_EIT_OFF	0x060
+/* interrupt enable */
+#define SPEAR1340_PLGPIO_IE_OFF		0x080
+/* Masked interrupt status */
+#define SPEAR1340_PLGPIO_MIS_OFF	0x0A0
+
+#define SPEAR1340_UOC_BASE		UL(0xE3800000)
+#define SPEAR1340_VIDEO_ENC_BASE	UL(0xEBC00000)
+#define SPEAR1340_VIDEO_DEC_BASE	UL(0xEBD00000)
+
+#endif /* __MACH_SPEAR1340_H */
+
+#endif /* CONFIG_CPU_SPEAR1340 */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear1340_misc_regs.h b/arch/arm/mach-spear13xx/include/mach/spear1340_misc_regs.h
new file mode 100644
index 0000000..9c3305c
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear1340_misc_regs.h
@@ -0,0 +1,563 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear1340_misc_regs.h
+ *
+ * Miscellaneous registers definitions for spear13xx machine family
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SPEAR1340_MISC_REGS_H
+#define __MACH_SPEAR1340_MISC_REGS_H
+
+#include <mach/hardware.h>
+
+#define VA_MISC_BASE				IOMEM(VA_SPEAR13XX_MISC_BASE)
+
+/* General Configuration */
+#define VA_SPEAR1340_SOC_CFG			(VA_MISC_BASE + 0x000)
+#define VA_SPEAR1340_BOOTSTRAP_CFG		(VA_MISC_BASE + 0x004)
+
+/* Power Management Registers */
+#define VA_SPEAR1340_PCM_CFG			(VA_MISC_BASE + 0x100)
+#define VA_SPEAR1340_PCM_WKUP_CFG		(VA_MISC_BASE + 0x104)
+#define VA_SPEAR1340_SWITCH_CTR			(VA_MISC_BASE + 0x108)
+
+/* Clock Configuration Registers */
+/*
+ * Some of the individual defines (mode related) for this register is
+ * present in generic misc_regs.h as it is common across 13xx variants
+ */
+#define VA_SPEAR1340_SYS_CLK_CTRL		(VA_MISC_BASE + 0x200)
+	#define SPEAR1340_HCLK_SRC_SEL_SHIFT	27
+	#define SPEAR1340_HCLK_SRC_SEL_MASK	1
+	#define SPEAR1340_HCLK_SRC_CPU		0
+	#define SPEAR1340_HCLK_SRC_SYNT		1
+
+	#define SPEAR1340_SCLK_SRC_SEL_SHIFT	23
+	#define SPEAR1340_SCLK_SRC_SEL_MASK	7
+	/*
+	 * Following is actualy 0xxb but defined as 001b, as BootROM
+	 * initializes these bits as 001b
+	 */
+	#define SPEAR1340_SCLK_SRC_PLL1		1
+	#define SPEAR1340_SCLK_SRC_SYNT		4
+	#define SPEAR1340_SCLK_SRC_PLL2		6
+	#define SPEAR1340_SCLK_SRC_PLL3		7
+
+#define VA_SPEAR1340_SYS_SW_RES			(VA_MISC_BASE + 0x204)
+#define VA_SPEAR1340_SYS_CLK_PLLTIMER		(VA_MISC_BASE + 0x208)
+#define VA_SPEAR1340_SYS_CLK_OSCITIMER		(VA_MISC_BASE + 0x20C)
+
+/* PLL related registers and bit values */
+#define VA_SPEAR1340_PLL_CFG			(VA_MISC_BASE + 0x210)
+	/* PLL_CFG bit values */
+	#define SPEAR1340_CLCD_SYNT_VCO1_DIV4_VAL	0
+	#define SPEAR1340_CLCD_SYNT_PLL2_VAL		1
+	#define SPEAR1340_CLCD_SYNT_CLK_MASK		1
+	#define SPEAR1340_CLCD_SYNT_CLK_SHIFT		31
+	#define SPEAR1340_GEN_SYNT2_3_VCO1_DIV4_VAL	0
+	#define SPEAR1340_GEN_SYNT2_3_VCO2_DIV2_VAL	1
+	#define SPEAR1340_GEN_SYNT2_3_PLL2_VAL		2
+	#define SPEAR1340_GEN_SYNT2_3_CLK_MASK		3
+	#define SPEAR1340_GEN_SYNT2_3_CLK_SHIFT		29
+	#define SPEAR1340_GEN_SYNT0_1_VCO1_DIV4_VAL	0
+	#define SPEAR1340_GEN_SYNT0_1_VCO3_DIV2_VAL	1
+	#define SPEAR1340_GEN_SYNT0_1_PLL3_VAL		2
+	#define SPEAR1340_GEN_SYNT0_1_CLK_MASK		3
+	#define SPEAR1340_GEN_SYNT0_1_CLK_SHIFT		27
+	#define SPEAR1340_OSC_24M_VAL			0
+	#define SPEAR1340_OSC_25M_VAL			1
+	#define SPEAR1340_PLL_CLK_MASK			3
+	#define SPEAR1340_PLL3_CLK_SHIFT		24
+	#define SPEAR1340_PLL2_CLK_SHIFT		22
+	#define SPEAR1340_PLL1_CLK_SHIFT		20
+
+#define VA_SPEAR1340_PLL1_CTR			(VA_MISC_BASE + 0x214)
+#define VA_SPEAR1340_PLL1_FRQ			(VA_MISC_BASE + 0x218)
+#define VA_SPEAR1340_PLL1_MOD			(VA_MISC_BASE + 0x21C)
+#define VA_SPEAR1340_PLL2_CTR			(VA_MISC_BASE + 0x220)
+#define VA_SPEAR1340_PLL2_FRQ			(VA_MISC_BASE + 0x224)
+#define VA_SPEAR1340_PLL2_MOD			(VA_MISC_BASE + 0x228)
+#define VA_SPEAR1340_PLL3_CTR			(VA_MISC_BASE + 0x22C)
+#define VA_SPEAR1340_PLL3_FRQ			(VA_MISC_BASE + 0x230)
+#define VA_SPEAR1340_PLL3_MOD			(VA_MISC_BASE + 0x234)
+#define VA_SPEAR1340_PLL4_CTR			(VA_MISC_BASE + 0x238)
+	/* PLL_CTR register masks */
+	#define SPEAR1340_PLL_MODE_NORMAL		0
+	#define SPEAR1340_PLL_MODE_FRACTION		1
+	#define SPEAR1340_PLL_MODE_DITH_DSM		2
+	#define SPEAR1340_PLL_MODE_DITH_SSM		3
+	#define SPEAR1340_PLL_MODE_MASK			3
+	#define SPEAR1340_PLL_MODE_SHIFT		4
+	#define SPEAR1340_PLL_ENABLE			2
+
+	#define SPEAR1340_PLL_LOCK_SHIFT		0
+	#define SPEAR1340_PLL_LOCK_MASK			1
+
+#define VA_SPEAR1340_PLL4_FRQ			(VA_MISC_BASE + 0x23C)
+	/* PLL FRQ register masks */
+	#define SPEAR1340_PLL_NORM_FDBK_M_MASK		0xFF
+	#define SPEAR1340_PLL_NORM_FDBK_M_SHIFT		24
+	#define SPEAR1340_PLL_DITH_FDBK_M_MASK		0xFFFF
+	#define SPEAR1340_PLL_DITH_FDBK_M_SHIFT		16
+	#define SPEAR1340_PLL_DIV_P_MASK		0x7
+	#define SPEAR1340_PLL_DIV_P_SHIFT		8
+	#define SPEAR1340_PLL_DIV_N_MASK		0xFF
+	#define SPEAR1340_PLL_DIV_N_SHIFT		0
+
+#define VA_SPEAR1340_PLL4_MOD			(VA_MISC_BASE + 0x240)
+#define VA_SPEAR1340_PERIP_CLK_CFG		(VA_MISC_BASE + 0x244)
+	/* PERIP_CLK_CFG bit values */
+	#define SPEAR1340_SPDIF_OUT_I2S_PAD_VAL		0
+	#define SPEAR1340_SPDIF_OUT_GSYNT2_VAL		1
+	#define SPEAR1340_SPDIF_CLK_MASK		1
+	#define SPEAR1340_SPDIF_OUT_CLK_SHIFT		15
+	#define SPEAR1340_SPDIF_IN_PLL2_VAL		0
+	#define SPEAR1340_SPDIF_IN_GSYNT3_VAL		1
+	#define SPEAR1340_SPDIF_IN_CLK_SHIFT		14
+	#define SPEAR1340_GPT3_CLK_SHIFT		13
+	#define SPEAR1340_GPT2_CLK_SHIFT		12
+	#define SPEAR1340_GPT_OSC24_VAL			0
+	#define SPEAR1340_GPT_APB_VAL			1
+	#define SPEAR1340_GPT_CLK_MASK			1
+	#define SPEAR1340_GPT1_CLK_SHIFT		9
+	#define SPEAR1340_GPT0_CLK_SHIFT		8
+	#define SPEAR1340_UART_CLK_PLL5_VAL		0
+	#define SPEAR1340_UART_CLK_OSC24_VAL		1
+	#define SPEAR1340_UART_CLK_SYNT_VAL		2
+	#define SPEAR1340_UART_CLK_MASK			3
+	#define SPEAR1340_UART1_CLK_SHIFT		6
+	#define SPEAR1340_UART0_CLK_SHIFT		4
+
+	#define SPEAR1340_AUX_CLK_PLL5_VAL		0
+	#define SPEAR1340_AUX_CLK_SYNT_VAL		1
+	#define SPEAR1340_CLCD_CLK_MASK			3
+	#define SPEAR1340_CLCD_CLK_SHIFT		2
+	#define SPEAR1340_C3_CLK_MASK			1
+	#define SPEAR1340_C3_CLK_SHIFT			1
+
+#define SPEAR1340_GMAC_CLK_CFG			(SPEAR13XX_MISC_BASE + 0x248)
+#define VA_SPEAR1340_GMAC_CLK_CFG		(VA_MISC_BASE + 0x248)
+	#define SPEAR1340_GMAC_PHY_IF_GMII_VAL		(0 << 3)
+	#define SPEAR1340_GMAC_PHY_IF_RGMII_VAL		(1 << 3)
+	#define SPEAR1340_GMAC_PHY_IF_SGMII_VAL		(2 << 3)
+	#define SPEAR1340_GMAC_PHY_IF_RMII_VAL		(4 << 3)
+	#define SPEAR1340_GMAC_PHY_IF_SEL_MASK		(7 << 3)
+	#define SPEAR1340_GMAC_PHY_INPUT_ENB_VAL	0
+	#define SPEAR1340_GMAC_PHY_SYNT_ENB_VAL		1
+	#define SPEAR1340_GMAC_PHY_CLK_MASK		1
+	#define SPEAR1340_GMAC_PHY_CLK_SHIFT		2
+	#define SPEAR1340_GMAC_PHY_125M_PAD_VAL		0
+	#define SPEAR1340_GMAC_PHY_PLL2_VAL		1
+	#define SPEAR1340_GMAC_PHY_OSC3_VAL		2
+	#define SPEAR1340_GMAC_PHY_INPUT_CLK_MASK	3
+	#define SPEAR1340_GMAC_PHY_INPUT_CLK_SHIFT	0
+
+#define VA_SPEAR1340_I2S_CLK_CFG		(VA_MISC_BASE + 0x24C)
+	/* I2S_CLK_CFG register mask */
+	#define SPEAR1340_I2S_SCLK_X_MASK		0x1F
+	#define SPEAR1340_I2S_SCLK_X_SHIFT		27
+	#define SPEAR1340_I2S_SCLK_Y_MASK		0x1F
+	#define SPEAR1340_I2S_SCLK_Y_SHIFT		22
+	#define SPEAR1340_I2S_SCLK_EQ_SEL_SHIFT		21
+	#define SPEAR1340_I2S_SCLK_SYNTH_ENB		20
+	#define SPEAR1340_I2S_PRS1_CLK_X_MASK		0xFF
+	#define SPEAR1340_I2S_PRS1_CLK_X_SHIFT		12
+	#define SPEAR1340_I2S_PRS1_CLK_Y_MASK		0xFF
+	#define SPEAR1340_I2S_PRS1_CLK_Y_SHIFT		4
+	#define SPEAR1340_I2S_PRS1_EQ_SEL_SHIFT		3
+	#define SPEAR1340_I2S_REF_SRC_VAL		0
+	#define SPEAR1340_I2S_REF_PRS1_VAL		1
+	#define SPEAR1340_I2S_REF_SEL_MASK		1
+	#define SPEAR1340_I2S_REF_SHIFT			2
+	#define SPEAR1340_I2S_SRC_VCO1DIV2_VAL		0
+	#define SPEAR1340_I2S_SRC_PLL2_VAL		1
+	#define SPEAR1340_I2S_SRC_PLL3_VAL		2
+	#define SPEAR1340_I2S_SRC_PL_CLK1_VAL		3
+	#define SPEAR1340_I2S_SRC_CLK_MASK		3
+	#define SPEAR1340_I2S_SRC_CLK_SHIFT		0
+
+#define VA_SPEAR1340_C3_CLK_SYNT		(VA_MISC_BASE + 0x250)
+#define VA_SPEAR1340_UART0_CLK_SYNT		(VA_MISC_BASE + 0x254)
+#define VA_SPEAR1340_UART1_CLK_SYNT		(VA_MISC_BASE + 0x258)
+#define VA_SPEAR1340_GMAC_CLK_SYNT		(VA_MISC_BASE + 0x25C)
+#define VA_SPEAR1340_SDHCI_CLK_SYNT		(VA_MISC_BASE + 0x260)
+#define VA_SPEAR1340_CFXD_CLK_SYNT		(VA_MISC_BASE + 0x264)
+#define VA_SPEAR1340_ADC_CLK_SYNT		(VA_MISC_BASE + 0x270)
+	/* aux clk synthesizer register masks */
+	#define SPEAR1340_AUX_SYNT_ENB			31
+	#define SPEAR1340_AUX_EQ_SEL_SHIFT		30
+	#define SPEAR1340_AUX_EQ_SEL_MASK		1
+	#define SPEAR1340_AUX_EQ1_SEL			0
+	#define SPEAR1340_AUX_EQ2_SEL			1
+	#define SPEAR1340_AUX_XSCALE_SHIFT		16
+	#define SPEAR1340_AUX_XSCALE_MASK		0xFFF
+	#define SPEAR1340_AUX_YSCALE_SHIFT		0
+	#define SPEAR1340_AUX_YSCALE_MASK		0xFFF
+
+#define VA_SPEAR1340_AMBA_CLK_SYNT		(VA_MISC_BASE + 0x274)
+	/* Fractional synthesizer reg masks */
+	#define SPEAR1340_FRAC_SYNT_ENB			18
+	#define SPEAR1340_FRAC_SYNT_DIV_FACTOR_MASK	0x1ffff
+	#define SPEAR1340_FRAC_SYNT_DIV_FACTOR_SHIFT	0
+
+#define VA_SPEAR1340_AMBA_CLK_SYNT_MOD		(VA_MISC_BASE + 0x278)
+#define VA_SPEAR1340_CLCD_CLK_SYNT		(VA_MISC_BASE + 0x27C)
+#define VA_SPEAR1340_CLCD_CLK_SYNT_MOD		(VA_MISC_BASE + 0x280)
+#define VA_SPEAR1340_SYS_CLK_SYNT		(VA_MISC_BASE + 0x284)
+#define VA_SPEAR1340_CPU_CLK_SYNT_MOD		(VA_MISC_BASE + 0x288)
+#define VA_SPEAR1340_GEN_CLK_SYNT0		(VA_MISC_BASE + 0x28C)
+#define VA_SPEAR1340_GEN_CLK_SYNT0_MOD		(VA_MISC_BASE + 0x290)
+#define VA_SPEAR1340_GEN_CLK_SYNT1		(VA_MISC_BASE + 0x294)
+#define VA_SPEAR1340_GEN_CLK_SYNT1_MOD		(VA_MISC_BASE + 0x298)
+#define VA_SPEAR1340_GEN_CLK_SYNT2		(VA_MISC_BASE + 0x29C)
+#define VA_SPEAR1340_GEN_CLK_SYNT2_MOD		(VA_MISC_BASE + 0x300)
+#define VA_SPEAR1340_GEN_CLK_SYNT3		(VA_MISC_BASE + 0x304)
+#define VA_SPEAR1340_GEN_CLK_SYNT3_MOD		(VA_MISC_BASE + 0x308)
+	/* Check Fractional synthesizer reg masks */
+
+#define VA_SPEAR1340_PERIP1_CLK_ENB		(VA_MISC_BASE + 0x30C)
+	/* PERIP1_CLK_ENB register masks */
+	#define SPEAR1340_RTC_CLK_ENB			31
+	#define SPEAR1340_ADC_CLK_ENB			30
+	#define SPEAR1340_C3_CLK_ENB			29
+	#define SPEAR1340_CLCD_CLK_ENB			27
+	#define SPEAR1340_DMA_CLK_ENB			25
+	#define SPEAR1340_GPIO1_CLK_ENB			24
+	#define SPEAR1340_GPIO0_CLK_ENB			23
+	#define SPEAR1340_GPT1_CLK_ENB			22
+	#define SPEAR1340_GPT0_CLK_ENB			21
+	#define SPEAR1340_I2S_PLAY_CLK_ENB		20
+	#define SPEAR1340_I2S_REC_CLK_ENB		19
+	#define SPEAR1340_I2C0_CLK_ENB			18
+	#define SPEAR1340_SSP_CLK_ENB			17
+	#define SPEAR1340_UART0_CLK_ENB			15
+	#define SPEAR1340_PCIE_SATA_CLK_ENB		12
+	#define SPEAR1340_UOC_CLK_ENB			11
+	#define SPEAR1340_UHC1_CLK_ENB			10
+	#define SPEAR1340_UHC0_CLK_ENB			9
+	#define SPEAR1340_GMAC_CLK_ENB			8
+	#define SPEAR1340_CFXD_CLK_ENB			7
+	#define SPEAR1340_SDHCI_CLK_ENB			6
+	#define SPEAR1340_SMI_CLK_ENB			5
+	#define SPEAR1340_FSMC_CLK_ENB			4
+	#define SPEAR1340_SYSRAM0_CLK_ENB		3
+	#define SPEAR1340_SYSRAM1_CLK_ENB		2
+	#define SPEAR1340_SYSROM_CLK_ENB		1
+	#define SPEAR1340_BUS_CLK_ENB			0
+
+#define VA_SPEAR1340_PERIP2_CLK_ENB		(VA_MISC_BASE + 0x310)
+	/* PERIP2_CLK_ENB register masks */
+	#define SPEAR1340_THSENS_CLK_ENB		8
+	#define SPEAR1340_I2S_REF_PAD_CLK_ENB		7
+	#define SPEAR1340_ACP_CLK_ENB			6
+	#define SPEAR1340_GPT3_CLK_ENB			5
+	#define SPEAR1340_GPT2_CLK_ENB			4
+	#define SPEAR1340_KBD_CLK_ENB			3
+	#define SPEAR1340_CPU_DBG_CLK_ENB		2
+	#define SPEAR1340_DDR_CORE_CLK_ENB		1
+	#define SPEAR1340_DDR_CTRL_CLK_ENB		0
+
+#define VA_SPEAR1340_PERIP3_CLK_ENB		(VA_MISC_BASE + 0x314)
+	/* PERIP2_CLK_ENB register masks */
+	#define SPEAR1340_PLGPIO_CLK_ENB		18
+	#define SPEAR1340_VIDEO_DEC_CLK_ENB		16
+	#define SPEAR1340_VIDEO_ENC_CLK_ENB		15
+	#define SPEAR1340_SPDIF_OUT_CLK_ENB		13
+	#define SPEAR1340_SPDIF_IN_CLK_ENB		12
+	#define SPEAR1340_VIDEO_IN_CLK_ENB		11
+	#define SPEAR1340_CAM0_CLK_ENB			10
+	#define SPEAR1340_CAM1_CLK_ENB			9
+	#define SPEAR1340_CAM2_CLK_ENB			8
+	#define SPEAR1340_CAM3_CLK_ENB			7
+	#define SPEAR1340_MALI_CLK_ENB			6
+	#define SPEAR1340_CEC0_CLK_ENB			5
+	#define SPEAR1340_CEC1_CLK_ENB			4
+	#define SPEAR1340_PWM_CLK_ENB			3
+	#define SPEAR1340_I2C1_CLK_ENB			2
+	#define SPEAR1340_UART1_CLK_ENB			1
+
+#define VA_SPEAR1340_PERIP1_SW_RST		(VA_MISC_BASE + 0x318)
+	#define SPEAR1340_UOC_RST_ENB			11
+
+#define VA_SPEAR1340_PERIP2_SW_RST		(VA_MISC_BASE + 0x31C)
+#define VA_SPEAR1340_PERIP3_SW_RST		(VA_MISC_BASE + 0x320)
+	#define SPEAR1340_SPDIF_IN_RST			(1 << 12)
+	#define SPEAR1340_CAM0_RST			(1 << 10)
+	#define SPEAR1340_CAM1_RST			(1 << 9)
+	#define SPEAR1340_CAM2_RST			(1 << 8)
+	#define SPEAR1340_CAM3_RST			(1 << 7)
+/* Peripherial Configuration Registers */
+#define VA_SPEAR1340_DMAC_HS_SEL		(VA_MISC_BASE + 0x400)
+#define VA_SPEAR1340_DMAC_SEL			(VA_MISC_BASE + 0x404)
+#define VA_SPEAR1340_DMAC_FLOW_SEL		(VA_MISC_BASE + 0x408)
+#define VA_SPEAR1340_DMAC_DIR_SEL		(VA_MISC_BASE + 0x40C)
+#define VA_SPEAR1340_ENDIANESS_CFG		(VA_MISC_BASE + 0x410)
+#define VA_SPEAR1340_USBPHY_GEN_CFG		(VA_MISC_BASE + 0x414)
+	#define SPEAR1340_USBPLLLOCK		(1 << 24)
+	#define SPEAR1340_USBPHYRST		(1 << 15)
+	#define SPEAR1340_USBPRSNT		(1 << 13)
+	#define SPEAR1340_USBPHYPOR		(1 << 12)
+
+#define VA_SPEAR1340_USBPHY_P1_CFG		(VA_MISC_BASE + 0x418)
+#define VA_SPEAR1340_USBPHY_P2_CFG		(VA_MISC_BASE + 0x41C)
+#define VA_SPEAR1340_USBPHY_P3_CFG		(VA_MISC_BASE + 0x420)
+
+#define SPEAR1340_PCIE_SATA_CFG			(SPEAR13XX_MISC_BASE + 0x424)
+#define VA_SPEAR1340_PCIE_SATA_CFG		(VA_MISC_BASE + 0x424)
+	/* PCIE CFG MASks */
+	#define SPEAR1340_PCIE_CFG_DEVICE_PRESENT	(1 << 11)
+	#define SPEAR1340_PCIE_CFG_POWERUP_RESET	(1 << 10)
+	#define SPEAR1340_PCIE_CFG_CORE_CLK_EN		(1 << 9)
+	#define SPEAR1340_PCIE_CFG_AUX_CLK_EN		(1 << 8)
+	#define SPEAR1340_SATA_CFG_TX_CLK_EN		(1 << 4)
+	#define SPEAR1340_SATA_CFG_RX_CLK_EN		(1 << 3)
+	#define SPEAR1340_SATA_CFG_POWERUP_RESET	(1 << 2)
+	#define SPEAR1340_SATA_CFG_PM_CLK_EN		(1 << 1)
+	#define SPEAR1340_PCIE_SATA_SEL_PCIE		(0)
+	#define SPEAR1340_PCIE_SATA_SEL_SATA		(1)
+	#define SPEAR1340_SATA_PCIE_CFG_MASK		0xF1F
+	#define SPEAR1340_PCIE_CFG_VAL	(SPEAR1340_PCIE_SATA_SEL_PCIE | \
+			SPEAR1340_PCIE_CFG_AUX_CLK_EN | \
+			SPEAR1340_PCIE_CFG_CORE_CLK_EN | \
+			SPEAR1340_PCIE_CFG_POWERUP_RESET | \
+			SPEAR1340_PCIE_CFG_DEVICE_PRESENT)
+	#define SPEAR1340_SATA_CFG_VAL	(SPEAR1340_PCIE_SATA_SEL_SATA | \
+			SPEAR1340_SATA_CFG_PM_CLK_EN | \
+			SPEAR1340_SATA_CFG_POWERUP_RESET | \
+			SPEAR1340_SATA_CFG_RX_CLK_EN | \
+			SPEAR1340_SATA_CFG_TX_CLK_EN)
+
+#define VA_SPEAR1340_PCIE_MIPHY_CFG		(VA_MISC_BASE + 0x428)
+	#define SPEAR1340_MIPHY_OSC_BYPASS_EXT		(1 << 31)
+	#define SPEAR1340_MIPHY_CLK_REF_DIV2		(1 << 27)
+	#define SPEAR1340_MIPHY_CLK_REF_DIV4		(2 << 27)
+	#define SPEAR1340_MIPHY_CLK_REF_DIV8		(3 << 27)
+	#define SPEAR1340_MIPHY_PLL_RATIO_TOP(x)	(x << 0)
+	#define SPEAR1340_PCIE_SATA_MIPHY_CFG_SATA \
+			(SPEAR1340_MIPHY_OSC_BYPASS_EXT | \
+			SPEAR1340_MIPHY_CLK_REF_DIV2 | \
+			SPEAR1340_MIPHY_PLL_RATIO_TOP(60))
+	#define SPEAR1340_PCIE_SATA_MIPHY_CFG_SATA_25M_CRYSTAL_CLK \
+			(SPEAR1340_MIPHY_PLL_RATIO_TOP(120))
+	#define SPEAR1340_PCIE_SATA_MIPHY_CFG_PCIE \
+			(SPEAR1340_MIPHY_OSC_BYPASS_EXT | \
+			SPEAR1340_MIPHY_PLL_RATIO_TOP(25))
+
+#define VA_SPEAR1340_PERIP_CFG			(VA_MISC_BASE + 0x42C)
+#define SPEAR1340_PERIP_CFG			(SPEAR13XX_MISC_BASE + 0x42C)
+	/* PERIP_CFG register masks */
+	#define SPEAR1340_SSP_CS_CTL_HW			0
+	#define SPEAR1340_SSP_CS_CTL_SW			1
+	#define SPEAR1340_SSP_CS_CTL_MASK		1
+	#define SPEAR1340_SSP_CS_CTL_SHIFT		21
+	#define SPEAR1340_SSP_CS_VAL_MASK		1
+	#define SPEAR1340_SSP_CS_VAL_SHIFT		20
+	#define SPEAR1340_SSP_CS_SEL_CS0		0
+	#define SPEAR1340_SSP_CS_SEL_CS1		1
+	#define SPEAR1340_SSP_CS_SEL_CS2		2
+	#define SPEAR1340_SSP_CS_SEL_MASK		3
+	#define SPEAR1340_SSP_CS_SEL_SHIFT		18
+
+	#define SPEAR1340_I2S_CHNL_2_0			(0)
+	#define SPEAR1340_I2S_CHNL_3_1			(1)
+	#define SPEAR1340_I2S_CHNL_5_1			(2)
+	#define SPEAR1340_I2S_CHNL_7_1			(3)
+	#define SPEAR1340_I2S_CHNL_PLAY_SHIFT		(4)
+	#define SPEAR1340_I2S_CHNL_PLAY_MASK		(3 << 4)
+	#define SPEAR1340_I2S_CHNL_REC_SHIFT		(6)
+	#define SPEAR1340_I2S_CHNL_REC_MASK		(3 << 6)
+
+	#define SPEAR1340_SPDIF_OUT_ENB_MASK		(1 << 2)
+	#define SPEAR1340_SPDIF_OUT_ENB_SHIFT		2
+
+	#define SPEAR1340_MCIF_SEL_SD			1
+	#define SPEAR1340_MCIF_SEL_CF			2
+	#define SPEAR1340_MCIF_SEL_XD			3
+	#define SPEAR1340_MCIF_SEL_MASK			3
+	#define SPEAR1340_MCIF_SEL_SHIFT		0
+
+#define VA_SPEAR1340_FSMC_CFG			(VA_MISC_BASE + 0x430)
+	/* FSMC_CFG register masks */
+	#define SPEAR1340_NAND_DEV_WIDTH16		4
+	#define SPEAR1340_NAND_BANK_MASK		3
+	#define SPEAR1340_NAND_BANK_SHIFT		2
+	#define SPEAR1340_FSMC_MEM_NOR			0
+	#define SPEAR1340_FSMC_MEM_NAND			1
+	#define SPEAR1340_FSMC_MEM_SRAM			2
+	#define SPEAR1340_FSMC_MEMSEL_MASK		3
+	#define SPEAR1340_FSMC_MEMSEL_SHIFT		0
+
+#define VA_SPEAR1340_MPMC_CFG			(VA_MISC_BASE + 0x434)
+#define VA_SPEAR1340_MPMC_CTR_STS		(VA_MISC_BASE + 0x438)
+#define VA_SPEAR1340_SATA_CORE_ID		(VA_MISC_BASE + 0x43C)
+#define VA_SPEAR1340_MALI_GEN_PURPOSE_1		(VA_MISC_BASE + 0x440)
+#define VA_SPEAR1340_MALI_GEN_PURPOSE_2		(VA_MISC_BASE + 0x444)
+/* Inter-Processor Communication Register */
+#define VA_SPEAR1340_PRC1_LOCK_CTR		(VA_MISC_BASE + 0x500)
+#define VA_SPEAR1340_PRC2_LOCK_CTR		(VA_MISC_BASE + 0x504)
+#define VA_SPEAR1340_PRC1_IRQ_CTR		(VA_MISC_BASE + 0x508)
+#define VA_SPEAR1340_PRC2_IRQ_CTR		(VA_MISC_BASE + 0x51C)
+
+/* Pad Configuration Registers */
+#define VA_SPEAR1340_PAD_PU_CFG_1		(VA_MISC_BASE + 0x600)
+#define SPEAR1340_PAD_PU_CFG_1			(SPEAR13XX_MISC_BASE + 0x600)
+#define VA_SPEAR1340_PAD_PU_CFG_2		(VA_MISC_BASE + 0x604)
+#define SPEAR1340_PAD_PU_CFG_2			(SPEAR13XX_MISC_BASE + 0x604)
+#define VA_SPEAR1340_PAD_PU_CFG_3		(VA_MISC_BASE + 0x608)
+#define SPEAR1340_PAD_PU_CFG_3			(SPEAR13XX_MISC_BASE + 0x608)
+#define VA_SPEAR1340_PAD_PU_CFG_4		(VA_MISC_BASE + 0x60C)
+#define SPEAR1340_PAD_PU_CFG_4			(SPEAR13XX_MISC_BASE + 0x60C)
+#define VA_SPEAR1340_PAD_PU_CFG_5		(VA_MISC_BASE + 0x610)
+#define SPEAR1340_PAD_PU_CFG_5			(SPEAR13XX_MISC_BASE + 0x610)
+#define VA_SPEAR1340_PAD_PU_CFG_6		(VA_MISC_BASE + 0x614)
+#define SPEAR1340_PAD_PU_CFG_6			(SPEAR13XX_MISC_BASE + 0x614)
+#define VA_SPEAR1340_PAD_PU_CFG_7		(VA_MISC_BASE + 0x618)
+#define SPEAR1340_PAD_PU_CFG_7			(SPEAR13XX_MISC_BASE + 0x618)
+#define VA_SPEAR1340_PAD_PU_CFG_8		(VA_MISC_BASE + 0x61C)
+#define SPEAR1340_PAD_PU_CFG_8			(SPEAR13XX_MISC_BASE + 0x61C)
+#define VA_SPEAR1340_PAD_PD_CFG_1		(VA_MISC_BASE + 0x620)
+#define SPEAR1340_PAD_PD_CFG_1			(SPEAR13XX_MISC_BASE + 0x620)
+#define VA_SPEAR1340_PAD_PD_CFG_2		(VA_MISC_BASE + 0x624)
+#define SPEAR1340_PAD_PD_CFG_2			(SPEAR13XX_MISC_BASE + 0x624)
+#define VA_SPEAR1340_PAD_PD_CFG_3		(VA_MISC_BASE + 0x628)
+#define SPEAR1340_PAD_PD_CFG_3			(SPEAR13XX_MISC_BASE + 0x628)
+#define VA_SPEAR1340_PAD_PD_CFG_4		(VA_MISC_BASE + 0x62C)
+#define SPEAR1340_PAD_PD_CFG_4			(SPEAR13XX_MISC_BASE + 0x62C)
+#define VA_SPEAR1340_PAD_PD_CFG_5		(VA_MISC_BASE + 0x630)
+#define SPEAR1340_PAD_PD_CFG_5			(SPEAR13XX_MISC_BASE + 0x630)
+#define VA_SPEAR1340_PAD_PD_CFG_6		(VA_MISC_BASE + 0x634)
+#define SPEAR1340_PAD_PD_CFG_6			(SPEAR13XX_MISC_BASE + 0x634)
+#define VA_SPEAR1340_PAD_PD_CFG_7		(VA_MISC_BASE + 0x638)
+#define SPEAR1340_PAD_PD_CFG_7			(SPEAR13XX_MISC_BASE + 0x638)
+#define VA_SPEAR1340_PAD_PD_CFG_8		(VA_MISC_BASE + 0x63C)
+#define SPEAR1340_PAD_PD_CFG_8			(SPEAR13XX_MISC_BASE + 0x63C)
+#define VA_SPEAR1340_PAD_DRV_CFG_1		(VA_MISC_BASE + 0x648)
+#define VA_SPEAR1340_PAD_DRV_CFG_2		(VA_MISC_BASE + 0x64C)
+#define VA_SPEAR1340_PAD_DRV_CFG_3		(VA_MISC_BASE + 0x650)
+#define VA_SPEAR1340_PAD_DRV_CFG_4		(VA_MISC_BASE + 0x654)
+#define VA_SPEAR1340_PAD_DRV_CFG_5		(VA_MISC_BASE + 0x658)
+#define VA_SPEAR1340_PAD_SLEW_CFG_1		(VA_MISC_BASE + 0x65C)
+#define VA_SPEAR1340_PAD_SLEW_CFG_2		(VA_MISC_BASE + 0x660)
+#define VA_SPEAR1340_PAD_SLEW_CFG_3		(VA_MISC_BASE + 0x664)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_1		(VA_MISC_BASE + 0x668)
+#define SPEAR1340_PAD_FUNCTION_EN_1		(SPEAR13XX_MISC_BASE + 0x668)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_2		(VA_MISC_BASE + 0x66C)
+#define SPEAR1340_PAD_FUNCTION_EN_2		(SPEAR13XX_MISC_BASE + 0x66C)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_3		(VA_MISC_BASE + 0x670)
+#define SPEAR1340_PAD_FUNCTION_EN_3		(SPEAR13XX_MISC_BASE + 0x670)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_4		(VA_MISC_BASE + 0x674)
+#define SPEAR1340_PAD_FUNCTION_EN_4		(SPEAR13XX_MISC_BASE + 0x674)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_5		(VA_MISC_BASE + 0x690)
+#define SPEAR1340_PAD_FUNCTION_EN_5		(SPEAR13XX_MISC_BASE + 0x690)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_6		(VA_MISC_BASE + 0x694)
+#define SPEAR1340_PAD_FUNCTION_EN_6		(SPEAR13XX_MISC_BASE + 0x694)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_7		(VA_MISC_BASE + 0x698)
+#define SPEAR1340_PAD_FUNCTION_EN_7		(SPEAR13XX_MISC_BASE + 0x698)
+#define VA_SPEAR1340_PAD_FUNCTION_EN_8		(VA_MISC_BASE + 0x69C)
+#define SPEAR1340_PAD_FUNCTION_EN_8		(SPEAR13XX_MISC_BASE + 0x69C)
+#define VA_SPEAR1340_PAD_SHARED_IP_EN_1		(VA_MISC_BASE + 0x6A0)
+#define SPEAR1340_PAD_SHARED_IP_EN_1		(SPEAR13XX_MISC_BASE + 0x6A0)
+#define VA_SPEAR1340_PAD_SHARED_IP_EN_2		(VA_MISC_BASE + 0x6A4)
+#define SPEAR1340_PAD_SHARED_IP_EN_2		(SPEAR13XX_MISC_BASE + 0x6A4)
+#define VA_SPEAR1340_DDR_PAD_CFG		(VA_MISC_BASE + 0x6A8)
+
+/* Compensation Configuration Register */
+#define VA_SPEAR1340_COMPENSATION_1V8_3V3_1_CFG	(VA_MISC_BASE + 0x700)
+#define VA_SPEAR1340_COMPENSATION_1V8_3V3_2_CFG	(VA_MISC_BASE + 0x704)
+#define VA_SPEAR1340_COMPENSATION_3V3_1_CFG	(VA_MISC_BASE + 0x708)
+#define VA_SPEAR1340_COMPENSATION_3V3_2_CFG	(VA_MISC_BASE + 0x70C)
+#define VA_SPEAR1340_COMPENSATION_DDR_CFG	(VA_MISC_BASE + 0x710)
+#define VA_SPEAR1340_COMPENSATION_2V5_3V3_1_CFG	(VA_MISC_BASE + 0x714)
+
+/* OTP  and  THSENS Programming Register */
+#define VA_SPEAR1340_OTP_PROG_CTR		(VA_MISC_BASE + 0x800)
+#define VA_SPEAR1340_OTP_WDATA1_1		(VA_MISC_BASE + 0x804)
+#define VA_SPEAR1340_OTP_WDATA1_2		(VA_MISC_BASE + 0x808)
+#define VA_SPEAR1340_OTP_WDATA1_3		(VA_MISC_BASE + 0x80c)
+#define VA_SPEAR1340_OTP_WDATA1_4		(VA_MISC_BASE + 0x810)
+#define VA_SPEAR1340_OTP_WDATA1_5		(VA_MISC_BASE + 0x814)
+#define VA_SPEAR1340_OTP_WDATA1_6		(VA_MISC_BASE + 0x818)
+#define VA_SPEAR1340_OTP_WDATA1_7		(VA_MISC_BASE + 0x81c)
+#define VA_SPEAR1340_OTP_WDATA1_8		(VA_MISC_BASE + 0x820)
+#define VA_SPEAR1340_OTP_WDATA2_1		(VA_MISC_BASE + 0x824)
+#define VA_SPEAR1340_OTP_WDATA2_2		(VA_MISC_BASE + 0x828)
+#define VA_SPEAR1340_OTP_WDATA2_3		(VA_MISC_BASE + 0x82c)
+#define VA_SPEAR1340_OTP_WDATA2_4		(VA_MISC_BASE + 0x830)
+#define VA_SPEAR1340_OTP_WDATA2_5		(VA_MISC_BASE + 0x834)
+#define VA_SPEAR1340_OTP_WDATA2_6		(VA_MISC_BASE + 0x838)
+#define VA_SPEAR1340_OTP_WDATA2_7		(VA_MISC_BASE + 0x83c)
+#define VA_SPEAR1340_OTP_WDATA2_8		(VA_MISC_BASE + 0x840)
+#define VA_SPEAR1340_OTP_MASK_1			(VA_MISC_BASE + 0x844)
+#define VA_SPEAR1340_OTP_MASK_2			(VA_MISC_BASE + 0x848)
+#define VA_SPEAR1340_OTP_MASK_3			(VA_MISC_BASE + 0x84c)
+#define VA_SPEAR1340_OTP_MASK_4			(VA_MISC_BASE + 0x850)
+#define VA_SPEAR1340_OTP_MASK_5			(VA_MISC_BASE + 0x854)
+#define VA_SPEAR1340_OTP_MASK_6			(VA_MISC_BASE + 0x858)
+#define VA_SPEAR1340_OTP_MASK_7			(VA_MISC_BASE + 0x85c)
+#define VA_SPEAR1340_OTP_MASK_8			(VA_MISC_BASE + 0x860)
+#define VA_SPEAR1340_OTP_RDATA1_1		(VA_MISC_BASE + 0x864)
+#define VA_SPEAR1340_OTP_RDATA1_2		(VA_MISC_BASE + 0x868)
+#define VA_SPEAR1340_OTP_RDATA1_3		(VA_MISC_BASE + 0x86c)
+#define VA_SPEAR1340_OTP_RDATA1_4		(VA_MISC_BASE + 0x870)
+#define VA_SPEAR1340_OTP_RDATA1_5		(VA_MISC_BASE + 0x874)
+#define VA_SPEAR1340_OTP_RDATA1_6		(VA_MISC_BASE + 0x878)
+#define VA_SPEAR1340_OTP_RDATA1_7		(VA_MISC_BASE + 0x87c)
+#define VA_SPEAR1340_OTP_RDATA1_8		(VA_MISC_BASE + 0x880)
+#define VA_SPEAR1340_OTP_RDATA2_1		(VA_MISC_BASE + 0x884)
+#define VA_SPEAR1340_OTP_RDATA2_2		(VA_MISC_BASE + 0x888)
+#define VA_SPEAR1340_OTP_RDATA2_3		(VA_MISC_BASE + 0x88c)
+#define VA_SPEAR1340_OTP_RDATA2_4		(VA_MISC_BASE + 0x890)
+#define VA_SPEAR1340_OTP_RDATA2_5		(VA_MISC_BASE + 0x894)
+#define VA_SPEAR1340_OTP_RDATA2_6		(VA_MISC_BASE + 0x898)
+#define VA_SPEAR1340_OTP_RDATA2_7		(VA_MISC_BASE + 0x89c)
+#define VA_SPEAR1340_OTP_RDATA2_8		(VA_MISC_BASE + 0x8a0)
+#define VA_SPEAR1340_OTP_RDATAM_1		(VA_MISC_BASE + 0x8a4)
+#define VA_SPEAR1340_OTP_RDATAM_2		(VA_MISC_BASE + 0x8a8)
+#define VA_SPEAR1340_OTP_RDATAM_3		(VA_MISC_BASE + 0x8ac)
+#define VA_SPEAR1340_OTP_RDATAM_4		(VA_MISC_BASE + 0x8b0)
+#define VA_SPEAR1340_OTP_RDATAM_5		(VA_MISC_BASE + 0x8b4)
+#define VA_SPEAR1340_OTP_RDATAM_6		(VA_MISC_BASE + 0x8b8)
+#define VA_SPEAR1340_OTP_RDATAM_7		(VA_MISC_BASE + 0x8bc)
+#define VA_SPEAR1340_OTP_RDATAM_8		(VA_MISC_BASE + 0x8c0)
+#define SPEAR1340_THSENS_CFG			(SPEAR13XX_MISC_BASE + 0x8c4)
+#define VA_SPEAR1340_THSENS_CFG		(VA_MISC_BASE + 0x8c4)
+	#define SPEAR1340_THERMAL_CONFIG_FLAGS		0x2a00
+/* A9SM Register */
+#define VA_SPEAR1340_A9SM_CLUSTERID		(VA_MISC_BASE + 0x900)
+#define VA_SPEAR1340_A9SM_STATUS		(VA_MISC_BASE + 0x904)
+#define VA_SPEAR1340_A9SM_DEBUG			(VA_MISC_BASE + 0x908)
+#define VA_SPEAR1340_A9SM_FILTER		(VA_MISC_BASE + 0x90C)
+#define VA_SPEAR1340_A9SM_PARITY_CFG		(VA_MISC_BASE + 0x910)
+#define VA_SPEAR1340_A9SM_PARITY_ERR		(VA_MISC_BASE + 0x914)
+/* SOC ID Register */
+#define VA_SPEAR1340_DIE_ID_1			(VA_MISC_BASE + 0xa00)
+#define VA_SPEAR1340_DIE_ID_2			(VA_MISC_BASE + 0xa04)
+#define VA_SPEAR1340_DIE_ID_3			(VA_MISC_BASE + 0xa08)
+#define VA_SPEAR1340_DIE_ID_4			(VA_MISC_BASE + 0xa0C)
+
+/* MASTERS Trnsaction tagging Register */
+#define VA_SPEAR1340_AXI_CACHE_USER_CTRL_0	(VA_MISC_BASE + 0xc00)
+#define VA_SPEAR1340_AXI_CACHE_USER_CTRL_1	(VA_MISC_BASE + 0xc04)
+#define VA_SPEAR1340_AXI_CACHE_USER_CTRL_2	(VA_MISC_BASE + 0xc08)
+#define VA_SPEAR1340_AXI_CACHE_USER_CTRL_3	(VA_MISC_BASE + 0xc0c)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_0	(VA_MISC_BASE + 0xc10)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_1	(VA_MISC_BASE + 0xc14)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_2	(VA_MISC_BASE + 0xc18)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_3	(VA_MISC_BASE + 0xc1c)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_4	(VA_MISC_BASE + 0xc20)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_5	(VA_MISC_BASE + 0xc24)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_6	(VA_MISC_BASE + 0xc28)
+#define VA_SPEAR1340_AHB_CACHE_USER_CTRL_7	(VA_MISC_BASE + 0xc2c)
+
+/* SOC TEST and  DEBUG Register */
+#define VA_SPEAR1340_MIPHY_TEST			(VA_MISC_BASE + 0x1000)
+#define VA_SPEAR1340_USB_TEST			(VA_MISC_BASE + 0x1004)
+#define VA_SPEAR1340_MISC_CFG			(VA_MISC_BASE + 0x1008)
+
+#endif /* __MACH_SPEAR1340_MISC_REGS_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear900.h b/arch/arm/mach-spear13xx/include/mach/spear900.h
new file mode 100644
index 0000000..fa604d2
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear900.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear900.h
+ *
+ * SPEAr900 Machine specific definition
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifdef	CONFIG_CPU_SPEAR900
+
+#ifndef __MACH_SPEAR900_H
+#define __MACH_SPEAR900_H
+
+#endif /* __MACH_SPEAR900_H */
+
+#endif /* CONFIG_CPU_SPEAR900 */
diff --git a/arch/arm/mach-spear13xx/include/mach/spear_pcie.h b/arch/arm/mach-spear13xx/include/mach/spear_pcie.h
new file mode 100644
index 0000000..7376826
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear_pcie.h
@@ -0,0 +1,160 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear_pcie.h
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __MACH_SPEAR_PCIE_H
+#define __MACH_SPEAR_PCIE_H
+#include <linux/types.h>
+#include "dw_pcie.h"
+
+struct pcie_app_reg {
+	u32	app_ctrl_0;		/*cr0*/
+	u32	app_ctrl_1;		/*cr1*/
+	u32	app_status_0;		/*cr2*/
+	u32	app_status_1;		/*cr3*/
+	u32	msg_status;		/*cr4*/
+	u32	msg_payload;		/*cr5*/
+	u32	int_sts;		/*cr6*/
+	u32	int_clr;		/*cr7*/
+	u32	int_mask;		/*cr8*/
+	u32	mst_bmisc;		/*cr9*/
+	u32	phy_ctrl;		/*cr10*/
+	u32	phy_status;		/*cr11*/
+	u32	cxpl_debug_info_0;	/*cr12*/
+	u32	cxpl_debug_info_1;	/*cr13*/
+	u32	ven_msg_ctrl_0;		/*cr14*/
+	u32	ven_msg_ctrl_1;		/*cr15*/
+	u32	ven_msg_data_0;		/*cr16*/
+	u32	ven_msg_data_1;		/*cr17*/
+	u32	ven_msi_0;		/*cr18*/
+	u32	ven_msi_1;		/*cr19*/
+	u32	mst_rmisc;		/*cr 20*/
+	u32	slv_awmisc;		/*cr 21*/
+	u32	slv_armisc;		/*cr 22*/
+	u32	pom0_mem_addr_start;	/*cr23*/
+	u32	pom1_mem_addr_start;	/*cr24*/
+	u32	pom_io_addr_start;	/*cr25*/
+	u32	pom_cfg0_addr_start;	/*cr26*/
+	u32	pom_cfg1_addr_start;	/*cr27*/
+	u32	in0_mem_addr_start;	/*cr28*/
+	u32	in1_mem_addr_start;	/*cr29*/
+	u32	in_io_addr_start;	/*cr30*/
+	u32	in_cfg0_addr_start;	/*cr31*/
+	u32	in_cfg1_addr_start;	/*cr32*/
+	u32	in_msg_addr_start;	/*cr33*/
+	u32	in0_mem_addr_limit;	/*cr34*/
+	u32	in1_mem_addr_limit;	/*cr35*/
+	u32	in_io_addr_limit;	/*cr36*/
+	u32	in_cfg0_addr_limit;	/*cr37*/
+	u32	in_cfg1_addr_limit;	/*cr38*/
+	u32	in_msg_addr_limit;	/*cr39*/
+	u32	mem0_addr_offset_limit;	/*cr40*/
+	u32	pim0_mem_addr_start;	/*cr41*/
+	u32	pim1_mem_addr_start;	/*cr42*/
+	u32	pim_io_addr_start;	/*cr43*/
+	u32	pim_rom_addr_start;	/*cr44*/
+};
+
+/*CR0 ID*/
+#define RX_LANE_FLIP_EN_ID			0
+#define TX_LANE_FLIP_EN_ID			1
+#define SYS_AUX_PWR_DET_ID			2
+#define APP_LTSSM_ENABLE_ID			3
+#define SYS_ATTEN_BUTTON_PRESSED_ID		4
+#define SYS_MRL_SENSOR_STATE_ID			5
+#define SYS_PWR_FAULT_DET_ID			6
+#define SYS_MRL_SENSOR_CHGED_ID			7
+#define SYS_PRE_DET_CHGED_ID			8
+#define SYS_CMD_CPLED_INT_ID			9
+#define APP_INIT_RST_0_ID			11
+#define APP_REQ_ENTR_L1_ID			12
+#define APP_READY_ENTR_L23_ID			13
+#define APP_REQ_EXIT_L1_ID			14
+#define DEVICE_TYPE_EP				(0 << 25)
+#define DEVICE_TYPE_LEP				(1 << 25)
+#define DEVICE_TYPE_RC				(4 << 25)
+#define SYS_INT_ID				29
+#define MISCTRL_EN_ID				30
+#define REG_TRANSLATION_ENABLE			31
+
+/*CR1 ID*/
+#define APPS_PM_XMT_TURNOFF_ID			2
+#define APPS_PM_XMT_PME_ID			5
+
+/*CR4 ID*/
+#define CFG_MSI_EN_ID				18
+
+/*CR6*/
+#define INTA_CTRL_INT				(1 << 7)
+#define INTB_CTRL_INT				(1 << 8)
+#define INTC_CTRL_INT				(1 << 9)
+#define INTD_CTRL_INT				(1 << 10)
+#define MSI_CTRL_INT				(1 << 26)
+
+/*CR19 ID*/
+#define VEN_MSI_REQ_ID				11
+#define VEN_MSI_FUN_NUM_ID			8
+#define VEN_MSI_TC_ID				5
+#define VEN_MSI_VECTOR_ID			0
+#define VEN_MSI_REQ_EN		((u32)0x1 << VEN_MSI_REQ_ID)
+#define VEN_MSI_FUN_NUM_MASK	((u32)0x7 << VEN_MSI_FUN_NUM_ID)
+#define VEN_MSI_TC_MASK		((u32)0x7 << VEN_MSI_TC_ID)
+#define VEN_MSI_VECTOR_MASK	((u32)0x1F << VEN_MSI_VECTOR_ID)
+
+/*CE21-22 ID*/
+/*ID definitio of ARMISC*/
+#define AXI_OP_TYPE_ID				0
+#define AXI_OP_BCM_ID				5
+#define AXI_OP_EP_ID				6
+#define AXI_OP_TD_ID				7
+#define AXI_OP_ATTRIBUTE_ID			8
+#define AXI_OP_TC_ID				10
+#define AXI_OP_MSG_CODE_ID			13
+#define AXI_OP_DBI_ACCESS_ID			21
+#define AXI_OP_TYPE_MASK			0x1F
+#define AXI_OP_TYPE_MEM_RDRW			0
+#define AXI_OP_TYPE_MEM_RDRW_LOCKED		1
+#define AXI_OP_TYPE_IO_RDRW			2
+#define AXI_OP_TYPE_CONFIG_RDRW_TYPE0		4
+#define AXI_OP_TYPE_CONFIG_RDRW_TYPE1		5
+#define AXI_OP_TYPE_MSG_REQ			16
+#define AXI_OP_TYPE_COMPLETION			10
+#define AXI_OP_TYPE_COMPLETION_LOCKED		11
+#define AXI_OP_TYPE_DBI_ELBI_ENABLE		1
+
+/* Sum of all these space can maximum be 256MB*/
+#define PCIE_MEM_SIZE		(252 * 1024 * 1024)
+#define PCIE_IO_SIZE		(64 * 1024)
+#define PCIE_CFG0_SIZE		(1 * 1024 * 1024)
+#define PCIE_CFG1_SIZE		(1 * 1024 * 1024)
+#define PCIE_MSG_SIZE		(1 * 1024 * 1024)
+#define PCIE_INBOUND_MEM_SIZE	(0x80000000)
+
+#define PCIE_IS_HOST		1
+#define PCIE_IS_DEVICE		0
+
+#define PCIE_IS_GEN1		1
+#define PCIE_IS_GEN2		0
+
+#define SPEAR_PCIE_REV_3_41	341
+#define SPEAR_PCIE_REV_3_70	370
+
+#define PCIE_PORT_INIT(port_info, __vendor) do { \
+	(port_info)->vendor = __vendor; \
+	(port_info)->is_host = PCIE_IS_HOST; \
+	(port_info)->is_gen1 = PCIE_IS_GEN2; \
+	(port_info)->mem_size = PCIE_MEM_SIZE; \
+	(port_info)->io_size = PCIE_IO_SIZE; \
+	(port_info)->cfg0_size = PCIE_CFG0_SIZE; \
+	(port_info)->cfg1_size = PCIE_CFG1_SIZE; \
+	(port_info)->msg_size = PCIE_MSG_SIZE; \
+	(port_info)->in_mem_size = PCIE_INBOUND_MEM_SIZE; \
+	} while (0);
+
+#endif
diff --git a/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_341.h b/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_341.h
new file mode 100644
index 0000000..53b39e1
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_341.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_341.h
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __MACH_SPEAR_PCIE_REV_341_H
+#define __MACH_SPEAR_PCIE_REV_341_H
+#include "spear_pcie.h"
+
+/*CR3 ID*/
+#define XMLH_LTSSM_STATE_ID			0
+#define XMLH_LTSSM_STATE_L0	((u32)0x11 << XMLH_LTSSM_STATE_ID)
+#define XMLH_LTSSM_STATE_MASK	((u32)0x1F << XMLH_LTSSM_STATE_ID)
+#define XMLH_LINK_UP_ID				5
+
+#endif
diff --git a/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_370.h b/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_370.h
new file mode 100644
index 0000000..63944b0
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_370.h
@@ -0,0 +1,21 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/spear_pcie_rev_370.h
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __MACH_SPEAR_PCIE_REV_370_H
+#define __MACH_SPEAR_PCIE_REV_370_H
+#include "spear_pcie.h"
+
+/*CR3 ID*/
+#define XMLH_LTSSM_STATE_ID			0
+#define XMLH_LTSSM_STATE_L0	((u32)0x11 << XMLH_LTSSM_STATE_ID)
+#define XMLH_LTSSM_STATE_MASK	((u32)0x3F << XMLH_LTSSM_STATE_ID)
+#define XMLH_LINK_UP_ID				6
+
+#endif
diff --git a/arch/arm/mach-spear13xx/include/mach/suspend.h b/arch/arm/mach-spear13xx/include/mach/suspend.h
new file mode 100644
index 0000000..7d5b5aa
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/suspend.h
@@ -0,0 +1,106 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/suspend.h
+ *
+ * Sleep mode defines for SPEAr13xx machine family
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * AUTHOR : Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SUSPEND_H
+#define __MACH_SUSPEND_H
+
+#include <mach/hardware.h>
+
+#ifndef __ASSEMBLER__
+extern void spear1340_sleep_mode(suspend_state_t state, unsigned long *saveblk);
+extern unsigned int spear1340_sleep_mode_sz;
+extern void spear13xx_sleep_mode(suspend_state_t state, unsigned long *saveblk);
+extern unsigned int spear13xx_sleep_mode_sz;
+extern void spear_wakeup(void);
+extern unsigned int spear_wakeup_sz;
+extern int spear_cpu_suspend(suspend_state_t, long);
+extern void spear_clocksource_resume(void);
+extern void spear_clocksource_suspend(void);
+extern int spear_pcie_suspend(void);
+extern int spear_pcie_resume(void);
+
+#endif
+
+/*
+ * Define this only if you want cpu + bus matrix to be off during
+ * suspend to ram i.e. echo mem > /sys/power/state
+ */
+/* #define CPU_PWR_DOMAIN_OFF */
+
+/* SRAM related defines*/
+#define SRAM_STACK_STRT_OFF	0x800
+#define SRAM_STACK_SCR_OFFS	0x900
+#define SPEAR_START_SRAM	SPEAR13XX_SYSRAM1_BASE
+#define SPEAR_LIMIT_SRAM	(SPEAR_START_SRAM + SZ_4K - 16)
+#define SPEAR_END_SRAM		(SPEAR_START_SRAM + SZ_4K - 4)
+#define SPEAR_SRAM_START_PA	SPEAR_START_SRAM
+#define SPEAR_SRAM_STACK_L2	(SPEAR_START_SRAM + SRAM_STACK_STRT_OFF - 0x30)
+#define SPEAR_SRAM_STACK_PA	(SPEAR_START_SRAM + SRAM_STACK_STRT_OFF)
+#define SPEAR_SRAM_SCR_REG	(SPEAR_START_SRAM + SRAM_STACK_SCR_OFFS)
+#define SRAM_SCRATCH_PA		(SPEAR13XX_SYS_LOCATION)
+/* SPEAr subsystem physical addresses */
+#define MPMC_BASE_PA		SPEAR13XX_MPMC_BASE
+#define MISC_BASE_PA		SPEAR13XX_MISC_BASE
+#define GPIO_START_PA		SPEAR13XX_GPIO0_BASE
+#define GPIO_START_UPD_PA	SPEAR13XX_UPD_BASE
+#define UART_BASE_PA		SPEAR13XX_UART_BASE
+
+#define DISABLE_I_C_M_V	0x1805
+#define MISC_PLL_OFFS	0x214
+#define MPMC_REG_END	0xff0
+#define SRAM_SCR_REG	0xffc
+#define PLL_VAL1	0x060a
+#define PLL_VAL2	0x060e
+#define PLL_VAL3	0x0606
+
+#define	MODE_IRQ_32	0x12
+#define	MODE_SVC_32	0x13
+#define	MODE_ABT_32	0x17
+#define	MODE_UND_32	0x1B
+#define	MODE_SYS_32	0x1F
+#define	MODE_BITS	0x1F
+
+#ifdef __ASSEMBLER__
+.macro	io_v2p, pa, va, tmp
+	ldr	\tmp, =0xfff
+	bic	\pa, \va, \tmp
+
+	/*
+	 * Following code uses VA to PA Translation Registers to
+	 * translate the virtual address provided by a general-purpose
+	 * register and store the corresponding physical address in the
+	 * PA Register.
+	 */
+	mcr	p15, 0, \pa, c7, c8, 1
+	mrc	p15, 0, \pa, c7, c4, 0
+	bic	\pa, \pa, \tmp
+	and	\tmp, \va, \tmp
+	orr	\pa, \pa, \tmp
+
+.endm
+
+.macro	io_p2v, pa, va, tmp
+
+	ldr	\tmp, =0xfff00000
+	and	\va, \pa, \tmp
+	lsr	\va, \va, #4
+
+	ldr	\tmp, =0xffff
+	and	\tmp, \pa, \tmp
+	orr	\va, \va, \tmp
+
+	ldr	\tmp, =0xf0000000
+	orr	\va, \va, \tmp
+.endm
+#endif
+#endif /* __MACH_SUSPEND_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/system.h b/arch/arm/mach-spear13xx/include/mach/system.h
new file mode 100644
index 0000000..52f5a19
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/system.h
@@ -0,0 +1,85 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/system.h
+ *
+ * spear13xx Machine family specific architecture functions
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+#include <mach/misc_regs.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+static inline int arch_change_mode(int mode)
+{
+	u32 val, mode_sts;
+	unsigned long finish;
+	void __iomem *sys_reg;
+
+	if (cpu_is_spear1340()) {
+#ifdef CONFIG_CPU_SPEAR1340
+		sys_reg = VA_SPEAR1340_SYS_CLK_CTRL;
+#endif
+	} else if (cpu_is_spear1310()) {
+#ifdef CONFIG_CPU_SPEAR1310
+		sys_reg = VA_SPEAR1310_SYS_CLK_CTRL;
+#endif
+	} else
+		sys_reg = VA_SYS_CLK_CTRL;
+
+	switch (mode) {
+	case SYS_MODE_DOZE:
+		mode_sts = SYS_MODE_STS_DOZE;
+		break;
+	case SYS_MODE_SLOW:
+		mode_sts = SYS_MODE_STS_SLOW;
+		break;
+	case SYS_MODE_NORMAL:
+		mode_sts = SYS_MODE_STS_NORMAL;
+		break;
+	default:
+		pr_err("Wrong system mode\n");
+		return -EINVAL;
+	}
+
+	val = readl(sys_reg);
+	if ((val & SYS_MODE_STS_MASK) == mode_sts)
+		return 0;
+
+	val &= ~SYS_MODE_MASK;
+	val |= mode;
+	writel(val, sys_reg);
+
+	/* read back if mode is set */
+	finish = jiffies + 2 * HZ;
+	do {
+		val = readl(sys_reg);
+		if ((val & SYS_MODE_STS_MASK) == mode_sts)
+			return 0;
+		udelay(1000);
+	} while (!time_after_eq(jiffies, finish));
+
+	return -EFAULT;
+}
+
+#endif /* __MACH_SYSTEM_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/timex.h b/arch/arm/mach-spear13xx/include/mach/timex.h
new file mode 100644
index 0000000..0a81490
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/timex.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/timex.h
+ *
+ * spear13xx machine family specific timex definitions
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_TIMEX_H
+#define __MACH_TIMEX_H
+
+#define CLOCK_TICK_RATE			24000000
+
+#endif /* __MACH_TIMEX_H */
diff --git a/arch/arm/mach-spear13xx/include/mach/uncompress.h b/arch/arm/mach-spear13xx/include/mach/uncompress.h
new file mode 100644
index 0000000..3c27f25
--- /dev/null
+++ b/arch/arm/mach-spear13xx/include/mach/uncompress.h
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-spear13xx/include/mach/uncompress.h
+ *
+ * Serial port stubs for kernel decompress status messages
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_UNCOMPRESS_H
+#define __MACH_UNCOMPRESS_H
+
+#include <plat/uncompress.h>
+
+#endif /* __MACH_UNCOMPRESS_H */
diff --git a/arch/arm/mach-spear13xx/localtimer.c b/arch/arm/mach-spear13xx/localtimer.c
new file mode 100644
index 0000000..05793f2
--- /dev/null
+++ b/arch/arm/mach-spear13xx/localtimer.c
@@ -0,0 +1,26 @@
+/*
+ * arch/arm/mach-spear13xx/localtimer.c
+ * Directly picked from realview
+ *
+ * Copyright (C) 2010 ST Microelectronics Ltd.
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+#include <asm/irq.h>
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+
+/* Setup the local clock events for a CPU. */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	evt->irq = IRQ_LOCALTIMER;
+	twd_timer_setup(evt);
+	return 0;
+}
diff --git a/arch/arm/mach-spear13xx/platsmp.c b/arch/arm/mach-spear13xx/platsmp.c
new file mode 100644
index 0000000..beb3c65
--- /dev/null
+++ b/arch/arm/mach-spear13xx/platsmp.c
@@ -0,0 +1,130 @@
+/*
+ * arch/arm/mach-spear13xx/platsmp.c
+ *
+ * based upon linux/arch/arm/mach-realview/platsmp.c
+ *
+ * Copyright (C) 2010 ST Microelectronics Ltd.
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/smp.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/smp_scu.h>
+#include <mach/hardware.h>
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+static DEFINE_SPINLOCK(boot_lock);
+
+static void __iomem *scu_base = IOMEM(IO_ADDRESS(SPEAR13XX_SCU_BASE));
+extern void spear13xx_secondary_startup(void);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	pen_release = cpu;
+	flush_cache_all();
+	outer_flush_all();
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = scu_get_core_count(scu_base);
+
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+
+	scu_enable(scu_base);
+
+	/*
+	 * Write the address of secondary startup into the system-wide location
+	 * (presently it is in SRAM). The BootMonitor waits until it receives a
+	 * soft interrupt, and then the secondary CPU branches to this address.
+	 */
+	__raw_writel(virt_to_phys(spear13xx_secondary_startup),
+			__io_address(SPEAR13XX_SYS_LOCATION));
+}
diff --git a/arch/arm/mach-spear13xx/pm.c b/arch/arm/mach-spear13xx/pm.c
new file mode 100644
index 0000000..1c44ea5
--- /dev/null
+++ b/arch/arm/mach-spear13xx/pm.c
@@ -0,0 +1,295 @@
+/*
+ * arch/arm/mach-spear13xx/pm.c
+ *
+ * SPEAr13xx Power Management source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu_pm.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/suspend.h>
+#include <linux/sysfs.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/smp_twd.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/misc_regs.h>
+#include <mach/suspend.h>
+#include <asm/hardware/gic.h>
+
+#define PLAT_PHYS_OFFSET	0x00000000
+#define PCM_SET_WAKEUP_CFG	0xfffff
+/* Wake up Configurations */
+#define ETH_WKUP	0x10
+#define RTC_WKUP	0x8
+#define GPIO_WKUP	0x4
+#define USB_WKUP	0x2
+#define PWR_DOM_ON	0x3c00
+/* Use all Sources except USB as wake up trigger */
+#define PCM_SET_CFG	(PWR_DOM_ON | GPIO_WKUP | RTC_WKUP | ETH_WKUP \
+		| USB_WKUP)
+#define DDR_PHY_NO_SHUTOFF_CFG	(~BIT(20))
+#define SWITCH_CTR_CFG	0xff
+
+static void __iomem *mpmc_regs_base;
+
+static void memcpy_decr_ptr(void *dest, void *src, u32 len)
+{
+	int i;
+
+	for (i = 0; i < len ; i++)
+		*((u32 *)(dest - (i<<2))) = *((u32 *)(src + (i<<2)));
+}
+
+/*
+ *	spear_pm_on - Manage PM_SUSPEND_ON state.
+ *
+ */
+static int spear_pm_on(void)
+{
+	cpu_do_idle();
+
+	return 0;
+}
+
+static int spear_pm_sleep(suspend_state_t state)
+{
+	u32 twd_ctrl, twd_load;
+
+	twd_ctrl = readl(twd_base + TWD_TIMER_CONTROL);
+	twd_load = readl(twd_base + TWD_TIMER_LOAD);
+	/* twd timer stop */
+	writel(0, twd_base + TWD_TIMER_CONTROL);
+
+	/* Do the GIC specific latch ups for suspend mode */
+	if (state == PM_SUSPEND_MEM) {
+#ifdef CPU_PWR_DOMAIN_OFF
+		gic_cpu_exit(0);
+		gic_dist_save(0);
+#endif
+#ifdef CONFIG_PCI
+		/* Suspend PCIE bus */
+		spear_pcie_suspend();
+#endif
+	}
+
+	/* Suspend the event timer */
+	spear_clocksource_suspend();
+	/* Move the cpu into suspend */
+	spear_cpu_suspend(state, PLAT_PHYS_OFFSET - PAGE_OFFSET);
+	/* Resume Operations begin */
+	spear13xx_l2x0_init();
+	/* Call the CPU PM notifiers to notify exit from sleep */
+	cpu_pm_exit();
+	/* twd timer restart */
+	writel(twd_ctrl, twd_base + TWD_TIMER_CONTROL);
+	writel(twd_load, twd_base + TWD_TIMER_LOAD);
+
+	/* Do the GIC restoration for suspend mode */
+	if (state == PM_SUSPEND_MEM) {
+#ifdef CPU_PWR_DOMAIN_OFF
+		gic_secondary_init(0);
+		gic_dist_restore(0);
+#endif
+#ifdef CONFIG_PCI
+		/* Resume PCIE bus */
+		spear_pcie_resume();
+#endif
+	}
+
+	/* Explicit set all the power domain to on */
+	writel((readl(VA_PCM_CFG) | PCM_SET_CFG),
+		VA_PCM_CFG);
+
+	/* Resume the event timer */
+	spear_clocksource_resume();
+
+	return 0;
+}
+
+/*
+ * This function call is made post the CPU suspend is done.
+ */
+void spear_sys_suspend(suspend_state_t state)
+{
+
+	void (*spear_sram_sleep)(suspend_state_t state, unsigned long *saveblk)
+		= NULL;
+#ifdef CPU_PWR_DOMAIN_OFF
+	void (*spear_sram_wake)(void) = NULL;
+#endif
+	void *sram_dest = (void *)IO_ADDRESS(SPEAR_START_SRAM);
+	void *sram_limit_va = (void *)IO_ADDRESS(SPEAR_LIMIT_SRAM);
+	u32 pm_cfg = readl(VA_PCM_CFG);
+
+#ifdef CPU_PWR_DOMAIN_OFF
+	if (state == PM_SUSPEND_MEM) {
+		spear_sram_wake = memcpy(sram_dest, (void *)spear_wakeup,
+				spear_wakeup_sz);
+		/* Increment destination pointer by the size copied*/
+		sram_dest += roundup(spear_wakeup_sz, 4);
+		/*
+		 * Set ddr_phy_no_shutoff to 0 in order to select
+		 * the SPEAr DDR pads, DDRIO_VDD1V8_1V5_OFF
+		 * and DDRIO_VDD1V2_OFF, to be used to control
+		 * the lines for the switching of the DDRPHY to the
+		 * external power supply.
+		 */
+		pm_cfg &= (unsigned long)DDR_PHY_NO_SHUTOFF_CFG;
+		/*
+		 * Set up the Power Domains specific registers.
+		 * 1. Setup the wake up enable of the desired sources.
+		 * 2. Set the wake up trigger field to zero
+		 * 3. Clear config_ack and config_bad
+		 * 4. Set sw_config equal to ack_power_state
+		 * The currrent S2R operations enable all the wake up
+		 * sources by default.
+		 */
+		writel(pm_cfg | PCM_SET_CFG, VA_PCM_CFG);
+		/* Set up the desired wake up state */
+		pm_cfg = readl(VA_PCM_WKUP_CFG);
+		/* Set the states for all power island on */
+		writel(pm_cfg | PCM_SET_WAKEUP_CFG, VA_PCM_WKUP_CFG);
+		/* Set the  VA_SWITCH_CTR to Max Restart Current */
+		writel(SWITCH_CTR_CFG, VA_SWITCH_CTR);
+	} else
+		/* source gpio interrupt through GIC */
+		writel((pm_cfg & (~(1 << 2))), VA_PCM_CFG);
+#else
+		pm_cfg |= PWR_DOM_ON;
+		writel((pm_cfg & (~(1 << 2))), VA_PCM_CFG);
+#endif
+
+	/*
+	 * Copy in the MPMC registers at the end of SRAM
+	 * Ensure that the backup of these registers does not
+	 * overlap the code being copied.
+	 */
+	if (cpu_is_spear1340()) {
+		memcpy_decr_ptr(sram_limit_va , mpmc_regs_base, 208);
+		/* Copy the Sleep code on to the SRAM*/
+		spear_sram_sleep =
+			memcpy(sram_dest, (void *)spear1340_sleep_mode,
+				spear1340_sleep_mode_sz);
+	} else {
+		memcpy_decr_ptr(sram_limit_va , mpmc_regs_base, 201);
+		/* Copy the Sleep code on to the SRAM*/
+		spear_sram_sleep =
+			memcpy(sram_dest, (void *)spear13xx_sleep_mode,
+					spear13xx_sleep_mode_sz);
+	}
+
+	/* Call the CPU PM notifiers to notify entry in sleep */
+	cpu_pm_enter();
+	/* Flush the cache */
+	flush_cache_all();
+	outer_flush_all();
+	outer_disable();
+	outer_sync();
+	/* Jump to the suspend routines in sram */
+	spear_sram_sleep(state, (unsigned long *)cpu_resume);
+}
+
+/*
+ *	spear_pm_prepare - Do preliminary suspend work.
+ *
+ */
+static int spear_pm_prepare(void)
+{
+	mpmc_regs_base = ioremap(SPEAR13XX_MPMC_BASE, 1024);
+	disable_hlt();
+
+	return 0;
+}
+
+/*
+ *	spear_pm_enter - Actually enter a sleep state.
+ *	@state:		State we're entering.
+ *
+ */
+static int spear_pm_enter(suspend_state_t state)
+{
+	int ret;
+
+	switch (state) {
+	case PM_SUSPEND_ON:
+		ret = spear_pm_on();
+		break;
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		ret = spear_pm_sleep(state);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*
+ *	spear_pm_finish - Finish up suspend sequence.
+ *
+ *	This is called after we wake back up (or if entering the sleep state
+ *	failed).
+ */
+static void spear_pm_finish(void)
+{
+	iounmap(mpmc_regs_base);
+	enable_hlt();
+}
+
+/*
+ *	spear_pm_valid_state- check the valid states in PM for the SPEAr
+ *	platform
+ */
+static int spear_pm_valid_state(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_ON:
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+static struct platform_suspend_ops spear_pm_ops = {
+	.prepare	= spear_pm_prepare,
+	.enter		= spear_pm_enter,
+	.finish		= spear_pm_finish,
+	.valid		= spear_pm_valid_state,
+};
+
+static void spear_power_off(void)
+{
+	while (1);
+}
+
+static int __init spear_pm_init(void)
+{
+	void * sram_limit_va = (void *)IO_ADDRESS(SPEAR_LIMIT_SRAM);
+	void * sram_st_va = (void *)IO_ADDRESS(SPEAR_START_SRAM);
+	int spear_sleep_mode_sz = spear13xx_sleep_mode_sz;
+
+	if (cpu_is_spear1340())
+		spear_sleep_mode_sz = spear1340_sleep_mode_sz;
+
+	/* In case the suspend code size is more than sram size return */
+	if (spear_sleep_mode_sz > (sram_limit_va - sram_st_va))
+		return	-ENOMEM;
+
+	suspend_set_ops(&spear_pm_ops);
+	pm_power_off = spear_power_off;
+	return 0;
+}
+arch_initcall(spear_pm_init);
diff --git a/arch/arm/mach-spear13xx/r1801e.c b/arch/arm/mach-spear13xx/r1801e.c
new file mode 100644
index 0000000..c97ee89
--- /dev/null
+++ b/arch/arm/mach-spear13xx/r1801e.c
@@ -0,0 +1,314 @@
+/*
+ * arch/arm/mach-spear13xx/r1801e.c
+ *
+ * ZT SOM board source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/phy.h>
+#include <linux/stmmac.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/misc_regs.h>
+#include <mach/spear_pcie.h>
+
+#define PARTITION(n, off, sz)	{.name = n, .offset = off, .size = sz}
+
+#ifdef CONFIG_USE_PLGPIO
+/* Pad muxing for PLGPIO_11 "System Alive" LED indicator */
+static struct pmx_mux_reg pmx_plgpio_10_11_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT0_TMR1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpio_10_11_modes[] = {
+	{
+		.mux_regs = pmx_plgpio_10_11_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpio_10_11_mux),
+	},
+};
+
+struct pmx_dev pmx_plgpio_10_11 = {
+	.name = "plgpio_10_11",
+	.modes = pmx_plgpio_10_11_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpio_10_11_modes),
+};
+
+/* Pad muxing for PLGPIO_9 "PWR_OFF" output */
+static struct pmx_mux_reg pmx_plgpio_8_9_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT0_TMR2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpio_8_9_modes[] = {
+	{
+		.mux_regs = pmx_plgpio_8_9_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpio_8_9_mux),
+	},
+};
+
+static struct pmx_dev pmx_plgpio_8_9 = {
+	.name = "plgpio_8_9",
+	.modes = pmx_plgpio_8_9_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpio_8_9_modes),
+};
+
+/* Pad muxing for PLGPIO_7 "SHTDWN_RQST" input */
+static struct pmx_mux_reg pmx_plgpio_6_7_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT1_TMR1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpio_6_7_modes[] = {
+	{
+		.mux_regs = pmx_plgpio_6_7_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpio_6_7_mux),
+	},
+};
+
+static struct pmx_dev pmx_plgpio_6_7 = {
+	.name = "plgpio_6_7",
+	.modes = pmx_plgpio_6_7_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpio_6_7_modes),
+};
+#endif /* CONFIG_USE_PLGPIO */
+
+/* NAND partition table */
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x20000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x20000,
+		.size = 12 * 0x20000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 12) * 0x20000,
+		.size = 48 * 0x20000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 48) * 0x20000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/* spear13xx specific devices */
+	&spear13xx_pmx_i2c,
+	&spear13xx_pmx_egpio_grp,
+	&spear13xx_pmx_gmii,
+	&spear13xx_pmx_mcif,
+	&spear13xx_pmx_uart0,
+	&spear13xx_pmx_nand_16bit,
+
+	/* spear1310 reva specific devices */
+	&spear1310_reva_pmx_i2c1,
+	&spear1310_reva_pmx_uart_1,
+	&spear1310_reva_pmx_uart_2,
+	&spear1310_reva_pmx_uart_3_4_5,
+#ifdef CONFIG_USE_PLGPIO
+	&pmx_plgpio_10_11,
+	&pmx_plgpio_8_9,
+	&pmx_plgpio_6_7,
+#endif
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+
+	/* spear1310 reva specific devices */
+	&spear1310_reva_uart1_device,
+	&spear1310_reva_uart2_device,
+	&spear1310_reva_uart3_device,
+	&spear1310_reva_uart4_device,
+	&spear1310_reva_uart5_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_cpufreq_device,
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_jpeg_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcie_host0_device,
+	&spear13xx_pcie_host1_device,
+	&spear13xx_pcie_host2_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_wdt_device,
+	&spear13xx_nand_device,
+
+	/* spear1310 reva specific devices */
+	&spear1310_reva_i2c1_device,
+	&spear1310_reva_plgpio_device,
+};
+
+/* Ethernet pLatform data */
+
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = 0,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+	.bsp_priv = &eth_data,
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW16,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+/* This function is needed for board specific PCIe initilization */
+static void __init r1801e_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host0_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+	((struct pcie_port_info *)plat_data)->is_gen1 = PCIE_IS_GEN1;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host1_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+	((struct pcie_port_info *)plat_data)->is_gen1 = PCIE_IS_GEN1;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host2_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+	((struct pcie_port_info *)plat_data)->is_gen1 = PCIE_IS_GEN1;
+}
+#endif
+
+static void __init ras_fsmc_config(u32 mode, u32 width)
+{
+	u32 val, *address;
+
+	address = ioremap(SPEAR1310_REVA_RAS_CTRL_REG0, SZ_16);
+
+	val = readl(address);
+	val &= ~(RAS_FSMC_MODE_MASK | RAS_FSMC_WIDTH_MASK);
+	val |= mode;
+	val |= width;
+	val |= RAS_FSMC_CS_SPLIT;
+
+	writel(val, address);
+
+	iounmap(address);
+}
+
+static void __init r1801e_init(void)
+{
+	int i;
+
+	/*
+	 * SPEAr1310 reva FSMC cannot used as NOR and NAND at the same time
+	 * For the moment, disable NOR and use NAND only
+	 */
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW16);
+	if (platform_device_add_data(&spear13xx_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_nand_device.name);
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+	/* call spear1310 reva machine init function */
+	spear1310_reva_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+	r1801e_pcie_board_init();
+#endif
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+
+	/* Initialize fsmc regiters */
+	ras_fsmc_config(RAS_FSMC_MODE_NAND, RAS_FSMC_WIDTH_16);
+
+}
+
+MACHINE_START(R1801E, "ST-SPEAR1310-REVA-R1801e")
+	.atag_offset	=	0x100,
+	.map_io		=	spear1310_reva_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	r1801e_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/sleep_1340.S b/arch/arm/mach-spear13xx/sleep_1340.S
new file mode 100644
index 0000000..3f8ffc7
--- /dev/null
+++ b/arch/arm/mach-spear13xx/sleep_1340.S
@@ -0,0 +1,565 @@
+/*
+ * linux/arch/arm/mach-spear13xx/sleep_1340.S
+ *
+ * SPEAR1340 specific functions that will run in internal SRAM.
+ * The functions are used in power management.
+ *
+ * Copyright (C) 2010 ST MicroElectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/suspend.h>
+
+#define DDR_PLL_SREFRESH
+#define MPMC_RESET
+#define PWRDOMAINS_ON
+#define GPIO_DDR_ISOLATE
+#define RESET_UART_REGISTERS
+
+/*
+ * spear1340_sleep_mode()
+ * Forces SPEAr into sleep
+ * r0: state
+ */
+.text
+ENTRY(spear1340_sleep_mode)
+	mov	r10, r1		/* latch the address of cpu_resume */
+	mov	r11, r0		/* latch the suspend state */
+
+	ldr	r8, =IO_ADDRESS(SPEAR_SRAM_STACK_PA)
+	ldr	r6, =IO_ADDRESS(MISC_BASE_PA)
+	ldr	r0, [r6, #0x200]
+	stmia	r8!, {r0}
+
+	/* Store Context ID, User R/W thread, secure or NS VBAR */
+	mrc	p15, 0, r2, c10, c2, 0
+	mrc	p15, 0, r3, c13, c0, 1
+	mrc	p15, 0, r4, c13, c1, 2
+	mrc	p15, 0, r5, c13, c2, 3
+	mrc	p15, 0, r6, c13, c3, 4
+	mrc	p15, 0, r7, c12, c0, 0
+	stmia	r8!, {r2-r7}
+
+	/* Store the Current CPSR */
+	mrs	r0, cpsr
+	stmia	r8!, {r0}
+
+	/* Move to IRQ Mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_IRQ_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+
+	/* Saving FIQ stack pointer on to Stack in DDR */
+	stmia	r8!, {r1, r13, r14}
+
+	/* Move to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to ABT mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_ABT_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to undefined mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_UND_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to sys_32 mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SYS_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move back to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+
+	/* Latch the physical address of cpu_resume on to SRAM */
+	io_v2p	r0, r10, r1
+	stmia	r8!, {r0}
+
+	/* Extract the physical address to jump to */
+	adr	r0, mmu_off
+	io_v2p	r2, r0, r1
+
+	/* Disable MMU */
+	mrc	p15, 0, r0, c1, c0, 0
+	ldr	r1, =DISABLE_I_C_M_V
+	bic	r0, r0, r1
+	mcr	p15, 0, r0, c1, c0, 0
+	/* Move the Physical address into PC */
+	bx	r2
+	nop
+mmu_off:
+	/* Put the DDR in self refresh mode */
+	ldr	r6, =MISC_BASE_PA
+
+	/* This is Rev-1 */
+	/* Program MPMC Control Status register in Misc Space */
+#ifdef MPMC_RESET
+	ldr	r7, =MPMC_BASE_PA
+	/* Set the MPMC controller in Self-Refresh */
+	ldr	r0, [r7, #0x2c]
+	orr	r0, r0, #0x10000
+	str	r0, [r7, #0x2c]
+wait_till_srefresh_on_r1:
+	ldr	r0, [r6, #0x438]
+	/* check for cke_status bit(13) */
+	tst	r0, #0x2000
+	bne	wait_till_srefresh_on_r1
+
+#ifdef GPIO_DDR_ISOLATE
+	/* Enable XGPIO clk */
+	ldr	r0, [r6, #0x314]
+	ldr	r2, =0x40000
+	orr	r0, r0, r2
+	str	r0, [r6, #0x314]
+
+	ldr	r6, =GPIO_START_UPD_PA
+	/* Set xgpio[88-89] driven for cke & reset patch enable */
+	ldr	r0, [r6, #0x048]
+	ldr	r2, =0x03000000
+	orr	r0, r0, r2
+	str	r0, [r6, #0x048]
+#endif
+
+	ldr	r6, =MISC_BASE_PA
+	/* Stop the MPMC controller */
+	ldr	r0, [r7, #0x2c]
+	bic	r0, r0, #0x1000000
+	str	r0, [r7, #0x2c]
+
+	/* reset the MPMC controller */
+	ldr	r1, [r6, #0x31C]
+	orr	r1, r1, #0x3
+	str	r1, [r6, #0x31C]
+
+	/* Stop the MPMC clock */
+	ldr	r1, [r6, #0x310]
+	bic	r1, r1, #0x3
+	str	r1, [r6, #0x310]
+#endif
+srefresh_on:
+	/* Put the system in slow mode */
+	ldr	r0, [r6, #0x200]
+	bic	r0, r0, #0x4
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	orr	r0, r0, #0x2
+	str	r0, [r6, #0x200]	/* System is now in slow mode */
+wait_till_slow_mode:
+	ldr	r0, [r6, #0x200]
+	/* Wait for the mode to be updated */
+	and	r0, r0, #0xF0000
+	/* Poll the SCCTRL register status bits (6:3) */
+	cmp	r0, #0xA0000
+	bne wait_till_slow_mode
+
+	/* Move the ahb clock control to cpu/3 */
+	/* Put the Pll-1 to off. */
+	ldr	r0, [r6, #0x200]
+	and	r0, r0, #0x7ffffff
+	str	r0, [r6, #0x200]
+
+	/*
+	 * Put the all the system pll's to off state
+	 * The loop of count 3 is provided below to
+	 * switch off the pll-1/2/3.
+	 * r1 contains the offset for the pll control
+	 * registers in the misc space.
+	 * DDR pll-4 requires different processing.
+	 */
+	ldr	r1, =MISC_PLL_OFFS
+	ldr	r2, =0x0	/* PLL Counter 1, 2, 3, 4 */
+swoff_pll:
+	ldr	r0, [r6, r1]
+	/* Clear pll_enable bit(1) of PLL1_CTR register in Misc registers */
+	bic	r0, r0, #0x04
+	str	r0, [r6, r1]
+	add	r1, #0xc
+	add	r2, #0x1
+	cmp	r2, #0x3	/* Switch off pll-1/2/3 */
+	bne	swoff_pll
+
+#ifdef DDR_PLL_SREFRESH
+	/* Switch off pll-4 */
+	ldr	r0, [r6, r1]
+	/* Clear pll_enable bit(2) of PLL1_CTR register in Misc registers */
+	bic	r0, r0, #0x04
+	str	r0, [r6, r1]
+#endif
+pwrdomains_on:
+#ifdef PWRDOMAINS_ON
+	cmp	r11, #0x1
+	beq	standby_mode
+
+	/* Store the Resume Physical Address on Stack Secure location */
+	adr	r0, spear_sleep_restore
+	ldr	r3, =SRAM_SCR_REG
+	ldr	r6, =SPEAR_SRAM_START_PA
+	str	r0, [r6, r3]
+
+	/* Switch on certan sections as suggested by HW team */
+	/* Let the USB Host clock be on */
+	ldr	r6, =MISC_BASE_PA
+
+	/* Enable BootRom and Always On Ram Clock */
+	ldr	r0, [r6, #0x30c]
+	orr	r0, r0, #0x6
+	str	r0, [r6, #0x30c]
+
+	ldr	r0, [r6, #0x100]
+	/*
+	 * Switch off the power domains.
+	 * Clear the ack bit
+	 */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+	bic	r0, r0, #0x800
+	str	r0, [r6, #0x100]
+
+wait_ack1:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack1
+
+	/* Clear the ack bit */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+	bic	r0, r0, #0x1000
+	str	r0, [r6, #0x100]
+wait_ack2:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack2
+
+	/* Clear the ack bit */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+#ifdef CPU_PWR_DOMAIN_OFF
+	bic	r0, r0, #0x03e0
+	bic	r0, r0, #0x2400
+	str	r0, [r6, #0x100]
+wait_ack3:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack3
+#endif
+	nop
+	nop
+	nop
+	nop
+#endif
+
+standby_mode:
+	wfi				@ wait for interrupt
+	nop
+spear_sleep_restore:
+	nop
+	ldr	r6, =MISC_BASE_PA
+	ldr	r1, =MISC_PLL_OFFS
+
+#ifdef DDR_PLL_SREFRESH
+	/* Switch on PLL-4, strobe the pll also */
+	ldr	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL1
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL2
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL3
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL2
+	str	r0, [r6, #0x238]
+pll_lock_4:
+	/* Set the pll_lock bit(0) in PLLX_CTR register in misc space*/
+	ldr	r5, [r6, #0x238]
+	and	r5, r5, #0x1
+	/* Wait for pll lock status */
+	cmp	r5, #0x1
+	bne	pll_lock_4
+
+	/* Switch the pll source back to pll-4 */
+	ldr	r0, [r6, #0x244]
+	orr	r0, r0, #0x0400
+	str	r0, [r6, #0x244]
+#endif
+
+	ldr	r2, =0x0	/* PLL Counter 1, 2, 3, 4 */
+swon_pll_1_3:
+	/* Switch on Pll-1/2/3 */
+	ldr	r0, [r6, r1]
+	orr	r0, r0, #0x6
+	str	r0, [r6, r1]
+pll_lock_1_3:
+	/* Set the pll_lock bit(0) in PLLX_CTR register in misc space*/
+	ldr	r5, [r6, r1]
+	and	r5, r5, #0x1
+	/* Wait for pll lock status */
+	cmp	r5, #0x1
+	bne	pll_lock_1_3
+
+	/* Loop for all the pll's */
+	add	r1, #0xc
+	add	r2, #0x1
+	cmp	r2, #0x3	/* Switch on till pll-3 */
+	bne	swon_pll_1_3
+
+	ldr	r8, =SPEAR_SRAM_STACK_PA
+	/* fetch the AHB clock config */
+	ldmia	r8!, {r0}
+
+	/* Move the Bus Parent clock to CPU/3 */
+	str	r0, [r6, #0x200]
+
+normal_mode:
+	/* Put the system in normal mode */
+	ldr	r0, [r6, #0x200]
+	bic	r0, r0, #0x7
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	orr	r0, r0, #0x4
+	str	r0, [r6, #0x200]	/* System is now in normal mode */
+wait_till_normal_mode:
+	ldr	r0, [r6, #0x200]
+	/* Wait for the mode to be updated */
+	and	r0, r0, #0xF0000
+	/* Poll the SCCTRL register status bits (6:3) */
+	cmp	r0, #0xf0000
+	bne wait_till_normal_mode
+
+#ifdef MPMC_RESET
+	ldr	r7, =MISC_BASE_PA
+	/* Enable the MPMC clock */
+	ldr	r1, [r7, #0x310]
+	orr	r1, r1, #0x3
+	str	r1, [r7, #0x310]
+	/* Provide Software Reset to MPMC */
+	ldr	r1, [r7, #0x31C]
+	orr	r1, r1, #0x3
+	str	r1, [r7, #0x31C]
+	/* Enable MPMC back */
+	bic	r1, r1, #0x3
+	str	r1, [r7, #0x31C]
+#endif
+	/* Restore the MPMC registers */
+	ldr	r7, =MPMC_BASE_PA
+	mov	r0, #0
+	ldr	r3, =MPMC_REG_END
+	ldr	r6, =SPEAR_SRAM_START_PA
+mpmc_restore_regs:
+	ldr	r1, [r6, r3]
+	cmp	r0, #0x2c
+	bne	ddf
+	nop
+	nop
+	bic	r1, r1, #0x1000000
+ddf:
+	str	r1, [r7, r0]
+	sub	r3, r3, #4
+	add	r0, r0, #4
+	cmp	r0, #0x3fc
+	bne	mpmc_restore_regs
+	dsb
+	isb
+
+#ifdef GPIO_DDR_ISOLATE
+	ldr	r7, =GPIO_START_UPD_PA
+	/* Set xgpio88 driven low for cke patch disable */
+	ldr	r0, [r7, #0x048]
+	ldr	r2, =0x02000000
+	and	r0, r0, r2
+	str	r0, [r7, #0x048]
+#endif
+	mov	r9, #0x0
+ddr_out_srefresh:
+	/* Add some delay for the cke signal to propagate */
+	add	r9, r9, #0x1
+	cmp	r9, #0x30000
+	bne	ddr_out_srefresh
+
+	/* Move the DDR out of self refresh mode */
+	ldr	r6, =MISC_BASE_PA
+	ldr	r7, =MPMC_BASE_PA
+
+	/* Exit from SR (bit 8) */
+	ldr	r1, [r7, #0x18]
+	orr	r1, r1, #0x100
+	str	r1, [r7, #0x18]
+
+	/* Set the MPMC controller to exit from Self-Refresh */
+	ldr	r0, [r7, #0x2c]
+	orr	r0, r0, #0x100
+	str	r0, [r7, #0x2c]
+
+	/* Set the MPMC controller to exit from Self-Refresh */
+	ldr	r0, [r7, #0x2c]
+	orr	r0, r0, #0x1
+	str	r0, [r7, #0x2c]
+
+	/* Enable MPMC */
+	ldr	r1, [r7, #0x2c]
+	orr	r1, r1, #0x1000000
+	str	r1, [r7, #0x2c]
+	dsb
+	isb
+
+finalize_exit:
+	/* Clearance is required in the mpmc space */
+	ldr	r1, [r7, #0x2c]
+	/*
+	 * Clear bit srefresh bit (2) of MPMC_11 register
+	 * The misc wrapper does not works fine by itself till
+	 * this bit is also cleared.
+	 */
+	bic	r1, r1, #0x10000
+
+	/* This is Rev-1 */
+	ldr	r0, [r6, #0x438]
+	/* Clear srefresh_enter bit(2) */
+	bic	r0, r0, #0x4
+	str	r0, [r6, #0x438]
+	str	r1, [r7, #0x2c]
+wait_for_srefresh_exit_r1:
+	ldr	r0, [r6, #0x438]
+	tst	r0, #0x2000
+	beq	wait_for_srefresh_exit_r1
+
+	/* Store Context ID, User R/W thread, secure or NS VBAR */
+	ldmia	r8!, {r2-r7}
+	mcr	p15, 0, r2, c10, c2, 0
+	mcr	p15, 0, r3, c13, c0, 1
+	mcr	p15, 0, r4, c13, c1, 2
+	mcr	p15, 0, r5, c13, c2, 3
+	mcr	p15, 0, r6, c13, c3, 4
+	mcr	p15, 0, r7, c12, c0, 0
+
+	ldmia	r8!, {r4}
+	msr	cpsr, r4
+	mov	r0, r4
+
+	/* Move to IRQ mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_IRQ_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to ABT mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_ABT_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to undefined mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_UND_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to sys_32 mode */
+	orr	r1, r0, #(MODE_SYS_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r0, r13, r14}
+	msr	spsr_cxsf, r0
+
+	/* Check for the SPEAr revision */
+#ifdef GPIO_DDR_ISOLATE
+	ldr	r7, =GPIO_START_UPD_PA
+	/* Set xgpio89 driven low for cke patch disable */
+	ldr	r0, [r7, #0x048]
+	and	r0, r0, #0x0
+	str	r0, [r7, #0x048]
+	mov	r9, #0x0
+wait_for_reset_low:
+	/* Add some delay for the reset signal to propagate */
+	add	r9, r9, #0x1
+	cmp	r9, #0x30000
+	bne	wait_for_reset_low
+#endif
+
+srefresh_end_rev_0:
+#ifdef RESET_UART_REGISTERS
+	/* Reprogram UART0 before wakeup */
+	ldr	r7, =UART_BASE_PA
+
+	ldr	r0, [r7, #0x024]
+	orr	r0, r0, #0x1A
+	str	r0, [r7, #0x024]
+
+	ldr	r0, [r7, #0x028]
+	orr	r0, r0, #0x3
+	str	r0, [r7, #0x028]
+
+	ldr	r0, [r7, #0x02C]
+	orr	r0, r0, #0x70
+	str	r0, [r7, #0x02C]
+
+	ldr	r0, [r7, #0x030]
+	ldr	r2, =0xF01
+	orr	r0, r0, r2
+	str	r0, [r7, #0x030]
+
+	ldr	r0, [r7, #0x034]
+	orr	r0, r0, #0x12
+	str	r0, [r7, #0x034]
+
+	ldr	r0, [r7, #0x038]
+	orr	r0, r0, #0x50
+	str	r0, [r7, #0x038]
+#endif
+	/*
+	 * Invalidate all instruction caches to PoU
+	 */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0
+	mcr	p15, 0, r0, c7, c5, 6	@ Invalidate branch predictor array
+	mcr	p15, 0, r0, c7, c5, 7
+	mcr	p15, 0, r0, c8, c5, 0	@ Invalidate instruction TLB
+	mcr	p15, 0, r0, c8, c6, 0	@ Invalidate data TLB
+
+	msr	cpsr, r4
+	ldmia	r8!, {r0}
+	mov	pc, r0
+	nop
+	.ltorg
+	.align
+ENTRY(spear1340_sleep_mode_sz)
+	.word	. - spear1340_sleep_mode
diff --git a/arch/arm/mach-spear13xx/sleep_13xx.S b/arch/arm/mach-spear13xx/sleep_13xx.S
new file mode 100644
index 0000000..bc9727c
--- /dev/null
+++ b/arch/arm/mach-spear13xx/sleep_13xx.S
@@ -0,0 +1,481 @@
+/*
+ * linux/arch/arm/mach-spear13xx/sleep_13xx.S
+ *
+ * SPEAR13xx specific functions that will run in internal SRAM.
+ * The functions are used in power management.
+ *
+ * Copyright (C) 2010 ST MicroElectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/suspend.h>
+
+#define DDR_PLL_SREFRESH
+#define MPMC_RESET
+#define PWRDOMAINS_ON
+#define GPIO_DDR_ISOLATE
+
+/*
+ * spear13xx_sleep_mode()
+ * Forces SPEAr into sleep
+ * r0: state
+ */
+.text
+ENTRY(spear13xx_sleep_mode)
+	mov	r10, r1		/* latch the address of cpu_resume */
+	mov	r11, r0		/* latch the suspend state */
+
+	ldr	r8, =IO_ADDRESS(SPEAR_SRAM_STACK_PA)
+	/* Store Context ID, User R/W thread, secure or NS VBAR */
+	mrc	p15, 0, r2, c10, c2, 0
+	mrc	p15, 0, r3, c13, c0, 1
+	mrc	p15, 0, r4, c13, c1, 2
+	mrc	p15, 0, r5, c13, c2, 3
+	mrc	p15, 0, r6, c13, c3, 4
+	mrc	p15, 0, r7, c12, c0, 0
+	stmia	r8!, {r2-r7}
+
+	/* Store the Current CPSR */
+	mrs	r0, cpsr
+	stmia	r8!, {r0}
+
+	/* Move to IRQ Mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_IRQ_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+
+	/* Saving FIQ stack pointer on to Stack in DDR */
+	stmia	r8!, {r1, r13, r14}
+
+	/* Move to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to ABT mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_ABT_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to undefined mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_UND_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move to sys_32 mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SYS_32)
+	msr	cpsr_c, r1
+	mrs	r1, spsr
+	stmia	r8!, {r1, r13, r14}	/* Saving IRQ stack pointer */
+
+	/* Move back to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+
+	/* Latch the physical address of cpu_resume on to SRAM */
+	io_v2p	r0, r10, r1
+	stmia	r8!, {r0}
+
+	/* Extract the physical address to jump to */
+	adr	r0, mmu_off
+	io_v2p	r2, r0, r1
+
+	/* Disable MMU */
+	mrc	p15, 0, r0, c1, c0, 0
+	ldr	r1, =DISABLE_I_C_M_V
+	bic	r0, r0, r1
+	mcr	p15, 0, r0, c1, c0, 0
+	/* Move the Physical address into PC */
+	bx	r2
+	nop
+mmu_off:
+	/* Put the DDR in self refresh mode */
+	ldr	r6, =MISC_BASE_PA
+
+	/* Program MPMC Control Status register in Misc Space */
+	ldr	r0, [r6, #0x334]
+	/* Set srefresh_enter bit(2) */
+	orr	r0, r0, #0x4
+	str	r0, [r6, #0x334]
+wait_till_srefresh_on_r0:
+	ldr	r0, [r6, #0x334]
+	/* check for cke_status bit(13) */
+	tst	r0, #0x2000
+	beq	wait_till_srefresh_on_r0
+
+#ifdef GPIO_DDR_ISOLATE
+	/* enable gpio clock */
+	ldr	r0, [r6, #0x274]
+	orr	r0, r0, #0x00800000
+	str	r0, [r6, #0x274]
+
+	ldr	r6, =GPIO_START_PA
+	/* Set the Direction of GPIO-2 as output */
+	ldr	r0, [r6, #0x400]
+	orr	r0, r0, #0xc
+	str	r0, [r6, #0x400]
+
+	/* Set the value of GPIO-2/3 */
+	ldr	r0, [r6, #0x3fc]
+	orr	r0, r0, #0xc
+	str	r0, [r6, #0x3fc]
+	ldr	r6, =MISC_BASE_PA
+#endif
+
+#ifdef MPMC_RESET
+	ldr	r7, =MPMC_BASE_PA
+	/* Stop the MPMC controller */
+	ldr	r0, [r7, #0x2c]
+	bic	r0, r0, #0x1000000
+	str	r0, [r7, #0x2c]
+
+	/* reset the MPMC controller */
+	ldr	r1, [r6, #0x280]
+	orr	r1, r1, #0x3
+	str	r1, [r6, #0x280]
+
+	/* Stop the MPMC clock */
+	ldr	r1, [r6, #0x278]
+	bic	r1, r1, #0x3
+	str	r1, [r6, #0x278]
+#endif
+	/* Put the system in slow mode */
+	ldr	r0, [r6, #0x200]
+	bic	r0, r0, #0x4
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	orr	r0, r0, #0x2
+	str	r0, [r6, #0x200]	/* System is now in slow mode */
+wait_till_slow_mode:
+	ldr	r0, [r6, #0x200]
+	/* Wait for the mode to be updated */
+	and	r0, r0, #0xF0000
+	/* Poll the SCCTRL register status bits (6:3) */
+	cmp	r0, #0xA0000
+	bne wait_till_slow_mode
+
+	/*
+	 * Put the all the system pll's to off state
+	 * The loop of count 3 is provided below to
+	 * switch off the pll-1/2/3.
+	 * r1 contains the offset for the pll control
+	 * registers in the misc space.
+	 * DDR pll-4 requires different processing.
+	 */
+	ldr	r1, =MISC_PLL_OFFS
+	ldr	r2, =0x0	/* PLL Counter 1, 2, 3, 4 */
+swoff_pll:
+	ldr	r0, [r6, r1]
+	/* Clear pll_enable bit(1) of PLL1_CTR register in Misc registers */
+	bic	r0, r0, #0x02
+	str	r0, [r6, r1]
+	add	r1, #0xc
+	add	r2, #0x1
+	cmp	r2, #0x3	/* Switch off pll-1/2/3 */
+	bne	swoff_pll
+
+#ifdef DDR_PLL_SREFRESH
+	/* Switch off pll-4 */
+	ldr	r0, [r6, r1]
+	/* Clear pll_enable bit(2) of PLL1_CTR register in Misc registers */
+	bic	r0, r0, #0x04
+	str	r0, [r6, r1]
+#endif
+#ifdef PWRDOMAINS_ON
+	cmp	r11, #0x1
+	beq	standby_mode
+
+	/* Store the Resume Physical Address on Stack Secure location */
+	adr	r0, spear_sleep_restore
+	ldr	r3, =SRAM_SCR_REG
+	ldr	r6, =SPEAR_SRAM_START_PA
+	str	r0, [r6, r3]
+
+	/* Switch on certan sections as suggested by HW team */
+	/* Let the USB Host clock be on */
+	ldr	r6, =MISC_BASE_PA
+	ldr	r0, [r6, #0x274]
+	orr	r0, r0, #0xE00
+	str	r0, [r6, #0x274]
+	ldr	r0, [r6, #0x100]
+
+	/*
+	 * Switch off the power domains.
+	 * Clear the ack bit
+	 */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+	bic	r0, r0, #0x1000
+	str	r0, [r6, #0x100]
+
+wait_ack1:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack1
+
+	/* Clear the ack bit */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+	bic	r0, r0, #0x0800
+	str	r0, [r6, #0x100]
+wait_ack2:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack2
+
+	/* Clear the ack bit */
+	bic	r0, r0, #0xc000
+	str	r0, [r6, #0x100]
+
+#ifdef CPU_PWR_DOMAIN_OFF
+	bic	r0, r0, #0x2400
+	str	r0, [r6, #0x100]
+wait_ack3:
+	ldr	r0, [r6, #0x100]
+	tst	r0, #0x4000
+	beq	wait_ack3
+#endif
+#endif
+
+standby_mode:
+	wfi				@ wait for interrupt
+	nop
+spear_sleep_restore:
+	nop
+	ldr	r6, =MISC_BASE_PA
+	ldr	r1, =MISC_PLL_OFFS
+
+#ifdef DDR_PLL_SREFRESH
+	/* Switch on PLL-4, strobe the pll also */
+	ldr	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL1
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL2
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL3
+	str	r0, [r6, #0x238]
+	ldr	r0, =PLL_VAL2
+	str	r0, [r6, #0x238]
+pll_lock_4:
+	/* Set the pll_lock bit(0) in PLLX_CTR register in misc space*/
+	ldr	r5, [r6, #0x238]
+	and	r5, r5, #0x1
+	/* Wait for pll lock status */
+	cmp	r5, #0x1
+	bne	pll_lock_4
+#endif
+
+	ldr	r2, =0x0	/* PLL Counter 1, 2, 3, 4 */
+swon_pll_1_3:
+	/* Switch on Pll-1/2/3 */
+	ldr	r0, [r6, r1]
+	orr	r0, r0, #0x2
+	str	r0, [r6, r1]
+pll_lock_1_3:
+	/* Set the pll_lock bit(0) in PLLX_CTR register in misc space*/
+	ldr	r5, [r6, r1]
+	and	r5, r5, #0x1
+	/* Wait for pll lock status */
+	cmp	r5, #0x1
+	bne	pll_lock_1_3
+
+	/* Loop for all the pll's */
+	add	r1, #0xc
+	add	r2, #0x1
+	cmp	r2, #0x3	/* Switch on till pll-3 */
+	bne	swon_pll_1_3
+
+	/* Put the system in normal mode */
+	ldr	r0, [r6, #0x200]
+	bic	r0, r0, #0x7
+	/* Set the apt mode bits(2:0) in SCCTRL register */
+	orr	r0, r0, #0x4
+	str	r0, [r6, #0x200]	/* System is now in slow mode */
+wait_till_normal_mode:
+	ldr	r0, [r6, #0x200]
+	/* Wait for the mode to be updated */
+	and	r0, r0, #0xF0000
+	/* Poll the SCCTRL register status bits (6:3) */
+	cmp	r0, #0xf0000
+	bne wait_till_normal_mode
+
+	ldr	r6, =SPEAR_SRAM_START_PA
+#ifdef MPMC_RESET
+	ldr	r7, =MISC_BASE_PA
+	/* Enable the MPMC clock */
+	ldr	r1, [r7, #0x278]
+	orr	r1, r1, #0x3
+	str	r1, [r7, #0x278]
+	/* Provide Software Reset to MPMC */
+	ldr	r1, [r7, #0x280]
+	orr	r1, r1, #0x3
+	str	r1, [r7, #0x280]
+	/* Enable MPMC back */
+	bic	r1, r1, #0x3
+	str	r1, [r7, #0x280]
+#endif
+	/* Restore the MPMC registers */
+	ldr	r7, =MPMC_BASE_PA
+	mov	r0, #0
+	ldr	r3, =MPMC_REG_END
+mpmc_restore_regs:
+	ldr	r1, [r6, r3]
+	cmp	r0, #0x2c
+	bne	ddf
+	nop
+	nop
+	bic	r1, r1, #0x1000000
+ddf:
+	str	r1, [r7, r0]
+	sub	r3, r3, #4
+	add	r0, r0, #4
+	cmp	r0, #0x320
+	bne	mpmc_restore_regs
+
+	/* Enable MPMC */
+	ldr	r1, [r7, #0x2c]
+	orr	r1, r1, #0x1000000
+	str	r1, [r7, #0x2c]
+	dsb
+	isb
+
+#ifdef GPIO_DDR_ISOLATE
+	/* Disable MPMC reset */
+	ldr	r6, =MISC_BASE_PA
+	mov	r0, #0
+	str	r0, [r6, #0x280]
+
+	ldr	r7, =GPIO_START_PA
+	/* Set the Direction of GPIO-2 as output */
+	ldr	r0, [r7, #0x400]
+	orr	r0, r0, #0xc
+	str	r0, [r7, #0x400]
+
+	/* Set the value of GPIO-2 DDR CLKEN*/
+	ldr	r0, [r7, #0x3fc]
+	bic	r0, r0, #0x7
+	str	r0, [r7, #0x3fc]
+
+	mov	r0, #0
+ddr_out_srefresh:
+	/* Add some delay */
+	add	r0, r0, #0x1
+	cmp	r0, #0x60000
+	bne	ddr_out_srefresh
+#endif
+	/* Move the DDR out of self refresh mode */
+	ldr	r7, =MPMC_BASE_PA
+	ldr	r8, =SPEAR_SRAM_STACK_PA
+
+	/* Clearance is required in the mpmc space */
+	ldr	r1, [r7, #0x2c]
+	/*
+	 * Clear bit srefresh bit (2) of MPMC_11 register
+	 * The misc wrapper does not works fine by itself till
+	 * this bit is also cleared.
+	 */
+	bic	r1, r1, #0x10000
+
+	/* Program MPMC Control Status register in Misc Space */
+	ldr	r0, [r6, #0x334]
+	/* Clear srefresh_enter bit(2) */
+	bic	r0, r0, #0x4
+	str	r0, [r6, #0x334]
+	str	r1, [r7, #0x2c]
+
+wait_for_srefresh_exit_r0:
+	ldr	r0, [r6, #0x334]
+	tst	r0, #0x2000
+	bne	wait_for_srefresh_exit_r0
+
+	/* Store Context ID, User R/W thread, secure or NS VBAR */
+	ldmia	r8!, {r2-r7}
+	mcr	p15, 0, r2, c10, c2, 0
+	mcr	p15, 0, r3, c13, c0, 1
+	mcr	p15, 0, r4, c13, c1, 2
+	mcr	p15, 0, r5, c13, c2, 3
+	mcr	p15, 0, r6, c13, c3, 4
+	mcr	p15, 0, r7, c12, c0, 0
+
+	ldmia	r8!, {r4}
+	msr	cpsr, r4
+	mov	r0, r4
+
+	/* Move to IRQ mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_IRQ_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to svc mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_SVC_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to ABT mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_ABT_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to undefined mode */
+	mrs	r0, cpsr
+	bic	r0, r0, #MODE_BITS
+	orr	r1, r0, #(MODE_UND_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r1, r13, r14}
+	msr	spsr, r1
+
+	/* Move to sys_32 mode */
+	orr	r1, r0, #(MODE_SYS_32)
+	msr	cpsr_c, r1
+	ldmia	r8!, {r0, r13, r14}
+	msr	spsr_cxsf, r0
+
+	/*
+	 * Invalidate all instruction caches to PoU
+	 */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c5, 0
+	mcr	p15, 0, r0, c7, c5, 6	@ Invalidate branch predictor array
+	mcr	p15, 0, r0, c7, c5, 7
+	mcr	p15, 0, r0, c8, c5, 0	@ Invalidate instruction TLB
+	mcr	p15, 0, r0, c8, c6, 0	@ Invalidate data TLB
+
+	msr	cpsr, r4
+	ldmia	r8!, {r0}
+	mov	pc, r0
+	nop
+	.ltorg
+	.align
+ENTRY(spear13xx_sleep_mode_sz)
+	.word	. - spear13xx_sleep_mode
diff --git a/arch/arm/mach-spear13xx/spear1300.c b/arch/arm/mach-spear13xx/spear1300.c
new file mode 100644
index 0000000..77bc2ed
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1300.c
@@ -0,0 +1,37 @@
+/*
+ * arch/arm/mach-spear13xx/spear1300.c
+ *
+ * SPEAr1300 machine source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/generic.h>
+
+/* pmx driver structure */
+static struct pmx_driver pmx_driver;
+
+/* Add spear1300 specific devices here */
+
+void __init spear1300_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count)
+{
+	int ret;
+
+	/* call spear13xx family common init function */
+	spear13xx_init();
+
+	/* pmx initialization */
+	pmx_driver.mode = pmx_mode;
+	pmx_driver.devs = pmx_devs;
+	pmx_driver.devs_count = pmx_dev_count;
+
+	ret = pmx_register(&pmx_driver);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
diff --git a/arch/arm/mach-spear13xx/spear1300_evb.c b/arch/arm/mach-spear13xx/spear1300_evb.c
new file mode 100644
index 0000000..7f1aa91
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1300_evb.c
@@ -0,0 +1,386 @@
+/*
+ * arch/arm/mach-spear13xx/spear1300_evb.c
+ *
+ * SPEAr1300 evaluation board source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/spear_smi.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <plat/keyboard.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear_pcie.h>
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/* spear13xx specific devices */
+	&spear13xx_pmx_i2c,
+	&spear13xx_pmx_i2s1,
+	&spear13xx_pmx_i2s2,
+	&spear13xx_pmx_clcd,
+	&spear13xx_pmx_egpio_grp,
+	&spear13xx_pmx_gmii,
+	&spear13xx_pmx_keyboard_6x6,
+	&spear13xx_pmx_mcif,
+	&spear13xx_pmx_nand_8bit,
+	&spear13xx_pmx_smi_4_chips,
+	&spear13xx_pmx_ssp,
+	&spear13xx_pmx_uart0,
+	&spear13xx_pmx_sdhci,
+
+	/* spear1300 specific devices */
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_cpufreq_device,
+	&spear13xx_db9000_clcd_device,
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear13xx_device_gpiokeys,
+#endif
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_i2s0_device,
+	&spear13xx_jpeg_device,
+	&spear13xx_kbd_device,
+	&spear13xx_nand_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcie_gadget0_device,
+	&spear13xx_pcie_host1_device,
+	&spear13xx_pcie_host2_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear13xx_thermal_device,
+	&spear13xx_udc_device,
+	&spear13xx_wdt_device,
+	/* spear1300 specific devices */
+
+};
+
+/* Ethernet PLatform data */
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = 5,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x20000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x20000,
+		.size = 12 * 0x20000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 12) * 0x20000,
+		.size = 48 * 0x20000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 48) * 0x20000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+#if 0
+/* fsmc nor partition info */
+#define PARTITION(n, off, sz)	{.name = n, .offset = off, .size = sz}
+static struct mtd_partition partition_info[] = {
+	PARTITION("X-loader", 0, 1 * 0x20000),
+	PARTITION("U-Boot", 0x20000, 3 * 0x20000),
+	PARTITION("Kernel", 0x80000, 24 * 0x20000),
+	PARTITION("Root File System", 0x380000, 84 * 0x20000),
+};
+
+/* fsmc nor platform data */
+static const struct physmap_flash_data nor_plat_data __initconst = {
+	.parts = partition_info,
+	.nr_parts = ARRAY_SIZE(partition_info),
+	.width = FSMC_FLASH_WIDTH8,
+};
+#endif
+
+/* arasan compact flash controller's platform data */
+static struct arasan_cf_pdata cf_pdata = {
+	.cf_if_clk = CF_IF_CLK_166M,
+	.quirk = CF_BROKEN_UDMA,
+	.dma_priv = &cf_dma_priv,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_9x9_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_9x9,
+};
+
+/* Currently no gpios are free on eval board so it is kept commented */
+#if 0
+/* spi0 flash Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, flash, /* mention gpio number here */);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_gpio_control);
+
+/* spi0 spidev Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, dev, /* mention gpio number here */);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_gpio_control);
+#endif
+
+/* spi0 touch screen Chip Select Control function, controlled by gpio pin */
+DECLARE_SPI_CS_GPIO_CONTROL(0, ts, GPIO1_7);
+/* spi0 touch screen Info structure */
+static struct pl022_config_chip spi0_ts_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.slave_tx_disable = 0,
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = spi0_ts_cs_gpio_control,
+};
+
+static struct stmpe_ts_platform_data stmpe610_ts_pdata = {
+	.sample_time = 4, /* 80 clocks */
+	.mod_12b = 1, /* 12 bit */
+	.ref_sel = 0, /* Internal */
+	.adc_freq = 1, /* 3.25 MHz */
+	.ave_ctrl = 1, /* 2 samples */
+	.touch_det_delay = 2, /* 100 us */
+	.settling = 2, /* 500 us */
+	.fraction_z = 7,
+	.i_drive = 1, /* 50 to 80 mA */
+};
+
+static struct stmpe_platform_data stmpe610_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = SPEAR_STMPE610_INT_BASE,
+	.irq_trigger = IRQ_TYPE_EDGE_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.irq_over_gpio = true,
+	.irq_gpio = GPIO1_6,
+	.ts = &stmpe610_ts_pdata,
+};
+
+static struct spi_board_info __initdata spi_board_info[] = {
+	/* spi0 board info */
+	{
+		.modalias = "stmpe610",
+		.platform_data = &stmpe610_pdata,
+		.controller_data = &spi0_ts_chip_info,
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	},
+#if 0
+	/* spi0 board info */
+	{
+		.modalias = "spidev",
+		.controller_data = &spi0_dev_chip_info,
+		.max_speed_hz = 25000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	}, {
+		.modalias = "m25p80",
+		.controller_data = &spi0_flash_chip_info,
+		.max_speed_hz = 12000000,
+		.bus_num = 0,
+		.chip_select = 1,
+		.mode = SPI_MODE_3,
+	}
+#endif
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+/* This function is needed for board specific PCIe initilization */
+static void __init spear1300_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host1_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host2_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+}
+#endif
+
+static void
+spear1300_evb_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init spear1300_evb_init(void)
+{
+	unsigned int i;
+
+	/* set compact flash plat data */
+	set_arasan_cf_pdata(&spear13xx_cf_device, &cf_pdata);
+
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* call spear1300 machine init function */
+	spear1300_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear13xx_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_nand_device.name);
+
+	/*
+	 * FSMC cannot used as NOR and NAND at the same time For the moment,
+	 * disable NOR and use NAND only. If NOR is needed, enable the following
+	 * code and disable all code for NAND. Also enable nand in padmux
+	 * configuration to use it
+	 */
+#if 0
+	/* Initialize fsmc regiters */
+	fsmc_nor_init(&spear13xx_fsmc_nor_device, SPEAR13XX_FSMC_BASE, 0,
+			FSMC_FLASH_WIDTH8);
+	/* initialize fsmc related data in fsmc plat data */
+	if (platform_device_add_data(&spear13xx_fsmc_nor_device, &nor_plat_data,
+				sizeof(nor_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_fsmc_nor_device.name);
+#endif
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+	spear1300_pcie_board_init();
+#endif
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/* Register slave devices on the I2C buses */
+	i2c_register_default_devices();
+
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR1300_EVB, "ST-SPEAR1300-EVB")
+	.atag_offset	=	0x100,
+	.fixup		=	spear1300_evb_fixup,
+	.map_io		=	spear13xx_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear1300_evb_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear1310.c b/arch/arm/mach-spear13xx/spear1310.c
new file mode 100644
index 0000000..da1c5483
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1310.c
@@ -0,0 +1,1441 @@
+/*
+ * arch/arm/mach-spear13xx/spear1310.c
+ *
+ * SPEAr1310 machine source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/amba/pl022.h>
+#include <linux/can/platform/c_can.h>
+#include <linux/clk.h>
+#include <linux/mtd/fsmc.h>
+#include <asm/irq.h>
+#include <plat/hdlc.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear1310_misc_regs.h>
+
+/* pmx driver structure */
+static struct pmx_driver pmx_driver;
+
+/* Pad multiplexing for uart1 device */
+/* Muxed with I2C */
+static struct pmx_mux_reg pmx_uart1_dis_i2c_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2C_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart1_dis_i2c_modes[] = {
+	{
+		.mux_regs = pmx_uart1_dis_i2c_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart1_dis_i2c_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_uart_1_dis_i2c = {
+	.name = "uart1 disable i2c",
+	.modes = pmx_uart1_dis_i2c_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart1_dis_i2c_modes),
+};
+
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_uart1_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_MCIDATA1_MASK |
+			SPEAR13XX_PMX_MCIDATA2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart1_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_uart1_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart1_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_uart_1_dis_sd = {
+	.name = "uart1 disable sd",
+	.modes = pmx_uart1_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart1_dis_sd_modes),
+};
+
+/* Pad multiplexing for uart2_3 device */
+static struct pmx_mux_reg pmx_uart2_3_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2S1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart2_3_modes[] = {
+	{
+		.mux_regs = pmx_uart2_3_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart2_3_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_uart_2_3 = {
+	.name = "uart2_3",
+	.modes = pmx_uart2_3_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart2_3_modes),
+};
+
+/* Pad multiplexing for uart4 device */
+static struct pmx_mux_reg pmx_uart4_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2S1_MASK | SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart4_modes[] = {
+	{
+		.mux_regs = pmx_uart4_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart4_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_uart_4 = {
+	.name = "uart4",
+	.modes = pmx_uart4_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart4_modes),
+};
+
+/* Pad multiplexing for uart5 device */
+static struct pmx_mux_reg pmx_uart5_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart5_modes[] = {
+	{
+		.mux_regs = pmx_uart5_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart5_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_uart_5 = {
+	.name = "uart5",
+	.modes = pmx_uart5_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart5_modes),
+};
+
+/* Pad multiplexing for rs485_0_1_tdm_0_1 device */
+static struct pmx_mux_reg pmx_rs485_0_1_tdm_0_1_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_rs485_0_1_tdm_0_1_modes[] = {
+	{
+		.mux_regs = pmx_rs485_0_1_tdm_0_1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rs485_0_1_tdm_0_1_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_rs485_0_1_tdm_0_1 = {
+	.name = "rs485_0_1_tdm_0_1",
+	.modes = pmx_rs485_0_1_tdm_0_1_modes,
+	.mode_count = ARRAY_SIZE(pmx_rs485_0_1_tdm_0_1_modes),
+};
+
+/* Pad multiplexing for i2c_1_2 device */
+static struct pmx_mux_reg pmx_i2c_1_2_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c_1_2_modes[] = {
+	{
+		.mux_regs = pmx_i2c_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c_1_2_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c_1_2 = {
+	.name = "i2c_1_2",
+	.modes = pmx_i2c_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c_1_2_modes),
+};
+
+/* Pad multiplexing for i2c3_dis_smi_clcd device */
+/* Muxed with SMI & CLCD */
+static struct pmx_mux_reg pmx_i2c3_dis_smi_clcd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK | SPEAR13XX_PMX_SMI_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c3_dis_smi_clcd_modes[] = {
+	{
+		.mux_regs = pmx_i2c3_dis_smi_clcd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c3_dis_smi_clcd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c3_dis_smi_clcd = {
+	.name = "i2c3_dis_smi_clcd",
+	.modes = pmx_i2c3_dis_smi_clcd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c3_dis_smi_clcd_modes),
+};
+
+/* Pad multiplexing for i2c3_dis_sd_i2s1 device */
+/* Muxed with SD/MMC & I2S1 */
+static struct pmx_mux_reg pmx_i2c3_dis_sd_i2s1_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_I2S2_MASK | SPEAR13XX_PMX_MCIDATA3_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c3_dis_sd_i2s1_modes[] = {
+	{
+		.mux_regs = pmx_i2c3_dis_sd_i2s1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c3_dis_sd_i2s1_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c3_dis_sd_i2s1 = {
+	.name = "i2c3_dis_sd_i2s1",
+	.modes = pmx_i2c3_dis_sd_i2s1_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c3_dis_sd_i2s1_modes),
+};
+
+/* Pad multiplexing for i2c_4_5_dis_smi device */
+/* Muxed with SMI */
+static struct pmx_mux_reg pmx_i2c_4_5_dis_smi_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SMI_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c_4_5_dis_smi_modes[] = {
+	{
+		.mux_regs = pmx_i2c_4_5_dis_smi_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c_4_5_dis_smi_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c_4_5_dis_smi = {
+	.name = "i2c_4_5_dis_smi",
+	.modes = pmx_i2c_4_5_dis_smi_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c_4_5_dis_smi_modes),
+};
+
+/* Pad multiplexing for i2c4_dis_sd device */
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_i2c4_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_MCIDATA4_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIDATA5_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c4_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_i2c4_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c4_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c4_dis_sd = {
+	.name = "i2c4_dis_sd",
+	.modes = pmx_i2c4_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c4_dis_sd_modes),
+};
+
+/* Pad multiplexing for i2c5_dis_sd device */
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_i2c5_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIDATA6_MASK |
+			SPEAR13XX_PMX_MCIDATA7_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c5_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_i2c5_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c5_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c5_dis_sd = {
+	.name = "i2c5_dis_sd",
+	.modes = pmx_i2c5_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c5_dis_sd_modes),
+};
+
+/* Pad multiplexing for i2c_6_7_dis_kbd device */
+/* Muxed with KBD */
+static struct pmx_mux_reg pmx_i2c_6_7_dis_kbd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KBD_ROWCOL25_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c_6_7_dis_kbd_modes[] = {
+	{
+		.mux_regs = pmx_i2c_6_7_dis_kbd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c_6_7_dis_kbd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c_6_7_dis_kbd = {
+	.name = "i2c_6_7_dis_kbd",
+	.modes = pmx_i2c_6_7_dis_kbd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c_6_7_dis_kbd_modes),
+};
+
+/* Pad multiplexing for i2c6_dis_sd device */
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_i2c6_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIIORDRE_MASK |
+			SPEAR13XX_PMX_MCIIOWRWE_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c6_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_i2c6_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c6_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c6_dis_sd = {
+	.name = "i2c6_dis_sd",
+	.modes = pmx_i2c6_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c6_dis_sd_modes),
+};
+
+/* Pad multiplexing for i2c7_dis_sd device */
+static struct pmx_mux_reg pmx_i2c7_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIRESETCF_MASK |
+			SPEAR13XX_PMX_MCICS0CE_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c7_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_i2c7_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c7_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_i2c7_dis_sd = {
+	.name = "i2c7_dis_sd",
+	.modes = pmx_i2c7_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c7_dis_sd_modes),
+};
+
+/* Pad multiplexing for rgmii device */
+static struct pmx_mux_reg pmx_rgmii_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1310_PMX_RGMII_REG0_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1310_PMX_RGMII_REG1_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1310_PMX_RGMII_REG2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_rgmii_modes[] = {
+	{
+		.mux_regs = pmx_rgmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rgmii_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_rgmii = {
+	.name = "rgmii",
+	.modes = pmx_rgmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_rgmii_modes),
+};
+
+/* Pad multiplexing for can0_dis_nor device */
+/* Muxed with NOR */
+static struct pmx_mux_reg pmx_can0_dis_nor_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NFRSTPWDWN2_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NFRSTPWDWN3_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_can0_dis_nor_modes[] = {
+	{
+		.mux_regs = pmx_can0_dis_nor_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_can0_dis_nor_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_can0_dis_nor = {
+	.name = "can0_dis_nor",
+	.modes = pmx_can0_dis_nor_modes,
+	.mode_count = ARRAY_SIZE(pmx_can0_dis_nor_modes),
+};
+
+/* Pad multiplexing for can0_dis_sd device */
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_can0_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCICFINTR_MASK |
+			SPEAR13XX_PMX_MCIIORDY_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_can0_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_can0_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_can0_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_can0_dis_sd = {
+	.name = "can0_dis_sd",
+	.modes = pmx_can0_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_can0_dis_sd_modes),
+};
+
+/* Pad multiplexing for can1_dis_sd device */
+/* Muxed with SD/MMC */
+static struct pmx_mux_reg pmx_can1_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCICS1_MASK |
+			SPEAR13XX_PMX_MCIDMAACK_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_can1_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_can1_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_can1_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_can1_dis_sd = {
+	.name = "can1_dis_sd",
+	.modes = pmx_can1_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_can1_dis_sd_modes),
+};
+
+/* Pad multiplexing for can1_dis_kbd device */
+/* Muxed with KBD */
+static struct pmx_mux_reg pmx_can1_dis_kbd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KBD_ROWCOL25_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_can1_dis_kbd_modes[] = {
+	{
+		.mux_regs = pmx_can1_dis_kbd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_can1_dis_kbd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_can1_dis_kbd = {
+	.name = "can1_dis_kbd",
+	.modes = pmx_can1_dis_kbd_modes,
+	.mode_count = ARRAY_SIZE(pmx_can1_dis_kbd_modes),
+};
+
+/* Pad multiplexing for pci device */
+static struct pmx_mux_reg pmx_pci_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1310_PMX_PCI_REG0_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1310_PMX_PCI_REG1_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1310_PMX_PCI_REG2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_pci_modes[] = {
+	{
+		.mux_regs = pmx_pci_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pci_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_pci = {
+	.name = "pci",
+	.modes = pmx_pci_modes,
+	.mode_count = ARRAY_SIZE(pmx_pci_modes),
+};
+
+/* Pad multiplexing for smii_0_1_2 device */
+static struct pmx_mux_reg pmx_smii_0_1_2_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1310_PMX_SMII_0_1_2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_smii_0_1_2_modes[] = {
+	{
+		.mux_regs = pmx_smii_0_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_smii_0_1_2_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_smii_0_1_2 = {
+	.name = "smii_0_1_2",
+	.modes = pmx_smii_0_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_smii_0_1_2_modes),
+};
+
+/* Pad multiplexing for ssp1_dis_kbd device */
+static struct pmx_mux_reg pmx_ssp1_dis_kbd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KBD_ROWCOL25_MASK |
+			SPEAR13XX_PMX_KBD_COL1_MASK |
+			SPEAR13XX_PMX_KBD_COL0_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp1_dis_kbd_modes[] = {
+	{
+		.mux_regs = pmx_ssp1_dis_kbd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp1_dis_kbd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_ssp1_dis_kbd = {
+	.name = "ssp1_dis_kbd",
+	.modes = pmx_ssp1_dis_kbd_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp1_dis_kbd_modes),
+};
+
+/* Pad multiplexing for ssp1_dis_sd device */
+static struct pmx_mux_reg pmx_ssp1_dis_sd_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIADDR0ALE_MASK |
+			SPEAR13XX_PMX_MCIADDR2_MASK | SPEAR13XX_PMX_MCICECF_MASK
+			| SPEAR13XX_PMX_MCICEXD_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp1_dis_sd_modes[] = {
+	{
+		.mux_regs = pmx_ssp1_dis_sd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp1_dis_sd_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_ssp1_dis_sd = {
+	.name = "ssp1_dis_sd",
+	.modes = pmx_ssp1_dis_sd_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp1_dis_sd_modes),
+};
+
+/* Pad multiplexing for gpt64 device */
+static struct pmx_mux_reg pmx_gpt64_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCICDCF1_MASK |
+			SPEAR13XX_PMX_MCICDCF2_MASK |
+			SPEAR13XX_PMX_MCICDXD_MASK |
+			SPEAR13XX_PMX_MCILEDS_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt64_modes[] = {
+	{
+		.mux_regs = pmx_gpt64_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt64_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_gpt64 = {
+	.name = "gpt64",
+	.modes = pmx_gpt64_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt64_modes),
+};
+
+/* Pad multiplexing for ras_mii_txclk device */
+static struct pmx_mux_reg pmx_ras_mii_txclk_mux[] = {
+	{
+		.address = SPEAR1310_PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NFCE2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_ras_mii_txclk_modes[] = {
+	{
+		.mux_regs = pmx_ras_mii_txclk_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ras_mii_txclk_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_ras_mii_txclk = {
+	.name = "ras_mii_txclk",
+	.modes = pmx_ras_mii_txclk_modes,
+	.mode_count = ARRAY_SIZE(pmx_ras_mii_txclk_modes),
+};
+
+/* pad multiplexing for pcie0 device */
+static struct pmx_mux_reg pmx_pcie0_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_PCIE_CFG_VAL(0),
+		.value = SPEAR1310_PCIE_CFG_VAL(0),
+	},
+};
+
+static struct pmx_dev_mode pmx_pcie0_modes[] = {
+	{
+		.mux_regs = pmx_pcie0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pcie0_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_pcie0 = {
+	.name = "pcie0",
+	.modes = pmx_pcie0_modes,
+	.mode_count = ARRAY_SIZE(pmx_pcie0_modes),
+};
+
+/* pad multiplexing for pcie1 device */
+static struct pmx_mux_reg pmx_pcie1_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_PCIE_CFG_VAL(1),
+		.value = SPEAR1310_PCIE_CFG_VAL(1),
+	},
+};
+
+static struct pmx_dev_mode pmx_pcie1_modes[] = {
+	{
+		.mux_regs = pmx_pcie1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pcie1_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_pcie1 = {
+	.name = "pcie1",
+	.modes = pmx_pcie1_modes,
+	.mode_count = ARRAY_SIZE(pmx_pcie1_modes),
+};
+
+/* pad multiplexing for pcie2 device */
+static struct pmx_mux_reg pmx_pcie2_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_PCIE_CFG_VAL(2),
+		.value = SPEAR1310_PCIE_CFG_VAL(2),
+	},
+};
+
+static struct pmx_dev_mode pmx_pcie2_modes[] = {
+	{
+		.mux_regs = pmx_pcie2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pcie2_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_pcie2 = {
+	.name = "pcie2",
+	.modes = pmx_pcie2_modes,
+	.mode_count = ARRAY_SIZE(pmx_pcie2_modes),
+};
+
+/* pad multiplexing for sata0 device */
+static struct pmx_mux_reg pmx_sata0_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_SATA_CFG_VAL(0),
+		.value = SPEAR1310_SATA_CFG_VAL(0),
+	},
+};
+
+static struct pmx_dev_mode pmx_sata0_modes[] = {
+	{
+		.mux_regs = pmx_sata0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sata0_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_sata0 = {
+	.name = "sata0",
+	.modes = pmx_sata0_modes,
+	.mode_count = ARRAY_SIZE(pmx_sata0_modes),
+};
+
+/* pad multiplexing for sata1 device */
+static struct pmx_mux_reg pmx_sata1_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_SATA_CFG_VAL(1),
+		.value = SPEAR1310_SATA_CFG_VAL(1),
+	},
+};
+
+static struct pmx_dev_mode pmx_sata1_modes[] = {
+	{
+		.mux_regs = pmx_sata1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sata1_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_sata1 = {
+	.name = "sata1",
+	.modes = pmx_sata1_modes,
+	.mode_count = ARRAY_SIZE(pmx_sata1_modes),
+};
+
+/* pad multiplexing for sata2 device */
+static struct pmx_mux_reg pmx_sata2_mux[] = {
+	{
+		.address = SPEAR1310_PCIE_SATA_CFG,
+		.mask = SPEAR1310_SATA_CFG_VAL(2),
+		.value = SPEAR1310_SATA_CFG_VAL(2),
+	},
+};
+
+static struct pmx_dev_mode pmx_sata2_modes[] = {
+	{
+		.mux_regs = pmx_sata2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sata2_mux),
+	},
+};
+
+struct pmx_dev spear1310_pmx_sata2 = {
+	.name = "sata2",
+	.modes = pmx_sata2_modes,
+	.mode_count = ARRAY_SIZE(pmx_sata2_modes),
+};
+
+/* Add spear1310 specific devices here */
+/* ssp1 device registeration */
+static struct pl022_ssp_controller ssp1_platform_data = {
+	.bus_id = 1,
+	.enable_dma = 0,
+	/*
+	 * This is number of spi devices that can be connected to spi. This
+	 * number depends on cs lines supported by soc.
+	 */
+	.num_chipselect = 3,
+};
+
+struct amba_device spear1310_ssp1_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "ssp-pl022.1",
+		.platform_data = &ssp1_platform_data,
+	},
+	.res = {
+		.start = SPEAR1310_SSP1_BASE,
+		.end = SPEAR1310_SSP1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_SSP1, NO_IRQ},
+};
+
+/* uart1 device registeration */
+struct amba_device spear1310_uart1_device = {
+	.dev = {
+		.init_name = "uart1",
+	},
+	.res = {
+		.start = SPEAR1310_UART1_BASE,
+		.end = SPEAR1310_UART1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_UART1, NO_IRQ},
+};
+
+/* uart2 device registeration */
+struct amba_device spear1310_uart2_device = {
+	.dev = {
+		.init_name = "uart2",
+	},
+	.res = {
+		.start = SPEAR1310_UART2_BASE,
+		.end = SPEAR1310_UART2_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_UART2, NO_IRQ},
+};
+
+/* uart3 device registeration */
+struct amba_device spear1310_uart3_device = {
+	.dev = {
+		.init_name = "uart3",
+	},
+	.res = {
+		.start = SPEAR1310_UART3_BASE,
+		.end = SPEAR1310_UART3_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_UART3, NO_IRQ},
+};
+
+/* uart4 device registeration */
+struct amba_device spear1310_uart4_device = {
+	.dev = {
+		.init_name = "uart4",
+	},
+	.res = {
+		.start = SPEAR1310_UART4_BASE,
+		.end = SPEAR1310_UART4_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_UART4, NO_IRQ},
+};
+
+/* uart5 device registeration */
+struct amba_device spear1310_uart5_device = {
+	.dev = {
+		.init_name = "uart5",
+	},
+	.res = {
+		.start = SPEAR1310_UART5_BASE,
+		.end = SPEAR1310_UART5_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_IRQ_UART5, NO_IRQ},
+};
+
+/* CAN device registeration */
+static struct c_can_platform_data can0_pdata = {
+	.is_quirk_required = true,
+	.devtype_data = {
+		.rx_first = 1,
+		.rx_split = 20,
+		.rx_last = 26,
+		.tx_num = 6,
+	},
+};
+
+static struct resource can0_resources[] = {
+	{
+		.start = SPEAR1310_CAN0_BASE,
+		.end = SPEAR1310_CAN0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_CAN0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_can0_device = {
+	.name = "c_can_platform",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(can0_resources),
+	.resource = can0_resources,
+	.dev.platform_data = &can0_pdata,
+};
+
+static struct c_can_platform_data can1_pdata = {
+	.is_quirk_required = true,
+	.devtype_data = {
+		.rx_first = 1,
+		.rx_split = 20,
+		.rx_last = 26,
+		.tx_num = 6,
+	},
+};
+
+static struct resource can1_resources[] = {
+	{
+		.start = SPEAR1310_CAN1_BASE,
+		.end = SPEAR1310_CAN1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_CAN1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_can1_device = {
+	.name = "c_can_platform",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(can1_resources),
+	.resource = can1_resources,
+	.dev.platform_data = &can1_pdata,
+};
+
+/* i2c1 device registeration */
+static struct resource i2c1_resources[] = {
+	{
+		.start = SPEAR1310_I2C1_BASE,
+		.end = SPEAR1310_I2C1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c1_device = {
+	.name = "i2c_designware",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c1_resources),
+	.resource = i2c1_resources,
+};
+
+/* i2c2 device registeration */
+static struct resource i2c2_resources[] = {
+	{
+		.start = SPEAR1310_I2C2_BASE,
+		.end = SPEAR1310_I2C2_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c2_device = {
+	.name = "i2c_designware",
+	.id = 2,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c2_resources),
+	.resource = i2c2_resources,
+};
+
+/* i2c3 device registeration */
+static struct resource i2c3_resources[] = {
+	{
+		.start = SPEAR1310_I2C3_BASE,
+		.end = SPEAR1310_I2C3_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c3_device = {
+	.name = "i2c_designware",
+	.id = 3,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c3_resources),
+	.resource = i2c3_resources,
+};
+
+/* i2c4 device registeration */
+static struct resource i2c4_resources[] = {
+	{
+		.start = SPEAR1310_I2C4_BASE,
+		.end = SPEAR1310_I2C4_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C4,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c4_device = {
+	.name = "i2c_designware",
+	.id = 4,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c4_resources),
+	.resource = i2c4_resources,
+};
+
+/* i2c5 device registeration */
+static struct resource i2c5_resources[] = {
+	{
+		.start = SPEAR1310_I2C5_BASE,
+		.end = SPEAR1310_I2C5_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C5,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c5_device = {
+	.name = "i2c_designware",
+	.id = 5,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c5_resources),
+	.resource = i2c5_resources,
+};
+
+/* i2c6 device registeration */
+static struct resource i2c6_resources[] = {
+	{
+		.start = SPEAR1310_I2C6_BASE,
+		.end = SPEAR1310_I2C6_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C6,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c6_device = {
+	.name = "i2c_designware",
+	.id = 6,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c6_resources),
+	.resource = i2c6_resources,
+};
+
+/* i2c7 device registeration */
+static struct resource i2c7_resources[] = {
+	{
+		.start = SPEAR1310_I2C7_BASE,
+		.end = SPEAR1310_I2C7_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_I2C7,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_i2c7_device = {
+	.name = "i2c_designware",
+	.id = 7,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c7_resources),
+	.resource = i2c7_resources,
+};
+
+/* plgpio */
+static struct plgpio_platform_data plgpio_plat_data = {
+	.gpio_base = 16,
+	.irq_base = SPEAR_PLGPIO_INT_BASE,
+	.gpio_count = SPEAR_PLGPIO_COUNT,
+	.regs = {
+		.enb = SPEAR1310_PLGPIO_ENB_OFF,
+		.wdata = SPEAR1310_PLGPIO_WDATA_OFF,
+		.dir = SPEAR1310_PLGPIO_DIR_OFF,
+		.rdata = SPEAR1310_PLGPIO_RDATA_OFF,
+		.ie = SPEAR1310_PLGPIO_IE_OFF,
+		.mis = SPEAR1310_PLGPIO_MIS_OFF,
+		.eit = SPEAR1310_PLGPIO_EIT_OFF,
+	},
+};
+
+static struct resource plgpio_resources[] = {
+	{
+		.start = SPEAR1310_RAS_BASE,
+		.end = SPEAR1310_RAS_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_PLGPIO,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_plgpio_device = {
+	.name = "plgpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &plgpio_plat_data,
+	},
+	.num_resources = ARRAY_SIZE(plgpio_resources),
+	.resource = plgpio_resources,
+};
+
+static struct tdm_hdlc_platform_data tdm_hdlc_0_plat_data = {
+	.ip_type = SPEAR1310_TDM_HDLC,
+	.nr_channel = 2,
+	.nr_timeslot = 128,
+};
+
+static struct resource tdm_hdlc_0_resources[] = {
+	{
+		.start = SPEAR1310_TDM_E1_0_BASE,
+		.end = SPEAR1310_TDM_E1_0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_TDM0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_tdm_hdlc_0_device = {
+	.name = "tdm_hdlc",
+	.id = 0,
+	.dev = {
+		.platform_data = &tdm_hdlc_0_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(tdm_hdlc_0_resources),
+	.resource = tdm_hdlc_0_resources,
+};
+
+static struct tdm_hdlc_platform_data tdm_hdlc_1_plat_data = {
+	.ip_type = SPEAR1310_TDM_HDLC,
+	.nr_channel = 2,
+	.nr_timeslot = 128,
+};
+
+static struct resource tdm_hdlc_1_resources[] = {
+	{
+		.start = SPEAR1310_TDM_E1_1_BASE,
+		.end = SPEAR1310_TDM_E1_1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_TDM1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_tdm_hdlc_1_device = {
+	.name = "tdm_hdlc",
+	.id = 1,
+	.dev = {
+		.platform_data = &tdm_hdlc_1_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(tdm_hdlc_1_resources),
+	.resource = tdm_hdlc_1_resources,
+};
+
+static struct rs485_hdlc_platform_data rs485_0_plat_data = {
+	.tx_falling_edge = 1,
+	.rx_rising_edge = 1,
+	.cts_enable = 1,
+	.cts_delay = 50,
+};
+
+static struct rs485_hdlc_platform_data rs485_1_plat_data = {
+	.tx_falling_edge = 1,
+	.rx_rising_edge = 1,
+	.cts_enable = 1,
+	.cts_delay = 50,
+};
+
+static struct resource rs485_0_resources[] = {
+	{
+		.start = SPEAR1310_RS485_0_BASE,
+		.end = SPEAR1310_RS485_0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_RS485_0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rs485_1_resources[] = {
+	{
+		.start = SPEAR1310_RS485_1_BASE,
+		.end = SPEAR1310_RS485_1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_RS485_1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_rs485_0_device = {
+	.name = "rs485_hdlc",
+	.id = 0,
+	.dev = {
+		.platform_data = &rs485_0_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(rs485_0_resources),
+	.resource = rs485_0_resources,
+};
+
+struct platform_device spear1310_rs485_1_device = {
+	.name = "rs485_hdlc",
+	.id = 1,
+	.dev = {
+		.platform_data = &rs485_1_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(rs485_1_resources),
+	.resource = rs485_1_resources,
+};
+
+/* SATA0 device registration */
+static struct resource sata0_resources[] = {
+	{
+		.start = SPEAR1310_SATA0_BASE,
+		.end = SPEAR1310_SATA0_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_SATA0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_sata0_device = {
+	.name = "ahci",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(sata0_resources),
+	.resource = sata0_resources,
+};
+
+/* SATA1 device registration */
+static struct resource sata1_resources[] = {
+	{
+		.start = SPEAR1310_SATA1_BASE,
+		.end = SPEAR1310_SATA1_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_SATA1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_sata1_device = {
+	.name = "ahci",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(sata1_resources),
+	.resource = sata1_resources,
+};
+
+/* SATA2 device registration */
+static struct resource sata2_resources[] = {
+	{
+		.start = SPEAR1310_SATA2_BASE,
+		.end = SPEAR1310_SATA2_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_SATA2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_sata2_device = {
+	.name = "ahci",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(sata2_resources),
+	.resource = sata2_resources,
+};
+
+/* OTG device registration */
+static struct resource otg_resources[] = {
+	{
+		.start = SPEAR1310_UOC_BASE,
+		.end = SPEAR1310_UOC_BASE + SZ_256K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_IRQ_UOC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_otg_device = {
+	.name = "dwc_otg",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(otg_resources),
+	.resource = otg_resources,
+};
+
+/* nand device registeration */
+void spear1310_nand_select_bank(u32 bank, u32 busw)
+{
+	u32 fsmc_cfg = readl(VA_SPEAR1310_FSMC_CFG);
+
+	fsmc_cfg &= ~(SPEAR1310_FSMC_CS_MEMSEL_MASK << (bank & 3));
+
+	writel(fsmc_cfg, VA_SPEAR1310_FSMC_CFG);
+}
+
+static struct resource nand_resources[] = {
+	{
+		.name = "nand_data",
+		.start = SPEAR1310_NAND_MEM_BASE,
+		.end = SPEAR1310_NAND_MEM_BASE + SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "fsmc_regs",
+		.start = SPEAR13XX_FSMC_BASE,
+		.end = SPEAR13XX_FSMC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear1310_nand_device = {
+	.name = "fsmc-nand",
+	.id = -1,
+	.resource = nand_resources,
+	.num_resources = ARRAY_SIZE(nand_resources),
+};
+
+static void tdm_hdlc_setup(void)
+{
+	struct clk *synth_clk, *vco_clk, *tdm0_clk, *tdm1_clk;
+	char *synth_clk_name = "ras_synth1_clk";
+	char *vco_clk_name = "vco1div4_clk";
+	int ret;
+
+	vco_clk = clk_get(NULL, vco_clk_name);
+	if (IS_ERR(vco_clk)) {
+		pr_err("Failed to get %s\n", vco_clk_name);
+		return;
+	}
+
+	synth_clk = clk_get(NULL, synth_clk_name);
+	if (IS_ERR(synth_clk)) {
+		pr_err("Failed to get %s\n", synth_clk_name);
+		goto free_vco_clk;
+	}
+
+	/* use vco1div4 source for gen_clk_synt1 */
+	ret = clk_set_parent(synth_clk, vco_clk);
+	if (ret < 0) {
+		pr_err("Failed to set parent %s to %s\n", vco_clk_name,
+				synth_clk_name);
+		goto free_synth_clk;
+	}
+
+	/* select gen_clk_synt1 as source for TDM */
+	tdm0_clk = clk_get_sys(NULL, "tdm_hdlc.0");
+	if (IS_ERR(tdm0_clk)) {
+		pr_err("Failed to get tdm 0 clock\n");
+		goto free_synth_clk;
+	}
+	/* select gen_clk_synt1 as source for TDM */
+	tdm1_clk = clk_get_sys(NULL, "tdm_hdlc.1");
+	if (IS_ERR(tdm1_clk)) {
+		pr_err("Failed to get tdm 1 clock\n");
+		goto free_tdm0_clk;
+	}
+
+	ret = clk_set_parent(tdm0_clk, synth_clk);
+	if (ret < 0) {
+		pr_err("Failed to set parent %s to tdm0 clock\n",
+				synth_clk_name);
+		goto free_tdm1_clk;
+	}
+	ret = clk_set_parent(tdm1_clk, synth_clk);
+	if (ret < 0) {
+		pr_err("Failed to set parent %s to tdm1 clock\n",
+				synth_clk_name);
+		goto free_tdm1_clk;
+	}
+
+free_tdm1_clk:
+	clk_put(tdm1_clk);
+free_tdm0_clk:
+	clk_put(tdm0_clk);
+free_synth_clk:
+	clk_put(synth_clk);
+free_vco_clk:
+	clk_put(vco_clk);
+}
+
+/* Following will create 1310 specific static virtual/physical mappings */
+static struct map_desc spear1310_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(SPEAR1310_RAS_BASE),
+		.pfn		= __phys_to_pfn(SPEAR1310_RAS_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+};
+
+/* This will create static memory mapping for selected devices */
+void __init spear1310_map_io(void)
+{
+	iotable_init(spear1310_io_desc,
+			ARRAY_SIZE(spear1310_io_desc));
+	spear13xx_map_io();
+}
+
+void __init spear1310_init(struct pmx_mode *pmx_mode,
+		struct pmx_dev **pmx_devs, u8 pmx_dev_count)
+{
+	int ret;
+
+	/* call spear13xx family common init function */
+	spear13xx_init();
+
+	tdm_hdlc_setup();
+
+	/* pmx initialization */
+	pmx_driver.mode = pmx_mode;
+	pmx_driver.devs = pmx_devs;
+	pmx_driver.devs_count = pmx_dev_count;
+
+	ret = pmx_register(&pmx_driver);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
diff --git a/arch/arm/mach-spear13xx/spear1310_clock.c b/arch/arm/mach-spear13xx/spear1310_clock.c
new file mode 100644
index 0000000..a8af3f3
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1310_clock.c
@@ -0,0 +1,1899 @@
+/*
+ * arch/arm/mach-spear13xx/spear1310_clock.c
+ *
+ * SPEAr1310 machines clock framework source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <plat/clock.h>
+#include <mach/hardware.h>
+#include <mach/spear1310_misc_regs.h>
+
+/* root clks */
+/* 24 MHz oscillator clock */
+static struct clk osc1_24m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 24000000,
+};
+
+/* 32 KHz oscillator clock */
+static struct clk osc2_32k_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 32000,
+};
+
+/* 25 MHz MIPHY oscillator clock */
+static struct clk osc3_25m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 25000000,
+};
+
+/* clock derived from 32 KHz osc clk */
+/* rtc clock */
+static struct clk rtc_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_RTC_CLK_ENB,
+	.recalc = &follow_parent,
+	.pclk = &osc2_32k_clk,
+};
+
+/* clock derived from osc1 or osc3 */
+/* vco[1-3] parents */
+static struct pclk_info vco_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1310_OSC_24M_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = SPEAR1310_OSC_25M_VAL,
+	},
+};
+
+/* vco[1-3] parent select structure */
+static struct pclk_sel vco_pclk_sel = {
+	.pclk_info = vco_pclk_info,
+	.pclk_count = ARRAY_SIZE(vco_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PLL_CFG,
+	.pclk_sel_mask = SPEAR1310_PLL_CLK_MASK,
+};
+
+/* vco masks structure */
+static struct vco_clk_masks vco_masks = {
+	.mode_mask = SPEAR1310_PLL_MODE_MASK,
+	.mode_shift = SPEAR1310_PLL_MODE_SHIFT,
+	.norm_fdbk_m_mask = SPEAR1310_PLL_NORM_FDBK_M_MASK,
+	.norm_fdbk_m_shift = SPEAR1310_PLL_NORM_FDBK_M_SHIFT,
+	.dith_fdbk_m_mask = SPEAR1310_PLL_DITH_FDBK_M_MASK,
+	.dith_fdbk_m_shift = SPEAR1310_PLL_DITH_FDBK_M_SHIFT,
+	.div_p_mask = SPEAR1310_PLL_DIV_P_MASK,
+	.div_p_shift = SPEAR1310_PLL_DIV_P_SHIFT,
+	.div_n_mask = SPEAR1310_PLL_DIV_N_MASK,
+	.div_n_shift = SPEAR1310_PLL_DIV_N_SHIFT,
+	.pll_lock_mask = SPEAR1310_PLL_LOCK_MASK,
+	.pll_lock_shift = SPEAR1310_PLL_LOCK_SHIFT,
+};
+/* vco1 configuration structure */
+static struct vco_clk_config vco1_config = {
+	.mode_reg = VA_SPEAR1310_PLL1_CTR,
+	.cfg_reg = VA_SPEAR1310_PLL1_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco_rtbl[] = {
+	/* PCLK 24MHz */
+	{.mode = 0, .m = 0x83, .n = 0x04, .p = 0x5}, /* vco 1572, pll 49.125 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x3}, /* vco 1000, pll 125 MHz */
+	{.mode = 0, .m = 0x64, .n = 0x06, .p = 0x1}, /* vco 800, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x1}, /* vco 1000, pll 500 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x1}, /* vco 1328, pll 664 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x1}, /* vco 1600, pll 800 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+};
+
+/* vco1 clock */
+static struct clk vco1_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.en_reg = VA_SPEAR1310_PLL1_CTR,
+	.en_reg_bit = SPEAR1310_PLL_ENABLE,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_PLL1_CLK_SHIFT,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco1_config,
+};
+
+/* thermal clock */
+static struct clk thermal_clk = {
+	.en_reg = VA_SPEAR1310_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1310_THSENS_CLK_ENB,
+	.pclk = &osc1_24m_clk,
+	.div_factor = 128,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from vco1 clock */
+/* pll1 clock */
+static struct clk pll1_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco1div2 clock */
+static struct clk vco1div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco1div4 clock */
+static struct clk vco1div4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 4,
+	.recalc = &follow_parent,
+};
+
+/* vco2 configuration structure */
+static struct vco_clk_config vco2_config = {
+	.mode_reg = VA_SPEAR1310_PLL2_CTR,
+	.cfg_reg = VA_SPEAR1310_PLL2_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco2 clock */
+static struct clk vco2_clk = {
+	.flags = SYSTEM_CLK,
+	.en_reg = VA_SPEAR1310_PLL2_CTR,
+	.en_reg_bit = SPEAR1310_PLL_ENABLE,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_PLL2_CLK_SHIFT,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco2_config,
+};
+
+/* clock derived from vco2 clock */
+/* pll2 clock */
+static struct clk pll2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco2div2 clock */
+static struct clk vco2div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco3 configuration structure */
+static struct vco_clk_config vco3_config = {
+	.mode_reg = VA_SPEAR1310_PLL3_CTR,
+	.cfg_reg = VA_SPEAR1310_PLL3_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco3 clock */
+static struct clk vco3_clk = {
+	.flags = SYSTEM_CLK,
+	.en_reg = VA_SPEAR1310_PLL3_CTR,
+	.en_reg_bit = SPEAR1310_PLL_ENABLE,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_PLL3_CLK_SHIFT,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 0},
+	.private_data = &vco3_config,
+};
+
+/* clock derived from vco3 clock */
+/* pll3 clock */
+static struct clk pll3_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco3div2 clock */
+static struct clk vco3div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco4 (DDR) configuration structure */
+static struct vco_clk_config vco4_config = {
+	.mode_reg = VA_SPEAR1310_PLL4_CTR,
+	.cfg_reg = VA_SPEAR1310_PLL4_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco4 rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco4_rtbl[] = {
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x2}, /* vco 1000, pll 250 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x2}, /* vco 1328, pll 332 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x2}, /* vco 1600, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+};
+
+/* vco4 (DDR) clock */
+static struct clk vco4_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.en_reg = VA_SPEAR1310_PLL4_CTR,
+	.en_reg_bit = SPEAR1310_PLL_ENABLE,
+	.pclk = &osc1_24m_clk,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco4_rtbl, ARRAY_SIZE(vco4_rtbl), 3},
+	.private_data = &vco4_config,
+};
+
+/* clock derived from vco4 clock */
+/* pll4 clock */
+static struct clk pll4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco4_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* pll5 USB 48 MHz clock */
+static struct clk pll5_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc1_24m_clk,
+	.rate = 48000000,
+};
+
+/* pll6 (MIPHY) clock */
+static struct clk pll6_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc3_25m_clk,
+	.rate = 25000000,
+};
+
+/* clocks derived from pll1 clk */
+/* ddr clock */
+static struct ddr_rate_tbl ddr_rate_tbl = {
+	.minrate = 332000000,
+	.maxrate = 500000000,
+};
+
+static struct clk ddr_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll4_clk,
+	.recalc = &follow_parent,
+	.private_data = &ddr_rate_tbl,
+};
+
+/* cpu clock */
+static struct clk cpu_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* ahb clock */
+static struct clk ahb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 6,
+	.recalc = &follow_parent,
+};
+
+/* apb clock */
+static struct clk apb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll1_clk,
+	.div_factor = 12,
+	.recalc = &follow_parent,
+};
+
+/* clocks derived from osc1, ahb or apb */
+/* gpt[0-3] parents */
+static struct pclk_info gpt_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1310_GPT_OSC24_VAL,
+	}, {
+		.pclk = &apb_clk,
+		.pclk_val = SPEAR1310_GPT_APB_VAL,
+	},
+};
+
+/* gpt[0-3] parent select structure */
+static struct pclk_sel gpt_pclk_sel = {
+	.pclk_info = gpt_pclk_info,
+	.pclk_count = ARRAY_SIZE(gpt_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_GPT_CLK_MASK,
+};
+
+/* gpt0 timer clock */
+static struct clk gpt0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPT0_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GPT0_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt1 timer clock */
+static struct clk gpt1_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPT1_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GPT1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt2 timer clock */
+static struct clk gpt2_clk = {
+	.en_reg = VA_SPEAR1310_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPT2_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GPT2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt3 timer clock */
+static struct clk gpt3_clk = {
+	.en_reg = VA_SPEAR1310_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPT3_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GPT3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* watch dog timer clock */
+static struct clk wdt_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &cpu_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* auxiliary synthesizers masks */
+static struct aux_clk_masks aux_masks = {
+	.eq_sel_mask = SPEAR1310_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1310_AUX_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1310_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1310_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1310_AUX_XSCALE_MASK,
+	.xscale_sel_shift = SPEAR1310_AUX_XSCALE_SHIFT,
+	.yscale_sel_mask = SPEAR1310_AUX_YSCALE_MASK,
+	.yscale_sel_shift = SPEAR1310_AUX_YSCALE_SHIFT,
+};
+
+/* clocks derived multiple parents (pll1, pll5, synthesizers or others) */
+/* uart configurations */
+static struct aux_clk_config uart_synth_config = {
+	.synth_reg = VA_SPEAR1310_UART_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl aux_rtbl[] = {
+	/* For VCO1div2 = 500 MHz */
+	{.xscale = 10, .yscale = 204, .eq = 0}, /* 12.29 MHz */
+	{.xscale = 4, .yscale = 21, .eq = 0}, /* 48 MHz */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* 83 MHz */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* 125 MHz */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* 166 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* 250 MHz */
+};
+
+/* uart synth clock */
+static struct clk uart_synth_clk = {
+	.en_reg = VA_SPEAR1310_UART_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &uart_synth_config,
+};
+
+/* uart parents */
+static struct pclk_info uart_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &uart_synth_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* uart parent select structure */
+static struct pclk_sel uart_pclk_sel = {
+	.pclk_info = uart_pclk_info,
+	.pclk_count = ARRAY_SIZE(uart_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_UART_CLK_MASK,
+};
+
+/* uart clock */
+static struct clk uart_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_UART_CLK_ENB,
+	.pclk_sel = &uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* sdhci configurations */
+static struct aux_clk_config sdhci_synth_config = {
+	.synth_reg = VA_SPEAR1310_SDHCI_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* sdhci synth clock */
+static struct clk sdhci_synth_clk = {
+	.en_reg = VA_SPEAR1310_SDHCI_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 1},
+	.private_data = &sdhci_synth_config,
+};
+
+/* sdhci clock */
+static struct clk sdhci_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_SDHCI_CLK_ENB,
+	.pclk = &sdhci_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* cfxd configurations */
+static struct aux_clk_config cfxd_synth_config = {
+	.synth_reg = VA_SPEAR1310_CFXD_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* cfxd synth clock */
+static struct clk cfxd_synth_clk = {
+	.en_reg = VA_SPEAR1310_CFXD_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 4},
+	.private_data = &cfxd_synth_config,
+};
+
+/* cfxd clock */
+static struct clk cfxd_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_CFXD_CLK_ENB,
+	.pclk = &cfxd_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* C3 clk configurations */
+static struct aux_clk_config c3_synth_config = {
+	.synth_reg = VA_SPEAR1310_C3_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* c3 synth clock */
+static struct clk c3_synth_clk = {
+	.en_reg = VA_SPEAR1310_C3_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &c3_synth_config,
+};
+
+/* c3 parents */
+static struct pclk_info c3_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &c3_synth_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* c3 parent select structure */
+static struct pclk_sel c3_pclk_sel = {
+	.pclk_info = c3_pclk_info,
+	.pclk_count = ARRAY_SIZE(c3_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_C3_CLK_MASK,
+};
+
+/* c3 clock */
+static struct clk c3_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_C3_CLK_ENB,
+	.pclk_sel = &c3_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_C3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac phy clk configurations */
+static struct aux_clk_config gmac_phy_synth_config = {
+	.synth_reg = VA_SPEAR1310_GMAC_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* gmii external pad clock for phy operation */
+static struct clk gmii_125m_pad = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 125000000,
+};
+
+/* gmac phy set of input clks*/
+static struct pclk_info gmac_phy_input_pclk_info[] = {
+	{
+		.pclk = &gmii_125m_pad,
+		.pclk_val = SPEAR1310_GMAC_PHY_125M_PAD_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1310_GMAC_PHY_PLL2_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = SPEAR1310_GMAC_PHY_OSC3_VAL,
+	},
+};
+
+static struct pclk_sel gmac_phy_input_pclk_sel = {
+	.pclk_info = gmac_phy_input_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_input_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_GMAC_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_GMAC_PHY_INPUT_CLK_MASK,
+};
+
+static struct clk gmac_phy_input_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_input_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GMAC_PHY_INPUT_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl gmac_rtbl[] = {
+	/* For gmac phy input clk */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* divided by 6 */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* divided by 4 */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* divided by 3 */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* divided by 2 */
+};
+
+static struct clk gmac_phy_synth_clk = {
+	.en_reg = VA_SPEAR1310_GMAC_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &gmac_phy_input_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {gmac_rtbl, ARRAY_SIZE(gmac_rtbl), 0},
+	.private_data = &gmac_phy_synth_config,
+};
+
+/* gmac phy parents */
+static struct pclk_info gmac_phy_pclk_info[] = {
+	{
+		.pclk = &gmac_phy_input_clk,
+		.pclk_val = SPEAR1310_GMAC_PHY_INPUT_ENB_VAL,
+	}, {
+		.pclk = &gmac_phy_synth_clk,
+		.pclk_val = SPEAR1310_GMAC_PHY_SYNT_ENB_VAL,
+	}
+};
+
+/* gmac phy parent select structure */
+static struct pclk_sel gmac_phy_pclk_sel = {
+	.pclk_info = gmac_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_GMAC_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_GMAC_PHY_CLK_MASK,
+};
+
+/* gmac phy clock */
+static struct clk gmac_phy0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_GMAC_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* clcd fractional synthesizers masks */
+static struct frac_synth_masks clcd_masks = {
+	.div_factor_mask = SPEAR1310_FRAC_SYNT_DIV_FACTOR_MASK,
+	.div_factor_shift = SPEAR1310_FRAC_SYNT_DIV_FACTOR_SHIFT,
+};
+
+static struct frac_synth_clk_config clcd_synth_config = {
+	.synth_reg = VA_SPEAR1310_CLCD_CLK_SYNT,
+	.masks = &clcd_masks,
+};
+
+/* clcd fractional synthesizer parents */
+static struct pclk_info clcd_synth_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1310_CLCD_SYNT_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1310_CLCD_SYNT_PLL2_VAL,
+	},
+};
+
+/* clcd fractional synthesizer parent select structure */
+static struct pclk_sel clcd_synth_pclk_sel = {
+	.pclk_info = clcd_synth_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_synth_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PLL_CFG,
+	.pclk_sel_mask = SPEAR1310_CLCD_SYNT_CLK_MASK,
+};
+
+/* clcd rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl clcd_rtbl[] = {
+	{.div = 0x14000}, /* 25 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x1284B}, /* 27 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0D8D3}, /* 58 Mhz , for vco1div4 = 393 MHz */
+	{.div = 0x0B72C}, /* 58 Mhz , for vco1div4 = 332 MHz */
+	{.div = 0x089EE}, /* 58 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06f1C}, /* 72 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06E58}, /* 58 Mhz , for vco1div4 = 200 MHz */
+	{.div = 0x06c1B}, /* 74 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x04A12}, /* 108 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0378E}, /* 144 Mhz , for vc01div4 = 250 MHz*/
+	/*
+	 * TODO : 1080p should work on 148 Mhz. But we see lots of
+	 * flickering at 148 Mhz.So, commenting this entry till we
+	 * resolve this issue
+	 */
+	/* {.div = 0x0360D}, */ /* 148 Mhz , for vc01div4 = 250 MHz*/
+};
+
+/* clcd fractional synthesizer clock */
+static struct clk clcd_synth_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &clcd_synth_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_CLCD_SYNT_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {clcd_rtbl, ARRAY_SIZE(clcd_rtbl), 2},
+	.private_data = &clcd_synth_config,
+};
+
+/*
+ * clcd clock parents
+ * This would select to use pll5_clk or clcd_synth_clk as a parent clock
+ * of clcd (called as pixel clock in CLCD documentation).
+ * For selection of any of these two parent, check the combination of
+ * 3-2 bit of clcdclk_sel misc register
+ */
+static struct pclk_info clcd_pixel_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &clcd_synth_clk,
+		.pclk_val = SPEAR1310_AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* clcd parent select structure */
+static struct pclk_sel clcd_pixel_pclk_sel = {
+	.pclk_info = clcd_pixel_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pixel_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_CLCD_CLK_MASK,
+};
+
+static struct clk clcd_pixel_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &clcd_pixel_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_CLCD_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/*
+ * clcd clock
+ * There are 2 options for clcd clock,
+ *  - derived from AHB (bus clk)
+ *  - dervied from Pixel Clock Input (pixel clk)
+ * The selection bit for these clock is in device itself, hence treating
+ * them as virtual clocks without selection register.
+ * Controller driver on itself needs to program proper selection
+ */
+
+static struct pclk_info clcd_pclk_info[] = {
+	{
+		.pclk = &clcd_pixel_clk,
+	}, {
+		.pclk = &ahb_clk,
+	},
+};
+
+static struct pclk_sel clcd_pclk_sel = {
+	.pclk_info = clcd_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pclk_info),
+	.pclk_sel_reg = 0, /* no select register SPEAR1310_*/
+};
+
+/* clcd clock */
+static struct clk clcd_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_CLCD_CLK_ENB,
+	.pclk_sel = &clcd_pclk_sel,
+	.recalc = &follow_parent,
+};
+
+/* i2s related clocks */
+/* i2s source clock parents */
+static struct clk i2s_src_pad_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 12288000,
+};
+
+static struct pclk_info i2s_src_pclk_info[] = {
+	{
+		.pclk = &vco1div2_clk,
+		.pclk_val = SPEAR1310_I2S_SRC_VCO1DIV2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = SPEAR1310_I2S_SRC_PLL3_VAL,
+	}, {
+		.pclk = &i2s_src_pad_clk,
+		.pclk_val = SPEAR1310_I2S_SRC_PL_CLK0_VAL,
+	},
+};
+
+static struct pclk_sel i2s_src_pclk_sel = {
+	.pclk_info = i2s_src_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_src_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_I2S_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_I2S_SRC_CLK_MASK,
+};
+
+/* i2s src clock */
+static struct clk i2s_src_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_src_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2S_SRC_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s prescaler1 masks */
+static struct aux_clk_masks i2s_prs1_aux_masks = {
+	.eq_sel_mask = SPEAR1310_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1310_I2S_PRS1_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1310_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1310_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1310_I2S_PRS1_CLK_X_MASK,
+	.xscale_sel_shift = SPEAR1310_I2S_PRS1_CLK_X_SHIFT,
+	.yscale_sel_mask = SPEAR1310_I2S_PRS1_CLK_Y_MASK,
+	.yscale_sel_shift = SPEAR1310_I2S_PRS1_CLK_Y_SHIFT,
+};
+
+/* i2s prs1 clk configurations */
+static struct aux_clk_config i2s_prs1_config = {
+	.synth_reg = VA_SPEAR1310_I2S_CLK_CFG,
+	.masks = &i2s_prs1_aux_masks,
+};
+
+/* i2s prs1 aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_prs1_aux_rtbl[] = {
+	/* For parent clk = 49.152 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 0}, /* 12.288 MHz */
+};
+
+/* i2s prs1 clock */
+static struct clk i2s_prs1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &i2s_src_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_prs1_aux_rtbl, ARRAY_SIZE(i2s_prs1_aux_rtbl), 0},
+	.private_data = &i2s_prs1_config,
+};
+
+/* i2s ref clk configuration */
+static struct pclk_info i2s_ref_pclk_info[] = {
+	{
+		.pclk = &i2s_src_clk,
+		.pclk_val = SPEAR1310_I2S_REF_SRC_VAL,
+	}, {
+		.pclk = &i2s_prs1_clk,
+		.pclk_val = SPEAR1310_I2S_REF_PRS1_VAL,
+	},
+};
+
+/* i2s ref clock parent select structure */
+static struct pclk_sel i2s_ref_pclk_sel = {
+	.pclk_info = i2s_ref_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_ref_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_I2S_CLK_CFG,
+	.pclk_sel_mask = SPEAR1310_I2S_REF_SEL_MASK,
+};
+
+/* i2s ref clock */
+static struct clk i2s_ref_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_ref_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2S_REF_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s ref pad clock: for codec */
+static struct clk i2s_ref_pad_clk = {
+	.en_reg = VA_SPEAR1310_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1310_I2S_REF_PAD_CLK_ENB,
+	.pclk = &i2s_ref_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s sclk aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_sclk_aux_rtbl[] = {
+	/* For i2s_ref_clk = 12.288MHz */
+	{.xscale = 1, .yscale = 4, .eq = 0}, /* 1.53 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 0}, /* 3.07 Mhz */
+};
+
+/* i2s sclk (bit clock) syynthesizers masks */
+static struct aux_clk_masks i2s_sclk_aux_masks = {
+	.eq_sel_mask = SPEAR1310_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1310_I2S_SCLK_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1310_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1310_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1310_I2S_SCLK_X_MASK,
+	.xscale_sel_shift = SPEAR1310_I2S_SCLK_X_SHIFT,
+	.yscale_sel_mask = SPEAR1310_I2S_SCLK_Y_MASK,
+	.yscale_sel_shift = SPEAR1310_I2S_SCLK_Y_SHIFT,
+};
+
+/* i2s sclk synth configurations */
+static struct aux_clk_config i2s_sclk_synth_config = {
+	.synth_reg = VA_SPEAR1310_I2S_CLK_CFG,
+	.masks = &i2s_sclk_aux_masks,
+};
+
+/* i2s sclk (bit clock) */
+static struct clk i2s_sclk_clk = {
+	.en_reg = VA_SPEAR1310_I2S_CLK_CFG,
+	.en_reg_bit = SPEAR1310_I2S_SCLK_SYNTH_ENB,
+	.pclk = &i2s_ref_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_sclk_aux_rtbl, ARRAY_SIZE(i2s_sclk_aux_rtbl), 0},
+	.private_data = &i2s_sclk_synth_config,
+};
+
+/* clock derived from ahb clk */
+
+/* i2c clock */
+static struct clk i2c_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_I2C0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* dma clock */
+static struct clk dma_pclk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_DMA_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+/* jpeg clock */
+static struct clk jpeg_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_JPEG_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gmac clock :Fixed Part*/
+static struct clk gmac0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GMAC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc clock */
+static struct clk fsmc_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_FSMC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nand clock */
+static struct clk fsmc_nand_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nor clock */
+static struct clk fsmc_nor_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* smi clock */
+static struct clk smi_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_SMI_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uhc0 clock */
+static struct clk uhci0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_UHC0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uhc1 clock */
+static struct clk uhci1_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_UHC1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uoc clock */
+static struct clk uoc_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_UOC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* pcie-sata parent clocks */
+static struct clk pcie_sata_0_pclk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PCIE_SATA_0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie_sata_1_pclk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PCIE_SATA_1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie_sata_2_pclk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PCIE_SATA_2_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* pcie clocks */
+static struct clk pcie0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_0_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_1_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk pcie2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_2_pclk,
+	.recalc = &follow_parent,
+};
+
+/* sata clocks */
+static struct clk sata0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_0_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk sata1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_1_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk sata2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_2_pclk,
+	.recalc = &follow_parent,
+};
+
+/* sysram clocks */
+static struct clk sysram0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_SYSRAM0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk sysram1_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_SYSRAM1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* adc configurations */
+static struct aux_clk_config adc_synth_config = {
+	.synth_reg = VA_SPEAR1310_ADC_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* adc rate configuration table, in ascending order of rates */
+/* possible adc range is 2.5 MHz to 20 MHz. */
+static struct aux_rate_tbl adc_rtbl[] = {
+	/* For ahb = 166.67 MHz */
+	{.xscale = 1, .yscale = 31, .eq = 0}, /* 2.68 MHz */
+	{.xscale = 2, .yscale = 21, .eq = 0}, /* 7.94 MHz */
+	{.xscale = 4, .yscale = 21, .eq = 0}, /* 15.87 MHz */
+	{.xscale = 10, .yscale = 42, .eq = 0}, /* 19.84 MHz */
+};
+
+/* adc synth clock */
+static struct clk adc_synth_clk = {
+	.en_reg = VA_SPEAR1310_ADC_CLK_SYNT,
+	.en_reg_bit = SPEAR1310_AUX_SYNT_ENB,
+	.pclk = &ahb_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {adc_rtbl, ARRAY_SIZE(adc_rtbl), 0},
+	.private_data = &adc_synth_config,
+};
+
+/* adc clock */
+static struct clk adc_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_ADC_CLK_ENB,
+	.pclk = &adc_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from apb clk */
+/* ssp clock */
+static struct clk ssp_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_SSP_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPIO0_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio1_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_GPIO1_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s0 clock */
+static struct clk i2s0_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_I2S0_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s1 clock */
+static struct clk i2s1_clk = {
+	.en_reg = VA_SPEAR1310_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1310_I2S1_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* keyboard clock */
+static struct clk kbd_clk = {
+	.en_reg = VA_SPEAR1310_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1310_KBD_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* RAS fractional synthesizers masks */
+static struct frac_synth_masks ras_synth_masks = {
+	.div_factor_mask = SPEAR1310_FRAC_SYNT_DIV_FACTOR_MASK,
+	.div_factor_shift = SPEAR1310_FRAC_SYNT_DIV_FACTOR_SHIFT,
+};
+
+static struct frac_synth_clk_config ras_synth0_config = {
+	.synth_reg = VA_SPEAR1310_RAS_CLK_SYNT0,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth1_config = {
+	.synth_reg = VA_SPEAR1310_RAS_CLK_SYNT1,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth2_config = {
+	.synth_reg = VA_SPEAR1310_RAS_CLK_SYNT2,
+	.masks = &ras_synth_masks,
+};
+
+static struct frac_synth_clk_config ras_synth3_config = {
+	.synth_reg = VA_SPEAR1310_RAS_CLK_SYNT3,
+	.masks = &ras_synth_masks,
+};
+
+/* RAS Fractional Synthesizer parents */
+static struct pclk_info ras_synth0_1_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT0_1_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco3div2_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT0_1_VCO3_DIV2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT0_1_PLL3_VAL,
+	},
+};
+
+/* RAS Fractional Synthesizer-0 and 1 parent select structure */
+static struct pclk_sel ras_synth0_1_pclk_sel = {
+	.pclk_info = ras_synth0_1_pclk_info,
+	.pclk_count = ARRAY_SIZE(ras_synth0_1_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PLL_CFG,
+	.pclk_sel_mask = SPEAR1310_RAS_SYNT0_1_CLK_MASK,
+};
+
+static struct pclk_info ras_synth2_3_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT2_3_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco2div2_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT2_3_VCO2_DIV2_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1310_RAS_SYNT2_3_PLL2_VAL,
+	},
+};
+
+/* RAS Fractional Synthesizer-2 and 3 parent select structure */
+static struct pclk_sel ras_synth2_3_pclk_sel = {
+	.pclk_info = ras_synth2_3_pclk_info,
+	.pclk_count = ARRAY_SIZE(ras_synth2_3_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1310_PLL_CFG,
+	.pclk_sel_mask = SPEAR1310_RAS_SYNT2_3_CLK_MASK,
+};
+
+/* RAS rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl ras_rtbl[] = {
+	/* For vco1div4 = 250 MHz */
+	{.div = 0x14000}, /* 25 MHz */
+	{.div = 0x0A000}, /* 50 MHz */
+	{.div = 0x05000}, /* 100 MHz */
+	{.div = 0x02000}, /* 250 MHz */
+};
+
+/* RAS Fractional Synthesizer-0 Clock */
+static struct clk ras_synth0_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_SYNT0,
+	.en_reg_bit = SPEAR1310_FRAC_SYNT_ENB,
+	.pclk_sel = &ras_synth0_1_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_RAS_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth0_config,
+};
+
+/* RAS Fractional Synthesizer1 Clock */
+static struct clk ras_synth1_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_SYNT1,
+	.en_reg_bit = SPEAR1310_FRAC_SYNT_ENB,
+	.pclk_sel = &ras_synth0_1_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_RAS_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth1_config,
+};
+
+/* RAS Fractional Synthesizer2 Clock */
+static struct clk ras_synth2_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_SYNT2,
+	.en_reg_bit = SPEAR1310_FRAC_SYNT_ENB,
+	.pclk_sel = &ras_synth2_3_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_RAS_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth2_config,
+};
+
+/* RAS Fractional Synthesizer3 Clock */
+static struct clk ras_synth3_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_SYNT3,
+	.en_reg_bit = SPEAR1310_FRAC_SYNT_ENB,
+	.pclk_sel = &ras_synth2_3_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_RAS_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {ras_rtbl, ARRAY_SIZE(ras_rtbl), 1},
+	.private_data = &ras_synth3_config,
+};
+
+/* pll2 generated clock */
+static struct clk ras_pll2_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PLL2_CLK_ENB,
+	.pclk = &pll2_clk,
+	.recalc = &follow_parent,
+};
+
+/* pll3 generated clock */
+static struct clk ras_pll3_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PLL3_CLK_ENB,
+	.pclk = &pll3_clk,
+	.recalc = &follow_parent,
+};
+
+/* 125MHz clock generated on Tx pad */
+static struct clk ras_tx125_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_C125M_PAD_CLK_ENB,
+	.pclk = &gmii_125m_pad,
+	.recalc = &follow_parent,
+};
+
+/* 30 MHz clock generated by USB PHy Pll */
+static struct clk ras_30Mhz_clk = {
+	.rate = 30000000,
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_C30M_CLK_ENB,
+};
+
+/* 48 MHz clock generated by USB PHy Pll */
+static struct clk ras_48Mhz_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_C48M_CLK_ENB,
+	.pclk = &pll5_clk,
+	.recalc = &follow_parent,
+};
+
+/* osc3 generated clock */
+static struct clk ras_osc3_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_OSC3_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* osc2 generated clock */
+static struct clk ras_osc2_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_OSC2_CLK_ENB,
+	.pclk = &osc2_32k_clk,
+	.recalc = &follow_parent,
+};
+
+/* osc1 generated clock */
+static struct clk ras_osc1_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_OSC1_CLK_ENB,
+	.pclk = &osc1_24m_clk,
+	.recalc = &follow_parent,
+};
+
+/* apb generated clock */
+static struct clk ras_pclk_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_PCLK_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* ahb generated clock */
+static struct clk ras_aclk_clk = {
+	.en_reg = VA_SPEAR1310_RAS_CLK_ENB,
+	.en_reg_bit = SPEAR1310_ACLK_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* ras pad clocks: rates are not fixed, should be updated when used */
+static struct clk ras_plclk0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 50000000,
+};
+
+/* External pad 50 MHz clock for phy operation */
+static struct clk ras_tx50_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 50000000,
+};
+
+/* can0 clock */
+static struct clk can0_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_CAN0_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* can1 clock */
+static struct clk can1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_CAN1_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk smii_ras0_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_MII0_CLK_ENB,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk smii_ras1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_MII1_CLK_ENB,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk smii_ras2_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_MII2_CLK_ENB,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk rgmii_ras_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_GMII_CLK_ENB,
+	.pclk = &ras_aclk_clk,
+	.recalc = &follow_parent,
+};
+
+/* phy clock parent select */
+static struct pclk_info rmii_phy_pclk_info[] = {
+	{
+		.pclk = &ras_tx50_clk,
+		.pclk_val = SPEAR1310_RAS_TX50M_VAL,
+	}, {
+		.pclk = &ras_pll2_clk,
+		.pclk_val = SPEAR1310_RAS_PLL2_VAL,
+	}, {
+		.pclk = &ras_synth0_clk,
+		.pclk_val = SPEAR1310_RAS_SYNTH0_VAL,
+	},
+};
+
+static struct pclk_info smii_rgmii_phy_pclk_info[] = {
+	{
+		.pclk = &ras_tx125_clk,
+		.pclk_val = SPEAR1310_RAS_TX125M_PAD_VAL,
+	}, {
+		.pclk = &ras_pll2_clk,
+		.pclk_val = SPEAR1310_RAS_PLL2_VAL,
+	}, {
+		.pclk = &ras_synth0_clk,
+		.pclk_val = SPEAR1310_RAS_SYNTH0_VAL,
+	},
+};
+
+/* RMII interface is driven by 50 MHz clock source */
+static struct pclk_sel phy_rmii_pclk_sel = {
+	.pclk_info = rmii_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(rmii_phy_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG1)),
+	.pclk_sel_mask = SPEAR1310_PHY_CLK_MASK,
+};
+
+/* SMII and RGMII are both driven by 125 MHz clock source */
+static struct pclk_sel phy_smii_rgmii_pclk_sel = {
+	.pclk_info = smii_rgmii_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(smii_rgmii_phy_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG1)),
+	.pclk_sel_mask = SPEAR1310_PHY_CLK_MASK,
+};
+
+/* Phy 1 Clock */
+static struct clk gmac_phy1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 2 Clock */
+static struct clk gmac_phy2_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 3 Clock */
+static struct clk gmac_phy3_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_rmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_RMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* Phy 4 Clock */
+static struct clk gmac_phy4_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &phy_smii_rgmii_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_SMII_RGMII_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart 1-5 parents */
+static struct pclk_info ras_uart_pclk_info[] = {
+	{
+		.pclk = &ras_pclk_clk,
+		.pclk_val = SPEAR1310_UART_CLK_PCLK_VAL,
+	}, {
+		.pclk = &ras_synth3_clk,
+		.pclk_val = SPEAR1310_UART_CLK_RAS_CLK_SYNT3,
+	},
+};
+
+/* uart parent select structure */
+static struct pclk_sel ras_uart_pclk_sel = {
+	.pclk_info = ras_uart_pclk_info,
+	.pclk_count = ARRAY_SIZE(ras_uart_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG0)),
+	.pclk_sel_mask = SPEAR1310_RAS_UART_CLK_MASK,
+};
+
+/* uart1 clock */
+static struct clk uart1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_UART1_CLK_ENB,
+	.pclk_sel = &ras_uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart2 clock */
+static struct clk uart2_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_UART2_CLK_ENB,
+	.pclk_sel = &ras_uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart3 clock */
+static struct clk uart3_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_UART3_CLK_ENB,
+	.pclk_sel = &ras_uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart4 clock */
+static struct clk uart4_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_UART4_CLK_ENB,
+	.pclk_sel = &ras_uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART4_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart5 clock */
+static struct clk uart5_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_UART5_CLK_ENB,
+	.pclk_sel = &ras_uart_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_UART5_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c 1-7 parents */
+static struct pclk_info i2c_pclk_info[] = {
+	{
+		.pclk = &ras_pclk_clk,
+		.pclk_val = SPEAR1310_I2C_CLK_PCLK_VAL,
+	}, {
+		.pclk = &ras_synth1_clk,
+		.pclk_val = SPEAR1310_I2C_CLK_RAS_SYNT1_VAL,
+	},
+};
+
+/* i2c parent select structure */
+static struct pclk_sel i2c_pclk_sel = {
+	.pclk_info = i2c_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2c_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG0)),
+	.pclk_sel_mask = SPEAR1310_I2C_CLK_MASK,
+};
+
+/* i2c1 clock */
+static struct clk i2c1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C1_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c2 clock */
+static struct clk i2c2_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C2_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c3 clock */
+static struct clk i2c3_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C3_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c4 clock */
+static struct clk i2c4_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C4_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C4_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c5 clock */
+static struct clk i2c5_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C5_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C5_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c6 clock */
+static struct clk i2c6_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C6_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C6_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2c7 clock */
+static struct clk i2c7_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_I2C7_CLK_ENB,
+	.pclk_sel = &i2c_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_I2C7_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* pci parents */
+static struct pclk_info pci_pclk_info[] = {
+	{
+		.pclk = &ras_pll3_clk,
+		.pclk_val = SPEAR1310_PCI_CLK_PLL3_VAL,
+	}, {
+		.pclk = &ras_synth2_clk,
+		.pclk_val = SPEAR1310_PCI_CLK_RAS_SYNT2_VAL,
+	},
+};
+
+/* pci parent select structure */
+static struct pclk_sel pci_pclk_sel = {
+	.pclk_info = pci_pclk_info,
+	.pclk_count = ARRAY_SIZE(pci_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG0)),
+	.pclk_sel_mask = SPEAR1310_PCI_CLK_MASK,
+};
+
+/* pci clock */
+static struct clk pci_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_PCI_CLK_ENB,
+	.pclk_sel = &pci_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_PCI_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* ssp1 parents */
+static struct pclk_info ssp1_pclk_info[] = {
+	{
+		.pclk = &ras_pclk_clk,
+		.pclk_val = SPEAR1310_SSP1_CLK_PCLK_VAL,
+	}, {
+		.pclk = &ras_synth1_clk,
+		.pclk_val = SPEAR1310_SSP1_CLK_RAS_SYNT1_VAL,
+	}, {
+		.pclk = &ras_plclk0_clk,
+		.pclk_val = SPEAR1310_SSP1_CLK_RAS_PLCLK0_VAL,
+	},
+};
+
+/* ssp1 parent select structure */
+static struct pclk_sel ssp1_pclk_sel = {
+	.pclk_info = ssp1_pclk_info,
+	.pclk_count = ARRAY_SIZE(ssp1_pclk_info),
+	.pclk_sel_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG0)),
+	.pclk_sel_mask = SPEAR1310_SSP1_CLK_MASK,
+};
+
+/* ssp1 clock */
+static struct clk ssp1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_SSP1_CLK_ENB,
+	.pclk_sel = &ssp1_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_SSP1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* tdm_hdlc clock */
+static struct pclk_info tdm_pclk_info[] = {
+	{
+		.pclk = &ras_pll3_clk,
+		.pclk_val = SPEAR1310_TDM_CLK_PLL3_VAL,
+	}, {
+		.pclk = &ras_synth1_clk,
+		.pclk_val = SPEAR1310_TDM_CLK_RAS_SYNT1_VAL,
+	},
+};
+
+static struct pclk_sel tdm_pclk_sel = {
+	.pclk_info = tdm_pclk_info,
+	.pclk_count = ARRAY_SIZE(tdm_pclk_info),
+	.pclk_sel_reg = (unsigned int *)(IO_ADDRESS(SPEAR1310_RAS_CTRL_REG0)),
+	.pclk_sel_mask = SPEAR1310_TDM_CLK_MASK,
+};
+
+static struct clk tdm1_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_TDM_E1_0_CLK_ENB,
+	.pclk_sel = &tdm_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_TDM1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+static struct clk tdm2_clk = {
+	.en_reg = IOMEM(IO_ADDRESS(SPEAR1310_RAS_SW_CLK_CTRL)),
+	.en_reg_bit = SPEAR1310_TDM_E1_1_CLK_ENB,
+	.pclk_sel = &tdm_pclk_sel,
+	.pclk_sel_shift = SPEAR1310_TDM2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+static struct clk dummy_apb_pclk;
+
+/* array of all spear 1310 clock lookups */
+static struct clk_lookup spear1310_clk_lookups[] = {
+	{ .con_id = "apb_pclk",			.clk = &dummy_apb_pclk},
+	/* root clks */
+	{.con_id = "osc1_24m_clk",		.clk = &osc1_24m_clk},
+	{.con_id = "osc2_32k_clk",		.clk = &osc2_32k_clk},
+	{.con_id = "osc3_25m_clk",		.clk = &osc3_25m_clk},
+
+	/* clock derived from 32 KHz osc clk */
+	{.dev_id = "rtc-spear",			.clk = &rtc_clk},
+
+	/* clock derived from 24/25 MHz osc1/osc3 clk */
+	{.con_id = "vco1_clk",			.clk = &vco1_clk},
+	{.con_id = "vco2_clk",			.clk = &vco2_clk},
+	{.con_id = "vco3_clk",			.clk = &vco3_clk},
+	{.con_id = "vco4_clk",			.clk = &vco4_clk},
+	{.con_id = "pll5_clk",			.clk = &pll5_clk},
+	{.con_id = "pll6_clk",			.clk = &pll6_clk},
+
+	/* clock derived from vco1-5 clk */
+	{.con_id = "pll1_clk",			.clk = &pll1_clk},
+	{.con_id = "pll2_clk",			.clk = &pll2_clk},
+	{.con_id = "pll3_clk",			.clk = &pll3_clk},
+	{.con_id = "pll4_clk",			.clk = &pll4_clk},
+	{.con_id = "vco1div2_clk",		.clk = &vco1div2_clk},
+	{.con_id = "vco1div4_clk",		.clk = &vco1div4_clk},
+	{.con_id = "vco2div2_clk",		.clk = &vco2div2_clk},
+	{.con_id = "vco3div2_clk",		.clk = &vco3div2_clk},
+
+	/* clock derived from pll1 clk */
+	{.con_id = "ddr_clk",			.clk = &ddr_clk},
+	{.con_id = "cpu_clk",			.clk = &cpu_clk},
+	{.con_id = "ahb_clk",			.clk = &ahb_clk},
+	{.con_id = "apb_clk",			.clk = &apb_clk},
+
+	/* synthesizers/prescaled clocks */
+	{.con_id = "c3_synth_clk",		.clk = &c3_synth_clk},
+	{.con_id = "gmii_125m_pad_clk",		.clk = &gmii_125m_pad},
+	{.con_id = "clcd_synth_clk",		.clk = &clcd_synth_clk},
+	{.con_id = "uart_synth_clk",		.clk = &uart_synth_clk},
+	{.con_id = "sdhci_synth_clk",		.clk = &sdhci_synth_clk},
+	{.con_id = "cfxd_synth_clk",		.clk = &cfxd_synth_clk},
+	{.con_id = "gmac_phy_input_clk",	.clk = &gmac_phy_input_clk},
+	{.con_id = "gmac_phy_synth_clk",	.clk = &gmac_phy_synth_clk},
+	{.con_id = "stmmacphy.0",		.clk = &gmac_phy0_clk},
+
+	/* RAS clocks */
+	{.con_id = "ras_synth0_clk",		.clk = &ras_synth0_clk},
+	{.con_id = "ras_synth1_clk",		.clk = &ras_synth1_clk},
+	{.con_id = "ras_synth2_clk",		.clk = &ras_synth2_clk},
+	{.con_id = "ras_synth3_clk",		.clk = &ras_synth3_clk},
+	{.con_id = "ras_pll3_clk",		.clk = &ras_pll3_clk},
+	{.con_id = "ras_pll2_clk",		.clk = &ras_pll2_clk},
+	{.con_id = "ras_tx125_clk",		.clk = &ras_tx125_clk},
+	{.con_id = "ras_30Mhz_clk",		.clk = &ras_30Mhz_clk},
+	{.con_id = "ras_48Mhz_clk",		.clk = &ras_48Mhz_clk},
+	{.con_id = "ras_osc3_clk",		.clk = &ras_osc3_clk},
+	{.con_id = "ras_osc2_clk",		.clk = &ras_osc2_clk},
+	{.con_id = "ras_osc1_clk",		.clk = &ras_osc1_clk},
+	{.con_id = "ras_pclk_clk",		.clk = &ras_pclk_clk},
+	{.con_id = "ras_aclk_clk",		.clk = &ras_aclk_clk},
+	{.con_id = "ras_tx50_clk",		.clk = &ras_tx50_clk},
+	/* i2s refout and sclk clks */
+	{.con_id = "i2s_src_pad_clk",		.clk = &i2s_src_pad_clk},
+	{.con_id = "i2s_src_clk",		.clk = &i2s_src_clk},
+	{.con_id = "i2s_prs1_clk",		.clk = &i2s_prs1_clk},
+	{.con_id = "i2s_ref_clk",		.clk = &i2s_ref_clk},
+	{.con_id = "i2s_ref_pad_clk",		.clk = &i2s_ref_pad_clk},
+	{.con_id = "i2s_sclk_clk",		.clk = &i2s_sclk_clk},
+
+	/* clocks having multiple parent source from above clocks */
+	{.dev_id = "clcd_pixel_clk",		.clk = &clcd_pixel_clk},
+	{.dev_id = "clcd-db9000",		.clk = &clcd_clk},
+	{.dev_id = "gpt0",			.clk = &gpt0_clk},
+	{.dev_id = "gpt1",			.clk = &gpt1_clk},
+	{.dev_id = "gpt2",			.clk = &gpt2_clk},
+	{.dev_id = "gpt3",			.clk = &gpt3_clk},
+	{.dev_id = "uart",			.clk = &uart_clk},
+
+	/* clock derived from ahb clk */
+	{.dev_id = "smi",			.clk = &smi_clk},
+	{.con_id = "usbh.0_clk",		.clk = &uhci0_clk},
+	{.con_id = "usbh.1_clk",		.clk = &uhci1_clk},
+	{.dev_id = "uoc",			.clk = &uoc_clk},
+	{.dev_id = "i2c_designware.0",		.clk = &i2c_clk},
+	{.con_id = "dmac_pclk",			.clk = &dma_pclk},
+	{.dev_id = "dw_dmac.0",			.clk = &dma0_clk},
+	{.dev_id = "dw_dmac.1",			.clk = &dma1_clk},
+	{.dev_id = "jpeg-designware",		.clk = &jpeg_clk},
+	{.dev_id = "stmmaceth.0",		.clk = &gmac0_clk},
+	{.dev_id = "c3",			.clk = &c3_clk},
+	{.con_id = "pcie_sata_0_pclk",		.clk = &pcie_sata_0_pclk},
+	{.con_id = "pcie_sata_1_pclk",		.clk = &pcie_sata_1_pclk},
+	{.con_id = "pcie_sata_2_pclk",		.clk = &pcie_sata_2_pclk},
+	{.dev_id = "dw_pcie.0",			.clk = &pcie0_clk},
+	{.dev_id = "dw_pcie.1",			.clk = &pcie1_clk},
+	{.dev_id = "dw_pcie.2",			.clk = &pcie2_clk},
+	{.dev_id = "ahci.0",			.clk = &sata0_clk},
+	{.dev_id = "ahci.1",			.clk = &sata1_clk},
+	{.dev_id = "ahci.2",			.clk = &sata2_clk},
+	{.dev_id = "sdhci",			.clk = &sdhci_clk},
+	{.con_id = "fsmc",			.clk = &fsmc_clk},
+	{.dev_id = "fsmc-nand",			.clk = &fsmc_nand_clk},
+	{.dev_id = "fsmc-nor",			.clk = &fsmc_nor_clk},
+	{.dev_id = "sysram0",			.clk = &sysram0_clk},
+	{.dev_id = "sysram1",			.clk = &sysram1_clk},
+	{.dev_id = "arasan_cf",			.clk = &cfxd_clk},
+	{.dev_id = "arasan_xd",			.clk = &cfxd_clk},
+	{.con_id = "adc_synth_clk",		.clk = &adc_synth_clk},
+	{.dev_id = "adc",			.clk = &adc_clk},
+
+	/* clock derived from apb clk */
+	{.dev_id = "designware-i2s.0",		.clk = &i2s0_clk},
+	{.dev_id = "designware-i2s.1",		.clk = &i2s1_clk},
+	{.dev_id = "ssp-pl022.0",		.clk = &ssp_clk},
+	{.dev_id = "gpio0",			.clk = &gpio0_clk},
+	{.dev_id = "gpio1",			.clk = &gpio1_clk},
+	{.dev_id = "keyboard",			.clk = &kbd_clk},
+	{.dev_id = "cortexa9-wdt",		.clk = &wdt_clk},
+
+	{.dev_id = "c_can_platform.0",		.clk = &can0_clk},
+	{.dev_id = "c_can_platform.1",		.clk = &can1_clk},
+	{.dev_id = "stmmaceth.1",		.clk = &smii_ras0_clk},
+	{.dev_id = "stmmaceth.2",		.clk = &smii_ras1_clk},
+	{.dev_id = "stmmaceth.3",		.clk = &smii_ras2_clk},
+	{.dev_id = "stmmaceth.4",		.clk = &rgmii_ras_clk},
+	{.con_id = "stmmacphy.1",		.clk = &gmac_phy1_clk},
+	{.con_id = "stmmacphy.2",		.clk = &gmac_phy2_clk},
+	{.con_id = "stmmacphy.3",		.clk = &gmac_phy3_clk},
+	{.con_id = "stmmacphy.4",		.clk = &gmac_phy4_clk},
+	{.dev_id = "uart1",			.clk = &uart1_clk},
+	{.dev_id = "uart2",			.clk = &uart2_clk},
+	{.dev_id = "uart3",			.clk = &uart3_clk},
+	{.dev_id = "uart4",			.clk = &uart4_clk},
+	{.dev_id = "uart5",			.clk = &uart5_clk},
+	{.dev_id = "i2c_designware.1",		.clk = &i2c1_clk},
+	{.dev_id = "i2c_designware.2",		.clk = &i2c2_clk},
+	{.dev_id = "i2c_designware.3",		.clk = &i2c3_clk},
+	{.dev_id = "i2c_designware.4",		.clk = &i2c4_clk},
+	{.dev_id = "i2c_designware.5",		.clk = &i2c5_clk},
+	{.dev_id = "i2c_designware.6",		.clk = &i2c6_clk},
+	{.dev_id = "i2c_designware.7",		.clk = &i2c7_clk},
+	{.dev_id = "pci",			.clk = &pci_clk},
+	{.dev_id = "spear_thermal",		.clk = &thermal_clk},
+	{.dev_id = "ssp-pl022.1",		.clk = &ssp1_clk},
+	{.con_id = "tdm_hdlc.0",		.clk = &tdm1_clk},
+	{.con_id = "tdm_hdlc.1",		.clk = &tdm2_clk},
+};
+
+/* machine clk init */
+void __init spear1310_clk_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(spear1310_clk_lookups); i++)
+		clk_register(&spear1310_clk_lookups[i]);
+
+	clk_init(&ddr_clk);
+}
diff --git a/arch/arm/mach-spear13xx/spear1310_evb.c b/arch/arm/mach-spear13xx/spear1310_evb.c
new file mode 100644
index 0000000..6577b54
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1310_evb.c
@@ -0,0 +1,367 @@
+/*
+ * arch/arm/mach-spear13xx/spear1310_evb.c
+ *
+ * SPEAr1310 evaluation board source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/spear_smi.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <plat/hdlc.h>
+#include <plat/keyboard.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear1310_misc_regs.h>
+#include <mach/spear_pcie.h>
+
+/* fsmc nor partition info */
+#define PARTITION(n, off, sz)	{.name = n, .offset = off, .size = sz}
+static struct mtd_partition partition_info[] = {
+	PARTITION("X-loader", 0, 1 * 0x20000),
+	PARTITION("U-Boot", 0x20000, 3 * 0x20000),
+	PARTITION("Kernel", 0x80000, 24 * 0x20000),
+	PARTITION("Root File System", 0x380000, 84 * 0x20000),
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/* spear13xx specific devices */
+	&spear13xx_pmx_i2c,
+	&spear13xx_pmx_i2s1,
+	&spear13xx_pmx_egpio_grp,
+	&spear13xx_pmx_gmii,
+	&spear13xx_pmx_keyboard_6x6,
+	&spear13xx_pmx_mcif,
+	&spear13xx_pmx_smi_2_chips,
+	&spear13xx_pmx_ssp,
+	&spear13xx_pmx_uart0,
+	&spear13xx_pmx_sdhci,
+
+	/* spear1310 specific devices */
+	&spear1310_pmx_rs485_0_1_tdm_0_1,
+	&spear1310_pmx_i2c_1_2,
+	&spear1310_pmx_pci,
+	&spear1310_pmx_smii_0_1_2,
+	&spear1310_pmx_pcie0,
+	&spear1310_pmx_pcie1,
+	&spear1310_pmx_pcie2,
+	&spear13xx_pmx_nand_8bit,
+	&spear13xx_pmx_nand_16bit,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+
+	/* spear1310 specific devices */
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_cpufreq_device,
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_i2s0_device,
+	&spear13xx_jpeg_device,
+	&spear13xx_kbd_device,
+	&spear1310_nand_device,
+	&spear13xx_pcie_gadget0_device,
+	&spear13xx_pcie_host1_device,
+	&spear13xx_pcie_host2_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear13xx_thermal_device,
+	&spear13xx_wdt_device,
+
+	/* spear1310 specific devices */
+	&spear1310_plgpio_device,
+	&spear1310_otg_device,
+};
+
+/* Ethernet PLatform data */
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = -1,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x20000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x20000,
+		.size = 12 * 0x20000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 12) * 0x20000,
+		.size = 48 * 0x20000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 48) * 0x20000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = spear1310_nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+/* fsmc nor platform data */
+static const struct physmap_flash_data nor_plat_data __initconst = {
+	.parts = partition_info,
+	.nr_parts = ARRAY_SIZE(partition_info),
+	.width = FSMC_FLASH_WIDTH8,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_9x9_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_9x9,
+};
+
+/* spi master's configuration routine */
+DECLARE_SPI_CS_CFG(0, VA_SPEAR1310_PERIP_CFG, SPEAR1310_SSP0_CS_SEL_MASK,
+		SPEAR1310_SSP0_CS_SEL_SHIFT, SPEAR1310_SSP0_CS_CTL_MASK,
+		SPEAR1310_SSP0_CS_CTL_SHIFT, SPEAR1310_SSP0_CS_CTL_SW,
+		SPEAR1310_SSP0_CS_VAL_MASK, SPEAR1310_SSP0_CS_VAL_SHIFT);
+
+/* spi0 flash Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, flash, SPEAR1310_SSP0_CS_SEL_CS1);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_control);
+
+/* spi0 spidev Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, dev, SPEAR1310_SSP0_CS_SEL_CS2);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_control);
+
+/* spi0 touch screen Chip Select Control function, controlled by gpio pin */
+DECLARE_SPI_CS_CONTROL(0, ts, SPEAR1310_SSP0_CS_SEL_CS0);
+/* spi0 touch screen Info structure */
+static struct pl022_config_chip spi0_ts_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.slave_tx_disable = 0,
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = spi0_ts_cs_control,
+};
+
+static struct stmpe_ts_platform_data stmpe610_ts_pdata = {
+	.sample_time = 4, /* 80 clocks */
+	.mod_12b = 1, /* 12 bit */
+	.ref_sel = 0, /* Internal */
+	.adc_freq = 1, /* 3.25 MHz */
+	.ave_ctrl = 1, /* 2 samples */
+	.touch_det_delay = 2, /* 100 us */
+	.settling = 2, /* 500 us */
+	.fraction_z = 7,
+	.i_drive = 1, /* 50 to 80 mA */
+};
+
+static struct stmpe_platform_data stmpe610_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = SPEAR_STMPE610_INT_BASE,
+	.irq_trigger = IRQ_TYPE_EDGE_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.irq_over_gpio = true,
+	.irq_gpio = GPIO1_6,
+	.ts = &stmpe610_ts_pdata,
+};
+
+static struct spi_board_info __initdata spi_board_info[] = {
+	/* spi0 board info */
+	{
+		.modalias = "stmpe610",
+		.platform_data = &stmpe610_pdata,
+		.controller_data = &spi0_ts_chip_info,
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = SPEAR1310_SSP0_CS_SEL_CS0,
+		.mode = SPI_MODE_1,
+	}, {
+		.modalias = "m25p80",
+		.controller_data = &spi0_flash_chip_info,
+		.max_speed_hz = 12000000,
+		.bus_num = 0,
+		.chip_select = SPEAR1310_SSP0_CS_SEL_CS1,
+		.mode = SPI_MODE_3,
+	}, {
+		.modalias = "spidev",
+		.controller_data = &spi0_dev_chip_info,
+		.max_speed_hz = 25000000,
+		.bus_num = 0,
+		.chip_select = SPEAR1310_SSP0_CS_SEL_CS2,
+		.mode = SPI_MODE_1,
+	}
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV370
+/* This function is needed for board specific PCIe initilization */
+static void __init spear1310_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host1_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_70);
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host2_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_70);
+}
+#endif
+
+static void
+spear1310_evb_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init spear1310_evb_init(void)
+{
+	unsigned int i;
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* call spear1310 machine init function */
+	spear1310_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/* set nand device's plat data */
+	if (platform_device_add_data(&spear1310_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_nand_device.name);
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+#ifdef CONFIG_SPEAR_PCIE_REV370
+	spear1310_pcie_board_init();
+#endif
+
+	/*
+	 * Note: Remove the comment to enable E1 interface for one HDLC port
+	 */
+	/* select_e1_interface(&spear1310_tdm_hdlc_0_device); */
+	/* select_e1_interface(&spear1310_tdm_hdlc_1_device); */
+
+	/* Register slave devices on the I2C buses */
+	i2c_register_default_devices();
+
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR1310_EVB, "ST-SPEAR1310-EVB")
+	.atag_offset	=	0x100,
+	.fixup		=	spear1310_evb_fixup,
+	.map_io		=	spear1310_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear1310_evb_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear1310_reva.c b/arch/arm/mach-spear13xx/spear1310_reva.c
new file mode 100644
index 0000000..167bdd1
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1310_reva.c
@@ -0,0 +1,982 @@
+/*
+ * arch/arm/mach-spear13xx/spear1310_reva.c
+ *
+ * SPEAr1310 machine source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/can/platform/c_can.h>
+#include <linux/clk.h>
+#include <linux/netdevice.h>
+#include <linux/ptrace.h>
+#include <linux/phy.h>
+#include <linux/stmmac.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <plat/hdlc.h>
+#include <mach/generic.h>
+#include <mach/gpio.h>
+#include <mach/hardware.h>
+#include <mach/misc_regs.h>
+
+/* pmx driver structure */
+static struct pmx_driver pmx_driver;
+
+/* Pad multiplexing for uart1_modem device */
+static struct pmx_mux_reg pmx_uart1_modem_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2S1_MASK | SPEAR13XX_PMX_SSP_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart1_modem_modes[] = {
+	{
+		.mux_regs = pmx_uart1_modem_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart1_modem_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_uart1_modem = {
+	.name = "uart1_modem",
+	.modes = pmx_uart1_modem_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart1_modem_modes),
+};
+
+/* Pad multiplexing for uart1 device */
+static struct pmx_mux_reg pmx_uart1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SSP_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart1_modes[] = {
+	{
+		.mux_regs = pmx_uart1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart1_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_uart_1 = {
+	.name = "uart1",
+	.modes = pmx_uart1_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart1_modes),
+};
+
+/* Pad multiplexing for uart2 device */
+static struct pmx_mux_reg pmx_uart2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SSP_MASK | SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart2_modes[] = {
+	{
+		.mux_regs = pmx_uart2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart2_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_uart_2 = {
+	.name = "uart2",
+	.modes = pmx_uart2_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart2_modes),
+};
+
+/* Pad multiplexing for uart_3_4_5 device */
+static struct pmx_mux_reg pmx_uart_3_4_5_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart_3_4_5_modes[] = {
+	{
+		.mux_regs = pmx_uart_3_4_5_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart_3_4_5_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_uart_3_4_5 = {
+	.name = "uart_3_4_5",
+	.modes = pmx_uart_3_4_5_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart_3_4_5_modes),
+};
+
+/* Pad multiplexing for rs485_hdlc_1_2 device */
+static struct pmx_mux_reg pmx_rs485_hdlc_1_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_rs485_hdlc_1_2_modes[] = {
+	{
+		.mux_regs = pmx_rs485_hdlc_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rs485_hdlc_1_2_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_rs485_hdlc_1_2 = {
+	.name = "rs485_hdlc_1_2",
+	.modes = pmx_rs485_hdlc_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_rs485_hdlc_1_2_modes),
+};
+
+/* Pad multiplexing for tdm_hdlc_1_2 device */
+static struct pmx_mux_reg pmx_tdm_hdlc_1_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_tdm_hdlc_1_2_modes[] = {
+	{
+		.mux_regs = pmx_tdm_hdlc_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_tdm_hdlc_1_2_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_tdm_hdlc_1_2 = {
+	.name = "tdm_hdlc_1_2",
+	.modes = pmx_tdm_hdlc_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_tdm_hdlc_1_2_modes),
+};
+
+/* Pad multiplexing for fsmc32bit device */
+static struct pmx_mux_reg pmx_fsmc32bit_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_EGPIO_0_GRP_MASK | \
+			SPEAR13XX_PMX_SMI_MASK | SPEAR13XX_PMX_CLCD1_MASK | \
+			SPEAR13XX_PMX_NAND16BIT4DEV_0_MASK,
+		.value = 0,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KEYBOARD_6X6_MASK | \
+			SPEAR13XX_PMX_NAND16BIT4DEV_1_MASK,
+		.value = 0,
+	}, {
+		.address = PCM_CFG,
+		.mask = SPEAR1310_REVA_PMX_EGPIO7_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_fsmc32bit_modes[] = {
+	{
+		.mux_regs = pmx_fsmc32bit_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_fsmc32bit_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_fsmc32bit_4_chips = {
+	.name = "fsmc32bit",
+	.modes = pmx_fsmc32bit_modes,
+	.mode_count = ARRAY_SIZE(pmx_fsmc32bit_modes),
+};
+
+/* Pad multiplexing for fsmc16bit device */
+static struct pmx_mux_reg pmx_fsmc16bit_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NAND16BIT4DEV_0_MASK,
+		.value = 0,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KEYBOARD_6X6_MASK | \
+			SPEAR13XX_PMX_NAND16BIT4DEV_1_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_fsmc16bit_modes[] = {
+	{
+		.mux_regs = pmx_fsmc16bit_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_fsmc16bit_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_fsmc16bit_4_chips = {
+	.name = "fsmc16bit",
+	.modes = pmx_fsmc16bit_modes,
+	.mode_count = ARRAY_SIZE(pmx_fsmc16bit_modes),
+};
+
+/* Pad multiplexing for gmii1 device */
+static struct pmx_mux_reg pmx_gmii1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_GMII_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_gmii1_modes[] = {
+	{
+		.mux_regs = pmx_gmii1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gmii1_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_gmii1 = {
+	.name = "gmii1",
+	.modes = pmx_gmii1_modes,
+	.mode_count = ARRAY_SIZE(pmx_gmii1_modes),
+};
+
+/* Pad multiplexing for rgmii device */
+static struct pmx_mux_reg pmx_rgmii_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_GMII_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_rgmii_modes[] = {
+	{
+		.mux_regs = pmx_rgmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rgmii_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_rgmii = {
+	.name = "rgmii",
+	.modes = pmx_rgmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_rgmii_modes),
+};
+
+/* Pad multiplexing for i2c1 device */
+static struct pmx_mux_reg pmx_i2c1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_SMINCS2_MASK | SPEAR13XX_PMX_SMINCS3_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c1_modes[] = {
+	{
+		.mux_regs = pmx_i2c1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c1_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_i2c1 = {
+	.name = "i2c1",
+	.modes = pmx_i2c1_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c1_modes),
+};
+
+/* Pad multiplexing for smii_0_1_2 device */
+static struct pmx_mux_reg pmx_smii_0_1_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_CLCD2_MASK | \
+			SPEAR13XX_PMX_KBD_ROWCOL68_MASK | \
+			SPEAR13XX_PMX_EGPIO_1_GRP_MASK | \
+			SPEAR13XX_PMX_GPT0_TMR1_MASK | \
+			SPEAR13XX_PMX_GPT0_TMR2_MASK | \
+			SPEAR13XX_PMX_GPT1_TMR1_MASK | \
+			SPEAR13XX_PMX_GPT1_TMR2_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_REVA_FUNC_CNTL_0,
+		.mask = SPEAR1310_REVA_PMX_SMII_MASK,
+		.value = SPEAR1310_REVA_PMX_SMII_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_smii_0_1_2_modes[] = {
+	{
+		.mux_regs = pmx_smii_0_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_smii_0_1_2_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_smii_0_1_2 = {
+	.name = "smii_0_1_2",
+	.modes = pmx_smii_0_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_smii_0_1_2_modes),
+};
+
+/* Pad multiplexing for pci1 device */
+static struct pmx_mux_reg pmx_pci1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_CLCD2_MASK | \
+			SPEAR13XX_PMX_KBD_ROWCOL68_MASK | \
+			SPEAR13XX_PMX_EGPIO_1_GRP_MASK | \
+			SPEAR13XX_PMX_GPT0_TMR1_MASK | \
+			SPEAR13XX_PMX_GPT0_TMR2_MASK | \
+			SPEAR13XX_PMX_GPT1_TMR1_MASK | \
+			SPEAR13XX_PMX_GPT1_TMR2_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1310_REVA_FUNC_CNTL_0,
+		.mask = SPEAR1310_REVA_PMX_SMII_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_pci1_modes[] = {
+	{
+		.mux_regs = pmx_pci1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pci1_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_pci1 = {
+	.name = "pci1",
+	.modes = pmx_pci1_modes,
+	.mode_count = ARRAY_SIZE(pmx_pci1_modes),
+};
+
+/* Pad multiplexing for can device */
+static struct pmx_mux_reg pmx_can_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_I2S2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_can_modes[] = {
+	{
+		.mux_regs = pmx_can_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_can_mux),
+	},
+};
+
+struct pmx_dev spear1310_reva_pmx_can = {
+	.name = "can",
+	.modes = pmx_can_modes,
+	.mode_count = ARRAY_SIZE(pmx_can_modes),
+};
+
+/* Add spear1310_reva specific devices here */
+/* uart1 device registeration */
+struct amba_device spear1310_reva_uart1_device = {
+	.dev = {
+		.init_name = "uart1",
+	},
+	.res = {
+		.start = SPEAR1310_REVA_UART1_BASE,
+		.end = SPEAR1310_REVA_UART1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_REVA_IRQ_UART1, NO_IRQ},
+};
+
+/* uart2 device registeration */
+struct amba_device spear1310_reva_uart2_device = {
+	.dev = {
+		.init_name = "uart2",
+	},
+	.res = {
+		.start = SPEAR1310_REVA_UART2_BASE,
+		.end = SPEAR1310_REVA_UART2_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_REVA_IRQ_UART2, NO_IRQ},
+};
+
+/* uart3 device registeration */
+struct amba_device spear1310_reva_uart3_device = {
+	.dev = {
+		.init_name = "uart3",
+	},
+	.res = {
+		.start = SPEAR1310_REVA_UART3_BASE,
+		.end = SPEAR1310_REVA_UART3_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_REVA_IRQ_UART3, NO_IRQ},
+};
+
+/* uart4 device registeration */
+struct amba_device spear1310_reva_uart4_device = {
+	.dev = {
+		.init_name = "uart4",
+	},
+	.res = {
+		.start = SPEAR1310_REVA_UART4_BASE,
+		.end = SPEAR1310_REVA_UART4_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_REVA_IRQ_UART4, NO_IRQ},
+};
+
+/* uart5 device registeration */
+struct amba_device spear1310_reva_uart5_device = {
+	.dev = {
+		.init_name = "uart5",
+	},
+	.res = {
+		.start = SPEAR1310_REVA_UART5_BASE,
+		.end = SPEAR1310_REVA_UART5_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1310_REVA_IRQ_UART5, NO_IRQ},
+};
+
+/* CAN device registeration */
+static struct c_can_platform_data can0_pdata = {
+	.is_quirk_required = true,
+	.devtype_data = {
+		.rx_first = 1,
+		.rx_split = 25,
+		.rx_last = 31,
+		.tx_num = 1,
+	},
+};
+
+static struct resource can0_resources[] = {
+	{
+		.start = SPEAR1310_REVA_CAN0_BASE,
+		.end = SPEAR1310_REVA_CAN0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_CCAN0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_can0_device = {
+	.name = "c_can_platform",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(can0_resources),
+	.resource = can0_resources,
+	.dev.platform_data = &can0_pdata,
+};
+
+static struct c_can_platform_data can1_pdata = {
+	.is_quirk_required = true,
+	.devtype_data = {
+		.rx_first = 1,
+		.rx_split = 25,
+		.rx_last = 31,
+		.tx_num = 1,
+	},
+};
+
+static struct resource can1_resources[] = {
+	{
+		.start = SPEAR1310_REVA_CAN1_BASE,
+		.end = SPEAR1310_REVA_CAN1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_CCAN1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_can1_device = {
+	.name = "c_can_platform",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(can1_resources),
+	.resource = can1_resources,
+	.dev.platform_data = &can1_pdata,
+};
+
+static struct resource eth1_resources[] = {
+	[0] = {
+		.start = SPEAR1310_REVA_GETH1_BASE,
+		.end = SPEAR1310_REVA_GETH1_BASE + SZ_32K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR1310_REVA_IRQ_GETH1_SBD,
+		.flags = IORESOURCE_IRQ,
+		.name = "macirq",
+	},
+	[2] = {
+		.start = SPEAR1310_REVA_IRQ_GETH1_PMT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 eth1_dma_mask = ~(u32) 0;
+struct platform_device spear1310_reva_eth1_device = {
+	.name = "stmmaceth",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(eth1_resources),
+	.resource = eth1_resources,
+	.dev = {
+		.dma_mask = &eth1_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+/* Ethernet GETH-2 device registeration */
+static struct resource eth2_resources[] = {
+	[0] = {
+		.start = SPEAR1310_REVA_GETH2_BASE,
+		.end = SPEAR1310_REVA_GETH2_BASE + SZ_32K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR1310_REVA_IRQ_GETH2_SBD,
+		.flags = IORESOURCE_IRQ,
+		.name = "macirq",
+	},
+	[2] = {
+		.start = SPEAR1310_REVA_IRQ_GETH2_PMT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 eth2_dma_mask = ~(u32) 0;
+struct platform_device spear1310_reva_eth2_device = {
+	.name = "stmmaceth",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(eth2_resources),
+	.resource = eth2_resources,
+	.dev = {
+		.dma_mask = &eth2_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+/* Ethernet GETH-3 device registeration */
+static struct resource eth3_resources[] = {
+	[0] = {
+		.start = SPEAR1310_REVA_GETH3_BASE,
+		.end = SPEAR1310_REVA_GETH3_BASE + SZ_32K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR1310_REVA_IRQ_GETH3_SBD,
+		.flags = IORESOURCE_IRQ,
+		.name = "macirq",
+	},
+	[2] = {
+		.start = SPEAR1310_REVA_IRQ_GETH3_PMT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 eth3_dma_mask = ~(u32) 0;
+struct platform_device spear1310_reva_eth3_device = {
+	.name = "stmmaceth",
+	.id = 3,
+	.num_resources = ARRAY_SIZE(eth3_resources),
+	.resource = eth3_resources,
+	.dev = {
+		.dma_mask = &eth3_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+/* Ethernet GETH-4 device registeration */
+static struct resource eth4_resources[] = {
+	[0] = {
+		.start = SPEAR1310_REVA_GETH4_BASE,
+		.end = SPEAR1310_REVA_GETH4_BASE + SZ_32K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR1310_REVA_IRQ_GETH4_SBD,
+		.flags = IORESOURCE_IRQ,
+		.name = "macirq",
+	},
+	[2] = {
+		.start = SPEAR1310_REVA_IRQ_GETH4_PMT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 eth4_dma_mask = ~(u32) 0;
+struct platform_device spear1310_reva_eth4_device = {
+	.name = "stmmaceth",
+	.id = 4,
+	.num_resources = ARRAY_SIZE(eth4_resources),
+	.resource = eth4_resources,
+	.dev = {
+		.dma_mask = &eth4_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+/* i2c1 device registeration */
+static struct resource i2c1_resources[] = {
+	{
+		.start = SPEAR1310_REVA_I2C1_BASE,
+		.end = SPEAR1310_REVA_I2C1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_I2C_CNTR,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_i2c1_device = {
+	.name = "i2c_designware",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c1_resources),
+	.resource = i2c1_resources,
+};
+
+/* plgpio */
+static struct plgpio_platform_data plgpio_plat_data = {
+	.gpio_base = 16,
+	.irq_base = SPEAR_PLGPIO_INT_BASE,
+	.gpio_count = SPEAR_PLGPIO_COUNT,
+	.grp_size = PLGPIO_GROUP_SIZE,
+	.regs = {
+		.enb = SPEAR13XX_PLGPIO_ENB_OFF,
+		.wdata = SPEAR13XX_PLGPIO_WDATA_OFF,
+		.dir = SPEAR13XX_PLGPIO_DIR_OFF,
+		.ie = SPEAR13XX_PLGPIO_IE_OFF,
+		.rdata = SPEAR13XX_PLGPIO_RDATA_OFF,
+		.mis = SPEAR13XX_PLGPIO_MIS_OFF,
+		.eit = -1,
+	},
+};
+
+static struct resource plgpio_resources[] = {
+	{
+		.start = SPEAR1310_REVA_RAS_BASE,
+		.end = SPEAR1310_REVA_RAS_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_PLGPIO,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_plgpio_device = {
+	.name = "plgpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &plgpio_plat_data,
+	},
+	.num_resources = ARRAY_SIZE(plgpio_resources),
+	.resource = plgpio_resources,
+};
+
+/* fsmc nor flash device registeration */
+static struct resource ras_fsmc_nor_resources[] = {
+	{
+		.start	= SPEAR1310_REVA_FSMC1_CS3_BASE,
+		.end	= SPEAR1310_REVA_FSMC1_CS3_BASE + SZ_64M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear1310_reva_ras_fsmc_nor_device = {
+	.name	= "physmap-flash",
+	.id	= -1,
+	.resource = ras_fsmc_nor_resources,
+	.num_resources = ARRAY_SIZE(ras_fsmc_nor_resources),
+};
+
+static struct rs485_hdlc_platform_data rs485_0_plat_data = {
+	.tx_falling_edge = 1,
+	.rx_rising_edge = 1,
+	.cts_enable = 1,
+	.cts_delay = 50,
+};
+
+static struct rs485_hdlc_platform_data rs485_1_plat_data = {
+	.tx_falling_edge = 1,
+	.rx_rising_edge = 1,
+	.cts_enable = 1,
+	.cts_delay = 50,
+};
+
+/* hdlc/tdm device registration */
+static struct resource rs485_0_resources[] = {
+	{
+		.start = SPEAR1310_REVA_RS485_0_BASE,
+		.end = SPEAR1310_REVA_RS485_0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_RS4850,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource rs485_1_resources[] = {
+	{
+		.start = SPEAR1310_REVA_RS485_1_BASE,
+		.end = SPEAR1310_REVA_RS485_1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_RS4851,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_rs485_0_device = {
+	.name = "rs485_hdlc",
+	.id = 0,
+	.dev = {
+		.platform_data = &rs485_0_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(rs485_0_resources),
+	.resource = rs485_0_resources,
+};
+
+struct platform_device spear1310_reva_rs485_1_device = {
+	.name = "rs485_hdlc",
+	.id = 1,
+	.dev = {
+		.platform_data = &rs485_1_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(rs485_1_resources),
+	.resource = rs485_1_resources,
+};
+
+static struct tdm_hdlc_platform_data tdm_hdlc_0_plat_data = {
+	.ip_type = SPEAR1310_REVA_TDM_HDLC,
+	.nr_channel = 2,
+	.nr_timeslot = 128,
+};
+
+static struct resource tdm_hdlc_0_resources[] = {
+	{
+		.start = SPEAR1310_REVA_TDM_E1_0_BASE,
+		.end = SPEAR1310_REVA_TDM_E1_0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_TDM0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_tdm_hdlc_0_device = {
+	.name = "tdm_hdlc",
+	.id = 0,
+	.dev = {
+		.platform_data = &tdm_hdlc_0_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(tdm_hdlc_0_resources),
+	.resource = tdm_hdlc_0_resources,
+};
+
+static struct tdm_hdlc_platform_data tdm_hdlc_1_plat_data = {
+	.ip_type = SPEAR1310_REVA_TDM_HDLC,
+	.nr_channel = 2,
+	.nr_timeslot = 128,
+};
+
+static struct resource tdm_hdlc_1_resources[] = {
+	{
+		.start = SPEAR1310_REVA_TDM_E1_1_BASE,
+		.end = SPEAR1310_REVA_TDM_E1_1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1310_REVA_IRQ_TDM1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1310_reva_tdm_hdlc_1_device = {
+	.name = "tdm_hdlc",
+	.id = 1,
+	.dev = {
+		.platform_data = &tdm_hdlc_1_plat_data,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(tdm_hdlc_1_resources),
+	.resource = tdm_hdlc_1_resources,
+};
+
+static void tdm_hdlc_setup(void)
+{
+	struct clk *synth_clk, *vco_clk, *tdm_clk;
+	char *synth_clk_name = "ras_synth1_clk";
+	char *vco_clk_name = "vco1div4_clk";
+	int ret;
+
+	vco_clk = clk_get(NULL, vco_clk_name);
+	if (IS_ERR(vco_clk)) {
+		pr_err("Failed to get %s\n", vco_clk_name);
+		return;
+	}
+
+	synth_clk = clk_get(NULL, synth_clk_name);
+	if (IS_ERR(synth_clk)) {
+		pr_err("Failed to get %s\n", synth_clk_name);
+		goto free_vco_clk;
+	}
+
+	/* use vco1div4 source for ras_clk_synt1 */
+	ret = clk_set_parent(synth_clk, vco_clk);
+	if (ret < 0) {
+		pr_err("Failed to set parent %s to %s\n", vco_clk_name,
+				synth_clk_name);
+		goto free_synth_clk;
+	}
+
+	/* select ras_clk_synt1 as source for TDM */
+	tdm_clk = clk_get_sys(NULL, "tdm_hdlc");
+	if (IS_ERR(tdm_clk)) {
+		pr_err("Failed to get tdm clock\n");
+		goto free_synth_clk;
+	}
+	ret = clk_set_parent(tdm_clk, synth_clk);
+	if (ret < 0) {
+		pr_err("Failed to set parent %s to tdm clock\n",
+				synth_clk_name);
+		goto free_tdm_clk;
+	}
+
+free_tdm_clk:
+	clk_put(tdm_clk);
+free_synth_clk:
+	clk_put(synth_clk);
+free_vco_clk:
+	clk_put(vco_clk);
+}
+
+int spear1310_reva_eth_phy_clk_cfg(struct platform_device *pdev)
+{
+	struct plat_stmmacenet_data *pdata = dev_get_platdata(&pdev->dev);
+	void __iomem *addr = IOMEM(IO_ADDRESS(SPEAR1310_REVA_RAS_CTRL_REG1));
+	struct clk *clk, *phy_clk = NULL;
+	u32 tmp;
+	int ret;
+	char *pclk_name[] = {
+		"ras_pll2_clk",
+		"ras_tx125_clk",
+		"ras_tx50_clk",
+		"ras_synth0_clk",
+	};
+	const char *phy_clk_name[] = {
+		"stmmacphy.0",
+		"stmmacphy.1",
+		"stmmacphy.2",
+		"stmmacphy.3",
+		"stmmacphy.4",
+	};
+
+	phy_clk = clk_get(NULL, phy_clk_name[pdata->bus_id]);
+	if (IS_ERR(phy_clk)) {
+		ret = PTR_ERR(phy_clk);
+		goto fail_get_phy_clk;
+	}
+
+	/*
+	 * Select 125 MHz clock for SMII mode, else the clock
+	 * for RMII mode is 50 Mhz.
+	 * The default clock for the GMAC is driven by pll-2
+	 * set to 125Mhz. In case the clock source is required to
+	 * be from tx pad, the gmac0 interface should select that
+	 * to pad clock.
+	 */
+	tmp = (pdata->interface == PHY_INTERFACE_MODE_RMII) ? 3 : 0;
+	clk = clk_get(NULL, pclk_name[tmp]);
+	if (IS_ERR(clk)) {
+		pr_err("%s:couldn't get %s as parent for MAC\n",
+				__func__, pclk_name[tmp]);
+		ret = PTR_ERR(clk);
+		goto fail_get_pclk;
+	}
+
+	tmp = readl(addr);
+	switch (pdata->bus_id) {
+	case 1:
+		tmp &= (~SPEAR1310_REVA_GETH1_PHY_INTF_MASK);
+		tmp |= (pdata->interface == PHY_INTERFACE_MODE_MII) ?
+			(SPEAR1310_REVA_PHY_SMII_VAL << 4) :
+			(SPEAR1310_REVA_PHY_RMII_VAL << 4);
+		break;
+	case 2:
+		tmp &= (~SPEAR1310_REVA_GETH2_PHY_INTF_MASK);
+		tmp |= (pdata->interface == PHY_INTERFACE_MODE_MII) ?
+			(SPEAR1310_REVA_PHY_SMII_VAL << 7) :
+			(SPEAR1310_REVA_PHY_RMII_VAL << 7);
+		break;
+	case 3:
+		tmp &= (~SPEAR1310_REVA_GETH3_PHY_INTF_MASK);
+		tmp |= (pdata->interface == PHY_INTERFACE_MODE_MII) ?
+			(SPEAR1310_REVA_PHY_SMII_VAL << 10) :
+			(SPEAR1310_REVA_PHY_RMII_VAL << 10);
+		break;
+	case 4:
+		tmp &= (~SPEAR1310_REVA_GETH4_PHY_INTF_MASK);
+		tmp |= SPEAR1310_REVA_PHY_RGMII_VAL << 13;
+		break;
+	default:
+		clk_put(clk);
+		return -EINVAL;
+		break;
+	}
+
+	writel(tmp, addr);
+	clk_set_parent(phy_clk, clk);
+	if (pdata->interface == PHY_INTERFACE_MODE_RMII)
+		ret = clk_set_rate(clk, 50000000);
+
+	ret = clk_enable(phy_clk);
+
+	return ret;
+fail_get_pclk:
+	clk_put(phy_clk);
+fail_get_phy_clk:
+	return ret;
+}
+
+/* Following will create 1310 specific static virtual/physical mappings */
+static struct map_desc spear1310_reva_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(SPEAR1310_REVA_RAS_BASE),
+		.pfn		= __phys_to_pfn(SPEAR1310_REVA_RAS_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	},
+};
+
+/* This will create static memory mapping for selected devices */
+void __init spear1310_reva_map_io(void)
+{
+	iotable_init(spear1310_reva_io_desc,
+			ARRAY_SIZE(spear1310_reva_io_desc));
+	spear13xx_map_io();
+}
+
+void __init spear1310_reva_init(struct pmx_mode *pmx_mode,
+		struct pmx_dev **pmx_devs, u8 pmx_dev_count)
+{
+	int ret;
+
+	/* call spear13xx family common init function */
+	spear13xx_init();
+
+	tdm_hdlc_setup();
+
+	/* pmx initialization */
+	pmx_driver.mode = pmx_mode;
+	pmx_driver.devs = pmx_devs;
+	pmx_driver.devs_count = pmx_dev_count;
+
+	ret = pmx_register(&pmx_driver);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
diff --git a/arch/arm/mach-spear13xx/spear1310_reva_evb.c b/arch/arm/mach-spear13xx/spear1310_reva_evb.c
new file mode 100644
index 0000000..d1c77ce
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1310_reva_evb.c
@@ -0,0 +1,613 @@
+/*
+ * arch/arm/mach-spear13xx/spear1310_reva_evb.c
+ *
+ * SPEAr1310 evaluation board source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Bhupesh Sharma <bhupesh.sharma@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/spear_smi.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <plat/hdlc.h>
+#include <plat/keyboard.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear_pcie.h>
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/* spear13xx specific devices */
+	&spear13xx_pmx_i2c,
+	&spear13xx_pmx_i2s1,
+	&spear13xx_pmx_egpio_grp,
+	&spear13xx_pmx_gmii,
+	&spear13xx_pmx_keyboard_6x6,
+	&spear13xx_pmx_mcif,
+	&spear13xx_pmx_smi_2_chips,
+	&spear13xx_pmx_uart0,
+	&spear13xx_pmx_sdhci,
+
+	/* spear1310_reva specific devices */
+	&spear1310_reva_pmx_can,
+	&spear1310_reva_pmx_i2c1,
+	&spear1310_reva_pmx_smii_0_1_2,
+	&spear1310_reva_pmx_fsmc16bit_4_chips,
+	&spear1310_reva_pmx_rs485_hdlc_1_2,
+	&spear1310_reva_pmx_tdm_hdlc_1_2,
+	&spear1310_reva_pmx_uart_1,
+	&spear1310_reva_pmx_uart_2,
+	&spear1310_reva_pmx_uart_3_4_5,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+
+	/* spear1310_reva specific devices */
+	&spear1310_reva_uart1_device,
+	&spear1310_reva_uart2_device,
+	&spear1310_reva_uart3_device,
+	&spear1310_reva_uart4_device,
+	&spear1310_reva_uart5_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_cpufreq_device,
+	&spear13xx_db9000_clcd_device,
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear13xx_device_gpiokeys,
+#endif
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_i2s0_device,
+	&spear13xx_jpeg_device,
+	&spear13xx_kbd_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcie_gadget0_device,
+	&spear13xx_pcie_host1_device,
+	&spear13xx_pcie_host2_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear13xx_thermal_device,
+	&spear13xx_udc_device,
+	&spear13xx_wdt_device,
+
+	/* spear1310_reva specific devices */
+	&spear1310_reva_can0_device,
+	&spear1310_reva_can1_device,
+	&spear1310_reva_eth1_device,
+	&spear1310_reva_eth2_device,
+	&spear1310_reva_eth3_device,
+	&spear1310_reva_eth4_device,
+	&spear1310_reva_i2c1_device,
+	&spear1310_reva_plgpio_device,
+	&spear1310_reva_ras_fsmc_nor_device,
+	&spear1310_reva_rs485_0_device,
+	&spear1310_reva_rs485_1_device,
+	&spear1310_reva_tdm_hdlc_0_device,
+	&spear1310_reva_tdm_hdlc_1_device,
+};
+
+/* Ethernet Platform Data */
+/* Ethernet GETH-0 device configuration */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth0_data = {
+	.bus_id = 0,
+	.phy_addr = 5,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+/* Ethernet GETH-1 device configuration */
+static struct stmmac_mdio_bus_data mdio1_private_data = {
+	.bus_id = 1,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma1_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth1_data = {
+	.bus_id = 1,
+	.phy_addr = 1,
+	.interface = PHY_INTERFACE_MODE_MII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 0,
+	.dma_cfg = &dma1_private_data,
+	.rx_coe = STMMAC_RX_COE_NONE,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio1_private_data,
+	.init = spear1310_reva_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+/* Ethernet GETH-2 device configuration */
+static struct stmmac_mdio_bus_data mdio2_private_data = {
+	.bus_id = 2,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma2_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth2_data = {
+	.bus_id = 2,
+	.phy_addr = 2,
+	.interface = PHY_INTERFACE_MODE_MII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 0,
+	.dma_cfg = &dma2_private_data,
+	.rx_coe = STMMAC_RX_COE_NONE,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio2_private_data,
+	.init = spear1310_reva_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+/* Ethernet GETH-3 device configuration */
+static struct stmmac_mdio_bus_data mdio3_private_data = {
+	.bus_id = 3,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma3_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth3_data = {
+	.bus_id = 3,
+	.phy_addr = 3,
+	.interface = PHY_INTERFACE_MODE_RMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 0,
+	.dma_cfg = &dma3_private_data,
+	.rx_coe = STMMAC_RX_COE_NONE,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio3_private_data,
+	.init = spear1310_reva_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+/* Ethernet GETH-4 device configuration */
+static struct stmmac_mdio_bus_data mdio4_private_data = {
+	.bus_id = 4,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma4_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth4_data = {
+	.bus_id = 4,
+	.phy_addr = 4,
+	.interface = PHY_INTERFACE_MODE_RGMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 0,
+	.dma_cfg = &dma4_private_data,
+	.rx_coe = STMMAC_RX_COE_NONE,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio4_private_data,
+	.init = spear1310_reva_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x20000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x20000,
+		.size = 12 * 0x20000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 12) * 0x20000,
+		.size = 48 * 0x20000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 48) * 0x20000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+/* fsmc nor partition info */
+#define PARTITION(n, off, sz)	{.name = n, .offset = off, .size = sz}
+static struct mtd_partition partition_info[] = {
+	PARTITION("X-loader", 0, 1 * 0x20000),
+	PARTITION("U-Boot", 0x20000, 3 * 0x20000),
+	PARTITION("Kernel", 0x80000, 24 * 0x20000),
+	PARTITION("Root File System", 0x380000, 84 * 0x20000),
+};
+
+/* fsmc nor platform data */
+static const struct physmap_flash_data fixed_nor_plat_data __initconst = {
+	.parts = partition_info,
+	.nr_parts = ARRAY_SIZE(partition_info),
+	.width = FSMC_FLASH_WIDTH8,
+};
+static const struct physmap_flash_data ras_nor_plat_data __initconst = {
+	.width = FSMC_FLASH_WIDTH16,
+};
+
+/* arasan compact flash controller's platform data */
+static struct arasan_cf_pdata cf_pdata = {
+	.cf_if_clk = CF_IF_CLK_166M,
+	.quirk = CF_BROKEN_UDMA,
+	.dma_priv = &cf_dma_priv,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_9x9_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_9x9,
+};
+
+#if 0
+/* spi0 flash Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, flash, /* mention gpio number here */);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_gpio_control);
+
+/* spi0 spidev Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, dev, /* mention gpio number here */);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_gpio_control);
+#endif
+
+/* spi0 touch screen Chip Select Control function, controlled by gpio pin */
+DECLARE_SPI_CS_GPIO_CONTROL(0, ts, GPIO1_7);
+/* spi0 touch screen Info structure */
+static struct pl022_config_chip spi0_ts_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.slave_tx_disable = 0,
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = spi0_ts_cs_gpio_control,
+};
+
+static struct stmpe_ts_platform_data stmpe610_ts_pdata = {
+	.sample_time = 4, /* 80 clocks */
+	.mod_12b = 1, /* 12 bit */
+	.ref_sel = 0, /* Internal */
+	.adc_freq = 1, /* 3.25 MHz */
+	.ave_ctrl = 1, /* 2 samples */
+	.touch_det_delay = 2, /* 100 us */
+	.settling = 2, /* 500 us */
+	.fraction_z = 7,
+	.i_drive = 1, /* 50 to 80 mA */
+};
+
+static struct stmpe_platform_data stmpe610_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = SPEAR_STMPE610_INT_BASE,
+	.irq_trigger = IRQ_TYPE_EDGE_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.irq_over_gpio = true,
+	.irq_gpio = GPIO1_6,
+	.ts = &stmpe610_ts_pdata,
+};
+
+static struct spi_board_info __initdata spi_board_info[] = {
+	/* spi0 board info */
+	{
+		.modalias = "stmpe610",
+		.platform_data = &stmpe610_pdata,
+		.controller_data = &spi0_ts_chip_info,
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	},
+#if 0
+	/* spi0 board info */
+	{
+		.modalias = "spidev",
+		.controller_data = &spi0_dev_chip_info,
+		.max_speed_hz = 25000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	}, {
+		.modalias = "m25p80",
+		.controller_data = &spi0_flash_chip_info,
+		.max_speed_hz = 12000000,
+		.bus_num = 0,
+		.chip_select = 1,
+		.mode = SPI_MODE_3,
+	}
+#endif
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+ /* This function is needed for board specific PCIe initilization */
+static void __init spear1310_reva_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host1_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host2_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+}
+#endif
+
+/* spear1310_reva ras misc configurations */
+static void __init ras_fsmc_config(u32 mode, u32 width)
+{
+	u32 val, *address;
+
+	address = ioremap(SPEAR1310_REVA_RAS_CTRL_REG0, SZ_16);
+
+	val = readl(address);
+	val &= ~(RAS_FSMC_MODE_MASK | RAS_FSMC_WIDTH_MASK);
+	val |= mode;
+	val |= width;
+	val |= RAS_FSMC_CS_SPLIT;
+
+	writel(val, address);
+
+	iounmap(address);
+}
+
+/*
+ * select_e1_interface: config CPLD to enable select E1 interface
+ *
+ * By default, TDM is selected. To switch the hardware connection, SW should
+ * call this function in machine init routine to enable E1 interface
+ */
+#if 0
+static void __init select_e1_interface(struct platform_device *pdev)
+{
+	/*
+	 * selection is through CPLD which is connected on FSMC bus
+	 * before config, initialize FSMC controller here
+	 */
+	ras_fsmc_config(RAS_FSMC_MODE_NOR, RAS_FSMC_WIDTH_8);
+	fsmc_nor_init(NULL, SPEAR1310_REVA_FSMC1_BASE, 2, FSMC_FLASH_WIDTH8);
+
+	e1phy_init(SPEAR1310_REVA_FSMC1_CS2_BASE + (pdev->id * 0x100), 0);
+	tdm_hdlc_set_plat_data(pdev, 32);
+}
+#endif
+
+static void
+spear1310_reva_evb_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init spear1310_reva_evb_init(void)
+{
+	unsigned int i;
+
+	/* set compact flash plat data */
+	set_arasan_cf_pdata(&spear13xx_cf_device, &cf_pdata);
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* call spear1310_reva machine init function */
+	spear1310_reva_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Set stmmac-0 plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth0_data,
+			sizeof(eth0_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+	/* Set stmmac-1 plat data */
+	if (platform_device_add_data(&spear1310_reva_eth1_device, &eth1_data,
+			sizeof(eth1_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1310_reva_eth1_device.name);
+
+	/* Set stmmac-2 plat data */
+	if (platform_device_add_data(&spear1310_reva_eth2_device, &eth2_data,
+			sizeof(eth2_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1310_reva_eth2_device.name);
+
+	/* Set stmmac-3 plat data */
+	if (platform_device_add_data(&spear1310_reva_eth3_device, &eth3_data,
+			sizeof(eth3_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1310_reva_eth3_device.name);
+
+	/* Set stmmac-4 plat data */
+	if (platform_device_add_data(&spear1310_reva_eth4_device, &eth4_data,
+			sizeof(eth4_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1310_reva_eth4_device.name);
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/*
+	 * SPEAr1310 FSMC cannot used as NOR and NAND at the same time
+	 * For the moment, disable NAND and use NOR only
+	 * If NAND is needed, enable the following code and disable all code for
+	 * NOR. Also enable nand in padmux configuration to use it.
+	 */
+	/* set nand device's plat data */
+#if 0
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear13xx_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_nand_device.name);
+#endif
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+	/*
+	 * Only one of Fixed or RAS part FSMC can be used at one time.
+	 * Default selection is RAS part FSMC for NOR.
+	 */
+#if 0
+	/* fixed part fsmc nor device */
+	/* Initialize fsmc regiters */
+	fsmc_nor_init(&spear13xx_fsmc_nor_device, SPEAR13XX_FSMC_BASE, 0,
+			FSMC_FLASH_WIDTH8);
+	/* initialize fsmc related data in fsmc plat data */
+	if (platform_device_add_data(&spear13xx_fsmc_nor_device,
+				&fixed_nor_plat_data,
+				sizeof(fixed_nor_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_fsmc_nor_device.name);
+#endif
+
+	/* ras part fsmc nor device */
+	/* Initialize fsmc regiters */
+	fsmc_nor_init(&spear1310_reva_ras_fsmc_nor_device,
+			SPEAR1310_REVA_FSMC1_BASE, 3, FSMC_FLASH_WIDTH16);
+	ras_fsmc_config(RAS_FSMC_MODE_NOR, RAS_FSMC_WIDTH_16);
+	/* initialize fsmc related data in fsmc plat data */
+	if (platform_device_add_data(&spear1310_reva_ras_fsmc_nor_device,
+				&ras_nor_plat_data, sizeof(ras_nor_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1310_reva_ras_fsmc_nor_device.name);
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+	spear1310_reva_pcie_board_init();
+#endif
+
+	/*
+	 * Note: Remove the comment to enable E1 interface for one HDLC port
+	 */
+	/* select_e1_interface(&spear1310_reva_tdm_hdlc_0_device); */
+	/* select_e1_interface(&spear1310_reva_tdm_hdlc_1_device); */
+
+	/* Register slave devices on the I2C buses */
+	i2c_register_default_devices();
+
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR1310_REVA_EVB, "ST-SPEAR1310-REVA-EVB")
+	.atag_offset	=	0x100,
+	.fixup		=	spear1310_reva_evb_fixup,
+	.map_io		=	spear1310_reva_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear1310_reva_evb_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear1340.c b/arch/arm/mach-spear13xx/spear1340.c
new file mode 100644
index 0000000..a4a0898
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1340.c
@@ -0,0 +1,2671 @@
+/*
+ * arch/arm/mach-spear13xx/spear1340.c
+ *
+ * SPEAr1340 machine source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/ahci_platform.h>
+#include <linux/amba/serial.h>
+#include <linux/delay.h>
+#include <linux/designware_i2s.h>
+#include <linux/dw_dmac.h>
+#include <linux/gpio.h>
+
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#endif
+
+#include <linux/i2c/i2c-designware.h>
+#include <linux/irq.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/platform_data/spear_thermal.h>
+#include <linux/usb/dwc_otg.h>
+#include <plat/camif.h>
+#include <plat/clock.h>
+#include <plat/cpufreq.h>
+#include <mach/dma.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spdif.h>
+#include <mach/spear1340_misc_regs.h>
+#include <mach/spear_pcie.h>
+#include <media/vip.h>
+#include <sound/pcm.h>
+
+/* pmx driver structure */
+static struct pmx_driver pmx_driver;
+
+/*
+ * Pad multiplexing for making all pads as gpio's. This is done to override the
+ * values passed from bootloader and start from scratch.
+ */
+static struct pmx_mux_reg pmx_pads_as_gpio_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REG1_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REGS_MASK,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = SPEAR1340_PMX_PADS_AS_GPIO_REG8_MASK,
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode pmx_pads_as_gpio_modes[] = {
+	{
+		.mux_regs = pmx_pads_as_gpio_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pads_as_gpio_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pads_as_gpio = {
+	.name = "pads_as_gpio",
+	.modes = pmx_pads_as_gpio_modes,
+	.mode_count = ARRAY_SIZE(pmx_pads_as_gpio_modes),
+};
+
+/* Pad multiplexing for fsmc_8bit device */
+static struct pmx_mux_reg pmx_fsmc_8bit_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+		.value = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+	}
+};
+
+static struct pmx_dev_mode pmx_fsmc_8bit_modes[] = {
+	{
+		.mux_regs = pmx_fsmc_8bit_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_fsmc_8bit_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_fsmc_8bit = {
+	.name = "fsmc_8bit",
+	.modes = pmx_fsmc_8bit_modes,
+	.mode_count = ARRAY_SIZE(pmx_fsmc_8bit_modes),
+};
+
+/* Pad multiplexing for fsmc_16bit device */
+static struct pmx_mux_reg pmx_fsmc_16bit_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_KBD_ROW_COL_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_FSMC_16_BIT_AND_KBD_ROW_COL_REG1_MASK,
+		.value = SPEAR1340_PMX_FSMC_16_BIT_AND_KBD_ROW_COL_REG1_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+		.value = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_fsmc_16bit_modes[] = {
+	{
+		.mux_regs = pmx_fsmc_16bit_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_fsmc_16bit_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_fsmc_16bit = {
+	.name = "fsmc_16bit",
+	.modes = pmx_fsmc_16bit_modes,
+	.mode_count = ARRAY_SIZE(pmx_fsmc_16bit_modes),
+};
+
+/* pad multiplexing for keyboard rows-cols device */
+static struct pmx_mux_reg pmx_keyboard_row_col_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_KBD_ROW_COL_MASK,
+		.value = SPEAR1340_PMX_KBD_ROW_COL_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_FSMC_16_BIT_AND_KBD_ROW_COL_REG1_MASK,
+		.value = SPEAR1340_PMX_FSMC_16_BIT_AND_KBD_ROW_COL_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_keyboard_row_col_modes[] = {
+	{
+		.mux_regs = pmx_keyboard_row_col_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_keyboard_row_col_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_keyboard_row_col = {
+	.name = "keyboard_row_col",
+	.modes = pmx_keyboard_row_col_modes,
+	.mode_count = ARRAY_SIZE(pmx_keyboard_row_col_modes),
+};
+
+/* pad multiplexing for keyboard col5 device */
+static struct pmx_mux_reg pmx_keyboard_col5_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_KBD_COL5_MASK,
+		.value = SPEAR1340_PMX_KBD_COL5_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM1_AND_KBD_COL5_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM1_AND_KBD_COL5_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_keyboard_col5_modes[] = {
+	{
+		.mux_regs = pmx_keyboard_col5_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_keyboard_col5_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_keyboard_col5 = {
+	.name = "keyboard_col5",
+	.modes = pmx_keyboard_col5_modes,
+	.mode_count = ARRAY_SIZE(pmx_keyboard_col5_modes),
+};
+
+/* pad multiplexing for uart0_enh device */
+static struct pmx_mux_reg pmx_uart0_enh_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_GPT_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_UART0_ENH_AND_GPT_REG1_MASK,
+		.value = SPEAR1340_PMX_UART0_ENH_AND_GPT_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart0_enh_modes[] = {
+	{
+		.mux_regs = pmx_uart0_enh_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart0_enh_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_uart0_enh = {
+	.name = "uart0_enh",
+	.modes = pmx_uart0_enh_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart0_enh_modes),
+};
+
+/* pad multiplexing for i2c1 device */
+static struct pmx_mux_reg pmx_i2c1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_I2C1_REG1_MASK,
+		.value = SPEAR1340_PMX_I2C1_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c1_modes[] = {
+	{
+		.mux_regs = pmx_i2c1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_i2c1 = {
+	.name = "i2c1",
+	.modes = pmx_i2c1_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c1_modes),
+};
+
+/* pad multiplexing for spdif_in device */
+static struct pmx_mux_reg pmx_spdif_in_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_SPDIF_IN_REG1_MASK,
+		.value = SPEAR1340_PMX_SPDIF_IN_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_spdif_in_modes[] = {
+	{
+		.mux_regs = pmx_spdif_in_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_spdif_in_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_spdif_in = {
+	.name = "spdif_in",
+	.modes = pmx_spdif_in_modes,
+	.mode_count = ARRAY_SIZE(pmx_spdif_in_modes),
+};
+
+/* pad multiplexing for gpt_0_1 device */
+static struct pmx_mux_reg pmx_gpt_0_1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_GPT_MASK |
+			SPEAR1340_PMX_GPT0_TMR0_CPT_MASK |
+			SPEAR1340_PMX_GPT0_TMR1_CLK_MASK,
+		.value = SPEAR1340_PMX_GPT_MASK |
+			SPEAR1340_PMX_GPT0_TMR0_CPT_MASK |
+			SPEAR1340_PMX_GPT0_TMR1_CLK_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_UART0_ENH_AND_GPT_REG1_MASK |
+			SPEAR1340_PMX_PWM2_AND_GPT0_TMR0_CPT_REG1_MASK |
+			SPEAR1340_PMX_PWM3_AND_GPT0_TMR1_CLK_REG1_MASK,
+		.value = SPEAR1340_PMX_UART0_ENH_AND_GPT_REG1_MASK |
+			SPEAR1340_PMX_PWM2_AND_GPT0_TMR0_CPT_REG1_MASK |
+			SPEAR1340_PMX_PWM3_AND_GPT0_TMR1_CLK_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt_0_1_modes[] = {
+	{
+		.mux_regs = pmx_gpt_0_1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt_0_1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_gpt_0_1 = {
+	.name = "gpt_0_1",
+	.modes = pmx_gpt_0_1_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt_0_1_modes),
+};
+
+/* pad multiplexing for pwm1 device */
+static struct pmx_mux_reg pmx_pwm1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_KBD_COL5_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM1_AND_KBD_COL5_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM1_AND_KBD_COL5_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_pwm1_modes[] = {
+	{
+		.mux_regs = pmx_pwm1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pwm1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pwm1 = {
+	.name = "pwm1",
+	.modes = pmx_pwm1_modes,
+	.mode_count = ARRAY_SIZE(pmx_pwm1_modes),
+};
+
+/* pad multiplexing for pwm2 device */
+static struct pmx_mux_reg pmx_pwm2_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_GPT0_TMR0_CPT_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM2_AND_GPT0_TMR0_CPT_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM2_AND_GPT0_TMR0_CPT_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_pwm2_modes[] = {
+	{
+		.mux_regs = pmx_pwm2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pwm2_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pwm2 = {
+	.name = "pwm2",
+	.modes = pmx_pwm2_modes,
+	.mode_count = ARRAY_SIZE(pmx_pwm2_modes),
+};
+
+/* pad multiplexing for pwm3 device */
+static struct pmx_mux_reg pmx_pwm3_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_GPT0_TMR1_CLK_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM3_AND_GPT0_TMR1_CLK_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM3_AND_GPT0_TMR1_CLK_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_pwm3_modes[] = {
+	{
+		.mux_regs = pmx_pwm3_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pwm3_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pwm3 = {
+	.name = "pwm3",
+	.modes = pmx_pwm3_modes,
+	.mode_count = ARRAY_SIZE(pmx_pwm3_modes),
+};
+
+/* pad multiplexing for pwm0 device */
+static struct pmx_mux_reg pmx_pwm0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_SSP0_CS1_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM0_AND_SSP0_CS1_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM0_AND_SSP0_CS1_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_pwm0_modes[] = {
+	{
+		.mux_regs = pmx_pwm0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pwm0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pwm0 = {
+	.name = "pwm0",
+	.modes = pmx_pwm0_modes,
+	.mode_count = ARRAY_SIZE(pmx_pwm0_modes),
+};
+
+/* pad multiplexing for ssp0_cs1 device */
+static struct pmx_mux_reg pmx_ssp0_cs1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_SSP0_CS1_MASK,
+		.value = SPEAR1340_PMX_SSP0_CS1_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_PWM0_AND_SSP0_CS1_REG1_MASK,
+		.value = SPEAR1340_PMX_PWM0_AND_SSP0_CS1_REG1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_cs1_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_cs1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_cs1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_ssp0_cs1 = {
+	.name = "ssp0_cs1",
+	.modes = pmx_ssp0_cs1_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_cs1_modes),
+};
+
+/* pad multiplexing for vip_mux_cam0 (disables cam0) device */
+static struct pmx_mux_reg pmx_vip_mux_cam0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM0_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_REG2_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM0_REG3_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM0_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_vip_mux_cam0_modes[] = {
+	{
+		.mux_regs = pmx_vip_mux_cam0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_vip_mux_cam0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_vip_mux_cam0 = {
+	.name = "vip_mux_cam0",
+	.modes = pmx_vip_mux_cam0_modes,
+	.mode_count = ARRAY_SIZE(pmx_vip_mux_cam0_modes),
+};
+
+/* pad multiplexing for vip_mux_cam1 (disables cam1) device */
+static struct pmx_mux_reg pmx_vip_mux_cam1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM1_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM1_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM1_REG2_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM1_REG3_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM1_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_vip_mux_cam1_modes[] = {
+	{
+		.mux_regs = pmx_vip_mux_cam1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_vip_mux_cam1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_vip_mux_cam1 = {
+	.name = "vip_mux_cam1",
+	.modes = pmx_vip_mux_cam1_modes,
+	.mode_count = ARRAY_SIZE(pmx_vip_mux_cam1_modes),
+};
+
+/* pad multiplexing for vip_mux_cam2 (disables cam2) device */
+static struct pmx_mux_reg pmx_vip_mux_cam2_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM2_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM2_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM2_REG2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_vip_mux_cam2_modes[] = {
+	{
+		.mux_regs = pmx_vip_mux_cam2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_vip_mux_cam2_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_vip_mux_cam2 = {
+	.name = "vip_mux_cam2",
+	.modes = pmx_vip_mux_cam2_modes,
+	.mode_count = ARRAY_SIZE(pmx_vip_mux_cam2_modes),
+};
+
+/* pad multiplexing for vip_mux_cam3 (disables cam3) device */
+static struct pmx_mux_reg pmx_vip_mux_cam3_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM3_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM3_REG1_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM3_REG1_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM3_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_REG2_MASK |
+			SPEAR1340_PMX_VIP_AND_CAM3_REG2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_vip_mux_cam3_modes[] = {
+	{
+		.mux_regs = pmx_vip_mux_cam3_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_vip_mux_cam3_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_vip_mux_cam3 = {
+	.name = "vip_mux_cam3",
+	.modes = pmx_vip_mux_cam3_modes,
+	.mode_count = ARRAY_SIZE(pmx_vip_mux_cam3_modes),
+};
+
+/* pad multiplexing for cam3 device */
+static struct pmx_mux_reg pmx_cam3_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM3_MASK,
+		.value = SPEAR1340_PMX_CAM3_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM3_REG1_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM3_REG1_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM3_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM3_REG2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cam3_modes[] = {
+	{
+		.mux_regs = pmx_cam3_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cam3_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cam3 = {
+	.name = "cam3",
+	.modes = pmx_cam3_modes,
+	.mode_count = ARRAY_SIZE(pmx_cam3_modes),
+};
+
+/* pad multiplexing for cam2 device */
+static struct pmx_mux_reg pmx_cam2_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM2_MASK,
+		.value = SPEAR1340_PMX_CAM2_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM2_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM2_REG2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cam2_modes[] = {
+	{
+		.mux_regs = pmx_cam2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cam2_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cam2 = {
+	.name = "cam2",
+	.modes = pmx_cam2_modes,
+	.mode_count = ARRAY_SIZE(pmx_cam2_modes),
+};
+
+/* pad multiplexing for cam1 device */
+static struct pmx_mux_reg pmx_cam1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM1_MASK,
+		.value = SPEAR1340_PMX_CAM1_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM1_REG2_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM1_REG2_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM1_REG3_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM1_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cam1_modes[] = {
+	{
+		.mux_regs = pmx_cam1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cam1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cam1 = {
+	.name = "cam1",
+	.modes = pmx_cam1_modes,
+	.mode_count = ARRAY_SIZE(pmx_cam1_modes),
+};
+
+/* pad multiplexing for cam0 device */
+static struct pmx_mux_reg pmx_cam0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_CAM0_MASK,
+		.value = SPEAR1340_PMX_CAM0_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_VIP_AND_CAM0_REG3_MASK,
+		.value = SPEAR1340_PMX_VIP_AND_CAM0_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cam0_modes[] = {
+	{
+		.mux_regs = pmx_cam0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cam0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cam0 = {
+	.name = "cam0",
+	.modes = pmx_cam0_modes,
+	.mode_count = ARRAY_SIZE(pmx_cam0_modes),
+};
+
+/* pad multiplexing for smi device */
+static struct pmx_mux_reg pmx_smi_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_SMI_REG3_MASK,
+		.value = SPEAR1340_PMX_SMI_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_smi_modes[] = {
+	{
+		.mux_regs = pmx_smi_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_smi_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_smi = {
+	.name = "smi",
+	.modes = pmx_smi_modes,
+	.mode_count = ARRAY_SIZE(pmx_smi_modes),
+};
+
+/* pad multiplexing for ssp0 device */
+static struct pmx_mux_reg pmx_ssp0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_SSP0_REG3_MASK,
+		.value = SPEAR1340_PMX_SSP0_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_ssp0 = {
+	.name = "ssp0",
+	.modes = pmx_ssp0_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_modes),
+};
+
+/* pad multiplexing for ssp0_cs2 device */
+static struct pmx_mux_reg pmx_ssp0_cs2_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_SSP0_CS2_MASK,
+		.value = SPEAR1340_PMX_SSP0_CS2_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_TS_AND_SSP0_CS2_REG3_MASK,
+		.value = SPEAR1340_PMX_TS_AND_SSP0_CS2_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_cs2_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_cs2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_cs2_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_ssp0_cs2 = {
+	.name = "ssp0_cs2",
+	.modes = pmx_ssp0_cs2_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_cs2_modes),
+};
+
+/* pad multiplexing for uart0 device */
+static struct pmx_mux_reg pmx_uart0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_UART0_REG3_MASK,
+		.value = SPEAR1340_PMX_UART0_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart0_modes[] = {
+	{
+		.mux_regs = pmx_uart0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_uart0 = {
+	.name = "uart0",
+	.modes = pmx_uart0_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart0_modes),
+};
+
+/* pad multiplexing for uart1 device */
+static struct pmx_mux_reg pmx_uart1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_UART1_REG3_MASK,
+		.value = SPEAR1340_PMX_UART1_REG3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart1_modes[] = {
+	{
+		.mux_regs = pmx_uart1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_uart1 = {
+	.name = "uart1",
+	.modes = pmx_uart1_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart1_modes),
+};
+
+/* pad multiplexing for i2s_in device */
+static struct pmx_mux_reg pmx_i2s_in_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = SPEAR1340_PMX_I2S_IN_REG3_MASK,
+		.value = SPEAR1340_PMX_I2S_IN_REG3_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = SPEAR1340_PMX_I2S_IN_REG4_MASK,
+		.value = SPEAR1340_PMX_I2S_IN_REG4_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2s_in_modes[] = {
+	{
+		.mux_regs = pmx_i2s_in_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2s_in_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_i2s_in = {
+	.name = "i2s_in",
+	.modes = pmx_i2s_in_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2s_in_modes),
+};
+
+/* pad multiplexing for i2s_out device */
+static struct pmx_mux_reg pmx_i2s_out_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = SPEAR1340_PMX_I2S_OUT_REG4_MASK,
+		.value = SPEAR1340_PMX_I2S_OUT_REG4_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2s_out_modes[] = {
+	{
+		.mux_regs = pmx_i2s_out_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2s_out_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_i2s_out = {
+	.name = "i2s_out",
+	.modes = pmx_i2s_out_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2s_out_modes),
+};
+
+/* pad multiplexing for gmac device */
+static struct pmx_mux_reg pmx_gmac_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = SPEAR1340_PMX_GMAC_REG4_MASK,
+		.value = SPEAR1340_PMX_GMAC_REG4_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_GMAC_REG5_MASK,
+		.value = SPEAR1340_PMX_GMAC_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gmac_modes[] = {
+	{
+		.mux_regs = pmx_gmac_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gmac_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_gmac = {
+	.name = "gmac",
+	.modes = pmx_gmac_modes,
+	.mode_count = ARRAY_SIZE(pmx_gmac_modes),
+};
+
+/* pad multiplexing for ssp0_cs3 device */
+static struct pmx_mux_reg pmx_ssp0_cs3_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_SSP0_CS3_REG5_MASK,
+		.value = SPEAR1340_PMX_SSP0_CS3_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_cs3_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_cs3_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_cs3_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_ssp0_cs3 = {
+	.name = "ssp0_cs3",
+	.modes = pmx_ssp0_cs3_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_cs3_modes),
+};
+
+/* pad multiplexing for i2c0 device */
+static struct pmx_mux_reg pmx_i2c0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_I2C0_REG5_MASK,
+		.value = SPEAR1340_PMX_I2C0_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c0_modes[] = {
+	{
+		.mux_regs = pmx_i2c0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_i2c0 = {
+	.name = "i2c0",
+	.modes = pmx_i2c0_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c0_modes),
+};
+
+/* pad multiplexing for cec0 device */
+static struct pmx_mux_reg pmx_cec0_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_CEC0_REG5_MASK,
+		.value = SPEAR1340_PMX_CEC0_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cec0_modes[] = {
+	{
+		.mux_regs = pmx_cec0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cec0_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cec0 = {
+	.name = "cec0",
+	.modes = pmx_cec0_modes,
+	.mode_count = ARRAY_SIZE(pmx_cec0_modes),
+};
+
+/* pad multiplexing for cec1 device */
+static struct pmx_mux_reg pmx_cec1_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_CEC1_REG5_MASK,
+		.value = SPEAR1340_PMX_CEC1_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_cec1_modes[] = {
+	{
+		.mux_regs = pmx_cec1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cec1_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cec1 = {
+	.name = "cec1",
+	.modes = pmx_cec1_modes,
+	.mode_count = ARRAY_SIZE(pmx_cec1_modes),
+};
+
+/* pad multiplexing for spdif_out device */
+static struct pmx_mux_reg pmx_spdif_out_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_SPDIF_OUT_REG5_MASK,
+		.value = SPEAR1340_PMX_SPDIF_OUT_REG5_MASK,
+	}, {
+		.address = SPEAR1340_PERIP_CFG,
+		.mask = SPEAR1340_SPDIF_OUT_ENB_MASK,
+		.value = SPEAR1340_SPDIF_OUT_ENB_MASK,
+	}
+};
+
+static struct pmx_dev_mode pmx_spdif_out_modes[] = {
+	{
+		.mux_regs = pmx_spdif_out_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_spdif_out_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_spdif_out = {
+	.name = "spdif_out",
+	.modes = pmx_spdif_out_modes,
+	.mode_count = ARRAY_SIZE(pmx_spdif_out_modes),
+};
+
+/* pad multiplexing for fsmc_pnor device */
+static struct pmx_mux_reg pmx_fsmc_pnor_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_MCIF_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = SPEAR1340_PMX_FSMC_PNOR_AND_MCIF_REG7_MASK,
+		.value = SPEAR1340_PMX_FSMC_PNOR_AND_MCIF_REG7_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+		.value = SPEAR1340_PMX_FSMC_8BIT_REG8_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_fsmc_pnor_modes[] = {
+	{
+		.mux_regs = pmx_fsmc_pnor_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_fsmc_pnor_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_fsmc_pnor = {
+	.name = "fsmc_pnor",
+	.modes = pmx_fsmc_pnor_modes,
+	.mode_count = ARRAY_SIZE(pmx_fsmc_pnor_modes),
+};
+
+/* pad multiplexing for mcif device */
+static struct pmx_mux_reg pmx_mcif_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_MCIF_MASK,
+		.value = SPEAR1340_PMX_MCIF_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = SPEAR1340_PMX_FSMC_PNOR_AND_MCIF_REG7_MASK |
+			SPEAR1340_PMX_MCIF_REG7_MASK,
+		.value = SPEAR1340_PMX_FSMC_PNOR_AND_MCIF_REG7_MASK |
+			SPEAR1340_PMX_MCIF_REG7_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = SPEAR1340_PMX_MCIF_REG8_MASK,
+		.value = SPEAR1340_PMX_MCIF_REG8_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_mcif_modes[] = {
+	{
+		.mux_regs = pmx_mcif_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_mcif_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_mcif = {
+	.name = "mcif",
+	.modes = pmx_mcif_modes,
+	.mode_count = ARRAY_SIZE(pmx_mcif_modes),
+};
+
+/* Pad multiplexing for sdhci device */
+static struct pmx_mux_reg pmx_sdhci_mux[] = {
+	{
+		.address = SPEAR1340_PERIP_CFG,
+		.mask = SPEAR1340_MCIF_SEL_MASK,
+		.value = SPEAR1340_MCIF_SEL_SD,
+	},
+};
+
+static struct pmx_dev_mode pmx_sdhci_modes[] = {
+	{
+		.mux_regs = pmx_sdhci_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sdhci_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_sdhci = {
+	.name = "sdhci",
+	.modes = pmx_sdhci_modes,
+	.mode_count = ARRAY_SIZE(pmx_sdhci_modes),
+};
+
+/* Pad multiplexing for cf device */
+static struct pmx_mux_reg pmx_cf_mux[] = {
+	{
+		.address = SPEAR1340_PERIP_CFG,
+		.mask = SPEAR1340_MCIF_SEL_MASK,
+		.value = SPEAR1340_MCIF_SEL_CF,
+	},
+};
+
+static struct pmx_dev_mode pmx_cf_modes[] = {
+	{
+		.mux_regs = pmx_cf_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cf_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_cf = {
+	.name = "cf",
+	.modes = pmx_cf_modes,
+	.mode_count = ARRAY_SIZE(pmx_cf_modes),
+};
+
+/* Pad multiplexing for xd device */
+static struct pmx_mux_reg pmx_xd_mux[] = {
+	{
+		.address = SPEAR1340_PERIP_CFG,
+		.mask = SPEAR1340_MCIF_SEL_MASK,
+		.value = SPEAR1340_MCIF_SEL_XD,
+	},
+};
+
+static struct pmx_dev_mode pmx_xd_modes[] = {
+	{
+		.mux_regs = pmx_xd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_xd_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_xd = {
+	.name = "xd",
+	.modes = pmx_xd_modes,
+	.mode_count = ARRAY_SIZE(pmx_xd_modes),
+};
+
+/* pad multiplexing for clcd device */
+static struct pmx_mux_reg pmx_clcd_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_ARM_TRACE_MASK |
+			SPEAR1340_PMX_MIPHY_DBG_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_CLCD_REG5_MASK |
+			SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG5_MASK,
+		.value = SPEAR1340_PMX_CLCD_REG5_MASK |
+			SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG5_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG6_MASK,
+		.value = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG6_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG7_MASK,
+		.value = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG7_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_clcd_modes[] = {
+	{
+		.mux_regs = pmx_clcd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_clcd_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_clcd = {
+	.name = "clcd",
+	.modes = pmx_clcd_modes,
+	.mode_count = ARRAY_SIZE(pmx_clcd_modes),
+};
+
+/* pad multiplexing for arm_trace device */
+static struct pmx_mux_reg pmx_arm_trace_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_ARM_TRACE_MASK,
+		.value = SPEAR1340_PMX_ARM_TRACE_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG5_MASK,
+		.value = SPEAR1340_PMX_CLCD_AND_ARM_TRACE_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_arm_trace_modes[] = {
+	{
+		.mux_regs = pmx_arm_trace_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_arm_trace_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_arm_trace = {
+	.name = "arm_trace",
+	.modes = pmx_arm_trace_modes,
+	.mode_count = ARRAY_SIZE(pmx_arm_trace_modes),
+};
+
+/* pad multiplexing for device group: I2S, SSP0_CS2, CEC0-1, SPDIF out, CLCD */
+static struct pmx_mux_reg pmx_devs_grp_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_MIPHY_DBG_MASK,
+		.value = 0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG5_MASK,
+		.value = SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_devs_grp_modes[] = {
+	{
+		.mux_regs = pmx_devs_grp_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_devs_grp_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_devs_grp = {
+	.name = "devs_grp",
+	.modes = pmx_devs_grp_modes,
+	.mode_count = ARRAY_SIZE(pmx_devs_grp_modes),
+};
+
+/* pad multiplexing for miphy_dbg device */
+static struct pmx_mux_reg pmx_miphy_dbg_mux[] = {
+	{
+		.address = SPEAR1340_PAD_SHARED_IP_EN_1,
+		.mask = SPEAR1340_PMX_MIPHY_DBG_MASK,
+		.value = SPEAR1340_PMX_MIPHY_DBG_MASK,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG5_MASK,
+		.value = SPEAR1340_PMX_DEVS_GRP_AND_MIPHY_DBG_REG5_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_miphy_dbg_modes[] = {
+	{
+		.mux_regs = pmx_miphy_dbg_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_miphy_dbg_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_miphy_dbg = {
+	.name = "miphy_dbg",
+	.modes = pmx_miphy_dbg_modes,
+	.mode_count = ARRAY_SIZE(pmx_miphy_dbg_modes),
+};
+
+/* pad multiplexing for gmii device */
+static struct pmx_mux_reg pmx_gmii_mux[] = {
+	{
+		.address = SPEAR1340_GMAC_CLK_CFG,
+		.mask = SPEAR1340_GMAC_PHY_IF_SEL_MASK,
+		.value = SPEAR1340_GMAC_PHY_IF_GMII_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_gmii_modes[] = {
+	{
+		.mux_regs = pmx_gmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gmii_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_gmii = {
+	.name = "gmii",
+	.modes = pmx_gmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_gmii_modes),
+};
+
+/* pad multiplexing for rgmii device */
+static struct pmx_mux_reg pmx_rgmii_mux[] = {
+	{
+		.address = SPEAR1340_GMAC_CLK_CFG,
+		.mask = SPEAR1340_GMAC_PHY_IF_SEL_MASK,
+		.value = SPEAR1340_GMAC_PHY_IF_RGMII_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_rgmii_modes[] = {
+	{
+		.mux_regs = pmx_rgmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rgmii_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_rgmii = {
+	.name = "rgmii",
+	.modes = pmx_rgmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_rgmii_modes),
+};
+
+/* pad multiplexing for rmii device */
+static struct pmx_mux_reg pmx_rmii_mux[] = {
+	{
+		.address = SPEAR1340_GMAC_CLK_CFG,
+		.mask = SPEAR1340_GMAC_PHY_IF_SEL_MASK,
+		.value = SPEAR1340_GMAC_PHY_IF_RMII_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_rmii_modes[] = {
+	{
+		.mux_regs = pmx_rmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_rmii_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_rmii = {
+	.name = "rmii",
+	.modes = pmx_rmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_rmii_modes),
+};
+
+/* pad multiplexing for sgmii device */
+static struct pmx_mux_reg pmx_sgmii_mux[] = {
+	{
+		.address = SPEAR1340_GMAC_CLK_CFG,
+		.mask = SPEAR1340_GMAC_PHY_IF_SEL_MASK,
+		.value = SPEAR1340_GMAC_PHY_IF_SGMII_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_sgmii_modes[] = {
+	{
+		.mux_regs = pmx_sgmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sgmii_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_sgmii = {
+	.name = "sgmii",
+	.modes = pmx_sgmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_sgmii_modes),
+};
+
+/* pad multiplexing for pcie device */
+static struct pmx_mux_reg pmx_pcie_mux[] = {
+	{
+		.address = SPEAR1340_PCIE_SATA_CFG,
+		.mask = SPEAR1340_SATA_PCIE_CFG_MASK,
+		.value = SPEAR1340_PCIE_CFG_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_pcie_modes[] = {
+	{
+		.mux_regs = pmx_pcie_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_pcie_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_pcie = {
+	.name = "pcie",
+	.modes = pmx_pcie_modes,
+	.mode_count = ARRAY_SIZE(pmx_pcie_modes),
+};
+
+/* pad multiplexing for sata device */
+static struct pmx_mux_reg pmx_sata_mux[] = {
+	{
+		.address = SPEAR1340_PCIE_SATA_CFG,
+		.mask = SPEAR1340_SATA_PCIE_CFG_MASK,
+		.value = SPEAR1340_SATA_CFG_VAL,
+	},
+};
+
+static struct pmx_dev_mode pmx_sata_modes[] = {
+	{
+		.mux_regs = pmx_sata_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sata_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_sata = {
+	.name = "sata",
+	.modes = pmx_sata_modes,
+	.mode_count = ARRAY_SIZE(pmx_sata_modes),
+};
+
+/* padmux devices to enable */
+static void config_io_pads(struct pmx_dev **devs, u8 count, bool to_device)
+{
+	struct pmx_mux_reg *mux_reg;
+	int ret, i, j, k;
+
+	/*
+	 * Use pas mux framework to program device pads as gpios or let
+	 * them under device control. Turn them to device pads if
+	 * to_device is true else reset to make them as gpio.
+	 */
+	for (i = 0; i < count; i++) {
+		for (j = 0; j < devs[i]->mode_count; j++) {
+			for (k = 0; k < devs[i]->modes[j].mux_reg_cnt; k++) {
+				mux_reg = &devs[i]->modes[j].mux_regs[k];
+				mux_reg->value = to_device? mux_reg->mask : 0x0;
+			}
+		}
+	}
+
+	ret = pmx_devs_enable(devs, count);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
+
+/* Add spear1340 specific devices here */
+/* Add Amba Devices */
+/* uart device registeration */
+static struct dw_dma_slave uart1_dma_param[] = {
+	{
+		/* Tx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR1340_DMA_REQ_UART1_TX),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_MEMORY,
+		.dst_master = SPEAR1340_DMA_MASTER_UART1,
+	}, {
+		/* Rx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_UART1_RX),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_UART1,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct amba_pl011_data uart1_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_tx_param = &uart1_dma_param[0],
+	.dma_rx_param = &uart1_dma_param[1],
+};
+
+/* uart1 device registeration */
+struct amba_device spear1340_uart1_device = {
+	.dev = {
+		.init_name = "uart1",
+		.platform_data = &uart1_data,
+	},
+	.res = {
+		.start = SPEAR1340_UART1_BASE,
+		.end = SPEAR1340_UART1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR1340_IRQ_UART1, NO_IRQ},
+};
+
+/* Add Platform Devices */
+
+/* camera reset handler */
+static void camif_enable(int cam_id, bool enable)
+{
+	u32 val = readl(VA_SPEAR1340_PERIP3_SW_RST);
+	u32 mask = 0;
+
+	switch (cam_id) {
+	case 0:
+		mask = SPEAR1340_CAM0_RST;
+		break;
+	case 1:
+		mask = SPEAR1340_CAM1_RST;
+		break;
+	case 2:
+		mask = SPEAR1340_CAM2_RST;
+		break;
+	case 3:
+		mask = SPEAR1340_CAM3_RST;
+		break;
+	}
+
+	if (!enable)
+		writel(val | mask, VA_SPEAR1340_PERIP3_SW_RST);
+	else
+		writel(val & ~mask, VA_SPEAR1340_PERIP3_SW_RST);
+}
+
+/* camera interface 0 device registeration */
+static struct camif_config_data cam0_data = {
+	.sync_type = EXTERNAL_SYNC,
+	.vsync_polarity = ACTIVE_HIGH,
+	.hsync_polarity = ACTIVE_HIGH,
+	.pclk_polarity = ACTIVE_LOW,
+	.capture_mode = VIDEO_MODE_ALL_FRAMES,
+	.burst_size = BURST_SIZE_128,
+	.channel = EVEN_CHANNEL,
+	.camif_module_enable = camif_enable,
+};
+
+static struct dw_dma_slave camif0_dma_param[] = {
+	{
+		/* odd line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM0_ODD),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}, {
+		/* even line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM0_EVEN),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct camif_controller camif0_platform_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_odd_param = &camif0_dma_param[0],
+	.dma_even_param = &camif0_dma_param[1],
+	.config = &cam0_data,
+};
+
+static struct resource camif0_resources[] = {
+	{
+		.start = SPEAR1340_CAM0_BASE,
+		.end = SPEAR1340_CAM0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "line_end_irq",
+		.start = SPEAR1340_IRQ_CAM0_CE,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.name = "frame_start_frame_end_irq",
+		.start = SPEAR1340_IRQ_CAM0_FVE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_camif0_device = {
+	.name = "spear_camif",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &camif0_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(camif0_resources),
+	.resource = camif0_resources,
+};
+
+/* camera interface 1 device registeration */
+static struct camif_config_data cam1_data = {
+	.sync_type = EXTERNAL_SYNC,
+	.vsync_polarity = ACTIVE_HIGH,
+	.hsync_polarity = ACTIVE_HIGH,
+	.pclk_polarity = ACTIVE_LOW,
+	.capture_mode = VIDEO_MODE_ALL_FRAMES,
+	.burst_size = BURST_SIZE_128,
+	.channel = EVEN_CHANNEL,
+	.camif_module_enable = camif_enable,
+};
+
+static struct dw_dma_slave camif1_dma_param[] = {
+	{
+		/* odd line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM1_ODD),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}, {
+		/* even line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM1_EVEN),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct camif_controller camif1_platform_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_odd_param = &camif1_dma_param[0],
+	.dma_even_param = &camif1_dma_param[1],
+	.config = &cam1_data,
+};
+
+static struct resource camif1_resources[] = {
+	{
+		.start = SPEAR1340_CAM1_BASE,
+		.end = SPEAR1340_CAM1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "line_end_irq",
+		.start = SPEAR1340_IRQ_CAM1_CE,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.name = "frame_start_frame_end_irq",
+		.start = SPEAR1340_IRQ_CAM1_FVE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_camif1_device = {
+	.name = "spear_camif",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &camif1_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(camif1_resources),
+	.resource = camif1_resources,
+};
+
+/* camera interface 2 device registeration */
+static struct camif_config_data cam2_data = {
+	.sync_type = EXTERNAL_SYNC,
+	.vsync_polarity = ACTIVE_HIGH,
+	.hsync_polarity = ACTIVE_HIGH,
+	.pclk_polarity = ACTIVE_LOW,
+	.capture_mode = VIDEO_MODE_ALL_FRAMES,
+	.burst_size = BURST_SIZE_128,
+	.channel = EVEN_CHANNEL,
+	.camif_module_enable = camif_enable,
+};
+
+static struct dw_dma_slave camif2_dma_param[] = {
+	{
+		/* odd line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM2_ODD),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}, {
+		/* even line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM2_EVEN),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct camif_controller camif2_platform_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_odd_param = &camif2_dma_param[0],
+	.dma_even_param = &camif2_dma_param[1],
+	.config = &cam2_data,
+};
+
+static struct resource camif2_resources[] = {
+	{
+		.start = SPEAR1340_CAM2_BASE,
+		.end = SPEAR1340_CAM2_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "line_end_irq",
+		.start = SPEAR1340_IRQ_CAM2_CE,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.name = "frame_start_frame_end_irq",
+		.start = SPEAR1340_IRQ_CAM2_FVE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_camif2_device = {
+	.name = "spear_camif",
+	.id = 2,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &camif2_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(camif2_resources),
+	.resource = camif2_resources,
+};
+
+
+/* camera interface 3 device registeration */
+static struct camif_config_data cam3_data = {
+	.sync_type = EXTERNAL_SYNC,
+	.vsync_polarity = ACTIVE_HIGH,
+	.hsync_polarity = ACTIVE_HIGH,
+	.pclk_polarity = ACTIVE_LOW,
+	.capture_mode = VIDEO_MODE_ALL_FRAMES,
+	.burst_size = BURST_SIZE_128,
+	.channel = EVEN_CHANNEL,
+	.camif_module_enable = camif_enable,
+};
+
+static struct dw_dma_slave camif3_dma_param[] = {
+	{
+		/* odd line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM3_ODD),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}, {
+		/* even line */
+		.dma_dev = &spear13xx_dmac_device[1].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_CAM3_EVEN),
+		.cfg_lo = 0,
+		.src_master = SPEAR1340_DMA_MASTER_CAM,
+		.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct camif_controller camif3_platform_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_odd_param = &camif3_dma_param[0],
+	.dma_even_param = &camif3_dma_param[1],
+	.config = &cam3_data,
+};
+
+static struct resource camif3_resources[] = {
+	{
+		.start = SPEAR1340_CAM3_BASE,
+		.end = SPEAR1340_CAM3_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "line_end_irq",
+		.start = SPEAR1340_IRQ_CAM3_CE,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.name = "frame_start_frame_end_irq",
+		.start = SPEAR1340_IRQ_CAM3_FVE,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_camif3_device = {
+	.name = "spear_camif",
+	.id = 3,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &camif3_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(camif3_resources),
+	.resource = camif3_resources,
+};
+
+/* CEC device registration */
+static struct resource cec0_resources[] = {
+	{
+		.start = SPEAR1340_CEC0_BASE,
+		.end = SPEAR1340_CEC0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_CEC0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_cec0_device = {
+	.name = "spear_cec",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(cec0_resources),
+	.resource = cec0_resources,
+};
+
+/* CEC1 device registration */
+static struct resource cec1_resources[] = {
+	{
+		.start = SPEAR1340_CEC1_BASE,
+		.end = SPEAR1340_CEC1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_CEC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_cec1_device = {
+	.name = "spear_cec",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(cec1_resources),
+	.resource = cec1_resources,
+};
+
+/* cpufreq platform device */
+static u32 cpu_freq_tbl[] = {
+	166000, /* 166 MHZ */
+	200000, /* 200 MHZ */
+	250000, /* 250 MHZ */
+	332000, /* 332 MHZ */
+	400000, /* 400 MHZ */
+	500000, /* 500 MHZ */
+	600000, /* 600 MHZ */
+};
+
+static struct spear_cpufreq_pdata cpufreq_pdata = {
+	.cpu_freq_table = cpu_freq_tbl,
+	.tbl_len = ARRAY_SIZE(cpu_freq_tbl),
+	/* Program the actual transition time for worstcase */
+	.transition_latency = 250 * 1000, /*250 us*/
+};
+
+struct platform_device spear1340_cpufreq_device = {
+	.name = "cpufreq-spear",
+	.id = -1,
+	.dev = {
+		.platform_data = &cpufreq_pdata,
+	},
+};
+
+/* SPEAr GPIO Buttons Info */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+/* SPEAr GPIO Buttons definition */
+#define SPEAR_GPIO_BTN9	9
+
+static struct gpio_keys_button spear_gpio_keys_table[] = {
+	{
+		.code = BTN_0,
+		.gpio = SPEAR_GPIO_BTN9,
+		.active_low = 0,
+		.desc = "gpio-keys: BTN0",
+		.type = EV_KEY,
+		.wakeup = 1,
+		.debounce_interval = 20,
+	},
+};
+
+static struct gpio_keys_platform_data spear_gpio_keys_data = {
+	.buttons = spear_gpio_keys_table,
+	.nbuttons = ARRAY_SIZE(spear_gpio_keys_table),
+};
+
+struct platform_device spear1340_gpiokeys_device = {
+	.name = "gpio-keys",
+	.dev = {
+		.platform_data = &spear_gpio_keys_data,
+	},
+};
+#endif
+
+static struct resource nand_resources[] = {
+	{
+		.name = "nand_data",
+		.start = SPEAR1340_FSMC_NAND_BASE,
+		.end = SPEAR1340_FSMC_NAND_BASE + SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "fsmc_regs",
+		.start = SPEAR13XX_FSMC_BASE,
+		.end = SPEAR13XX_FSMC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear1340_nand_device = {
+	.name = "fsmc-nand",
+	.id = -1,
+	.resource = nand_resources,
+	.num_resources = ARRAY_SIZE(nand_resources),
+};
+
+/*
+ * This routine does i2c bus recovery as specified in the
+ * i2c protocol Rev. 03 section 3.16 titled "Bus clear"
+ */
+static void spear1340_i2c_dw_recover_bus(void *data)
+{
+	struct platform_device *pdev = data;
+	int i2c_clk_gpio, i = 0, ret = 0;
+	int val = 0;
+	struct pmx_dev *pmxdev;
+
+	if (pdev->id == 0) {
+		i2c_clk_gpio = PLGPIO_134;
+		pmxdev = &spear1340_pmx_i2c0;
+	} else if (pdev->id == 1) {
+		i2c_clk_gpio = PLGPIO_23;
+		pmxdev = &spear1340_pmx_i2c1;
+	} else {
+		pr_err("Invalid I2C device id\n");
+		return;
+	}
+
+	ret = gpio_request(i2c_clk_gpio, "i2c-sclk");
+	if (ret) {
+		pr_err("couldn't req gpio %d\n", ret);
+		return;
+	}
+
+	ret = gpio_direction_output(i2c_clk_gpio, 0);
+	if (ret) {
+		pr_err("couldn't set i2s-sclk low: %d\n", ret);
+		goto free_gpio;
+	}
+
+	/* take I2C SLCK control as pl-gpio */
+	config_io_pads(&pmxdev, 1, false);
+
+	/* Send high and low on the I2C SCL line */
+	for (i = 0; i < 18; i++) {
+		gpio_set_value(i2c_clk_gpio, val);
+		val = !val;
+		msleep(100);
+	}
+
+	/* restore I2C SLCK control to I2C controller*/
+	config_io_pads(&pmxdev, 1, true);
+
+free_gpio:
+	gpio_free(i2c_clk_gpio);
+
+}
+
+/* i2c device registeration */
+static struct resource i2c1_resources[] = {
+	{
+		.start = SPEAR1340_I2C1_BASE,
+		.end = SPEAR1340_I2C1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_I2C1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct i2c_dw_pdata spear1340_i2c_dw_pdata = {
+	.i2c_recover_bus = spear1340_i2c_dw_recover_bus,
+};
+
+struct platform_device spear1340_i2c1_device = {
+	.name = "i2c_designware",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &spear1340_i2c_dw_pdata,
+	},
+	.num_resources = ARRAY_SIZE(i2c1_resources),
+	.resource = i2c1_resources,
+};
+
+/* i2s:play device registration */
+static struct dw_dma_slave i2s_play_dma_data = {
+	/* Play */
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.cfg_hi = DWC_CFGH_DST_PER(SPEAR1340_DMA_REQ_I2S_TX),
+	.cfg_lo = 0,
+	.src_master = SPEAR1340_DMA_MASTER_MEMORY,
+	.dst_master = SPEAR1340_DMA_MASTER_I2S_PLAY,
+};
+
+static struct i2s_platform_data i2s_play_data = {
+	.cap = PLAY,
+	.channel = 8,
+	.play_dma_data = &i2s_play_dma_data,
+	.snd_fmts = SNDRV_PCM_FMTBIT_S16_LE,
+	.snd_rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000),
+	.filter = dw_dma_filter,
+	.i2s_clk_cfg = audio_clk_config,
+};
+
+static struct resource i2s_play_resources[] = {
+	{
+		.start	= SPEAR1340_I2S_PLAY_BASE,
+		.end	= SPEAR1340_I2S_PLAY_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "play_irq",
+		.start	= SPEAR1340_IRQ_I2S_PLAY_OR_M,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device spear1340_i2s_play_device = {
+	.name = "designware-i2s",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &i2s_play_data,
+	},
+	.num_resources = ARRAY_SIZE(i2s_play_resources),
+	.resource = i2s_play_resources,
+};
+
+/* i2s:record device registeration */
+static struct dw_dma_slave i2s_capture_dma_data = {
+	/* Record */
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_I2S_RX),
+	.cfg_lo = 0,
+	.src_master = SPEAR1340_DMA_MASTER_I2S_REC,
+	.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+};
+
+static struct i2s_platform_data i2s_capture_data = {
+	.cap = RECORD,
+	.channel = 8,
+	.capture_dma_data = &i2s_capture_dma_data,
+	.snd_fmts = SNDRV_PCM_FMTBIT_S16_LE,
+	.snd_rates = (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_48000),
+	.filter = dw_dma_filter,
+	.i2s_clk_cfg = audio_clk_config,
+};
+
+static struct resource i2s_record_resources[] = {
+	{
+		.start	= SPEAR1340_I2S_REC_BASE,
+		.end	= SPEAR1340_I2S_REC_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "record_irq",
+		.start	= SPEAR1340_IRQ_I2S_REC_OR_S,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_i2s_record_device = {
+	.name = "designware-i2s",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &i2s_capture_data,
+	},
+	.num_resources = ARRAY_SIZE(i2s_record_resources),
+	.resource = i2s_record_resources,
+};
+
+/* plgpio */
+static struct plgpio_platform_data plgpio_plat_data = {
+	.gpio_base = 16,
+	.irq_base = SPEAR_PLGPIO_INT_BASE,
+	.gpio_count = SPEAR_PLGPIO_COUNT,
+	.regs = {
+		.enb = -1,
+		.wdata = SPEAR1340_PLGPIO_WDATA_OFF,
+		.dir = SPEAR1340_PLGPIO_DIR_OFF,
+		.rdata = SPEAR1340_PLGPIO_RDATA_OFF,
+		.ie = SPEAR1340_PLGPIO_IE_OFF,
+		.mis = SPEAR1340_PLGPIO_MIS_OFF,
+		.eit = SPEAR1340_PLGPIO_EIT_OFF,
+	},
+};
+
+static struct resource plgpio_resources[] = {
+	{
+		.start = SPEAR1340_PLGPIO_BASE,
+		.end = SPEAR1340_PLGPIO_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_PLGPIO,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_plgpio_device = {
+	.name = "plgpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &plgpio_plat_data,
+	},
+	.num_resources = ARRAY_SIZE(plgpio_resources),
+	.resource = plgpio_resources,
+};
+
+/* pwm device registeration */
+static struct resource pwm_resources[] = {
+	{
+		.start = SPEAR1340_PWM_BASE,
+		.end = SPEAR1340_PWM_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear1340_pwm_device = {
+	.name = "pwm",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pwm_resources),
+	.resource = pwm_resources,
+};
+
+/* SATA device registration */
+void sata_miphy_exit(struct device *dev)
+{
+	writel(0, VA_SPEAR1340_PCIE_SATA_CFG);
+	writel(0, VA_SPEAR1340_PCIE_MIPHY_CFG);
+
+	/* Enable PCIE SATA Controller reset */
+	writel((readl(VA_SPEAR1340_PERIP1_SW_RST) | (0x1000)),
+			VA_SPEAR1340_PERIP1_SW_RST);
+	msleep(20);
+	/* Switch off sata power domain */
+	writel((readl(VA_SPEAR1340_PCM_CFG) & (~0x800)),
+			VA_SPEAR1340_PCM_CFG);
+	msleep(20);
+}
+
+static int sata_miphy_init(struct device *dev, void __iomem *addr)
+{
+	writel(SPEAR1340_SATA_CFG_VAL, VA_SPEAR1340_PCIE_SATA_CFG);
+	writel(SPEAR1340_PCIE_SATA_MIPHY_CFG_SATA_25M_CRYSTAL_CLK,
+			VA_SPEAR1340_PCIE_MIPHY_CFG);
+	/* Switch on sata power domain */
+	writel((readl(VA_SPEAR1340_PCM_CFG) | (0x800)),
+			VA_SPEAR1340_PCM_CFG);
+	msleep(20);
+	/* Disable PCIE SATA Controller reset */
+	writel((readl(VA_SPEAR1340_PERIP1_SW_RST) & (~0x1000)),
+			VA_SPEAR1340_PERIP1_SW_RST);
+	msleep(20);
+
+	return 0;
+}
+
+int sata_suspend(struct device *dev)
+{
+	if (dev->power.power_state.event == PM_EVENT_FREEZE)
+		return 0;
+
+	sata_miphy_exit(dev);
+
+	return 0;
+}
+
+int sata_resume(struct device *dev)
+{
+	if (dev->power.power_state.event == PM_EVENT_THAW)
+		return 0;
+
+	return sata_miphy_init(dev, NULL);
+}
+
+static struct resource sata_resources[] = {
+	{
+		.start = SPEAR1340_SATA_BASE,
+		.end = SPEAR1340_SATA_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_SATA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct ahci_platform_data sata_pdata = {
+	.init = sata_miphy_init,
+	.exit = sata_miphy_exit,
+	.suspend = sata_suspend,
+	.resume = sata_resume,
+};
+
+static u64 ahci_dmamask = DMA_BIT_MASK(32);
+
+struct platform_device spear1340_sata0_device = {
+	.name = "ahci",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(sata_resources),
+	.resource = sata_resources,
+	.dev = {
+		.platform_data = &sata_pdata,
+		.dma_mask = &ahci_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+
+/* spdif-in device registeration */
+static void spdif_in_reset(void)
+{
+	writel(readl(VA_SPEAR1340_PERIP3_SW_RST) | SPEAR1340_SPDIF_IN_RST,
+		VA_SPEAR1340_PERIP3_SW_RST);
+
+	writel(readl(VA_SPEAR1340_PERIP3_SW_RST) & ~SPEAR1340_SPDIF_IN_RST,
+		VA_SPEAR1340_PERIP3_SW_RST);
+}
+
+static struct dw_dma_slave spdif_in_dma_data = {
+	/* Record */
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.cfg_hi = DWC_CFGH_SRC_PER(SPEAR1340_DMA_REQ_SPDIF_RX),
+	.cfg_lo = 0,
+	.src_master = SPEAR1340_DMA_MASTER_SPDIF,
+	.dst_master = SPEAR1340_DMA_MASTER_MEMORY,
+};
+
+static struct spdif_platform_data spdif_in_data = {
+	.dma_params = &spdif_in_dma_data,
+	.filter = dw_dma_filter,
+	.reset_perip = spdif_in_reset,
+};
+
+static struct resource spdif_in_resources[] = {
+	{
+		.start = SPEAR1340_SPDIF_IN_BASE,
+		.end = SPEAR1340_SPDIF_IN_BASE + SZ_128 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_SPDIF_IN_FIFO_BASE,
+		.end = SPEAR1340_SPDIF_IN_FIFO_BASE + SZ_64 - 1,
+		.flags = IORESOURCE_IO,
+	}, {
+		.start = SPEAR1340_IRQ_SPDIF_IN,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_spdif_in_device = {
+	.name = "spdif-in",
+	.id = -1,
+	.dev.platform_data = &spdif_in_data,
+	.num_resources = ARRAY_SIZE(spdif_in_resources),
+	.resource = spdif_in_resources,
+};
+
+/* spdif-out device registeration */
+static struct dw_dma_slave spdif_out_dma_data = {
+	/* Play */
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.cfg_hi = DWC_CFGH_DST_PER(SPEAR1340_DMA_REQ_SPDIF_TX),
+	.cfg_lo = 0,
+	.src_master = SPEAR1340_DMA_MASTER_MEMORY,
+	.dst_master = SPEAR1340_DMA_MASTER_SPDIF,
+};
+
+static struct spdif_platform_data spdif_out_data = {
+	.dma_params = &spdif_out_dma_data,
+	.filter = dw_dma_filter,
+};
+
+static struct resource spdif_out_resources[] = {
+	{
+		.start = SPEAR1340_SPDIF_OUT_BASE,
+		.end = SPEAR1340_SPDIF_OUT_BASE + SZ_128 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_SPDIF_OUT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_spdif_out_device = {
+	.name = "spdif-out",
+	.id = -1,
+	.dev.platform_data = &spdif_out_data,
+	.num_resources = ARRAY_SIZE(spdif_out_resources),
+	.resource = spdif_out_resources,
+};
+
+/* SPEAr Thermal Sensor Platform Data for 1340 */
+static struct resource spear1340_thermal_resources[] = {
+	{
+		.start = SPEAR1340_THSENS_CFG,
+		.end = SPEAR1340_THSENS_CFG + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct spear_thermal_pdata spear1340_thermal_pdata = {
+	.thermal_flags = SPEAR1340_THERMAL_CONFIG_FLAGS,
+};
+
+struct platform_device spear1340_thermal_device = {
+	.name = "spear_thermal",
+	.id = -1,
+	.dev = {
+		.platform_data = &spear1340_thermal_pdata,
+	},
+	.num_resources = ARRAY_SIZE(spear1340_thermal_resources),
+	.resource = spear1340_thermal_resources,
+};
+
+static int spear1340_otg_phy_init(void)
+{
+	u32 temp, msec = 1000;
+
+	/* phy por deassert */
+	temp = readl(VA_SPEAR1340_USBPHY_GEN_CFG);
+	temp &= ~SPEAR1340_USBPHYPOR;
+	writel(temp, VA_SPEAR1340_USBPHY_GEN_CFG);
+
+	/* phy clock enable */
+	temp = readl(VA_SPEAR1340_USBPHY_GEN_CFG);
+	temp |= SPEAR1340_USBPHYRST;
+	writel(temp, VA_SPEAR1340_USBPHY_GEN_CFG);
+
+	/* wait for pll lock */
+	while (!(readl(VA_SPEAR1340_USBPHY_GEN_CFG) & SPEAR1340_USBPLLLOCK)) {
+		if (msec--) {
+			pr_err(" Problem with USB PHY PLL Lock\n");
+			return -ETIMEDOUT;
+		}
+		udelay(1);
+	}
+
+	/* otg prstnt deassert */
+	temp = readl(VA_SPEAR1340_USBPHY_GEN_CFG);
+	temp |= SPEAR1340_USBPRSNT;
+	writel(temp, VA_SPEAR1340_USBPHY_GEN_CFG);
+
+	/* OTG HCLK Disable */
+	temp = readl(VA_SPEAR1340_PERIP1_CLK_ENB);
+	temp &= ~(1 << SPEAR1340_UOC_CLK_ENB);
+	writel(temp, VA_SPEAR1340_PERIP1_CLK_ENB);
+
+	/* OTG HRESET deassert */
+	temp = readl(VA_SPEAR1340_PERIP1_SW_RST);
+	temp &= ~(1 << SPEAR1340_UOC_RST_ENB);
+	writel(temp, VA_SPEAR1340_PERIP1_SW_RST);
+
+	/* OTG HCLK Enable */
+	temp = readl(VA_SPEAR1340_PERIP1_CLK_ENB);
+	temp |= (1 << SPEAR1340_UOC_CLK_ENB);
+	writel(temp, VA_SPEAR1340_PERIP1_CLK_ENB);
+
+	return 0;
+}
+
+static int spear1340_otg_param_init(struct core_params *params)
+{
+	int i;
+
+	/* Common Dev RX fifo Size : 0x400 */
+	params->dev_rx_fifo_size = 0x400;
+	/* Dev TX fifo Size for fifo 0: 0x300 */
+	params->dev_nperio_tx_fifo_size = 0x300;
+	/* TX fifo Size for fifo 1-7: 0x200 */
+	params->fifo_number = 7;
+	for (i = 1; i <= 7; i++)
+		params->dev_tx_fifo_size[i - 1] = 0x200;
+
+	/* Common Host RX fifo Size : 0x400 */
+	params->host_rx_fifo_size = 0x400;
+	/* Host TX fifo Size for fifo 0: 0x400 */
+	params->host_nperio_tx_fifo_size = 0x400;
+	/* Host Periodic TX fifo Size for fifo 0: 0x400 */
+	params->host_perio_tx_fifo_size = 0x400;
+
+	return 0;
+}
+
+/* OTG device registration */
+static struct resource otg_resources[] = {
+	{
+		.start = SPEAR1340_UOC_BASE,
+		.end = SPEAR1340_UOC_BASE + SZ_256K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_UOC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct dwc_otg_plat_data otg_platform_data = {
+	.phy_init = spear1340_otg_phy_init,
+	.param_init = spear1340_otg_param_init,
+};
+
+static u64 otg_dmamask = ~0;
+struct platform_device spear1340_otg_device = {
+	.name = "dwc_otg",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &otg_dmamask,
+		.platform_data = &otg_platform_data,
+	},
+	.num_resources = ARRAY_SIZE(otg_resources),
+	.resource = otg_resources,
+};
+
+/* video input parallel port registeration */
+static unsigned long vb_base;
+static unsigned long vb_size = VIP_TOTAL_BUFFER_SIZE;
+
+unsigned long vip_buffer_fixup(struct meminfo *mi)
+{
+	vb_base = reserve_mem(mi, ALIGN(vb_size, SZ_1M));
+	if (vb_base == ~0) {
+		pr_err("Unable to allocate videobufs in fixup\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+void vip_set_vb_base(struct vip_plat_data *pdata)
+{
+	pdata->vb_base = vb_base;
+	pdata->vb_size = vb_size;
+}
+
+static struct resource vip_resources[] = {
+	{
+		.start = SPEAR1340_VIP_BASE,
+		.end = SPEAR1340_VIP_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "fifo_overflow_irq",
+		.start = SPEAR1340_IRQ_VIP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_vip_device = {
+	.name = "spear_vip",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(vip_resources),
+	.resource = vip_resources,
+};
+
+#ifdef CONFIG_DRM_MALI
+struct platform_device spear1340_device_mali_drm = {
+        .name = "mali_drm",
+        .id   = -1,
+};
+#endif
+
+static struct resource spear1340_video_dec_resources[] = {
+	{
+		.start = SPEAR1340_VIDEO_DEC_BASE,
+		.end =  SPEAR1340_VIDEO_DEC_BASE + (4*100),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR1340_IRQ_VIDEO_DEC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear1340_video_dec_device = {
+	.name = "video_dec",
+	.id   = -1,
+	.num_resources = ARRAY_SIZE(spear1340_video_dec_resources),
+	.resource = spear1340_video_dec_resources,
+};
+
+static int spear1340_sys_clk_init(void)
+{
+	struct clk *sys_pclk, *ahb_pclk, *sys_clk, *ahb_clk;
+	int ret = 0;
+	const char *sys_clk_src[] = {
+		"sys_synth_clk",
+		"pll1_clk",
+		"pll2_clk",
+		"pll3_clk",
+	};
+	const char *ahb_clk_src[] = {
+		"amba_synth_clk",
+		"cpu_clk_div3",
+	};
+
+	/*
+	 * If we need to run cpu at 600 MHz we need to have an alternate
+	 * pll (other than pll1)
+	 * So,
+	 * pll1 - would be used to feed all synthesizers and AHB
+	 * (through AHB synthesizer)
+	 * pll2 - would feed gmac (for 125 MHz)
+	 * pll3 - would be used to feed cpu
+	 *
+	 * Note: I2S which was using PLL3 as the source clock is
+	 * impacted by this. The possibility is to use an external
+	 * oscillator (not preset on board as of now) for I2S.
+	 */
+	sys_pclk = clk_get(NULL, sys_clk_src[3]);
+	if (IS_ERR(sys_pclk)) {
+		ret = PTR_ERR(sys_pclk);
+		goto fail_get_sys_pclk;
+	}
+
+	/* Get the amba synthesizer as the clock source for ahb clock */
+	ahb_pclk = clk_get(NULL, ahb_clk_src[0]);
+	if (IS_ERR(ahb_pclk)) {
+		ret = PTR_ERR(ahb_pclk);
+		goto fail_get_ahb_pclk;
+	}
+
+	/* Get the system clock */
+	sys_clk = clk_get(NULL, "sys_clk");
+	if (IS_ERR(sys_clk)) {
+		ret = PTR_ERR(sys_clk);
+		goto fail_get_sysclk;
+	}
+
+	/* Get the ahb clock */
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	if (IS_ERR(ahb_clk)) {
+		ret = PTR_ERR(ahb_clk);
+		goto fail_get_ahb_clk;
+	}
+
+	if (clk_set_rate(sys_pclk, 1200000000)) {
+		ret = -EPERM;
+		pr_err("SPEAr1340: Failed to set system clock rate\n");
+		goto fail_sys_set_rate;
+	}
+
+	if (clk_set_rate(ahb_pclk, 166000000)) {
+		ret = -EPERM;
+		pr_err("SPEAr1340: Failed to set AHB rate\n");
+		goto fail_sys_set_rate;
+	}
+
+	if (clk_enable(sys_pclk)) {
+		ret = -ENODEV;
+		goto fail_sys_set_rate;
+	}
+
+	if (clk_enable(ahb_pclk)) {
+		ret = -ENODEV;
+		goto fail_en_sys_clk;
+	}
+
+	/* Set the amba synth as parent for ahb clk */
+	if (clk_set_parent(ahb_clk, ahb_pclk)) {
+		ret = -EPERM;
+		pr_err("SPEAr1340: Failed to set AHB parent\n");
+		goto fail_ahb_set_parent;
+	}
+
+	/* Set the sys synth as parent for sys clk */
+	if (clk_set_parent(sys_clk, sys_pclk)) {
+		ret = -EPERM;
+		pr_err("SPEAr1340: Failed to set sys clk parent\n");
+		goto fail_sys_set_parent;
+	}
+
+	/* put back all the clocks */
+	goto fail_sys_set_rate;
+
+fail_sys_set_parent:
+fail_ahb_set_parent:
+	clk_disable(ahb_pclk);
+fail_en_sys_clk:
+	clk_disable(sys_pclk);
+fail_sys_set_rate:
+	clk_put(ahb_clk);
+fail_get_ahb_clk:
+	clk_put(sys_clk);
+fail_get_sysclk:
+	clk_put(ahb_pclk);
+fail_get_ahb_pclk:
+	clk_put(sys_pclk);
+fail_get_sys_pclk:
+	return ret;
+}
+
+/* gpio Configure in pull-down mode for clcd */
+static struct pmx_mux_reg gpio_pd_mux[] = {
+	{
+		.address = SPEAR1340_PAD_PU_CFG_5,
+		.mask = 0xFFFFFC00,
+		.value = 0XFFFFFC00,
+	}, {
+		.address = SPEAR1340_PAD_PU_CFG_6,
+		.mask = 0xFFFFFFFF,
+		.value = 0XFFFFFFFF,
+	}, {
+		.address = SPEAR1340_PAD_PD_CFG_5,
+		.mask = 0xFFFFFC00,
+		.value = ~0XFFFFFC00,
+	}, {
+		.address = SPEAR1340_PAD_PD_CFG_6,
+		.mask = 0xFFFFFFFF,
+		.value = ~0XFFFFFFFF,
+	},
+};
+
+static struct pmx_dev_mode gpio_pd_modes[] = {
+	{
+		.mux_regs = gpio_pd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(gpio_pd_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_clcd_gpio_pd = {
+	.name = "gpio",
+	.modes = gpio_pd_modes,
+	.mode_count = ARRAY_SIZE(gpio_pd_modes),
+};
+
+/* clcd/gpio pad selection */
+static struct pmx_mux_reg clcd_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = 0xFFFFF800,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = 0xFFFFFFFF,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = 0x00000001,
+	},
+
+};
+
+static struct pmx_dev_mode clcd_plgpios_modes[] = {
+	{
+		.mux_regs = clcd_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(clcd_plgpios_mux),
+	},
+};
+
+struct pmx_dev clcd_pmx_plgpios = {
+	.name = "clcd",
+	.modes = clcd_plgpios_modes,
+	.mode_count = ARRAY_SIZE(clcd_plgpios_modes),
+};
+
+static struct pmx_dev *clcd_pmx_devs[] = {
+	&clcd_pmx_plgpios,
+};
+
+static struct gpio_req_list clcd_gpio_list[] = {
+	{
+		.start = PLGPIO_138,
+		.end = PLGPIO_191,
+	},
+};
+
+/* Switch pads to plgpio or clcd now */
+void config_clcd_gpio_pads(bool on)
+{
+	int ret;
+	static bool gpio_avail;
+
+	if (!gpio_avail) {
+		ret = request_gpio(clcd_gpio_list, GPIOF_IN,
+				ARRAY_SIZE(clcd_gpio_list));
+		if (ret)
+			pr_err("clcd request for gpio is failed. err no:%d\n",
+					ret);
+
+		gpio_avail = true;
+	}
+
+	config_io_pads(clcd_pmx_devs, ARRAY_SIZE(clcd_pmx_devs), on);
+}
+
+#ifdef CONFIG_SND_SPEAR_SPDIF_IN
+static int spdif_in_clk_init(void)
+{
+	int ret;
+
+	ret = clk_set_parent_sys("gen_synth3_clk", NULL, NULL, "vco1div4_clk");
+	if (ret)
+		return ret;
+
+	ret = clk_set_parent_sys("spdif-in", NULL, "gen_synth3_clk", NULL);
+	if (ret)
+		return ret;
+
+	/* Set SPDIF IN for a fixed clock = 200 MHz */
+	return clk_set_rate_sys("spdif-in", NULL, 200000000);
+}
+#endif
+
+#ifdef CONFIG_SND_SPEAR_SPDIF_OUT
+static int spdif_out_clk_init(void)
+{
+	int ret;
+
+	ret = clk_set_parent_sys("gen_synth2_clk", NULL, NULL, "vco1div4_clk");
+	if (ret)
+		return ret;
+
+	return clk_set_parent_sys("spdif-out", NULL, "gen_synth2_clk", NULL);
+}
+#endif
+
+#ifdef CONFIG_SPEAR_PCIE_REV370
+/* This function is needed for board specific PCIe initilization */
+void __init spear1340_pcie_board_init(struct device *dev)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_70);
+}
+#endif
+
+void __init spear1340_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count)
+{
+	int ret;
+
+	/* call spear13xx family common init function */
+	spear13xx_init();
+
+	/* call spear1340 system clock init function */
+	ret = spear1340_sys_clk_init();
+	if (ret)
+		pr_err("SPEAr1340: sysclock init failed, err no: %d\n", ret);
+
+#ifdef CONFIG_SND_SPEAR_SPDIF_IN
+	/* call spdif in clock init */
+	ret = spdif_in_clk_init();
+	if (ret)
+		pr_err("SPEAr1340: spdif in clock init failed, err no: %d\n",
+				ret);
+#endif
+
+#ifdef CONFIG_SND_SPEAR_SPDIF_OUT
+	/* call spdif out clock init */
+	ret = spdif_out_clk_init();
+	if (ret)
+		pr_err("SPEAr1340: spdif out clock init failed, err no: %d\n",
+				ret);
+#endif
+	spear13xx_i2c_device.dev.platform_data = &spear1340_i2c_dw_pdata;
+
+	/* pmx initialization */
+	pmx_driver.mode = pmx_mode;
+	pmx_driver.devs = pmx_devs;
+	pmx_driver.devs_count = pmx_dev_count;
+
+	ret = pmx_register(&pmx_driver);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
diff --git a/arch/arm/mach-spear13xx/spear1340_clock.c b/arch/arm/mach-spear13xx/spear1340_clock.c
new file mode 100644
index 0000000..9a8ec2b
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1340_clock.c
@@ -0,0 +1,1786 @@
+/*
+ * arch/arm/mach-spear13xx/spear1340_clock.c
+ *
+ * SPEAr13xx machines clock framework source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <plat/clock.h>
+#include <mach/hardware.h>
+#include <mach/spear1340_misc_regs.h>
+
+/* root clks */
+/* 24 MHz oscillator clock */
+static struct clk osc1_24m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 24000000,
+};
+
+/* 32 KHz oscillator clock */
+static struct clk osc2_32k_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 32000,
+};
+
+/* 25 MHz MIPHY oscillator clock */
+static struct clk osc3_25m_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.rate = 25000000,
+};
+
+/* clock derived from 32 KHz osc clk */
+/* rtc clock */
+static struct clk rtc_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_RTC_CLK_ENB,
+	.pclk = &osc2_32k_clk,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from osc1 or osc3 */
+/* vco[1-3] parents */
+static struct pclk_info vco_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1340_OSC_24M_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = SPEAR1340_OSC_25M_VAL,
+	},
+};
+
+/* vco[1-3] parent select structure */
+static struct pclk_sel vco_pclk_sel = {
+	.pclk_info = vco_pclk_info,
+	.pclk_count = ARRAY_SIZE(vco_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PLL_CFG,
+	.pclk_sel_mask = SPEAR1340_PLL_CLK_MASK,
+};
+
+/* vco masks structure */
+static struct vco_clk_masks vco_masks = {
+	.mode_mask = SPEAR1340_PLL_MODE_MASK,
+	.mode_shift = SPEAR1340_PLL_MODE_SHIFT,
+	.norm_fdbk_m_mask = SPEAR1340_PLL_NORM_FDBK_M_MASK,
+	.norm_fdbk_m_shift = SPEAR1340_PLL_NORM_FDBK_M_SHIFT,
+	.dith_fdbk_m_mask = SPEAR1340_PLL_DITH_FDBK_M_MASK,
+	.dith_fdbk_m_shift = SPEAR1340_PLL_DITH_FDBK_M_SHIFT,
+	.div_p_mask = SPEAR1340_PLL_DIV_P_MASK,
+	.div_p_shift = SPEAR1340_PLL_DIV_P_SHIFT,
+	.div_n_mask = SPEAR1340_PLL_DIV_N_MASK,
+	.div_n_shift = SPEAR1340_PLL_DIV_N_SHIFT,
+	.pll_lock_mask = SPEAR1340_PLL_LOCK_MASK,
+	.pll_lock_shift = SPEAR1340_PLL_LOCK_SHIFT,
+};
+/* vco1 configuration structure */
+static struct vco_clk_config vco1_config = {
+	.mode_reg = VA_SPEAR1340_PLL1_CTR,
+	.cfg_reg = VA_SPEAR1340_PLL1_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco_rtbl[] = {
+	/* PCLK 24MHz */
+	{.mode = 0, .m = 0x83, .n = 0x04, .p = 0x5}, /* vco 1572, pll 49.125 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x3}, /* vco 1000, pll 125 MHz */
+	{.mode = 0, .m = 0x64, .n = 0x06, .p = 0x1}, /* vco 800, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x1}, /* vco 1000, pll 500 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x1}, /* vco 1328, pll 664 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x1}, /* vco 1600, pll 800 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+	{.mode = 0, .m = 0x96, .n = 0x06, .p = 0x0}, /* vco 1200, pll 1200 MHz */
+};
+
+/* vco1 clock */
+static struct clk vco1_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_PLL1_CLK_SHIFT,
+	.en_reg = VA_SPEAR1340_PLL1_CTR,
+	.en_reg_bit = SPEAR1340_PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco1_config,
+};
+
+/* thermal clock */
+static struct clk thermal_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_THSENS_CLK_ENB,
+	.pclk = &osc1_24m_clk,
+	.div_factor = 128,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from vco1 clock */
+/* pll1 clock */
+static struct clk pll1_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco1div2 clock */
+static struct clk vco1div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/*
+ * Synthesizer Clock derived from vcodiv2. This clock is one of the
+ * possible clocks to feed cpu directly.
+ * We can program this synthesizer to make cpu run on different clock
+ * frequencies.
+ * Following table provides configuration values to let cpu run on 200,
+ * 250, 332, 400 or 500 MHz considering different possibilites of input
+ * (vco1div2) clock.
+ *
+ * --------------------------------------------------------------------
+ * vco1div2(Mhz)	fout(Mhz)	cpuclk = fout/2		div
+ * --------------------------------------------------------------------
+ * 400			200		100			0x04000
+ * 400			250		125			0x03333
+ * 400			332		166			0x0268D
+ * 400			400		200			0x02000
+ * --------------------------------------------------------------------
+ * 500			200		100			0x05000
+ * 500			250		125			0x04000
+ * 500			332		166			0x03031
+ * 500			400		200			0x02800
+ * 500			500		250			0x02000
+ * --------------------------------------------------------------------
+ * 664			200		100			0x06a38
+ * 664			250		125			0x054FD
+ * 664			332		166			0x04000
+ * 664			400		200			0x0351E
+ * 664			500		250			0x02A7E
+ * --------------------------------------------------------------------
+ * 800			200		100			0x08000
+ * 800			250		125			0x06666
+ * 800			332		166			0x04D18
+ * 800			400		200			0x04000
+ * 800			500		250			0x03333
+ * --------------------------------------------------------------------
+ * sys rate configuration table is in descending order of divisor.
+ */
+static struct frac_synth_rate_tbl sys_synth_rtbl[] = {
+	{.div = 0x08000},
+	{.div = 0x06a38},
+	{.div = 0x06666},
+	{.div = 0x054FD},
+	{.div = 0x05000},
+	{.div = 0x04D18},
+	{.div = 0x04000},
+	{.div = 0x0351E},
+	{.div = 0x03333},
+	{.div = 0x03031},
+	{.div = 0x02A7E},
+	{.div = 0x02800},
+	{.div = 0x0268D},
+	{.div = 0x02000},
+};
+
+/* common fractional synthesizer masks */
+static struct frac_synth_masks frac_synth_masks = {
+	.div_factor_mask = SPEAR1340_FRAC_SYNT_DIV_FACTOR_MASK,
+	.div_factor_shift = SPEAR1340_FRAC_SYNT_DIV_FACTOR_SHIFT,
+};
+
+/* system synthesizer clock definitions */
+static struct frac_synth_clk_config sys_synth_config = {
+	.synth_reg = VA_SPEAR1340_SYS_CLK_SYNT,
+	.masks = &frac_synth_masks,
+};
+
+/* sys synth clock */
+static struct clk sys_synth_clk = {
+	.flags = SYSTEM_CLK,
+	.en_reg = VA_SPEAR1340_SYS_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {sys_synth_rtbl, ARRAY_SIZE(sys_synth_rtbl), 8},
+	.private_data = &sys_synth_config,
+};
+
+/*
+ * All below entries generate 166 MHz for
+ * different values of vco1div2
+ */
+static struct frac_synth_rate_tbl amba_synth_rtbl[] = {
+	{.div = 0x06062}, /* for vco1div2 = 500 MHz */
+	{.div = 0x04D1B}, /* for vco1div2 = 400 MHz */
+	{.div = 0x04000}, /* for vco1div2 = 332 MHz */
+	{.div = 0x03031}, /* for vco1div2 = 250 MHz */
+	{.div = 0x0268D}, /* for vco1div2 = 200 MHz */
+};
+
+/* amba synth clock definitions */
+static struct frac_synth_clk_config amba_synth_config = {
+	.synth_reg = VA_SPEAR1340_AMBA_CLK_SYNT,
+	.masks = &frac_synth_masks,
+};
+
+/* sys synth clock */
+static struct clk amba_synth_clk = {
+	.flags = SYSTEM_CLK,
+	.en_reg = VA_SPEAR1340_AMBA_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {amba_synth_rtbl, ARRAY_SIZE(amba_synth_rtbl), 0},
+	.private_data = &amba_synth_config,
+};
+
+/* vco1div4 clock */
+static struct clk vco1div4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco1_clk,
+	.div_factor = 4,
+	.recalc = &follow_parent,
+};
+
+/* vco2 configuration structure */
+static struct vco_clk_config vco2_config = {
+	.mode_reg = VA_SPEAR1340_PLL2_CTR,
+	.cfg_reg = VA_SPEAR1340_PLL2_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco2 clock */
+static struct clk vco2_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_PLL2_CLK_SHIFT,
+	.en_reg = VA_SPEAR1340_PLL2_CTR,
+	.en_reg_bit = SPEAR1340_PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 6},
+	.private_data = &vco2_config,
+};
+
+/* clock derived from vco2 clock */
+/* pll2 clock */
+static struct clk pll2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco2div2 clock */
+static struct clk vco2div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco2_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco3 configuration structure */
+static struct vco_clk_config vco3_config = {
+	.mode_reg = VA_SPEAR1340_PLL3_CTR,
+	.cfg_reg = VA_SPEAR1340_PLL3_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco3 clock */
+static struct clk vco3_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.pclk_sel = &vco_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_PLL3_CLK_SHIFT,
+	.en_reg = VA_SPEAR1340_PLL3_CTR,
+	.en_reg_bit = SPEAR1340_PLL_ENABLE,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco_rtbl, ARRAY_SIZE(vco_rtbl), 0},
+	.private_data = &vco3_config,
+};
+
+/* clock derived from vco3 clock */
+/* pll3 clock */
+static struct clk pll3_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* vco3div2 clock */
+static struct clk vco3div2_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco3_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* vco4 (DDR) configuration structure */
+static struct vco_clk_config vco4_config = {
+	.mode_reg = VA_SPEAR1340_PLL4_CTR,
+	.cfg_reg = VA_SPEAR1340_PLL4_FRQ,
+	.masks = &vco_masks,
+};
+
+/* vco4 rate configuration table, in ascending order of rates */
+static struct vco_rate_tbl vco4_rtbl[] = {
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x2}, /* vco 1000, pll 250 MHz */
+	{.mode = 0, .m = 0xA6, .n = 0x06, .p = 0x2}, /* vco 1328, pll 332 MHz */
+	{.mode = 0, .m = 0xC8, .n = 0x06, .p = 0x2}, /* vco 1600, pll 400 MHz */
+	{.mode = 0, .m = 0x7D, .n = 0x06, .p = 0x0}, /* vco 1, pll 1 GHz */
+};
+
+/* vco4 (DDR) clock */
+static struct clk vco4_clk = {
+	.flags = ENABLED_ON_INIT | SYSTEM_CLK,
+	.en_reg = VA_SPEAR1340_PLL4_CTR,
+	.en_reg_bit = SPEAR1340_PLL_ENABLE,
+	.pclk = &osc1_24m_clk,
+	.calc_rate = &vco_calc_rate,
+	.recalc = &vco_clk_recalc,
+	.set_rate = &vco_clk_set_rate,
+	.rate_config = {vco4_rtbl, ARRAY_SIZE(vco4_rtbl), 3},
+	.private_data = &vco4_config,
+};
+
+/* clock derived from vco4 clock */
+/* pll4 clock */
+static struct clk pll4_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &vco4_clk,
+	.recalc = &pll_clk_recalc,
+};
+
+/* pll5 USB 48 MHz clock */
+static struct clk pll5_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc1_24m_clk,
+	.rate = 48000000,
+};
+
+/* pll6 (MIPHY) clock */
+static struct clk pll6_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &osc3_25m_clk,
+	.rate = 25000000,
+};
+
+/* clocks derived from pll1 clk */
+/* ddr clock */
+static struct ddr_rate_tbl ddr_rate_tbl = {
+	.minrate = 332000000,
+	.maxrate = 500000000,
+};
+
+static struct clk ddr_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &pll4_clk,
+	.recalc = &follow_parent,
+	.private_data = &ddr_rate_tbl,
+};
+
+static struct pclk_info sys_pclk_info[] = {
+	{
+		.pclk = &pll1_clk,
+		.pclk_val = SPEAR1340_SCLK_SRC_PLL1,
+	}, {
+		.pclk = &sys_synth_clk,
+		.pclk_val = SPEAR1340_SCLK_SRC_SYNT,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_SCLK_SRC_PLL2,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = SPEAR1340_SCLK_SRC_PLL3,
+	},
+};
+
+static struct pclk_sel sys_pclk_sel = {
+	.pclk_info = sys_pclk_info,
+	.pclk_count = ARRAY_SIZE(sys_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_SYS_CLK_CTRL,
+	.pclk_sel_mask = SPEAR1340_SCLK_SRC_SEL_MASK,
+};
+
+/* sys clock */
+static struct clk sys_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk_sel = &sys_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_SCLK_SRC_SEL_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* cpu clock */
+static struct clk cpu_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &sys_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* cpu clock div3*/
+static struct clk cpu_clk_div3 = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &cpu_clk,
+	.div_factor = 3,
+	.recalc = &follow_parent,
+};
+
+/* ahb clock */
+static struct pclk_info ahb_pclk_info[] = {
+	{
+		.pclk = &cpu_clk_div3,
+		.pclk_val = SPEAR1340_HCLK_SRC_CPU,
+	}, {
+		.pclk = &amba_synth_clk,
+		.pclk_val = SPEAR1340_HCLK_SRC_SYNT,
+	},
+};
+
+static struct pclk_sel ahb_pclk_sel = {
+	.pclk_info = ahb_pclk_info,
+	.pclk_count = ARRAY_SIZE(ahb_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_SYS_CLK_CTRL,
+	.pclk_sel_mask = SPEAR1340_HCLK_SRC_SEL_MASK,
+};
+
+static struct clk ahb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk_sel = &ahb_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_HCLK_SRC_SEL_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* apb clock */
+static struct clk apb_clk = {
+	.flags = ALWAYS_ENABLED | SYSTEM_CLK,
+	.pclk = &ahb_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* clocks derived from osc1, ahb or apb */
+/* gpt[0-3] parents */
+static struct pclk_info gpt_pclk_info[] = {
+	{
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1340_GPT_OSC24_VAL,
+	}, {
+		.pclk = &apb_clk,
+		.pclk_val = SPEAR1340_GPT_APB_VAL,
+	},
+};
+
+/* gpt[0-3] parent select structure */
+static struct pclk_sel gpt_pclk_sel = {
+	.pclk_info = gpt_pclk_info,
+	.pclk_count = ARRAY_SIZE(gpt_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_GPT_CLK_MASK,
+};
+
+/* gpt0 timer clock */
+static struct clk gpt0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPT0_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GPT0_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt1 timer clock */
+static struct clk gpt1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPT1_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GPT1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt2 timer clock */
+static struct clk gpt2_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPT2_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GPT2_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gpt3 timer clock */
+static struct clk gpt3_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPT3_CLK_ENB,
+	.pclk_sel = &gpt_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GPT3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* watch dog timer clock */
+static struct clk wdt_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &cpu_clk,
+	.div_factor = 2,
+	.recalc = &follow_parent,
+};
+
+/* auxiliary synthesizers masks */
+static struct aux_clk_masks aux_masks = {
+	.eq_sel_mask = SPEAR1340_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1340_AUX_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1340_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1340_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1340_AUX_XSCALE_MASK,
+	.xscale_sel_shift = SPEAR1340_AUX_XSCALE_SHIFT,
+	.yscale_sel_mask = SPEAR1340_AUX_YSCALE_MASK,
+	.yscale_sel_shift = SPEAR1340_AUX_YSCALE_SHIFT,
+};
+
+/* aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl aux_rtbl[] = {
+	/* For VCO1div2 = 500 MHz */
+	{.xscale = 10, .yscale = 204, .eq = 0}, /* 12.29 MHz */
+	{.xscale = 4, .yscale = 21, .eq = 0}, /* 48 MHz */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* 83 MHz */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* 125 MHz */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* 166 MHz */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* 250 MHz */
+};
+
+/* clocks derived multiple parents (pll1, pll5, synthesizers or others) */
+/* uart0 configurations */
+static struct aux_clk_config uart0_synth_config = {
+	.synth_reg = VA_SPEAR1340_UART0_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* uart1 configurations */
+static struct aux_clk_config uart1_synth_config = {
+	.synth_reg = VA_SPEAR1340_UART1_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* uart0 synth clock */
+static struct clk uart0_synth_clk = {
+	.en_reg = VA_SPEAR1340_UART0_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &uart0_synth_config,
+};
+
+/* uart1 synth clock */
+static struct clk uart1_synth_clk = {
+	.en_reg = VA_SPEAR1340_UART1_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &uart1_synth_config,
+};
+
+/* uart0 parents */
+static struct pclk_info uart0_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1340_UART_CLK_PLL5_VAL,
+	}, {
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1340_UART_CLK_OSC24_VAL,
+	}, {
+		.pclk = &uart0_synth_clk,
+		.pclk_val = SPEAR1340_UART_CLK_SYNT_VAL,
+	},
+};
+
+/* uart1 parents */
+static struct pclk_info uart1_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1340_UART_CLK_PLL5_VAL,
+	}, {
+		.pclk = &osc1_24m_clk,
+		.pclk_val = SPEAR1340_UART_CLK_OSC24_VAL,
+	}, {
+		.pclk = &uart1_synth_clk,
+		.pclk_val = SPEAR1340_UART_CLK_SYNT_VAL,
+	},
+};
+
+/* uart0 parent select structure */
+static struct pclk_sel uart0_pclk_sel = {
+	.pclk_info = uart0_pclk_info,
+	.pclk_count = ARRAY_SIZE(uart0_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_UART_CLK_MASK,
+};
+
+/* uart1 parent select structure */
+static struct pclk_sel uart1_pclk_sel = {
+	.pclk_info = uart1_pclk_info,
+	.pclk_count = ARRAY_SIZE(uart1_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_UART_CLK_MASK,
+};
+
+/* uart0 clock */
+static struct clk uart0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_UART0_CLK_ENB,
+	.pclk_sel = &uart0_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_UART0_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* uart1 clock */
+static struct clk uart1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_UART1_CLK_ENB,
+	.pclk_sel = &uart1_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_UART1_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* sdhci configurations */
+static struct aux_clk_config sdhci_synth_config = {
+	.synth_reg = VA_SPEAR1340_SDHCI_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* sdhci synth clock */
+static struct clk sdhci_synth_clk = {
+	.en_reg = VA_SPEAR1340_SDHCI_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 1},
+	.private_data = &sdhci_synth_config,
+};
+
+/* sdhci clock */
+static struct clk sdhci_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SDHCI_CLK_ENB,
+	.pclk = &sdhci_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* cfxd configurations */
+static struct aux_clk_config cfxd_synth_config = {
+	.synth_reg = VA_SPEAR1340_CFXD_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* cfxd synth clock */
+static struct clk cfxd_synth_clk = {
+	.en_reg = VA_SPEAR1340_CFXD_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 4},
+	.private_data = &cfxd_synth_config,
+};
+
+/* cfxd clock */
+static struct clk cfxd_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CFXD_CLK_ENB,
+	.pclk = &cfxd_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* C3 clk configurations */
+static struct aux_clk_config c3_synth_config = {
+	.synth_reg = VA_SPEAR1340_C3_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* c3 synth clock */
+static struct clk c3_synth_clk = {
+	.en_reg = VA_SPEAR1340_C3_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &vco1div2_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {aux_rtbl, ARRAY_SIZE(aux_rtbl), 2},
+	.private_data = &c3_synth_config,
+};
+
+/* c3 parents */
+static struct pclk_info c3_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1340_AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &c3_synth_clk,
+		.pclk_val = SPEAR1340_AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* c3 parent select structure */
+static struct pclk_sel c3_pclk_sel = {
+	.pclk_info = c3_pclk_info,
+	.pclk_count = ARRAY_SIZE(c3_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_C3_CLK_MASK,
+};
+
+/* c3 clock */
+static struct clk c3_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_C3_CLK_ENB,
+	.pclk_sel = &c3_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_C3_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac phy clk configurations */
+static struct aux_clk_config gmac_phy_synth_config = {
+	.synth_reg = VA_SPEAR1340_GMAC_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* gmii external pad clock for phy operation */
+static struct clk gmii_125m_pad = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 125000000,
+};
+
+/* gmac phy set of input clks*/
+static struct pclk_info gmac_phy_input_pclk_info[] = {
+	{
+		.pclk = &gmii_125m_pad,
+		.pclk_val = SPEAR1340_GMAC_PHY_125M_PAD_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_GMAC_PHY_PLL2_VAL,
+	}, {
+		.pclk = &osc3_25m_clk,
+		.pclk_val = SPEAR1340_GMAC_PHY_OSC3_VAL,
+	},
+};
+
+static struct pclk_sel gmac_phy_input_pclk_sel = {
+	.pclk_info = gmac_phy_input_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_input_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_GMAC_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_GMAC_PHY_INPUT_CLK_MASK,
+};
+
+static struct clk gmac_phy_input_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_input_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GMAC_PHY_INPUT_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* gmac rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl gmac_rtbl[] = {
+	/* For gmac phy input clk */
+	{.xscale = 2, .yscale = 6, .eq = 0}, /* divided by 6 */
+	{.xscale = 2, .yscale = 4, .eq = 0}, /* divided by 4 */
+	{.xscale = 1, .yscale = 3, .eq = 1}, /* divided by 3 */
+	{.xscale = 1, .yscale = 2, .eq = 1}, /* divided by 2 */
+};
+
+static struct clk gmac_phy_synth_clk = {
+	.en_reg = VA_SPEAR1340_GMAC_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &gmac_phy_input_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {gmac_rtbl, ARRAY_SIZE(gmac_rtbl), 0},
+	.private_data = &gmac_phy_synth_config,
+};
+
+/* gmac phy parents */
+static struct pclk_info gmac_phy_pclk_info[] = {
+	{
+		.pclk = &gmac_phy_input_clk,
+		.pclk_val = SPEAR1340_GMAC_PHY_INPUT_ENB_VAL,
+	}, {
+		.pclk = &gmac_phy_synth_clk,
+		.pclk_val = SPEAR1340_GMAC_PHY_SYNT_ENB_VAL,
+	}
+};
+
+/* gmac phy parent select structure */
+static struct pclk_sel gmac_phy_pclk_sel = {
+	.pclk_info = gmac_phy_pclk_info,
+	.pclk_count = ARRAY_SIZE(gmac_phy_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_GMAC_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_GMAC_PHY_CLK_MASK,
+};
+
+/* gmac phy clock */
+static struct clk gmac_phy0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &gmac_phy_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GMAC_PHY_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* clcd fractional synthesizers definition */
+static struct frac_synth_clk_config clcd_synth_config = {
+	.synth_reg = VA_SPEAR1340_CLCD_CLK_SYNT,
+	.masks = &frac_synth_masks,
+};
+
+/* clcd fractional synthesizer parents */
+static struct pclk_info clcd_synth_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1340_CLCD_SYNT_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_CLCD_SYNT_PLL2_VAL,
+	},
+};
+
+/* clcd fractional synthesizer parent select structure */
+static struct pclk_sel clcd_synth_pclk_sel = {
+	.pclk_info = clcd_synth_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_synth_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PLL_CFG,
+	.pclk_sel_mask = SPEAR1340_CLCD_SYNT_CLK_MASK,
+};
+
+/* clcd rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl clcd_rtbl[] = {
+	{.div = 0x14000}, /* 25 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x1284B}, /* 27 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0D8D3}, /* 58 Mhz , for vco1div4 = 393 MHz */
+	{.div = 0x0B72C}, /* 58 Mhz , for vco1div4 = 332 MHz */
+	{.div = 0x089EE}, /* 58 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x07BA0}, /* 65 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06f1C}, /* 72 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x06E58}, /* 58 Mhz , for vco1div4 = 200 MHz */
+	{.div = 0x06c1B}, /* 74 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x04A12}, /* 108 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0378E}, /* 144 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x0360D}, /* 148 Mhz , for vc01div4 = 250 MHz*/
+	{.div = 0x035E0}, /* 148.5 MHz, for vc01div4 = 250 MHz*/
+};
+
+/* clcd fractional synthesizer clock */
+static struct clk clcd_synth_clk = {
+	.en_reg = VA_SPEAR1340_CLCD_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk_sel = &clcd_synth_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_CLCD_SYNT_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {clcd_rtbl, ARRAY_SIZE(clcd_rtbl), 2},
+	.private_data = &clcd_synth_config,
+};
+
+/*
+ * clcd clock parents
+ * This would select to use pll5_clk or clcd_synth_clk as a parent clock
+ * of clcd (called as pixel clock in CLCD documentation).
+ * For selection of any of these two parent, check the combination of
+ * 3-2 bit of clcdclk_sel misc register
+ */
+static struct pclk_info clcd_pixel_pclk_info[] = {
+	{
+		.pclk = &pll5_clk,
+		.pclk_val = SPEAR1340_AUX_CLK_PLL5_VAL,
+	}, {
+		.pclk = &clcd_synth_clk,
+		.pclk_val = SPEAR1340_AUX_CLK_SYNT_VAL,
+	},
+};
+
+/* clcd parent select structure */
+static struct pclk_sel clcd_pixel_pclk_sel = {
+	.pclk_info = clcd_pixel_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pixel_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_CLCD_CLK_MASK,
+};
+
+static struct clk clcd_pixel_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &clcd_pixel_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_CLCD_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/*
+ * clcd clock
+ * There are 2 options for clcd clock,
+ * - derived from AHB (bus clk)
+ * - dervied from Pixel Clock Input (pixel clk)
+ * The selection bit for these clock is in device itself, hence treating
+ * them as virtual clocks without selection register.
+ * Controller driver on itself needs to program proper selection
+ */
+
+static struct pclk_info clcd_pclk_info[] = {
+	{
+		.pclk = &clcd_pixel_clk,
+	}, {
+		.pclk = &ahb_clk,
+	},
+};
+
+static struct pclk_sel clcd_pclk_sel = {
+	.pclk_info = clcd_pclk_info,
+	.pclk_count = ARRAY_SIZE(clcd_pclk_info),
+	.pclk_sel_reg = 0, /* no select register */
+};
+
+/* clcd clock */
+static struct clk clcd_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CLCD_CLK_ENB,
+	.pclk_sel = &clcd_pclk_sel,
+	.recalc = &follow_parent,
+};
+
+/* i2s related clocks */
+/* i2s source clock parents */
+static struct clk i2s_src_pad_clk = {
+	.flags = ALWAYS_ENABLED,
+	.rate = 12288000,
+};
+
+static struct pclk_info i2s_src_pclk_info[] = {
+	{
+		.pclk = &vco1div2_clk,
+		.pclk_val = SPEAR1340_I2S_SRC_VCO1DIV2_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_I2S_SRC_PLL2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = SPEAR1340_I2S_SRC_PLL3_VAL,
+	}, {
+		.pclk = &i2s_src_pad_clk,
+		.pclk_val = SPEAR1340_I2S_SRC_PL_CLK1_VAL,
+	},
+};
+
+static struct pclk_sel i2s_src_pclk_sel = {
+	.pclk_info = i2s_src_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_src_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_I2S_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_I2S_SRC_CLK_MASK,
+};
+
+/* i2s src clock */
+static struct clk i2s_src_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_src_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_I2S_SRC_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s prescaler1 masks */
+static struct aux_clk_masks i2s_prs1_aux_masks = {
+	.eq_sel_mask = SPEAR1340_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1340_I2S_PRS1_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1340_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1340_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1340_I2S_PRS1_CLK_X_MASK,
+	.xscale_sel_shift = SPEAR1340_I2S_PRS1_CLK_X_SHIFT,
+	.yscale_sel_mask = SPEAR1340_I2S_PRS1_CLK_Y_MASK,
+	.yscale_sel_shift = SPEAR1340_I2S_PRS1_CLK_Y_SHIFT,
+};
+
+/* i2s prs1 clk configurations */
+static struct aux_clk_config i2s_prs1_config = {
+	.synth_reg = VA_SPEAR1340_I2S_CLK_CFG,
+	.masks = &i2s_prs1_aux_masks,
+};
+
+/* i2s prs1 aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_prs1_aux_rtbl[] = {
+	/* For parent clk = 49.152 MHz */
+	{.xscale = 1, .yscale = 12, .eq = 0}, /* 2.048 MHz, smp freq = 8Khz */
+	{.xscale = 11, .yscale = 96, .eq = 0}, /* 2.816 MHz, smp freq = 11Khz */
+	{.xscale = 1, .yscale = 6, .eq = 0}, /* 4.096 MHz, smp freq = 16Khz */
+	{.xscale = 11, .yscale = 48, .eq = 0}, /* 5.632 MHz, smp freq = 22Khz */
+
+	/*
+	 * with parent clk = 49.152, freq gen is 8.192 MHz, smp freq = 32Khz
+	 * with parent clk = 12.288, freq gen is 2.048 MHz, smp freq = 8Khz
+	 */
+	{.xscale = 1, .yscale = 3, .eq = 0},
+
+	/* For parent clk = 49.152 MHz */
+	{.xscale = 17, .yscale = 37, .eq = 0}, /* 11.289 MHz, smp freq = 44Khz*/
+	{.xscale = 1, .yscale = 2, .eq = 0}, /* 12.288 MHz, smp freq = 48Khz*/
+};
+
+/* i2s prs1 clock */
+static struct clk i2s_prs1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &i2s_src_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_prs1_aux_rtbl, ARRAY_SIZE(i2s_prs1_aux_rtbl), 6},
+	.private_data = &i2s_prs1_config,
+};
+
+/* i2s ref clk configuration */
+static struct pclk_info i2s_ref_pclk_info[] = {
+	{
+		.pclk = &i2s_src_clk,
+		.pclk_val = SPEAR1340_I2S_REF_SRC_VAL,
+	}, {
+		.pclk = &i2s_prs1_clk,
+		.pclk_val = SPEAR1340_I2S_REF_PRS1_VAL,
+	},
+};
+
+/* i2s ref clock parent select structure */
+static struct pclk_sel i2s_ref_pclk_sel = {
+	.pclk_info = i2s_ref_pclk_info,
+	.pclk_count = ARRAY_SIZE(i2s_ref_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_I2S_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_I2S_REF_SEL_MASK,
+};
+
+/* i2s ref clock */
+static struct clk i2s_ref_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk_sel = &i2s_ref_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_I2S_REF_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* i2s ref pad clock: for codec */
+static struct clk i2s_ref_pad_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_I2S_REF_PAD_CLK_ENB,
+	.pclk = &i2s_ref_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s sclk aux rate configuration table, in ascending order of rates */
+static struct aux_rate_tbl i2s_sclk_aux_rtbl[] = {
+	/* For sclk = ref_clk * x/2/y */
+	{.xscale = 1, .yscale = 4, .eq = 0},
+	{.xscale = 1, .yscale = 2, .eq = 0},
+};
+
+/* i2s sclk (bit clock) syynthesizers masks */
+static struct aux_clk_masks i2s_sclk_aux_masks = {
+	.eq_sel_mask = SPEAR1340_AUX_EQ_SEL_MASK,
+	.eq_sel_shift = SPEAR1340_I2S_SCLK_EQ_SEL_SHIFT,
+	.eq1_mask = SPEAR1340_AUX_EQ1_SEL,
+	.eq2_mask = SPEAR1340_AUX_EQ2_SEL,
+	.xscale_sel_mask = SPEAR1340_I2S_SCLK_X_MASK,
+	.xscale_sel_shift = SPEAR1340_I2S_SCLK_X_SHIFT,
+	.yscale_sel_mask = SPEAR1340_I2S_SCLK_Y_MASK,
+	.yscale_sel_shift = SPEAR1340_I2S_SCLK_Y_SHIFT,
+};
+
+/* i2s sclk synth configurations */
+static struct aux_clk_config i2s_sclk_synth_config = {
+	.synth_reg = VA_SPEAR1340_I2S_CLK_CFG,
+	.masks = &i2s_sclk_aux_masks,
+};
+
+/* i2s sclk (bit clock) */
+static struct clk i2s_sclk_clk = {
+	.en_reg = VA_SPEAR1340_I2S_CLK_CFG,
+	.en_reg_bit = SPEAR1340_I2S_SCLK_SYNTH_ENB,
+	.pclk = &i2s_ref_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {i2s_sclk_aux_rtbl, ARRAY_SIZE(i2s_sclk_aux_rtbl), 0},
+	.private_data = &i2s_sclk_synth_config,
+};
+
+/* clock derived from ahb clk */
+
+/* i2c0 clock */
+static struct clk i2c0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_I2C0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2c1 clock */
+static struct clk i2c1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_I2C1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* dma clock */
+static struct clk dma_pclk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_DMA_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma0_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dma1_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &dma_pclk,
+	.recalc = &follow_parent,
+};
+
+/* gmac clock */
+static struct clk gmac_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GMAC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc clock */
+static struct clk fsmc_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_FSMC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nand clock */
+static struct clk fsmc_nand_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* fsmc-nor clock */
+static struct clk fsmc_nor_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &fsmc_clk,
+	.recalc = &follow_parent,
+};
+
+/* smi clock */
+static struct clk smi_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SMI_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uhc0 clock */
+static struct clk uhci0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_UHC0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uhc1 clock */
+static struct clk uhci1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_UHC1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* uoc clock */
+static struct clk uoc_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_UOC_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* pcie-sata parent clock */
+static struct clk pcie_sata_pclk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_PCIE_SATA_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* pcie clock */
+static struct clk pcie_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_pclk,
+	.recalc = &follow_parent,
+};
+
+/* sata clock */
+static struct clk sata_clk = {
+	.flags = ALWAYS_ENABLED,
+	.pclk = &pcie_sata_pclk,
+	.recalc = &follow_parent,
+};
+
+/* sysram clocks */
+static struct clk sysram0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SYSRAM0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk sysram1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SYSRAM1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* adc configurations */
+static struct aux_clk_config adc_synth_config = {
+	.synth_reg = VA_SPEAR1340_ADC_CLK_SYNT,
+	.masks = &aux_masks,
+};
+
+/* adc rate configuration table, in ascending order of rates */
+/* possible adc range is 2.5 MHz to 20 MHz. */
+static struct aux_rate_tbl adc_rtbl[] = {
+	/* For ahb = 166.67 MHz */
+	{.xscale = 1, .yscale = 31, .eq = 0}, /* 2.68 MHz */
+	{.xscale = 2, .yscale = 21, .eq = 0}, /* 7.94 MHz */
+	{.xscale = 4, .yscale = 21, .eq = 0}, /* 15.87 MHz */
+	{.xscale = 10, .yscale = 42, .eq = 0}, /* 19.84 MHz */
+};
+
+/* adc synth clock */
+static struct clk adc_synth_clk = {
+	.en_reg = VA_SPEAR1340_ADC_CLK_SYNT,
+	.en_reg_bit = SPEAR1340_AUX_SYNT_ENB,
+	.pclk = &ahb_clk,
+	.calc_rate = &aux_calc_rate,
+	.recalc = &aux_clk_recalc,
+	.set_rate = &aux_clk_set_rate,
+	.rate_config = {adc_rtbl, ARRAY_SIZE(adc_rtbl), 0},
+	.private_data = &adc_synth_config,
+};
+
+/* adc clock */
+static struct clk adc_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_ADC_CLK_ENB,
+	.pclk = &adc_synth_clk,
+	.recalc = &follow_parent,
+};
+
+/* clock derived from apb clk */
+/* ssp clock */
+static struct clk ssp_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SSP_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPIO0_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* gpio clock */
+static struct clk gpio1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_GPIO1_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s play clock */
+static struct clk i2s_play_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_I2S_PLAY_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* i2s rec clock */
+static struct clk i2s_rec_clk = {
+	.en_reg = VA_SPEAR1340_PERIP1_CLK_ENB,
+	.en_reg_bit = SPEAR1340_I2S_REC_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* keyboard clock */
+static struct clk kbd_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_KBD_CLK_ENB,
+	.pclk = &apb_clk,
+	.recalc = &follow_parent,
+};
+
+/* general fractional synthesizers definitions */
+static struct frac_synth_clk_config gen_synth0_config = {
+	.synth_reg = VA_SPEAR1340_GEN_CLK_SYNT0,
+	.masks = &frac_synth_masks,
+};
+
+static struct frac_synth_clk_config gen_synth1_config = {
+	.synth_reg = VA_SPEAR1340_GEN_CLK_SYNT1,
+	.masks = &frac_synth_masks,
+};
+
+static struct frac_synth_clk_config gen_synth2_config = {
+	.synth_reg = VA_SPEAR1340_GEN_CLK_SYNT2,
+	.masks = &frac_synth_masks,
+};
+
+static struct frac_synth_clk_config gen_synth3_config = {
+	.synth_reg = VA_SPEAR1340_GEN_CLK_SYNT3,
+	.masks = &frac_synth_masks,
+};
+
+/* GEN Fractional Synthesizer parents */
+static struct pclk_info gen_synth0_1_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT0_1_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco3div2_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT0_1_VCO3_DIV2_VAL,
+	}, {
+		.pclk = &pll3_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT0_1_PLL3_VAL,
+	},
+};
+
+/* GEN Fractional Synthesizer-0 and 1 parent select structure */
+static struct pclk_sel gen_synth0_1_pclk_sel = {
+	.pclk_info = gen_synth0_1_pclk_info,
+	.pclk_count = ARRAY_SIZE(gen_synth0_1_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PLL_CFG,
+	.pclk_sel_mask = SPEAR1340_GEN_SYNT0_1_CLK_MASK,
+};
+
+static struct pclk_info gen_synth2_3_pclk_info[] = {
+	{
+		.pclk = &vco1div4_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT2_3_VCO1_DIV4_VAL,
+	}, {
+		.pclk = &vco2div2_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT2_3_VCO2_DIV2_VAL,
+	}, {
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_GEN_SYNT2_3_PLL2_VAL,
+	},
+};
+
+/* GEN Fractional Synthesizer-2 and 3 parent select structure */
+static struct pclk_sel gen_synth2_3_pclk_sel = {
+	.pclk_info = gen_synth2_3_pclk_info,
+	.pclk_count = ARRAY_SIZE(gen_synth2_3_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PLL_CFG,
+	.pclk_sel_mask = SPEAR1340_GEN_SYNT2_3_CLK_MASK,
+};
+
+/* GEN rate configuration table, in ascending order of rates */
+static struct frac_synth_rate_tbl gen_rtbl[] = {
+	/* For vco1div4 = 250 MHz */
+	{.div = 0x1624E}, /* 22.5792 MHz */
+	{.div = 0x14585}, /* 24.576 MHz */
+	{.div = 0x14000}, /* 25 MHz */
+	{.div = 0x0B127}, /* 45.1584 MHz */
+	{.div = 0x0A000}, /* 50 MHz */
+	{.div = 0x061A8}, /* 81.92 MHz */
+	{.div = 0x05000}, /* 100 MHz */
+	{.div = 0x02800}, /* 200 MHz */
+	{.div = 0x02620}, /* 210 MHz */
+	{.div = 0x02460}, /* 220 MHz */
+	{.div = 0x022C0}, /* 230 MHz */
+	{.div = 0x02160}, /* 240 MHz */
+	{.div = 0x02000}, /* 250 MHz */
+};
+
+/* GEN Fractional Synthesizer-0 Clock */
+static struct clk gen_synth0_clk = {
+	.en_reg = VA_SPEAR1340_GEN_CLK_SYNT0,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk_sel = &gen_synth0_1_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GEN_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {gen_rtbl, ARRAY_SIZE(gen_rtbl), 4},
+	.private_data = &gen_synth0_config,
+};
+
+/* GEN Fractional Synthesizer1 Clock */
+static struct clk gen_synth1_clk = {
+	.en_reg = VA_SPEAR1340_GEN_CLK_SYNT1,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk_sel = &gen_synth0_1_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GEN_SYNT0_1_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {gen_rtbl, ARRAY_SIZE(gen_rtbl), 4},
+	.private_data = &gen_synth1_config,
+};
+
+/* GEN Fractional Synthesizer2 Clock */
+static struct clk gen_synth2_clk = {
+	.en_reg = VA_SPEAR1340_GEN_CLK_SYNT2,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk_sel = &gen_synth2_3_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GEN_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {gen_rtbl, ARRAY_SIZE(gen_rtbl), 4},
+	.private_data = &gen_synth2_config,
+};
+
+/* GEN Fractional Synthesizer3 Clock */
+static struct clk gen_synth3_clk = {
+	.en_reg = VA_SPEAR1340_GEN_CLK_SYNT3,
+	.en_reg_bit = SPEAR1340_FRAC_SYNT_ENB,
+	.pclk_sel = &gen_synth2_3_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_GEN_SYNT2_3_CLK_SHIFT,
+	.calc_rate = &frac_synth_calc_rate,
+	.recalc = &frac_synth_clk_recalc,
+	.set_rate = &frac_synth_clk_set_rate,
+	.rate_config = {gen_rtbl, ARRAY_SIZE(gen_rtbl), 4},
+	.private_data = &gen_synth3_config,
+};
+
+/* mali clock */
+static struct clk mali_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_MALI_CLK_ENB,
+	.pclk = &gen_synth3_clk,
+	.recalc = &follow_parent,
+};
+
+/* cec0 clock */
+static struct clk cec0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CEC0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* cec1 clock */
+static struct clk cec1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CEC1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* SPDIF Out clk */
+static struct pclk_info spdif_out_pclk_info[] = {
+	{
+		.pclk = &gen_synth2_clk,
+		.pclk_val = SPEAR1340_SPDIF_OUT_GSYNT2_VAL,
+	}, {
+		.pclk = &i2s_src_pad_clk,
+		.pclk_val = SPEAR1340_SPDIF_OUT_I2S_PAD_VAL,
+	},
+};
+
+static struct pclk_sel spdif_out_pclk_sel = {
+	.pclk_info = spdif_out_pclk_info,
+	.pclk_count = ARRAY_SIZE(spdif_out_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_SPDIF_CLK_MASK,
+};
+
+static struct clk spdif_out_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SPDIF_OUT_CLK_ENB,
+	.pclk_sel = &spdif_out_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_SPDIF_OUT_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* SPDIF In clk */
+static struct pclk_info spdif_in_pclk_info[] = {
+	{
+		.pclk = &pll2_clk,
+		.pclk_val = SPEAR1340_SPDIF_IN_PLL2_VAL,
+	}, {
+		.pclk = &gen_synth3_clk,
+		.pclk_val = SPEAR1340_SPDIF_IN_GSYNT3_VAL,
+	},
+};
+
+static struct pclk_sel spdif_in_pclk_sel = {
+	.pclk_info = spdif_in_pclk_info,
+	.pclk_count = ARRAY_SIZE(spdif_in_pclk_info),
+	.pclk_sel_reg = VA_SPEAR1340_PERIP_CLK_CFG,
+	.pclk_sel_mask = SPEAR1340_SPDIF_CLK_MASK,
+};
+
+static struct clk spdif_in_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_SPDIF_IN_CLK_ENB,
+	.pclk_sel = &spdif_in_pclk_sel,
+	.pclk_sel_shift = SPEAR1340_SPDIF_IN_CLK_SHIFT,
+	.recalc = &follow_parent,
+};
+
+/* ACP clock */
+static struct clk acp_clk = {
+	.en_reg = VA_SPEAR1340_PERIP2_CLK_ENB,
+	.en_reg_bit = SPEAR1340_ACP_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* PLGPIO clock */
+static struct clk plgpio_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_PLGPIO_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* VIDEO_DEC clock */
+static struct clk video_dec_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_VIDEO_DEC_CLK_ENB,
+	.pclk = &gen_synth0_clk,
+	.recalc = &follow_parent,
+};
+
+/* VIDEO_ENC clock */
+static struct clk video_enc_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_VIDEO_ENC_CLK_ENB,
+	.pclk = &gen_synth1_clk,
+	.recalc = &follow_parent,
+};
+
+/* VIDEO Input Port clock */
+static struct clk video_input_port_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_VIDEO_IN_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* CAM0 clock */
+static struct clk cam0_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CAM0_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* CAM1 clock */
+static struct clk cam1_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CAM1_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* CAM2 clock */
+static struct clk cam2_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CAM2_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* CAM3 clock */
+static struct clk cam3_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_CAM3_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+/* pwm clock */
+static struct clk pwm_clk = {
+	.en_reg = VA_SPEAR1340_PERIP3_CLK_ENB,
+	.en_reg_bit = SPEAR1340_PWM_CLK_ENB,
+	.pclk = &ahb_clk,
+	.recalc = &follow_parent,
+};
+
+static struct clk dummy_apb_pclk;
+
+/* array of all spear 13xx clock lookups */
+static struct clk_lookup spear1340_clk_lookups[] = {
+	{ .con_id = "apb_pclk",			.clk = &dummy_apb_pclk},
+	/* root clks */
+	{.con_id = "osc1_24m_clk",		.clk = &osc1_24m_clk},
+	{.con_id = "osc2_32k_clk",		.clk = &osc2_32k_clk},
+	{.con_id = "osc3_25m_clk",		.clk = &osc3_25m_clk},
+
+	/* clock derived from 32 KHz osc clk */
+	{.dev_id = "rtc-spear",			.clk = &rtc_clk},
+
+	/* clock derived from 24/25 MHz osc1/osc3 clk */
+	{.con_id = "vco1_clk",			.clk = &vco1_clk},
+	{.con_id = "vco2_clk",			.clk = &vco2_clk},
+	{.con_id = "vco3_clk",			.clk = &vco3_clk},
+	{.con_id = "vco4_clk",			.clk = &vco4_clk},
+	{.con_id = "pll5_clk",			.clk = &pll5_clk},
+	{.con_id = "pll6_clk",			.clk = &pll6_clk},
+
+	/* clock derived from vco1-5 clk */
+	{.con_id = "pll1_clk",			.clk = &pll1_clk},
+	{.con_id = "pll2_clk",			.clk = &pll2_clk},
+	{.con_id = "pll3_clk",			.clk = &pll3_clk},
+	{.con_id = "pll4_clk",			.clk = &pll4_clk},
+	{.con_id = "vco1div2_clk",		.clk = &vco1div2_clk},
+	{.con_id = "vco1div4_clk",		.clk = &vco1div4_clk},
+	{.con_id = "vco2div2_clk",		.clk = &vco2div2_clk},
+	{.con_id = "vco3div2_clk",		.clk = &vco3div2_clk},
+
+	/* System synth clk */
+	{.con_id = "sys_synth_clk",		.clk = &sys_synth_clk},
+	{.con_id = "amba_synth_clk",		.clk = &amba_synth_clk},
+
+	/* clock derived from pll1 clk */
+	{.con_id = "ddr_clk",			.clk = &ddr_clk},
+
+	/* sys clk */
+	{.con_id = "sys_clk",			.clk = &sys_clk},
+
+	/* clock derived from sys clk */
+	{.con_id = "cpu_clk",			.clk = &cpu_clk},
+
+	/* clock derived from cpu clock */
+	{.con_id = "cpu_clk_div3",		.clk = &cpu_clk_div3},
+	{.con_id = "ahb_clk",			.clk = &ahb_clk},
+	{.con_id = "apb_clk",			.clk = &apb_clk},
+
+	/* synthesizers/prescaled clocks */
+	{.con_id = "c3_synth_clk",		.clk = &c3_synth_clk},
+	{.con_id = "gmii_125m_pad_clk",		.clk = &gmii_125m_pad},
+	{.con_id = "clcd_synth_clk",		.clk = &clcd_synth_clk},
+	{.con_id = "uart0_synth_clk",		.clk = &uart0_synth_clk},
+	{.con_id = "uart1_synth_clk",		.clk = &uart1_synth_clk},
+	{.con_id = "sdhci_synth_clk",		.clk = &sdhci_synth_clk},
+	{.con_id = "cfxd_synth_clk",		.clk = &cfxd_synth_clk},
+	{.con_id = "gmac_phy_input_clk",	.clk = &gmac_phy_input_clk},
+	{.con_id = "gmac_phy_synth_clk",	.clk = &gmac_phy_synth_clk},
+	{.con_id = "stmmacphy.0",		.clk = &gmac_phy0_clk},
+	{.dev_id = "gen_synth0_clk",		.clk = &gen_synth0_clk},
+	{.dev_id = "gen_synth1_clk",		.clk = &gen_synth1_clk},
+	{.dev_id = "gen_synth2_clk",		.clk = &gen_synth2_clk},
+	{.dev_id = "gen_synth3_clk",		.clk = &gen_synth3_clk},
+
+	/* i2s refout and sclk clks */
+	{.con_id = "i2s_src_pad_clk",		.clk = &i2s_src_pad_clk},
+	{.con_id = "i2s_src_clk",		.clk = &i2s_src_clk},
+	{.con_id = "i2s_prs1_clk",		.clk = &i2s_prs1_clk},
+	{.con_id = "i2s_ref_clk",		.clk = &i2s_ref_clk},
+	{.con_id = "i2s_ref_pad_clk",		.clk = &i2s_ref_pad_clk},
+	{.con_id = "i2s_sclk_clk",		.clk = &i2s_sclk_clk},
+
+	/* cec clks */
+	{.dev_id = "spear_cec.0",		.clk = &cec0_clk},
+	{.dev_id = "spear_cec.1",		.clk = &cec1_clk},
+
+	/* clocks having multiple parent source from above clocks */
+	{.dev_id = "clcd_pixel_clk",		.clk = &clcd_pixel_clk},
+	{.dev_id = "clcd-db9000",		.clk = &clcd_clk},
+	{.dev_id = "gpt0",			.clk = &gpt0_clk},
+	{.dev_id = "gpt1",			.clk = &gpt1_clk},
+	{.dev_id = "gpt2",			.clk = &gpt2_clk},
+	{.dev_id = "gpt3",			.clk = &gpt3_clk},
+	{.dev_id = "uart",			.clk = &uart0_clk},
+	{.dev_id = "uart1",			.clk = &uart1_clk},
+	{.dev_id = "sdhci",			.clk = &sdhci_clk},
+	{.dev_id = "arasan_cf",			.clk = &cfxd_clk},
+	{.dev_id = "arasan_xd",			.clk = &cfxd_clk},
+	{.dev_id = "mali",			.clk = &mali_clk},
+	{.dev_id = "spdif-out",			.clk = &spdif_out_clk},
+	{.dev_id = "spdif-in",			.clk = &spdif_in_clk},
+	{.dev_id = "video_dec",			.clk = &video_dec_clk},
+	{.dev_id = "video_enc",			.clk = &video_enc_clk},
+
+	/* clock derived from ahb clk */
+	{.dev_id = "smi",			.clk = &smi_clk},
+	{.con_id = "usbh.0_clk",		.clk = &uhci0_clk},
+	{.con_id = "usbh.1_clk",		.clk = &uhci1_clk},
+	{.dev_id = "uoc",			.clk = &uoc_clk},
+	{.dev_id = "i2c_designware.0",		.clk = &i2c0_clk},
+	{.dev_id = "i2c_designware.1",		.clk = &i2c1_clk},
+	{.con_id = "dmac_pclk",			.clk = &dma_pclk},
+	{.dev_id = "dw_dmac.0",			.clk = &dma0_clk},
+	{.dev_id = "dw_dmac.1",			.clk = &dma1_clk},
+	{.dev_id = "stmmaceth.0",		.clk = &gmac_clk},
+	{.dev_id = "c3",			.clk = &c3_clk},
+	{.con_id = "pcie_sata_pclk",		.clk = &pcie_sata_pclk},
+	{.dev_id = "dw_pcie.0",			.clk = &pcie_clk},
+	{.dev_id = "ahci",			.clk = &sata_clk},
+	{.con_id = "fsmc",			.clk = &fsmc_clk},
+	{.dev_id = "fsmc-nand",                 .clk = &fsmc_nand_clk},
+	{.dev_id = "fsmc-nor",                  .clk = &fsmc_nor_clk},
+	{.dev_id = "sysram0",			.clk = &sysram0_clk},
+	{.dev_id = "sysram1",			.clk = &sysram1_clk},
+	{.dev_id = "acp_clk",			.clk = &acp_clk},
+	{.dev_id = "spear_camif.0",		.clk = &cam0_clk},
+	{.dev_id = "spear_camif.1",		.clk = &cam1_clk},
+	{.dev_id = "spear_camif.2",		.clk = &cam2_clk},
+	{.dev_id = "spear_camif.3",		.clk = &cam3_clk},
+	{.dev_id = "plgpio",			.clk = &plgpio_clk},
+	{.dev_id = "pwm",			.clk = &pwm_clk},
+	{.dev_id = "spear_vip",			.clk = &video_input_port_clk},
+	{.con_id = "adc_synth_clk",		.clk = &adc_synth_clk},
+	{.dev_id = "adc",			.clk = &adc_clk},
+
+	/* clock derived from apb clk */
+	{.dev_id = "designware-i2s.0",		.clk = &i2s_play_clk},
+	{.dev_id = "designware-i2s.1",		.clk = &i2s_rec_clk},
+	{.dev_id = "ssp-pl022",			.clk = &ssp_clk},
+	{.dev_id = "gpio0",			.clk = &gpio0_clk},
+	{.dev_id = "gpio1",			.clk = &gpio1_clk},
+	{.dev_id = "keyboard",			.clk = &kbd_clk},
+	{.dev_id = "cortexa9-wdt",		.clk = &wdt_clk},
+	{.dev_id = "spear_thermal",		.clk = &thermal_clk},
+};
+
+/* machine clk init */
+void __init spear1340_clk_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(spear1340_clk_lookups); i++)
+		clk_register(&spear1340_clk_lookups[i]);
+
+	clk_init(&ddr_clk);
+}
diff --git a/arch/arm/mach-spear13xx/spear1340_evb.c b/arch/arm/mach-spear13xx/spear1340_evb.c
new file mode 100644
index 0000000..c95aff0
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1340_evb.c
@@ -0,0 +1,706 @@
+/*
+ * arch/arm/mach-spear13xx/spear1340_evb.c
+ *
+ * SPEAr1340 evaluation board source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/l3g4200d.h>
+#include <linux/i2c/lsm303dlh.h>
+#include <linux/irq.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/spear_smi.h>
+#include <linux/netdevice.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <plat/i2c.h>
+#include <plat/keyboard.h>
+#include <plat/plug_board.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear1340_misc_regs.h>
+#include <media/soc_camera.h>
+#include <media/vip.h>
+
+/* camera sensor registeration */
+static struct i2c_board_info vs6725_camera_sensor_info = {
+	I2C_BOARD_INFO("vs6725", 0x10),
+};
+
+/* Camera power: default is ON */
+static int vs6725_cam_power(struct device *dev, int val)
+{
+	int ret = 0;
+	static bool gpio_avail;
+
+	if (!gpio_avail) {
+
+		ret = gpio_request(STMPE801_GPIO_6, "vs6725-power");
+		if (!ret) {
+			gpio_direction_output(STMPE801_GPIO_6, 0);
+		} else {
+			pr_err("gpio request fail for STMPE801_GPIO_6\n");
+			goto out;
+		}
+
+		gpio_avail = true;
+	}
+
+	/* turn on/off the CE pin for camera sensor */
+	gpio_set_value_cansleep(STMPE801_GPIO_6, val);
+
+	/*
+	 * Now check if we really were able to set the desired value on CE
+	 * pin of the sensor
+	 */
+	ret = gpio_get_value_cansleep(STMPE801_GPIO_6);
+	if (ret != val) {
+		pr_err("gpio get_val returned %d but expected %d\n", ret, val);
+		ret = -ERESTARTSYS;
+	}
+
+out:
+	return ret;
+}
+
+static struct soc_camera_link vs6725_cam3_sensor_iclink = {
+	.bus_id = 3,	/* sensor is connected to camera device 3 */
+	.i2c_adapter_id = 0, /* sensor is connected to i2c controller 0 */
+	.board_info = &vs6725_camera_sensor_info,
+	.power = vs6725_cam_power,
+	.module_name = "vs6725",
+};
+
+static struct platform_device spear1340_cam3_sensor_device = {
+	.name = "soc-camera-pdrv",
+	.id = -1,
+	.dev = {
+		.platform_data = &vs6725_cam3_sensor_iclink,
+	},
+};
+
+/*
+ * Pad multiplexing for making few pads as plgpio's.
+ * Please retain original values and addresses, and update only mask as
+ * required.
+ * For example: if we need to enable plgpio's on pads: 15, 28, 45 & 102.
+ * They corresponds to following bits in registers: 16, 29, 46 & 103
+ * So following mask entries will solve this purpose:
+ * Reg1: .mask = 0x20010000,
+ * Reg2: .mask = 0x00004000,
+ * Reg4: .mask = 0x00000080,
+ *
+ * Note: Counting of bits and pads start from 0.
+ */
+static struct pmx_mux_reg pmx_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		/*
+		 * PLGPIO 12 is used for interrupt reception from
+		 * STMPE801.
+		 */
+		.mask = 0x2000,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = 0x00000020, /* enabling I2S_OUT_DATA_3 as PL-GPIO */
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = 0x1000000,
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpios_modes[] = {
+	{
+		.mux_regs = pmx_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpios_mux),
+	},
+};
+
+static struct pmx_dev spear1340_pmx_plgpios = {
+	.name = "plgpios",
+	.modes = pmx_plgpios_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpios_modes),
+};
+
+/* Pad Multiplexing for LSM303DLH Accelerometer and Magnetometer device */
+static struct pmx_mux_reg lsm303_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = 0x1180, /* PLGPIO: 70, 71, 75 */
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode lsm303_plgpios_modes[] = {
+	{
+		.mux_regs = lsm303_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(lsm303_plgpios_mux),
+	},
+};
+
+struct pmx_dev spear1340_pmx_lsm303 = {
+	.name = "lsm303_acc_mag",
+	.modes = lsm303_plgpios_modes,
+	.mode_count = ARRAY_SIZE(lsm303_plgpios_modes),
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/*
+	 * Keep pads_as_gpio as the first element in this array. Don't ever
+	 * remove it. It makes all pads as gpio's in starting, and then pads are
+	 * configured as peripherals wherever required.
+	 */
+	&spear1340_pmx_pads_as_gpio,
+	&spear1340_pmx_fsmc_8bit,
+	&spear1340_pmx_keyboard_row_col,
+#if !defined(CONFIG_PM)
+	&spear1340_pmx_keyboard_col5,
+#endif
+	&spear1340_pmx_uart0_enh,
+	&spear1340_pmx_i2c1,
+	&spear1340_pmx_spdif_in,
+	&spear1340_pmx_ssp0_cs1,
+#if !defined(CONFIG_PM)
+	&spear1340_pmx_pwm2,
+#endif
+	&spear1340_pmx_pwm3,
+	&spear1340_pmx_smi,
+	&spear1340_pmx_ssp0,
+	&spear1340_pmx_uart0,
+	&spear1340_pmx_i2s_in,
+	&spear1340_pmx_i2s_out,
+	&spear1340_pmx_gmac,
+	&spear1340_pmx_ssp0_cs3,
+	&spear1340_pmx_i2c0,
+	&spear1340_pmx_cam3,
+	&spear1340_pmx_cec0,
+	&spear1340_pmx_cec1,
+	&spear1340_pmx_spdif_out,
+	&spear1340_pmx_mcif,
+	&spear1340_pmx_sdhci,
+	&spear1340_pmx_clcd,
+	&spear1340_pmx_clcd_gpio_pd,
+	&spear1340_pmx_devs_grp,
+	&spear1340_pmx_rgmii,
+	&spear1340_pmx_sata,
+	&spear1340_pmx_lsm303,
+
+	/* Keep this entry at the bottom of table to override earlier setting */
+	&spear1340_pmx_plgpios,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+
+	/* spear1340 specific devices */
+	&spear1340_uart1_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_db9000_clcd_device,
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear13xx_wdt_device,
+
+	/* spear1340 specific devices */
+	&spear1340_camif3_device,
+	&spear1340_cam3_sensor_device,
+	&spear1340_cec0_device,
+	&spear1340_cec1_device,
+	&spear1340_cpufreq_device,
+#ifdef CONFIG_DRM_MALI
+	&spear1340_device_mali_drm,
+#endif
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear1340_gpiokeys_device,
+#endif
+	&spear1340_i2c1_device,
+	&spear1340_i2s_play_device,
+	&spear1340_i2s_record_device,
+	&spear1340_nand_device,
+	&spear1340_otg_device,
+	&spear1340_plgpio_device,
+	&spear1340_pwm_device,
+	&spear1340_sata0_device,
+	&spear1340_spdif_in_device,
+	&spear1340_spdif_out_device,
+	&spear1340_thermal_device,
+	&spear1340_video_dec_device,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x80000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x80000,
+		.size = 6 * 0x80000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 6) * 0x80000,
+		.size = 24 * 0x80000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 24) * 0x80000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+static const struct fsmc_rbpin fsmc_rbpin __initconst = {
+	/*
+	 * PLGPIO 247 is also enabled along with this ready/busy feature.
+	 * Disable the plgpio when ready/busy pin is being used by controller
+	 * itself
+	 */
+	.use_pin = FSMC_RB_GPIO,
+	.gpio_pin = PLGPIO_247,
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+	.rbpin = &fsmc_rbpin,
+};
+
+/* arasan compact flash controller's platform data */
+static struct arasan_cf_pdata cf_pdata = {
+	.cf_if_clk = CF_IF_CLK_166M,
+	.quirk = CF_BROKEN_UDMA,
+	.dma_priv = &cf_dma_priv,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_6x6_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_2x2,
+};
+
+/* Ethernet specific plat data */
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 16,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = -1,
+	.interface = PHY_INTERFACE_MODE_RGMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+/* Initializing platform data for spear1340 evb specific I2C devices */
+
+/* STMPE801 platform data */
+static struct stmpe_gpio_platform_data stmpe801_gpio = {
+	.gpio_base = SPEAR_STMPE801_GPIO_BASE,
+	.norequest_mask = 0,
+};
+static struct stmpe_platform_data stmpe801_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_GPIO,
+	.irq_base = SPEAR_STMPE801_GPIO_INT_BASE,
+	.irq_gpio = GPIO0_4,
+	.irq_over_gpio = true,
+	.irq_trigger = IRQF_TRIGGER_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.gpio = &stmpe801_gpio,
+};
+
+static struct i2c_board_info spear1340_evb_i2c_board_stmpe801 = {
+	I2C_BOARD_INFO("stmpe801", 0x41),
+	.platform_data = &stmpe801_pdata,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_stmpe801 = {
+	.board = &spear1340_evb_i2c_board_stmpe801,
+	.busnum = 1,
+};
+
+/* Gyroscope platform data */
+static struct l3g4200d_gyr_platform_data l3g4200d_pdata = {
+	.poll_interval = 5,
+	.min_interval = 2,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+};
+
+/* LSM303DLH Accelerometer and Magnetometer platform data */
+static struct lsm303dlh_platform_data lsm303dlh_a_pdata = {
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.input_poll_dev = 1,
+	.name_a = "lsm303dlh_a",
+#ifdef CONFIG_INPUT_ST_LSM303DLH_INPUT_DEVICE
+	.irq_a1 = PLGPIO_71,
+	.irq_a2 = PLGPIO_75,
+#endif
+};
+
+static struct lsm303dlh_platform_data lsm303dlh_m_pdata = {
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.name_m = "lsm303dlh_m",
+#ifdef CONFIG_INPUT_ST_LSM303DLH_INPUT_DEVICE
+	.irq_m = PLGPIO_70,
+#endif
+};
+
+static struct i2c_board_info spear1340_evb_i2c_board_l3g4200d_gyr = {
+	/* gyroscope board info */
+	.type = "l3g4200d_gyr",
+	.addr = 0x69,
+	.platform_data = &l3g4200d_pdata,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_l3g4200d_gyr = {
+	.board = &spear1340_evb_i2c_board_l3g4200d_gyr,
+	.busnum = 0,
+};
+
+/* lsm303dlh accelerometer board info */
+static struct i2c_board_info spear1340_evb_i2c_lsm303dlh_acc = {
+	.type = "lsm303dlh_a",
+	.addr = 0x19,
+	.platform_data = &lsm303dlh_a_pdata,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_lsm303dlh_a = {
+	.board = &spear1340_evb_i2c_lsm303dlh_acc,
+	.busnum = 0,
+};
+
+/* lsm303dlh magnetometer board info */
+static struct i2c_board_info spear1340_evb_i2c_lsm303dlh_mag = {
+	.type = "lsm303dlh_m",
+	.addr = 0x1E,
+	.platform_data = &lsm303dlh_m_pdata,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_lsm303dlh_m = {
+	.board = &spear1340_evb_i2c_lsm303dlh_mag,
+	.busnum = 0,
+};
+
+static struct i2c_board_info spear1340_evb_i2c_board_eeprom0 = {
+	.type = "eeprom",
+	.addr = 0x50,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_eeprom0 = {
+	.board = &spear1340_evb_i2c_board_eeprom0,
+	.busnum = 0,
+};
+
+static struct i2c_board_info spear1340_evb_i2c_board_eeprom1 = {
+	.type = "eeprom",
+	.addr = 0x51,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_eeprom1 = {
+	.board = &spear1340_evb_i2c_board_eeprom1,
+	.busnum = 0,
+};
+
+static struct i2c_board_info spear1340_evb_i2c_board_sta529 = {
+	.type = "sta529",
+	.addr = 0x1a,
+};
+
+struct i2c_dev_info spear1340_evb_i2c_sta529 = {
+	.board = &spear1340_evb_i2c_board_sta529,
+	.busnum = 0,
+};
+
+static struct i2c_dev_info *i2c_devs[] __initdata = {
+	&spear1340_evb_i2c_stmpe801,
+	&spear1340_evb_i2c_l3g4200d_gyr,
+	&spear1340_evb_i2c_eeprom0,
+	&spear1340_evb_i2c_eeprom1,
+	&spear1340_evb_i2c_lsm303dlh_a,
+	&spear1340_evb_i2c_lsm303dlh_m,
+	&spear1340_evb_i2c_sta529,
+};
+
+/* Definitions for SPI Devices*/
+
+/* spi master's configuration routine */
+DECLARE_SPI_CS_CFG(0, VA_SPEAR1340_PERIP_CFG, SPEAR1340_SSP_CS_SEL_MASK,
+		SPEAR1340_SSP_CS_SEL_SHIFT, SPEAR1340_SSP_CS_CTL_MASK,
+		SPEAR1340_SSP_CS_CTL_SHIFT, SPEAR1340_SSP_CS_CTL_SW,
+		SPEAR1340_SSP_CS_VAL_MASK, SPEAR1340_SSP_CS_VAL_SHIFT);
+
+/* spi0 flash Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, flash, SPEAR1340_SSP_CS_SEL_CS0);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_control);
+
+/* spi0 spidev Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, dev, SPEAR1340_SSP_CS_SEL_CS2);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_control);
+
+/* spi0 touch screen Chip Select Control function, controlled by gpio pin */
+DECLARE_SPI_CS_CONTROL(0, ts, SPEAR1340_SSP_CS_SEL_CS1);
+/* spi0 touch screen Info structure */
+static struct pl022_config_chip spi0_ts_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.slave_tx_disable = 0,
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = spi0_ts_cs_control,
+};
+
+static struct stmpe_ts_platform_data stmpe610_ts_pdata = {
+	.sample_time = 4, /* 80 clocks */
+	.mod_12b = 1, /* 12 bit */
+	.ref_sel = 0, /* Internal */
+	.adc_freq = 1, /* 3.25 MHz */
+	.ave_ctrl = 1, /* 2 samples */
+	.touch_det_delay = 2, /* 100 us */
+	.settling = 2, /* 500 us */
+	.fraction_z = 7,
+	.i_drive = 1, /* 50 to 80 mA */
+};
+
+static struct stmpe_platform_data stmpe610_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = SPEAR_STMPE610_INT_BASE,
+	.irq_trigger = IRQ_TYPE_EDGE_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.irq_over_gpio = true,
+	.irq_gpio = PLGPIO_100,
+	.ts = &stmpe610_ts_pdata,
+};
+
+struct spi_board_info spear1340_evb_spi_m25p80 = {
+	.modalias = "m25p80",
+	.controller_data = &spi0_flash_chip_info,
+	.max_speed_hz = 12000000,
+	.bus_num = 0,
+	.chip_select = SPEAR1340_SSP_CS_SEL_CS0,
+	.mode = SPI_MODE_3,
+};
+struct spi_board_info spear1340_evb_spi_stmpe610 = {
+	.modalias = "stmpe610",
+	.platform_data = &stmpe610_pdata,
+	.controller_data = &spi0_ts_chip_info,
+	.max_speed_hz = 1000000,
+	.bus_num = 0,
+	.chip_select = SPEAR1340_SSP_CS_SEL_CS1,
+	.mode = SPI_MODE_1,
+};
+struct spi_board_info spear1340_evb_spi_spidev = {
+	.modalias = "spidev",
+	.controller_data = &spi0_dev_chip_info,
+	.max_speed_hz = 25000000,
+	.bus_num = 0,
+	.chip_select = SPEAR1340_SSP_CS_SEL_CS2,
+	.mode = SPI_MODE_1,
+};
+
+static struct spi_board_info *spi_board[] __initdata = {
+	&spear1340_evb_spi_m25p80,
+	&spear1340_evb_spi_stmpe610,
+	&spear1340_evb_spi_spidev,
+};
+
+static void
+spear1340_evb_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+
+#ifdef CONFIG_VIDEO_SPEAR_VIP
+	vip_buffer_fixup(mi);
+#endif
+}
+
+static void __init spear1340_evb_init(void)
+{
+	unsigned int i;
+
+	/* set compact flash plat data */
+	set_arasan_cf_pdata(&spear13xx_cf_device, &cf_pdata);
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* call spear1340 machine init function */
+	spear1340_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+	/*
+	 * SPEAr1340 FSMC cannot used as NOR and NAND at the same time
+	 * For the moment, disable NOR and use NAND only
+	 * If NOR is needed, enable NOR's code and disable all code for NOR.
+	 */
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear1340_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1340_nand_device.name);
+
+#ifdef CONFIG_SPEAR1340_PLUG_BOARDS
+	/* Check if plug boards are requested or not */
+	if (spear_pb_present()) {
+		struct plug_board_info pb_info;
+		int ret;
+
+		pb_info.pdevs = plat_devs;
+		pb_info.pcnt = ARRAY_SIZE(plat_devs);
+		pb_info.adevs = amba_devs;
+		pb_info.acnt = ARRAY_SIZE(amba_devs);
+		pb_info.spi_devs = spi_board;
+		pb_info.spi_cnt = ARRAY_SIZE(spi_board);
+		pb_info.i2c_devs = i2c_devs;
+		pb_info.i2c_cnt = ARRAY_SIZE(i2c_devs);
+		ret = spear1340_pb_init(&pb_info);
+		if (!ret)
+			return;
+	}
+#endif
+
+	/* Register spear1340 evb board specific i2c slave devices */
+	for (i = 0; i < ARRAY_SIZE(i2c_devs); i++)
+		i2c_register_board_info(i2c_devs[i]->busnum,
+				i2c_devs[i]->board, 1);
+
+	/* Register SPI Board */
+	for (i = 0; i < ARRAY_SIZE(spi_board); i++)
+		spi_register_board_info(spi_board[i], 1);
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR1340_EVB, "ST-SPEAR1340-EVB")
+	.atag_offset	=	0x100,
+	.fixup		=	spear1340_evb_fixup,
+	.map_io		=	spear13xx_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear1340_evb_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear1340_lcad.c b/arch/arm/mach-spear13xx/spear1340_lcad.c
new file mode 100644
index 0000000..6e4079b
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1340_lcad.c
@@ -0,0 +1,474 @@
+/*
+ * arch/arm/mach-spear13xx/spear1340_lcad.c
+ *
+ * SPEAr1340 based Low Cost Access Device (LCAD) Board's source file
+ *
+ * Copyright (C) 2012 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/amba/pl061.h>
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#endif
+
+#include <linux/i2c.h>
+#include <linux/i2c/lsm303dlh.h>
+#include <linux/irq.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/spi/spi.h>
+#include <media/soc_camera.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <plat/i2c.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear1340_misc_regs.h>
+
+/* camera sensor registeration */
+static struct i2c_board_info hi704_camera_sensor_info = {
+	I2C_BOARD_INFO("hi704", 0x30),
+};
+
+/* Camera power: default is ON */
+static int hi704_cam_power(struct device *dev, int val)
+{
+	int ret;
+	static bool hi704_powered;
+
+	if (!hi704_powered) {
+
+		/*
+		 * hi704 is chip enable pin is connected to 2 gpio's on board
+		 * Keep one gpio always in input to keep the board safe.
+		 * Similarly, 2 spear gpio's connect to vsync. So, keep 1 in
+		 * input mode.
+		 */
+		ret = gpio_request(PLGPIO_40, "hi704-ce");
+		ret |= gpio_request(PLGPIO_51, "hi704-ce-psuedo");
+		ret |= gpio_request(PLGPIO_32, "hi704-vsync-psuedo");
+
+		if (!ret) {
+			gpio_direction_input(PLGPIO_51);
+			gpio_direction_input(PLGPIO_32);
+			gpio_direction_output(PLGPIO_40, 1);
+		} else {
+			pr_err("gpio request failed\n");
+			return ret;
+		}
+		hi704_powered = true;
+	}
+
+	/* turn on/off the CE pin for camera sensor */
+	if (val)
+		gpio_set_value_cansleep(PLGPIO_40, 0);
+	else
+		gpio_set_value_cansleep(PLGPIO_40, 1);
+
+	return 0;
+}
+
+static struct soc_camera_link hi704_cam0_sensor_iclink = {
+	.bus_id = 0,	/* sensor is connected to camera device */
+	.i2c_adapter_id = 1, /* sensor is connected to i2c controller 0 */
+	.board_info = &hi704_camera_sensor_info,
+	.power = hi704_cam_power,
+	.module_name = "hi704",
+};
+
+static struct platform_device cam0_sensor_device = {
+	.name = "soc-camera-pdrv",
+	.id = -1,
+	.dev = {
+		.platform_data = &hi704_cam0_sensor_iclink,
+	},
+};
+
+/*
+ * Pad multiplexing for making few pads as plgpio's.
+ * Please retain original values and addresses, and update only mask as
+ * required.
+ * For example: if we need to enable plgpio's on pads: 15, 28, 45 & 102.
+ * They corresponds to following bits in registers: 16, 29, 46 & 103
+ * So following mask entries will solve this purpose:
+ * Reg1: .mask = 0x20010000,
+ * Reg2: .mask = 0x00004000,
+ * Reg4: .mask = 0x00000080,
+ *
+ * Note: Counting of bits and pads start from 0.
+ */
+static struct pmx_mux_reg pmx_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = 0x0,
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpios_modes[] = {
+	{
+		.mux_regs = pmx_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpios_mux),
+	},
+};
+
+static struct pmx_dev pmx_plgpios = {
+	.name = "plgpios",
+	.modes = pmx_plgpios_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpios_modes),
+};
+
+/* SPEAr GPIO Buttons Info */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+/* SPEAr GPIO Buttons definition */
+#define SPEAR_GPIO_BTN9	9
+
+static struct gpio_keys_button spear1340_lcad_gpio_keys_table[] = {
+	{
+		.code = BTN_0,
+		.gpio = SPEAR_GPIO_BTN9,
+		.active_low = 0,
+		.desc = "gpio-keys: BTN0",
+		.type = EV_KEY,
+		.wakeup = 1,
+		.debounce_interval = 20,
+	}, {
+		.code = KEY_BACK,
+		.gpio = PLGPIO_53,
+		.active_low = 1,
+		.desc = "gpio-keys: BTN1:BACK",
+		.type = EV_KEY,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	}, {
+		.code = KEY_MENU,
+		.gpio = PLGPIO_52,
+		.active_low = 1,
+		.desc = "gpio-keys: BTN2:MENU",
+		.type = EV_KEY,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	}, {
+		.code = KEY_HOME,
+		.gpio = PLGPIO_48,
+		.active_low = 1,
+		.desc = "gpio-keys: BTN3:HOME",
+		.type = EV_KEY,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	}, {
+		.code = KEY_VOLUMEDOWN,
+		.gpio = PLGPIO_37,
+		.active_low = 1,
+		.desc = "gpio-keys: BTN4:VOLUMEDOWN",
+		.type = EV_KEY,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	}, {
+		.code = KEY_VOLUMEUP,
+		.gpio = PLGPIO_42,
+		.active_low = 1,
+		.desc = "gpio-keys: BTN5:VOLUMEUP",
+		.type = EV_KEY,
+		.wakeup = 0,
+		.debounce_interval = 20,
+	},
+};
+
+static struct gpio_keys_platform_data spear1340_lcad_gpio_keys_data = {
+	.buttons = spear1340_lcad_gpio_keys_table,
+	.nbuttons = ARRAY_SIZE(spear1340_lcad_gpio_keys_table),
+};
+
+struct platform_device spear1340_lcad_gpiokeys_device = {
+	.name = "gpio-keys",
+	.dev = {
+		.platform_data = &spear1340_lcad_gpio_keys_data,
+	},
+};
+#endif
+
+/* Pad Multiplexing for LSM303DLH Accelerometer device */
+static struct pmx_mux_reg lsm303_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = 0x42100, /* PLGPIO: 39, 44, 49 */
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode lsm303_plgpios_modes[] = {
+	{
+		.mux_regs = lsm303_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(lsm303_plgpios_mux),
+	},
+};
+
+struct pmx_dev pmx_lsm303 = {
+	.name = "lsm303_acc_mag",
+	.modes = lsm303_plgpios_modes,
+	.mode_count = ARRAY_SIZE(lsm303_plgpios_modes),
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/*
+	 * Keep pads_as_gpio as the first element in this array. Don't ever
+	 * remove it. It makes all pads as gpio's in starting, and then pads are
+	 * configured as peripherals wherever required.
+	 */
+	&spear1340_pmx_pads_as_gpio,
+	&spear1340_pmx_fsmc_8bit,
+	&spear1340_pmx_i2c1,
+	&spear1340_pmx_ssp0_cs1,
+	&spear1340_pmx_ssp0,
+	&spear1340_pmx_uart0,
+	&spear1340_pmx_i2s_in,
+	&spear1340_pmx_i2s_out,
+	&spear1340_pmx_i2c0,
+	&spear1340_pmx_mcif,
+	&spear1340_pmx_sdhci,
+	&spear1340_pmx_cam0,
+	&spear1340_pmx_clcd,
+	&spear1340_pmx_clcd_gpio_pd,
+	&spear1340_pmx_devs_grp,
+	&pmx_lsm303,
+
+	/* Keep this entry at the bottom of table to override earlier setting */
+	&pmx_plgpios,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_db9000_clcd_device,
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_i2c_device,
+	&spear1340_nand_device,
+	&spear1340_i2s_play_device,
+	&spear1340_i2s_record_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_wdt_device,
+
+	/* spear1340 specific devices */
+	&spear1340_camif0_device,
+	&cam0_sensor_device,
+	&spear1340_i2c1_device,
+	&spear1340_plgpio_device,
+	&spear1340_otg_device,
+	&spear1340_thermal_device,
+
+	/* spear1340 lcad specific devices */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear1340_lcad_gpiokeys_device,
+#endif
+
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x80000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x80000,
+		.size = 6 * 0x80000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 6) * 0x80000,
+		.size = 24 * 0x80000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 24) * 0x80000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+/* I2S STA529 i2c board info */
+static struct i2c_board_info i2c_sta529 = {
+	.type = "sta529",
+	.addr = 0x1a,
+};
+
+static struct i2c_dev_info i2c_dev_sta529 = {
+	.board = &i2c_sta529,
+	.busnum = 0,
+};
+
+/* lsm303dlh accelerometer board info */
+static struct lsm303dlh_platform_data lsm303dlh_a_pdata = {
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.name_a = "lsm303dlh_a",
+#ifdef CONFIG_INPUT_ST_LSM303DLH_INPUT_DEVICE
+	.irq_a1 = PLGPIO_49,
+	.irq_a2 = PLGPIO_44,
+#endif
+};
+
+static struct i2c_board_info i2c_lsm303dlh_acc = {
+	.type = "lsm303dlh_a",
+	.addr = 0x19,
+	.platform_data = &lsm303dlh_a_pdata,
+};
+
+static struct i2c_dev_info i2c_dev_lsm303dlh_acc = {
+	.board = &i2c_lsm303dlh_acc,
+	.busnum = 1,
+};
+
+/* lsm303dlh magnetometer board info */
+static struct lsm303dlh_platform_data lsm303dlh_m_pdata = {
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+	.name_m = "lsm303dlh_m",
+#ifdef CONFIG_INPUT_ST_LSM303DLH_INPUT_DEVICE
+	.irq_m = PLGPIO_40,
+#endif
+};
+
+static struct i2c_board_info i2c_lsm303dlh_mag = {
+	.type = "lsm303dlh_m",
+	.addr = 0x1E,
+	.platform_data = &lsm303dlh_m_pdata,
+};
+
+static struct i2c_dev_info i2c_dev_lsm303dlh_mag = {
+	.board = &i2c_lsm303dlh_mag,
+	.busnum = 1,
+};
+
+static struct i2c_dev_info *i2c_devs[] __initdata = {
+	&i2c_dev_sta529,
+	&i2c_dev_lsm303dlh_acc,
+	&i2c_dev_lsm303dlh_mag,
+};
+
+static void
+lcad_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init lcad_init(void)
+{
+	unsigned int i;
+	struct pl061_platform_data *gpio0_pdata;
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* Set GPIO0_3 as 1 and others in input mode */
+	gpio0_pdata = dev_get_platdata(&spear13xx_gpio_device[0].dev);
+	gpio0_pdata->directions = 0x08;
+	gpio0_pdata->values = 0x08;
+
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear1340_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1340_nand_device.name);
+
+	/* call spear1340 machine init function */
+	spear1340_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Register spear1340 evb board specific i2c slave devices */
+	for (i = 0; i < ARRAY_SIZE(i2c_devs); i++)
+		i2c_register_board_info(i2c_devs[i]->busnum, i2c_devs[i]->board,
+				1);
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR1340_LCAD, "SPEAR1340-LCAD")
+	.atag_offset	=	0x100,
+	.fixup		=	lcad_fixup,
+	.map_io		=	spear13xx_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	lcad_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear1340_plug_boards.c b/arch/arm/mach-spear13xx/spear1340_plug_boards.c
new file mode 100644
index 0000000..f65c575
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear1340_plug_boards.c
@@ -0,0 +1,435 @@
+/*
+ * arch/arm/mach-spear13xx/spear1340_plug_boards.c
+ *
+ * SPEAr1340 plug boards source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define pr_fmt(fmt) "spear1340_pb: " fmt
+
+/*
+ * Following are the plug boards available with SPEAr1340:
+ * - gmii: gmii interface present for ethernet
+ * - rgmii: rgmii interface present for ethernet
+ * - etm: etm trace module
+ * - hdmi_rx: hdmi receiver
+ * - hdmi_tx: hdmi transmitter
+ * - cam0: camera sensor connected to camera device 0 of SoC
+ * - vga:
+ * - sata: It is not a separate physical plug board but a board
+ *   configuration
+ * - pcie: It is not a separate physical plug board but a board
+ *   configuration. sata and pcie are muxed and cannot be used together.
+ *
+ * Plug boards details can be found at:
+ * https://codex.cro.st.com/plugins/docman/?group_id=1309&action=show&id=164214
+ */
+
+#include <linux/ad9889b.h>
+#include <linux/bug.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/designware_i2s.h>
+#include <linux/list.h>
+#include <linux/phy.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <sound/pcm.h>
+#include <video/db9000fb.h>
+#include <plat/plug_board.h>
+#include <media/soc_camera.h>
+#include <media/vip.h>
+#include <plat/i2c.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear1340_misc_regs.h>
+#include <mach/spear_pcie.h>
+
+/*
+ * FIXME: Update this later when the HDMI receiver chip driver is available:
+ *
+ * 1. Here, we assume that the SIL9135A HDMI receiver chip supports
+ *    two inputs and a single output. The names of these macros can be
+ *    updated later.
+ * 2. Assume that SIL HDMI Rx chip supports all DV standards.
+ *    Also note that analog standards like PAL and NTSC is also supported by
+ *    VIP IP. So the STD supported by VIP driver will be a super-set
+ *    of these DV and analog standards.
+ */
+#define SIL9135A_INPUT		1
+#define SIL9135A_OUTPUT		2
+#define SIL9135A_I2C_ADDR	0x18
+#define SIL9135A_STD_ALL	(V4L2_DV_480P59_94 | V4L2_DV_576P50 |	\
+				V4L2_DV_720P24 | V4L2_DV_720P25 |	\
+				V4L2_DV_720P30 | V4L2_DV_720P50 |	\
+				V4L2_DV_720P59_94 | V4L2_DV_720P60 |	\
+				V4L2_DV_1080I29_97 | V4L2_DV_1080I30 |	\
+				V4L2_DV_1080I25 | V4L2_DV_1080I50 |	\
+				V4L2_DV_1080I60 | V4L2_DV_1080P24 |	\
+				V4L2_DV_1080P25 | V4L2_DV_1080P30 |	\
+				V4L2_DV_1080P50 | V4L2_DV_1080P60)
+static char pb_empty_array[] __initdata = {};
+
+
+/* Definitions specific to GMII plug board */
+#define gmii_pb_rm_adevs		pb_empty_array
+#define gmii_pb_rm_pdevs		pb_empty_array
+#define gmii_pb_add_adevs		pb_empty_array
+#define gmii_pb_add_pdevs		pb_empty_array
+#define gmii_pb_rm_spi_devs		pb_empty_array
+#define gmii_pb_add_spi_devs		pb_empty_array
+#define gmii_pb_rm_i2c_devs		pb_empty_array
+#define gmii_pb_add_i2c_devs		pb_empty_array
+
+/* padmux devices to enable */
+static struct pmx_dev *gmii_pb_pmx_devs[] = {
+	&spear1340_pmx_gmii,
+};
+
+static void __init gmii_pb_init(void)
+{
+	struct plat_stmmacenet_data *phy_data =
+		dev_get_platdata(&spear13xx_eth_device.dev);
+
+	phy_data->interface = PHY_INTERFACE_MODE_GMII;
+}
+
+
+/* Definitions specific to RGMII plug board */
+#define rgmii_pb_rm_adevs		pb_empty_array
+#define rgmii_pb_rm_pdevs		pb_empty_array
+#define rgmii_pb_add_adevs		pb_empty_array
+#define rgmii_pb_add_pdevs		pb_empty_array
+#define rgmii_pb_rm_spi_devs		pb_empty_array
+#define rgmii_pb_add_spi_devs		pb_empty_array
+#define rgmii_pb_rm_i2c_devs		pb_empty_array
+#define rgmii_pb_add_i2c_devs		pb_empty_array
+
+/* padmux devices to enable */
+static struct pmx_dev *rgmii_pb_pmx_devs[] = {
+	&spear1340_pmx_rgmii,
+};
+
+static void __init rgmii_pb_init(void)
+{
+	struct plat_stmmacenet_data *phy_data =
+		dev_get_platdata(&spear13xx_eth_device.dev);
+
+	phy_data->interface = PHY_INTERFACE_MODE_RGMII;
+}
+
+
+/* Definitions specific to ETM plug board */
+#define etm_pb_pmx_devs			pb_empty_array
+#define etm_pb_rm_adevs			pb_empty_array
+#define etm_pb_rm_pdevs			pb_empty_array
+#define etm_pb_add_adevs		pb_empty_array
+#define etm_pb_add_pdevs		pb_empty_array
+#define etm_pb_rm_spi_devs		pb_empty_array
+#define etm_pb_add_spi_devs		pb_empty_array
+#define etm_pb_rm_i2c_devs		pb_empty_array
+#define etm_pb_add_i2c_devs		pb_empty_array
+#define etm_pb_init			NULL
+
+
+/* Definitions specific to HDMI RX plug board */
+#define hdmi_rx_pb_rm_adevs		pb_empty_array
+#define hdmi_rx_pb_rm_pdevs		pb_empty_array
+#define hdmi_rx_pb_add_adevs		pb_empty_array
+#define hdmi_rx_pb_rm_spi_devs		pb_empty_array
+#define hdmi_rx_pb_add_spi_devs		pb_empty_array
+#define hdmi_rx_pb_rm_i2c_devs		pb_empty_array
+#define hdmi_rx_pb_add_i2c_devs		pb_empty_array
+
+/* sil9135a hdmi rx chip related */
+
+/*
+ * As HDMI RX is a dummy subdev for completing the flow to test VideoIN IP
+ * So, only single path is sufficient for the testing
+ */
+static struct v4l2_input sil9135a_inputs[] = {
+	{
+		.index = 0,
+		.name = "VideoIN",
+		.type = V4L2_INPUT_TYPE_CAMERA,
+		.std = SIL9135A_STD_ALL,
+	}
+};
+
+/*
+ * this is the route info for connecting each input of the SIL9135A
+ * hdmi receiver to its output which eventually goes to vip.
+ * There is a one to one correspondence with sil9135a_inputs.
+ */
+static struct vip_subdev_route sil9135a_routes[] = {
+	{
+		.input = SIL9135A_INPUT,
+		.output = SIL9135A_OUTPUT,
+	}
+};
+
+/* info regarding the various subdevs connected to VIP */
+static struct vip_subdev_info vip_sdev_info[] = {
+	/* SIL9135A hdmi receiver */
+	{
+		.name = "sil9135a",
+		.grp_id = 0,
+		.num_inputs = ARRAY_SIZE(sil9135a_inputs),
+		.inputs = sil9135a_inputs,
+		.routes = sil9135a_routes,
+		.can_route = 1,
+		.board_info = {
+			I2C_BOARD_INFO("sil9135a", SIL9135A_I2C_ADDR),
+			/*
+			 * TODO: we can add some platform specific
+			 * data for HDMI receiver chip here, if needed.
+			 */
+		},
+	},
+};
+
+/*
+ * some of the VIP features cannot be programmed via standard V4L2
+ * ioctls, so we configure them here.
+ */
+static struct vip_config vip_config_info = {
+	.vsync_pol = POL_ACTIVE_LOW,
+	.hsync_pol = POL_ACTIVE_LOW,
+	.rgb_width = THIRTYTWO_BIT,
+	.vdo_mode = SINGLE_PORT,
+	.pix_clk_pol = POL_ACTIVE_LOW,
+};
+
+/*
+ * a lot of VIP subdev specific params can change with a change in the
+ * EVB being used, so we need to be careful while populating these
+ * details.
+ */
+static struct vip_plat_data vip_board_specific_data = {
+	.card_name = "spear_vip",
+	.config = &vip_config_info,
+	.subdev_info = vip_sdev_info,
+	.subdev_count = ARRAY_SIZE(vip_sdev_info),
+	.i2c_adapter_id = 0,
+	.is_field_end_gpio_based = 1,
+	.gpio_for_frame_end_intr = PLGPIO_100, /* I2S_OUT_DATA_3 */
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *hdmi_rx_pb_pmx_devs[] = {
+	&spear1340_pmx_vip_mux_cam0,
+	&spear1340_pmx_vip_mux_cam1,
+	&spear1340_pmx_vip_mux_cam2,
+	&spear1340_pmx_vip_mux_cam3,
+};
+
+static struct platform_device *hdmi_rx_pb_add_pdevs[] __initdata = {
+	&spear1340_vip_device,
+};
+
+static void __init hdmi_rx_pb_init(void)
+{
+	vip_set_vb_base(&vip_board_specific_data);
+
+	/* set vip plat data */
+	vip_set_plat_data(&spear1340_vip_device,
+				&vip_board_specific_data);
+}
+
+
+/* Definitions specific to HDMI TX plug board */
+#define hdmi_tx_pb_pmx_devs		pb_empty_array
+#define hdmi_tx_pb_rm_adevs		pb_empty_array
+#define hdmi_tx_pb_rm_pdevs		pb_empty_array
+#define hdmi_tx_pb_add_adevs		pb_empty_array
+#define hdmi_tx_pb_add_pdevs		pb_empty_array
+#define hdmi_tx_pb_rm_spi_devs		pb_empty_array
+#define hdmi_tx_pb_add_spi_devs		pb_empty_array
+#define hdmi_tx_pb_rm_i2c_devs		pb_empty_array
+
+static struct ad9889b_pdata ad9889b_platdata = {
+	.irq_gpio = STMPE801_GPIO_7,
+	.irq_type = IRQF_DISABLED | IRQF_SHARED | IRQF_TRIGGER_FALLING,
+	.fb = 0,
+	.ain = HDMI_AUDIO_IN_SPDIF,
+};
+
+static struct i2c_board_info spear1340_pb_i2c_board_hdmi_tx = {
+		.type = "adi9889_i2c",
+		.addr = 0x39,
+		.platform_data = &ad9889b_platdata,
+};
+
+static struct i2c_dev_info spear1340_pb_i2c_hdmi_tx = {
+	.board = &spear1340_pb_i2c_board_hdmi_tx,
+	.busnum = 0,
+};
+
+/* I2C devices to be added */
+static struct i2c_dev_info *hdmi_tx_pb_add_i2c_devs[] __initdata = {
+	&spear1340_pb_i2c_hdmi_tx,
+};
+
+static void __init hdmi_tx_pb_init(void)
+{
+	struct ad9889b_pdata *ad9889b_pdata
+		= spear1340_pb_i2c_board_hdmi_tx.platform_data;
+
+	if (ad9889b_pdata->ain == HDMI_AUDIO_IN_I2S) {
+		struct i2s_platform_data *i2s_pdata
+			= dev_get_platdata(&spear1340_i2s_play_device.dev);
+
+		i2s_pdata->snd_fmts = SNDRV_PCM_FMTBIT_S32_LE;
+	}
+}
+
+
+/* Definitions specific to CAM plug board with single sensor mounted */
+#define cam0_pb_pmx_devs		pb_empty_array
+#define cam0_pb_rm_adevs		pb_empty_array
+#define cam0_pb_rm_pdevs		pb_empty_array
+#define cam0_pb_add_adevs		pb_empty_array
+#define cam0_pb_add_pdevs		pb_empty_array
+#define cam0_pb_rm_spi_devs		pb_empty_array
+#define cam0_pb_add_spi_devs		pb_empty_array
+#define cam0_pb_rm_i2c_devs		pb_empty_array
+#define cam0_pb_add_i2c_devs		pb_empty_array
+#define cam0_pb_init			NULL
+
+
+/* Definitions specific to VGA plug board */
+#define vga_pb_pmx_devs			pb_empty_array
+#define vga_pb_rm_adevs			pb_empty_array
+#define vga_pb_rm_pdevs			pb_empty_array
+#define vga_pb_add_adevs		pb_empty_array
+#define vga_pb_add_pdevs		pb_empty_array
+#define vga_pb_rm_spi_devs		pb_empty_array
+#define vga_pb_add_spi_devs		pb_empty_array
+#define vga_pb_rm_i2c_devs		pb_empty_array
+#define vga_pb_add_i2c_devs		pb_empty_array
+#define vga_pb_init			NULL
+
+/*
+ * Definitions specific to SATA configuration
+ * This is an exception as SATA is not a separate plug board but is a
+ * change in normal evaulation board for supporting SATA.
+ */
+#define sata_pb_rm_adevs		pb_empty_array
+#define sata_pb_add_adevs		pb_empty_array
+#define sata_pb_rm_spi_devs		pb_empty_array
+#define sata_pb_add_spi_devs		pb_empty_array
+#define sata_pb_rm_i2c_devs		pb_empty_array
+#define sata_pb_add_i2c_devs		pb_empty_array
+
+/* padmux devices to enable */
+static struct pmx_dev *sata_pb_pmx_devs[] = {
+	&spear1340_pmx_sata,
+};
+
+static struct platform_device *sata_pb_rm_pdevs[] __initdata = {
+	&spear13xx_pcie_host0_device,
+};
+
+static struct platform_device *sata_pb_add_pdevs[] __initdata = {
+	&spear1340_sata0_device,
+};
+
+static void __init sata_pb_init(void)
+{
+	/* Miphy configuration for SATA */
+	writel(SPEAR1340_PCIE_SATA_MIPHY_CFG_SATA_25M_CRYSTAL_CLK,
+			VA_SPEAR1340_PCIE_MIPHY_CFG);
+}
+
+/*
+ * Definitions specific to PCIe configuration
+ * This is an exception as PCIe is not a separate plug board but is a
+ * change in normal evaulation board for supporting PCIe.
+ */
+#define pcie_pb_rm_adevs		pb_empty_array
+#define pcie_pb_add_adevs		pb_empty_array
+#define pcie_pb_rm_spi_devs		pb_empty_array
+#define pcie_pb_add_spi_devs		pb_empty_array
+#define pcie_pb_rm_i2c_devs		pb_empty_array
+#define pcie_pb_add_i2c_devs		pb_empty_array
+
+/* padmux devices to enable */
+static struct pmx_dev *pcie_pb_pmx_devs[] = {
+	&spear1340_pmx_pcie,
+};
+
+static struct platform_device *pcie_pb_rm_pdevs[] __initdata = {
+	&spear1340_sata0_device,
+};
+
+static struct platform_device *pcie_pb_add_pdevs[] __initdata = {
+	&spear13xx_pcie_host0_device,
+};
+
+static void __init pcie_pb_init(void)
+{
+#ifdef CONFIG_SPEAR_PCIE_REV370
+	spear1340_pcie_board_init(&spear13xx_pcie_host0_device.dev);
+#endif
+}
+
+static int make_pb_list(struct list_head *pb_list)
+{
+	char *pb_name;
+	struct plug_board *pb = NULL;
+
+	while ((pb_name = get_spear_pb()) != NULL) {
+		if (!strcmp(pb_name, "gmii")) {
+			INIT_PB(gmii, pb);
+		} else if (!strcmp(pb_name, "rgmii")) {
+			INIT_PB(rgmii, pb);
+		} else if (!strcmp(pb_name, "etm")) {
+			INIT_PB(etm, pb);
+		} else if (!strcmp(pb_name, "hdmi_rx")) {
+			INIT_PB(hdmi_rx, pb);
+		} else if (!strcmp(pb_name, "hdmi_tx")) {
+			INIT_PB(hdmi_tx, pb);
+		} else if (!strcmp(pb_name, "cam0")) {
+			INIT_PB(cam0, pb);
+		} else if (!strcmp(pb_name, "vga")) {
+			INIT_PB(vga, pb);
+		} else if (!strcmp(pb_name, "sata")) {
+			INIT_PB(sata, pb);
+		} else if (!strcmp(pb_name, "pcie")) {
+			INIT_PB(pcie, pb);
+		} else {
+			pr_err("Invalid plug board requested: %s\n", pb_name);
+			goto release_pb;
+		}
+
+		if (!pb)
+			goto release_pb;
+
+		list_add_tail(&pb->node, pb_list);
+	}
+
+	if (list_empty(pb_list)) {
+		pr_err("Board list can't be empty\n");
+			goto release_pb;
+	}
+
+	return 0;
+
+release_pb:
+	list_for_each_entry(pb, pb_list, node)
+		kfree(pb);
+
+	return -EINVAL;
+}
+
+int __init spear1340_pb_init(struct plug_board_info *pb_info)
+{
+	return spear_pb_init(pb_info, make_pb_list);
+}
diff --git a/arch/arm/mach-spear13xx/spear13xx.c b/arch/arm/mach-spear13xx/spear13xx.c
new file mode 100644
index 0000000..17d330e
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear13xx.c
@@ -0,0 +1,2329 @@
+/*
+ * arch/arm/mach-spear13xx/spear13xx.c
+ *
+ * SPEAr13XX machines common source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Shiraz Hashim <shiraz.hashim@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define pr_fmt(fmt) "spear13xx: " fmt
+
+#include <linux/types.h>
+#include <linux/amba/pl022.h>
+#include <linux/amba/pl061.h>
+#include <linux/amba/serial.h>
+#include <linux/dw_dmac.h>
+#include <linux/designware_i2s.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/ptrace.h>
+#include <linux/phy.h>
+#include <linux/io.h>
+#include <linux/netdevice.h>
+#include <linux/platform_data/spear_thermal.h>
+#include <linux/stmmac.h>
+#include <asm/hardware/gic.h>
+#include <asm/irq.h>
+#include <asm/pmu.h>
+#include <asm/setup.h>
+#include <asm/localtimer.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/smp_twd.h>
+#include <plat/adc.h>
+#include <plat/clock.h>
+#include <plat/cpufreq.h>
+#include <plat/jpeg.h>
+#include <plat/udc.h>
+#include <mach/dma.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/misc_regs.h>
+#include <mach/spear_pcie.h>
+#include <sound/pcm.h>
+
+/* SPEAr GPIO Buttons Info */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+
+/* SPEAr GPIO Buttons definition */
+#define SPEAR_GPIO_BTN7	7
+
+static struct gpio_keys_button spear_gpio_keys_table[] = {
+	{
+		.code = BTN_0,
+		.gpio = SPEAR_GPIO_BTN7,
+		.active_low = 0,
+		.desc = "gpio-keys: BTN0",
+		.type = EV_KEY,
+		.wakeup = 1,
+		.debounce_interval = 20,
+	},
+};
+
+static struct gpio_keys_platform_data spear_gpio_keys_data = {
+	.buttons = spear_gpio_keys_table,
+	.nbuttons = ARRAY_SIZE(spear_gpio_keys_table),
+};
+
+struct platform_device spear13xx_device_gpiokeys = {
+	.name = "gpio-keys",
+	.dev = {
+		.platform_data = &spear_gpio_keys_data,
+	},
+};
+#endif
+
+/* Add spear13xx machines common devices here */
+/* common dw_dma filter routine to be used by peripherals */
+bool dw_dma_filter(struct dma_chan *chan, void *slave)
+{
+	struct dw_dma_slave *dws = (struct dw_dma_slave *)slave;
+
+	if (chan->device->dev == dws->dma_dev) {
+		chan->private = slave;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+/* SPEAr Thermal Sensor Platform Data */
+static struct resource spear13xx_thermal_resources[] = {
+	{
+		.start = THSENS_CFG,
+		.end = THSENS_CFG + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct spear_thermal_pdata spear13xx_thermal_pdata = {
+	.thermal_flags = THERMAL_CONFIG_FLAGS,
+};
+
+struct platform_device spear13xx_thermal_device = {
+	.name = "spear_thermal",
+	.id = -1,
+	.dev = {
+		.platform_data = &spear13xx_thermal_pdata,
+	},
+	.num_resources = ARRAY_SIZE(spear13xx_thermal_resources),
+	.resource = spear13xx_thermal_resources,
+};
+
+/* gpio device registeration */
+static struct pl061_platform_data gpio_plat_data[] = {
+	{
+		.gpio_base	= 0,
+		.irq_base	= SPEAR_GPIO0_INT_BASE,
+	}, {
+		.gpio_base	= 8,
+		.irq_base	= SPEAR_GPIO1_INT_BASE,
+	},
+};
+
+struct amba_device spear13xx_gpio_device[] = {
+	{
+		.dev = {
+			.init_name = "gpio0",
+			.platform_data = &gpio_plat_data[0],
+		},
+		.res = {
+			.start = SPEAR13XX_GPIO0_BASE,
+			.end = SPEAR13XX_GPIO0_BASE + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		.irq = {SPEAR13XX_IRQ_GPIO0, NO_IRQ},
+	}, {
+		.dev = {
+			.init_name = "gpio1",
+			.platform_data = &gpio_plat_data[1],
+		},
+		.res = {
+			.start = SPEAR13XX_GPIO1_BASE,
+			.end = SPEAR13XX_GPIO1_BASE + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		},
+		.irq = {SPEAR13XX_IRQ_GPIO1, NO_IRQ},
+	}
+};
+
+/* ssp device registeration */
+#if 0
+static struct dw_dma_slave ssp_dma_param[] = {
+	{
+		/* Tx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR13XX_DMA_REQ_SSP0_TX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_MEMORY,
+		.dst_master = SPEAR13XX_DMA_MASTER_SSP0,
+	}, {
+		/* Rx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_SSP0_RX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_SSP0,
+		.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	}
+};
+#endif
+
+static struct pl022_ssp_controller ssp_platform_data = {
+	.bus_id = 0,
+	.enable_dma = 0,
+#if 0
+	.dma_filter = dw_dma_filter,
+	.dma_rx_param = &ssp_dma_param[1],
+	.dma_tx_param = &ssp_dma_param[0],
+#endif
+	/*
+	 * Following is the number of chip selects from spi controller
+	 * to which spi devices can be connected.
+	 * There are two type of chipselects on which slave devices can
+	 * work. One is chip select provided by spi masters other is
+	 * controlled through external gpio's.
+	 */
+	.num_chipselect = 3,
+};
+
+struct amba_device spear13xx_ssp_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "ssp-pl022",
+		.platform_data = &ssp_platform_data,
+	},
+	.res = {
+		.start = SPEAR13XX_SSP_BASE,
+		.end = SPEAR13XX_SSP_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR13XX_IRQ_SSP, NO_IRQ},
+};
+
+/* uart device registeration */
+/* As uart0 is used for console, so disable DMA here */
+#if 0
+static struct dw_dma_slave uart_dma_param[] = {
+	{
+		/* Tx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR13XX_DMA_REQ_UART0_TX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_MEMORY,
+		.dst_master = SPEAR13XX_DMA_MASTER_UART0,
+	}, {
+		/* Rx */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_UART0_RX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_UART0,
+		.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct amba_pl011_data uart_data = {
+	.dma_filter = dw_dma_filter,
+	.dma_tx_param = &uart_dma_param[0],
+	.dma_rx_param = &uart_dma_param[1],
+};
+#endif
+
+struct amba_device spear13xx_uart_device = {
+	.dev = {
+		.init_name = "uart",
+/*		.platform_data = &uart_data, */
+	},
+	.res = {
+		.start = SPEAR13XX_UART_BASE,
+		.end = SPEAR13XX_UART_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	.irq = {SPEAR13XX_IRQ_UART, NO_IRQ},
+};
+
+/* adc device registeration */
+static struct dw_dma_slave adc_dma_param[] = {
+	{
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_ADC),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_ADC,
+		.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct adc_plat_data adc_pdata = {
+	.dma_filter = dw_dma_filter,
+	.dma_data = &adc_dma_param,
+	.config = {CONTINUOUS_CONVERSION, EXTERNAL_VOLT, 2500, INTERNAL_SCAN,
+		NORMAL_RESOLUTION, 14000000, 0},
+};
+
+static struct resource adc_resources[] = {
+	{
+		.start = SPEAR13XX_ADC_BASE,
+		.end = SPEAR13XX_ADC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_ADC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_adc_device = {
+	.name = "adc",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &adc_pdata,
+	},
+	.num_resources = ARRAY_SIZE(adc_resources),
+	.resource = adc_resources,
+};
+
+/* cf device registeration */
+struct dw_dma_slave cf_dma_priv = {
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.cfg_hi = 0,
+	.cfg_lo = 0,
+	.src_master = 0,
+	.dst_master = 0,
+};
+
+static struct resource cf_resources[] = {
+	{
+		.start = SPEAR13XX_MCIF_CF_BASE,
+		.end = SPEAR13XX_MCIF_CF_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_CF,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_cf_device = {
+	.name = "arasan_cf",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(cf_resources),
+	.resource = cf_resources,
+};
+
+/* clcd db9000 devide registration */
+static struct resource db9000fb_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_CLCD_BASE,
+		.end = SPEAR13XX_CLCD_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_CLCD,
+		.end = SPEAR13XX_IRQ_CLCD,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 fb_dma_mask = ~(u64)0;
+
+struct platform_device spear13xx_db9000_clcd_device = {
+	.name = "clcd-db9000",
+	.id = -1,
+	.dev = {
+		.parent = NULL,
+		.dma_mask = &fb_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(db9000fb_resources),
+	.resource = db9000fb_resources,
+};
+
+/* dmac device registeration */
+static struct dw_dma_platform_data dmac_plat_data = {
+	.nr_channels = 8,
+	.chan_allocation_order = CHAN_ALLOCATION_DESCENDING,
+	.chan_priority = CHAN_PRIORITY_DESCENDING,
+};
+
+static struct resource dmac_resources[][2] = {
+	[0] = {
+		{
+			.start = SPEAR13XX_DMAC0_BASE,
+			.end = SPEAR13XX_DMAC0_BASE + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = SPEAR13XX_IRQ_DMAC0_COMBINED,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+	[1] = {
+		{
+			.start = SPEAR13XX_DMAC1_BASE,
+			.end = SPEAR13XX_DMAC1_BASE + SZ_4K - 1,
+			.flags = IORESOURCE_MEM,
+		}, {
+			.start = SPEAR13XX_IRQ_DMAC1_COMBINED,
+			.flags = IORESOURCE_IRQ,
+		},
+	},
+};
+
+struct platform_device spear13xx_dmac_device[] = {
+	[0] = {
+		.name = "dw_dmac",
+		.id = 0,
+		.dev = {
+			.coherent_dma_mask = ~0,
+			.platform_data = &dmac_plat_data,
+		},
+		.num_resources = ARRAY_SIZE(dmac_resources[0]),
+		.resource = dmac_resources[0],
+	},
+	[1] = {
+		.name = "dw_dmac",
+		.id = 1,
+		.dev = {
+			.coherent_dma_mask = ~0,
+			.platform_data = &dmac_plat_data,
+		},
+		.num_resources = ARRAY_SIZE(dmac_resources[1]),
+		.resource = dmac_resources[1],
+	},
+};
+
+/* Ethernet device registeration */
+static struct resource eth_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_GETH_BASE,
+		.end = SPEAR13XX_GETH_BASE + SZ_32K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_GETH_SBD,
+		.flags = IORESOURCE_IRQ,
+		.name = "macirq",
+	},
+	[2] = {
+		.start = SPEAR13XX_IRQ_GETH_PMT,
+		.flags = IORESOURCE_IRQ,
+		.name = "eth_wake_irq",
+	},
+};
+
+static u64 eth_dma_mask = ~(u32) 0;
+struct platform_device spear13xx_eth_device = {
+	.name = "stmmaceth",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(eth_resources),
+	.resource = eth_resources,
+	.dev = {
+		.dma_mask = &eth_dma_mask,
+		.coherent_dma_mask = ~0,
+	},
+};
+
+/* i2c device registeration */
+static struct resource i2c_resources[] = {
+	{
+		.start = SPEAR13XX_I2C_BASE,
+		.end = SPEAR13XX_I2C_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_I2C,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_i2c_device = {
+	.name = "i2c_designware",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.num_resources = ARRAY_SIZE(i2c_resources),
+	.resource = i2c_resources,
+};
+
+/* fsmc nor flash device registeration */
+static struct resource fsmc_nor_resources[] = {
+	{
+		.start	= SPEAR13XX_FSMC_MEM_BASE,
+		.end	= SPEAR13XX_FSMC_MEM_BASE + SZ_16M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear13xx_fsmc_nor_device = {
+	.name	= "physmap-flash",
+	.id	= -1,
+	.resource = fsmc_nor_resources,
+	.num_resources = ARRAY_SIZE(fsmc_nor_resources),
+};
+
+/* nand device registeration */
+void __init nand_mach_init(u32 busw)
+{
+	void __iomem *reg;
+	u32 fsmc_cfg;
+
+	if (cpu_is_spear1340()) {
+#ifdef CONFIG_CPU_SPEAR1340
+		reg = VA_SPEAR1340_FSMC_CFG;
+#endif
+	} else
+		reg = VA_FSMC_CFG;
+
+	fsmc_cfg = readl(reg);
+	fsmc_cfg &= ~(FSMC_MEMSEL_MASK << FSMC_MEMSEL_SHIFT);
+	fsmc_cfg |= (FSMC_MEM_NAND << FSMC_MEMSEL_SHIFT);
+
+	if (busw == FSMC_NAND_BW16)
+		fsmc_cfg |= 1 << NAND_DEV_WIDTH16;
+	else
+		fsmc_cfg &= ~(1 << NAND_DEV_WIDTH16);
+
+	writel(fsmc_cfg, reg);
+}
+
+void nand_select_bank(u32 bank, u32 busw)
+{
+	u32 fsmc_cfg;
+
+	if (cpu_is_spear1340()) {
+#ifdef CONFIG_CPU_SPEAR1340
+		fsmc_cfg = readl(VA_SPEAR1340_FSMC_CFG);
+#endif
+	} else
+		fsmc_cfg = readl(VA_FSMC_CFG);
+
+	fsmc_cfg &= ~(NAND_BANK_MASK << NAND_BANK_SHIFT);
+	fsmc_cfg |= (bank << NAND_BANK_SHIFT);
+
+	if (busw)
+		fsmc_cfg |= 1 << NAND_DEV_WIDTH16;
+	else
+		fsmc_cfg &= ~(1 << NAND_DEV_WIDTH16);
+
+	if (cpu_is_spear1340()) {
+#ifdef CONFIG_CPU_SPEAR1340
+		writel(fsmc_cfg, VA_SPEAR1340_FSMC_CFG);
+#endif
+	} else
+		writel(fsmc_cfg, VA_FSMC_CFG);
+}
+
+struct dw_dma_slave nand_read_dma_priv = {
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.src_master = SPEAR13XX_DMA_MASTER_FSMC,
+	.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+};
+
+struct dw_dma_slave nand_write_dma_priv = {
+	.dma_dev = &spear13xx_dmac_device[0].dev,
+	.src_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	.dst_master = SPEAR13XX_DMA_MASTER_FSMC,
+};
+
+static struct resource nand_resources[] = {
+	{
+		.name = "nand_data",
+		.start = SPEAR13XX_FSMC_MEM_BASE,
+		.end = SPEAR13XX_FSMC_MEM_BASE + SZ_16 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.name = "fsmc_regs",
+		.start = SPEAR13XX_FSMC_BASE,
+		.end = SPEAR13XX_FSMC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear13xx_nand_device = {
+	.name = "fsmc-nand",
+	.id = -1,
+	.resource = nand_resources,
+	.num_resources = ARRAY_SIZE(nand_resources),
+};
+
+/* pmu device */
+static struct resource spear13xx_pmu_resources[] = {
+	{
+		.start	= SPEAR13XX_IRQ_PMU0,
+		.end	= SPEAR13XX_IRQ_PMU0,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.start	= SPEAR13XX_IRQ_PMU1,
+		.end	= SPEAR13XX_IRQ_PMU1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_pmu_device = {
+	.name		= "arm-pmu",
+	.id		= ARM_PMU_DEVICE_CPU,
+	.num_resources	= ARRAY_SIZE(spear13xx_pmu_resources),
+	.resource	= spear13xx_pmu_resources,
+};
+
+/* usb host device registeration */
+static struct resource ehci0_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_UHC0_EHCI_BASE,
+		.end = SPEAR13XX_UHC0_EHCI_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_USBH_EHCI0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ehci1_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_UHC1_EHCI_BASE,
+		.end = SPEAR13XX_UHC1_EHCI_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_USBH_EHCI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource ohci0_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_UHC0_OHCI_BASE,
+		.end = SPEAR13XX_UHC0_OHCI_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_USBH_OHCI0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+static struct resource ohci1_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_UHC1_OHCI_BASE,
+		.end = SPEAR13XX_UHC1_OHCI_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_IRQ_USBH_OHCI1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* usbh0_id defaults to 0, being static variable */
+static int usbh0_id;
+static int usbh1_id = 1;
+static u64 ehci0_dmamask = ~0;
+
+struct platform_device spear13xx_ehci0_device = {
+	.name = "spear-ehci",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &ehci0_dmamask,
+		.platform_data = &usbh0_id,
+	},
+	.num_resources = ARRAY_SIZE(ehci0_resources),
+	.resource = ehci0_resources,
+};
+
+static u64 ehci1_dmamask = ~0;
+
+struct platform_device spear13xx_ehci1_device = {
+	.name = "spear-ehci",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &ehci1_dmamask,
+		.platform_data = &usbh1_id,
+	},
+	.num_resources = ARRAY_SIZE(ehci1_resources),
+	.resource = ehci1_resources,
+};
+
+static u64 ohci0_dmamask = ~0;
+
+struct platform_device spear13xx_ohci0_device = {
+	.name = "spear-ohci",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &ohci0_dmamask,
+		.platform_data = &usbh0_id,
+	},
+	.num_resources = ARRAY_SIZE(ohci0_resources),
+	.resource = ohci0_resources,
+};
+
+static u64 ohci1_dmamask = ~0;
+struct platform_device spear13xx_ohci1_device = {
+	.name = "spear-ohci",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &ohci1_dmamask,
+		.platform_data = &usbh1_id,
+	},
+	.num_resources = ARRAY_SIZE(ohci1_resources),
+	.resource = ohci1_resources,
+};
+
+/* keyboard device registration */
+static struct resource kbd_resources[] = {
+	{
+		.start = SPEAR13XX_KBD_BASE,
+		.end = SPEAR13XX_KBD_BASE + SZ_1K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_KBD,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_kbd_device = {
+	.name = "keyboard",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(kbd_resources),
+	.resource = kbd_resources,
+};
+
+/* rtc device registration */
+static struct resource rtc_resources[] = {
+	{
+		.start = SPEAR13XX_RTC_BASE,
+		.end = SPEAR13XX_RTC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_rtc_device = {
+	.name = "rtc-spear",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+
+/* sdhci (sdio) device declaration */
+static struct resource sdhci_resources[] = {
+	{
+		.start	= SPEAR13XX_MCIF_SDHCI_BASE,
+		.end	= SPEAR13XX_MCIF_SDHCI_BASE + SZ_256 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= SPEAR13XX_IRQ_SDHCI,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device spear13xx_sdhci_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+	},
+	.name = "sdhci",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(sdhci_resources),
+	.resource = sdhci_resources,
+};
+
+/* smi device registration */
+static struct resource smi_resources[] = {
+	{
+		.start = SPEAR13XX_SMI_CTRL_BASE,
+		.end = SPEAR13XX_SMI_CTRL_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_SMI,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_smi_device = {
+	.name = "smi",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(smi_resources),
+	.resource = smi_resources,
+};
+
+/* wdt device registration */
+static struct resource wdt_resources[] = {
+	{
+		.start = SPEAR13XX_WDT_BASE,
+		.end = SPEAR13XX_WDT_BASE + SZ_256 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device spear13xx_wdt_device = {
+	.name = "cortexa9-wdt",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+struct platform_device spear13xx_pcm_device = {
+	.name		= "spear-pcm-audio",
+	.id		= -1,
+};
+
+/* pcie host/gadget registration */
+static int pcie_gadget0_id;
+
+static u64 pcie_gadget0_dmamask = ~0;
+
+static struct pcie_port_info	pcie_host0_info;
+
+static u64 pcie_host0_dmamask = ~0;
+
+static struct resource pcie0_resources[] = {
+	{
+		.start = SPEAR13XX_PCIE0_APP_BASE,
+		.end = SPEAR13XX_PCIE0_APP_BASE + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_PCIE0_BASE,
+		.end = SPEAR13XX_PCIE0_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_PCIE0,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_pcie_gadget0_device = {
+	.name = "pcie-gadget-spear",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_gadget0_dmamask,
+		.platform_data = &pcie_gadget0_id,
+	},
+	.num_resources = ARRAY_SIZE(pcie0_resources),
+	.resource = pcie0_resources,
+};
+
+struct platform_device spear13xx_pcie_host0_device = {
+	.name = "dw_pcie",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_host0_dmamask,
+		.platform_data = &pcie_host0_info,
+	},
+	.num_resources = ARRAY_SIZE(pcie0_resources),
+	.resource = pcie0_resources,
+};
+
+/*
+ * Devices present on CPU_SPEAR1300, CPU_SPEAR1310, CPU_SPEAR1310_REVA or
+ * CPU_SPEAR900
+ */
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+/* cpufreq platform device */
+static u32 cpu_freq_tbl[] = {
+	200000, /* 200 MHZ */
+	250000, /* 250 MHZ */
+	332000, /* 332 MHZ */
+	400000, /* 400 MHZ */
+	500000, /* 500 MHZ */
+};
+
+static struct spear_cpufreq_pdata cpufreq_pdata = {
+	.cpu_freq_table = cpu_freq_tbl,
+	.tbl_len = ARRAY_SIZE(cpu_freq_tbl),
+};
+
+struct platform_device spear13xx_cpufreq_device = {
+	.name = "cpufreq-spear",
+	.id = -1,
+	.dev = {
+		.platform_data = &cpufreq_pdata,
+	},
+};
+
+/*
+ * configure i2s ref clk and sclk
+ *
+ * Depending on these parameters sclk and ref clock will be configured.
+ * For sclk:
+ * sclk = channel_num * data_len * sample_rate
+ *
+ * For ref clock:
+ *
+ * ref_clock = 256 * sample_rate
+ */
+
+int audio_clk_config(struct i2s_clk_config_data *config)
+{
+	struct clk *i2s_sclk_clk, *i2s_ref_clk;
+	int ret;
+	u32 bclk;
+
+	i2s_sclk_clk = clk_get_sys(NULL, "i2s_sclk_clk");
+	if (IS_ERR(i2s_sclk_clk)) {
+		pr_err("%s:couldn't get i2s_sclk_clk\n", __func__);
+		return PTR_ERR(i2s_sclk_clk);
+	}
+
+	i2s_ref_clk = clk_get_sys(NULL, "i2s_ref_clk");
+	if (IS_ERR(i2s_ref_clk)) {
+		pr_err("%s:couldn't get i2s_ref_clk\n", __func__);
+		ret = PTR_ERR(i2s_ref_clk);
+		goto put_i2s_sclk_clk;
+	}
+
+	if (machine_is_spear1340_evb()) {
+		if (config->sample_rate != 48000) {
+			ret = clk_set_parent_sys(NULL, "i2s_ref_clk", NULL,
+					"i2s_prs1_clk");
+			if (ret) {
+				pr_err("%s:set_parent of ref_clk fail\n",
+						__func__);
+				goto put_i2s_sclk_clk;
+			}
+		} else {
+			ret = clk_set_parent_sys(NULL, "i2s_ref_clk", NULL,
+					"i2s_src_clk");
+			if (ret) {
+				pr_err("%s:set_parent of ref_clk fail\n",
+						__func__);
+				goto put_i2s_sclk_clk;
+			}
+			goto config_bclk;
+		}
+	}
+
+	ret = clk_set_rate(i2s_ref_clk, 256 * config->sample_rate);
+	if (ret) {
+		pr_err("%s:couldn't set i2s_ref_clk rate\n", __func__);
+		goto put_i2s_ref_clk;
+	}
+
+config_bclk:
+	bclk = config->chan_nr * config->data_width * config->sample_rate;
+
+	ret = clk_set_rate(i2s_sclk_clk, bclk);
+	if (ret) {
+		pr_err("%s:couldn't set i2s_sclk_clk rate\n", __func__);
+		goto put_i2s_ref_clk;
+	}
+
+	ret = clk_enable(i2s_sclk_clk);
+	if (ret) {
+		pr_err("%s:enabling i2s_sclk_clk\n", __func__);
+		goto put_i2s_ref_clk;
+	}
+
+	return 0;
+
+put_i2s_ref_clk:
+	clk_put(i2s_ref_clk);
+put_i2s_sclk_clk:
+	clk_put(i2s_sclk_clk);
+
+	return ret;
+
+}
+
+/* i2s0 device registeration */
+static struct dw_dma_slave i2s0_dma_data[] = {
+	{
+		/* Play */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR13XX_DMA_REQ_I2S_TX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_MEMORY,
+		.dst_master = SPEAR13XX_DMA_MASTER_I2S,
+	}, {
+		/* Record */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_I2S_RX),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_I2S,
+		.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct i2s_platform_data i2s0_data = {
+	.cap = PLAY | RECORD,
+	.channel = 4,
+	.snd_fmts = SNDRV_PCM_FMTBIT_S16_LE,
+	.snd_rates = (SNDRV_PCM_RATE_8000 | \
+		 SNDRV_PCM_RATE_11025 | \
+		 SNDRV_PCM_RATE_16000 | \
+		 SNDRV_PCM_RATE_22050 | \
+		 SNDRV_PCM_RATE_32000 | \
+		 SNDRV_PCM_RATE_44100 | \
+		 SNDRV_PCM_RATE_48000),
+	.play_dma_data = &i2s0_dma_data[0],
+	.capture_dma_data = &i2s0_dma_data[1],
+	.filter = dw_dma_filter,
+	.i2s_clk_cfg = audio_clk_config,
+};
+
+static struct resource i2s0_resources[] = {
+	{
+		.start	= SPEAR13XX_I2S0_BASE,
+		.end	= SPEAR13XX_I2S0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+
+		.name	= "play_irq",
+		.start	= SPEAR13XX_IRQ_PLAY_I2S0,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.name	= "record_irq",
+		.start	= SPEAR13XX_IRQ_REC_I2S0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_i2s0_device = {
+	.name = "designware-i2s",
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &i2s0_data,
+	},
+	.num_resources = ARRAY_SIZE(i2s0_resources),
+	.resource = i2s0_resources,
+};
+
+/* i2s1 device registeration */
+static struct dw_dma_slave i2s1_dma_data[] = {
+	{
+		/* Play */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR13XX_DMA_REQ_I2S_TX),
+		.cfg_lo = 0,
+		.src_master = 0,
+		.dst_master = 1,
+	}, {
+		/* Record */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_I2S_RX),
+		.cfg_lo = 0,
+		.src_master = 1,
+		.dst_master = 0,
+	}
+};
+
+static struct i2s_platform_data i2s1_data = {
+	.cap = PLAY | RECORD,
+	.channel = 4,
+	.snd_fmts = SNDRV_PCM_FMTBIT_S16_LE,
+	.snd_rates = (SNDRV_PCM_RATE_8000 | \
+		 SNDRV_PCM_RATE_11025 | \
+		 SNDRV_PCM_RATE_16000 | \
+		 SNDRV_PCM_RATE_22050 | \
+		 SNDRV_PCM_RATE_32000 | \
+		 SNDRV_PCM_RATE_44100 | \
+		 SNDRV_PCM_RATE_48000),
+	.play_dma_data = &i2s1_dma_data[0],
+	.capture_dma_data = &i2s1_dma_data[1],
+	.filter = dw_dma_filter,
+	.i2s_clk_cfg = audio_clk_config,
+};
+
+static struct resource i2s1_resources[] = {
+	{
+		.start	= SPEAR13XX_I2S1_BASE,
+		.end	= SPEAR13XX_I2S1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+
+		.name	= "play_irq",
+		.start	= SPEAR13XX_IRQ_PLAY_I2S1,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.name	= "record_irq",
+		.start	= SPEAR13XX_IRQ_REC_I2S1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_i2s1_device = {
+	.name = "designware-i2s",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &i2s1_data,
+	},
+	.num_resources = ARRAY_SIZE(i2s1_resources),
+	.resource = i2s1_resources,
+};
+
+/* jpeg device registeration */
+static struct dw_dma_slave jpeg_dma_param[] = {
+	{
+		/* mem2jpeg */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_DST_PER(SPEAR13XX_DMA_REQ_TO_JPEG),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_MEMORY,
+		.dst_master = SPEAR13XX_DMA_MASTER_JPEG,
+	}, {
+		/* jpeg2mem */
+		.dma_dev = &spear13xx_dmac_device[0].dev,
+		.cfg_hi = DWC_CFGH_SRC_PER(SPEAR13XX_DMA_REQ_FROM_JPEG),
+		.cfg_lo = 0,
+		.src_master = SPEAR13XX_DMA_MASTER_JPEG,
+		.dst_master = SPEAR13XX_DMA_MASTER_MEMORY,
+	}
+};
+
+static struct jpeg_plat_data jpeg_pdata = {
+	.dma_filter = dw_dma_filter,
+	.mem2jpeg_slave = &jpeg_dma_param[0],
+	.jpeg2mem_slave = &jpeg_dma_param[1],
+};
+
+static struct resource jpeg_resources[] = {
+	{
+		.start = SPEAR13XX_JPEG_BASE,
+		.end = SPEAR13XX_JPEG_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_JPEG,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_jpeg_device = {
+	.name = "jpeg-designware",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.platform_data = &jpeg_pdata,
+	},
+	.num_resources = ARRAY_SIZE(jpeg_resources),
+	.resource = jpeg_resources,
+};
+
+/* pcie host/gadget registration */
+static int pcie_gadget1_id;
+static int pcie_gadget2_id;
+
+static u64 pcie_gadget1_dmamask = ~0;
+static u64 pcie_gadget2_dmamask = ~0;
+
+static struct pcie_port_info	pcie_host1_info;
+static struct pcie_port_info	pcie_host2_info;
+
+static u64 pcie_host1_dmamask = ~0;
+static u64 pcie_host2_dmamask = ~0;
+
+static struct resource pcie1_resources[] = {
+	{
+		.start = SPEAR13XX_PCIE1_APP_BASE,
+		.end = SPEAR13XX_PCIE1_APP_BASE + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_PCIE1_BASE,
+		.end = SPEAR13XX_PCIE1_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_PCIE1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource pcie2_resources[] = {
+	{
+		.start = SPEAR13XX_PCIE2_APP_BASE,
+		.end = SPEAR13XX_PCIE2_APP_BASE + SZ_16K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_PCIE2_BASE,
+		.end = SPEAR13XX_PCIE2_BASE + SZ_8K - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = SPEAR13XX_IRQ_PCIE2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_pcie_gadget1_device = {
+	.name = "pcie-gadget-spear",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_gadget1_dmamask,
+		.platform_data = &pcie_gadget1_id,
+	},
+	.num_resources = ARRAY_SIZE(pcie1_resources),
+	.resource = pcie1_resources,
+};
+
+struct platform_device spear13xx_pcie_gadget2_device = {
+	.name = "pcie-gadget-spear",
+	.id = 2,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_gadget2_dmamask,
+		.platform_data = &pcie_gadget2_id,
+	},
+	.num_resources = ARRAY_SIZE(pcie2_resources),
+	.resource = pcie2_resources,
+};
+
+struct platform_device spear13xx_pcie_host1_device = {
+	.name = "dw_pcie",
+	.id = 1,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_host1_dmamask,
+		.platform_data = &pcie_host1_info,
+	},
+	.num_resources = ARRAY_SIZE(pcie1_resources),
+	.resource = pcie1_resources,
+};
+
+struct platform_device spear13xx_pcie_host2_device = {
+	.name = "dw_pcie",
+	.id = 2,
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.dma_mask = &pcie_host2_dmamask,
+		.platform_data = &pcie_host2_info,
+	},
+	.num_resources = ARRAY_SIZE(pcie2_resources),
+	.resource = pcie2_resources,
+};
+
+#endif
+
+/*Devices present on CPU_SPEAR1300, CPU_SPEAR1310_REVA or CPU_SPEAR900 */
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900)
+/* usb device registeration */
+static struct resource udc_resources[] = {
+	[0] = {
+		.start = SPEAR13XX_UDC_BASE,
+		.end = SPEAR13XX_UDC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SPEAR13XX_UPD_BASE,
+		.end = SPEAR13XX_UPD_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[3] = {
+		.start = SPEAR13XX_IRQ_UDC,
+		.end = SPEAR13XX_IRQ_UDC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device spear13xx_udc_device = {
+	.name = "designware_udc",
+	.id = -1,
+	.dev = {
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources = ARRAY_SIZE(udc_resources),
+	.resource = udc_resources,
+};
+#endif
+
+static void dmac_setup(void)
+{
+	/*
+	 * This function does static initialization of few misc regs for dmac
+	 * operations.
+	 */
+	/* setting Peripheral flow controller for jpeg */
+	writel(1 << SPEAR13XX_DMA_REQ_FROM_JPEG, VA_DMAC_FLOW_SEL);
+}
+
+/*
+ * Generic function to configure ethernet phy clock as per the selected
+ * interface
+ */
+int spear13xx_eth_phy_clk_cfg(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *input_clk, *input_pclk, *phy_pclk, *phy_clk;
+	struct plat_stmmacenet_data *pdata = dev_get_platdata(&pdev->dev);
+	const char *phy_clk_src_name[] = {
+		"gmac_phy_input_clk",
+		"gmac_phy_synth_clk",
+	};
+	const char *input_clk_src_name[] = {
+		"pll2_clk",
+		"gmii_125m_pad_clk",
+		"osc3_25m_clk",
+	};
+	const char *phy_clk_name[] = {
+		"stmmacphy.0"
+	};
+
+	if (pdata == NULL)
+		return -EFAULT;
+
+	/* Get the Pll-2 Clock as parent for PHY Input Clock Source */
+	input_pclk = clk_get(NULL, input_clk_src_name[0]);
+	if (IS_ERR(input_pclk)) {
+		ret = PTR_ERR(input_pclk);
+		goto fail_get_input_pclk;
+	}
+
+	/*
+	 * Get the Phy Input clock source as parent for Phy clock. Default
+	 * selection is gmac_phy_input_clk. This selection would be driving both
+	 * the synthesizer and phy clock.
+	 */
+	input_clk = clk_get(NULL, phy_clk_src_name[0]);
+	if (IS_ERR(input_clk)) {
+		ret = PTR_ERR(input_clk);
+		goto fail_get_input_clk;
+	}
+
+	/* Fetch the phy clock */
+	phy_clk = clk_get(NULL, phy_clk_name[pdata->bus_id]);
+	if (IS_ERR(phy_clk)) {
+		ret = PTR_ERR(phy_clk);
+		goto fail_get_phy_clk;
+	}
+
+	/* Set the pll-2 to 125 MHz */
+	clk_set_rate(input_pclk, 125000000);
+
+	/* Set the Pll-2 as parent for gmac_phy_input_clk */
+	clk_set_parent(input_clk, input_pclk);
+
+	if (pdata->interface == PHY_INTERFACE_MODE_RMII) {
+		/*
+		 * For the rmii interface select gmac_phy_synth_clk
+		 * as the parent and set the clock to 50 Mhz
+		 */
+		phy_pclk = clk_get(NULL, phy_clk_src_name[1]);
+		clk_set_rate(phy_pclk, 50000000);
+	} else {
+		/*
+		 * Set the gmac_phy_input_clk as the parent,
+		 * and pll-2 is already running as parent of
+		 * gmac_phy_input_clk at 125 Mhz
+		 */
+		phy_pclk = input_clk;
+	}
+
+	/* Select the parent for phy clock */
+	clk_set_parent(phy_clk, phy_pclk);
+	ret = clk_enable(phy_clk);
+
+	return ret;
+fail_get_phy_clk:
+	clk_put(input_clk);
+fail_get_input_clk:
+	clk_put(input_pclk);
+fail_get_input_pclk:
+	return ret;
+}
+
+#ifdef CONFIG_SND_SOC_STA529
+static void i2s_clk_init(void)
+{
+	struct clk *i2s_ref_pad_clk, *i2s_sclk_clk;
+	char *src_pclk_name, *ref_pclk_name;
+
+	if (machine_is_spear1340_lcad() || !cpu_is_spear1340()) {
+		if (machine_is_spear1340_lcad())
+			src_pclk_name = "pll2_clk";
+		else
+			src_pclk_name = "pll3_clk";
+
+		 ref_pclk_name = "i2s_prs1_clk";
+
+		/* set pll to 49.15 Mhz */
+		if (clk_set_rate_sys(NULL, src_pclk_name, 49152000)) {
+			pr_err("%s:set_rate of %s fail\n", __func__,
+					src_pclk_name);
+			return;
+		}
+	} else {
+		src_pclk_name = "i2s_src_pad_clk";
+		ref_pclk_name = "i2s_src_clk";
+	}
+
+	/*
+	 * After this this src_clk is correctly programmed, either to
+	 * pll2, pll3 or pad.
+	 */
+	if (clk_set_parent_sys(NULL, "i2s_src_clk", NULL, src_pclk_name)) {
+		pr_err("%s:set_parent to %s for i2s_src_clk fail\n",
+				__func__, src_pclk_name);
+		return;
+	}
+
+	/* program prescalar if required */
+	if (machine_is_spear1340_lcad() || !cpu_is_spear1340()) {
+		/* set to 12.288 Mhz */
+		if (clk_set_rate_sys(NULL, ref_pclk_name, 12288000)) {
+			pr_err("%s:set_rate of %s fail\n", __func__,
+					ref_pclk_name);
+			return;
+		}
+	}
+
+	/*
+	 * After this this ref_clk is correctly programmed to 12.288 and
+	 * sclk_clk to 1.536 MHz
+	 */
+	if (clk_set_parent_sys(NULL, "i2s_ref_clk", NULL, ref_pclk_name)) {
+		pr_err("%s:set_parent to %s of ref_clk fail\n",
+				__func__, ref_pclk_name);
+		return;
+	}
+
+	i2s_sclk_clk = clk_get_sys(NULL, "i2s_sclk_clk");
+	if (IS_ERR(i2s_sclk_clk)) {
+		pr_err("%s:couldn't get i2s_sclk_clk\n", __func__);
+		return;
+	}
+
+	i2s_ref_pad_clk = clk_get_sys(NULL, "i2s_ref_pad_clk");
+	if (IS_ERR(i2s_ref_pad_clk)) {
+		pr_err("%s:couldn't get i2s_ref_pad_clk\n", __func__);
+		goto put_sclk_clk;
+	}
+
+	if (clk_enable(i2s_ref_pad_clk)) {
+		pr_err("%s:enabling i2s_ref_pad_clk_fail\n", __func__);
+		goto put_ref_pad_clk;
+	}
+
+	if (clk_enable(i2s_sclk_clk)) {
+		pr_err("%s:enabling i2s_sclk_clk\n", __func__);
+		goto put_ref_pad_clk;
+	}
+
+put_ref_pad_clk:
+	clk_put(i2s_ref_pad_clk);
+put_sclk_clk:
+	clk_put(i2s_sclk_clk);
+}
+#endif
+
+void spear13xx_l2x0_init(void)
+{
+#ifdef CONFIG_CACHE_L2X0
+	/*
+	 * 512KB (64KB/way), 8-way associativity, parity supported
+	 *
+	 * FIXME: 9th bit, of Auxillary Controller register must be set
+	 * for some spear13xx devices for stable L2 operation.
+	 *
+	 * Enable Early BRESP, L2 prefetch for Instruction and Data,
+	 * write alloc and 'Full line of zero' options
+	 *
+	 */
+
+	writel_relaxed(0x06, __io_address(SPEAR13XX_L2CC_BASE)
+			+ L2X0_PREFETCH_CTRL);
+
+	if (cpu_is_spear1340() || cpu_is_spear1310()) {
+		/*
+		 * Program following latencies in order to make
+		 * SPEAr1340 work at 600 MHz
+		 */
+		writel_relaxed(0x221, __io_address(SPEAR13XX_L2CC_BASE)
+				+ L2X0_TAG_LATENCY_CTRL);
+		writel_relaxed(0x441, __io_address(SPEAR13XX_L2CC_BASE)
+				+ L2X0_DATA_LATENCY_CTRL);
+		l2x0_init(__io_address(SPEAR13XX_L2CC_BASE), 0x70A60001,
+				0xfe00ffff);
+	} else {
+		l2x0_init(__io_address(SPEAR13XX_L2CC_BASE), 0x70A60201,
+				0xfe00ffff);
+	}
+#endif
+}
+
+/* Do spear13xx familiy common initialization part here */
+void spear13xx_init(void)
+{
+	int ret;
+
+	spear13xx_l2x0_init();
+
+#ifdef CONFIG_SND_SOC_STA529
+	i2s_clk_init();
+#endif
+
+	dmac_setup();
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900)
+	if (!cpu_is_spear1340() && !cpu_is_spear1310())
+		set_udc_plat_data(&spear13xx_udc_device);
+#endif
+
+	ret = clk_set_rate_sys("sdhci", NULL, 50000000);
+	if (ret)
+		pr_err("clk_set_rate failed for sdhci: %d\n", ret);
+
+#ifdef CONFIG_PCI
+	/* PCI specific initializations */
+	pcibios_min_io = 0x1000;
+	pcibios_min_mem = 0;
+	pci_set_flags(0);
+#endif
+}
+
+static int spear13xx_set_wake(struct irq_data *data, unsigned int on)
+{
+	return 0;
+}
+
+/* This will initialize gic */
+void __init spear13xx_init_irq(void)
+{
+	gic_init(0, 29, __io_address(SPEAR13XX_GIC_DIST_BASE),
+			__io_address(SPEAR13XX_GIC_CPU_BASE));
+	gic_arch_extn.irq_set_wake = spear13xx_set_wake;
+}
+
+unsigned long reserve_mem(struct meminfo *mi, unsigned long size)
+{
+	unsigned long addr = ~0;
+	int i;
+	for (i = mi->nr_banks - 1; i >= 0; i--)
+		if (mi->bank[i].size >= size) {
+			mi->bank[i].size -= size;
+			addr = mi->bank[i].start + mi->bank[i].size;
+			break;
+		}
+
+	return addr;
+}
+
+/* Following will create static virtual/physical mappings */
+static struct map_desc spear13xx_io_desc[] __initdata = {
+	{
+		.virtual	= IO_ADDRESS(SPEAR13XX_UART_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_UART_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_A9SM_PERIP_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_A9SM_PERIP_BASE),
+		.length		= SZ_8K,
+		.type		= MT_DEVICE
+#ifdef CONFIG_CACHE_L2X0
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_L2CC_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_L2CC_BASE),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE
+#endif
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_MISC_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_MISC_BASE),
+		.length		= SZ_8K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_SYSRAM0_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_SYSRAM0_BASE),
+		.length		= SZ_32K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_SYSRAM1_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_SYSRAM1_BASE),
+		.length		= SZ_4K,
+		.type		= MT_MEMORY_NONCACHED
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_PCIE0_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_PCIE0_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_PCIE1_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_PCIE1_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= IO_ADDRESS(SPEAR13XX_PCIE2_BASE),
+		.pfn		= __phys_to_pfn(SPEAR13XX_PCIE2_BASE),
+		.length		= SZ_64K,
+		.type		= MT_DEVICE
+	}
+};
+
+/* This will create static memory mapping for selected devices */
+void __init spear13xx_map_io(void)
+{
+	iotable_init(spear13xx_io_desc, ARRAY_SIZE(spear13xx_io_desc));
+
+	/* This will initialize clock framework */
+	if (cpu_is_spear1340()) {
+#ifdef CONFIG_CPU_SPEAR1340
+		spear1340_clk_init();
+#endif
+	} else if (cpu_is_spear1310()) {
+#ifdef CONFIG_CPU_SPEAR1310
+		spear1310_clk_init();
+#endif
+	} else
+		spear13xx_clk_init();
+}
+
+static void __init spear13xx_timer_init(void)
+{
+	char pclk_name[] = "osc1_24m_clk";
+	struct clk *gpt_clk, *pclk;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	/* Setup the local timer base */
+	twd_base = __io_address(SPEAR13XX_LOCAL_TMR_BASE);
+#endif
+
+	/* get the system timer clock */
+	gpt_clk = clk_get_sys("gpt0", NULL);
+	if (IS_ERR(gpt_clk)) {
+		pr_err("%s:couldn't get clk for gpt\n", __func__);
+		BUG();
+	}
+
+	/* get the suitable parent clock for timer*/
+	pclk = clk_get(NULL, pclk_name);
+	if (IS_ERR(pclk)) {
+		pr_err("%s:couldn't get %s as parent for gpt\n",
+				__func__, pclk_name);
+		BUG();
+	}
+
+	clk_set_parent(gpt_clk, pclk);
+	clk_put(gpt_clk);
+	clk_put(pclk);
+
+	spear_setup_timer();
+}
+
+struct sys_timer spear13xx_timer = {
+	.init = spear13xx_timer_init,
+};
+
+#if defined(CONFIG_CPU_SPEAR1300) || defined(CONFIG_CPU_SPEAR1310_REVA) || \
+			defined(CONFIG_CPU_SPEAR900) || \
+			defined(CONFIG_CPU_SPEAR1310)
+/* pad multiplexing support */
+/* devices */
+
+/* Pad multiplexing for i2c device */
+static struct pmx_mux_reg pmx_i2c_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2C_MASK,
+		.value = SPEAR13XX_PMX_I2C_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2c_modes[] = {
+	{
+		.mux_regs = pmx_i2c_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2c_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_i2c = {
+	.name = "i2c",
+	.modes = pmx_i2c_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2c_modes),
+};
+
+/* Pad multiplexing for ssp device */
+static struct pmx_mux_reg pmx_ssp_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SSP_MASK,
+		.value = SPEAR13XX_PMX_SSP_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp_modes[] = {
+	{
+		.mux_regs = pmx_ssp_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_ssp = {
+	.name = "ssp",
+	.modes = pmx_ssp_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp_modes),
+};
+
+/* Pad multiplexing for i2s1 device */
+static struct pmx_mux_reg pmx_i2s1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_I2S1_MASK,
+		.value = SPEAR13XX_PMX_I2S1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2s1_modes[] = {
+	{
+		.mux_regs = pmx_i2s1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2s1_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_i2s1 = {
+	.name = "i2s1",
+	.modes = pmx_i2s1_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2s1_modes),
+};
+
+/* Pad multiplexing for i2s2 device */
+static struct pmx_mux_reg pmx_i2s2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_I2S2_MASK,
+		.value = SPEAR13XX_PMX_I2S2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_i2s2_modes[] = {
+	{
+		.mux_regs = pmx_i2s2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_i2s2_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_i2s2 = {
+	.name = "i2s2",
+	.modes = pmx_i2s2_modes,
+	.mode_count = ARRAY_SIZE(pmx_i2s2_modes),
+};
+
+/* Pad multiplexing for clcd device */
+static struct pmx_mux_reg pmx_clcd_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = SPEAR13XX_PMX_CLCD1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_clcd_modes[] = {
+	{
+		.mux_regs = pmx_clcd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_clcd_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_clcd = {
+	.name = "clcd",
+	.modes = pmx_clcd_modes,
+	.mode_count = ARRAY_SIZE(pmx_clcd_modes),
+};
+
+/* Pad multiplexing for clcd_hires device */
+static struct pmx_mux_reg pmx_clcd_hires_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_CLCD1_MASK,
+		.value = SPEAR13XX_PMX_CLCD1_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_CLCD2_MASK,
+		.value = SPEAR13XX_PMX_CLCD2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_clcd_hires_modes[] = {
+	{
+		.mux_regs = pmx_clcd_hires_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_clcd_hires_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_clcd_hires = {
+	.name = "clcd_high_res",
+	.modes = pmx_clcd_hires_modes,
+	.mode_count = ARRAY_SIZE(pmx_clcd_hires_modes),
+};
+
+/*
+ * By default, all EGPIOs are enabled.
+ * TBD : Board specific enabling of specific GPIOs only
+ */
+static struct pmx_mux_reg pmx_egpio_grp_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_EGPIO_0_GRP_MASK,
+		.value = SPEAR13XX_PMX_EGPIO_0_GRP_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_EGPIO_1_GRP_MASK,
+		.value = SPEAR13XX_PMX_EGPIO_1_GRP_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_egpio_grp_modes[] = {
+	{
+		.mux_regs = pmx_egpio_grp_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_egpio_grp_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_egpio_grp = {
+	.name = "egpios",
+	.modes = pmx_egpio_grp_modes,
+	.mode_count = ARRAY_SIZE(pmx_egpio_grp_modes),
+};
+
+/* Pad multiplexing for smi 2 chips device */
+static struct pmx_mux_reg pmx_smi_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SMI_MASK,
+		.value = SPEAR13XX_PMX_SMI_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_smi_2_modes[] = {
+	{
+		.mux_regs = pmx_smi_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_smi_2_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_smi_2_chips = {
+	.name = "smi_2_chips",
+	.modes = pmx_smi_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_smi_2_modes),
+};
+
+/* Pad multiplexing for smi 4 chips device */
+static struct pmx_mux_reg pmx_smi_4_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_SMI_MASK,
+		.value = SPEAR13XX_PMX_SMI_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_SMINCS2_MASK | SPEAR13XX_PMX_SMINCS3_MASK,
+		.value = SPEAR13XX_PMX_SMINCS2_MASK | \
+			 SPEAR13XX_PMX_SMINCS3_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_smi_4_modes[] = {
+	{
+		.mux_regs = pmx_smi_4_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_smi_4_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_smi_4_chips = {
+	.name = "smi_4_chips",
+	.modes = pmx_smi_4_modes,
+	.mode_count = ARRAY_SIZE(pmx_smi_4_modes),
+};
+
+/* Pad multiplexing for gmii device */
+static struct pmx_mux_reg pmx_gmii_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_GMII_MASK,
+		.value = SPEAR13XX_PMX_GMII_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gmii_modes[] = {
+	{
+		.mux_regs = pmx_gmii_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gmii_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_gmii = {
+	.name = "gmii",
+	.modes = pmx_gmii_modes,
+	.mode_count = ARRAY_SIZE(pmx_gmii_modes),
+};
+
+/* Pad multiplexing for nand 8bit (4 chips) */
+static struct pmx_mux_reg pmx_nand8_4_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NAND8BIT4DEV_0_MASK,
+		.value = SPEAR13XX_PMX_NAND8BIT4DEV_0_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NAND8BIT4DEV_1_MASK | \
+			SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+		.value = SPEAR13XX_PMX_NAND8BIT4DEV_1_MASK | \
+			 SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_nand8_4_modes[] = {
+	{
+		.mux_regs = pmx_nand8_4_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_nand8_4_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_nand_8bit_4_chips = {
+	.name = "nand-8bit_4_chips",
+	.modes = pmx_nand8_4_modes,
+	.mode_count = ARRAY_SIZE(pmx_nand8_4_modes),
+};
+
+/* Pad multiplexing for nand 8bit device (cs0 only) */
+static struct pmx_mux_reg pmx_nand8_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NAND8BIT_0_MASK,
+		.value = SPEAR13XX_PMX_NAND8BIT_0_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NAND8BIT_1_MASK | \
+			SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+		.value = SPEAR13XX_PMX_NAND8BIT_1_MASK | \
+			 SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_nand8_modes[] = {
+	{
+		.mux_regs = pmx_nand8_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_nand8_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_nand_8bit = {
+	.name = "nand-8bit",
+	.modes = pmx_nand8_modes,
+	.mode_count = ARRAY_SIZE(pmx_nand8_modes),
+};
+
+/*
+ * Pad multiplexing for nand 16bit device
+ * Note : Enabling pmx_nand_16bit means that all the required pads for
+ *   16bit nand device operations are enabled. These also include pads
+ *   for 8bit devices
+ */
+static struct pmx_mux_reg pmx_nand16_4_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NAND16BIT4DEV_0_MASK,
+		.value = SPEAR13XX_PMX_NAND16BIT4DEV_0_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NAND16BIT4DEV_1_MASK | \
+			SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+		.value = SPEAR13XX_PMX_NAND16BIT4DEV_1_MASK | \
+			 SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_nand16_4_modes[] = {
+	{
+		.mux_regs = pmx_nand16_4_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_nand16_4_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_nand_16bit_4_chips = {
+	.name = "nand-16bit_4_chips",
+	.modes = pmx_nand16_4_modes,
+	.mode_count = ARRAY_SIZE(pmx_nand16_4_modes),
+};
+
+/* Pad multiplexing for nand 16bit device (cs0 only) */
+static struct pmx_mux_reg pmx_nand16_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_NAND16BIT_0_MASK,
+		.value = SPEAR13XX_PMX_NAND16BIT_0_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NAND16BIT_1_MASK | \
+			SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+		.value = SPEAR13XX_PMX_NAND16BIT_1_MASK | \
+			 SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_nand16_modes[] = {
+	{
+		.mux_regs = pmx_nand16_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_nand16_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_nand_16bit = {
+	.name = "nand-16bit",
+	.modes = pmx_nand16_modes,
+	.mode_count = ARRAY_SIZE(pmx_nand16_modes),
+};
+
+/* Pad multiplexing for keyboard_6x6 device */
+static struct pmx_mux_reg pmx_keyboard_6x6_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+		.value = SPEAR13XX_PMX_KEYBOARD_6X6_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NFIO815_MASK | SPEAR13XX_PMX_NFCE1_MASK |\
+			SPEAR13XX_PMX_NFCE2_MASK | SPEAR13XX_PMX_NFWPRT1_MASK |\
+			SPEAR13XX_PMX_NFWPRT2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_keyboard_6x6_modes[] = {
+	{
+		.mux_regs = pmx_keyboard_6x6_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_keyboard_6x6_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_keyboard_6x6 = {
+	.name = "keyboard_6x6",
+	.modes = pmx_keyboard_6x6_modes,
+	.mode_count = ARRAY_SIZE(pmx_keyboard_6x6_modes),
+};
+
+/* Pad multiplexing for keyboard_9x9 device */
+static struct pmx_mux_reg pmx_keyboard_9x9_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_KEYBOARD_6X6_MASK | \
+			SPEAR13XX_PMX_KBD_ROWCOL68_MASK,
+		.value = SPEAR13XX_PMX_KEYBOARD_6X6_MASK | \
+			 SPEAR13XX_PMX_KBD_ROWCOL68_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_NFIO815_MASK | SPEAR13XX_PMX_NFCE1_MASK |\
+			SPEAR13XX_PMX_NFCE2_MASK | SPEAR13XX_PMX_NFWPRT1_MASK |\
+			SPEAR13XX_PMX_NFWPRT2_MASK,
+		.value = 0,
+	},
+};
+
+static struct pmx_dev_mode pmx_keyboard_9x9_modes[] = {
+	{
+		.mux_regs = pmx_keyboard_9x9_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_keyboard_9x9_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_keyboard_9x9 = {
+	.name = "keyboard_9x9",
+	.modes = pmx_keyboard_9x9_modes,
+	.mode_count = ARRAY_SIZE(pmx_keyboard_9x9_modes),
+};
+
+/* Pad multiplexing for uart0 device */
+static struct pmx_mux_reg pmx_uart0_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_UART0_MASK,
+		.value = SPEAR13XX_PMX_UART0_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart0_modes[] = {
+	{
+		.mux_regs = pmx_uart0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart0_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_uart0 = {
+	.name = "uart0",
+	.modes = pmx_uart0_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart0_modes),
+};
+
+/* Pad multiplexing for uart0_modem device */
+static struct pmx_mux_reg pmx_uart0_modem_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_UART0_MODEM_MASK,
+		.value = SPEAR13XX_PMX_UART0_MODEM_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_uart0_modem_modes[] = {
+	{
+		.mux_regs = pmx_uart0_modem_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_uart0_modem_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_uart0_modem = {
+	.name = "uart0_modem",
+	.modes = pmx_uart0_modem_modes,
+	.mode_count = ARRAY_SIZE(pmx_uart0_modem_modes),
+};
+
+/* Pad multiplexing for gpt_0_1 device */
+static struct pmx_mux_reg pmx_gpt_0_1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT0_TMR1_MASK,
+		.value = SPEAR13XX_PMX_GPT0_TMR1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt_0_1_modes[] = {
+	{
+		.mux_regs = pmx_gpt_0_1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt_0_1_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_gpt_0_1 = {
+	.name = "gpt_0_1",
+	.modes = pmx_gpt_0_1_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt_0_1_modes),
+};
+
+/* Pad multiplexing for gpt_0_2 device */
+static struct pmx_mux_reg pmx_gpt_0_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT0_TMR2_MASK,
+		.value = SPEAR13XX_PMX_GPT0_TMR2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt_0_2_modes[] = {
+	{
+		.mux_regs = pmx_gpt_0_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt_0_2_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_gpt_0_2 = {
+	.name = "gpt_0_2",
+	.modes = pmx_gpt_0_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt_0_2_modes),
+};
+
+/* Pad multiplexing for gpt_1_1 device */
+static struct pmx_mux_reg pmx_gpt_1_1_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT1_TMR1_MASK,
+		.value = SPEAR13XX_PMX_GPT1_TMR1_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt_1_1_modes[] = {
+	{
+		.mux_regs = pmx_gpt_1_1_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt_1_1_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_gpt_1_1 = {
+	.name = "gpt_1_1",
+	.modes = pmx_gpt_1_1_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt_1_1_modes),
+};
+
+/* Pad multiplexing for gpt_1_2 device */
+static struct pmx_mux_reg pmx_gpt_1_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_GPT1_TMR2_MASK,
+		.value = SPEAR13XX_PMX_GPT1_TMR2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_gpt_1_2_modes[] = {
+	{
+		.mux_regs = pmx_gpt_1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_gpt_1_2_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_gpt_1_2 = {
+	.name = "gpt_1_2",
+	.modes = pmx_gpt_1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_gpt_1_2_modes),
+};
+
+/* Pad multiplexing for mcif device */
+static struct pmx_mux_reg pmx_mcif_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_1,
+		.mask = SPEAR13XX_PMX_MCI_DATA8_15_MASK,
+		.value = SPEAR13XX_PMX_MCI_DATA8_15_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_2,
+		.mask = SPEAR13XX_PMX_MCIFALL_1_MASK,
+		.value = SPEAR13XX_PMX_MCIFALL_1_MASK,
+	}, {
+		.address = PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_MCIFALL_2_MASK,
+		.value = SPEAR13XX_PMX_MCIFALL_2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_mcif_modes[] = {
+	{
+		.mux_regs = pmx_mcif_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_mcif_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_mcif = {
+	.name = "mcif",
+	.modes = pmx_mcif_modes,
+	.mode_count = ARRAY_SIZE(pmx_mcif_modes),
+};
+
+/* Pad multiplexing for sdhci device */
+static struct pmx_mux_reg pmx_sdhci_mux[] = {
+	{
+		.address = PERIP_CFG,
+		.mask = MCIF_SEL_MASK,
+		.value = MCIF_SEL_SD,
+	},
+};
+
+static struct pmx_dev_mode pmx_sdhci_modes[] = {
+	{
+		.mux_regs = pmx_sdhci_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_sdhci_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_sdhci = {
+	.name = "sdhci",
+	.modes = pmx_sdhci_modes,
+	.mode_count = ARRAY_SIZE(pmx_sdhci_modes),
+};
+
+/* Pad multiplexing for cf device */
+static struct pmx_mux_reg pmx_cf_mux[] = {
+	{
+		.address = PERIP_CFG,
+		.mask = MCIF_SEL_MASK,
+		.value = MCIF_SEL_CF,
+	},
+};
+
+static struct pmx_dev_mode pmx_cf_modes[] = {
+	{
+		.mux_regs = pmx_cf_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_cf_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_cf = {
+	.name = "cf",
+	.modes = pmx_cf_modes,
+	.mode_count = ARRAY_SIZE(pmx_cf_modes),
+};
+
+/* Pad multiplexing for xd device */
+static struct pmx_mux_reg pmx_xd_mux[] = {
+	{
+		.address = PERIP_CFG,
+		.mask = MCIF_SEL_MASK,
+		.value = MCIF_SEL_XD,
+	},
+};
+
+static struct pmx_dev_mode pmx_xd_modes[] = {
+	{
+		.mux_regs = pmx_xd_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_xd_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_xd = {
+	.name = "xd",
+	.modes = pmx_xd_modes,
+	.mode_count = ARRAY_SIZE(pmx_xd_modes),
+};
+
+/* Pad multiplexing for touch_xy device */
+static struct pmx_mux_reg pmx_touch_xy_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_TOUCH_XY_MASK,
+		.value = SPEAR13XX_PMX_TOUCH_XY_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_touch_xy_modes[] = {
+	{
+		.mux_regs = pmx_touch_xy_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_touch_xy_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_touch_xy = {
+	.name = "touch_xy",
+	.modes = pmx_touch_xy_modes,
+	.mode_count = ARRAY_SIZE(pmx_touch_xy_modes),
+};
+
+/* Pad multiplexing for ssp0_cs0 device */
+static struct pmx_mux_reg pmx_ssp0_cs0_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_SSP0_CS0_MASK,
+		.value = SPEAR13XX_PMX_SSP0_CS0_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_cs0_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_cs0_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_cs0_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_ssp0_cs0 = {
+	.name = "ssp0_cs0",
+	.modes = pmx_ssp0_cs0_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_cs0_modes),
+};
+
+/* Pad multiplexing for ssp0_cs1_2 device */
+static struct pmx_mux_reg pmx_ssp0_cs1_2_mux[] = {
+	{
+		.address = PAD_FUNCTION_EN_3,
+		.mask = SPEAR13XX_PMX_SSP0_CS1_2_MASK,
+		.value = SPEAR13XX_PMX_SSP0_CS1_2_MASK,
+	},
+};
+
+static struct pmx_dev_mode pmx_ssp0_cs1_2_modes[] = {
+	{
+		.mux_regs = pmx_ssp0_cs1_2_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_ssp0_cs1_2_mux),
+	},
+};
+
+struct pmx_dev spear13xx_pmx_ssp0_cs1_2 = {
+	.name = "ssp0_cs1_2",
+	.modes = pmx_ssp0_cs1_2_modes,
+	.mode_count = ARRAY_SIZE(pmx_ssp0_cs1_2_modes),
+};
+#endif
diff --git a/arch/arm/mach-spear13xx/spear900.c b/arch/arm/mach-spear13xx/spear900.c
new file mode 100644
index 0000000..db00618
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear900.c
@@ -0,0 +1,37 @@
+/*
+ * arch/arm/mach-spear13xx/spear900.c
+ *
+ * SPEAr900 machine source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/generic.h>
+
+/* pmx driver structure */
+static struct pmx_driver pmx_driver;
+
+/* Add spear900 specific devices here */
+
+void __init spear900_init(struct pmx_mode *pmx_mode, struct pmx_dev **pmx_devs,
+		u8 pmx_dev_count)
+{
+	int ret;
+
+	/* call spear13xx family common init function */
+	spear13xx_init();
+
+	/* pmx initialization */
+	pmx_driver.mode = pmx_mode;
+	pmx_driver.devs = pmx_devs;
+	pmx_driver.devs_count = pmx_dev_count;
+
+	ret = pmx_register(&pmx_driver);
+	if (ret)
+		pr_err("padmux: registeration failed. err no: %d\n", ret);
+}
diff --git a/arch/arm/mach-spear13xx/spear900_evb.c b/arch/arm/mach-spear13xx/spear900_evb.c
new file mode 100644
index 0000000..47bd82a
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear900_evb.c
@@ -0,0 +1,409 @@
+/*
+ * arch/arm/mach-spear13xx/spear900_evb.c
+ *
+ * SPEAr900 evaluation board source file
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Viresh Kumar <viresh.kumar@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/l3g4200d.h>
+#include <linux/mfd/stmpe.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/spear_smi.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <plat/keyboard.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/spear_pcie.h>
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/* spear13xx specific devices */
+	&spear13xx_pmx_i2c,
+	&spear13xx_pmx_i2s1,
+	&spear13xx_pmx_i2s2,
+	&spear13xx_pmx_clcd,
+	&spear13xx_pmx_egpio_grp,
+	&spear13xx_pmx_gmii,
+	&spear13xx_pmx_keyboard_6x6,
+	&spear13xx_pmx_mcif,
+	&spear13xx_pmx_nand_8bit,
+	&spear13xx_pmx_smi_4_chips,
+	&spear13xx_pmx_ssp,
+	&spear13xx_pmx_uart0,
+	&spear13xx_pmx_sdhci,
+
+	/* spear900 specific devices */
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_cpufreq_device,
+	&spear13xx_db9000_clcd_device,
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear13xx_device_gpiokeys,
+#endif
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear13xx_i2s0_device,
+	&spear13xx_jpeg_device,
+	&spear13xx_kbd_device,
+	&spear13xx_nand_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcie_gadget0_device,
+	&spear13xx_pcie_host1_device,
+	&spear13xx_pcie_host2_device,
+	&spear13xx_pcm_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear13xx_thermal_device,
+	&spear13xx_udc_device,
+	&spear13xx_wdt_device,
+
+};
+
+/* Ethernet Platform Data */
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 8,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = 5,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x20000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x20000,
+		.size = 12 * 0x20000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 12) * 0x20000,
+		.size = 48 * 0x20000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 48) * 0x20000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+#if 0
+/* fsmc nor partition info */
+#define PARTITION(n, off, sz)	{.name = n, .offset = off, .size = sz}
+static struct mtd_partition partition_info[] = {
+	PARTITION("X-loader", 0, 1 * 0x20000),
+	PARTITION("U-Boot", 0x20000, 3 * 0x20000),
+	PARTITION("Kernel", 0x80000, 24 * 0x20000),
+	PARTITION("Root File System", 0x380000, 84 * 0x20000),
+};
+
+/* fsmc nor platform data */
+static const struct physmap_flash_data nor_plat_data __initconst = {
+	.parts = partition_info,
+	.nr_parts = ARRAY_SIZE(partition_info),
+	.width = FSMC_FLASH_WIDTH8,
+};
+#endif
+
+/* arasan compact flash controller's platform data */
+static struct arasan_cf_pdata cf_pdata = {
+	.cf_if_clk = CF_IF_CLK_166M,
+	.quirk = CF_BROKEN_UDMA,
+	.dma_priv = &cf_dma_priv,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_9x9_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_9x9,
+};
+
+/* Initializing platform data for SPEAr900 specific Input devices on I2C Bus */
+/* Gyroscope platform data */
+static struct l3g4200d_gyr_platform_data l3g4200d_pdata = {
+	.poll_interval = 5,
+	.min_interval = 2,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+};
+
+static struct i2c_board_info __initdata i2c_board_info[] = {
+	/* gyroscope board info */
+	{
+		.type = "l3g4200d_gyr",
+		.addr = 0x68,
+		.platform_data = &l3g4200d_pdata,
+	},
+};
+
+/* Currently no gpios are free on eval board so it is kept commented */
+#if 0
+/* spi0 flash Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, flash, /* mention gpio number here */);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_gpio_control);
+
+/* spi0 spidev Chip Select Control function, controlled by gpio pin mentioned */
+DECLARE_SPI_CS_GPIO_CONTROL(0, dev, /* mention gpio number here */);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_gpio_control);
+#endif
+
+/* spi0 touch screen Chip Select Control function, controlled by gpio pin */
+DECLARE_SPI_CS_GPIO_CONTROL(0, ts, GPIO1_7);
+/* spi0 touch screen Info structure */
+static struct pl022_config_chip spi0_ts_chip_info = {
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_MASTER,
+	.slave_tx_disable = 0,
+	.com_mode = INTERRUPT_TRANSFER,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = spi0_ts_cs_gpio_control,
+};
+
+static struct stmpe_ts_platform_data stmpe610_ts_pdata = {
+	.sample_time = 4, /* 80 clocks */
+	.mod_12b = 1, /* 12 bit */
+	.ref_sel = 0, /* Internal */
+	.adc_freq = 1, /* 3.25 MHz */
+	.ave_ctrl = 1, /* 2 samples */
+	.touch_det_delay = 2, /* 100 us */
+	.settling = 2, /* 500 us */
+	.fraction_z = 7,
+	.i_drive = 1, /* 50 to 80 mA */
+};
+
+static struct stmpe_platform_data stmpe610_pdata = {
+	.id = 0,
+	.blocks = STMPE_BLOCK_TOUCHSCREEN,
+	.irq_base = SPEAR_STMPE610_INT_BASE,
+	.irq_trigger = IRQ_TYPE_EDGE_FALLING,
+	.irq_invert_polarity = false,
+	.autosleep = false,
+	.irq_over_gpio = true,
+	.irq_gpio = GPIO1_6,
+	.ts = &stmpe610_ts_pdata,
+};
+
+static struct spi_board_info __initdata spi_board_info[] = {
+	/* spi0 board info */
+	{
+		.modalias = "stmpe610",
+		.platform_data = &stmpe610_pdata,
+		.controller_data = &spi0_ts_chip_info,
+		.max_speed_hz = 1000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	},
+#if 0
+	/* spi0 board info */
+	{
+		.modalias = "spidev",
+		.controller_data = &spi0_dev_chip_info,
+		.max_speed_hz = 25000000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_1,
+	}, {
+		.modalias = "m25p80",
+		.controller_data = &spi0_flash_chip_info,
+		.max_speed_hz = 12000000,
+		.bus_num = 0,
+		.chip_select = 1,
+		.mode = SPI_MODE_3,
+	}
+#endif
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+/* This function is needed for board specific PCIe initilization */
+static void __init spear900_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host1_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host2_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_41);
+}
+#endif
+
+static void
+spear900_evb_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init spear900_evb_init(void)
+{
+	unsigned int i;
+
+	/* set compact flash plat data */
+	set_arasan_cf_pdata(&spear13xx_cf_device, &cf_pdata);
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* call spear900 machine init function */
+	spear900_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear13xx_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_nand_device.name);
+
+	/*
+	 * FSMC cannot used as NOR and NAND at the same time For the moment,
+	 * disable NOR and use NAND only. If NOR is needed, enable the following
+	 * code and disable all code for NAND. Also enable nand in padmux
+	 * configuration to use it
+	 */
+#if 0
+	/* Initialize fsmc regiters */
+	fsmc_nor_init(&spear13xx_fsmc_nor_device, SPEAR13XX_FSMC_BASE, 0,
+			FSMC_FLASH_WIDTH8);
+	/* initialize fsmc related data in fsmc plat data */
+	if (platform_device_add_data(&spear13xx_fsmc_nor_device, &nor_plat_data,
+				sizeof(nor_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_fsmc_nor_device.name);
+#endif
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+#ifdef CONFIG_SPEAR_PCIE_REV341
+	spear900_pcie_board_init();
+#endif
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/* Register slave devices on the I2C buses */
+	i2c_register_default_devices();
+
+	/* Register EVB 900 specific i2c slave devices */
+	i2c_register_board_info(0, i2c_board_info,
+				ARRAY_SIZE(i2c_board_info));
+
+	spi_register_board_info(spi_board_info, ARRAY_SIZE(spi_board_info));
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR900_EVB, "ST-SPEAR900-EVB")
+	.atag_offset	=	0x100,
+	.fixup		=	spear900_evb_fixup,
+	.map_io		=	spear13xx_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear900_evb_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear_hurricane_board.c b/arch/arm/mach-spear13xx/spear_hurricane_board.c
new file mode 100644
index 0000000..ad391b6
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear_hurricane_board.c
@@ -0,0 +1,445 @@
+/*
+ * arch/arm/mach-spear13xx/spear_hurricane_board.c
+ *
+ * NComputing SPEAr Hurricane board source file
+ *
+ * Copyright (C) 2011 ST Microelectronics
+ * Vincenzo Frascino <vincenzo.frascino@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/l3g4200d.h>
+#include <linux/irq.h>
+#include <linux/mtd/fsmc.h>
+#include <linux/mtd/nand.h>
+#include <linux/netdevice.h>
+#include <linux/pata_arasan_cf_data.h>
+#include <linux/phy.h>
+#include <linux/spi/spi.h>
+#include <linux/stmmac.h>
+#include <video/db9000fb.h>
+#include <asm/hardware/gic.h>
+#include <plat/keyboard.h>
+#include <plat/spi.h>
+#include <mach/generic.h>
+#include <mach/hardware.h>
+#include <mach/plug_board.h>
+#include <mach/spear1340_misc_regs.h>
+#include <mach/spear_pcie.h>
+
+/*
+ * Pad multiplexing for making few pads as plgpio's.
+ * Please retain original values and addresses, and update only mask as
+ * required.
+ * For example: if we need to enable plgpio's on pads: 15, 28, 45 & 102.
+ * They corresponds to following bits in registers: 16, 29, 46 & 103
+ * So following mask entries will solve this purpose:
+ * Reg1: .mask = 0x20010000,
+ * Reg2: .mask = 0x00004000,
+ * Reg4: .mask = 0x00000080,
+ *
+ * Note: Counting of bits and pads start from 0.
+ */
+static struct pmx_mux_reg pmx_plgpios_mux[] = {
+	{
+		.address = SPEAR1340_PAD_FUNCTION_EN_1,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_2,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_3,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_4,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_5,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_6,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_7,
+		.mask = 0x0,
+		.value = 0x0,
+	}, {
+		.address = SPEAR1340_PAD_FUNCTION_EN_8,
+		.mask = 0x0,
+		.value = 0x0,
+	},
+};
+
+static struct pmx_dev_mode pmx_plgpios_modes[] = {
+	{
+		.mux_regs = pmx_plgpios_mux,
+		.mux_reg_cnt = ARRAY_SIZE(pmx_plgpios_mux),
+	},
+};
+
+static struct pmx_dev spear1340_pmx_plgpios = {
+	.name = "plgpios",
+	.modes = pmx_plgpios_modes,
+	.mode_count = ARRAY_SIZE(pmx_plgpios_modes),
+};
+
+/* padmux devices to enable */
+static struct pmx_dev *pmx_devs[] = {
+	/*
+	 * Keep pads_as_gpio as the first element in this array. Don't ever
+	 * remove it. It makes all pads as gpio's in starting, and then pads are
+	 * configured as peripherals wherever required.
+	 */
+	&spear1340_pmx_pads_as_gpio,
+	&spear1340_pmx_fsmc_8bit,
+	&spear1340_pmx_keyboard_row_col,
+#if !defined(CONFIG_PM)
+	&spear1340_pmx_keyboard_col5,
+#endif
+	&spear1340_pmx_uart0_enh,
+	&spear1340_pmx_i2c1,
+	&spear1340_pmx_spdif_in,
+	&spear1340_pmx_ssp0_cs1,
+#if !defined(CONFIG_PM)
+	&spear1340_pmx_pwm2,
+#endif
+	&spear1340_pmx_pwm3,
+	&spear1340_pmx_smi,
+	&spear1340_pmx_ssp0,
+	&spear1340_pmx_uart0,
+	&spear1340_pmx_i2s_in,
+	&spear1340_pmx_i2s_out,
+	&spear1340_pmx_gmac,
+	&spear1340_pmx_ssp0_cs3,
+	&spear1340_pmx_i2c0,
+	&spear1340_pmx_cec0,
+	&spear1340_pmx_cec1,
+	&spear1340_pmx_spdif_out,
+	&spear1340_pmx_mcif,
+	&spear1340_pmx_sdhci,
+	&spear1340_pmx_clcd,
+	&spear1340_pmx_clcd_gpio_pd,
+	&spear1340_pmx_devs_grp,
+	&spear1340_pmx_gmii,
+	&spear1340_pmx_pcie,
+
+	/* Keep this entry at the bottom of table to override earlier setting */
+	&spear1340_pmx_plgpios,
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_gpio_device[0],
+	&spear13xx_gpio_device[1],
+	&spear13xx_ssp_device,
+	&spear13xx_uart_device,
+
+	/* spear1340 specific devices */
+	&spear1340_uart1_device,
+};
+
+static struct platform_device *plat_devs[] __initdata = {
+	/* spear13xx specific devices */
+	&spear13xx_adc_device,
+	&spear13xx_db9000_clcd_device,
+	&spear13xx_dmac_device[0],
+	&spear13xx_dmac_device[1],
+	&spear13xx_ehci0_device,
+	&spear13xx_ehci1_device,
+	&spear13xx_eth_device,
+	&spear13xx_i2c_device,
+	&spear1340_nand_device,
+	&spear1340_i2s_play_device,
+	&spear1340_i2s_record_device,
+	&spear13xx_ohci0_device,
+	&spear13xx_ohci1_device,
+	&spear13xx_pcm_device,
+	&spear13xx_pcie_host0_device,
+	&spear13xx_rtc_device,
+	&spear13xx_sdhci_device,
+	&spear13xx_smi_device,
+	&spear1340_spdif_out_device,
+	&spear13xx_wdt_device,
+
+	/* spear1340 specific devices */
+	&spear1340_cec0_device,
+	&spear1340_cec1_device,
+	&spear1340_cpufreq_device,
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+	&spear1340_gpiokeys_device,
+#endif
+	&spear1340_i2c1_device,
+	&spear1340_pwm_device,
+	&spear1340_phy0_device,
+	&spear1340_plgpio_device,
+	&spear1340_otg_device,
+	&spear1340_thermal_device,
+};
+
+/* MDIO Bus Data */
+static struct stmmac_mdio_bus_data mdio0_private_data = {
+	.bus_id = 0,
+	.phy_mask = 0,
+};
+
+static struct stmmac_dma_cfg dma0_private_data = {
+	.pbl = 16,
+	.fixed_burst = 1,
+	.burst_len = DMA_AXI_BLEN_ALL,
+};
+
+static struct plat_stmmacenet_data eth_data = {
+	.bus_id = 0,
+	.phy_addr = -1,
+	.interface = PHY_INTERFACE_MODE_GMII,
+	.has_gmac = 1,
+	.enh_desc = 1,
+	.tx_coe = 1,
+	.dma_cfg = &dma0_private_data,
+	.rx_coe = STMMAC_RX_COE_TYPE2,
+	.bugged_jumbo = 1,
+	.pmt = 1,
+	.mdio_bus_data = &mdio0_private_data,
+	.init = spear13xx_eth_phy_clk_cfg,
+	.clk_csr = STMMAC_CSR_150_250M,
+};
+
+static struct mtd_partition nand_partition_info[] __initdata = {
+	{
+		.name = "X-loader",
+		.offset = 0,
+		.size = 4 * 0x80000,
+	}, {
+		.name = "U-Boot",
+		.offset = 4 * 0x80000,
+		.size = 6 * 0x80000,
+	}, {
+		.name = "Kernel",
+		.offset = (4 + 6) * 0x80000,
+		.size = 24 * 0x80000,
+	}, {
+		.name = "Root File System",
+		.offset = (4 + 12 + 24) * 0x80000,
+		.size = MTDPART_SIZ_FULL,
+	}
+};
+
+/* Ethernet specific plat data */
+/* fsmc platform data */
+static const struct fsmc_nand_platform_data nand_plat_data __initconst = {
+	.select_bank = nand_select_bank,
+	.partitions = nand_partition_info,
+	.nr_partitions = ARRAY_SIZE(nand_partition_info),
+	.options = NAND_SKIP_BBTSCAN,
+	.width = FSMC_NAND_BW8,
+	.ale_off = PLAT_NAND_ALE,
+	.cle_off = PLAT_NAND_CLE,
+	.mode = USE_DMA_ACCESS,
+	.read_dma_priv = &nand_read_dma_priv,
+	.write_dma_priv = &nand_write_dma_priv,
+	.max_banks = 1,
+};
+
+static struct arasan_cf_pdata cf_pdata = {
+	.cf_if_clk = CF_IF_CLK_166M,
+	.quirk = CF_BROKEN_UDMA,
+	.dma_priv = &cf_dma_priv,
+};
+
+/* keyboard specific platform data */
+static const __initconst DECLARE_6x6_KEYMAP(keymap);
+static const struct matrix_keymap_data keymap_data __initconst = {
+	.keymap = keymap,
+	.keymap_size = ARRAY_SIZE(keymap),
+};
+
+static const struct kbd_platform_data kbd_data __initconst = {
+	.keymap = &keymap_data,
+	.rep = 1,
+	.mode = KEYPAD_2x2,
+};
+
+/* Initializing platform data for spear1340 evb specific I2C devices */
+/* Gyroscope platform data */
+static struct l3g4200d_gyr_platform_data l3g4200d_pdata = {
+	.poll_interval = 5,
+	.min_interval = 2,
+	.axis_map_x = 0,
+	.axis_map_y = 1,
+	.axis_map_z = 2,
+};
+
+struct i2c_board_info spear_hurricane_board_i2c_l3g4200d_gyr = {
+	/* gyroscope board info */
+	.type = "l3g4200d_gyr",
+	.addr = 0x69,
+	.platform_data = &l3g4200d_pdata,
+};
+
+struct i2c_board_info spear_hurricane_board_i2c_eeprom0 = {
+	.type = "eeprom",
+	.addr = 0x50,
+};
+
+struct i2c_board_info spear_hurricane_board_i2c_eeprom1 = {
+	.type = "eeprom",
+	.addr = 0x51,
+};
+
+struct i2c_board_info spear_hurricane_board_i2c_sta529 = {
+	.type = "sta529",
+	.addr = 0x1a,
+};
+
+static struct i2c_board_info *i2c_board[] __initdata = {
+	&spear_hurricane_board_i2c_l3g4200d_gyr,
+	&spear_hurricane_board_i2c_eeprom0,
+	&spear_hurricane_board_i2c_eeprom1,
+	&spear_hurricane_board_i2c_sta529,
+};
+
+/* Definitions for SPI Devices*/
+
+/* spi master's configuration routine */
+DECLARE_SPI_CS_CFG(0, VA_SPEAR1340_PERIP_CFG, SPEAR1340_SSP_CS_SEL_MASK,
+		SPEAR1340_SSP_CS_SEL_SHIFT, SPEAR1340_SSP_CS_CTL_MASK,
+		SPEAR1340_SSP_CS_CTL_SHIFT, SPEAR1340_SSP_CS_CTL_SW,
+		SPEAR1340_SSP_CS_VAL_MASK, SPEAR1340_SSP_CS_VAL_SHIFT);
+
+/* spi0 flash Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, flash, SPEAR1340_SSP_CS_SEL_CS0);
+/* spi0 flash Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, flash, spi0_flash_cs_control);
+
+/* spi0 spidev Chip Select Control function */
+DECLARE_SPI_CS_CONTROL(0, dev, SPEAR1340_SSP_CS_SEL_CS2);
+/* spi0 spidev Chip Info structure */
+DECLARE_SPI_CHIP_INFO(0, dev, spi0_dev_cs_control);
+
+struct spi_board_info spear_hurricane_board_spi_m25p80 = {
+	.modalias = "m25p80",
+	.controller_data = &spi0_flash_chip_info,
+	.max_speed_hz = 12000000,
+	.bus_num = 0,
+	.chip_select = SPEAR1340_SSP_CS_SEL_CS0,
+	.mode = SPI_MODE_3,
+};
+struct spi_board_info spear_hurricane_board_spi_spidev = {
+	.modalias = "spidev",
+	.controller_data = &spi0_dev_chip_info,
+	.max_speed_hz = 25000000,
+	.bus_num = 0,
+	.chip_select = SPEAR1340_SSP_CS_SEL_CS2,
+	.mode = SPI_MODE_1,
+};
+
+static struct spi_board_info *spi_board[] __initdata = {
+	&spear_hurricane_board_spi_m25p80,
+	&spear_hurricane_board_spi_spidev,
+};
+
+#ifdef CONFIG_SPEAR_PCIE_REV370
+/* This function is needed for board specific PCIe initilization */
+static void __init spear_hurricane_pcie_board_init(void)
+{
+	void *plat_data;
+
+	plat_data = dev_get_platdata(&spear13xx_pcie_host0_device.dev);
+	PCIE_PORT_INIT((struct pcie_port_info *)plat_data, SPEAR_PCIE_REV_3_70);
+}
+#endif
+
+static void
+spear_hurricane_fixup(struct tag *tags, char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE)
+	spear13xx_panel_fixup(mi);
+#endif
+}
+
+static void __init spear_hurricane_init(void)
+{
+	unsigned int i;
+
+	/* set compact flash plat data */
+	set_arasan_cf_pdata(&spear13xx_cf_device, &cf_pdata);
+
+#if (defined(CONFIG_FB_DB9000) || defined(CONFIG_FB_DB9000_MODULE))
+	/* db9000_clcd plat data */
+	spear13xx_panel_init(&spear13xx_db9000_clcd_device);
+#endif
+
+	/* Set stmmac plat data */
+	if (platform_device_add_data(&spear13xx_eth_device, &eth_data,
+			sizeof(eth_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_eth_device.name);
+
+	/* initialize serial nor related data in smi plat data */
+	smi_init_board_info(&spear13xx_smi_device);
+
+	/* set keyboard plat data */
+	if (platform_device_add_data(&spear13xx_kbd_device, &kbd_data,
+				sizeof(kbd_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear13xx_kbd_device.name);
+
+	/*
+	 * SPEAr1340 FSMC cannot used as NOR and NAND at the same time
+	 * For the moment, disable NOR and use NAND only
+	 * If NOR is needed, enable NOR's code and disable all code for NOR.
+	 */
+	/* set nand device's plat data */
+	/* set nand device's plat data */
+	nand_mach_init(FSMC_NAND_BW8);
+	if (platform_device_add_data(&spear1340_nand_device, &nand_plat_data,
+				sizeof(nand_plat_data)))
+		printk(KERN_WARNING "%s: couldn't add plat_data",
+				spear1340_nand_device.name);
+
+#ifdef CONFIG_SPEAR_PCIE_REV370
+	spear_hurricane_pcie_board_init();
+#endif
+
+	/* call spear1340 machine init function */
+	spear1340_init(NULL, pmx_devs, ARRAY_SIZE(pmx_devs));
+
+	/* Register spear1340 evb board specific i2c slave devices */
+	for (i = 0; i < ARRAY_SIZE(i2c_board); i++)
+		i2c_register_board_info(0, i2c_board[i], 1);
+
+	/* Register SPI Board */
+	for (i = 0; i < ARRAY_SIZE(spi_board); i++)
+		spi_register_board_info(spi_board[i], 1);
+
+	/* Add Platform Devices */
+	platform_add_devices(plat_devs, ARRAY_SIZE(plat_devs));
+
+	/* Add Amba Devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++)
+		amba_device_register(amba_devs[i], &iomem_resource);
+}
+
+MACHINE_START(SPEAR_HURRICANE, "NCOMPUTING-SPEAR-HURRICANE-BOARD")
+	.atag_offset	=	0x100,
+	.fixup		=	spear_hurricane_fixup,
+	.map_io		=	spear13xx_map_io,
+	.init_irq	=	spear13xx_init_irq,
+	.handle_irq	=	gic_handle_irq,
+	.timer		=	&spear13xx_timer,
+	.init_machine	=	spear_hurricane_init,
+	.restart	=	spear_restart,
+MACHINE_END
diff --git a/arch/arm/mach-spear13xx/spear_pcie_rev_341.c b/arch/arm/mach-spear13xx/spear_pcie_rev_341.c
new file mode 100644
index 0000000..a380d33
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear_pcie_rev_341.c
@@ -0,0 +1,581 @@
+/*
+ * arch/arm/mach-spear13xx/spear_pcie_rev_341.c
+ *
+ * Supports SPEAr1300, SPEAr1310 RevA, SPEAr900
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/platform_device.h>
+#include <asm/mach/irq.h>
+#include <mach/misc_regs.h>
+#include <mach/spear_pcie_rev_341.h>
+
+static void enable_dbi_access(struct pcie_app_reg __iomem *app_reg)
+{
+	writel(readl(&app_reg->slv_armisc) | (1 << AXI_OP_DBI_ACCESS_ID),
+			&app_reg->slv_armisc);
+	writel(readl(&app_reg->slv_awmisc) | (1 << AXI_OP_DBI_ACCESS_ID),
+			&app_reg->slv_awmisc);
+}
+
+static void disable_dbi_access(struct pcie_app_reg __iomem *app_reg)
+{
+	writel(readl(&app_reg->slv_armisc) & ~(1 << AXI_OP_DBI_ACCESS_ID),
+			&app_reg->slv_armisc);
+	writel(readl(&app_reg->slv_awmisc) & ~(1 << AXI_OP_DBI_ACCESS_ID),
+			&app_reg->slv_awmisc);
+}
+
+static void pcie_rd_own_conf(struct pcie_port *pp, int where, int size,
+		u32 *val)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+	u32 va_address;
+
+	enable_dbi_access(app_reg);
+
+	va_address = (u32)pp->va_base + (where & ~0x3);
+
+	*val = readl(va_address);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	disable_dbi_access(app_reg);
+}
+
+static void pcie_wr_own_conf(struct pcie_port *pp, int where, int size, u32 val)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+	u32 va_address;
+
+	enable_dbi_access(app_reg);
+
+	va_address = (u32)pp->va_base + (where & ~0x3);
+
+	if (size == 4)
+		writel(val, va_address);
+	else if (size == 2)
+		writew(val, va_address + (where & 2));
+	else if (size == 1)
+		writeb(val, va_address + (where & 3));
+
+	disable_dbi_access(app_reg);
+}
+
+static int pcie_rd_other_conf(struct pcie_port *pp, struct pci_bus *bus,
+		u32 devfn, int where, int size, u32 *val)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+	u32 address;
+	u32 armisc;
+
+	armisc = readl(&app_reg->slv_armisc);
+	armisc &= ~(AXI_OP_TYPE_MASK);
+	if (bus->parent->number == pp->root_bus_nr) {
+		address = (u32)pp->va_cfg0_base | (PCI_FUNC(devfn) << 16)
+			| (where & 0xFFFC);
+		writel((bus->number << 24) | (PCI_SLOT(devfn) << 19),
+			&app_reg->pom_cfg0_addr_start);
+		armisc |= AXI_OP_TYPE_CONFIG_RDRW_TYPE0;
+	} else {
+		address = (u32)pp->va_cfg1_base | (PCI_FUNC(devfn) << 16)
+			| (where & 0xFFFC);
+		writel((bus->number << 24) | (PCI_SLOT(devfn) << 19),
+			&app_reg->pom_cfg1_addr_start);
+		armisc |= AXI_OP_TYPE_CONFIG_RDRW_TYPE1;
+	}
+
+	writel(armisc, &app_reg->slv_armisc);
+	while (armisc != readl(&app_reg->slv_armisc))
+		;
+
+	*val = readl(address);
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+
+	armisc &= ~(AXI_OP_TYPE_MASK);
+	writel(armisc, &app_reg->slv_armisc);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_wr_other_conf(struct pcie_port *pp, struct pci_bus *bus,
+		u32 devfn, int where, int size, u32 val)
+{
+	int ret = PCIBIOS_SUCCESSFUL;
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+	u32 address;
+	u32 awmisc;
+
+	awmisc = readl(&app_reg->slv_awmisc);
+	awmisc &= ~(AXI_OP_TYPE_MASK);
+
+	if (bus->parent->number == pp->root_bus_nr) {
+		address = (u32)pp->va_cfg0_base | (PCI_FUNC(devfn) << 16)
+			| (where & 0xFFFC);
+		writel((bus->number << 24) | (PCI_SLOT(devfn) << 19),
+			&app_reg->pom_cfg0_addr_start);
+		awmisc |= AXI_OP_TYPE_CONFIG_RDRW_TYPE0;
+	} else {
+		address = (u32)pp->va_cfg1_base | (PCI_FUNC(devfn) << 16)
+			| (where & 0xFFFC);
+		writel((bus->number << 24) | (PCI_SLOT(devfn) << 19),
+			&app_reg->pom_cfg1_addr_start);
+		awmisc |= AXI_OP_TYPE_CONFIG_RDRW_TYPE1;
+	}
+
+	writel(awmisc, &app_reg->slv_awmisc);
+	while (awmisc != readl(&app_reg->slv_awmisc))
+		;
+
+	if (size == 4)
+		writel(val, address);
+	else if (size == 2)
+		writew(val, address + (where & 2));
+	else if (size == 1)
+		writeb(val, address + (where & 3));
+	else
+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
+
+	awmisc &= ~(AXI_OP_TYPE_MASK);
+	writel(awmisc, &app_reg->slv_awmisc);
+	return ret;
+}
+
+#ifdef CONFIG_PCI_MSI
+extern unsigned int msi_data[];
+
+static void msi_init(struct pcie_port *pp)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+
+	pp->ops.wr_own(pp, PCIE_MSI_ADDR_LO, 4,
+			__virt_to_phys((u32)(&msi_data[pp->port])));
+	pp->ops.wr_own(pp, PCIE_MSI_ADDR_HI, 4, 0);
+	/* Enbale MSI interrupt*/
+	writel(readl(&app_reg->int_mask) | MSI_CTRL_INT,
+			&app_reg->int_mask);
+}
+#endif
+
+static void mask_intx_irq(struct irq_data *data)
+{
+	u32 irq = data->irq;
+	int irq_offset = (irq - INTX0_BASE) % NUM_INTX_IRQS;
+	int port = (irq - INTX0_BASE) / NUM_INTX_IRQS;
+	struct pcie_port *pp = portno_to_port(port);
+	struct pcie_app_reg __iomem *app_reg;
+	u32 mask;
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	app_reg = pp->va_app_base;
+
+	switch (irq_offset) {
+	case 0:
+		mask = ~INTA_CTRL_INT;
+		break;
+	case 1:
+		mask = ~INTB_CTRL_INT;
+		break;
+	case 2:
+		mask = ~INTC_CTRL_INT;
+		break;
+	case 3:
+		mask = ~INTD_CTRL_INT;
+		break;
+	}
+	writel(readl(&app_reg->int_mask) & mask, &app_reg->int_mask);
+}
+
+static void unmask_intx_irq(struct irq_data *data)
+{
+	u32 irq = data->irq;
+	int irq_offset = (irq - INTX0_BASE) % NUM_INTX_IRQS;
+	int port = (irq - INTX0_BASE) / NUM_INTX_IRQS;
+	struct pcie_port *pp = portno_to_port(port);
+	struct pcie_app_reg __iomem *app_reg;
+	u32 mask;
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	app_reg = pp->va_app_base;
+
+	switch (irq_offset) {
+	case 0:
+		mask = INTA_CTRL_INT;
+		break;
+	case 1:
+		mask = INTB_CTRL_INT;
+		break;
+	case 2:
+		mask = INTC_CTRL_INT;
+		break;
+	case 3:
+		mask = INTD_CTRL_INT;
+		break;
+	}
+	writel(readl(&app_reg->int_mask) | mask, &app_reg->int_mask);
+}
+
+static struct irq_chip intx_chip = {
+	.name = "PCI-INTX",
+	.irq_mask = mask_intx_irq,
+	.irq_unmask = unmask_intx_irq,
+};
+
+static void pcie_int_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct pcie_port *pp  = portno_to_port(irq - IRQ_PCIE0);
+	struct pcie_app_reg __iomem *app_reg;
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+	unsigned int status;
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	app_reg = pp->va_app_base;
+	status = readl(&app_reg->int_sts);
+
+	chained_irq_enter(irqchip, desc);
+
+	if (status & MSI_CTRL_INT) {
+#ifdef CONFIG_PCI_MSI
+		handle_msi(pp);
+#endif
+		writel(MSI_CTRL_INT, &app_reg->int_clr);
+	} else if (status & INTA_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS);
+	else if (status & INTB_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 1);
+	else if (status & INTC_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 2);
+	else if (status & INTD_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 3);
+	else
+		writel(status, &app_reg->int_clr);
+
+	chained_irq_exit(irqchip, desc);
+}
+
+static void pcie_int_init(struct pcie_port *pp)
+{
+	int i, irq;
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+
+	irq_set_chained_handler(IRQ_PCIE0 + pp->port,
+			pcie_int_handler);
+
+#ifdef CONFIG_PCI_MSI
+	msi_init(pp);
+#endif
+	/*
+	 * initilize INTX chip here only. MSI chip will be
+	 * initilized dynamically.
+	 */
+	irq = (INTX0_BASE + pp->port * NUM_INTX_IRQS);
+	for (i = 0; i < NUM_INTX_IRQS; i++) {
+		irq_set_chip_and_handler(irq + i, &intx_chip,
+				handle_simple_irq);
+		set_irq_flags(irq + i, IRQF_VALID);
+	}
+
+	/* Enbale INTX interrupt*/
+	writel(readl(&app_reg->int_mask) | INTA_CTRL_INT
+			| INTB_CTRL_INT	| INTC_CTRL_INT
+			| INTD_CTRL_INT, &app_reg->int_mask);
+}
+
+static void pcie_host_init(struct pcie_port *pp)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+	struct pcie_port_info *config = &pp->config;
+	u32 cap, val;
+
+	/*setup registers for outbound translation */
+
+	writel(pp->base, &app_reg->in_io_addr_start);
+	pp->io_base = pp->base;
+	writel(readl(&app_reg->in_io_addr_start) + (config->io_size - 1),
+			&app_reg->in_io_addr_limit);
+	writel(readl(&app_reg->in_io_addr_limit) + 1,
+			&app_reg->in0_mem_addr_start);
+	pp->mem_base = pp->io_base + config->io_size;
+	writel(readl(&app_reg->in0_mem_addr_start) + (config->mem_size - 1),
+			&app_reg->in0_mem_addr_limit);
+	writel(readl(&app_reg->in0_mem_addr_limit) + 1,
+			&app_reg->in_cfg0_addr_start);
+	pp->cfg0_base = pp->mem_base + config->mem_size;
+	writel(readl(&app_reg->in_cfg0_addr_start) + (config->cfg0_size - 1),
+			&app_reg->in_cfg0_addr_limit);
+	writel(readl(&app_reg->in_cfg0_addr_limit) + 1,
+			&app_reg->in_cfg1_addr_start);
+	pp->cfg1_base = pp->cfg0_base + config->cfg0_size;
+	writel(readl(&app_reg->in_cfg1_addr_start) + (config->cfg1_size - 1),
+			&app_reg->in_cfg1_addr_limit);
+	writel(readl(&app_reg->in_cfg1_addr_limit) + 1,
+			&app_reg->in_msg_addr_start);
+	writel(readl(&app_reg->in_msg_addr_start) + (config->msg_size - 1),
+			&app_reg->in_msg_addr_limit);
+
+	writel(readl(&app_reg->in0_mem_addr_start),
+			&app_reg->pom0_mem_addr_start);
+	writel(readl(&app_reg->in1_mem_addr_start),
+			&app_reg->pom1_mem_addr_start);
+	writel(readl(&app_reg->in_io_addr_start),
+			&app_reg->pom_io_addr_start);
+
+	/*setup registers for inbound translation */
+
+	writel((u32)config->in_mem_size, &app_reg->mem0_addr_offset_limit);
+	writel(0, &app_reg->pim0_mem_addr_start);
+	writel(0, &app_reg->pim1_mem_addr_start);
+	pcie_wr_own_conf(pp, PCIE_BAR0_MASK_REG, 4,
+			(config->in_mem_size - 1));
+	pcie_wr_own_conf(pp, PCI_BASE_ADDRESS_0, 4, 0);
+
+	writel(0x0, &app_reg->pim_io_addr_start);
+	writel(0x0, &app_reg->pim_io_addr_start);
+	writel(0x0, &app_reg->pim_rom_addr_start);
+
+	cap = pci_find_own_capability(pp, PCI_CAP_ID_EXP);
+
+	/*
+	 * this controller support only 128 bytes read size, however its
+	 * default value in capability register is 512 bytes. So force
+	 * it to 128 here.
+	 */
+
+	pcie_rd_own_conf(pp, cap + PCI_EXP_DEVCTL, 4, &val);
+	val &= ~PCI_EXP_DEVCTL_READRQ;
+	pcie_wr_own_conf(pp, cap + PCI_EXP_DEVCTL, 4, val);
+
+	/*program correct class for RC*/
+	pcie_rd_own_conf(pp, PCI_CLASS_REVISION, 4, &val);
+	val &= 0xFFFF;
+	val |= (PCI_CLASS_BRIDGE_PCI << 16);
+	pcie_wr_own_conf(pp, PCI_CLASS_REVISION, 4, val);
+	/*program vid and did for RC*/
+	pcie_wr_own_conf(pp, PCI_VENDOR_ID, 2, 0x104A);
+	pcie_wr_own_conf(pp, PCI_DEVICE_ID, 2, 0xCD80);
+	/*if is_gen1 is set then handle it*/
+	if (pp->config.is_gen1) {
+		cap = pci_find_own_capability(pp, PCI_CAP_ID_EXP);
+		pcie_rd_own_conf(pp, cap + PCI_EXP_LNKCAP, 4, &val);
+		if ((val & 0xF) != 1) {
+			val &= ~((u32)0xF);
+			val |= 1;
+			pcie_wr_own_conf(pp, cap + PCI_EXP_LNKCAP, 4,
+					val);
+		}
+		pcie_rd_own_conf(pp, cap + PCI_EXP_LNKCTL2, 4, &val);
+		if ((val & 0xF) != 1) {
+			val &= ~((u32)0xF);
+			val |= 1;
+			pcie_wr_own_conf(pp, cap + PCI_EXP_LNKCTL2, 4,
+					val);
+		}
+	} else {
+		pcie_rd_own_conf(pp, PCIE_PORT_LOGIC, 4, &val);
+		val |= (1 << PORT_LOGIC_SPD_CHANGE_ID);
+		pcie_wr_own_conf(pp, PCIE_PORT_LOGIC, 4, val);
+	}
+
+	writel(DEVICE_TYPE_RC | (1 << MISCTRL_EN_ID)
+			| (1 << APP_LTSSM_ENABLE_ID)
+			| ((u32)1 << REG_TRANSLATION_ENABLE),
+			&app_reg->app_ctrl_0);
+
+	pcie_int_init(pp);
+}
+
+static void pcie_host_exit(struct pcie_port *pp)
+{
+	struct pcie_app_reg __iomem *app_reg = pp->va_app_base;
+
+	/* Remove link up */
+	writel(0, &app_reg->app_ctrl_0);
+}
+
+static int pcie_link_up(void __iomem *va_app_base)
+{
+	struct pcie_app_reg __iomem *app_reg = va_app_base;
+	int ucount = 0;
+
+	do {
+		if (readl(&app_reg->app_status_1) &
+				((u32)1 << XMLH_LINK_UP_ID))
+			return 1;
+		ucount++;
+		udelay(1);
+	} while (ucount <= MAX_LINK_UP_WAIT_MS * 1000);
+
+	return 0;
+}
+
+static int add_pcie_port(struct pcie_port *pp, struct platform_device *pdev)
+{
+	struct pcie_app_reg __iomem *app_reg;
+	struct resource *base;
+	struct resource *app_base;
+	int err;
+
+	app_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!app_base) {
+		dev_err(&pdev->dev, "couldn't get app base resource\n");
+		return -EINVAL;
+	}
+	if (!request_mem_region(app_base->start, resource_size(app_base),
+				pdev->name)) {
+		dev_err(&pdev->dev, "app base resource is busy\n");
+		return -EBUSY;
+	}
+	pp->app_base = (void __iomem *)app_base->start;
+
+	base = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!base) {
+		dev_err(&pdev->dev, "couldn't get base resource\n");
+		err = -EINVAL;
+		goto free_app_res;
+	}
+	if (!request_mem_region(base->start, resource_size(base),
+				pdev->name)) {
+		dev_err(&pdev->dev, "app base resource is busy\n");
+		err = -EBUSY;
+		goto free_app_res;
+	}
+	pp->base = (void __iomem *)base->start;
+
+	pp->va_app_base = ioremap(app_base->start, resource_size(app_base));
+	if (!pp->va_app_base) {
+		dev_err(&pdev->dev, "error with ioremap\n");
+		err = -ENOMEM;
+		goto free_base_res;
+	}
+
+	pp->va_base = ioremap(base->start, resource_size(base));
+	if (!pp->va_base) {
+		dev_err(&pdev->dev, "error with ioremap\n");
+		err = -ENOMEM;
+		goto unmap_app_res;
+	}
+
+	pp->port = pdev->id;
+	pp->root_bus_nr = -1;
+	spin_lock_init(&pp->conf_lock);
+	if (pcie_link_up(pp->va_app_base)) {
+		dev_info(&pdev->dev, "link up\n");
+	} else {
+		dev_info(&pdev->dev, "link down\n");
+		pcie_host_init(pp);
+		app_reg = pp->va_app_base;
+		pp->va_cfg0_base =
+			ioremap(readl(&app_reg->in_cfg0_addr_start),
+					pp->config.cfg0_size);
+		if (!pp->va_cfg0_base) {
+			dev_err(&pdev->dev, "error with ioremap\n");
+			err = -ENOMEM;
+			goto unmap_base_res;
+		}
+		pp->va_cfg1_base =
+			ioremap(readl(&app_reg->in_cfg1_addr_start),
+					pp->config.cfg1_size);
+		if (!pp->va_cfg1_base) {
+			dev_err(&pdev->dev, "error with ioremap\n");
+			err = -ENOMEM;
+			goto unmap_cfg0;
+		}
+		return 0;
+	}
+unmap_cfg0:
+	iounmap(pp->va_cfg0_base);
+unmap_base_res:
+	iounmap(pp->va_base);
+unmap_app_res:
+	iounmap(pp->va_app_base);
+free_base_res:
+	release_mem_region(base->start, resource_size(base));
+free_app_res:
+	release_mem_region(app_base->start, resource_size(app_base));
+	return err;
+}
+
+static int pcie_clk_init(struct pcie_port *pp)
+{
+	/*
+	 * Enable all CLK in CFG registers here only. Idealy only PCIE0
+	 * should have been enabled. But Controler does not work
+	 * properly if PCIE1 and PCIE2's CFG CLK is enabled in stages.
+	 */
+	writel(PCIE0_CFG_VAL | PCIE1_CFG_VAL | PCIE2_CFG_VAL, VA_PCIE_CFG);
+
+	if (pp->clk == NULL) {
+		pp->clk = clk_get_sys("dw_pcie.0", NULL);
+
+		if (IS_ERR(pp->clk)) {
+			pr_err("%s:couldn't get clk for pcie0\n", __func__);
+			return -ENODEV;
+		}
+	}
+
+	if (clk_enable(pp->clk)) {
+		pr_err("%s:couldn't enable clk for pcie0\n", __func__);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int pcie_clk_exit(struct pcie_port *pp)
+{
+	writel(0, VA_PCIE_CFG);
+	if (pp->clk)
+		clk_disable(pp->clk);
+
+	return 0;
+}
+
+void spear_pcie_341_add_ops(struct pcie_port *pp)
+{
+	struct pcie_private_ops	*ops = &pp->ops;
+
+	ops->rd_own = pcie_rd_own_conf;
+	ops->wr_own = pcie_wr_own_conf;
+	ops->rd_other = pcie_rd_other_conf;
+	ops->wr_other = pcie_wr_other_conf;
+	ops->add_port = add_pcie_port;
+	ops->link_up = pcie_link_up;
+	ops->host_init = pcie_host_init;
+	ops->host_exit = pcie_host_exit;
+	ops->clk_init = pcie_clk_init;
+	ops->clk_exit = pcie_clk_exit;
+}
diff --git a/arch/arm/mach-spear13xx/spear_pcie_rev_370.c b/arch/arm/mach-spear13xx/spear_pcie_rev_370.c
new file mode 100644
index 0000000..92e935c
--- /dev/null
+++ b/arch/arm/mach-spear13xx/spear_pcie_rev_370.c
@@ -0,0 +1,588 @@
+/*
+ * arch/arm/mach-spear13xx/spear_pcie_rev_370.c
+ *
+ * Supports, SPEAr1310 and SPEAr1340
+ *
+ * Copyright (C) 2010-2011 ST Microelectronics
+ * Pratyush Anand <pratyush.anand@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/platform_device.h>
+#include <asm/mach/irq.h>
+#include <mach/spear1340_misc_regs.h>
+#include <mach/spear_pcie_rev_370.h>
+
+#define PCIE_APP_SPECIFIC_OFFSET	0x2000
+
+static void pcie_rd_own_conf(struct pcie_port *pp, int where, int size,
+		u32 *val)
+{
+	u32 va_address;
+
+	va_address = (u32)pp->va_app_base + (where & ~0x3);
+
+	*val = readl(va_address);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+}
+
+static void pcie_wr_own_conf(struct pcie_port *pp, int where, int size,
+		u32 val)
+{
+	u32 va_address;
+
+	va_address = (u32)pp->va_app_base + (where & ~0x3);
+
+	if (size == 4)
+		writel(val, va_address);
+	else if (size == 2)
+		writew(val, va_address + (where & 2));
+	else if (size == 1)
+		writeb(val, va_address + (where & 3));
+}
+
+static void spear_pcie_prog_viewport_cfg0(struct pcie_port *pp, u32 busdev)
+{
+	u32 val;
+	void __iomem *dbi_base = pp->va_app_base;
+	/* Program viewport 0 : OUTBOUND : CFG0*/
+	val = PCIE_ATU_REGION_OUTBOUND | (0 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_CFG0, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	writel((u32)pp->cfg0_base,
+			((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((u32)pp->cfg0_base + (pp->config.cfg0_size - 1),
+			((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel(busdev, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+}
+
+static void spear_pcie_prog_viewport_cfg1(struct pcie_port *pp, u32 busdev)
+{
+	u32 val;
+	void __iomem *dbi_base = pp->va_app_base;
+	/* Program viewport 1 : OUTBOUND : CFG1*/
+	val = PCIE_ATU_REGION_OUTBOUND | (1 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_CFG1, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	writel((u32)pp->cfg1_base,
+			((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((u32)pp->cfg1_base + (pp->config.cfg1_size - 1),
+			((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel(busdev, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+}
+
+static void spear_pcie_prog_viewport_mem(struct pcie_port *pp)
+{
+	u32 val;
+	void __iomem *dbi_base = pp->va_app_base;
+	/* Program viewport 0 : OUTBOUND : MEM*/
+	val = PCIE_ATU_REGION_OUTBOUND | (0 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_MEM, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	writel((u32)pp->mem_base, ((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((u32)pp->mem_base + (pp->config.mem_size - 1),
+			((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel((u32)pp->mem_base, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+}
+
+static void spear_pcie_prog_viewport_io(struct pcie_port *pp)
+{
+	u32 val;
+	void __iomem *dbi_base = pp->va_app_base;
+	/* Program viewport 1 : OUTBOUND : IO*/
+	val = PCIE_ATU_REGION_OUTBOUND | (1 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_IO, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	writel((u32)pp->io_base, ((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((u32)pp->io_base + (pp->config.io_size - 1),
+			((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel((u32)pp->io_base, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+}
+
+static int pcie_rd_other_conf(struct pcie_port *pp, struct pci_bus *bus,
+		u32 devfn, int where, int size, u32 *val)
+{
+	u32 address, busdev;
+
+	busdev = (bus->number << 24) | (PCI_SLOT(devfn) << 19);
+	address = (PCI_FUNC(devfn) << 16) | (where & 0xFFFC);
+
+	if (bus->parent->number == pp->root_bus_nr) {
+		spear_pcie_prog_viewport_cfg0(pp, busdev);
+		*val = readl((u32)pp->va_cfg0_base + address);
+		if (size == 1)
+			*val = (*val >> (8 * (where & 3))) & 0xff;
+		else if (size == 2)
+			*val = (*val >> (8 * (where & 3))) & 0xffff;
+		spear_pcie_prog_viewport_mem(pp);
+	} else {
+		spear_pcie_prog_viewport_cfg1(pp, busdev);
+		*val = readl((u32)pp->va_cfg1_base + address);
+		if (size == 1)
+			*val = (*val >> (8 * (where & 3))) & 0xff;
+		else if (size == 2)
+			*val = (*val >> (8 * (where & 3))) & 0xffff;
+		spear_pcie_prog_viewport_io(pp);
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcie_wr_other_conf(struct pcie_port *pp, struct pci_bus *bus,
+		u32 devfn, int where, int size, u32 val)
+{
+	int ret = PCIBIOS_SUCCESSFUL;
+	u32 address, busdev;
+
+	busdev = (bus->number << 24) | (PCI_SLOT(devfn) << 19);
+	address = (PCI_FUNC(devfn) << 16) | (where & 0xFFFC);
+
+	if (bus->parent->number == pp->root_bus_nr) {
+		spear_pcie_prog_viewport_cfg0(pp, busdev);
+		address = (u32)pp->va_cfg0_base + address;
+		if (size == 4)
+			writel(val, address);
+		else if (size == 2)
+			writew(val, address + (where & 2));
+		else if (size == 1)
+			writeb(val, address + (where & 3));
+		else
+			ret = PCIBIOS_BAD_REGISTER_NUMBER;
+		spear_pcie_prog_viewport_mem(pp);
+	} else {
+		spear_pcie_prog_viewport_cfg1(pp, busdev);
+		address = (u32)pp->va_cfg1_base + address;
+		if (size == 4)
+			writel(val, address);
+		else if (size == 2)
+			writew(val, address + (where & 2));
+		else if (size == 1)
+			writeb(val, address + (where & 3));
+		else
+			ret = PCIBIOS_BAD_REGISTER_NUMBER;
+		spear_pcie_prog_viewport_io(pp);
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PCI_MSI
+extern unsigned int msi_data[];
+
+static void msi_init(struct pcie_port *pp)
+{
+	struct pcie_app_reg *app_reg =
+		(struct pcie_app_reg *)((u32)pp->va_app_base
+		+ PCIE_APP_SPECIFIC_OFFSET);
+
+	pp->ops.wr_own(pp, PCIE_MSI_ADDR_LO, 4,
+			__virt_to_phys((u32)(&msi_data[pp->port])));
+	pp->ops.wr_own(pp, PCIE_MSI_ADDR_HI, 4, 0);
+	/* Enbale MSI interrupt*/
+	writel(readl(&app_reg->int_mask) | MSI_CTRL_INT,
+			&app_reg->int_mask);
+}
+#endif
+
+static void mask_intx_irq(struct irq_data *data)
+{
+	u32 irq = data->irq;
+	int irq_offset = (irq - INTX0_BASE) % NUM_INTX_IRQS;
+	int port = (irq - INTX0_BASE) / NUM_INTX_IRQS;
+	struct pcie_port *pp = portno_to_port(port);
+	struct pcie_app_reg *app_reg;
+	u32 mask;
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	app_reg = (struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	switch (irq_offset) {
+	case 0:
+		mask = ~INTA_CTRL_INT;
+		break;
+	case 1:
+		mask = ~INTB_CTRL_INT;
+		break;
+	case 2:
+		mask = ~INTC_CTRL_INT;
+		break;
+	case 3:
+		mask = ~INTD_CTRL_INT;
+		break;
+	}
+	writel(readl(&app_reg->int_mask) & mask, &app_reg->int_mask);
+}
+
+static void unmask_intx_irq(struct irq_data *data)
+{
+	u32 irq = data->irq;
+	int irq_offset = (irq - INTX0_BASE) % NUM_INTX_IRQS;
+	int port = (irq - INTX0_BASE) / NUM_INTX_IRQS;
+	struct pcie_port *pp = portno_to_port(port);
+	struct pcie_app_reg *app_reg;
+	u32 mask;
+
+	app_reg = (struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+
+	switch (irq_offset) {
+	case 0:
+		mask = INTA_CTRL_INT;
+		break;
+	case 1:
+		mask = INTB_CTRL_INT;
+		break;
+	case 2:
+		mask = INTC_CTRL_INT;
+		break;
+	case 3:
+		mask = INTD_CTRL_INT;
+		break;
+	}
+	writel(readl(&app_reg->int_mask) | mask, &app_reg->int_mask);
+}
+
+static struct irq_chip intx_chip = {
+	.name = "PCI-INTX",
+	.irq_mask = mask_intx_irq,
+	.irq_unmask = unmask_intx_irq,
+};
+
+static void pcie_int_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct pcie_port *pp
+		= portno_to_port(irq - IRQ_PCIE0);
+	struct pcie_app_reg *app_reg;
+	struct irq_chip *irqchip = irq_desc_get_chip(desc);
+	unsigned int status;
+
+	if (!pp) {
+		BUG();
+		return;
+	}
+
+	app_reg = (struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	status = readl(&app_reg->int_sts);
+
+	chained_irq_enter(irqchip, desc);
+
+	if (status & MSI_CTRL_INT) {
+#ifdef CONFIG_PCI_MSI
+		handle_msi(pp);
+#endif
+		writel(MSI_CTRL_INT, &app_reg->int_clr);
+	} else if (status & INTA_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS);
+	else if (status & INTB_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 1);
+	else if (status & INTC_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 2);
+	else if (status & INTD_CTRL_INT)
+		generic_handle_irq(INTX0_BASE
+				+ pp->port * NUM_INTX_IRQS + 3);
+	else
+		writel(status, &app_reg->int_clr);
+
+	chained_irq_exit(irqchip, desc);
+}
+
+static void pcie_int_init(struct pcie_port *pp)
+{
+	int i, irq;
+	struct pcie_app_reg *app_reg =
+		(struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	irq_set_chained_handler(IRQ_PCIE0 + pp->port,
+			pcie_int_handler);
+
+#ifdef CONFIG_PCI_MSI
+	msi_init(pp);
+#endif
+	/*
+	 * initilize INTX chip here only. MSI chip will be
+	 * initilized dynamically.
+	 */
+	irq = (INTX0_BASE + pp->port * NUM_INTX_IRQS);
+	for (i = 0; i < NUM_INTX_IRQS; i++) {
+		irq_set_chip_and_handler(irq + i, &intx_chip,
+				handle_simple_irq);
+		set_irq_flags(irq + i, IRQF_VALID);
+	}
+
+	/* Enbale INTX interrupt*/
+	writel(readl(&app_reg->int_mask) | INTA_CTRL_INT
+			| INTB_CTRL_INT	| INTC_CTRL_INT
+			| INTD_CTRL_INT, &app_reg->int_mask);
+}
+
+static void pcie_host_exit(struct pcie_port *pp)
+{
+	struct pcie_app_reg *app_reg =
+		(struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	writel(0, &app_reg->app_ctrl_0);
+
+}
+
+static void pcie_host_init(struct pcie_port *pp)
+{
+	struct pcie_port_info *config = &pp->config;
+	u32 cap, val;
+	void __iomem *dbi_base = pp->va_app_base;
+	struct pcie_app_reg *app_reg =
+		(struct pcie_app_reg *)((u32)pp->va_app_base
+			+ PCIE_APP_SPECIFIC_OFFSET);
+
+	/* Keep first 64K for IO */
+	pp->io_base = pp->base;
+	pp->mem_base = pp->io_base + config->io_size;
+	pp->cfg0_base = pp->mem_base + config->mem_size;
+	pp->cfg1_base = pp->cfg0_base + config->cfg0_size;
+
+	/*
+	 * setup registers for inbound translation. Fix viewport 0 for
+	 * Memory and viewport 1 for IO transaction
+	 */
+
+	/* Program viewport 0 : INBOUND : MEMORY*/
+	val = PCIE_ATU_REGION_INBOUND | (0 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_MEM, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE | PCIE_ATU_BAR_MODE_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	/* program first 256 MB as inbound address*/
+	writel(0, ((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((config->in_mem_size - 1), ((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel(0, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+
+	/* Program viewport 1 : INBOUND : IO*/
+	val = PCIE_ATU_REGION_INBOUND | (1 & 0xF);
+	writel(val, ((u32)dbi_base + PCIE_ATU_VIEWPORT));
+	writel(PCIE_ATU_TYPE_IO, ((u32)dbi_base + PCIE_ATU_CR1));
+	val = PCIE_ATU_ENABLE | PCIE_ATU_BAR_MODE_ENABLE;
+	writel(val, ((u32)dbi_base + PCIE_ATU_CR2));
+	/* program first 256 MB as inbound address*/
+	writel(0, ((u32)dbi_base + PCIE_ATU_LOWER_BASE));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_BASE));
+	writel((config->in_mem_size - 1), ((u32)dbi_base + PCIE_ATU_LIMIT));
+	writel(0, ((u32)dbi_base + PCIE_ATU_LOWER_TARGET));
+	writel(0, ((u32)dbi_base + PCIE_ATU_UPPER_TARGET));
+
+	pcie_wr_own_conf(pp, PCIE_BAR0_MASK_REG, 4,
+			(config->in_mem_size - 1));
+	pcie_wr_own_conf(pp, PCI_BASE_ADDRESS_0, 4, 0);
+
+	cap = pci_find_own_capability(pp, PCI_CAP_ID_EXP);
+
+	/*
+	 * this controller support only 128 bytes read size, however its
+	 * default value in capability register is 512 bytes. So force
+	 * it to 128 here.
+	 */
+
+	pcie_rd_own_conf(pp, cap + PCI_EXP_DEVCTL, 4, &val);
+	val &= ~PCI_EXP_DEVCTL_READRQ;
+	pcie_wr_own_conf(pp, cap + PCI_EXP_DEVCTL, 4, val);
+
+	/*program correct class for RC*/
+	pcie_rd_own_conf(pp, PCI_CLASS_REVISION, 4, &val);
+	val &= 0xFFFF;
+	val |= (PCI_CLASS_BRIDGE_PCI << 16);
+	pcie_wr_own_conf(pp, PCI_CLASS_REVISION, 4, val);
+	/*program vid and did for RC*/
+	pcie_wr_own_conf(pp, PCI_VENDOR_ID, 2, 0x104A);
+	pcie_wr_own_conf(pp, PCI_DEVICE_ID, 2, 0xCD80);
+	/*if is_gen1 is set then handle it*/
+	if (pp->config.is_gen1) {
+		cap = pci_find_own_capability(pp, PCI_CAP_ID_EXP);
+		pcie_rd_own_conf(pp, cap + PCI_EXP_LNKCAP, 4, &val);
+		if ((val & 0xF) != 1) {
+			val &= ~((u32)0xF);
+			val |= 1;
+			pcie_wr_own_conf(pp, cap + PCI_EXP_LNKCAP, 4,
+					val);
+		}
+		pcie_rd_own_conf(pp, cap + PCI_EXP_LNKCTL2, 4, &val);
+		if ((val & 0xF) != 1) {
+			val &= ~((u32)0xF);
+			val |= 1;
+			pcie_wr_own_conf(pp, cap + PCI_EXP_LNKCTL2, 4,
+					val);
+		}
+	} else {
+		pcie_rd_own_conf(pp, PCIE_PORT_LOGIC, 4, &val);
+		val |= (1 << PORT_LOGIC_SPD_CHANGE_ID);
+		pcie_wr_own_conf(pp, PCIE_PORT_LOGIC, 4, val);
+	}
+
+	writel(DEVICE_TYPE_RC | (1 << MISCTRL_EN_ID)
+			| (1 << APP_LTSSM_ENABLE_ID)
+			| ((u32)1 << REG_TRANSLATION_ENABLE),
+			&app_reg->app_ctrl_0);
+
+	pcie_int_init(pp);
+}
+
+static int pcie_link_up(void __iomem *va_app_base)
+{
+	struct pcie_app_reg *app_reg =
+		(struct pcie_app_reg *)((u32)va_app_base
+		+ PCIE_APP_SPECIFIC_OFFSET);
+	int ucount = 0;
+
+	do {
+		if (readl(&app_reg->app_status_1) &
+			((u32)1 << XMLH_LINK_UP_ID))
+			return 1;
+		ucount++;
+		udelay(1);
+	} while (ucount <= MAX_LINK_UP_WAIT_MS * 1000);
+
+	return 0;
+}
+
+static int add_pcie_port(struct pcie_port *pp, struct platform_device *pdev)
+{
+	struct resource *base;
+	struct resource *app_base;
+	int err;
+
+	app_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!app_base) {
+		dev_err(&pdev->dev, "couldn't get app base resource\n");
+		return -EINVAL;
+	}
+	if (!request_mem_region(app_base->start, resource_size(app_base),
+				pdev->name)) {
+		dev_err(&pdev->dev, "app base resource is busy\n");
+		return -EBUSY;
+	}
+
+	pp->app_base = (void __iomem *)app_base->start;
+	pp->va_app_base = ioremap(app_base->start, resource_size(app_base));
+	if (!pp->va_app_base) {
+		dev_err(&pdev->dev, "error with ioremap\n");
+		err = -ENOMEM;
+		goto free_app_res;
+	}
+
+	base = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!base) {
+		dev_err(&pdev->dev, "couldn't get base resource\n");
+		err = -EINVAL;
+		goto unmap_app_res;
+	}
+
+	pp->base = (void __iomem *)base->start;
+
+	pp->port = pdev->id;
+	pp->root_bus_nr = -1;
+	spin_lock_init(&pp->conf_lock);
+	if (pcie_link_up(pp->va_app_base)) {
+		dev_err(&pdev->dev, "link up\n");
+	} else {
+		dev_err(&pdev->dev, "link down\n");
+		pcie_host_init(pp);
+		pp->va_cfg0_base =
+			ioremap((u32)pp->cfg0_base, pp->config.cfg0_size);
+		if (!pp->va_cfg0_base) {
+			dev_err(&pdev->dev, "error with ioremap in function\n");
+			err = -ENOMEM;
+			goto unmap_app_res;
+		}
+		pp->va_cfg1_base =
+			ioremap((u32)pp->cfg1_base, pp->config.cfg1_size);
+		if (!pp->va_cfg1_base) {
+			dev_err(&pdev->dev, "error with ioremap\n");
+			err = -ENOMEM;
+			goto unmap_cfg0;
+		}
+		return 0;
+	}
+unmap_cfg0:
+	iounmap(pp->va_cfg0_base);
+unmap_app_res:
+	iounmap(pp->va_app_base);
+free_app_res:
+	release_mem_region(app_base->start, resource_size(app_base));
+	return err;
+}
+
+static int pcie_clk_init(struct pcie_port *pp)
+{
+	writel(SPEAR1340_PCIE_SATA_MIPHY_CFG_PCIE,
+			VA_SPEAR1340_PCIE_MIPHY_CFG);
+	writel(SPEAR1340_PCIE_CFG_VAL, VA_SPEAR1340_PCIE_SATA_CFG);
+	return 0;
+}
+
+static int pcie_clk_exit(struct pcie_port *pp)
+{
+	writel(0, VA_SPEAR1340_PCIE_SATA_CFG);
+	writel(0, VA_SPEAR1340_PCIE_MIPHY_CFG);
+	return 0;
+}
+
+void spear_pcie_370_add_ops(struct pcie_port *pp)
+{
+	struct pcie_private_ops	*ops = &pp->ops;
+
+	ops->rd_own = pcie_rd_own_conf;
+	ops->wr_own = pcie_wr_own_conf;
+	ops->rd_other = pcie_rd_other_conf;
+	ops->wr_other = pcie_wr_other_conf;
+	ops->add_port = add_pcie_port;
+	ops->link_up = pcie_link_up;
+	ops->host_init = pcie_host_init;
+	ops->host_exit = pcie_host_exit;
+	ops->clk_init = pcie_clk_init;
+	ops->clk_exit = pcie_clk_exit;
+}
diff --git a/arch/arm/mach-spear13xx/wakeup.S b/arch/arm/mach-spear13xx/wakeup.S
new file mode 100644
index 0000000..988733e
--- /dev/null
+++ b/arch/arm/mach-spear13xx/wakeup.S
@@ -0,0 +1,152 @@
+/*
+ * linux/arch/arm/mach-spear13xx/wakeup.S
+ *
+ * SPEAR13xx specific functions that will run in internal SRAM.
+ * The functions are used in power management for resume.
+ *
+ * Copyright (C) 2010 ST MicroElectronics
+ * Deepak Sikri <deepak.sikri@st.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/suspend.h>
+
+#define	SRAM_SCR_REG	0xffc
+#define ASSOC_MASK	0x3ff
+#define NUMSET_MASK	0x7fff
+
+.text
+ENTRY(spear_wakeup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #0xf
+	cmp	r0, #0x0
+	bne	cpux_sleep
+back:
+	bl	cache_invalidate
+	nop
+	ldr	r3, =SRAM_SCR_REG
+	ldr	r6, =SPEAR_SRAM_START_PA
+	ldr	r0, [r6, r3]
+	bx	r0
+cpux_sleep:
+	/* Core-2 executed this code */
+	ldr	r7, =SRAM_SCRATCH_PA
+	ldr	r1, =0xFFFFFFFF
+	str	r1, [r7]
+	dsb
+check:
+	wfe
+	ldr	r1, [r7]
+	tst	r1, #3
+	bne	check
+	bl	cache_invalidate
+
+	ldr	r7, =SRAM_SCRATCH_PA
+	ldr	r1, [r7]
+	bx	r1
+
+/* L1 invalidate */
+cache_invalidate:
+	/* Data Cache Invalidate */
+	/* read clidr */
+	mrc	p15, 1, r0, c0, c0, 1
+	/* extract loc from clidr */
+	ands	r3, r0, #0x7000000
+	/* left align loc bit field */
+	mov	r3, r3, lsr #23
+	/* if loc is 0, then no need to clean */
+	beq	finished
+	/* start clean at cache level 0 */
+	mov	r10, #0
+loop1:
+	/* work out 3x current cache level */
+	add	r2, r10, r10, lsr #1
+	/* extract cache type bits from clidr*/
+	mov	r1, r0, lsr r2
+	/* mask of the bits for current cache only */
+	and	r1, r1, #7
+	/* see what cache we have at this level */
+	cmp	r1, #2
+	/* skip if no cache, or just i-cache */
+	blt	skip
+	/* select current cache level in cssr */
+	mcr	p15, 2, r10, c0, c0, 0
+	/* isb to sych the new cssr&csidr */
+	isb
+	/* read the new csidr */
+	mrc	p15, 1, r1, c0, c0, 0
+	/* extract the length of the cache lines */
+	and	r2, r1, #7
+	/* add 4 (line length offset) */
+	add	r2, r2, #4
+	ldr	r4, =ASSOC_MASK
+	/* find maximum number on the way size */
+	ands	r4, r4, r1, lsr #3
+	/* find bit position of way size increment */
+	clz	r5, r4
+	ldr	r7, =NUMSET_MASK
+	/* extract max number of the index size*/
+	ands	r7, r7, r1, lsr #13
+loop2:
+	mov	r9, r4
+	/* create working copy of max way size*/
+loop3:
+	/* factor way and cache number into r11 */
+	orr	r11, r10, r9, lsl r5
+	/* factor index number into r11 */
+	orr	r11, r11, r7, lsl r2
+	/*clean & invalidate by set/way */
+	mcr	p15, 0, r11, c7, c6, 2
+	/* decrement the way*/
+	subs	r9, r9, #1
+	bge	loop3
+	/*decrement the index */
+	subs	r7, r7, #1
+	bge	loop2
+skip:
+	add	r10, r10, #2
+	/* increment cache number */
+	cmp	r3, r10
+	bgt	loop1
+finished:
+	/* Switch back to cache level 0 */
+	mov	r10, #0
+	/* select current cache level in cssr */
+	mcr	p15, 2, r10, c0, c0, 0
+	dsb
+	isb
+	mov	r0, #0
+	/* L1 Invalidation complete */
+
+	/* Disable SMP, prefetch */
+	mcr	p15, 0, r0, c1, c0, 1
+	dsb
+	/* Instruction cache Invalidate */
+	mcr	p15, 0, r0, c7, c5, 0
+	/* Invalidate branch pred array */
+	mcr	p15, 0, r0, c7, c5, 6
+	/* Invalidate unified TLB */
+	mcr	p15, 0, r0, c8, c7, 0
+	mcr	p15, 0, r0, c8, c5, 0
+	mcr	p15, 0, r0, c8, c6, 0
+	/* memory barrier to sync up the things */
+	mcr	p15, 0, r0, c7, c10, 4
+	dsb
+	isb
+	mov	r0, #0x1800
+	mcr	p15, 0, r0, c1, c0, 0
+	dsb
+	isb
+
+	bx	lr
+	.ltorg
+	.align
+
+ENTRY(spear_wakeup_sz)
+	.word	. - spear_wakeup
+	.text
-- 
1.7.9.7

