From a4e25ec6292d1097d155350ed60d3b3a19fe4313 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 28 Jul 2010 10:43:33 +0800
Subject: [PATCH 9/9] omap3isp: Add ISP main driver and register definitions

Implement a sensible generic interface so that the ISP can offer a
v4l2_subdev (like the v4l2-int-device slaves) interface towards the
camera driver.
Add ISP frontend (CCDC)
Add ISP backend (PRV and RSZ)
Add ISP tables
 * Blue Gamma gain table
 * CFA gain table
 * Green Gamma gain table
 * Luma Enhancement gain table
 * Noise filter gain table
 * Red Gamma gain table
Add Preview Wrapper
Add Resizer Wrapper

[Picked from the commit b056656d to 227037c2 when execute
 "git log drivers/media/video/isp/. on http://arago-project.org/git/\
 projects/linux-omap3.git]

Signed-off-by: Sakari Ailus <sakari.ailus@maxwell.research.nokia.com>
Signed-off-by: David Cohen <david.cohen@nokia.com>
Signed-off-by: Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
Signed-off-by: Sergio Aguirre <saaguirre@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/plat-omap/include/plat/isp_user.h   |  688 +++++++
 drivers/media/video/Kconfig                  |    2 +
 drivers/media/video/Makefile                 |    1 +
 drivers/media/video/isp/Kconfig              |   18 +
 drivers/media/video/isp/Makefile             |   15 +
 drivers/media/video/isp/bluegamma_table.h    | 1040 ++++++++++
 drivers/media/video/isp/cfa_coef_table.h     |  602 ++++++
 drivers/media/video/isp/greengamma_table.h   | 1040 ++++++++++
 drivers/media/video/isp/isp.c                | 2825 ++++++++++++++++++++++++++
 drivers/media/video/isp/isp.h                |  545 +++++
 drivers/media/video/isp/isp_af.c             |  513 +++++
 drivers/media/video/isp/isp_af.h             |  134 ++
 drivers/media/video/isp/ispccdc.c            | 1824 +++++++++++++++++
 drivers/media/video/isp/ispccdc.h            |  286 +++
 drivers/media/video/isp/ispcsi2.c            | 2276 +++++++++++++++++++++
 drivers/media/video/isp/ispcsi2.h            |  240 +++
 drivers/media/video/isp/isph3a.c             |  618 ++++++
 drivers/media/video/isp/isph3a.h             |  154 ++
 drivers/media/video/isp/isphist.c            |  577 ++++++
 drivers/media/video/isp/isphist.h            |  163 ++
 drivers/media/video/isp/isppreview.c         | 1967 ++++++++++++++++++
 drivers/media/video/isp/isppreview.h         |  426 ++++
 drivers/media/video/isp/ispreg.h             | 1702 ++++++++++++++++
 drivers/media/video/isp/ispresizer.c         |  925 +++++++++
 drivers/media/video/isp/ispresizer.h         |  190 ++
 drivers/media/video/isp/ispstat.c            |  259 +++
 drivers/media/video/isp/ispstat.h            |   65 +
 drivers/media/video/isp/luma_enhance_table.h |  144 ++
 drivers/media/video/isp/noise_filter_table.h |   79 +
 drivers/media/video/isp/omap_previewer.c     | 1251 ++++++++++++
 drivers/media/video/isp/omap_previewer.h     |  171 ++
 drivers/media/video/isp/omap_resizer.c       | 1895 +++++++++++++++++
 drivers/media/video/isp/redgamma_table.h     | 1040 ++++++++++
 include/linux/omap_resizer.h                 |  137 ++
 34 files changed, 23812 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-omap/include/plat/isp_user.h
 create mode 100644 drivers/media/video/isp/Kconfig
 create mode 100644 drivers/media/video/isp/Makefile
 create mode 100644 drivers/media/video/isp/bluegamma_table.h
 create mode 100644 drivers/media/video/isp/cfa_coef_table.h
 create mode 100644 drivers/media/video/isp/greengamma_table.h
 create mode 100644 drivers/media/video/isp/isp.c
 create mode 100644 drivers/media/video/isp/isp.h
 create mode 100644 drivers/media/video/isp/isp_af.c
 create mode 100644 drivers/media/video/isp/isp_af.h
 create mode 100644 drivers/media/video/isp/ispccdc.c
 create mode 100644 drivers/media/video/isp/ispccdc.h
 create mode 100644 drivers/media/video/isp/ispcsi2.c
 create mode 100644 drivers/media/video/isp/ispcsi2.h
 create mode 100644 drivers/media/video/isp/isph3a.c
 create mode 100644 drivers/media/video/isp/isph3a.h
 create mode 100644 drivers/media/video/isp/isphist.c
 create mode 100644 drivers/media/video/isp/isphist.h
 create mode 100644 drivers/media/video/isp/isppreview.c
 create mode 100644 drivers/media/video/isp/isppreview.h
 create mode 100644 drivers/media/video/isp/ispreg.h
 create mode 100644 drivers/media/video/isp/ispresizer.c
 create mode 100644 drivers/media/video/isp/ispresizer.h
 create mode 100644 drivers/media/video/isp/ispstat.c
 create mode 100644 drivers/media/video/isp/ispstat.h
 create mode 100644 drivers/media/video/isp/luma_enhance_table.h
 create mode 100644 drivers/media/video/isp/noise_filter_table.h
 create mode 100644 drivers/media/video/isp/omap_previewer.c
 create mode 100644 drivers/media/video/isp/omap_previewer.h
 create mode 100644 drivers/media/video/isp/omap_resizer.c
 create mode 100644 drivers/media/video/isp/redgamma_table.h
 create mode 100644 include/linux/omap_resizer.h

diff --git a/arch/arm/plat-omap/include/plat/isp_user.h b/arch/arm/plat-omap/include/plat/isp_user.h
new file mode 100644
index 0000000..39822a5
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/isp_user.h
@@ -0,0 +1,688 @@
+/*
+ * isp_user.h
+ *
+ * Include file for OMAP ISP module in TI's OMAP3.
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Mohit Jalori <mjalori@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_USER_H
+#define OMAP_ISP_USER_H
+
+#include <linux/types.h>
+#include <linux/videodev2.h>
+
+/* ISP Private IOCTLs */
+#define VIDIOC_PRIVATE_ISP_CCDC_CFG	\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 1, struct ispccdc_update_config)
+#define VIDIOC_PRIVATE_ISP_PRV_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 2, struct ispprv_update_config)
+#define VIDIOC_PRIVATE_ISP_AEWB_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 4, struct isph3a_aewb_config)
+#define VIDIOC_PRIVATE_ISP_AEWB_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 5, struct isph3a_aewb_data)
+#define VIDIOC_PRIVATE_ISP_HIST_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct isp_hist_config)
+#define VIDIOC_PRIVATE_ISP_HIST_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 7, struct isp_hist_data)
+#define VIDIOC_PRIVATE_ISP_AF_CFG \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 8, struct af_configuration)
+#define VIDIOC_PRIVATE_ISP_AF_REQ \
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 9, struct isp_af_data)
+#define VIDIOC_PRIVATE_OMAP34XXCAM_SENSOR_INFO	\
+	_IOWR('V', BASE_VIDIOC_PRIVATE + 10, struct omap34xxcam_sensor_info)
+
+/* Structre for getting Sensor Information*/
+struct omap34xxcam_sensor_info {
+	__u32 current_xclk;
+	struct v4l2_pix_format active_size;
+	struct v4l2_pix_format full_size;
+};
+
+/* AE/AWB related structures and flags*/
+
+/* Flags for update field */
+#define REQUEST_STATISTICS	(1 << 0)
+#define SET_COLOR_GAINS		(1 << 1)
+#define SET_DIGITAL_GAIN	(1 << 2)
+#define SET_EXPOSURE		(1 << 3)
+#define SET_ANALOG_GAIN		(1 << 4)
+
+#define MAX_FRAME_COUNT		0x0FFF
+#define MAX_FUTURE_FRAMES	10
+
+#define MAX_SATURATION_LIM	1023
+#define MIN_WIN_H		2
+#define MAX_WIN_H		256
+#define MIN_WIN_W		6
+#define MAX_WIN_W		256
+#define MAX_WINVC		128
+#define MAX_WINHC		36
+#define MAX_WINSTART		4095
+#define MIN_SUB_INC		2
+#define MAX_SUB_INC		32
+
+/* Range Constants */
+#define AF_IIRSH_MIN			0
+#define AF_IIRSH_MAX			4094
+#define AF_PAXEL_HORIZONTAL_COUNT_MIN	0
+#define AF_PAXEL_HORIZONTAL_COUNT_MAX	35
+#define AF_PAXEL_VERTICAL_COUNT_MIN	0
+#define AF_PAXEL_VERTICAL_COUNT_MAX	127
+#define AF_PAXEL_INCREMENT_MIN		0
+#define AF_PAXEL_INCREMENT_MAX		14
+#define AF_PAXEL_HEIGHT_MIN		0
+#define AF_PAXEL_HEIGHT_MAX		127
+#define AF_PAXEL_WIDTH_MIN		0
+#define AF_PAXEL_WIDTH_MAX		127
+#define AF_PAXEL_HZSTART_MIN		2
+#define AF_PAXEL_HZSTART_MAX		4094
+
+#define AF_PAXEL_VTSTART_MIN		0
+#define AF_PAXEL_VTSTART_MAX		4095
+#define AF_THRESHOLD_MAX		255
+#define AF_COEF_MAX			4095
+#define AF_PAXEL_SIZE			48
+
+/**
+ * struct isph3a_aewb_config - AE AWB configuration reset values.
+ * saturation_limit: Saturation limit.
+ * @win_height: Window Height. Range 2 - 256, even values only.
+ * @win_width: Window Width. Range 6 - 256, even values only.
+ * @ver_win_count: Vertical Window Count. Range 1 - 128.
+ * @hor_win_count: Horizontal Window Count. Range 1 - 36.
+ * @ver_win_start: Vertical Window Start. Range 0 - 4095.
+ * @hor_win_start: Horizontal Window Start. Range 0 - 4095.
+ * @blk_ver_win_start: Black Vertical Windows Start. Range 0 - 4095.
+ * @blk_win_height: Black Window Height. Range 2 - 256, even values only.
+ * @subsample_ver_inc: Subsample Vertical points increment Range 2 - 32, even
+ *                     values only.
+ * @subsample_hor_inc: Subsample Horizontal points increment Range 2 - 32, even
+ *                     values only.
+ * @alaw_enable: AEW ALAW EN flag.
+ * @aewb_enable: AE AWB stats generation EN flag.
+ */
+struct isph3a_aewb_config {
+	__u16 saturation_limit;
+	__u16 win_height;
+	__u16 win_width;
+	__u16 ver_win_count;
+	__u16 hor_win_count;
+	__u16 ver_win_start;
+	__u16 hor_win_start;
+	__u16 blk_ver_win_start;
+	__u16 blk_win_height;
+	__u16 subsample_ver_inc;
+	__u16 subsample_hor_inc;
+	__u8 alaw_enable;
+	__u8 aewb_enable;
+};
+
+/**
+ * struct isph3a_aewb_data - Structure of data sent to or received from user
+ * @h3a_aewb_statistics_buf: Pointer to pass to user.
+ * @shutter: Shutter speed.
+ * @gain: Sensor analog Gain.
+ * @shutter_cap: Shutter speed for capture.
+ * @gain_cap: Sensor Gain for capture.
+ * @dgain: White balance digital gain.
+ * @wb_gain_b: White balance color gain blue.
+ * @wb_gain_r: White balance color gain red.
+ * @wb_gain_gb: White balance color gain green blue.
+ * @wb_gain_gr: White balance color gain green red.
+ * @frame_number: Frame number of requested stats.
+ * @curr_frame: Current frame number being processed.
+ * @update: Bitwise flags to update parameters.
+ * @ts: Timestamp of returned framestats.
+ * @field_count: Sequence number of returned framestats.
+ */
+struct isph3a_aewb_data {
+	void *h3a_aewb_statistics_buf;
+	__u32 shutter;
+	__u16 gain;
+	__u32 shutter_cap;
+	__u16 gain_cap;
+	__u16 dgain;
+	__u16 wb_gain_b;
+	__u16 wb_gain_r;
+	__u16 wb_gain_gb;
+	__u16 wb_gain_gr;
+	__u16 frame_number;
+	__u16 curr_frame;
+	__u8 update;
+	struct timeval ts;
+	__u32 config_counter;
+	unsigned long field_count;
+};
+
+
+/* Histogram related structs */
+/* Flags for number of bins */
+#define BINS_32			0x0
+#define BINS_64			0x1
+#define BINS_128		0x2
+#define BINS_256		0x3
+
+struct isp_hist_config {
+	__u8 hist_source;		/* CCDC or Memory */
+	__u8 input_bit_width;	/* Needed o know the size per pixel */
+	__u8 hist_frames;		/* Num of frames to be processed and
+				 * accumulated
+				 */
+	__u8 hist_h_v_info;	/* frame-input width and height if source is
+				 * memory
+				 */
+	__u16 hist_radd;		/* frame-input address in memory */
+	__u16 hist_radd_off;	/* line-offset for frame-input */
+	__u16 hist_bins;	/* number of bins: 32, 64, 128, or 256 */
+	__u16 wb_gain_R;	/* White Balance Field-to-Pattern Assignments */
+	__u16 wb_gain_RG;	/* White Balance Field-to-Pattern Assignments */
+	__u16 wb_gain_B;	/* White Balance Field-to-Pattern Assignments */
+	__u16 wb_gain_BG;	/* White Balance Field-to-Pattern Assignments */
+	__u8 num_regions;		/* number of regions to be configured */
+	__u16 reg0_hor;		/* Region 0 size and position */
+	__u16 reg0_ver;		/* Region 0 size and position */
+	__u16 reg1_hor;		/* Region 1 size and position */
+	__u16 reg1_ver;		/* Region 1 size and position */
+	__u16 reg2_hor;		/* Region 2 size and position */
+	__u16 reg2_ver;		/* Region 2 size and position */
+	__u16 reg3_hor;		/* Region 3 size and position */
+	__u16 reg3_ver;		/* Region 3 size and position */
+};
+
+struct isp_hist_data {
+	__u32 *hist_statistics_buf;	/* Pointer to pass to user */
+};
+
+/* Auto Focus related structs */
+
+#define AF_NUMBER_OF_COEF		11
+
+/* Flags for update field */
+#define REQUEST_STATISTICS		(1 << 0)
+#define LENS_DESIRED_POSITION	(1 << 1)
+#define LENS_CURRENT_POSITION	(1 << 2)
+
+/**
+ * struct isp_af_xtrastats - Extra statistics related to AF generated stats.
+ * @ts: Timestamp when the frame gets delivered to the user.
+ * @field_count: Field count of the frame delivered to the user.
+ * @lens_position: Lens position when the stats are being generated.
+ */
+struct isp_af_xtrastats {
+	struct timeval ts;
+	unsigned long field_count;
+	__u16 lens_position; /* deprecated */
+};
+
+/**
+ * struct isp_af_data - AF statistics data to transfer between driver and user.
+ * @af_statistics_buf: Pointer to pass to user.
+ * @lens_current_position: Read value of lens absolute position.
+ * @desired_lens_direction: Lens desired location.
+ * @update: Bitwise flags to update parameters.
+ * @frame_number: Data for which frame is desired/given.
+ * @curr_frame: Current frame number being processed by AF module.
+ * @xtrastats: Extra statistics structure.
+ */
+struct isp_af_data {
+	void *af_statistics_buf;
+	__u16 lens_current_position; /* deprecated */
+	__u16 desired_lens_direction; /* deprecated */
+	__u16 update;
+	__u16 frame_number;
+	__u16 curr_frame;
+	__u32 config_counter;
+	struct isp_af_xtrastats xtrastats;
+};
+
+/* enum used for status of specific feature */
+enum af_alaw_enable {
+	H3A_AF_ALAW_DISABLE = 0,
+	H3A_AF_ALAW_ENABLE = 1
+};
+
+enum af_hmf_enable {
+	H3A_AF_HMF_DISABLE = 0,
+	H3A_AF_HMF_ENABLE = 1
+};
+
+enum af_config_flag {
+	H3A_AF_CFG_DISABLE = 0,
+	H3A_AF_CFG_ENABLE = 1
+};
+
+enum af_mode {
+	ACCUMULATOR_SUMMED = 0,
+	ACCUMULATOR_PEAK = 1
+};
+
+/* Red, Green, and blue pixel location in the AF windows */
+enum rgbpos {
+	GR_GB_BAYER = 0,	/* GR and GB as Bayer pattern */
+	RG_GB_BAYER = 1,	/* RG and GB as Bayer pattern */
+	GR_BG_BAYER = 2,	/* GR and BG as Bayer pattern */
+	RG_BG_BAYER = 3,	/* RG and BG as Bayer pattern */
+	GG_RB_CUSTOM = 4,	/* GG and RB as custom pattern */
+	RB_GG_CUSTOM = 5	/* RB and GG as custom pattern */
+};
+
+/* Contains the information regarding the Horizontal Median Filter */
+struct af_hmf {
+	enum af_hmf_enable enable;	/* Status of Horizontal Median Filter */
+	unsigned int threshold;	/* Threshhold Value for Horizontal Median
+				 * Filter
+				 */
+};
+
+/* Contains the information regarding the IIR Filters */
+struct af_iir {
+	unsigned int hz_start_pos;	/* IIR Start Register Value */
+	int coeff_set0[AF_NUMBER_OF_COEF];	/*
+						 * IIR Filter Coefficient for
+						 * Set 0
+						 */
+	int coeff_set1[AF_NUMBER_OF_COEF];	/*
+						 * IIR Filter Coefficient for
+						 * Set 1
+						 */
+};
+
+/* Contains the information regarding the Paxels Structure in AF Engine */
+struct af_paxel {
+	unsigned int width;	/* Width of the Paxel */
+	unsigned int height;	/* Height of the Paxel */
+	unsigned int hz_start;	/* Horizontal Start Position */
+	unsigned int vt_start;	/* Vertical Start Position */
+	unsigned int hz_cnt;	/* Horizontal Count */
+	unsigned int vt_cnt;	/* vertical Count */
+	unsigned int line_incr;	/* Line Increment */
+};
+/* Contains the parameters required for hardware set up of AF Engine */
+struct af_configuration {
+	enum af_alaw_enable alaw_enable;	/*ALWAW status */
+	struct af_hmf hmf_config;	/*HMF configurations */
+	enum rgbpos rgb_pos;		/*RGB Positions */
+	struct af_iir iir_config;	/*IIR filter configurations */
+	struct af_paxel paxel_config;	/*Paxel parameters */
+	enum af_mode mode;		/*Accumulator mode */
+	enum af_config_flag af_config; /*Flag indicates Engine is configured */
+};
+
+/* ISP CCDC structs */
+
+/* Abstraction layer CCDC configurations */
+#define ISP_ABS_CCDC_ALAW		(1 << 0)
+#define ISP_ABS_CCDC_LPF		(1 << 1)
+#define ISP_ABS_CCDC_BLCLAMP		(1 << 2)
+#define ISP_ABS_CCDC_BCOMP		(1 << 3)
+#define ISP_ABS_CCDC_FPC		(1 << 4)
+#define ISP_ABS_CCDC_CULL		(1 << 5)
+#define ISP_ABS_CCDC_COLPTN		(1 << 6)
+#define ISP_ABS_CCDC_CONFIG_LSC		(1 << 7)
+#define ISP_ABS_TBL_LSC			(1 << 8)
+
+#define RGB_MAX				3
+
+/* Enumeration constants for Alaw input width */
+enum alaw_ipwidth {
+	ALAW_BIT12_3 = 0x3,
+	ALAW_BIT11_2 = 0x4,
+	ALAW_BIT10_1 = 0x5,
+	ALAW_BIT9_0 = 0x6
+};
+
+/* Enumeration constants for Video Port */
+enum vpin {
+	BIT12_3 = 3,
+	BIT11_2 = 4,
+	BIT10_1 = 5,
+	BIT9_0 = 6
+};
+
+enum vpif_freq {
+	PIXCLKBY2,
+	PIXCLKBY3_5,
+	PIXCLKBY4_5,
+	PIXCLKBY5_5,
+	PIXCLKBY6_5
+};
+
+/**
+ * struct ispccdc_lsc_config - Structure for LSC configuration.
+ * @offset: Table Offset of the gain table.
+ * @gain_mode_n: Vertical dimension of a paxel in LSC configuration.
+ * @gain_mode_m: Horizontal dimension of a paxel in LSC configuration.
+ * @gain_format: Gain table format.
+ * @fmtsph: Start pixel horizontal from start of the HS sync pulse.
+ * @fmtlnh: Number of pixels in horizontal direction to use for the data
+ *          reformatter.
+ * @fmtslv: Start line from start of VS sync pulse for the data reformatter.
+ * @fmtlnv: Number of lines in vertical direction for the data reformatter.
+ * @initial_x: X position, in pixels, of the first active pixel in reference
+ *             to the first active paxel. Must be an even number.
+ * @initial_y: Y position, in pixels, of the first active pixel in reference
+ *             to the first active paxel. Must be an even number.
+ * @size: Size of LSC gain table. Filled when loaded from userspace.
+ */
+struct ispccdc_lsc_config {
+	__u16 offset;
+	__u8 gain_mode_n;
+	__u8 gain_mode_m;
+	__u8 gain_format;
+	__u16 fmtsph;
+	__u16 fmtlnh;
+	__u16 fmtslv;
+	__u16 fmtlnv;
+	__u8 initial_x;
+	__u8 initial_y;
+	__u32 size;
+};
+
+/**
+ * struct ispccdc_bclamp - Structure for Optical & Digital black clamp subtract
+ * @obgain: Optical black average gain.
+ * @obstpixel: Start Pixel w.r.t. HS pulse in Optical black sample.
+ * @oblines: Optical Black Sample lines.
+ * @oblen: Optical Black Sample Length.
+ * @dcsubval: Digital Black Clamp subtract value.
+ */
+struct ispccdc_bclamp {
+	__u8 obgain;
+	__u8 obstpixel;
+	__u8 oblines;
+	__u8 oblen;
+	__u16 dcsubval;
+};
+
+/**
+ * ispccdc_fpc - Structure for FPC
+ * @fpnum: Number of faulty pixels to be corrected in the frame.
+ * @fpcaddr: Memory address of the FPC Table
+ */
+struct ispccdc_fpc {
+	__u16 fpnum;
+	__u32 fpcaddr;
+};
+
+/**
+ * ispccdc_blcomp - Structure for Black Level Compensation parameters.
+ * @b_mg: B/Mg pixels. 2's complement. -128 to +127.
+ * @gb_g: Gb/G pixels. 2's complement. -128 to +127.
+ * @gr_cy: Gr/Cy pixels. 2's complement. -128 to +127.
+ * @r_ye: R/Ye pixels. 2's complement. -128 to +127.
+ */
+struct ispccdc_blcomp {
+	__u8 b_mg;
+	__u8 gb_g;
+	__u8 gr_cy;
+	__u8 r_ye;
+};
+
+/**
+ * struct ispccdc_vp - Structure for Video Port parameters
+ * @bitshift_sel: Video port input select. 3 - bits 12-3, 4 - bits 11-2,
+ *                5 - bits 10-1, 6 - bits 9-0.
+ * @freq_sel: Video port data ready frequency. 1 - 1/3.5, 2 - 1/4.5,
+ *            3 - 1/5.5, 4 - 1/6.5.
+ */
+struct ispccdc_vp {
+	enum vpin bitshift_sel;
+	enum vpif_freq freq_sel;
+};
+
+/**
+ * ispccdc_culling - Structure for Culling parameters.
+ * @v_pattern: Vertical culling pattern.
+ * @h_odd: Horizontal Culling pattern for odd lines.
+ * @h_even: Horizontal Culling pattern for even lines.
+ */
+struct ispccdc_culling {
+	__u8 v_pattern;
+	__u16 h_odd;
+	__u16 h_even;
+};
+
+/**
+ * ispccdc_update_config - Structure for CCDC configuration.
+ * @update: Specifies which CCDC registers should be updated.
+ * @flag: Specifies which CCDC functions should be enabled.
+ * @alawip: Enable/Disable A-Law compression.
+ * @bclamp: Black clamp control register.
+ * @blcomp: Black level compensation value for RGrGbB Pixels. 2's complement.
+ * @fpc: Number of faulty pixels corrected in the frame, address of FPC table.
+ * @cull: Cull control register.
+ * @colptn: Color pattern of the sensor.
+ * @lsc: Pointer to LSC gain table.
+ */
+struct ispccdc_update_config {
+	__u16 update;
+	__u16 flag;
+	enum alaw_ipwidth alawip;
+	struct ispccdc_bclamp *bclamp;
+	struct ispccdc_blcomp *blcomp;
+	struct ispccdc_fpc *fpc;
+	struct ispccdc_lsc_config *lsc_cfg;
+	struct ispccdc_culling *cull;
+	__u32 colptn;
+	__u8 *lsc;
+};
+
+/* Preview configuration */
+
+/*Abstraction layer preview configurations*/
+#define ISP_ABS_PREV_LUMAENH		(1 << 0)
+#define ISP_ABS_PREV_INVALAW		(1 << 1)
+#define ISP_ABS_PREV_HRZ_MED		(1 << 2)
+#define ISP_ABS_PREV_CFA		(1 << 3)
+#define ISP_ABS_PREV_CHROMA_SUPP	(1 << 4)
+#define ISP_ABS_PREV_WB			(1 << 5)
+#define ISP_ABS_PREV_BLKADJ		(1 << 6)
+#define ISP_ABS_PREV_RGB2RGB		(1 << 7)
+#define ISP_ABS_PREV_COLOR_CONV		(1 << 8)
+#define ISP_ABS_PREV_YC_LIMIT		(1 << 9)
+#define ISP_ABS_PREV_DEFECT_COR		(1 << 10)
+#define ISP_ABS_PREV_GAMMABYPASS	(1 << 11)
+#define ISP_ABS_TBL_NF			(1 << 12)
+#define ISP_ABS_TBL_REDGAMMA		(1 << 13)
+#define ISP_ABS_TBL_GREENGAMMA		(1 << 14)
+#define ISP_ABS_TBL_BLUEGAMMA		(1 << 15)
+
+#define ISPPRV_NF_TBL_SIZE		64
+#define ISPPRV_CFA_TBL_SIZE		576
+#define ISPPRV_GAMMA_TBL_SIZE		1024
+#define ISPPRV_YENH_TBL_SIZE		128
+
+/**
+ * struct ispprev_hmed - Structure for Horizontal Median Filter.
+ * @odddist: Distance between consecutive pixels of same color in the odd line.
+ * @evendist: Distance between consecutive pixels of same color in the even
+ *            line.
+ * @thres: Horizontal median filter threshold.
+ */
+struct ispprev_hmed {
+	__u8 odddist;
+	__u8 evendist;
+	__u8 thres;
+};
+
+/*
+ * Enumeration for CFA Formats supported by preview
+ */
+enum cfa_fmt {
+	CFAFMT_BAYER, CFAFMT_SONYVGA, CFAFMT_RGBFOVEON,
+	CFAFMT_DNSPL, CFAFMT_HONEYCOMB, CFAFMT_RRGGBBFOVEON
+};
+
+/**
+ * struct ispprev_cfa - Structure for CFA Inpterpolation.
+ * @cfafmt: CFA Format Enum value supported by preview.
+ * @cfa_gradthrs_vert: CFA Gradient Threshold - Vertical.
+ * @cfa_gradthrs_horz: CFA Gradient Threshold - Horizontal.
+ * @cfa_table: Pointer to the CFA table.
+ */
+struct ispprev_cfa {
+	enum cfa_fmt cfafmt;
+	__u8 cfa_gradthrs_vert;
+	__u8 cfa_gradthrs_horz;
+	__u32 *cfa_table;
+};
+
+/**
+ * struct ispprev_csup - Structure for Chrominance Suppression.
+ * @gain: Gain.
+ * @thres: Threshold.
+ * @hypf_en: Flag to enable/disable the High Pass Filter.
+ */
+struct ispprev_csup {
+	__u8 gain;
+	__u8 thres;
+	__u8 hypf_en;
+};
+
+/**
+ * struct ispprev_wbal - Structure for White Balance.
+ * @dgain: Digital gain (U10Q8).
+ * @coef3: White balance gain - COEF 3 (U8Q5).
+ * @coef2: White balance gain - COEF 2 (U8Q5).
+ * @coef1: White balance gain - COEF 1 (U8Q5).
+ * @coef0: White balance gain - COEF 0 (U8Q5).
+ */
+struct ispprev_wbal {
+	__u16 dgain;
+	__u8 coef3;
+	__u8 coef2;
+	__u8 coef1;
+	__u8 coef0;
+};
+
+/**
+ * struct ispprev_blkadj - Structure for Black Adjustment.
+ * @red: Black level offset adjustment for Red in 2's complement format
+ * @green: Black level offset adjustment for Green in 2's complement format
+ * @blue: Black level offset adjustment for Blue in 2's complement format
+ */
+struct ispprev_blkadj {
+	/*Black level offset adjustment for Red in 2's complement format */
+	__u8 red;
+	/*Black level offset adjustment for Green in 2's complement format */
+	__u8 green;
+	/* Black level offset adjustment for Blue in 2's complement format */
+	__u8 blue;
+};
+
+/**
+ * struct ispprev_rgbtorgb - Structure for RGB to RGB Blending.
+ * @matrix: Blending values(S12Q8 format)
+ *              [RR] [GR] [BR]
+ *              [RG] [GG] [BG]
+ *              [RB] [GB] [BB]
+ * @offset: Blending offset value for R,G,B in 2's complement integer format.
+ */
+struct ispprev_rgbtorgb {
+	__u16 matrix[3][3];
+	__u16 offset[3];
+};
+
+/**
+ * struct ispprev_csc - Structure for Color Space Conversion from RGB-YCbYCr
+ * @matrix: Color space conversion coefficients(S10Q8)
+ *              [CSCRY]  [CSCGY]  [CSCBY]
+ *              [CSCRCB] [CSCGCB] [CSCBCB]
+ *              [CSCRCR] [CSCGCR] [CSCBCR]
+ * @offset: CSC offset values for Y offset, CB offset and CR offset respectively
+ */
+struct ispprev_csc {
+	__u16 matrix[RGB_MAX][RGB_MAX];
+	__s16 offset[RGB_MAX];
+};
+
+/**
+ * struct ispprev_yclimit - Structure for Y, C Value Limit.
+ * @minC: Minimum C value
+ * @maxC: Maximum C value
+ * @minY: Minimum Y value
+ * @maxY: Maximum Y value
+ */
+struct ispprev_yclimit {
+	__u8 minC;
+	__u8 maxC;
+	__u8 minY;
+	__u8 maxY;
+};
+
+/**
+ * struct ispprev_dcor - Structure for Defect correction.
+ * @couplet_mode_en: Flag to enable or disable the couplet dc Correction in NF
+ * @detect_correct: Thresholds for correction bit 0:10 detect 16:25 correct
+ */
+struct ispprev_dcor {
+	__u8 couplet_mode_en;
+	__u32 detect_correct[4];
+};
+
+/**
+ * struct ispprev_nf - Structure for Noise Filter
+ * @spread: Spread value to be used in Noise Filter
+ * @table: Pointer to the Noise Filter table
+ */
+struct ispprev_nf {
+	__u8 spread;
+	__u32 table[ISPPRV_NF_TBL_SIZE];
+};
+
+/**
+ * struct ispprv_update_config - Structure for Preview Configuration (user).
+ * @update: Specifies which ISP Preview registers should be updated.
+ * @flag: Specifies which ISP Preview functions should be enabled.
+ * @yen: Pointer to luma enhancement table.
+ * @shading_shift: 3bit value of shift used in shading compensation.
+ * @prev_hmed: Pointer to structure containing the odd and even distance.
+ *             between the pixels in the image along with the filter threshold.
+ * @prev_cfa: Pointer to structure containing the CFA interpolation table, CFA.
+ *            format in the image, vertical and horizontal gradient threshold.
+ * @csup: Pointer to Structure for Chrominance Suppression coefficients.
+ * @prev_wbal: Pointer to structure for White Balance.
+ * @prev_blkadj: Pointer to structure for Black Adjustment.
+ * @rgb2rgb: Pointer to structure for RGB to RGB Blending.
+ * @prev_csc: Pointer to structure for Color Space Conversion from RGB-YCbYCr.
+ * @yclimit: Pointer to structure for Y, C Value Limit.
+ * @prev_dcor: Pointer to structure for defect correction.
+ * @prev_nf: Pointer to structure for Noise Filter
+ * @red_gamma: Pointer to red gamma correction table.
+ * @green_gamma: Pointer to green gamma correction table.
+ * @blue_gamma: Pointer to blue gamma correction table.
+ */
+struct ispprv_update_config {
+	__u16 update;
+	__u16 flag;
+	void *yen;
+	__u32 shading_shift;
+	struct ispprev_hmed *prev_hmed;
+	struct ispprev_cfa *prev_cfa;
+	struct ispprev_csup *csup;
+	struct ispprev_wbal *prev_wbal;
+	struct ispprev_blkadj *prev_blkadj;
+	struct ispprev_rgbtorgb *rgb2rgb;
+	struct ispprev_csc *prev_csc;
+	struct ispprev_yclimit *yclimit;
+	struct ispprev_dcor *prev_dcor;
+	struct ispprev_nf *prev_nf;
+	__u32 *red_gamma;
+	__u32 *green_gamma;
+	__u32 *blue_gamma;
+};
+
+#endif /* OMAP_ISP_USER_H */
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 2114b6e..685b16d 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -842,6 +842,8 @@ config VIDEO_OMAP3
 	---help---
 	  Driver for an OMAP 3 camera controller.
 
+source "drivers/media/video/isp/Kconfig"
+
 config SOC_CAMERA
 	tristate "SoC camera support"
 	depends on VIDEO_V4L2 && HAS_DMA && I2C
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index e793f42..4703b5d 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -127,6 +127,7 @@ obj-$(CONFIG_VIDEO_CX2341X) += cx2341x.o
 
 obj-$(CONFIG_VIDEO_CAFE_CCIC) += cafe_ccic.o
 
+obj-y				+= isp/
 obj-$(CONFIG_VIDEO_OMAP3)	+= omap34xxcam.o
 obj-$(CONFIG_USB_DABUSB)        += dabusb.o
 obj-$(CONFIG_USB_OV511)         += ov511.o
diff --git a/drivers/media/video/isp/Kconfig b/drivers/media/video/isp/Kconfig
new file mode 100644
index 0000000..9566da0
--- /dev/null
+++ b/drivers/media/video/isp/Kconfig
@@ -0,0 +1,18 @@
+# Kconfig for OMAP3 ISP driver
+
+config VIDEO_OMAP3_ISP
+	bool
+	select VIDEOBUF_GEN
+	select VIDEOBUF_DMA_SG
+	select OMAP_IOMMU
+
+config VIDEO_OMAP34XX_ISP_PREVIEWER
+	tristate "OMAP ISP Previewer"
+	depends on !ARCH_OMAP3410
+	select VIDEO_OMAP3_ISP
+
+
+config VIDEO_OMAP34XX_ISP_RESIZER
+	tristate "OMAP ISP Resizer"
+	depends on !ARCH_OMAP3410
+	select VIDEO_OMAP3_ISP
diff --git a/drivers/media/video/isp/Makefile b/drivers/media/video/isp/Makefile
new file mode 100644
index 0000000..629aab5
--- /dev/null
+++ b/drivers/media/video/isp/Makefile
@@ -0,0 +1,15 @@
+# Makefile for OMAP3 ISP driver
+
+isp-mod-objs += \
+	isp.o ispccdc.o \
+	isppreview.o ispresizer.o isph3a.o isphist.o isp_af.o ispcsi2.o \
+	ispstat.o
+
+obj-$(CONFIG_VIDEO_OMAP3_ISP) += isp-mod.o
+
+obj-$(CONFIG_VIDEO_OMAP34XX_ISP_PREVIEWER) += \
+	omap_previewer.o
+
+obj-$(CONFIG_VIDEO_OMAP34XX_ISP_RESIZER) += \
+	omap_resizer.o
+
diff --git a/drivers/media/video/isp/bluegamma_table.h b/drivers/media/video/isp/bluegamma_table.h
new file mode 100644
index 0000000..301382a
--- /dev/null
+++ b/drivers/media/video/isp/bluegamma_table.h
@@ -0,0 +1,1040 @@
+/*
+ * bluegamma_table.h
+ *
+ * Gamma Table values for BLUE for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+0,
+0,
+1,
+2,
+3,
+3,
+4,
+5,
+6,
+8,
+10,
+12,
+14,
+16,
+18,
+20,
+22,
+23,
+25,
+26,
+28,
+29,
+31,
+32,
+34,
+35,
+36,
+37,
+39,
+40,
+41,
+42,
+43,
+44,
+45,
+46,
+47,
+48,
+49,
+50,
+51,
+52,
+52,
+53,
+54,
+55,
+56,
+57,
+58,
+59,
+60,
+61,
+62,
+63,
+63,
+64,
+65,
+66,
+66,
+67,
+68,
+69,
+69,
+70,
+71,
+72,
+72,
+73,
+74,
+75,
+75,
+76,
+77,
+78,
+78,
+79,
+80,
+81,
+81,
+82,
+83,
+84,
+84,
+85,
+86,
+87,
+88,
+88,
+89,
+90,
+91,
+91,
+92,
+93,
+94,
+94,
+95,
+96,
+97,
+97,
+98,
+98,
+99,
+99,
+100,
+100,
+101,
+101,
+102,
+103,
+104,
+104,
+105,
+106,
+107,
+108,
+108,
+109,
+110,
+111,
+111,
+112,
+113,
+114,
+114,
+115,
+116,
+117,
+117,
+118,
+119,
+119,
+120,
+120,
+121,
+121,
+122,
+122,
+123,
+123,
+124,
+124,
+125,
+125,
+126,
+126,
+127,
+127,
+128,
+128,
+129,
+129,
+130,
+130,
+131,
+131,
+132,
+132,
+133,
+133,
+134,
+134,
+135,
+135,
+136,
+136,
+137,
+137,
+138,
+138,
+139,
+139,
+140,
+140,
+141,
+141,
+142,
+142,
+143,
+143,
+144,
+144,
+145,
+145,
+146,
+146,
+147,
+147,
+148,
+148,
+149,
+149,
+150,
+150,
+151,
+151,
+152,
+152,
+153,
+153,
+153,
+153,
+154,
+154,
+154,
+154,
+155,
+155,
+156,
+156,
+157,
+157,
+158,
+158,
+158,
+159,
+159,
+159,
+160,
+160,
+160,
+161,
+161,
+162,
+162,
+163,
+163,
+164,
+164,
+164,
+164,
+165,
+165,
+165,
+165,
+166,
+166,
+167,
+167,
+168,
+168,
+169,
+169,
+170,
+170,
+170,
+170,
+171,
+171,
+171,
+171,
+172,
+172,
+173,
+173,
+174,
+174,
+175,
+175,
+176,
+176,
+176,
+176,
+177,
+177,
+177,
+177,
+178,
+178,
+178,
+178,
+179,
+179,
+179,
+179,
+180,
+180,
+180,
+180,
+181,
+181,
+181,
+181,
+182,
+182,
+182,
+182,
+183,
+183,
+183,
+183,
+184,
+184,
+184,
+184,
+185,
+185,
+185,
+185,
+186,
+186,
+186,
+186,
+187,
+187,
+187,
+187,
+188,
+188,
+188,
+188,
+189,
+189,
+189,
+189,
+190,
+190,
+190,
+190,
+191,
+191,
+191,
+191,
+192,
+192,
+192,
+192,
+193,
+193,
+193,
+193,
+194,
+194,
+194,
+194,
+195,
+195,
+195,
+195,
+196,
+196,
+196,
+196,
+197,
+197,
+197,
+197,
+198,
+198,
+198,
+198,
+199,
+199,
+199,
+199,
+200,
+200,
+200,
+200,
+201,
+201,
+201,
+201,
+202,
+202,
+202,
+203,
+203,
+203,
+203,
+204,
+204,
+204,
+204,
+205,
+205,
+205,
+205,
+206,
+206,
+206,
+206,
+207,
+207,
+207,
+207,
+208,
+208,
+208,
+208,
+209,
+209,
+209,
+209,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+212,
+212,
+212,
+212,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+214,
+214,
+214,
+214,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+216,
+216,
+216,
+216,
+217,
+217,
+217,
+217,
+218,
+218,
+218,
+218,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+220,
+220,
+220,
+220,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+222,
+222,
+222,
+222,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+224,
+224,
+224,
+224,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+226,
+226,
+226,
+226,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+228,
+228,
+228,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+230,
+230,
+230,
+230,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+233,
+233,
+233,
+233,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+235,
+235,
+235,
+235,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+237,
+237,
+237,
+237,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+239,
+239,
+239,
+239,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+241,
+241,
+241,
+241,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+243,
+243,
+243,
+243,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+245,
+245,
+245,
+245,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+247,
+247,
+247,
+247,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+249,
+249,
+249,
+249,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+251,
+251,
+251,
+251,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+254,
+254,
+254,
+254,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255
diff --git a/drivers/media/video/isp/cfa_coef_table.h b/drivers/media/video/isp/cfa_coef_table.h
new file mode 100644
index 0000000..722a123
--- /dev/null
+++ b/drivers/media/video/isp/cfa_coef_table.h
@@ -0,0 +1,602 @@
+/*
+ * cfa_coef_table.h
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *          Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *
+ * Written by Gjorgji Rosikopulos
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0,
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0,
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+244,
+12,
+250,
+4,
+0,
+27,
+0,
+250,
+247,
+36,
+27,
+12,
+0,
+247,
+0,
+244,
+248,
+0,
+0,
+0,
+0,
+40,
+0,
+0,
+244,
+0,
+247,
+0,
+12,
+27,
+36,
+247,
+250,
+0,
+27,
+0,
+4,
+250,
+12,
+244,
+0,
+0,
+40,
+0,
+0,
+0,
+0,
+248,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0,
+4,
+250,
+12,
+244,
+250,
+0,
+27,
+0,
+12,
+27,
+36,
+247,
+244,
+0,
+247,
+0,
+0,
+0,
+0,
+248,
+0,
+0,
+40,
+0,
+0,
+247,
+0,
+244,
+247,
+36,
+27,
+12,
+0,
+27,
+0,
+250,
+244,
+12,
+250,
+4,
+0,
+40,
+0,
+0,
+248,
+0,
+0,
+0
diff --git a/drivers/media/video/isp/greengamma_table.h b/drivers/media/video/isp/greengamma_table.h
new file mode 100644
index 0000000..0f5c5e4
--- /dev/null
+++ b/drivers/media/video/isp/greengamma_table.h
@@ -0,0 +1,1040 @@
+/*
+ * greengamma_table.h
+ *
+ * Gamma Table values for GREEN for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+0,
+0,
+1,
+2,
+3,
+3,
+4,
+5,
+6,
+8,
+10,
+12,
+14,
+16,
+18,
+20,
+22,
+23,
+25,
+26,
+28,
+29,
+31,
+32,
+34,
+35,
+36,
+37,
+39,
+40,
+41,
+42,
+43,
+44,
+45,
+46,
+47,
+48,
+49,
+50,
+51,
+52,
+52,
+53,
+54,
+55,
+56,
+57,
+58,
+59,
+60,
+61,
+62,
+63,
+63,
+64,
+65,
+66,
+66,
+67,
+68,
+69,
+69,
+70,
+71,
+72,
+72,
+73,
+74,
+75,
+75,
+76,
+77,
+78,
+78,
+79,
+80,
+81,
+81,
+82,
+83,
+84,
+84,
+85,
+86,
+87,
+88,
+88,
+89,
+90,
+91,
+91,
+92,
+93,
+94,
+94,
+95,
+96,
+97,
+97,
+98,
+98,
+99,
+99,
+100,
+100,
+101,
+101,
+102,
+103,
+104,
+104,
+105,
+106,
+107,
+108,
+108,
+109,
+110,
+111,
+111,
+112,
+113,
+114,
+114,
+115,
+116,
+117,
+117,
+118,
+119,
+119,
+120,
+120,
+121,
+121,
+122,
+122,
+123,
+123,
+124,
+124,
+125,
+125,
+126,
+126,
+127,
+127,
+128,
+128,
+129,
+129,
+130,
+130,
+131,
+131,
+132,
+132,
+133,
+133,
+134,
+134,
+135,
+135,
+136,
+136,
+137,
+137,
+138,
+138,
+139,
+139,
+140,
+140,
+141,
+141,
+142,
+142,
+143,
+143,
+144,
+144,
+145,
+145,
+146,
+146,
+147,
+147,
+148,
+148,
+149,
+149,
+150,
+150,
+151,
+151,
+152,
+152,
+153,
+153,
+153,
+153,
+154,
+154,
+154,
+154,
+155,
+155,
+156,
+156,
+157,
+157,
+158,
+158,
+158,
+159,
+159,
+159,
+160,
+160,
+160,
+161,
+161,
+162,
+162,
+163,
+163,
+164,
+164,
+164,
+164,
+165,
+165,
+165,
+165,
+166,
+166,
+167,
+167,
+168,
+168,
+169,
+169,
+170,
+170,
+170,
+170,
+171,
+171,
+171,
+171,
+172,
+172,
+173,
+173,
+174,
+174,
+175,
+175,
+176,
+176,
+176,
+176,
+177,
+177,
+177,
+177,
+178,
+178,
+178,
+178,
+179,
+179,
+179,
+179,
+180,
+180,
+180,
+180,
+181,
+181,
+181,
+181,
+182,
+182,
+182,
+182,
+183,
+183,
+183,
+183,
+184,
+184,
+184,
+184,
+185,
+185,
+185,
+185,
+186,
+186,
+186,
+186,
+187,
+187,
+187,
+187,
+188,
+188,
+188,
+188,
+189,
+189,
+189,
+189,
+190,
+190,
+190,
+190,
+191,
+191,
+191,
+191,
+192,
+192,
+192,
+192,
+193,
+193,
+193,
+193,
+194,
+194,
+194,
+194,
+195,
+195,
+195,
+195,
+196,
+196,
+196,
+196,
+197,
+197,
+197,
+197,
+198,
+198,
+198,
+198,
+199,
+199,
+199,
+199,
+200,
+200,
+200,
+200,
+201,
+201,
+201,
+201,
+202,
+202,
+202,
+203,
+203,
+203,
+203,
+204,
+204,
+204,
+204,
+205,
+205,
+205,
+205,
+206,
+206,
+206,
+206,
+207,
+207,
+207,
+207,
+208,
+208,
+208,
+208,
+209,
+209,
+209,
+209,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+212,
+212,
+212,
+212,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+214,
+214,
+214,
+214,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+216,
+216,
+216,
+216,
+217,
+217,
+217,
+217,
+218,
+218,
+218,
+218,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+220,
+220,
+220,
+220,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+222,
+222,
+222,
+222,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+224,
+224,
+224,
+224,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+226,
+226,
+226,
+226,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+228,
+228,
+228,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+230,
+230,
+230,
+230,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+233,
+233,
+233,
+233,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+235,
+235,
+235,
+235,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+237,
+237,
+237,
+237,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+239,
+239,
+239,
+239,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+241,
+241,
+241,
+241,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+243,
+243,
+243,
+243,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+245,
+245,
+245,
+245,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+247,
+247,
+247,
+247,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+249,
+249,
+249,
+249,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+251,
+251,
+251,
+251,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+254,
+254,
+254,
+254,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255
diff --git a/drivers/media/video/isp/isp.c b/drivers/media/video/isp/isp.c
new file mode 100644
index 0000000..bedcfc7
--- /dev/null
+++ b/drivers/media/video/isp/isp.c
@@ -0,0 +1,2825 @@
+/*
+ * isp.c
+ *
+ * Driver Library for ISP Control module in TI's OMAP3 Camera ISP
+ * ISP interface and IRQ related APIs are defined here.
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ * Copyright (C) 2009 Nokia.
+ *
+ * Contributors:
+ *	Sameer Venkatraman <sameerv@ti.com>
+ *	Mohit Jalori <mjalori@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Sakari Ailus <sakari.ailus@nokia.com>
+ *	Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *	Toni Leinonen <toni.leinonen@nokia.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <asm/cacheflush.h>
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "ispccdc.h"
+#include "isph3a.h"
+#include "isphist.h"
+#include "isp_af.h"
+#include "isppreview.h"
+#include "ispresizer.h"
+#include "ispcsi2.h"
+
+static struct platform_device *omap3isp_pdev;
+
+static void isp_save_ctx(struct device *dev);
+
+static void isp_restore_ctx(struct device *dev);
+
+static void isp_buf_init(struct device *dev);
+
+#define omap_rev_is_1_0() (GET_OMAP_REVISION() == 0x00)
+
+/* List of image formats supported via OMAP ISP */
+const static struct v4l2_fmtdesc isp_formats[] = {
+	{
+		.description = "UYVY, packed",
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+	},
+	{
+		.description = "YUYV (YUV 4:2:2), packed",
+		.pixelformat = V4L2_PIX_FMT_YUYV,
+	},
+	{
+		.description = "Bayer10 (GrR/BGb)",
+		.pixelformat = V4L2_PIX_FMT_SGRBG10,
+	},
+};
+
+/**
+ * struct vcontrol - Video control structure.
+ * @qc: V4L2 Query control structure.
+ * @current_value: Current value of the control.
+ */
+static struct vcontrol {
+	struct v4l2_queryctrl qc;
+	int current_value;
+} video_control[] = {
+	{
+		{
+			.id = V4L2_CID_BRIGHTNESS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Brightness",
+			.minimum = ISPPRV_BRIGHT_LOW,
+			.maximum = ISPPRV_BRIGHT_HIGH,
+			.step = ISPPRV_BRIGHT_STEP,
+			.default_value = ISPPRV_BRIGHT_DEF,
+		},
+		.current_value = ISPPRV_BRIGHT_DEF,
+	},
+	{
+		{
+			.id = V4L2_CID_CONTRAST,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Contrast",
+			.minimum = ISPPRV_CONTRAST_LOW,
+			.maximum = ISPPRV_CONTRAST_HIGH,
+			.step = ISPPRV_CONTRAST_STEP,
+			.default_value = ISPPRV_CONTRAST_DEF,
+		},
+		.current_value = ISPPRV_CONTRAST_DEF,
+	},
+	{
+		{
+			.id = V4L2_CID_COLORFX,
+			.type = V4L2_CTRL_TYPE_MENU,
+			.name = "Color Effects",
+			.minimum = V4L2_COLORFX_NONE,
+			.maximum = V4L2_COLORFX_SEPIA,
+			.step = 1,
+			.default_value = V4L2_COLORFX_NONE,
+		},
+		.current_value = V4L2_COLORFX_NONE,
+	}
+};
+
+static struct v4l2_querymenu video_menu[] = {
+	{
+		.id = V4L2_CID_COLORFX,
+		.index = 0,
+		.name = "None",
+	},
+	{
+		.id = V4L2_CID_COLORFX,
+		.index = 1,
+		.name = "B&W",
+	},
+	{
+		.id = V4L2_CID_COLORFX,
+		.index = 2,
+		.name = "Sepia",
+	},
+};
+
+/* Structure for saving/restoring ISP module registers */
+static struct isp_reg isp_reg_list[] = {
+	{OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_IRQ1ENABLE, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_GRESET_LENGTH, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_PSTRB_REPLAY, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_FRAME, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_PSTRB_DELAY, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_STRB_DELAY, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_SHUT_DELAY, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_PSTRB_LENGTH, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_STRB_LENGTH, 0},
+	{OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_SHUT_LENGTH, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF_SYSCONFIG, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF_IRQENABLE, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF0_CTRL, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF1_CTRL, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF0_START, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF1_START, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF0_END, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF1_END, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF0_WINDOWSIZE, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF1_WINDOWSIZE, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF0_THRESHOLD, 0},
+	{OMAP3_ISP_IOMEM_CBUFF, ISP_CBUFF1_THRESHOLD, 0},
+	{0, ISP_TOK_TERM, 0}
+};
+
+/**
+ * isp_flush - Post pending L3 bus writes by doing a register readback
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * In order to force posting of pending writes, we need to write and
+ * readback the same register, in this case the revision register.
+ *
+ * See this link for reference:
+ *   http://www.mail-archive.com/linux-omap@vger.kernel.org/msg08149.html
+ **/
+void isp_flush(struct device *dev)
+{
+	isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);
+	isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_REVISION);
+}
+
+/**
+ * isp_reg_readl - Read value of an OMAP3 ISP register
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @isp_mmio_range: Range to which the register offset refers to.
+ * @reg_offset: Register offset to read from.
+ *
+ * Returns an unsigned 32 bit value with the required register contents.
+ **/
+u32 isp_reg_readl(struct device *dev, enum isp_mem_resources isp_mmio_range,
+		  u32 reg_offset)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	return __raw_readl(isp->mmio_base[isp_mmio_range] + reg_offset);
+}
+EXPORT_SYMBOL(isp_reg_readl);
+
+/**
+ * isp_reg_writel - Write value to an OMAP3 ISP register
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @reg_value: 32 bit value to write to the register.
+ * @isp_mmio_range: Range to which the register offset refers to.
+ * @reg_offset: Register offset to write into.
+ **/
+void isp_reg_writel(struct device *dev, u32 reg_value,
+		    enum isp_mem_resources isp_mmio_range, u32 reg_offset)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	__raw_writel(reg_value, isp->mmio_base[isp_mmio_range] + reg_offset);
+}
+EXPORT_SYMBOL(isp_reg_writel);
+
+/**
+ * isp_reg_and - Do AND binary operation within an OMAP3 ISP register value
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @mmio_range: Range to which the register offset refers to.
+ * @reg: Register offset to work on.
+ * @and_bits: 32 bit value which would be 'ANDed' with current register value.
+ **/
+void isp_reg_and(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		 u32 and_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, v & and_bits, mmio_range, reg);
+}
+EXPORT_SYMBOL(isp_reg_and);
+
+/**
+ * isp_reg_or - Do OR binary operation within an OMAP3 ISP register value
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @mmio_range: Range to which the register offset refers to.
+ * @reg: Register offset to work on.
+ * @or_bits: 32 bit value which would be 'ORed' with current register value.
+ **/
+void isp_reg_or(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		u32 or_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, v | or_bits, mmio_range, reg);
+}
+EXPORT_SYMBOL(isp_reg_or);
+
+/**
+ * isp_reg_and_or - Do AND and OR binary ops within an OMAP3 ISP register value
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @mmio_range: Range to which the register offset refers to.
+ * @reg: Register offset to work on.
+ * @and_bits: 32 bit value which would be 'ANDed' with current register value.
+ * @or_bits: 32 bit value which would be 'ORed' with current register value.
+ *
+ * The AND operation is done first, and then the OR operation. Mostly useful
+ * when clearing a group of bits before setting a value.
+ **/
+void isp_reg_and_or(struct device *dev, enum isp_mem_resources mmio_range,
+		    u32 reg, u32 and_bits, u32 or_bits)
+{
+	u32 v = isp_reg_readl(dev, mmio_range, reg);
+
+	isp_reg_writel(dev, (v & and_bits) | or_bits, mmio_range, reg);
+}
+EXPORT_SYMBOL(isp_reg_and_or);
+
+/**
+ * find_vctrl - Return the index of the ctrl array of the requested ctrl ID.
+ * @id: Requested control ID.
+ *
+ * Returns 0 if successful, -EINVAL if not found, or -EDOM if its out of
+ * domain.
+ **/
+static int find_vctrl(int id)
+{
+	int i;
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = (ARRAY_SIZE(video_control) - 1); i >= 0; i--)
+		if (video_control[i].qc.id == id)
+			break;
+
+	if (i < 0)
+		i = -EINVAL;
+
+	return i;
+}
+
+/**
+ * find_next_vctrl - Return next v4l2 ctrl ID available after the specified ID
+ * @id: Reference V4L2 control ID.
+ *
+ * Returns 0 if successful, or -EINVAL if not found.
+ **/
+static int find_next_vctrl(int id)
+{
+	int i;
+	u32 best = (u32)-1;
+
+	for (i = 0; i < ARRAY_SIZE(video_control); i++) {
+		if (video_control[i].qc.id > id &&
+		    (best == (u32)-1 ||
+		     video_control[i].qc.id <
+		     video_control[best].qc.id)) {
+			best = i;
+		}
+	}
+
+	if (best == (u32)-1)
+		return -EINVAL;
+
+	return best;
+}
+
+/**
+ * find_vmenu - Return index of the menu array of the requested ctrl option.
+ * @id: Requested control ID.
+ * @index: Requested menu option index.
+ *
+ * Returns 0 if successful, -EINVAL if not found, or -EDOM if its out of
+ * domain.
+ **/
+static int find_vmenu(int id, int index)
+{
+	int i;
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = (ARRAY_SIZE(video_menu) - 1); i >= 0; i--) {
+		if (video_menu[i].id != id || video_menu[i].index != index)
+			continue;
+		return i;
+	}
+
+	return -EINVAL;
+}
+
+/**
+ * isp_release_resources - Free all currently requested ISP submodules.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_release_resources(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (isp->pipeline.modules & OMAP_ISP_CCDC)
+		ispccdc_free(&isp->isp_ccdc);
+
+	if (isp->pipeline.modules & OMAP_ISP_PREVIEW)
+		isppreview_free(&isp->isp_prev);
+
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER)
+		ispresizer_free(&isp->isp_res);
+	return;
+}
+
+/**
+ * isp_wait - Wait for idle or busy state transition with a time limit
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @busy: Function pointer which determines if submodule is busy.
+ * @wait_for_busy: If 0, waits for idle state, if 1, waits for busy state.
+ * @max_wait: Max retry count in us for wait for idle/busy transition.
+ * @priv: Function parameter to send to busy check function.
+ **/
+static int isp_wait(struct device *dev, int (*busy)(void *), int wait_for_busy,
+		    int max_wait, void *priv)
+{
+	int wait = 0;
+
+	if (max_wait == 0)
+		max_wait = 10000; /* 10 ms */
+
+	while ((wait_for_busy && !busy(priv))
+	       || (!wait_for_busy && busy(priv))) {
+		rmb();
+		udelay(1);
+		wait++;
+		if (wait > max_wait) {
+			dev_alert(dev, "%s: wait is too much\n", __func__);
+			return -EBUSY;
+		}
+	}
+	DPRINTK_ISPCTRL(KERN_ALERT "%s: wait %d\n", __func__, wait);
+
+	return 0;
+}
+
+/**
+ * ispccdc_sbl_wait_idle - Wrapper to wait for ccdc sbl status bits to be idle.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @max_wait: Max retry count for wait for idle transition of the CCDC SBL bits
+ **/
+static int ispccdc_sbl_wait_idle(struct isp_ccdc_device *isp_ccdc, int max_wait)
+{
+	return isp_wait(isp_ccdc->dev, ispccdc_sbl_busy, 0, max_wait, isp_ccdc);
+}
+
+/**
+ * isp_enable_interrupts - Enable ISP interrupts.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @is_raw: Determines if current pipeline ends in CCDC (!0) or Resizer (0)
+ **/
+static void isp_enable_interrupts(struct device *dev, int is_raw)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	u32 irq0enable;
+
+	irq0enable = IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ
+		| IRQ0ENABLE_HS_VS_IRQ
+		| IRQ0ENABLE_CCDC_VD0_IRQ | IRQ0ENABLE_CCDC_VD1_IRQ
+		| IRQ0ENABLE_CSIA_IRQ
+		| IRQ0ENABLE_CSIB_IRQ
+		| IRQ0ENABLE_H3A_AWB_DONE_IRQ | IRQ0ENABLE_H3A_AF_DONE_IRQ
+		| isp->interrupts;
+
+	if (!is_raw)
+		irq0enable |= IRQ0ENABLE_PRV_DONE_IRQ | IRQ0ENABLE_RSZ_DONE_IRQ;
+
+	isp_reg_writel(dev, -1, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+	isp_reg_writel(dev, irq0enable, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+
+	return;
+}
+
+/**
+ * isp_disable_interrupts - Disable all ISP interrupts.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_disable_interrupts(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (isp->bt656ifen == 0)
+		isp_reg_writel(dev, 0, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+	else
+		isp_reg_writel(dev, 0 | IRQ0ENABLE_RSZ_DONE_IRQ,
+				OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+}
+
+/**
+ * isp_set_callback - Set an external callback for an ISP interrupt.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @type: Type of the event for which callback is requested.
+ * @callback: Method to be called as callback in the ISR context.
+ * @arg1: First argument to be passed when callback is called in ISR.
+ * @arg2: Second argument to be passed when callback is called in ISR.
+ *
+ * This function sets a callback function for a done event in the ISP
+ * module, and enables the corresponding interrupt.
+ **/
+int isp_set_callback(struct device *dev, enum isp_callback_type type,
+		     isp_callback_t callback, isp_vbq_callback_ptr arg1,
+		     void *arg2)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	unsigned long irqflags = 0;
+
+	if (callback == NULL) {
+		DPRINTK_ISPCTRL("ISP_ERR : Null Callback\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&isp->lock, irqflags);
+	isp->irq.isp_callbk[type] = callback;
+	isp->irq.isp_callbk_arg1[type] = arg1;
+	isp->irq.isp_callbk_arg2[type] = arg2;
+	spin_unlock_irqrestore(&isp->lock, irqflags);
+
+	switch (type) {
+	case CBK_HIST_DONE:
+		isp->interrupts |= IRQ0ENABLE_HIST_DONE_IRQ;
+		if (isp->running != ISP_RUNNING)
+			break;
+		isp_reg_writel(dev, IRQ0ENABLE_HIST_DONE_IRQ,
+			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			   IRQ0ENABLE_HIST_DONE_IRQ);
+		break;
+	case CBK_PREV_DONE:
+		isp_reg_writel(dev, IRQ0ENABLE_PRV_DONE_IRQ,
+			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			   IRQ0ENABLE_PRV_DONE_IRQ);
+		break;
+	case CBK_RESZ_DONE:
+		isp_reg_writel(dev, IRQ0ENABLE_RSZ_DONE_IRQ,
+			       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+		isp_reg_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			   IRQ0ENABLE_RSZ_DONE_IRQ);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_set_callback);
+
+/**
+ * isp_unset_callback - Clears the callback for the ISP module done events.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @type: Type of the event for which callback to be cleared.
+ *
+ * This function clears a callback function for a done event in the ISP
+ * module, and disables the corresponding interrupt.
+ **/
+int isp_unset_callback(struct device *dev, enum isp_callback_type type)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&isp->lock, irqflags);
+	isp->irq.isp_callbk[type] = NULL;
+	isp->irq.isp_callbk_arg1[type] = NULL;
+	isp->irq.isp_callbk_arg2[type] = NULL;
+	spin_unlock_irqrestore(&isp->lock, irqflags);
+
+	switch (type) {
+	case CBK_HIST_DONE:
+		isp->interrupts &= ~IRQ0ENABLE_HIST_DONE_IRQ;
+		if (isp->running != ISP_RUNNING)
+			break;
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			    ~IRQ0ENABLE_HIST_DONE_IRQ);
+		break;
+	case CBK_PREV_DONE:
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			    ~IRQ0ENABLE_PRV_DONE_IRQ);
+		break;
+	case CBK_RESZ_DONE:
+		isp_reg_and(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE,
+			    ~IRQ0ENABLE_RSZ_DONE_IRQ);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_unset_callback);
+
+/**
+ * isp_set_xclk - Configures the specified cam_xclk to the desired frequency.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @xclk: Desired frequency of the clock in Hz.
+ * @xclksel: XCLK to configure (0 = A, 1 = B).
+ *
+ * Configures the specified MCLK divisor in the ISP timing control register
+ * (TCTRL_CTRL) to generate the desired xclk clock value.
+ *
+ * Divisor = CM_CAM_MCLK_HZ / xclk
+ *
+ * Returns the final frequency that is actually being generated
+ **/
+u32 isp_set_xclk(struct device *dev, u32 xclk, u8 xclksel)
+{
+	u32 divisor;
+	u32 currentxclk;
+
+	if (xclk >= CM_CAM_MCLK_HZ) {
+		divisor = ISPTCTRL_CTRL_DIV_BYPASS;
+		currentxclk = CM_CAM_MCLK_HZ;
+	} else if (xclk >= 2) {
+		divisor = CM_CAM_MCLK_HZ / xclk;
+		if (divisor >= ISPTCTRL_CTRL_DIV_BYPASS)
+			divisor = ISPTCTRL_CTRL_DIV_BYPASS - 1;
+		currentxclk = CM_CAM_MCLK_HZ / divisor;
+	} else {
+		divisor = xclk;
+		currentxclk = 0;
+	}
+
+	switch (xclksel) {
+	case 0:
+		isp_reg_and_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,
+			       ~ISPTCTRL_CTRL_DIVA_MASK,
+			       divisor << ISPTCTRL_CTRL_DIVA_SHIFT);
+		DPRINTK_ISPCTRL("isp_set_xclk(): cam_xclka set to %d Hz\n",
+				currentxclk);
+		break;
+	case 1:
+		isp_reg_and_or(dev, OMAP3_ISP_IOMEM_MAIN, ISP_TCTRL_CTRL,
+			       ~ISPTCTRL_CTRL_DIVB_MASK,
+			       divisor << ISPTCTRL_CTRL_DIVB_SHIFT);
+		DPRINTK_ISPCTRL("isp_set_xclk(): cam_xclkb set to %d Hz\n",
+				currentxclk);
+		break;
+	default:
+		DPRINTK_ISPCTRL("ISP_ERR: isp_set_xclk(): Invalid requested "
+				"xclk. Must be 0 (A) or 1 (B).\n");
+		return -EINVAL;
+	}
+
+	return currentxclk;
+}
+EXPORT_SYMBOL(isp_set_xclk);
+
+/**
+ * isp_power_settings - Sysconfig settings, for Power Management.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @idle: Consider idle state.
+ *
+ * Sets the power settings for the ISP, and SBL bus.
+ **/
+static void isp_power_settings(struct device *dev, int idle)
+{
+	if (idle) {
+		isp_reg_writel(dev, ISP_SYSCONFIG_AUTOIDLE |
+			       (ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY <<
+				ISP_SYSCONFIG_MIDLEMODE_SHIFT),
+			       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
+		if (!cpu_is_omap3630() && cpu_is_omap34xx() &&
+				omap_rev_is_1_0()) {
+			isp_reg_writel(dev, ISPCSI1_AUTOIDLE |
+				       (ISPCSI1_MIDLEMODE_SMARTSTANDBY <<
+					ISPCSI1_MIDLEMODE_SHIFT),
+				       OMAP3_ISP_IOMEM_CSI2A,
+				       ISP_CSIA_SYSCONFIG);
+			isp_reg_writel(dev, ISPCSI1_AUTOIDLE |
+				       (ISPCSI1_MIDLEMODE_SMARTSTANDBY <<
+					ISPCSI1_MIDLEMODE_SHIFT),
+				       OMAP3_ISP_IOMEM_CCP2,
+				       ISP_CSIB_SYSCONFIG);
+		}
+		isp_reg_writel(dev, ISPCTRL_SBL_AUTOIDLE, OMAP3_ISP_IOMEM_MAIN,
+			       ISP_CTRL);
+
+	} else {
+		isp_reg_writel(dev, ISP_SYSCONFIG_AUTOIDLE |
+			       (ISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY <<
+				ISP_SYSCONFIG_MIDLEMODE_SHIFT),
+			       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
+		if (!cpu_is_omap3630() && cpu_is_omap34xx() &&
+				omap_rev_is_1_0()) {
+			isp_reg_writel(dev, ISPCSI1_AUTOIDLE |
+				       (ISPCSI1_MIDLEMODE_FORCESTANDBY <<
+					ISPCSI1_MIDLEMODE_SHIFT),
+				       OMAP3_ISP_IOMEM_CSI2A,
+				       ISP_CSIA_SYSCONFIG);
+
+			isp_reg_writel(dev, ISPCSI1_AUTOIDLE |
+				       (ISPCSI1_MIDLEMODE_FORCESTANDBY <<
+					ISPCSI1_MIDLEMODE_SHIFT),
+				       OMAP3_ISP_IOMEM_CCP2,
+				       ISP_CSIB_SYSCONFIG);
+		}
+
+		isp_reg_writel(dev, ISPCTRL_SBL_AUTOIDLE, OMAP3_ISP_IOMEM_MAIN,
+			       ISP_CTRL);
+	}
+}
+
+#define BIT_SET(var, shift, mask, val)		\
+	do {					\
+		var = (var & ~(mask << shift))	\
+			| (val << shift);	\
+	} while (0)
+
+/**
+ * isp_csi_enable - Enable CSI1/CCP2 interface.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @enable: Enable flag.
+ **/
+static void isp_csi_enable(struct device *dev, u8 enable)
+{
+	isp_reg_and_or(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL,
+		       ~(BIT(0) | BIT(4)),
+		       enable ? (BIT(0) | BIT(4)) : 0);
+}
+
+/**
+ * isp_init_csi - Initialize CSI1/CCP2 interface.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @config: Pointer to ISP interface config structure.
+ *
+ * This will analize the parameters passed by the interface config
+ * structure, and configure the respective registers for proper CSI1/CCP2
+ * config.
+ *
+ * Returns -EINVAL if wrong format, -EIO if strobe is choosen in CSI1 mode, or
+ * 0 on success.
+ **/
+static int isp_init_csi(struct device *dev, struct isp_interface_config *config)
+{
+	u32 i = 0, val, reg;
+	int format;
+
+	switch (config->u.csi.format) {
+	case V4L2_PIX_FMT_SGRBG10:
+		format = 0x16;		/* RAW10+VP */
+		break;
+	case V4L2_PIX_FMT_SGRBG10DPCM8:
+		format = 0x12;		/* RAW8+DPCM10+VP */
+		break;
+	default:
+		dev_err(dev, "isp_init_csi: bad csi format\n");
+		return -EINVAL;
+	}
+
+	/* Reset the CSI and wait for reset to complete */
+	isp_reg_writel(dev, isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
+		       ISPCSI1_SYSCONFIG) | BIT(1),
+		       OMAP3_ISP_IOMEM_CCP2, ISPCSI1_SYSCONFIG);
+	while (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_SYSSTATUS) &
+		 BIT(0))) {
+		udelay(10);
+		if (i++ > 10)
+			break;
+	}
+	if (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_SYSSTATUS) &
+	      BIT(0))) {
+		dev_warn(dev,
+		       "omap3_isp: timeout waiting for csi reset\n");
+	}
+
+	/* ISPCSI1_CTRL */
+	val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL);
+	val &= ~BIT(11);	/* Enable VP only off ->
+				   extract embedded data to interconnect */
+	BIT_SET(val, 8, 0x3, config->u.csi.vpclk);	/* Video port clock */
+/*	val |= BIT(3);	*/	/* Wait for FEC before disabling interface */
+	val |= BIT(2);		/* I/O cell output is parallel
+				   (no effect, but errata says should be enabled
+				   for class 1/2) */
+	val |= BIT(12);		/* VP clock polarity to falling edge
+				   (needed or bad picture!) */
+
+	/* Data/strobe physical layer */
+	BIT_SET(val, 1, 1, config->u.csi.signalling);
+	BIT_SET(val, 10, 1, config->u.csi.strobe_clock_inv);
+	val |= BIT(4);		/* Magic bit to enable CSI1 and strobe mode */
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_CTRL);
+
+	/* ISPCSI1_LCx_CTRL logical channel #0 */
+	reg = ISPCSI1_LCx_CTRL(0);	/* reg = ISPCSI1_CTRL1; */
+	val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, reg);
+	/* Format = RAW10+VP or RAW8+DPCM10+VP*/
+	BIT_SET(val, 3, 0x1f, format);
+	/* Enable setting of frame regions of interest */
+	BIT_SET(val, 1, 1, 1);
+	BIT_SET(val, 2, 1, config->u.csi.crc);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, reg);
+
+	/* ISPCSI1_DAT_START for logical channel #0 */
+	reg = ISPCSI1_LCx_DAT_START(0);		/* reg = ISPCSI1_DAT_START; */
+	val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, reg);
+	BIT_SET(val, 16, 0xfff, config->u.csi.data_start);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, reg);
+
+	/* ISPCSI1_DAT_SIZE for logical channel #0 */
+	reg = ISPCSI1_LCx_DAT_SIZE(0);		/* reg = ISPCSI1_DAT_SIZE; */
+	val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2, reg);
+	BIT_SET(val, 16, 0xfff, config->u.csi.data_size);
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2, reg);
+
+	/* Clear status bits for logical channel #0 */
+	val = ISPCSI1_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_CRC_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FSP_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FW_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_FSC_IRQ |
+	      ISPCSI1_LC01_IRQSTATUS_LC0_SSC_IRQ;
+
+	/* Clear IRQ status bits for logical channel #0 */
+	isp_reg_writel(dev, val, OMAP3_ISP_IOMEM_CCP2,
+		       ISPCSI1_LC01_IRQSTATUS);
+
+	/* Enable IRQs for logical channel #0 */
+	isp_reg_or(dev, OMAP3_ISP_IOMEM_CCP2, ISPCSI1_LC01_IRQENABLE, val);
+
+	/* Enable CSI1 */
+	isp_csi_enable(dev, 1);
+
+	if (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
+			    ISPCSI1_CTRL) & BIT(4))) {
+		dev_warn(dev, "OMAP3 CSI1 bus not available\n");
+		if (config->u.csi.signalling) {
+			/* Strobe mode requires CCP2 */
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * isp_configure_interface - Configures ISP Control I/F related parameters.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @config: Pointer to structure containing the desired configuration for the
+ *          ISP.
+ *
+ * Configures ISP control register (ISP_CTRL) with the values specified inside
+ * the config structure. Controls:
+ * - Selection of parallel or serial input to the preview hardware.
+ * - Data lane shifter.
+ * - Pixel clock polarity.
+ * - 8 to 16-bit bridge at the input of CCDC module.
+ * - HS or VS synchronization signal detection
+ *
+ * Returns 0 on success, otherwise, will return other negative error value.
+ **/
+int isp_configure_interface(struct device *dev,
+			    struct isp_interface_config *config)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	u32 ispctrl_val = isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+	u32 fmtcfg;
+	int r;
+
+	isp->config = config;
+
+	ispctrl_val &= ISPCTRL_SHIFT_MASK;
+	ispctrl_val |= config->dataline_shift << ISPCTRL_SHIFT_SHIFT;
+	ispctrl_val &= ~ISPCTRL_PAR_CLK_POL_INV;
+
+	ispctrl_val &= ISPCTRL_PAR_SER_CLK_SEL_MASK;
+
+	isp_buf_init(dev);
+
+	switch (config->ccdc_par_ser) {
+	case ISP_PARLL:
+	case ISP_PARLL_YUV_BT:
+		ispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_PARALLEL;
+		ispctrl_val |= config->u.par.par_clk_pol
+			<< ISPCTRL_PAR_CLK_POL_SHIFT;
+		ispctrl_val &= ~ISPCTRL_PAR_BRIDGE_BENDIAN;
+		ispctrl_val |= config->u.par.par_bridge
+			<< ISPCTRL_PAR_BRIDGE_SHIFT;
+		if (config->ccdc_par_ser == ISP_PARLL_YUV_BT)
+			isp->bt656ifen = 1;
+		break;
+	case ISP_CSIA:
+		ispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIA;
+		ispctrl_val &= ~ISPCTRL_PAR_BRIDGE_BENDIAN;
+
+		if (config->u.csi.crc)
+			isp_csi2_ctrl_config_ecc_enable(true);
+
+		isp_csi2_ctrl_config_vp_out_ctrl(config->u.csi.vpclk);
+		isp_csi2_ctrl_config_vp_only_enable(true);
+		isp_csi2_ctrl_config_vp_clk_enable(true);
+		isp_csi2_ctrl_update(false);
+
+		isp_csi2_ctx_config_format(0, config->u.csi.format);
+		isp_csi2_ctx_update(0, false);
+
+		isp_csi2_irq_complexio1_set(1);
+		isp_csi2_irq_status_set(1);
+
+		isp_csi2_enable(1);
+		mdelay(3);
+		break;
+	case ISP_CSIB:
+		ispctrl_val |= ISPCTRL_PAR_SER_CLK_SEL_CSIB;
+		r = isp_init_csi(dev, config);
+		if (r)
+			return r;
+		break;
+	case ISP_NONE:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
+	ispctrl_val &= ~ISPCTRL_SYNC_DETECT_VSRISE;
+	ispctrl_val |= config->hsvs_syncdetect;
+
+	isp_reg_writel(dev, ispctrl_val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+
+	/* Set sensor specific fields in CCDC and Previewer module. */
+	ispccdc_set_wenlog(&isp->isp_ccdc, config->wenlog);
+
+	/* FIXME: this should be set in ispccdc_config_vp() */
+	fmtcfg = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
+	fmtcfg &= ISPCCDC_FMTCFG_VPIF_FRQ_MASK;
+	if (config->pixelclk) {
+		unsigned long l3_ick = clk_get_rate(isp->l3_ick);
+		unsigned long div = l3_ick / config->pixelclk;
+		if (div < 2)
+			div = 2;
+		if (div > 6)
+			div = 6;
+		fmtcfg |= (div - 2) << ISPCCDC_FMTCFG_VPIF_FRQ_SHIFT;
+	}
+	isp_reg_writel(dev, fmtcfg, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG);
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_configure_interface);
+
+static int isp_buf_process(struct device *dev, struct isp_bufs *bufs);
+
+/**
+ * omap34xx_isp_isr - Interrupt Service Routine for Camera ISP module.
+ * @irq: Not used currently.
+ * @_pdev: Pointer to the platform device associated with the OMAP3 ISP.
+ *
+ * Returns IRQ_HANDLED when IRQ was correctly handled, or IRQ_NONE when the
+ * IRQ wasn't handled.
+ **/
+static irqreturn_t omap34xx_isp_isr(int irq, void *_pdev)
+{
+	struct device *dev = &((struct platform_device *)_pdev)->dev;
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_irq *irqdis = &isp->irq;
+	struct isp_bufs *bufs = &isp->bufs;
+	unsigned long flags;
+	u32 irqstatus = 0;
+	u32 sbl_pcr;
+	unsigned long irqflags = 0;
+	int wait_hs_vs = 0;
+	u8 fld_stat;
+
+	if (isp->running == ISP_STOPPED) {
+		dev_err(dev, "ouch %8.8x!\n", isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS));
+		return IRQ_NONE;
+	}
+
+	irqstatus = isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+	isp_reg_writel(dev, irqstatus, OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS);
+
+	if (isp->running == ISP_STOPPING)
+		return IRQ_HANDLED;
+
+	spin_lock_irqsave(&bufs->lock, flags);
+	wait_hs_vs = bufs->wait_hs_vs;
+	if (irqstatus & HS_VS) {
+		if (bufs->wait_hs_vs) {
+			bufs->wait_hs_vs--;
+		} else {
+			if (isp->pipeline.pix.field == V4L2_FIELD_INTERLACED) {
+				fld_stat = (isp_reg_readl(dev,
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_SYN_MODE) &
+					ISPCCDC_SYN_MODE_FLDSTAT) ? 1 :	0;
+				isp->current_field = fld_stat;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&bufs->lock, flags);
+
+	spin_lock_irqsave(&isp->lock, irqflags);
+
+	if (irqstatus & RESZ_DONE) {
+		if (irqdis->isp_callbk[CBK_RESZ_DONE])
+			irqdis->isp_callbk[CBK_RESZ_DONE](
+				RESZ_DONE,
+				irqdis->isp_callbk_arg1[CBK_RESZ_DONE],
+				irqdis->isp_callbk_arg2[CBK_RESZ_DONE]);
+		else if (!RAW_CAPTURE(isp)) {
+			ispresizer_config_shadow_registers(&isp->isp_res);
+			isp_buf_process(dev, bufs);
+		}
+	}
+	/*
+	 * We need to wait for the first HS_VS interrupt from CCDC.
+	 * Otherwise our frame (and everything else) might be bad.
+	 */
+	switch (wait_hs_vs) {
+	case 1:
+		/*
+		 * Enable preview for the first time. We just have
+		 * missed the start-of-frame so we can do it now.
+		 */
+		if (irqstatus & HS_VS && !RAW_CAPTURE(isp))
+			isppreview_enable(&isp->isp_prev);
+	default:
+		goto out_ignore_buff;
+	case 0:
+		break;
+	}
+
+	if (irqstatus & CCDC_VD0) {
+		if (isp->pipeline.pix.field == V4L2_FIELD_INTERLACED) {
+			/* Skip even fields, and process only odd fields */
+			if (isp->current_field != 0)
+				if (RAW_CAPTURE(isp))
+					isp_buf_process(dev, bufs);
+		}
+		if (!ispccdc_busy(&isp->isp_ccdc))
+			ispccdc_config_shadow_registers(&isp->isp_ccdc);
+	}
+
+	if (irqstatus & PREV_DONE) {
+		if (irqdis->isp_callbk[CBK_PREV_DONE])
+			irqdis->isp_callbk[CBK_PREV_DONE](
+				PREV_DONE,
+				irqdis->isp_callbk_arg1[CBK_PREV_DONE],
+				irqdis->isp_callbk_arg2[CBK_PREV_DONE]);
+		else if (!RAW_CAPTURE(isp)) {
+			if (ispresizer_busy(&isp->isp_res)) {
+				ISP_BUF_DONE(bufs)->vb_state =
+					VIDEOBUF_ERROR;
+				dev_err(dev, "%s: resizer busy!\n", __func__);
+			} else {
+				ispresizer_enable(&isp->isp_res, 1);
+			}
+			isppreview_config_shadow_registers(&isp->isp_prev);
+			isppreview_enable(&isp->isp_prev);
+		}
+	}
+
+	if (irqstatus & H3A_AWB_DONE)
+		isph3a_aewb_isr(&isp->isp_h3a);
+
+	if (irqstatus & HIST_DONE) {
+		if (irqdis->isp_callbk[CBK_HIST_DONE])
+			irqdis->isp_callbk[CBK_HIST_DONE](
+				HIST_DONE,
+				irqdis->isp_callbk_arg1[CBK_HIST_DONE],
+				irqdis->isp_callbk_arg2[CBK_HIST_DONE]);
+	}
+
+	if (irqstatus & H3A_AF_DONE)
+		isp_af_isr(&isp->isp_af);
+
+	/* Handle shared buffer logic overflows for video buffers. */
+	/* ISPSBL_PCR_CCDCPRV_2_RSZ_OVF can be safely ignored. */
+	sbl_pcr = isp_reg_readl(dev, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR) &
+		~ISPSBL_PCR_CCDCPRV_2_RSZ_OVF;
+	isp_reg_writel(dev, sbl_pcr, OMAP3_ISP_IOMEM_SBL, ISPSBL_PCR);
+	if (sbl_pcr & (ISPSBL_PCR_RSZ1_WBL_OVF
+		       | ISPSBL_PCR_RSZ2_WBL_OVF
+		       | ISPSBL_PCR_RSZ3_WBL_OVF
+		       | ISPSBL_PCR_RSZ4_WBL_OVF
+		       | ISPSBL_PCR_PRV_WBL_OVF
+		       | ISPSBL_PCR_CCDC_WBL_OVF
+		       | ISPSBL_PCR_CSIA_WBL_OVF
+		       | ISPSBL_PCR_CSIB_WBL_OVF)) {
+		struct isp_buf *buf = ISP_BUF_DONE(bufs);
+		buf->vb_state = VIDEOBUF_ERROR;
+		dev_info(dev, "%s: sbl overflow, sbl_pcr = %8.8x\n",
+		       __func__, sbl_pcr);
+	}
+
+out_ignore_buff:
+	if (irqstatus & LSC_PRE_ERR) {
+		struct isp_buf *buf = ISP_BUF_DONE(bufs);
+		/* Mark buffer faulty. */
+		buf->vb_state = VIDEOBUF_ERROR;
+		ispccdc_lsc_error_handler(&isp->isp_ccdc);
+		dev_err(dev, "%s: lsc prefetch error\n", __func__);
+	}
+
+	if (irqstatus & CSIA) {
+		struct isp_buf *buf = ISP_BUF_DONE(bufs);
+		int ret = isp_csi2_isr();
+		if (ret)
+			buf->vb_state = VIDEOBUF_ERROR;
+	}
+
+	if (irqstatus & IRQ0STATUS_CSIB_IRQ) {
+		struct isp_buf *buf = ISP_BUF_DONE(bufs);
+		u32 ispcsi1_irqstatus;
+
+		ispcsi1_irqstatus = isp_reg_readl(dev, OMAP3_ISP_IOMEM_CCP2,
+						  ISPCSI1_LC01_IRQSTATUS);
+		isp_reg_writel(dev, ispcsi1_irqstatus, OMAP3_ISP_IOMEM_CCP2,
+			       ISPCSI1_LC01_IRQSTATUS);
+		buf->vb_state = VIDEOBUF_ERROR;
+		dev_err(dev, "CCP2 err:%x\n", ispcsi1_irqstatus);
+	}
+
+	if (irqdis->isp_callbk[CBK_CATCHALL]) {
+		irqdis->isp_callbk[CBK_CATCHALL](
+			irqstatus,
+			irqdis->isp_callbk_arg1[CBK_CATCHALL],
+			irqdis->isp_callbk_arg2[CBK_CATCHALL]);
+	}
+
+	spin_unlock_irqrestore(&isp->lock, irqflags);
+
+	isp_flush(dev);
+
+#if 1
+	{
+		static const struct {
+			int num;
+			char *name;
+		} bits[] = {
+			{ 31, "HS_VS_IRQ" },
+			{ 30, "SEC_ERR_IRQ" },
+			{ 29, "OCP_ERR_IRQ" },
+			{ 28, "MMU_ERR_IRQ" },
+			{ 27, "res27" },
+			{ 26, "res26" },
+			{ 25, "OVF_IRQ" },
+			{ 24, "RSZ_DONE_IRQ" },
+			{ 23, "res23" },
+			{ 22, "res22" },
+			{ 21, "CBUFF_IRQ" },
+			{ 20, "PRV_DONE_IRQ" },
+			{ 19, "CCDC_LSC_PREFETCH_ERROR" },
+			{ 18, "CCDC_LSC_PREFETCH_COMPLETED" },
+			{ 17, "CCDC_LSC_DONE" },
+			{ 16, "HIST_DONE_IRQ" },
+			{ 15, "res15" },
+			{ 14, "res14" },
+			{ 13, "H3A_AWB_DONE_IRQ" },
+			{ 12, "H3A_AF_DONE_IRQ" },
+			{ 11, "CCDC_ERR_IRQ" },
+			{ 10, "CCDC_VD2_IRQ" },
+			{  9, "CCDC_VD1_IRQ" },
+			{  8, "CCDC_VD0_IRQ" },
+			{  7, "res7" },
+			{  6, "res6" },
+			{  5, "res5" },
+			{  4, "CSIB_IRQ" },
+			{  3, "CSIB_LCM_IRQ" },
+			{  2, "res2" },
+			{  1, "res1" },
+			{  0, "CSIA_IRQ" },
+		};
+		int i;
+		for (i = 0; i < ARRAY_SIZE(bits); i++) {
+			if ((1 << bits[i].num) & irqstatus)
+				DPRINTK_ISPCTRL("%s ", bits[i].name);
+		}
+		DPRINTK_ISPCTRL("\n");
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+
+/* Device name, needed for resource tracking layer */
+struct device_driver camera_drv = {
+	.name = "camera"
+};
+
+struct device camera_dev = {
+	.driver = &camera_drv,
+};
+
+/**
+ * isp_tmp_buf_free - Free buffer for CCDC->PRV->RSZ datapath workaround.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_tmp_buf_free(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (isp->tmp_buf) {
+		iommu_vfree(isp->iommu, isp->tmp_buf);
+		isp->tmp_buf = 0;
+		isp->tmp_buf_size = 0;
+	}
+}
+
+/**
+ * isp_tmp_buf_alloc - Allocate buffer for CCDC->PRV->RSZ datapath workaround.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @size: Byte size of the buffer to allocate
+ *
+ * Returns 0 if successful, or -ENOMEM if there's no available memory.
+ **/
+static u32 isp_tmp_buf_alloc(struct device *dev, size_t size)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	u32 da;
+
+	isp_tmp_buf_free(dev);
+
+	dev_dbg(dev, "%s: allocating %d bytes\n", __func__, size);
+
+	da = iommu_vmalloc(isp->iommu, 0, size, IOMMU_FLAG);
+	if (IS_ERR_VALUE(da)) {
+		dev_err(dev, "iommu_vmap mapping failed ");
+		return -ENOMEM;
+	}
+	isp->tmp_buf = da;
+	isp->tmp_buf_size = size;
+
+	isppreview_set_outaddr(&isp->isp_prev, isp->tmp_buf);
+	ispresizer_set_inaddr(&isp->isp_res, isp->tmp_buf);
+
+	return 0;
+}
+
+/**
+ * isp_start - Set ISP in running state
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void isp_start(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp->running = ISP_RUNNING;
+
+	return;
+}
+EXPORT_SYMBOL(isp_start);
+
+#define ISP_STATISTICS_BUSY			\
+	()
+#define ISP_STOP_TIMEOUT	msecs_to_jiffies(1000)
+
+/**
+ * __isp_disable_modules - Disable ISP submodules with a timeout to be idle.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @suspend: If 0, disable modules; if 1, send modules to suspend state.
+ *
+ * Returns 0 if stop/suspend left in idle state all the submodules properly,
+ * or returns 1 if a general Reset is required to stop/suspend the submodules.
+ **/
+static int __isp_disable_modules(struct device *dev, int suspend)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	unsigned long timeout = jiffies + ISP_STOP_TIMEOUT;
+	int reset = 0;
+
+	/*
+	 * We need to stop all the modules after CCDC first or they'll
+	 * never stop since they may not get a full frame from CCDC.
+	 */
+	if (suspend) {
+		isp_af_suspend(&isp->isp_af);
+		isph3a_aewb_suspend(&isp->isp_h3a);
+		isp_hist_suspend(&isp->isp_hist);
+	} else {
+		isp_af_enable(&isp->isp_af, 0);
+		isph3a_aewb_enable(&isp->isp_h3a, 0);
+		isp_hist_enable(&isp->isp_hist, 0);
+	}
+	ispresizer_enable(&isp->isp_res, 0);
+
+	timeout = jiffies + ISP_STOP_TIMEOUT;
+	while (isp_af_busy(&isp->isp_af)
+	       || isph3a_aewb_busy(&isp->isp_h3a)
+	       || isp_hist_busy(&isp->isp_hist)
+	       || isppreview_busy(&isp->isp_prev)
+	       || ispresizer_busy(&isp->isp_res)) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(dev, "%s: can't stop non-ccdc modules\n",
+			       __func__);
+			reset = 1;
+			break;
+		}
+		msleep(1);
+	}
+
+	/* Let's stop CCDC now. */
+	ispccdc_enable(&isp->isp_ccdc, 0);
+
+	timeout = jiffies + ISP_STOP_TIMEOUT;
+	while (ispccdc_busy(&isp->isp_ccdc)) {
+		if (time_after(jiffies, timeout)) {
+			dev_err(dev, "%s: can't stop ccdc\n", __func__);
+			reset = 1;
+			break;
+		}
+		msleep(1);
+	}
+
+	isp_csi_enable(dev, 0);
+	isp_csi2_enable(0);
+	isp_buf_init(dev);
+
+	return reset;
+}
+
+/**
+ * isp_stop_modules - Stop ISP submodules.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Returns 0 if stop left in idle state all the submodules properly,
+ * or returns 1 if a general Reset is required to stop the submodules.
+ **/
+static int isp_stop_modules(struct device *dev)
+{
+	return __isp_disable_modules(dev, 0);
+}
+
+#ifdef CONFIG_PM
+/**
+ * isp_suspend_modules - Suspend ISP submodules.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Returns 0 if suspend left in idle state all the submodules properly,
+ * or returns 1 if a general Reset is required to suspend the submodules.
+ **/
+static int isp_suspend_modules(struct device *dev)
+{
+	return __isp_disable_modules(dev, 1);
+}
+
+/**
+ * isp_resume_modules - Resume ISP submodules.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_resume_modules(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp_hist_resume(&isp->isp_hist);
+	isph3a_aewb_resume(&isp->isp_h3a);
+	isp_af_resume(&isp->isp_af);
+}
+#endif	/* CONFIG_PM */
+
+/**
+ * isp_reset - Reset ISP with a timeout wait for idle.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_reset(struct device *dev)
+{
+	unsigned long timeout = 0;
+
+	isp_reg_writel(dev,
+		       isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG)
+		       | ISP_SYSCONFIG_SOFTRESET,
+		       OMAP3_ISP_IOMEM_MAIN, ISP_SYSCONFIG);
+	while (!(isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+			       ISP_SYSSTATUS) & 0x1)) {
+		if (timeout++ > 10000) {
+			dev_alert(dev, "%s: cannot reset ISP\n", __func__);
+			break;
+		}
+		udelay(1);
+	}
+}
+
+/**
+ * isp_stop - Stop ISP.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void isp_stop(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int reset;
+
+	isp->running = ISP_STOPPING;
+	isp_disable_interrupts(dev);
+	synchronize_irq(((struct isp_device *)dev_get_drvdata(dev))->irq_num);
+	isp->running = ISP_STOPPED;
+	reset = isp_stop_modules(dev);
+	if (!reset)
+		return;
+
+	isp_save_ctx(dev);
+	isp_reset(dev);
+	isp_restore_ctx(dev);
+}
+EXPORT_SYMBOL(isp_stop);
+
+/**
+ * isp_set_buf - Program output buffer address based on current pipeline.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @buf: Pointer to ISP buffer structure.
+ **/
+static void isp_set_buf(struct device *dev, struct isp_buf *buf)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER
+	    && is_ispresizer_enabled())
+		ispresizer_set_outaddr(&isp->isp_res, buf->isp_addr);
+	else if (isp->pipeline.modules & OMAP_ISP_CCDC)
+		ispccdc_set_outaddr(&isp->isp_ccdc, buf->isp_addr);
+
+}
+
+/**
+ * isp_try_pipeline - Retrieve and simulate resulting internal ISP pipeline.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @pix_input: Pointer to pixel format to use as input in the ISP.
+ * @pipe: Pointer to ISP pipeline structure to fill back.
+ *
+ * Returns the closest possible output size based on silicon limitations
+ * detailed through the pipe structure.
+ *
+ * If the input can't be read, it'll return -EINVAL. Returns 0 on success.
+ **/
+static int isp_try_pipeline(struct device *dev,
+			    struct v4l2_pix_format *pix_input,
+			    struct isp_pipeline *pipe)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct v4l2_pix_format *pix_output = &pipe->pix;
+	unsigned int wanted_width = pix_output->width;
+	unsigned int wanted_height = pix_output->height;
+	int ifmt;
+	int rval;
+
+	if ((pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10 ||
+	     pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8 ||
+	     pix_input->pixelformat == V4L2_PIX_FMT_SRGGB10 ||
+	     pix_input->pixelformat == V4L2_PIX_FMT_SBGGR10 ||
+	     pix_input->pixelformat == V4L2_PIX_FMT_SGBRG10) &&
+	    (pix_output->pixelformat == V4L2_PIX_FMT_YUYV ||
+	     pix_output->pixelformat == V4L2_PIX_FMT_UYVY)) {
+		pipe->modules = OMAP_ISP_CCDC | OMAP_ISP_PREVIEW
+			| OMAP_ISP_RESIZER;
+		if (pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10 ||
+		    pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8)
+			pipe->ccdc_in = CCDC_RAW_GRBG;
+		if (pix_input->pixelformat == V4L2_PIX_FMT_SRGGB10)
+			pipe->ccdc_in = CCDC_RAW_RGGB;
+		if (pix_input->pixelformat == V4L2_PIX_FMT_SBGGR10)
+			pipe->ccdc_in = CCDC_RAW_BGGR;
+		if (pix_input->pixelformat == V4L2_PIX_FMT_SGBRG10)
+			pipe->ccdc_in = CCDC_RAW_GBRG;
+		pipe->ccdc_out = CCDC_OTHERS_VP;
+		pipe->prv_in = PRV_RAW_CCDC;
+		pipe->prv_out = PREVIEW_MEM;
+		pipe->rsz_in = RSZ_MEM_YUV;
+	} else {
+		pipe->modules = OMAP_ISP_CCDC;
+		if (pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10 ||
+		    pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8 ||
+		    pix_input->pixelformat == V4L2_PIX_FMT_SRGGB10 ||
+		    pix_input->pixelformat == V4L2_PIX_FMT_SBGGR10 ||
+		    pix_input->pixelformat == V4L2_PIX_FMT_SGBRG10) {
+			pipe->ccdc_out = CCDC_OTHERS_VP_MEM;
+			if (pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10 ||
+			    pix_input->pixelformat == V4L2_PIX_FMT_SGRBG10DPCM8)
+				pipe->ccdc_in = CCDC_RAW_GRBG;
+			if (pix_input->pixelformat == V4L2_PIX_FMT_SRGGB10)
+				pipe->ccdc_in = CCDC_RAW_RGGB;
+			if (pix_input->pixelformat == V4L2_PIX_FMT_SBGGR10)
+				pipe->ccdc_in = CCDC_RAW_BGGR;
+			if (pix_input->pixelformat == V4L2_PIX_FMT_SGBRG10)
+				pipe->ccdc_in = CCDC_RAW_GBRG;
+		} else if (pix_input->pixelformat == V4L2_PIX_FMT_YUYV ||
+			   pix_input->pixelformat == V4L2_PIX_FMT_UYVY) {
+			if (isp->bt656ifen)
+				pipe->ccdc_in = CCDC_YUV_BT;
+			else
+				pipe->ccdc_in = CCDC_YUV_SYNC;
+			pipe->ccdc_out = CCDC_OTHERS_MEM;
+		} else
+			return -EINVAL;
+	}
+
+	if (pipe->modules & OMAP_ISP_CCDC) {
+		pipe->ccdc_in_w = pix_input->width;
+		pipe->ccdc_in_h = pix_input->height;
+		rval = ispccdc_try_pipeline(&isp->isp_ccdc, pipe);
+		if (rval) {
+			dev_err(dev, "the dimensions %dx%d are not"
+			       " supported\n", pix_input->width,
+			       pix_input->height);
+			return rval;
+		}
+		pix_output->width = pipe->ccdc_out_w_img;
+		pix_output->height = pipe->ccdc_out_h;
+		pix_output->bytesperline =
+			pipe->ccdc_out_w * ISP_BYTES_PER_PIXEL;
+	}
+
+	if (pipe->modules & OMAP_ISP_PREVIEW) {
+		rval = isppreview_try_pipeline(&isp->isp_prev, pipe);
+		if (rval) {
+			dev_err(dev, "the dimensions %dx%d are not"
+			       " supported\n", pix_input->width,
+			       pix_input->height);
+			return rval;
+		}
+		pix_output->width = pipe->prv_out_w;
+		pix_output->height = pipe->prv_out_h;
+	}
+
+	if (pipe->modules & OMAP_ISP_RESIZER) {
+		pipe->rsz_out_w = wanted_width;
+		pipe->rsz_out_h = wanted_height;
+
+		pipe->rsz_crop.left = pipe->rsz_crop.top = 0;
+		pipe->rsz_crop.width = pipe->prv_out_w_img;
+		pipe->rsz_crop.height = pipe->prv_out_h_img;
+
+		rval = ispresizer_try_pipeline(&isp->isp_res, pipe);
+		if (rval) {
+			dev_err(dev, "The dimensions %dx%d are not"
+			       " supported\n", pix_input->width,
+			       pix_input->height);
+			return rval;
+		}
+
+		pix_output->width = pipe->rsz_out_w;
+		pix_output->height = pipe->rsz_out_h;
+		pix_output->bytesperline =
+			pipe->rsz_out_w * ISP_BYTES_PER_PIXEL;
+	}
+
+	if (isp->bt656ifen)
+		pix_output->field = pix_input->field;
+	else {
+		pix_output->field = V4L2_FIELD_NONE;
+		pix_output->sizeimage =
+			PAGE_ALIGN(pix_output->bytesperline *
+					pix_output->height);
+	}
+	pix_output->priv = 0;
+
+	for (ifmt = 0; ifmt < NUM_ISP_CAPTURE_FORMATS; ifmt++) {
+		if (pix_output->pixelformat == isp_formats[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == NUM_ISP_CAPTURE_FORMATS)
+		pix_output->pixelformat = V4L2_PIX_FMT_YUYV;
+
+	switch (pix_output->pixelformat) {
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		if (isp->bt656ifen)
+			pix_output->colorspace = pix_input->colorspace;
+		else
+			pix_output->colorspace = V4L2_COLORSPACE_JPEG;
+		break;
+	default:
+		pix_output->colorspace = V4L2_COLORSPACE_SRGB;
+	}
+
+	return 0;
+}
+
+/**
+ * isp_s_pipeline - Configure internal ISP pipeline.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @pix_input: Pointer to pixel format to use as input in the ISP.
+ * @pix_output: Pointer to pixel format to use as output in the ISP.
+ *
+ * Returns the closest possible output size based on silicon limitations.
+ *
+ * If the input can't be read, it'll return -EINVAL. Returns 0 on success.
+ **/
+static int isp_s_pipeline(struct device *dev,
+			  struct v4l2_pix_format *pix_input,
+			  struct v4l2_pix_format *pix_output)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_pipeline pipe;
+	int rval;
+
+	isp_release_resources(dev);
+
+	pipe.pix = *pix_output;
+
+	rval = isp_try_pipeline(dev, pix_input, &pipe);
+	if (rval)
+		return rval;
+
+	ispccdc_request(&isp->isp_ccdc);
+	ispccdc_s_pipeline(&isp->isp_ccdc, &pipe);
+
+	if (pix_input->pixelformat == V4L2_PIX_FMT_UYVY)
+		ispccdc_config_y8pos(&isp->isp_ccdc, Y8POS_ODD);
+	else if (pix_input->pixelformat == V4L2_PIX_FMT_YUYV)
+		ispccdc_config_y8pos(&isp->isp_ccdc, Y8POS_EVEN);
+
+	if (((pix_input->pixelformat == V4L2_PIX_FMT_UYVY) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_UYVY))	||
+			((pix_input->pixelformat == V4L2_PIX_FMT_YUYV) &&
+			 (pix_output->pixelformat == V4L2_PIX_FMT_YUYV)))
+		/* input and output formats are in same order */
+		ispccdc_config_byteswap(&isp->isp_ccdc, 0);
+	else if (((pix_input->pixelformat == V4L2_PIX_FMT_YUYV) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_UYVY)) ||
+			((pix_input->pixelformat == V4L2_PIX_FMT_UYVY) &&
+			(pix_output->pixelformat == V4L2_PIX_FMT_YUYV)))
+		/* input and output formats are in reverse order */
+		ispccdc_config_byteswap(&isp->isp_ccdc, 1);
+	/*
+	 * Configure Pitch - This enables application to use a
+	 * different pitch
+	 * other than active pixels per line.
+	 */
+	if (isp->bt656ifen)
+		ispccdc_config_outlineoffset(&isp->isp_ccdc,
+				pipe.pix.bytesperline, 0, 0);
+	if (pipe.modules & OMAP_ISP_PREVIEW) {
+		isppreview_request(&isp->isp_prev);
+		isppreview_s_pipeline(&isp->isp_prev, &pipe);
+	}
+
+	if (pipe.modules & OMAP_ISP_RESIZER) {
+		ispresizer_request(&isp->isp_res);
+		ispresizer_s_pipeline(&isp->isp_res, &pipe);
+	}
+
+	isp->pipeline = pipe;
+	*pix_output = isp->pipeline.pix;
+
+	return 0;
+}
+
+/**
+ * isp_vbq_sync - Flush the entire cache
+ * @vb: Videobuffer to sync. (Not used)
+ * @when: (Not used)
+ *
+ * FIXME: This impacts the performance on the other systems when camera is
+ * running, but seems to be needed to ensure coherency of DMA transfers
+ * somehow. Investigation ongoing...
+ **/
+static int isp_vbq_sync(struct videobuf_buffer *vb, int when)
+{
+	flush_cache_all();
+
+	return 0;
+}
+
+/**
+ * isp_buf_init - Initialize the internal buffer queue handling.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_buf_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_bufs *bufs = &isp->bufs;
+	int sg;
+
+	bufs->queue = 0;
+	bufs->done = 0;
+	bufs->wait_hs_vs = isp->config->wait_hs_vs;
+	for (sg = 0; sg < NUM_BUFS; sg++) {
+		if (bufs->buf[sg].vb) {
+			isp_vbq_sync(bufs->buf[sg].vb, DMA_FROM_DEVICE);
+			bufs->buf[sg].vb->state = VIDEOBUF_ERROR;
+			bufs->buf[sg].complete(bufs->buf[sg].vb,
+					       bufs->buf[sg].priv);
+		}
+		bufs->buf[sg].complete = NULL;
+		bufs->buf[sg].vb = NULL;
+		bufs->buf[sg].priv = NULL;
+	}
+}
+
+/**
+ * isp_buf_process - Do final handling when a buffer has been processed.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @bufs: Pointer to ISP buffer handling structure.
+ *
+ * Updates the pointers accordingly depending of the internal pipeline.
+ **/
+static int isp_buf_process(struct device *dev, struct isp_bufs *bufs)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_buf *buf = NULL;
+	unsigned long flags;
+	int last;
+
+	spin_lock_irqsave(&bufs->lock, flags);
+
+	if (ISP_BUFS_IS_EMPTY(bufs))
+		goto out;
+
+	if (RAW_CAPTURE(isp) && ispccdc_sbl_wait_idle(&isp->isp_ccdc, 1000)) {
+		dev_err(dev, "ccdc %d won't become idle!\n",
+		       RAW_CAPTURE(isp));
+		goto out;
+	}
+
+	/* We had at least one buffer in queue. */
+	buf = ISP_BUF_DONE(bufs);
+	last = ISP_BUFS_IS_LAST(bufs);
+
+	if (!last) {
+		/* Set new buffer address. */
+		isp_set_buf(dev, ISP_BUF_NEXT_DONE(bufs));
+	} else {
+		/* Tell ISP not to write any of our buffers. */
+		isp_disable_interrupts(dev);
+		if (RAW_CAPTURE(isp))
+			ispccdc_enable(&isp->isp_ccdc, 0);
+		else if (isp->bt656ifen == 0)
+			ispresizer_enable(&isp->isp_res, 0);
+		/*
+		 * We must wait for the HS_VS since before that the
+		 * CCDC may trigger interrupts even if it's not
+		 * receiving a frame.
+		 */
+		bufs->wait_hs_vs = isp->config->wait_hs_vs;
+	}
+	if ((RAW_CAPTURE(isp) && ispccdc_busy(&isp->isp_ccdc))
+	    || (!RAW_CAPTURE(isp) && ispresizer_busy(&isp->isp_res))) {
+		/*
+		 * Next buffer available: for the transfer to succeed, the
+		 * CCDC (RAW capture) or resizer (YUV capture) must be idle
+		 * for the duration of transfer setup. Bad things happen
+		 * otherwise!
+		 *
+		 * Next buffer not available: if we fail to stop the
+		 * ISP the buffer is probably going to be bad.
+		 */
+		/* Mark this buffer faulty. */
+		buf->vb_state = VIDEOBUF_ERROR;
+		/* Mark next faulty, too, in case we have one. */
+		if (!last) {
+			ISP_BUF_NEXT_DONE(bufs)->vb_state = VIDEOBUF_ERROR;
+			dev_alert(dev, "OUCH!!!\n");
+		} else {
+			dev_alert(dev, "Ouch!\n");
+		}
+	}
+
+	/* Mark the current buffer as done. */
+	ISP_BUF_MARK_DONE(bufs);
+
+	DPRINTK_ISPCTRL(KERN_ALERT "%s: finish %d mmu %p\n", __func__,
+			(bufs->done - 1 + NUM_BUFS) % NUM_BUFS,
+			(bufs->buf+((bufs->done - 1 + NUM_BUFS)
+				    % NUM_BUFS))->isp_addr);
+
+out:
+	spin_unlock_irqrestore(&bufs->lock, flags);
+
+	if (buf && buf->vb) {
+		/*
+		 * We want to dequeue a buffer from the video buffer
+		 * queue. Let's do it!
+		 */
+		isp_vbq_sync(buf->vb, DMA_FROM_DEVICE);
+		buf->vb->state = buf->vb_state;
+		buf->complete(buf->vb, buf->priv);
+		buf->vb = NULL;
+	}
+
+	return 0;
+}
+
+/**
+ * isp_buf_queue - Queue a buffer into the internal ISP queue list.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @vb: Pointer to video buffer to queue.
+ * @complete: Pointer to function to call when buffer is completely processed.
+ * @priv: Pointer to private paramemter to send to complete function.
+ *
+ * Always returns 0.
+ **/
+int isp_buf_queue(struct device *dev, struct videobuf_buffer *vb,
+		  void (*complete)(struct videobuf_buffer *vb, void *priv),
+		  void *priv)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	unsigned long flags;
+	struct isp_buf *buf;
+	struct videobuf_dmabuf *dma = videobuf_to_dma(vb);
+	const struct scatterlist *sglist = dma->sglist;
+	struct isp_bufs *bufs = &isp->bufs;
+	int sglen = dma->sglen;
+
+	if (isp->running != ISP_RUNNING) {
+		vb->state = VIDEOBUF_ERROR;
+		complete(vb, priv);
+
+		return 0;
+	}
+
+	BUG_ON(sglen < 0 || !sglist);
+
+	isp_vbq_sync(vb, DMA_TO_DEVICE);
+
+	spin_lock_irqsave(&bufs->lock, flags);
+
+	BUG_ON(ISP_BUFS_IS_FULL(bufs));
+
+	buf = ISP_BUF_QUEUE(bufs);
+
+	buf->isp_addr = bufs->isp_addr_capture[vb->i];
+	buf->complete = complete;
+	buf->vb = vb;
+	buf->priv = priv;
+	buf->vb_state = VIDEOBUF_DONE;
+	buf->vb->state = VIDEOBUF_ACTIVE;
+
+	if (ISP_BUFS_IS_EMPTY(bufs)) {
+		isp_enable_interrupts(dev, RAW_CAPTURE(isp));
+		isp_set_buf(dev, buf);
+		ispccdc_enable(&isp->isp_ccdc, 1);
+	}
+
+	ISP_BUF_MARK_QUEUED(bufs);
+
+	spin_unlock_irqrestore(&bufs->lock, flags);
+
+	DPRINTK_ISPCTRL(KERN_ALERT "%s: queue %d vb %d, mmu %p\n", __func__,
+			(bufs->queue - 1 + NUM_BUFS) % NUM_BUFS, vb->i,
+			buf->isp_addr);
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_buf_queue);
+
+/**
+ * isp_vbq_setup - Do ISP specific actions when the VB wueue is set.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @vbq: Pointer to video buffer queue.
+ * @cnt: Pointer to buffer count size of the queue list.
+ * @size: Pointer to the bytesize of every video buffer queue entry.
+ *
+ * Currently, this just allocates the temporary buffer used for the
+ * ISP Workaround when having CCDC->PRV->RSZ internal datapath.
+ **/
+int isp_vbq_setup(struct device *dev, struct videobuf_queue *vbq,
+		  unsigned int *cnt, unsigned int *size)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	size_t tmp_size = PAGE_ALIGN(isp->pipeline.prv_out_w
+				     * isp->pipeline.prv_out_h
+				     * ISP_BYTES_PER_PIXEL);
+
+	if (isp->pipeline.modules & OMAP_ISP_PREVIEW
+	    && isp->tmp_buf_size < tmp_size)
+		return isp_tmp_buf_alloc(dev, tmp_size);
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_vbq_setup);
+
+/**
+ * ispmmu_vmap - Wrapper for Virtual memory mapping of a scatter gather list
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @sglist: Pointer to source Scatter gather list to allocate.
+ * @sglen: Number of elements of the scatter-gatter list.
+ *
+ * Returns a resulting mapped device address by the ISP MMU, or -ENOMEM if
+ * we ran out of memory.
+ **/
+dma_addr_t ispmmu_vmap(struct device *dev, const struct scatterlist *sglist,
+		       int sglen)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int err;
+	u32 da;
+	struct sg_table *sgt;
+	unsigned int i;
+	struct scatterlist *sg, *src = (struct scatterlist *)sglist;
+
+	/*
+	 * convert isp sglist to iommu sgt
+	 * FIXME: should be fixed in the upper layer?
+	 */
+	sgt = kmalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return -ENOMEM;
+	err = sg_alloc_table(sgt, sglen, GFP_KERNEL);
+	if (err)
+		goto err_sg_alloc;
+
+	for_each_sg(sgt->sgl, sg, sgt->nents, i)
+		sg_set_buf(sg, phys_to_virt(sg_dma_address(src + i)),
+			   sg_dma_len(src + i));
+
+	da = iommu_vmap(isp->iommu, 0, sgt, IOMMU_FLAG);
+	if (IS_ERR_VALUE(da))
+		goto err_vmap;
+
+	return (dma_addr_t)da;
+
+err_vmap:
+	sg_free_table(sgt);
+err_sg_alloc:
+	kfree(sgt);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(ispmmu_vmap);
+
+/**
+ * ispmmu_vunmap - Unmap a device address from the ISP MMU
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @da: Device address generated from a ispmmu_vmap call.
+ **/
+void ispmmu_vunmap(struct device *dev, dma_addr_t da)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct sg_table *sgt;
+
+	sgt = iommu_vunmap(isp->iommu, (u32)da);
+	if (!sgt)
+		return;
+	sg_free_table(sgt);
+	kfree(sgt);
+}
+EXPORT_SYMBOL_GPL(ispmmu_vunmap);
+
+/**
+ * isp_vbq_prepare - Videobuffer queue prepare.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @vbq: Pointer to videobuf_queue structure.
+ * @vb: Pointer to videobuf_buffer structure.
+ * @field: Requested Field order for the videobuffer.
+ *
+ * Returns 0 if successful, or -EIO if the ispmmu was unable to map a
+ * scatter-gather linked list data space.
+ **/
+int isp_vbq_prepare(struct device *dev, struct videobuf_queue *vbq,
+		    struct videobuf_buffer *vb, enum v4l2_field field)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	unsigned int isp_addr;
+	struct videobuf_dmabuf *vdma;
+	struct isp_bufs *bufs = &isp->bufs;
+
+	int err = 0;
+
+	vdma = videobuf_to_dma(vb);
+
+	isp_addr = ispmmu_vmap(dev, vdma->sglist, vdma->sglen);
+
+	if (IS_ERR_VALUE(isp_addr))
+		err = -EIO;
+	else
+		bufs->isp_addr_capture[vb->i] = isp_addr;
+
+	return err;
+}
+EXPORT_SYMBOL(isp_vbq_prepare);
+
+/**
+ * isp_vbq_release - Videobuffer queue release.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @vbq: Pointer to videobuf_queue structure.
+ * @vb: Pointer to videobuf_buffer structure.
+ **/
+void isp_vbq_release(struct device *dev, struct videobuf_queue *vbq,
+		     struct videobuf_buffer *vb)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_bufs *bufs = &isp->bufs;
+
+	ispmmu_vunmap(dev, bufs->isp_addr_capture[vb->i]);
+	bufs->isp_addr_capture[vb->i] = (dma_addr_t)NULL;
+	return;
+}
+EXPORT_SYMBOL(isp_vbq_release);
+
+/**
+ * isp_queryctrl - Query V4L2 control from existing controls in ISP.
+ * @a: Pointer to v4l2_queryctrl structure. It only needs the id field filled.
+ *
+ * Returns 0 if successful, or -EINVAL if not found in ISP.
+ **/
+int isp_queryctrl(struct v4l2_queryctrl *a)
+{
+	int i;
+
+	if (a->id & V4L2_CTRL_FLAG_NEXT_CTRL) {
+		a->id &= ~V4L2_CTRL_FLAG_NEXT_CTRL;
+		i = find_next_vctrl(a->id);
+	} else {
+		i = find_vctrl(a->id);
+	}
+
+	if (i < 0)
+		return -EINVAL;
+
+	*a = video_control[i].qc;
+	return 0;
+}
+EXPORT_SYMBOL(isp_queryctrl);
+
+/**
+ * isp_queryctrl - Query V4L2 control from existing controls in ISP.
+ * @a: Pointer to v4l2_queryctrl structure. It only needs the id field filled.
+ *
+ * Returns 0 if successful, or -EINVAL if not found in ISP.
+ **/
+int isp_querymenu(struct v4l2_querymenu *a)
+{
+	int i;
+
+	i = find_vmenu(a->id, a->index);
+
+	if (i < 0)
+		return -EINVAL;
+
+	*a = video_menu[i];
+	return 0;
+}
+EXPORT_SYMBOL(isp_querymenu);
+
+/**
+ * isp_g_ctrl - Get value of the desired V4L2 control.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @a: V4L2 control to read actual value from.
+ *
+ * Return 0 if successful, or -EINVAL if chosen control is not found.
+ **/
+int isp_g_ctrl(struct device *dev, struct v4l2_control *a)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	u8 current_value;
+	int rval = 0;
+
+	if (!isp->ref_count)
+		return -EINVAL;
+
+	switch (a->id) {
+	case V4L2_CID_BRIGHTNESS:
+		isppreview_query_brightness(&isp->isp_prev, &current_value);
+		a->value = current_value / ISPPRV_BRIGHT_UNITS;
+		break;
+	case V4L2_CID_CONTRAST:
+		isppreview_query_contrast(&isp->isp_prev, &current_value);
+		a->value = current_value / ISPPRV_CONTRAST_UNITS;
+		break;
+	case V4L2_CID_COLORFX:
+		isppreview_get_color(&isp->isp_prev, &current_value);
+		a->value = current_value;
+		break;
+	default:
+		rval = -EINVAL;
+		break;
+	}
+
+	return rval;
+}
+EXPORT_SYMBOL(isp_g_ctrl);
+
+/**
+ * isp_s_ctrl - Set value of the desired V4L2 control.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @a: V4L2 control to read actual value from.
+ *
+ * Return 0 if successful, -EINVAL if chosen control is not found or value
+ * is out of bounds, -EFAULT if copy_from_user or copy_to_user operation fails
+ * from camera abstraction layer related controls or the transfered user space
+ * pointer via the value field is not set properly.
+ **/
+int isp_s_ctrl(struct device *dev, struct v4l2_control *a)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int rval = 0;
+	u8 new_value = a->value;
+
+	if (!isp->ref_count)
+		return -EINVAL;
+
+	switch (a->id) {
+	case V4L2_CID_BRIGHTNESS:
+		if (a->value > ISPPRV_BRIGHT_HIGH)
+			rval = -EINVAL;
+		else
+			isppreview_update_brightness(&isp->isp_prev,
+						     &new_value);
+		break;
+	case V4L2_CID_CONTRAST:
+		if (a->value > ISPPRV_CONTRAST_HIGH)
+			rval = -EINVAL;
+		else
+			isppreview_update_contrast(&isp->isp_prev, &new_value);
+		break;
+	case V4L2_CID_COLORFX:
+		if (a->value > V4L2_COLORFX_SEPIA)
+			rval = -EINVAL;
+		else
+			isppreview_set_color(&isp->isp_prev, &new_value);
+		break;
+	default:
+		rval = -EINVAL;
+		break;
+	}
+
+	return rval;
+}
+EXPORT_SYMBOL(isp_s_ctrl);
+
+/**
+ * isp_handle_private - Handle all private ioctls for isp module.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @cmd: ioctl cmd value
+ * @arg: ioctl arg value
+ *
+ * Return 0 if successful, -EINVAL if chosen cmd value is not handled or value
+ * is out of bounds, -EFAULT if ioctl arg value is not valid.
+ * Function simply routes the input ioctl cmd id to the appropriate handler in
+ * the isp module.
+ **/
+int isp_handle_private(struct device *dev, int cmd, void *arg)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int rval = 0;
+
+	if (!isp->ref_count)
+		return -EINVAL;
+
+	switch (cmd) {
+	case VIDIOC_PRIVATE_ISP_CCDC_CFG:
+		rval = omap34xx_isp_ccdc_config(&isp->isp_ccdc, arg);
+		break;
+	case VIDIOC_PRIVATE_ISP_PRV_CFG:
+		rval = omap34xx_isp_preview_config(&isp->isp_prev, arg);
+		break;
+	case VIDIOC_PRIVATE_ISP_AEWB_CFG: {
+		struct isph3a_aewb_config *params;
+		params = (struct isph3a_aewb_config *)arg;
+		rval = isph3a_aewb_configure(&isp->isp_h3a, params);
+	}
+		break;
+	case VIDIOC_PRIVATE_ISP_AEWB_REQ: {
+		struct isph3a_aewb_data *data;
+		data = (struct isph3a_aewb_data *)arg;
+		rval = isph3a_aewb_request_statistics(&isp->isp_h3a, data);
+	}
+		break;
+	case VIDIOC_PRIVATE_ISP_HIST_CFG: {
+		struct isp_hist_config *params;
+		params = (struct isp_hist_config *)arg;
+		rval = isp_hist_configure(&isp->isp_hist, params);
+	}
+		break;
+	case VIDIOC_PRIVATE_ISP_HIST_REQ: {
+		struct isp_hist_data *data;
+		data = (struct isp_hist_data *)arg;
+		rval = isp_hist_request_statistics(&isp->isp_hist, data);
+	}
+		break;
+	case VIDIOC_PRIVATE_ISP_AF_CFG: {
+		struct af_configuration *params;
+		params = (struct af_configuration *)arg;
+		rval = isp_af_configure(&isp->isp_af, params);
+	}
+		break;
+	case VIDIOC_PRIVATE_ISP_AF_REQ: {
+		struct isp_af_data *data;
+		data = (struct isp_af_data *)arg;
+		rval = isp_af_request_statistics(&isp->isp_af, data);
+	}
+		break;
+	default:
+		rval = -EINVAL;
+		break;
+	}
+	return rval;
+}
+EXPORT_SYMBOL(isp_handle_private);
+
+/**
+ * isp_enum_fmt_cap - Get more information of chosen format index and type
+ * @f: Pointer to structure containing index and type of format to read from.
+ *
+ * Returns 0 if successful, or -EINVAL if format index or format type is
+ * invalid.
+ **/
+int isp_enum_fmt_cap(struct v4l2_fmtdesc *f)
+{
+	int index = f->index;
+	enum v4l2_buf_type type = f->type;
+	int rval = -EINVAL;
+
+	if (index >= NUM_ISP_CAPTURE_FORMATS)
+		goto err;
+
+	memset(f, 0, sizeof(*f));
+	f->index = index;
+	f->type = type;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		rval = 0;
+		break;
+	default:
+		goto err;
+	}
+
+	f->flags = isp_formats[index].flags;
+	strncpy(f->description, isp_formats[index].description,
+		sizeof(f->description));
+	f->pixelformat = isp_formats[index].pixelformat;
+err:
+	return rval;
+}
+EXPORT_SYMBOL(isp_enum_fmt_cap);
+
+/**
+ * isp_g_fmt_cap - Get current output image format.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @pix: Pointer to V4L2 format structure to return current output format
+ **/
+void isp_g_fmt_cap(struct device *dev, struct v4l2_pix_format *pix)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	*pix = isp->pipeline.pix;
+	return;
+}
+EXPORT_SYMBOL(isp_g_fmt_cap);
+
+/**
+ * isp_s_fmt_cap - Set I/O formats and crop, and configure pipeline in ISP
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @pix_input: Pointer to V4L2 format structure to represent current input.
+ * @pix_output: Pointer to V4L2 format structure to represent current output.
+ *
+ * Returns 0 if successful, -EINVAL if ISP hasn't been opened, or return
+ * value of isp_s_pipeline if there is an error.
+ **/
+int isp_s_fmt_cap(struct device *dev, struct v4l2_pix_format *pix_input,
+		  struct v4l2_pix_format *pix_output)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (!isp->ref_count)
+		return -EINVAL;
+
+	return isp_s_pipeline(dev, pix_input, pix_output);
+}
+EXPORT_SYMBOL(isp_s_fmt_cap);
+
+/**
+ * isp_g_crop - Get crop rectangle size and position.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @crop: Pointer to V4L2 crop structure to be filled.
+ *
+ * Always returns 0.
+ **/
+int isp_g_crop(struct device *dev, struct v4l2_crop *crop)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	if (isp->pipeline.modules & OMAP_ISP_RESIZER) {
+		crop->c = isp->pipeline.rsz_crop;
+	} else {
+		crop->c.left = 0;
+		crop->c.top = 0;
+		crop->c.width = isp->pipeline.ccdc_out_w_img;
+		crop->c.height = isp->pipeline.ccdc_out_h;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_g_crop);
+
+/**
+ * isp_s_crop - Set crop rectangle size and position.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @a: Pointer to V4L2 crop structure with desired parameters.
+ *
+ * Always returns 0.
+ *
+ * FIXME: Hardcoded to configure always the resizer, which could not be always
+ *        the case.
+ **/
+int isp_s_crop(struct device *dev, struct v4l2_crop *a)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	ispresizer_config_crop(&isp->isp_res, a);
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_s_crop);
+
+/**
+ * isp_try_fmt_cap - Try desired input/output image formats
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @pix_input: Pointer to V4L2 pixel format structure for input image.
+ * @pix_output: Pointer to V4L2 pixel format structure for output image.
+ *
+ * Returns 0 if successful, or return value of either isp_try_size or
+ * isp_try_fmt if there is an error.
+ **/
+int isp_try_fmt_cap(struct device *dev, struct v4l2_pix_format *pix_input,
+		    struct v4l2_pix_format *pix_output)
+{
+	struct isp_pipeline pipe;
+	int rval;
+
+	pipe.pix = *pix_output;
+
+	rval = isp_try_pipeline(dev, pix_input, &pipe);
+	if (rval)
+		return rval;
+
+	*pix_output = pipe.pix;
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_try_fmt_cap);
+
+/**
+ * isp_save_ctx - Saves ISP, CCDC, HIST, H3A, PREV, RESZ & MMU context.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Routine for saving the context of each module in the ISP.
+ * CCDC, HIST, H3A, PREV, RESZ and IOMMU.
+ **/
+static void isp_save_ctx(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp_save_context(dev, isp_reg_list);
+	ispccdc_save_context(dev);
+	if (isp->iommu)
+		iommu_save_ctx(isp->iommu);
+	isphist_save_context(dev);
+	isph3a_save_context(dev);
+	isppreview_save_context(dev);
+	ispresizer_save_context(dev);
+	ispcsi2_save_context(dev);
+}
+
+/**
+ * isp_restore_ctx - Restores ISP, CCDC, HIST, H3A, PREV, RESZ & MMU context.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Routine for restoring the context of each module in the ISP.
+ * CCDC, HIST, H3A, PREV, RESZ and IOMMU.
+ **/
+static void isp_restore_ctx(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp_restore_context(dev, isp_reg_list);
+	ispccdc_restore_context(dev);
+	if (isp->iommu)
+		iommu_restore_ctx(isp->iommu);
+	isphist_restore_context(dev);
+	isph3a_restore_context(dev);
+	isppreview_restore_context(dev);
+	ispresizer_restore_context(dev);
+	ispcsi2_restore_context(dev);
+}
+
+/**
+ * isp_enable_clocks - Enable ISP clocks
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Return 0 if successful, or clk_enable return value if any of tthem fails.
+ **/
+static int isp_enable_clocks(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int r;
+
+	r = clk_enable(isp->cam_ick);
+	if (r) {
+		dev_err(dev, "clk_enable cam_ick failed\n");
+		goto out_clk_enable_ick;
+	}
+	r = clk_enable(isp->cam_mclk);
+	if (r) {
+		dev_err(dev, "clk_enable cam_mclk failed\n");
+		goto out_clk_enable_mclk;
+	}
+	r = clk_enable(isp->csi2_fck);
+	if (r) {
+		dev_err(dev, "clk_enable csi2_fck failed\n");
+		goto out_clk_enable_csi2_fclk;
+	}
+	return 0;
+
+out_clk_enable_csi2_fclk:
+	clk_disable(isp->cam_mclk);
+out_clk_enable_mclk:
+	clk_disable(isp->cam_ick);
+out_clk_enable_ick:
+	return r;
+}
+
+/**
+ * isp_disable_clocks - Disable ISP clocks
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+static void isp_disable_clocks(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	clk_disable(isp->cam_ick);
+	clk_disable(isp->cam_mclk);
+	clk_disable(isp->csi2_fck);
+}
+
+/**
+ * isp_get - Acquire the ISP resource.
+ *
+ * Initializes the clocks for the first acquire.
+ *
+ * Returns pointer for isp device structure.
+ **/
+struct device *isp_get(void)
+{
+	struct platform_device *pdev = omap3isp_pdev;
+	struct isp_device *isp;
+	static int has_context;
+	int ret_err = 0;
+
+	if (!pdev)
+		return NULL;
+	isp = platform_get_drvdata(pdev);
+
+	DPRINTK_ISPCTRL("isp_get: old %d\n", isp->ref_count);
+	mutex_lock(&(isp->isp_mutex));
+	if (isp->ref_count == 0) {
+		ret_err = isp_enable_clocks(&pdev->dev);
+		if (ret_err)
+			goto out_err;
+		/* We don't want to restore context before saving it! */
+		if (has_context)
+			isp_restore_ctx(&pdev->dev);
+		else
+			has_context = 1;
+	}
+	isp->ref_count++;
+	mutex_unlock(&(isp->isp_mutex));
+
+	DPRINTK_ISPCTRL("isp_get: new %d\n", isp->ref_count);
+	/* FIXME: ISP should register as v4l2 device to store its priv data */
+	return &pdev->dev;
+
+out_err:
+	mutex_unlock(&(isp->isp_mutex));
+	return NULL;
+}
+EXPORT_SYMBOL(isp_get);
+
+/**
+ * isp_put - Release the ISP resource.
+ *
+ * Releases the clocks also for the last release.
+ *
+ * Return resulting reference count, or -EBUSY if ISP structure is not
+ * allocated.
+ **/
+int isp_put(void)
+{
+	struct platform_device *pdev = omap3isp_pdev;
+	struct isp_device *isp = platform_get_drvdata(pdev);
+
+	if (!isp)
+		return -EBUSY;
+
+	DPRINTK_ISPCTRL("isp_put: old %d\n", isp->ref_count);
+	mutex_lock(&(isp->isp_mutex));
+	if (isp->ref_count) {
+		if (--isp->ref_count == 0) {
+			isp_save_ctx(&pdev->dev);
+			isp_tmp_buf_free(&pdev->dev);
+			isp_release_resources(&pdev->dev);
+			isp_disable_clocks(&pdev->dev);
+		}
+	}
+	mutex_unlock(&(isp->isp_mutex));
+	DPRINTK_ISPCTRL("isp_put: new %d\n", isp->ref_count);
+	return isp->ref_count;
+}
+EXPORT_SYMBOL(isp_put);
+
+/**
+ * isp_save_context - Saves the values of the ISP module registers.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @reg_list: Structure containing pairs of register address and value to
+ *            modify on OMAP.
+ **/
+void isp_save_context(struct device *dev, struct isp_reg *reg_list)
+{
+	struct isp_reg *next = reg_list;
+
+	for (; next->reg != ISP_TOK_TERM; next++)
+		next->val = isp_reg_readl(dev, next->mmio_range, next->reg);
+}
+EXPORT_SYMBOL(isp_save_context);
+
+/**
+ * isp_restore_context - Restores the values of the ISP module registers.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @reg_list: Structure containing pairs of register address and value to
+ *            modify on OMAP.
+ **/
+void isp_restore_context(struct device *dev, struct isp_reg *reg_list)
+{
+	struct isp_reg *next = reg_list;
+
+	for (; next->reg != ISP_TOK_TERM; next++)
+		isp_reg_writel(dev, next->val, next->mmio_range, next->reg);
+}
+EXPORT_SYMBOL(isp_restore_context);
+
+/**
+ * isp_remove - Remove ISP platform device
+ * @pdev: Pointer to ISP platform device
+ *
+ * Always returns 0.
+ **/
+static int isp_remove(struct platform_device *pdev)
+{
+	struct isp_device *isp = platform_get_drvdata(pdev);
+	int i;
+
+	if (!isp)
+		return 0;
+
+	isp_csi2_cleanup(&pdev->dev);
+	isp_af_exit(&pdev->dev);
+	isp_preview_cleanup(&pdev->dev);
+	isp_resizer_cleanup(&pdev->dev);
+	isp_get();
+	if (isp->iommu)
+		iommu_put(isp->iommu);
+	isp_put();
+	isph3a_aewb_cleanup(&pdev->dev);
+	isp_hist_cleanup(&pdev->dev);
+	isp_ccdc_cleanup(&pdev->dev);
+
+	clk_put(isp->cam_ick);
+	clk_put(isp->cam_mclk);
+	clk_put(isp->csi2_fck);
+	clk_put(isp->l3_ick);
+
+	free_irq(isp->irq_num, isp);
+
+	for (i = 0; i <= OMAP3_ISP_IOMEM_CSI2PHY; i++) {
+		if (isp->mmio_base[i]) {
+			iounmap((void *)isp->mmio_base[i]);
+			isp->mmio_base[i] = 0;
+		}
+
+		if (isp->mmio_base_phys[i]) {
+			release_mem_region(isp->mmio_base_phys[i],
+					   isp->mmio_size[i]);
+			isp->mmio_base_phys[i] = 0;
+		}
+	}
+
+	omap3isp_pdev = NULL;
+	kfree(isp);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+/**
+ * isp_suspend - Suspend routine for the ISP
+ * @dev: Pointer to ISP device
+ *
+ * Always returns 0.
+ **/
+static int isp_suspend(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int reset;
+
+	DPRINTK_ISPCTRL("isp_suspend: starting\n");
+
+	if (mutex_is_locked(&isp->isp_mutex))
+		dev_err(dev, "%s: bug: isp_mutex is locked\n", __func__);
+
+	if (isp->ref_count == 0)
+		goto out;
+
+	isp_disable_interrupts(dev);
+	reset = isp_suspend_modules(dev);
+	isp_save_ctx(dev);
+	if (reset)
+		isp_reset(dev);
+
+	isp_disable_clocks(dev);
+
+out:
+	DPRINTK_ISPCTRL("isp_suspend: done\n");
+
+	return 0;
+}
+
+/**
+ * isp_resume - Resume routine for the ISP
+ * @dev: Pointer to ISP device
+ *
+ * Returns 0 if successful, or isp_enable_clocks return value otherwise.
+ **/
+static int isp_resume(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	int ret_err = 0;
+
+	DPRINTK_ISPCTRL("isp_resume: starting\n");
+
+	if (mutex_is_locked(&isp->isp_mutex))
+		dev_err(dev, "%s: bug: isp_mutex is locked\n", __func__);
+
+	if (isp->ref_count == 0)
+		goto out;
+
+	ret_err = isp_enable_clocks(dev);
+	if (ret_err)
+		goto out;
+	isp_restore_ctx(dev);
+	isp_resume_modules(dev);
+
+out:
+	DPRINTK_ISPCTRL("isp_resume: done\n");
+
+	return ret_err;
+}
+
+#else
+
+#define isp_suspend	NULL
+#define isp_resume	NULL
+
+#endif /* CONFIG_PM */
+
+/**
+ * isp_probe - Probe ISP platform device
+ * @pdev: Pointer to ISP platform device
+ *
+ * Returns 0 if successful,
+ *   -ENOMEM if no memory available,
+ *   -ENODEV if no platform device resources found
+ *     or no space for remapping registers,
+ *   -EINVAL if couldn't install ISR,
+ *   or clk_get return error value.
+ **/
+static int isp_probe(struct platform_device *pdev)
+{
+	struct isp_device *isp;
+	int ret_err = 0;
+	int i;
+
+	isp = kzalloc(sizeof(*isp), GFP_KERNEL);
+	if (!isp) {
+		dev_err(&pdev->dev, "could not allocate memory\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, isp);
+
+	isp->dev = &pdev->dev;
+
+	for (i = 0; i <= OMAP3_ISP_IOMEM_CSI2PHY; i++) {
+		struct resource *mem;
+		/* request the mem region for the camera registers */
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!mem) {
+			dev_err(isp->dev, "no mem resource?\n");
+			ret_err = -ENODEV;
+			goto out_free_mmio;
+		}
+
+		if (!request_mem_region(mem->start, mem->end - mem->start + 1,
+					pdev->name)) {
+			dev_err(isp->dev,
+				"cannot reserve camera register I/O region\n");
+			ret_err = -ENODEV;
+			goto out_free_mmio;
+		}
+		isp->mmio_base_phys[i] = mem->start;
+		isp->mmio_size[i] = mem->end - mem->start + 1;
+
+		/* map the region */
+		isp->mmio_base[i] = (unsigned long)
+			ioremap_nocache(isp->mmio_base_phys[i],
+					isp->mmio_size[i]);
+		if (!isp->mmio_base[i]) {
+			dev_err(isp->dev,
+				"cannot map camera register I/O region\n");
+			ret_err = -ENODEV;
+			goto out_free_mmio;
+		}
+	}
+
+	isp->irq_num = platform_get_irq(pdev, 0);
+	if (isp->irq_num <= 0) {
+		dev_err(isp->dev, "no irq for camera?\n");
+		ret_err = -ENODEV;
+		goto out_free_mmio;
+	}
+
+	isp->cam_ick = clk_get(&camera_dev, "cam_ick");
+	if (IS_ERR(isp->cam_ick)) {
+		dev_err(isp->dev, "clk_get cam_ick failed\n");
+		ret_err = PTR_ERR(isp->cam_ick);
+		goto out_free_mmio;
+	}
+	isp->cam_mclk = clk_get(&camera_dev, "cam_mclk");
+	if (IS_ERR(isp->cam_mclk)) {
+		dev_err(isp->dev, "clk_get cam_mclk failed\n");
+		ret_err = PTR_ERR(isp->cam_mclk);
+		goto out_clk_get_mclk;
+	}
+	isp->csi2_fck = clk_get(&camera_dev, "csi2_96m_fck");
+	if (IS_ERR(isp->csi2_fck)) {
+		dev_err(isp->dev, "clk_get csi2_96m_fck failed\n");
+		ret_err = PTR_ERR(isp->csi2_fck);
+		goto out_clk_get_csi2_fclk;
+	}
+	isp->l3_ick = clk_get(&camera_dev, "l3_ick");
+	if (IS_ERR(isp->l3_ick)) {
+		dev_err(isp->dev, "clk_get l3_ick failed\n");
+		ret_err = PTR_ERR(isp->l3_ick);
+		goto out_clk_get_l3_ick;
+	}
+
+	if (request_irq(isp->irq_num, omap34xx_isp_isr, IRQF_SHARED,
+			"Omap 3 Camera ISP", pdev)) {
+		dev_err(isp->dev, "could not install isr\n");
+		ret_err = -EINVAL;
+		goto out_request_irq;
+	}
+
+	isp->ref_count = 0;
+	omap3isp_pdev = pdev;
+
+	mutex_init(&(isp->isp_mutex));
+	spin_lock_init(&isp->lock);
+	spin_lock_init(&isp->bufs.lock);
+	spin_lock_init(&isp->h3a_lock);
+
+	isp_get();
+	isp->iommu = iommu_get("isp");
+	if (IS_ERR(isp->iommu)) {
+		ret_err = PTR_ERR(isp->iommu);
+		isp->iommu = NULL;
+	}
+	isp_put();
+	if (!isp->iommu)
+		goto out_iommu_get;
+
+	isp_ccdc_init(&pdev->dev);
+	isp_hist_init(&pdev->dev);
+	isph3a_aewb_init(&pdev->dev);
+	isp_preview_init(&pdev->dev);
+	isp_resizer_init(&pdev->dev);
+	isp_af_init(&pdev->dev);
+	isp_csi2_init(&pdev->dev);
+
+	isp_get();
+	isp_power_settings(&pdev->dev, 1);
+	isp_put();
+
+	return 0;
+
+out_iommu_get:
+	free_irq(isp->irq_num, isp);
+	omap3isp_pdev = NULL;
+out_request_irq:
+	clk_put(isp->l3_ick);
+out_clk_get_l3_ick:
+	clk_put(isp->csi2_fck);
+out_clk_get_csi2_fclk:
+	clk_put(isp->cam_mclk);
+out_clk_get_mclk:
+	clk_put(isp->cam_ick);
+out_free_mmio:
+	for (i = 0; i <= OMAP3_ISP_IOMEM_CSI2PHY; i++) {
+		if (isp->mmio_base[i]) {
+			iounmap((void *)isp->mmio_base[i]);
+			isp->mmio_base[i] = 0;
+		}
+
+		if (isp->mmio_base_phys[i]) {
+			release_mem_region(isp->mmio_base_phys[i],
+					   isp->mmio_size[i]);
+			isp->mmio_base_phys[i] = 0;
+		}
+	}
+
+	kfree(isp);
+	return ret_err;
+}
+
+const static struct dev_pm_ops omap3isp_pm_ops = {
+	.suspend = isp_suspend,
+	.resume  = isp_resume,
+};
+
+static struct platform_driver omap3isp_driver = {
+	.probe = isp_probe,
+	.remove = isp_remove,
+	.driver = {
+		.name = "omap3isp",
+		.pm	= &omap3isp_pm_ops,
+	},
+};
+
+/**
+ * isp_init - ISP module initialization.
+ **/
+static int __init isp_init(void)
+{
+	return platform_driver_register(&omap3isp_driver);
+}
+
+/**
+ * isp_cleanup - ISP module cleanup.
+ **/
+static void __exit isp_cleanup(void)
+{
+	platform_driver_unregister(&omap3isp_driver);
+}
+
+/**
+ * isp_print_status - Prints the values of the ISP Control Module registers
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void isp_print_status(struct device *dev)
+{
+	if (!is_ispctrl_debug_enabled())
+		return;
+
+	DPRINTK_ISPCTRL("###ISP_CTRL=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL));
+	DPRINTK_ISPCTRL("###ISP_TCTRL_CTRL=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_TCTRL_CTRL));
+	DPRINTK_ISPCTRL("###ISP_SYSCONFIG=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_SYSCONFIG));
+	DPRINTK_ISPCTRL("###ISP_SYSSTATUS=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_SYSSTATUS));
+	DPRINTK_ISPCTRL("###ISP_IRQ0ENABLE=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0ENABLE));
+	DPRINTK_ISPCTRL("###ISP_IRQ0STATUS=0x%x\n",
+			isp_reg_readl(dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0STATUS));
+}
+EXPORT_SYMBOL(isp_print_status);
+
+module_init(isp_init);
+module_exit(isp_cleanup);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("ISP Control Module Library");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/isp.h b/drivers/media/video/isp/isp.h
new file mode 100644
index 0000000..2ddf43c
--- /dev/null
+++ b/drivers/media/video/isp/isp.h
@@ -0,0 +1,545 @@
+/*
+ * isp.h
+ *
+ * Top level public header file for ISP Control module in
+ * TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ * Copyright (C) 2009 Nokia.
+ *
+ * Contributors:
+ *	Sameer Venkatraman <sameerv@ti.com>
+ *	Mohit Jalori
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Sakari Ailus <sakari.ailus@nokia.com>
+ *	Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_TOP_H
+#define OMAP_ISP_TOP_H
+#include <plat/cpu.h>
+#include <media/videobuf-dma-sg.h>
+#include <linux/videodev2.h>
+
+#include <linux/io.h>
+
+#include <plat/iommu.h>
+#include <plat/iovmm.h>
+
+struct isp_pipeline;
+
+#include "ispstat.h"
+#include "isp_af.h"
+#include "isphist.h"
+#include "ispccdc.h"
+#include "ispreg.h"
+#include "isph3a.h"
+#include "ispresizer.h"
+#include "isppreview.h"
+
+#define IOMMU_FLAG (IOVMF_ENDIAN_LITTLE | IOVMF_ELSZ_8)
+
+#define OMAP_ISP_CCDC		(1 << 0)
+#define OMAP_ISP_PREVIEW	(1 << 1)
+#define OMAP_ISP_RESIZER	(1 << 2)
+#define OMAP_ISP_AEWB		(1 << 3)
+#define OMAP_ISP_AF		(1 << 4)
+#define OMAP_ISP_HIST		(1 << 5)
+
+#define ISP_TOK_TERM		0xFFFFFFFF	/*
+						 * terminating token for ISP
+						 * modules reg list
+						 */
+#define NUM_BUFS		VIDEO_MAX_FRAME
+
+#ifndef CONFIG_ARCH_OMAP3410
+#define USE_ISP_PREVIEW
+#define USE_ISP_RESZ
+#define is_isppreview_enabled()		1
+#define is_ispresizer_enabled()		1
+#else
+#define is_isppreview_enabled()		0
+#define is_ispresizer_enabled()		0
+#endif
+
+#define ISP_BYTES_PER_PIXEL		2
+#define NUM_ISP_CAPTURE_FORMATS	(sizeof(isp_formats) / \
+				 sizeof(isp_formats[0]))
+
+typedef int (*isp_vbq_callback_ptr) (struct videobuf_buffer *vb);
+typedef void (*isp_callback_t) (unsigned long status,
+				isp_vbq_callback_ptr arg1, void *arg2);
+
+enum isp_mem_resources {
+	OMAP3_ISP_IOMEM_MAIN,
+	OMAP3_ISP_IOMEM_CBUFF,
+	OMAP3_ISP_IOMEM_CCP2,
+	OMAP3_ISP_IOMEM_CCDC,
+	OMAP3_ISP_IOMEM_HIST,
+	OMAP3_ISP_IOMEM_H3A,
+	OMAP3_ISP_IOMEM_PREV,
+	OMAP3_ISP_IOMEM_RESZ,
+	OMAP3_ISP_IOMEM_SBL,
+	OMAP3_ISP_IOMEM_CSI2A,
+	OMAP3_ISP_IOMEM_CSI2PHY
+};
+
+enum isp_interface_type {
+	ISP_PARLL = 1,
+	ISP_CSIA = 2,
+	ISP_CSIB = 4,
+	ISP_PARLL_YUV_BT = 8,
+	ISP_NONE = 16 /* memory input to preview / resizer */
+};
+
+enum isp_irqevents {
+	CSIA = 0x01,
+	CSIB = 0x10,
+	CCDC_VD0 = 0x100,
+	CCDC_VD1 = 0x200,
+	CCDC_VD2 = 0x400,
+	CCDC_ERR = 0x800,
+	H3A_AWB_DONE = 0x2000,
+	H3A_AF_DONE = 0x1000,
+	HIST_DONE = 0x10000,
+	PREV_DONE = 0x100000,
+	LSC_DONE = 0x20000,
+	LSC_PRE_COMP = 0x40000,
+	LSC_PRE_ERR = 0x80000,
+	RESZ_DONE = 0x1000000,
+	SBL_OVF = 0x2000000,
+	MMU_ERR = 0x10000000,
+	OCP_ERR = 0x20000000,
+	HS_VS = 0x80000000
+};
+
+enum isp_callback_type {
+	CBK_CCDC_VD0,
+	CBK_CCDC_VD1,
+	CBK_PREV_DONE,
+	CBK_RESZ_DONE,
+	CBK_MMU_ERR,
+	CBK_HIST_DONE,
+	CBK_HS_VS,
+	CBK_LSC_ISR,
+	CBK_CATCHALL,
+	CBK_CSIA,
+	CBK_CSIB,
+	CBK_END,
+};
+
+enum isp_running {
+	ISP_STOPPED,
+	ISP_RUNNING,
+	ISP_STOPPING,
+};
+
+/**
+ * struct isp_reg - Structure for ISP register values.
+ * @reg: 32-bit Register address.
+ * @val: 32-bit Register value.
+ */
+struct isp_reg {
+	enum isp_mem_resources mmio_range;
+	u32 reg;
+	u32 val;
+};
+
+/**
+ * struct isp_interface_config - ISP interface configuration.
+ * @ccdc_par_ser: ISP interface type. 0 - Parallel, 1 - CSIA, 2 - CSIB to CCDC.
+ * @dataline_shift: Data lane shifter.
+ *                      0 - No Shift, 1 - CAMEXT[13 to 2]->CAM[11 to 0]
+ *                      2 - CAMEXT[13 to 4]->CAM[9 to 0]
+ *                      3 - CAMEXT[13 to 6]->CAM[7 to 0]
+ * @hsvs_syncdetect: HS or VS synchronization signal detection.
+ *                       0 - HS Falling, 1 - HS rising
+ *                       2 - VS falling, 3 - VS rising
+ * @strobe: Strobe related parameter.
+ * @prestrobe: PreStrobe related parameter.
+ * @shutter: Shutter related parameter.
+ * @prev_sph: Horizontal Start Pixel performed in Preview module.
+ * @prev_slv: Vertical Start Line performed in Preview module.
+ * @wenlog: Store the value for the sensor specific wenlog field.
+ * @wait_hs_vs: Wait for this many hs_vs before anything else in the beginning.
+ * @pixelclk: Pixel data rate from sensor.
+ * @par_bridge: CCDC Bridge input control. Parallel interface.
+ *                  0 - Disable, 1 - Enable, first byte->cam_d(bits 7 to 0)
+ *                  2 - Enable, first byte -> cam_d(bits 15 to 8)
+ * @par_clk_pol: Pixel clock polarity on the parallel interface.
+ *                    0 - Non Inverted, 1 - Inverted
+ * @crc: Use cyclic redundancy check.
+ * @mode: (?)
+ * @edge: Falling or rising edge
+ * @signalling: Use strobe mode (only valid for CCP2 mode)
+ * @strobe_clock_inv: Strobe/clock signal inversion.
+ * @vs_edge: Type of edge used for detecting VSync signal.
+ * @channel: Logical channel number used in transmission.
+ * @vpclk: Video port output clock.
+ * @data_start: Start vertical position of the region of interest.
+ * @data_size: Vertical size of the region of interest.
+ * @format: V4L2 format which matches with the transmitted frame data.
+ */
+struct isp_interface_config {
+	enum isp_interface_type ccdc_par_ser;
+	u8 dataline_shift;
+	u32 hsvs_syncdetect;
+	int strobe;
+	int prestrobe;
+	int shutter;
+	u32 prev_sph;
+	u32 prev_slv;
+	u32 wenlog;
+	int wait_hs_vs;
+	unsigned int pixelclk;
+	union {
+		struct par {
+			unsigned par_bridge:2;
+			unsigned par_clk_pol:1;
+		} par;
+		struct csi {
+			unsigned crc:1;
+			unsigned mode:1;
+			unsigned edge:1;
+			unsigned signalling:1;
+			unsigned strobe_clock_inv:1;
+			unsigned vs_edge:1;
+			unsigned channel:3;
+			unsigned vpclk:2;
+			unsigned int data_start;
+			unsigned int data_size;
+			u32 format;
+		} csi;
+	} u;
+};
+
+/**
+ * struct isp_buf - ISP buffer information structure.
+ * @isp_addr: MMU mapped address (a.k.a. device address) of the buffer.
+ * @complete: Pointer to function used to handle the buffer once its complete
+ * @vb: Pointer to associated video buffer structure.
+ * @priv: Private pointer to send to associated complete handling function.
+ * @vb_state: Current ISP video buffer state.
+ */
+struct isp_buf {
+	dma_addr_t isp_addr;
+	void (*complete)(struct videobuf_buffer *vb, void *priv);
+	struct videobuf_buffer *vb;
+	void *priv;
+	u32 vb_state;
+};
+
+#define ISP_BUFS_IS_FULL(bufs)					\
+	(((bufs)->queue + 1) % NUM_BUFS == (bufs)->done)
+#define ISP_BUFS_IS_EMPTY(bufs)		((bufs)->queue == (bufs)->done)
+#define ISP_BUFS_IS_LAST(bufs)					\
+	((bufs)->queue == ((bufs)->done + 1) % NUM_BUFS)
+#define ISP_BUFS_QUEUED(bufs)						\
+	((((bufs)->done - (bufs)->queue + NUM_BUFS)) % NUM_BUFS)
+#define ISP_BUF_DONE(bufs)		((bufs)->buf + (bufs)->done)
+#define ISP_BUF_NEXT_DONE(bufs)				\
+	((bufs)->buf + ((bufs)->done + 1) % NUM_BUFS)
+#define ISP_BUF_QUEUE(bufs)		((bufs)->buf + (bufs)->queue)
+#define ISP_BUF_MARK_DONE(bufs)				\
+	(bufs)->done = ((bufs)->done + 1) % NUM_BUFS;
+#define ISP_BUF_MARK_QUEUED(bufs)			\
+	(bufs)->queue = ((bufs)->queue + 1) % NUM_BUFS;
+
+/**
+ * struct isp_bufs - ISP internal buffer queue list.
+ * @isp_addr_capture: Array of addresses for the ISP buffers inside the list.
+ * @lock: For handling current buffer
+ * @buf: Array of ISP buffers inside the list.
+ * @queue: Next slot to queue a buffer.
+ * @done: Buffer that is being processed.
+ * @wait_hs_vs: Wait for this many hs_vs before anything else.
+ */
+struct isp_bufs {
+	dma_addr_t isp_addr_capture[VIDEO_MAX_FRAME];
+	spinlock_t lock;
+	struct isp_buf buf[NUM_BUFS];
+	int queue;
+	int done;
+	int wait_hs_vs;
+};
+
+/**
+ * struct ispirq - Structure for containing callbacks to be called in ISP ISR.
+ * @isp_callbk: Array which stores callback functions, indexed by the type of
+ *              callback (8 possible types).
+ * @isp_callbk_arg1: Pointer to array containing pointers to the first argument
+ *                   to be passed to the requested callback function.
+ * @isp_callbk_arg2: Pointer to array containing pointers to the second
+ *                   argument to be passed to the requested callback function.
+ *
+ * This structure is used to contain all the callback functions related for
+ * each callback type (CBK_CCDC_VD0, CBK_CCDC_VD1, CBK_PREV_DONE,
+ * CBK_RESZ_DONE, CBK_MMU_ERR, CBK_H3A_AWB_DONE, CBK_HIST_DONE, CBK_HS_VS,
+ * CBK_LSC_ISR).
+ */
+struct isp_irq {
+	isp_callback_t isp_callbk[CBK_END];
+	isp_vbq_callback_ptr isp_callbk_arg1[CBK_END];
+	void *isp_callbk_arg2[CBK_END];
+};
+
+/**
+ * struct isp_pipeline - ISP pipeline description.
+ * @modules: ISP submodules in use.
+ * @pix: Output pixel format details in v4l2_pix_format structure.
+ * @ccdc_in_v_st: CCDC input vertical start.
+ * @ccdc_in_h_st: CCDC input horizontal start.
+ * @ccdc_in_w: CCDC input width.
+ * @ccdc_in_h: CCDC input height.
+ * @ccdc_out_w: CCDC output width (with extra padding pixels).
+ * @ccdc_out_h: CCDC output height.
+ * @ccdc_out_w_img: CCDC output width.
+ * @ccdc_in: CCDC input source.
+ * @ccdc_out: CCDC output destination.
+ * @prv_out_w: Preview output width (with extra padding pixels).
+ * @prv_out_h: Preview output height (with extra padding pixels).
+ * @prv_out_w_img: Preview output width.
+ * @prv_out_h_img: Preview output height.
+ * @prv_in: Preview input source.
+ * @prv_out: Preview output destination.
+ * @rsz_crop: Resizer crop region.
+ * @rsz_out_w: Resizer output width (with extra padding pixels).
+ * @rsz_out_h: Resizer output height.
+ * @rsz_out_w_img: Resizer output width (valid image region).
+ */
+struct isp_pipeline {
+	unsigned int modules;
+	struct v4l2_pix_format pix;
+	unsigned int ccdc_in_v_st;
+	unsigned int ccdc_in_h_st;
+	unsigned int ccdc_in_w;
+	unsigned int ccdc_in_h;
+	unsigned int ccdc_out_w;
+	unsigned int ccdc_out_h;
+	unsigned int ccdc_out_w_img;
+	enum ccdc_input ccdc_in;
+	enum ccdc_output ccdc_out;
+	unsigned int prv_out_w;
+	unsigned int prv_out_h;
+	unsigned int prv_out_w_img;
+	unsigned int prv_out_h_img;
+	enum preview_input prv_in;
+	enum preview_output prv_out;
+	struct v4l2_rect rsz_crop;
+	unsigned int rsz_out_w;
+	unsigned int rsz_out_h;
+	unsigned int rsz_out_w_img;
+	enum resizer_input rsz_in;
+};
+
+#define RAW_CAPTURE(isp)					\
+	(!((isp)->pipeline.modules & OMAP_ISP_PREVIEW))
+
+/**
+ * struct isp_device - ISP device structure.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ * @isp_obj: ISP information structure.
+ * @irq_num: Currently used IRQ number.
+ * @mmio_base: Array with kernel base addresses for ioremapped ISP register
+ *             regions.
+ * @mmio_base_phys: Array with physical L4 bus addresses for ISP register
+ *                  regions.
+ * @mmio_size: Array with ISP register regions size in bytes.
+ * @lock: Spinlock for handling registered ISP callbacks.
+ * @h3a_lock: Spinlock for handling H3a (Not used) (?)
+ * @isp_mutex: Mutex for serializing requests to ISP.
+ * @ref_count: Reference count for handling multiple ISP requests.
+ * @cam_ick: Pointer to camera interface clock structure.
+ * @cam_mclk: Pointer to camera functional clock structure.
+ * @cam_fck: Pointer to camera functional clock structure. (outdated)
+ * @csi2_fck: Pointer to camera CSI2 complexIO clock structure.
+ * @l3_ick: Pointer to OMAP3 L3 bus interface clock.
+ * @config: Pointer to currently set ISP interface configuration.
+ * @tmp_buf: ISP MMU mapped temporary buffer address used for 34xx Workaround
+ *           for CCDC->PRV->RSZ datapath errata.
+ * @tmp_buf_size: ISP MMU mapped temporary buffer size used for 34xx Workaround
+ *                for CCDC->PRV->RSZ datapath errata.
+ * @tmp_buf_offset: ISP MMU mapped temporary buffer line offset used for 34xx
+ *                  Workaround for CCDC->PRV->RSZ datapath errata.
+ * @bufs: Internal ISP buffer queue list.
+ * @irq: Currently attached ISP ISR callbacks information structure.
+ * @pipeline: Currently used internal ISP pipeline information.
+ * @interrupts: ISP interrupts staged for deferred enabling.
+ * @running: Current running/stopped status of ISP.
+ * @isp_af: Pointer to current settings for ISP AutoFocus SCM.
+ * @isp_hist: Pointer to current settings for ISP Histogram SCM.
+ * @isp_h3a: Pointer to current settings for ISP Auto Exposure and
+ *           White Balance SCM.
+ * @isp_res: Pointer to current settings for ISP Resizer.
+ * @isp_prev: Pointer to current settings for ISP Preview.
+ * @isp_ccdc: Pointer to current settings for ISP CCDC.
+ * @iommu: Pointer to requested IOMMU instance for ISP.
+ *
+ * This structure is used to store the OMAP ISP Information.
+ */
+struct isp_device {
+	struct device *dev;
+	struct isp *isp_obj;
+
+	/*** platform HW resources ***/
+	unsigned int irq_num;
+
+#define mmio_base_main mmio_base[OMAP3_ISP_IOMEM_MAIN]
+#define mmio_cbuff_main mmio_base[OMAP3_ISP_IOMEM_CBUFF]
+#define mmio_ccp2_main mmio_base[OMAP3_ISP_IOMEM_CCP2]
+#define mmio_ccdc_main mmio_base[OMAP3_ISP_IOMEM_CCDC]
+#define mmio_hist_main mmio_base[OMAP3_ISP_IOMEM_HIST]
+#define mmio_h3a_main mmio_base[OMAP3_ISP_IOMEM_H3A]
+#define mmio_prev_main mmio_base[OMAP3_ISP_IOMEM_PREV]
+#define mmio_resz_main mmio_base[OMAP3_ISP_IOMEM_RESZ]
+#define mmio_sbl_main mmio_base[OMAP3_ISP_IOMEM_SBL]
+#define mmio_csi2_main mmio_base[OMAP3_ISP_IOMEM_CSI2A]
+#define mmio_csi2phy_main mmio_base[OMAP3_ISP_IOMEM_CSI2PHY]
+	unsigned long mmio_base[OMAP3_ISP_IOMEM_CSI2PHY + 1];
+	unsigned long mmio_base_phys[OMAP3_ISP_IOMEM_CSI2PHY + 1];
+	unsigned long mmio_size[OMAP3_ISP_IOMEM_CSI2PHY + 1];
+
+	/* ISP Obj */
+	spinlock_t lock;	/* For handling registered ISP callbacks */
+	spinlock_t h3a_lock;
+	struct mutex isp_mutex;	/* For handling ref_count field */
+	int ref_count;
+	struct clk *cam_ick;
+	struct clk *cam_mclk;
+	struct clk *csi2_fck;
+	struct clk *l3_ick;
+	struct isp_interface_config *config;
+	dma_addr_t tmp_buf;
+	size_t tmp_buf_size;
+	unsigned long tmp_buf_offset;
+	struct isp_bufs bufs;
+	struct isp_irq irq;
+	struct isp_pipeline pipeline;
+	u32 interrupts;
+	enum isp_running running;
+	int current_field;
+	int bt656ifen;
+
+	/* ISP modules */
+	struct isp_af_device isp_af;
+	struct isp_hist_device isp_hist;
+	struct isp_h3a_device isp_h3a;
+	struct isp_res_device isp_res;
+	struct isp_prev_device isp_prev;
+	struct isp_ccdc_device isp_ccdc;
+
+	struct iommu *iommu;
+};
+
+void isp_flush(struct device *dev);
+
+u32 isp_reg_readl(struct device *dev, enum isp_mem_resources isp_mmio_range,
+		  u32 reg_offset);
+
+void isp_reg_writel(struct device *dev, u32 reg_value,
+		    enum isp_mem_resources isp_mmio_range, u32 reg_offset);
+
+void isp_reg_and(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		 u32 and_bits);
+
+void isp_reg_or(struct device *dev, enum isp_mem_resources mmio_range, u32 reg,
+		u32 or_bits);
+
+void isp_reg_and_or(struct device *dev, enum isp_mem_resources mmio_range,
+		    u32 reg, u32 and_bits, u32 or_bits);
+
+void isp_start(struct device *dev);
+
+void isp_stop(struct device *dev);
+
+int isp_buf_queue(struct device *dev, struct videobuf_buffer *vb,
+		  void (*complete)(struct videobuf_buffer *vb, void *priv),
+		  void *priv);
+
+int isp_vbq_setup(struct device *dev, struct videobuf_queue *vbq,
+		  unsigned int *cnt, unsigned int *size);
+
+int isp_vbq_prepare(struct device *dev, struct videobuf_queue *vbq,
+		    struct videobuf_buffer *vb, enum v4l2_field field);
+
+void isp_vbq_release(struct device *dev, struct videobuf_queue *vbq,
+		    struct videobuf_buffer *vb);
+
+int isp_set_callback(struct device *dev, enum isp_callback_type type,
+		     isp_callback_t callback, isp_vbq_callback_ptr arg1,
+		     void *arg2);
+
+int isp_unset_callback(struct device *dev, enum isp_callback_type type);
+
+u32 isp_set_xclk(struct device *dev, u32 xclk, u8 xclksel);
+
+int isp_configure_interface(struct device *dev,
+			    struct isp_interface_config *config);
+
+struct device *isp_get(void);
+
+int isp_put(void);
+
+int isp_queryctrl(struct v4l2_queryctrl *a);
+
+int isp_querymenu(struct v4l2_querymenu *a);
+
+int isp_g_ctrl(struct device *dev, struct v4l2_control *a);
+
+int isp_s_ctrl(struct device *dev, struct v4l2_control *a);
+
+int isp_enum_fmt_cap(struct v4l2_fmtdesc *f);
+
+int isp_try_fmt_cap(struct device *dev, struct v4l2_pix_format *pix_input,
+		    struct v4l2_pix_format *pix_output);
+
+void isp_g_fmt_cap(struct device *dev, struct v4l2_pix_format *pix);
+
+int isp_s_fmt_cap(struct device *dev, struct v4l2_pix_format *pix_input,
+		  struct v4l2_pix_format *pix_output);
+
+int isp_g_crop(struct device *dev, struct v4l2_crop *a);
+
+int isp_s_crop(struct device *dev, struct v4l2_crop *a);
+
+int isp_try_fmt(struct device *dev, struct v4l2_pix_format *pix_input,
+		struct v4l2_pix_format *pix_output);
+
+int isp_handle_private(struct device *dev, int cmd, void *arg);
+
+void isp_save_context(struct device *dev, struct isp_reg *);
+
+void isp_restore_context(struct device *dev, struct isp_reg *);
+
+void isp_print_status(struct device *dev);
+
+int __init isp_ccdc_init(struct device *dev);
+int __init isp_hist_init(struct device *dev);
+int __init isph3a_aewb_init(struct device *dev);
+int __init isp_preview_init(struct device *dev);
+int __init isp_resizer_init(struct device *dev);
+int __init isp_af_init(struct device *dev);
+int __init isp_csi2_init(struct device *dev);
+
+void isp_ccdc_cleanup(struct device *dev);
+void isp_hist_cleanup(struct device *dev);
+void isph3a_aewb_cleanup(struct device *dev);
+void isp_preview_cleanup(struct device *dev);
+void isp_resizer_cleanup(struct device *dev);
+void isp_af_exit(struct device *dev);
+void isp_csi2_cleanup(struct device *dev);
+
+/* FIXME: Remove these when iommu supports these directly. */
+dma_addr_t ispmmu_vmap(struct device *dev, const struct scatterlist *sglist,
+		       int sglen);
+void ispmmu_vunmap(struct device *dev, dma_addr_t da);
+
+#endif	/* OMAP_ISP_TOP_H */
diff --git a/drivers/media/video/isp/isp_af.c b/drivers/media/video/isp/isp_af.c
new file mode 100644
index 0000000..867c307
--- /dev/null
+++ b/drivers/media/video/isp/isp_af.c
@@ -0,0 +1,513 @@
+/*
+ * isp_af.c
+ *
+ * AF module for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *	David Cohen <david.cohen@nokia.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* Linux specific include files */
+#include <asm/cacheflush.h>
+
+#include <linux/uaccess.h>
+#include <linux/dma-mapping.h>
+#include <asm/atomic.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "isph3a.h"
+#include "isp_af.h"
+
+#define IS_OUT_OF_BOUNDS(value, min, max)		\
+	(((value) < (min)) || ((value) > (max)))
+
+static void __isp_af_enable(struct isp_af_device *isp_af, int enable);
+
+static void isp_af_set_address(struct isp_af_device *isp_af,
+			       unsigned long address)
+{
+	isp_reg_writel(isp_af->dev, address, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AFBUFST);
+}
+
+/* Function to check paxel parameters */
+static int isp_af_check_params(struct isp_af_device *isp_af,
+			       struct af_configuration *afconfig)
+{
+	struct af_paxel *paxel_cfg = &afconfig->paxel_config;
+	struct af_iir *iir_cfg = &afconfig->iir_config;
+	int index;
+
+	/* Check horizontal Count */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->hz_cnt, AF_PAXEL_HORIZONTAL_COUNT_MIN,
+			     AF_PAXEL_HORIZONTAL_COUNT_MAX)) {
+		DPRINTK_ISP_AF("Error : Horizontal Count is incorrect");
+		return -AF_ERR_HZ_COUNT;
+	}
+
+	/* Check Vertical Count */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->vt_cnt, AF_PAXEL_VERTICAL_COUNT_MIN,
+			     AF_PAXEL_VERTICAL_COUNT_MAX)) {
+		DPRINTK_ISP_AF("Error : Vertical Count is incorrect");
+		return -AF_ERR_VT_COUNT;
+	}
+
+	/* Check Height */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->height, AF_PAXEL_HEIGHT_MIN,
+			     AF_PAXEL_HEIGHT_MAX)) {
+		DPRINTK_ISP_AF("Error : Height is incorrect");
+		return -AF_ERR_HEIGHT;
+	}
+
+	/* Check width */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->width, AF_PAXEL_WIDTH_MIN,
+			     AF_PAXEL_WIDTH_MAX)) {
+		DPRINTK_ISP_AF("Error : Width is incorrect");
+		return -AF_ERR_WIDTH;
+	}
+
+	/* Check Line Increment */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->line_incr, AF_PAXEL_INCREMENT_MIN,
+			     AF_PAXEL_INCREMENT_MAX)) {
+		DPRINTK_ISP_AF("Error : Line Increment is incorrect");
+		return -AF_ERR_INCR;
+	}
+
+	/* Check Horizontal Start */
+	if ((paxel_cfg->hz_start % 2 != 0) ||
+	    (paxel_cfg->hz_start < (iir_cfg->hz_start_pos + 2)) ||
+	    IS_OUT_OF_BOUNDS(paxel_cfg->hz_start,
+			     AF_PAXEL_HZSTART_MIN, AF_PAXEL_HZSTART_MAX)) {
+		DPRINTK_ISP_AF("Error : Horizontal Start is incorrect");
+		return -AF_ERR_HZ_START;
+	}
+
+	/* Check Vertical Start */
+	if (IS_OUT_OF_BOUNDS(paxel_cfg->vt_start, AF_PAXEL_VTSTART_MIN,
+			     AF_PAXEL_VTSTART_MAX)) {
+		DPRINTK_ISP_AF("Error : Vertical Start is incorrect");
+		return -AF_ERR_VT_START;
+	}
+
+	/* Check IIR */
+	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
+		if ((iir_cfg->coeff_set0[index]) > AF_COEF_MAX) {
+			DPRINTK_ISP_AF("Error : Coefficient for set 0 is "
+				       "incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+
+		if ((iir_cfg->coeff_set1[index]) > AF_COEF_MAX) {
+			DPRINTK_ISP_AF("Error : Coefficient for set 1 is "
+				       "incorrect");
+			return -AF_ERR_IIR_COEF;
+		}
+	}
+
+	if (IS_OUT_OF_BOUNDS(iir_cfg->hz_start_pos, AF_IIRSH_MIN,
+			     AF_IIRSH_MAX)) {
+		DPRINTK_ISP_AF("Error : IIRSH is incorrect");
+		return -AF_ERR_IIRSH;
+	}
+
+	/* Check HMF Threshold Values */
+	if (afconfig->hmf_config.threshold > AF_THRESHOLD_MAX) {
+		DPRINTK_ISP_AF("Error : HMF Threshold is incorrect");
+		return -AF_ERR_THRESHOLD;
+	}
+
+	return 0;
+}
+
+static void isp_af_register_setup(struct isp_af_device *isp_af)
+{
+	unsigned int pcr = 0, pax1 = 0, pax2 = 0, paxstart = 0;
+	unsigned int coef = 0;
+	unsigned int base_coef_set0 = 0;
+	unsigned int base_coef_set1 = 0;
+	int index;
+
+	if (!isp_af->update)
+		return;
+
+	__isp_af_enable(isp_af, 0);
+
+	if (isp_af_busy(isp_af))
+		goto out;
+
+	/* Configure Hardware Registers */
+	pax1 |= isp_af->config.paxel_config.width << AF_PAXW_SHIFT;
+	/* Set height in AFPAX1 */
+	pax1 |= isp_af->config.paxel_config.height;
+	isp_reg_writel(isp_af->dev, pax1, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX1);
+
+	/* Configure AFPAX2 Register */
+	/* Set Line Increment in AFPAX2 Register */
+	pax2 |= isp_af->config.paxel_config.line_incr << AF_LINE_INCR_SHIFT;
+	/* Set Vertical Count */
+	pax2 |= isp_af->config.paxel_config.vt_cnt << AF_VT_COUNT_SHIFT;
+	/* Set Horizontal Count */
+	pax2 |= isp_af->config.paxel_config.hz_cnt;
+	isp_reg_writel(isp_af->dev, pax2, OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX2);
+
+	/* Configure PAXSTART Register */
+	/*Configure Horizontal Start */
+	paxstart |= isp_af->config.paxel_config.hz_start << AF_HZ_START_SHIFT;
+	/* Configure Vertical Start */
+	paxstart |= isp_af->config.paxel_config.vt_start;
+	isp_reg_writel(isp_af->dev, paxstart, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AFPAXSTART);
+
+	/*SetIIRSH Register */
+	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.hz_start_pos,
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFIIRSH);
+
+	base_coef_set0 = ISPH3A_AFCOEF010;
+	base_coef_set1 = ISPH3A_AFCOEF110;
+	for (index = 0; index <= 8; index += 2) {
+		/*Set IIR Filter0 Coefficients */
+		coef = 0;
+		coef |= isp_af->config.iir_config.coeff_set0[index];
+		coef |= isp_af->config.iir_config.coeff_set0[index + 1] <<
+			AF_COEF_SHIFT;
+		isp_reg_writel(isp_af->dev, coef, OMAP3_ISP_IOMEM_H3A,
+			       base_coef_set0);
+		base_coef_set0 += AFCOEF_OFFSET;
+
+		/*Set IIR Filter1 Coefficients */
+		coef = 0;
+		coef |= isp_af->config.iir_config.coeff_set1[index];
+		coef |= isp_af->config.iir_config.coeff_set1[index + 1] <<
+			AF_COEF_SHIFT;
+		isp_reg_writel(isp_af->dev, coef, OMAP3_ISP_IOMEM_H3A,
+			       base_coef_set1);
+		base_coef_set1 += AFCOEF_OFFSET;
+	}
+	/* set AFCOEF0010 Register */
+	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.coeff_set0[10],
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF0010);
+	/* set AFCOEF1010 Register */
+	isp_reg_writel(isp_af->dev, isp_af->config.iir_config.coeff_set1[10],
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF1010);
+
+	/* PCR Register */
+	/* Set Accumulator Mode */
+	if (isp_af->config.mode == ACCUMULATOR_PEAK)
+		pcr |= FVMODE;
+	/* Set A-law */
+	if (isp_af->config.alaw_enable == H3A_AF_ALAW_ENABLE)
+		pcr |= AF_ALAW_EN;
+	/* Set RGB Position */
+	pcr |= isp_af->config.rgb_pos << AF_RGBPOS_SHIFT;
+	/* HMF Configurations */
+	if (isp_af->config.hmf_config.enable == H3A_AF_HMF_ENABLE) {
+		/* Enable HMF */
+		pcr |= AF_MED_EN;
+		/* Set Median Threshold */
+		pcr |= isp_af->config.hmf_config.threshold << AF_MED_TH_SHIFT;
+	}
+	/* Set PCR Register */
+	isp_reg_and_or(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR,
+		       ~AF_PCR_MASK, pcr);
+
+	isp_af->update = 0;
+
+out:
+	if (isp_af->pm_state)
+		__isp_af_enable(isp_af, 1);
+}
+
+/* Update local parameters */
+static void isp_af_update_params(struct isp_af_device *isp_af,
+				 struct af_configuration *afconfig)
+{
+	int update = 0;
+	int index;
+
+	/* alaw */
+	if (isp_af->config.alaw_enable != afconfig->alaw_enable) {
+		update = 1;
+		goto out;
+	}
+
+	/* hmf */
+	if (isp_af->config.hmf_config.enable != afconfig->hmf_config.enable) {
+		update = 1;
+		goto out;
+	}
+	if (isp_af->config.hmf_config.threshold !=
+					afconfig->hmf_config.threshold) {
+		update = 1;
+		goto out;
+	}
+
+	/* rgbpos */
+	if (isp_af->config.rgb_pos != afconfig->rgb_pos) {
+		update = 1;
+		goto out;
+	}
+
+	/* iir */
+	if (isp_af->config.iir_config.hz_start_pos !=
+					afconfig->iir_config.hz_start_pos) {
+		update = 1;
+		goto out;
+	}
+	for (index = 0; index < AF_NUMBER_OF_COEF; index++) {
+		if (isp_af->config.iir_config.coeff_set0[index] !=
+				afconfig->iir_config.coeff_set0[index]) {
+			update = 1;
+			goto out;
+		}
+		if (isp_af->config.iir_config.coeff_set1[index] !=
+				afconfig->iir_config.coeff_set1[index]) {
+			update = 1;
+			goto out;
+		}
+	}
+
+	/* paxel */
+	if ((isp_af->config.paxel_config.width !=
+				afconfig->paxel_config.width) ||
+	    (isp_af->config.paxel_config.height !=
+				afconfig->paxel_config.height) ||
+	    (isp_af->config.paxel_config.hz_start !=
+				afconfig->paxel_config.hz_start) ||
+	    (isp_af->config.paxel_config.vt_start !=
+				afconfig->paxel_config.vt_start) ||
+	    (isp_af->config.paxel_config.hz_cnt !=
+				afconfig->paxel_config.hz_cnt) ||
+	    (isp_af->config.paxel_config.line_incr !=
+				afconfig->paxel_config.line_incr)) {
+		update = 1;
+		goto out;
+	}
+
+	/* af_mode */
+	if (isp_af->config.mode != afconfig->mode) {
+		update = 1;
+		goto out;
+	}
+
+	isp_af->config.af_config = afconfig->af_config;
+
+out:
+	if (update) {
+		memcpy(&isp_af->config, afconfig, sizeof(*afconfig));
+		isp_af->update = 1;
+	}
+}
+
+/* Function to perform hardware set up */
+int isp_af_configure(struct isp_af_device *isp_af,
+		     struct af_configuration *afconfig)
+{
+	int result;
+	int buf_size;
+	struct ispstat_buffer *buf;
+	unsigned long irqflags;
+
+	if (!afconfig) {
+		dev_err(isp_af->dev, "af: Null argument in configuration.\n");
+		return -EINVAL;
+	}
+
+	/* Check Parameters */
+	result = isp_af_check_params(isp_af, afconfig);
+	if (result) {
+		dev_dbg(isp_af->dev, "af: wrong configure params received.\n");
+		return result;
+	}
+
+	/* Compute buffer size */
+	buf_size = (afconfig->paxel_config.hz_cnt + 1) *
+		   (afconfig->paxel_config.vt_cnt + 1) * AF_PAXEL_SIZE;
+
+	result = ispstat_bufs_alloc(&isp_af->stat, buf_size);
+	if (result)
+		return result;
+	buf = ispstat_buf_next(&isp_af->stat);
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	isp_af_set_address(isp_af, buf->iommu_addr);
+	isp_af_update_params(isp_af, afconfig);
+
+	if (!isp_af->pm_state)
+		isp_af_register_setup(isp_af);
+
+	if (isp_af->config.af_config) {
+		__isp_af_enable(isp_af, 1);
+		isp_af->pm_state = 1;
+	} else {
+		__isp_af_enable(isp_af, 0);
+		isp_af->pm_state = 0;
+	}
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+
+	/* Success */
+	return 0;
+}
+EXPORT_SYMBOL(isp_af_configure);
+
+/*
+ * This API allows the user to update White Balance gains, as well as
+ * exposure time and analog gain. It is also used to request frame
+ * statistics.
+ */
+int isp_af_request_statistics(struct isp_af_device *isp_af,
+			      struct isp_af_data *afdata)
+{
+	struct ispstat_buffer *buf;
+
+	if (!isp_af->config.af_config) {
+		dev_err(isp_af->dev, "af: statistics requested while af engine"
+				     " is not configured\n");
+		return -EINVAL;
+	}
+
+	if (afdata->update & REQUEST_STATISTICS) {
+		buf = ispstat_buf_get(&isp_af->stat,
+			      (void *)afdata->af_statistics_buf,
+			      afdata->frame_number);
+		if (IS_ERR(buf))
+			return PTR_ERR(buf);
+
+		afdata->xtrastats.ts = buf->ts;
+		afdata->config_counter = buf->config_counter;
+		afdata->frame_number = buf->frame_number;
+
+		ispstat_buf_release(&isp_af->stat);
+	} else
+		afdata->af_statistics_buf = NULL;
+
+	afdata->curr_frame = isp_af->stat.frame_number;
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_af_request_statistics);
+
+/* This function will handle the H3A interrupt. */
+void isp_af_isr(struct isp_af_device *isp_af)
+{
+	struct ispstat_buffer *buf;
+	unsigned long irqflags;
+
+	/* Exchange buffers */
+	buf = ispstat_buf_next(&isp_af->stat);
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+
+	isp_af_set_address(isp_af, buf->iommu_addr);
+	isp_af_register_setup(isp_af);
+
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+}
+
+static void __isp_af_enable(struct isp_af_device *isp_af, int enable)
+{
+	unsigned int pcr;
+
+	pcr = isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+
+	/* Set AF_EN bit in PCR Register */
+	if (enable)
+		pcr |= AF_EN;
+	else
+		pcr &= ~AF_EN;
+
+	isp_reg_writel(isp_af->dev, pcr, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+}
+
+/* Function to Enable/Disable AF Engine */
+int isp_af_enable(struct isp_af_device *isp_af, int enable)
+{
+	int rval = 0;
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (enable) {
+		if (!isp_af->config.af_config) {
+			rval = -EINVAL;
+			goto out;
+		}
+		if (isp_af->pm_state)
+			goto out;
+		isp_af_register_setup(isp_af);
+		__isp_af_enable(isp_af, 1);
+		isp_af->pm_state = 1;
+	} else {
+		if (!isp_af->pm_state)
+			goto out;
+		__isp_af_enable(isp_af, 0);
+		isp_af->pm_state = 0;
+	}
+
+out:
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+
+	return rval;
+}
+
+/* Function to Suspend AF Engine */
+void isp_af_suspend(struct isp_af_device *isp_af)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (isp_af->pm_state)
+		__isp_af_enable(isp_af, 0);
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+}
+
+/* Function to Resume AF Engine */
+void isp_af_resume(struct isp_af_device *isp_af)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_af->lock, irqflags);
+	if (isp_af->pm_state) {
+		isp_af->update = 1;
+		isp_af_register_setup(isp_af);
+	}
+	spin_unlock_irqrestore(isp_af->lock, irqflags);
+}
+
+int isp_af_busy(struct isp_af_device *isp_af)
+{
+	return isp_reg_readl(isp_af->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
+		& ISPH3A_PCR_BUSYAF;
+}
+
+/* Function to register the AF character device driver. */
+int __init isp_af_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_af_device *isp_af = &isp->isp_af;
+
+	isp_af->dev = dev;
+	isp_af->lock = &isp->h3a_lock;
+	ispstat_init(dev, &isp_af->stat, H3A_MAX_BUFF, MAX_FRAME_COUNT);
+
+	return 0;
+}
+
+void isp_af_exit(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	/* Free buffers */
+	ispstat_free(&isp->isp_af.stat);
+}
diff --git a/drivers/media/video/isp/isp_af.h b/drivers/media/video/isp/isp_af.h
new file mode 100644
index 0000000..860015a
--- /dev/null
+++ b/drivers/media/video/isp/isp_af.h
@@ -0,0 +1,134 @@
+/*
+ * isp_af.h
+ *
+ * Include file for AF module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* Device Constants */
+#ifndef OMAP_ISP_AF_H
+#define OMAP_ISP_AF_H
+
+#include <plat/isp_user.h>
+
+#include "isph3a.h"
+#include "ispstat.h"
+
+#define AF_MAJOR_NUMBER			0
+#define ISPAF_NAME			"OMAPISP_AF"
+#define AF_NR_DEVS			1
+#define AF_TIMEOUT			((300 * HZ) / 1000)
+
+
+
+/* Print Macros */
+/*list of error code */
+#define AF_ERR_HZ_COUNT			800	/* Invalid Horizontal Count */
+#define AF_ERR_VT_COUNT			801	/* Invalid Vertical Count */
+#define AF_ERR_HEIGHT			802	/* Invalid Height */
+#define AF_ERR_WIDTH			803	/* Invalid width */
+#define AF_ERR_INCR			804	/* Invalid Increment */
+#define AF_ERR_HZ_START			805	/* Invalid horizontal Start */
+#define AF_ERR_VT_START			806	/* Invalud vertical Start */
+#define AF_ERR_IIRSH			807	/* Invalid IIRSH value */
+#define AF_ERR_IIR_COEF			808	/* Invalid Coefficient */
+#define AF_ERR_SETUP			809	/* Setup not done */
+#define AF_ERR_THRESHOLD		810	/* Invalid Threshold */
+#define AF_ERR_ENGINE_BUSY		811	/* Engine is busy */
+
+#define AFPID				0x0	/* Peripheral Revision
+						 * and Class Information
+						 */
+
+#define AFCOEF_OFFSET			0x00000004	/* COEFFICIENT BASE
+							 * ADDRESS
+							 */
+
+/*
+ * PCR fields
+ */
+#define AF_BUSYAF			(1 << 15)
+#define FVMODE				(1 << 14)
+#define RGBPOS				(0x7 << 11)
+#define MED_TH				(0xFF << 3)
+#define AF_MED_EN			(1 << 2)
+#define AF_ALAW_EN			(1 << 1)
+#define AF_EN				(1 << 0)
+#define AF_PCR_MASK			(FVMODE | RGBPOS | MED_TH | \
+					 AF_MED_EN | AF_ALAW_EN)
+
+/*
+ * AFPAX1 fields
+ */
+#define PAXW				(0x7F << 16)
+#define PAXH				0x7F
+
+/*
+ * AFPAX2 fields
+ */
+#define AFINCV				(0xF << 13)
+#define PAXVC				(0x7F << 6)
+#define PAXHC				0x3F
+
+/*
+ * AFPAXSTART fields
+ */
+#define PAXSH				(0xFFF<<16)
+#define PAXSV				0xFFF
+
+/*
+ * COEFFICIENT MASK
+ */
+
+#define COEF_MASK0			0xFFF
+#define COEF_MASK1			(0xFFF<<16)
+
+/* BIT SHIFTS */
+#define AF_RGBPOS_SHIFT			11
+#define AF_MED_TH_SHIFT			3
+#define AF_PAXW_SHIFT			16
+#define AF_LINE_INCR_SHIFT		13
+#define AF_VT_COUNT_SHIFT		6
+#define AF_HZ_START_SHIFT		16
+#define AF_COEF_SHIFT			16
+
+#define AF_UPDATEXS_TS			(1 << 0)
+#define AF_UPDATEXS_FIELDCOUNT	(1 << 1)
+#define AF_UPDATEXS_LENSPOS		(1 << 2)
+
+/**
+ * struct isp_af_status - AF status.
+ * @update: 1 - Update registers.
+ */
+struct isp_af_device {
+	u8 update;
+	int pm_state;
+	struct device *dev;
+	struct ispstat stat;
+	struct af_configuration config; /*Device configuration structure */
+	spinlock_t *lock;
+};
+
+void isp_af_isr(struct isp_af_device *isp_af);
+int isp_af_enable(struct isp_af_device *, int);
+void isp_af_suspend(struct isp_af_device *);
+void isp_af_resume(struct isp_af_device *);
+int isp_af_busy(struct isp_af_device *);
+int isp_af_request_statistics(struct isp_af_device *,
+			      struct isp_af_data *afdata);
+int isp_af_configure(struct isp_af_device *, struct af_configuration *afconfig);
+
+#endif	/* OMAP_ISP_AF_H */
diff --git a/drivers/media/video/isp/ispccdc.c b/drivers/media/video/isp/ispccdc.c
new file mode 100644
index 0000000..45900a9
--- /dev/null
+++ b/drivers/media/video/isp/ispccdc.c
@@ -0,0 +1,1824 @@
+/*
+ * ispccdc.c
+ *
+ * Driver Library for CCDC module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Senthilvadivu Guruswamy <svadivu@ti.com>
+ *	Pallavi Kulkarni <p-kulkarni@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "ispccdc.h"
+
+#define omap_rev_lt_2_0() (GET_OMAP_REVISION() <= 0x10)
+
+#define LSC_TABLE_INIT_SIZE	50052
+
+/* Structure for saving/restoring CCDC module registers*/
+static struct isp_reg ispccdc_reg_list[] = {
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HD_VD_WID, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PIX_LINES, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HORZ_INFO, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_START, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VERT_LINES, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CULLING, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HSIZE_OFF, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDR_ADDR, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_COLPTN, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_BLKCMP, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VDINT, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_REC656IF, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_HORZ, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_VERT, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR0, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR1, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR2, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR3, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR4, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR5, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR6, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR7, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN0, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN1, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD0, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD1, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_VP_OUT, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_CONFIG, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_INITIAL, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE, 0},
+	{OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_OFFSET, 0},
+	{0, ISP_TOK_TERM, 0}
+};
+
+/**
+ * omap34xx_isp_ccdc_config - Set CCDC configuration from userspace
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @userspace_add: Structure containing CCDC configuration sent from userspace.
+ *
+ * Returns 0 if successful, -EINVAL if the pointer to the configuration
+ * structure is null, or the copy_from_user function fails to copy user space
+ * memory to kernel space memory.
+ **/
+int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
+			     void *userspace_add)
+{
+	struct isp_device *isp =
+		container_of(isp_ccdc, struct isp_device, isp_ccdc);
+	struct ispccdc_bclamp bclamp_t;
+	struct ispccdc_blcomp blcomp_t;
+	struct ispccdc_fpc fpc_t;
+	struct ispccdc_culling cull_t;
+	struct ispccdc_update_config *ccdc_struct;
+
+	if (userspace_add == NULL)
+		return -EINVAL;
+
+	ccdc_struct = userspace_add;
+
+	if (ISP_ABS_CCDC_ALAW & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
+			ispccdc_config_alaw(isp_ccdc, ccdc_struct->alawip);
+		ispccdc_enable_alaw(isp_ccdc, 1);
+	} else if (ISP_ABS_CCDC_ALAW & ccdc_struct->update)
+		ispccdc_enable_alaw(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_LPF & ccdc_struct->flag)
+		ispccdc_enable_lpf(isp_ccdc, 1);
+	else
+		ispccdc_enable_lpf(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
+			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
+					   ccdc_struct->bclamp,
+					   sizeof(struct ispccdc_bclamp)))
+				goto copy_from_user_err;
+
+			ispccdc_enable_black_clamp(isp_ccdc, 1);
+			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
+		} else
+			ispccdc_enable_black_clamp(isp_ccdc, 1);
+	} else {
+		if (ISP_ABS_CCDC_BLCLAMP & ccdc_struct->update) {
+			if (copy_from_user(&bclamp_t, (struct ispccdc_bclamp *)
+					   ccdc_struct->bclamp,
+					   sizeof(struct ispccdc_bclamp)))
+				goto copy_from_user_err;
+
+			ispccdc_enable_black_clamp(isp_ccdc, 0);
+			ispccdc_config_black_clamp(isp_ccdc, bclamp_t);
+		}
+	}
+
+	if (ISP_ABS_CCDC_BCOMP & ccdc_struct->update) {
+		if (copy_from_user(&blcomp_t, (struct ispccdc_blcomp *)
+				   ccdc_struct->blcomp,
+				   sizeof(blcomp_t)))
+			goto copy_from_user_err;
+
+		ispccdc_config_black_comp(isp_ccdc, blcomp_t);
+	}
+
+	if (ISP_ABS_CCDC_FPC & ccdc_struct->flag) {
+		if (ISP_ABS_CCDC_FPC & ccdc_struct->update) {
+			if (copy_from_user(&fpc_t, (struct ispccdc_fpc *)
+					   ccdc_struct->fpc,
+					   sizeof(fpc_t)))
+				goto copy_from_user_err;
+			isp_ccdc->fpc_table_add = kmalloc(64 + fpc_t.fpnum * 4,
+						GFP_KERNEL | GFP_DMA);
+			if (!isp_ccdc->fpc_table_add) {
+				dev_err(isp_ccdc->dev,
+					"ccdc: Cannot allocate memory for"
+					" FPC table");
+				return -ENOMEM;
+			}
+			while (((unsigned long)isp_ccdc->fpc_table_add
+				& 0xFFFFFFC0)
+			       != (unsigned long)isp_ccdc->fpc_table_add)
+				isp_ccdc->fpc_table_add++;
+
+			isp_ccdc->fpc_table_add_m = iommu_kmap(
+				isp->iommu,
+				0,
+				virt_to_phys(isp_ccdc->fpc_table_add),
+				fpc_t.fpnum * 4,
+				IOMMU_FLAG);
+			/* FIXME: Correct unwinding */
+			BUG_ON(IS_ERR_VALUE(isp_ccdc->fpc_table_add_m));
+
+			if (copy_from_user(isp_ccdc->fpc_table_add,
+					   (u32 *)fpc_t.fpcaddr,
+					   fpc_t.fpnum * 4))
+				goto copy_from_user_err;
+
+			fpc_t.fpcaddr = isp_ccdc->fpc_table_add_m;
+			ispccdc_config_fpc(isp_ccdc, fpc_t);
+		}
+		ispccdc_enable_fpc(isp_ccdc, 1);
+	} else if (ISP_ABS_CCDC_FPC & ccdc_struct->update)
+		ispccdc_enable_fpc(isp_ccdc, 0);
+
+	if (ISP_ABS_CCDC_CULL & ccdc_struct->update) {
+		if (copy_from_user(&cull_t, (struct ispccdc_culling *)
+				   ccdc_struct->cull,
+				   sizeof(cull_t)))
+			goto copy_from_user_err;
+		ispccdc_config_culling(isp_ccdc, cull_t);
+	}
+
+	if (is_isplsc_activated()) {
+		if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->flag) {
+			if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) {
+				if (copy_from_user(
+					    &isp_ccdc->lsc_config,
+					    (struct ispccdc_lsc_config *)
+					    ccdc_struct->lsc_cfg,
+					    sizeof(struct ispccdc_lsc_config)))
+					goto copy_from_user_err;
+				ispccdc_config_lsc(isp_ccdc,
+						   &isp_ccdc->lsc_config);
+			}
+			ispccdc_enable_lsc(isp_ccdc, 1);
+		} else if (ISP_ABS_CCDC_CONFIG_LSC & ccdc_struct->update) {
+			ispccdc_enable_lsc(isp_ccdc, 0);
+		}
+		if (ISP_ABS_TBL_LSC & ccdc_struct->update) {
+			if (copy_from_user(isp_ccdc->lsc_gain_table,
+					   ccdc_struct->lsc,
+					   isp_ccdc->lsc_config.size))
+				goto copy_from_user_err;
+			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table,
+					 isp_ccdc->lsc_config.size);
+		}
+	}
+
+	if (ISP_ABS_CCDC_COLPTN & ccdc_struct->update)
+		ispccdc_config_imgattr(isp_ccdc, ccdc_struct->colptn);
+
+	return 0;
+
+copy_from_user_err:
+	dev_err(isp_ccdc->dev, "ccdc: Config: copy from user error");
+	return -EINVAL ;
+}
+EXPORT_SYMBOL(omap34xx_isp_ccdc_config);
+
+/**
+ * ispccdc_set_wenlog - Set the CCDC Write Enable valid region.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @wenlog: Write enable logic to apply against valid area. 0 - AND, 1 - OR.
+ */
+void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog)
+{
+	isp_ccdc->wenlog = wenlog;
+}
+EXPORT_SYMBOL(ispccdc_set_wenlog);
+
+/**
+ * ispccdc_request - Reserve the CCDC module.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Returns 0 if successful, or -EBUSY if CCDC module is busy.
+ **/
+int ispccdc_request(struct isp_ccdc_device *isp_ccdc)
+{
+	mutex_lock(&isp_ccdc->mutexlock);
+	if (isp_ccdc->ccdc_inuse) {
+		mutex_unlock(&isp_ccdc->mutexlock);
+		DPRINTK_ISPCCDC("ISP_ERR : CCDC Module Busy\n");
+		return -EBUSY;
+	}
+
+	isp_ccdc->ccdc_inuse = 1;
+	mutex_unlock(&isp_ccdc->mutexlock);
+	isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+		   ISPCTRL_CCDC_RAM_EN | ISPCTRL_CCDC_CLK_EN |
+		   ISPCTRL_SBL_WR1_RAM_EN);
+	isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+		   ISPCCDC_CFG_VDLC);
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_request);
+
+/**
+ * ispccdc_free - Free the CCDC module.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Frees the CCDC module so it can be used by another process.
+ *
+ * Returns 0 if successful, or -EINVAL if module has been already freed.
+ **/
+int ispccdc_free(struct isp_ccdc_device *isp_ccdc)
+{
+	mutex_lock(&isp_ccdc->mutexlock);
+	if (!isp_ccdc->ccdc_inuse) {
+		mutex_unlock(&isp_ccdc->mutexlock);
+		DPRINTK_ISPCCDC("ISP_ERR: CCDC Module already freed\n");
+		return -EINVAL;
+	}
+
+	isp_ccdc->ccdc_inuse = 0;
+	mutex_unlock(&isp_ccdc->mutexlock);
+	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+		    ~(ISPCTRL_CCDC_CLK_EN |
+		      ISPCTRL_CCDC_RAM_EN |
+		      ISPCTRL_SBL_WR1_RAM_EN));
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_free);
+
+/**
+ * ispccdc_free_lsc - Frees Lens Shading Compensation table
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Always returns 0.
+ **/
+static int ispccdc_free_lsc(struct isp_ccdc_device *isp_ccdc)
+{
+	struct isp_device *isp =
+		container_of(isp_ccdc, struct isp_device, isp_ccdc);
+
+	if (!isp_ccdc->lsc_ispmmu_addr)
+		return 0;
+
+	ispccdc_enable_lsc(isp_ccdc, 0);
+	isp_ccdc->lsc_initialized = 0;
+	isp_reg_writel(isp_ccdc->dev, 0, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_TABLE_BASE);
+	iommu_kunmap(isp->iommu, isp_ccdc->lsc_ispmmu_addr);
+	kfree(isp_ccdc->lsc_gain_table);
+	return 0;
+}
+
+/**
+ * ispccdc_allocate_lsc - Allocate space for Lens Shading Compensation table
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @table_size: LSC gain table size.
+ *
+ * Returns 0 if successful, -ENOMEM of its no memory available, or -EINVAL if
+ * table_size is zero.
+ **/
+static int ispccdc_allocate_lsc(struct isp_ccdc_device *isp_ccdc,
+				u32 table_size)
+{
+	struct isp_device *isp =
+		container_of(isp_ccdc, struct isp_device, isp_ccdc);
+
+	if (table_size == 0)
+		return -EINVAL;
+
+	if ((isp_ccdc->lsc_config.size >= table_size)
+	    && isp_ccdc->lsc_gain_table)
+		return 0;
+
+	ispccdc_free_lsc(isp_ccdc);
+
+	isp_ccdc->lsc_gain_table = kmalloc(table_size, GFP_KERNEL | GFP_DMA);
+
+	if (!isp_ccdc->lsc_gain_table) {
+		dev_err(isp_ccdc->dev,
+			"ccdc: Cannot allocate memory for gain tables\n");
+		return -ENOMEM;
+	}
+
+	isp_ccdc->lsc_ispmmu_addr =
+		iommu_kmap(isp->iommu,
+			   0,
+			   virt_to_phys(isp_ccdc->lsc_gain_table),
+			   table_size,
+			   IOMMU_FLAG);
+	if (IS_ERR_VALUE(isp_ccdc->lsc_ispmmu_addr)) {
+		dev_err(isp_ccdc->dev,
+			"ccdc: Cannot map memory for gain tables\n");
+		kfree(isp_ccdc->lsc_gain_table);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/**
+ * ispccdc_program_lsc - Program Lens Shading Compensation table.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Returns 0 if successful, or -EINVAL if there's no mapped address for the
+ * table yet.
+ **/
+static int ispccdc_program_lsc(struct isp_ccdc_device *isp_ccdc)
+{
+	if (!isp_ccdc->lsc_ispmmu_addr)
+		return -EINVAL;
+
+	if (isp_ccdc->lsc_initialized)
+		return 0;
+
+	isp_reg_writel(isp_ccdc->dev, isp_ccdc->lsc_ispmmu_addr,
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_LSC_TABLE_BASE);
+	isp_ccdc->lsc_initialized = 1;
+	return 0;
+}
+
+/**
+ * ispccdc_load_lsc - Load Lens Shading Compensation table.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @table_addr: MMU Mapped address to LSC gain table.
+ * @table_size: LSC gain table size.
+ *
+ * Returns 0 if successful, -ENOMEM of its no memory available, or -EINVAL if
+ * table_size is zero.
+ **/
+int ispccdc_load_lsc(struct isp_ccdc_device *isp_ccdc, u8 *table_addr,
+		     u32 table_size)
+{
+	int ret;
+
+	if (!is_isplsc_activated())
+		return 0;
+
+	if (!table_addr)
+		return -EINVAL;
+
+	ret = ispccdc_allocate_lsc(isp_ccdc, table_size);
+	if (ret)
+		return ret;
+
+	if (table_addr != isp_ccdc->lsc_gain_table)
+		memcpy(isp_ccdc->lsc_gain_table, table_addr, table_size);
+	ret = ispccdc_program_lsc(isp_ccdc);
+	if (ret)
+		return ret;
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_load_lsc);
+
+/**
+ * ispccdc_config_lsc - Configures the lens shading compensation module
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @lsc_cfg: Pointer to LSC configuration structure
+ **/
+void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc,
+			struct ispccdc_lsc_config *lsc_cfg)
+{
+	int reg;
+
+	if (!is_isplsc_activated())
+		return;
+
+	ispccdc_enable_lsc(isp_ccdc, 0);
+	isp_reg_writel(isp_ccdc->dev, lsc_cfg->offset, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_TABLE_OFFSET);
+
+	reg = 0;
+	reg |= lsc_cfg->gain_mode_n << ISPCCDC_LSC_GAIN_MODE_N_SHIFT;
+	reg |= lsc_cfg->gain_mode_m << ISPCCDC_LSC_GAIN_MODE_M_SHIFT;
+	reg |= lsc_cfg->gain_format << ISPCCDC_LSC_GAIN_FORMAT_SHIFT;
+	isp_reg_writel(isp_ccdc->dev, reg, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_CONFIG);
+
+	reg = 0;
+	reg &= ~ISPCCDC_LSC_INITIAL_X_MASK;
+	reg |= lsc_cfg->initial_x << ISPCCDC_LSC_INITIAL_X_SHIFT;
+	reg &= ~ISPCCDC_LSC_INITIAL_Y_MASK;
+	reg |= lsc_cfg->initial_y << ISPCCDC_LSC_INITIAL_Y_SHIFT;
+	isp_reg_writel(isp_ccdc->dev, reg, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_LSC_INITIAL);
+}
+EXPORT_SYMBOL(ispccdc_config_lsc);
+
+/**
+ * ispccdc_enable_lsc - Enables/Disables the Lens Shading Compensation module.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables LSC, 1 Enables LSC.
+ **/
+void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	if (!is_isplsc_activated())
+		return;
+
+	if (enable) {
+		if (!ispccdc_busy(isp_ccdc)) {
+			isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+				   ISP_CTRL, ISPCTRL_SBL_SHARED_RPORTB
+				   | ISPCTRL_SBL_RD_RAM_EN);
+
+			isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				   ISPCCDC_LSC_CONFIG, 0x1);
+
+			isp_ccdc->lsc_state = 1;
+		} else {
+			/* Postpone enabling LSC */
+			isp_ccdc->lsc_enable = 1;
+		}
+	} else {
+		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			    ISPCCDC_LSC_CONFIG, 0xFFFE);
+		isp_ccdc->lsc_state = 0;
+		isp_ccdc->lsc_enable = 0;
+	}
+}
+EXPORT_SYMBOL(ispccdc_enable_lsc);
+
+/**
+ * ispccdc_lsc_error_handler - Handle LSC prefetch error scenario.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Disables LSC, and defers enablement to shadow registers update time.
+ **/
+void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc)
+{
+	int lsc_enable = isp_ccdc->lsc_state;
+
+	ispccdc_enable_lsc(isp_ccdc, 0);
+
+	isp_ccdc->lsc_enable = lsc_enable;
+}
+
+/**
+ * ispccdc_config_crop - Configures crop parameters for the ISP CCDC.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @left: Left offset of the crop area.
+ * @top: Top offset of the crop area.
+ * @height: Height of the crop area.
+ * @width: Width of the crop area.
+ *
+ * The following restrictions are applied for the crop settings. If incoming
+ * values do not follow these restrictions then we map the settings to the
+ * closest acceptable crop value.
+ * 1) Left offset is always odd. This can be avoided if we enable byte swap
+ *    option for incoming data into CCDC.
+ * 2) Top offset is always even.
+ * 3) Crop height is always even.
+ * 4) Crop width is always a multiple of 16 pixels
+ **/
+void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc, u32 left, u32 top,
+			 u32 height, u32 width)
+{
+	isp_ccdc->ccdcin_woffset = left + (left % 2);
+	isp_ccdc->ccdcin_hoffset = top + (top % 2);
+
+	isp_ccdc->crop_w = width - (width % 16);
+	isp_ccdc->crop_h = height + (height % 2);
+
+	DPRINTK_ISPCCDC("\n\tOffsets L %d T %d W %d H %d\n",
+			isp_ccdc->ccdcin_woffset,
+			isp_ccdc->ccdcin_hoffset,
+			isp_ccdc->crop_w,
+			isp_ccdc->crop_h);
+}
+
+/**
+ * ispccdc_config_datapath - Specify the input and output modules for CCDC.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @pipe: Pointer to ISP pipeline structure to base on for config.
+ *
+ * Configures the default configuration for the CCDC to work with.
+ *
+ * The valid values for the input are CCDC_RAW (0), CCDC_YUV_SYNC (1),
+ * CCDC_YUV_BT (2), and CCDC_OTHERS (3).
+ *
+ * The valid values for the output are CCDC_YUV_RSZ (0), CCDC_YUV_MEM_RSZ (1),
+ * CCDC_OTHERS_VP (2), CCDC_OTHERS_MEM (3), CCDC_OTHERS_VP_MEM (4).
+ *
+ * Returns 0 if successful, or -EINVAL if wrong I/O combination or wrong input
+ * or output values.
+ **/
+static int ispccdc_config_datapath(struct isp_ccdc_device *isp_ccdc,
+				   struct isp_pipeline *pipe)
+{
+	u32 syn_mode = 0;
+	struct ispccdc_vp vpcfg;
+	struct ispccdc_syncif syncif;
+	struct ispccdc_bclamp blkcfg;
+
+	u32 colptn = ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC0_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC1_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP0PLC2_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP0PLC3_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC0_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC1_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP1PLC2_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP1PLC3_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC0_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC1_SHIFT |
+		ISPCCDC_COLPTN_Gr_Cy << ISPCCDC_COLPTN_CP2PLC2_SHIFT |
+		ISPCCDC_COLPTN_R_Ye << ISPCCDC_COLPTN_CP2PLC3_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC0_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC1_SHIFT |
+		ISPCCDC_COLPTN_B_Mg << ISPCCDC_COLPTN_CP3PLC2_SHIFT |
+		ISPCCDC_COLPTN_Gb_G << ISPCCDC_COLPTN_CP3PLC3_SHIFT;
+
+	syn_mode = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				 ISPCCDC_SYN_MODE);
+
+	switch (pipe->ccdc_out) {
+	case CCDC_YUV_RSZ:
+		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
+		break;
+
+	case CCDC_YUV_MEM_RSZ:
+		syn_mode |= ISPCCDC_SYN_MODE_SDR2RSZ;
+		isp_ccdc->wen = 1;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		break;
+
+	case CCDC_OTHERS_VP:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode &= ~ISPCCDC_SYN_MODE_WEN;
+		vpcfg.bitshift_sel = BIT9_0;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 1);
+		break;
+
+	case CCDC_OTHERS_MEM:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		if (pipe->ccdc_in == CCDC_YUV_BT) {
+			syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
+			isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_CFG, ~ISPCCDC_CFG_WENLOG);
+		} else {
+			syn_mode |= ISPCCDC_SYN_MODE_EXWEN;
+			isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_CFG, ISPCCDC_CFG_WENLOG);
+		}
+		vpcfg.bitshift_sel = BIT11_2;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 0);
+		break;
+
+	case CCDC_OTHERS_VP_MEM:
+		syn_mode &= ~ISPCCDC_SYN_MODE_VP2SDR;
+		syn_mode &= ~ISPCCDC_SYN_MODE_SDR2RSZ;
+		syn_mode |= ISPCCDC_SYN_MODE_WEN;
+		syn_mode &= ~ISPCCDC_SYN_MODE_EXWEN;
+
+		isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_CFG, ~ISPCCDC_CFG_WENLOG,
+			       isp_ccdc->wenlog);
+		vpcfg.bitshift_sel = BIT9_0;
+		vpcfg.freq_sel = PIXCLKBY2;
+		ispccdc_config_vp(isp_ccdc, vpcfg);
+		ispccdc_enable_vp(isp_ccdc, 1);
+		break;
+	default:
+		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Output\n");
+		return -EINVAL;
+	};
+
+	isp_reg_writel(isp_ccdc->dev, syn_mode, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_SYN_MODE);
+
+	switch (pipe->ccdc_in) {
+	case CCDC_RAW_GRBG:
+	case CCDC_RAW_RGGB:
+	case CCDC_RAW_BGGR:
+	case CCDC_RAW_GBRG:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT10;
+		syncif.fldmode = 0;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = RAW;
+		syncif.vdpol = 0;
+		syncif.bt_r656_en = 0;
+		ispccdc_config_sync_if(isp_ccdc, syncif);
+		ispccdc_config_imgattr(isp_ccdc, colptn);
+		blkcfg.dcsubval = 64;
+		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
+		if (is_isplsc_activated()) {
+			ispccdc_config_lsc(isp_ccdc, &isp_ccdc->lsc_config);
+			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table_tmp,
+					 LSC_TABLE_INIT_SIZE);
+		}
+
+		break;
+	case CCDC_YUV_SYNC:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT8;
+		syncif.fldmode = 0;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = YUV16;
+		syncif.vdpol = 1;
+		syncif.bt_r656_en = 0;
+		ispccdc_config_imgattr(isp_ccdc, 0);
+		ispccdc_config_sync_if(isp_ccdc, syncif);
+		blkcfg.dcsubval = 0;
+		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
+		break;
+	case CCDC_YUV_BT:
+		syncif.ccdc_mastermode = 0;
+		syncif.datapol = 0;
+		syncif.datsz = DAT8;
+		syncif.fldmode = 1;
+		syncif.fldout = 0;
+		syncif.fldpol = 0;
+		syncif.fldstat = 0;
+		syncif.hdpol = 0;
+		syncif.ipmod = YUV8;
+		syncif.vdpol = 1;
+		syncif.bt_r656_en = 1;
+		ispccdc_config_imgattr(isp_ccdc, 0);
+		ispccdc_config_sync_if(isp_ccdc, syncif);
+		blkcfg.dcsubval = 0;
+		ispccdc_config_black_clamp(isp_ccdc, blkcfg);
+		break;
+	case CCDC_OTHERS:
+		break;
+	default:
+		DPRINTK_ISPCCDC("ISP_ERR: Wrong CCDC Input\n");
+		return -EINVAL;
+	}
+
+	ispccdc_print_status(isp_ccdc, pipe);
+	isp_print_status(isp_ccdc->dev);
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_config_datapath);
+
+/**
+ * ispccdc_config_sync_if - Set CCDC sync interface params between sensor and CCDC.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @syncif: Structure containing the sync parameters like field state, CCDC in
+ *          master/slave mode, raw/yuv data, polarity of data, field, hs, vs
+ *          signals.
+ **/
+void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
+			    struct ispccdc_syncif syncif)
+{
+	u32 syn_mode = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				     ISPCCDC_SYN_MODE);
+
+	syn_mode |= ISPCCDC_SYN_MODE_VDHDEN;
+
+	if (syncif.fldstat)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDSTAT;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDSTAT;
+
+	syn_mode &= ISPCCDC_SYN_MODE_INPMOD_MASK;
+	isp_ccdc->syncif_ipmod = syncif.ipmod;
+
+	switch (syncif.ipmod) {
+	case RAW:
+		break;
+	case YUV16:
+		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR16;
+		break;
+	case YUV8:
+		syn_mode |= ISPCCDC_SYN_MODE_INPMOD_YCBCR8;
+		if (syncif.bt_r656_en)
+			syn_mode |= ISPCCDC_SYN_MODE_PACK8;
+		break;
+	};
+
+	syn_mode &= ISPCCDC_SYN_MODE_DATSIZ_MASK;
+	switch (syncif.datsz) {
+	case DAT8:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_8;
+		break;
+	case DAT10:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_10;
+		break;
+	case DAT11:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_11;
+		break;
+	case DAT12:
+		syn_mode |= ISPCCDC_SYN_MODE_DATSIZ_12;
+		break;
+	};
+
+	if (syncif.fldmode)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDMODE;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDMODE;
+
+	if (syncif.datapol)
+		syn_mode |= ISPCCDC_SYN_MODE_DATAPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_DATAPOL;
+
+	if (syncif.fldpol)
+		syn_mode |= ISPCCDC_SYN_MODE_FLDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_FLDPOL;
+
+	if (syncif.hdpol)
+		syn_mode |= ISPCCDC_SYN_MODE_HDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_HDPOL;
+
+	if (syncif.vdpol)
+		syn_mode |= ISPCCDC_SYN_MODE_VDPOL;
+	else
+		syn_mode &= ~ISPCCDC_SYN_MODE_VDPOL;
+
+	if (syncif.ccdc_mastermode) {
+		syn_mode |= ISPCCDC_SYN_MODE_FLDOUT | ISPCCDC_SYN_MODE_VDHDOUT;
+		isp_reg_writel(isp_ccdc->dev,
+			       syncif.hs_width << ISPCCDC_HD_VD_WID_HDW_SHIFT
+			       | syncif.vs_width << ISPCCDC_HD_VD_WID_VDW_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_HD_VD_WID);
+
+		isp_reg_writel(isp_ccdc->dev,
+			       syncif.ppln << ISPCCDC_PIX_LINES_PPLN_SHIFT
+			       | syncif.hlprf << ISPCCDC_PIX_LINES_HLPRF_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_PIX_LINES);
+	} else
+		syn_mode &= ~(ISPCCDC_SYN_MODE_FLDOUT |
+			      ISPCCDC_SYN_MODE_VDHDOUT);
+
+	isp_reg_writel(isp_ccdc->dev, syn_mode, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_SYN_MODE);
+
+	if (!(syncif.bt_r656_en)) {
+		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			    ISPCCDC_REC656IF, ~ISPCCDC_REC656IF_R656ON);
+	} else {
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			ISPCCDC_REC656IF, ISPCCDC_REC656IF_R656ON |
+			ISPCCDC_REC656IF_ECCFVH);
+	}
+}
+EXPORT_SYMBOL(ispccdc_config_sync_if);
+
+/**
+ * ispccdc_config_black_clamp - Configures the clamp parameters in CCDC.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @bclamp: Structure containing the optical black average gain, optical black
+ *          sample length, sample lines, and the start pixel position of the
+ *          samples w.r.t the HS pulse.
+ *
+ * Configures the clamp parameters in CCDC. Either if its being used the
+ * optical black clamp, or the digital clamp. If its a digital clamp, then
+ * assures to put a valid DC substraction level.
+ *
+ * Returns always 0 when completed.
+ **/
+int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
+			       struct ispccdc_bclamp bclamp)
+{
+	u32 bclamp_val = 0;
+
+	if (isp_ccdc->obclamp_en) {
+		bclamp_val |= bclamp.obgain << ISPCCDC_CLAMP_OBGAIN_SHIFT;
+		bclamp_val |= bclamp.oblen << ISPCCDC_CLAMP_OBSLEN_SHIFT;
+		bclamp_val |= bclamp.oblines << ISPCCDC_CLAMP_OBSLN_SHIFT;
+		bclamp_val |= bclamp.obstpixel << ISPCCDC_CLAMP_OBST_SHIFT;
+		isp_reg_writel(isp_ccdc->dev, bclamp_val,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP);
+	} else {
+		if (cpu_is_omap34xx() && omap_rev_lt_2_0())
+			if (isp_ccdc->syncif_ipmod == YUV16 ||
+			    isp_ccdc->syncif_ipmod == YUV8 ||
+			    isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+					  ISPCCDC_REC656IF) &
+			    ISPCCDC_REC656IF_R656ON)
+				bclamp.dcsubval = 0;
+		isp_reg_writel(isp_ccdc->dev, bclamp.dcsubval,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_DCSUB);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_config_black_clamp);
+
+/**
+ * ispccdc_enable_black_clamp - Enables/Disables the optical black clamp.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables optical black clamp, 1 Enables optical black clamp.
+ *
+ * Enables or disables the optical black clamp. When disabled, the digital
+ * clamp operates.
+ **/
+void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CLAMP,
+		       ~ISPCCDC_CLAMP_CLAMPEN,
+		       enable ? ISPCCDC_CLAMP_CLAMPEN : 0);
+	isp_ccdc->obclamp_en = enable;
+}
+EXPORT_SYMBOL(ispccdc_enable_black_clamp);
+
+/**
+ * ispccdc_config_fpc - Configures the Faulty Pixel Correction parameters.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @fpc: Structure containing the number of faulty pixels corrected in the
+ *       frame, address of the FPC table.
+ *
+ * Returns 0 if successful, or -EINVAL if FPC Address is not on the 64 byte
+ * boundary.
+ **/
+int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc, struct ispccdc_fpc fpc)
+{
+	u32 fpc_val = 0;
+
+	fpc_val = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				ISPCCDC_FPC);
+
+	if ((fpc.fpcaddr & 0xFFFFFFC0) == fpc.fpcaddr) {
+		isp_reg_writel(isp_ccdc->dev, fpc_val & (~ISPCCDC_FPC_FPCEN),
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
+		isp_reg_writel(isp_ccdc->dev, fpc.fpcaddr,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC_ADDR);
+	} else {
+		DPRINTK_ISPCCDC("FPC Address should be on 64byte boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(isp_ccdc->dev, fpc_val |
+		       (fpc.fpnum << ISPCCDC_FPC_FPNUM_SHIFT),
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC);
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_config_fpc);
+
+/**
+ * ispccdc_enable_fpc - Enable Faulty Pixel Correction.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables FPC, 1 Enables FPC.
+ **/
+void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FPC,
+		       ~ISPCCDC_FPC_FPCEN,
+		       enable ? ISPCCDC_FPC_FPCEN : 0);
+}
+EXPORT_SYMBOL(ispccdc_enable_fpc);
+
+/**
+ * ispccdc_config_black_comp - Configure Black Level Compensation.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @blcomp: Structure containing the black level compensation value for RGrGbB
+ *          pixels. in 2's complement.
+ **/
+void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
+			       struct ispccdc_blcomp blcomp)
+{
+	u32 blcomp_val = 0;
+
+	blcomp_val |= blcomp.b_mg << ISPCCDC_BLKCMP_B_MG_SHIFT;
+	blcomp_val |= blcomp.gb_g << ISPCCDC_BLKCMP_GB_G_SHIFT;
+	blcomp_val |= blcomp.gr_cy << ISPCCDC_BLKCMP_GR_CY_SHIFT;
+	blcomp_val |= blcomp.r_ye << ISPCCDC_BLKCMP_R_YE_SHIFT;
+
+	isp_reg_writel(isp_ccdc->dev, blcomp_val, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_BLKCMP);
+}
+EXPORT_SYMBOL(ispccdc_config_black_comp);
+
+/**
+ * ispccdc_config_vp - Configure the Video Port.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @vpcfg: Structure containing the Video Port input frequency, and the 10 bit
+ *         format.
+ **/
+void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc,
+		       struct ispccdc_vp vpcfg)
+{
+	u32 fmtcfg_vp = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMTCFG);
+
+	fmtcfg_vp &= ISPCCDC_FMTCFG_VPIN_MASK & ISPCCDC_FMTCFG_VPIF_FRQ_MASK;
+
+	switch (vpcfg.bitshift_sel) {
+	case BIT9_0:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_9_0;
+		break;
+	case BIT10_1:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_10_1;
+		break;
+	case BIT11_2:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_11_2;
+		break;
+	case BIT12_3:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIN_12_3;
+		break;
+	};
+	switch (vpcfg.freq_sel) {
+	case PIXCLKBY2:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY2;
+		break;
+	case PIXCLKBY3_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY3;
+		break;
+	case PIXCLKBY4_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY4;
+		break;
+	case PIXCLKBY5_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY5;
+		break;
+	case PIXCLKBY6_5:
+		fmtcfg_vp |= ISPCCDC_FMTCFG_VPIF_FRQ_BY6;
+		break;
+	};
+	isp_reg_writel(isp_ccdc->dev, fmtcfg_vp, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_FMTCFG);
+}
+EXPORT_SYMBOL(ispccdc_config_vp);
+
+/**
+ * ispccdc_enable_vp - Enable Video Port.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables VP, 1 Enables VP
+ *
+ * This is needed for outputting image to Preview, H3A and HIST ISP submodules.
+ **/
+void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
+		       ~ISPCCDC_FMTCFG_VPEN,
+		       enable ? ISPCCDC_FMTCFG_VPEN : 0);
+}
+EXPORT_SYMBOL(ispccdc_enable_vp);
+
+/**
+ * ispccdc_config_reformatter - Configure Data Reformatter.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @refmt: Structure containing the memory address to format and the bit fields
+ *         for the reformatter registers.
+ *
+ * Configures the Reformatter register values if line alternating is disabled.
+ * Else, just enabling line alternating is enough.
+ **/
+void ispccdc_config_reformatter(struct isp_ccdc_device *isp_ccdc,
+				struct ispccdc_refmt refmt)
+{
+	u32 fmtcfg_val = 0;
+
+	fmtcfg_val = isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				   ISPCCDC_FMTCFG);
+
+	if (refmt.lnalt)
+		fmtcfg_val |= ISPCCDC_FMTCFG_LNALT;
+	else {
+		fmtcfg_val &= ~ISPCCDC_FMTCFG_LNALT;
+		fmtcfg_val &= 0xFFFFF003;
+		fmtcfg_val |= refmt.lnum << ISPCCDC_FMTCFG_LNUM_SHIFT;
+		fmtcfg_val |= refmt.plen_even <<
+			ISPCCDC_FMTCFG_PLEN_EVEN_SHIFT;
+		fmtcfg_val |= refmt.plen_odd << ISPCCDC_FMTCFG_PLEN_ODD_SHIFT;
+
+		isp_reg_writel(isp_ccdc->dev, refmt.prgeven0,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN0);
+		isp_reg_writel(isp_ccdc->dev, refmt.prgeven1,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGEVEN1);
+		isp_reg_writel(isp_ccdc->dev, refmt.prgodd0,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD0);
+		isp_reg_writel(isp_ccdc->dev, refmt.prgodd1,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PRGODD1);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr0,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR0);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr1,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR1);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr2,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR2);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr3,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR3);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr4,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR4);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr5,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR5);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr6,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR6);
+		isp_reg_writel(isp_ccdc->dev, refmt.fmtaddr7,
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMT_ADDR7);
+	}
+	isp_reg_writel(isp_ccdc->dev, fmtcfg_val, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_FMTCFG);
+}
+EXPORT_SYMBOL(ispccdc_config_reformatter);
+
+/**
+ * ispccdc_enable_reformatter - Enable Data Reformatter.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables Reformatter, 1- Enables Data Reformatter
+ **/
+void ispccdc_enable_reformatter(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_FMTCFG,
+		       ~ISPCCDC_FMTCFG_FMTEN,
+		       enable ? ISPCCDC_FMTCFG_FMTEN : 0);
+	isp_ccdc->refmt_en = enable;
+}
+EXPORT_SYMBOL(ispccdc_enable_reformatter);
+
+/**
+ * ispccdc_config_culling - Configure culling parameters.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @cull: Structure containing the vertical culling pattern, and horizontal
+ *        culling pattern for odd and even lines.
+ **/
+void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
+			    struct ispccdc_culling cull)
+{
+	u32 culling_val = 0;
+
+	culling_val |= cull.v_pattern << ISPCCDC_CULLING_CULV_SHIFT;
+	culling_val |= cull.h_even << ISPCCDC_CULLING_CULHEVN_SHIFT;
+	culling_val |= cull.h_odd << ISPCCDC_CULLING_CULHODD_SHIFT;
+
+	isp_reg_writel(isp_ccdc->dev, culling_val, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_CULLING);
+}
+EXPORT_SYMBOL(ispccdc_config_culling);
+
+/**
+ * ispccdc_enable_lpf - Enable Low-Pass Filter (LPF).
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables LPF, 1 Enables LPF
+ **/
+void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SYN_MODE,
+		       ~ISPCCDC_SYN_MODE_LPF,
+		       enable ? ISPCCDC_SYN_MODE_LPF : 0);
+}
+EXPORT_SYMBOL(ispccdc_enable_lpf);
+
+/**
+ * ispccdc_config_alaw - Configure the input width for A-law compression.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @ipwidth: Input width for A-law
+ **/
+void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
+			 enum alaw_ipwidth ipwidth)
+{
+	isp_reg_writel(isp_ccdc->dev, ipwidth << ISPCCDC_ALAW_GWDI_SHIFT,
+		       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW);
+}
+EXPORT_SYMBOL(ispccdc_config_alaw);
+
+/**
+ * ispccdc_enable_alaw - Enable A-law compression.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 - Disables A-law, 1 - Enables A-law
+ **/
+void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_ALAW,
+		       ~ISPCCDC_ALAW_CCDTBL,
+		       enable ? ISPCCDC_ALAW_CCDTBL : 0);
+}
+EXPORT_SYMBOL(ispccdc_enable_alaw);
+
+/**
+ * ispccdc_config_imgattr - Configure sensor image specific attributes.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @colptn: Color pattern of the sensor.
+ **/
+void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn)
+{
+	isp_reg_writel(isp_ccdc->dev, colptn, OMAP3_ISP_IOMEM_CCDC,
+		       ISPCCDC_COLPTN);
+}
+EXPORT_SYMBOL(ispccdc_config_imgattr);
+
+/**
+ * ispccdc_config_shadow_registers - Configure CCDC during interframe time.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Executes LSC deferred enablement before next frame starts.
+ **/
+void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc)
+{
+	if (isp_ccdc->lsc_enable) {
+		ispccdc_enable_lsc(isp_ccdc, 1);
+		isp_ccdc->lsc_enable = 0;
+	}
+}
+
+/**
+ * ispccdc_try_pipeline - Checks if requested Input/output dimensions are valid
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @pipe: Pointer to ISP pipeline structure to fill back.
+ *
+ * Calculates the number of pixels cropped if the reformater is disabled,
+ * Fills up the output width and height variables in the isp_ccdc structure.
+ *
+ * Returns 0 if successful, or -EINVAL if the input width is less than 2 pixels
+ **/
+int ispccdc_try_pipeline(struct isp_ccdc_device *isp_ccdc,
+			 struct isp_pipeline *pipe)
+{
+	struct isp_device *isp =
+		container_of(isp_ccdc, struct isp_device, isp_ccdc);
+
+	if (pipe->ccdc_in_w < 32 || pipe->ccdc_in_h < 32) {
+		DPRINTK_ISPCCDC("ISP_ERR: CCDC cannot handle input width less"
+				" than 32 pixels or height less than 32\n");
+		return -EINVAL;
+	}
+
+	/* CCDC does not convert the image format */
+	if ((pipe->ccdc_in == CCDC_RAW_GRBG ||
+	     pipe->ccdc_in == CCDC_RAW_RGGB ||
+	     pipe->ccdc_in == CCDC_RAW_BGGR ||
+	     pipe->ccdc_in == CCDC_RAW_GBRG ||
+	     pipe->ccdc_in == CCDC_OTHERS) &&
+	    pipe->ccdc_out == CCDC_YUV_RSZ) {
+		dev_info(isp->dev, "wrong CCDC I/O Combination\n");
+		return -EINVAL;
+	}
+
+	pipe->ccdc_in_h_st = 0;
+	pipe->ccdc_in_v_st = 0;
+	pipe->ccdc_out_w = pipe->ccdc_in_w;
+	pipe->ccdc_out_h = pipe->ccdc_in_h;
+
+	if (!isp_ccdc->refmt_en
+	    && pipe->ccdc_out != CCDC_OTHERS_MEM
+	    && pipe->ccdc_out != CCDC_OTHERS_VP_MEM)
+		pipe->ccdc_out_h -= 1;
+
+	if (pipe->ccdc_out == CCDC_OTHERS_VP) {
+		switch (pipe->ccdc_in) {
+		case CCDC_RAW_GRBG:
+			pipe->ccdc_in_h_st = 1;
+			pipe->ccdc_in_v_st = 0;
+			break;
+		case CCDC_RAW_BGGR:
+			pipe->ccdc_in_h_st = 1;
+			pipe->ccdc_in_v_st = 1;
+			break;
+		case CCDC_RAW_RGGB:
+			pipe->ccdc_in_h_st = 0;
+			pipe->ccdc_in_v_st = 0;
+			break;
+		case CCDC_RAW_GBRG:
+			pipe->ccdc_in_h_st = 0;
+			pipe->ccdc_in_v_st = 1;
+			break;
+		default:
+			break;
+		}
+		pipe->ccdc_out_h -= pipe->ccdc_in_v_st;
+		pipe->ccdc_out_w -= pipe->ccdc_in_h_st;
+		pipe->ccdc_out_h -= (pipe->ccdc_out_h % 2);
+		pipe->ccdc_out_w -= (pipe->ccdc_out_w % 2);
+	}
+
+	pipe->ccdc_out_w_img = pipe->ccdc_out_w;
+	/* Round up to nearest 16 pixels. */
+	pipe->ccdc_out_w = ALIGN(pipe->ccdc_out_w, 0x10);
+
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_try_pipeline);
+
+/**
+ * ispccdc_s_pipeline - Configure the CCDC based on overall ISP pipeline.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @pipe: Pointer to ISP pipeline structure to configure.
+ *
+ * Configures the appropriate values stored in the isp_ccdc structure to
+ * HORZ/VERT_INFO registers and the VP_OUT depending on whether the image
+ * is stored in memory or given to the another module in the ISP pipeline.
+ *
+ * Returns 0 if successful, or -EINVAL if try_size was not called before to
+ * validate the requested dimensions.
+ **/
+int ispccdc_s_pipeline(struct isp_ccdc_device *isp_ccdc,
+		       struct isp_pipeline *pipe)
+{
+	int rval;
+
+	rval = ispccdc_config_datapath(isp_ccdc, pipe);
+	if (rval)
+		return rval;
+
+	if (pipe->ccdc_out == CCDC_OTHERS_VP) {
+		isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_in_h_st <<
+				ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+			       ((pipe->ccdc_in_w - pipe->ccdc_in_h_st) <<
+				ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_FMT_HORZ);
+		isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_in_v_st <<
+				ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+			       ((pipe->ccdc_in_h - pipe->ccdc_in_v_st) <<
+				ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_FMT_VERT);
+		isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_out_w <<
+				ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
+			       (pipe->ccdc_out_h - 1) <<
+			       ISPCCDC_VP_OUT_VERT_NUM_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VP_OUT);
+		isp_reg_writel(isp_ccdc->dev, (((pipe->ccdc_out_h - 25) &
+				 ISPCCDC_VDINT_0_MASK) <<
+				ISPCCDC_VDINT_0_SHIFT) |
+			       ((50 & ISPCCDC_VDINT_1_MASK) <<
+				ISPCCDC_VDINT_1_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VDINT);
+
+	} else if (pipe->ccdc_out == CCDC_OTHERS_MEM) {
+		isp_reg_writel(isp_ccdc->dev, 0, OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VP_OUT);
+		if (pipe->ccdc_in == CCDC_RAW_GRBG ||
+		    pipe->ccdc_in == CCDC_RAW_RGGB ||
+		    pipe->ccdc_in == CCDC_RAW_BGGR ||
+		    pipe->ccdc_in == CCDC_RAW_GBRG) {
+			isp_reg_writel(isp_ccdc->dev,
+				       pipe->ccdc_in_h_st << ISPCCDC_HORZ_INFO_SPH_SHIFT
+				       | ((pipe->ccdc_out_w - 1)
+					  << ISPCCDC_HORZ_INFO_NPH_SHIFT),
+				       OMAP3_ISP_IOMEM_CCDC,
+				       ISPCCDC_HORZ_INFO);
+		} else if (pipe->ccdc_in == CCDC_YUV_BT) {
+			isp_reg_writel(isp_ccdc->dev,
+					0 << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+					(((pipe->ccdc_out_w << 1) - 1) <<
+					 ISPCCDC_HORZ_INFO_NPH_SHIFT),
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_HORZ_INFO);
+			isp_reg_writel(isp_ccdc->dev,
+					2 << ISPCCDC_VERT_START_SLV0_SHIFT |
+					2 << ISPCCDC_VERT_START_SLV1_SHIFT,
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VERT_START);
+			isp_reg_writel(isp_ccdc->dev,
+					((pipe->ccdc_out_h >> 1) - 1) <<
+					ISPCCDC_VERT_LINES_NLV_SHIFT,
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VERT_LINES);
+		} else {
+			isp_reg_writel(isp_ccdc->dev,
+				       0 << ISPCCDC_HORZ_INFO_SPH_SHIFT
+				       | ((pipe->ccdc_out_w - 1)
+					  << ISPCCDC_HORZ_INFO_NPH_SHIFT),
+				       OMAP3_ISP_IOMEM_CCDC,
+				       ISPCCDC_HORZ_INFO);
+		}
+		ispccdc_config_outlineoffset(isp_ccdc, pipe->ccdc_out_w * 2,
+					     0, 0);
+		if (pipe->ccdc_in != CCDC_YUV_BT) {
+			isp_reg_writel(isp_ccdc->dev,
+					0 << ISPCCDC_VERT_START_SLV0_SHIFT,
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VERT_START);
+			isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_out_h - 1) <<
+					ISPCCDC_VERT_LINES_NLV_SHIFT,
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VERT_LINES);
+			isp_reg_writel(isp_ccdc->dev, (((pipe->ccdc_out_h - 2) &
+					ISPCCDC_VDINT_0_MASK) <<
+					ISPCCDC_VDINT_0_SHIFT) |
+					((100 & ISPCCDC_VDINT_1_MASK) <<
+					 ISPCCDC_VDINT_1_SHIFT),
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VDINT);
+		} else {
+			ispccdc_config_outlineoffset(isp_ccdc,
+					pipe->ccdc_out_w * 2, EVENEVEN, 1);
+			ispccdc_config_outlineoffset(isp_ccdc,
+					pipe->ccdc_out_w * 2, ODDEVEN, 1);
+			ispccdc_config_outlineoffset(isp_ccdc,
+					pipe->ccdc_out_w * 2, EVENODD, 1);
+			ispccdc_config_outlineoffset(isp_ccdc,
+					pipe->ccdc_out_w * 2, ODDODD, 1);
+			isp_reg_writel(isp_ccdc->dev,
+					((((pipe->ccdc_out_h >> 1) - 1) &
+					ISPCCDC_VDINT_0_MASK) <<
+					ISPCCDC_VDINT_0_SHIFT) |
+					((50 & ISPCCDC_VDINT_1_MASK) <<
+					 ISPCCDC_VDINT_1_SHIFT),
+					OMAP3_ISP_IOMEM_CCDC,
+					ISPCCDC_VDINT);
+		}
+
+	} else if (pipe->ccdc_out == CCDC_OTHERS_VP_MEM) {
+		isp_reg_writel(isp_ccdc->dev,
+			       (pipe->ccdc_in_h_st << ISPCCDC_FMT_HORZ_FMTSPH_SHIFT) |
+			       ((pipe->ccdc_in_w - pipe->ccdc_in_h_st) <<
+				ISPCCDC_FMT_HORZ_FMTLNH_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_FMT_HORZ);
+		isp_reg_writel(isp_ccdc->dev,
+			       (pipe->ccdc_in_v_st << ISPCCDC_FMT_VERT_FMTSLV_SHIFT) |
+			       ((pipe->ccdc_in_h - pipe->ccdc_in_v_st) <<
+				ISPCCDC_FMT_VERT_FMTLNV_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_FMT_VERT);
+		isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_out_w
+				<< ISPCCDC_VP_OUT_HORZ_NUM_SHIFT) |
+			       ((pipe->ccdc_out_h - 1) <<
+				ISPCCDC_VP_OUT_VERT_NUM_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VP_OUT);
+		isp_reg_writel(isp_ccdc->dev,
+			       pipe->ccdc_in_h_st << ISPCCDC_HORZ_INFO_SPH_SHIFT |
+			       ((pipe->ccdc_out_w - 1) <<
+				ISPCCDC_HORZ_INFO_NPH_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_HORZ_INFO);
+		isp_reg_writel(isp_ccdc->dev,
+			       pipe->ccdc_in_v_st << ISPCCDC_VERT_START_SLV0_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VERT_START);
+		isp_reg_writel(isp_ccdc->dev, (pipe->ccdc_out_h - 1) <<
+			       ISPCCDC_VERT_LINES_NLV_SHIFT,
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VERT_LINES);
+		ispccdc_config_outlineoffset(isp_ccdc, pipe->ccdc_out_w * 2,
+					     0, 0);
+		isp_reg_writel(isp_ccdc->dev, (((pipe->ccdc_out_h - 2) &
+				 ISPCCDC_VDINT_0_MASK) <<
+				ISPCCDC_VDINT_0_SHIFT) |
+			       ((100 & ISPCCDC_VDINT_1_MASK) <<
+				ISPCCDC_VDINT_1_SHIFT),
+			       OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_VDINT);
+	}
+
+	if (is_isplsc_activated()) {
+		if (pipe->ccdc_in == CCDC_RAW_GRBG ||
+		    pipe->ccdc_in == CCDC_RAW_RGGB ||
+		    pipe->ccdc_in == CCDC_RAW_BGGR ||
+		    pipe->ccdc_in == CCDC_RAW_GBRG) {
+			ispccdc_config_lsc(isp_ccdc, &isp_ccdc->lsc_config);
+			ispccdc_load_lsc(isp_ccdc, isp_ccdc->lsc_gain_table,
+					 isp_ccdc->lsc_config.size);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_s_pipeline);
+
+/**
+ * ispccdc_config_outlineoffset - Configure memory saving output line offset
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @offset: Address offset to start a new line. Must be twice the
+ *          Output width and aligned on 32 byte boundary
+ * @oddeven: Specifies the odd/even line pattern to be chosen to store the
+ *           output.
+ * @numlines: Set the value 0-3 for +1-4lines, 4-7 for -1-4lines.
+ *
+ * - Configures the output line offset when stored in memory
+ * - Sets the odd/even line pattern to store the output
+ *    (EVENEVEN (1), ODDEVEN (2), EVENODD (3), ODDODD (4))
+ * - Configures the number of even and odd line fields in case of rearranging
+ * the lines.
+ *
+ * Returns 0 if successful, or -EINVAL if the offset is not in 32 byte
+ * boundary.
+ **/
+int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
+				 u8 oddeven, u8 numlines)
+{
+	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
+		isp_reg_writel(isp_ccdc->dev, (offset & 0xFFFF),
+			       OMAP3_ISP_IOMEM_CCDC, ISPCCDC_HSIZE_OFF);
+	} else {
+		DPRINTK_ISPCCDC("ISP_ERR : Offset should be in 32 byte"
+				" boundary\n");
+		return -EINVAL;
+	}
+
+	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+		    ~ISPCCDC_SDOFST_FINV);
+
+	isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_SDOFST,
+		    ~ISPCCDC_SDOFST_FOFST_4L);
+
+	switch (oddeven) {
+	case EVENEVEN:
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			   ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST0_SHIFT);
+		break;
+	case ODDEVEN:
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			   ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST1_SHIFT);
+		break;
+	case EVENODD:
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			   ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST2_SHIFT);
+		break;
+	case ODDODD:
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			   ISPCCDC_SDOFST,
+			   (numlines & 0x7) << ISPCCDC_SDOFST_LOFST3_SHIFT);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(ispccdc_config_outlineoffset);
+
+/**
+ * ispccdc_set_outaddr - Set memory address to save output image
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @addr: ISP MMU Mapped 32-bit memory address aligned on 32 byte boundary.
+ *
+ * Returns 0 if successful, or -EINVAL if the address is not in the 32 byte
+ * boundary.
+ **/
+int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr)
+{
+	if ((addr & ISP_32B_BOUNDARY_BUF) == addr) {
+		isp_reg_writel(isp_ccdc->dev, addr, OMAP3_ISP_IOMEM_CCDC,
+			       ISPCCDC_SDR_ADDR);
+		return 0;
+	} else {
+		DPRINTK_ISPCCDC("ISP_ERR : Address should be in 32 byte"
+				" boundary\n");
+		return -EINVAL;
+	}
+
+}
+EXPORT_SYMBOL(ispccdc_set_outaddr);
+
+/**
+ * ispccdc_enable - Enable the CCDC module.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @enable: 0 Disables CCDC, 1 Enables CCDC
+ *
+ * Client should configure all the sub modules in CCDC before this.
+ **/
+void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable)
+{
+	struct isp_device *isp =
+		container_of(isp_ccdc, struct isp_device, isp_ccdc);
+
+	if (enable) {
+		if (isp_ccdc->lsc_enable &&
+		    ((isp->pipeline.ccdc_in == CCDC_RAW_GRBG) ||
+		     (isp->pipeline.ccdc_in == CCDC_RAW_RGGB) ||
+		     (isp->pipeline.ccdc_in == CCDC_RAW_BGGR) ||
+		     (isp->pipeline.ccdc_in == CCDC_RAW_GBRG)))
+			ispccdc_enable_lsc(isp_ccdc, 1);
+
+	} else {
+		int lsc_enable = isp_ccdc->lsc_state;
+
+		ispccdc_enable_lsc(isp_ccdc, 0);
+		isp_ccdc->lsc_enable = lsc_enable;
+	}
+
+	isp_reg_and_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_PCR,
+		       ~ISPCCDC_PCR_EN, enable ? ISPCCDC_PCR_EN : 0);
+}
+EXPORT_SYMBOL(ispccdc_enable);
+
+/**
+ * ispccdc_sbl_busy - Poll idle state of CCDC and related SBL memory write bits
+ * @_isp_ccdc: Pointer to ISP CCDC device.
+ *
+ * Returns zero if the CCDC is idle and the image has been written to
+ * memory, too.
+ **/
+int ispccdc_sbl_busy(void *_isp_ccdc)
+{
+	struct isp_ccdc_device *isp_ccdc = _isp_ccdc;
+
+	return ispccdc_busy(isp_ccdc)
+		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
+				 ISPSBL_CCDC_WR_0) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
+				 ISPSBL_CCDC_WR_1) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
+				 ISPSBL_CCDC_WR_2) &
+		   ISPSBL_CCDC_WR_0_DATA_READY)
+		| (isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_SBL,
+				 ISPSBL_CCDC_WR_3) &
+		   ISPSBL_CCDC_WR_0_DATA_READY);
+}
+EXPORT_SYMBOL(ispccdc_sbl_busy);
+
+/**
+ * ispccdc_config_y8pos - Configures the location of Y color component
+ * @mode: Y8POS_EVEN Y pixel in even position, otherwise Y pixel in odd
+ *
+ * Configures the location of Y color componenent for YCbCr 8-bit data
+ */
+void ispccdc_config_y8pos(struct isp_ccdc_device *isp_ccdc,
+		enum y8pos_mode mode)
+{
+	if (mode == Y8POS_EVEN) {
+		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+							~ISPCCDC_CFG_Y8POS);
+	} else {
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+							ISPCCDC_CFG_Y8POS);
+	}
+}
+EXPORT_SYMBOL(ispccdc_config_y8pos);
+
+/**
+ * ispccdc_config_byteswap - Configures byte swap data stored in memory
+ * @swap: 1 - swap bytes, 0 - normal
+ *
+ * Controls the order in which the Y and C pixels are stored in memory
+ */
+void ispccdc_config_byteswap(struct isp_ccdc_device *isp_ccdc, int swap)
+{
+	if (swap) {
+		isp_reg_or(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+							ISPCCDC_CFG_BSWD);
+	} else {
+		isp_reg_and(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC, ISPCCDC_CFG,
+							~ISPCCDC_CFG_BSWD);
+	}
+}
+EXPORT_SYMBOL(ispccdc_config_byteswap);
+
+/**
+ * ispccdc_busy - Get busy state of the CCDC.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ **/
+int ispccdc_busy(struct isp_ccdc_device *isp_ccdc)
+{
+	return isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_PCR) &
+		ISPCCDC_PCR_BUSY;
+}
+EXPORT_SYMBOL(ispccdc_busy);
+
+/**
+ * ispccdc_save_context - Save values of the CCDC module registers
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void ispccdc_save_context(struct device *dev)
+{
+	DPRINTK_ISPCCDC("Saving context\n");
+	isp_save_context(dev, ispccdc_reg_list);
+}
+EXPORT_SYMBOL(ispccdc_save_context);
+
+/**
+ * ispccdc_restore_context - Restore values of the CCDC module registers
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void ispccdc_restore_context(struct device *dev)
+{
+	DPRINTK_ISPCCDC("Restoring context\n");
+	isp_restore_context(dev, ispccdc_reg_list);
+}
+EXPORT_SYMBOL(ispccdc_restore_context);
+
+/**
+ * ispccdc_print_status - Print current CCDC Module register values.
+ * @isp_ccdc: Pointer to ISP CCDC device.
+ * @pipe: Pointer to current ISP pipeline structure.
+ *
+ * Also prints other debug information stored in the CCDC module.
+ **/
+void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
+			  struct isp_pipeline *pipe)
+{
+	if (!is_ispccdc_debug_enabled())
+		return;
+
+	DPRINTK_ISPCCDC("Module in use =%d\n", isp_ccdc->ccdc_inuse);
+	DPRINTK_ISPCCDC("Accepted CCDC Input (width = %d,Height = %d)\n",
+			isp_ccdc->ccdcin_w,
+			isp_ccdc->ccdcin_h);
+	DPRINTK_ISPCCDC("Accepted CCDC Output (width = %d,Height = %d)\n",
+			isp_ccdc->ccdcout_w,
+			isp_ccdc->ccdcout_h);
+	DPRINTK_ISPCCDC("###CCDC PCR=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_PCR));
+	DPRINTK_ISPCCDC("ISP_CTRL =0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_CTRL));
+	switch ((int)pipe->ccdc_in) {
+	case CCDC_RAW_GRBG:
+	case CCDC_RAW_RGGB:
+	case CCDC_RAW_BGGR:
+	case CCDC_RAW_GBRG:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_RAW\n");
+		break;
+	case CCDC_YUV_SYNC:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_SYNC\n");
+		break;
+	case CCDC_YUV_BT:
+		DPRINTK_ISPCCDC("ccdc input format is CCDC_YUV_BT\n");
+		break;
+	}
+
+	switch ((int)pipe->ccdc_out) {
+	case CCDC_OTHERS_VP:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_VP\n");
+		break;
+	case CCDC_OTHERS_MEM:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_OTHERS_MEM\n");
+		break;
+	case CCDC_YUV_RSZ:
+		DPRINTK_ISPCCDC("ccdc output format is CCDC_YUV_RSZ\n");
+		break;
+	}
+
+	DPRINTK_ISPCCDC("###ISP_CTRL in ccdc =0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_CTRL));
+	DPRINTK_ISPCCDC("###ISP_IRQ0ENABLE in ccdc =0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0ENABLE));
+	DPRINTK_ISPCCDC("###ISP_IRQ0STATUS in ccdc =0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0STATUS));
+	DPRINTK_ISPCCDC("###CCDC SYN_MODE=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SYN_MODE));
+	DPRINTK_ISPCCDC("###CCDC HORZ_INFO=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_HORZ_INFO));
+	DPRINTK_ISPCCDC("###CCDC VERT_START=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VERT_START));
+	DPRINTK_ISPCCDC("###CCDC VERT_LINES=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VERT_LINES));
+	DPRINTK_ISPCCDC("###CCDC CULLING=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CULLING));
+	DPRINTK_ISPCCDC("###CCDC HSIZE_OFF=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_HSIZE_OFF));
+	DPRINTK_ISPCCDC("###CCDC SDOFST=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDOFST));
+	DPRINTK_ISPCCDC("###CCDC SDR_ADDR=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDR_ADDR));
+	DPRINTK_ISPCCDC("###CCDC CLAMP=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CLAMP));
+	DPRINTK_ISPCCDC("###CCDC COLPTN=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_COLPTN));
+	DPRINTK_ISPCCDC("###CCDC CFG=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_CFG));
+	DPRINTK_ISPCCDC("###CCDC VP_OUT=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_VP_OUT));
+	DPRINTK_ISPCCDC("###CCDC_SDR_ADDR= 0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_SDR_ADDR));
+	DPRINTK_ISPCCDC("###CCDC FMTCFG=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMTCFG));
+	DPRINTK_ISPCCDC("###CCDC FMT_HORZ=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMT_HORZ));
+	DPRINTK_ISPCCDC("###CCDC FMT_VERT=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_FMT_VERT));
+	DPRINTK_ISPCCDC("###CCDC LSC_CONFIG=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_CONFIG));
+	DPRINTK_ISPCCDC("###CCDC LSC_INIT=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_INITIAL));
+	DPRINTK_ISPCCDC("###CCDC LSC_TABLE BASE=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_TABLE_BASE));
+	DPRINTK_ISPCCDC("###CCDC LSC TABLE OFFSET=0x%x\n",
+			isp_reg_readl(isp_ccdc->dev, OMAP3_ISP_IOMEM_CCDC,
+				      ISPCCDC_LSC_TABLE_OFFSET));
+}
+EXPORT_SYMBOL(ispccdc_print_status);
+
+/**
+ * isp_ccdc_init - CCDC module initialization.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ *
+ * Always returns 0
+ **/
+int __init isp_ccdc_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_ccdc_device *isp_ccdc = &isp->isp_ccdc;
+
+	isp_ccdc->ccdc_inuse = 0;
+	ispccdc_config_crop(isp_ccdc, 0, 0, 0, 0);
+	mutex_init(&isp_ccdc->mutexlock);
+	isp_ccdc->dev = dev;
+
+	if (is_isplsc_activated()) {
+		isp_ccdc->lsc_gain_table_tmp = kmalloc(LSC_TABLE_INIT_SIZE,
+						       GFP_KERNEL | GFP_DMA);
+		memset(isp_ccdc->lsc_gain_table_tmp, 0x40, LSC_TABLE_INIT_SIZE);
+		isp_ccdc->lsc_config.initial_x = 0;
+		isp_ccdc->lsc_config.initial_y = 0;
+		isp_ccdc->lsc_config.gain_mode_n = 0x6;
+		isp_ccdc->lsc_config.gain_mode_m = 0x6;
+		isp_ccdc->lsc_config.gain_format = 0x4;
+		isp_ccdc->lsc_config.offset = 0x60;
+		isp_ccdc->lsc_config.size = LSC_TABLE_INIT_SIZE;
+		isp_ccdc->lsc_enable = 1;
+	}
+
+	return 0;
+}
+
+/**
+ * isp_ccdc_cleanup - CCDC module cleanup.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ **/
+void isp_ccdc_cleanup(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_ccdc_device *isp_ccdc = &isp->isp_ccdc;
+
+	if (is_isplsc_activated()) {
+		ispccdc_free_lsc(isp_ccdc);
+		kfree(isp_ccdc->lsc_gain_table_tmp);
+	}
+
+	if (isp_ccdc->fpc_table_add_m != 0) {
+		iommu_kunmap(isp->iommu, isp_ccdc->fpc_table_add_m);
+		kfree(isp_ccdc->fpc_table_add);
+	}
+}
diff --git a/drivers/media/video/isp/ispccdc.h b/drivers/media/video/isp/ispccdc.h
new file mode 100644
index 0000000..07ba00d
--- /dev/null
+++ b/drivers/media/video/isp/ispccdc.h
@@ -0,0 +1,286 @@
+/*
+ * ispccdc.h
+ *
+ * Driver header file for CCDC module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Senthilvadivu Guruswamy <svadivu@ti.com>
+ *	Pallavi Kulkarni <p-kulkarni@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_CCDC_H
+#define OMAP_ISP_CCDC_H
+
+#include <plat/isp_user.h>
+
+#define is_isplsc_activated()		1
+
+/* Enumeration constants for CCDC input output format */
+enum ccdc_input {
+	CCDC_RAW_GRBG,
+	CCDC_RAW_RGGB,
+	CCDC_RAW_BGGR,
+	CCDC_RAW_GBRG,
+	CCDC_YUV_SYNC,
+	CCDC_YUV_BT,
+	CCDC_OTHERS
+};
+
+enum ccdc_output {
+	CCDC_YUV_RSZ,
+	CCDC_YUV_MEM_RSZ,
+	CCDC_OTHERS_VP,
+	CCDC_OTHERS_MEM,
+	CCDC_OTHERS_VP_MEM
+};
+
+/* Enumeration constants for the sync interface parameters */
+enum inpmode {
+	RAW,
+	YUV16,
+	YUV8
+};
+enum datasize {
+	DAT8,
+	DAT10,
+	DAT11,
+	DAT12
+};
+
+/* Enumeration constants for location of Y component in 8-bit YUV data */
+enum y8pos_mode {
+	Y8POS_EVEN = 0,
+	Y8POS_ODD = 1
+};
+
+/**
+ * struct ispccdc_syncif - Structure for Sync Interface between sensor and CCDC
+ * @ccdc_mastermode: Master mode. 1 - Master, 0 - Slave.
+ * @fldstat: Field state. 0 - Odd Field, 1 - Even Field.
+ * @ipmod: Input mode.
+ * @datsz: Data size.
+ * @fldmode: 0 - Progressive, 1 - Interlaced.
+ * @datapol: 0 - Positive, 1 - Negative.
+ * @fldpol: 0 - Positive, 1 - Negative.
+ * @hdpol: 0 - Positive, 1 - Negative.
+ * @vdpol: 0 - Positive, 1 - Negative.
+ * @fldout: 0 - Input, 1 - Output.
+ * @hs_width: Width of the Horizontal Sync pulse, used for HS/VS Output.
+ * @vs_width: Width of the Vertical Sync pulse, used for HS/VS Output.
+ * @ppln: Number of pixels per line, used for HS/VS Output.
+ * @hlprf: Number of half lines per frame, used for HS/VS Output.
+ * @bt_r656_en: 1 - Enable ITU-R BT656 mode, 0 - Sync mode.
+ */
+struct ispccdc_syncif {
+	u8 ccdc_mastermode;
+	u8 fldstat;
+	enum inpmode ipmod;
+	enum datasize datsz;
+	u8 fldmode;
+	u8 datapol;
+	u8 fldpol;
+	u8 hdpol;
+	u8 vdpol;
+	u8 fldout;
+	u8 hs_width;
+	u8 vs_width;
+	u8 ppln;
+	u8 hlprf;
+	u8 bt_r656_en;
+};
+
+/**
+ * ispccdc_refmt - Structure for Reformatter parameters
+ * @lnalt: Line alternating mode enable. 0 - Enable, 1 - Disable.
+ * @lnum: Number of output lines from 1 input line. 1 to 4 lines.
+ * @plen_even: Number of program entries in even line minus 1.
+ * @plen_odd: Number of program entries in odd line minus 1.
+ * @prgeven0: Program entries 0-7 for even lines register
+ * @prgeven1: Program entries 8-15 for even lines register
+ * @prgodd0: Program entries 0-7 for odd lines register
+ * @prgodd1: Program entries 8-15 for odd lines register
+ * @fmtaddr0: Output line in which the original pixel is to be placed
+ * @fmtaddr1: Output line in which the original pixel is to be placed
+ * @fmtaddr2: Output line in which the original pixel is to be placed
+ * @fmtaddr3: Output line in which the original pixel is to be placed
+ * @fmtaddr4: Output line in which the original pixel is to be placed
+ * @fmtaddr5: Output line in which the original pixel is to be placed
+ * @fmtaddr6: Output line in which the original pixel is to be placed
+ * @fmtaddr7: Output line in which the original pixel is to be placed
+ */
+struct ispccdc_refmt {
+	u8 lnalt;
+	u8 lnum;
+	u8 plen_even;
+	u8 plen_odd;
+	u32 prgeven0;
+	u32 prgeven1;
+	u32 prgodd0;
+	u32 prgodd1;
+	u32 fmtaddr0;
+	u32 fmtaddr1;
+	u32 fmtaddr2;
+	u32 fmtaddr3;
+	u32 fmtaddr4;
+	u32 fmtaddr5;
+	u32 fmtaddr6;
+	u32 fmtaddr7;
+};
+
+/**
+ * struct isp_ccdc_device - Structure for the CCDC module to store its own
+ *			    information
+ * @ccdc_inuse: Flag to determine if CCDC has been reserved or not (0 or 1).
+ * @ccdcin_woffset: CCDC input horizontal offset.
+ * @ccdcin_hoffset: CCDC input vertical offset.
+ * @crop_w: Crop width.
+ * @crop_h: Crop weight.
+ * @vpout_en: Video port output enable.
+ * @wen: Data write enable.
+ * @exwen: External data write enable.
+ * @refmt_en: Reformatter enable.
+ * @ccdcslave: CCDC slave mode enable.
+ * @syncif_ipmod: Image
+ * @obclamp_en: Data input format.
+ * @lsc_enable: Pending enable of the LSC.
+ * @lsc_initialized: Is LSC initialized?
+ * @lsc_state: Enable state of the LSC.
+ * @mutexlock: Mutex used to get access to the CCDC.
+ * @wenlog: Write Enable logic to use against valid data signal.
+ * @lsc_gain_table_tmp: Pointer to Virtual address of temporary LSC table.
+ * @lsc_ispmmu_addr: ISP MMU mapped address of the current used LSC table.
+ * @lsc_gain_table: Virtual address of the current used LSC table.
+ * @lsc_config: Pointer to LSC configuration structure.
+ * @fpc_table_add_m: ISP MMU mapped address of the current used FPC table.
+ * @fpc_table_add: Virtual address of the current used FPC table.
+ * @dev: Device pointer specific to the OMAP3 ISP.
+ */
+struct isp_ccdc_device {
+	u8 ccdc_inuse;
+	u32 ccdcin_woffset;
+	u32 ccdcin_hoffset;
+	u32 crop_w;
+	u32 crop_h;
+	u8 vpout_en;
+	u8 wen;
+	u8 exwen;
+	u8 refmt_en;
+	u8 ccdcslave;
+	u8 syncif_ipmod;
+	u8 obclamp_en;
+	u8 lsc_enable;
+	u8 lsc_initialized;
+	int lsc_state;
+	struct mutex mutexlock; /* For checking/modifying ccdc_inuse */
+	u32 wenlog;
+	u8 *lsc_gain_table_tmp;
+	unsigned long lsc_ispmmu_addr;
+	u8 *lsc_gain_table;
+	struct ispccdc_lsc_config lsc_config;
+	unsigned long fpc_table_add_m;
+	u32 *fpc_table_add;
+	struct device *dev;
+};
+
+int ispccdc_request(struct isp_ccdc_device *isp_ccdc);
+
+int ispccdc_free(struct isp_ccdc_device *isp_ccdc);
+
+void ispccdc_config_crop(struct isp_ccdc_device *isp_ccdc, u32 left, u32 top,
+			 u32 height, u32 width);
+
+void ispccdc_config_sync_if(struct isp_ccdc_device *isp_ccdc,
+			    struct ispccdc_syncif syncif);
+
+int ispccdc_config_black_clamp(struct isp_ccdc_device *isp_ccdc,
+			       struct ispccdc_bclamp bclamp);
+
+void ispccdc_enable_black_clamp(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+int ispccdc_config_fpc(struct isp_ccdc_device *isp_ccdc,
+		       struct ispccdc_fpc fpc);
+
+void ispccdc_enable_fpc(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+void ispccdc_config_black_comp(struct isp_ccdc_device *isp_ccdc,
+			       struct ispccdc_blcomp blcomp);
+
+void ispccdc_config_vp(struct isp_ccdc_device *isp_ccdc, struct ispccdc_vp vp);
+
+void ispccdc_enable_vp(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+void ispccdc_config_reformatter(struct isp_ccdc_device *isp_ccdc,
+				struct ispccdc_refmt refmt);
+
+void ispccdc_enable_reformatter(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+void ispccdc_config_culling(struct isp_ccdc_device *isp_ccdc,
+			    struct ispccdc_culling culling);
+
+void ispccdc_enable_lpf(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+void ispccdc_config_alaw(struct isp_ccdc_device *isp_ccdc,
+			 enum alaw_ipwidth ipwidth);
+
+void ispccdc_enable_alaw(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+int ispccdc_load_lsc(struct isp_ccdc_device *isp_ccdc, u8 *table_addr,
+		     u32 table_size);
+
+void ispccdc_config_lsc(struct isp_ccdc_device *isp_ccdc,
+			struct ispccdc_lsc_config *lsc_cfg);
+
+void ispccdc_enable_lsc(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+void ispccdc_lsc_error_handler(struct isp_ccdc_device *isp_ccdc);
+
+void ispccdc_config_imgattr(struct isp_ccdc_device *isp_ccdc, u32 colptn);
+
+void ispccdc_config_shadow_registers(struct isp_ccdc_device *isp_ccdc);
+
+int ispccdc_try_pipeline(struct isp_ccdc_device *isp_ccdc,
+			 struct isp_pipeline *pipe);
+
+int ispccdc_s_pipeline(struct isp_ccdc_device *isp_ccdc,
+		       struct isp_pipeline *pipe);
+
+int ispccdc_config_outlineoffset(struct isp_ccdc_device *isp_ccdc, u32 offset,
+				 u8 oddeven, u8 numlines);
+
+int ispccdc_set_outaddr(struct isp_ccdc_device *isp_ccdc, u32 addr);
+
+void ispccdc_enable(struct isp_ccdc_device *isp_ccdc, u8 enable);
+
+int ispccdc_sbl_busy(void *_isp_ccdc);
+
+int ispccdc_busy(struct isp_ccdc_device *isp_ccdc);
+
+void ispccdc_save_context(struct device *dev);
+
+void ispccdc_restore_context(struct device *dev);
+
+void ispccdc_print_status(struct isp_ccdc_device *isp_ccdc,
+			  struct isp_pipeline *pipe);
+
+int omap34xx_isp_ccdc_config(struct isp_ccdc_device *isp_ccdc,
+			     void *userspace_add);
+
+void ispccdc_set_wenlog(struct isp_ccdc_device *isp_ccdc, u32 wenlog);
+
+void ispccdc_config_y8pos(struct isp_ccdc_device *isp_ccdc,
+				enum y8pos_mode mode);
+
+void ispccdc_config_byteswap(struct isp_ccdc_device *isp_ccdc, int swap);
+
+#endif		/* OMAP_ISP_CCDC_H */
diff --git a/drivers/media/video/isp/ispcsi2.c b/drivers/media/video/isp/ispcsi2.c
new file mode 100644
index 0000000..e370c13
--- /dev/null
+++ b/drivers/media/video/isp/ispcsi2.c
@@ -0,0 +1,2276 @@
+/*
+ * ispcsi2.c
+ *
+ * Driver Library for ISP CSI Control module in TI's OMAP3 Camera ISP
+ * ISP CSI interface and IRQ related APIs are defined here.
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Dominic Curran <dcurran@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/delay.h>
+#include <media/v4l2-common.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "ispcsi2.h"
+
+static struct isp_csi2_cfg current_csi2_cfg;
+static struct isp_csi2_cfg_update current_csi2_cfg_update;
+
+static bool update_complexio_cfg1;
+static bool update_phy_cfg0;
+static bool update_phy_cfg1;
+static bool update_ctx_ctrl1[8];
+static bool update_ctx_ctrl2[8];
+static bool update_ctx_ctrl3[8];
+static bool update_timing;
+static bool update_ctrl;
+static bool uses_videoport;
+
+/* Structure for saving/restoring CSI2 module registers*/
+static struct isp_reg ispcsi2_reg_list[] = {
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_SYSCONFIG, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_SYSSTATUS, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_IRQSTATUS, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_IRQENABLE, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTRL, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_DBG_H, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_GNQ, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_COMPLEXIO_CFG1, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_COMPLEXIO1_IRQSTATUS, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_SHORT_PACKET, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_COMPLEXIO1_IRQENABLE, 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_CTRL1(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_CTRL2(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_DAT_OFST(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_DAT_PING_ADDR(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_DAT_PONG_ADDR(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_IRQENABLE(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_IRQSTATUS(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_CTX_CTRL3(0), 0},
+	{OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG0, 0},
+	{OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG1, 0},
+	{0, ISP_TOK_TERM, 0}
+};
+
+/**
+ * isp_csi2_complexio_lanes_config - Configuration of CSI2 ComplexIO lanes.
+ * @reqcfg: Pointer to structure containing desired lane configuration
+ *
+ * Validates and saves to internal driver memory the passed configuration.
+ * Returns 0 if successful, or -EINVAL if null pointer is passed, invalid
+ * lane position or polarity is set, and if 2 lanes try to occupy the same
+ * position. To apply this settings, use the isp_csi2_complexio_lanes_update()
+ * function just after calling this function.
+ **/
+int isp_csi2_complexio_lanes_config(struct isp_csi2_lanes_cfg *reqcfg)
+{
+	int i;
+	bool pos_occupied[5] = {false, false, false, false, false};
+	struct isp_csi2_lanes_cfg *currlanes = &current_csi2_cfg.lanes;
+	struct isp_csi2_lanes_cfg_update *currlanes_u =
+		&current_csi2_cfg_update.lanes;
+
+	/* Validating parameters sent by driver */
+	if (reqcfg == NULL) {
+		printk(KERN_ERR "Invalid Complex IO Configuration sent by"
+		       " sensor\n");
+		goto err_einval;
+	}
+
+	/* Data lanes verification */
+	for (i = 0; i < 4; i++) {
+		if ((reqcfg->data[i].pol > 1) || (reqcfg->data[i].pos > 5)) {
+			printk(KERN_ERR "Invalid CSI-2 Complex IO configuration"
+			       " parameters for data lane #%d\n", i);
+			goto err_einval;
+		}
+		if (pos_occupied[reqcfg->data[i].pos - 1] &&
+		    reqcfg->data[i].pos > 0) {
+			printk(KERN_ERR "Lane #%d already occupied\n",
+			       reqcfg->data[i].pos);
+			goto err_einval;
+		} else
+			pos_occupied[reqcfg->data[i].pos - 1] = true;
+	}
+
+	/* Clock lane verification */
+	if ((reqcfg->clk.pol > 1) || (reqcfg->clk.pos > 5) ||
+	    (reqcfg->clk.pos == 0)) {
+		printk(KERN_ERR "Invalid CSI-2 Complex IO configuration"
+		       " parameters for clock lane\n");
+		goto err_einval;
+	}
+	if (pos_occupied[reqcfg->clk.pos - 1]) {
+		printk(KERN_ERR "Lane #%d already occupied",
+		       reqcfg->clk.pos);
+		goto err_einval;
+	} else
+		pos_occupied[reqcfg->clk.pos - 1] = true;
+
+	for (i = 0; i < 4; i++) {
+		if (currlanes->data[i].pos != reqcfg->data[i].pos) {
+			currlanes->data[i].pos = reqcfg->data[i].pos;
+			currlanes_u->data[i] = true;
+			update_complexio_cfg1 = true;
+		}
+		if (currlanes->data[i].pol != reqcfg->data[i].pol) {
+			currlanes->data[i].pol = reqcfg->data[i].pol;
+			currlanes_u->data[i] = true;
+			update_complexio_cfg1 = true;
+		}
+		/* If the lane position is non zero then we can assume that
+		 * the initial lane state is on.
+		 */
+		if (currlanes->data[i].pos)
+			currlanes->data[i].state = ISP_CSI2_LANE_ON;
+	}
+
+	if (currlanes->clk.pos != reqcfg->clk.pos) {
+		currlanes->clk.pos = reqcfg->clk.pos;
+		currlanes_u->clk = true;
+		update_complexio_cfg1 = true;
+	}
+	if (currlanes->clk.pol != reqcfg->clk.pol) {
+		currlanes->clk.pol = reqcfg->clk.pol;
+		currlanes_u->clk = true;
+		update_complexio_cfg1 = true;
+	}
+	return 0;
+err_einval:
+	return -EINVAL;
+}
+
+/**
+ * isp_csi2_complexio_lanes_update - Applies CSI2 ComplexIO lanes configuration.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_complexio_lanes_config() function.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_complexio_lanes_config() function, unless the force_update flag is
+ * set to true.
+ * Always returns 0.
+ **/
+int isp_csi2_complexio_lanes_update(bool force_update)
+{
+	struct isp_csi2_lanes_cfg *currlanes = &current_csi2_cfg.lanes;
+	struct isp_csi2_lanes_cfg_update *currlanes_u =
+		&current_csi2_cfg_update.lanes;
+	u32 reg;
+	int i;
+
+	if (!update_complexio_cfg1 && !force_update)
+		return 0;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_COMPLEXIO_CFG1);
+	for (i = 0; i < 4; i++) {
+		if (currlanes_u->data[i] || force_update) {
+			reg &= ~(ISPCSI2_COMPLEXIO_CFG1_DATA_POL_MASK(i + 1) |
+				 ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_MASK(i +
+									   1));
+			reg |= (currlanes->data[i].pol <<
+				ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(i + 1));
+			if (currlanes->data[i].state == ISP_CSI2_LANE_ON)
+				reg |= (currlanes->data[i].pos <<
+				ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(i +
+					1));
+			currlanes_u->data[i] = false;
+		}
+	}
+
+	if (currlanes_u->clk || force_update) {
+		reg &= ~(ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_MASK |
+			 ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_MASK);
+		reg |= (currlanes->clk.pol <<
+			ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT);
+		reg |= (currlanes->clk.pos <<
+			ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT);
+		currlanes_u->clk = false;
+	}
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_COMPLEXIO_CFG1);
+
+	update_complexio_cfg1 = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_complexio_lanes_count - Turn data lanes on/off dynamically.
+ * @ cnt: Number of data lanes to enable.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_complexio_lanes_count(int cnt)
+{
+	struct isp_csi2_lanes_cfg *currlanes = &current_csi2_cfg.lanes;
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		if (i < cnt)
+			currlanes->data[i].state = ISP_CSI2_LANE_ON;
+		else
+			currlanes->data[i].state = ISP_CSI2_LANE_OFF;
+	}
+
+	isp_csi2_complexio_lanes_update(true);
+	return 0;
+}
+EXPORT_SYMBOL(isp_csi2_complexio_lanes_count);
+
+/**
+ * isp_csi2_complexio_lanes_get - Gets CSI2 ComplexIO lanes configuration.
+ *
+ * Gets settings from HW registers and fills in the internal driver memory
+ * Always returns 0.
+ **/
+int isp_csi2_complexio_lanes_get(void)
+{
+	struct isp_csi2_lanes_cfg *currlanes = &current_csi2_cfg.lanes;
+	struct isp_csi2_lanes_cfg_update *currlanes_u =
+		&current_csi2_cfg_update.lanes;
+	u32 reg;
+	int i;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_COMPLEXIO_CFG1);
+	for (i = 0; i < 4; i++) {
+		currlanes->data[i].pol = (reg &
+			  ISPCSI2_COMPLEXIO_CFG1_DATA_POL_MASK(i + 1)) >>
+			ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(i + 1);
+		currlanes->data[i].pos = (reg &
+			  ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_MASK(i + 1)) >>
+			ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(i + 1);
+		currlanes_u->data[i] = false;
+	}
+	currlanes->clk.pol = (reg & ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_MASK) >>
+		ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT;
+	currlanes->clk.pos = (reg &
+			      ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_MASK) >>
+		ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT;
+	currlanes_u->clk = false;
+
+	update_complexio_cfg1 = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_complexio_power_status - Gets CSI2 ComplexIO power status.
+ *
+ * Returns 3 possible valid states: ISP_CSI2_POWER_OFF, ISP_CSI2_POWER_ON,
+ * and ISP_CSI2_POWER_ULPW.
+ **/
+static enum isp_csi2_power_cmds isp_csi2_complexio_power_status(void)
+{
+	enum isp_csi2_power_cmds ret;
+	u32 reg;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_COMPLEXIO_CFG1) &
+		ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_MASK;
+	switch (reg) {
+	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_OFF:
+		ret = ISP_CSI2_POWER_OFF;
+		break;
+	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ON:
+		ret = ISP_CSI2_POWER_ON;
+		break;
+	case ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ULPW:
+		ret = ISP_CSI2_POWER_ULPW;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ret;
+}
+
+/**
+ * isp_csi2_complexio_power_autoswitch - Sets CSI2 ComplexIO power autoswitch.
+ * @enable: Sets or clears the autoswitch function enable flag.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_complexio_power_autoswitch(bool enable)
+{
+	u32 reg;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_COMPLEXIO_CFG1);
+	reg &= ~ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_MASK;
+
+	if (enable)
+		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_ENABLE;
+	else
+		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_DISABLE;
+
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_COMPLEXIO_CFG1);
+	return 0;
+}
+
+/**
+ * isp_csi2_complexio_power - Sets the desired power command for CSI2 ComplexIO.
+ * @power_cmd: Power command to be set.
+ *
+ * Returns 0 if successful, or -EBUSY if the retry count is exceeded.
+ **/
+int isp_csi2_complexio_power(enum isp_csi2_power_cmds power_cmd)
+{
+	enum isp_csi2_power_cmds current_state;
+	u32 reg;
+	u8 retry_count;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_COMPLEXIO_CFG1) &
+		~ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_MASK;
+	switch (power_cmd) {
+	case ISP_CSI2_POWER_OFF:
+		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_OFF;
+		break;
+	case ISP_CSI2_POWER_ON:
+		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ON;
+		break;
+	case ISP_CSI2_POWER_ULPW:
+		reg |= ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ULPW;
+		break;
+	default:
+		printk(KERN_ERR "CSI2: ERROR - Wrong Power command!\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_COMPLEXIO_CFG1);
+
+	retry_count = 0;
+	do {
+		udelay(50);
+		current_state = isp_csi2_complexio_power_status();
+
+		if (current_state != power_cmd) {
+			printk(KERN_DEBUG "CSI2: Complex IO power command not"
+			       " yet taken.");
+			if (++retry_count < 100) {
+				printk(KERN_DEBUG " Retrying...\n");
+				udelay(50);
+			} else {
+				printk(KERN_DEBUG " Retry count exceeded!\n");
+			}
+		}
+	} while ((current_state != power_cmd) && (retry_count < 100));
+
+	if (retry_count == 100)
+		return -EBUSY;
+
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_frame_mode - Configure if_en behaviour for CSI2
+ * @frame_mode: Desired action for IF_EN switch off. 0 - disable IF immediately
+ *              1 - disable after all Frame end Code is received in all
+ *              contexts.
+ *
+ * Validates and saves to internal driver memory the passed configuration.
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_frame_mode(enum isp_csi2_frame_mode frame_mode)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->frame_mode != frame_mode) {
+		currctrl->frame_mode = frame_mode;
+		currctrl_u->frame_mode = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_vp_clk_enable - Enables/disables CSI2 Videoport clock.
+ * @vp_clk_enable: Boolean value to specify the Videoport clock state.
+ *
+ * Validates and saves to internal driver memory the passed configuration.
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_vp_clk_enable(bool vp_clk_enable)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->vp_clk_enable != vp_clk_enable) {
+		currctrl->vp_clk_enable = vp_clk_enable;
+		currctrl_u->vp_clk_enable = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_vp_only_enable - Sets CSI2 Videoport clock as exclusive
+ * @vp_only_enable: Boolean value to specify if the Videoport clock is
+ *                  exclusive, setting the OCP port as disabled.
+ *
+ * Validates and saves to internal driver memory the passed configuration.
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_vp_only_enable(bool vp_only_enable)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->vp_only_enable != vp_only_enable) {
+		currctrl->vp_only_enable = vp_only_enable;
+		currctrl_u->vp_only_enable = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_vp_out_ctrl - Sets CSI2 Videoport clock divider
+ * @vp_out_ctrl: Divider value for setting videoport clock frequency based on
+ *               OCP port frequency, valid dividers are between 1 and 4.
+ *
+ * Validates and saves to internal driver memory the passed configuration.
+ * Returns 0 if successful, or -EINVAL if wrong divider value is passed.
+ **/
+int isp_csi2_ctrl_config_vp_out_ctrl(u8 vp_out_ctrl)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if ((vp_out_ctrl == 0) || (vp_out_ctrl > 4)) {
+		printk(KERN_ERR "CSI2: Wrong divisor value. Must be between"
+		       " 1 and 4");
+		return -EINVAL;
+	}
+
+	if (currctrl->vp_out_ctrl != vp_out_ctrl) {
+		currctrl->vp_out_ctrl = vp_out_ctrl;
+		currctrl_u->vp_out_ctrl = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_debug_enable - Sets CSI2 debug
+ * @debug_enable: Boolean for setting debug configuration on CSI2.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_debug_enable(bool debug_enable)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->debug_enable != debug_enable) {
+		currctrl->debug_enable = debug_enable;
+		currctrl_u->debug_enable = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_burst_size - Sets CSI2 burst size.
+ * @burst_size: Burst size of the memory saving capability of receiver.
+ *
+ * Returns 0 if successful, or -EINVAL if burst size is wrong.
+ **/
+int isp_csi2_ctrl_config_burst_size(u8 burst_size)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+	if (burst_size > 3) {
+		printk(KERN_ERR "CSI2: Wrong burst size. Must be between"
+		       " 0 and 3");
+		return -EINVAL;
+	}
+
+	if (currctrl->burst_size != burst_size) {
+		currctrl->burst_size = burst_size;
+		currctrl_u->burst_size = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_ecc_enable - Enables ECC on CSI2 Receiver
+ * @ecc_enable: Boolean to enable/disable the CSI2 receiver ECC handling.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_ecc_enable(bool ecc_enable)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->ecc_enable != ecc_enable) {
+		currctrl->ecc_enable = ecc_enable;
+		currctrl_u->ecc_enable = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_ecc_enable - Enables ECC on CSI2 Receiver
+ * @ecc_enable: Boolean to enable/disable the CSI2 receiver ECC handling.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_secure_mode(bool secure_mode)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->secure_mode != secure_mode) {
+		currctrl->secure_mode = secure_mode;
+		currctrl_u->secure_mode = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_config_if_enable - Enables CSI2 Receiver interface.
+ * @if_enable: Boolean to enable/disable the CSI2 receiver interface.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_config_if_enable(bool if_enable)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+
+	if (currctrl->if_enable != if_enable) {
+		currctrl->if_enable = if_enable;
+		currctrl_u->if_enable = true;
+		update_ctrl = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_update - Applies CSI2 control configuration.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_ctrl_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_ctrl_config_*() functions, unless the force_update flag is
+ * set to true.
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_update(bool force_update)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+	u32 reg;
+
+	if (update_ctrl || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_CTRL);
+		if (currctrl_u->frame_mode || force_update) {
+			reg &= ~ISPCSI2_CTRL_FRAME_MASK;
+			if (currctrl->frame_mode)
+				reg |= ISPCSI2_CTRL_FRAME_DISABLE_FEC;
+			else
+				reg |= ISPCSI2_CTRL_FRAME_DISABLE_IMM;
+			currctrl_u->frame_mode = false;
+		}
+		if (currctrl_u->vp_clk_enable || force_update) {
+			reg &= ~ISPCSI2_CTRL_VP_CLK_EN_MASK;
+			if (currctrl->vp_clk_enable)
+				reg |= ISPCSI2_CTRL_VP_CLK_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_VP_CLK_EN_DISABLE;
+			currctrl_u->vp_clk_enable = false;
+		}
+		if (currctrl_u->vp_only_enable || force_update) {
+			reg &= ~ISPCSI2_CTRL_VP_ONLY_EN_MASK;
+			uses_videoport = currctrl->vp_only_enable;
+			if (currctrl->vp_only_enable)
+				reg |= ISPCSI2_CTRL_VP_ONLY_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_VP_ONLY_EN_DISABLE;
+			currctrl_u->vp_only_enable = false;
+		}
+		if (currctrl_u->vp_out_ctrl || force_update) {
+			reg &= ~ISPCSI2_CTRL_VP_OUT_CTRL_MASK;
+			reg |= (currctrl->vp_out_ctrl - 1) <<
+				ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT;
+			currctrl_u->vp_out_ctrl = false;
+		}
+		if (currctrl_u->debug_enable || force_update) {
+			reg &= ~ISPCSI2_CTRL_DBG_EN_MASK;
+			if (currctrl->debug_enable)
+				reg |= ISPCSI2_CTRL_DBG_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_DBG_EN_DISABLE;
+			currctrl_u->debug_enable = false;
+		}
+		if (currctrl_u->burst_size || force_update) {
+			reg &= ~ISPCSI2_CTRL_BURST_SIZE_MASK;
+			reg |= currctrl->burst_size <<
+				ISPCSI2_CTRL_BURST_SIZE_SHIFT;
+			currctrl_u->burst_size = false;
+		}
+		if (currctrl_u->ecc_enable || force_update) {
+			reg &= ~ISPCSI2_CTRL_ECC_EN_MASK;
+			if (currctrl->ecc_enable)
+				reg |= ISPCSI2_CTRL_ECC_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_ECC_EN_DISABLE;
+			currctrl_u->ecc_enable = false;
+		}
+		if (currctrl_u->secure_mode || force_update) {
+			reg &= ~ISPCSI2_CTRL_SECURE_MASK;
+			if (currctrl->secure_mode)
+				reg |= ISPCSI2_CTRL_SECURE_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_SECURE_DISABLE;
+			currctrl_u->secure_mode = false;
+		}
+		if (currctrl_u->if_enable || force_update) {
+			reg &= ~ISPCSI2_CTRL_IF_EN_MASK;
+			if (currctrl->if_enable)
+				reg |= ISPCSI2_CTRL_IF_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTRL_IF_EN_DISABLE;
+			currctrl_u->if_enable = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTRL);
+		update_ctrl = false;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctrl_get - Gets CSI2 control configuration
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctrl_get(void)
+{
+	struct isp_csi2_ctrl_cfg *currctrl = &current_csi2_cfg.ctrl;
+	struct isp_csi2_ctrl_cfg_update *currctrl_u =
+		&current_csi2_cfg_update.ctrl;
+	u32 reg;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_CTRL);
+	currctrl->frame_mode = (reg & ISPCSI2_CTRL_FRAME_MASK) >>
+		ISPCSI2_CTRL_FRAME_SHIFT;
+	currctrl_u->frame_mode = false;
+
+	if ((reg & ISPCSI2_CTRL_VP_CLK_EN_MASK) ==
+	    ISPCSI2_CTRL_VP_CLK_EN_ENABLE)
+		currctrl->vp_clk_enable = true;
+	else
+		currctrl->vp_clk_enable = false;
+	currctrl_u->vp_clk_enable = false;
+
+	if ((reg & ISPCSI2_CTRL_VP_ONLY_EN_MASK) ==
+	    ISPCSI2_CTRL_VP_ONLY_EN_ENABLE)
+		currctrl->vp_only_enable = true;
+	else
+		currctrl->vp_only_enable = false;
+	uses_videoport = currctrl->vp_only_enable;
+	currctrl_u->vp_only_enable = false;
+
+	currctrl->vp_out_ctrl = ((reg & ISPCSI2_CTRL_VP_OUT_CTRL_MASK) >>
+				 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT) + 1;
+	currctrl_u->vp_out_ctrl = false;
+
+	if ((reg & ISPCSI2_CTRL_DBG_EN_MASK) == ISPCSI2_CTRL_DBG_EN_ENABLE)
+		currctrl->debug_enable = true;
+	else
+		currctrl->debug_enable = false;
+	currctrl_u->debug_enable = false;
+
+	currctrl->burst_size = (reg & ISPCSI2_CTRL_BURST_SIZE_MASK) >>
+		ISPCSI2_CTRL_BURST_SIZE_SHIFT;
+	currctrl_u->burst_size = false;
+
+	if ((reg & ISPCSI2_CTRL_ECC_EN_MASK) == ISPCSI2_CTRL_ECC_EN_ENABLE)
+		currctrl->ecc_enable = true;
+	else
+		currctrl->ecc_enable = false;
+	currctrl_u->ecc_enable = false;
+
+	if ((reg & ISPCSI2_CTRL_SECURE_MASK) == ISPCSI2_CTRL_SECURE_ENABLE)
+		currctrl->secure_mode = true;
+	else
+		currctrl->secure_mode = false;
+	currctrl_u->secure_mode = false;
+
+	if ((reg & ISPCSI2_CTRL_IF_EN_MASK) == ISPCSI2_CTRL_IF_EN_ENABLE)
+		currctrl->if_enable = true;
+	else
+		currctrl->if_enable = false;
+	currctrl_u->if_enable = false;
+
+	update_ctrl = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_validate - Validates the context number value
+ * @ctxnum: Pointer to variable containing context number.
+ *
+ * If the value is not in range (3 bits), it is being ANDed with 0x7 to force
+ * it to be on range.
+ **/
+static void isp_csi2_ctx_validate(u8 *ctxnum)
+{
+	if (*ctxnum > 7) {
+		printk(KERN_ERR "Invalid context number. Forcing valid"
+		       " value...\n");
+		*ctxnum &= ~(0x7);
+	}
+}
+
+/**
+ * isp_csi2_ctx_config_virtual_id - Maps a virtual ID with a CSI2 Rx context
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @virtual_id: CSI2 Virtual ID to associate with specified context number.
+ *
+ * Returns 0 if successful, or -EINVAL if Virtual ID is not in range (0-3).
+ **/
+int isp_csi2_ctx_config_virtual_id(u8 ctxnum, u8 virtual_id)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	if (virtual_id > 3) {
+		printk(KERN_ERR "Wrong requested virtual_id\n");
+		return -EINVAL;
+	}
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->virtual_id != virtual_id) {
+		selected_ctx->virtual_id = virtual_id;
+		selected_ctx_u->virtual_id = true;
+		update_ctx_ctrl2[ctxnum] = true;
+	}
+
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_frame_count - Sets frame count to be received in CSI2 Rx.
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @frame_count: Number of frames to acquire.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_frame_count(u8 ctxnum, u8 frame_count)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->frame_count != frame_count) {
+		selected_ctx->frame_count = frame_count;
+		selected_ctx_u->frame_count = true;
+		update_ctx_ctrl1[ctxnum] = true;
+	}
+
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_format - Maps a pixel format to a specified context.
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @pixformat: V4L2 structure for pixel format.
+ *
+ * Returns 0 if successful, or -EINVAL if the format is not supported by the
+ * receiver.
+ **/
+int isp_csi2_ctx_config_format(u8 ctxnum, u32 pixformat)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	struct v4l2_pix_format pix;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	pix.pixelformat = pixformat;
+	switch (pix.pixelformat) {
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+	case V4L2_PIX_FMT_RGB555:
+	case V4L2_PIX_FMT_RGB555X:
+	case V4L2_PIX_FMT_SGRBG10:
+		break;
+	default:
+		printk(KERN_ERR "Context config pixel format unsupported\n");
+		return -EINVAL;
+	}
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	selected_ctx->format = pix;
+	selected_ctx_u->format = true;
+	update_ctx_ctrl2[ctxnum] = true;
+
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_alpha - Sets the alpha value for pixel format
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @alpha: Alpha value.
+ *
+ * Returns 0 if successful, or -EINVAL if the alpha value is bigger than 16383.
+ **/
+int isp_csi2_ctx_config_alpha(u8 ctxnum, u16 alpha)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	if (alpha > 0x3FFF) {
+		printk(KERN_ERR "Wrong alpha value\n");
+		return -EINVAL;
+	}
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->alpha != alpha) {
+		selected_ctx->alpha = alpha;
+		selected_ctx_u->alpha = true;
+		update_ctx_ctrl3[ctxnum] = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_data_offset - Sets the offset between received lines
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @data_offset: Offset between first pixel of each 2 contiguous lines.
+ *
+ * Returns 0 if successful, or -EINVAL if the line offset is bigger than 1023.
+ **/
+int isp_csi2_ctx_config_data_offset(u8 ctxnum, u16 data_offset)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	if (data_offset > 0x3FF) {
+		printk(KERN_ERR "Wrong line offset\n");
+		return -EINVAL;
+	}
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->data_offset != data_offset) {
+		selected_ctx->data_offset = data_offset;
+		selected_ctx_u->data_offset = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_ping_addr - Sets Ping address for CSI2 Rx. buffer saving
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @ping_addr: 32 bit ISP MMU mapped address.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_ping_addr(u8 ctxnum, u32 ping_addr)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	ping_addr &= ~(0x1F);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->ping_addr != ping_addr) {
+		selected_ctx->ping_addr = ping_addr;
+		selected_ctx_u->ping_addr = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_pong_addr - Sets Pong address for CSI2 Rx. buffer saving
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @pong_addr: 32 bit ISP MMU mapped address.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_pong_addr(u8 ctxnum, u32 pong_addr)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	pong_addr &= ~(0x1F);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->pong_addr != pong_addr) {
+		selected_ctx->pong_addr = pong_addr;
+		selected_ctx_u->pong_addr = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_eof_enabled - Enables EOF signal assertion
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @eof_enabled: Boolean to enable/disable EOF signal assertion on received
+ *               packets.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_eof_enabled(u8 ctxnum, bool eof_enabled)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->eof_enabled != eof_enabled) {
+		selected_ctx->eof_enabled = eof_enabled;
+		selected_ctx_u->eof_enabled = true;
+		update_ctx_ctrl1[ctxnum] = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_eol_enabled - Enables EOL signal assertion
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @eol_enabled: Boolean to enable/disable EOL signal assertion on received
+ *               packets.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_eol_enabled(u8 ctxnum, bool eol_enabled)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->eol_enabled != eol_enabled) {
+		selected_ctx->eol_enabled = eol_enabled;
+		selected_ctx_u->eol_enabled = true;
+		update_ctx_ctrl1[ctxnum] = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_checksum_enabled - Enables Checksum check in rcvd packets
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @checksum_enabled: Boolean to enable/disable Checksum check on received
+ *                    packets
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_checksum_enabled(u8 ctxnum, bool checksum_enabled)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->checksum_enabled != checksum_enabled) {
+		selected_ctx->checksum_enabled = checksum_enabled;
+		selected_ctx_u->checksum_enabled = true;
+		update_ctx_ctrl1[ctxnum] = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_config_enabled - Enables specified CSI2 context
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @enabled: Boolean to enable/disable specified context.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_config_enabled(u8 ctxnum, bool enabled)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (selected_ctx->enabled != enabled) {
+		selected_ctx->enabled = enabled;
+		selected_ctx_u->enabled = true;
+		update_ctx_ctrl1[ctxnum] = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_update - Applies CSI2 context configuration.
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_ctx_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_ctx_config_*() functions, unless the force_update flag is
+ * set to true.
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_update(u8 ctxnum, bool force_update)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	u32 reg;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	if (update_ctx_ctrl1[ctxnum] || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_CTX_CTRL1(ctxnum));
+		if (selected_ctx_u->frame_count || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL1_COUNT_MASK);
+			reg |= selected_ctx->frame_count <<
+				ISPCSI2_CTX_CTRL1_COUNT_SHIFT;
+			selected_ctx_u->frame_count = false;
+		}
+		if (selected_ctx_u->eof_enabled || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL1_EOF_EN_MASK);
+			if (selected_ctx->eof_enabled)
+				reg |= ISPCSI2_CTX_CTRL1_EOF_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTX_CTRL1_EOF_EN_DISABLE;
+			selected_ctx_u->eof_enabled = false;
+		}
+		if (selected_ctx_u->eol_enabled || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL1_EOL_EN_MASK);
+			if (selected_ctx->eol_enabled)
+				reg |= ISPCSI2_CTX_CTRL1_EOL_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTX_CTRL1_EOL_EN_DISABLE;
+			selected_ctx_u->eol_enabled = false;
+		}
+		if (selected_ctx_u->checksum_enabled || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL1_CS_EN_MASK);
+			if (selected_ctx->checksum_enabled)
+				reg |= ISPCSI2_CTX_CTRL1_CS_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTX_CTRL1_CS_EN_DISABLE;
+			selected_ctx_u->checksum_enabled = false;
+		}
+		if (selected_ctx_u->enabled || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL1_CTX_EN_MASK);
+			if (selected_ctx->enabled)
+				reg |= ISPCSI2_CTX_CTRL1_CTX_EN_ENABLE;
+			else
+				reg |= ISPCSI2_CTX_CTRL1_CTX_EN_DISABLE;
+			selected_ctx_u->enabled = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_CTRL1(ctxnum));
+		update_ctx_ctrl1[ctxnum] = false;
+	}
+
+	if (update_ctx_ctrl2[ctxnum] || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_CTX_CTRL2(ctxnum));
+		if (selected_ctx_u->virtual_id || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK);
+			reg |= selected_ctx->virtual_id <<
+				ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;
+			selected_ctx_u->virtual_id = false;
+		}
+
+		if (selected_ctx_u->format || force_update) {
+			struct v4l2_pix_format *pix;
+			u16 new_format = 0;
+
+			reg &= ~(ISPCSI2_CTX_CTRL2_FORMAT_MASK);
+			pix = &selected_ctx->format;
+			switch (pix->pixelformat) {
+			case V4L2_PIX_FMT_RGB565:
+			case V4L2_PIX_FMT_RGB565X:
+				new_format = 0x22;
+				break;
+			case V4L2_PIX_FMT_YUYV:
+			case V4L2_PIX_FMT_UYVY:
+				if (uses_videoport)
+					new_format = 0x9E;
+				else
+					new_format = 0x1E;
+				break;
+			case V4L2_PIX_FMT_RGB555:
+			case V4L2_PIX_FMT_RGB555X:
+				new_format = 0xA1;
+				break;
+			case V4L2_PIX_FMT_SGRBG10:
+				if (uses_videoport)
+					new_format = 0x12F;
+				else
+					new_format = 0xAB;
+				break;
+			}
+			reg |= (new_format << ISPCSI2_CTX_CTRL2_FORMAT_SHIFT);
+			selected_ctx_u->format = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_CTRL2(ctxnum));
+		update_ctx_ctrl2[ctxnum] = false;
+	}
+
+	if (update_ctx_ctrl3[ctxnum] || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_CTX_CTRL3(ctxnum));
+		if (selected_ctx_u->alpha || force_update) {
+			reg &= ~(ISPCSI2_CTX_CTRL3_ALPHA_MASK);
+			reg |= (selected_ctx->alpha <<
+				ISPCSI2_CTX_CTRL3_ALPHA_SHIFT);
+			selected_ctx_u->alpha = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_CTRL3(ctxnum));
+		update_ctx_ctrl3[ctxnum] = false;
+	}
+
+	if (selected_ctx_u->data_offset) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_CTX_DAT_OFST(ctxnum));
+		reg &= ~ISPCSI2_CTX_DAT_OFST_OFST_MASK;
+		reg |= selected_ctx->data_offset <<
+			ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_DAT_OFST(ctxnum));
+		selected_ctx_u->data_offset = false;
+	}
+
+	if (selected_ctx_u->ping_addr) {
+		reg = selected_ctx->ping_addr;
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_DAT_PING_ADDR(ctxnum));
+		selected_ctx_u->ping_addr = false;
+	}
+
+	if (selected_ctx_u->pong_addr) {
+		reg = selected_ctx->pong_addr;
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_DAT_PONG_ADDR(ctxnum));
+		selected_ctx_u->pong_addr = false;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_get - Gets specific CSI2 Context configuration
+ * @ctxnum: Context number, valid between 0 and 7 values.
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_get(u8 ctxnum)
+{
+	struct isp_csi2_ctx_cfg *selected_ctx;
+	struct isp_csi2_ctx_cfg_update *selected_ctx_u;
+	u32 reg;
+
+	isp_csi2_ctx_validate(&ctxnum);
+
+	selected_ctx = &current_csi2_cfg.contexts[ctxnum];
+	selected_ctx_u = &current_csi2_cfg_update.contexts[ctxnum];
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_CTX_CTRL1(ctxnum));
+	selected_ctx->frame_count = (reg & ISPCSI2_CTX_CTRL1_COUNT_MASK) >>
+		ISPCSI2_CTX_CTRL1_COUNT_SHIFT;
+	selected_ctx_u->frame_count = false;
+
+	if ((reg & ISPCSI2_CTX_CTRL1_EOF_EN_MASK) ==
+	    ISPCSI2_CTX_CTRL1_EOF_EN_ENABLE)
+		selected_ctx->eof_enabled = true;
+	else
+		selected_ctx->eof_enabled = false;
+	selected_ctx_u->eof_enabled = false;
+
+	if ((reg & ISPCSI2_CTX_CTRL1_EOL_EN_MASK) ==
+	    ISPCSI2_CTX_CTRL1_EOL_EN_ENABLE)
+		selected_ctx->eol_enabled = true;
+	else
+		selected_ctx->eol_enabled = false;
+	selected_ctx_u->eol_enabled = false;
+
+	if ((reg & ISPCSI2_CTX_CTRL1_CS_EN_MASK) ==
+	    ISPCSI2_CTX_CTRL1_CS_EN_ENABLE)
+		selected_ctx->checksum_enabled = true;
+	else
+		selected_ctx->checksum_enabled = false;
+	selected_ctx_u->checksum_enabled = false;
+
+	if ((reg & ISPCSI2_CTX_CTRL1_CTX_EN_MASK) ==
+	    ISPCSI2_CTX_CTRL1_CTX_EN_ENABLE)
+		selected_ctx->enabled = true;
+	else
+		selected_ctx->enabled = false;
+	selected_ctx_u->enabled = false;
+	update_ctx_ctrl1[ctxnum] = false;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_CTX_CTRL2(ctxnum));
+
+	selected_ctx->virtual_id = (reg & ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK) >>
+		ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT;
+	selected_ctx_u->virtual_id = false;
+
+	switch ((reg & ISPCSI2_CTX_CTRL2_FORMAT_MASK) >>
+		ISPCSI2_CTX_CTRL2_FORMAT_SHIFT) {
+	case 0x22:
+		selected_ctx->format.pixelformat = V4L2_PIX_FMT_RGB565;
+		break;
+	case 0x9E:
+	case 0x1E:
+		selected_ctx->format.pixelformat = V4L2_PIX_FMT_YUYV;
+		break;
+	case 0xA1:
+		selected_ctx->format.pixelformat = V4L2_PIX_FMT_RGB555;
+		break;
+	case 0xAB:
+	case 0x12F:
+		selected_ctx->format.pixelformat = V4L2_PIX_FMT_SGRBG10;
+		break;
+	}
+	selected_ctx_u->format = false;
+	update_ctx_ctrl2[ctxnum] = false;
+
+	selected_ctx->alpha = (isp_reg_readl(current_csi2_cfg.dev,
+					     OMAP3_ISP_IOMEM_CSI2A,
+					     ISPCSI2_CTX_CTRL3(ctxnum)) &
+			       ISPCSI2_CTX_CTRL3_ALPHA_MASK) >>
+		ISPCSI2_CTX_CTRL3_ALPHA_SHIFT;
+	selected_ctx_u->alpha = false;
+	update_ctx_ctrl3[ctxnum] = false;
+
+	selected_ctx->data_offset = (isp_reg_readl(current_csi2_cfg.dev,
+						   OMAP3_ISP_IOMEM_CSI2A,
+					   ISPCSI2_CTX_DAT_OFST(ctxnum)) &
+				     ISPCSI2_CTX_DAT_OFST_OFST_MASK) >>
+		ISPCSI2_CTX_DAT_OFST_OFST_SHIFT;
+	selected_ctx_u->data_offset = false;
+
+	selected_ctx->ping_addr = isp_reg_readl(current_csi2_cfg.dev,
+						OMAP3_ISP_IOMEM_CSI2A,
+					ISPCSI2_CTX_DAT_PING_ADDR(ctxnum));
+	selected_ctx_u->ping_addr = false;
+
+	selected_ctx->pong_addr = isp_reg_readl(current_csi2_cfg.dev,
+						OMAP3_ISP_IOMEM_CSI2A,
+					ISPCSI2_CTX_DAT_PONG_ADDR(ctxnum));
+	selected_ctx_u->pong_addr = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_update_all - Applies all CSI2 context configuration.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_ctx_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_ctx_config_*() functions, unless the force_update flag is
+ * set to true.
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_update_all(bool force_update)
+{
+	u8 ctxnum;
+
+	for (ctxnum = 0; ctxnum < 8; ctxnum++)
+		isp_csi2_ctx_update(ctxnum, force_update);
+
+	return 0;
+}
+
+/**
+ * isp_csi2_ctx_get_all - Gets all CSI2 Context configurations
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_ctx_get_all(void)
+{
+	u8 ctxnum;
+
+	for (ctxnum = 0; ctxnum < 8; ctxnum++)
+		isp_csi2_ctx_get(ctxnum);
+
+	return 0;
+}
+
+int isp_csi2_phy_config(struct isp_csi2_phy_cfg *desiredphyconfig)
+{
+	struct isp_csi2_phy_cfg *currphy = &current_csi2_cfg.phy;
+	struct isp_csi2_phy_cfg_update *currphy_u =
+						&current_csi2_cfg_update.phy;
+
+	if ((desiredphyconfig->tclk_term > 0x7f) ||
+				(desiredphyconfig->tclk_miss > 0x3)) {
+		printk(KERN_ERR "Invalid PHY configuration sent by the"
+								" driver\n");
+		return -EINVAL;
+	}
+
+	if (currphy->ths_term != desiredphyconfig->ths_term) {
+		currphy->ths_term = desiredphyconfig->ths_term;
+		currphy_u->ths_term = true;
+		update_phy_cfg0 = true;
+	}
+	if (currphy->ths_settle != desiredphyconfig->ths_settle) {
+		currphy->ths_settle = desiredphyconfig->ths_settle;
+		currphy_u->ths_settle = true;
+		update_phy_cfg0 = true;
+	}
+	if (currphy->tclk_term != desiredphyconfig->tclk_term) {
+		currphy->tclk_term = desiredphyconfig->tclk_term;
+		currphy_u->tclk_term = true;
+		update_phy_cfg1 = true;
+	}
+	if (currphy->tclk_miss != desiredphyconfig->tclk_miss) {
+		currphy->tclk_miss = desiredphyconfig->tclk_miss;
+		currphy_u->tclk_miss = true;
+		update_phy_cfg1 = true;
+	}
+	if (currphy->tclk_settle != desiredphyconfig->tclk_settle) {
+		currphy->tclk_settle = desiredphyconfig->tclk_settle;
+		currphy_u->tclk_settle = true;
+		update_phy_cfg1 = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_calc_phy_cfg0 - Calculates D-PHY config based on the MIPIClk speed.
+ * @mipiclk: MIPI clock frequency being used with CSI2 sensor.
+ * @lbound_hs_settle: Lower bound for CSI2 High Speed Settle transition.
+ * @ubound_hs_settle: Upper bound for CSI2 High Speed Settle transition.
+ *
+ * From TRM, we have the same calculation for HS Termination signal.
+ *  THS_TERM  = ceil( 12.5ns / DDRCLK period ) - 1
+ * But for Settle, we use the mid value between the two passed boundaries from
+ * sensor:
+ *  THS_SETTLE = (Upper bound + Lower bound) / 2
+ *
+ * Always returns 0.
+ */
+int isp_csi2_calc_phy_cfg0(u32 mipiclk, u32 lbound_hs_settle,
+							u32 ubound_hs_settle)
+{
+	struct isp_csi2_phy_cfg *currphy = &current_csi2_cfg.phy;
+	struct isp_csi2_phy_cfg_update *currphy_u =
+						&current_csi2_cfg_update.phy;
+	u32 tmp, ddrclk = mipiclk >> 1;
+
+	/* Calculate THS_TERM */
+	tmp = ddrclk / 80000000;
+	if ((ddrclk % 80000000) > 0)
+		tmp++;
+	currphy->ths_term = tmp - 1;
+	currphy_u->ths_term = true;
+
+	/* Calculate THS_SETTLE */
+	currphy->ths_settle = (ubound_hs_settle + lbound_hs_settle) / 2;
+
+	currphy_u->ths_settle = true;
+	isp_csi2_phy_update(true);
+	return 0;
+}
+EXPORT_SYMBOL(isp_csi2_calc_phy_cfg0);
+
+/**
+ * isp_csi2_phy_update - Applies CSI2 D-PHY configuration.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_phy_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_phy_config_*() functions, unless the force_update flag is
+	* set to true.
+	* Always returns 0.
+	**/
+int isp_csi2_phy_update(bool force_update)
+{
+	struct isp_csi2_phy_cfg *currphy = &current_csi2_cfg.phy;
+	struct isp_csi2_phy_cfg_update *currphy_u =
+		&current_csi2_cfg_update.phy;
+	u32 reg;
+
+	if (update_phy_cfg0 || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev,
+				    OMAP3_ISP_IOMEM_CSI2PHY,
+				    ISPCSI2PHY_CFG0);
+		if (currphy_u->ths_term || force_update) {
+			reg &= ~ISPCSI2PHY_CFG0_THS_TERM_MASK;
+			reg |= (currphy->ths_term <<
+				ISPCSI2PHY_CFG0_THS_TERM_SHIFT);
+			currphy_u->ths_term = false;
+		}
+		if (currphy_u->ths_settle || force_update) {
+			reg &= ~ISPCSI2PHY_CFG0_THS_SETTLE_MASK;
+			reg |= (currphy->ths_settle <<
+				ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT);
+			currphy_u->ths_settle = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg,
+			       OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG0);
+		update_phy_cfg0 = false;
+	}
+
+	if (update_phy_cfg1 || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev,
+				    OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG1);
+		if (currphy_u->tclk_term || force_update) {
+			reg &= ~ISPCSI2PHY_CFG1_TCLK_TERM_MASK;
+			reg |= (currphy->tclk_term <<
+				ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT);
+			currphy_u->tclk_term = false;
+		}
+		if (currphy_u->tclk_miss || force_update) {
+			reg &= ~ISPCSI2PHY_CFG1_TCLK_MISS_MASK;
+			reg |= (currphy->tclk_miss <<
+				ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT);
+			currphy_u->tclk_miss = false;
+		}
+		if (currphy_u->tclk_settle || force_update) {
+			reg &= ~ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK;
+			reg |= (currphy->tclk_settle <<
+				ISPCSI2PHY_CFG1_TCLK_SETTLE_SHIFT);
+			currphy_u->tclk_settle = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg,
+			       OMAP3_ISP_IOMEM_CSI2PHY, ISPCSI2PHY_CFG1);
+		update_phy_cfg1 = false;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_phy_get - Gets CSI2 D-PHY configuration
+ *
+ * Gets settings from HW registers and fills in the internal driver memory
+ * Always returns 0.
+ **/
+int isp_csi2_phy_get(void)
+{
+	struct isp_csi2_phy_cfg *currphy = &current_csi2_cfg.phy;
+	struct isp_csi2_phy_cfg_update *currphy_u =
+		&current_csi2_cfg_update.phy;
+	u32 reg;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2PHY,
+			    ISPCSI2PHY_CFG0);
+	currphy->ths_term = (reg & ISPCSI2PHY_CFG0_THS_TERM_MASK) >>
+		ISPCSI2PHY_CFG0_THS_TERM_SHIFT;
+	currphy_u->ths_term = false;
+
+	currphy->ths_settle = (reg & ISPCSI2PHY_CFG0_THS_SETTLE_MASK) >>
+		ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT;
+	currphy_u->ths_settle = false;
+	update_phy_cfg0 = false;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2PHY,
+			    ISPCSI2PHY_CFG1);
+
+	currphy->tclk_term = (reg & ISPCSI2PHY_CFG1_TCLK_TERM_MASK) >>
+		ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT;
+	currphy_u->tclk_term = false;
+
+	currphy->tclk_miss = (reg & ISPCSI2PHY_CFG1_TCLK_MISS_MASK) >>
+		ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT;
+	currphy_u->tclk_miss = false;
+
+	currphy->tclk_settle = (reg & ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK) >>
+		ISPCSI2PHY_CFG1_TCLK_SETTLE_SHIFT;
+	currphy_u->tclk_settle = false;
+
+	update_phy_cfg1 = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_config_forcerxmode - Sets Force Rx mode on stop state count
+ * @force_rx_mode: Boolean to enable/disable forcing Rx mode in CSI2 receiver
+ *
+ * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
+ **/
+int isp_csi2_timings_config_forcerxmode(u8 io, bool force_rx_mode)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+	if (currtimings->force_rx_mode != force_rx_mode) {
+		currtimings->force_rx_mode = force_rx_mode;
+		currtimings_u->force_rx_mode = true;
+		update_timing = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_config_stopstate_16x - Sets 16x factor for L3 cycles
+ * @stop_state_16x: Boolean to use or not use the 16x multiplier for stop count
+ *
+ * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
+ **/
+int isp_csi2_timings_config_stopstate_16x(u8 io, bool stop_state_16x)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+	if (currtimings->stop_state_16x != stop_state_16x) {
+		currtimings->stop_state_16x = stop_state_16x;
+		currtimings_u->stop_state_16x = true;
+		update_timing = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_config_stopstate_4x - Sets 4x factor for L3 cycles
+ * @stop_state_4x: Boolean to use or not use the 4x multiplier for stop count
+ *
+ * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
+ **/
+int isp_csi2_timings_config_stopstate_4x(u8 io, bool stop_state_4x)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+	if (currtimings->stop_state_4x != stop_state_4x) {
+		currtimings->stop_state_4x = stop_state_4x;
+		currtimings_u->stop_state_4x = true;
+		update_timing = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_config_stopstate_cnt - Sets L3 cycles
+ * @stop_state_counter: Stop state counter value for L3 cycles
+ *
+ * Returns 0 if successful, or -EINVAL if wrong ComplexIO number is selected.
+ **/
+int isp_csi2_timings_config_stopstate_cnt(u8 io, u16 stop_state_counter)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+	if (currtimings->stop_state_counter != stop_state_counter) {
+		currtimings->stop_state_counter = (stop_state_counter & 0x1FFF);
+		currtimings_u->stop_state_counter = true;
+		update_timing = true;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_update - Applies specified CSI2 timing configuration.
+ * @io: IO number (1 or 2) which specifies which ComplexIO are we updating
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_timings_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_timings_config_*() functions, unless the force_update flag is
+ * set to true.
+ * Returns 0 if successful, or -EINVAL if invalid IO number is passed.
+ **/
+int isp_csi2_timings_update(u8 io, bool force_update)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+	u32 reg;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+
+	if (update_timing || force_update) {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_TIMING);
+		if (currtimings_u->force_rx_mode || force_update) {
+			reg &= ~ISPCSI2_TIMING_FORCE_RX_MODE_IO_MASK(io);
+			if (currtimings->force_rx_mode)
+				reg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO_ENABLE
+					(io);
+			else
+				reg |= ISPCSI2_TIMING_FORCE_RX_MODE_IO_DISABLE
+					(io);
+			currtimings_u->force_rx_mode = false;
+		}
+		if (currtimings_u->stop_state_16x || force_update) {
+			reg &= ~ISPCSI2_TIMING_STOP_STATE_X16_IO_MASK(io);
+			if (currtimings->stop_state_16x)
+				reg |= ISPCSI2_TIMING_STOP_STATE_X16_IO_ENABLE
+					(io);
+			else
+				reg |= ISPCSI2_TIMING_STOP_STATE_X16_IO_DISABLE
+					(io);
+			currtimings_u->stop_state_16x = false;
+		}
+		if (currtimings_u->stop_state_4x || force_update) {
+			reg &= ~ISPCSI2_TIMING_STOP_STATE_X4_IO_MASK(io);
+			if (currtimings->stop_state_4x) {
+				reg |= ISPCSI2_TIMING_STOP_STATE_X4_IO_ENABLE
+					(io);
+			} else {
+				reg |= ISPCSI2_TIMING_STOP_STATE_X4_IO_DISABLE
+					(io);
+			}
+			currtimings_u->stop_state_4x = false;
+		}
+		if (currtimings_u->stop_state_counter || force_update) {
+			reg &= ~ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(io);
+			reg |= currtimings->stop_state_counter <<
+				ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(io);
+			currtimings_u->stop_state_counter = false;
+		}
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_TIMING);
+		update_timing = false;
+	}
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_get - Gets specific CSI2 ComplexIO timing configuration
+ * @io: IO number (1 or 2) which specifies which ComplexIO are we getting
+ *
+ * Gets settings from HW registers and fills in the internal driver memory
+ * Returns 0 if successful, or -EINVAL if invalid IO number is passed.
+ **/
+int isp_csi2_timings_get(u8 io)
+{
+	struct isp_csi2_timings_cfg *currtimings;
+	struct isp_csi2_timings_cfg_update *currtimings_u;
+	u32 reg;
+
+	if (io < 1 || io > 2) {
+		printk(KERN_ERR "CSI2 - Timings config: Invalid IO number\n");
+		return -EINVAL;
+	}
+
+	currtimings = &current_csi2_cfg.timings[io - 1];
+	currtimings_u = &current_csi2_cfg_update.timings[io - 1];
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_TIMING);
+	if ((reg & ISPCSI2_TIMING_FORCE_RX_MODE_IO_MASK(io)) ==
+	    ISPCSI2_TIMING_FORCE_RX_MODE_IO_ENABLE(io))
+		currtimings->force_rx_mode = true;
+	else
+		currtimings->force_rx_mode = false;
+	currtimings_u->force_rx_mode = false;
+
+	if ((reg & ISPCSI2_TIMING_STOP_STATE_X16_IO_MASK(io)) ==
+	    ISPCSI2_TIMING_STOP_STATE_X16_IO_ENABLE(io))
+		currtimings->stop_state_16x = true;
+	else
+		currtimings->stop_state_16x = false;
+	currtimings_u->stop_state_16x = false;
+
+	if ((reg & ISPCSI2_TIMING_STOP_STATE_X4_IO_MASK(io)) ==
+	    ISPCSI2_TIMING_STOP_STATE_X4_IO_ENABLE(io))
+		currtimings->stop_state_4x = true;
+	else
+		currtimings->stop_state_4x = false;
+	currtimings_u->stop_state_4x = false;
+
+	currtimings->stop_state_counter = (reg &
+			   ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(io)) >>
+		ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(io);
+	currtimings_u->stop_state_counter = false;
+	update_timing = false;
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_update_all - Applies specified CSI2 timing configuration.
+ * @force_update: Flag to force rewrite of registers, even if they haven't been
+ *                updated with the isp_csi2_timings_config_*() functions.
+ *
+ * It only saves settings when they were previously updated using the
+ * isp_csi2_timings_config_*() functions, unless the force_update flag is
+ * set to true.
+ * Always returns 0.
+ **/
+int isp_csi2_timings_update_all(bool force_update)
+{
+	int i;
+
+	for (i = 1; i < 3; i++)
+		isp_csi2_timings_update(i, force_update);
+	return 0;
+}
+
+/**
+ * isp_csi2_timings_get_all - Gets all CSI2 ComplexIO timing configurations
+ *
+ * Always returns 0.
+ **/
+int isp_csi2_timings_get_all(void)
+{
+	int i;
+
+	for (i = 1; i < 3; i++)
+		isp_csi2_timings_get(i);
+	return 0;
+}
+
+/**
+ * isp_csi2_isr - CSI2 interrupt handling.
+ *
+ * Return -EIO on Transmission error
+ **/
+int isp_csi2_isr(void)
+{
+	int retval = 0;
+	u32 csi2_irqstatus, cpxio1_irqstatus, ctxirqstatus;
+
+	csi2_irqstatus = isp_reg_readl(current_csi2_cfg.dev,
+				       OMAP3_ISP_IOMEM_CSI2A,
+				       ISPCSI2_IRQSTATUS);
+	isp_reg_writel(current_csi2_cfg.dev, csi2_irqstatus,
+		       OMAP3_ISP_IOMEM_CSI2A, ISPCSI2_IRQSTATUS);
+
+	/* Failure Cases */
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ) {
+		cpxio1_irqstatus = isp_reg_readl(current_csi2_cfg.dev,
+						 OMAP3_ISP_IOMEM_CSI2A,
+						 ISPCSI2_COMPLEXIO1_IRQSTATUS);
+		isp_reg_writel(current_csi2_cfg.dev, cpxio1_irqstatus,
+			       OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_COMPLEXIO1_IRQSTATUS);
+		dev_dbg(current_csi2_cfg.dev, "CSI2: ComplexIO Error IRQ %x\n",
+			cpxio1_irqstatus);
+		retval = -EIO;
+	}
+
+	if (csi2_irqstatus & (ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |
+			      ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |
+			      ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |
+			      ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |
+			      ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ)) {
+		dev_dbg(current_csi2_cfg.dev, "CSI2 Err:"
+			" OCP:%d,"
+			" Short_pack:%d,"
+			" ECC:%d,"
+			" CPXIO2:%d,"
+			" FIFO_OVF:%d,"
+			"\n",
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_OCP_ERR_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ) ? 1 : 0,
+			(csi2_irqstatus &
+			 ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ) ? 1 : 0);
+		retval = -EIO;
+	}
+
+	/* Successful cases */
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_CONTEXT(0)) {
+		ctxirqstatus = isp_reg_readl(current_csi2_cfg.dev,
+					     OMAP3_ISP_IOMEM_CSI2A,
+					     ISPCSI2_CTX_IRQSTATUS(0));
+		isp_reg_writel(current_csi2_cfg.dev, ctxirqstatus,
+			       OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_IRQSTATUS(0));
+	}
+
+	if (csi2_irqstatus & ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ)
+		dev_dbg(current_csi2_cfg.dev, "CSI2: ECC correction done\n");
+
+	return retval;
+}
+EXPORT_SYMBOL(isp_csi2_isr);
+
+/**
+ * isp_csi2_irq_complexio1_set - Enables CSI2 ComplexIO IRQs.
+ * @enable: Enable/disable CSI2 ComplexIO #1 interrupts
+ **/
+void isp_csi2_irq_complexio1_set(int enable)
+{
+	u32 reg;
+	reg = ISPCSI2_COMPLEXIO1_IRQENABLE_STATEALLULPMEXIT |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEALLULPMENTER |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM5 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL5 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC5 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS5 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS5 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM4 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL4 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC4 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS4 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS4 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM3 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL3 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC3 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS3 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS3 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM2 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL2 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC2 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS2 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS2 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM1 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL1 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC1 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS1 |
+		ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS1;
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_COMPLEXIO1_IRQSTATUS);
+	if (enable) {
+		reg |= isp_reg_readl(current_csi2_cfg.dev,
+				     OMAP3_ISP_IOMEM_CSI2A,
+				     ISPCSI2_COMPLEXIO1_IRQENABLE);
+	} else
+		reg = 0;
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_COMPLEXIO1_IRQENABLE);
+}
+EXPORT_SYMBOL(isp_csi2_irq_complexio1_set);
+
+/**
+ * isp_csi2_irq_ctx_set - Enables CSI2 Context IRQs.
+ * @enable: Enable/disable CSI2 Context interrupts
+ **/
+void isp_csi2_irq_ctx_set(int enable)
+{
+	u32 reg;
+	int i;
+
+	reg = ISPCSI2_CTX_IRQSTATUS_FS_IRQ | ISPCSI2_CTX_IRQSTATUS_FE_IRQ;
+	for (i = 0; i < 8; i++) {
+		isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+			       ISPCSI2_CTX_IRQSTATUS(i));
+		if (enable) {
+			isp_reg_or(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				   ISPCSI2_CTX_IRQENABLE(i), reg);
+		} else {
+			isp_reg_writel(current_csi2_cfg.dev, 0,
+				       OMAP3_ISP_IOMEM_CSI2A,
+				       ISPCSI2_CTX_IRQENABLE(i));
+		}
+	}
+
+}
+EXPORT_SYMBOL(isp_csi2_irq_ctx_set);
+
+/**
+ * isp_csi2_irq_status_set - Enables CSI2 Status IRQs.
+ * @enable: Enable/disable CSI2 Status interrupts
+ **/
+void isp_csi2_irq_status_set(int enable)
+{
+	u32 reg;
+	reg = ISPCSI2_IRQSTATUS_OCP_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ |
+		ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ |
+		ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ |
+		ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ |
+		ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ |
+		ISPCSI2_IRQSTATUS_CONTEXT(0);
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_IRQSTATUS);
+	if (enable)
+		reg |= isp_reg_readl(current_csi2_cfg.dev,
+				     OMAP3_ISP_IOMEM_CSI2A,
+				     ISPCSI2_IRQENABLE);
+	else
+		reg = 0;
+
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_IRQENABLE);
+}
+EXPORT_SYMBOL(isp_csi2_irq_status_set);
+
+/**
+ * isp_csi2_irq_all_set - Enable/disable CSI2 interrupts.
+ * @enable: 0-Disable, 1-Enable.
+ **/
+void isp_csi2_irq_all_set(int enable)
+{
+	if (enable) {
+		isp_csi2_irq_complexio1_set(enable);
+		isp_csi2_irq_ctx_set(enable);
+		isp_csi2_irq_status_set(enable);
+	} else {
+		isp_csi2_irq_status_set(enable);
+		isp_csi2_irq_ctx_set(enable);
+		isp_csi2_irq_complexio1_set(enable);
+	}
+	return;
+}
+EXPORT_SYMBOL(isp_csi2_irq_all_set);
+
+/**
+ * isp_csi2_reset - Resets the CSI2 module.
+ *
+ * Returns 0 if successful, or -EBUSY if power command didn't respond.
+ **/
+int isp_csi2_reset(void)
+{
+	u32 reg;
+	u8 soft_reset_retries = 0;
+	int i;
+	struct device *temp_dev;
+
+	temp_dev = current_csi2_cfg.dev;
+	memset(&current_csi2_cfg, 0, sizeof(current_csi2_cfg));
+	memset(&current_csi2_cfg_update, 0, sizeof(current_csi2_cfg_update));
+	current_csi2_cfg.dev = temp_dev;
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_SYSCONFIG);
+	reg |= ISPCSI2_SYSCONFIG_SOFT_RESET_RESET;
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_SYSCONFIG);
+
+	do {
+		reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+				    ISPCSI2_SYSSTATUS) &
+			ISPCSI2_SYSSTATUS_RESET_DONE_MASK;
+		if (reg == ISPCSI2_SYSSTATUS_RESET_DONE_DONE)
+			break;
+		soft_reset_retries++;
+		if (soft_reset_retries < 5)
+			udelay(100);
+	} while (soft_reset_retries < 5);
+
+	if (soft_reset_retries == 5) {
+		printk(KERN_ERR "CSI2: Soft reset try count exceeded!\n");
+		return -EBUSY;
+	}
+
+	i = 100;
+	do {
+		reg = isp_reg_readl(current_csi2_cfg.dev,
+				    OMAP3_ISP_IOMEM_CSI2PHY,
+				    ISPCSI2PHY_CFG1) &
+		      ISPCSI2PHY_CFG1_RESETDONECTRLCLK_MASK;
+		if (reg == ISPCSI2PHY_CFG1_RESETDONECTRLCLK_MASK)
+			break;
+		udelay(100);
+	} while (--i > 0);
+
+	if (i == 0) {
+		printk(KERN_ERR
+			"CSI2: Reset for CSI2_96M_FCLK domain Failed!\n");
+		return -EBUSY;
+	}
+
+	reg = isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			    ISPCSI2_SYSCONFIG);
+	reg &= ~ISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK;
+	reg |= ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SMART;
+	reg &= ~ISPCSI2_SYSCONFIG_AUTO_IDLE_MASK;
+	reg |= ISPCSI2_SYSCONFIG_AUTO_IDLE_AUTO;
+	isp_reg_writel(current_csi2_cfg.dev, reg, OMAP3_ISP_IOMEM_CSI2A,
+		       ISPCSI2_SYSCONFIG);
+
+	uses_videoport = false;
+	update_complexio_cfg1 = false;
+	update_phy_cfg0 = false;
+	update_phy_cfg1 = false;
+	for (i = 0; i < 8; i++) {
+		update_ctx_ctrl1[i] = false;
+		update_ctx_ctrl2[i] = false;
+		update_ctx_ctrl3[i] = false;
+	}
+	update_timing = false;
+	update_ctrl = false;
+
+	isp_csi2_complexio_lanes_get();
+	isp_csi2_ctrl_get();
+	isp_csi2_ctx_get_all();
+	isp_csi2_phy_get();
+	isp_csi2_timings_get_all();
+
+	isp_csi2_complexio_power(ISP_CSI2_POWER_ON);
+	isp_csi2_complexio_power_autoswitch(true);
+
+	isp_csi2_timings_config_forcerxmode(1, true);
+	isp_csi2_timings_config_stopstate_cnt(1, 0x1FF);
+	isp_csi2_timings_update_all(true);
+
+	return 0;
+}
+
+/**
+ * isp_csi2_enable - Enables the CSI2 module.
+ * @enable: Enables/disables the CSI2 module.
+ **/
+void isp_csi2_enable(int enable)
+{
+	if (enable) {
+		isp_csi2_ctx_config_enabled(0, true);
+		isp_csi2_ctx_config_eof_enabled(0, true);
+		isp_csi2_ctx_config_checksum_enabled(0, true);
+		isp_csi2_ctx_update(0, false);
+
+		isp_csi2_ctrl_config_ecc_enable(true);
+		isp_csi2_ctrl_config_if_enable(true);
+		isp_csi2_ctrl_update(false);
+	} else {
+		isp_csi2_ctx_config_enabled(0, false);
+		isp_csi2_ctx_config_eof_enabled(0, false);
+		isp_csi2_ctx_config_checksum_enabled(0, false);
+		isp_csi2_ctx_update(0, false);
+
+		isp_csi2_ctrl_config_ecc_enable(false);
+		isp_csi2_ctrl_config_if_enable(false);
+		isp_csi2_ctrl_update(false);
+	}
+}
+EXPORT_SYMBOL(isp_csi2_enable);
+
+/**
+ * isp_csi2_regdump - Prints CSI2 debug information.
+ **/
+void isp_csi2_regdump(void)
+{
+	printk(KERN_DEBUG "-------------Register dump-------------\n");
+
+	printk(KERN_DEBUG "ISP_CTRL: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_MAIN,
+			     ISP_CTRL));
+	printk(KERN_DEBUG "ISP_TCTRL_CTRL: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_MAIN,
+			     ISP_TCTRL_CTRL));
+	printk(KERN_DEBUG "ISPCCDC_SDR_ADDR: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_SDR_ADDR));
+	printk(KERN_DEBUG "ISPCCDC_SYN_MODE: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_SYN_MODE));
+	printk(KERN_DEBUG "ISPCCDC_CFG: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_CFG));
+	printk(KERN_DEBUG "ISPCCDC_FMTCFG: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_FMTCFG));
+	printk(KERN_DEBUG "ISPCCDC_HSIZE_OFF: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_HSIZE_OFF));
+	printk(KERN_DEBUG "ISPCCDC_HORZ_INFO: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_HORZ_INFO));
+	printk(KERN_DEBUG "ISPCCDC_VERT_START: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_VERT_START));
+	printk(KERN_DEBUG "ISPCCDC_VERT_LINES: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CCDC,
+			     ISPCCDC_VERT_LINES));
+
+	printk(KERN_DEBUG "ISPCSI2_COMPLEXIO_CFG1: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_COMPLEXIO_CFG1));
+	printk(KERN_DEBUG "ISPCSI2_SYSSTATUS: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_SYSSTATUS));
+	printk(KERN_DEBUG "ISPCSI2_SYSCONFIG: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_SYSCONFIG));
+	printk(KERN_DEBUG "ISPCSI2_IRQENABLE: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_IRQENABLE));
+	printk(KERN_DEBUG "ISPCSI2_IRQSTATUS: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_IRQSTATUS));
+
+	printk(KERN_DEBUG "ISPCSI2_CTX_IRQENABLE(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_IRQENABLE(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_IRQSTATUS(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_IRQSTATUS(0)));
+	printk(KERN_DEBUG "ISPCSI2_TIMING: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_TIMING));
+	printk(KERN_DEBUG "ISPCSI2PHY_CFG0: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2PHY,
+			     ISPCSI2PHY_CFG0));
+	printk(KERN_DEBUG "ISPCSI2PHY_CFG1: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2PHY,
+			     ISPCSI2PHY_CFG1));
+	printk(KERN_DEBUG "ISPCSI2_CTX_CTRL1(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_CTRL1(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_CTRL2(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_CTRL2(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_CTRL3(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_CTRL3(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_DAT_OFST(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_DAT_OFST(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_DAT_PING_ADDR(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_DAT_PING_ADDR(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTX_DAT_PONG_ADDR(0): %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTX_DAT_PONG_ADDR(0)));
+	printk(KERN_DEBUG "ISPCSI2_CTRL: %x\n",
+	       isp_reg_readl(current_csi2_cfg.dev, OMAP3_ISP_IOMEM_CSI2A,
+			     ISPCSI2_CTRL));
+	printk(KERN_DEBUG "---------------------------------------\n");
+}
+
+/**
+ * ispcsi2_save_context - Saves the values of the CSI1 module registers
+ **/
+void ispcsi2_save_context(struct device *dev)
+{
+	printk(KERN_DEBUG "Saving csi2 context\n");
+	isp_save_context(dev, ispcsi2_reg_list);
+}
+EXPORT_SYMBOL(ispcsi2_save_context);
+
+/**
+ * ispcsi2_restore_context - Restores the values of the CSI2 module registers
+ **/
+void ispcsi2_restore_context(struct device *dev)
+{
+	printk(KERN_DEBUG "Restoring csi2 context\n");
+	isp_restore_context(dev, ispcsi2_reg_list);
+}
+EXPORT_SYMBOL(ispcsi2_restore_context);
+
+/**
+ * isp_csi2_cleanup - Routine for module driver cleanup
+ **/
+void isp_csi2_cleanup(struct device *dev)
+{
+	return;
+}
+
+/**
+ * isp_csi2_init - Routine for module driver init
+ **/
+int __init isp_csi2_init(struct device *dev)
+{
+	int i;
+
+	update_complexio_cfg1 = false;
+	update_phy_cfg0 = false;
+	update_phy_cfg1 = false;
+	for (i = 0; i < 8; i++) {
+		update_ctx_ctrl1[i] = false;
+		update_ctx_ctrl2[i] = false;
+		update_ctx_ctrl3[i] = false;
+	}
+	update_timing = false;
+	update_ctrl = false;
+
+	memset(&current_csi2_cfg, 0, sizeof(current_csi2_cfg));
+	memset(&current_csi2_cfg_update, 0, sizeof(current_csi2_cfg_update));
+	current_csi2_cfg.dev = dev;
+	return 0;
+}
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("ISP CSI2 Receiver Module");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/ispcsi2.h b/drivers/media/video/isp/ispcsi2.h
new file mode 100644
index 0000000..306823d
--- /dev/null
+++ b/drivers/media/video/isp/ispcsi2.h
@@ -0,0 +1,240 @@
+/*
+ * ispcsi2.h
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Dominic Curran <dcurran@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_CSI2_API_H
+#define OMAP_ISP_CSI2_API_H
+#include <linux/videodev2.h>
+
+#define ISP_CSI2_LANE_OFF	0
+#define ISP_CSI2_LANE_ON	1
+
+enum isp_csi2_irqevents {
+	OCP_ERR_IRQ = 0x4000,
+	SHORT_PACKET_IRQ = 0x2000,
+	ECC_CORRECTION_IRQ = 0x1000,
+	ECC_NO_CORRECTION_IRQ = 0x800,
+	COMPLEXIO2_ERR_IRQ = 0x400,
+	COMPLEXIO1_ERR_IRQ = 0x200,
+	FIFO_OVF_IRQ = 0x100,
+	CONTEXT7 = 0x80,
+	CONTEXT6 = 0x40,
+	CONTEXT5 = 0x20,
+	CONTEXT4 = 0x10,
+	CONTEXT3 = 0x8,
+	CONTEXT2 = 0x4,
+	CONTEXT1 = 0x2,
+	CONTEXT0 = 0x1,
+};
+
+enum isp_csi2_ctx_irqevents {
+	CTX_ECC_CORRECTION = 0x100,
+	CTX_LINE_NUMBER = 0x80,
+	CTX_FRAME_NUMBER = 0x40,
+	CTX_CS = 0x20,
+	CTX_LE = 0x8,
+	CTX_LS = 0x4,
+	CTX_FE = 0x2,
+	CTX_FS = 0x1,
+};
+
+enum isp_csi2_power_cmds {
+	ISP_CSI2_POWER_OFF,
+	ISP_CSI2_POWER_ON,
+	ISP_CSI2_POWER_ULPW,
+};
+
+enum isp_csi2_frame_mode {
+	ISP_CSI2_FRAME_IMMEDIATE,
+	ISP_CSI2_FRAME_AFTERFEC,
+};
+
+struct csi2_lanecfg {
+	u8 pos;
+	u8 pol;
+	u8 state;	/*Current state - 1-Used  0-Unused */
+};
+
+struct isp_csi2_lanes_cfg {
+	struct csi2_lanecfg data[4];
+	struct csi2_lanecfg clk;
+};
+
+struct isp_csi2_lanes_cfg_update {
+	bool data[4];
+	bool clk;
+};
+
+struct isp_csi2_phy_cfg {
+	u8 ths_term;
+	u8 ths_settle;
+	u8 tclk_term;
+	unsigned tclk_miss:1;
+	u8 tclk_settle;
+};
+
+struct isp_csi2_phy_cfg_update {
+	bool ths_term;
+	bool ths_settle;
+	bool tclk_term;
+	bool tclk_miss;
+	bool tclk_settle;
+};
+
+struct isp_csi2_ctx_cfg {
+	u8 virtual_id;
+	u8 frame_count;
+	struct v4l2_pix_format format;
+	u16 alpha;
+	u16 data_offset;
+	u32 ping_addr;
+	u32 pong_addr;
+	bool eof_enabled;
+	bool eol_enabled;
+	bool checksum_enabled;
+	bool enabled;
+};
+
+struct isp_csi2_ctx_cfg_update {
+	bool virtual_id;
+	bool frame_count;
+	bool format;
+	bool alpha;
+	bool data_offset;
+	bool ping_addr;
+	bool pong_addr;
+	bool eof_enabled;
+	bool eol_enabled;
+	bool checksum_enabled;
+	bool enabled;
+};
+
+struct isp_csi2_timings_cfg {
+	bool force_rx_mode;
+	bool stop_state_16x;
+	bool stop_state_4x;
+	u16 stop_state_counter;
+};
+
+struct isp_csi2_timings_cfg_update {
+	bool force_rx_mode;
+	bool stop_state_16x;
+	bool stop_state_4x;
+	bool stop_state_counter;
+};
+
+struct isp_csi2_ctrl_cfg {
+	bool vp_clk_enable;
+	bool vp_only_enable;
+	u8 vp_out_ctrl;
+	bool debug_enable;
+	u8 burst_size;
+	enum isp_csi2_frame_mode frame_mode;
+	bool ecc_enable;
+	bool secure_mode;
+	bool if_enable;
+};
+
+struct isp_csi2_ctrl_cfg_update {
+	bool vp_clk_enable;
+	bool vp_only_enable;
+	bool vp_out_ctrl;
+	bool debug_enable;
+	bool burst_size;
+	bool frame_mode;
+	bool ecc_enable;
+	bool secure_mode;
+	bool if_enable;
+};
+
+struct isp_csi2_cfg {
+	struct isp_csi2_lanes_cfg lanes;
+	struct isp_csi2_phy_cfg phy;
+	struct isp_csi2_ctx_cfg contexts[8];
+	struct isp_csi2_timings_cfg timings[2];
+	struct isp_csi2_ctrl_cfg ctrl;
+	struct device *dev;
+};
+
+struct isp_csi2_cfg_update {
+	struct isp_csi2_lanes_cfg_update lanes;
+	struct isp_csi2_phy_cfg_update phy;
+	struct isp_csi2_ctx_cfg_update contexts[8];
+	struct isp_csi2_timings_cfg_update timings[2];
+	struct isp_csi2_ctrl_cfg_update ctrl;
+};
+
+int isp_csi2_complexio_lanes_config(struct isp_csi2_lanes_cfg *reqcfg);
+int isp_csi2_complexio_lanes_update(bool force_update);
+int isp_csi2_complexio_lanes_count(int cnt);
+int isp_csi2_complexio_lanes_get(void);
+int isp_csi2_complexio_power_autoswitch(bool enable);
+int isp_csi2_complexio_power(enum isp_csi2_power_cmds power_cmd);
+int isp_csi2_ctrl_config_frame_mode(enum isp_csi2_frame_mode frame_mode);
+int isp_csi2_ctrl_config_vp_clk_enable(bool vp_clk_enable);
+int isp_csi2_ctrl_config_vp_only_enable(bool vp_only_enable);
+int isp_csi2_ctrl_config_debug_enable(bool debug_enable);
+int isp_csi2_ctrl_config_burst_size(u8 burst_size);
+int isp_csi2_ctrl_config_ecc_enable(bool ecc_enable);
+int isp_csi2_ctrl_config_secure_mode(bool secure_mode);
+int isp_csi2_ctrl_config_if_enable(bool if_enable);
+int isp_csi2_ctrl_config_vp_out_ctrl(u8 vp_out_ctrl);
+int isp_csi2_ctrl_update(bool force_update);
+int isp_csi2_ctrl_get(void);
+int isp_csi2_ctx_config_virtual_id(u8 ctxnum, u8 virtual_id);
+int isp_csi2_ctx_config_frame_count(u8 ctxnum, u8 frame_count);
+int isp_csi2_ctx_config_format(u8 ctxnum, u32 pixformat);
+int isp_csi2_ctx_config_alpha(u8 ctxnum, u16 alpha);
+int isp_csi2_ctx_config_data_offset(u8 ctxnum, u16 data_offset);
+int isp_csi2_ctx_config_ping_addr(u8 ctxnum, u32 ping_addr);
+int isp_csi2_ctx_config_pong_addr(u8 ctxnum, u32 pong_addr);
+int isp_csi2_ctx_config_eof_enabled(u8 ctxnum, bool eof_enabled);
+int isp_csi2_ctx_config_eol_enabled(u8 ctxnum, bool eol_enabled);
+int isp_csi2_ctx_config_checksum_enabled(u8 ctxnum, bool checksum_enabled);
+int isp_csi2_ctx_config_enabled(u8 ctxnum, bool enabled);
+int isp_csi2_ctx_update(u8 ctxnum, bool force_update);
+int isp_csi2_ctx_get(u8 ctxnum);
+int isp_csi2_ctx_update_all(bool force_update);
+int isp_csi2_ctx_get_all(void);
+int isp_csi2_phy_config(struct isp_csi2_phy_cfg *desiredphyconfig);
+int isp_csi2_calc_phy_cfg0(u32 mipiclk, u32 lbound_hs_settle,
+			   u32 ubound_hs_settle);
+int isp_csi2_phy_update(bool force_update);
+int isp_csi2_phy_get(void);
+int isp_csi2_timings_config_forcerxmode(u8 io, bool force_rx_mode);
+int isp_csi2_timings_config_stopstate_16x(u8 io, bool stop_state_16x);
+int isp_csi2_timings_config_stopstate_4x(u8 io, bool stop_state_4x);
+int isp_csi2_timings_config_stopstate_cnt(u8 io, u16 stop_state_counter);
+int isp_csi2_timings_update(u8 io, bool force_update);
+int isp_csi2_timings_get(u8 io);
+int isp_csi2_timings_update_all(bool force_update);
+int isp_csi2_timings_get_all(void);
+void isp_csi2_irq_complexio1_set(int enable);
+void isp_csi2_irq_ctx_set(int enable);
+void isp_csi2_irq_status_set(int enable);
+void isp_csi2_irq_all_set(int enable);
+
+int isp_csi2_isr(void);
+int isp_csi2_reset(void);
+void isp_csi2_enable(int enable);
+void isp_csi2_regdump(void);
+
+void ispcsi2_save_context(struct device *dev);
+void ispcsi2_restore_context(struct device *dev);
+
+#endif	/* OMAP_ISP_CSI2_H */
+
diff --git a/drivers/media/video/isp/isph3a.c b/drivers/media/video/isp/isph3a.c
new file mode 100644
index 0000000..3f419cd
--- /dev/null
+++ b/drivers/media/video/isp/isph3a.c
@@ -0,0 +1,618 @@
+/*
+ * isph3a.c
+ *
+ * H3A module for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+
+#include "isp.h"
+
+/* Structure for saving/restoring h3a module registers */
+static struct isp_reg isph3a_reg_list[] = {
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR, 0}, /* Should be the first one */
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWWIN1, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWINSTART, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWINBLK, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWSUBWIN, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX1, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAX2, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFPAXSTART, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFIIRSH, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFBUFST, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF010, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF032, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF054, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF076, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF098, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF0010, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF110, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF132, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF154, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF176, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF198, 0},
+	{OMAP3_ISP_IOMEM_H3A, ISPH3A_AFCOEF1010, 0},
+	{0, ISP_TOK_TERM, 0}
+};
+
+static void isph3a_aewb_update_regs(struct isp_h3a_device *isp_h3a);
+static void isph3a_print_status(struct isp_h3a_device *isp_h3a);
+
+void __isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable)
+{
+	if (enable) {
+		isp_h3a->regs.pcr |= ISPH3A_PCR_AEW_EN;
+		DPRINTK_ISPH3A("    H3A enabled\n");
+	} else {
+		isp_h3a->regs.pcr &= ~ISPH3A_PCR_AEW_EN;
+		DPRINTK_ISPH3A("    H3A disabled\n");
+	}
+	isp_h3a->update = 1;
+	isp_h3a->aewb_config_local.aewb_enable = enable;
+	isph3a_aewb_update_regs(isp_h3a);
+}
+
+/**
+ * isph3a_aewb_enable - Enables AE, AWB engine in the H3A module.
+ * @enable: 1 - Enables the AE & AWB engine.
+ *
+ * Client should configure all the AE & AWB registers in H3A before this.
+ **/
+void isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable)
+{
+	unsigned long irqflags;
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	__isph3a_aewb_enable(isp_h3a, enable);
+	isp_h3a->pm_state = enable;
+
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+}
+
+/**
+ * isph3a_aewb_suspend - Suspend AE, AWB engine in the H3A module.
+ **/
+void isph3a_aewb_suspend(struct isp_h3a_device *isp_h3a)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(isp_h3a->lock, flags);
+
+	if (isp_h3a->pm_state)
+		__isph3a_aewb_enable(isp_h3a, 0);
+
+	spin_unlock_irqrestore(isp_h3a->lock, flags);
+}
+
+/**
+ * isph3a_aewb_resume - Resume AE, AWB engine in the H3A module.
+ **/
+void isph3a_aewb_resume(struct isp_h3a_device *isp_h3a)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(isp_h3a->lock, flags);
+
+	if (isp_h3a->pm_state)
+		__isph3a_aewb_enable(isp_h3a, 1);
+
+	spin_unlock_irqrestore(isp_h3a->lock, flags);
+}
+
+int isph3a_aewb_busy(struct isp_h3a_device *isp_h3a)
+{
+	return isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR)
+		& ISPH3A_PCR_BUSYAEAWB;
+}
+
+/**
+ * isph3a_update_wb - Updates WB parameters.
+ *
+ * Needs to be called when no ISP Preview processing is taking place.
+ **/
+void isph3a_update_wb(struct isp_h3a_device *isp_h3a)
+{
+	struct isp_device *isp = dev_get_drvdata(isp_h3a->dev);
+
+	if (isp_h3a->wb_update) {
+		/* FIXME: Get the preview crap out of here!!! */
+		isppreview_config_whitebalance(&isp->isp_prev,
+					       isp_h3a->h3awb_update);
+		isp_h3a->wb_update = 0;
+	}
+	return;
+}
+EXPORT_SYMBOL(isph3a_update_wb);
+
+/**
+ * isph3a_aewb_update_regs - Helper function to update h3a registers.
+ **/
+static void isph3a_aewb_update_regs(struct isp_h3a_device *isp_h3a)
+{
+	u32 pcr;
+
+	if (!isp_h3a->update)
+		return;
+
+	pcr = isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+	isp_reg_writel(isp_h3a->dev, (pcr & ~ISPH3A_PCR_AEW_MASK) |
+				     (isp_h3a->regs.pcr & ~ISPH3A_PCR_AEW_EN),
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+	if (!isp_h3a->aewb_config_local.aewb_enable)
+		return;
+
+	if (isph3a_aewb_busy(isp_h3a)) {
+		isp_reg_writel(isp_h3a->dev, (pcr & ~ISPH3A_PCR_AEW_MASK) |
+					     isp_h3a->regs.pcr,
+			       OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+		return;
+	}
+
+	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.win1, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AEWWIN1);
+	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.start, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AEWINSTART);
+	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.blk, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AEWINBLK);
+	isp_reg_writel(isp_h3a->dev, isp_h3a->regs.subwin, OMAP3_ISP_IOMEM_H3A,
+		       ISPH3A_AEWSUBWIN);
+	isp_reg_writel(isp_h3a->dev, (pcr & ~ISPH3A_PCR_AEW_MASK) |
+				     isp_h3a->regs.pcr,
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_PCR);
+
+	isp_h3a->update = 0;
+}
+
+/**
+ * isph3a_aewb_stats_available - Check for stats available of specified frame.
+ * @aewbdata: Pointer to return AE AWB statistics data
+ *
+ * Returns 0 if successful, or -1 if statistics are unavailable.
+ **/
+static int isph3a_aewb_get_stats(struct isp_h3a_device *isp_h3a,
+				 struct isph3a_aewb_data *aewbdata)
+{
+	unsigned long irqflags;
+	struct ispstat_buffer *buf;
+
+	buf = ispstat_buf_get(&isp_h3a->stat,
+			      (void *)aewbdata->h3a_aewb_statistics_buf,
+			      aewbdata->frame_number);
+
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	aewbdata->ts = buf->ts;
+	aewbdata->config_counter = buf->config_counter;
+	aewbdata->frame_number = buf->frame_number;
+
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+
+	ispstat_buf_release(&isp_h3a->stat);
+
+	return 0;
+}
+
+/**
+ * isph3a_aewb_isr - Callback from ISP driver for H3A AEWB interrupt.
+ * @status: IRQ0STATUS in case of MMU error, 0 for H3A interrupt.
+ * @arg1: Not used as of now.
+ * @arg2: Not used as of now.
+ */
+void isph3a_aewb_isr(struct isp_h3a_device *isp_h3a)
+{
+	unsigned long irqflags;
+	struct ispstat_buffer *buf;
+
+	buf = ispstat_buf_next(&isp_h3a->stat);
+
+	isp_reg_writel(isp_h3a->dev, buf->iommu_addr,
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+	isph3a_aewb_update_regs(isp_h3a);
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+
+	isph3a_update_wb(isp_h3a);
+}
+
+static int isph3a_aewb_validate_params(struct isp_h3a_device *isp_h3a,
+				       struct isph3a_aewb_config *user_cfg)
+{
+	if (unlikely(user_cfg->saturation_limit > MAX_SATURATION_LIM)) {
+		dev_info(isp_h3a->dev, "h3a: Invalid Saturation_limit: %d\n",
+			 user_cfg->saturation_limit);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->win_height < MIN_WIN_H ||
+		     user_cfg->win_height > MAX_WIN_H ||
+		     user_cfg->win_height & 0x01)) {
+		dev_info(isp_h3a->dev, "h3a: Invalid window height: %d\n",
+			 user_cfg->win_height);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->win_width < MIN_WIN_W ||
+		     user_cfg->win_width > MAX_WIN_W ||
+		     user_cfg->win_width & 0x01)) {
+		dev_info(isp_h3a->dev, "h3a: Invalid window width: %d\n",
+			 user_cfg->win_width);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->ver_win_count < 1 ||
+		     user_cfg->ver_win_count > MAX_WINVC)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid vertical window count: %d\n",
+			 user_cfg->ver_win_count);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->hor_win_count < 1 ||
+		     user_cfg->hor_win_count > MAX_WINHC)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid horizontal window count: %d\n",
+			 user_cfg->hor_win_count);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->ver_win_start > MAX_WINSTART)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid vertical window start: %d\n",
+			 user_cfg->ver_win_start);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->hor_win_start > MAX_WINSTART)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid horizontal window start: %d\n",
+			 user_cfg->hor_win_start);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->blk_ver_win_start > MAX_WINSTART)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid black vertical window start: %d\n",
+			 user_cfg->blk_ver_win_start);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->blk_win_height < MIN_WIN_H ||
+		     user_cfg->blk_win_height > MAX_WIN_H ||
+		     user_cfg->blk_win_height & 0x01)) {
+		dev_info(isp_h3a->dev, "h3a: Invalid black window height: %d\n",
+			 user_cfg->blk_win_height);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->subsample_ver_inc < MIN_SUB_INC ||
+		     user_cfg->subsample_ver_inc > MAX_SUB_INC ||
+		     user_cfg->subsample_ver_inc & 0x01)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid vertical subsample increment: %d\n",
+			 user_cfg->subsample_ver_inc);
+		return -EINVAL;
+	}
+	if (unlikely(user_cfg->subsample_hor_inc < MIN_SUB_INC ||
+		     user_cfg->subsample_hor_inc > MAX_SUB_INC ||
+		     user_cfg->subsample_hor_inc & 0x01)) {
+		dev_info(isp_h3a->dev,
+			 "h3a: Invalid horizontal subsample increment: %d\n",
+			 user_cfg->subsample_hor_inc);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * isph3a_aewb_set_params - Helper function to check & store user given params.
+ * @user_cfg: Pointer to AE and AWB parameters struct.
+ *
+ * As most of them are busy-lock registers, need to wait until AEW_BUSY = 0 to
+ * program them during ISR.
+ *
+ * Returns 0 if successful, or -EINVAL if any of the parameters are invalid.
+ **/
+static void isph3a_aewb_set_params(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_config *user_cfg)
+{
+	if (isp_h3a->aewb_config_local.saturation_limit !=
+						user_cfg->saturation_limit) {
+		WRITE_SAT_LIM(isp_h3a->regs.pcr, user_cfg->saturation_limit);
+		isp_h3a->aewb_config_local.saturation_limit =
+			user_cfg->saturation_limit;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.alaw_enable != user_cfg->alaw_enable) {
+		WRITE_ALAW(isp_h3a->regs.pcr, user_cfg->alaw_enable);
+		isp_h3a->aewb_config_local.alaw_enable = user_cfg->alaw_enable;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.win_height != user_cfg->win_height) {
+		WRITE_WIN_H(isp_h3a->regs.win1, user_cfg->win_height);
+		isp_h3a->aewb_config_local.win_height = user_cfg->win_height;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.win_width != user_cfg->win_width) {
+		WRITE_WIN_W(isp_h3a->regs.win1, user_cfg->win_width);
+		isp_h3a->aewb_config_local.win_width = user_cfg->win_width;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.ver_win_count !=
+						user_cfg->ver_win_count) {
+		WRITE_VER_C(isp_h3a->regs.win1, user_cfg->ver_win_count);
+		isp_h3a->aewb_config_local.ver_win_count =
+						user_cfg->ver_win_count;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.hor_win_count !=
+						user_cfg->hor_win_count) {
+		WRITE_HOR_C(isp_h3a->regs.win1, user_cfg->hor_win_count);
+		isp_h3a->aewb_config_local.hor_win_count =
+						user_cfg->hor_win_count;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.ver_win_start !=
+						user_cfg->ver_win_start) {
+		WRITE_VER_WIN_ST(isp_h3a->regs.start, user_cfg->ver_win_start);
+		isp_h3a->aewb_config_local.ver_win_start =
+						user_cfg->ver_win_start;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.hor_win_start !=
+						user_cfg->hor_win_start) {
+		WRITE_HOR_WIN_ST(isp_h3a->regs.start, user_cfg->hor_win_start);
+		isp_h3a->aewb_config_local.hor_win_start =
+						user_cfg->hor_win_start;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.blk_ver_win_start !=
+	    user_cfg->blk_ver_win_start) {
+		WRITE_BLK_VER_WIN_ST(isp_h3a->regs.blk,
+				     user_cfg->blk_ver_win_start);
+		isp_h3a->aewb_config_local.blk_ver_win_start =
+			user_cfg->blk_ver_win_start;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.blk_win_height !=
+						user_cfg->blk_win_height) {
+		WRITE_BLK_WIN_H(isp_h3a->regs.blk, user_cfg->blk_win_height);
+		isp_h3a->aewb_config_local.blk_win_height =
+						user_cfg->blk_win_height;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.subsample_ver_inc !=
+	    user_cfg->subsample_ver_inc) {
+		WRITE_SUB_VER_INC(isp_h3a->regs.subwin,
+				  user_cfg->subsample_ver_inc);
+		isp_h3a->aewb_config_local.subsample_ver_inc =
+			user_cfg->subsample_ver_inc;
+		isp_h3a->update = 1;
+	}
+
+	if (isp_h3a->aewb_config_local.subsample_hor_inc !=
+	    user_cfg->subsample_hor_inc) {
+		WRITE_SUB_HOR_INC(isp_h3a->regs.subwin,
+				  user_cfg->subsample_hor_inc);
+		isp_h3a->aewb_config_local.subsample_hor_inc =
+			user_cfg->subsample_hor_inc;
+		isp_h3a->update = 1;
+	}
+}
+
+/**
+ * isph3a_aewb_configure - Configure AEWB regs, enable/disable H3A engine.
+ * @aewbcfg: Pointer to AEWB config structure.
+ *
+ * Returns 0 if successful, -EINVAL if aewbcfg pointer is NULL, -ENOMEM if
+ * was unable to allocate memory for the buffer, of other errors if H3A
+ * callback is not set or the parameters for AEWB are invalid.
+ **/
+int isph3a_aewb_configure(struct isp_h3a_device *isp_h3a,
+			  struct isph3a_aewb_config *aewbcfg)
+{
+	int ret = 0;
+	int win_count = 0;
+	unsigned int buf_size;
+	unsigned long irqflags;
+	struct ispstat_buffer *buf;
+
+	if (NULL == aewbcfg) {
+		dev_info(isp_h3a->dev, "h3a: Null argument in configuration\n");
+		return -EINVAL;
+	}
+
+	ret = isph3a_aewb_validate_params(isp_h3a, aewbcfg);
+	if (ret)
+		return ret;
+
+	/* FIXME: This win_count handling looks really fishy. */
+	win_count = aewbcfg->ver_win_count * aewbcfg->hor_win_count;
+	win_count += aewbcfg->hor_win_count;
+	ret = win_count / 8;
+	win_count += win_count % 8 ? 1 : 0;
+	win_count += ret;
+
+	buf_size = win_count * AEWB_PACKET_SIZE;
+
+	ret = ispstat_bufs_alloc(&isp_h3a->stat, buf_size);
+	if (ret)
+		return ret;
+
+	buf = ispstat_buf_next(&isp_h3a->stat);
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	isp_h3a->win_count = win_count;
+
+	isph3a_aewb_set_params(isp_h3a, aewbcfg);
+	isp_reg_writel(isp_h3a->dev, buf->iommu_addr,
+		       OMAP3_ISP_IOMEM_H3A, ISPH3A_AEWBUFST);
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+	isph3a_aewb_enable(isp_h3a, aewbcfg->aewb_enable);
+	isph3a_print_status(isp_h3a);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(isph3a_aewb_configure);
+
+/**
+ * isph3a_aewb_request_statistics - REquest statistics and update gains in AEWB
+ * @aewbdata: Pointer to return AE AWB statistics data.
+ *
+ * This API allows the user to update White Balance gains, as well as
+ * exposure time and analog gain. It is also used to request frame
+ * statistics.
+ *
+ * Returns 0 if successful, -EINVAL when H3A engine is not enabled, or other
+ * errors when setting gains.
+ **/
+int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_data *aewbdata)
+{
+	unsigned long irqflags;
+	int ret = 0;
+
+	if (!isp_h3a->aewb_config_local.aewb_enable) {
+		dev_err(isp_h3a->dev, "h3a: engine not enabled\n");
+		return -EINVAL;
+	}
+
+	DPRINTK_ISPH3A("isph3a_aewb_request_statistics: Enter "
+		       "(frame req. => %d, current frame => %d,"
+		       "update => %d)\n",
+		       aewbdata->frame_number, isp_h3a->stat.frame_number,
+		       aewbdata->update);
+	DPRINTK_ISPH3A("User data received:\n");
+	DPRINTK_ISPH3A("Digital gain = 0x%04x\n", aewbdata->dgain);
+	DPRINTK_ISPH3A("WB gain b *=   0x%04x\n", aewbdata->wb_gain_b);
+	DPRINTK_ISPH3A("WB gain r *=   0x%04x\n", aewbdata->wb_gain_r);
+	DPRINTK_ISPH3A("WB gain gb =   0x%04x\n", aewbdata->wb_gain_gb);
+	DPRINTK_ISPH3A("WB gain gr =   0x%04x\n", aewbdata->wb_gain_gr);
+
+	spin_lock_irqsave(isp_h3a->lock, irqflags);
+
+	if (aewbdata->update & SET_DIGITAL_GAIN)
+		isp_h3a->h3awb_update.dgain = (u16)aewbdata->dgain;
+	if (aewbdata->update & SET_COLOR_GAINS) {
+		isp_h3a->h3awb_update.coef0 = (u8)aewbdata->wb_gain_r;
+		isp_h3a->h3awb_update.coef1 = (u8)aewbdata->wb_gain_gr;
+		isp_h3a->h3awb_update.coef2 = (u8)aewbdata->wb_gain_gb;
+		isp_h3a->h3awb_update.coef3 = (u8)aewbdata->wb_gain_b;
+	}
+	if (aewbdata->update & (SET_COLOR_GAINS | SET_DIGITAL_GAIN))
+		isp_h3a->wb_update = 1;
+
+	spin_unlock_irqrestore(isp_h3a->lock, irqflags);
+
+	if (aewbdata->update & REQUEST_STATISTICS)
+		ret = isph3a_aewb_get_stats(isp_h3a, aewbdata);
+	aewbdata->curr_frame = isp_h3a->stat.frame_number;
+
+	DPRINTK_ISPH3A("isph3a_aewb_request_statistics: "
+		       "aewbdata->h3a_aewb_statistics_buf => %p\n",
+		       aewbdata->h3a_aewb_statistics_buf);
+
+	return ret;
+}
+EXPORT_SYMBOL(isph3a_aewb_request_statistics);
+
+/**
+ * isph3a_aewb_init - Module Initialisation.
+ *
+ * Always returns 0.
+ **/
+int __init isph3a_aewb_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_h3a_device *isp_h3a = &isp->isp_h3a;
+
+	isp_h3a->dev = dev;
+	isp_h3a->lock = &isp->h3a_lock;
+	isp_h3a->aewb_config_local.saturation_limit = AEWB_SATURATION_LIMIT;
+	ispstat_init(dev, &isp_h3a->stat, H3A_MAX_BUFF, MAX_FRAME_COUNT);
+
+	return 0;
+}
+
+/**
+ * isph3a_aewb_cleanup - Module exit.
+ **/
+void isph3a_aewb_cleanup(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	ispstat_free(&isp->isp_h3a.stat);
+}
+
+/**
+ * isph3a_print_status - Debug print. Values of H3A related registers.
+ **/
+static void isph3a_print_status(struct isp_h3a_device *isp_h3a)
+{
+	DPRINTK_ISPH3A("ISPH3A_PCR = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_PCR));
+	DPRINTK_ISPH3A("ISPH3A_AEWWIN1 = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_AEWWIN1));
+	DPRINTK_ISPH3A("ISPH3A_AEWINSTART = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_AEWINSTART));
+	DPRINTK_ISPH3A("ISPH3A_AEWINBLK = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_AEWINBLK));
+	DPRINTK_ISPH3A("ISPH3A_AEWSUBWIN = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_AEWSUBWIN));
+	DPRINTK_ISPH3A("ISPH3A_AEWBUFST = 0x%08x\n",
+		       isp_reg_readl(isp_h3a->dev, OMAP3_ISP_IOMEM_H3A,
+				     ISPH3A_AEWBUFST));
+	DPRINTK_ISPH3A("stats windows = %d\n", isp_h3a->win_count);
+	DPRINTK_ISPH3A("stats buf size = %d\n", isp_h3a->stat.buf_size);
+}
+
+/**
+ * isph3a_save_context - Saves the values of the h3a module registers.
+ **/
+void isph3a_save_context(struct device *dev)
+{
+	DPRINTK_ISPH3A(" Saving context\n");
+	isp_save_context(dev, isph3a_reg_list);
+	/* Avoid enable during restore ctx */
+	isph3a_reg_list[0].val &= ~ISPH3A_PCR_AEW_EN;
+}
+EXPORT_SYMBOL(isph3a_save_context);
+
+/**
+ * isph3a_restore_context - Restores the values of the h3a module registers.
+ **/
+void isph3a_restore_context(struct device *dev)
+{
+	DPRINTK_ISPH3A(" Restoring context\n");
+	isp_restore_context(dev, isph3a_reg_list);
+}
+EXPORT_SYMBOL(isph3a_restore_context);
diff --git a/drivers/media/video/isp/isph3a.h b/drivers/media/video/isp/isph3a.h
new file mode 100644
index 0000000..32994bc
--- /dev/null
+++ b/drivers/media/video/isp/isph3a.h
@@ -0,0 +1,154 @@
+/*
+ * isph3a.h
+ *
+ * Include file for H3A module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_H3A_H
+#define OMAP_ISP_H3A_H
+
+#include <plat/isp_user.h>
+
+#define AEWB_PACKET_SIZE	16
+#define H3A_MAX_BUFF		5
+#define AEWB_SATURATION_LIMIT	0x3FF
+
+/* Flags for changed registers */
+#define PCR_CHNG		(1 << 0)
+#define AEWWIN1_CHNG		(1 << 1)
+#define AEWINSTART_CHNG		(1 << 2)
+#define AEWINBLK_CHNG		(1 << 3)
+#define AEWSUBWIN_CHNG		(1 << 4)
+#define PRV_WBDGAIN_CHNG	(1 << 5)
+#define PRV_WBGAIN_CHNG		(1 << 6)
+
+/* ISPH3A REGISTERS bits */
+#define ISPH3A_PCR_AF_EN	(1 << 0)
+#define ISPH3A_PCR_AF_ALAW_EN	(1 << 1)
+#define ISPH3A_PCR_AF_MED_EN	(1 << 2)
+#define ISPH3A_PCR_AF_BUSY	(1 << 15)
+#define ISPH3A_PCR_AEW_EN	(1 << 16)
+#define ISPH3A_PCR_AEW_ALAW_EN	(1 << 17)
+#define ISPH3A_PCR_AEW_BUSY	(1 << 18)
+#define ISPH3A_PCR_AEW_MASK	(ISPH3A_PCR_AEW_EN | ISPH3A_PCR_AEW_ALAW_EN | \
+				 ISPH3A_PCR_AEW_AVE2LMT_MASK)
+
+#define WRITE_SAT_LIM(reg, sat_limit)			\
+	(reg = (reg & (~(ISPH3A_PCR_AEW_AVE2LMT_MASK))) \
+	 | (sat_limit << ISPH3A_PCR_AEW_AVE2LMT_SHIFT))
+
+#define WRITE_ALAW(reg, alaw_en)			\
+	(reg = (reg & (~(ISPH3A_PCR_AEW_ALAW_EN)))	\
+	 | ((alaw_en & ISPH3A_PCR_AF_ALAW_EN)		\
+	    << ISPH3A_PCR_AEW_ALAW_EN_SHIFT))
+
+#define WRITE_WIN_H(reg, height)				\
+	(reg = (reg & (~(ISPH3A_AEWWIN1_WINH_MASK)))		\
+	 | (((height >> 1) - 1) << ISPH3A_AEWWIN1_WINH_SHIFT))
+
+#define WRITE_WIN_W(reg, width)					\
+	(reg = (reg & (~(ISPH3A_AEWWIN1_WINW_MASK)))		\
+	 | (((width >> 1) - 1) << ISPH3A_AEWWIN1_WINW_SHIFT))
+
+#define WRITE_VER_C(reg, ver_count)				\
+	(reg = (reg & ~(ISPH3A_AEWWIN1_WINVC_MASK))		\
+	 | ((ver_count - 1) << ISPH3A_AEWWIN1_WINVC_SHIFT))
+
+#define WRITE_HOR_C(reg, hor_count)				\
+	(reg = (reg & ~(ISPH3A_AEWWIN1_WINHC_MASK))		\
+	 | ((hor_count - 1) << ISPH3A_AEWWIN1_WINHC_SHIFT))
+
+#define WRITE_VER_WIN_ST(reg, ver_win_st)			\
+	(reg = (reg & ~(ISPH3A_AEWINSTART_WINSV_MASK))		\
+	 | (ver_win_st << ISPH3A_AEWINSTART_WINSV_SHIFT))
+
+#define WRITE_HOR_WIN_ST(reg, hor_win_st)			\
+	(reg = (reg & ~(ISPH3A_AEWINSTART_WINSH_MASK))		\
+	 | (hor_win_st << ISPH3A_AEWINSTART_WINSH_SHIFT))
+
+#define WRITE_BLK_VER_WIN_ST(reg, blk_win_st)		\
+	(reg = (reg & ~(ISPH3A_AEWINBLK_WINSV_MASK))	\
+	 | (blk_win_st << ISPH3A_AEWINBLK_WINSV_SHIFT))
+
+#define WRITE_BLK_WIN_H(reg, height)				\
+	(reg = (reg & ~(ISPH3A_AEWINBLK_WINH_MASK))		\
+	 | (((height >> 1) - 1) << ISPH3A_AEWINBLK_WINH_SHIFT))
+
+#define WRITE_SUB_VER_INC(reg, sub_ver_inc)				\
+	(reg = (reg & ~(ISPH3A_AEWSUBWIN_AEWINCV_MASK))			\
+	 | (((sub_ver_inc >> 1) - 1) << ISPH3A_AEWSUBWIN_AEWINCV_SHIFT))
+
+#define WRITE_SUB_HOR_INC(reg, sub_hor_inc)				\
+	(reg = (reg & ~(ISPH3A_AEWSUBWIN_AEWINCH_MASK))			\
+	 | (((sub_hor_inc >> 1) - 1) << ISPH3A_AEWSUBWIN_AEWINCH_SHIFT))
+
+/**
+ * struct isph3a_aewb_regs - Current value of AE, AWB configuration registers.
+ * pcr: Peripheral control register.
+ * win1: Control register.
+ * start: Start position register.
+ * blk: Black line register.
+ * subwin: Configuration register.
+ */
+struct isph3a_aewb_regs {
+	u32 pcr;
+	u32 win1;
+	u32 start;
+	u32 blk;
+	u32 subwin;
+};
+
+struct isp_h3a_device {
+	spinlock_t *lock;		/* Lock for this struct */
+
+	u8 update;
+	int pm_state;
+	int wb_update;
+
+	struct isph3a_aewb_regs regs;
+	struct ispprev_wbal h3awb_update;
+	struct isph3a_aewb_config aewb_config_local;
+	u16 win_count;
+
+	struct device *dev;
+
+	struct ispstat stat;
+};
+
+int isph3a_aewb_configure(struct isp_h3a_device *isp_h3a,
+			  struct isph3a_aewb_config *aewbcfg);
+
+int isph3a_aewb_request_statistics(struct isp_h3a_device *isp_h3a,
+				   struct isph3a_aewb_data *aewbdata);
+
+void isph3a_save_context(struct device *dev);
+
+void isph3a_restore_context(struct device *dev);
+
+void isph3a_aewb_enable(struct isp_h3a_device *isp_h3a, u8 enable);
+
+int isph3a_aewb_busy(struct isp_h3a_device *isp_h3a);
+
+void isph3a_aewb_suspend(struct isp_h3a_device *isp_h3a);
+
+void isph3a_aewb_resume(struct isp_h3a_device *isp_h3a);
+
+void isph3a_update_wb(struct isp_h3a_device *isp_h3a);
+
+void isph3a_aewb_isr(struct isp_h3a_device *isp_h3a);
+
+#endif		/* OMAP_ISP_H3A_H */
diff --git a/drivers/media/video/isp/isphist.c b/drivers/media/video/isp/isphist.c
new file mode 100644
index 0000000..d1cf1f9
--- /dev/null
+++ b/drivers/media/video/isp/isphist.c
@@ -0,0 +1,577 @@
+/*
+ * isphist.c
+ *
+ * HISTOGRAM module for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <asm/cacheflush.h>
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "isphist.h"
+
+/* Structure for saving/restoring histogram module registers */
+struct isp_reg isphist_reg_list[] = {
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_HORZ, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_VERT, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_HORZ, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_VERT, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_HORZ, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_VERT, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_HORZ, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_VERT, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD_OFF, 0},
+	{OMAP3_ISP_IOMEM_HIST, ISPHIST_H_V_INFO, 0},
+	{0, ISP_TOK_TERM, 0}
+};
+
+static void isp_hist_print_status(struct isp_hist_device *isp_hist);
+
+void __isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable)
+{
+	if (enable)
+		DPRINTK_ISPHIST("   histogram enabled\n");
+	else
+		DPRINTK_ISPHIST("   histogram disabled\n");
+
+	isp_reg_and_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,
+		       ~ISPHIST_PCR_EN,	(enable ? ISPHIST_PCR_EN : 0));
+	isp_hist->hist_enable = enable;
+}
+
+/**
+ * isp_hist_enable - Enables ISP Histogram submodule operation.
+ * @enable: 1 - Enables the histogram submodule.
+ *
+ * Client should configure all the Histogram registers before calling this
+ * function.
+ **/
+void isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable)
+{
+	__isp_hist_enable(isp_hist, enable);
+	isp_hist->pm_state = enable;
+}
+
+/**
+ * isp_hist_suspend - Suspend ISP Histogram submodule.
+ **/
+void isp_hist_suspend(struct isp_hist_device *isp_hist)
+{
+	if (isp_hist->pm_state)
+		__isp_hist_enable(isp_hist, 0);
+}
+
+/**
+ * isp_hist_resume - Resume ISP Histogram submodule.
+ **/
+void isp_hist_resume(struct isp_hist_device *isp_hist)
+{
+	if (isp_hist->pm_state)
+		__isp_hist_enable(isp_hist, 1);
+}
+
+int isp_hist_busy(struct isp_hist_device *isp_hist)
+{
+	return isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)
+			     & ISPHIST_PCR_BUSY;
+}
+
+
+/**
+ * isp_hist_update_regs - Helper function to update Histogram registers.
+ **/
+static void isp_hist_update_regs(struct isp_hist_device *isp_hist)
+{
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.pcr, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_PCR);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.cnt, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_CNT);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.wb_gain,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r0_h, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R0_HORZ);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r0_v, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R0_VERT);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r1_h, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R1_HORZ);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r1_v, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R1_VERT);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r2_h, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R2_HORZ);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r2_v, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R2_VERT);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r3_h, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R3_HORZ);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.r3_v, OMAP3_ISP_IOMEM_HIST,
+		       ISPHIST_R3_VERT);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_addr,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_data,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_radd,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.hist_radd_off,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_RADD_OFF);
+	isp_reg_writel(isp_hist->dev, isp_hist->regs.h_v_info,
+		       OMAP3_ISP_IOMEM_HIST, ISPHIST_H_V_INFO);
+}
+
+/**
+ * isp_hist_isr - Callback from ISP driver for HIST interrupt.
+ * @status: IRQ0STATUS in case of MMU error, 0 for hist interrupt.
+ *          arg1 and arg2 Not used as of now.
+ **/
+static void isp_hist_isr(unsigned long status, isp_vbq_callback_ptr arg1,
+			 void *arg2)
+{
+	struct isp_hist_device *isp_hist = arg2;
+
+	isp_hist_enable(isp_hist, 0);
+
+	if (!(status & HIST_DONE))
+		return;
+
+	if (!isp_hist->completed) {
+		if (isp_hist->frame_req == isp_hist->frame_cnt) {
+			isp_hist->frame_cnt = 0;
+			isp_hist->frame_req = 0;
+			isp_hist->completed = 1;
+		} else {
+			isp_hist_enable(isp_hist, 1);
+			isp_hist->frame_cnt++;
+		}
+	}
+}
+
+/**
+ * isp_hist_reset_mem - clear Histogram memory before start stats engine.
+ *
+ * Returns 0 after histogram memory was cleared.
+ **/
+static int isp_hist_reset_mem(struct isp_hist_device *isp_hist)
+{
+	int i;
+
+	isp_reg_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		   ISPHIST_CNT_CLR_EN);
+
+	for (i = 0; i < HIST_MEM_SIZE; i++)
+		isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+			      ISPHIST_DATA);
+
+	isp_reg_and(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		    ~ISPHIST_CNT_CLR_EN);
+
+	return 0;
+}
+
+/**
+ * isp_hist_set_params - Helper function to check and store user given params.
+ * @user_cfg: Pointer to user configuration structure.
+ *
+ * Returns 0 on success configuration.
+ **/
+static int isp_hist_set_params(struct isp_hist_device *isp_hist,
+			       struct isp_hist_config *user_cfg)
+{
+
+	int reg_num = 0;
+	int bit_shift = 0;
+
+
+	if (isp_hist_busy(isp_hist))
+		return -EINVAL;
+
+	if (user_cfg->input_bit_width > MIN_BIT_WIDTH)
+		WRITE_DATA_SIZE(isp_hist->regs.cnt, 0);
+	else
+		WRITE_DATA_SIZE(isp_hist->regs.cnt, 1);
+
+	WRITE_SOURCE(isp_hist->regs.cnt, user_cfg->hist_source);
+
+	if (user_cfg->hist_source) {
+		WRITE_HV_INFO(isp_hist->regs.h_v_info, user_cfg->hist_h_v_info);
+
+		if ((user_cfg->hist_radd & ISP_32B_BOUNDARY_BUF) ==
+		    user_cfg->hist_radd) {
+			WRITE_RADD(isp_hist->regs.hist_radd,
+				   user_cfg->hist_radd);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Address should be in 32 byte boundary"
+				"\n");
+			return -EINVAL;
+		}
+
+		if ((user_cfg->hist_radd_off & ISP_32B_BOUNDARY_OFFSET) ==
+		    user_cfg->hist_radd_off) {
+			WRITE_RADD_OFF(isp_hist->regs.hist_radd_off,
+				       user_cfg->hist_radd_off);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Offset should be in 32 byte boundary\n");
+			return -EINVAL;
+		}
+
+	}
+
+	isp_hist_reset_mem(isp_hist);
+	DPRINTK_ISPHIST("ISPHIST: Memory Cleared\n");
+	isp_hist->frame_req = user_cfg->hist_frames;
+
+	if (unlikely(user_cfg->wb_gain_R > MAX_WB_GAIN ||
+		     user_cfg->wb_gain_RG > MAX_WB_GAIN ||
+		     user_cfg->wb_gain_B > MAX_WB_GAIN ||
+		     user_cfg->wb_gain_BG > MAX_WB_GAIN)) {
+		dev_err(isp_hist->dev, "hist: Invalid WB gain\n");
+		return -EINVAL;
+	} else {
+		WRITE_WB_R(isp_hist->regs.wb_gain, user_cfg->wb_gain_R);
+		WRITE_WB_RG(isp_hist->regs.wb_gain, user_cfg->wb_gain_RG);
+		WRITE_WB_B(isp_hist->regs.wb_gain, user_cfg->wb_gain_B);
+		WRITE_WB_BG(isp_hist->regs.wb_gain, user_cfg->wb_gain_BG);
+	}
+
+	/* Regions size and position */
+
+	if (user_cfg->num_regions > MAX_REGIONS)
+		return -EINVAL;
+
+	if (likely((user_cfg->reg0_hor & ISPHIST_REGHORIZ_HEND_MASK) -
+		   ((user_cfg->reg0_hor & ISPHIST_REGHORIZ_HSTART_MASK) >>
+		    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
+		WRITE_REG_HORIZ(isp_hist->regs.r0_h, user_cfg->reg0_hor);
+		reg_num++;
+	} else {
+		dev_err(isp_hist->dev, "hist: Invalid Region parameters\n");
+		return -EINVAL;
+	}
+
+	if (likely((user_cfg->reg0_ver & ISPHIST_REGVERT_VEND_MASK) -
+		   ((user_cfg->reg0_ver & ISPHIST_REGVERT_VSTART_MASK) >>
+		    ISPHIST_REGVERT_VSTART_SHIFT))) {
+		WRITE_REG_VERT(isp_hist->regs.r0_v, user_cfg->reg0_ver);
+	} else {
+		dev_err(isp_hist->dev, "hist: Invalid Region parameters\n");
+		return -EINVAL;
+	}
+
+	if (user_cfg->num_regions >= 1) {
+		if (likely((user_cfg->reg1_hor & ISPHIST_REGHORIZ_HEND_MASK) -
+			   ((user_cfg->reg1_hor &
+			     ISPHIST_REGHORIZ_HSTART_MASK) >>
+			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
+			WRITE_REG_HORIZ(isp_hist->regs.r1_h,
+					user_cfg->reg1_hor);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+
+		if (likely((user_cfg->reg1_ver & ISPHIST_REGVERT_VEND_MASK) -
+			   ((user_cfg->reg1_ver &
+			     ISPHIST_REGVERT_VSTART_MASK) >>
+			    ISPHIST_REGVERT_VSTART_SHIFT))) {
+			WRITE_REG_VERT(isp_hist->regs.r1_v,
+				       user_cfg->reg1_ver);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+	}
+
+	if (user_cfg->num_regions >= 2) {
+		if (likely((user_cfg->reg2_hor & ISPHIST_REGHORIZ_HEND_MASK) -
+			   ((user_cfg->reg2_hor &
+			     ISPHIST_REGHORIZ_HSTART_MASK) >>
+			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
+			WRITE_REG_HORIZ(isp_hist->regs.r2_h,
+					user_cfg->reg2_hor);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+
+		if (likely((user_cfg->reg2_ver & ISPHIST_REGVERT_VEND_MASK) -
+			   ((user_cfg->reg2_ver &
+			     ISPHIST_REGVERT_VSTART_MASK) >>
+			    ISPHIST_REGVERT_VSTART_SHIFT))) {
+			WRITE_REG_VERT(isp_hist->regs.r2_v,
+				       user_cfg->reg2_ver);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+	}
+
+	if (user_cfg->num_regions >= 3) {
+		if (likely((user_cfg->reg3_hor & ISPHIST_REGHORIZ_HEND_MASK) -
+			   ((user_cfg->reg3_hor &
+			     ISPHIST_REGHORIZ_HSTART_MASK) >>
+			    ISPHIST_REGHORIZ_HSTART_SHIFT))) {
+			WRITE_REG_HORIZ(isp_hist->regs.r3_h,
+					user_cfg->reg3_hor);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+
+		if (likely((user_cfg->reg3_ver & ISPHIST_REGVERT_VEND_MASK) -
+			   ((user_cfg->reg3_ver &
+			     ISPHIST_REGVERT_VSTART_MASK) >>
+			    ISPHIST_REGVERT_VSTART_SHIFT))) {
+			WRITE_REG_VERT(isp_hist->regs.r3_v,
+				       user_cfg->reg3_ver);
+		} else {
+			dev_err(isp_hist->dev,
+				"hist: Invalid Region parameters\n");
+			return -EINVAL;
+		}
+	}
+	reg_num = user_cfg->num_regions;
+	if (unlikely(((user_cfg->hist_bins > BINS_256) &&
+		      (user_cfg->hist_bins != BINS_32)) ||
+		     ((user_cfg->hist_bins == BINS_256) &&
+		      reg_num != 0) || ((user_cfg->hist_bins ==
+					 BINS_128) && reg_num >= 2))) {
+		dev_err(isp_hist->dev, "hist: Invalid Bins Number: %d\n",
+		       user_cfg->hist_bins);
+		return -EINVAL;
+	} else {
+		WRITE_NUM_BINS(isp_hist->regs.cnt, user_cfg->hist_bins);
+	}
+
+	if (user_cfg->input_bit_width > MAX_BIT_WIDTH ||
+	    user_cfg->input_bit_width < MIN_BIT_WIDTH) {
+		dev_err(isp_hist->dev, "hist: Invalid Bit Width: %d\n",
+		       user_cfg->input_bit_width);
+		return -EINVAL;
+	} else {
+		switch (user_cfg->hist_bins) {
+		case BINS_256:
+			bit_shift = user_cfg->input_bit_width - 8;
+			break;
+		case BINS_128:
+			bit_shift = user_cfg->input_bit_width - 7;
+			break;
+		case BINS_64:
+			bit_shift = user_cfg->input_bit_width - 6;
+			break;
+		case BINS_32:
+			bit_shift = user_cfg->input_bit_width - 5;
+			break;
+		default:
+			return -EINVAL;
+		}
+		WRITE_BIT_SHIFT(isp_hist->regs.cnt, bit_shift);
+	}
+
+	isp_hist_update_regs(isp_hist);
+	isp_hist->initialized = 1;
+
+	return 0;
+}
+
+/**
+ * isp_hist_configure - API to configure HIST registers.
+ * @histcfg: Pointer to user configuration structure.
+ *
+ * Returns 0 on success configuration.
+ **/
+int isp_hist_configure(struct isp_hist_device *isp_hist,
+		       struct isp_hist_config *histcfg)
+{
+
+	int ret = 0;
+
+	if (NULL == histcfg) {
+		dev_err(isp_hist->dev,
+			"hist: Null argument in configuration.\n");
+		return -EINVAL;
+	}
+
+	if (!isp_hist->initialized) {
+		DPRINTK_ISPHIST("Setting callback for HISTOGRAM\n");
+		ret = isp_set_callback(isp_hist->dev, CBK_HIST_DONE,
+				       isp_hist_isr, (void *)NULL,
+				       isp_hist);
+		if (ret) {
+			dev_err(isp_hist->dev, "hist: No callback for HIST\n");
+			return ret;
+		}
+	}
+
+	ret = isp_hist_set_params(isp_hist, histcfg);
+	if (ret) {
+		dev_err(isp_hist->dev, "hist: Invalid parameters!\n");
+		return ret;
+	}
+
+	isp_hist->frame_cnt = 0;
+	isp_hist->completed = 0;
+	isp_hist_enable(isp_hist, 1);
+	isp_hist_print_status(isp_hist);
+
+	return 0;
+}
+EXPORT_SYMBOL(isp_hist_configure);
+
+/**
+ * isp_hist_request_statistics - Request statistics in Histogram.
+ * @histdata: Pointer to data structure.
+ *
+ * This API allows the user to request for histogram statistics.
+ *
+ * Returns 0 on successful request.
+ **/
+int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+				struct isp_hist_data *histdata)
+{
+	int i, ret;
+	u32 curr;
+
+	if (isp_hist_busy(isp_hist))
+		return -EBUSY;
+
+	if (!isp_hist->completed && isp_hist->initialized)
+		return -EINVAL;
+
+	isp_reg_or(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		   ISPHIST_CNT_CLR_EN);
+
+	for (i = 0; i < HIST_MEM_SIZE; i++) {
+		curr = isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				     ISPHIST_DATA);
+		ret = put_user(curr, histdata->hist_statistics_buf + i);
+		if (ret) {
+			dev_err(isp_hist->dev, "hist: Failed copy_to_user for "
+			       "HIST stats buff, %d\n", ret);
+		}
+	}
+
+	isp_reg_and(isp_hist->dev, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,
+		    ~ISPHIST_CNT_CLR_EN);
+	isp_hist->completed = 0;
+	return 0;
+}
+EXPORT_SYMBOL(isp_hist_request_statistics);
+
+/**
+ * isp_hist_init - Module Initialization.
+ *
+ * Returns 0 if successful.
+ **/
+int __init isp_hist_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+
+	isp->isp_hist.dev = dev;
+
+	return 0;
+}
+
+/**
+ * isp_hist_cleanup - Module cleanup.
+ **/
+void isp_hist_cleanup(struct device *dev)
+{
+}
+
+/**
+ * isphist_save_context - Saves the values of the histogram module registers.
+ **/
+void isphist_save_context(struct device *dev)
+{
+	DPRINTK_ISPHIST(" Saving context\n");
+	isp_save_context(dev, isphist_reg_list);
+}
+EXPORT_SYMBOL(isphist_save_context);
+
+/**
+ * isphist_restore_context - Restores the values of the histogram module regs.
+ **/
+void isphist_restore_context(struct device *dev)
+{
+	DPRINTK_ISPHIST(" Restoring context\n");
+	isp_restore_context(dev, isphist_reg_list);
+}
+EXPORT_SYMBOL(isphist_restore_context);
+
+/**
+ * isp_hist_print_status - Debug print
+ **/
+static void isp_hist_print_status(struct isp_hist_device *isp_hist)
+{
+	DPRINTK_ISPHIST("ISPHIST_PCR = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_PCR));
+	DPRINTK_ISPHIST("ISPHIST_CNT = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_CNT));
+	DPRINTK_ISPHIST("ISPHIST_WB_GAIN = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_WB_GAIN));
+	DPRINTK_ISPHIST("ISPHIST_R0_HORZ = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R0_HORZ));
+	DPRINTK_ISPHIST("ISPHIST_R0_VERT = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R0_VERT));
+	DPRINTK_ISPHIST("ISPHIST_R1_HORZ = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R1_HORZ));
+	DPRINTK_ISPHIST("ISPHIST_R1_VERT = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R1_VERT));
+	DPRINTK_ISPHIST("ISPHIST_R2_HORZ = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R2_HORZ));
+	DPRINTK_ISPHIST("ISPHIST_R2_VERT = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R2_VERT));
+	DPRINTK_ISPHIST("ISPHIST_R3_HORZ = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R3_HORZ));
+	DPRINTK_ISPHIST("ISPHIST_R3_VERT = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_R3_VERT));
+	DPRINTK_ISPHIST("ISPHIST_ADDR = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_ADDR));
+	DPRINTK_ISPHIST("ISPHIST_RADD = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_RADD));
+	DPRINTK_ISPHIST("ISPHIST_RADD_OFF = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_RADD_OFF));
+	DPRINTK_ISPHIST("ISPHIST_H_V_INFO = 0x%08x\n",
+			isp_reg_readl(isp_hist->dev, OMAP3_ISP_IOMEM_HIST,
+				      ISPHIST_H_V_INFO));
+}
diff --git a/drivers/media/video/isp/isphist.h b/drivers/media/video/isp/isphist.h
new file mode 100644
index 0000000..021b165
--- /dev/null
+++ b/drivers/media/video/isp/isphist.h
@@ -0,0 +1,163 @@
+/*
+ * isphist.h
+ *
+ * Header file for HISTOGRAM module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_HIST_H
+#define OMAP_ISP_HIST_H
+
+#include <plat/isp_user.h>
+
+#define MAX_REGIONS		0x4
+#define MAX_WB_GAIN		255
+#define MIN_WB_GAIN		0x0
+#define MAX_BIT_WIDTH		14
+#define MIN_BIT_WIDTH		8
+
+#define ISPHIST_PCR_EN		(1 << 0)
+#define HIST_MEM_SIZE		1024
+#define ISPHIST_CNT_CLR_EN	(1 << 7)
+
+#define WRITE_SOURCE(reg, source)			\
+	(reg = (reg & ~(ISPHIST_CNT_SOURCE_MASK))	\
+	 | (source << ISPHIST_CNT_SOURCE_SHIFT))
+
+#define WRITE_HV_INFO(reg, hv_info)			\
+	(reg = ((reg & ~(ISPHIST_HV_INFO_MASK))		\
+		| (hv_info & ISPHIST_HV_INFO_MASK)))
+
+#define WRITE_RADD(reg, radd)			\
+	(reg = (reg & ~(ISPHIST_RADD_MASK))	\
+	 | (radd << ISPHIST_RADD_SHIFT))
+
+#define WRITE_RADD_OFF(reg, radd_off)			\
+	(reg = (reg & ~(ISPHIST_RADD_OFF_MASK))		\
+	 | (radd_off << ISPHIST_RADD_OFF_SHIFT))
+
+#define WRITE_BIT_SHIFT(reg, bit_shift)			\
+	(reg = (reg & ~(ISPHIST_CNT_SHIFT_MASK))	\
+	 | (bit_shift << ISPHIST_CNT_SHIFT_SHIFT))
+
+#define WRITE_DATA_SIZE(reg, data_size)			\
+	(reg = (reg & ~(ISPHIST_CNT_DATASIZE_MASK))	\
+	 | (data_size << ISPHIST_CNT_DATASIZE_SHIFT))
+
+#define WRITE_NUM_BINS(reg, num_bins)			\
+	(reg = (reg & ~(ISPHIST_CNT_BINS_MASK))		\
+	 | (num_bins << ISPHIST_CNT_BINS_SHIFT))
+
+#define WRITE_WB_R(reg, reg_wb_gain)				\
+	reg = ((reg & ~(ISPHIST_WB_GAIN_WG00_MASK))		\
+	       | (reg_wb_gain << ISPHIST_WB_GAIN_WG00_SHIFT))
+
+#define WRITE_WB_RG(reg, reg_wb_gain)			\
+	(reg = (reg & ~(ISPHIST_WB_GAIN_WG01_MASK))	\
+	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG01_SHIFT))
+
+#define WRITE_WB_B(reg, reg_wb_gain)			\
+	(reg = (reg & ~(ISPHIST_WB_GAIN_WG02_MASK))	\
+	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG02_SHIFT))
+
+#define WRITE_WB_BG(reg, reg_wb_gain)			\
+	(reg = (reg & ~(ISPHIST_WB_GAIN_WG03_MASK))	\
+	 | (reg_wb_gain << ISPHIST_WB_GAIN_WG03_SHIFT))
+
+#define WRITE_REG_HORIZ(reg, reg_n_hor)			\
+	(reg = ((reg & ~ISPHIST_REGHORIZ_MASK)		\
+		| (reg_n_hor & ISPHIST_REGHORIZ_MASK)))
+
+#define WRITE_REG_VERT(reg, reg_n_vert)			\
+	(reg = ((reg & ~ISPHIST_REGVERT_MASK)		\
+		| (reg_n_vert & ISPHIST_REGVERT_MASK)))
+
+/**
+ * struct isp_hist_regs - Current value of Histogram configuration registers.
+ * @pcr: Peripheral control register.
+ * @cnt: Histogram control register.
+ * @wb_gain: Histogram white balance gain register.
+ * @r0_h: Region 0 horizontal register.
+ * @r0_v: Region 0 vertical register.
+ * @r1_h: Region 1 horizontal register.
+ * @r1_v: Region 1 vertical register.
+ * @r2_h: Region 2 horizontal register.
+ * @r2_v: Region 2 vertical register.
+ * @r3_h: Region 3 horizontal register.
+ * @r3_v: Region 3 vertical register.
+ * @hist_addr: Histogram address register.
+ * @hist_data: Histogram data.
+ * @hist_radd: Address register. When input data comes from mem.
+ * @hist_radd_off: Address offset register. When input data comes from mem.
+ * @h_v_info: Image size register. When input data comes from mem.
+ */
+struct isp_hist_regs {
+	u32 pcr;
+	u32 cnt;
+	u32 wb_gain;
+	u32 r0_h;
+	u32 r0_v;
+	u32 r1_h;
+	u32 r1_v;
+	u32 r2_h;
+	u32 r2_v;
+	u32 r3_h;
+	u32 r3_v;
+	u32 hist_addr;
+	u32 hist_data;
+	u32 hist_radd;
+	u32 hist_radd_off;
+	u32 h_v_info;
+};
+
+/**
+ * struct isp_hist_status - Histogram status.
+ * @hist_enable: Enables the histogram module.
+ * @initialized: Flag to indicate that the module is correctly initializated.
+ * @frame_cnt: Actual frame count.
+ * @frame_req: Frame requested by user.
+ * @completed: Flag to indicate if a frame request is completed.
+ */
+struct isp_hist_device {
+	u8 hist_enable;
+	u8 pm_state;
+	u8 initialized;
+	u8 frame_cnt;
+	u8 frame_req;
+	u8 completed;
+	struct isp_hist_regs regs;
+	struct device *dev;
+};
+
+void isp_hist_enable(struct isp_hist_device *isp_hist, u8 enable);
+
+int isp_hist_busy(struct isp_hist_device *isp_hist);
+
+int isp_hist_configure(struct isp_hist_device *isp_hist,
+		       struct isp_hist_config *histcfg);
+
+int isp_hist_request_statistics(struct isp_hist_device *isp_hist,
+				struct isp_hist_data *histdata);
+
+void isphist_save_context(struct device *dev);
+
+void isp_hist_suspend(struct isp_hist_device *isp_hist);
+
+void isp_hist_resume(struct isp_hist_device *isp_hist);
+
+void isphist_restore_context(struct device *dev);
+
+#endif				/* OMAP_ISP_HIST */
diff --git a/drivers/media/video/isp/isppreview.c b/drivers/media/video/isp/isppreview.c
new file mode 100644
index 0000000..e1a457d
--- /dev/null
+++ b/drivers/media/video/isp/isppreview.c
@@ -0,0 +1,1967 @@
+/*
+ * isppreview.c
+ *
+ * Driver Library for Preview module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Senthilvadivu Guruswamy <svadivu@ti.com>
+ *	Pallavi Kulkarni <p-kulkarni@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "isppreview.h"
+
+#define omap_rev_is_1_0() (GET_OMAP_REVISION() == 0x00)
+#define omap_rev_gt_1_0() (GET_OMAP_REVISION() >= 0x00)
+
+/* Structure for saving/restoring preview module registers */
+static struct isp_reg ispprev_reg_list[] = {
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RADR_OFFSET, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_DSDR_ADDR, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_DRKF_OFFSET, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_WSDR_ADDR, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_WADD_OFFSET, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_HMED, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_NF, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CFA, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT1, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT2, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT3, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT4, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT5, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF1, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF2, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC_OFFSET, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_SETUP_YC, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3, 0x0000},
+	{OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, 0x0000},
+	{0, ISP_TOK_TERM, 0x0000}
+};
+
+
+/* Default values in Office Flourescent Light for RGBtoRGB Blending */
+static struct ispprev_rgbtorgb flr_rgb2rgb = {
+	{	/* RGB-RGB Matrix */
+		{0x01E2, 0x0F30, 0x0FEE},
+		{0x0F9B, 0x01AC, 0x0FB9},
+		{0x0FE0, 0x0EC0, 0x0260}
+	},	/* RGB Offset */
+	{0x0000, 0x0000, 0x0000}
+};
+
+/* Default values in Office Flourescent Light for RGB to YUV Conversion*/
+static struct ispprev_csc flr_prev_csc[] = {
+	{
+		{	/* CSC Coef Matrix */
+			{66, 129, 25},
+			{-38, -75, 112},
+			{112, -94 , -18}
+		},	/* CSC Offset */
+		{0x0, 0x0, 0x0}
+	},
+	{
+		{	/* CSC Coef Matrix BW */
+			{66, 129, 25},
+			{0, 0, 0},
+			{0, 0, 0}
+		},	/* CSC Offset */
+		{0x0, 0x0, 0x0}
+	},
+	{
+		{	/* CSC Coef Matrix Sepia */
+			{19, 38, 7},
+			{0, 0, 0},
+			{0, 0, 0}
+		},	/* CSC Offset */
+		{0x0, 0xE7, 0x14}
+	}
+};
+
+
+/* Default values in Office Flourescent Light for CFA Gradient*/
+#define FLR_CFA_GRADTHRS_HORZ	0x28
+#define FLR_CFA_GRADTHRS_VERT	0x28
+
+/* Default values in Office Flourescent Light for Chroma Suppression*/
+#define FLR_CSUP_GAIN		0x0D
+#define FLR_CSUP_THRES		0xEB
+
+/* Default values in Office Flourescent Light for Noise Filter*/
+#define FLR_NF_STRGTH		0x03
+
+/* Default values in Office Flourescent Light for White Balance*/
+#define FLR_WBAL_DGAIN		0x100
+#define FLR_WBAL_COEF0		0x29
+#define FLR_WBAL_COEF1		0x20
+#define FLR_WBAL_COEF2		0x20
+#define FLR_WBAL_COEF3		0x2d
+
+#define FLR_WBAL_COEF0_ES1	0x23
+#define FLR_WBAL_COEF1_ES1	0x20
+#define FLR_WBAL_COEF2_ES1	0x20
+#define FLR_WBAL_COEF3_ES1	0x39
+
+/* Default values in Office Flourescent Light for Black Adjustment*/
+#define FLR_BLKADJ_BLUE		0x0
+#define FLR_BLKADJ_GREEN	0x0
+#define FLR_BLKADJ_RED		0x0
+
+/*
+ * Coeficient Tables for the submodules in Preview.
+ * Array is initialised with the values from.the tables text file.
+ */
+
+/*
+ * CFA Filter Coefficient Table
+ *
+ */
+static u32 cfa_coef_table[] = {
+#include "cfa_coef_table.h"
+};
+
+/*
+ * Gamma Correction Table - Red
+ */
+static u32 redgamma_table[] = {
+#include "redgamma_table.h"
+};
+
+/*
+ * Gamma Correction Table - Green
+ */
+static u32 greengamma_table[] = {
+#include "greengamma_table.h"
+};
+
+/*
+ * Gamma Correction Table - Blue
+ */
+static u32 bluegamma_table[] = {
+#include "bluegamma_table.h"
+};
+
+/*
+ * Noise Filter Threshold table
+ */
+static u32 noise_filter_table[] = {
+#include "noise_filter_table.h"
+};
+
+/*
+ * Luminance Enhancement Table
+ */
+static u32 luma_enhance_table[] = {
+#include "luma_enhance_table.h"
+};
+
+static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
+				struct isptables_update *isptables_struct);
+
+
+/**
+ * omap34xx_isp_preview_config - Abstraction layer Preview configuration.
+ * @userspace_add: Pointer from Userspace to structure with flags and data to
+ *                 update.
+ **/
+int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
+				void *userspace_add)
+{
+	struct isp_device *isp =
+		container_of(isp_prev, struct isp_device, isp_prev);
+	struct ispprev_hmed prev_hmed_t;
+	struct ispprev_csup csup_t;
+	struct ispprev_wbal prev_wbal_t;
+	struct ispprev_blkadj prev_blkadj_t;
+	struct ispprev_yclimit yclimit_t;
+	struct ispprev_dcor prev_dcor_t;
+	struct ispprv_update_config *config;
+	struct isptables_update isp_table_update;
+	int yen_t[ISPPRV_YENH_TBL_SIZE];
+	unsigned long flags;
+
+	if (userspace_add == NULL)
+		return -EINVAL;
+
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 1;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
+	config = userspace_add;
+
+	if (isp->running != ISP_STOPPED)
+		goto out_config_shadow;
+
+	if (ISP_ABS_PREV_LUMAENH & config->flag) {
+		if (ISP_ABS_PREV_LUMAENH & config->update) {
+			if (copy_from_user(yen_t, config->yen,
+					   sizeof(yen_t)))
+				goto err_copy_from_user;
+			isppreview_config_luma_enhancement(isp_prev, yen_t);
+		}
+		isp_prev->params.features |= PREV_LUMA_ENHANCE;
+	} else if (ISP_ABS_PREV_LUMAENH & config->update)
+		isp_prev->params.features &= ~PREV_LUMA_ENHANCE;
+
+	if (ISP_ABS_PREV_INVALAW & config->flag) {
+		isppreview_enable_invalaw(isp_prev, 1);
+		isp_prev->params.features |= PREV_INVERSE_ALAW;
+	} else {
+		isppreview_enable_invalaw(isp_prev, 0);
+		isp_prev->params.features &= ~PREV_INVERSE_ALAW;
+	}
+
+	if (ISP_ABS_PREV_HRZ_MED & config->flag) {
+		if (ISP_ABS_PREV_HRZ_MED & config->update) {
+			if (copy_from_user(&prev_hmed_t,
+					   (struct ispprev_hmed *)
+					   config->prev_hmed,
+					   sizeof(struct ispprev_hmed)))
+				goto err_copy_from_user;
+			isppreview_config_hmed(isp_prev, prev_hmed_t);
+		}
+		isppreview_enable_hmed(isp_prev, 1);
+		isp_prev->params.features |= PREV_HORZ_MEDIAN_FILTER;
+	} else if (ISP_ABS_PREV_HRZ_MED & config->update) {
+		isppreview_enable_hmed(isp_prev, 0);
+		isp_prev->params.features &= ~PREV_HORZ_MEDIAN_FILTER;
+	}
+
+	if (ISP_ABS_PREV_CHROMA_SUPP & config->flag) {
+		if (ISP_ABS_PREV_CHROMA_SUPP & config->update) {
+			if (copy_from_user(&csup_t,
+					   (struct ispprev_csup *)
+					   config->csup,
+					   sizeof(struct ispprev_csup)))
+				goto err_copy_from_user;
+			isppreview_config_chroma_suppression(isp_prev, csup_t);
+		}
+		isppreview_enable_chroma_suppression(isp_prev, 1);
+		isp_prev->params.features |= PREV_CHROMA_SUPPRESS;
+	} else if (ISP_ABS_PREV_CHROMA_SUPP & config->update) {
+		isppreview_enable_chroma_suppression(isp_prev, 0);
+		isp_prev->params.features &= ~PREV_CHROMA_SUPPRESS;
+	}
+
+	if (ISP_ABS_PREV_WB & config->update) {
+		if (copy_from_user(&prev_wbal_t, (struct ispprev_wbal *)
+				   config->prev_wbal,
+				   sizeof(struct ispprev_wbal)))
+			goto err_copy_from_user;
+		isppreview_config_whitebalance(isp_prev, prev_wbal_t);
+	}
+
+	if (ISP_ABS_PREV_BLKADJ & config->update) {
+		if (copy_from_user(&prev_blkadj_t, (struct ispprev_blkadjl *)
+				   config->prev_blkadj,
+				   sizeof(struct ispprev_blkadj)))
+			goto err_copy_from_user;
+		isppreview_config_blkadj(isp_prev, prev_blkadj_t);
+	}
+
+	if (ISP_ABS_PREV_YC_LIMIT & config->update) {
+		if (copy_from_user(&yclimit_t, (struct ispprev_yclimit *)
+				   config->yclimit,
+				   sizeof(struct ispprev_yclimit)))
+			goto err_copy_from_user;
+		isppreview_config_yc_range(isp_prev, yclimit_t);
+	}
+
+	if (ISP_ABS_PREV_DEFECT_COR & config->flag) {
+		if (ISP_ABS_PREV_DEFECT_COR & config->update) {
+			if (copy_from_user(&prev_dcor_t,
+					   (struct ispprev_dcor *)
+					   config->prev_dcor,
+					   sizeof(struct ispprev_dcor)))
+				goto err_copy_from_user;
+			isppreview_config_dcor(isp_prev, prev_dcor_t);
+		}
+		isppreview_enable_dcor(isp_prev, 1);
+		isp_prev->params.features |= PREV_DEFECT_COR;
+	} else if (ISP_ABS_PREV_DEFECT_COR & config->update) {
+		isppreview_enable_dcor(isp_prev, 0);
+		isp_prev->params.features &= ~PREV_DEFECT_COR;
+	}
+
+	if (ISP_ABS_PREV_GAMMABYPASS & config->flag) {
+		isppreview_enable_gammabypass(isp_prev, 1);
+		isp_prev->params.features |= PREV_GAMMA_BYPASS;
+	} else {
+		isppreview_enable_gammabypass(isp_prev, 0);
+		isp_prev->params.features &= ~PREV_GAMMA_BYPASS;
+	}
+
+out_config_shadow:
+	if (ISP_ABS_PREV_RGB2RGB & config->update) {
+		if (copy_from_user(&isp_prev->params.rgb2rgb,
+				   (struct ispprev_rgbtorgb *)
+				   config->rgb2rgb,
+				   sizeof(struct ispprev_rgbtorgb)))
+			goto err_copy_from_user;
+		isppreview_config_rgb_blending(isp_prev,
+					       isp_prev->params.rgb2rgb);
+		/* The function call above prevents compiler from reordering
+		 * writes so that the flag below is always set after
+		 * isp_prev->params.rgb2rgb is written to. */
+		isp_prev->update_rgb_blending = 1;
+	}
+
+	if (ISP_ABS_PREV_COLOR_CONV & config->update) {
+		if (copy_from_user(&isp_prev->params.rgb2ycbcr,
+				   (struct ispprev_csc *)
+					config->prev_csc,
+				   sizeof(struct ispprev_csc)))
+			goto err_copy_from_user;
+		isppreview_config_rgb_to_ycbcr(isp_prev,
+					       isp_prev->params.rgb2ycbcr);
+		/* Same here... this flag has to be set after rgb2ycbcr
+		 * structure is written to. */
+		isp_prev->update_rgb_to_ycbcr = 1;
+	}
+
+	isp_table_update.update = config->update;
+	isp_table_update.flag = config->flag;
+	isp_table_update.prev_nf = config->prev_nf;
+	isp_table_update.red_gamma = config->red_gamma;
+	isp_table_update.green_gamma = config->green_gamma;
+	isp_table_update.blue_gamma = config->blue_gamma;
+	isp_table_update.prev_cfa = config->prev_cfa;
+
+	if (omap34xx_isp_tables_update(isp_prev, &isp_table_update))
+		goto err_copy_from_user;
+
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 0;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
+	return 0;
+
+err_copy_from_user:
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	isp_prev->shadow_update = 0;
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+
+	dev_err(isp_prev->dev, "preview: Config: Copy From User Error\n");
+	return -EFAULT;
+}
+EXPORT_SYMBOL_GPL(omap34xx_isp_preview_config);
+
+/**
+ * omap34xx_isp_tables_update - Abstraction layer Tables update.
+ * @isptables_struct: Pointer from Userspace to structure with flags and table
+ *                 data to update.
+ **/
+static int omap34xx_isp_tables_update(struct isp_prev_device *isp_prev,
+			       struct isptables_update *isptables_struct)
+{
+
+	if (ISP_ABS_TBL_NF & isptables_struct->flag) {
+		isp_prev->nf_enable = 1;
+		isp_prev->params.features |= PREV_NOISE_FILTER;
+		if (ISP_ABS_TBL_NF & isptables_struct->update) {
+			if (copy_from_user(&isp_prev->prev_nf_t,
+					   (struct ispprev_nf *)
+					   isptables_struct->prev_nf,
+					   sizeof(struct ispprev_nf)))
+				goto err_copy_from_user;
+
+			isp_prev->nf_update = 1;
+		} else
+			isp_prev->nf_update = 0;
+	} else {
+		isp_prev->nf_enable = 0;
+		isp_prev->params.features &= ~PREV_NOISE_FILTER;
+		if (ISP_ABS_TBL_NF & isptables_struct->update)
+			isp_prev->nf_update = 1;
+		else
+			isp_prev->nf_update = 0;
+	}
+
+	if (ISP_ABS_TBL_REDGAMMA & isptables_struct->update) {
+		if (copy_from_user(redgamma_table, isptables_struct->red_gamma,
+				   sizeof(redgamma_table))) {
+			goto err_copy_from_user;
+		}
+		isp_prev->rg_update = 1;
+	} else
+		isp_prev->rg_update = 0;
+
+	if (ISP_ABS_TBL_GREENGAMMA & isptables_struct->update) {
+		if (copy_from_user(greengamma_table,
+				   isptables_struct->green_gamma,
+				   sizeof(greengamma_table)))
+			goto err_copy_from_user;
+		isp_prev->gg_update = 1;
+	} else
+		isp_prev->gg_update = 0;
+
+	if (ISP_ABS_TBL_BLUEGAMMA & isptables_struct->update) {
+		if (copy_from_user(bluegamma_table,
+				   isptables_struct->blue_gamma,
+				   sizeof(bluegamma_table))) {
+			goto err_copy_from_user;
+		}
+		isp_prev->bg_update = 1;
+	} else
+		isp_prev->bg_update = 0;
+
+	if (ISP_ABS_PREV_CFA & isptables_struct->update) {
+		struct ispprev_cfa cfa;
+		if (isptables_struct->prev_cfa) {
+			if (copy_from_user(&cfa,
+					   isptables_struct->prev_cfa,
+					   sizeof(struct ispprev_cfa)))
+				goto err_copy_from_user;
+			if (cfa.cfa_table != NULL) {
+				if (copy_from_user(cfa_coef_table,
+						   cfa.cfa_table,
+						   sizeof(cfa_coef_table)))
+					goto err_copy_from_user;
+			}
+			cfa.cfa_table = cfa_coef_table;
+			isp_prev->params.cfa = cfa;
+		}
+		if (ISP_ABS_PREV_CFA & isptables_struct->flag) {
+			isp_prev->cfa_en = 1;
+			isp_prev->params.features |= PREV_CFA;
+		} else {
+			isp_prev->cfa_en = 0;
+			isp_prev->params.features &= ~PREV_CFA;
+		}
+		isp_prev->cfa_update = 1;
+	}
+
+	return 0;
+
+err_copy_from_user:
+	dev_err(isp_prev->dev, "preview tables: Copy From User Error\n");
+	return -EFAULT;
+}
+
+/**
+ * isppreview_config_shadow_registers - Program shadow registers for preview.
+ *
+ * Allows user to program shadow registers associated with preview module.
+ **/
+void isppreview_config_shadow_registers(struct isp_prev_device *isp_prev)
+{
+	u8 current_brightness_contrast;
+	int ctr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&isp_prev->lock, flags);
+	if (isp_prev->shadow_update) {
+		spin_unlock_irqrestore(&isp_prev->lock, flags);
+		return;
+	}
+
+	isppreview_query_brightness(isp_prev, &current_brightness_contrast);
+	if (current_brightness_contrast != isp_prev->brightness) {
+		DPRINTK_ISPPREV(" Changing Brightness level to %d\n",
+				isp_prev->brightness);
+		isppreview_config_brightness(isp_prev, isp_prev->brightness);
+	}
+
+	isppreview_query_contrast(isp_prev, &current_brightness_contrast);
+	if (current_brightness_contrast != isp_prev->contrast) {
+		DPRINTK_ISPPREV(" Changing Contrast level to %d\n",
+				isp_prev->contrast);
+		isppreview_config_contrast(isp_prev, isp_prev->contrast);
+	}
+	if (isp_prev->update_color_matrix) {
+		isppreview_config_rgb_to_ycbcr(isp_prev,
+					       flr_prev_csc[isp_prev->color]);
+		isp_prev->update_color_matrix = 0;
+	}
+	if (isp_prev->update_rgb_blending) {
+		isp_prev->update_rgb_blending = 0;
+		isppreview_config_rgb_blending(isp_prev,
+					       isp_prev->params.rgb2rgb);
+	}
+	if (isp_prev->update_rgb_to_ycbcr) {
+		isp_prev->update_rgb_to_ycbcr = 0;
+		isppreview_config_rgb_to_ycbcr(isp_prev,
+					       isp_prev->params.rgb2ycbcr);
+	}
+
+	if (isp_prev->gg_update) {
+		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_GREEN_G_START,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+
+		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
+			isp_reg_writel(isp_prev->dev, greengamma_table[ctr],
+				       OMAP3_ISP_IOMEM_PREV,
+				       ISPPRV_SET_TBL_DATA);
+		}
+		isp_prev->gg_update = 0;
+	}
+
+	if (isp_prev->rg_update) {
+		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_RED_G_START,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+
+		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
+			isp_reg_writel(isp_prev->dev, redgamma_table[ctr],
+				       OMAP3_ISP_IOMEM_PREV,
+				       ISPPRV_SET_TBL_DATA);
+		}
+		isp_prev->rg_update = 0;
+	}
+
+	if (isp_prev->bg_update) {
+		isp_reg_writel(isp_prev->dev, ISPPRV_TBL_ADDR_BLUE_G_START,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+
+		for (ctr = 0; ctr < ISP_GAMMA_TABLE_SIZE; ctr++) {
+			isp_reg_writel(isp_prev->dev, bluegamma_table[ctr],
+				       OMAP3_ISP_IOMEM_PREV,
+				       ISPPRV_SET_TBL_DATA);
+		}
+		isp_prev->bg_update = 0;
+	}
+
+	if (isp_prev->cfa_update) {
+		isp_prev->cfa_update = 0;
+		isppreview_config_cfa(isp_prev, &isp_prev->params.cfa);
+		isppreview_enable_cfa(isp_prev, isp_prev->cfa_en);
+	}
+
+	if (isp_prev->nf_update && isp_prev->nf_enable) {
+		isp_reg_writel(isp_prev->dev, 0xC00,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+		isp_reg_writel(isp_prev->dev, isp_prev->prev_nf_t.spread,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_NF);
+		for (ctr = 0; ctr < ISPPRV_NF_TBL_SIZE; ctr++) {
+			isp_reg_writel(isp_prev->dev,
+				       isp_prev->prev_nf_t.table[ctr],
+				       OMAP3_ISP_IOMEM_PREV,
+				       ISPPRV_SET_TBL_DATA);
+		}
+		isppreview_enable_noisefilter(isp_prev, 1);
+		isp_prev->nf_update = 0;
+	}
+
+	if (~isp_prev->nf_update && isp_prev->nf_enable)
+		isppreview_enable_noisefilter(isp_prev, 1);
+
+	if (isp_prev->nf_update && ~isp_prev->nf_enable)
+		isppreview_enable_noisefilter(isp_prev, 0);
+
+	spin_unlock_irqrestore(&isp_prev->lock, flags);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_shadow_registers);
+
+/**
+ * isppreview_request - Reserves the preview module.
+ *
+ * Returns 0 if successful, or -EBUSY if the module was already reserved.
+ **/
+int isppreview_request(struct isp_prev_device *isp_prev)
+{
+	isp_reg_or(isp_prev->dev,
+		   OMAP3_ISP_IOMEM_MAIN, ISP_CTRL, ISPCTRL_PREV_RAM_EN |
+		   ISPCTRL_PREV_CLK_EN | ISPCTRL_SBL_WR1_RAM_EN);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_request);
+
+/**
+ * isppreview_free - Frees the preview module.
+ *
+ * Returns 0 if successful, or -EINVAL if the module was already freed.
+ **/
+int isppreview_free(struct isp_prev_device *isp_prev)
+{
+	isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+			    ~(ISPCTRL_PREV_CLK_EN |
+			      ISPCTRL_PREV_RAM_EN |
+			      ISPCTRL_SBL_WR1_RAM_EN));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_free);
+
+/** isppreview_config_datapath - Specifies input and output modules for Preview
+ * @input: Indicates the module that gives the image to preview.
+ * @output: Indicates the module to which the preview outputs to.
+ *
+ * Configures the default configuration for the CCDC to work with.
+ *
+ * The valid values for the input are PRV_RAW_CCDC (0), PRV_RAW_MEM (1),
+ * PRV_RGBBAYERCFA (2), PRV_COMPCFA (3), PRV_CCDC_DRKF (4), PRV_OTHERS (5).
+ *
+ * The valid values for the output are PREVIEW_RSZ (0), PREVIEW_MEM (1).
+ *
+ * Returns 0 if successful, or -EINVAL if wrong input or output values are
+ * specified.
+ **/
+int isppreview_config_datapath(struct isp_prev_device *isp_prev,
+			       struct isp_pipeline *pipe)
+{
+	u32 pcr = 0;
+	u8 enable = 0;
+	struct prev_params *params = &isp_prev->params;
+	struct ispprev_yclimit yclimit;
+
+	pcr = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+
+	switch (pipe->prv_in) {
+	case PRV_RAW_CCDC:
+		pcr &= ~ISPPRV_PCR_SOURCE;
+		break;
+	case PRV_RAW_MEM:
+		pcr |= ISPPRV_PCR_SOURCE;
+		break;
+	case PRV_CCDC_DRKF:
+		pcr |= ISPPRV_PCR_DRKFCAP;
+		break;
+	case PRV_COMPCFA:
+		break;
+	case PRV_OTHERS:
+		break;
+	case PRV_RGBBAYERCFA:
+		break;
+	default:
+		dev_err(isp_prev->dev, "preview: Wrong Input\n");
+		return -EINVAL;
+	};
+
+	switch (pipe->prv_out) {
+	case PREVIEW_RSZ:
+		pcr |= ISPPRV_PCR_RSZPORT;
+		pcr &= ~ISPPRV_PCR_SDRPORT;
+		break;
+	case PREVIEW_MEM:
+		pcr &= ~ISPPRV_PCR_RSZPORT;
+		pcr |= ISPPRV_PCR_SDRPORT;
+		break;
+	default:
+		dev_err(isp_prev->dev, "preview: Wrong Output\n");
+		return -EINVAL;
+	}
+
+	isp_reg_writel(isp_prev->dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+
+	if (params->csup.hypf_en == 1)
+		isppreview_config_chroma_suppression(isp_prev, params->csup);
+	if (params->ytable != NULL)
+		isppreview_config_luma_enhancement(isp_prev, params->ytable);
+
+	if (params->gtable.redtable != NULL)
+		isppreview_config_gammacorrn(isp_prev, params->gtable);
+
+	isp_prev->cfa_update = 0;
+	isppreview_config_cfa(isp_prev, &params->cfa);
+	enable = (params->features & PREV_CFA) ? 1 : 0;
+	isppreview_enable_cfa(isp_prev, enable);
+
+	enable = (params->features & PREV_CHROMA_SUPPRESS) ? 1 : 0;
+	isppreview_enable_chroma_suppression(isp_prev, enable);
+
+	enable = (params->features & PREV_LUMA_ENHANCE) ? 1 : 0;
+	isppreview_enable_luma_enhancement(isp_prev, enable);
+
+	enable = (params->features & PREV_NOISE_FILTER) ? 1 : 0;
+	if (enable)
+		isppreview_config_noisefilter(isp_prev, params->nf);
+	isppreview_enable_noisefilter(isp_prev, enable);
+
+	enable = (params->features & PREV_DEFECT_COR) ? 1 : 0;
+	if (enable)
+		isppreview_config_dcor(isp_prev, params->dcor);
+	isppreview_enable_dcor(isp_prev, enable);
+
+	enable = (params->features & PREV_GAMMA_BYPASS) ? 1 : 0;
+	isppreview_enable_gammabypass(isp_prev, enable);
+
+	isppreview_config_whitebalance(isp_prev, params->wbal);
+	isppreview_config_blkadj(isp_prev, params->blk_adj);
+	isppreview_config_rgb_blending(isp_prev, params->rgb2rgb);
+	isppreview_config_rgb_to_ycbcr(isp_prev, params->rgb2ycbcr);
+
+	isppreview_config_contrast(isp_prev, params->contrast);
+	isppreview_config_brightness(isp_prev, params->brightness);
+
+	yclimit.minC = ISPPRV_YC_MIN;
+	yclimit.maxC = ISPPRV_YC_MAX;
+	yclimit.minY = ISPPRV_YC_MIN;
+	yclimit.maxY = ISPPRV_YC_MAX;
+	isppreview_config_yc_range(isp_prev, yclimit);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_config_datapath);
+
+/**
+ * isppreview_set_skip - Set the number of rows/columns that should be skipped.
+ *  h - Start Pixel Horizontal.
+ *  v - Start Line Vertical.
+ **/
+void isppreview_set_skip(struct isp_prev_device *isp_prev, u32 h, u32 v)
+{
+	isp_prev->sph = h;
+	isp_prev->slv = v;
+}
+EXPORT_SYMBOL_GPL(isppreview_set_skip);
+
+/**
+ * isppreview_config_ycpos - Configure byte layout of YUV image.
+ * @mode: Indicates the required byte layout.
+ **/
+void isppreview_config_ycpos(struct isp_prev_device *isp_prev,
+			     enum preview_ycpos_mode mode)
+{
+	u32 pcr = isp_reg_readl(isp_prev->dev,
+				OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+	pcr &= ~ISPPRV_PCR_YCPOS_CrYCbY;
+	pcr |= (mode << ISPPRV_PCR_YCPOS_SHIFT);
+	isp_reg_writel(isp_prev->dev, pcr, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_ycpos);
+
+/**
+ * isppreview_config_averager - Enable / disable / configure averager
+ * @average: Average value to be configured.
+ **/
+void isppreview_config_averager(struct isp_prev_device *isp_prev, u8 average)
+{
+	int reg = 0;
+
+	reg = AVE_ODD_PIXEL_DIST | AVE_EVEN_PIXEL_DIST | average;
+	isp_reg_writel(isp_prev->dev, reg, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_averager);
+
+/**
+ * isppreview_enable_invalaw - Enable/Disable Inverse A-Law module in Preview.
+ * @enable: 1 - Reverse the A-Law done in CCDC.
+ **/
+void isppreview_enable_invalaw(struct isp_prev_device *isp_prev, u8 enable)
+{
+	u32 pcr_val = 0;
+	pcr_val = isp_reg_readl(isp_prev->dev,
+				OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+
+	if (enable) {
+		isp_reg_writel(isp_prev->dev,
+			       pcr_val | ISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+	} else {
+		isp_reg_writel(isp_prev->dev, pcr_val &
+			       ~(ISPPRV_PCR_WIDTH | ISPPRV_PCR_INVALAW),
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_invalaw);
+
+/**
+ * isppreview_enable_drkframe - Enable/Disable of the darkframe subtract.
+ * @enable: 1 - Acquires memory bandwidth since the pixels in each frame is
+ *          subtracted with the pixels in the current frame.
+ *
+ * The proccess is applied for each captured frame.
+ **/
+void isppreview_enable_drkframe(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev,
+			   OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, ISPPRV_PCR_DRKFEN);
+	else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_DRKFEN);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_drkframe);
+
+/**
+ * isppreview_enable_shadcomp - Enables/Disables the shading compensation.
+ * @enable: 1 - Enables the shading compensation.
+ *
+ * If dark frame subtract won't be used, then enable this shading
+ * compensation.
+ **/
+void isppreview_enable_shadcomp(struct isp_prev_device *isp_prev, u8 enable)
+{
+
+	if (enable) {
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_SCOMP_EN);
+		isppreview_enable_drkframe(isp_prev, 1);
+	} else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_SCOMP_EN);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_shadcomp);
+
+/**
+ * isppreview_config_drkf_shadcomp - Configures shift value in shading comp.
+ * @scomp_shtval: 3bit value of shift used in shading compensation.
+ **/
+void isppreview_config_drkf_shadcomp(struct isp_prev_device *isp_prev,
+				     u8 scomp_shtval)
+{
+	u32 pcr_val = isp_reg_readl(isp_prev->dev,
+				    OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+
+	pcr_val &= ISPPRV_PCR_SCOMP_SFT_MASK;
+	isp_reg_writel(isp_prev->dev,
+		       pcr_val | (scomp_shtval << ISPPRV_PCR_SCOMP_SFT_SHIFT),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_drkf_shadcomp);
+
+/**
+ * isppreview_enable_hmed - Enables/Disables of the Horizontal Median Filter.
+ * @enable: 1 - Enables Horizontal Median Filter.
+ **/
+void isppreview_enable_hmed(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_HMEDEN);
+	else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_HMEDEN);
+	}
+	isp_prev->hmed_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_hmed);
+
+/**
+ * isppreview_config_hmed - Configures the Horizontal Median Filter.
+ * @prev_hmed: Structure containing the odd and even distance between the
+ *             pixels in the image along with the filter threshold.
+ **/
+void isppreview_config_hmed(struct isp_prev_device *isp_prev,
+			    struct ispprev_hmed prev_hmed)
+{
+
+	u32 odddist = 0;
+	u32 evendist = 0;
+
+	if (prev_hmed.odddist == 1)
+		odddist = ~ISPPRV_HMED_ODDDIST;
+	else
+		odddist = ISPPRV_HMED_ODDDIST;
+
+	if (prev_hmed.evendist == 1)
+		evendist = ~ISPPRV_HMED_EVENDIST;
+	else
+		evendist = ISPPRV_HMED_EVENDIST;
+
+	isp_reg_writel(isp_prev->dev, odddist | evendist | (prev_hmed.thres <<
+					     ISPPRV_HMED_THRESHOLD_SHIFT),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_HMED);
+
+}
+EXPORT_SYMBOL_GPL(isppreview_config_hmed);
+
+/**
+ * isppreview_config_noisefilter - Configures the Noise Filter.
+ * @prev_nf: Structure containing the noisefilter table, strength to be used
+ *           for the noise filter and the defect correction enable flag.
+ **/
+void isppreview_config_noisefilter(struct isp_prev_device *isp_prev,
+				   struct ispprev_nf prev_nf)
+{
+	int i = 0;
+
+	isp_reg_writel(isp_prev->dev, prev_nf.spread, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_NF);
+	isp_reg_writel(isp_prev->dev, ISPPRV_NF_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+	for (i = 0; i < ISPPRV_NF_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, prev_nf.table[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_config_noisefilter);
+
+/**
+ * isppreview_config_dcor - Configures the defect correction
+ * @prev_nf: Structure containing the defect correction structure
+ **/
+void isppreview_config_dcor(struct isp_prev_device *isp_prev,
+			    struct ispprev_dcor prev_dcor)
+{
+	if (prev_dcor.couplet_mode_en) {
+		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[0],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0);
+		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[1],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1);
+		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[2],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2);
+		isp_reg_writel(isp_prev->dev, prev_dcor.detect_correct[3],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3);
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_DCCOUP);
+	} else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_DCCOUP);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_config_dcor);
+
+/**
+ * isppreview_config_cfa - Configures the CFA Interpolation parameters.
+ * @prev_cfa: Structure containing the CFA interpolation table, CFA format
+ *            in the image, vertical and horizontal gradient threshold.
+ **/
+void isppreview_config_cfa(struct isp_prev_device *isp_prev,
+			   struct ispprev_cfa *prev_cfa)
+{
+	int i = 0;
+
+	isp_prev->cfafmt = prev_cfa->cfafmt;
+
+	isp_reg_and_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		       ~ISPPRV_PCR_CFAFMT_MASK,
+		       (prev_cfa->cfafmt << ISPPRV_PCR_CFAFMT_SHIFT));
+
+	isp_reg_writel(isp_prev->dev,
+		(prev_cfa->cfa_gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |
+		(prev_cfa->cfa_gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),
+		OMAP3_ISP_IOMEM_PREV, ISPPRV_CFA);
+
+	isp_reg_writel(isp_prev->dev, ISPPRV_CFA_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+
+	for (i = 0; i < ISPPRV_CFA_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, prev_cfa->cfa_table[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_config_cfa);
+
+/**
+ * isppreview_config_gammacorrn - Configures the Gamma Correction table values
+ * @gtable: Structure containing the table for red, blue, green gamma table.
+ **/
+void isppreview_config_gammacorrn(struct isp_prev_device *isp_prev,
+				  struct ispprev_gtable gtable)
+{
+	int i = 0;
+
+	isp_reg_writel(isp_prev->dev, ISPPRV_REDGAMMA_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, gtable.redtable[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+
+	isp_reg_writel(isp_prev->dev, ISPPRV_GREENGAMMA_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, gtable.greentable[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+
+	isp_reg_writel(isp_prev->dev, ISPPRV_BLUEGAMMA_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+	for (i = 0; i < ISPPRV_GAMMA_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, gtable.bluetable[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_config_gammacorrn);
+
+/**
+ * isppreview_set_luma_enhancement - Stores the Luminance Enhancement table.
+ * @ytable: Structure containing the table for Luminance Enhancement table.
+ **/
+void isppreview_set_luma_enhancement(struct isp_prev_device *isp_prev,
+				     u32 *ytable)
+{
+	int i;
+
+	for (i = 0; i < ISPPRV_YENH_TBL_SIZE; i++)
+		isp_prev->params.ytable[i] = ytable[i];
+}
+EXPORT_SYMBOL_GPL(isppreview_set_luma_enhancement);
+
+/**
+ * isppreview_config_luma_enhancement - Writes the Luminance Enhancement table.
+ * @ytable: Structure containing the table for Luminance Enhancement table.
+ **/
+void isppreview_config_luma_enhancement(struct isp_prev_device *isp_prev,
+					u32 *ytable)
+{
+	int i = 0;
+
+	isp_reg_writel(isp_prev->dev, ISPPRV_YENH_TABLE_ADDR,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);
+	for (i = 0; i < ISPPRV_YENH_TBL_SIZE; i++) {
+		isp_reg_writel(isp_prev->dev, ytable[i],
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_config_luma_enhancement);
+
+/**
+ * isppreview_config_chroma_suppression - Configures the Chroma Suppression.
+ * @csup: Structure containing the threshold value for suppression
+ *        and the hypass filter enable flag.
+ **/
+void isppreview_config_chroma_suppression(struct isp_prev_device *isp_prev,
+					  struct ispprev_csup csup)
+{
+	isp_reg_writel(isp_prev->dev,
+		       csup.gain | (csup.thres << ISPPRV_CSUP_THRES_SHIFT) |
+		       (csup.hypf_en << ISPPRV_CSUP_HPYF_SHIFT),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_chroma_suppression);
+
+/**
+ * isppreview_enable_noisefilter - Enables/Disables the Noise Filter.
+ * @enable: 1 - Enables the Noise Filter.
+ **/
+void isppreview_enable_noisefilter(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_NFEN);
+	else
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_NFEN);
+	isp_prev->nf_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_noisefilter);
+
+/**
+ * isppreview_enable_dcor - Enables/Disables the defect correction.
+ * @enable: 1 - Enables the defect correction.
+ **/
+void isppreview_enable_dcor(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_DCOREN);
+	else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_DCOREN);
+	}
+	isp_prev->dcor_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_dcor);
+
+/**
+ * isppreview_enable_cfa - Enable/Disable the CFA Interpolation.
+ * @enable: 1 - Enables the CFA.
+ **/
+void isppreview_enable_cfa(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_CFAEN);
+	else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_CFAEN);
+	}
+	isp_prev->cfa_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_cfa);
+
+/**
+ * isppreview_enable_gammabypass - Enables/Disables the GammaByPass
+ * @enable: 1 - Bypasses Gamma - 10bit input is cropped to 8MSB.
+ *          0 - Goes through Gamma Correction. input and output is 10bit.
+ **/
+void isppreview_enable_gammabypass(struct isp_prev_device *isp_prev, u8 enable)
+{
+	if (enable) {
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_GAMMA_BYPASS);
+	} else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_GAMMA_BYPASS);
+	}
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_gammabypass);
+
+/**
+ * isppreview_enable_luma_enhancement - Enables/Disables Luminance Enhancement
+ * @enable: 1 - Enable the Luminance Enhancement.
+ **/
+void isppreview_enable_luma_enhancement(struct isp_prev_device *isp_prev,
+					u8 enable)
+{
+	if (enable) {
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_YNENHEN);
+	} else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_YNENHEN);
+	}
+	isp_prev->yenh_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_luma_enhancement);
+
+/**
+ * isppreview_enable_chroma_suppression - Enables/Disables Chrominance Suppr.
+ * @enable: 1 - Enable the Chrominance Suppression.
+ **/
+void isppreview_enable_chroma_suppression(struct isp_prev_device *isp_prev,
+					  u8 enable)
+{
+	if (enable)
+		isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			   ISPPRV_PCR_SUPEN);
+	else {
+		isp_reg_and(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+			    ~ISPPRV_PCR_SUPEN);
+	}
+	isp_prev->csup_en = enable ? 1 : 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_enable_chroma_suppression);
+
+/**
+ * isppreview_config_whitebalance - Configures the White Balance parameters.
+ * @prev_wbal: Structure containing the digital gain and white balance
+ *             coefficient.
+ *
+ * Coefficient matrix always with default values.
+ **/
+void isppreview_config_whitebalance(struct isp_prev_device *isp_prev,
+				    struct ispprev_wbal prev_wbal)
+{
+	u32 val;
+
+	isp_reg_writel(isp_prev->dev, prev_wbal.dgain, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_WB_DGAIN);
+
+	val = prev_wbal.coef0 << ISPPRV_WBGAIN_COEF0_SHIFT;
+	val |= prev_wbal.coef1 << ISPPRV_WBGAIN_COEF1_SHIFT;
+	val |= prev_wbal.coef2 << ISPPRV_WBGAIN_COEF2_SHIFT;
+	val |= prev_wbal.coef3 << ISPPRV_WBGAIN_COEF3_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_WBGAIN);
+
+	isp_reg_writel(isp_prev->dev,
+		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_0_SHIFT |
+		       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_1_SHIFT |
+		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_2_SHIFT |
+		       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_3_SHIFT |
+		       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_0_SHIFT |
+		       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_1_SHIFT |
+		       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_2_SHIFT |
+		       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_3_SHIFT |
+		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_0_SHIFT |
+		       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_1_SHIFT |
+		       ISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_2_SHIFT |
+		       ISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_3_SHIFT |
+		       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_0_SHIFT |
+		       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_1_SHIFT |
+		       ISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_2_SHIFT |
+		       ISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_3_SHIFT,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_whitebalance);
+
+/**
+ * isppreview_config_whitebalance2 - Configures the White Balance parameters.
+ * @prev_wbal: Structure containing the digital gain and white balance
+ *             coefficient.
+ *
+ * Coefficient matrix can be changed.
+ **/
+void isppreview_config_whitebalance2(struct isp_prev_device *isp_prev,
+				     struct prev_white_balance prev_wbal)
+{
+	isp_reg_writel(isp_prev->dev, prev_wbal.wb_dgain,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN);
+	isp_reg_writel(isp_prev->dev, prev_wbal.wb_gain[0] |
+		       prev_wbal.wb_gain[1] << ISPPRV_WBGAIN_COEF1_SHIFT |
+		       prev_wbal.wb_gain[2] << ISPPRV_WBGAIN_COEF2_SHIFT |
+		       prev_wbal.wb_gain[3] << ISPPRV_WBGAIN_COEF3_SHIFT,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN);
+
+	isp_reg_writel(isp_prev->dev,
+		prev_wbal.wb_coefmatrix[0][0] << ISPPRV_WBSEL_N0_0_SHIFT |
+		prev_wbal.wb_coefmatrix[0][1] << ISPPRV_WBSEL_N0_1_SHIFT |
+		prev_wbal.wb_coefmatrix[0][2] << ISPPRV_WBSEL_N0_2_SHIFT |
+		prev_wbal.wb_coefmatrix[0][3] << ISPPRV_WBSEL_N0_3_SHIFT |
+		prev_wbal.wb_coefmatrix[1][0] << ISPPRV_WBSEL_N1_0_SHIFT |
+		prev_wbal.wb_coefmatrix[1][1] << ISPPRV_WBSEL_N1_1_SHIFT |
+		prev_wbal.wb_coefmatrix[1][2] << ISPPRV_WBSEL_N1_2_SHIFT |
+		prev_wbal.wb_coefmatrix[1][3] << ISPPRV_WBSEL_N1_3_SHIFT |
+		prev_wbal.wb_coefmatrix[2][0] << ISPPRV_WBSEL_N2_0_SHIFT |
+		prev_wbal.wb_coefmatrix[2][1] << ISPPRV_WBSEL_N2_1_SHIFT |
+		prev_wbal.wb_coefmatrix[2][2] << ISPPRV_WBSEL_N2_2_SHIFT |
+		prev_wbal.wb_coefmatrix[2][3] << ISPPRV_WBSEL_N2_3_SHIFT |
+		prev_wbal.wb_coefmatrix[3][0] << ISPPRV_WBSEL_N3_0_SHIFT |
+		prev_wbal.wb_coefmatrix[3][1] << ISPPRV_WBSEL_N3_1_SHIFT |
+		prev_wbal.wb_coefmatrix[3][2] << ISPPRV_WBSEL_N3_2_SHIFT |
+		prev_wbal.wb_coefmatrix[3][3] << ISPPRV_WBSEL_N3_3_SHIFT,
+		OMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_whitebalance2);
+
+/**
+ * isppreview_config_blkadj - Configures the Black Adjustment parameters.
+ * @prev_blkadj: Structure containing the black adjustment towards red, green,
+ *               blue.
+ **/
+void isppreview_config_blkadj(struct isp_prev_device *isp_prev,
+			      struct ispprev_blkadj prev_blkadj)
+{
+	isp_reg_writel(isp_prev->dev, prev_blkadj.blue |
+		       (prev_blkadj.green << ISPPRV_BLKADJOFF_G_SHIFT) |
+		       (prev_blkadj.red << ISPPRV_BLKADJOFF_R_SHIFT),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_blkadj);
+
+/**
+ * isppreview_config_rgb_blending - Configures the RGB-RGB Blending matrix.
+ * @rgb2rgb: Structure containing the rgb to rgb blending matrix and the rgb
+ *           offset.
+ **/
+void isppreview_config_rgb_blending(struct isp_prev_device *isp_prev,
+				    struct ispprev_rgbtorgb rgb2rgb)
+{
+	u32 val = 0;
+
+	val = (rgb2rgb.matrix[0][0] & 0xfff) << ISPPRV_RGB_MAT1_MTX_RR_SHIFT;
+	val |= (rgb2rgb.matrix[0][1] & 0xfff) << ISPPRV_RGB_MAT1_MTX_GR_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_MAT1);
+
+	val = (rgb2rgb.matrix[0][2] & 0xfff) << ISPPRV_RGB_MAT2_MTX_BR_SHIFT;
+	val |= (rgb2rgb.matrix[1][0] & 0xfff) << ISPPRV_RGB_MAT2_MTX_RG_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_MAT2);
+
+	val = (rgb2rgb.matrix[1][1] & 0xfff) << ISPPRV_RGB_MAT3_MTX_GG_SHIFT;
+	val |= (rgb2rgb.matrix[1][2] & 0xfff) << ISPPRV_RGB_MAT3_MTX_BG_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_MAT3);
+
+	val = (rgb2rgb.matrix[2][0] & 0xfff) << ISPPRV_RGB_MAT4_MTX_RB_SHIFT;
+	val |= (rgb2rgb.matrix[2][1] & 0xfff) << ISPPRV_RGB_MAT4_MTX_GB_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_MAT4);
+
+	val = (rgb2rgb.matrix[2][2] & 0xfff) << ISPPRV_RGB_MAT5_MTX_BB_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_MAT5);
+
+	val = (rgb2rgb.offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;
+	val |= (rgb2rgb.offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_OFF1);
+
+	val = (rgb2rgb.offset[2] & 0x3ff) << ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_RGB_OFF2);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_rgb_blending);
+
+/**
+ * Configures the RGB-YCbYCr conversion matrix
+ * @prev_csc: Structure containing the RGB to YCbYCr matrix and the
+ *            YCbCr offset.
+ **/
+void isppreview_config_rgb_to_ycbcr(struct isp_prev_device *isp_prev,
+				    struct ispprev_csc prev_csc)
+{
+	u32 val = 0;
+
+	val = (prev_csc.matrix[0][0] & 0x3ff) << ISPPRV_CSC0_RY_SHIFT;
+	val |= (prev_csc.matrix[0][1] & 0x3ff) << ISPPRV_CSC0_GY_SHIFT;
+	val |= (prev_csc.matrix[0][2] & 0x3ff) << ISPPRV_CSC0_BY_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);
+
+	val = (prev_csc.matrix[1][0] & 0x3ff) << ISPPRV_CSC1_RCB_SHIFT;
+	val |= (prev_csc.matrix[1][1] & 0x3ff) << ISPPRV_CSC1_GCB_SHIFT;
+	val |= (prev_csc.matrix[1][2] & 0x3ff) << ISPPRV_CSC1_BCB_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);
+
+	val = (prev_csc.matrix[2][0] & 0x3ff) << ISPPRV_CSC2_RCR_SHIFT;
+	val |= (prev_csc.matrix[2][1] & 0x3ff) << ISPPRV_CSC2_GCR_SHIFT;
+	val |= (prev_csc.matrix[2][2] & 0x3ff) << ISPPRV_CSC2_BCR_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);
+
+	val = (prev_csc.offset[0] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;
+	val |= (prev_csc.offset[1] & 0xff) << ISPPRV_CSC_OFFSET_CB_SHIFT;
+	val |= (prev_csc.offset[2] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;
+	isp_reg_writel(isp_prev->dev, val, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_CSC_OFFSET);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_rgb_to_ycbcr);
+
+/**
+ * isppreview_query_contrast - Query the contrast.
+ * @contrast: Pointer to hold the current programmed contrast value.
+ **/
+void isppreview_query_contrast(struct isp_prev_device *isp_prev, u8 *contrast)
+{
+	u32 brt_cnt_val = 0;
+
+	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				    ISPPRV_CNT_BRT);
+	*contrast = (brt_cnt_val >> ISPPRV_CNT_BRT_CNT_SHIFT) & 0xff;
+	DPRINTK_ISPPREV(" Current brt cnt value in hw is %x\n", brt_cnt_val);
+}
+EXPORT_SYMBOL_GPL(isppreview_query_contrast);
+
+/**
+ * isppreview_update_contrast - Updates the contrast.
+ * @contrast: Pointer to hold the current programmed contrast value.
+ *
+ * Value should be programmed before enabling the module.
+ **/
+void isppreview_update_contrast(struct isp_prev_device *isp_prev, u8 *contrast)
+{
+	isp_prev->contrast = *contrast;
+}
+EXPORT_SYMBOL_GPL(isppreview_update_contrast);
+
+/**
+ * isppreview_config_contrast - Configures the Contrast.
+ * @contrast: 8 bit value in U8Q4 format.
+ *
+ * Value should be programmed before enabling the module.
+ **/
+void isppreview_config_contrast(struct isp_prev_device *isp_prev, u8 contrast)
+{
+	u32 brt_cnt_val = 0;
+
+	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				    ISPPRV_CNT_BRT);
+	brt_cnt_val &= ~(0xff << ISPPRV_CNT_BRT_CNT_SHIFT);
+	contrast &= 0xff;
+	isp_reg_writel(isp_prev->dev,
+		       brt_cnt_val | contrast << ISPPRV_CNT_BRT_CNT_SHIFT,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_contrast);
+
+/**
+ * isppreview_get_contrast_range - Gets the range contrast value.
+ * @min_contrast: Pointer to hold the minimum Contrast value.
+ * @max_contrast: Pointer to hold the maximum Contrast value.
+ **/
+void isppreview_get_contrast_range(u8 *min_contrast, u8 *max_contrast)
+{
+	*min_contrast = ISPPRV_CONTRAST_MIN;
+	*max_contrast = ISPPRV_CONTRAST_MAX;
+}
+EXPORT_SYMBOL_GPL(isppreview_get_contrast_range);
+
+/**
+ * isppreview_update_brightness - Updates the brightness in preview module.
+ * @brightness: Pointer to hold the current programmed brightness value.
+ *
+ **/
+void isppreview_update_brightness(struct isp_prev_device *isp_prev,
+				  u8 *brightness)
+{
+	isp_prev->brightness = *brightness;
+}
+EXPORT_SYMBOL_GPL(isppreview_update_brightness);
+
+/**
+ * isppreview_config_brightness - Configures the brightness.
+ * @contrast: 8bitvalue in U8Q0 format.
+ **/
+void isppreview_config_brightness(struct isp_prev_device *isp_prev,
+				  u8 brightness)
+{
+	u32 brt_cnt_val = 0;
+
+	DPRINTK_ISPPREV("\tConfiguring brightness in ISP: %d\n", brightness);
+	brt_cnt_val = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				    ISPPRV_CNT_BRT);
+	brt_cnt_val &= ~(0xff << ISPPRV_CNT_BRT_BRT_SHIFT);
+	brightness &= 0xff;
+	isp_reg_writel(isp_prev->dev,
+		       brt_cnt_val | brightness << ISPPRV_CNT_BRT_BRT_SHIFT,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_brightness);
+
+/**
+ * isppreview_query_brightness - Query the brightness.
+ * @brightness: Pointer to hold the current programmed brightness value.
+ **/
+void isppreview_query_brightness(struct isp_prev_device *isp_prev,
+				 u8 *brightness)
+{
+	*brightness = isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				    ISPPRV_CNT_BRT);
+}
+EXPORT_SYMBOL_GPL(isppreview_query_brightness);
+
+/**
+ * isppreview_get_brightness_range - Gets the range brightness value
+ * @min_brightness: Pointer to hold the minimum brightness value
+ * @max_brightness: Pointer to hold the maximum brightness value
+ **/
+void isppreview_get_brightness_range(u8 *min_brightness, u8 *max_brightness)
+{
+	*min_brightness = ISPPRV_BRIGHT_MIN;
+	*max_brightness = ISPPRV_BRIGHT_MAX;
+}
+EXPORT_SYMBOL_GPL(isppreview_get_brightness_range);
+
+/**
+ * isppreview_set_color - Sets the color effect.
+ * @mode: Indicates the required color effect.
+ **/
+void isppreview_set_color(struct isp_prev_device *isp_prev, u8 *mode)
+{
+	isp_prev->color = *mode;
+	isp_prev->update_color_matrix = 1;
+}
+EXPORT_SYMBOL_GPL(isppreview_set_color);
+
+/**
+ * isppreview_get_color - Gets the current color effect.
+ * @mode: Indicates the current color effect.
+ **/
+void isppreview_get_color(struct isp_prev_device *isp_prev, u8 *mode)
+{
+	*mode = isp_prev->color;
+}
+EXPORT_SYMBOL_GPL(isppreview_get_color);
+
+/**
+ * isppreview_config_yc_range - Configures the max and min Y and C values.
+ * @yclimit: Structure containing the range of Y and C values.
+ **/
+void isppreview_config_yc_range(struct isp_prev_device *isp_prev,
+				struct ispprev_yclimit yclimit)
+{
+	isp_reg_writel(isp_prev->dev,
+		       yclimit.maxC << ISPPRV_SETUP_YC_MAXC_SHIFT |
+		       yclimit.maxY << ISPPRV_SETUP_YC_MAXY_SHIFT |
+		       yclimit.minC << ISPPRV_SETUP_YC_MINC_SHIFT |
+		       yclimit.minY << ISPPRV_SETUP_YC_MINY_SHIFT,
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_SETUP_YC);
+}
+EXPORT_SYMBOL_GPL(isppreview_config_yc_range);
+
+/**
+ * isppreview_try_size - Calculates output dimensions with the modules enabled.
+ * @input_w: input width for the preview in number of pixels per line
+ * @input_h: input height for the preview in number of lines
+ * @output_w: output width from the preview in number of pixels per line
+ * @output_h: output height for the preview in number of lines
+ *
+ * Calculates the number of pixels cropped in the submodules that are enabled,
+ * Fills up the output width height variables in the isp_prev structure.
+ **/
+int isppreview_try_pipeline(struct isp_prev_device *isp_prev,
+			    struct isp_pipeline *pipe)
+{
+	u32 div = 0;
+	int max_out;
+
+	if (pipe->ccdc_out_w_img < 32 || pipe->ccdc_out_h < 32) {
+		dev_err(isp_prev->dev, "preview does not support "
+		       "width < 16 or height < 32\n");
+		return -EINVAL;
+	}
+	if (!cpu_is_omap3630() && cpu_is_omap34xx() && omap_rev_is_1_0())
+		max_out = ISPPRV_MAXOUTPUT_WIDTH;
+	else
+		max_out = ISPPRV_MAXOUTPUT_WIDTH_ES2;
+
+	pipe->prv_out_w = pipe->ccdc_out_w;
+	pipe->prv_out_h = pipe->ccdc_out_h;
+	pipe->prv_out_w_img = pipe->ccdc_out_w_img;
+	pipe->prv_out_h_img = pipe->ccdc_out_h;
+
+	isp_prev->fmtavg = 0;
+
+	if (pipe->ccdc_out_w_img > max_out) {
+		div = (pipe->ccdc_out_w_img/max_out);
+		if (div >= 2 && div < 4) {
+			isp_prev->fmtavg = 1;
+			pipe->prv_out_w_img /= 2;
+		} else if (div >= 4 && div < 8) {
+			isp_prev->fmtavg = 2;
+			pipe->prv_out_w_img /= 4;
+		} else if (div >= 8) {
+			isp_prev->fmtavg = 3;
+			pipe->prv_out_w_img /= 8;
+		}
+	}
+
+/*	if (isp_prev->hmed_en) */
+	pipe->prv_out_w_img -= 4;
+/*	if (isp_prev->nf_en) */
+	pipe->prv_out_w_img -= 4;
+	pipe->prv_out_h_img -= 4;
+/*	if (isp_prev->cfa_en) */
+	switch (isp_prev->cfafmt) {
+	case CFAFMT_BAYER:
+	case CFAFMT_SONYVGA:
+		pipe->prv_out_w_img -= 4;
+		pipe->prv_out_h_img -= 4;
+		break;
+	case CFAFMT_RGBFOVEON:
+	case CFAFMT_RRGGBBFOVEON:
+	case CFAFMT_DNSPL:
+	case CFAFMT_HONEYCOMB:
+		pipe->prv_out_h_img -= 2;
+		break;
+	};
+/*	if (isp_prev->yenh_en || isp_prev->csup_en) */
+	pipe->prv_out_w_img -= 2;
+
+	/* Start at the correct row/column by skipping
+	 * a Sensor specific amount.
+	 */
+	pipe->prv_out_w_img -= isp_prev->sph;
+	pipe->prv_out_h_img -= isp_prev->slv;
+
+	if (pipe->prv_out_w_img % 2)
+		pipe->prv_out_w_img -= 1;
+
+	/* FIXME: This doesn't apply for prv -> rsz. */
+	pipe->prv_out_w = ALIGN(pipe->prv_out_w_img, 0x20);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_try_pipeline);
+
+/**
+ * isppreview_config_size - Sets the size of ISP preview output.
+ * @pipe->ccdc_out_w: input width for the preview in number of pixels per line
+ * @pipe->ccdc_out_h: input height for the preview in number of lines
+ * @output_w: output width from the preview in number of pixels per line
+ * @output_h: output height for the preview in number of lines
+ *
+ * Configures the appropriate values stored in the isp_prev structure to
+ * HORZ/VERT_INFO. Configures PRV_AVE if needed for downsampling as calculated
+ * in trysize.
+ **/
+int isppreview_s_pipeline(struct isp_prev_device *isp_prev,
+			  struct isp_pipeline *pipe)
+{
+	u32 prevsdroff;
+	int rval;
+
+	rval = isppreview_config_datapath(isp_prev, pipe);
+	if (rval)
+		return rval;
+
+	isp_reg_writel(isp_prev->dev,
+		       (isp_prev->sph << ISPPRV_HORZ_INFO_SPH_SHIFT) |
+		       (pipe->ccdc_out_w - 1),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO);
+	isp_reg_writel(isp_prev->dev,
+		       (isp_prev->slv << ISPPRV_VERT_INFO_SLV_SHIFT) |
+		       (pipe->ccdc_out_h - 2),
+		       OMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO);
+
+	if (isp_prev->cfafmt == CFAFMT_BAYER)
+		isp_reg_writel(isp_prev->dev, ISPPRV_AVE_EVENDIST_2 <<
+			       ISPPRV_AVE_EVENDIST_SHIFT |
+			       ISPPRV_AVE_ODDDIST_2 <<
+			       ISPPRV_AVE_ODDDIST_SHIFT |
+			       isp_prev->fmtavg,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);
+
+	if (pipe->prv_out == PREVIEW_MEM) {
+		prevsdroff = pipe->prv_out_w * ISP_BYTES_PER_PIXEL;
+		if ((prevsdroff & ISP_32B_BOUNDARY_OFFSET) != prevsdroff) {
+			DPRINTK_ISPPREV("ISP_WARN: Preview output buffer line"
+					" size is truncated"
+					" to 32byte boundary\n");
+			prevsdroff &= ISP_32B_BOUNDARY_BUF ;
+		}
+		isppreview_config_outlineoffset(isp_prev, prevsdroff);
+	}
+
+	if (pipe->pix.pixelformat == V4L2_PIX_FMT_UYVY)
+		isppreview_config_ycpos(isp_prev, YCPOS_YCrYCb);
+	else
+		isppreview_config_ycpos(isp_prev, YCPOS_CrYCbY);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_s_pipeline);
+
+/**
+ * isppreview_config_inlineoffset - Configures the Read address line offset.
+ * @offset: Line Offset for the input image.
+ **/
+int isppreview_config_inlineoffset(struct isp_prev_device *isp_prev, u32 offset)
+{
+	if ((offset & ISP_32B_BOUNDARY_OFFSET) == offset) {
+		isp_reg_writel(isp_prev->dev, offset & 0xffff,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_RADR_OFFSET);
+	} else {
+		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_config_inlineoffset);
+
+/**
+ * isppreview_set_inaddr - Sets memory address of input frame.
+ * @addr: 32bit memory address aligned on 32byte boundary.
+ *
+ * Configures the memory address from which the input frame is to be read.
+ **/
+int isppreview_set_inaddr(struct isp_prev_device *isp_prev, u32 addr)
+{
+	if ((addr & ISP_32B_BOUNDARY_BUF) == addr)
+		isp_reg_writel(isp_prev->dev, addr,
+			       OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR);
+	else {
+		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_set_inaddr);
+
+/**
+ * isppreview_config_outlineoffset - Configures the Write address line offset.
+ * @offset: Line Offset for the preview output.
+ **/
+int isppreview_config_outlineoffset(struct isp_prev_device *isp_prev,
+				    u32 offset)
+{
+	if ((offset & ISP_32B_BOUNDARY_OFFSET) != offset) {
+		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(isp_prev->dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_WADD_OFFSET);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_config_outlineoffset);
+
+/**
+ * isppreview_set_outaddr - Sets the memory address to store output frame
+ * @addr: 32bit memory address aligned on 32byte boundary.
+ *
+ * Configures the memory address to which the output frame is written.
+ **/
+int isppreview_set_outaddr(struct isp_prev_device *isp_prev, u32 addr)
+{
+	if ((addr & ISP_32B_BOUNDARY_BUF) != addr) {
+		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(isp_prev->dev, addr, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_WSDR_ADDR);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_set_outaddr);
+
+/**
+ * isppreview_config_darklineoffset - Sets the Dark frame address line offset.
+ * @offset: Line Offset for the Darkframe.
+ **/
+int isppreview_config_darklineoffset(struct isp_prev_device *isp_prev,
+				     u32 offset)
+{
+	if ((offset & ISP_32B_BOUNDARY_OFFSET) != offset) {
+		dev_err(isp_prev->dev, "preview: Offset should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(isp_prev->dev, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_DRKF_OFFSET);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_config_darklineoffset);
+
+/**
+ * isppreview_set_darkaddr - Sets the memory address to store Dark frame.
+ * @addr: 32bit memory address aligned on 32 bit boundary.
+ **/
+int isppreview_set_darkaddr(struct isp_prev_device *isp_prev, u32 addr)
+{
+	if ((addr & ISP_32B_BOUNDARY_BUF) != addr) {
+		dev_err(isp_prev->dev, "preview: Address should be in 32 byte "
+		       "boundary\n");
+		return -EINVAL;
+	}
+	isp_reg_writel(isp_prev->dev, addr, OMAP3_ISP_IOMEM_PREV,
+		       ISPPRV_DSDR_ADDR);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(isppreview_set_darkaddr);
+
+/**
+ * isppreview_enable - Enables the Preview module.
+ * @enable: 1 - Enables the preview module.
+ *
+ * Client should configure all the sub modules in Preview before this.
+ **/
+void isppreview_enable(struct isp_prev_device *isp_prev)
+{
+	isp_reg_or(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,
+		   ISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT);
+}
+EXPORT_SYMBOL_GPL(isppreview_enable);
+
+/**
+ * isppreview_busy - Gets busy state of preview module.
+ **/
+int isppreview_busy(struct isp_prev_device *isp_prev)
+{
+	return isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)
+		& ISPPRV_PCR_BUSY;
+}
+EXPORT_SYMBOL_GPL(isppreview_busy);
+
+/**
+ * isppreview_save_context - Saves the values of the preview module registers.
+ **/
+void isppreview_save_context(struct device *dev)
+{
+	DPRINTK_ISPPREV("Saving context\n");
+	isp_save_context(dev, ispprev_reg_list);
+}
+EXPORT_SYMBOL_GPL(isppreview_save_context);
+
+/**
+ * isppreview_restore_context - Restores the values of preview module registers
+ **/
+void isppreview_restore_context(struct device *dev)
+{
+	DPRINTK_ISPPREV("Restoring context\n");
+	isp_restore_context(dev, ispprev_reg_list);
+}
+EXPORT_SYMBOL_GPL(isppreview_restore_context);
+
+/**
+ * isppreview_print_status - Prints the values of the Preview Module registers.
+ *
+ * Also prints other debug information stored in the preview moduel.
+ **/
+void isppreview_print_status(struct isp_prev_device *isp_prev,
+			     struct isp_pipeline *pipe)
+{
+	DPRINTK_ISPPREV("Preview Input format =%d, Output Format =%d\n",
+			pipe->prv_inp, pipe->prv_out);
+	DPRINTK_ISPPREV("Accepted Preview Input (width = %d,Height = %d)\n",
+			isp_prev->previn_w,
+			isp_prev->previn_h);
+	DPRINTK_ISPPREV("Accepted Preview Output (width = %d,Height = %d)\n",
+			isp_prev->prevout_w,
+			isp_prev->prevout_h);
+	DPRINTK_ISPPREV("###ISP_CTRL in preview =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_CTRL));
+	DPRINTK_ISPPREV("###ISP_IRQ0ENABLE in preview =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0ENABLE));
+	DPRINTK_ISPPREV("###ISP_IRQ0STATUS in preview =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_MAIN,
+				      ISP_IRQ0STATUS));
+	DPRINTK_ISPPREV("###PRV PCR =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_PCR));
+	DPRINTK_ISPPREV("###PRV HORZ_INFO =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_HORZ_INFO));
+	DPRINTK_ISPPREV("###PRV VERT_INFO =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_VERT_INFO));
+	DPRINTK_ISPPREV("###PRV WSDR_ADDR =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WSDR_ADDR));
+	DPRINTK_ISPPREV("###PRV WADD_OFFSET =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WADD_OFFSET));
+	DPRINTK_ISPPREV("###PRV AVE =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_AVE));
+	DPRINTK_ISPPREV("###PRV HMED =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_HMED));
+	DPRINTK_ISPPREV("###PRV NF =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_NF));
+	DPRINTK_ISPPREV("###PRV WB_DGAIN =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WB_DGAIN));
+	DPRINTK_ISPPREV("###PRV WBGAIN =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WBGAIN));
+	DPRINTK_ISPPREV("###PRV WBSEL =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WBSEL));
+	DPRINTK_ISPPREV("###PRV CFA =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CFA));
+	DPRINTK_ISPPREV("###PRV BLKADJOFF =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_BLKADJOFF));
+	DPRINTK_ISPPREV("###PRV RGB_MAT1 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_MAT1));
+	DPRINTK_ISPPREV("###PRV RGB_MAT2 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_MAT2));
+	DPRINTK_ISPPREV("###PRV RGB_MAT3 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_MAT3));
+	DPRINTK_ISPPREV("###PRV RGB_MAT4 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_MAT4));
+	DPRINTK_ISPPREV("###PRV RGB_MAT5 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_MAT5));
+	DPRINTK_ISPPREV("###PRV RGB_OFF1 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_OFF1));
+	DPRINTK_ISPPREV("###PRV RGB_OFF2 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_RGB_OFF2));
+	DPRINTK_ISPPREV("###PRV CSC0 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CSC0));
+	DPRINTK_ISPPREV("###PRV CSC1 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CSC1));
+	DPRINTK_ISPPREV("###PRV CSC2 =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CSC2));
+	DPRINTK_ISPPREV("###PRV CSC_OFFSET =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CSC_OFFSET));
+	DPRINTK_ISPPREV("###PRV CNT_BRT =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CNT_BRT));
+	DPRINTK_ISPPREV("###PRV CSUP =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_CSUP));
+	DPRINTK_ISPPREV("###PRV SETUP_YC =0x%x\n",
+			isp_reg_readl(isp_prev->dev, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_SETUP_YC));
+}
+EXPORT_SYMBOL_GPL(isppreview_print_status);
+
+/**
+ * isp_preview_init - Module Initialization.
+ **/
+int __init isp_preview_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_prev_device *isp_prev = &isp->isp_prev;
+	struct prev_params *params = &isp_prev->params;
+	int i = 0;
+
+	isp_prev->dev = dev;
+
+	/* Init values */
+	isp_prev->sph = 2;
+	isp_prev->slv = 0;
+	isp_prev->color = V4L2_COLORFX_NONE;
+	isp_prev->contrast = ISPPRV_CONTRAST_DEF;
+	params->contrast = ISPPRV_CONTRAST_DEF;
+	isp_prev->brightness = ISPPRV_BRIGHT_DEF;
+	params->brightness = ISPPRV_BRIGHT_DEF;
+	params->average = NO_AVE;
+	params->lens_shading_shift = 0;
+	params->cfa.cfafmt = CFAFMT_BAYER;
+	params->cfa.cfa_table = cfa_coef_table;
+	params->cfa.cfa_gradthrs_horz = FLR_CFA_GRADTHRS_HORZ;
+	params->cfa.cfa_gradthrs_vert = FLR_CFA_GRADTHRS_VERT;
+	params->csup.gain = FLR_CSUP_GAIN;
+	params->csup.thres = FLR_CSUP_THRES;
+	params->csup.hypf_en = 0;
+	params->ytable = kzalloc(sizeof(u32) * ISPPRV_YENH_TBL_SIZE,
+				 GFP_KERNEL);
+	isppreview_set_luma_enhancement(isp_prev, luma_enhance_table);
+	params->nf.spread = FLR_NF_STRGTH;
+	memcpy(params->nf.table, noise_filter_table, sizeof(params->nf.table));
+	params->dcor.couplet_mode_en = 1;
+	for (i = 0; i < 4; i++)
+		params->dcor.detect_correct[i] = 0xE;
+	params->gtable.bluetable = bluegamma_table;
+	params->gtable.greentable = greengamma_table;
+	params->gtable.redtable = redgamma_table;
+	params->wbal.dgain = FLR_WBAL_DGAIN;
+	if ((cpu_is_omap34xx() && omap_rev_gt_1_0()) || cpu_is_omap3630()) {
+		params->wbal.coef0 = FLR_WBAL_COEF0_ES1;
+		params->wbal.coef1 = FLR_WBAL_COEF1_ES1;
+		params->wbal.coef2 = FLR_WBAL_COEF2_ES1;
+		params->wbal.coef3 = FLR_WBAL_COEF3_ES1;
+	} else {
+		params->wbal.coef0 = FLR_WBAL_COEF0;
+		params->wbal.coef1 = FLR_WBAL_COEF1;
+		params->wbal.coef2 = FLR_WBAL_COEF2;
+		params->wbal.coef3 = FLR_WBAL_COEF3;
+	}
+	params->blk_adj.red = FLR_BLKADJ_RED;
+	params->blk_adj.green = FLR_BLKADJ_GREEN;
+	params->blk_adj.blue = FLR_BLKADJ_BLUE;
+	params->rgb2rgb = flr_rgb2rgb;
+	params->rgb2ycbcr = flr_prev_csc[isp_prev->color];
+
+	params->features = PREV_CFA | PREV_DEFECT_COR | PREV_NOISE_FILTER;
+	params->features &= ~(PREV_AVERAGER | PREV_INVERSE_ALAW |
+			      PREV_HORZ_MEDIAN_FILTER |
+			      PREV_GAMMA_BYPASS |
+			      PREV_DARK_FRAME_SUBTRACT |
+			      PREV_LENS_SHADING |
+			      PREV_DARK_FRAME_CAPTURE |
+			      PREV_CHROMA_SUPPRESS |
+			      PREV_LUMA_ENHANCE);
+
+	spin_lock_init(&isp_prev->lock);
+
+	return 0;
+}
+
+/**
+ * isp_preview_cleanup - Module Cleanup.
+ **/
+void isp_preview_cleanup(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_prev_device *isp_prev = &isp->isp_prev;
+	struct prev_params *params = &isp_prev->params;
+
+	kfree(params->ytable);
+}
diff --git a/drivers/media/video/isp/isppreview.h b/drivers/media/video/isp/isppreview.h
new file mode 100644
index 0000000..99710bc
--- /dev/null
+++ b/drivers/media/video/isp/isppreview.h
@@ -0,0 +1,426 @@
+/*
+ * isppreview.h
+ *
+ * Driver header file for Preview module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Senthilvadivu Guruswamy <svadivu@ti.com>
+ *	Pallavi Kulkarni <p-kulkarni@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_PREVIEW_H
+#define OMAP_ISP_PREVIEW_H
+
+#include <plat/isp_user.h>
+/* Isp query control structure */
+
+#define ISPPRV_BRIGHT_STEP		0x1
+#define ISPPRV_BRIGHT_DEF		0x1
+#define ISPPRV_BRIGHT_LOW		0x0
+#define ISPPRV_BRIGHT_HIGH		0xFF
+#define ISPPRV_BRIGHT_UNITS		0x1
+
+#define ISPPRV_CONTRAST_STEP		0x1
+#define ISPPRV_CONTRAST_DEF		0x10
+#define ISPPRV_CONTRAST_LOW		0x0
+#define ISPPRV_CONTRAST_HIGH		0xFF
+#define ISPPRV_CONTRAST_UNITS		0x1
+
+#define NO_AVE				0x0
+#define AVE_2_PIX			0x1
+#define AVE_4_PIX			0x2
+#define AVE_8_PIX			0x3
+#define AVE_ODD_PIXEL_DIST		(1 << 4) /* For Bayer Sensors */
+#define AVE_EVEN_PIXEL_DIST		(1 << 2)
+
+#define WB_GAIN_MAX			4
+
+/* Features list */
+#define PREV_AVERAGER			(1 << 0)
+#define PREV_INVERSE_ALAW		(1 << 1)
+#define PREV_HORZ_MEDIAN_FILTER		(1 << 2)
+#define PREV_NOISE_FILTER		(1 << 3)
+#define PREV_CFA			(1 << 4)
+#define PREV_GAMMA_BYPASS		(1 << 5)
+#define PREV_LUMA_ENHANCE		(1 << 6)
+#define PREV_CHROMA_SUPPRESS		(1 << 7)
+#define PREV_DARK_FRAME_SUBTRACT	(1 << 8)
+#define PREV_LENS_SHADING		(1 << 9)
+#define PREV_DARK_FRAME_CAPTURE		(1 << 10)
+#define PREV_DEFECT_COR			(1 << 11)
+
+
+#define ISP_NF_TABLE_SIZE		(1 << 10)
+
+#define ISP_GAMMA_TABLE_SIZE		(1 << 10)
+
+/* Table addresses */
+#define ISPPRV_TBL_ADDR_RED_G_START  0x00
+#define ISPPRV_TBL_ADDR_BLUE_G_START  0x800
+#define ISPPRV_TBL_ADDR_GREEN_G_START  0x400
+
+/*
+ *Enumeration Constants for input and output format
+ */
+enum preview_input {
+	PRV_RAW_CCDC,
+	PRV_RAW_MEM,
+	PRV_RGBBAYERCFA,
+	PRV_COMPCFA,
+	PRV_CCDC_DRKF,
+	PRV_OTHERS
+};
+enum preview_output {
+	PREVIEW_RSZ,
+	PREVIEW_MEM
+};
+/*
+ * Configure byte layout of YUV image
+ */
+enum preview_ycpos_mode {
+	YCPOS_YCrYCb = 0,
+	YCPOS_YCbYCr = 1,
+	YCPOS_CbYCrY = 2,
+	YCPOS_CrYCbY = 3
+};
+
+/**
+ * struct ispprev_gtable - Structure for Gamma Correction.
+ * @redtable: Pointer to the red gamma table.
+ * @greentable: Pointer to the green gamma table.
+ * @bluetable: Pointer to the blue gamma table.
+ */
+struct ispprev_gtable {
+	u32 *redtable;
+	u32 *greentable;
+	u32 *bluetable;
+};
+
+/**
+ * struct prev_white_balance - Structure for White Balance 2.
+ * @wb_dgain: White balance common gain.
+ * @wb_gain: Individual color gains.
+ * @wb_coefmatrix: Coefficient matrix
+ */
+struct prev_white_balance {
+	u16 wb_dgain; /* white balance common gain */
+	u8 wb_gain[WB_GAIN_MAX]; /* individual color gains */
+	u8 wb_coefmatrix[WB_GAIN_MAX][WB_GAIN_MAX];
+};
+
+/**
+ * struct prev_size_params - Structure for size parameters.
+ * @hstart: Starting pixel.
+ * @vstart: Starting line.
+ * @hsize: Width of input image.
+ * @vsize: Height of input image.
+ * @pixsize: Pixel size of the image in terms of bits.
+ * @in_pitch: Line offset of input image.
+ * @out_pitch: Line offset of output image.
+ */
+struct prev_size_params {
+	unsigned int hstart;
+	unsigned int vstart;
+	unsigned int hsize;
+	unsigned int vsize;
+	unsigned char pixsize;
+	unsigned short in_pitch;
+	unsigned short out_pitch;
+};
+
+/**
+ * struct prev_rgb2ycbcr_coeffs - Structure RGB2YCbCr parameters.
+ * @coeff: Color conversion gains in 3x3 matrix.
+ * @offset: Color conversion offsets.
+ */
+struct prev_rgb2ycbcr_coeffs {
+	short coeff[RGB_MAX][RGB_MAX];
+	short offset[RGB_MAX];
+};
+
+/**
+ * struct prev_darkfrm_params - Structure for Dark frame suppression.
+ * @addr: Memory start address.
+ * @offset: Line offset.
+ */
+struct prev_darkfrm_params {
+	u32 addr;
+	 u32 offset;
+ };
+
+/**
+ * struct prev_params - Structure for all configuration
+ * @features: Set of features enabled.
+ * @cfa: CFA coefficients.
+ * @csup: Chroma suppression coefficients.
+ * @ytable: Pointer to Luma enhancement coefficients.
+ * @nf: Noise filter coefficients.
+ * @dcor: Noise filter coefficients.
+ * @gtable: Gamma coefficients.
+ * @wbal: White Balance parameters.
+ * @blk_adj: Black adjustment parameters.
+ * @rgb2rgb: RGB blending parameters.
+ * @rgb2ycbcr: RGB to ycbcr parameters.
+ * @hmf_params: Horizontal median filter.
+ * @size_params: Size parameters.
+ * @drkf_params: Darkframe parameters.
+ * @lens_shading_shift:
+ * @average: Downsampling rate for averager.
+ * @contrast: Contrast.
+ * @brightness: Brightness.
+ */
+struct prev_params {
+	u16 features;
+	enum preview_ycpos_mode pix_fmt;
+	struct ispprev_cfa cfa;
+	struct ispprev_csup csup;
+	u32 *ytable;
+	struct ispprev_nf nf;
+	struct ispprev_dcor dcor;
+	struct ispprev_gtable gtable;
+	struct ispprev_wbal wbal;
+	struct ispprev_blkadj blk_adj;
+	struct ispprev_rgbtorgb rgb2rgb;
+	struct ispprev_csc rgb2ycbcr;
+	struct ispprev_hmed hmf_params;
+	struct prev_size_params size_params;
+	struct prev_darkfrm_params drkf_params;
+	u8 lens_shading_shift;
+	u8 average;
+	u8 contrast;
+	u8 brightness;
+};
+
+/**
+ * struct isptables_update - Structure for Table Configuration.
+ * @update: Specifies which tables should be updated.
+ * @flag: Specifies which tables should be enabled.
+ * @prev_nf: Pointer to structure for Noise Filter
+ * @lsc: Pointer to LSC gain table. (currently not used)
+ * @red_gamma: Pointer to red gamma correction table.
+ * @green_gamma: Pointer to green gamma correction table.
+ * @blue_gamma: Pointer to blue gamma correction table.
+ */
+struct isptables_update {
+	u16 update;
+	u16 flag;
+	struct ispprev_nf *prev_nf;
+	u32 *lsc;
+	u32 *red_gamma;
+	u32 *green_gamma;
+	u32 *blue_gamma;
+	struct ispprev_cfa *prev_cfa;
+};
+
+/**
+ * struct isp_prev_device - Structure for storing ISP Preview module information
+ * @prevout_w: Preview output width.
+ * @prevout_h: Preview output height.
+ * @previn_w: Preview input width.
+ * @previn_h: Preview input height.
+ * @prev_inpfmt: Preview input format.
+ * @prev_outfmt: Preview output format.
+ * @hmed_en: Horizontal median filter enable.
+ * @nf_en: Noise filter enable.
+ * @dcor_en: Defect correction enable.
+ * @cfa_en: Color Filter Array (CFA) interpolation enable.
+ * @csup_en: Chrominance suppression enable.
+ * @yenh_en: Luma enhancement enable.
+ * @fmtavg: Number of horizontal pixels to average in input formatter. The
+ *          input width should be a multiple of this number.
+ * @brightness: Brightness in preview module.
+ * @contrast: Contrast in preview module.
+ * @color: Color effect in preview module.
+ * @cfafmt: Color Filter Array (CFA) Format.
+ *
+ * This structure is used to store the OMAP ISP Preview module Information.
+ */
+struct isp_prev_device {
+	u8 update_color_matrix;
+	u8 update_rgb_blending;
+	u8 update_rgb_to_ycbcr;
+	u8 hmed_en;
+	u8 nf_en;
+	u8 dcor_en;
+	u8 cfa_en;
+	u8 csup_en;
+	u8 yenh_en;
+	u8 rg_update;
+	u8 gg_update;
+	u8 bg_update;
+	u8 cfa_update;
+	u8 nf_enable;
+	u8 nf_update;
+	u8 fmtavg;
+	u8 brightness;
+	u8 contrast;
+	enum v4l2_colorfx color;
+	enum cfa_fmt cfafmt;
+	struct ispprev_nf prev_nf_t;
+	struct prev_params params;
+	int shadow_update;
+	u32 sph;
+	u32 slv;
+	struct device *dev;
+	spinlock_t lock;
+};
+
+void isppreview_config_shadow_registers(struct isp_prev_device *isp_prev);
+
+int isppreview_request(struct isp_prev_device *isp_prev);
+
+int isppreview_free(struct isp_prev_device *isp_prev);
+
+int isppreview_config_datapath(struct isp_prev_device *isp_prev,
+			       struct isp_pipeline *pipe);
+
+void isppreview_config_ycpos(struct isp_prev_device *isp_prev,
+			     enum preview_ycpos_mode mode);
+
+void isppreview_config_averager(struct isp_prev_device *isp_prev, u8 average);
+
+void isppreview_enable_invalaw(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_enable_drkframe(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_enable_shadcomp(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_config_drkf_shadcomp(struct isp_prev_device *isp_prev,
+				     u8 scomp_shtval);
+
+void isppreview_enable_gammabypass(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_enable_hmed(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_config_hmed(struct isp_prev_device *isp_prev,
+			    struct ispprev_hmed);
+
+void isppreview_enable_noisefilter(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_config_noisefilter(struct isp_prev_device *isp_prev,
+				   struct ispprev_nf prev_nf);
+
+void isppreview_enable_dcor(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_config_dcor(struct isp_prev_device *isp_prev,
+			    struct ispprev_dcor prev_dcor);
+
+
+void isppreview_config_cfa(struct isp_prev_device *isp_prev,
+			   struct ispprev_cfa *cfa);
+
+void isppreview_config_gammacorrn(struct isp_prev_device *isp_prev,
+				  struct ispprev_gtable);
+
+void isppreview_config_chroma_suppression(struct isp_prev_device *isp_prev,
+					  struct ispprev_csup csup);
+
+void isppreview_enable_cfa(struct isp_prev_device *isp_prev, u8 enable);
+
+void isppreview_set_luma_enhancement(struct isp_prev_device *isp_prev,
+				     u32 *ytable);
+
+void isppreview_config_luma_enhancement(struct isp_prev_device *isp_prev,
+					u32 *ytable);
+
+void isppreview_enable_luma_enhancement(struct isp_prev_device *isp_prev,
+					u8 enable);
+
+void isppreview_enable_chroma_suppression(struct isp_prev_device *isp_prev,
+					  u8 enable);
+
+void isppreview_config_whitebalance(struct isp_prev_device *isp_prev,
+				    struct ispprev_wbal);
+
+void isppreview_config_blkadj(struct isp_prev_device *isp_prev,
+			      struct ispprev_blkadj);
+
+void isppreview_config_rgb_blending(struct isp_prev_device *isp_prev,
+				    struct ispprev_rgbtorgb);
+
+void isppreview_config_rgb_to_ycbcr(struct isp_prev_device *isp_prev,
+				    struct ispprev_csc);
+
+void isppreview_update_contrast(struct isp_prev_device *isp_prev, u8 *contrast);
+
+void isppreview_query_contrast(struct isp_prev_device *isp_prev, u8 *contrast);
+
+void isppreview_config_contrast(struct isp_prev_device *isp_prev, u8 contrast);
+
+void isppreview_get_contrast_range(u8 *min_contrast, u8 *max_contrast);
+
+void isppreview_update_brightness(struct isp_prev_device *isp_prev,
+				  u8 *brightness);
+
+void isppreview_config_brightness(struct isp_prev_device *isp_prev,
+				  u8 brightness);
+
+void isppreview_get_brightness_range(u8 *min_brightness, u8 *max_brightness);
+
+void isppreview_set_color(struct isp_prev_device *isp_prev, u8 *mode);
+
+void isppreview_get_color(struct isp_prev_device *isp_prev, u8 *mode);
+
+void isppreview_query_brightness(struct isp_prev_device *isp_prev,
+				 u8 *brightness);
+
+void isppreview_config_yc_range(struct isp_prev_device *isp_prev,
+				struct ispprev_yclimit yclimit);
+
+int isppreview_try_pipeline(struct isp_prev_device *isp_prev,
+			    struct isp_pipeline *pipe);
+
+int isppreview_s_pipeline(struct isp_prev_device *isp_prev,
+			  struct isp_pipeline *pipe);
+
+int isppreview_config_inlineoffset(struct isp_prev_device *isp_prev,
+				   u32 offset);
+
+int isppreview_set_inaddr(struct isp_prev_device *isp_prev, u32 addr);
+
+int isppreview_config_outlineoffset(struct isp_prev_device *isp_prev,
+				    u32 offset);
+
+int isppreview_set_outaddr(struct isp_prev_device *isp_prev, u32 addr);
+
+int isppreview_config_darklineoffset(struct isp_prev_device *isp_prev,
+				     u32 offset);
+
+int isppreview_set_darkaddr(struct isp_prev_device *isp_prev, u32 addr);
+
+void isppreview_enable(struct isp_prev_device *isp_prev);
+
+int isppreview_busy(struct isp_prev_device *isp_prev);
+
+void isppreview_print_status(struct isp_prev_device *isp_prev,
+			     struct isp_pipeline *pipe);
+
+#ifndef CONFIG_ARCH_OMAP3410
+void isppreview_save_context(struct device *dev);
+#else
+static inline void isppreview_save_context(struct device *dev) {}
+#endif
+
+#ifndef CONFIG_ARCH_OMAP3410
+void isppreview_restore_context(struct device *dev);
+#else
+static inline void isppreview_restore_context(struct device *dev) {}
+#endif
+
+int omap34xx_isp_preview_config(struct isp_prev_device *isp_prev,
+				void *userspace_add);
+
+void isppreview_set_skip(struct isp_prev_device *isp_prev, u32 h, u32 v);
+
+#endif/* OMAP_ISP_PREVIEW_H */
diff --git a/drivers/media/video/isp/ispreg.h b/drivers/media/video/isp/ispreg.h
new file mode 100644
index 0000000..2769eb8
--- /dev/null
+++ b/drivers/media/video/isp/ispreg.h
@@ -0,0 +1,1702 @@
+/*
+ * ispreg.h
+ *
+ * Header file for all the ISP module in TI's OMAP3 Camera ISP.
+ * It has the OMAP HW register definitions.
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ * Copyright (C) 2009 Nokia.
+ *
+ * Contributors:
+ *	Tuukka Toivonen <tuukka.o.toivonen@nokia.com>
+ *	Thara Gopinath <thara@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __ISPREG_H__
+#define __ISPREG_H__
+
+#include <plat/omap34xx.h>
+
+/* Note: Uncomment below defines as needed for enabling module specific debug
+ * messages
+ */
+
+/*
+  #define OMAP_ISPCTRL_DEBUG
+  #define OMAP_ISPCCDC_DEBUG
+  #define OMAP_ISPPREV_DEBUG
+  #define OMAP_ISPRESZ_DEBUG
+  #define OMAP_ISPMMU_DEBUG
+  #define OMAP_ISPH3A_DEBUG
+  #define OMAP_ISP_AF_DEBUG
+  #define OMAP_ISPHIST_DEBUG
+*/
+
+#ifdef OMAP_ISPCTRL_DEBUG
+#define DPRINTK_ISPCTRL(format, ...)				\
+	printk(KERN_INFO "ISPCTRL: " format, ## __VA_ARGS__)
+#define is_ispctrl_debug_enabled()		1
+#else
+#define DPRINTK_ISPCTRL(format, ...)
+#define is_ispctrl_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPCCDC_DEBUG
+#define DPRINTK_ISPCCDC(format, ...)				\
+	printk(KERN_INFO "ISPCCDC: " format, ## __VA_ARGS__)
+#define is_ispccdc_debug_enabled()		1
+#else
+#define DPRINTK_ISPCCDC(format, ...)
+#define is_ispccdc_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPPREV_DEBUG
+#define DPRINTK_ISPPREV(format, ...)				\
+	printk(KERN_INFO "ISPPREV: " format, ## __VA_ARGS__)
+#define is_ispprev_debug_enabled()		1
+#else
+#define DPRINTK_ISPPREV(format, ...)
+#define is_ispprev_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPRESZ_DEBUG
+#define DPRINTK_ISPRESZ(format, ...)				\
+	printk(KERN_INFO "ISPRESZ: " format, ## __VA_ARGS__)
+#define is_ispresz_debug_enabled()		1
+#else
+#define DPRINTK_ISPRESZ(format, ...)
+#define is_ispresz_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPMMU_DEBUG
+#define DPRINTK_ISPMMU(format, ...)				\
+	printk(KERN_INFO "ISPMMU: " format, ## __VA_ARGS__)
+#define is_ispmmu_debug_enabled()		1
+#else
+#define DPRINTK_ISPMMU(format, ...)
+#define is_ispmmu_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPH3A_DEBUG
+#define DPRINTK_ISPH3A(format, ...)				\
+	printk(KERN_INFO "ISPH3A: " format, ## __VA_ARGS__)
+#define is_isph3a_debug_enabled()		1
+#else
+#define DPRINTK_ISPH3A(format, ...)
+#define is_isph3a_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISP_AF_DEBUG
+#define DPRINTK_ISP_AF(format, ...)				\
+	printk(KERN_INFO "ISP_AF: " format, ## __VA_ARGS__)
+#define is_isp_af_debug_enabled()		1
+#else
+#define DPRINTK_ISP_AF(format, ...)
+#define is_isp_af_debug_enabled()		0
+#endif
+
+#ifdef OMAP_ISPHIST_DEBUG
+#define DPRINTK_ISPHIST(format, ...)				\
+	printk(KERN_INFO "ISPHIST: " format, ## __VA_ARGS__)
+#define is_isphist_debug_enabled()		1
+#else
+#define DPRINTK_ISPHIST(format, ...)
+#define is_isphist_debug_enabled()		0
+#endif
+
+#define ISP_32B_BOUNDARY_BUF		0xFFFFFFE0
+#define ISP_32B_BOUNDARY_OFFSET		0x0000FFE0
+
+#define CM_CAM_MCLK_HZ			216000000
+
+/* ISP Submodules offset */
+
+#define OMAP3ISP_REG_BASE		OMAP3430_ISP_BASE
+#define OMAP3ISP_REG(offset)		(OMAP3ISP_REG_BASE + (offset))
+
+#define OMAP3ISP_CBUFF_REG_OFFSET	0x0100
+#define OMAP3ISP_CBUFF_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_CBUFF_REG_OFFSET)
+#define OMAP3ISP_CBUFF_REG(offset)	(OMAP3ISP_CBUFF_REG_BASE + (offset))
+
+#define OMAP3ISP_CCP2_REG_OFFSET	0x0400
+#define OMAP3ISP_CCP2_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_CCP2_REG_OFFSET)
+#define OMAP3ISP_CCP2_REG(offset)	(OMAP3ISP_CCP2_REG_BASE + (offset))
+
+#define OMAP3ISP_CCDC_REG_OFFSET	0x0600
+#define OMAP3ISP_CCDC_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_CCDC_REG_OFFSET)
+#define OMAP3ISP_CCDC_REG(offset)	(OMAP3ISP_CCDC_REG_BASE + (offset))
+
+#define OMAP3ISP_HIST_REG_OFFSET	0x0A00
+#define OMAP3ISP_HIST_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_HIST_REG_OFFSET)
+#define OMAP3ISP_HIST_REG(offset)	(OMAP3ISP_HIST_REG_BASE + (offset))
+
+#define OMAP3ISP_H3A_REG_OFFSET		0x0C00
+#define OMAP3ISP_H3A_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_H3A_REG_OFFSET)
+#define OMAP3ISP_H3A_REG(offset)	(OMAP3ISP_H3A_REG_BASE + (offset))
+
+#define OMAP3ISP_PREV_REG_OFFSET	0x0E00
+#define OMAP3ISP_PREV_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_PREV_REG_OFFSET)
+#define OMAP3ISP_PREV_REG(offset)	(OMAP3ISP_PREV_REG_BASE + (offset))
+
+#define OMAP3ISP_RESZ_REG_OFFSET	0x1000
+#define OMAP3ISP_RESZ_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_RESZ_REG_OFFSET)
+#define OMAP3ISP_RESZ_REG(offset)	(OMAP3ISP_RESZ_REG_BASE + (offset))
+
+#define OMAP3ISP_SBL_REG_OFFSET		0x1200
+#define OMAP3ISP_SBL_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_SBL_REG_OFFSET)
+#define OMAP3ISP_SBL_REG(offset)	(OMAP3ISP_SBL_REG_BASE + (offset))
+
+#define OMAP3ISP_MMU_REG_OFFSET		0x1400
+#define OMAP3ISP_MMU_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_MMU_REG_OFFSET)
+#define OMAP3ISP_MMU_REG(offset)	(OMAP3ISP_MMU_REG_BASE + (offset))
+
+#define OMAP3ISP_CSI2A_REG_OFFSET	0x1800
+#define OMAP3ISP_CSI2A_REG_BASE		(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_CSI2A_REG_OFFSET)
+#define OMAP3ISP_CSI2A_REG(offset)	(OMAP3ISP_CSI2A_REG_BASE + (offset))
+
+#define OMAP3ISP_CSI2PHY_REG_OFFSET	0x1970
+#define OMAP3ISP_CSI2PHY_REG_BASE	(OMAP3ISP_REG_BASE +		\
+					 OMAP3ISP_CSI2PHY_REG_OFFSET)
+#define OMAP3ISP_CSI2PHY_REG(offset)	(OMAP3ISP_CSI2PHY_REG_BASE + (offset))
+
+/* ISP module register offset */
+
+#define ISP_REVISION			(0x000)
+#define ISP_SYSCONFIG			(0x004)
+#define ISP_SYSSTATUS			(0x008)
+#define ISP_IRQ0ENABLE			(0x00C)
+#define ISP_IRQ0STATUS			(0x010)
+#define ISP_IRQ1ENABLE			(0x014)
+#define ISP_IRQ1STATUS			(0x018)
+#define ISP_TCTRL_GRESET_LENGTH		(0x030)
+#define ISP_TCTRL_PSTRB_REPLAY		(0x034)
+#define ISP_CTRL			(0x040)
+#define ISP_SECURE			(0x044)
+#define ISP_TCTRL_CTRL			(0x050)
+#define ISP_TCTRL_FRAME			(0x054)
+#define ISP_TCTRL_PSTRB_DELAY		(0x058)
+#define ISP_TCTRL_STRB_DELAY		(0x05C)
+#define ISP_TCTRL_SHUT_DELAY		(0x060)
+#define ISP_TCTRL_PSTRB_LENGTH		(0x064)
+#define ISP_TCTRL_STRB_LENGTH		(0x068)
+#define ISP_TCTRL_SHUT_LENGTH		(0x06C)
+#define ISP_PING_PONG_ADDR		(0x070)
+#define ISP_PING_PONG_MEM_RANGE		(0x074)
+#define ISP_PING_PONG_BUF_SIZE		(0x078)
+
+/* CSI1 receiver registers (ES2.0) */
+#define ISPCSI1_REVISION		(0x000)
+#define ISPCSI1_SYSCONFIG		(0x004)
+#define ISPCSI1_SYSSTATUS		(0x008)
+#define ISPCSI1_LC01_IRQENABLE		(0x00C)
+#define ISPCSI1_LC01_IRQSTATUS		(0x010)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FS_IRQ	(1 << 11)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_LE_IRQ	(1 << 10)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_LS_IRQ	(1 << 9)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FE_IRQ	(1 << 8)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_COUNT_IRQ	(1 << 7)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FIFO_OVF_IRQ	(1 << 5)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_CRC_IRQ	(1 << 4)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FSP_IRQ	(1 << 3)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FW_IRQ	(1 << 2)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_FSC_IRQ	(1 << 1)
+#define ISPCSI1_LC01_IRQSTATUS_LC0_SSC_IRQ	(1 << 0)
+
+#define ISPCSI1_LC23_IRQENABLE		(0x014)
+#define ISPCSI1_LC23_IRQSTATUS		(0x018)
+#define ISPCSI1_LCM_IRQENABLE		(0x02C)
+#define ISPCSI1_LCM_IRQSTATUS		(0x030)
+#define ISPCSI1_CTRL			(0x040)
+#define ISPCSI1_DBG			(0x044)
+#define ISPCSI1_GNQ			(0x048)
+#define ISPCSI1_LCx_CTRL(x)		((0x050)+0x30*(x))
+#define ISPCSI1_LCx_CODE(x)		((0x054)+0x30*(x))
+#define ISPCSI1_LCx_STAT_START(x)	((0x058)+0x30*(x))
+#define ISPCSI1_LCx_STAT_SIZE(x)	((0x05C)+0x30*(x))
+#define ISPCSI1_LCx_SOF_ADDR(x)		((0x060)+0x30*(x))
+#define ISPCSI1_LCx_EOF_ADDR(x)		((0x064)+0x30*(x))
+#define ISPCSI1_LCx_DAT_START(x)	((0x068)+0x30*(x))
+#define ISPCSI1_LCx_DAT_SIZE(x)		((0x06C)+0x30*(x))
+#define ISPCSI1_LCx_DAT_PING_ADDR(x)	((0x070)+0x30*(x))
+#define ISPCSI1_LCx_DAT_PONG_ADDR(x)	((0x074)+0x30*(x))
+#define ISPCSI1_LCx_DAT_OFST(x)		((0x078)+0x30*(x))
+#define ISPCSI1_LCM_CTRL		(0x1D0)
+#define ISPCSI1_LCM_VSIZE		(0x1D4)
+#define ISPCSI1_LCM_HSIZE		(0x1D8)
+#define ISPCSI1_LCM_PREFETCH		(0x1DC)
+#define ISPCSI1_LCM_SRC_ADDR		(0x1E0)
+#define ISPCSI1_LCM_SRC_OFST		(0x1E4)
+#define ISPCSI1_LCM_DST_ADDR		(0x1E8)
+#define ISPCSI1_LCM_DST_OFST		(0x1EC)
+#define ISP_CSIB_SYSCONFIG		ISPCSI1_SYSCONFIG
+#define ISP_CSIA_SYSCONFIG		ISPCSI2_SYSCONFIG
+
+/* ISP_CBUFF Registers */
+
+#define ISP_CBUFF_SYSCONFIG		(0x010)
+#define ISP_CBUFF_IRQENABLE		(0x01C)
+
+#define ISP_CBUFF0_CTRL			(0x020)
+#define ISP_CBUFF1_CTRL			(0x024)
+
+#define ISP_CBUFF0_START		(0x040)
+#define ISP_CBUFF1_START		(0x044)
+
+#define ISP_CBUFF0_END			(0x050)
+#define ISP_CBUFF1_END			(0x054)
+
+#define ISP_CBUFF0_WINDOWSIZE		(0x060)
+#define ISP_CBUFF1_WINDOWSIZE		(0x064)
+
+#define ISP_CBUFF0_THRESHOLD		(0x070)
+#define ISP_CBUFF1_THRESHOLD		(0x074)
+
+/* CCDC module register offset */
+
+#define ISPCCDC_PID			(0x000)
+#define ISPCCDC_PCR			(0x004)
+#define ISPCCDC_SYN_MODE		(0x008)
+#define ISPCCDC_HD_VD_WID		(0x00C)
+#define ISPCCDC_PIX_LINES		(0x010)
+#define ISPCCDC_HORZ_INFO		(0x014)
+#define ISPCCDC_VERT_START		(0x018)
+#define ISPCCDC_VERT_LINES		(0x01C)
+#define ISPCCDC_CULLING			(0x020)
+#define ISPCCDC_HSIZE_OFF		(0x024)
+#define ISPCCDC_SDOFST			(0x028)
+#define ISPCCDC_SDR_ADDR		(0x02C)
+#define ISPCCDC_CLAMP			(0x030)
+#define ISPCCDC_DCSUB			(0x034)
+#define ISPCCDC_COLPTN			(0x038)
+#define ISPCCDC_BLKCMP			(0x03C)
+#define ISPCCDC_FPC			(0x040)
+#define ISPCCDC_FPC_ADDR		(0x044)
+#define ISPCCDC_VDINT			(0x048)
+#define ISPCCDC_ALAW			(0x04C)
+#define ISPCCDC_REC656IF		(0x050)
+#define ISPCCDC_CFG			(0x054)
+#define ISPCCDC_FMTCFG			(0x058)
+#define ISPCCDC_FMT_HORZ		(0x05C)
+#define ISPCCDC_FMT_VERT		(0x060)
+#define ISPCCDC_FMT_ADDR0		(0x064)
+#define ISPCCDC_FMT_ADDR1		(0x068)
+#define ISPCCDC_FMT_ADDR2		(0x06C)
+#define ISPCCDC_FMT_ADDR3		(0x070)
+#define ISPCCDC_FMT_ADDR4		(0x074)
+#define ISPCCDC_FMT_ADDR5		(0x078)
+#define ISPCCDC_FMT_ADDR6		(0x07C)
+#define ISPCCDC_FMT_ADDR7		(0x080)
+#define ISPCCDC_PRGEVEN0		(0x084)
+#define ISPCCDC_PRGEVEN1		(0x088)
+#define ISPCCDC_PRGODD0			(0x08C)
+#define ISPCCDC_PRGODD1			(0x090)
+#define ISPCCDC_VP_OUT			(0x094)
+
+#define ISPCCDC_LSC_CONFIG		(0x098)
+#define ISPCCDC_LSC_INITIAL		(0x09C)
+#define ISPCCDC_LSC_TABLE_BASE		(0x0A0)
+#define ISPCCDC_LSC_TABLE_OFFSET	(0x0A4)
+
+/* SBL */
+#define ISPSBL_PCR			0x4
+#define ISPSBL_PCR_H3A_AEAWB_WBL_OVF	(1 << 16)
+#define ISPSBL_PCR_H3A_AF_WBL_OVF	(1 << 17)
+#define ISPSBL_PCR_RSZ4_WBL_OVF		(1 << 18)
+#define ISPSBL_PCR_RSZ3_WBL_OVF		(1 << 19)
+#define ISPSBL_PCR_RSZ2_WBL_OVF		(1 << 20)
+#define ISPSBL_PCR_RSZ1_WBL_OVF		(1 << 21)
+#define ISPSBL_PCR_PRV_WBL_OVF		(1 << 22)
+#define ISPSBL_PCR_CCDC_WBL_OVF		(1 << 23)
+#define ISPSBL_PCR_CCDCPRV_2_RSZ_OVF	(1 << 24)
+#define ISPSBL_PCR_CSIA_WBL_OVF		(1 << 25)
+#define ISPSBL_PCR_CSIB_WBL_OVF		(1 << 26)
+#define ISPSBL_CCDC_WR_0		(0x028)
+#define ISPSBL_CCDC_WR_0_DATA_READY	(1 << 21)
+#define ISPSBL_CCDC_WR_1		(0x02C)
+#define ISPSBL_CCDC_WR_2		(0x030)
+#define ISPSBL_CCDC_WR_3		(0x034)
+
+/* Histogram registers */
+#define ISPHIST_PID			(0x000)
+#define ISPHIST_PCR			(0x004)
+#define ISPHIST_CNT			(0x008)
+#define ISPHIST_WB_GAIN			(0x00C)
+#define ISPHIST_R0_HORZ			(0x010)
+#define ISPHIST_R0_VERT			(0x014)
+#define ISPHIST_R1_HORZ			(0x018)
+#define ISPHIST_R1_VERT			(0x01C)
+#define ISPHIST_R2_HORZ			(0x020)
+#define ISPHIST_R2_VERT			(0x024)
+#define ISPHIST_R3_HORZ			(0x028)
+#define ISPHIST_R3_VERT			(0x02C)
+#define ISPHIST_ADDR			(0x030)
+#define ISPHIST_DATA			(0x034)
+#define ISPHIST_RADD			(0x038)
+#define ISPHIST_RADD_OFF		(0x03C)
+#define ISPHIST_H_V_INFO		(0x040)
+
+/* H3A module registers */
+#define ISPH3A_PID			(0x000)
+#define ISPH3A_PCR			(0x004)
+#define ISPH3A_AEWWIN1			(0x04C)
+#define ISPH3A_AEWINSTART		(0x050)
+#define ISPH3A_AEWINBLK			(0x054)
+#define ISPH3A_AEWSUBWIN		(0x058)
+#define ISPH3A_AEWBUFST			(0x05C)
+#define ISPH3A_AFPAX1			(0x008)
+#define ISPH3A_AFPAX2			(0x00C)
+#define ISPH3A_AFPAXSTART		(0x010)
+#define ISPH3A_AFIIRSH			(0x014)
+#define ISPH3A_AFBUFST			(0x018)
+#define ISPH3A_AFCOEF010		(0x01C)
+#define ISPH3A_AFCOEF032		(0x020)
+#define ISPH3A_AFCOEF054		(0x024)
+#define ISPH3A_AFCOEF076		(0x028)
+#define ISPH3A_AFCOEF098		(0x02C)
+#define ISPH3A_AFCOEF0010		(0x030)
+#define ISPH3A_AFCOEF110		(0x034)
+#define ISPH3A_AFCOEF132		(0x038)
+#define ISPH3A_AFCOEF154		(0x03C)
+#define ISPH3A_AFCOEF176		(0x040)
+#define ISPH3A_AFCOEF198		(0x044)
+#define ISPH3A_AFCOEF1010		(0x048)
+
+#define ISPPRV_PCR			(0x004)
+#define ISPPRV_HORZ_INFO		(0x008)
+#define ISPPRV_VERT_INFO		(0x00C)
+#define ISPPRV_RSDR_ADDR		(0x010)
+#define ISPPRV_RADR_OFFSET		(0x014)
+#define ISPPRV_DSDR_ADDR		(0x018)
+#define ISPPRV_DRKF_OFFSET		(0x01C)
+#define ISPPRV_WSDR_ADDR		(0x020)
+#define ISPPRV_WADD_OFFSET		(0x024)
+#define ISPPRV_AVE			(0x028)
+#define ISPPRV_HMED			(0x02C)
+#define ISPPRV_NF			(0x030)
+#define ISPPRV_WB_DGAIN			(0x034)
+#define ISPPRV_WBGAIN			(0x038)
+#define ISPPRV_WBSEL			(0x03C)
+#define ISPPRV_CFA			(0x040)
+#define ISPPRV_BLKADJOFF		(0x044)
+#define ISPPRV_RGB_MAT1			(0x048)
+#define ISPPRV_RGB_MAT2			(0x04C)
+#define ISPPRV_RGB_MAT3			(0x050)
+#define ISPPRV_RGB_MAT4			(0x054)
+#define ISPPRV_RGB_MAT5			(0x058)
+#define ISPPRV_RGB_OFF1			(0x05C)
+#define ISPPRV_RGB_OFF2			(0x060)
+#define ISPPRV_CSC0			(0x064)
+#define ISPPRV_CSC1			(0x068)
+#define ISPPRV_CSC2			(0x06C)
+#define ISPPRV_CSC_OFFSET		(0x070)
+#define ISPPRV_CNT_BRT			(0x074)
+#define ISPPRV_CSUP			(0x078)
+#define ISPPRV_SETUP_YC			(0x07C)
+#define ISPPRV_SET_TBL_ADDR		(0x080)
+#define ISPPRV_SET_TBL_DATA		(0x084)
+#define ISPPRV_CDC_THR0			(0x090)
+#define ISPPRV_CDC_THR1			(ISPPRV_CDC_THR0 + (0x4))
+#define ISPPRV_CDC_THR2			(ISPPRV_CDC_THR0 + (0x4) * 2)
+#define ISPPRV_CDC_THR3			(ISPPRV_CDC_THR0 + (0x4) * 3)
+
+#define ISPPRV_REDGAMMA_TABLE_ADDR	0x0000
+#define ISPPRV_GREENGAMMA_TABLE_ADDR	0x0400
+#define ISPPRV_BLUEGAMMA_TABLE_ADDR	0x0800
+#define ISPPRV_NF_TABLE_ADDR		0x0C00
+#define ISPPRV_YENH_TABLE_ADDR		0x1000
+#define ISPPRV_CFA_TABLE_ADDR		0x1400
+
+#define ISPPRV_MAXOUTPUT_WIDTH		1280
+#define ISPPRV_MAXOUTPUT_WIDTH_ES2	3300
+#define ISPRSZ_MIN_OUTPUT		64
+#define ISPRSZ_MAX_OUTPUT		3312
+
+/* Resizer module register offset */
+#define ISPRSZ_PID			(0x000)
+#define ISPRSZ_PCR			(0x004)
+#define ISPRSZ_CNT			(0x008)
+#define ISPRSZ_OUT_SIZE			(0x00C)
+#define ISPRSZ_IN_START			(0x010)
+#define ISPRSZ_IN_SIZE			(0x014)
+#define ISPRSZ_SDR_INADD		(0x018)
+#define ISPRSZ_SDR_INOFF		(0x01C)
+#define ISPRSZ_SDR_OUTADD		(0x020)
+#define ISPRSZ_SDR_OUTOFF		(0x024)
+#define ISPRSZ_HFILT10			(0x028)
+#define ISPRSZ_HFILT32			(0x02C)
+#define ISPRSZ_HFILT54			(0x030)
+#define ISPRSZ_HFILT76			(0x034)
+#define ISPRSZ_HFILT98			(0x038)
+#define ISPRSZ_HFILT1110		(0x03C)
+#define ISPRSZ_HFILT1312		(0x040)
+#define ISPRSZ_HFILT1514		(0x044)
+#define ISPRSZ_HFILT1716		(0x048)
+#define ISPRSZ_HFILT1918		(0x04C)
+#define ISPRSZ_HFILT2120		(0x050)
+#define ISPRSZ_HFILT2322		(0x054)
+#define ISPRSZ_HFILT2524		(0x058)
+#define ISPRSZ_HFILT2726		(0x05C)
+#define ISPRSZ_HFILT2928		(0x060)
+#define ISPRSZ_HFILT3130		(0x064)
+#define ISPRSZ_VFILT10			(0x068)
+#define ISPRSZ_VFILT32			(0x06C)
+#define ISPRSZ_VFILT54			(0x070)
+#define ISPRSZ_VFILT76			(0x074)
+#define ISPRSZ_VFILT98			(0x078)
+#define ISPRSZ_VFILT1110		(0x07C)
+#define ISPRSZ_VFILT1312		(0x080)
+#define ISPRSZ_VFILT1514		(0x084)
+#define ISPRSZ_VFILT1716		(0x088)
+#define ISPRSZ_VFILT1918		(0x08C)
+#define ISPRSZ_VFILT2120		(0x090)
+#define ISPRSZ_VFILT2322		(0x094)
+#define ISPRSZ_VFILT2524		(0x098)
+#define ISPRSZ_VFILT2726		(0x09C)
+#define ISPRSZ_VFILT2928		(0x0A0)
+#define ISPRSZ_VFILT3130		(0x0A4)
+#define ISPRSZ_YENH			(0x0A8)
+
+/* MMU module registers */
+#define ISPMMU_REVISION			(0x000)
+#define ISPMMU_SYSCONFIG		(0x010)
+#define ISPMMU_SYSSTATUS		(0x014)
+#define ISPMMU_IRQSTATUS		(0x018)
+#define ISPMMU_IRQENABLE		(0x01C)
+#define ISPMMU_WALKING_ST		(0x040)
+#define ISPMMU_CNTL			(0x044)
+#define ISPMMU_FAULT_AD			(0x048)
+#define ISPMMU_TTB			(0x04C)
+#define ISPMMU_LOCK			(0x050)
+#define ISPMMU_LD_TLB			(0x054)
+#define ISPMMU_CAM			(0x058)
+#define ISPMMU_RAM			(0x05C)
+#define ISPMMU_GFLUSH			(0x060)
+#define ISPMMU_FLUSH_ENTRY		(0x064)
+#define ISPMMU_READ_CAM			(0x068)
+#define ISPMMU_READ_RAM			(0x06c)
+#define ISPMMU_EMU_FAULT_AD		(0x070)
+
+#define ISP_INT_CLR			0xFF113F11
+#define ISPPRV_PCR_EN			1
+#define ISPPRV_PCR_BUSY			(1 << 1)
+#define ISPPRV_PCR_SOURCE		(1 << 2)
+#define ISPPRV_PCR_ONESHOT		(1 << 3)
+#define ISPPRV_PCR_WIDTH		(1 << 4)
+#define ISPPRV_PCR_INVALAW		(1 << 5)
+#define ISPPRV_PCR_DRKFEN		(1 << 6)
+#define ISPPRV_PCR_DRKFCAP		(1 << 7)
+#define ISPPRV_PCR_HMEDEN		(1 << 8)
+#define ISPPRV_PCR_NFEN			(1 << 9)
+#define ISPPRV_PCR_CFAEN		(1 << 10)
+#define ISPPRV_PCR_CFAFMT_SHIFT		11
+#define ISPPRV_PCR_CFAFMT_MASK		0x7800
+#define ISPPRV_PCR_CFAFMT_BAYER		(0 << 11)
+#define ISPPRV_PCR_CFAFMT_SONYVGA	(1 << 11)
+#define ISPPRV_PCR_CFAFMT_RGBFOVEON	(2 << 11)
+#define ISPPRV_PCR_CFAFMT_DNSPL		(3 << 11)
+#define ISPPRV_PCR_CFAFMT_HONEYCOMB	(4 << 11)
+#define ISPPRV_PCR_CFAFMT_RRGGBBFOVEON	(5 << 11)
+#define ISPPRV_PCR_YNENHEN		(1 << 15)
+#define ISPPRV_PCR_SUPEN		(1 << 16)
+#define ISPPRV_PCR_YCPOS_SHIFT		17
+#define ISPPRV_PCR_YCPOS_YCrYCb		(0 << 17)
+#define ISPPRV_PCR_YCPOS_YCbYCr		(1 << 17)
+#define ISPPRV_PCR_YCPOS_CbYCrY		(2 << 17)
+#define ISPPRV_PCR_YCPOS_CrYCbY		(3 << 17)
+#define ISPPRV_PCR_RSZPORT		(1 << 19)
+#define ISPPRV_PCR_SDRPORT		(1 << 20)
+#define ISPPRV_PCR_SCOMP_EN		(1 << 21)
+#define ISPPRV_PCR_SCOMP_SFT_SHIFT	(22)
+#define ISPPRV_PCR_SCOMP_SFT_MASK	(~(7 << 22))
+#define ISPPRV_PCR_GAMMA_BYPASS		(1 << 26)
+#define ISPPRV_PCR_DCOREN		(1 << 27)
+#define ISPPRV_PCR_DCCOUP		(1 << 28)
+#define ISPPRV_PCR_DRK_FAIL		(1 << 31)
+
+#define ISPPRV_HORZ_INFO_EPH_SHIFT	0
+#define ISPPRV_HORZ_INFO_EPH_MASK	0x3fff
+#define ISPPRV_HORZ_INFO_SPH_SHIFT	16
+#define ISPPRV_HORZ_INFO_SPH_MASK	0x3fff0
+
+#define ISPPRV_VERT_INFO_ELV_SHIFT	0
+#define ISPPRV_VERT_INFO_ELV_MASK	0x3fff
+#define ISPPRV_VERT_INFO_SLV_SHIFT	16
+#define ISPPRV_VERT_INFO_SLV_MASK	0x3fff0
+
+#define ISPPRV_AVE_EVENDIST_SHIFT	2
+#define ISPPRV_AVE_EVENDIST_1		0x0
+#define ISPPRV_AVE_EVENDIST_2		0x1
+#define ISPPRV_AVE_EVENDIST_3		0x2
+#define ISPPRV_AVE_EVENDIST_4		0x3
+#define ISPPRV_AVE_ODDDIST_SHIFT	4
+#define ISPPRV_AVE_ODDDIST_1		0x0
+#define ISPPRV_AVE_ODDDIST_2		0x1
+#define ISPPRV_AVE_ODDDIST_3		0x2
+#define ISPPRV_AVE_ODDDIST_4		0x3
+
+#define ISPPRV_HMED_THRESHOLD_SHIFT	0
+#define ISPPRV_HMED_EVENDIST		(1 << 8)
+#define ISPPRV_HMED_ODDDIST		(1 << 9)
+
+#define ISPPRV_WBGAIN_COEF0_SHIFT	0
+#define ISPPRV_WBGAIN_COEF1_SHIFT	8
+#define ISPPRV_WBGAIN_COEF2_SHIFT	16
+#define ISPPRV_WBGAIN_COEF3_SHIFT	24
+
+#define ISPPRV_WBSEL_COEF0		0x0
+#define ISPPRV_WBSEL_COEF1		0x1
+#define ISPPRV_WBSEL_COEF2		0x2
+#define ISPPRV_WBSEL_COEF3		0x3
+
+#define ISPPRV_WBSEL_N0_0_SHIFT		0
+#define ISPPRV_WBSEL_N0_1_SHIFT		2
+#define ISPPRV_WBSEL_N0_2_SHIFT		4
+#define ISPPRV_WBSEL_N0_3_SHIFT		6
+#define ISPPRV_WBSEL_N1_0_SHIFT		8
+#define ISPPRV_WBSEL_N1_1_SHIFT		10
+#define ISPPRV_WBSEL_N1_2_SHIFT		12
+#define ISPPRV_WBSEL_N1_3_SHIFT		14
+#define ISPPRV_WBSEL_N2_0_SHIFT		16
+#define ISPPRV_WBSEL_N2_1_SHIFT		18
+#define ISPPRV_WBSEL_N2_2_SHIFT		20
+#define ISPPRV_WBSEL_N2_3_SHIFT		22
+#define ISPPRV_WBSEL_N3_0_SHIFT		24
+#define ISPPRV_WBSEL_N3_1_SHIFT		26
+#define ISPPRV_WBSEL_N3_2_SHIFT		28
+#define ISPPRV_WBSEL_N3_3_SHIFT		30
+
+#define ISPPRV_CFA_GRADTH_HOR_SHIFT	0
+#define ISPPRV_CFA_GRADTH_VER_SHIFT	8
+
+#define ISPPRV_BLKADJOFF_B_SHIFT	0
+#define ISPPRV_BLKADJOFF_G_SHIFT	8
+#define ISPPRV_BLKADJOFF_R_SHIFT	16
+
+#define ISPPRV_RGB_MAT1_MTX_RR_SHIFT	0
+#define ISPPRV_RGB_MAT1_MTX_GR_SHIFT	16
+
+#define ISPPRV_RGB_MAT2_MTX_BR_SHIFT	0
+#define ISPPRV_RGB_MAT2_MTX_RG_SHIFT	16
+
+#define ISPPRV_RGB_MAT3_MTX_GG_SHIFT	0
+#define ISPPRV_RGB_MAT3_MTX_BG_SHIFT	16
+
+#define ISPPRV_RGB_MAT4_MTX_RB_SHIFT	0
+#define ISPPRV_RGB_MAT4_MTX_GB_SHIFT	16
+
+#define ISPPRV_RGB_MAT5_MTX_BB_SHIFT	0
+
+#define ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT	0
+#define ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT	16
+
+#define ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT	0
+
+#define ISPPRV_CSC0_RY_SHIFT		0
+#define ISPPRV_CSC0_GY_SHIFT		10
+#define ISPPRV_CSC0_BY_SHIFT		20
+
+#define ISPPRV_CSC1_RCB_SHIFT		0
+#define ISPPRV_CSC1_GCB_SHIFT		10
+#define ISPPRV_CSC1_BCB_SHIFT		20
+
+#define ISPPRV_CSC2_RCR_SHIFT		0
+#define ISPPRV_CSC2_GCR_SHIFT		10
+#define ISPPRV_CSC2_BCR_SHIFT		20
+
+#define ISPPRV_CSC_OFFSET_CR_SHIFT	0
+#define ISPPRV_CSC_OFFSET_CB_SHIFT	8
+#define ISPPRV_CSC_OFFSET_Y_SHIFT	16
+
+#define ISPPRV_CNT_BRT_BRT_SHIFT	0
+#define ISPPRV_CNT_BRT_CNT_SHIFT	8
+
+#define ISPPRV_CONTRAST_MAX		0x10
+#define ISPPRV_CONTRAST_MIN		0xFF
+#define ISPPRV_BRIGHT_MIN		0x00
+#define ISPPRV_BRIGHT_MAX		0xFF
+
+#define ISPPRV_CSUP_CSUPG_SHIFT		0
+#define ISPPRV_CSUP_THRES_SHIFT		8
+#define ISPPRV_CSUP_HPYF_SHIFT		16
+
+#define ISPPRV_SETUP_YC_MINC_SHIFT	0
+#define ISPPRV_SETUP_YC_MAXC_SHIFT	8
+#define ISPPRV_SETUP_YC_MINY_SHIFT	16
+#define ISPPRV_SETUP_YC_MAXY_SHIFT	24
+#define ISPPRV_YC_MAX			0xFF
+#define ISPPRV_YC_MIN			0x0
+
+/* Define bit fields within selected registers */
+#define ISP_REVISION_SHIFT			0
+
+#define ISP_SYSCONFIG_AUTOIDLE			0
+#define ISP_SYSCONFIG_SOFTRESET			(1 << 1)
+#define ISP_SYSCONFIG_MIDLEMODE_SHIFT		12
+#define ISP_SYSCONFIG_MIDLEMODE_FORCESTANDBY	0x0
+#define ISP_SYSCONFIG_MIDLEMODE_NOSTANBY	0x1
+#define ISP_SYSCONFIG_MIDLEMODE_SMARTSTANDBY	0x2
+
+#define ISP_SYSSTATUS_RESETDONE			0
+
+#define IRQ0ENABLE_CSIA_IRQ			1
+#define IRQ0ENABLE_CSIA_LC1_IRQ			(1 << 1)
+#define IRQ0ENABLE_CSIA_LC2_IRQ			(1 << 2)
+#define IRQ0ENABLE_CSIA_LC3_IRQ			(1 << 3)
+#define IRQ0ENABLE_CSIB_IRQ			(1 << 4)
+#define IRQ0ENABLE_CSIB_LC1_IRQ			(1 << 5)
+#define IRQ0ENABLE_CSIB_LC2_IRQ			(1 << 6)
+#define IRQ0ENABLE_CSIB_LC3_IRQ			(1 << 7)
+#define IRQ0ENABLE_CCDC_VD0_IRQ			(1 << 8)
+#define IRQ0ENABLE_CCDC_VD1_IRQ			(1 << 9)
+#define IRQ0ENABLE_CCDC_VD2_IRQ			(1 << 10)
+#define IRQ0ENABLE_CCDC_ERR_IRQ			(1 << 11)
+#define IRQ0ENABLE_H3A_AF_DONE_IRQ		(1 << 12)
+#define IRQ0ENABLE_H3A_AWB_DONE_IRQ		(1 << 13)
+#define IRQ0ENABLE_HIST_DONE_IRQ		(1 << 16)
+#define IRQ0ENABLE_CCDC_LSC_DONE_IRQ		(1 << 17)
+#define IRQ0ENABLE_CCDC_LSC_PREF_COMP_IRQ	(1 << 18)
+#define IRQ0ENABLE_CCDC_LSC_PREF_ERR_IRQ	(1 << 19)
+#define IRQ0ENABLE_PRV_DONE_IRQ			(1 << 20)
+#define IRQ0ENABLE_RSZ_DONE_IRQ			(1 << 24)
+#define IRQ0ENABLE_OVF_IRQ			(1 << 25)
+#define IRQ0ENABLE_PING_IRQ			(1 << 26)
+#define IRQ0ENABLE_PONG_IRQ			(1 << 27)
+#define IRQ0ENABLE_MMU_ERR_IRQ			(1 << 28)
+#define IRQ0ENABLE_OCP_ERR_IRQ			(1 << 29)
+#define IRQ0ENABLE_SEC_ERR_IRQ			(1 << 30)
+#define IRQ0ENABLE_HS_VS_IRQ			(1 << 31)
+
+#define IRQ0STATUS_CSIA_IRQ			1
+#define IRQ0STATUS_CSIA_LC1_IRQ			(1 << 1)
+#define IRQ0STATUS_CSIA_LC2_IRQ			(1 << 2)
+#define IRQ0STATUS_CSIA_LC3_IRQ			(1 << 3)
+#define IRQ0STATUS_CSIB_IRQ			(1 << 4)
+#define IRQ0STATUS_CSIB_LC1_IRQ			(1 << 5)
+#define IRQ0STATUS_CSIB_LC2_IRQ			(1 << 6)
+#define IRQ0STATUS_CSIB_LC3_IRQ			(1 << 7)
+#define IRQ0STATUS_CCDC_VD0_IRQ			(1 << 8)
+#define IRQ0STATUS_CCDC_VD1_IRQ			(1 << 9)
+#define IRQ0STATUS_CCDC_VD2_IRQ			(1 << 10)
+#define IRQ0STATUS_CCDC_ERR_IRQ			(1 << 11)
+#define IRQ0STATUS_H3A_AF_DONE_IRQ		(1 << 12)
+#define IRQ0STATUS_H3A_AWB_DONE_IRQ		(1 << 13)
+#define IRQ0STATUS_HIST_DONE_IRQ		(1 << 16)
+#define IRQ0STATUS_PRV_DONE_IRQ			(1 << 20)
+#define IRQ0STATUS_RSZ_DONE_IRQ			(1 << 24)
+#define IRQ0STATUS_OVF_IRQ			(1 << 25)
+#define IRQ0STATUS_PING_IRQ			(1 << 26)
+#define IRQ0STATUS_PONG_IRQ			(1 << 27)
+#define IRQ0STATUS_MMU_ERR_IRQ			(1 << 28)
+#define IRQ0STATUS_OCP_ERR_IRQ			(1 << 29)
+#define IRQ0STATUS_SEC_ERR_IRQ			(1 << 30)
+#define IRQ0STATUS_HS_VS_IRQ			(1 << 31)
+
+#define TCTRL_GRESET_LEN			0
+
+#define TCTRL_PSTRB_REPLAY_DELAY		0
+#define TCTRL_PSTRB_REPLAY_COUNTER_SHIFT	25
+
+#define ISPCTRL_PAR_SER_CLK_SEL_PARALLEL	0x0
+#define ISPCTRL_PAR_SER_CLK_SEL_CSIA		0x1
+#define ISPCTRL_PAR_SER_CLK_SEL_CSIB		0x2
+#define ISPCTRL_PAR_SER_CLK_SEL_MASK		0xFFFFFFFC
+
+#define ISPCTRL_PAR_BRIDGE_SHIFT		2
+#define ISPCTRL_PAR_BRIDGE_DISABLE		(0x0 << 2)
+#define ISPCTRL_PAR_BRIDGE_LENDIAN		(0x2 << 2)
+#define ISPCTRL_PAR_BRIDGE_BENDIAN		(0x3 << 2)
+
+#define ISPCTRL_PAR_CLK_POL_SHIFT		4
+#define ISPCTRL_PAR_CLK_POL_INV			(1 << 4)
+#define ISPCTRL_PING_PONG_EN			(1 << 5)
+#define ISPCTRL_SHIFT_SHIFT			6
+#define ISPCTRL_SHIFT_0				(0x0 << 6)
+#define ISPCTRL_SHIFT_2				(0x1 << 6)
+#define ISPCTRL_SHIFT_4				(0x2 << 6)
+#define ISPCTRL_SHIFT_MASK			(~(0x3 << 6))
+
+#define ISPCTRL_CCDC_CLK_EN			(1 << 8)
+#define ISPCTRL_SCMP_CLK_EN			(1 << 9)
+#define ISPCTRL_H3A_CLK_EN			(1 << 10)
+#define ISPCTRL_HIST_CLK_EN			(1 << 11)
+#define ISPCTRL_PREV_CLK_EN			(1 << 12)
+#define ISPCTRL_RSZ_CLK_EN			(1 << 13)
+#define ISPCTRL_SYNC_DETECT_SHIFT		14
+#define ISPCTRL_SYNC_DETECT_HSFALL	(0x0 << ISPCTRL_SYNC_DETECT_SHIFT)
+#define ISPCTRL_SYNC_DETECT_HSRISE	(0x1 << ISPCTRL_SYNC_DETECT_SHIFT)
+#define ISPCTRL_SYNC_DETECT_VSFALL	(0x2 << ISPCTRL_SYNC_DETECT_SHIFT)
+#define ISPCTRL_SYNC_DETECT_VSRISE	(0x3 << ISPCTRL_SYNC_DETECT_SHIFT)
+#define ISPCTRL_SYNC_DETECT_MASK	(0x3 << ISPCTRL_SYNC_DETECT_SHIFT)
+
+#define ISPCTRL_CCDC_RAM_EN		(1 << 16)
+#define ISPCTRL_PREV_RAM_EN		(1 << 17)
+#define ISPCTRL_SBL_RD_RAM_EN		(1 << 18)
+#define ISPCTRL_SBL_WR1_RAM_EN		(1 << 19)
+#define ISPCTRL_SBL_WR0_RAM_EN		(1 << 20)
+#define ISPCTRL_SBL_AUTOIDLE		(1 << 21)
+#define ISPCTRL_SBL_SHARED_RPORTB	(1 << 28)
+#define ISPCTRL_JPEG_FLUSH		(1 << 30)
+#define ISPCTRL_CCDC_FLUSH		(1 << 31)
+
+#define ISPSECURE_SECUREMODE		0
+
+#define ISPTCTRL_CTRL_DIV_LOW		0x0
+#define ISPTCTRL_CTRL_DIV_HIGH		0x1
+#define ISPTCTRL_CTRL_DIV_BYPASS	0x1F
+
+#define ISPTCTRL_CTRL_DIVA_SHIFT	0
+#define ISPTCTRL_CTRL_DIVA_MASK		(0x1F << ISPTCTRL_CTRL_DIVA_SHIFT)
+
+#define ISPTCTRL_CTRL_DIVB_SHIFT	5
+#define ISPTCTRL_CTRL_DIVB_MASK		(0x1F << ISPTCTRL_CTRL_DIVB_SHIFT)
+
+#define ISPTCTRL_CTRL_DIVC_SHIFT	10
+#define ISPTCTRL_CTRL_DIVC_NOCLOCK	(0x0 << 10)
+
+#define ISPTCTRL_CTRL_SHUTEN		(1 << 21)
+#define ISPTCTRL_CTRL_PSTRBEN		(1 << 22)
+#define ISPTCTRL_CTRL_STRBEN		(1 << 23)
+#define ISPTCTRL_CTRL_SHUTPOL		(1 << 24)
+#define ISPTCTRL_CTRL_STRBPSTRBPOL	(1 << 26)
+
+#define ISPTCTRL_CTRL_INSEL_SHIFT	27
+#define ISPTCTRL_CTRL_INSEL_PARALLEL	(0x0 << 27)
+#define ISPTCTRL_CTRL_INSEL_CSIA	(0x1 << 27)
+#define ISPTCTRL_CTRL_INSEL_CSIB	(0x2 << 27)
+
+#define ISPTCTRL_CTRL_GRESETEn		(1 << 29)
+#define ISPTCTRL_CTRL_GRESETPOL		(1 << 30)
+#define ISPTCTRL_CTRL_GRESETDIR		(1 << 31)
+
+#define ISPTCTRL_FRAME_SHUT_SHIFT		0
+#define ISPTCTRL_FRAME_PSTRB_SHIFT		6
+#define ISPTCTRL_FRAME_STRB_SHIFT		12
+
+#define ISPCCDC_PID_PREV_SHIFT			0
+#define ISPCCDC_PID_CID_SHIFT			8
+#define ISPCCDC_PID_TID_SHIFT			16
+
+#define ISPCCDC_PCR_EN				1
+#define ISPCCDC_PCR_BUSY			(1 << 1)
+
+#define ISPCCDC_SYN_MODE_VDHDOUT		0x1
+#define ISPCCDC_SYN_MODE_FLDOUT			(1 << 1)
+#define ISPCCDC_SYN_MODE_VDPOL			(1 << 2)
+#define ISPCCDC_SYN_MODE_HDPOL			(1 << 3)
+#define ISPCCDC_SYN_MODE_FLDPOL			(1 << 4)
+#define ISPCCDC_SYN_MODE_EXWEN			(1 << 5)
+#define ISPCCDC_SYN_MODE_DATAPOL		(1 << 6)
+#define ISPCCDC_SYN_MODE_FLDMODE		(1 << 7)
+#define ISPCCDC_SYN_MODE_DATSIZ_MASK		0xFFFFF8FF
+#define ISPCCDC_SYN_MODE_DATSIZ_8_16		(0x0 << 8)
+#define ISPCCDC_SYN_MODE_DATSIZ_12		(0x4 << 8)
+#define ISPCCDC_SYN_MODE_DATSIZ_11		(0x5 << 8)
+#define ISPCCDC_SYN_MODE_DATSIZ_10		(0x6 << 8)
+#define ISPCCDC_SYN_MODE_DATSIZ_8		(0x7 << 8)
+#define ISPCCDC_SYN_MODE_PACK8			(1 << 11)
+#define ISPCCDC_SYN_MODE_INPMOD_MASK		0xFFFFCFFF
+#define ISPCCDC_SYN_MODE_INPMOD_RAW		(0 << 12)
+#define ISPCCDC_SYN_MODE_INPMOD_YCBCR16		(1 << 12)
+#define ISPCCDC_SYN_MODE_INPMOD_YCBCR8		(2 << 12)
+#define ISPCCDC_SYN_MODE_LPF			(1 << 14)
+#define ISPCCDC_SYN_MODE_FLDSTAT		(1 << 15)
+#define ISPCCDC_SYN_MODE_VDHDEN			(1 << 16)
+#define ISPCCDC_SYN_MODE_WEN			(1 << 17)
+#define ISPCCDC_SYN_MODE_VP2SDR			(1 << 18)
+#define ISPCCDC_SYN_MODE_SDR2RSZ		(1 << 19)
+
+#define ISPCCDC_HD_VD_WID_VDW_SHIFT		0
+#define ISPCCDC_HD_VD_WID_HDW_SHIFT		16
+
+#define ISPCCDC_PIX_LINES_HLPRF_SHIFT		0
+#define ISPCCDC_PIX_LINES_PPLN_SHIFT		16
+
+#define ISPCCDC_HORZ_INFO_NPH_SHIFT		0
+#define ISPCCDC_HORZ_INFO_NPH_MASK		0xFFFF8000
+#define ISPCCDC_HORZ_INFO_SPH_MASK		0x1000FFFF
+#define ISPCCDC_HORZ_INFO_SPH_SHIFT		16
+
+#define ISPCCDC_VERT_START_SLV0_SHIFT		16
+#define ISPCCDC_VERT_START_SLV0_MASK		0x1000FFFF
+#define ISPCCDC_VERT_START_SLV1_SHIFT		0
+
+#define ISPCCDC_VERT_LINES_NLV_MASK		0xFFFF8000
+#define ISPCCDC_VERT_LINES_NLV_SHIFT		0
+
+#define ISPCCDC_CULLING_CULV_SHIFT		0
+#define ISPCCDC_CULLING_CULHODD_SHIFT		16
+#define ISPCCDC_CULLING_CULHEVN_SHIFT		24
+
+#define ISPCCDC_HSIZE_OFF_SHIFT			0
+
+#define ISPCCDC_SDOFST_FINV			(1 << 14)
+#define ISPCCDC_SDOFST_FOFST_1L			0
+#define ISPCCDC_SDOFST_FOFST_4L			(3 << 12)
+#define ISPCCDC_SDOFST_LOFST3_SHIFT		0
+#define ISPCCDC_SDOFST_LOFST2_SHIFT		3
+#define ISPCCDC_SDOFST_LOFST1_SHIFT		6
+#define ISPCCDC_SDOFST_LOFST0_SHIFT		9
+#define EVENEVEN				1
+#define ODDEVEN					2
+#define EVENODD					3
+#define ODDODD					4
+
+#define ISPCCDC_CLAMP_OBGAIN_SHIFT		0
+#define ISPCCDC_CLAMP_OBST_SHIFT		10
+#define ISPCCDC_CLAMP_OBSLN_SHIFT		25
+#define ISPCCDC_CLAMP_OBSLEN_SHIFT		28
+#define ISPCCDC_CLAMP_CLAMPEN			(1 << 31)
+
+#define ISPCCDC_COLPTN_R_Ye			0x0
+#define ISPCCDC_COLPTN_Gr_Cy			0x1
+#define ISPCCDC_COLPTN_Gb_G			0x2
+#define ISPCCDC_COLPTN_B_Mg			0x3
+#define ISPCCDC_COLPTN_CP0PLC0_SHIFT		0
+#define ISPCCDC_COLPTN_CP0PLC1_SHIFT		2
+#define ISPCCDC_COLPTN_CP0PLC2_SHIFT		4
+#define ISPCCDC_COLPTN_CP0PLC3_SHIFT		6
+#define ISPCCDC_COLPTN_CP1PLC0_SHIFT		8
+#define ISPCCDC_COLPTN_CP1PLC1_SHIFT		10
+#define ISPCCDC_COLPTN_CP1PLC2_SHIFT		12
+#define ISPCCDC_COLPTN_CP1PLC3_SHIFT		14
+#define ISPCCDC_COLPTN_CP2PLC0_SHIFT		16
+#define ISPCCDC_COLPTN_CP2PLC1_SHIFT		18
+#define ISPCCDC_COLPTN_CP2PLC2_SHIFT		20
+#define ISPCCDC_COLPTN_CP2PLC3_SHIFT		22
+#define ISPCCDC_COLPTN_CP3PLC0_SHIFT		24
+#define ISPCCDC_COLPTN_CP3PLC1_SHIFT		26
+#define ISPCCDC_COLPTN_CP3PLC2_SHIFT		28
+#define ISPCCDC_COLPTN_CP3PLC3_SHIFT		30
+
+#define ISPCCDC_BLKCMP_B_MG_SHIFT		0
+#define ISPCCDC_BLKCMP_GB_G_SHIFT		8
+#define ISPCCDC_BLKCMP_GR_CY_SHIFT		16
+#define ISPCCDC_BLKCMP_R_YE_SHIFT		24
+
+#define ISPCCDC_FPC_FPNUM_SHIFT			0
+#define ISPCCDC_FPC_FPCEN			(1 << 15)
+#define ISPCCDC_FPC_FPERR			(1 << 16)
+
+#define ISPCCDC_VDINT_1_SHIFT			0
+#define ISPCCDC_VDINT_0_SHIFT			16
+#define ISPCCDC_VDINT_0_MASK			0x7FFF
+#define ISPCCDC_VDINT_1_MASK			0x7FFF
+
+#define ISPCCDC_ALAW_GWDI_SHIFT			0
+#define ISPCCDC_ALAW_CCDTBL			(1 << 3)
+
+#define ISPCCDC_REC656IF_R656ON			1
+#define ISPCCDC_REC656IF_ECCFVH			(1 << 1)
+
+#define ISPCCDC_CFG_BW656			(1 << 5)
+#define ISPCCDC_CFG_FIDMD_SHIFT			6
+#define ISPCCDC_CFG_WENLOG			(1 << 8)
+#define ISPCCDC_CFG_WENLOG_AND			(0 << 8)
+#define ISPCCDC_CFG_WENLOG_OR		(1 << 8)
+#define ISPCCDC_CFG_Y8POS			(1 << 11)
+#define ISPCCDC_CFG_BSWD			(1 << 12)
+#define ISPCCDC_CFG_MSBINVI			(1 << 13)
+#define ISPCCDC_CFG_VDLC			(1 << 15)
+
+#define ISPCCDC_FMTCFG_FMTEN			0x1
+#define ISPCCDC_FMTCFG_LNALT			(1 << 1)
+#define ISPCCDC_FMTCFG_LNUM_SHIFT		2
+#define ISPCCDC_FMTCFG_PLEN_ODD_SHIFT		4
+#define ISPCCDC_FMTCFG_PLEN_EVEN_SHIFT		8
+#define ISPCCDC_FMTCFG_VPIN_MASK		0xFFFF8000
+#define ISPCCDC_FMTCFG_VPIN_12_3		(0x3 << 12)
+#define ISPCCDC_FMTCFG_VPIN_11_2		(0x4 << 12)
+#define ISPCCDC_FMTCFG_VPIN_10_1		(0x5 << 12)
+#define ISPCCDC_FMTCFG_VPIN_9_0			(0x6 << 12)
+#define ISPCCDC_FMTCFG_VPEN			(1 << 15)
+
+#define ISPCCDC_FMTCFG_VPIF_FRQ_MASK		0xFFF8FFFF
+#define ISPCCDC_FMTCFG_VPIF_FRQ_SHIFT		16
+#define ISPCCDC_FMTCFG_VPIF_FRQ_BY2		(0x0 << 16)
+#define ISPCCDC_FMTCFG_VPIF_FRQ_BY3		(0x1 << 16)
+#define ISPCCDC_FMTCFG_VPIF_FRQ_BY4		(0x2 << 16)
+#define ISPCCDC_FMTCFG_VPIF_FRQ_BY5		(0x3 << 16)
+#define ISPCCDC_FMTCFG_VPIF_FRQ_BY6		(0x4 << 16)
+
+#define ISPCCDC_FMT_HORZ_FMTLNH_SHIFT		0
+#define ISPCCDC_FMT_HORZ_FMTSPH_SHIFT		16
+
+#define ISPCCDC_FMT_VERT_FMTLNV_SHIFT		0
+#define ISPCCDC_FMT_VERT_FMTSLV_SHIFT		16
+
+#define ISPCCDC_FMT_HORZ_FMTSPH_MASK		0x1FFF0000
+#define ISPCCDC_FMT_HORZ_FMTLNH_MASK		0x1FFF
+
+#define ISPCCDC_FMT_VERT_FMTSLV_MASK		0x1FFF0000
+#define ISPCCDC_FMT_VERT_FMTLNV_MASK		0x1FFF
+
+#define ISPCCDC_VP_OUT_HORZ_ST_SHIFT		0
+#define ISPCCDC_VP_OUT_HORZ_NUM_SHIFT		4
+#define ISPCCDC_VP_OUT_VERT_NUM_SHIFT		17
+
+#define ISPRSZ_PID_PREV_SHIFT			0
+#define ISPRSZ_PID_CID_SHIFT			8
+#define ISPRSZ_PID_TID_SHIFT			16
+
+#define ISPRSZ_PCR_ENABLE			0x5
+#define ISPRSZ_PCR_BUSY				(1 << 1)
+
+#define ISPRSZ_CNT_HRSZ_SHIFT			0
+#define ISPRSZ_CNT_HRSZ_MASK			0x3FF
+#define ISPRSZ_CNT_VRSZ_SHIFT			10
+#define ISPRSZ_CNT_VRSZ_MASK			0xFFC00
+#define ISPRSZ_CNT_HSTPH_SHIFT			20
+#define ISPRSZ_CNT_HSTPH_MASK			0x700000
+#define ISPRSZ_CNT_VSTPH_SHIFT			23
+#define	ISPRSZ_CNT_VSTPH_MASK			0x3800000
+#define	ISPRSZ_CNT_CBILIN_MASK			0x20000000
+#define	ISPRSZ_CNT_INPTYP_MASK			0x08000000
+#define	ISPRSZ_CNT_PIXFMT_MASK			0x04000000
+#define ISPRSZ_CNT_YCPOS			(1 << 26)
+#define ISPRSZ_CNT_INPTYP			(1 << 27)
+#define ISPRSZ_CNT_INPSRC			(1 << 28)
+#define ISPRSZ_CNT_CBILIN			(1 << 29)
+
+#define ISPRSZ_OUT_SIZE_HORZ_SHIFT		0
+#define ISPRSZ_OUT_SIZE_HORZ_MASK		0x7FF
+#define ISPRSZ_OUT_SIZE_VERT_SHIFT		16
+#define ISPRSZ_OUT_SIZE_VERT_MASK		0x7FF0000
+
+
+#define ISPRSZ_IN_START_HORZ_ST_SHIFT		0
+#define ISPRSZ_IN_START_HORZ_ST_MASK		0x1FFF
+#define ISPRSZ_IN_START_VERT_ST_SHIFT		16
+#define ISPRSZ_IN_START_VERT_ST_MASK		0x1FFF0000
+
+
+#define ISPRSZ_IN_SIZE_HORZ_SHIFT		0
+#define ISPRSZ_IN_SIZE_HORZ_MASK		0x1FFF
+#define ISPRSZ_IN_SIZE_VERT_SHIFT		16
+#define ISPRSZ_IN_SIZE_VERT_MASK		0x1FFF0000
+
+#define ISPRSZ_SDR_INADD_ADDR_SHIFT		0
+#define ISPRSZ_SDR_INADD_ADDR_MASK		0xFFFFFFFF
+
+#define ISPRSZ_SDR_INOFF_OFFSET_SHIFT		0
+#define ISPRSZ_SDR_INOFF_OFFSET_MASK		0xFFFF
+
+#define ISPRSZ_SDR_OUTADD_ADDR_SHIFT		0
+#define ISPRSZ_SDR_OUTADD_ADDR_MASK		0xFFFFFFFF
+
+
+#define ISPRSZ_SDR_OUTOFF_OFFSET_SHIFT		0
+#define ISPRSZ_SDR_OUTOFF_OFFSET_MASK		0xFFFF
+
+#define ISPRSZ_HFILT10_COEF0_SHIFT		0
+#define ISPRSZ_HFILT10_COEF0_MASK		0x3FF
+#define ISPRSZ_HFILT10_COEF1_SHIFT		16
+#define ISPRSZ_HFILT10_COEF1_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT32_COEF2_SHIFT		0
+#define ISPRSZ_HFILT32_COEF2_MASK		0x3FF
+#define ISPRSZ_HFILT32_COEF3_SHIFT		16
+#define ISPRSZ_HFILT32_COEF3_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT54_COEF4_SHIFT		0
+#define ISPRSZ_HFILT54_COEF4_MASK		0x3FF
+#define ISPRSZ_HFILT54_COEF5_SHIFT		16
+#define ISPRSZ_HFILT54_COEF5_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT76_COEFF6_SHIFT		0
+#define ISPRSZ_HFILT76_COEFF6_MASK		0x3FF
+#define ISPRSZ_HFILT76_COEFF7_SHIFT		16
+#define ISPRSZ_HFILT76_COEFF7_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT98_COEFF8_SHIFT		0
+#define ISPRSZ_HFILT98_COEFF8_MASK		0x3FF
+#define ISPRSZ_HFILT98_COEFF9_SHIFT		16
+#define ISPRSZ_HFILT98_COEFF9_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT1110_COEF10_SHIFT		0
+#define ISPRSZ_HFILT1110_COEF10_MASK		0x3FF
+#define ISPRSZ_HFILT1110_COEF11_SHIFT		16
+#define ISPRSZ_HFILT1110_COEF11_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT1312_COEFF12_SHIFT		0
+#define ISPRSZ_HFILT1312_COEFF12_MASK		0x3FF
+#define ISPRSZ_HFILT1312_COEFF13_SHIFT		16
+#define ISPRSZ_HFILT1312_COEFF13_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT1514_COEFF14_SHIFT		0
+#define ISPRSZ_HFILT1514_COEFF14_MASK		0x3FF
+#define ISPRSZ_HFILT1514_COEFF15_SHIFT		16
+#define ISPRSZ_HFILT1514_COEFF15_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT1716_COEF16_SHIFT		0
+#define ISPRSZ_HFILT1716_COEF16_MASK		0x3FF
+#define ISPRSZ_HFILT1716_COEF17_SHIFT		16
+#define ISPRSZ_HFILT1716_COEF17_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT1918_COEF18_SHIFT		0
+#define ISPRSZ_HFILT1918_COEF18_MASK		0x3FF
+#define ISPRSZ_HFILT1918_COEF19_SHIFT		16
+#define ISPRSZ_HFILT1918_COEF19_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT2120_COEF20_SHIFT		0
+#define ISPRSZ_HFILT2120_COEF20_MASK		0x3FF
+#define ISPRSZ_HFILT2120_COEF21_SHIFT		16
+#define ISPRSZ_HFILT2120_COEF21_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT2322_COEF22_SHIFT		0
+#define ISPRSZ_HFILT2322_COEF22_MASK		0x3FF
+#define ISPRSZ_HFILT2322_COEF23_SHIFT		16
+#define ISPRSZ_HFILT2322_COEF23_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT2524_COEF24_SHIFT		0
+#define ISPRSZ_HFILT2524_COEF24_MASK		0x3FF
+#define ISPRSZ_HFILT2524_COEF25_SHIFT		16
+#define ISPRSZ_HFILT2524_COEF25_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT2726_COEF26_SHIFT		0
+#define ISPRSZ_HFILT2726_COEF26_MASK		0x3FF
+#define ISPRSZ_HFILT2726_COEF27_SHIFT		16
+#define ISPRSZ_HFILT2726_COEF27_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT2928_COEF28_SHIFT		0
+#define ISPRSZ_HFILT2928_COEF28_MASK		0x3FF
+#define ISPRSZ_HFILT2928_COEF29_SHIFT		16
+#define ISPRSZ_HFILT2928_COEF29_MASK		0x3FF0000
+
+#define ISPRSZ_HFILT3130_COEF30_SHIFT		0
+#define ISPRSZ_HFILT3130_COEF30_MASK		0x3FF
+#define ISPRSZ_HFILT3130_COEF31_SHIFT		16
+#define ISPRSZ_HFILT3130_COEF31_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT10_COEF0_SHIFT		0
+#define ISPRSZ_VFILT10_COEF0_MASK		0x3FF
+#define ISPRSZ_VFILT10_COEF1_SHIFT		16
+#define ISPRSZ_VFILT10_COEF1_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT32_COEF2_SHIFT		0
+#define ISPRSZ_VFILT32_COEF2_MASK		0x3FF
+#define ISPRSZ_VFILT32_COEF3_SHIFT		16
+#define ISPRSZ_VFILT32_COEF3_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT54_COEF4_SHIFT		0
+#define ISPRSZ_VFILT54_COEF4_MASK		0x3FF
+#define ISPRSZ_VFILT54_COEF5_SHIFT		16
+#define ISPRSZ_VFILT54_COEF5_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT76_COEFF6_SHIFT		0
+#define ISPRSZ_VFILT76_COEFF6_MASK		0x3FF
+#define ISPRSZ_VFILT76_COEFF7_SHIFT		16
+#define ISPRSZ_VFILT76_COEFF7_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT98_COEFF8_SHIFT		0
+#define ISPRSZ_VFILT98_COEFF8_MASK		0x3FF
+#define ISPRSZ_VFILT98_COEFF9_SHIFT		16
+#define ISPRSZ_VFILT98_COEFF9_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT1110_COEF10_SHIFT		0
+#define ISPRSZ_VFILT1110_COEF10_MASK		0x3FF
+#define ISPRSZ_VFILT1110_COEF11_SHIFT		16
+#define ISPRSZ_VFILT1110_COEF11_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT1312_COEFF12_SHIFT		0
+#define ISPRSZ_VFILT1312_COEFF12_MASK		0x3FF
+#define ISPRSZ_VFILT1312_COEFF13_SHIFT		16
+#define ISPRSZ_VFILT1312_COEFF13_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT1514_COEFF14_SHIFT		0
+#define ISPRSZ_VFILT1514_COEFF14_MASK		0x3FF
+#define ISPRSZ_VFILT1514_COEFF15_SHIFT		16
+#define ISPRSZ_VFILT1514_COEFF15_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT1716_COEF16_SHIFT		0
+#define ISPRSZ_VFILT1716_COEF16_MASK		0x3FF
+#define ISPRSZ_VFILT1716_COEF17_SHIFT		16
+#define ISPRSZ_VFILT1716_COEF17_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT1918_COEF18_SHIFT		0
+#define ISPRSZ_VFILT1918_COEF18_MASK		0x3FF
+#define ISPRSZ_VFILT1918_COEF19_SHIFT		16
+#define ISPRSZ_VFILT1918_COEF19_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT2120_COEF20_SHIFT		0
+#define ISPRSZ_VFILT2120_COEF20_MASK		0x3FF
+#define ISPRSZ_VFILT2120_COEF21_SHIFT		16
+#define ISPRSZ_VFILT2120_COEF21_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT2322_COEF22_SHIFT		0
+#define ISPRSZ_VFILT2322_COEF22_MASK		0x3FF
+#define ISPRSZ_VFILT2322_COEF23_SHIFT		16
+#define ISPRSZ_VFILT2322_COEF23_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT2524_COEF24_SHIFT		0
+#define ISPRSZ_VFILT2524_COEF24_MASK		0x3FF
+#define ISPRSZ_VFILT2524_COEF25_SHIFT		16
+#define ISPRSZ_VFILT2524_COEF25_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT2726_COEF26_SHIFT		0
+#define ISPRSZ_VFILT2726_COEF26_MASK		0x3FF
+#define ISPRSZ_VFILT2726_COEF27_SHIFT		16
+#define ISPRSZ_VFILT2726_COEF27_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT2928_COEF28_SHIFT		0
+#define ISPRSZ_VFILT2928_COEF28_MASK		0x3FF
+#define ISPRSZ_VFILT2928_COEF29_SHIFT		16
+#define ISPRSZ_VFILT2928_COEF29_MASK		0x3FF0000
+
+#define ISPRSZ_VFILT3130_COEF30_SHIFT		0
+#define ISPRSZ_VFILT3130_COEF30_MASK		0x3FF
+#define ISPRSZ_VFILT3130_COEF31_SHIFT		16
+#define ISPRSZ_VFILT3130_COEF31_MASK		0x3FF0000
+
+#define ISPRSZ_YENH_CORE_SHIFT			0
+#define ISPRSZ_YENH_CORE_MASK			0xFF
+#define ISPRSZ_YENH_SLOP_SHIFT			8
+#define ISPRSZ_YENH_SLOP_MASK			0xF00
+#define ISPRSZ_YENH_GAIN_SHIFT			12
+#define ISPRSZ_YENH_GAIN_MASK			0xF000
+#define ISPRSZ_YENH_ALGO_SHIFT			16
+#define ISPRSZ_YENH_ALGO_MASK			0x30000
+
+#define ISPH3A_PCR_AEW_ALAW_EN_SHIFT		1
+#define ISPH3A_PCR_AF_MED_TH_SHIFT		3
+#define ISPH3A_PCR_AF_RGBPOS_SHIFT		11
+#define ISPH3A_PCR_AEW_AVE2LMT_SHIFT		22
+#define ISPH3A_PCR_AEW_AVE2LMT_MASK		0xFFC00000
+#define ISPH3A_PCR_BUSYAF			(1 << 15)
+#define ISPH3A_PCR_BUSYAEAWB			(1 << 18)
+
+#define ISPH3A_AEWWIN1_WINHC_SHIFT		0
+#define ISPH3A_AEWWIN1_WINHC_MASK		0x3F
+#define ISPH3A_AEWWIN1_WINVC_SHIFT		6
+#define ISPH3A_AEWWIN1_WINVC_MASK		0x1FC0
+#define ISPH3A_AEWWIN1_WINW_SHIFT		13
+#define ISPH3A_AEWWIN1_WINW_MASK		0xFE000
+#define ISPH3A_AEWWIN1_WINH_SHIFT		24
+#define ISPH3A_AEWWIN1_WINH_MASK		0x7F000000
+
+#define ISPH3A_AEWINSTART_WINSH_SHIFT		0
+#define ISPH3A_AEWINSTART_WINSH_MASK		0x0FFF
+#define ISPH3A_AEWINSTART_WINSV_SHIFT		16
+#define ISPH3A_AEWINSTART_WINSV_MASK		0x0FFF0000
+
+#define ISPH3A_AEWINBLK_WINH_SHIFT		0
+#define ISPH3A_AEWINBLK_WINH_MASK		0x7F
+#define ISPH3A_AEWINBLK_WINSV_SHIFT		16
+#define ISPH3A_AEWINBLK_WINSV_MASK		0x0FFF0000
+
+#define ISPH3A_AEWSUBWIN_AEWINCH_SHIFT		0
+#define ISPH3A_AEWSUBWIN_AEWINCH_MASK		0x0F
+#define ISPH3A_AEWSUBWIN_AEWINCV_SHIFT		8
+#define ISPH3A_AEWSUBWIN_AEWINCV_MASK		0x0F00
+
+#define ISPHIST_PCR_ENABLE_SHIFT	0
+#define ISPHIST_PCR_ENABLE_MASK		0x01
+#define ISPHIST_PCR_BUSY		0x02
+
+#define ISPHIST_CNT_DATASIZE_SHIFT	8
+#define ISPHIST_CNT_DATASIZE_MASK	0x0100
+#define ISPHIST_CNT_CLEAR_SHIFT		7
+#define ISPHIST_CNT_CLEAR_MASK		0x080
+#define ISPHIST_CNT_CFA_SHIFT		6
+#define ISPHIST_CNT_CFA_MASK		0x040
+#define ISPHIST_CNT_BINS_SHIFT		4
+#define ISPHIST_CNT_BINS_MASK		0x030
+#define ISPHIST_CNT_SOURCE_SHIFT	3
+#define ISPHIST_CNT_SOURCE_MASK		0x08
+#define ISPHIST_CNT_SHIFT_SHIFT		0
+#define ISPHIST_CNT_SHIFT_MASK		0x07
+
+#define ISPHIST_WB_GAIN_WG00_SHIFT	24
+#define ISPHIST_WB_GAIN_WG00_MASK	0xFF000000
+#define ISPHIST_WB_GAIN_WG01_SHIFT	16
+#define ISPHIST_WB_GAIN_WG01_MASK	0xFF0000
+#define ISPHIST_WB_GAIN_WG02_SHIFT	8
+#define ISPHIST_WB_GAIN_WG02_MASK	0xFF00
+#define ISPHIST_WB_GAIN_WG03_SHIFT	0
+#define ISPHIST_WB_GAIN_WG03_MASK	0xFF
+
+#define ISPHIST_REGHORIZ_HSTART_SHIFT		16	/*
+							 * REGION 0 to 3 HORZ
+							 * and VERT
+							 */
+#define ISPHIST_REGHORIZ_HSTART_MASK		0x3FFF0000
+#define ISPHIST_REGHORIZ_HEND_SHIFT		0
+#define ISPHIST_REGHORIZ_HEND_MASK		0x3FFF
+#define ISPHIST_REGVERT_VSTART_SHIFT		16
+#define ISPHIST_REGVERT_VSTART_MASK		0x3FFF0000
+#define ISPHIST_REGVERT_VEND_SHIFT		0
+#define ISPHIST_REGVERT_VEND_MASK		0x3FFF
+
+#define ISPHIST_REGHORIZ_MASK			0x3FFF3FFF
+#define ISPHIST_REGVERT_MASK			0x3FFF3FFF
+
+#define ISPHIST_ADDR_SHIFT			0
+#define ISPHIST_ADDR_MASK			0x3FF
+
+#define ISPHIST_DATA_SHIFT			0
+#define ISPHIST_DATA_MASK			0xFFFFF
+
+#define ISPHIST_RADD_SHIFT			0
+#define ISPHIST_RADD_MASK			0xFFFFFFFF
+
+#define ISPHIST_RADD_OFF_SHIFT			0
+#define ISPHIST_RADD_OFF_MASK			0xFFFF
+
+#define ISPHIST_HV_INFO_HSIZE_SHIFT		16
+#define ISPHIST_HV_INFO_HSIZE_MASK		0x3FFF0000
+#define ISPHIST_HV_INFO_VSIZE_SHIFT		0
+#define ISPHIST_HV_INFO_VSIZE_MASK		0x3FFF
+
+#define ISPHIST_HV_INFO_MASK			0x3FFF3FFF
+
+#define ISPCCDC_LSC_GAIN_MODE_N_MASK		0x700
+#define ISPCCDC_LSC_GAIN_MODE_N_SHIFT		8
+#define ISPCCDC_LSC_GAIN_MODE_M_MASK		0x3800
+#define ISPCCDC_LSC_GAIN_MODE_M_SHIFT		12
+#define ISPCCDC_LSC_GAIN_FORMAT_MASK		0xE
+#define ISPCCDC_LSC_GAIN_FORMAT_SHIFT		1
+#define ISPCCDC_LSC_AFTER_REFORMATTER_MASK	(1<<6)
+
+#define ISPCCDC_LSC_INITIAL_X_MASK		0x3F
+#define ISPCCDC_LSC_INITIAL_X_SHIFT		0
+#define ISPCCDC_LSC_INITIAL_Y_MASK		0x3F0000
+#define ISPCCDC_LSC_INITIAL_Y_SHIFT		16
+
+#define ISPMMU_REVISION_REV_MINOR_MASK		0xF
+#define ISPMMU_REVISION_REV_MAJOR_SHIFT		0x4
+
+#define IRQENABLE_MULTIHITFAULT			(1<<4)
+#define IRQENABLE_TWFAULT			(1<<3)
+#define IRQENABLE_EMUMISS			(1<<2)
+#define IRQENABLE_TRANSLNFAULT			(1<<1)
+#define IRQENABLE_TLBMISS			(1)
+
+#define ISPMMU_MMUCNTL_MMU_EN			(1<<1)
+#define ISPMMU_MMUCNTL_TWL_EN			(1<<2)
+#define ISPMMU_MMUCNTL_EMUTLBUPDATE		(1<<3)
+#define ISPMMU_AUTOIDLE				0x1
+#define ISPMMU_SIDLEMODE_FORCEIDLE		0
+#define ISPMMU_SIDLEMODE_NOIDLE			1
+#define ISPMMU_SIDLEMODE_SMARTIDLE		2
+#define ISPMMU_SIDLEMODE_SHIFT			3
+
+#define ISPCSI1_AUTOIDLE			0x1
+#define ISPCSI1_MIDLEMODE_SHIFT			12
+#define ISPCSI1_MIDLEMODE_FORCESTANDBY		0x0
+#define ISPCSI1_MIDLEMODE_NOSTANDBY		0x1
+#define ISPCSI1_MIDLEMODE_SMARTSTANDBY		0x2
+
+/* CSI2 receiver registers (ES2.0) */
+#define ISPCSI2_REVISION			(0x000)
+#define ISPCSI2_SYSCONFIG			(0x010)
+#define ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SHIFT	12
+#define ISPCSI2_SYSCONFIG_MSTANDBY_MODE_MASK		\
+	(0x3 << ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SHIFT)
+#define ISPCSI2_SYSCONFIG_MSTANDBY_MODE_FORCE		\
+	(0x0 << ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SHIFT)
+#define ISPCSI2_SYSCONFIG_MSTANDBY_MODE_NO		\
+	(0x1 << ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SHIFT)
+#define ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SMART		\
+	(0x2 << ISPCSI2_SYSCONFIG_MSTANDBY_MODE_SHIFT)
+#define ISPCSI2_SYSCONFIG_SOFT_RESET_SHIFT	1
+#define ISPCSI2_SYSCONFIG_SOFT_RESET_MASK		\
+	(0x1 << ISPCSI2_SYSCONFIG_SOFT_RESET_SHIFT)
+#define ISPCSI2_SYSCONFIG_SOFT_RESET_NORMAL		\
+	(0x0 << ISPCSI2_SYSCONFIG_SOFT_RESET_SHIFT)
+#define ISPCSI2_SYSCONFIG_SOFT_RESET_RESET		\
+	(0x1 << ISPCSI2_SYSCONFIG_SOFT_RESET_SHIFT)
+#define ISPCSI2_SYSCONFIG_AUTO_IDLE_SHIFT	0
+#define ISPCSI2_SYSCONFIG_AUTO_IDLE_MASK		\
+	(0x1 << ISPCSI2_SYSCONFIG_AUTO_IDLE_SHIFT)
+#define ISPCSI2_SYSCONFIG_AUTO_IDLE_FREE		\
+	(0x0 << ISPCSI2_SYSCONFIG_AUTO_IDLE_SHIFT)
+#define ISPCSI2_SYSCONFIG_AUTO_IDLE_AUTO		\
+	(0x1 << ISPCSI2_SYSCONFIG_AUTO_IDLE_SHIFT)
+#define ISPCSI2_SYSSTATUS			(0x014)
+#define ISPCSI2_SYSSTATUS_RESET_DONE_SHIFT	0
+#define ISPCSI2_SYSSTATUS_RESET_DONE_MASK		\
+	(0x1 << ISPCSI2_SYSSTATUS_RESET_DONE_SHIFT)
+#define ISPCSI2_SYSSTATUS_RESET_DONE_ONGOING		\
+	(0x0 << ISPCSI2_SYSSTATUS_RESET_DONE_SHIFT)
+#define ISPCSI2_SYSSTATUS_RESET_DONE_DONE		\
+	(0x1 << ISPCSI2_SYSSTATUS_RESET_DONE_SHIFT)
+#define ISPCSI2_IRQSTATUS				(0x018)
+#define ISPCSI2_IRQSTATUS_OCP_ERR_IRQ			(1 << 14)
+#define ISPCSI2_IRQSTATUS_SHORT_PACKET_IRQ		(1 << 13)
+#define ISPCSI2_IRQSTATUS_ECC_CORRECTION_IRQ		(1 << 12)
+#define ISPCSI2_IRQSTATUS_ECC_NO_CORRECTION_IRQ		(1 << 11)
+#define ISPCSI2_IRQSTATUS_COMPLEXIO2_ERR_IRQ		(1 << 10)
+#define ISPCSI2_IRQSTATUS_COMPLEXIO1_ERR_IRQ		(1 << 9)
+#define ISPCSI2_IRQSTATUS_FIFO_OVF_IRQ			(1 << 8)
+#define ISPCSI2_IRQSTATUS_CONTEXT(n)			(1 << (n))
+
+#define ISPCSI2_IRQENABLE			(0x01C)
+#define ISPCSI2_CTRL				(0x040)
+#define ISPCSI2_CTRL_VP_CLK_EN_SHIFT	15
+#define ISPCSI2_CTRL_VP_CLK_EN_MASK	(0x1 << ISPCSI2_CTRL_VP_CLK_EN_SHIFT)
+#define ISPCSI2_CTRL_VP_CLK_EN_DISABLE	(0x0 << ISPCSI2_CTRL_VP_CLK_EN_SHIFT)
+#define ISPCSI2_CTRL_VP_CLK_EN_ENABLE	(0x1 << ISPCSI2_CTRL_VP_CLK_EN_SHIFT)
+
+#define ISPCSI2_CTRL_VP_ONLY_EN_SHIFT	11
+#define ISPCSI2_CTRL_VP_ONLY_EN_MASK	(0x1 << ISPCSI2_CTRL_VP_ONLY_EN_SHIFT)
+#define ISPCSI2_CTRL_VP_ONLY_EN_DISABLE	(0x0 << ISPCSI2_CTRL_VP_ONLY_EN_SHIFT)
+#define ISPCSI2_CTRL_VP_ONLY_EN_ENABLE	(0x1 << ISPCSI2_CTRL_VP_ONLY_EN_SHIFT)
+
+#define ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT		8
+#define ISPCSI2_CTRL_VP_OUT_CTRL_MASK	(0x3 <<				\
+					 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT)
+#define ISPCSI2_CTRL_VP_OUT_CTRL_DISABLE	(0x0 <<			\
+						 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT)
+#define ISPCSI2_CTRL_VP_OUT_CTRL_DIV2	(0x1 <<				\
+					 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT)
+#define ISPCSI2_CTRL_VP_OUT_CTRL_DIV3	(0x2 <<			\
+					 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT)
+#define ISPCSI2_CTRL_VP_OUT_CTRL_DIV4	(0x3 <<			\
+					 ISPCSI2_CTRL_VP_OUT_CTRL_SHIFT)
+
+#define ISPCSI2_CTRL_DBG_EN_SHIFT	7
+#define ISPCSI2_CTRL_DBG_EN_MASK	(0x1 << ISPCSI2_CTRL_DBG_EN_SHIFT)
+#define ISPCSI2_CTRL_DBG_EN_DISABLE	(0x0 << ISPCSI2_CTRL_DBG_EN_SHIFT)
+#define ISPCSI2_CTRL_DBG_EN_ENABLE	(0x1 << ISPCSI2_CTRL_DBG_EN_SHIFT)
+
+#define ISPCSI2_CTRL_BURST_SIZE_SHIFT	5
+#define ISPCSI2_CTRL_BURST_SIZE_MASK	(0x3 <<			\
+					 ISPCSI2_CTRL_BURST_SIZE_SHIFT)
+#define ISPCSI2_CTRL_BURST_SIZE_MYSTERY_VAL	(0x2 <<		\
+						 ISPCSI2_CTRL_BURST_SIZE_SHIFT)
+
+#define ISPCSI2_CTRL_FRAME_SHIFT	3
+#define ISPCSI2_CTRL_FRAME_MASK		(0x1 << ISPCSI2_CTRL_FRAME_SHIFT)
+#define ISPCSI2_CTRL_FRAME_DISABLE_IMM	(0x0 << ISPCSI2_CTRL_FRAME_SHIFT)
+#define ISPCSI2_CTRL_FRAME_DISABLE_FEC	(0x1 << ISPCSI2_CTRL_FRAME_SHIFT)
+
+#define ISPCSI2_CTRL_ECC_EN_SHIFT	2
+#define ISPCSI2_CTRL_ECC_EN_MASK	(0x1 << ISPCSI2_CTRL_ECC_EN_SHIFT)
+#define ISPCSI2_CTRL_ECC_EN_DISABLE	(0x0 << ISPCSI2_CTRL_ECC_EN_SHIFT)
+#define ISPCSI2_CTRL_ECC_EN_ENABLE	(0x1 << ISPCSI2_CTRL_ECC_EN_SHIFT)
+
+#define ISPCSI2_CTRL_SECURE_SHIFT	1
+#define ISPCSI2_CTRL_SECURE_MASK	(0x1 << ISPCSI2_CTRL_SECURE_SHIFT)
+#define ISPCSI2_CTRL_SECURE_DISABLE	(0x0 << ISPCSI2_CTRL_SECURE_SHIFT)
+#define ISPCSI2_CTRL_SECURE_ENABLE	(0x1 << ISPCSI2_CTRL_SECURE_SHIFT)
+
+#define ISPCSI2_CTRL_IF_EN_SHIFT	0
+#define ISPCSI2_CTRL_IF_EN_MASK		(0x1 << ISPCSI2_CTRL_IF_EN_SHIFT)
+#define ISPCSI2_CTRL_IF_EN_DISABLE	(0x0 << ISPCSI2_CTRL_IF_EN_SHIFT)
+#define ISPCSI2_CTRL_IF_EN_ENABLE	(0x1 << ISPCSI2_CTRL_IF_EN_SHIFT)
+
+#define ISPCSI2_DBG_H				(0x044)
+#define ISPCSI2_GNQ				(0x048)
+#define ISPCSI2_COMPLEXIO_CFG1			(0x050)
+#define ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_SHIFT		29
+#define ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_MASK			\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_ONGOING		\
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_DONE			\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_RESET_DONE_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_SHIFT		27
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_MASK		\
+	(0x3 << ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_OFF		\
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ON		\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_ULPW		\
+	(0x2 << ISPCSI2_COMPLEXIO_CFG1_PWR_CMD_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_SHIFT		25
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_MASK			\
+	(0x3 << ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_OFF			\
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ON			\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_ULPW			\
+	(0x2 << ISPCSI2_COMPLEXIO_CFG1_PWR_STATUS_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_SHIFT		24
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_MASK		\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_DISABLE		\
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_ENABLE		\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_PWR_AUTO_SHIFT)
+
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(n)	(3 + ((n) * 4))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POL_MASK(n) \
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POL_PN(n) \
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POL_NP(n) \
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_DATA_POL_SHIFT(n))
+
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n)	((n) * 4)
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_MASK(n) \
+	(0x7 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_NC(n) \
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_1(n) \
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_2(n) \
+	(0x2 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_3(n) \
+	(0x3 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_4(n) \
+	(0x4 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+#define ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_5(n) \
+	(0x5 << ISPCSI2_COMPLEXIO_CFG1_DATA_POSITION_SHIFT(n))
+
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT		3
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_MASK		\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_PN		\
+	(0x0 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_NP		\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POL_SHIFT)
+
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT		0
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_MASK		\
+	(0x7 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_1			\
+	(0x1 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_2			\
+	(0x2 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_3			\
+	(0x3 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_4			\
+	(0x4 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+#define ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_5			\
+	(0x5 << ISPCSI2_COMPLEXIO_CFG1_CLOCK_POSITION_SHIFT)
+
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS			(0x054)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEALLULPMEXIT	(1 << 26)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEALLULPMENTER	(1 << 25)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEULPM5		(1 << 24)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEULPM4		(1 << 23)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEULPM3		(1 << 22)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEULPM2		(1 << 21)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_STATEULPM1		(1 << 20)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRCONTROL5	(1 << 19)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRCONTROL4	(1 << 18)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRCONTROL3	(1 << 17)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRCONTROL2	(1 << 16)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRCONTROL1	(1 << 15)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRESC5		(1 << 14)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRESC4		(1 << 13)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRESC3		(1 << 12)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRESC2		(1 << 11)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRESC1		(1 << 10)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTSYNCHS5	(1 << 9)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTSYNCHS4	(1 << 8)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTSYNCHS3	(1 << 7)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTSYNCHS2	(1 << 6)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTSYNCHS1	(1 << 5)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTHS5		(1 << 4)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTHS4		(1 << 3)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTHS3		(1 << 2)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTHS2		(1 << 1)
+#define ISPCSI2_COMPLEXIO1_IRQSTATUS_ERRSOTHS1		1
+
+#define ISPCSI2_SHORT_PACKET		(0x05C)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE			(0x060)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEALLULPMEXIT	(1 << 26)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEALLULPMENTER	(1 << 25)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM5		(1 << 24)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM4		(1 << 23)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM3		(1 << 22)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM2		(1 << 21)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_STATEULPM1		(1 << 20)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL5	(1 << 19)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL4	(1 << 18)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL3	(1 << 17)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL2	(1 << 16)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRCONTROL1	(1 << 15)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC5		(1 << 14)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC4		(1 << 13)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC3		(1 << 12)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC2		(1 << 11)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRESC1		(1 << 10)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS5	(1 << 9)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS4	(1 << 8)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS3	(1 << 7)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS2	(1 << 6)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTSYNCHS1	(1 << 5)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS5		(1 << 4)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS4		(1 << 3)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS3		(1 << 2)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS2		(1 << 1)
+#define ISPCSI2_COMPLEXIO1_IRQENABLE_ERRSOTHS1		1
+#define ISPCSI2_DBG_P			(0x068)
+#define ISPCSI2_TIMING			(0x06C)
+
+
+#define ISPCSI2_TIMING_FORCE_RX_MODE_IO_SHIFT(n) \
+	((16 * ((n) - 1)) + 15)
+#define ISPCSI2_TIMING_FORCE_RX_MODE_IO_MASK(n) \
+	(0x1 << ISPCSI2_TIMING_FORCE_RX_MODE_IO_SHIFT(n))
+#define ISPCSI2_TIMING_FORCE_RX_MODE_IO_DISABLE(n) \
+	(0x0 << ISPCSI2_TIMING_FORCE_RX_MODE_IO_SHIFT(n))
+#define ISPCSI2_TIMING_FORCE_RX_MODE_IO_ENABLE(n) \
+	(0x1 << ISPCSI2_TIMING_FORCE_RX_MODE_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X16_IO_SHIFT(n)	((16 * ((n) - 1)) + 14)
+#define ISPCSI2_TIMING_STOP_STATE_X16_IO_MASK(n) \
+	(0x1 << ISPCSI2_TIMING_STOP_STATE_X16_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X16_IO_DISABLE(n) \
+	(0x0 << ISPCSI2_TIMING_STOP_STATE_X16_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X16_IO_ENABLE(n) \
+	(0x1 << ISPCSI2_TIMING_STOP_STATE_X16_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X4_IO_SHIFT(n)	((16 * ((n) - 1)) + 13)
+#define ISPCSI2_TIMING_STOP_STATE_X4_IO_MASK(n)	\
+	(0x1 << ISPCSI2_TIMING_STOP_STATE_X4_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X4_IO_DISABLE(n) \
+	(0x0 << ISPCSI2_TIMING_STOP_STATE_X4_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_X4_IO_ENABLE(n) \
+	(0x1 << ISPCSI2_TIMING_STOP_STATE_X4_IO_SHIFT(n))
+#define ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(n)	(16 * ((n) - 1))
+#define ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_MASK(n) \
+	(0x1fff << ISPCSI2_TIMING_STOP_STATE_COUNTER_IO_SHIFT(n))
+
+#define ISPCSI2_CTX_CTRL1(n)		((0x070) + 0x20 * (n))
+#define ISPCSI2_CTX_CTRL1_COUNT_SHIFT		8
+#define ISPCSI2_CTX_CTRL1_COUNT_MASK		(0xFF <<		\
+						 ISPCSI2_CTX_CTRL1_COUNT_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOF_EN_SHIFT		7
+#define ISPCSI2_CTX_CTRL1_EOF_EN_MASK \
+	(0x1 << ISPCSI2_CTX_CTRL1_EOF_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOF_EN_DISABLE \
+	(0x0 << ISPCSI2_CTX_CTRL1_EOF_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOF_EN_ENABLE	\
+	(0x1 << ISPCSI2_CTX_CTRL1_EOF_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOL_EN_SHIFT		6
+#define ISPCSI2_CTX_CTRL1_EOL_EN_MASK \
+	(0x1 << ISPCSI2_CTX_CTRL1_EOL_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOL_EN_DISABLE \
+	(0x0 << ISPCSI2_CTX_CTRL1_EOL_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_EOL_EN_ENABLE \
+	(0x1 << ISPCSI2_CTX_CTRL1_EOL_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CS_EN_SHIFT		5
+#define ISPCSI2_CTX_CTRL1_CS_EN_MASK \
+	(0x1 << ISPCSI2_CTX_CTRL1_CS_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CS_EN_DISABLE \
+	(0x0 << ISPCSI2_CTX_CTRL1_CS_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CS_EN_ENABLE \
+	(0x1 << ISPCSI2_CTX_CTRL1_CS_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_SHIFT		4
+#define ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_MASK \
+	(0x1 <<	ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_DISABLE \
+	(0x0 <<	ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_ENABLE \
+	(0x1 << ISPCSI2_CTX_CTRL1_COUNT_UNLOCK_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_PING_PONG_SHIFT	3
+#define ISPCSI2_CTX_CTRL1_PING_PONG_MASK \
+	(0x1 <<	ISPCSI2_CTX_CTRL1_PING_PONG_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CTX_EN_SHIFT		0
+#define ISPCSI2_CTX_CTRL1_CTX_EN_MASK \
+	(0x1 << ISPCSI2_CTX_CTRL1_CTX_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CTX_EN_DISABLE \
+	(0x0 <<	ISPCSI2_CTX_CTRL1_CTX_EN_SHIFT)
+#define ISPCSI2_CTX_CTRL1_CTX_EN_ENABLE \
+	(0x1 <<	ISPCSI2_CTX_CTRL1_CTX_EN_SHIFT)
+
+#define ISPCSI2_CTX_CTRL2(n)		((0x074) + 0x20 * (n))
+#define ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT	11
+#define ISPCSI2_CTX_CTRL2_VIRTUAL_ID_MASK \
+	(0x3 <<	ISPCSI2_CTX_CTRL2_VIRTUAL_ID_SHIFT)
+#define ISPCSI2_CTX_CTRL2_FORMAT_SHIFT	0
+#define ISPCSI2_CTX_CTRL2_FORMAT_MASK	(0x3FF <<			\
+					 ISPCSI2_CTX_CTRL2_FORMAT_SHIFT)
+
+#define ISPCSI2_CTX_DAT_OFST(n)		((0x078) + 0x20 * (n))
+#define ISPCSI2_CTX_DAT_OFST_OFST_SHIFT	5
+#define ISPCSI2_CTX_DAT_OFST_OFST_MASK	(0x7FF <<			\
+					 ISPCSI2_CTX_DAT_OFST_OFST_SHIFT)
+
+#define ISPCSI2_CTX_DAT_PING_ADDR(n)	((0x07C) + 0x20 * (n))
+#define ISPCSI2_CTX_DAT_PONG_ADDR(n)	((0x080) + 0x20 * (n))
+#define ISPCSI2_CTX_IRQENABLE(n)	((0x084) + 0x20 * (n))
+#define ISPCSI2_CTX_IRQENABLE_ECC_CORRECTION_IRQ		(1 << 8)
+#define ISPCSI2_CTX_IRQENABLE_LINE_NUMBER_IRQ		(1 << 7)
+#define ISPCSI2_CTX_IRQENABLE_FRAME_NUMBER_IRQ		(1 << 6)
+#define ISPCSI2_CTX_IRQENABLE_CS_IRQ			(1 << 5)
+#define ISPCSI2_CTX_IRQENABLE_LE_IRQ			(1 << 3)
+#define ISPCSI2_CTX_IRQENABLE_LS_IRQ			(1 << 2)
+#define ISPCSI2_CTX_IRQENABLE_FE_IRQ			(1 << 1)
+#define ISPCSI2_CTX_IRQENABLE_FS_IRQ			1
+#define ISPCSI2_CTX_IRQSTATUS(n)	((0x088) + 0x20 * (n))
+#define ISPCSI2_CTX_IRQSTATUS_ECC_CORRECTION_IRQ		(1 << 8)
+#define ISPCSI2_CTX_IRQSTATUS_LINE_NUMBER_IRQ		(1 << 7)
+#define ISPCSI2_CTX_IRQSTATUS_FRAME_NUMBER_IRQ		(1 << 6)
+#define ISPCSI2_CTX_IRQSTATUS_CS_IRQ			(1 << 5)
+#define ISPCSI2_CTX_IRQSTATUS_LE_IRQ			(1 << 3)
+#define ISPCSI2_CTX_IRQSTATUS_LS_IRQ			(1 << 2)
+#define ISPCSI2_CTX_IRQSTATUS_FE_IRQ			(1 << 1)
+#define ISPCSI2_CTX_IRQSTATUS_FS_IRQ			1
+
+#define ISPCSI2_CTX_CTRL3(n)		((0x08C) + 0x20 * (n))
+#define ISPCSI2_CTX_CTRL3_ALPHA_SHIFT	5
+#define ISPCSI2_CTX_CTRL3_ALPHA_MASK	(0x3FFF <<			\
+					 ISPCSI2_CTX_CTRL3_ALPHA_SHIFT)
+
+#define ISPCSI2PHY_CFG0				(0x000)
+#define ISPCSI2PHY_CFG0_THS_TERM_SHIFT		8
+#define ISPCSI2PHY_CFG0_THS_TERM_MASK			\
+	(0xFF << ISPCSI2PHY_CFG0_THS_TERM_SHIFT)
+#define ISPCSI2PHY_CFG0_THS_TERM_RESETVAL		\
+	(0x04 << ISPCSI2PHY_CFG0_THS_TERM_SHIFT)
+#define ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT		0
+#define ISPCSI2PHY_CFG0_THS_SETTLE_MASK			\
+	(0xFF << ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT)
+#define ISPCSI2PHY_CFG0_THS_SETTLE_RESETVAL		\
+	(0x27 << ISPCSI2PHY_CFG0_THS_SETTLE_SHIFT)
+#define ISPCSI2PHY_CFG1				(0x004)
+#define ISPCSI2PHY_CFG1_RESETDONECTRLCLK_SHIFT		29
+#define ISPCSI2PHY_CFG1_RESETDONECTRLCLK_MASK		\
+	(0x1 << ISPCSI2PHY_CFG1_RESETDONECTRLCLK_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT		18
+#define ISPCSI2PHY_CFG1_TCLK_TERM_MASK			\
+	(0x7F << ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_TERM__RESETVAL		\
+	(0x00 << ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT)
+#define ISPCSI2PHY_CFG1_RESERVED1_SHIFT		10
+#define ISPCSI2PHY_CFG1_RESERVED1_MASK			\
+	(0xFF << ISPCSI2PHY_CFG1_RESERVED1_SHIFT)
+#define ISPCSI2PHY_CFG1_RESERVED1__RESETVAL		\
+	(0xB8 << ISPCSI2PHY_CFG1_RESERVED1_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT		8
+#define ISPCSI2PHY_CFG1_TCLK_MISS_MASK			\
+	(0x3 << ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_MISS__RESETVAL		\
+	(0x1 << ISPCSI2PHY_CFG1_TCLK_MISS_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_SETTLE_SHIFT		0
+#define ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK		\
+	(0xFF << ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT)
+#define ISPCSI2PHY_CFG1_TCLK_SETTLE__RESETVAL		\
+	(0x0E << ISPCSI2PHY_CFG1_TCLK_TERM_SHIFT)
+#define ISPCSI2PHY_CFG1__RESETVAL	(ISPCSI2PHY_CFG1_TCLK_TERM__RESETVAL | \
+					 ISPCSI2PHY_CFG1_RESERVED1__RESETVAL | \
+					 ISPCSI2PHY_CFG1_TCLK_MISS__RESETVAL | \
+					 ISPCSI2PHY_CFG1_TCLK_SETTLE__RESETVAL)
+#define ISPCSI2PHY_CFG1__EDITABLE_MASK	(ISPCSI2PHY_CFG1_TCLK_TERM_MASK | \
+					 ISPCSI2PHY_CFG1_RESERVED1_MASK | \
+					 ISPCSI2PHY_CFG1_TCLK_MISS_MASK | \
+					 ISPCSI2PHY_CFG1_TCLK_SETTLE_MASK)
+
+#endif	/* __ISPREG_H__ */
diff --git a/drivers/media/video/isp/ispresizer.c b/drivers/media/video/isp/ispresizer.c
new file mode 100644
index 0000000..08c0903
--- /dev/null
+++ b/drivers/media/video/isp/ispresizer.c
@@ -0,0 +1,925 @@
+/*
+ * ispresizer.c
+ *
+ * Driver Library for Resizer module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C)2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sameer Venkatraman <sameerv@ti.com>
+ *	Mohit Jalori
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "ispresizer.h"
+
+#define omap_rev_is_1_0() (GET_OMAP_REVISION() == 0x00)
+/* Default configuration of resizer,filter coefficients,yenh for camera isp */
+static struct isprsz_coef ispreszdefcoef = {
+	{
+		0x0000, 0x0100, 0x0000, 0x0000,
+		0x03FA, 0x00F6, 0x0010, 0x0000,
+		0x03F9, 0x00DB, 0x002C, 0x0000,
+		0x03FB, 0x00B3, 0x0053, 0x03FF,
+		0x03FD, 0x0082, 0x0084, 0x03FD,
+		0x03FF, 0x0053, 0x00B3, 0x03FB,
+		0x0000, 0x002C, 0x00DB, 0x03F9,
+		0x0000, 0x0010, 0x00F6, 0x03FA
+	},
+	{
+		0x0000, 0x0100, 0x0000, 0x0000,
+		0x03FA, 0x00F6, 0x0010, 0x0000,
+		0x03F9, 0x00DB, 0x002C, 0x0000,
+		0x03FB, 0x00B3, 0x0053, 0x03FF,
+		0x03FD, 0x0082, 0x0084, 0x03FD,
+		0x03FF, 0x0053, 0x00B3, 0x03FB,
+		0x0000, 0x002C, 0x00DB, 0x03F9,
+		0x0000, 0x0010, 0x00F6, 0x03FA
+	},
+	{
+		0x0004, 0x0023, 0x005A, 0x0058,
+		0x0023, 0x0004, 0x0000, 0x0002,
+		0x0018, 0x004d, 0x0060, 0x0031,
+		0x0008, 0x0000, 0x0001, 0x000f,
+		0x003f, 0x0062, 0x003f, 0x000f,
+		0x0001, 0x0000, 0x0008, 0x0031,
+		0x0060, 0x004d, 0x0018, 0x0002
+	},
+	{
+		0x0004, 0x0023, 0x005A, 0x0058,
+		0x0023, 0x0004, 0x0000, 0x0002,
+		0x0018, 0x004d, 0x0060, 0x0031,
+		0x0008, 0x0000, 0x0001, 0x000f,
+		0x003f, 0x0062, 0x003f, 0x000f,
+		0x0001, 0x0000, 0x0008, 0x0031,
+		0x0060, 0x004d, 0x0018, 0x0002
+	}
+};
+
+/* Structure for saving/restoring resizer module registers */
+static struct isp_reg isprsz_reg_list[] = {
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_OUT_SIZE, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_SIZE, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT10, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT32, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT54, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT76, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT98, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT1110, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT1312, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT1514, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT1716, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT1918, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT2120, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT2322, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT2524, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT2726, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT2928, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_HFILT3130, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT10, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT32, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT54, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT76, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT98, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT1110, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT1312, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT1514, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT1716, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT1918, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT2120, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT2322, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT2524, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT2726, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT2928, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_VFILT3130, 0x0000},
+	{OMAP3_ISP_IOMEM_RESZ, ISPRSZ_YENH, 0x0000},
+	{0, ISP_TOK_TERM, 0x0000}
+};
+
+/**
+ * ispresizer_applycrop - Apply crop to input image.
+ **/
+void ispresizer_applycrop(struct isp_res_device *isp_res)
+{
+	struct isp_device *isp =
+		container_of(isp_res, struct isp_device, isp_res);
+	if (!isp_res->applycrop)
+		return;
+
+	ispresizer_s_pipeline(isp_res, &isp->pipeline);
+
+	isp_res->applycrop = 0;
+
+	return;
+}
+
+/**
+ * ispresizer_config_shadow_registers - Configure shadow registers.
+ **/
+void ispresizer_config_shadow_registers(struct isp_res_device *isp_res)
+{
+	ispresizer_applycrop(isp_res);
+
+	return;
+}
+EXPORT_SYMBOL(ispresizer_config_shadow_registers);
+
+int ispresizer_config_crop(struct isp_res_device *isp_res,
+			   struct v4l2_crop *a)
+{
+	struct isp_device *isp =
+		container_of(isp_res, struct isp_device, isp_res);
+	struct v4l2_crop *crop = a;
+	int rval;
+
+	if (crop->c.left < 0)
+		crop->c.left = 0;
+	if (crop->c.width < 0)
+		crop->c.width = 0;
+	if (crop->c.top < 0)
+		crop->c.top = 0;
+	if (crop->c.height < 0)
+		crop->c.height = 0;
+
+	if (crop->c.left >= isp->pipeline.prv_out_w_img)
+		crop->c.left = isp->pipeline.prv_out_w_img - 1;
+	if (crop->c.top >= isp->pipeline.rsz_out_h)
+		crop->c.top = isp->pipeline.rsz_out_h - 1;
+
+	/* Make sure the crop rectangle is never smaller than width
+	 * and height divided by 4, since the resizer cannot upscale it
+	 * by more than 4x. */
+
+	if (crop->c.width < (isp->pipeline.rsz_out_w + 3) / 4)
+		crop->c.width = (isp->pipeline.rsz_out_w + 3) / 4;
+	if (crop->c.height < (isp->pipeline.rsz_out_h + 3) / 4)
+		crop->c.height = (isp->pipeline.rsz_out_h + 3) / 4;
+
+	if (crop->c.left + crop->c.width > isp->pipeline.prv_out_w_img)
+		crop->c.width = isp->pipeline.prv_out_w_img - crop->c.left;
+	if (crop->c.top + crop->c.height > isp->pipeline.rsz_out_h)
+		crop->c.height =
+			isp->pipeline.prv_out_h - crop->c.top;
+
+	isp->pipeline.rsz_crop = crop->c;
+
+	rval = ispresizer_try_pipeline(isp_res, &isp->pipeline);
+	if (rval)
+		return rval;
+
+	isp_res->applycrop = 1;
+
+	if (isp->running == ISP_STOPPED)
+		ispresizer_applycrop(isp_res);
+
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_config_crop);
+
+/**
+ * ispresizer_request - Reserves the Resizer module.
+ *
+ * Allows only one user at a time.
+ *
+ * Returns 0 if successful, or -EBUSY if resizer module was already requested.
+ **/
+int ispresizer_request(struct isp_res_device *isp_res)
+{
+	mutex_lock(&isp_res->ispres_mutex);
+	if (!isp_res->res_inuse) {
+		isp_res->res_inuse = 1;
+		mutex_unlock(&isp_res->ispres_mutex);
+		isp_reg_writel(isp_res->dev,
+			       isp_reg_readl(isp_res->dev,
+					     OMAP3_ISP_IOMEM_MAIN, ISP_CTRL) |
+			       ISPCTRL_SBL_WR0_RAM_EN |
+			       ISPCTRL_RSZ_CLK_EN,
+			       OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+		return 0;
+	} else {
+		mutex_unlock(&isp_res->ispres_mutex);
+		dev_err(isp_res->dev, "resizer: Module Busy\n");
+		return -EBUSY;
+	}
+}
+EXPORT_SYMBOL(ispresizer_request);
+
+/**
+ * ispresizer_free - Makes Resizer module free.
+ *
+ * Returns 0 if successful, or -EINVAL if resizer module was already freed.
+ **/
+int ispresizer_free(struct isp_res_device *isp_res)
+{
+	mutex_lock(&isp_res->ispres_mutex);
+	if (isp_res->res_inuse) {
+		isp_res->res_inuse = 0;
+		mutex_unlock(&isp_res->ispres_mutex);
+		isp_reg_and(isp_res->dev, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL,
+			    ~(ISPCTRL_RSZ_CLK_EN | ISPCTRL_SBL_WR0_RAM_EN));
+		return 0;
+	} else {
+		mutex_unlock(&isp_res->ispres_mutex);
+		DPRINTK_ISPRESZ("ISP_ERR : Resizer Module already freed\n");
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL(ispresizer_free);
+
+/**
+ * ispresizer_config_datapath - Specifies which input to use in resizer module
+ * @input: Indicates the module that gives the image to resizer.
+ *
+ * Sets up the default resizer configuration according to the arguments.
+ *
+ * Returns 0 if successful, or -EINVAL if an unsupported input was requested.
+ **/
+int ispresizer_config_datapath(struct isp_res_device *isp_res,
+			       struct isp_pipeline *pipe)
+{
+	u32 cnt = 0;
+
+	DPRINTK_ISPRESZ("ispresizer_config_datapath()+\n");
+
+	switch (pipe->rsz_in) {
+	case RSZ_OTFLY_YUV:
+		cnt &= ~ISPRSZ_CNT_INPTYP;
+		cnt &= ~ISPRSZ_CNT_INPSRC;
+		ispresizer_set_inaddr(isp_res, 0);
+		ispresizer_config_inlineoffset(isp_res, 0);
+		break;
+	case RSZ_MEM_YUV:
+		cnt |= ISPRSZ_CNT_INPSRC;
+		cnt &= ~ISPRSZ_CNT_INPTYP;
+		break;
+	case RSZ_MEM_COL8:
+		cnt |= ISPRSZ_CNT_INPSRC;
+		cnt |= ISPRSZ_CNT_INPTYP;
+		break;
+	default:
+		dev_err(isp_res->dev, "resizer: Wrong Input\n");
+		return -EINVAL;
+	}
+	isp_reg_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT, cnt);
+	ispresizer_config_ycpos(isp_res, 0);
+	ispresizer_config_filter_coef(isp_res, &ispreszdefcoef);
+	ispresizer_enable_cbilin(isp_res, 0);
+	ispresizer_config_luma_enhance(isp_res, &isp_res->defaultyenh);
+	DPRINTK_ISPRESZ("ispresizer_config_datapath()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_config_datapath);
+
+/**
+ * ispresizer_try_size - Validates input and output images size.
+ * @input_w: input width for the resizer in number of pixels per line
+ * @input_h: input height for the resizer in number of lines
+ * @output_w: output width from the resizer in number of pixels per line
+ *            resizer when writing to memory needs this to be multiple of 16.
+ * @pipe->rsz_out_h: output height for the resizer in number of lines, must be
+ *		     even.
+ *
+ * Calculates the horizontal and vertical resize ratio, number of pixels to
+ * be cropped in the resizer module and checks the validity of various
+ * parameters. Formula used for calculation is:-
+ *
+ * 8-phase 4-tap mode :-
+ * inputwidth = (32 * sph + (ow - 1) * hrsz + 16) >> 8 + 7
+ * inputheight = (32 * spv + (oh - 1) * vrsz + 16) >> 8 + 4
+ * endpahse for width = ((32 * sph + (ow - 1) * hrsz + 16) >> 5) % 8
+ * endphase for height = ((32 * sph + (oh - 1) * hrsz + 16) >> 5) % 8
+ *
+ * 4-phase 7-tap mode :-
+ * inputwidth = (64 * sph + (ow - 1) * hrsz + 32) >> 8 + 7
+ * inputheight = (64 * spv + (oh - 1) * vrsz + 32) >> 8 + 7
+ * endpahse for width = ((64 * sph + (ow - 1) * hrsz + 32) >> 6) % 4
+ * endphase for height = ((64 * sph + (oh - 1) * hrsz + 32) >> 6) % 4
+ *
+ * Where:
+ * sph = Start phase horizontal
+ * spv = Start phase vertical
+ * ow = Output width
+ * oh = Output height
+ * hrsz = Horizontal resize value
+ * vrsz = Vertical resize value
+ *
+ * Fills up the output/input widht/height, horizontal/vertical resize ratio,
+ * horizontal/vertical crop variables in the isp_res structure.
+ **/
+int ispresizer_try_pipeline(struct isp_res_device *isp_res,
+			    struct isp_pipeline *pipe)
+{
+	u32 rsz, rsz_7, rsz_4;
+	u32 sph;
+	int max_in_otf, max_out_7tap;
+
+	if (pipe->rsz_crop.width < 32 || pipe->rsz_crop.height < 32) {
+		DPRINTK_ISPCCDC("ISP_ERR: RESIZER cannot handle input width"
+				" less than 32 pixels or height less than"
+				" 32\n");
+		return -EINVAL;
+	}
+
+	if (pipe->rsz_crop.height > MAX_IN_HEIGHT)
+		return -EINVAL;
+
+	if (pipe->rsz_out_w < 16)
+		pipe->rsz_out_w = 16;
+
+	if (pipe->rsz_out_h < 2)
+		pipe->rsz_out_h = 2;
+
+	if (!cpu_is_omap3630() && cpu_is_omap34xx() && omap_rev_is_1_0()) {
+		max_in_otf = MAX_IN_WIDTH_ONTHEFLY_MODE;
+		max_out_7tap = MAX_7TAP_VRSZ_OUTWIDTH;
+	} else {
+		max_in_otf = MAX_IN_WIDTH_ONTHEFLY_MODE_ES2;
+		max_out_7tap = MAX_7TAP_VRSZ_OUTWIDTH_ES2;
+	}
+
+	if (pipe->rsz_in == RSZ_OTFLY_YUV) {
+		if (pipe->rsz_crop.width > max_in_otf)
+			return -EINVAL;
+	} else {
+		if (pipe->rsz_crop.width > MAX_IN_WIDTH_MEMORY_MODE)
+			return -EINVAL;
+	}
+
+	pipe->rsz_out_h &= 0xfffffffe;
+	sph = DEFAULTSTPHASE;
+
+	rsz_7 = ((pipe->rsz_crop.height - 7) * 256) / (pipe->rsz_out_h - 1);
+	rsz_4 = ((pipe->rsz_crop.height - 4) * 256) / (pipe->rsz_out_h - 1);
+
+	rsz = (pipe->rsz_crop.height * 256) / pipe->rsz_out_h;
+
+	if (rsz <= MID_RESIZE_VALUE) {
+		rsz = rsz_4;
+		if (rsz < MINIMUM_RESIZE_VALUE) {
+			rsz = MINIMUM_RESIZE_VALUE;
+			pipe->rsz_out_h =
+				(((pipe->rsz_crop.height - 4) * 256) / rsz) + 1;
+			dev_dbg(isp_res->dev,
+				"resizer: %s: using height %d instead\n",
+				__func__, pipe->rsz_out_h);
+		}
+	} else {
+		rsz = rsz_7;
+		if (pipe->rsz_out_w > max_out_7tap)
+			pipe->rsz_out_w = max_out_7tap;
+		if (rsz > MAXIMUM_RESIZE_VALUE) {
+			rsz = MAXIMUM_RESIZE_VALUE;
+			pipe->rsz_out_h =
+				(((pipe->rsz_crop.height - 7) * 256) / rsz) + 1;
+			dev_dbg(isp_res->dev,
+				"resizer: %s: using height %d instead\n",
+				__func__, pipe->rsz_out_h);
+		}
+	}
+
+	if (rsz > MID_RESIZE_VALUE) {
+		pipe->rsz_crop.height =
+			(((64 * sph) + ((pipe->rsz_out_h - 1) * rsz) + 32)
+			 / 256) + 7;
+	} else {
+		pipe->rsz_crop.height =
+			(((32 * sph) + ((pipe->rsz_out_h - 1) * rsz) + 16)
+			 / 256) + 4;
+	}
+
+	isp_res->v_resz = rsz;
+	/* FIXME: pipe->rsz_crop.height here is the real input height! */
+	isp_res->v_startphase = sph;
+
+	pipe->rsz_out_w &= 0xfffffff0;
+	sph = DEFAULTSTPHASE;
+
+	rsz_7 = ((pipe->rsz_crop.width - 7) * 256) / (pipe->rsz_out_w - 1);
+	rsz_4 = ((pipe->rsz_crop.width - 4) * 256) / (pipe->rsz_out_w - 1);
+
+	rsz = (pipe->rsz_crop.width * 256) / pipe->rsz_out_w;
+	if (rsz > MID_RESIZE_VALUE) {
+		rsz = rsz_7;
+		if (rsz > MAXIMUM_RESIZE_VALUE) {
+			rsz = MAXIMUM_RESIZE_VALUE;
+			pipe->rsz_out_w =
+				(((pipe->rsz_crop.width - 7) * 256) / rsz) + 1;
+			pipe->rsz_out_w = (pipe->rsz_out_w + 0xf) & 0xfffffff0;
+			dev_dbg(isp_res->dev,
+				"resizer: %s: using width %d instead\n",
+				__func__, pipe->rsz_out_w);
+		}
+	} else {
+		rsz = rsz_4;
+		if (rsz < MINIMUM_RESIZE_VALUE) {
+			rsz = MINIMUM_RESIZE_VALUE;
+			pipe->rsz_out_w =
+				(((pipe->rsz_crop.width - 4) * 256) / rsz) + 1;
+			pipe->rsz_out_w = (pipe->rsz_out_w + 0xf) & 0xfffffff0;
+			dev_dbg(isp_res->dev,
+				"resizer: %s: using width %d instead\n",
+				__func__, pipe->rsz_out_w);
+		}
+	}
+
+	/* Recalculate input based on TRM equations */
+	if (rsz > MID_RESIZE_VALUE) {
+		pipe->rsz_crop.width =
+			(((64 * sph) + ((pipe->rsz_out_w - 1) * rsz) + 32)
+			 / 256) + 7;
+	} else {
+		pipe->rsz_crop.width =
+			(((32 * sph) + ((pipe->rsz_out_w - 1) * rsz) + 16)
+			 / 256) + 7;
+	}
+
+	isp_res->h_resz = rsz;
+	/* FIXME: pipe->rsz_crop.width here is the real input width! */
+	isp_res->h_startphase = sph;
+
+	pipe->rsz_out_w_img = pipe->rsz_out_w;
+
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_try_pipeline);
+
+/**
+ * ispresizer_config_size - Configures input and output image size.
+ * @pipe->rsz_crop.width: input width for the resizer in number of pixels per
+ *			  line.
+ * @pipe->rsz_crop.height: input height for the resizer in number of lines.
+ * @pipe->rsz_out_w: output width from the resizer in number of pixels per line.
+ * @pipe->rsz_out_h: output height for the resizer in number of lines.
+ *
+ * Configures the appropriate values stored in the isp_res structure in the
+ * resizer registers.
+ *
+ * Returns 0 if successful, or -EINVAL if passed values haven't been verified
+ * with ispresizer_try_size() previously.
+ **/
+int ispresizer_s_pipeline(struct isp_res_device *isp_res,
+			  struct isp_pipeline *pipe)
+{
+	int i, j;
+	u32 res;
+	int rval;
+
+	rval = ispresizer_config_datapath(isp_res, pipe);
+	if (rval)
+		return rval;
+
+	/* Set Resizer input address and offset adderss */
+	ispresizer_config_inlineoffset(isp_res,
+				       pipe->prv_out_w * ISP_BYTES_PER_PIXEL);
+
+	res = isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
+		~(ISPRSZ_CNT_HSTPH_MASK | ISPRSZ_CNT_VSTPH_MASK);
+	isp_reg_writel(isp_res->dev, res |
+		       (isp_res->h_startphase << ISPRSZ_CNT_HSTPH_SHIFT) |
+		       (isp_res->v_startphase << ISPRSZ_CNT_VSTPH_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ,
+		       ISPRSZ_CNT);
+	/* Set start address for cropping */
+	ispresizer_set_inaddr(isp_res, isp_res->tmp_buf);
+
+	isp_reg_writel(isp_res->dev,
+		       (pipe->rsz_crop.width << ISPRSZ_IN_SIZE_HORZ_SHIFT) |
+		       (pipe->rsz_crop.height <<
+			ISPRSZ_IN_SIZE_VERT_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ,
+		       ISPRSZ_IN_SIZE);
+	if (!isp_res->algo) {
+		isp_reg_writel(isp_res->dev,
+			       (pipe->rsz_out_w << ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
+			       (pipe->rsz_out_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
+			       OMAP3_ISP_IOMEM_RESZ,
+			       ISPRSZ_OUT_SIZE);
+	} else {
+		isp_reg_writel(isp_res->dev,
+			       ((pipe->rsz_out_w - 4)
+				<< ISPRSZ_OUT_SIZE_HORZ_SHIFT) |
+			       (pipe->rsz_out_h << ISPRSZ_OUT_SIZE_VERT_SHIFT),
+			       OMAP3_ISP_IOMEM_RESZ,
+			       ISPRSZ_OUT_SIZE);
+	}
+
+	res = isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT) &
+		~(ISPRSZ_CNT_HRSZ_MASK | ISPRSZ_CNT_VRSZ_MASK);
+	isp_reg_writel(isp_res->dev, res |
+		       ((isp_res->h_resz - 1) << ISPRSZ_CNT_HRSZ_SHIFT) |
+		       ((isp_res->v_resz - 1) << ISPRSZ_CNT_VRSZ_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ,
+		       ISPRSZ_CNT);
+	if (isp_res->h_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			isp_reg_writel(isp_res->dev,
+				(isp_res->coeflist.h_filter_coef_4tap[j]
+				 << ISPRSZ_HFILT10_COEF0_SHIFT) |
+				(isp_res->coeflist.h_filter_coef_4tap[j + 1]
+				 << ISPRSZ_HFILT10_COEF1_SHIFT),
+				OMAP3_ISP_IOMEM_RESZ,
+				ISPRSZ_HFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
+				isp_reg_writel(isp_res->dev,
+					       (isp_res->coeflist.
+						h_filter_coef_7tap[j] <<
+						ISPRSZ_HFILT10_COEF0_SHIFT),
+					       OMAP3_ISP_IOMEM_RESZ,
+					       ISPRSZ_HFILT10 + (i * 0x04));
+				j += 1;
+			} else {
+				isp_reg_writel(isp_res->dev,
+					       (isp_res->coeflist.
+						h_filter_coef_7tap[j] <<
+						ISPRSZ_HFILT10_COEF0_SHIFT) |
+					       (isp_res->coeflist.
+						h_filter_coef_7tap[j+1] <<
+						ISPRSZ_HFILT10_COEF1_SHIFT),
+					       OMAP3_ISP_IOMEM_RESZ,
+					       ISPRSZ_HFILT10 + (i * 0x04));
+				j += 2;
+			}
+		}
+	}
+	if (isp_res->v_resz <= MID_RESIZE_VALUE) {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			isp_reg_writel(isp_res->dev, (isp_res->coeflist.
+					v_filter_coef_4tap[j] <<
+					ISPRSZ_VFILT10_COEF0_SHIFT) |
+				       (isp_res->coeflist.
+					v_filter_coef_4tap[j + 1] <<
+					ISPRSZ_VFILT10_COEF1_SHIFT),
+				       OMAP3_ISP_IOMEM_RESZ,
+				       ISPRSZ_VFILT10 + (i * 0x04));
+			j += 2;
+		}
+	} else {
+		j = 0;
+		for (i = 0; i < 16; i++) {
+			if ((i + 1) % 4 == 0) {
+				isp_reg_writel(isp_res->dev,
+					       (isp_res->coeflist.
+						v_filter_coef_7tap[j] <<
+						ISPRSZ_VFILT10_COEF0_SHIFT),
+					       OMAP3_ISP_IOMEM_RESZ,
+					       ISPRSZ_VFILT10 + (i * 0x04));
+				j += 1;
+			} else {
+				isp_reg_writel(isp_res->dev,
+					       (isp_res->coeflist.
+						v_filter_coef_7tap[j] <<
+						ISPRSZ_VFILT10_COEF0_SHIFT) |
+					       (isp_res->coeflist.
+						v_filter_coef_7tap[j+1] <<
+						ISPRSZ_VFILT10_COEF1_SHIFT),
+					       OMAP3_ISP_IOMEM_RESZ,
+					       ISPRSZ_VFILT10 + (i * 0x04));
+				j += 2;
+			}
+		}
+	}
+
+	ispresizer_config_outlineoffset(isp_res, pipe->rsz_out_w*2);
+
+	if (pipe->pix.pixelformat == V4L2_PIX_FMT_UYVY)
+		ispresizer_config_ycpos(isp_res, 0);
+	else
+		ispresizer_config_ycpos(isp_res, 1);
+
+	DPRINTK_ISPRESZ("ispresizer_config_size()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_s_pipeline);
+
+/**
+ * ispresizer_enable - Enables the resizer module.
+ * @enable: 1 - Enable, 0 - Disable
+ *
+ * Client should configure all the sub modules in resizer before this.
+ **/
+void ispresizer_enable(struct isp_res_device *isp_res, int enable)
+{
+	int val;
+	DPRINTK_ISPRESZ("+ispresizer_enable()+\n");
+	if (enable) {
+		val = (isp_reg_readl(isp_res->dev,
+				     OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) & 0x2) |
+			ISPRSZ_PCR_ENABLE;
+	} else {
+		val = isp_reg_readl(isp_res->dev,
+				    OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &
+			~ISPRSZ_PCR_ENABLE;
+	}
+	isp_reg_writel(isp_res->dev, val, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR);
+	DPRINTK_ISPRESZ("+ispresizer_enable()-\n");
+}
+EXPORT_SYMBOL(ispresizer_enable);
+
+/**
+ * ispresizer_busy - Checks if ISP resizer is busy.
+ *
+ * Returns busy field from ISPRSZ_PCR register.
+ **/
+int ispresizer_busy(struct isp_res_device *isp_res)
+{
+	return isp_reg_readl(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR) &
+		ISPPRV_PCR_BUSY;
+}
+EXPORT_SYMBOL(ispresizer_busy);
+
+/**
+ * ispresizer_config_startphase - Sets the horizontal and vertical start phase.
+ * @hstartphase: horizontal start phase (0 - 7).
+ * @vstartphase: vertical startphase (0 - 7).
+ *
+ * This API just updates the isp_res struct. Actual register write happens in
+ * ispresizer_config_size.
+ **/
+void ispresizer_config_startphase(struct isp_res_device *isp_res,
+				  u8 hstartphase, u8 vstartphase)
+{
+	DPRINTK_ISPRESZ("ispresizer_config_startphase()+\n");
+	isp_res->h_startphase = hstartphase;
+	isp_res->v_startphase = vstartphase;
+	DPRINTK_ISPRESZ("ispresizer_config_startphase()-\n");
+}
+EXPORT_SYMBOL(ispresizer_config_startphase);
+
+/**
+ * ispresizer_config_ycpos - Specifies if output should be in YC or CY format.
+ * @yc: 0 - YC format, 1 - CY format
+ **/
+void ispresizer_config_ycpos(struct isp_res_device *isp_res, u8 yc)
+{
+	DPRINTK_ISPRESZ("ispresizer_config_ycpos()+\n");
+	isp_reg_and_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
+		       ~ISPRSZ_CNT_YCPOS, (yc ? ISPRSZ_CNT_YCPOS : 0));
+	DPRINTK_ISPRESZ("ispresizer_config_ycpos()-\n");
+}
+EXPORT_SYMBOL(ispresizer_config_ycpos);
+
+/**
+ * Sets the chrominance algorithm
+ * @cbilin: 0 - chrominance uses same processing as luminance,
+ *          1 - bilinear interpolation processing
+ **/
+void ispresizer_enable_cbilin(struct isp_res_device *isp_res, u8 enable)
+{
+	DPRINTK_ISPRESZ("ispresizer_enable_cbilin()+\n");
+	isp_reg_and_or(isp_res->dev, OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT,
+		       ~ISPRSZ_CNT_CBILIN, (enable ? ISPRSZ_CNT_CBILIN : 0));
+	DPRINTK_ISPRESZ("ispresizer_enable_cbilin()-\n");
+}
+EXPORT_SYMBOL(ispresizer_enable_cbilin);
+
+/**
+ * ispresizer_config_luma_enhance - Configures luminance enhancer parameters.
+ * @yenh: Pointer to structure containing desired values for core, slope, gain
+ *        and algo parameters.
+ **/
+void ispresizer_config_luma_enhance(struct isp_res_device *isp_res,
+				    struct isprsz_yenh *yenh)
+{
+	DPRINTK_ISPRESZ("ispresizer_config_luma_enhance()+\n");
+	isp_res->algo = yenh->algo;
+	isp_reg_writel(isp_res->dev, (yenh->algo << ISPRSZ_YENH_ALGO_SHIFT) |
+		       (yenh->gain << ISPRSZ_YENH_GAIN_SHIFT) |
+		       (yenh->slope << ISPRSZ_YENH_SLOP_SHIFT) |
+		       (yenh->coreoffset << ISPRSZ_YENH_CORE_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ,
+		       ISPRSZ_YENH);
+	DPRINTK_ISPRESZ("ispresizer_config_luma_enhance()-\n");
+}
+EXPORT_SYMBOL(ispresizer_config_luma_enhance);
+
+/**
+ * ispresizer_config_filter_coef - Sets filter coefficients for 4 & 7-tap mode.
+ * This API just updates the isp_res struct.Actual register write happens in
+ * ispresizer_config_size.
+ * @coef: Structure containing horizontal and vertical filter coefficients for
+ *        both 4-tap and 7-tap mode.
+ **/
+void ispresizer_config_filter_coef(struct isp_res_device *isp_res,
+				   struct isprsz_coef *coef)
+{
+	int i;
+	DPRINTK_ISPRESZ("ispresizer_config_filter_coef()+\n");
+	for (i = 0; i < 32; i++) {
+		isp_res->coeflist.h_filter_coef_4tap[i] =
+			coef->h_filter_coef_4tap[i];
+		isp_res->coeflist.v_filter_coef_4tap[i] =
+			coef->v_filter_coef_4tap[i];
+	}
+	for (i = 0; i < 28; i++) {
+		isp_res->coeflist.h_filter_coef_7tap[i] =
+			coef->h_filter_coef_7tap[i];
+		isp_res->coeflist.v_filter_coef_7tap[i] =
+			coef->v_filter_coef_7tap[i];
+	}
+	DPRINTK_ISPRESZ("ispresizer_config_filter_coef()-\n");
+}
+EXPORT_SYMBOL(ispresizer_config_filter_coef);
+
+/**
+ * ispresizer_config_inlineoffset - Configures the read address line offset.
+ * @offset: Line Offset for the input image.
+ *
+ * Returns 0 if successful, or -EINVAL if offset is not 32 bits aligned.
+ **/
+int ispresizer_config_inlineoffset(struct isp_res_device *isp_res, u32 offset)
+{
+	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()+\n");
+	if (offset % 32)
+		return -EINVAL;
+	isp_reg_writel(isp_res->dev, offset << ISPRSZ_SDR_INOFF_OFFSET_SHIFT,
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF);
+	DPRINTK_ISPRESZ("ispresizer_config_inlineoffset()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_config_inlineoffset);
+
+/**
+ * ispresizer_set_inaddr - Sets the memory address of the input frame.
+ * @addr: 32bit memory address aligned on 32byte boundary.
+ *
+ * Returns 0 if successful, or -EINVAL if address is not 32 bits aligned.
+ **/
+int ispresizer_set_inaddr(struct isp_res_device *isp_res, u32 addr)
+{
+	struct isp_device *isp =
+		container_of(isp_res, struct isp_device, isp_res);
+
+	DPRINTK_ISPRESZ("ispresizer_set_inaddr()+\n");
+
+	if (addr % 32)
+		return -EINVAL;
+	isp_res->tmp_buf = addr;
+	/* FIXME: is this the right place to put crop-related junk? */
+	isp_reg_writel(isp_res->dev,
+		       isp_res->tmp_buf + ISP_BYTES_PER_PIXEL
+		       * ((isp->pipeline.rsz_crop.left & ~0xf) +
+			  isp->pipeline.prv_out_w
+			  * isp->pipeline.rsz_crop.top),
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD);
+	/* Set the fractional part of the starting address. Needed for crop */
+	isp_reg_writel(isp_res->dev, ((isp->pipeline.rsz_crop.left & 0xf) <<
+		       ISPRSZ_IN_START_HORZ_ST_SHIFT) |
+		       (0x00 << ISPRSZ_IN_START_VERT_ST_SHIFT),
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START);
+
+	DPRINTK_ISPRESZ("ispresizer_set_inaddr()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_set_inaddr);
+
+/**
+ * ispresizer_config_outlineoffset - Configures the write address line offset.
+ * @offset: Line offset for the preview output.
+ *
+ * Returns 0 if successful, or -EINVAL if address is not 32 bits aligned.
+ **/
+int ispresizer_config_outlineoffset(struct isp_res_device *isp_res, u32 offset)
+{
+	DPRINTK_ISPRESZ("ispresizer_config_outlineoffset()+\n");
+	if (offset % 32)
+		return -EINVAL;
+	isp_reg_writel(isp_res->dev, offset << ISPRSZ_SDR_OUTOFF_OFFSET_SHIFT,
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF);
+	DPRINTK_ISPRESZ("ispresizer_config_outlineoffset()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_config_outlineoffset);
+
+/**
+ * Configures the memory address to which the output frame is written.
+ * @addr: 32bit memory address aligned on 32byte boundary.
+ **/
+int ispresizer_set_outaddr(struct isp_res_device *isp_res, u32 addr)
+{
+	DPRINTK_ISPRESZ("ispresizer_set_outaddr()+\n");
+	if (addr % 32)
+		return -EINVAL;
+	isp_reg_writel(isp_res->dev, addr << ISPRSZ_SDR_OUTADD_ADDR_SHIFT,
+		       OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD);
+	DPRINTK_ISPRESZ("ispresizer_set_outaddr()-\n");
+	return 0;
+}
+EXPORT_SYMBOL(ispresizer_set_outaddr);
+
+/**
+ * ispresizer_save_context - Saves the values of the resizer module registers.
+ **/
+void ispresizer_save_context(struct device *dev)
+{
+	DPRINTK_ISPRESZ("Saving context\n");
+	isp_save_context(dev, isprsz_reg_list);
+}
+EXPORT_SYMBOL(ispresizer_save_context);
+
+/**
+ * ispresizer_restore_context - Restores resizer module register values.
+ **/
+void ispresizer_restore_context(struct device *dev)
+{
+	DPRINTK_ISPRESZ("Restoring context\n");
+	isp_restore_context(dev, isprsz_reg_list);
+}
+EXPORT_SYMBOL(ispresizer_restore_context);
+
+/**
+ * ispresizer_print_status - Prints the values of the resizer module registers.
+ **/
+void ispresizer_print_status(struct isp_res_device *isp_res)
+{
+	if (!is_ispresz_debug_enabled())
+		return;
+	DPRINTK_ISPRESZ("###ISP_CTRL inresizer =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_MAIN, ISP_CTRL));
+	DPRINTK_ISPRESZ("###ISP_IRQ0ENABLE in resizer =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE));
+	DPRINTK_ISPRESZ("###ISP_IRQ0STATUS in resizer =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0STATUS));
+	DPRINTK_ISPRESZ("###RSZ PCR =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_PCR));
+	DPRINTK_ISPRESZ("###RSZ CNT =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_CNT));
+	DPRINTK_ISPRESZ("###RSZ OUT SIZE =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_OUT_SIZE));
+	DPRINTK_ISPRESZ("###RSZ IN START =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_START));
+	DPRINTK_ISPRESZ("###RSZ IN SIZE =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_IN_SIZE));
+	DPRINTK_ISPRESZ("###RSZ SDR INADD =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INADD));
+	DPRINTK_ISPRESZ("###RSZ SDR INOFF =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_INOFF));
+	DPRINTK_ISPRESZ("###RSZ SDR OUTADD =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTADD));
+	DPRINTK_ISPRESZ("###RSZ SDR OTOFF =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_SDR_OUTOFF));
+	DPRINTK_ISPRESZ("###RSZ YENH =0x%x\n",
+			isp_reg_readl(isp_res->dev,
+				      OMAP3_ISP_IOMEM_RESZ, ISPRSZ_YENH));
+}
+EXPORT_SYMBOL(ispresizer_print_status);
+
+/**
+ * isp_resizer_init - Module Initialisation.
+ *
+ * Always returns 0.
+ **/
+int __init isp_resizer_init(struct device *dev)
+{
+	struct isp_device *isp = dev_get_drvdata(dev);
+	struct isp_res_device *isp_res = &isp->isp_res;
+
+	mutex_init(&isp_res->ispres_mutex);
+	isp_res->dev = dev;
+
+	return 0;
+}
+
+/**
+ * isp_resizer_cleanup - Module Cleanup.
+ **/
+void isp_resizer_cleanup(struct device *dev)
+{
+}
diff --git a/drivers/media/video/isp/ispresizer.h b/drivers/media/video/isp/ispresizer.h
new file mode 100644
index 0000000..d2aaece
--- /dev/null
+++ b/drivers/media/video/isp/ispresizer.h
@@ -0,0 +1,190 @@
+/*
+ * ispresizer.h
+ *
+ * Driver header file for Resizer module in TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sameer Venkatraman <sameerv@ti.com>
+ *	Mohit Jalori
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_ISP_RESIZER_H
+#define OMAP_ISP_RESIZER_H
+
+/*
+ * Resizer Constants
+ */
+#define MAX_IN_WIDTH_MEMORY_MODE	4095
+
+#define MAX_IN_WIDTH_ONTHEFLY_MODE	1280
+#define MAX_IN_WIDTH_ONTHEFLY_MODE_ES2	4095
+#define MAX_IN_HEIGHT			4095
+#define MINIMUM_RESIZE_VALUE		64
+#define MAXIMUM_RESIZE_VALUE		1024
+#define MID_RESIZE_VALUE		512
+
+#define MAX_7TAP_HRSZ_OUTWIDTH		1280
+#define MAX_7TAP_VRSZ_OUTWIDTH		640
+
+#define MAX_7TAP_HRSZ_OUTWIDTH_ES2	3300
+#define MAX_7TAP_VRSZ_OUTWIDTH_ES2	1650
+
+#define DEFAULTSTPIXEL			0
+#define DEFAULTSTPHASE			1
+#define DEFAULTHSTPIXEL4TAPMODE		3
+#define FOURPHASE			4
+#define EIGHTPHASE			8
+#define RESIZECONSTANT			256
+#define SHIFTER4TAPMODE			0
+#define SHIFTER7TAPMODE			1
+#define DEFAULTOFFSET			7
+#define OFFSETVERT4TAPMODE		4
+#define OPWDALIGNCONSTANT		0xfffffff0
+
+/*
+ * The client is supposed to call resizer API in the following sequence:
+ *	- request()
+ *	- config_datatpath()
+ *	- optionally config/enable sub modules
+ *	- try/config size
+ *	- setup callback
+ *	- setup in/out memory offsets and ptrs
+ *	- enable()
+ *	...
+ *	- disable()
+ *	- free()
+ */
+
+enum resizer_input {
+	RSZ_OTFLY_YUV,
+	RSZ_MEM_YUV,
+	RSZ_MEM_COL8
+};
+
+/**
+ * struct isprsz_coef - Structure for resizer filter coeffcients.
+ * @h_filter_coef_4tap: Horizontal filter coefficients for 8-phase/4-tap
+ *			mode (.5x-4x)
+ * @v_filter_coef_4tap: Vertical filter coefficients for 8-phase/4-tap
+ *			mode (.5x-4x)
+ * @h_filter_coef_7tap: Horizontal filter coefficients for 4-phase/7-tap
+ *			mode (.25x-.5x)
+ * @v_filter_coef_7tap: Vertical filter coefficients for 4-phase/7-tap
+ *			mode (.25x-.5x)
+ */
+struct isprsz_coef {
+	u16 h_filter_coef_4tap[32];
+	u16 v_filter_coef_4tap[32];
+	u16 h_filter_coef_7tap[28];
+	u16 v_filter_coef_7tap[28];
+};
+
+/**
+ * struct isprsz_yenh - Structure for resizer luminance enhancer parameters.
+ * @algo: Algorithm select.
+ * @gain: Maximum gain.
+ * @slope: Slope.
+ * @coreoffset: Coring offset.
+ */
+struct isprsz_yenh {
+	u8 algo;
+	u8 gain;
+	u8 slope;
+	u8 coreoffset;
+};
+
+/**
+ * struct isp_res_device - Structure for the resizer module to store its
+ *			   information.
+ * @res_inuse: Indicates if resizer module has been reserved. 1 - Reserved,
+ *             0 - Freed.
+ * @h_startphase: Horizontal starting phase.
+ * @v_startphase: Vertical starting phase.
+ * @h_resz: Horizontal resizing value.
+ * @v_resz: Vertical resizing value.
+ * @outputwidth: Output Image Width in pixels.
+ * @outputheight: Output Image Height in pixels.
+ * @inputwidth: Input Image Width in pixels.
+ * @inputheight: Input Image Height in pixels.
+ * @algo: Algorithm select. 0 - Disable, 1 - [-1 2 -1]/2 high-pass filter,
+ *        2 - [-1 -2 6 -2 -1]/4 high-pass filter.
+ * @ipht_crop: Vertical start line for cropping.
+ * @ipwd_crop: Horizontal start pixel for cropping.
+ * @cropwidth: Crop Width.
+ * @cropheight: Crop Height.
+ * @resinput: Resizer input.
+ * @coeflist: Register configuration for Resizer.
+ * @ispres_mutex: Mutex for isp resizer.
+ */
+struct isp_res_device {
+	u8 res_inuse;
+	u8 h_startphase;
+	u8 v_startphase;
+	u16 h_resz;
+	u16 v_resz;
+	u8 algo;
+	dma_addr_t tmp_buf;
+	struct isprsz_coef coeflist;
+	struct mutex ispres_mutex; /* For checking/modifying res_inuse */
+	struct isprsz_yenh defaultyenh;
+	struct device *dev;
+	int applycrop;
+};
+
+int ispresizer_config_crop(struct isp_res_device *isp_res,
+			   struct v4l2_crop *a);
+void ispresizer_config_shadow_registers(struct isp_res_device *isp_res);
+
+int ispresizer_request(struct isp_res_device *isp_res);
+
+int ispresizer_free(struct isp_res_device *isp_res);
+
+void ispresizer_enable_cbilin(struct isp_res_device *isp_res, u8 enable);
+
+void ispresizer_config_ycpos(struct isp_res_device *isp_res, u8 yc);
+
+void ispresizer_config_startphase(struct isp_res_device *isp_res,
+				  u8 hstartphase, u8 vstartphase);
+
+void ispresizer_config_filter_coef(struct isp_res_device *isp_res,
+				   struct isprsz_coef *coef);
+
+void ispresizer_config_luma_enhance(struct isp_res_device *isp_res,
+				    struct isprsz_yenh *yenh);
+
+int ispresizer_try_pipeline(struct isp_res_device *isp_res,
+			    struct isp_pipeline *pipe);
+
+int ispresizer_s_pipeline(struct isp_res_device *isp_res,
+			  struct isp_pipeline *pipe);
+
+int ispresizer_config_inlineoffset(struct isp_res_device *isp_res, u32 offset);
+
+int ispresizer_set_inaddr(struct isp_res_device *isp_res, u32 addr);
+
+int ispresizer_config_outlineoffset(struct isp_res_device *isp_res, u32 offset);
+
+int ispresizer_set_outaddr(struct isp_res_device *isp_res, u32 addr);
+
+void ispresizer_enable(struct isp_res_device *isp_res, int enable);
+
+int ispresizer_busy(struct isp_res_device *isp_res);
+
+void ispresizer_save_context(struct device *dev);
+
+void ispresizer_restore_context(struct device *dev);
+
+void ispresizer_print_status(struct isp_res_device *isp_res);
+
+#endif		/* OMAP_ISP_RESIZER_H */
diff --git a/drivers/media/video/isp/ispstat.c b/drivers/media/video/isp/ispstat.c
new file mode 100644
index 0000000..d1fce13
--- /dev/null
+++ b/drivers/media/video/isp/ispstat.c
@@ -0,0 +1,259 @@
+/*
+ * ispstat.c
+ *
+ * STAT module for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+
+#include "isp.h"
+
+/* Get next free buffer to write the statistics to and mark it active. */
+struct ispstat_buffer *ispstat_buf_next(struct ispstat *stat)
+{
+	unsigned long flags;
+	struct ispstat_buffer *found = NULL;
+	int i;
+
+	if (stat->active_buf)
+		do_gettimeofday(&stat->active_buf->ts);
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	if (stat->active_buf) {
+		stat->active_buf->config_counter = stat->config_counter;
+		stat->active_buf->frame_number = stat->frame_number;
+	}
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *curr = &stat->buf[i];
+
+		/*
+		 * Don't select the buffer which is being copied to
+		 * userspace.
+		 */
+		if (curr == stat->locked_buf)
+			continue;
+
+		if (!found
+		    || (curr->frame_number > found->frame_number
+			&& (curr->frame_number - found->frame_number
+			    > stat->max_frame / 2))
+		    || (curr->frame_number < found->frame_number
+			&& (found->frame_number - curr->frame_number
+			    < stat->max_frame / 2))) {
+			found = curr;
+		}
+	}
+
+	stat->active_buf = found;
+
+	stat->frame_number++;
+	if (stat->frame_number == stat->max_frame)
+		stat->frame_number = 0;
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	return found;
+}
+
+/* Get buffer to userspace. */
+static struct ispstat_buffer *ispstat_buf_find(
+	struct ispstat *stat, u32 frame_number)
+{
+	struct ispstat_buffer *latest = NULL;
+	int i;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *curr = &stat->buf[i];
+
+		/* We cannot deal with the active buffer. */
+		if (curr == stat->active_buf)
+			continue;
+
+		/* Don't take uninitialised buffers. */
+		if (curr->frame_number == stat->max_frame)
+			continue;
+
+		/* Found correct number. */
+		if (curr->frame_number == frame_number) {
+			latest = curr;
+			break;
+		}
+
+		/* Select first buffer or a better one. */
+		if (!latest
+		    || (curr->frame_number < latest->frame_number
+			&& (latest->frame_number - curr->frame_number
+			    > stat->max_frame / 2))
+		    || (curr->frame_number > latest->frame_number
+			&& (curr->frame_number - latest->frame_number
+			    < stat->max_frame / 2)))
+			latest = curr;
+	}
+
+	return latest;
+}
+
+/**
+ * ispstat_stats_available - Check for stats available of specified frame.
+ * @aewbdata: Pointer to return AE AWB statistics data
+ *
+ * Returns 0 if successful, or -1 if statistics are unavailable.
+ **/
+struct ispstat_buffer *ispstat_buf_get(struct ispstat *stat,
+				       void __user *ptr,
+				       unsigned int frame_number)
+{
+	int rval = 0;
+	unsigned long flags;
+	struct ispstat_buffer *buf;
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	buf = ispstat_buf_find(stat, frame_number);
+	if (!buf) {
+		spin_unlock_irqrestore(&stat->lock, flags);
+		return ERR_PTR(-EBUSY);
+	}
+
+	stat->locked_buf = buf;
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	rval = copy_to_user((void *)ptr,
+			    buf->virt_addr,
+			    stat->buf_size);
+
+	if (rval) {
+		dev_info(stat->dev,
+			 "failed copying %d bytes of stat data\n", rval);
+		buf = ERR_PTR(-EFAULT);
+		ispstat_buf_release(stat);
+	}
+
+	return buf;
+}
+
+void ispstat_buf_release(struct ispstat *stat)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&stat->lock, flags);
+	stat->locked_buf = NULL;
+	spin_unlock_irqrestore(&stat->lock, flags);
+}
+
+void ispstat_bufs_free(struct ispstat *stat)
+{
+	struct isp_device *isp = dev_get_drvdata(stat->dev);
+	int i;
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *buf = &stat->buf[i];
+
+		if (!buf->iommu_addr)
+			continue;
+
+		iommu_vfree(isp->iommu, buf->iommu_addr);
+		buf->iommu_addr = 0;
+	}
+
+	stat->buf_alloc_size = 0;
+}
+
+int ispstat_bufs_alloc(struct ispstat *stat,
+		       unsigned int size)
+{
+	struct isp_device *isp = dev_get_drvdata(stat->dev);
+	unsigned long flags;
+	int i;
+
+	spin_lock_irqsave(&stat->lock, flags);
+
+	BUG_ON(stat->locked_buf != NULL);
+
+	/* Are the old buffers big enough? */
+	if (stat->buf_alloc_size >= size) {
+		for (i = 0; i < stat->nbufs; i++)
+			stat->buf[i].frame_number = stat->max_frame;
+		spin_unlock_irqrestore(&stat->lock, flags);
+		goto out;
+	}
+
+	if (isp->running != ISP_STOPPED) {
+		dev_info(stat->dev, "stat: trying to configure when busy\n");
+		spin_unlock_irqrestore(&stat->lock, flags);
+		return -EBUSY;
+	}
+
+	spin_unlock_irqrestore(&stat->lock, flags);
+
+	ispstat_bufs_free(stat);
+
+	for (i = 0; i < stat->nbufs; i++) {
+		struct ispstat_buffer *buf = &stat->buf[i];
+
+		buf->iommu_addr = iommu_vmalloc(isp->iommu, 0, size,
+						IOMMU_FLAG);
+		if (buf->iommu_addr == 0) {
+			dev_info(stat->dev, "stat: Can't acquire memory for "
+				 "buffer %d\n", i);
+			ispstat_bufs_free(stat);
+			return -ENOMEM;
+		}
+		buf->virt_addr = da_to_va(isp->iommu, (u32)buf->iommu_addr);
+		buf->frame_number = stat->max_frame;
+	}
+
+	stat->buf_alloc_size = size;
+
+out:
+	stat->buf_size = size;
+	stat->active_buf = NULL;
+
+	return 0;
+}
+
+int ispstat_init(struct device *dev, struct ispstat *stat,
+		 unsigned int nbufs, unsigned int max_frame)
+{
+	BUG_ON(nbufs < 2);
+	BUG_ON(max_frame < 2);
+	BUG_ON(nbufs >= max_frame);
+
+	memset(stat, 0, sizeof(*stat));
+
+	stat->buf = kcalloc(nbufs, sizeof(*stat->buf), GFP_KERNEL);
+	if (!stat->buf)
+		return -ENOMEM;
+
+	spin_lock_init(&stat->lock);
+	stat->nbufs = nbufs;
+	stat->dev = dev;
+	stat->max_frame = max_frame;
+
+	return 0;
+}
+
+void ispstat_free(struct ispstat *stat)
+{
+	ispstat_bufs_free(stat);
+	kfree(stat->buf);
+}
diff --git a/drivers/media/video/isp/ispstat.h b/drivers/media/video/isp/ispstat.h
new file mode 100644
index 0000000..12ab4d5
--- /dev/null
+++ b/drivers/media/video/isp/ispstat.h
@@ -0,0 +1,65 @@
+/*
+ * ispstat.h
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef ISPSTAT_H
+#define ISPSTAT_H
+
+#include "isp.h"
+
+struct ispstat_buffer {
+	unsigned long iommu_addr;
+	void *virt_addr;
+	struct timeval ts;
+	u32 config_counter;
+	u32 frame_number;
+};
+
+struct ispstat {
+	spinlock_t lock;		/* Lock for this struct */
+
+	unsigned int nbufs;
+	struct ispstat_buffer *buf;
+	unsigned int buf_size;
+	unsigned int buf_alloc_size;
+	struct ispstat_buffer *active_buf;
+	struct ispstat_buffer *locked_buf;
+	unsigned int frame_number;
+	unsigned int max_frame;
+	unsigned int config_counter;
+
+	struct device *dev;
+};
+
+struct ispstat_buffer *ispstat_buf_next(struct ispstat *stat);
+struct ispstat_buffer *ispstat_buf_get(struct ispstat *stat,
+				       void __user *ptr,
+				       unsigned int frame_number);
+void ispstat_buf_release(struct ispstat *stat);
+void ispstat_bufs_free(struct ispstat *stat);
+int ispstat_bufs_alloc(struct ispstat *stat,
+		       unsigned int size);
+int ispstat_init(struct device *dev, struct ispstat *stat,
+		 unsigned int nbufs, unsigned int max_frame);
+void ispstat_free(struct ispstat *stat);
+
+#endif /* ISPSTAT_H */
diff --git a/drivers/media/video/isp/luma_enhance_table.h b/drivers/media/video/isp/luma_enhance_table.h
new file mode 100644
index 0000000..99c8b05
--- /dev/null
+++ b/drivers/media/video/isp/luma_enhance_table.h
@@ -0,0 +1,144 @@
+/*
+ * luma_enhance_table.h
+ *
+ * Luminance Enhancement table values for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1047552,
+1048575,
+1047551,
+1046527,
+1045503,
+1044479,
+1043455,
+1042431,
+1041407,
+1040383,
+1039359,
+1038335,
+1037311,
+1036287,
+1035263,
+1034239,
+1033215,
+1032191,
+1031167,
+1030143,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028096,
+1028100,
+1032196,
+1036292,
+1040388,
+1044484,
+0,
+0,
+0,
+5,
+5125,
+10245,
+15365,
+20485,
+25605,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+30720,
+31743,
+30719,
+29695,
+28671,
+27647,
+26623,
+25599,
+24575,
+23551,
+22527,
+21503,
+20479,
+19455,
+18431,
+17407,
+16383,
+15359,
+14335,
+13311,
+12287,
+11263,
+10239,
+9215,
+8191,
+7167,
+6143,
+5119,
+4095,
+3071,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024,
+1024
diff --git a/drivers/media/video/isp/noise_filter_table.h b/drivers/media/video/isp/noise_filter_table.h
new file mode 100644
index 0000000..7345f90
--- /dev/null
+++ b/drivers/media/video/isp/noise_filter_table.h
@@ -0,0 +1,79 @@
+/*
+ * noise_filter_table.h
+ *
+ * Noise Filter Table values for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+16,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31,
+31
diff --git a/drivers/media/video/isp/omap_previewer.c b/drivers/media/video/isp/omap_previewer.c
new file mode 100644
index 0000000..3fc97bf
--- /dev/null
+++ b/drivers/media/video/isp/omap_previewer.c
@@ -0,0 +1,1251 @@
+/*
+ * drivers/media/video/isp/omap_previewer.c
+ *
+ * Wrapper for Preview module in TI's OMAP3430 ISP
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Leonides Martinez <leonides.martinez@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <media/v4l2-dev.h>
+#include <asm/cacheflush.h>
+
+#include "isp.h"
+#include "omap_previewer.h"
+
+#define OMAP_PREV_NAME		"omap-previewer"
+
+#define BIT_SET(var, shift, mask, val)		\
+	do {					\
+		var = (var & ~(mask << shift))	\
+			| (val << shift);	\
+	} while (0)
+
+/*
+#define OMAP_ISP_PREVIEWER_DEBUG
+*/
+#undef OMAP_ISP_PREVIEWER_DEBUG
+
+#ifdef OMAP_ISP_PREVIEWER_DEBUG
+#define DPRINTK_PREVIEWER(format, ...) \
+	printk(KERN_DEBUG "PREV: " format, ## __VA_ARGS__)
+#else
+#define DPRINTK_PREVIEWER(format, ...)
+#endif
+
+#define ISP_CTRL_SBL_SHARED_RPORTB	(1 << 28)
+#define ISP_CTRL_SBL_SHARED_RPORTA	(1 << 27)
+#define SBL_RD_RAM_EN				18
+
+static struct isp_interface_config prevwrap_config = {
+	.ccdc_par_ser = ISP_NONE,
+	.dataline_shift = 0,
+	.hsvs_syncdetect = ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe = 0,
+	.prestrobe = 0,
+	.shutter = 0,
+	.wait_hs_vs = 0,
+};
+
+static u32 isp_ctrl;
+static u32 prv_wsdr_addr;
+static int prev_major = -1;
+static struct device *prev_dev;
+static struct class *prev_class;
+static struct prev_device *prevdevice;
+static struct platform_driver omap_previewer_driver;
+
+static u32 prev_bufsize;
+static u32 lsc_bufsize;
+
+/**
+ * prev_calculate_crop - Calculate crop size according to device parameters
+ * @device: Structure containing ISP preview wrapper global information
+ * @crop: Structure containing crop size
+ *
+ * This function is used to calculate frame size reduction depending on
+ * the features enabled by the application.
+ **/
+static int prev_calculate_crop(struct prev_device *device,
+			       struct prev_cropsize *crop)
+{
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+	int ret;
+	struct isp_pipeline pipe;
+
+	pipe.ccdc_out_w = pipe.ccdc_out_w_img =
+		device->size_params.hsize;
+	pipe.ccdc_out_h = device->size_params.vsize;
+	pipe.prv_in = PRV_RAW_MEM;
+	pipe.prv_out = PREVIEW_MEM;
+
+	ret = isppreview_try_pipeline(&isp->isp_prev, &pipe);
+
+	crop->hcrop = pipe.prv_out_w_img;
+	crop->vcrop = pipe.prv_out_h_img;
+
+	return ret;
+}
+
+/**
+ * prev_get_status - Get status of ISP preview module
+ * @status: Structure containing the busy state.
+ *
+ * Checks if the ISP preview module is busy.
+ *
+ * Returns 0 if successful, or -EINVAL if the status parameter is invalid.
+ **/
+static int prev_get_status(struct prev_device *device,
+			   struct prev_status *status)
+{
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+
+	if (!status) {
+		dev_err(prev_dev, "get_status: invalid parameter\n");
+		return -EINVAL;
+	}
+	status->hw_busy = (char)isppreview_busy(&isp->isp_prev);
+	return 0;
+}
+
+/**
+ * prev_hw_setup - Stores the desired configuration in the proper HW registers
+ * @config: Structure containing the desired configuration for ISP preview
+ *          module.
+ *
+ * Reads the structure sent, and modifies the desired registers.
+ *
+ * Always returns 0.
+ **/
+static int prev_hw_setup(struct prev_device *device,
+			 struct prev_params *config)
+{
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+
+	if (config->features & PREV_AVERAGER)
+		isppreview_config_averager(&isp->isp_prev, config->average);
+	else
+		isppreview_config_averager(&isp->isp_prev, 0);
+
+	if (config->features & PREV_INVERSE_ALAW)
+		isppreview_enable_invalaw(&isp->isp_prev, 1);
+	else
+		isppreview_enable_invalaw(&isp->isp_prev, 0);
+
+	if (config->features & PREV_HORZ_MEDIAN_FILTER) {
+		isppreview_config_hmed(&isp->isp_prev, config->hmf_params);
+		isppreview_enable_hmed(&isp->isp_prev, 1);
+	} else
+		isppreview_enable_hmed(&isp->isp_prev, 0);
+
+	if (config->features & PREV_DARK_FRAME_SUBTRACT) {
+		DPRINTK_PREVIEWER("[%s] darkaddr %08x, darklineoffset %d\n",
+						__func__,
+						config->drkf_params.addr,
+						config->drkf_params.offset);
+		isppreview_set_darkaddr(&isp->isp_prev,
+					config->drkf_params.addr);
+		isppreview_config_darklineoffset(&isp->isp_prev,
+						 config->drkf_params.offset);
+		isppreview_enable_drkframe(&isp->isp_prev, 1);
+	} else
+		isppreview_enable_drkframe(&isp->isp_prev, 0);
+
+	if (config->features & PREV_LENS_SHADING) {
+		isppreview_config_drkf_shadcomp(&isp->isp_prev,
+						config->lens_shading_shift);
+		isppreview_enable_shadcomp(&isp->isp_prev, 1);
+	} else
+		isppreview_enable_shadcomp(&isp->isp_prev, 0);
+
+	if (config->ytable)
+		isppreview_set_luma_enhancement(&isp->isp_prev,
+						config->ytable);
+
+	dev_dbg(prev_dev, "prev_hw_setup L\n");
+	return 0;
+}
+
+/**
+ * prev_validate_params - Validate configuration parameters for Preview Wrapper
+ * @params: Structure containing configuration parameters
+ *
+ * Validate configuration parameters for Preview Wrapper
+ *
+ * Returns 0 if successful, or -EINVAL if a parameter value is invalid.
+ **/
+static int prev_validate_params(struct prev_params *params)
+{
+	if (!params) {
+		dev_err(prev_dev, "validate_params: error in argument");
+		goto err_einval;
+	}
+
+	if ((params->features & PREV_AVERAGER) == PREV_AVERAGER) {
+		if ((params->average != NO_AVE)
+					&& (params->average != AVE_2_PIX)
+					&& (params->average != AVE_4_PIX)
+					&& (params->average != AVE_8_PIX)) {
+			dev_err(prev_dev, "validate_params: wrong pix "
+								"average\n");
+			goto err_einval;
+		} else if (((params->average == AVE_2_PIX)
+					&& (params->size_params.hsize % 2))
+					|| ((params->average == AVE_4_PIX)
+					&& (params->size_params.hsize % 4))
+					|| ((params->average == AVE_8_PIX)
+					&& (params->size_params.hsize % 8))) {
+			dev_err(prev_dev, "validate_params: "
+					"wrong pix average for input size\n");
+			goto err_einval;
+		}
+	}
+
+	if ((params->size_params.pixsize != PREV_INWIDTH_8BIT)
+					&& (params->size_params.pixsize
+					!= PREV_INWIDTH_10BIT)) {
+		dev_err(prev_dev, "validate_params: wrong pixsize\n");
+		goto err_einval;
+	}
+
+	if (params->size_params.hsize > MAX_IMAGE_WIDTH
+					|| params->size_params.hsize < 0) {
+		dev_err(prev_dev, "validate_params: wrong hsize\n");
+		goto err_einval;
+	}
+
+	if (params->size_params.hsize % 32) {
+		dev_err(prev_dev, "validate_params: width must be multiple of"
+			" 64 bytes\n");
+		goto err_einval;
+	}
+
+	if ((params->pix_fmt != YCPOS_YCrYCb)
+					&& (YCPOS_YCbYCr != params->pix_fmt)
+					&& (YCPOS_CbYCrY != params->pix_fmt)
+					&& (YCPOS_CrYCbY != params->pix_fmt)) {
+		dev_err(prev_dev, "validate_params: wrong pix_fmt");
+		goto err_einval;
+	}
+
+	if ((params->features & PREV_DARK_FRAME_SUBTRACT)
+						&& (params->features
+						& PREV_DARK_FRAME_CAPTURE)) {
+		dev_err(prev_dev, "validate_params: DARK FRAME CAPTURE and "
+						"SUBSTRACT cannot be enabled "
+						"at same time\n");
+		goto err_einval;
+	}
+
+	if ((params->size_params.in_pitch <= 0)
+				|| (params->size_params.in_pitch % 32)) {
+		params->size_params.in_pitch =
+				(params->size_params.hsize * 2) & 0xFFE0;
+		dev_err(prev_dev, "Error in in_pitch; new value = %d\n",
+						params->size_params.in_pitch);
+	}
+
+	return 0;
+err_einval:
+	return -EINVAL;
+}
+
+/**
+ * preview_isr - Callback from ISP driver for ISP Preview Interrupt
+ * @status: ISP IRQ0STATUS register value
+ * @arg1: Structure containing ISP preview wrapper global information
+ * @arg2: Currently not used
+ **/
+static void prev_isr(unsigned long status, isp_vbq_callback_ptr arg1,
+								void *arg2)
+{
+	struct prev_device *device = (struct prev_device *)arg1;
+
+	if ((status & PREV_DONE) != PREV_DONE)
+		return;
+
+	if (device)
+		complete(&device->wfc);
+}
+
+/*
+ * Set shared ports for using dark frame (lens shading)
+ */
+static void prev_set_isp_ctrl(u16 mode)
+{
+	struct prev_device *device = prevdevice;
+	u32 val;
+
+	val = isp_reg_readl(device->isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+
+	isp_ctrl = val;
+
+	/* Read port used by preview module data read */
+	val &= ~ISP_CTRL_SBL_SHARED_RPORTA;
+
+	/* Read port used by preview module dark frame read */
+	if (mode & (PREV_DARK_FRAME_SUBTRACT | PREV_LENS_SHADING))
+		val &= ~ISP_CTRL_SBL_SHARED_RPORTB;
+
+	BIT_SET(val, SBL_RD_RAM_EN, 0x1, 0x1);
+
+	/* write ISP CTRL register */
+	isp_reg_writel(device->isp, val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+
+	prv_wsdr_addr = isp_reg_readl(device->isp, OMAP3_ISP_IOMEM_PREV,
+				      ISPPRV_WSDR_ADDR);
+}
+
+/*
+ * Set old isp shared port configuration
+ */
+static void prev_unset_isp_ctrl(void)
+{
+	struct prev_device *device = prevdevice;
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+	u32 val;
+
+	val = isp_reg_readl(device->isp, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+
+	if (isp_ctrl & ISP_CTRL_SBL_SHARED_RPORTB)
+		val |= ISP_CTRL_SBL_SHARED_RPORTB;
+
+	if (isp_ctrl & ISP_CTRL_SBL_SHARED_RPORTA)
+		val |= ISP_CTRL_SBL_SHARED_RPORTA;
+
+	if (isp_ctrl & (1 << SBL_RD_RAM_EN))
+		val &= ~(1 << SBL_RD_RAM_EN);
+
+	/* write ISP CTRL register */
+	isp_reg_writel(device->isp, val, OMAP3_ISP_IOMEM_MAIN, ISP_CTRL);
+
+	/* disable dark frame and shading compensation */
+	isppreview_enable_drkframe(&isp->isp_prev, 0);
+	isppreview_enable_shadcomp(&isp->isp_prev, 0);
+
+	/* Set output and input adresses to 0 */
+	isppreview_set_outaddr(&isp->isp_prev, prv_wsdr_addr);
+}
+
+static void isp_enable_interrupts(struct device *dev, int is_raw)
+{
+	isp_reg_writel(dev, IRQ0ENABLE_PRV_DONE_IRQ,
+		       OMAP3_ISP_IOMEM_MAIN, ISP_IRQ0ENABLE);
+}
+
+/**
+ * prev_do_preview - Performs the Preview process
+ * @device: Structure containing ISP preview wrapper global information
+ *
+ * Returns 0 if successful, or -EINVAL if the sent parameters are invalid.
+ **/
+static int prev_do_preview(struct prev_device *device)
+{
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+	struct isp_prev_device *isp_prev = &isp->isp_prev;
+	struct prev_params *config = &isp_prev->params;
+	int bpp, size;
+	int ret = 0;
+	struct isp_pipeline pipe;
+
+	memset(&pipe, 0, sizeof(pipe));
+	pipe.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+
+	prev_set_isp_ctrl(config->features);
+
+	if (device->size_params.pixsize == PREV_INWIDTH_8BIT)
+		bpp = 1;
+	else
+		bpp = 2;
+
+	size = device->size_params.hsize * device->size_params.vsize * bpp;
+
+	pipe.prv_in = PRV_RAW_MEM;
+	pipe.prv_out = PREVIEW_MEM;
+
+	isppreview_set_skip(isp_prev, 2, 0);
+
+	pipe.ccdc_out_w = pipe.ccdc_out_w_img = device->size_params.hsize;
+	pipe.ccdc_out_h = device->size_params.vsize & ~0xf;
+
+	ret = isppreview_try_pipeline(isp_prev, &pipe);
+	if (ret) {
+		dev_err(prev_dev, "ERROR while try size!\n");
+		goto out;
+	}
+
+	ret = isppreview_s_pipeline(isp_prev, &pipe);
+	if (ret) {
+		dev_err(prev_dev, "ERROR while config size!\n");
+		goto out;
+	}
+
+	ret = isppreview_config_inlineoffset(isp_prev,
+					     pipe.prv_out_w * bpp);
+	if (ret)
+		goto out;
+
+	ret = isppreview_config_outlineoffset(isp_prev,
+					      (pipe.prv_out_w * bpp) - 32);
+	if (ret)
+		goto out;
+
+	config->drkf_params.addr = device->isp_addr_lsc;
+
+	prev_hw_setup(device, config);
+
+	ret = isppreview_set_inaddr(isp_prev, device->isp_addr_read);
+	if (ret)
+		goto out;
+
+	ret = isppreview_set_outaddr(isp_prev, device->isp_addr_read);
+	if (ret)
+		goto out;
+
+	ret = isp_set_callback(device->isp, CBK_PREV_DONE, prev_isr,
+			       (void *)device, (void *)NULL);
+	if (ret) {
+		dev_err(prev_dev, "ERROR while setting Previewer callback!\n");
+		goto out;
+	}
+
+	isp_configure_interface(device->isp, &prevwrap_config);
+
+	isp_start(device->isp);
+
+	isp_enable_interrupts(device->isp, 0);
+
+	isppreview_enable(isp_prev);
+
+	wait_for_completion_interruptible(&device->wfc);
+
+	ret = isp_unset_callback(device->isp, CBK_PREV_DONE);
+
+	prev_unset_isp_ctrl();
+out:
+	return ret;
+}
+
+/**
+ * previewer_vbq_release - Videobuffer queue release
+ * @q: Structure containing the videobuffer queue.
+ * @vb: Structure containing the videobuffer used for previewer processing.
+ **/
+static void previewer_vbq_release(struct videobuf_queue *q,
+						struct videobuf_buffer *vb)
+{
+	struct prev_fh *fh = q->priv_data;
+	struct prev_device *device = fh->device;
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		ispmmu_vunmap(device->isp, device->isp_addr_read);
+		device->isp_addr_read = 0;
+		spin_lock(&device->inout_vbq_lock);
+		vb->state = VIDEOBUF_NEEDS_INIT;
+		spin_unlock(&device->inout_vbq_lock);
+	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
+		ispmmu_vunmap(device->isp, device->isp_addr_lsc);
+		device->isp_addr_lsc = 0;
+		spin_lock(&device->lsc_vbq_lock);
+		vb->state = VIDEOBUF_NEEDS_INIT;
+		spin_unlock(&device->lsc_vbq_lock);
+	}
+
+	if (vb->memory != V4L2_MEMORY_MMAP) {
+		videobuf_dma_unmap(q, videobuf_to_dma(vb));
+		videobuf_dma_free(videobuf_to_dma(vb));
+	}
+
+	dev_dbg(prev_dev, "previewer_vbq_release\n");
+}
+
+/**
+ * previewer_vbq_setup - Sets up the videobuffer size and validates count.
+ * @q: Structure containing the videobuffer queue.
+ * @cnt: Number of buffers requested
+ * @size: Size in bytes of the buffer used for previewing
+ *
+ * Always returns 0.
+ **/
+static int previewer_vbq_setup(struct videobuf_queue *q,
+							unsigned int *cnt,
+							unsigned int *size)
+{
+	struct prev_fh *fh = q->priv_data;
+	struct prev_device *device = fh->device;
+	u32 bpp = 1;
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		spin_lock(&device->inout_vbq_lock);
+
+		if (*cnt <= 0)
+			*cnt = 1;
+
+		if (*cnt > VIDEO_MAX_FRAME)
+			*cnt = VIDEO_MAX_FRAME;
+
+		if (!device->size_params.hsize ||
+			!device->size_params.vsize) {
+			dev_err(prev_dev, "Can't setup inout buffer size\n");
+			spin_unlock(&device->inout_vbq_lock);
+			return -EINVAL;
+		}
+
+		if (device->size_params.pixsize == PREV_INWIDTH_10BIT)
+			bpp = 2;
+		*size = prev_bufsize = bpp * device->size_params.hsize *
+					device->size_params.vsize;
+		spin_unlock(&device->inout_vbq_lock);
+	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
+		spin_lock(&device->lsc_vbq_lock);
+		if (*cnt <= 0)
+			*cnt = 1;
+
+		if (*cnt > 1)
+			*cnt = 1;
+
+		if (!device->size_params.hsize ||
+			!device->size_params.vsize) {
+			dev_err(prev_dev, "Can't setup lsc buffer size\n");
+			spin_unlock(&device->lsc_vbq_lock);
+			return -EINVAL;
+		}
+
+		/* upsampled lsc table size - for now bpp = 2 */
+		bpp = 2;
+		*size = lsc_bufsize = bpp * device->size_params.hsize *
+					device->size_params.vsize;
+
+		spin_unlock(&device->lsc_vbq_lock);
+	} else {
+		return -EINVAL;
+	}
+
+	dev_dbg(prev_dev, "previewer_vbq_setup\n");
+	return 0;
+}
+
+/**
+ * previewer_vbq_prepare - Videobuffer is prepared and mmapped.
+ * @q: Structure containing the videobuffer queue.
+ * @vb: Structure containing the videobuffer used for previewer processing.
+ * @field: Type of field to set in videobuffer device.
+ *
+ * Returns 0 if successful, or -EINVAL if buffer couldn't get allocated, or
+ * -EIO if the ISP MMU mapping fails
+ **/
+static int previewer_vbq_prepare(struct videobuf_queue *q,
+						struct videobuf_buffer *vb,
+						enum v4l2_field field)
+{
+	struct prev_fh *fh = q->priv_data;
+	struct prev_device *device = fh->device;
+	int err = -EINVAL;
+	unsigned int isp_addr;
+	struct videobuf_dmabuf *dma = videobuf_to_dma(vb);
+
+	dev_dbg(prev_dev, "previewer_vbq_prepare E\n");
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		spin_lock(&device->inout_vbq_lock);
+
+		if (vb->baddr) {
+			vb->size = prev_bufsize;
+			vb->bsize = prev_bufsize;
+			DPRINTK_PREVIEWER("[%s] bsize = %d\n", __func__,
+								vb->bsize);
+		} else {
+			spin_unlock(&device->inout_vbq_lock);
+			dev_err(prev_dev, "No user buffer allocated\n");
+			goto out;
+		}
+
+		vb->width = device->size_params.hsize;
+		vb->height = device->size_params.vsize;
+		vb->field = field;
+		spin_unlock(&device->inout_vbq_lock);
+
+		if (vb->state == VIDEOBUF_NEEDS_INIT) {
+			DPRINTK_PREVIEWER("[%s] baddr = %08x\n", __func__,
+								(int)vb->baddr);
+			err = videobuf_iolock(q, vb, NULL);
+			if (!err) {
+				isp_addr = ispmmu_vmap(device->isp,
+						       dma->sglist,
+						       dma->sglen);
+
+				if (!isp_addr) {
+					err = -EIO;
+				} else {
+					device->isp_addr_read = isp_addr;
+					DPRINTK_PREVIEWER("[%s] isp_addr_read ="
+						" %08x\n", __func__, isp_addr);
+				}
+			}
+		}
+
+		if (!err) {
+			vb->state = VIDEOBUF_PREPARED;
+			flush_cache_user_range(NULL, vb->baddr, (vb->baddr +
+								vb->bsize));
+		} else {
+			previewer_vbq_release(q, vb);
+		}
+
+	} else if (q->type == V4L2_BUF_TYPE_PRIVATE) {
+
+		spin_lock(&device->lsc_vbq_lock);
+
+		if (vb->baddr) {
+			vb->size = lsc_bufsize;
+			vb->bsize = lsc_bufsize;
+			DPRINTK_PREVIEWER("[%s] bsize = %d\n", __func__,
+								vb->bsize);
+		} else {
+			spin_unlock(&device->lsc_vbq_lock);
+			dev_err(prev_dev, "No user buffer allocated\n");
+			goto out;
+		}
+
+		vb->width = device->size_params.hsize;
+		vb->height = device->size_params.vsize;
+		vb->field = field;
+		spin_unlock(&device->lsc_vbq_lock);
+
+		if (vb->state == VIDEOBUF_NEEDS_INIT) {
+			DPRINTK_PREVIEWER("[%s] baddr = %08x\n", __func__,
+								(int)vb->baddr);
+			err = videobuf_iolock(q, vb, NULL);
+			if (!err) {
+				isp_addr = ispmmu_vmap(device->isp,
+						       dma->sglist,
+						       dma->sglen);
+				if (!isp_addr) {
+					err = -EIO;
+				} else {
+					device->isp_addr_lsc = isp_addr;
+					DPRINTK_PREVIEWER("[%s] isp_addr_lsc ="
+						" %08x\n", __func__, isp_addr);
+				}
+			}
+		}
+
+		if (!err) {
+			vb->state = VIDEOBUF_PREPARED;
+			flush_cache_user_range(NULL, vb->baddr, (vb->baddr +
+								vb->bsize));
+		} else {
+			previewer_vbq_release(q, vb);
+		}
+
+	} else {
+		return -EINVAL;
+	}
+
+	dev_dbg(prev_dev, "previewer_vbq_prepare L\n");
+out:
+	return err;
+}
+
+static void previewer_vbq_queue(struct videobuf_queue *q,
+						struct videobuf_buffer *vb)
+{
+	return;
+}
+
+/**
+ * previewer_open - Initializes and opens the Preview Wrapper
+ * @inode: Inode structure associated with the Preview Wrapper
+ * @filp: File structure associated with the Preview Wrapper
+ *
+ * Returns 0 if successful, -EACCES if its unable to initialize default config,
+ * -EBUSY if its already opened or the ISP module is not available, or -ENOMEM
+ * if its unable to allocate the device in kernel space memory.
+ **/
+static int previewer_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct prev_device *device = prevdevice;
+	struct prev_fh *fh;
+	struct device *isp;
+	struct isp_device *isp_dev;
+
+	if (device->opened || (filp->f_flags & O_NONBLOCK)) {
+		dev_err(prev_dev, "previewer_open: device is already "
+								"opened\n");
+		return -EBUSY;
+	}
+
+	fh = kzalloc(sizeof(struct prev_fh), GFP_KERNEL);
+	if (NULL == fh) {
+		ret = -ENOMEM;
+		goto err_fh;
+	}
+
+	isp = isp_get();
+	if (!isp) {
+		printk(KERN_ERR "Can't enable ISP clocks (ret %d)\n", ret);
+		ret = -EACCES;
+		goto err_isp;
+	}
+	device->isp = isp;
+	isp_dev = dev_get_drvdata(isp);
+
+	ret = isppreview_request(&isp_dev->isp_prev);
+	if (ret) {
+		dev_err(prev_dev, "Can't acquire isppreview\n");
+		goto err_prev;
+	}
+
+	device->opened = 1;
+
+	filp->private_data = fh;
+	fh->inout_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fh->lsc_type = V4L2_BUF_TYPE_PRIVATE;
+	fh->device = device;
+
+	videobuf_queue_sg_init(&fh->inout_vbq, &device->vbq_ops, NULL,
+					&device->inout_vbq_lock, fh->inout_type,
+					V4L2_FIELD_NONE,
+					sizeof(struct videobuf_buffer), fh);
+
+	videobuf_queue_sg_init(&fh->lsc_vbq, &device->vbq_ops, NULL,
+					&device->lsc_vbq_lock, fh->lsc_type,
+					V4L2_FIELD_NONE,
+					sizeof(struct videobuf_buffer), fh);
+
+	init_completion(&device->wfc);
+	device->wfc.done = 0;
+	mutex_init(&device->prevwrap_mutex);
+
+	return 0;
+
+err_prev:
+	isp_put();
+err_isp:
+	kfree(fh);
+err_fh:
+	return ret;
+}
+
+/**
+ * previewer_release - Releases Preview Wrapper and frees up allocated memory
+ * @inode: Inode structure associated with the Preview Wrapper
+ * @filp: File structure associated with the Preview Wrapper
+ *
+ * Always returns 0.
+ **/
+static int previewer_release(struct inode *inode, struct file *filp)
+{
+	struct prev_fh *fh = filp->private_data;
+	struct prev_device *device = fh->device;
+	struct isp_device *isp = dev_get_drvdata(device->isp);
+	struct videobuf_queue *q1 = &fh->inout_vbq;
+	struct videobuf_queue *q2 = &fh->lsc_vbq;
+
+	device->opened = 0;
+	videobuf_mmap_free(q1);
+	videobuf_mmap_free(q2);
+	videobuf_queue_cancel(q1);
+	videobuf_queue_cancel(q2);
+	isppreview_free(&isp->isp_prev);
+	isp_put();
+	prev_bufsize = 0;
+	lsc_bufsize = 0;
+	filp->private_data = NULL;
+	kfree(fh);
+
+	dev_dbg(prev_dev, "previewer_release\n");
+	return 0;
+}
+
+/**
+ * previewer_mmap - Memory maps the Preview Wrapper module.
+ * @file: File structure associated with the Preview Wrapper
+ * @vma: Virtual memory area structure.
+ *
+ * Returns 0 if successful, or returned value by the videobuf_mmap_mapper()
+ * function.
+ **/
+static int previewer_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	return -EINVAL;
+}
+
+static int previewer_get_param(struct prev_device *device,
+			       struct prev_params __user *uparams)
+{
+	struct isp_device *isp_dev = dev_get_drvdata(device->isp);
+	struct prev_params *config = &isp_dev->isp_prev.params;
+	struct prev_params params;
+	__u32 *cfa_table;
+	__u32 *ytable;
+	__u32 *redtable;
+	__u32 *greentable;
+	__u32 *bluetable;
+	int ret;
+
+	ret = copy_from_user(&params, uparams, sizeof(params));
+	if (ret) {
+		dev_err(prev_dev, "GET_PARAM: nocopy: %d\n", ret);
+		return -EFAULT;
+	}
+
+	/* Backup user pointers */
+	cfa_table = params.cfa.cfa_table;
+	ytable = params.ytable;
+	redtable = params.gtable.redtable;
+	greentable = params.gtable.greentable;
+	bluetable = params.gtable.bluetable;
+
+	memcpy(&params, config, sizeof(config));
+
+	/* Restore user pointers */
+	params.cfa.cfa_table = cfa_table;
+	params.ytable = ytable;
+	params.gtable.redtable = redtable;
+	params.gtable.greentable = greentable;
+	params.gtable.bluetable = bluetable;
+
+	ret = copy_to_user(uparams, &params, sizeof(struct prev_params));
+	if (ret) {
+		dev_err(prev_dev, "GET_PARAM: nocopy: %d\n", ret);
+		return -EFAULT;
+	}
+
+	return ret;
+}
+
+#define COPY_USERTABLE(dst, src, size)					\
+	if (src) {							\
+		if (!dst)						\
+			return -EACCES;					\
+		if (copy_from_user(dst, src, (size) * sizeof(*(dst))))	\
+			return -EFAULT;					\
+	}
+
+/* Copy preview module configuration into use */
+static int previewer_set_param(struct prev_device *device,
+			       struct prev_params __user *uparams)
+{
+	struct isp_device *isp_dev = dev_get_drvdata(device->isp);
+	struct prev_params *config = &isp_dev->isp_prev.params;
+	/* Here it should be safe to allocate 420 bytes from stack */
+	struct prev_params p;
+	struct prev_params *params = &p;
+	int ret;
+
+	ret = copy_from_user(params, uparams, sizeof(*params));
+	if (ret) {
+		dev_err(prev_dev, "SET_PARAM: nocopy: %d\n", ret);
+		return -EFAULT;
+	}
+	ret = prev_validate_params(params);
+	if (ret < 0)
+		return -EINVAL;
+
+	config->features = params->features;
+	config->pix_fmt = params->pix_fmt;
+	config->cfa.cfafmt = params->cfa.cfafmt;
+
+	/* struct ispprev_cfa */
+	config->cfa.cfa_gradthrs_vert = params->cfa.cfa_gradthrs_vert;
+	config->cfa.cfa_gradthrs_horz = params->cfa.cfa_gradthrs_horz;
+	COPY_USERTABLE(config->cfa.cfa_table, params->cfa.cfa_table,
+			ISPPRV_CFA_TBL_SIZE);
+
+	/* struct ispprev_csup csup */
+	config->csup.gain = params->csup.gain;
+	config->csup.thres = params->csup.thres;
+	config->csup.hypf_en = params->csup.hypf_en;
+
+	COPY_USERTABLE(config->ytable, params->ytable, ISPPRV_YENH_TBL_SIZE);
+
+	/* struct ispprev_nf nf */
+	config->nf.spread = params->nf.spread;
+	memcpy(&config->nf.table, &params->nf.table, sizeof(config->nf.table));
+
+	/* struct ispprev_dcor dcor */
+	config->dcor.couplet_mode_en = params->dcor.couplet_mode_en;
+	memcpy(&config->dcor.detect_correct, &params->dcor.detect_correct,
+		sizeof(config->dcor.detect_correct));
+
+	/* struct ispprev_gtable gtable */
+	COPY_USERTABLE(config->gtable.redtable, params->gtable.redtable,
+		ISPPRV_GAMMA_TBL_SIZE);
+	COPY_USERTABLE(config->gtable.greentable, params->gtable.greentable,
+		ISPPRV_GAMMA_TBL_SIZE);
+	COPY_USERTABLE(config->gtable.bluetable, params->gtable.bluetable,
+		ISPPRV_GAMMA_TBL_SIZE);
+
+	/* struct ispprev_wbal wbal */
+	config->wbal.dgain = params->wbal.dgain;
+	config->wbal.coef3 = params->wbal.coef3;
+	config->wbal.coef2 = params->wbal.coef2;
+	config->wbal.coef1 = params->wbal.coef1;
+	config->wbal.coef0 = params->wbal.coef0;
+
+	/* struct ispprev_blkadj blk_adj */
+	config->blk_adj.red = params->blk_adj.red;
+	config->blk_adj.green = params->blk_adj.green;
+	config->blk_adj.blue = params->blk_adj.blue;
+
+	/* struct ispprev_rgbtorgb rgb2rgb */
+	memcpy(&config->rgb2rgb.matrix, &params->rgb2rgb.matrix,
+		sizeof(config->rgb2rgb.matrix));
+	memcpy(&config->rgb2rgb.offset, &params->rgb2rgb.offset,
+		sizeof(config->rgb2rgb.offset));
+
+	/* struct ispprev_csc rgb2ycbcr */
+	memcpy(&config->rgb2ycbcr.matrix, &params->rgb2ycbcr.matrix,
+		sizeof(config->rgb2ycbcr.matrix));
+	memcpy(&config->rgb2ycbcr.offset, &params->rgb2ycbcr.offset,
+		sizeof(config->rgb2ycbcr.offset));
+
+	/* struct ispprev_hmed hmf_params */
+	config->hmf_params.odddist = params->hmf_params.odddist;
+	config->hmf_params.evendist = params->hmf_params.evendist;
+	config->hmf_params.thres = params->hmf_params.thres;
+
+	/* struct prev_darkfrm_params drkf_params not set here */
+
+	config->lens_shading_shift = params->lens_shading_shift;
+	config->average = params->average;
+	config->contrast = params->contrast;
+	config->brightness = params->brightness;
+
+	device->size_params = params->size_params;
+
+	return 0;
+}
+
+/**
+ * previewer_ioctl - I/O control function for Preview Wrapper
+ * @inode: Inode structure associated with the Preview Wrapper.
+ * @file: File structure associated with the Preview Wrapper.
+ * @cmd: Type of command to execute.
+ * @arg: Argument to send to requested command.
+ *
+ * Returns 0 if successful, -1 if bad command passed or access is denied,
+ * -EFAULT if copy_from_user() or copy_to_user() fails, -EINVAL if parameter
+ * validation fails or parameter structure is not present
+ **/
+static int previewer_ioctl(struct inode *inode, struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct prev_fh *fh = file->private_data;
+	struct prev_device *device = fh->device;
+	struct v4l2_buffer b;
+	struct v4l2_requestbuffers req;
+
+	dev_dbg(prev_dev, "Entering previewer_ioctl()\n");
+
+	if ((_IOC_TYPE(cmd) != PREV_IOC_BASE)
+					|| (_IOC_NR(cmd) > PREV_IOC_MAXNR)) {
+		dev_err(prev_dev, "Bad command Value\n");
+		goto err_minusone;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (ret) {
+		dev_err(prev_dev, "access denied\n");
+		goto err_minusone;
+	}
+
+	switch (cmd) {
+	case PREV_REQBUF:
+		if (copy_from_user(&req, (struct v4l2_requestbuffers *)arg,
+					sizeof(struct v4l2_requestbuffers)))
+			return -EFAULT;
+
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+
+		if (req.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_reqbufs(&fh->inout_vbq, &req);
+		else if (req.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_reqbufs(&fh->lsc_vbq, &req);
+		else
+			ret = -EINVAL;
+
+		if (!ret && copy_to_user((struct v4l2_requestbuffers *)arg,
+				&req, sizeof(struct v4l2_requestbuffers)))
+			ret = -EFAULT;
+
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_QUERYBUF:
+		if (copy_from_user(&b, (struct v4l2_buffer *)arg,
+					sizeof(struct v4l2_buffer)))
+			return -EFAULT;
+
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+
+		if (b.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_querybuf(&fh->inout_vbq, &b);
+		else if (b.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_querybuf(&fh->lsc_vbq, &b);
+		else
+			ret = -EINVAL;
+
+		if (!ret && copy_to_user((struct v4l2_buffer *)arg, &b,
+					sizeof(struct v4l2_buffer)))
+			ret = -EFAULT;
+
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_QUEUEBUF:
+		if (copy_from_user(&b, (struct v4l2_buffer *)arg,
+					sizeof(struct v4l2_buffer)))
+			return -EFAULT;
+
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+
+		if (b.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			ret = videobuf_qbuf(&fh->inout_vbq, &b);
+		else if (b.type == V4L2_BUF_TYPE_PRIVATE)
+			ret = videobuf_qbuf(&fh->lsc_vbq, &b);
+		else
+			ret = -EINVAL;
+
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_SET_PARAM:
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+		ret = previewer_set_param(device, (struct prev_params *)arg);
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_GET_PARAM:
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+		ret = previewer_get_param(device, (struct prev_params *)arg);
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_GET_STATUS:
+	{
+		struct prev_status status;
+
+		ret = prev_get_status(device, &status);
+		if (ret)
+			break;
+
+		if (copy_to_user((struct prev_status *)arg, &status,
+						sizeof(struct prev_status)))
+			ret = -EFAULT;
+		break;
+	}
+
+	case PREV_PREVIEW:
+		if (mutex_lock_interruptible(&device->prevwrap_mutex))
+			goto err_eintr;
+		ret = prev_do_preview(device);
+		mutex_unlock(&device->prevwrap_mutex);
+		break;
+
+	case PREV_GET_CROPSIZE: {
+		struct prev_cropsize outputsize;
+
+		memset(&outputsize, 0, sizeof(outputsize));
+		ret = prev_calculate_crop(device, &outputsize);
+		if (ret)
+			break;
+
+		if (copy_to_user((struct prev_cropsize *)arg, &outputsize,
+						sizeof(struct prev_cropsize)))
+			ret = -EFAULT;
+		break;
+	}
+
+	default:
+		dev_err(prev_dev, "previewer_ioctl: Invalid Command Value\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+err_minusone:
+	return -1;
+err_eintr:
+	return -EINTR;
+}
+
+/**
+ * previewer_platform_release - Acts when Reference count is zero
+ * @device: Structure containing ISP preview wrapper global information
+ *
+ * This is called when the reference count goes to zero
+ **/
+static void previewer_platform_release(struct device *device)
+{
+	dev_dbg(prev_dev, "previewer_platform_release()\n");
+}
+
+static const struct file_operations prev_fops = {
+	.owner = THIS_MODULE,
+	.open = previewer_open,
+	.release = previewer_release,
+	.mmap = previewer_mmap,
+	.ioctl = previewer_ioctl,
+};
+
+static struct platform_device omap_previewer_device = {
+	.name = OMAP_PREV_NAME,
+	.id = -1,
+	.dev = {
+		.release = previewer_platform_release,
+	}
+};
+
+/**
+ * previewer_probe - Checks for device presence
+ * @pdev: Structure containing details of the current device.
+ *
+ * Always returns 0
+ **/
+static int previewer_probe(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/**
+ * previewer_remove - Handles the removal of the driver
+ * @pdev: Structure containing details of the current device.
+ *
+ * Always returns 0.
+ **/
+static int previewer_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver omap_previewer_driver = {
+	.probe = previewer_probe,
+	.remove = previewer_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = OMAP_PREV_NAME,
+	},
+};
+
+/**
+ * omap_previewer_init - Initialization of Preview Wrapper
+ *
+ * Returns 0 if successful, -ENOMEM if could not allocate memory, -ENODEV if
+ * could not register the wrapper as a character device, or other errors if the
+ * device or driver can't register.
+ **/
+static int __init omap_previewer_init(void)
+{
+	int ret;
+	struct prev_device *device;
+
+	device = kzalloc(sizeof(struct prev_device), GFP_KERNEL);
+	if (!device) {
+		dev_err(prev_dev, OMAP_PREV_NAME ": could not allocate"
+								" memory\n");
+		return -ENOMEM;
+	}
+	prev_major = register_chrdev(0, OMAP_PREV_NAME, &prev_fops);
+
+	if (prev_major < 0) {
+		dev_err(prev_dev, OMAP_PREV_NAME ": initialization "
+				"failed. could not register character "
+				"device\n");
+		return -ENODEV;
+	}
+
+	ret = platform_driver_register(&omap_previewer_driver);
+	if (ret) {
+		dev_err(prev_dev, OMAP_PREV_NAME
+			": failed to register platform driver!\n");
+		goto fail2;
+	}
+	ret = platform_device_register(&omap_previewer_device);
+	if (ret) {
+		dev_err(prev_dev, OMAP_PREV_NAME
+			": failed to register platform device!\n");
+		goto fail3;
+	}
+
+	prev_class = class_create(THIS_MODULE, OMAP_PREV_NAME);
+	if (!prev_class)
+		goto fail4;
+
+	prev_dev = device_create(prev_class, prev_dev,
+					MKDEV(prev_major, 0), NULL,
+					OMAP_PREV_NAME);
+	dev_dbg(prev_dev, OMAP_PREV_NAME ": Registered Previewer Wrapper\n");
+	device->opened = 0;
+
+	device->vbq_ops.buf_setup = previewer_vbq_setup;
+	device->vbq_ops.buf_prepare = previewer_vbq_prepare;
+	device->vbq_ops.buf_release = previewer_vbq_release;
+	device->vbq_ops.buf_queue = previewer_vbq_queue;
+	spin_lock_init(&device->inout_vbq_lock);
+	spin_lock_init(&device->lsc_vbq_lock);
+	prevdevice = device;
+	return 0;
+
+fail4:
+	platform_device_unregister(&omap_previewer_device);
+fail3:
+	platform_driver_unregister(&omap_previewer_driver);
+fail2:
+	unregister_chrdev(prev_major, OMAP_PREV_NAME);
+
+	return ret;
+}
+
+/**
+ * omap_previewer_exit - Close of Preview Wrapper
+ **/
+static void __exit omap_previewer_exit(void)
+{
+	device_destroy(prev_class, MKDEV(prev_major, 0));
+	class_destroy(prev_class);
+	platform_device_unregister(&omap_previewer_device);
+	platform_driver_unregister(&omap_previewer_driver);
+	unregister_chrdev(prev_major, OMAP_PREV_NAME);
+
+	kfree(prevdevice);
+	prev_major = -1;
+}
+
+module_init(omap_previewer_init);
+module_exit(omap_previewer_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("OMAP ISP Previewer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/omap_previewer.h b/drivers/media/video/isp/omap_previewer.h
new file mode 100644
index 0000000..a70113d
--- /dev/null
+++ b/drivers/media/video/isp/omap_previewer.h
@@ -0,0 +1,171 @@
+/*
+ * drivers/media/video/isp/omap_previewer.h
+ *
+ * Header file for Preview module wrapper in TI's OMAP3430 ISP
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Leonides Martinez <leonides.martinez@ti.com>
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "isppreview.h"
+
+#ifndef OMAP_ISP_PREVIEW_WRAP_H
+#define OMAP_ISP_PREVIEW_WRAP_H
+
+#define PREV_IOC_BASE			'P'
+#define PREV_REQBUF			_IOWR(PREV_IOC_BASE, 1,\
+						struct v4l2_requestbuffers)
+#define PREV_QUERYBUF			_IOWR(PREV_IOC_BASE, 2,\
+							struct v4l2_buffer)
+#define PREV_SET_PARAM			_IOW(PREV_IOC_BASE, 3,\
+							struct prev_params)
+#define PREV_GET_PARAM			_IOWR(PREV_IOC_BASE, 4,\
+							struct prev_params)
+#define PREV_PREVIEW			_IOR(PREV_IOC_BASE, 5, int)
+#define PREV_GET_STATUS			_IOR(PREV_IOC_BASE, 6, char)
+#define PREV_GET_CROPSIZE		_IOR(PREV_IOC_BASE, 7,\
+							struct prev_cropsize)
+#define PREV_QUEUEBUF			_IOWR(PREV_IOC_BASE, 8,\
+							struct v4l2_buffer)
+#define PREV_IOC_MAXNR			8
+
+#define LUMA_TABLE_SIZE			128
+#define GAMMA_TABLE_SIZE		1024
+#define CFA_COEFF_TABLE_SIZE		576
+#define NOISE_FILTER_TABLE_SIZE		256
+
+#define MAX_IMAGE_WIDTH			3300
+
+#define PREV_INWIDTH_8BIT		0	/* pixel width of 8 bits */
+#define PREV_INWIDTH_10BIT		1	/* pixel width of 10 bits */
+
+#define PREV_32BYTES_ALIGN_MASK		0xFFFFFFE0
+#define PREV_16PIX_ALIGN_MASK		0xFFFFFFF0
+
+/**
+ * struct prev_rgbblending - Structure for RGB2RGB blending parameters
+ * @blending: Color correlation 3x3 matrix.
+ * @offset: Color correlation offsets.
+ */
+struct prev_rgbblending {
+	short blending[RGB_MAX][RGB_MAX];	/* color correlation 3x3
+						 * matrix.
+						 */
+	short offset[RGB_MAX];			/* color correlation offsets */
+};
+
+/**
+ * struct prev_cfa_coeffs - Structure for CFA coefficients
+ * @hthreshold: Horizontal threshold.
+ * @vthreshold: Vertical threshold.
+ * @coeffs: CFA coefficients
+ */
+struct prev_cfa_coeffs {
+	char hthreshold, vthreshold;
+	int coeffs[CFA_COEFF_TABLE_SIZE];
+};
+
+/**
+ * struct prev_gamma_coeffs - Structure for Gamma Coefficients
+ * @red: Table of gamma correction values for red color.
+ * @green: Table of gamma correction values for green color.
+ * @blue: Table of gamma correction values for blue color.
+ */
+struct prev_gamma_coeffs {
+	unsigned char red[GAMMA_TABLE_SIZE];
+	unsigned char green[GAMMA_TABLE_SIZE];
+	unsigned char blue[GAMMA_TABLE_SIZE];
+};
+
+/**
+ * struct prev_noiseflt_coeffs - Structure for Noise Filter Coefficients.
+ * @noise: Noise filter table.
+ * @strength: Used to find out weighted average.
+ */
+struct prev_noiseflt_coeffs {
+	unsigned char noise[NOISE_FILTER_TABLE_SIZE];
+	unsigned char strength;
+};
+
+/**
+ * struct prev_chroma_spr - Structure for Chroma Suppression.
+ * @hpfy: High passed version of Y or normal Y.
+ * @threshold: Threshold for chroma suppress.
+ * @gain: Chroma suppression gain
+ */
+struct prev_chroma_spr {
+	unsigned char hpfy;
+	char threshold;
+	unsigned char gain;
+};
+
+/**
+ * struct prev_status - Structure to know status of the hardware
+ * @hw_busy: Flag to indicate if Hardware is Busy.
+ */
+struct prev_status {
+	char hw_busy;
+};
+
+/**
+ * struct prev_cropsize - Structure to know crop size.
+ * @hcrop: Horizontal size of crop window.
+ * @vcrop: Vertical size of crop window.
+ */
+struct prev_cropsize {
+	int hcrop;
+	int vcrop;
+};
+
+/**
+ * struct prev_device - Global device information structure.
+ * @params: Pointer to structure containing preview parameters.
+ * @opened: State of the device.
+ * @wfc: Wait for completion. Used for locking operations.
+ * @prevwrap_mutex: Mutex for preview wrapper use.
+ * @inout_vbq_lock: Spinlock for in/out videobuf queues.
+ * @lsc_vbq_lock: Spinlock for LSC videobuf queues.
+ * @vbq_ops: Videobuf queue operations
+ * @isp_addr_read: Input/Output address
+ * @isp_addr_read: LSC address
+ */
+struct prev_device {
+	unsigned char opened;
+	struct completion wfc;
+	struct mutex prevwrap_mutex;
+	spinlock_t inout_vbq_lock; /* Spinlock for in/out videobuf queues. */
+	spinlock_t lsc_vbq_lock; /* Spinlock for LSC videobuf queues. */
+	struct videobuf_queue_ops vbq_ops;
+	dma_addr_t isp_addr_read;
+	dma_addr_t isp_addr_lsc;
+	struct device *isp;
+	struct prev_size_params size_params;
+};
+
+/**
+ * struct prev_fh - Per-filehandle data structure
+ * @inout_type: Used buffer type for I/O.
+ * @inout_vbq: I/O Videobuffer queue.
+ * @lsc_type: Used buffer type for LSC.
+ * @lsc_vbq: LSC Videobuffer queue.
+ * @device: Pointer to device information structure.
+ */
+struct prev_fh {
+	enum v4l2_buf_type inout_type;
+	struct videobuf_queue inout_vbq;
+	enum v4l2_buf_type lsc_type;
+	struct videobuf_queue lsc_vbq;
+	struct prev_device *device;
+};
+#endif
diff --git a/drivers/media/video/isp/omap_resizer.c b/drivers/media/video/isp/omap_resizer.c
new file mode 100644
index 0000000..9ba753c
--- /dev/null
+++ b/drivers/media/video/isp/omap_resizer.c
@@ -0,0 +1,1895 @@
+/*
+ * drivers/media/video/isp/omap_resizer.c
+ *
+ * Wrapper for Resizer module in TI's OMAP3430 ISP
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * Contributors:
+ *	Sergio Aguirre <saaguirre@ti.com>
+ *	Troy Laramy <t-laramy@ti.com>
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/pci.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-dev.h>
+#include <asm/cacheflush.h>
+
+#include "isp.h"
+#include "ispreg.h"
+#include "ispresizer.h"
+#include <linux/omap_resizer.h>
+
+#define OMAP_REZR_NAME		"omap-resizer"
+
+/* Defines and Constants*/
+#define MAX_CHANNELS		16
+#define MAX_IMAGE_WIDTH		2047
+#define MAX_IMAGE_WIDTH_HIGH	2047
+#define ALIGNMENT		16
+#define CHANNEL_BUSY		1
+#define CHANNEL_FREE		0
+#define PIXEL_EVEN		2
+#define RATIO_MULTIPLIER	256
+/* Bit position Macro */
+/* macro for bit set and clear */
+#define BITSET(variable, bit)	((variable) | (1 << bit))
+#define BITRESET(variable, bit)	((variable) & ~(0x00000001 << (bit)))
+#define SET_BIT_INPUTRAM	28
+#define SET_BIT_CBLIN		29
+#define SET_BIT_INPTYP		27
+#define SET_BIT_YCPOS		26
+#define INPUT_RAM		1
+#define UP_RSZ_RATIO		64
+#define DOWN_RSZ_RATIO		512
+#define UP_RSZ_RATIO1		513
+#define DOWN_RSZ_RATIO1		1024
+#define RSZ_IN_SIZE_VERT_SHIFT	16
+#define MAX_HORZ_PIXEL_8BIT	31
+#define MAX_HORZ_PIXEL_16BIT	15
+#define NUM_PHASES		8
+#define NUM_TAPS		4
+#define NUM_D2PH		4	/* for downsampling * 2+x ~ 4x,
+					 * number of phases
+					 */
+#define NUM_D2TAPS		7	/* for downsampling * 2+x ~ 4x,
+					 * number of taps
+					 */
+#define ALIGN32			32
+#define MAX_COEF_COUNTER	16
+#define COEFF_ADDRESS_OFFSET	0x04
+
+#define RSZ_DEF_REQ_EXP		0x0	/* Default read operation expand
+					 * for the Resizer driver
+					 */
+/* Global structure which contains information about number of channels
+   and protection variables */
+struct device_params {
+
+	unsigned char opened;			/* state of the device */
+	struct completion compl_isr;		/* Completion for interrupt */
+	struct mutex reszwrap_mutex;		/* Semaphore for array */
+
+	struct videobuf_queue_ops vbq_ops;	/* videobuf queue operations */
+	unsigned long extra_page_addr;
+};
+
+/* Register mapped structure which contains the every register
+   information */
+struct resizer_config {
+	u32 rsz_pcr;				/* pcr register mapping
+						 * variable.
+						 */
+	u32 rsz_in_start;			/* in_start register mapping
+						 * variable.
+						 */
+	u32 rsz_in_size;			/* in_size register mapping
+						 * variable.
+						 */
+	u32 rsz_out_size;			/* out_size register mapping
+						 * variable.
+						 */
+	u32 rsz_cnt;				/* rsz_cnt register mapping
+						 * variable.
+						 */
+	u32 rsz_sdr_inadd;			/* sdr_inadd register mapping
+						 * variable.
+						 */
+	u32 rsz_sdr_inoff;			/* sdr_inoff register mapping
+						 * variable.
+						 */
+	u32 rsz_sdr_outadd;			/* sdr_outadd register mapping
+						 * variable.
+						 */
+	u32 rsz_sdr_outoff;			/* sdr_outbuff register
+						 * mapping variable.
+						 */
+	u32 rsz_coeff_horz[16];			/* horizontal coefficients
+						 * mapping array.
+						 */
+	u32 rsz_coeff_vert[16];			/* vertical coefficients
+						 * mapping array.
+						 */
+	u32 rsz_yehn;				/* yehn(luma)register mapping
+						 * variable.
+						 */
+	u32 sdr_req_exp;			/* Configuration for Read
+						 * cycle Expand
+						 */
+};
+
+struct rsz_mult {
+	int in_hsize;				/* input frame horizontal
+						 * size.
+						 */
+	int in_vsize;				/* input frame vertical size.
+						 */
+	int out_hsize;				/* output frame horizontal
+						 * size.
+						 */
+	int out_vsize;				/* output frame vertical
+						 * size.
+						 */
+	int in_pitch;				/* offset between two rows of
+						 * input frame.
+						 */
+	int out_pitch;				/* offset between two rows of
+						 * output frame.
+						 */
+	int end_hsize;
+	int end_vsize;
+	int num_htap;				/* 0 = 7tap; 1 = 4tap */
+	int num_vtap;				/* 0 = 7tap; 1 = 4tap */
+	int active;
+	int inptyp;
+	int vrsz;
+	int hrsz;
+	int hstph;				/* for specifying horizontal
+						 * starting phase.
+						 */
+	int vstph;
+	int pix_fmt;				/* # defined, UYVY or YUYV. */
+	int cbilin;				/* # defined, filter with luma
+						 * or bi-linear.
+						 */
+	u16 tap4filt_coeffs[32];		/* horizontal filter
+						 * coefficients.
+						 */
+	u16 tap7filt_coeffs[32];		/* vertical filter
+						 * coefficients.
+						 */
+};
+/* Channel specific structure contains information regarding
+   the every channel */
+struct channel_config {
+	struct resizer_config register_config;	/* Instance of register set
+						 * mapping structure
+						 */
+	int status;				/* Specifies whether the
+						 * channel is busy or not
+						 */
+	struct mutex chanprotection_mutex;
+	int buf_address[VIDEO_MAX_FRAME];
+	enum config_done config_state;
+	u8 input_buf_index;
+	u8 output_buf_index;
+
+};
+
+/* per-filehandle data structure */
+struct rsz_fh {
+	struct rsz_params *params;
+	struct channel_config *config;
+	struct rsz_mult *multipass;		/* Multipass to support
+						 * resizing ration outside
+						 * of 0.25x to 4x
+						 */
+	spinlock_t vbq_lock;			/* spinlock for videobuf
+						 * queues.
+						 */
+	enum v4l2_buf_type type;
+	struct videobuf_queue vbq;
+	struct device_params *device;
+
+	u32 rsz_bufsize;			/* channel specific buffersize
+						 */
+	struct device *dev;			/*
+						 * Device structure contains
+						 * whole ISP related data
+						 */
+};
+
+static struct device_params *device_config;
+static struct device *rsz_device;
+static bool is_vm_io;
+static int rsz_major = -1;
+/* functions declaration */
+static void rsz_hardware_setup(struct channel_config *rsz_conf_chan);
+static int rsz_set_params(struct rsz_mult *multipass, struct rsz_params *,
+						struct channel_config *);
+static int rsz_get_params(struct rsz_params *, struct channel_config *);
+static void rsz_copy_data(struct rsz_mult *multipass,
+						struct rsz_params *params);
+static void rsz_isr(unsigned long status, isp_vbq_callback_ptr arg1,
+						void *arg2);
+static void rsz_calculate_crop(struct channel_config *rsz_conf_chan,
+					struct rsz_cropsize *cropsize);
+static int rsz_set_multipass(struct rsz_mult *multipass,
+					struct channel_config *rsz_conf_chan);
+static int rsz_set_ratio(struct rsz_mult *multipass,
+					struct channel_config *rsz_conf_chan);
+static void rsz_config_ratio(struct rsz_mult *multipass,
+					struct channel_config *rsz_conf_chan);
+
+static inline void rsz_set_exp(unsigned int exp)
+{
+	omap_writel(((exp & 0x3FF) << 10), OMAP3ISP_SBL_REG(0xF8));
+}
+/**
+ * rsz_hardware_setup - Sets hardware configuration registers
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Set hardware configuration registers
+ **/
+static void rsz_hardware_setup(struct channel_config *rsz_conf_chan)
+{
+	int coeffcounter;
+	int coeffoffset = 0;
+
+	omap_writel(rsz_conf_chan->register_config.rsz_cnt,
+					OMAP3ISP_RESZ_REG(ISPRSZ_CNT));
+
+	omap_writel(rsz_conf_chan->register_config.rsz_in_start,
+					OMAP3ISP_RESZ_REG(ISPRSZ_IN_START));
+	omap_writel(rsz_conf_chan->register_config.rsz_in_size,
+					OMAP3ISP_RESZ_REG(ISPRSZ_IN_SIZE));
+
+	omap_writel(rsz_conf_chan->register_config.rsz_out_size,
+					OMAP3ISP_RESZ_REG(ISPRSZ_OUT_SIZE));
+	omap_writel(rsz_conf_chan->register_config.rsz_sdr_inadd,
+					OMAP3ISP_RESZ_REG(ISPRSZ_SDR_INADD));
+	omap_writel(rsz_conf_chan->register_config.rsz_sdr_inoff,
+					OMAP3ISP_RESZ_REG(ISPRSZ_SDR_INOFF));
+	omap_writel(rsz_conf_chan->register_config.rsz_sdr_outadd,
+					OMAP3ISP_RESZ_REG(ISPRSZ_SDR_OUTADD));
+	omap_writel(rsz_conf_chan->register_config.rsz_sdr_outoff,
+					OMAP3ISP_RESZ_REG(ISPRSZ_SDR_OUTOFF));
+	omap_writel(rsz_conf_chan->register_config.rsz_yehn,
+					OMAP3ISP_RESZ_REG(ISPRSZ_YENH));
+
+	for (coeffcounter = 0; coeffcounter < MAX_COEF_COUNTER;
+							coeffcounter++) {
+		omap_writel(rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter],
+					OMAP3ISP_RESZ_REG(ISPRSZ_HFILT10
+						+ coeffoffset));
+
+		omap_writel(rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter],
+					OMAP3ISP_RESZ_REG(ISPRSZ_VFILT10
+						+ coeffoffset));
+		coeffoffset = coeffoffset + COEFF_ADDRESS_OFFSET;
+	}
+	/* Configure the read expand register */
+	rsz_set_exp(rsz_conf_chan->register_config.sdr_req_exp);
+}
+
+/**
+ * rsz_start - Enables Resizer Wrapper
+ * @arg: Currently not used.
+ * @fh: File structure containing ISP resizer information specific to
+ *      channel opened.
+ *
+ * Submits a resizing task specified by the rsz_resize structure. The call can
+ * either be blocked until the task is completed or returned immediately based
+ * on the value of the blocking argument in the rsz_resize structure. If it is
+ * blocking, the status of the task can be checked by calling ioctl
+ * RSZ_G_STATUS. Only one task can be outstanding for each logical channel.
+ *
+ * Returns 0 if successful, or -EINVAL if could not set callback for RSZR IRQ
+ * event or the state of the channel is not configured.
+ **/
+int rsz_start(int *arg, struct rsz_fh *fh)
+{
+	struct channel_config *rsz_conf_chan = fh->config;
+	struct rsz_mult *multipass = fh->multipass;
+	struct videobuf_queue *q = &fh->vbq;
+	struct videobuf_buffer *buf;
+	struct isp_device *isp = dev_get_drvdata(fh->dev);
+	int ret;
+
+	if (rsz_conf_chan->config_state) {
+		dev_err(rsz_device, "State not configured\n");
+		goto err_einval;
+	}
+	if (!rsz_conf_chan->register_config.rsz_sdr_inadd ||
+			!rsz_conf_chan->register_config.rsz_sdr_outadd) {
+		dev_err(rsz_device, "address is null\n");
+		goto err_einval;
+	}
+
+	rsz_conf_chan->status = CHANNEL_BUSY;
+
+	rsz_hardware_setup(rsz_conf_chan);
+
+	if (isp_set_callback(fh->dev, CBK_RESZ_DONE, rsz_isr, (void *) NULL,
+							(void *)NULL)) {
+		dev_err(rsz_device, "No callback for RSZR\n");
+		goto err_einval;
+	}
+mult:
+	device_config->compl_isr.done = 0;
+
+	ispresizer_enable(&isp->isp_res, 1);
+
+	ret = wait_for_completion_interruptible(&device_config->compl_isr);
+	if (ret != 0) {
+		dev_dbg(rsz_device, "Unexpected exit from "
+				"wait_for_completion_interruptible\n");
+		wait_for_completion(&device_config->compl_isr);
+	}
+
+	if (multipass->active) {
+		rsz_set_multipass(multipass, rsz_conf_chan);
+		goto mult;
+	}
+
+	rsz_conf_chan->status = CHANNEL_FREE;
+	rsz_conf_chan->register_config.rsz_sdr_outadd = 0;
+	rsz_conf_chan->register_config.rsz_sdr_inadd = 0;
+
+	isp_unset_callback(fh->dev, CBK_RESZ_DONE);
+
+	/* Empty the Videobuf queue which was filled during the qbuf */
+	buf = q->bufs[rsz_conf_chan->input_buf_index];
+	buf->state = VIDEOBUF_IDLE;
+	list_del(&buf->stream);
+	if (rsz_conf_chan->input_buf_index != rsz_conf_chan->output_buf_index) {
+		buf = q->bufs[rsz_conf_chan->output_buf_index];
+		buf->state = VIDEOBUF_IDLE;
+		list_del(&buf->stream);
+	}
+
+	return 0;
+err_einval:
+	return -EINVAL;
+}
+
+/**
+ * rsz_set_multipass - Set resizer multipass
+ * @multipass: Structure containing channel configuration
+			for multipass support
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Returns always 0
+ **/
+static int rsz_set_multipass(struct rsz_mult *multipass,
+			struct channel_config *rsz_conf_chan)
+{
+	multipass->in_hsize = multipass->out_hsize;
+	multipass->in_vsize = multipass->out_vsize;
+	multipass->out_hsize = multipass->end_hsize;
+	multipass->out_vsize = multipass->end_vsize;
+
+	multipass->out_pitch = (multipass->inptyp ? multipass->out_hsize
+						: (multipass->out_hsize * 2));
+	multipass->in_pitch = (multipass->inptyp ? multipass->in_hsize
+						: (multipass->in_hsize * 2));
+
+	rsz_set_ratio(multipass, rsz_conf_chan);
+	rsz_config_ratio(multipass, rsz_conf_chan);
+	rsz_hardware_setup(rsz_conf_chan);
+	return 0;
+}
+
+/**
+ * rsz_copy_data - Copy data
+ * @multipass: Structure containing channel configuration
+			for multipass support
+ * @params: Structure containing the Resizer Wrapper parameters
+ *
+ * Copy data
+ **/
+static void rsz_copy_data(struct rsz_mult *multipass, struct rsz_params *params)
+{
+	int i;
+	multipass->in_hsize = params->in_hsize;
+	multipass->in_vsize = params->in_vsize;
+	multipass->out_hsize = params->out_hsize;
+	multipass->out_vsize = params->out_vsize;
+	multipass->end_hsize = params->out_hsize;
+	multipass->end_vsize = params->out_vsize;
+	multipass->in_pitch = params->in_pitch;
+	multipass->out_pitch = params->out_pitch;
+	multipass->hstph = params->hstph;
+	multipass->vstph = params->vstph;
+	multipass->inptyp = params->inptyp;
+	multipass->pix_fmt = params->pix_fmt;
+	multipass->cbilin = params->cbilin;
+
+	for (i = 0; i < 32; i++) {
+		multipass->tap4filt_coeffs[i] = params->tap4filt_coeffs[i];
+		multipass->tap7filt_coeffs[i] = params->tap7filt_coeffs[i];
+	}
+}
+
+/**
+ * rsz_set_params - Set parameters for resizer wrapper
+ * @multipass: Structure containing channel configuration
+			for multipass support
+ * @params: Structure containing the Resizer Wrapper parameters
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Used to set the parameters of the Resizer hardware, including input and
+ * output image size, horizontal and vertical poly-phase filter coefficients,
+ * luma enchancement filter coefficients, etc.
+ **/
+static int rsz_set_params(struct rsz_mult *multipass, struct rsz_params *params,
+					struct channel_config *rsz_conf_chan)
+{
+	int mul = 1;
+	if ((params->yenh_params.type < 0) || (params->yenh_params.type > 2)) {
+		dev_err(rsz_device, "rsz_set_params: Wrong yenh type\n");
+		return -EINVAL;
+	}
+	if ((params->in_vsize <= 0) || (params->in_hsize <= 0) ||
+			(params->out_vsize <= 0) || (params->out_hsize <= 0) ||
+			(params->in_pitch <= 0) || (params->out_pitch <= 0)) {
+		dev_err(rsz_device, "rsz_set_params: Invalid size params\n");
+		return -EINVAL;
+	}
+	if ((params->inptyp != RSZ_INTYPE_YCBCR422_16BIT) &&
+			(params->inptyp != RSZ_INTYPE_PLANAR_8BIT)) {
+		dev_err(rsz_device, "rsz_set_params: Invalid input type\n");
+		return -EINVAL;
+	}
+	if ((params->pix_fmt != RSZ_PIX_FMT_UYVY) &&
+			(params->pix_fmt != RSZ_PIX_FMT_YUYV)) {
+		dev_err(rsz_device, "rsz_set_params: Invalid pixel format\n");
+		return -EINVAL;
+	}
+	if (params->inptyp == RSZ_INTYPE_YCBCR422_16BIT)
+		mul = 2;
+	else
+		mul = 1;
+	if (params->in_pitch < (params->in_hsize * mul)) {
+		dev_err(rsz_device, "rsz_set_params: Pitch is incorrect\n");
+		return -EINVAL;
+	}
+	if (params->out_pitch < (params->out_hsize * mul)) {
+		dev_err(rsz_device, "rsz_set_params: Out pitch cannot be less"
+					" than out hsize\n");
+		return -EINVAL;
+	}
+	/* Output H size should be even */
+	if ((params->out_hsize % PIXEL_EVEN) != 0) {
+		dev_err(rsz_device, "rsz_set_params: Output H size should"
+					" be even\n");
+		return -EINVAL;
+	}
+	if (params->horz_starting_pixel < 0) {
+		dev_err(rsz_device, "rsz_set_params: Horz start pixel cannot"
+					" be less than zero\n");
+		return -EINVAL;
+	}
+
+	rsz_copy_data(multipass, params);
+	if (0 != rsz_set_ratio(multipass, rsz_conf_chan))
+		goto err_einval;
+
+	if (params->yenh_params.type) {
+		if ((multipass->num_htap && multipass->out_hsize >
+				1280) ||
+				(!multipass->num_htap && multipass->out_hsize >
+				640))
+			goto err_einval;
+	}
+
+	if (INPUT_RAM)
+		params->vert_starting_pixel = 0;
+
+	rsz_conf_chan->register_config.rsz_in_start =
+						(params->vert_starting_pixel
+						<< ISPRSZ_IN_SIZE_VERT_SHIFT)
+						& ISPRSZ_IN_SIZE_VERT_MASK;
+
+	if (params->inptyp == RSZ_INTYPE_PLANAR_8BIT) {
+		if (params->horz_starting_pixel > MAX_HORZ_PIXEL_8BIT)
+			goto err_einval;
+	}
+	if (params->inptyp == RSZ_INTYPE_YCBCR422_16BIT) {
+		if (params->horz_starting_pixel > MAX_HORZ_PIXEL_16BIT)
+			goto err_einval;
+	}
+
+	rsz_conf_chan->register_config.rsz_in_start |=
+						params->horz_starting_pixel
+						& ISPRSZ_IN_START_HORZ_ST_MASK;
+
+	rsz_conf_chan->register_config.rsz_yehn =
+						(params->yenh_params.type
+						<< ISPRSZ_YENH_ALGO_SHIFT)
+						& ISPRSZ_YENH_ALGO_MASK;
+
+	if (params->yenh_params.type) {
+		rsz_conf_chan->register_config.rsz_yehn |=
+						params->yenh_params.core
+						& ISPRSZ_YENH_CORE_MASK;
+
+		rsz_conf_chan->register_config.rsz_yehn |=
+						(params->yenh_params.gain
+						<< ISPRSZ_YENH_GAIN_SHIFT)
+						& ISPRSZ_YENH_GAIN_MASK;
+
+		rsz_conf_chan->register_config.rsz_yehn |=
+						(params->yenh_params.slop
+						<< ISPRSZ_YENH_SLOP_SHIFT)
+						& ISPRSZ_YENH_SLOP_MASK;
+	}
+
+	rsz_config_ratio(multipass, rsz_conf_chan);
+	/* Default value for read expand:Taken from Davinci */
+	rsz_conf_chan->register_config.sdr_req_exp = RSZ_DEF_REQ_EXP;
+
+	rsz_conf_chan->config_state = STATE_CONFIGURED;
+
+	return 0;
+err_einval:
+	return -EINVAL;
+}
+
+/**
+ * rsz_set_ratio - Set ratio
+ * @multipass: Structure containing channel configuration
+			for multipass support
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Returns 0 if successful, -EINVAL if invalid output size, upscaling ratio is
+ * being requested, or other ratio configuration value is out of bounds
+ **/
+static int rsz_set_ratio(struct rsz_mult *multipass,
+				struct channel_config *rsz_conf_chan)
+{
+	int alignment = 0;
+
+	rsz_conf_chan->register_config.rsz_cnt = 0;
+
+	if ((multipass->out_hsize > MAX_IMAGE_WIDTH) ||
+			(multipass->out_vsize > MAX_IMAGE_WIDTH)) {
+		dev_err(rsz_device, "Invalid output size! - %d", \
+					multipass->out_hsize);
+		goto err_einval;
+	}
+	if (multipass->cbilin) {
+		rsz_conf_chan->register_config.rsz_cnt =
+				BITSET(rsz_conf_chan->register_config.rsz_cnt,
+				SET_BIT_CBLIN);
+	}
+	if (INPUT_RAM) {
+		rsz_conf_chan->register_config.rsz_cnt =
+				BITSET(rsz_conf_chan->register_config.rsz_cnt,
+				SET_BIT_INPUTRAM);
+	}
+	if (multipass->inptyp == RSZ_INTYPE_PLANAR_8BIT) {
+		rsz_conf_chan->register_config.rsz_cnt =
+				BITSET(rsz_conf_chan->register_config.rsz_cnt,
+				SET_BIT_INPTYP);
+	} else {
+		rsz_conf_chan->register_config.rsz_cnt =
+				BITRESET(rsz_conf_chan->register_config.
+				rsz_cnt, SET_BIT_INPTYP);
+
+		if (multipass->pix_fmt == RSZ_PIX_FMT_UYVY) {
+			rsz_conf_chan->register_config.rsz_cnt =
+				BITRESET(rsz_conf_chan->register_config.
+				rsz_cnt, SET_BIT_YCPOS);
+		} else if (multipass->pix_fmt == RSZ_PIX_FMT_YUYV) {
+			rsz_conf_chan->register_config.rsz_cnt =
+					BITSET(rsz_conf_chan->register_config.
+					rsz_cnt, SET_BIT_YCPOS);
+		}
+
+	}
+	multipass->vrsz =
+		(multipass->in_vsize * RATIO_MULTIPLIER) / multipass->out_vsize;
+	multipass->hrsz =
+		(multipass->in_hsize * RATIO_MULTIPLIER) / multipass->out_hsize;
+	if (UP_RSZ_RATIO > multipass->vrsz || UP_RSZ_RATIO > multipass->hrsz) {
+		dev_err(rsz_device, "Upscaling ratio not supported!");
+		goto err_einval;
+	}
+	multipass->vrsz = (multipass->in_vsize - NUM_D2TAPS) * RATIO_MULTIPLIER
+						/ (multipass->out_vsize - 1);
+	multipass->hrsz = ((multipass->in_hsize - NUM_D2TAPS)
+						* RATIO_MULTIPLIER) /
+						(multipass->out_hsize - 1);
+
+	if (multipass->hrsz <= 512) {
+		multipass->hrsz = (multipass->in_hsize - NUM_TAPS)
+						* RATIO_MULTIPLIER
+						/ (multipass->out_hsize - 1);
+		if (multipass->hrsz < 64)
+			multipass->hrsz = 64;
+		if (multipass->hrsz > 512)
+			multipass->hrsz = 512;
+		if (multipass->hstph > NUM_PHASES)
+			goto err_einval;
+		multipass->num_htap = 1;
+	} else if (multipass->hrsz >= 513 && multipass->hrsz <= 1024) {
+		if (multipass->hstph > NUM_D2PH)
+			goto err_einval;
+		multipass->num_htap = 0;
+	}
+
+	if (multipass->vrsz <= 512) {
+		multipass->vrsz = (multipass->in_vsize - NUM_TAPS)
+						* RATIO_MULTIPLIER
+						/ (multipass->out_vsize - 1);
+		if (multipass->vrsz < 64)
+			multipass->vrsz = 64;
+		if (multipass->vrsz > 512)
+			multipass->vrsz = 512;
+		if (multipass->vstph > NUM_PHASES)
+			goto err_einval;
+		multipass->num_vtap = 1;
+	} else if (multipass->vrsz >= 513 && multipass->vrsz <= 1024) {
+		if (multipass->vstph > NUM_D2PH)
+			goto err_einval;
+		multipass->num_vtap = 0;
+	}
+
+	if ((multipass->in_pitch) % ALIGN32) {
+		dev_err(rsz_device, "Invalid input pitch: %d\n",
+							multipass->in_pitch);
+		goto err_einval;
+	}
+	if ((multipass->out_pitch) % ALIGN32) {
+		dev_err(rsz_device, "Invalid output pitch %d\n",
+							multipass->out_pitch);
+		goto err_einval;
+	}
+
+	if (multipass->vrsz < 256 &&
+			(multipass->in_vsize < multipass->out_vsize)) {
+		if (multipass->inptyp == RSZ_INTYPE_PLANAR_8BIT)
+			alignment = ALIGNMENT;
+		else if (multipass->inptyp == RSZ_INTYPE_YCBCR422_16BIT)
+			alignment = (ALIGNMENT / 2);
+		else
+			dev_err(rsz_device, "Invalid input type\n");
+
+		if (!(((multipass->out_hsize % PIXEL_EVEN) == 0)
+				&& (multipass->out_hsize % alignment) == 0)) {
+			dev_err(rsz_device, "wrong hsize\n");
+			goto err_einval;
+		}
+	}
+	if (multipass->hrsz >= 64 && multipass->hrsz <= 1024) {
+		if (multipass->out_hsize > MAX_IMAGE_WIDTH) {
+			dev_err(rsz_device, "wrong width\n");
+			goto err_einval;
+		}
+		multipass->active = 0;
+
+	} else if (multipass->hrsz > 1024) {
+		if (multipass->out_hsize > MAX_IMAGE_WIDTH) {
+			dev_err(rsz_device, "wrong width\n");
+			goto err_einval;
+		}
+		if (multipass->hstph > NUM_D2PH)
+			goto err_einval;
+		multipass->num_htap = 0;
+		multipass->out_hsize = multipass->in_hsize * 256 / 1024;
+		if (multipass->out_hsize % ALIGN32) {
+			multipass->out_hsize +=
+				abs((multipass->out_hsize % ALIGN32) - ALIGN32);
+		}
+		multipass->out_pitch = ((multipass->inptyp) ?
+						multipass->out_hsize :
+						(multipass->out_hsize * 2));
+		multipass->hrsz = ((multipass->in_hsize - NUM_D2TAPS)
+						* RATIO_MULTIPLIER)
+						/ (multipass->out_hsize - 1);
+		multipass->active = 1;
+
+	}
+
+	if (multipass->vrsz > 1024) {
+		if (multipass->out_vsize > MAX_IMAGE_WIDTH_HIGH) {
+			dev_err(rsz_device, "wrong width\n");
+			goto err_einval;
+		}
+
+		multipass->out_vsize = multipass->in_vsize * 256 / 1024;
+		multipass->vrsz = ((multipass->in_vsize - NUM_D2TAPS)
+						* RATIO_MULTIPLIER)
+						/ (multipass->out_vsize - 1);
+		multipass->active = 1;
+		multipass->num_vtap = 0;
+
+	}
+	rsz_conf_chan->register_config.rsz_out_size =
+						multipass->out_hsize
+						& ISPRSZ_OUT_SIZE_HORZ_MASK;
+
+	rsz_conf_chan->register_config.rsz_out_size |=
+						(multipass->out_vsize
+						<< ISPRSZ_OUT_SIZE_VERT_SHIFT)
+						& ISPRSZ_OUT_SIZE_VERT_MASK;
+
+	rsz_conf_chan->register_config.rsz_sdr_inoff =
+						multipass->in_pitch
+						& ISPRSZ_SDR_INOFF_OFFSET_MASK;
+
+	rsz_conf_chan->register_config.rsz_sdr_outoff =
+					multipass->out_pitch
+					& ISPRSZ_SDR_OUTOFF_OFFSET_MASK;
+
+	if (multipass->hrsz >= 64 && multipass->hrsz <= 512) {
+		if (multipass->hstph > NUM_PHASES)
+			goto err_einval;
+	} else if (multipass->hrsz >= 64 && multipass->hrsz <= 512) {
+		if (multipass->hstph > NUM_D2PH)
+			goto err_einval;
+	}
+
+	rsz_conf_chan->register_config.rsz_cnt |=
+						(multipass->hstph
+						<< ISPRSZ_CNT_HSTPH_SHIFT)
+						& ISPRSZ_CNT_HSTPH_MASK;
+
+	if (multipass->vrsz >= 64 && multipass->hrsz <= 512) {
+		if (multipass->vstph > NUM_PHASES)
+			goto err_einval;
+	} else if (multipass->vrsz >= 64 && multipass->vrsz <= 512) {
+		if (multipass->vstph > NUM_D2PH)
+			goto err_einval;
+	}
+
+	rsz_conf_chan->register_config.rsz_cnt |=
+						(multipass->vstph
+						<< ISPRSZ_CNT_VSTPH_SHIFT)
+						& ISPRSZ_CNT_VSTPH_MASK;
+
+	rsz_conf_chan->register_config.rsz_cnt |=
+						(multipass->hrsz - 1)
+						& ISPRSZ_CNT_HRSZ_MASK;
+
+	rsz_conf_chan->register_config.rsz_cnt |=
+						((multipass->vrsz - 1)
+						<< ISPRSZ_CNT_VRSZ_SHIFT)
+						& ISPRSZ_CNT_VRSZ_MASK;
+
+	return 0;
+err_einval:
+	return -EINVAL;
+}
+
+/**
+ * rsz_config_ratio - Configure ratio
+ * @multipass: Structure containing channel configuration
+			for multipass support
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Configure ratio
+ **/
+static void rsz_config_ratio(struct rsz_mult *multipass,
+				struct channel_config *rsz_conf_chan)
+{
+	int hsize;
+	int vsize;
+	int coeffcounter;
+
+	if (multipass->hrsz <= 512) {
+		hsize = ((32 * multipass->hstph + (multipass->out_hsize - 1)
+					* multipass->hrsz + 16) >> 8) + 7;
+	} else {
+		hsize = ((64 * multipass->hstph + (multipass->out_hsize - 1)
+					* multipass->hrsz + 32) >> 8) + 7;
+	}
+	if (multipass->vrsz <= 512) {
+		vsize = ((32 * multipass->vstph + (multipass->out_vsize - 1)
+					* multipass->vrsz + 16) >> 8) + 4;
+	} else {
+		vsize = ((64 * multipass->vstph + (multipass->out_vsize - 1)
+					* multipass->vrsz + 32) >> 8) + 7;
+	}
+	rsz_conf_chan->register_config.rsz_in_size = hsize;
+
+	rsz_conf_chan->register_config.rsz_in_size |=
+					((vsize << ISPRSZ_IN_SIZE_VERT_SHIFT)
+					& ISPRSZ_IN_SIZE_VERT_MASK);
+
+	/* This is another workaround for the ISP-MMU translation fault.
+	   For the parameters whose image size comes exactly to PAGE_SIZE
+	   generates ISP-MMU translation fault. The root-cause is the equation
+		input width = (32*sph + (ow - 1)*hrsz + 16) >> 8 + 7
+			= (64*sph + (ow - 1)*hrsz + 32) >> 8 + 7
+		input height = (32*spv + (oh - 1)*vrsz + 16) >> 8 + 4
+		= (64*spv + (oh - 1)*vrsz + 32) >> 8 + 7
+
+	   we are adjusting the input width to suit for Resizer module,
+	   application should use this configuration henceforth.
+	 */
+	multipass->in_hsize = hsize;
+	multipass->in_vsize = vsize;
+
+	for (coeffcounter = 0; coeffcounter < MAX_COEF_COUNTER;
+							coeffcounter++) {
+		if (multipass->num_htap) {
+			rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter] =
+					(multipass->tap4filt_coeffs[2
+					* coeffcounter]
+					& ISPRSZ_HFILT10_COEF0_MASK);
+			rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter] |=
+					((multipass->tap4filt_coeffs[2
+					* coeffcounter + 1]
+					<< ISPRSZ_HFILT10_COEF1_SHIFT)
+					& ISPRSZ_HFILT10_COEF1_MASK);
+		} else {
+			rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter] =
+					(multipass->tap7filt_coeffs[2
+					* coeffcounter]
+					& ISPRSZ_HFILT10_COEF0_MASK);
+
+			rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter] |=
+					((multipass->tap7filt_coeffs[2
+					* coeffcounter + 1]
+					<< ISPRSZ_HFILT10_COEF1_SHIFT)
+					& ISPRSZ_HFILT10_COEF1_MASK);
+		}
+
+		if (multipass->num_vtap) {
+			rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter] =
+					(multipass->tap4filt_coeffs[2
+					* coeffcounter]
+					& ISPRSZ_VFILT10_COEF0_MASK);
+
+			rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter] |=
+					((multipass->tap4filt_coeffs[2
+					* coeffcounter + 1]
+					<< ISPRSZ_VFILT10_COEF1_SHIFT) &
+					ISPRSZ_VFILT10_COEF1_MASK);
+		} else {
+			rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter] =
+					(multipass->tap7filt_coeffs[2
+					* coeffcounter]
+					& ISPRSZ_VFILT10_COEF0_MASK);
+			rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter] |=
+					((multipass->tap7filt_coeffs[2
+					* coeffcounter + 1]
+					<< ISPRSZ_VFILT10_COEF1_SHIFT)
+					& ISPRSZ_VFILT10_COEF1_MASK);
+		}
+	}
+}
+
+/**
+ * rsz_get_params - Gets the parameter values
+ * @params: Structure containing the Resizer Wrapper parameters
+ * @rsz_conf_chan: Structure containing channel configuration
+ *
+ * Used to get the Resizer hardware settings associated with the
+ * current logical channel represented by fd.
+ **/
+static int rsz_get_params(struct rsz_params *params,
+					struct channel_config *rsz_conf_chan)
+{
+	int coeffcounter;
+
+	if (rsz_conf_chan->config_state) {
+		dev_err(rsz_device, "state not configured\n");
+		return -EINVAL;
+	}
+
+	params->in_hsize = rsz_conf_chan->register_config.rsz_in_size
+					& ISPRSZ_IN_SIZE_HORZ_MASK;
+	params->in_vsize = (rsz_conf_chan->register_config.rsz_in_size
+					& ISPRSZ_IN_SIZE_VERT_MASK)
+					>> ISPRSZ_IN_SIZE_VERT_SHIFT;
+
+	params->in_pitch = rsz_conf_chan->register_config.rsz_sdr_inoff
+					& ISPRSZ_SDR_INOFF_OFFSET_MASK;
+
+	params->out_hsize = rsz_conf_chan->register_config.rsz_out_size
+					& ISPRSZ_OUT_SIZE_HORZ_MASK;
+
+	params->out_vsize = (rsz_conf_chan->register_config.rsz_out_size
+					& ISPRSZ_OUT_SIZE_VERT_MASK)
+					>> ISPRSZ_OUT_SIZE_VERT_SHIFT;
+
+	params->out_pitch = rsz_conf_chan->register_config.rsz_sdr_outoff
+					& ISPRSZ_SDR_OUTOFF_OFFSET_MASK;
+
+	params->cbilin = (rsz_conf_chan->register_config.rsz_cnt
+					& SET_BIT_CBLIN) >> SET_BIT_CBLIN;
+
+	params->inptyp = (rsz_conf_chan->register_config.rsz_cnt
+					& ISPRSZ_CNT_INPTYP_MASK)
+					>> SET_BIT_INPTYP;
+	params->horz_starting_pixel = ((rsz_conf_chan->register_config.
+					rsz_in_start
+					& ISPRSZ_IN_START_HORZ_ST_MASK));
+	params->vert_starting_pixel = ((rsz_conf_chan->register_config.
+					rsz_in_start
+					& ISPRSZ_IN_START_VERT_ST_MASK)
+					>> ISPRSZ_IN_START_VERT_ST_SHIFT);
+
+	params->hstph = ((rsz_conf_chan->register_config.rsz_cnt
+					& ISPRSZ_CNT_HSTPH_MASK
+					>> ISPRSZ_CNT_HSTPH_SHIFT));
+	params->vstph = ((rsz_conf_chan->register_config.rsz_cnt
+					& ISPRSZ_CNT_VSTPH_MASK
+					>> ISPRSZ_CNT_VSTPH_SHIFT));
+
+	for (coeffcounter = 0; coeffcounter < MAX_COEF_COUNTER;
+							coeffcounter++) {
+		params->tap4filt_coeffs[2 * coeffcounter] =
+					rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter]
+					& ISPRSZ_HFILT10_COEF0_MASK;
+
+		params->tap4filt_coeffs[2 * coeffcounter + 1] =
+					(rsz_conf_chan->register_config.
+					rsz_coeff_horz[coeffcounter]
+					& ISPRSZ_HFILT10_COEF1_MASK)
+					>> ISPRSZ_HFILT10_COEF1_SHIFT;
+
+		params->tap7filt_coeffs[2 * coeffcounter] =
+					rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter]
+					& ISPRSZ_VFILT10_COEF0_MASK;
+
+		params->tap7filt_coeffs[2 * coeffcounter + 1] =
+					(rsz_conf_chan->register_config.
+					rsz_coeff_vert[coeffcounter]
+					& ISPRSZ_VFILT10_COEF1_MASK)
+					>> ISPRSZ_VFILT10_COEF1_SHIFT;
+
+	}
+
+	params->yenh_params.type = (rsz_conf_chan->register_config.rsz_yehn
+					& ISPRSZ_YENH_ALGO_MASK)
+					>> ISPRSZ_YENH_ALGO_SHIFT;
+
+	params->yenh_params.core = rsz_conf_chan->register_config.rsz_yehn
+					& ISPRSZ_YENH_CORE_MASK;
+
+	params->yenh_params.gain = (rsz_conf_chan->register_config.rsz_yehn
+					& ISPRSZ_YENH_GAIN_MASK)
+					>> ISPRSZ_YENH_GAIN_SHIFT;
+
+	params->yenh_params.slop = (rsz_conf_chan->register_config.rsz_yehn
+					& ISPRSZ_YENH_SLOP_MASK)
+					>> ISPRSZ_YENH_SLOP_SHIFT;
+
+	params->pix_fmt = ((rsz_conf_chan->register_config.rsz_cnt
+					& ISPRSZ_CNT_PIXFMT_MASK)
+					>> SET_BIT_YCPOS);
+
+	if (params->pix_fmt)
+		params->pix_fmt = RSZ_PIX_FMT_UYVY;
+	else
+		params->pix_fmt = RSZ_PIX_FMT_YUYV;
+
+	return 0;
+}
+
+/**
+ * rsz_calculate_crop - Calculate Crop values
+ * @rsz_conf_chan: Structure containing channel configuration
+ * @cropsize: Structure containing crop parameters
+ *
+ * Calculate Crop values
+ **/
+static void rsz_calculate_crop(struct channel_config *rsz_conf_chan,
+						struct rsz_cropsize *cropsize)
+{
+	int luma_enable;
+
+	cropsize->hcrop = 0;
+	cropsize->vcrop = 0;
+
+	luma_enable = (rsz_conf_chan->register_config.rsz_yehn
+						& ISPRSZ_YENH_ALGO_MASK)
+						>> ISPRSZ_YENH_ALGO_SHIFT;
+
+	if (luma_enable)
+		cropsize->hcrop += 2;
+}
+
+/**
+ * rsz_vbq_release - Videobuffer queue release
+ * @q: Structure containing the videobuffer queue file handle, and device
+ *     structure which contains the actual configuration.
+ * @vb: Structure containing the videobuffer used for resizer processing.
+ **/
+static void rsz_vbq_release(struct videobuf_queue *q,
+						struct videobuf_buffer *vb)
+{
+	struct rsz_fh *fh = q->priv_data;
+	struct videobuf_dmabuf *dma = NULL;
+	struct vm_area_struct *vma;
+
+	dma = videobuf_to_dma(q->bufs[vb->i]);
+	vma = find_vma(current->mm, vb->baddr);
+	if ((vma) && (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
+		vfree(dma->sglist);
+		dma->sglist = NULL;
+		dma->sglen = 0;
+	} else {
+		videobuf_dma_unmap(q, dma);
+		videobuf_dma_free(dma);
+	}
+	ispmmu_vunmap(fh->dev, fh->config->buf_address[vb->i]);
+	fh->config->buf_address[vb->i] = 0;
+
+	spin_lock(&fh->vbq_lock);
+	vb->state = VIDEOBUF_NEEDS_INIT;
+	spin_unlock(&fh->vbq_lock);
+
+}
+
+/**
+ * rsz_vbq_setup - Sets up the videobuffer size and validates count.
+ * @q: Structure containing the videobuffer queue file handle, and device
+ *     structure which contains the actual configuration.
+ * @cnt: Number of buffers requested
+ * @size: Size in bytes of the buffer used for previewing
+ *
+ * Always returns 0.
+ **/
+static int rsz_vbq_setup(struct videobuf_queue *q, unsigned int *cnt,
+							unsigned int *size)
+{
+	struct rsz_fh *fh = q->priv_data;
+	struct rsz_mult *multipass = fh->multipass;
+	u32 insize, outsize;
+
+	spin_lock(&fh->vbq_lock);
+	if (*cnt <= 0)
+		*cnt = VIDEO_MAX_FRAME;
+
+	if (*cnt > VIDEO_MAX_FRAME)
+		*cnt = VIDEO_MAX_FRAME;
+
+	outsize = multipass->out_pitch * multipass->out_vsize;
+	insize = multipass->in_pitch * multipass->in_vsize;
+	if (*cnt == 1 && (outsize > insize)) {
+		dev_err(rsz_device, "2 buffers are required for Upscaling "
+								"mode\n");
+		goto err_einval;
+	}
+	if (!fh->params->in_hsize || !fh->params->in_vsize) {
+		dev_err(rsz_device, "Can't setup buffer size\n");
+		goto err_einval;
+	} else {
+		if (outsize > insize)
+			*size = outsize;
+		else
+			*size = insize;
+
+		fh->rsz_bufsize = *size;
+	}
+	spin_unlock(&fh->vbq_lock);
+
+	return 0;
+err_einval:
+	spin_unlock(&fh->vbq_lock);
+	return -EINVAL;
+}
+/*
+ * This function is work around for the videobuf_iolock API,
+ * for User memory allocated with ioremap (VM_IO flag) the API
+ * get_user_pages fails.
+ *
+ * To fulfill this requirement, we have completely ignored VM layer of
+ * Linux, and configuring the ISP MMU with physical address.
+ */
+static int omap_videobuf_dma_init_user(struct videobuf_buffer *vb,
+		unsigned long physp, unsigned long asize)
+{
+	struct videobuf_dmabuf *dma;
+	struct scatterlist *sglist;
+	unsigned long data, first, last;
+	int len, i = 0;
+
+	dma = videobuf_to_dma(vb);
+	data = vb->baddr;
+
+	first = (data & PAGE_MASK) >> PAGE_SHIFT;
+	last  = ((data+asize-1) & PAGE_MASK) >> PAGE_SHIFT;
+	dma->offset   = data & ~PAGE_MASK;
+	dma->nr_pages = last-first+1;
+
+	dma->direction = PCI_DMA_BIDIRECTIONAL;
+	/*
+	 * Allocate array of sglen + 1, to add entry of extra page
+	 * for input buffer. Driver always uses 0th buffer as input buffer.
+	 */
+	len = dma->nr_pages + (vb->i ? 0 : 1);
+	sglist = vmalloc(len * sizeof(*sglist));
+	if (NULL == sglist)
+		return -ENOMEM;
+
+	sglist[0].offset = 0;
+	sglist[0].length = PAGE_SIZE - dma->offset;
+	sglist[0].dma_address = (dma_addr_t)physp;
+	physp += sglist[0].length;
+	/*
+	 * Iterate in a loop for the number of pages
+	 */
+	for (i = 1; i < (len - (vb->i ? 0 : 1)); i++) {
+		sglist[i].offset = 0;
+		sglist[i].length = PAGE_SIZE;
+		sglist[i].dma_address = (dma_addr_t)physp;
+		physp += PAGE_SIZE;
+	}
+	if (0 == vb->i) {
+		sglist[i].offset = 0;
+		sglist[i].length = PAGE_SIZE;
+		sglist[i].dma_address =
+			(dma_addr_t)device_config->extra_page_addr;
+	}
+	dma->sglist = sglist;
+	dma->sglen = len;
+
+	return 0;
+
+}
+
+/*
+ * This function is workaround for the issue, where ISP-MMU generated
+ * translation fault for specific params whose size is aligned to PAGE_SIZE.
+
+ * As a workaround we are padding one extra page for input buffer. This page
+ * we are allocating during init time and will not be released through-out
+ * life time of resizer driver. Please note that Resizer module only reads
+ * from this extra page.
+ */
+int omap_create_sg(struct videobuf_queue *q, struct videobuf_dmabuf *dma)
+{
+	struct scatterlist *sglist;
+	int sglen;
+
+	if (0 == dma->nr_pages)
+		return EINVAL;
+	sglen = dma->sglen;
+	sglist = vmalloc((dma->nr_pages + 1) * sizeof(*sglist));
+	if (NULL == sglist)
+		return -ENOMEM;
+
+	sg_init_table(sglist, dma->nr_pages + 1);
+	/*
+	 * Copy the sglist locally
+	 */
+	memcpy(sglist, dma->sglist, sglen * sizeof(*sglist));
+	/*
+	 * Release the old sglist, since we already copied it locally
+	 */
+	videobuf_dma_unmap(q, dma);
+	/*
+	 * Add extra entry to sglist to work with specific params, whose
+	 * buffer address alined to PAGE_SIZE.
+	 */
+	sglist[sglen].offset = 0;
+	sglist[sglen].length = PAGE_SIZE;
+	sglist[sglen].dma_address = (dma_addr_t)device_config->extra_page_addr;
+	sglen++;
+	/*
+	 * Save the sglist for mapping to ISP-MMU space
+	 */
+	dma->sglist = sglist;
+	dma->sglen = sglen;
+	return 0;
+}
+/**
+ * rsz_vbq_prepare - Videobuffer is prepared and mmapped.
+ * @q: Structure containing the videobuffer queue file handle, and device
+ *     structure which contains the actual configuration.
+ * @vb: Structure containing the videobuffer used for resizer processing.
+ * @field: Type of field to set in videobuffer device.
+ *
+ * Returns 0 if successful, or -EINVAL if buffer couldn't get allocated, or
+ * -EIO if the ISP MMU mapping fails
+ **/
+static int rsz_vbq_prepare(struct videobuf_queue *q,
+						struct videobuf_buffer *vb,
+						enum v4l2_field field)
+{
+	struct rsz_fh *fh = q->priv_data;
+	struct channel_config *rsz_conf_chan = fh->config;
+	struct rsz_mult *multipass = fh->multipass;
+	int err = 0;
+	unsigned int isp_addr, insize, outsize;
+
+	spin_lock(&fh->vbq_lock);
+	if (vb->baddr) {
+		/* Check for 32 byte alignement */
+		if (vb->baddr != (vb->baddr & ~0x1F)) {
+			spin_unlock(&fh->vbq_lock);
+			dev_err(rsz_device, "Buffer address should be aligned \
+					to 32 byte\n");
+			return -EINVAL;
+		}
+		vb->size = fh->rsz_bufsize;
+		vb->bsize = fh->rsz_bufsize;
+	} else {
+		spin_unlock(&fh->vbq_lock);
+		dev_err(rsz_device, "No user buffer allocated\n");
+		return -EINVAL;
+	}
+	if (vb->i) {
+		vb->width = fh->params->out_hsize;
+		vb->height = fh->params->out_vsize;
+	} else {
+		vb->width = fh->params->in_hsize;
+		vb->height = fh->params->in_vsize;
+	}
+
+	vb->field = field;
+	spin_unlock(&fh->vbq_lock);
+	/*
+	 * Calculate input and output sizes, will be used while mapping
+	 * user pages
+	 */
+	outsize = multipass->out_pitch * multipass->out_vsize;
+	insize = multipass->in_pitch * multipass->in_vsize;
+
+	if (vb->state == VIDEOBUF_NEEDS_INIT) {
+		struct videobuf_dmabuf *dma;
+		struct vm_area_struct *vma;
+		spin_lock(&fh->vbq_lock);
+		dma = videobuf_to_dma(vb);
+		vma = find_vma(current->mm, vb->baddr);
+		if ((vma) && (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
+			/* This will catch ioremaped buffers to the kernel.
+			 *  It gives two possible scenarios -
+			 *  - Driver allocates buffer using either
+			 *    dma_alloc_coherent or get_free_pages,
+			 *    and maps to user space using
+			 *    io_remap_pfn_range/remap_pfn_range
+			 *  - Drivers maps memory outside from Linux using
+			 *    io_remap
+			 */
+			unsigned long physp = 0, asize;
+			asize = vb->i ? outsize : insize;
+			if ((vb->baddr + asize) > vma->vm_end) {
+				spin_unlock(&fh->vbq_lock);
+				dev_err(rsz_device, "User Buffer Allocation:" \
+					"err=%lu[%lu]\n",\
+					(vma->vm_end - vb->baddr), asize);
+				return -ENOMEM;
+			}
+			physp = (vma->vm_pgoff << PAGE_SHIFT) +
+					(vb->baddr - vma->vm_start);
+			err = omap_videobuf_dma_init_user(vb, physp, asize);
+			spin_unlock(&fh->vbq_lock);
+			if (0 != err)
+				return err;
+			is_vm_io = 1;
+		} else {
+			err = videobuf_iolock(q, vb, NULL);
+			/*
+			 * In case of user pointer mode, the get_user_pages
+			 * will fail if user has allocated less memory than
+			 * vb->size. But it is not error from resizer driver
+			 * point of view. so handled seperately
+			 */
+			if ((err < 0) && (dma->nr_pages > 0))
+				err = videobuf_dma_map(q, dma);
+			if (err)
+				goto buf_release;
+			/*
+			 * Add one extra page for input buffer
+			 */
+			if (0 == vb->i)
+				err = omap_create_sg(q, dma);
+			if (err)
+				goto buf_release;
+			spin_unlock(&fh->vbq_lock);
+			is_vm_io = 0;
+		}
+		isp_addr = ispmmu_vmap(fh->dev, dma->sglist, dma->sglen);
+		if (!isp_addr || IS_ERR_VALUE(isp_addr))
+			err = -EIO;
+		else {
+			if (vb->i) {
+				rsz_conf_chan->buf_address[vb->i] = isp_addr;
+				rsz_conf_chan->register_config.
+					rsz_sdr_outadd
+					= isp_addr;
+				rsz_conf_chan->output_buf_index = vb->i;
+			} else {
+				rsz_conf_chan->buf_address[vb->i] = isp_addr;
+				rsz_conf_chan->register_config.
+					rsz_sdr_inadd
+					= isp_addr;
+				rsz_conf_chan->input_buf_index = vb->i;
+				if (outsize < insize && rsz_conf_chan->
+						register_config.
+						rsz_sdr_outadd == 0) {
+					rsz_conf_chan->register_config.
+						rsz_sdr_outadd
+						= isp_addr;
+					rsz_conf_chan->
+						output_buf_index =
+						vb->i;
+				}
+			}
+		}
+
+	} else {
+		if (vb->i) {
+			rsz_conf_chan->register_config.
+				rsz_sdr_outadd =
+					rsz_conf_chan->buf_address[vb->i];
+			rsz_conf_chan->output_buf_index = vb->i;
+		} else {
+			rsz_conf_chan->register_config.
+				rsz_sdr_inadd =
+					rsz_conf_chan->buf_address[vb->i];
+			rsz_conf_chan->input_buf_index = vb->i;
+			if (outsize < insize && rsz_conf_chan->
+					register_config.
+					rsz_sdr_outadd == 0) {
+				rsz_conf_chan->register_config.
+					rsz_sdr_outadd
+					= rsz_conf_chan->buf_address[vb->i];
+				rsz_conf_chan->output_buf_index = vb->i;
+			}
+
+		}
+
+	}
+	if (!err) {
+		spin_lock(&fh->vbq_lock);
+		vb->state = VIDEOBUF_PREPARED;
+		spin_unlock(&fh->vbq_lock);
+	} else
+		rsz_vbq_release(q, vb);
+
+	return err;
+buf_release:
+	spin_unlock(&fh->vbq_lock);
+	rsz_vbq_release(q, vb);
+	return err;
+}
+
+static void rsz_vbq_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	return;
+}
+
+/**
+ * rsz_open - Initializes and opens the Resizer Wrapper
+ * @inode: Inode structure associated with the Resizer Wrapper
+ * @filp: File structure associated with the Resizer Wrapper
+ *
+ * Returns 0 if successful, -EBUSY if its already opened or the ISP module is
+ * not available, or -ENOMEM if its unable to allocate the device in kernel
+ * space memory.
+ **/
+static int rsz_open(struct inode *inode, struct file *filp)
+{
+	int ret = 0;
+	struct channel_config *rsz_conf_chan;
+	struct rsz_fh *fh;
+	struct device_params *device = device_config;
+	struct rsz_params *params;
+	struct rsz_mult *multipass;
+
+	if ((filp->f_flags & O_NONBLOCK) == O_NONBLOCK) {
+		printk(KERN_DEBUG "omap-resizer: Device is opened in "
+					"non blocking mode\n");
+	} else {
+		printk(KERN_DEBUG "omap-resizer: Device is opened in blocking "
+					"mode\n");
+	}
+	fh = kzalloc(sizeof(struct rsz_fh), GFP_KERNEL);
+	if (NULL == fh)
+		return -ENOMEM;
+
+	fh->dev = isp_get();
+	if (fh->dev == NULL)
+		return -EINVAL;
+
+	isp_start(fh->dev);
+
+	rsz_conf_chan = kzalloc(sizeof(struct channel_config), GFP_KERNEL);
+	if (rsz_conf_chan == NULL) {
+		dev_err(rsz_device, "\n cannot allocate memory to config");
+		ret = -ENOMEM;
+		goto err_enomem0;
+	}
+	params = kzalloc(sizeof(struct rsz_params), GFP_KERNEL);
+	if (params == NULL) {
+		dev_err(rsz_device, "\n cannot allocate memory to params");
+		ret = -ENOMEM;
+		goto err_enomem1;
+	}
+	multipass = kzalloc(sizeof(struct rsz_mult), GFP_KERNEL);
+	if (multipass == NULL) {
+		dev_err(rsz_device, "\n cannot allocate memory to multipass");
+		ret = -ENOMEM;
+		goto err_enomem2;
+	}
+
+	fh->multipass = multipass;
+	fh->params = params;
+	fh->config = rsz_conf_chan;
+
+	if (mutex_lock_interruptible(&device->reszwrap_mutex)) {
+		ret = -EINTR;
+		goto err_enomem2;
+	}
+	device->opened++;
+	mutex_unlock(&device->reszwrap_mutex);
+
+	rsz_conf_chan->config_state = STATE_NOT_CONFIGURED;
+	rsz_conf_chan->status = CHANNEL_FREE;
+
+	filp->private_data = fh;
+	fh->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fh->device = device;
+
+	videobuf_queue_sg_init(&fh->vbq, &device->vbq_ops, NULL,
+					&fh->vbq_lock, fh->type,
+					V4L2_FIELD_NONE,
+					sizeof(struct videobuf_buffer), fh);
+
+	spin_lock_init(&fh->vbq_lock);
+	mutex_init(&rsz_conf_chan->chanprotection_mutex);
+
+	return 0;
+err_enomem2:
+	kfree(params);
+err_enomem1:
+	kfree(rsz_conf_chan);
+err_enomem0:
+	kfree(fh);
+	return ret;
+}
+
+/**
+ * rsz_release - Releases Resizer Wrapper and frees up allocated memory
+ * @inode: Inode structure associated with the Resizer Wrapper
+ * @filp: File structure associated with the Resizer Wrapper
+ *
+ * Returns 0 if successful, or -EBUSY if channel is being used.
+ **/
+static int rsz_release(struct inode *inode, struct file *filp)
+{
+	int i;
+	unsigned int timeout = 0;
+	struct rsz_fh *fh = filp->private_data;
+	struct channel_config *rsz_conf_chan = fh->config;
+	struct rsz_params *params = fh->params;
+	struct rsz_mult *multipass = fh->multipass;
+	struct videobuf_queue *q = &fh->vbq;
+
+	while ((rsz_conf_chan->status != CHANNEL_FREE) && (timeout < 20)) {
+		timeout++;
+		schedule();
+	}
+	/* Free memory allocated to the buffers */
+	for (i = 0 ; i < VIDEO_MAX_FRAME ; i++) {
+		struct videobuf_dmabuf *dma = NULL;
+
+		if (!q->bufs[i])
+			continue;
+		dma = videobuf_to_dma(q->bufs[i]);
+		if (is_vm_io) {
+			vfree(dma->sglist);
+			dma->sglist = NULL;
+			dma->sglen = 0;
+		} else {
+			videobuf_dma_unmap(q, dma);
+			videobuf_dma_free(dma);
+		}
+	}
+
+	videobuf_mmap_free(q);
+	fh->rsz_bufsize = 0;
+	filp->private_data = NULL;
+
+	kfree(rsz_conf_chan);
+	kfree(params);
+	kfree(multipass);
+	kfree(fh);
+
+	isp_put();
+	fh->params = NULL;
+	fh->config = NULL;
+	return 0;
+}
+
+/**
+ * rsz_mmap - Memory maps the Resizer Wrapper module.
+ * @file: File structure associated with the Resizer Wrapper
+ * @vma: Virtual memory area structure.
+ *
+ * Returns 0 if successful, or returned value by the videobuf_mmap_mapper()
+ * function.
+ **/
+static int rsz_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct rsz_fh *fh = file->private_data;
+
+	return videobuf_mmap_mapper(&fh->vbq, vma);
+}
+
+/**
+ * rsz_ioctl - I/O control function for Resizer Wrapper
+ * @inode: Inode structure associated with the Resizer Wrapper.
+ * @file: File structure associated with the Resizer Wrapper.
+ * @cmd: Type of command to execute.
+ * @arg: Argument to send to requested command.
+ *
+ * Returns 0 if successful, -EBUSY if channel is being used, -1 if bad command
+ * passed or access is denied, -EFAULT if copy_from_user() or copy_to_user()
+ * fails, -EINVAL if parameter validation fails or parameter structure is not
+ * present.
+ **/
+static long rsz_unlocked_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	int ret = 0;
+	struct rsz_fh *fh = file->private_data;
+	struct device_params *device = fh->device;
+	struct channel_config *rsz_conf_chan = fh->config;
+
+	if ((_IOC_TYPE(cmd) != RSZ_IOC_BASE)
+					|| (_IOC_NR(cmd) > RSZ_IOC_MAXNR)) {
+		dev_err(rsz_device, "Bad command value\n");
+		return -1;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+
+	if (ret) {
+		dev_err(rsz_device, "Access denied\n");
+		return -1;
+	}
+
+	switch (cmd) {
+	case RSZ_REQBUF:
+	{
+		struct v4l2_requestbuffers req_buf;
+		if (copy_from_user(&req_buf, (struct v4l2_requestbuffers *)arg,
+					sizeof(struct v4l2_requestbuffers))) {
+			return -EFAULT;
+		}
+		if (mutex_lock_interruptible(&rsz_conf_chan->
+							chanprotection_mutex))
+			return -EINTR;
+		ret = videobuf_reqbufs(&fh->vbq, (void *)&req_buf);
+		if (ret >= 0) {
+			if (copy_to_user((struct v4l2_requestbuffers *)arg,
+						&req_buf, sizeof(struct
+						v4l2_requestbuffers)))
+				return -EFAULT;
+		}
+		mutex_unlock(&rsz_conf_chan->chanprotection_mutex);
+		break;
+	}
+	case RSZ_QUERYBUF:
+	{
+		struct v4l2_buffer buf;
+		if (copy_from_user(&buf, (struct v4l2_buffer *)arg,
+						sizeof(struct v4l2_buffer))) {
+			return -EFAULT;
+		}
+		if (mutex_lock_interruptible(&rsz_conf_chan->
+							chanprotection_mutex))
+			return -EINTR;
+		ret = videobuf_querybuf(&fh->vbq, (void *)&buf);
+		mutex_unlock(&rsz_conf_chan->chanprotection_mutex);
+		if (copy_to_user((struct v4l2_buffer *)arg, &buf,
+						sizeof(struct v4l2_buffer)))
+			return -EFAULT;
+		break;
+	}
+	case RSZ_QUEUEBUF:
+	{
+		struct v4l2_buffer buf;
+		if (copy_from_user(&buf, (struct v4l2_buffer *)arg,
+						sizeof(struct v4l2_buffer))) {
+			return -EFAULT;
+		}
+		if (mutex_lock_interruptible(&rsz_conf_chan->
+							chanprotection_mutex))
+			return -EINTR;
+		ret = videobuf_qbuf(&fh->vbq, (void *)&buf);
+		mutex_unlock(&rsz_conf_chan->chanprotection_mutex);
+		break;
+	}
+	case RSZ_S_PARAM:
+	{
+		struct rsz_params *params = fh->params;
+		if (copy_from_user(params, (struct rsz_params *)arg,
+						sizeof(struct rsz_params))) {
+			return -EFAULT;
+		}
+		ret = rsz_set_params(fh->multipass, fh->params,	rsz_conf_chan);
+		break;
+	}
+	case RSZ_G_PARAM:
+		ret = rsz_get_params((struct rsz_params *)arg, rsz_conf_chan);
+		break;
+
+	case RSZ_G_STATUS:
+	{
+		struct rsz_status *status;
+		struct isp_device *isp = dev_get_drvdata(fh->dev);
+		status = (struct rsz_status *)arg;
+		status->chan_busy = rsz_conf_chan->status;
+		status->hw_busy = ispresizer_busy(&isp->isp_res);
+		status->src = INPUT_RAM;
+		break;
+	}
+	case RSZ_RESIZE:
+	{
+		struct isp_device *isp = dev_get_drvdata(fh->dev);
+		if (file->f_flags & O_NONBLOCK) {
+			if (ispresizer_busy(&isp->isp_res))
+				return -EBUSY;
+			else {
+				if (!mutex_trylock(&device->reszwrap_mutex))
+					return -EBUSY;
+			}
+		} else {
+			if (mutex_lock_interruptible(&device->reszwrap_mutex))
+				return -EINTR;
+		}
+		ret = rsz_start((int *)arg, fh);
+		mutex_unlock(&device->reszwrap_mutex);
+		break;
+	}
+	case RSZ_GET_CROPSIZE:
+		rsz_calculate_crop(rsz_conf_chan, (struct rsz_cropsize *)arg);
+		break;
+	case RSZ_S_EXP:
+		if (mutex_lock_interruptible(&rsz_conf_chan->
+						chanprotection_mutex))
+			return -EINTR;
+		rsz_conf_chan->register_config.sdr_req_exp =
+						*((unsigned int	*)arg);
+		mutex_unlock(&rsz_conf_chan->chanprotection_mutex);
+		break;
+
+	default:
+		dev_err(rsz_device, "resizer_ioctl: Invalid Command Value");
+		return -EINVAL;
+	}
+
+	return (long)ret;
+}
+
+static const struct file_operations rsz_fops = {
+	.owner = THIS_MODULE,
+	.open = rsz_open,
+	.release = rsz_release,
+	.mmap = rsz_mmap,
+	.unlocked_ioctl = rsz_unlocked_ioctl,
+};
+
+/**
+ * rsz_isr - Interrupt Service Routine for Resizer wrapper
+ * @status: ISP IRQ0STATUS register value
+ * @arg1: Currently not used
+ * @arg2: Currently not used
+ *
+ * Interrupt Service Routine for Resizer wrapper
+ **/
+static void rsz_isr(unsigned long status, isp_vbq_callback_ptr arg1, void *arg2)
+{
+
+	if ((status & RESZ_DONE) != RESZ_DONE)
+		return;
+
+	complete(&(device_config->compl_isr));
+
+}
+
+/**
+ * resizer_platform_release - Acts when Reference count is zero
+ * @device: Structure containing ISP resizer wrapper global information
+ *
+ * This is called when the reference count goes to zero.
+ **/
+static void resizer_platform_release(struct device *device)
+{
+}
+
+/**
+ * resizer_probe - Checks for device presence
+ * @device: Structure containing details of the current device.
+ *
+ * Always returns 0.
+ **/
+static int __init resizer_probe(struct platform_device *device)
+{
+	return 0;
+}
+
+/**
+ * resizer_remove - Handles the removal of the driver
+ * @omap_resizer_device: Structure containing details of the current device.
+ *
+ * Always returns 0.
+ **/
+static int resizer_remove(struct platform_device *omap_resizer_device)
+{
+	return 0;
+}
+
+static struct class *rsz_class;
+static struct cdev c_dev;
+static dev_t dev;
+static struct platform_device omap_resizer_device = {
+	.name = OMAP_REZR_NAME,
+	.id = 2,
+	.dev = {
+		.release = resizer_platform_release,}
+};
+
+static struct platform_driver omap_resizer_driver = {
+	.probe = resizer_probe,
+	.remove = resizer_remove,
+	.driver = {
+			.bus = &platform_bus_type,
+			.name = OMAP_REZR_NAME,
+	},
+};
+
+/**
+ * omap_rsz_init - Initialization of Resizer Wrapper
+ *
+ * Returns 0 if successful, -ENOMEM if could not allocate memory, -ENODEV if
+ * could not register the wrapper as a character device, or other errors if the
+ * device or driver can't register.
+ **/
+static int __init omap_rsz_init(void)
+{
+	int ret = 0;
+	struct device_params *device;
+	device = kzalloc(sizeof(struct device_params), GFP_KERNEL);
+	if (!device) {
+		printk(OMAP_REZR_NAME ": could not allocate memory\n");
+		return -ENOMEM;
+	}
+	device->extra_page_addr = __get_free_pages(GFP_KERNEL | GFP_DMA, 0);
+	if (!device->extra_page_addr) {
+		printk(OMAP_REZR_NAME ":Allocation failed. ");
+		kfree(device);
+		return -ENOMEM;
+	}
+
+	ret = alloc_chrdev_region(&dev, 0, 1, OMAP_REZR_NAME);
+	if (ret < 0) {
+		printk(OMAP_REZR_NAME ": intialization failed. "
+			"Could not allocate region for character device\n");
+		goto fail1;
+	}
+
+	/* Register the driver in the kernel */
+	/* Initialize of character device */
+	cdev_init(&c_dev, &rsz_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &rsz_fops;
+
+	/* Addding character device */
+	ret = cdev_add(&c_dev, dev, 1);
+	if (ret) {
+		printk(OMAP_REZR_NAME ": Error adding device - %d\n", ret);
+		goto fail2;
+	}
+	rsz_major = MAJOR(dev);
+
+	/* register driver as a platform driver */
+	ret = platform_driver_register(&omap_resizer_driver);
+	if (ret) {
+		printk(OMAP_REZR_NAME
+				": Failed to register platform driver!\n");
+		goto fail3;
+	}
+
+	/* Register the drive as a platform device */
+	ret = platform_device_register(&omap_resizer_device);
+	if (ret) {
+		printk(OMAP_REZR_NAME
+				": Failed to register platform device!\n");
+		goto fail4;
+	}
+
+	rsz_class = class_create(THIS_MODULE, OMAP_REZR_NAME);
+	if (!rsz_class) {
+		printk(OMAP_REZR_NAME ": Failed to create class!\n");
+		goto fail5;
+	}
+
+	/* make entry in the devfs */
+	rsz_device = device_create(rsz_class, rsz_device,
+						MKDEV(rsz_major, 0), NULL,
+						OMAP_REZR_NAME);
+	dev_dbg(rsz_device, OMAP_REZR_NAME ": Registered Resizer Wrapper\n");
+	device->opened = 0;
+
+	device->vbq_ops.buf_setup = rsz_vbq_setup;
+	device->vbq_ops.buf_prepare = rsz_vbq_prepare;
+	device->vbq_ops.buf_release = rsz_vbq_release;
+	device->vbq_ops.buf_queue = rsz_vbq_queue;
+	init_completion(&device->compl_isr);
+	mutex_init(&device->reszwrap_mutex);
+
+	device_config = device;
+	return 0;
+
+fail5:
+	platform_device_unregister(&omap_resizer_device);
+fail4:
+	platform_driver_unregister(&omap_resizer_driver);
+fail3:
+	cdev_del(&c_dev);
+fail2:
+	unregister_chrdev_region(dev, 1);
+fail1:
+	free_pages((unsigned long)device->extra_page_addr, 0);
+	kfree(device);
+	return ret;
+}
+
+/**
+ * omap_rsz_exit - Close of Resizer Wrapper
+ **/
+void __exit omap_rsz_exit(void)
+{
+	device_destroy(rsz_class, dev);
+	class_destroy(rsz_class);
+	platform_device_unregister(&omap_resizer_device);
+	platform_driver_unregister(&omap_resizer_driver);
+	cdev_del(&c_dev);
+	unregister_chrdev_region(dev, 1);
+	free_pages((unsigned long)device_config->extra_page_addr, 0);
+	kfree(device_config);
+}
+
+module_init(omap_rsz_init)
+module_exit(omap_rsz_exit)
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("OMAP ISP Resizer");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/isp/redgamma_table.h b/drivers/media/video/isp/redgamma_table.h
new file mode 100644
index 0000000..ad0232a
--- /dev/null
+++ b/drivers/media/video/isp/redgamma_table.h
@@ -0,0 +1,1040 @@
+/*
+ * redgamma_table.h
+ *
+ * Gamma Table values for RED for TI's OMAP3 Camera ISP
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+0,
+0,
+1,
+2,
+3,
+3,
+4,
+5,
+6,
+8,
+10,
+12,
+14,
+16,
+18,
+20,
+22,
+23,
+25,
+26,
+28,
+29,
+31,
+32,
+34,
+35,
+36,
+37,
+39,
+40,
+41,
+42,
+43,
+44,
+45,
+46,
+47,
+48,
+49,
+50,
+51,
+52,
+52,
+53,
+54,
+55,
+56,
+57,
+58,
+59,
+60,
+61,
+62,
+63,
+63,
+64,
+65,
+66,
+66,
+67,
+68,
+69,
+69,
+70,
+71,
+72,
+72,
+73,
+74,
+75,
+75,
+76,
+77,
+78,
+78,
+79,
+80,
+81,
+81,
+82,
+83,
+84,
+84,
+85,
+86,
+87,
+88,
+88,
+89,
+90,
+91,
+91,
+92,
+93,
+94,
+94,
+95,
+96,
+97,
+97,
+98,
+98,
+99,
+99,
+100,
+100,
+101,
+101,
+102,
+103,
+104,
+104,
+105,
+106,
+107,
+108,
+108,
+109,
+110,
+111,
+111,
+112,
+113,
+114,
+114,
+115,
+116,
+117,
+117,
+118,
+119,
+119,
+120,
+120,
+121,
+121,
+122,
+122,
+123,
+123,
+124,
+124,
+125,
+125,
+126,
+126,
+127,
+127,
+128,
+128,
+129,
+129,
+130,
+130,
+131,
+131,
+132,
+132,
+133,
+133,
+134,
+134,
+135,
+135,
+136,
+136,
+137,
+137,
+138,
+138,
+139,
+139,
+140,
+140,
+141,
+141,
+142,
+142,
+143,
+143,
+144,
+144,
+145,
+145,
+146,
+146,
+147,
+147,
+148,
+148,
+149,
+149,
+150,
+150,
+151,
+151,
+152,
+152,
+153,
+153,
+153,
+153,
+154,
+154,
+154,
+154,
+155,
+155,
+156,
+156,
+157,
+157,
+158,
+158,
+158,
+159,
+159,
+159,
+160,
+160,
+160,
+161,
+161,
+162,
+162,
+163,
+163,
+164,
+164,
+164,
+164,
+165,
+165,
+165,
+165,
+166,
+166,
+167,
+167,
+168,
+168,
+169,
+169,
+170,
+170,
+170,
+170,
+171,
+171,
+171,
+171,
+172,
+172,
+173,
+173,
+174,
+174,
+175,
+175,
+176,
+176,
+176,
+176,
+177,
+177,
+177,
+177,
+178,
+178,
+178,
+178,
+179,
+179,
+179,
+179,
+180,
+180,
+180,
+180,
+181,
+181,
+181,
+181,
+182,
+182,
+182,
+182,
+183,
+183,
+183,
+183,
+184,
+184,
+184,
+184,
+185,
+185,
+185,
+185,
+186,
+186,
+186,
+186,
+187,
+187,
+187,
+187,
+188,
+188,
+188,
+188,
+189,
+189,
+189,
+189,
+190,
+190,
+190,
+190,
+191,
+191,
+191,
+191,
+192,
+192,
+192,
+192,
+193,
+193,
+193,
+193,
+194,
+194,
+194,
+194,
+195,
+195,
+195,
+195,
+196,
+196,
+196,
+196,
+197,
+197,
+197,
+197,
+198,
+198,
+198,
+198,
+199,
+199,
+199,
+199,
+200,
+200,
+200,
+200,
+201,
+201,
+201,
+201,
+202,
+202,
+202,
+203,
+203,
+203,
+203,
+204,
+204,
+204,
+204,
+205,
+205,
+205,
+205,
+206,
+206,
+206,
+206,
+207,
+207,
+207,
+207,
+208,
+208,
+208,
+208,
+209,
+209,
+209,
+209,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+210,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+211,
+212,
+212,
+212,
+212,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+213,
+214,
+214,
+214,
+214,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+215,
+216,
+216,
+216,
+216,
+217,
+217,
+217,
+217,
+218,
+218,
+218,
+218,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+219,
+220,
+220,
+220,
+220,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+221,
+222,
+222,
+222,
+222,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+223,
+224,
+224,
+224,
+224,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+225,
+226,
+226,
+226,
+226,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+227,
+228,
+228,
+228,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+229,
+230,
+230,
+230,
+230,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+231,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+232,
+233,
+233,
+233,
+233,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+234,
+235,
+235,
+235,
+235,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+236,
+237,
+237,
+237,
+237,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+238,
+239,
+239,
+239,
+239,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+240,
+241,
+241,
+241,
+241,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+242,
+243,
+243,
+243,
+243,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+244,
+245,
+245,
+245,
+245,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+246,
+247,
+247,
+247,
+247,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+248,
+249,
+249,
+249,
+249,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+250,
+251,
+251,
+251,
+251,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+252,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+253,
+254,
+254,
+254,
+254,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255,
+255
diff --git a/include/linux/omap_resizer.h b/include/linux/omap_resizer.h
new file mode 100644
index 0000000..47b8dd8
--- /dev/null
+++ b/include/linux/omap_resizer.h
@@ -0,0 +1,137 @@
+/*
+ * drivers/media/video/isp/omap_resizer.h
+ *
+ * Include file for Resizer module wrapper in TI's OMAP3430 ISP
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef OMAP_RESIZER_H
+#define OMAP_RESIZER_H
+
+#include <linux/types.h>
+
+/* ioctls definition */
+#define RSZ_IOC_BASE		'R'
+#define RSZ_IOC_MAXNR		9
+
+/*Ioctl options which are to be passed while calling the ioctl*/
+#define RSZ_REQBUF		_IOWR(RSZ_IOC_BASE, 1,\
+					struct v4l2_requestbuffers)
+#define RSZ_QUERYBUF		_IOWR(RSZ_IOC_BASE, 2, struct v4l2_buffer)
+#define RSZ_S_PARAM		_IOWR(RSZ_IOC_BASE, 3, struct rsz_params)
+#define RSZ_G_PARAM		_IOWR(RSZ_IOC_BASE, 4, struct rsz_params)
+#define RSZ_RESIZE		_IOWR(RSZ_IOC_BASE, 5, __s32)
+#define RSZ_G_STATUS		_IOWR(RSZ_IOC_BASE, 6, struct rsz_status)
+#define RSZ_QUEUEBUF		_IOWR(RSZ_IOC_BASE, 7, struct v4l2_buffer)
+#define RSZ_GET_CROPSIZE	_IOWR(RSZ_IOC_BASE, 8, struct rsz_cropsize)
+#define RSZ_S_EXP		_IOWR(RSZ_IOC_BASE, 9, __s32)
+
+#define RSZ_INTYPE_YCBCR422_16BIT	0
+#define RSZ_INTYPE_PLANAR_8BIT		1
+#define RSZ_PIX_FMT_UYVY		1	/* cb:y:cr:y */
+#define RSZ_PIX_FMT_YUYV		0	/* y:cb:y:cr */
+
+enum config_done {
+	STATE_CONFIGURED,			/* Resizer driver configured
+						 * by application.
+						 */
+	STATE_NOT_CONFIGURED			/* Resizer driver not
+						 * configured by application.
+						 */
+};
+
+/* Structure Definitions */
+
+/* used to luma enhancement options */
+
+struct rsz_yenh {
+	__s32 type;				/* represents luma enable or
+						 * disable.
+						 */
+	__u8 gain;			/* represents gain. */
+	__u8 slop;			/* represents slop. */
+	__u8 core;			/* Represents core value. */
+};
+
+/* Conatins all the parameters for resizing. This structure
+ * is used to configure resiser parameters
+ */
+struct rsz_params {
+	__s32 in_hsize;				/* input frame horizontal
+						 * size.
+						 */
+	__s32 in_vsize;				/* input frame vertical size */
+	__s32 in_pitch;				/* offset between two rows of
+						 * input frame.
+						 */
+	__s32 inptyp;				/* for determining 16 bit or
+						 * 8 bit data.
+						 */
+	__s32 vert_starting_pixel;		/* for specifying vertical
+						 * starting pixel in input.
+						 */
+	__s32 horz_starting_pixel;		/* for specyfing horizontal
+						 * starting pixel in input.
+						 */
+	__s32 cbilin;				/* # defined, filter with luma
+						 * or bi-linear interpolation.
+						 */
+	__s32 pix_fmt;				/* # defined, UYVY or YUYV */
+	__s32 out_hsize;			/* output frame horizontal
+						 * size.
+						 */
+	__s32 out_vsize;				/* output frame vertical
+						 * size.
+						 */
+	__s32 out_pitch;			/* offset between two rows of
+						 * output frame.
+						 */
+	__s32 hstph;				/* for specifying horizontal
+						 * starting phase.
+						 */
+	__s32 vstph;				/* for specifying vertical
+						 * starting phase.
+						 */
+	__u16 tap4filt_coeffs[32];		/* horizontal filter
+						 * coefficients.
+						 */
+	__u16 tap7filt_coeffs[32];		/* vertical filter
+						 * coefficients.
+						 */
+	struct rsz_yenh yenh_params;
+};
+
+/* Contains the status of hardware and channel */
+struct rsz_status {
+	__s32 chan_busy;				/* 1: channel is busy,
+						 * 0: channel is not busy
+						 */
+	__s32 hw_busy;				/* 1: hardware is busy,
+						 * 0: hardware is not busy
+						 */
+	__s32 src;				/* # defined, can be either
+						 * SD-RAM or CCDC/PREVIEWER
+						 */
+};
+
+/* Passed by application for getting crop size */
+struct rsz_cropsize {
+	__u32 hcrop;			/* Number of pixels per line
+						 * cropped in output image.
+						 */
+
+	__u32 vcrop;			/* Number of lines cropped
+						 * in output image.
+						 */
+};
+
+#endif
-- 
1.6.5.2

