From c497c0bfed9fca091bb0ebbfb03d49f371717e2e Mon Sep 17 00:00:00 2001
From: "yadi.hu@windriver.com" <yadi.hu@windriver.com>
Date: Thu, 6 Nov 2014 10:06:30 +0800
Subject: [PATCH] ARM:enable irq in translation/section permission fault
 handlers

When we try to take a spinlock with irqs disabled, the RT patchset treats
that like a mutex.

	BUG: sleeping function called from invalid context at
	kernel/rtmutex.c:658
	in_atomic(): 0, irqs_disabled(): 128, pid: 994, name: a.out
	(dump_stack+0x20/0x24) from (__might_sleep+0x1dc/0x1e0)
	(__might_sleep+0x1dc/0x1e0) from (rt_spin_lock+0x34/0x6c)
	(rt_spin_lock+0x34/0x6c) from(do_force_sig_info+0x34/0xf0)

the cause is mainline commit<02fe2845d6a837ab02f0738f6cf4591a02cc88d4>
[avoid enabling interrupts in prefetch/data abort handlers], in which
it deletes irq enable block in assemble code and move them into page/
breakpiont/alignment fault handlers instead.unfortunately,author does
not enable irq in translation/section permission fault handlers.

Signed-off-by: Hu <yadi.hu@windriver.com>
---
 arch/arm/mm/fault.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index de5ee78..4ba4cd1 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -431,6 +431,9 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 	if (addr < TASK_SIZE)
 		return do_page_fault(addr, fsr, regs);
 
+	if (interrupts_enabled(regs))
+		local_irq_enable();
+
 	if (user_mode(regs))
 		goto bad_area;
 
@@ -507,6 +510,9 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 static int
 do_sect_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
 {
+	if (interrupts_enabled(regs))
+                local_irq_enable();
+
 	do_bad_area(addr, fsr, regs);
 	return 0;
 }
-- 
1.7.5.4

