From 42bda34fae30693da50c20f10c220954a2bfb55f Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Tue, 11 Jan 2011 16:44:02 +0000
Subject: [PATCH 3/5] ARM: sched_clock: make minsec argument to clocks_calc_mult_shift() zero

commit edc4d272551594729f63ca4cde1612608494091f upstream

The purpose of the minsec argument is to prevent 64-bit math overflow
when the number of cycles is multiplied up.  However, the multipler
is 32-bit, and in the sched_clock() case, the cycle counter is up to
32-bit as well.  So the math can never overflow.

With a value of 60, and clock rates greater than 71MHz, the calculated
multiplier is unnecessarily reduced in value, which reduces accuracy by
maybe 70ppt.  It's almost not worth bothering with as the oscillator
driving the counter won't be any more than 1ppm - unless you're using
a rubidium lamp or caesium fountain frequency standard.

So, set the minsec argument to zero.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
---
 arch/arm/kernel/sched_clock.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/arch/arm/kernel/sched_clock.c b/arch/arm/kernel/sched_clock.c
index 784464a..9a46370 100644
--- a/arch/arm/kernel/sched_clock.c
+++ b/arch/arm/kernel/sched_clock.c
@@ -34,7 +34,7 @@ void __init init_sched_clock(struct clock_data *cd, void (*update)(void),
 	sched_clock_update_fn = update;
 
 	/* calculate the mult/shift to convert counter ticks to ns. */
-	clocks_calc_mult_shift(&cd->mult, &cd->shift, rate, NSEC_PER_SEC, 60);
+	clocks_calc_mult_shift(&cd->mult, &cd->shift, rate, NSEC_PER_SEC, 0);
 
 	r = rate;
 	if (r >= 4000000) {
-- 
1.7.0.2

