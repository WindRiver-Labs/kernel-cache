From 1f25b7a8c635e7d1a955dd87d97d738774773396 Mon Sep 17 00:00:00 2001
From: Liming Wang <liming.wang@windriver.com>
Date: Fri, 29 Oct 2010 00:12:45 -0700
Subject: [PATCH] arm: fix the wrong find bit functions

In some special cases, the find bit functions will return the wrong
result.

In arm implementations, if the function finds the bit, it will call
.L_found label to return the final result.

Refer to generic find bit implementation, lib/find_next_bit.c, if the
result is larger than size/maxbit, we should make result equal to size/maxbit.

But .L_found label doesn't compare result with size/maxbit, so that it may
return wrong result.

let's see following four cases to show how
"find_first_zero_bit" of arm version works(note the third case):

1.
00000000 00111111
  ^       ^
  |       |
  |       |
 size   result

bitmap = 0x3f
size   = 13
result = 6, is correct.

2.
00000011 11111111
  ^  ^
  |  |
  |  ------|
 size    result

bitmap = 0x3ff
size   = 13
result = 10, is correct.

3.
00111111 11111111
 ^^
 ||
 -|--------|
 size      result

bitmap = 0x3fff
size   = 13
result = 14, is wrong!

It should compare result with size and make result equal to 13.

4.
00000011 11111111 11111111
           ^
           |
           |
          size(result)

bitmap = 0x3ffff
size   = 13
result = 13, is correct.

We can see that in the third case, the result is wrong.

This fix is to add the comparing in the end. Besides that, it also
compare maxbit and offset in the entry of the find_next_* functions.

In other archs, they have switched to use generic implementation in
lib/find_next_bit.c. So the best solution is to make arm to use the
generic version.

Signed-off-by: Liming Wang <liming.wang@windriver.com>
---
 arch/arm/lib/findbit.S |   16 +++++++++++++---
 1 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/arch/arm/lib/findbit.S b/arch/arm/lib/findbit.S
index 1e4cbd4..60a8be7 100644
--- a/arch/arm/lib/findbit.S
+++ b/arch/arm/lib/findbit.S
@@ -45,6 +45,8 @@ ENDPROC(_find_first_zero_bit_le)
 ENTRY(_find_next_zero_bit_le)
 		teq	r1, #0
 		beq	3b
+		cmp	r2, r1
+		bhs	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
  ARM(		ldrb	r3, [r0, r2, lsr #3]	)
@@ -81,11 +83,13 @@ ENDPROC(_find_first_bit_le)
 
 /*
  * Purpose  : Find next 'one' bit
- * Prototype: int find_next_zero_bit(void *addr, unsigned int maxbit, int offset)
+ * Prototype: int find_next_bit(void *addr, unsigned int maxbit, int offset)
  */
 ENTRY(_find_next_bit_le)
 		teq	r1, #0
 		beq	3b
+		cmp	r2, r1
+		bhs	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
  ARM(		ldrb	r3, [r0, r2, lsr #3]	)
@@ -120,6 +124,8 @@ ENDPROC(_find_first_zero_bit_be)
 ENTRY(_find_next_zero_bit_be)
 		teq	r1, #0
 		beq	3b
+		cmp	r2, r1
+		bhs	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
 		eor	r3, r2, #0x18		@ big endian byte ordering
@@ -154,6 +160,8 @@ ENDPROC(_find_first_bit_be)
 ENTRY(_find_next_bit_be)
 		teq	r1, #0
 		beq	3b
+		cmp	r2, r1
+		bhs	3b
 		ands	ip, r2, #7
 		beq	1b			@ If new byte, goto old routine
 		eor	r3, r2, #0x18		@ big endian byte ordering
@@ -174,8 +182,8 @@ ENDPROC(_find_next_bit_be)
  */
 .L_found:
 #if __LINUX_ARM_ARCH__ >= 5
-		rsb	r1, r3, #0
-		and	r3, r3, r1
+		rsb	r0, r3, #0
+		and	r3, r3, r0
 		clz	r3, r3
 		rsb	r3, r3, #31
 		add	r0, r2, r3
@@ -190,5 +198,7 @@ ENDPROC(_find_next_bit_be)
 		addeq	r2, r2, #1
 		mov	r0, r2
 #endif
+		cmp     r0, r1
+		movhi   r0, r1
 		mov	pc, lr
 
-- 
1.6.5.2

