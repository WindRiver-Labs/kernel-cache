From cbee38ef0537eaa01b5db548c81ce071e7ef46fd Mon Sep 17 00:00:00 2001
From: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Date: Tue, 23 Dec 2014 17:42:02 +0530
Subject: [PATCH 012/132] irqchip/gicv3-its: Add low level msi_prepare

Add a low level __its_msi_pepare() function which can be
used by non PCI bus driver code to implement their
prepare function. __its_msi_prepare() takes dev_id as an
argument.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Change-Id: I4c5a3a0cac27e4f09e521ceb07c3aec33c29a3c2
Reviewed-on: http://git.am.freescale.net:8181/33321
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Tested-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/irqchip/irq-gic-v3-its.c   |   31 ++++++++++++++++++++-----------
 include/linux/irqchip/arm-gic-v3.h |    3 +++
 2 files changed, 23 insertions(+), 11 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 44d6354..b562876 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -1139,20 +1139,15 @@ static int its_alloc_device_irq(struct its_device *dev, irq_hw_number_t *hwirq)
 	return 0;
 }
 
-static int its_msi_prepare(struct irq_domain *domain, struct device *dev,
-			   int nvec, msi_alloc_info_t *info)
+
+int __its_msi_prepare(struct irq_domain *domain, u32 dev_id,
+	struct device *dev, int nvec, msi_alloc_info_t *info)
 {
-	struct pci_dev *pdev;
 	struct its_node *its;
-	u32 dev_id;
 	struct its_device *its_dev;
 
-	if (!dev_is_pci(dev))
-		return -EINVAL;
 
-	pdev = to_pci_dev(dev);
-	dev_id = PCI_DEVID(pdev->bus->number, pdev->devfn);
-	its = domain->parent->host_data;
+	its = domain->host_data;
 
 	its_dev = its_find_device(its, dev_id);
 	if (WARN_ON(its_dev))
@@ -1162,13 +1157,27 @@ static int its_msi_prepare(struct irq_domain *domain, struct device *dev,
 	if (!its_dev)
 		return -ENOMEM;
 
-	dev_dbg(&pdev->dev, "ITT %d entries, %d bits\n", nvec, ilog2(nvec));
-
 	info->scratchpad[0].ptr = its_dev;
 	info->scratchpad[1].ptr = dev;
+
 	return 0;
 }
 
+static int its_msi_prepare(struct irq_domain *domain, struct device *dev,
+			   int nvec, msi_alloc_info_t *info)
+{
+	struct pci_dev *pdev;
+	u32 dev_id;
+
+	if (!dev_is_pci(dev))
+		return -EINVAL;
+
+	pdev = to_pci_dev(dev);
+	dev_dbg(dev, "ITT %d entries, %d bits\n", nvec, ilog2(nvec));
+	dev_id = PCI_DEVID(pdev->bus->number, pdev->devfn);
+	return __its_msi_prepare(domain->parent, dev_id, dev, nvec, info);
+}
+
 static struct msi_domain_ops its_pci_msi_ops = {
 	.msi_prepare	= its_msi_prepare,
 };
diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h
index 0e3be0a..71b58a4 100644
--- a/include/linux/irqchip/arm-gic-v3.h
+++ b/include/linux/irqchip/arm-gic-v3.h
@@ -286,6 +286,7 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/stringify.h>
+#include <linux/msi.h>
 
 /*
  * We need a value to serve as a irq-type for LPIs. Choose one that will
@@ -313,6 +314,8 @@ static inline void gic_write_eoir(u64 irq)
 int its_cpu_init(void);
 struct irq_chip *its_init(struct device_node *node, struct rdist *rdist,
 			  struct irq_domain *domain);
+int __its_msi_prepare(struct irq_domain *domain, u32 dev_id,
+	struct device *dev, int nvec, msi_alloc_info_t *info);
 
 #endif
 
-- 
1.7.5.4

