From a69dcc15404cd1f8977833d88210584277e40ce1 Mon Sep 17 00:00:00 2001
From: Marc Zyngier <marc.zyngier@arm.com>
Date: Mon, 24 Nov 2014 14:35:13 +0000
Subject: [PATCH 015/132] irqchip: GICv3: ITS: LPI allocator

commit bf9529f8c80c2ec61eacb677eba06a6bd0466be2 upstream

LPIs are the type of interrupts that are used by the ITS. Given
the size of the namespace (anywhere between 16 and 32bit), interrupt
IDs are allocated in chunks of 32.

Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
Link: https://lkml.kernel.org/r/1416839720-18400-7-git-send-email-marc.zyngier@arm.com
Signed-off-by: Jason Cooper <jason@lakedaemon.net>
[irq-gic files are different from mainline, so this patch
 is not same as upstream.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/irqchip/irq-gic-v3-its.c |   85 +++++++++++++++++++++++---------------
 1 files changed, 51 insertions(+), 34 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index 08e5615..368eb28 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -710,53 +710,65 @@ static int its_lpi_init(u32 id_bits)
 	return 0;
 }
 
-static struct its_lpi_chunk *its_lpi_alloc(void)
+static unsigned long *its_lpi_alloc_chunks(int nr_irqs, int *base, int *nr_ids)
 {
-	struct its_lpi_chunk *chunk;
-	int lpi;
+	unsigned long *bitmap = NULL;
+	int chunk_id;
+	int nr_chunks;
+	int i;
 
-	chunk = kzalloc(sizeof(*chunk), GFP_KERNEL);
-	if (!chunk)
-		return NULL;
+	nr_chunks = DIV_ROUND_UP(nr_irqs, IRQS_PER_CHUNK);
 
 	spin_lock(&lpi_lock);
 
-	lpi = find_first_zero_bit(lpi_bitmap, lpi_chunks);
-	if (lpi < lpi_chunks) {
-		set_bit(lpi, lpi_bitmap);
-		chunk->lpi_base = its_chunk_to_lpi(lpi);
-		INIT_LIST_HEAD(&chunk->entry);
-	} else {
-		lpi = -ENOSPC;
-	}
+	do {
+		chunk_id = bitmap_find_next_zero_area(lpi_bitmap, lpi_chunks,
+						      0, nr_chunks, 0);
+		if (chunk_id < lpi_chunks)
+			break;
 
-	spin_unlock(&lpi_lock);
+		nr_chunks--;
+	} while (nr_chunks > 0);
 
-	if (lpi < 0) {
-		kfree(chunk);
-		return NULL;
-	}
+	if (!nr_chunks)
+		goto out;
+
+	bitmap = kzalloc(BITS_TO_LONGS(nr_chunks * IRQS_PER_CHUNK) * sizeof (long),
+			 GFP_ATOMIC);
+	if (!bitmap)
+		goto out;
+
+	for (i = 0; i < nr_chunks; i++)
+		set_bit(chunk_id + i, lpi_bitmap);
+
+	*base = its_chunk_to_lpi(chunk_id);
+	*nr_ids = nr_chunks * IRQS_PER_CHUNK;
 
-	return chunk;
+out:
+	spin_unlock(&lpi_lock);
+
+	return bitmap;
 }
 
-static void its_lpi_free(struct its_lpi_chunk *chunk)
+static void its_lpi_free(unsigned long *bitmap, int base, int nr_ids)
 {
 	int lpi;
 
 	spin_lock(&lpi_lock);
 
-	lpi = its_lpi_to_chunk(chunk->lpi_base);
-	BUG_ON(lpi > lpi_chunks);
-	if (test_bit(lpi, lpi_bitmap)) {
-		clear_bit(lpi, lpi_bitmap);
-	} else {
-		pr_err("Bad LPI chunk %d\n", lpi);
+	for (lpi = base; lpi < (base + nr_ids); lpi += IRQS_PER_CHUNK) {
+		int chunk = its_lpi_to_chunk(lpi);
+		BUG_ON(chunk > lpi_chunks);
+		if (test_bit(chunk, lpi_bitmap)) {
+			clear_bit(chunk, lpi_bitmap);
+		} else {
+			pr_err("Bad LPI chunk %d\n", chunk);
+		}
 	}
 
 	spin_unlock(&lpi_lock);
 
-	kfree(chunk);
+	kfree(bitmap);
 }
 
 /*
@@ -1112,6 +1124,17 @@ static struct its_device *its_create_device(struct its_node *its, u32 dev_id,
 	return dev;
 }
 
+static void its_free_device(struct its_device *its_dev)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&its_dev->its->lock, flags);
+	list_del(&its_dev->entry);
+	raw_spin_unlock_irqrestore(&its_dev->its->lock, flags);
+	kfree(its_dev->itt);
+	kfree(its_dev);
+}
+
 static int its_alloc_device_irq(struct its_device *dev, irq_hw_number_t *hwirq)
 {
 	int idx;
@@ -1278,12 +1301,6 @@ static const struct irq_domain_ops its_domain_ops = {
 	.deactivate		= its_irq_domain_deactivate,
 };
 
-static void its_free_device(struct its_device *its_dev)
-{
-	kfree(its_dev->itt);
-	kfree(its_dev);
-}
-
 static struct its_lpi_chunk *its_find_chunk(struct its_device *its_dev,
 					    struct irq_data *d)
 {
-- 
1.7.5.4

