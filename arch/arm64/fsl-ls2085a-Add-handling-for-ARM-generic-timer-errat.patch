From cd5fa3517292a28f0ff2490466e085fd7a9f8310 Mon Sep 17 00:00:00 2001
From: Bhupesh Sharma <bhupesh.sharma@freescale.com>
Date: Fri, 23 Jan 2015 16:26:00 +0530
Subject: [PATCH 127/132] fsl/ls2085a: Add handling for ARM generic timer
 errata (ERR008585)

This patch adds s/w handling for LS2085A-Rev1 SoC Errata ERR008585:
ARM Generic Timer may contain an erroneous value.

Errata Description:
------------------
The ARM Generic Timer (as specified in the ARMv8 Architecture Reference
Manual) is supported. The ARM Generic Timer can schedule events and
trigger interrupts based on an incrementing counter value. However, it
has the potential to contain an erroneous value for a small number of
core clock cycles every time the timer value changes.

Errata Workaround:
-----------------
Use ARM Generic Timer and ignore spurious interrupts. Any time in
software reading registers CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL,
CNTPCT, or CNTVCT), have software read the register twice. If the
value read differs, then re-read the register, and continue to read
until two consecutive reads return the same value.

Signed-off-by: Bhupesh Sharma <bhupesh.sharma@freescale.com>
Change-Id: I829792ac6d85ca7a3aeb9b9740c2edcd128a8353
Reviewed-on: http://git.am.freescale.net:8181/29726
(cherry picked from commit 95fdc95afa2f78a1b9245723d2ac98d7b471102e)
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/arm64/Kconfig                   |   11 ++++++++++
 arch/arm64/include/asm/arch_timer.h  |   14 +++++++++++++
 drivers/clocksource/arm_arch_timer.c |   35 ++++++++++++++++++++++++++++++++++
 3 files changed, 60 insertions(+), 0 deletions(-)

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index b5179ba..f01cc23 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -135,8 +135,19 @@ source "kernel/Kconfig.freezer"
 
 menu "Platform selection"
 
+config LS2085A_ERRATA_ERR008585
+	bool "Freescale LS2085A SOC Errata ERR008585"
+	help
+	  This enables support for Freescale LS2085A SOC Errata ERR008585, which
+	  is related to ARM generic timers. The Errata is related to spurious
+	  arriving from ARM generic timers. Software should read registers
+	  CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL, CNTPCT, or CNTVCT twice.
+	  If the value read differs, then re-read the register, and continue to
+	  read until two consecutive reads return the same value.
+
 config ARCH_FSL_LS2085A
 	bool "Freescale LS2085A SOC"
+	select LS2085A_ERRATA_ERR008585
 	help
 	  This enables support for Freescale LS2085A SOC.
 
diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index 9400596..644ae0d 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -139,9 +139,23 @@ static inline u64 arch_counter_get_cntvct(void)
 {
 	u64 cval;
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u64 cval_new, timeout = 200;
+#endif
+
 	isb();
 	asm volatile("mrs %0, cntvct_el0" : "=r" (cval));
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
+	while (cval != cval_new && timeout) {
+		cval = cval_new;
+		asm volatile("mrs %0, cntvct_el0" : "=r" (cval_new));
+		timeout--;
+	}
+	BUG_ON((timeout <= 0) && (cval != cval_new));
+#endif
+
 	return cval;
 }
 
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index 49c38e7..e542db3 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -108,6 +108,10 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 {
 	u32 val;
 
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u32 val_new, timeout = 200;
+#endif
+
 	if (access == ARCH_TIMER_MEM_PHYS_ACCESS) {
 		struct arch_timer *timer = to_arch_timer(clk);
 		switch (reg) {
@@ -116,6 +120,17 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			val = readl_relaxed(timer->base + CNTP_TVAL);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			val_new = readl_relaxed(timer->base + CNTP_TVAL);
+			while (val != val_new && timeout) {
+				val = val_new;
+				val_new = readl_relaxed(timer->base +
+							CNTP_TVAL);
+				timeout--;
+
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	} else if (access == ARCH_TIMER_MEM_VIRT_ACCESS) {
@@ -126,10 +141,30 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			val = readl_relaxed(timer->base + CNTV_TVAL);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			val_new = readl_relaxed(timer->base + CNTV_TVAL);
+			while (val != val_new && timeout) {
+				val = val_new;
+				val_new = readl_relaxed(timer->base +
+							CNTV_TVAL);
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
+
 			break;
 		}
 	} else {
 		val = arch_timer_reg_read_cp15(access, reg);
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+		val_new = arch_timer_reg_read_cp15(access, reg);
+		while (val != val_new && timeout) {
+			val = val_new;
+			val_new = arch_timer_reg_read_cp15(access, reg);
+			timeout--;
+		}
+		BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 	}
 
 	return val;
-- 
1.7.5.4

