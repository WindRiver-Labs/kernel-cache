From 956d5831912d3deef574019d65cf142307cca33b Mon Sep 17 00:00:00 2001
From: Minghuan Lian <Minghuan.Lian@freescale.com>
Date: Thu, 8 Jan 2015 16:04:57 +0800
Subject: [PATCH 045/132] pci/layerscape: add LS2085A PCIe support

Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Change-Id: I8756c09fe6c9f917e2db676105b53fdb1c7845dd
Reviewed-on: http://git.am.freescale.net:8181/31067
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/pci/host/Kconfig          |    2 +-
 drivers/pci/host/pci-layerscape.c |  102 ++++++++++++++++++++++++++++++-------
 2 files changed, 85 insertions(+), 19 deletions(-)

diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index 22f5881..e30cb6a 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -57,7 +57,7 @@ config PCI_RCAR_GEN2_PCIE
 
 config PCI_LAYERSCAPE
 	bool "Freescale Layerscape PCIe controller"
-	depends on OF && ARM
+	depends on OF && (ARM || ARM64)
 	select PCIE_DW
 	select MFD_SYSCON
 	help
diff --git a/drivers/pci/host/pci-layerscape.c b/drivers/pci/host/pci-layerscape.c
index 6697b1a..7048f8c 100644
--- a/drivers/pci/host/pci-layerscape.c
+++ b/drivers/pci/host/pci-layerscape.c
@@ -32,14 +32,20 @@
 #define LTSSM_STATE_MASK	0x3f
 #define LTSSM_PCIE_L0		0x11 /* L0 state */
 
-/* Symbol Timer Register and Filter Mask Register 1 */
-#define PCIE_STRFMR1 0x71c
+/* PEX internal configuration registers */
+#define PCIE_STRFMR1		0x71c /* Symbol Timer & Filter Mask Register1 */
+#define PCIE_DBI_RO_WR_EN	0x8bc /* DBI Read-Only Write Enable Register */
+
+/* PEX LUT registers */
+#define PCIE_LUT_BASE		0x80000
+#define PCIE_LUT_DBG		0x7FC /* PEX LUT Debug register */
 
 struct ls_pcie {
 	struct list_head node;
 	struct device *dev;
 	struct pci_bus *bus;
 	void __iomem *dbi;
+	void __iomem *lut;
 	struct regmap *scfg;
 	struct pcie_port pp;
 	int index;
@@ -48,7 +54,7 @@ struct ls_pcie {
 
 #define to_ls_pcie(x)	container_of(x, struct ls_pcie, pp)
 
-static int ls_pcie_link_up(struct pcie_port *pp)
+static int ls1_pcie_link_up(struct pcie_port *pp)
 {
 	u32 state;
 	struct ls_pcie *pcie = to_ls_pcie(pp);
@@ -62,7 +68,7 @@ static int ls_pcie_link_up(struct pcie_port *pp)
 	return 1;
 }
 
-static void ls_pcie_host_init(struct pcie_port *pp)
+static void ls1_pcie_host_init(struct pcie_port *pp)
 {
 	struct ls_pcie *pcie = to_ls_pcie(pp);
 	int count = 0;
@@ -70,7 +76,7 @@ static void ls_pcie_host_init(struct pcie_port *pp)
 
 	dw_pcie_setup_rc(pp);
 
-	while (!ls_pcie_link_up(pp)) {
+	while (!ls1_pcie_link_up(pp)) {
 		usleep_range(100, 1000);
 		count++;
 		if (count >= 200) {
@@ -88,11 +94,60 @@ static void ls_pcie_host_init(struct pcie_port *pp)
 	iowrite32(val, pcie->dbi + PCIE_STRFMR1);
 }
 
+static int ls2_pcie_link_up(struct pcie_port *pp)
+{
+	u32 state;
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+
+	state = ioread32(pcie->lut + PCIE_LUT_DBG) & LTSSM_STATE_MASK;
+	if (state < LTSSM_PCIE_L0)
+		return 0;
+
+	return 1;
+}
+
+static void ls2_pcie_host_init(struct pcie_port *pp)
+{
+	int count = 0;
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+
+	dw_pcie_setup_rc(pp);
+
+	/* Fix class value and clean multi-func bit */
+	writel(1, pcie->dbi + PCIE_DBI_RO_WR_EN);
+	dw_pcie_cfg_write(pcie->dbi + (PCI_CLASS_DEVICE & ~0x3),
+			  PCI_CLASS_DEVICE, 2,
+			  PCI_CLASS_BRIDGE_PCI);
+	dw_pcie_cfg_write(pcie->dbi + (PCI_HEADER_TYPE & ~0x3),
+			  PCI_HEADER_TYPE, 1,
+			  PCI_HEADER_TYPE_BRIDGE);
+	writel(0, pcie->dbi + PCIE_DBI_RO_WR_EN);
+
+	while (!ls2_pcie_link_up(pp)) {
+		usleep_range(100, 1000);
+		count++;
+		if (count >= 200) {
+			dev_err(pp->dev, "phy link never came up\n");
+			return;
+		}
+	}
+}
+
 static struct pcie_host_ops ls_pcie_host_ops = {
-	.link_up = ls_pcie_link_up,
-	.host_init = ls_pcie_host_init,
+	.link_up = ls2_pcie_link_up,
+	.host_init = ls2_pcie_host_init,
 };
 
+static bool ls_pcie_is_bridge(struct ls_pcie *pcie)
+{
+	u32 header_type = 0;
+
+	dw_pcie_cfg_read(pcie->dbi + (PCI_HEADER_TYPE & ~0x3),
+			 PCI_HEADER_TYPE, 2, &header_type);
+
+	return (header_type & 0x7f) == PCI_HEADER_TYPE_BRIDGE;
+}
+
 static int ls_add_pcie_port(struct ls_pcie *pcie)
 {
 	struct pcie_port *pp;
@@ -136,18 +191,28 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 	if (IS_ERR(pcie->dbi))
 		return PTR_ERR(pcie->dbi);
 
-	pcie->scfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
-						     "fsl,pcie-scfg");
-	if (IS_ERR(pcie->scfg)) {
-		dev_err(&pdev->dev, "No syscfg phandle specified\n");
-		return PTR_ERR(pcie->scfg);
-	}
+	pcie->lut = pcie->dbi + PCIE_LUT_BASE;
 
-	ret = of_property_read_u32_array(pdev->dev.of_node,
-					 "fsl,pcie-scfg", index, 2);
-	if (ret)
-		return ret;
-	pcie->index = index[1];
+	if (!ls_pcie_is_bridge(pcie))
+		return 0;
+
+	if (of_device_is_compatible(pcie->dev->of_node, "fsl,ls1021a-pcie")) {
+		pcie->scfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+							     "fsl,pcie-scfg");
+		if (IS_ERR(pcie->scfg)) {
+			dev_err(&pdev->dev, "No syscfg phandle specified\n");
+			return PTR_ERR(pcie->scfg);
+		}
+
+		ret = of_property_read_u32_array(pdev->dev.of_node,
+						 "fsl,pcie-scfg", index, 2);
+		if (ret)
+			return ret;
+		pcie->index = index[1];
+
+		ls_pcie_host_ops.link_up = ls1_pcie_link_up;
+		ls_pcie_host_ops.host_init = ls1_pcie_host_init;
+	}
 
 	ret = ls_add_pcie_port(pcie);
 	if (ret < 0)
@@ -160,6 +225,7 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 
 static const struct of_device_id ls_pcie_of_match[] = {
 	{ .compatible = "fsl,ls1021a-pcie" },
+	{ .compatible = "fsl,ls2085a-pcie" },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, ls_pcie_of_match);
-- 
1.7.5.4

