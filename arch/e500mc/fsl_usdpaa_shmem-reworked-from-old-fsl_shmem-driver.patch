From ab93443f3cf3ac4b5d4121bda3920e5b27ccbf19 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 28 Apr 2011 20:26:46 -0400
Subject: [PATCH 087/233] fsl_usdpaa_shmem: reworked from old "fsl_shmem" driver.

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0192-fsl_usdpaa_shmem-reworked-from-old-fsl_shmem-driver.patch

This the old "fsl_shmem" driver, renamed to "fsl_usdpaa_shmem", with a
variety of updates that make it USDPAA-specific.

The support for a "fsl-shmem" device-tree node specifying the memory
region is removed, as this required the manual coordination of too many
hard-coded constants. (User-space address-handling, the "mem=" boot
parameter to the kernel, the buffer-pool seeding in the device-tree, and
the "TLB1 hack" in the kernel memory handling.) Note also that the
original authors of fsl_shmem, who believed it to be removed for good,
were not keen to see it revived in its existing form.

This change uses a Kconfig setting to trigger an early-boot allocation of
a physically-contiguous memory range, size is also controlled by a
Kconfig setting (default: 64MB).

Also, the old "TLB1 hack" is included and has been updated to match
against the early-boot allocation, rather than assuming hard-coded
addresses. This also means the driver cannot be built as a loadable
module, it must be built into the kernel. The driver's early-boot hook
will attempt to find an unused region of suitably-aligned memory, by
searching from the high-end of the memory range downwards, though due to a
conflict with ramdisk handling this logic intentionally limits itself to
the first 6GB. It also reserves a "tlbcam_index" value to ensure other
uses of TLB1 (HugeTLB, kvm, ...) don't conflict.

The resulting character device "/dev/fsl-usdpaa-shmem" (renamed) supports
a new ioctl() to allow the application to retrieve the physical (DMA)
base-address and size of the memory region. (So this change is inter-
dependent on a matching change in the user-space "dma_mem" driver.)

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Becky Bruce <beckyb@kernel.crashing.org>
[context adjustment]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/powerpc/mm/fsl_booke_mmu.c          |    4 +-
 arch/powerpc/mm/mem.c                    |   32 +++++++
 arch/powerpc/mm/mmu_decl.h               |    2 +
 arch/powerpc/platforms/85xx/corenet_ds.c |    5 +
 drivers/misc/Kconfig                     |   35 +++++++
 drivers/misc/Makefile                    |    1 +
 drivers/misc/fsl_usdpaa_shmem.c          |  142 ++++++++++++++++++++++++++++++
 include/linux/fsl_usdpaa.h               |   53 +++++++++++
 8 files changed, 272 insertions(+), 2 deletions(-)
 create mode 100644 drivers/misc/fsl_usdpaa_shmem.c
 create mode 100644 include/linux/fsl_usdpaa.h

diff --git a/arch/powerpc/mm/fsl_booke_mmu.c b/arch/powerpc/mm/fsl_booke_mmu.c
index 5913343..2a86dae 100644
--- a/arch/powerpc/mm/fsl_booke_mmu.c
+++ b/arch/powerpc/mm/fsl_booke_mmu.c
@@ -2,7 +2,7 @@
  * Modifications by Kumar Gala (galak@kernel.crashing.org) to support
  * E500 Book E processors.
  *
- * Copyright 2004,2010 Freescale Semiconductor, Inc.
+ * Copyright 2004-2011 Freescale Semiconductor, Inc.
  *
  * This file contains the routines for initializing the MMU
  * on the 4xx series of chips.
@@ -103,7 +103,7 @@ unsigned long p_mapped_by_tlbcam(phys_addr_t pa)
  * The parameters are not checked; in particular size must be a power
  * of 4 between 4k and 256M.
  */
-static void settlbcam(int index, unsigned long virt, phys_addr_t phys,
+void settlbcam(int index, unsigned long virt, phys_addr_t phys,
 		unsigned long size, unsigned long flags, unsigned int pid)
 {
 	unsigned int tsize, lz;
diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index f4e910e..78a85bf 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -35,6 +35,9 @@
 #include <linux/lmb.h>
 #include <linux/hugetlb.h>
 
+/* See hook_usdpaa_tlb1() */
+#include <linux/fsl_usdpaa.h>
+
 #include <asm/pgalloc.h>
 #include <asm/prom.h>
 #include <asm/io.h>
@@ -510,6 +513,31 @@ void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
 }
 EXPORT_SYMBOL(flush_icache_user_range);
 
+#ifdef CONFIG_FSL_USDPAA_SHMEM
+/*
+ * NB: this 'usdpaa' check+hack is to create a single TLB1 entry to cover the
+ * buffer memory used by run-to-completion UIO-based apps ("User-Space DataPath
+ * Acceleration Architecture"). It is expected to be phased out once HugeTLB
+ * support is hooked up. The other half of this hack is in
+ * drivers/misc/fsl_shmem.c.
+ */
+static inline void hook_usdpaa_tlb1(struct vm_area_struct *vma,
+				unsigned long address, pte_t *ptep)
+{
+	unsigned long pfn = pte_pfn(*ptep);
+	if ((pfn < (usdpaa_pfn_start + usdpaa_pfn_len)) &&
+	    (pfn >= usdpaa_pfn_start)) {
+		unsigned long va = address & ~(usdpaa_phys_size - 1);
+		flush_tlb_mm(vma->vm_mm);
+		settlbcam(usdpaa_tlbcam_index, va,
+			usdpaa_phys_start, usdpaa_phys_size,
+			pte_val(*ptep), mfspr(SPRN_PID));
+	}
+}
+#else
+#define hook_usdpaa_tlb1(a, b, c) do { ; } while (0)
+#endif
+
 /*
  * This is called at the end of handling a user page fault, when the
  * fault has been handled by updating a PTE in the linux page tables.
@@ -543,6 +571,10 @@ void update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
 	else if (trap != 0x300)
 		return;
 	hash_preload(vma->vm_mm, address, access, trap);
+#else
+
+	hook_usdpaa_tlb1(vma, address, ptep);
+
 #endif /* CONFIG_PPC_STD_MMU */
 #if (defined(CONFIG_PPC_BOOK3E_64) || defined(CONFIG_PPC_FSL_BOOK3E)) \
 	&& defined(CONFIG_HUGETLB_PAGE)
diff --git a/arch/powerpc/mm/mmu_decl.h b/arch/powerpc/mm/mmu_decl.h
index 313ee92..c1cf576 100644
--- a/arch/powerpc/mm/mmu_decl.h
+++ b/arch/powerpc/mm/mmu_decl.h
@@ -102,6 +102,8 @@ extern void mapin_ram(void);
 extern int map_page(unsigned long va, phys_addr_t pa, int flags);
 extern void setbat(int index, unsigned long virt, phys_addr_t phys,
 		   unsigned int size, int flags);
+void settlbcam(int index, unsigned long virt, phys_addr_t phys,
+		unsigned long size, unsigned long flags, unsigned int pid);
 
 extern int __map_without_bats;
 extern int __allow_ioremap_reserved;
diff --git a/arch/powerpc/platforms/85xx/corenet_ds.c b/arch/powerpc/platforms/85xx/corenet_ds.c
index 9bcb55a..5adbee3 100644
--- a/arch/powerpc/platforms/85xx/corenet_ds.c
+++ b/arch/powerpc/platforms/85xx/corenet_ds.c
@@ -18,6 +18,8 @@
 #include <linux/interrupt.h>
 #include <linux/lmb.h>
 
+#include <linux/fsl_usdpaa.h>
+
 #include <asm/system.h>
 #include <asm/time.h>
 #include <asm/machdep.h>
@@ -188,5 +190,8 @@ __init void corenet_ds_init_early(void)
 #ifdef CONFIG_FSL_PME2_CTRL
 	pme2_init_early();
 #endif
+#ifdef CONFIG_FSL_USDPAA_SHMEM
+	fsl_usdpaa_shmem_init_early();
+#endif
 }
 
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 3f4093a..a98566d 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -173,6 +173,41 @@ config ENCLOSURE_SERVICES
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
+config FSL_USDPAA_SHMEM
+	bool "Freescale USDPAA shared memory driver"
+	depends on PPC_85xx
+	help
+	  This driver provides user-space access to a large contiguous
+	  memory allocation, reserved for use by Freescale USDPAA (User
+	  Space DataPath Acceleration Architecture) applications. This
+	  driver includes a private ioctl() interface for conveying the
+	  size and (DMA-)base-address of the memory region. It is also
+	  hooked by the MMU code, such that a single TLB1 mapping is
+	  created for the entire region when the first fault occurs.
+	  The intention is for this driver to be replaced by HugeTLB
+	  facilities, once they are available for USDPAA platforms.
+
+config FSL_USDPAA_SHMEM_LOG4
+	int "Log4 page-order of USDPAA memory reservation"
+	depends on FSL_USDPAA_SHMEM
+	range 7 9
+	default 7
+	help
+	  This configures the size of contiguous memory reserved for
+	  the USDPAA DMA memory map. It is carved out of the physical
+	  address-space early during boot, and cannot be released or
+	  resized thereafter. Some of this memory is used for seeding
+	  Bman buffer pools, and the remainder is for ad-hoc DMA buffer
+	  allocation (eg. Qman-stashable FQ contexts). Current USDPAA
+	  defaults require ~24MB for buffers.
+
+	  This region must be a power-of-four multiple of the page
+	  size (4KB), so the minimal usable value with the current
+	  USPAA (and the default) is 64MB (setting=7).
+
+	  For memory size 'x', the required setting is 'log4(x/4096)'.
+	  Or for setting 'x', the memory size will be '4096*(4^x)'.
+
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 240f6c1..b9f6c4e 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_TIFM_7XX1)       	+= tifm_7xx1.o
 obj-$(CONFIG_PHANTOM)		+= phantom.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
+obj-$(CONFIG_FSL_USDPAA_SHMEM)	+= fsl_usdpaa_shmem.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
diff --git a/drivers/misc/fsl_usdpaa_shmem.c b/drivers/misc/fsl_usdpaa_shmem.c
new file mode 100644
index 0000000..6c293ed
--- /dev/null
+++ b/drivers/misc/fsl_usdpaa_shmem.c
@@ -0,0 +1,142 @@
+/* Copyright (C) 2008-2011 Freescale Semiconductor, Inc.
+ * Authors: Andy Fleming <afleming@freescale.com>
+ *          Timur Tabi <timur@freescale.com>
+ *          Geoff Thorpe <Geoff.Thorpe@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/fsl_usdpaa.h>
+
+#include <linux/miscdevice.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/lmb.h>
+
+/* Physical address range */
+u64 usdpaa_phys_start;
+u64 usdpaa_phys_size;
+
+/* PFN versions */
+unsigned long usdpaa_pfn_start;
+unsigned long usdpaa_pfn_len;
+
+/* TLB1 index */
+unsigned int usdpaa_tlbcam_index;
+
+static int usdpaa_shmem_open(struct inode *inode, struct file *filp)
+{
+	filp->f_mapping->backing_dev_info = &directly_mappable_cdev_bdi;
+
+	return 0;
+}
+
+static int usdpaa_shmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	if (vma->vm_pgoff) {
+		pr_err("%s: non-zero mmap page-offset 0x%lx is invalid\n",
+			__func__, vma->vm_pgoff);
+		return -EINVAL;
+	}
+	if (size != usdpaa_phys_size) {
+		pr_err("%s: mmap size 0x%llx doesn't match region (0x%llx)\n",
+			__func__, (unsigned long long)size, usdpaa_phys_size);
+		return -EINVAL;
+	}
+	if (vma->vm_start & (usdpaa_phys_size - 1)) {
+		pr_err("%s: un-aligned mapping %llx:%llx -> %lx\n",
+			__func__, usdpaa_phys_start, usdpaa_phys_size,
+			vma->vm_start);
+		return -EINVAL;
+	}
+	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start, size,
+				vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+static long usdpaa_shmem_ioctl(struct file *fp, unsigned int cmd,
+				unsigned long arg)
+{
+	struct usdpaa_ioctl_get_region ret = {
+		.phys_start = usdpaa_phys_start,
+		.phys_len = usdpaa_phys_size
+	};
+	if (cmd != USDPAA_IOCTL_GET_PHYS_BASE)
+		return -EINVAL;
+	return copy_to_user((void __user *)arg, &ret, sizeof(ret));
+}
+
+static const struct file_operations shmem_fops = {
+	.open		= usdpaa_shmem_open,
+	.mmap		= usdpaa_shmem_mmap,
+	.unlocked_ioctl = usdpaa_shmem_ioctl
+};
+
+static struct miscdevice usdpaa_shmem_miscdev = {
+	.name = "fsl-usdpaa-shmem",
+	.fops = &shmem_fops,
+	.minor = MISC_DYNAMIC_MINOR,
+};
+
+__init void fsl_usdpaa_shmem_init_early(void)
+{
+	u64 sz = (u64)PAGE_SIZE << (2 * CONFIG_FSL_USDPAA_SHMEM_LOG4);
+	u64 addr = (lmb_end_of_DRAM() - sz) & ~(sz - 1);
+	/* FIXME: if booting with 8GB of RAM, the upper memory region seems to
+	 * be unavailable because of some conflict with the ramdisk. Ensure that
+	 * we don't search above 6GB. */
+	if (addr >= 0x180000000ULL)
+		addr = (0x180000000ULL - sz) & ~(sz - 1);
+	/* Search downwards, looking for an appropriately-aligned region that
+	 * isn't already reserved. */
+	do {
+		if (lmb_is_region_reserved(addr, sz) == -1)
+			goto found;
+		addr -= sz;
+		/* If we reach the lower 1GB, call off the search. */
+	} while (addr >= 0x40000000);
+	pr_err("Failed to reserve USDPAA region (sz:%llx)\n", sz);
+	return;
+found:
+	lmb_reserve(addr, sz);
+	usdpaa_phys_start = addr;
+	usdpaa_phys_size = sz;
+	usdpaa_pfn_start = (addr >> PAGE_SHIFT);
+	usdpaa_pfn_len = (sz >> PAGE_SHIFT);
+	usdpaa_tlbcam_index = tlbcam_index++;
+	pr_info("USDPAA region at %llx:%llx\n",
+		usdpaa_phys_start, usdpaa_phys_size);
+}
+
+static int __init usdpaa_shmem_init(void)
+{
+	int ret;
+
+	pr_info("Freescale USDPAA shared memory driver\n");
+
+	if (!usdpaa_phys_size) {
+		pr_warning("fsl-usdpaa-shmem: no region found\n");
+		return 0;
+	}
+	ret = misc_register(&usdpaa_shmem_miscdev);
+	if (ret)
+		pr_err("fsl-usdpaa-shmem: failed to register misc device\n");
+	return ret;
+}
+
+static void __exit usdpaa_shmem_exit(void)
+{
+	misc_deregister(&usdpaa_shmem_miscdev);
+}
+
+module_init(usdpaa_shmem_init);
+module_exit(usdpaa_shmem_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_DESCRIPTION("Freescale USDPAA shared memory driver");
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
new file mode 100644
index 0000000..65f73fc
--- /dev/null
+++ b/include/linux/fsl_usdpaa.h
@@ -0,0 +1,53 @@
+/* Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef FSL_USDPAA_H
+#define FSL_USDPAA_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <linux/uaccess.h>
+
+#ifdef CONFIG_FSL_USDPAA_SHMEM
+
+/* Character-device interface. NB: these definitions need to be duplicated in
+ * user-space. It is all temporary until being replaced by HugeTLB. */
+#define USDPAA_IOCTL_MAGIC 'u'
+struct usdpaa_ioctl_get_region {
+	uint64_t phys_start;
+	uint64_t phys_len;
+};
+#define USDPAA_IOCTL_GET_PHYS_BASE \
+	_IOR(USDPAA_IOCTL_MAGIC, 0x01, struct usdpaa_ioctl_get_region)
+
+#ifdef __KERNEL__
+
+/* Physical address range */
+extern u64 usdpaa_phys_start;
+extern u64 usdpaa_phys_size;
+
+/* PFN versions */
+extern unsigned long usdpaa_pfn_start;
+extern unsigned long usdpaa_pfn_len;
+
+/* TLB1 index */
+extern unsigned int usdpaa_tlbcam_index;
+
+/* Early-boot hook */
+void __init fsl_usdpaa_shmem_init_early(void);
+
+#endif /* __KERNEL__ */
+
+#endif /* CONFIG_FSL_USDPAA_SHMEM */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FSL_USDPAA_H */
-- 
1.7.0.4

