From 62c28a1c021ce18b192677e0e88a4c99b9ac3d6d Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 20 Dec 2010 11:21:27 +0800
Subject: [PATCH 16/28] PME: certain locks must be IRQ-safe

Fix a lockdep error incured by enabling CONFIG_PROVE_LOCKING

In hard-irq context, spin_lock/unlock_irq can't be used, must
use spin_lock_irqsave/spin_unlock_irqrestore to keep lock state
consistent.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/match/pme2_high.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/drivers/match/pme2_high.c b/drivers/match/pme2_high.c
index ad25350..238276c 100644
--- a/drivers/match/pme2_high.c
+++ b/drivers/match/pme2_high.c
@@ -502,7 +502,9 @@ static inline void release_exclusive(__maybe_unused struct pme_ctx *ctx)
 static int __try_exclusive(struct pme_ctx *ctx)
 {
 	int ret = 0;
-	spin_lock(&ctx->lock);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ctx->lock, flags);
 	if (exclusive_refs) {
 		/* exclusivity already held, continue if we're the owner */
 		if (exclusive_ctx != ctx)
@@ -515,7 +517,7 @@ static int __try_exclusive(struct pme_ctx *ctx)
 	}
 	if (!ret)
 		exclusive_refs++;
-	spin_unlock(&ctx->lock);
+	spin_unlock_irqrestore(&ctx->lock, flags);
 	return ret;
 }
 /* Use this macro as the wait expression because we don't want to continue
@@ -779,6 +781,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 {
 	struct pme_ctx_token *token;
 	const struct qm_fd *t_fd;
+	unsigned long flags;
 
 	/* The fast-path case is that the for() loop actually degenerates into;
 	 *     token = list_first_entry();
@@ -787,7 +790,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	 * The penalty of the slow-path case is the for() loop plus the fact
 	 * we're optimising for a "likely" match first time, which might hurt
 	 * when that assumption is wrong a few times in succession. */
-	spin_lock_irq(&ctx->lock);
+	spin_lock_irqsave(&ctx->lock, flags);
 	list_for_each_entry(token, &ctx->tokens, node) {
 		t_fd = (const struct qm_fd *)&token->blob[0];
 		if (likely(MATCH(t_fd, fd))) {
@@ -799,7 +802,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	pr_err("PME2 Could not find matching token!\n");
 	BUG();
 found:
-	spin_unlock_irq(&ctx->lock);
+	spin_unlock_irqrestore(&ctx->lock, flags);
 	return token;
 }
 
-- 
1.6.5.2

