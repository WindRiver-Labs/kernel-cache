From 6c22ac2390710f7e191966a7b7894d827a9ff853 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Wed, 29 Jun 2011 13:54:14 +0800
Subject: [PATCH 201/233] qman: free all the fq before booting the dump kernel

In kdump we can't invoke the device_shutdown function as we do
in kexec. So we just forcibly free all the fq before booting
the dump kernel.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
[rebase it onto QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c |   70 +++++++++++++++++++++++++++++++
 1 files changed, 70 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 197a688..80b1e34 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -634,6 +634,72 @@ int qman_have_ccsr(void)
 	return qm ? 1 : 0;
 }
 
+#ifdef CONFIG_KEXEC
+static void qman_free_all_fq(void)
+{
+	int i, ret;
+	struct device_node *dn;
+	u32 *bpid = NULL, *cfg;
+	u64 count, incr, base;
+
+	for_each_compatible_node(dn, NULL, "fsl,bpool") {
+		bpid = (u32 *)of_get_property(dn, "fsl,bpid", &ret);
+		if (!bpid || (ret != 4)) {
+			pr_err("Can't get %s property 'fsl,bpid'\n",
+				dn->full_name);
+			continue;
+		}
+
+		if (*bpid == 0)
+			break;
+	}
+
+	if (!bpid || *bpid) {
+		pr_err("Can't get the pool for fqid\n");
+		return;
+	}
+
+	cfg = (u32 *)of_get_property(dn, "fsl,bpool-cfg", &ret);
+	if (cfg && (!ret || (ret % 24))) {
+		pr_err("Invalid 'fsl,bpool-cfg' property %s\n", dn->full_name);
+		return;
+	}
+
+	count = ((u64)cfg[0] << 32) | cfg[1];
+	incr  = ((u64)cfg[2] << 32) | cfg[3];
+	base  = ((u64)cfg[4] << 32) | cfg[5];
+
+	for (i = 0; i < count; i++) {
+		struct qman_fq fq;
+
+		memset(&fq, 0, sizeof(fq));
+		ret = qman_create_fq((u32)base, QMAN_FQ_FLAG_AS_IS, &fq);
+		if (ret)
+			pr_err("Create fq %d error\n", i);
+
+		base += incr;
+
+		if (fq.state != qman_fq_state_parked &&
+			fq.state != qman_fq_state_sched)
+			continue;
+
+		ret = qman_retire_fq(&fq, NULL);
+		if (ret) {
+			pr_err("Retire fq %d error\n", fq.fqid);
+			continue;
+		}
+
+		ret = qman_oos_fq(&fq);
+		if (ret) {
+			pr_err("OOS fq %d error\n", fq.fqid);
+			continue;
+		}
+
+		qman_destroy_fq(&fq, 0);
+	}
+}
+#endif
+
 __init void qman_init_early(void)
 {
 	struct device_node *dn;
@@ -646,6 +712,10 @@ __init void qman_init_early(void)
 			BUG_ON(ret);
 		}
 	}
+
+#ifdef CONFIG_KEXEC
+	crash_shutdown_register(&qman_free_all_fq);
+#endif
 }
 
 static void log_edata_bits(u32 bit_count)
-- 
1.7.0.4

