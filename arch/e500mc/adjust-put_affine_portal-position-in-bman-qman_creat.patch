From 1dc1441d06d1990c0a26d851f0f5bd5d20ca57cf Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 17 Jan 2011 18:34:50 +0800
Subject: [PATCH 18/28] adjust put_affine_portal() position in bman/qman_create_affine_portal

When CONFIG_PROVE_LOCKING is enabled, the call trace will appear
when hardirq is threaded:

BUG: scheduling while atomic: bman_affine0/0x00000001/150, CPU#0
no locks held by bman_affine0/150.
Modules linked in:
irq event stamp: 28
hardirqs last  enabled at (27): [<c05bab50>] _raw_spin_unlock_irqrestore+0x70/0x94
hardirqs last disabled at (28): [<c05b78b0>] schedule+0x30/0x60
softirqs last  enabled at (0): [<c004cc8c>] copy_process+0x3a4/0xed8
softirqs last disabled at (0): [<(null)>] (null)
Call Trace:
[eb411c50] [c0008694] show_stack+0x68/0x1d8 (unreliable)
[eb411ca0] [c05baff4] dump_stack+0x2c/0x44
[eb411cb0] [c0041be0] __schedule_bug+0xac/0xc4
[eb411cd0] [c05b7518] __schedule+0x3a4/0x5c8
[eb411d30] [c05b78b4] schedule+0x34/0x60
[eb411d40] [c05b7e24] schedule_timeout+0x1e0/0x2fc
[eb411da0] [c05b6ee8] wait_for_common+0xd0/0x1c4
[eb411de0] [c05b715c] wait_for_completion+0x30/0x48
[eb411df0] [c0075124] kthread_create+0xa4/0x124
[eb411eb0] [c00bd550] __setup_irq+0x21c/0x424
[eb411ee0] [c00bd86c] request_threaded_irq+0x114/0x230
[eb411f20] [c04c7218] bman_create_affine_portal+0x2f0/0x58c
[eb411f50] [c04c4b10] __init_affine_portal+0x44/0x6c
[eb411f70] [c0074e54] kthread+0x88/0x8c
[eb411ff0] [c00130bc] original_kernel_thread+0x4c/0x68

bman/qman_create_affine_portal are kernel initial functions which
can be called without preempt disabled, so it is safe to call
put_affine_portal() in early period.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/hwalloc/bman_high.c |    8 ++++++--
 drivers/hwqueue/qman_high.c |    1 -
 2 files changed, 6 insertions(+), 3 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index 95b138e..61a31ec 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -175,6 +175,12 @@ int bman_create_affine_portal(const struct bm_portal_config *config,
 	const struct bman_depletion *pools = &config->mask;
 	int ret;
 
+	/* A criteria for calling this function is that we're already affine
+	 * to the cpu and won't schedule onto another cpu. This means we can
+	 * put_affine_portal() and yet continue to use "portal", which in turn
+	 * means aspects of this routine can sleep. */
+	put_affine_portal();
+
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
 	 * for (de)reference... */
@@ -257,7 +263,6 @@ int bman_create_affine_portal(const struct bm_portal_config *config,
 	cpumask_set_cpu(config->cpu, &affine_mask);
 	spin_unlock(&affine_mask_lock);
 	bm_isr_disable_write(__p, 0);
-	put_affine_portal();
 	return 0;
 fail_rcr_empty:
 #ifdef CONFIG_FSL_BMAN_HAVE_IRQ
@@ -274,7 +279,6 @@ fail_isr:
 fail_mc:
 	bm_rcr_finish(__p);
 fail_rcr:
-	put_affine_portal();
 	return -EINVAL;
 }
 
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index e1ce822..68ee41b 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -462,7 +462,6 @@ fail_mr:
 fail_dqrr:
 	qm_eqcr_finish(__p);
 fail_eqcr:
-	put_affine_portal();
 	return -EINVAL;
 }
 
-- 
1.6.5.2

