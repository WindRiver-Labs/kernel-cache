From 5608a03410d13130cc414cf6d725a65eb232f3e6 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 25 Jan 2011 19:25:26 +0800
Subject: [PATCH 20/28] qman: clean SDQCR when do kexec fast reboot

If kernel option maxcpus is set when we do kexec fast reboot,
kernel will hang due to uncertain status of SDQCR on the offlined
CPU bman portal, so clean it in qman shutdown function.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/hwqueue/qman_config.c |   16 ++++++++++++++++
 drivers/hwqueue/qman_high.c   |   19 +++++++++++++++++++
 include/linux/fsl_qman.h      |   17 +++++++++++++++++
 3 files changed, 52 insertions(+), 0 deletions(-)

diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index a0ac830..c3baa03 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -976,6 +976,19 @@ static const struct attribute_group qman_dev_ecr_grp = {
 	.attrs = qman_dev_ecr_attributes
 };
 
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
+static int of_fsl_qman_shutdown(struct of_device *ofdev)
+{
+	int cpu;
+	struct qman_portal *p;
+	for_each_online_cpu(cpu) {
+		p = per_cpu_affine_portal(cpu);
+		qman_static_dequeue_del_ex(p, ~0);
+	}
+	return 0;
+};
+#endif
+
 static int of_fsl_qman_remove(struct of_device *ofdev)
 {
 	sysfs_remove_group(&ofdev->dev.kobj, &qman_dev_attr_grp);
@@ -1024,6 +1037,9 @@ static struct of_platform_driver of_fsl_qman_driver = {
 	.name = DRV_NAME,
 	.match_table = of_fsl_qman_ids,
 	.probe = of_fsl_qman_probe,
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
+	.shutdown = of_fsl_qman_shutdown,
+#endif
 	.remove      = __devexit_p(of_fsl_qman_remove),
 };
 
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 27f6f3d..9046ed2 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -128,6 +128,12 @@ struct qman_portal {
 static cpumask_t affine_mask = CPU_MASK_NONE;
 static DEFINE_SPINLOCK(affine_mask_lock);
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
+struct qman_portal *per_cpu_affine_portal(int cpu)
+{
+	return &per_cpu(qman_affine_portal, cpu);
+}
+EXPORT_SYMBOL(per_cpu_affine_portal);
+
 static inline struct qman_portal *get_affine_portal(void)
 {
 	return &get_cpu_var(qman_affine_portal);
@@ -909,6 +915,19 @@ void qman_static_dequeue_del(u32 pools)
 }
 EXPORT_SYMBOL(qman_static_dequeue_del);
 
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools)
+{
+	__maybe_unused unsigned long irqflags;
+	if (p->config != NULL) {
+		local_irq_save(irqflags);
+		pools &= p->config->pools;
+		p->sdqcr &= ~pools;
+		qm_dqrr_sdqcr_set(&p->p, p->sdqcr);
+		local_irq_restore(irqflags);
+	}
+}
+EXPORT_SYMBOL(qman_static_dequeue_del_ex);
+
 u32 qman_static_dequeue_get(void)
 {
 	struct qman_portal *p = get_affine_portal();
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index d19abf3..5dfcc59 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1270,6 +1270,23 @@ void qman_static_dequeue_add(u32 pools);
 void qman_static_dequeue_del(u32 pools);
 
 /**
+ * qman_static_dequeue_del_ex - Remove pool channels from specific portal SDQCR
+ * @p: qman_portal pointer that we will operate on
+ * @pools: bit-mask of pool channels, using QM_SDQCR_CHANNELS_POOL(n)
+ *
+ * Removes a set of pool channels from specific portal's static dequeue command
+ * register (SDQCR). The requested pools are limited to those the portal has
+ * dequeue access to.
+ */
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools);
+
+/**
+ * per_cpu_affine_portal - Get affine portal of specific cpu
+ * @cpu: the specific cpu from which we get affine portal
+ */
+struct qman_portal *per_cpu_affine_portal(int cpu);
+
+/**
  * qman_static_dequeue_get - return the portal's current SDQCR
  *
  * Returns the portal's current static dequeue command register (SDQCR). The
-- 
1.6.5.2

