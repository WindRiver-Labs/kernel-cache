From 398a4087cea57f49de974f76ad6aec7244dfe74a Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 30 Jun 2011 11:31:48 +0800
Subject: [PATCH 217/233] qman: clean SDQCR when do kexec fast reboot

If kernel option maxcpus is set when we do kexec fast reboot,
kernel will hang due to uncertain status of SDQCR on the offlined
CPU bman portal, so clean it in qman shutdown function.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c |   16 ++++++++++++++++
 drivers/staging/fsl_qbman/qman_high.c   |   20 ++++++++++++++++++++
 include/linux/fsl_qman.h                |   17 +++++++++++++++++
 3 files changed, 53 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index cf93cec..2d50e27 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -1034,6 +1034,19 @@ static const struct attribute_group qman_dev_ecr_grp = {
 	.attrs = qman_dev_ecr_attributes
 };
 
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
+static int of_fsl_qman_shutdown(struct of_device *ofdev)
+{
+	int cpu;
+	struct qman_portal *p;
+	for_each_online_cpu(cpu) {
+		p = per_cpu_affine_portal(cpu);
+		qman_static_dequeue_del_ex(p, ~0);
+	}
+	return 0;
+};
+#endif
+
 static int of_fsl_qman_remove(struct of_device *ofdev)
 {
 	sysfs_remove_group(&ofdev->dev.kobj, &qman_dev_attr_grp);
@@ -1082,6 +1095,9 @@ static struct of_platform_driver of_fsl_qman_driver = {
 	.name = DRV_NAME,
 	.match_table = of_fsl_qman_ids,
 	.probe = of_fsl_qman_probe,
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
+	.shutdown = of_fsl_qman_shutdown,
+#endif
 	.remove      = __devexit_p(of_fsl_qman_remove),
 };
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 254d8f6..8f2cbc9 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -152,6 +152,13 @@ struct qman_portal {
 static cpumask_t affine_mask;
 static DEFINE_SPINLOCK(affine_mask_lock);
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
+
+struct qman_portal *per_cpu_affine_portal(int cpu)
+{
+	return &per_cpu(qman_affine_portal, cpu);
+}
+EXPORT_SYMBOL(per_cpu_affine_portal);
+
 /* "raw" gets the cpu-local struct whether it's a redirect or not. */
 static inline struct qman_portal *get_raw_affine_portal(void)
 {
@@ -1374,6 +1381,19 @@ void qman_static_dequeue_del(u32 pools)
 }
 EXPORT_SYMBOL(qman_static_dequeue_del);
 
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools)
+{
+	__maybe_unused unsigned long irqflags;
+	if (p->config != NULL) {
+		local_irq_save(irqflags);
+		pools &= p->config->pools;
+		p->sdqcr &= ~pools;
+		qm_dqrr_sdqcr_set(&p->p, p->sdqcr);
+		local_irq_restore(irqflags);
+	}
+}
+EXPORT_SYMBOL(qman_static_dequeue_del_ex);
+
 u32 qman_static_dequeue_get(void)
 {
 	struct qman_portal *p = get_affine_portal();
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index b9b4de2..1e38edb 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1250,6 +1250,23 @@ void qman_static_dequeue_add(u32 pools);
 void qman_static_dequeue_del(u32 pools);
 
 /**
+ * qman_static_dequeue_del_ex - Remove pool channels from specific portal SDQCR
+ * @p: qman_portal pointer that we will operate on
+ * @pools: bit-mask of pool channels, using QM_SDQCR_CHANNELS_POOL(n)
+ *
+ * Removes a set of pool channels from specific portal's static dequeue command
+ * register (SDQCR). The requested pools are limited to those the portal has
+ * dequeue access to.
+ */
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools);
+
+/**
+ * per_cpu_affine_portal - Get affine portal of specific cpu
+ * @cpu: the specific cpu from which we get affine portal
+ */
+struct qman_portal *per_cpu_affine_portal(int cpu);
+
+/**
  * qman_static_dequeue_get - return the portal's current SDQCR
  *
  * Returns the portal's current static dequeue command register (SDQCR). The
-- 
1.7.0.4

