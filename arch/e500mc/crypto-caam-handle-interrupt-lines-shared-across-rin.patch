From c941cad3bb54fd7637e91390f9af79965dc640f8 Mon Sep 17 00:00:00 2001
From: Kim Phillips <kim.phillips@freescale.com>
Date: Tue, 22 Mar 2011 19:58:24 -0500
Subject: [PATCH 093/233] crypto: caam - handle interrupt lines shared across rings

commit 9620fd959fb169358f2ba349c9fd1bcd96944c28 upstream
correspond to vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0006-crypto-caam-handle-interrupt-lines-shared-across-rin.patch

o add IRQF_SHARED to request_irq flags
o resetting a job ring triggers interrupts, so move
  request_irq prior to jr_reset to avoid 'got IRQ but nobody
  cared' messages.
o for now, disable IRQs manually in jr_reset to avoid contention
  between reset status and interrupt status

tested on p1023, p3041, p4080, and 32- and 64-bit p5020.

Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
---
 drivers/crypto/caam/jr.c |   46 ++++++++++++++++++++--------------------------
 1 files changed, 20 insertions(+), 26 deletions(-)

diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 68cb9af..340fa32 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -292,10 +292,10 @@ static int caam_reset_hw_jr(struct device *dev)
 	unsigned int timeout = 100000;
 
 	/*
-	 * FIXME: disabling IRQs here inhibits proper job completion
-	 * and error propagation
+	 * mask interrupts since we are going to poll
+	 * for reset completion status
 	 */
-	disable_irq(jrp->irq);
+	setbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);
 
 	/* initiate flush (required prior to reset) */
 	wr_reg32(&jrp->rregs->jrcommand, JRCR_RESET);
@@ -320,7 +320,8 @@ static int caam_reset_hw_jr(struct device *dev)
 		return -EIO;
 	}
 
-	enable_irq(jrp->irq);
+	/* unmask interrupts */
+	clrbits32(&jrp->rregs->rconfig_lo, JRCFG_IMSK);
 
 	return 0;
 }
@@ -336,6 +337,21 @@ static int caam_jr_init(struct device *dev)
 
 	jrp = dev_get_drvdata(dev);
 
+	/* Connect job ring interrupt handler. */
+	for_each_possible_cpu(i)
+		tasklet_init(&jrp->irqtask[i], caam_jr_dequeue,
+			     (unsigned long)dev);
+
+	error = request_irq(jrp->irq, caam_jr_interrupt, IRQF_SHARED,
+			    "caam-jobr", dev);
+	if (error) {
+		dev_err(dev, "can't connect JobR %d interrupt (%d)\n",
+			jrp->ridx, jrp->irq);
+		irq_dispose_mapping(jrp->irq);
+		jrp->irq = 0;
+		return -EINVAL;
+	}
+
 	error = caam_reset_hw_jr(dev);
 	if (error)
 		return error;
@@ -404,28 +420,6 @@ static int caam_jr_init(struct device *dev)
 		  (JOBR_INTC_COUNT_THLD << JRCFG_ICDCT_SHIFT) |
 		  (JOBR_INTC_TIME_THLD << JRCFG_ICTT_SHIFT));
 
-	/* Connect job ring interrupt handler. */
-	for_each_possible_cpu(i)
-		tasklet_init(&jrp->irqtask[i], caam_jr_dequeue,
-			     (unsigned long)dev);
-
-	error = request_irq(jrp->irq, caam_jr_interrupt, 0,
-			    "caam-jobr", dev);
-	if (error) {
-		dev_err(dev, "can't connect JobR %d interrupt (%d)\n",
-			jrp->ridx, jrp->irq);
-		irq_dispose_mapping(jrp->irq);
-		jrp->irq = 0;
-		dma_unmap_single(dev, inpbusaddr, sizeof(u32 *) * JOBR_DEPTH,
-				 DMA_BIDIRECTIONAL);
-		dma_unmap_single(dev, outbusaddr, sizeof(u32 *) * JOBR_DEPTH,
-				 DMA_BIDIRECTIONAL);
-		kfree(jrp->inpring);
-		kfree(jrp->outring);
-		kfree(jrp->entinfo);
-		return -EINVAL;
-	}
-
 	jrp->assign = JOBR_UNASSIGNED;
 	return 0;
 }
-- 
1.7.0.4

