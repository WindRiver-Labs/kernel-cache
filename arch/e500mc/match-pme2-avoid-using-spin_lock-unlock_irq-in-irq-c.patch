From fa70974e63e36cefd71b1127a764f3e37f34bbb2 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 30 Jun 2011 10:08:59 +0800
Subject: [PATCH 228/233] match/pme2: avoid using spin_lock/unlock_irq in irq context

The spin_lock/unlock_irq can't be used in hard irq context.
Otherwise it will cause the following warning when CONFIG_PROVE_LOCKING
is enabled. So replace them with spin_lock_irqsave/spin_unlock_irqrestore
if the function is used in both irq and nonirq context or
spin_lock/spin_unlock if it is only used in hard irq context.

Badness at kernel/lockdep.c:2333
NIP: c006c24c LR: c006c234 CTR: c00693c0
REGS: ebcbbc20 TRAP: 0700   Not tainted  (2.6.34.6-WR4.0.0.0_standard)
MSR: 00021002 <ME,CE>  CR: 22002082  XER: 20000000
TASK = ebca1da0[0] 'swapper' THREAD: ebcba000 CPU: 2
GPR00: 00000000 ebcbbcd0 ebca1da0 00000001 00000001 c044921c 08980000 00000000
GPR08: 089c2800 c0730000 00000001 c0730000 22002088 00000000 0801080b 06130008
GPR16: 0169914e c060d3d4 c071b670 c071b690 ebcba040 00000004 ebcba000 c0711ccc
GPR24: 00000000 00028000 40000000 f10b1010 ebca9e34 ebca9d5c c0519464 ebca1da0
NIP [c006c24c] trace_hardirqs_on_caller+0x130/0x1cc
LR [c006c234] trace_hardirqs_on_caller+0x118/0x1cc
Call Trace:
[ebcbbcd0] [00028000] 0x28000 (unreliable)
[ebcbbcf0] [c0519464] _raw_spin_unlock_irq+0x30/0x68
[ebcbbd00] [c044921c] cb_dqrr+0xd0/0x55c
[ebcbbde0] [c0442b20] portal_isr+0x6c/0x72c
[ebcbbe20] [c00a0094] handle_IRQ_event+0xa0/0x2f8
[ebcbbe70] [c00a2fd8] handle_fasteoi_irq+0x8c/0x138
[ebcbbe90] [c0004c04] native_do_IRQ+0xd4/0xfc
[ebcbbeb0] [c00037fc] do_IRQ+0x10/0x20
[ebcbbec0] [c0010e98] ret_from_except+0x0/0x18
[ebcbbf80] [c00083ec] cpu_idle_simple+0x34/0xb4
[ebcbbfa0] [c0008498] cpu_idle+0x2c/0x174
[ebcbbfc0] [c051ead0] start_secondary+0x2f4/0x30c
[ebcbbff0] [c000198c] __secondary_start+0x30/0x84
Instruction dump:
70098000 408200a4 80020488 2f800000 419eff68 4822e601 2f830000 41beff90
3d20c073 800993b8 2f800000 40beff80 <0fe00000> 4bffff78 7fe3fb78 38800001

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
[rebase it onto QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/staging/fsl_pme2/pme2_high.c |   16 ++++++++++------
 1 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_pme2/pme2_high.c b/drivers/staging/fsl_pme2/pme2_high.c
index d755473..8a38a93 100644
--- a/drivers/staging/fsl_pme2/pme2_high.c
+++ b/drivers/staging/fsl_pme2/pme2_high.c
@@ -90,14 +90,16 @@ static inline int do_flags(struct pme_ctx *ctx,
 			u32 to_set, u32 to_unset)
 {
 	int err = -EBUSY;
-	spin_lock_irq(&ctx->lock);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ctx->lock, flags);
 	if (((ctx->flags & must_be_set) == must_be_set) &&
 			!(ctx->flags & must_not_be_set)) {
 		ctx->flags |= to_set;
 		ctx->flags &= ~to_unset;
 		err = 0;
 	}
-	spin_unlock_irq(&ctx->lock);
+	spin_unlock_irqrestore(&ctx->lock, flags);
 	return err;
 }
 
@@ -483,15 +485,17 @@ EXPORT_SYMBOL(pme_ctx_reconfigure_rx);
  * is EXCLUSIVE. */
 static inline void release_exclusive(__maybe_unused struct pme_ctx *ctx)
 {
+	unsigned long flags;
+
 	BUG_ON(exclusive_ctx != ctx);
 	BUG_ON(!exclusive_refs);
-	spin_lock_irq(&exclusive_lock);
+	spin_lock_irqsave(&exclusive_lock, flags);
 	if (!(--exclusive_refs)) {
 		exclusive_ctx = NULL;
 		pme2_exclusive_unset();
 		wake_up(&exclusive_queue);
 	}
-	spin_unlock_irq(&exclusive_lock);
+	spin_unlock_irqrestore(&exclusive_lock, flags);
 }
 static int __try_exclusive(struct pme_ctx *ctx)
 {
@@ -781,7 +785,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	 * The penalty of the slow-path case is the for() loop plus the fact
 	 * we're optimising for a "likely" match first time, which might hurt
 	 * when that assumption is wrong a few times in succession. */
-	spin_lock_irq(&ctx->lock);
+	spin_lock(&ctx->lock);
 	list_for_each_entry(token, &ctx->tokens, node) {
 		t_fd = (const struct qm_fd *)&token->blob[0];
 		if (likely(MATCH(t_fd, fd))) {
@@ -793,7 +797,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	pr_err("PME2 Could not find matching token!\n");
 	BUG();
 found:
-	spin_unlock_irq(&ctx->lock);
+	spin_unlock(&ctx->lock);
 	return token;
 }
 
-- 
1.7.0.4

