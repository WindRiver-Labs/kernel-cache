From 540bbb2ecc904ee05b4bfdbc7e4dc69d4b98d949 Mon Sep 17 00:00:00 2001
From: Kumar Gala <galak@kernel.crashing.org>
Date: Thu, 26 Aug 2010 02:55:29 -0500
Subject: [PATCH 056/233] fsl_rio: Error interrupt handler for sRIO.

commit 6ff31453161e8614e8ba3b360f8d883a27230e0c upstream
correspond to vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0080-fsl_rio-Error-interrupt-handler-for-sRIO.patch

The sRIO controller reports errors to the core with one signal, it uses
register EPWISR to provides the core quick access to where the error occurred.
The EPWISR indicates that there are 4 interrupts sources, port1, port2, message
unit and port write receive, but the sRIO driver does not support port2 and
port write receive for now, while the handler handle the 4 sources.
Currently the handler only clear error status without any recovery.

Signed-off-by: Shaohui Xie <b21989@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
---
 arch/powerpc/sysdev/fsl_rio.c |  132 ++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 129 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_rio.c b/arch/powerpc/sysdev/fsl_rio.c
index f0b4245..caa5065 100644
--- a/arch/powerpc/sysdev/fsl_rio.c
+++ b/arch/powerpc/sysdev/fsl_rio.c
@@ -1,7 +1,7 @@
 /*
  * Freescale MPC85xx/MPC86xx RapidIO support
  *
- * Copyright (C) 2007, 2008,2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007, 2008, 2010 Freescale Semiconductor, Inc.
  * Zhang Wei <wei.zhang@freescale.com>
  *
  * Copyright 2005 MontaVista Software, Inc.
@@ -30,14 +30,41 @@
 #include <asm/uaccess.h>
 
 /* RapidIO definition irq, which read from OF-tree */
+#define IRQ_RIO_ERR(m)		(((struct rio_priv *)(m->priv))->errirq)
 #define IRQ_RIO_BELL(m)		(((struct rio_priv *)(m->priv))->bellirq)
 #define IRQ_RIO_TX(m)		(((struct rio_priv *)(m->priv))->txirq)
 #define IRQ_RIO_RX(m)		(((struct rio_priv *)(m->priv))->rxirq)
 
+/* EPWISR Error match value */
+#define EPWISR_ERR_PINT1	0x80000000
+#define EPWISR_ERR_PINT2	0x40000000
+#define EPWISR_ERR_MU		0x2
+#define EPWISR_ERR_PW		0x1
+
+#define IPWMR_CLEAR_QUEUE      0x00000002
+#define IPWSR_CLEAR		0x98
+#define OMSR_CLEAR		0x1cb3
+#define IMSR_CLEAR		0x491
+#define IDSR_CLEAR		0x91
+#define ODSR_CLEAR		0x1c00
+#define LTLEECSR_ENABLE_ALL	0xFFC000FC
+#define ESCSR_CLEAR		0x07120204
+
+#define RIO_EDCSR		0x0640
+#define PORT2_RIO_EDCSR	0x0680
+#define RIO_IECSR		0x10130
+#define PORT2_RIO_IECSR	0x101B0
+#define RIO_IM0SR		0x13064
+#define RIO_IM1SR		0x13164
+#define RIO_OM0SR		0x13004
+#define RIO_OM1SR		0x13104
+
+#define RIO_EPWISR_OFFSET	0x10010
 #define RIO_ATMU_REGS_OFFSET	0x10c00
 #define RIO_P_MSG_REGS_OFFSET	0x11000
 #define RIO_S_MSG_REGS_OFFSET	0x13000
 #define RIO_ESCSR		0x158
+#define PORT2_RIO_ESCSR	0x178
 #define RIO_CCSR		0x15c
 #define RIO_LTLEDCSR		0x0608
 #define RIO_LTLEDCSR_IER	0x80000000
@@ -193,6 +220,7 @@ struct rio_priv {
 	struct rio_dbell_ring dbell_ring;
 	struct rio_msg_tx_ring msg_tx_ring;
 	struct rio_msg_rx_ring msg_rx_ring;
+	int errirq;
 	int bellirq;
 	int txirq;
 	int rxirq;
@@ -945,6 +973,92 @@ fsl_rio_dbell_handler(int irq, void *dev_instance)
 	return IRQ_HANDLED;
 }
 
+void port_error_handler(struct rio_mport *port, int offset)
+{
+	/*XXX: Error recovery is not implemented, we just clear errors */
+	out_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR), 0);
+
+	if (offset == 0) {
+		out_be32((u32 *)(rio_regs_win + RIO_EDCSR), 0);
+		out_be32((u32 *)(rio_regs_win + RIO_IECSR), 0);
+		out_be32((u32 *)(rio_regs_win + RIO_ESCSR), ESCSR_CLEAR);
+	} else {
+		out_be32((u32 *)(rio_regs_win + PORT2_RIO_EDCSR), 0);
+		out_be32((u32 *)(rio_regs_win + PORT2_RIO_IECSR), 0);
+		out_be32((u32 *)(rio_regs_win + PORT2_RIO_ESCSR), ESCSR_CLEAR);
+	}
+}
+
+void msg_unit_error_handler(struct rio_mport *port)
+{
+	struct rio_priv *priv = port->priv;
+
+	/*XXX: Error recovery is not implemented, we just clear errors */
+	out_be32((u32 *)(rio_regs_win + RIO_IM0SR), IMSR_CLEAR);
+	out_be32((u32 *)(rio_regs_win + RIO_IM1SR), IMSR_CLEAR);
+	out_be32((u32 *)(rio_regs_win + RIO_OM0SR), OMSR_CLEAR);
+	out_be32((u32 *)(rio_regs_win + RIO_OM1SR), OMSR_CLEAR);
+
+	out_be32(&priv->msg_regs->odsr, ODSR_CLEAR);
+	out_be32(&priv->msg_regs->dsr, IDSR_CLEAR);
+
+	out_be32(&priv->msg_regs->pwsr, IPWSR_CLEAR);
+}
+
+void inbound_port_write_rx(struct rio_mport *port)
+{
+	struct rio_priv *priv = port->priv;
+	int mode;
+
+	/*XXX: Error recovery is not implemented, we just clear errors */
+	/* Clearing the queue */
+	mode = in_be32(&priv->msg_regs->pwmr);
+	out_be32(&priv->msg_regs->pwmr, mode | IPWMR_CLEAR_QUEUE);
+
+	/* Clearing status register */
+	out_be32(&priv->msg_regs->pwsr, IPWSR_CLEAR);
+}
+
+/**
+ * fsl_rio_error_handler - MPC85xx error interrupt handler
+ * @irq: ERROR interrupt number
+ * @dev_instance: Pointer to interrupt-specific data
+ *
+ * Handles error interrupts. Parses a list of registered
+ * error event handlers and executes a matching event handler.
+ */
+static irqreturn_t
+fsl_rio_error_handler(int irq, void *dev_instance)
+{
+	int status;
+	struct rio_mport *port = (struct rio_mport *)dev_instance;
+
+	/* Read Error/Port-Write Interrupt Status Register(EPWISR) */
+	status = in_be32((u32 *)(rio_regs_win + RIO_EPWISR_OFFSET));
+
+	if (status & EPWISR_ERR_PINT1) {
+		pr_info("RIO: port1 error\n");
+		port_error_handler(port, 0);
+	}
+
+	if (status & EPWISR_ERR_PINT2) {
+		pr_info("RIO: port2 error\n");
+		port_error_handler(port, 1);
+	}
+
+	if (status & EPWISR_ERR_MU) {
+		pr_info("RIO: message unit error\n");
+		msg_unit_error_handler(port);
+	}
+
+	if (status & EPWISR_ERR_PW) {
+		pr_info("RIO: Inbound port-write received\n");
+		inbound_port_write_rx(port);
+	}
+
+	return IRQ_HANDLED;
+}
+
 /**
  * fsl_rio_doorbell_init - MPC85xx doorbell interface init
  * @mport: Master port implementing the inbound doorbell unit
@@ -997,6 +1111,17 @@ static int fsl_rio_doorbell_init(struct rio_mport *mport)
 		goto out;
 	}
 
+	/* Hook up error handler */
+	rc = request_irq(IRQ_RIO_ERR(mport), fsl_rio_error_handler, IRQF_SHARED,
+			 "error_rx", (void *)mport);
+	if (rc < 0) {
+		printk(KERN_ERR
+		       "MPC85xx RIO: unable to request error irq");
+		goto out;
+	}
+	/* Enable Error Interrupt */
+	out_be32((u32 *)(rio_regs_win + RIO_LTLEECSR), LTLEECSR_ENABLE_ALL);
+
 	/* Configure doorbells for snooping, 512 entries, and enable */
 	out_be32(&priv->msg_regs->dmr, 0x00108161);
 
@@ -1163,11 +1288,12 @@ int fsl_rio_setup(struct of_device *dev)
 	port->iores.flags = IORESOURCE_MEM;
 	port->iores.name = "rio_io_win";
 
+	priv->errirq = irq_of_parse_and_map(dev->node, 0);
 	priv->bellirq = irq_of_parse_and_map(dev->node, 2);
 	priv->txirq = irq_of_parse_and_map(dev->node, 3);
 	priv->rxirq = irq_of_parse_and_map(dev->node, 4);
-	dev_info(&dev->dev, "bellirq: %d, txirq: %d, rxirq %d\n", priv->bellirq,
-				priv->txirq, priv->rxirq);
+	dev_info(&dev->dev, "errirq: %d, bellirq: %d, txirq: %d, rxirq %d\n",
+			priv->errirq, priv->bellirq, priv->txirq, priv->rxirq);
 
 	rio_init_dbell_res(&port->riores[RIO_DOORBELL_RESOURCE], 0, 0xffff);
 	rio_init_mbox_res(&port->riores[RIO_INB_MBOX_RESOURCE], 0, 0);
-- 
1.7.0.4

