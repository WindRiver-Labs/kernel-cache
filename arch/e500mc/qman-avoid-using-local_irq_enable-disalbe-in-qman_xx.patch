From ea2337fabfd5ba5829bed5d4e6f08a616a87de76 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 20 Dec 2010 10:05:19 +0800
Subject: [PATCH 02/28] qman: avoid using local_irq_enable/disalbe in qman_xxx_fq functions

These functions are invoked in hard irq context by pme driver, and
will cause the following warning for the using of
local_irq_enable/disable when CONFIG_PROVE_LOCKING is enabled.
So replace the local_irq_enable/disable with local_irq_save/restore
to fix this issue.

Badness at kernel/lockdep.c:2333
NIP: c006c24c LR: c006c234 CTR: c04466c8
REGS: ebcbbb90 TRAP: 0700   Not tainted  (2.6.34.6-WR4.0.0.0_standard)
MSR: 00021002 <ME,CE>  CR: 22002022  XER: 20000000
TASK = ebca1da0[0] 'swapper' THREAD: ebcba000 CPU: 2
GPR00: 00000000 ebcbbc40 ebca1da0 00000001 eb6e60c0 ebcbbc68 08980000 00000000
GPR08: 089c2800 c0730000 00000001 c0730000 22002084 00000000 0001081b 06130008
GPR16: 0169910e c060f544 c071e730 c071e750 ebcba040 00000004 ebcba000 c0714ccc
GPR24: 00000000 000000f0 eb6e6100 ebcbbcd8 f10b3940 ebd2a780 c0441ba8 ebca1da0
NIP [c006c24c] trace_hardirqs_on_caller+0x130/0x1cc
LR [c006c234] trace_hardirqs_on_caller+0x118/0x1cc
Call Trace:
[ebcbbc40] [c060f544] gss_kerberos_ops+0xaaac0/0x111d5c (unreliable)
[ebcbbc60] [c0441ba8] qman_retire_fq+0x254/0x3c0
[ebcbbcd0] [c04482ac] park+0x20/0x84
[ebcbbd00] [c0449ce8] cb_dqrr+0x564/0x570
[ebcbbde0] [c0442b20] portal_isr+0x6c/0x72c
[ebcbbe20] [c00a0094] handle_IRQ_event+0xa0/0x2f8
[ebcbbe70] [c00a2fd8] handle_fasteoi_irq+0x8c/0x138
[ebcbbe90] [c0004c04] native_do_IRQ+0xd4/0xfc
[ebcbbeb0] [c00037fc] do_IRQ+0x10/0x20
[ebcbbec0] [c0010e98] ret_from_except+0x0/0x18
[ebcbbf80] [c00083ec] cpu_idle_simple+0x34/0xb4
[ebcbbfa0] [c0008498] cpu_idle+0x2c/0x174
[ebcbbfc0] [c0520a70] start_secondary+0x2f4/0x30c
[ebcbbff0] [c000198c] __secondary_start+0x30/0x84
Instruction dump:
70098000 408200a4 80020488 2f800000 419eff68 4822e601 2f830000 41beff90
3d20c073 8009d3b8 2f800000 40beff80 <0fe00000> 4bffff78 7fe3fb78 38800001

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwqueue/qman_high.c |   24 ++++++++++++++----------
 1 files changed, 14 insertions(+), 10 deletions(-)

diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 1b55b24..cc95f69 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -885,6 +885,7 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	struct qman_portal *p;
 	u8 res, myverb = (flags & QMAN_INITFQ_FLAG_SCHED) ?
 		QM_MCC_VERB_INITFQ_SCHED : QM_MCC_VERB_INITFQ_PARKED;
+	unsigned long f;
 
 	QM_ASSERT((fq->state == qman_fq_state_oos) ||
 		(fq->state == qman_fq_state_parked));
@@ -894,13 +895,13 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 #endif
 	/* Issue an INITFQ_[PARKED|SCHED] management command */
 	p = get_affine_portal();
-	local_irq_disable();
+	local_irq_save(f);
 	FQLOCK(fq);
 	if (unlikely((fq_isset(fq, QMAN_FQ_STATE_CHANGING)) ||
 			((fq->state != qman_fq_state_oos) &&
 				(fq->state != qman_fq_state_parked)))) {
 		FQUNLOCK(fq);
-		local_irq_enable();
+		local_irq_restore(f);
 		put_affine_portal();
 		return -EBUSY;
 	}
@@ -947,7 +948,7 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	if (res != QM_MCR_RESULT_OK) {
 		pr_err("INITFQ failed: %s\n", mcr_result_str(res));
 		FQUNLOCK(fq);
-		local_irq_enable();
+		local_irq_restore(f);
 		put_affine_portal();
 		return -EIO;
 	}
@@ -964,7 +965,7 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	fq->state = (flags & QMAN_INITFQ_FLAG_SCHED) ?
 			qman_fq_state_sched : qman_fq_state_parked;
 	FQUNLOCK(fq);
-	local_irq_enable();
+	local_irq_restore(f);
 	put_affine_portal();
 	return 0;
 }
@@ -1020,6 +1021,7 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags)
 	struct qman_portal *p;
 	int rval;
 	u8 res;
+	unsigned long f;
 
 	QM_ASSERT((fq->state == qman_fq_state_parked) ||
 		(fq->state == qman_fq_state_sched));
@@ -1028,7 +1030,7 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags)
 		return -EINVAL;
 #endif
 	p = get_affine_portal();
-	local_irq_disable();
+	local_irq_save(f);
 	FQLOCK(fq);
 	if (unlikely((fq_isset(fq, QMAN_FQ_STATE_CHANGING)) ||
 			(fq->state == qman_fq_state_retired) ||
@@ -1090,7 +1092,7 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags)
 	}
 out:
 	FQUNLOCK(fq);
-	local_irq_enable();
+	local_irq_restore(f);
 	put_affine_portal();
 	return rval;
 }
@@ -1103,6 +1105,7 @@ int qman_oos_fq(struct qman_fq *fq)
 	struct qman_portal *p;
 	int ret = 0;
 	u8 res;
+	unsigned long flags;
 
 	QM_ASSERT(fq->state == qman_fq_state_retired);
 #ifdef CONFIG_FSL_QMAN_CHECKING
@@ -1110,7 +1113,7 @@ int qman_oos_fq(struct qman_fq *fq)
 		return -EINVAL;
 #endif
 	p = get_affine_portal();
-	local_irq_disable();
+	local_irq_save(flags);
 	FQLOCK(fq);
 	if (unlikely((fq_isset(fq, QMAN_FQ_STATE_BLOCKOOS)) ||
 			(fq->state != qman_fq_state_retired))) {
@@ -1132,7 +1135,7 @@ int qman_oos_fq(struct qman_fq *fq)
 	fq->state = qman_fq_state_oos;
 out:
 	FQUNLOCK(fq);
-	local_irq_enable();
+	local_irq_restore(flags);
 	put_affine_portal();
 	return ret;
 }
@@ -1144,8 +1147,9 @@ int qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd)
 	struct qm_mc_result *mcr;
 	struct qman_portal *p = get_affine_portal();
 	u8 res;
+	unsigned long flags;
 
-	local_irq_disable();
+	local_irq_save(flags);
 	mcc = qm_mc_start(p->p);
 	mcc->queryfq.fqid = fq->fqid;
 	qm_mc_commit(p->p, QM_MCC_VERB_QUERYFQ);
@@ -1155,7 +1159,7 @@ int qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd)
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
 		*fqd = mcr->queryfq.fqd;
-	local_irq_enable();
+	local_irq_restore(flags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK) {
 		pr_err("QUERYFQ failed: %s\n", mcr_result_str(res));
-- 
1.6.5.2

