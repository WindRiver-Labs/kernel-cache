From e0a6197b131323e8eb4780796b7672d5e3733ac4 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 4 Nov 2009 15:38:50 -0500
Subject: [PATCH 069/252] qman: tune performance settings.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Applied FSL SDK 2.0.3 patch
"kernel-2.6.30-qman-tune-performance-settings.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/hwqueue/Kconfig     |    2 +-
 drivers/hwqueue/qman_high.c |    8 ++++++++
 drivers/hwqueue/qman_low.c  |    7 +++++++
 include/linux/fsl_qman.h    |    1 +
 4 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/drivers/hwqueue/Kconfig b/drivers/hwqueue/Kconfig
index bb4f530..8250c22 100644
--- a/drivers/hwqueue/Kconfig
+++ b/drivers/hwqueue/Kconfig
@@ -66,7 +66,7 @@ config FSL_QMAN_FQRANGE
 
 config FSL_QMAN_POLL_LIMIT
 	int
-	default 15
+	default 32
 
 config FSL_QMAN_CONFIG
 	bool "Qman device management"
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 283ce8b..987a8dd 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -251,6 +251,10 @@ struct qman_portal *qman_create_portal(struct qm_portal *__p, u32 flags,
 		pr_err("Qman ISR initialisation failed\n");
 		goto fail_isr;
 	}
+	/* static interrupt-gating controls */
+	qm_dqrr_set_ithresh(__p, 12);
+	qm_mr_set_ithresh(__p, 4);
+	qm_isr_set_iperiod(__p, 100);
 	portal->p = __p;
 	if (!cgrs)
 		portal->cgrs = NULL;
@@ -576,7 +580,9 @@ static inline void __poll_portal_fast(struct qman_portal *p,
 	struct qman_fq *fq;
 	enum qman_cb_dqrr_result res;
 	int prefetch = !(p->options & QMAN_PORTAL_FLAG_RSTASH);
+	int limit = 0;
 
+loop:
 	if (qm_dqrr_pvb_update(lowp) && prefetch)
 		qm_dqrr_pvb_prefetch(lowp);
 	dq = qm_dqrr_current(lowp);
@@ -624,6 +630,8 @@ static inline void __poll_portal_fast(struct qman_portal *p,
 	/* Move forward */
 	qm_dqrr_next(lowp);
 #endif
+	if (++limit < CONFIG_FSL_QMAN_POLL_LIMIT)
+		goto loop;
 done:
 	if (prefetch)
 		qm_dqrr_pvb_prefetch(lowp);
diff --git a/drivers/hwqueue/qman_low.c b/drivers/hwqueue/qman_low.c
index a7f0fd3..000d260 100644
--- a/drivers/hwqueue/qman_low.c
+++ b/drivers/hwqueue/qman_low.c
@@ -52,6 +52,7 @@
 #define REG_MR_ITR		(void *)0x0088
 #define REG_CFG			(void *)0x0100
 #define REG_ISR			(void *)0x0e00
+#define REG_ITPR		(void *)0x0e14
 
 /* Cache-enabled register offsets */
 #define CL_EQCR			(void *)0x0000
@@ -1081,6 +1082,12 @@ void qm_isr_finish(struct qm_portal *portal)
 }
 EXPORT_SYMBOL(qm_isr_finish);
 
+void qm_isr_set_iperiod(struct qm_portal *portal, u16 iperiod)
+{
+	qm_out(ITPR, iperiod);
+}
+EXPORT_SYMBOL(qm_isr_set_iperiod);
+
 u32 __qm_isr_read(struct qm_portal *portal, enum qm_isr_reg n)
 {
 	return __qm_in(&portal->addr, REG_ISR + (n << 2));
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index df53e05..b083216 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -505,6 +505,7 @@ struct qm_mc_result *qm_mc_result(struct qm_portal *portal);
 /* Create/destroy */
 int qm_isr_init(struct qm_portal *portal);
 void qm_isr_finish(struct qm_portal *portal);
+void qm_isr_set_iperiod(struct qm_portal *portal, u16 iperiod);
 
 /* Used by all portal interrupt registers except 'inhibit' */
 #define QM_PIRQ_CSCI	0x00100000	/* Congestion State Change */
-- 
1.6.5.2

