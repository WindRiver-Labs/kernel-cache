From c0d7e95d1dc9bcf8f13a7c9c18ab35b75f3a46ae Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Sun, 26 Dec 2010 19:01:11 +0800
Subject: [PATCH 22/28] FMAN: h_Spinlock must be IRQ-safe

Fix a lockdep error incured by Enabling CONFIG_PROVE_LOCKING

h_Spinlock can be used from both process and hard-irq context, so
h_Spinlock must be taken with IRQs disabled.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c |   16 ++++++++--------
 1 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
index b5f89ae..8056b96 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -753,11 +753,11 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     uint8_t     hardwarePortId = p_PortParams->hardwarePortId, relativePortId;
     uint32_t    minFifoSizeRequired = 0;
     uint16_t    macMaxFrameLength = 0;
+    uint32_t	intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
-
+	intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
     if(p_PortParams->independentMode)
     {
         /* set port parameters */
@@ -770,7 +770,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->hcPortInitialized)
         {
-            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+	    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
         }
         else
@@ -783,7 +783,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if((p_Fm->accumulatedNumOfTasks + p_PortParams->numOfTasks) >
        (p_Fm->totalNumOfTasks - p_Fm->extraTasksPoolSize))
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+	XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfTasks and extra tasks pool exceed total numOfTasks."));
     }
     else
@@ -841,7 +841,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->lowEndRestriction)
         {
-            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+	    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
         }
         else
@@ -855,7 +855,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) >
        p_Fm->maxNumOfOpenDmas)
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+	XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfOpenDmas."));
     }
     else
@@ -917,7 +917,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if((p_Fm->accumulatedFifoSize + p_PortParams->sizeOfFifo) >
        (p_Fm->totalFifoSize - p_Fm->extraFifoPoolSize))
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+	XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
     }
     else
@@ -972,7 +972,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return E_OK;
 }
-- 
1.6.5.2

