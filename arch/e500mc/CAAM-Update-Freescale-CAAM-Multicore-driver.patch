From 3fbd8407e5b8fc882f6341d0123694948f5bd4c7 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 14 Dec 2010 15:54:42 +0800
Subject: [PATCH 08/28] CAAM: Update Freescale CAAM-Multicore driver

Patch taken from FSL vendor SDK 2.2.

CAAM(Freescale's Cryptographic Accelerator and Assurance Module) adds
support for scatterlist crypto API and also can be configured to
operate as a DPAA component.

Modify code style.
Rearrange the files: remove jobdesc.c/protoshared.c and
CAAM's self-test files.

Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/crypto/caam/Kconfig                |   12 +-
 drivers/crypto/caam/Makefile               |    1 -
 drivers/crypto/caam/algapi.c               |  320 ++++--
 drivers/crypto/caam/compat.h               |    3 +-
 drivers/crypto/caam/ctrl.c                 |   61 +-
 drivers/crypto/caam/dcl/Makefile           |    2 +-
 drivers/crypto/caam/dcl/cmdgen.c           |   90 +-
 drivers/crypto/caam/dcl/dcl.h              |   14 +-
 drivers/crypto/caam/dcl/disasm.c           |   38 +-
 drivers/crypto/caam/dcl/jobdesc.c          |  666 -----------
 drivers/crypto/caam/dcl/protoshared.c      | 1682 ----------------------------
 drivers/crypto/caam/desc.h                 |    2 +-
 drivers/crypto/caam/error.c                |  136 ++-
 drivers/crypto/caam/error.h                |    2 +-
 drivers/crypto/caam/intern.h               |    5 +-
 drivers/crypto/caam/jq.c                   |  203 +++--
 drivers/crypto/caam/jq.h                   |    2 +-
 drivers/crypto/caam/jq_test/Makefile       |    4 -
 drivers/crypto/caam/jq_test/caam_jqtest.c  |  130 ---
 drivers/crypto/caam/jq_test/caam_jqtest.h  |   54 -
 drivers/crypto/caam/jq_test/jq_blkcipher.c |  321 ------
 drivers/crypto/caam/jq_test/jq_ipsec.c     |  381 -------
 drivers/crypto/caam/jq_test/jq_snow.c      |  298 -----
 drivers/crypto/caam/pdb.h                  |    2 +-
 drivers/crypto/caam/regs.h                 |   57 +-
 25 files changed, 580 insertions(+), 3906 deletions(-)
 delete mode 100644 drivers/crypto/caam/dcl/jobdesc.c
 delete mode 100644 drivers/crypto/caam/dcl/protoshared.c
 delete mode 100644 drivers/crypto/caam/jq_test/Makefile
 delete mode 100644 drivers/crypto/caam/jq_test/caam_jqtest.c
 delete mode 100644 drivers/crypto/caam/jq_test/caam_jqtest.h
 delete mode 100644 drivers/crypto/caam/jq_test/jq_blkcipher.c
 delete mode 100644 drivers/crypto/caam/jq_test/jq_ipsec.c
 delete mode 100644 drivers/crypto/caam/jq_test/jq_snow.c

diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index f322e1a..08c15dd 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -47,7 +47,7 @@ config CRYPTO_DEV_FSL_CAAM_INTC_TIME_THLD
 	int "Job Queue interrupt coalescing timer threshold"
 	depends on CRYPTO_DEV_FSL_CAAM_INTC
 	range 1 65535
-	default 255
+	default 2048
 	help
 	  Select number of bus clocks/64 to timeout in the case that one or
 	  more descriptor completions are queued without reaching the count
@@ -69,13 +69,3 @@ config CRYPTO_DEV_FSL_CAAM_CRYPTO_API
 	  Selecting this will offload crypto for users of the
 	  scatterlist crypto API (such as the linux native IPSec
 	  stack NETKEY) to the SEC4 via a job queue.
-
-config CRYPTO_DEV_FSL_CAAM_JQ_TEST
-	tristate "Freescale CAAM-Multicore JobQ Test (EXPERIMENTAL)"
-	depends on CRYPTO_DEV_FSL_CAAM
-	depends on CRYPTO_DEV_FSL_CAAM_DC_LIB
-	help
-	  Enables a test module for to exercise CAAM through a
-	  native job queue.
-
-
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
index ae3425f..409d954 100644
--- a/drivers/crypto/caam/Makefile
+++ b/drivers/crypto/caam/Makefile
@@ -9,6 +9,5 @@ obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM) += caam.o
 
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DC_LIB) += dcl/
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API) += algapi.o
-obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_JQ_TEST) += jq_test/
 
 caam-objs := ctrl.o jq.o error.o
diff --git a/drivers/crypto/caam/algapi.c b/drivers/crypto/caam/algapi.c
index c950469..cb080ad 100644
--- a/drivers/crypto/caam/algapi.c
+++ b/drivers/crypto/caam/algapi.c
@@ -94,12 +94,14 @@ struct caam_ctx {
 	struct device *dev;
 	int class1_alg_type;
 	int class2_alg_type;
+	int alg_op;
 	u8 *key;
 	dma_addr_t key_phys;
 	unsigned int keylen;
 	unsigned int enckeylen;
 	unsigned int authkeylen;
 	unsigned int split_key_len;
+	unsigned int split_key_pad_len;
 	unsigned int authsize;
 	union {
 		struct ipsec_encap_pdb *shared_encap;
@@ -127,16 +129,35 @@ static int aead_authenc_setauthsize(struct crypto_aead *authenc,
 				    unsigned int authsize)
 {
 	struct caam_ctx *ctx = crypto_aead_ctx(authenc);
+	struct device *dev = ctx->dev;
 
 	debug("setauthsize: authsize %d\n", authsize);
 
-	switch (authsize) {
-	case 12:
+	switch (authsize * 8) {
+	case 96:
+		if (ctx->alg_op != OP_ALG_ALGSEL_SHA1) {
+			dev_err(dev, "h/w doesn't support %d-bit ICV trunc."
+				" length with chosen authentication algorithm",
+				authsize * 8);
+			return -EOPNOTSUPP;
+		}
 		ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96;
 		break;
-	case 20:
+	case 128:
+		ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_256;
+		break;
+	case 160:
 		ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_160;
 		break;
+	case 192:
+		ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_384;
+		break;
+	case 256:
+		ctx->class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_256;
+		break;
+	default:
+		dev_err(dev, "unknown auth digest size: %d\n", authsize);
+		return -EINVAL;
 	}
 
 	ctx->authsize = authsize;
@@ -150,18 +171,15 @@ static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
 	struct device *dev = ctx->dev;
 	gfp_t flags = req->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :
 		      GFP_ATOMIC;
-	struct crypto_async_request *req_base = &req->base;
-	struct sk_buff *skb = req_base->data;
-	struct xfrm_state *x = xfrm_input_state(skb);
 	struct ipsec_decap_pdb *sh_desc;
 	int seq_no_offset = offsetof(struct ip_esp_hdr, seq_no);
-	void *sh_desc_ptr;
+	void *sh_desc_ptr, *enc_key;
 	int endidx;
 
 	/* build shared descriptor for this session */
-	sh_desc = kzalloc(sizeof(struct ipsec_decap_pdb) +
-			 ctx->split_key_len + ctx->enckeylen +
-			 sizeof(struct iphdr), GFP_DMA | flags);
+	sh_desc = kzalloc(sizeof(struct ipsec_decap_pdb) + ctx->split_key_len +
+			  ctx->enckeylen + sizeof(struct iphdr),
+			  GFP_DMA | flags);
 	if (!sh_desc) {
 		dev_err(dev, "could not allocate shared descriptor\n");
 		return -ENOMEM;
@@ -174,15 +192,14 @@ static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
 	sh_desc->ip_nh_offset = 0;
 
 	/*
-	 * options: ipv4, only the decapsulated output if tunnel mode
+	 * options: ipv4, beneath crypto api, no real way of
+	 * knowing tunnel vs. transport, so we treat tunnel mode
+	 * as a special case of transport mode.
 	 * linux doesn't support Extended Sequence Numbers
 	 * as of time of writing: thus PDBOPTS_ESPCBC_ESN not set.
 	 */
-	debug("xfrm is in %s mode\n", x->props.mode == XFRM_MODE_TUNNEL ?
-	      "tunnel" : "transport");
-	sh_desc->options = ((x->props.mode == XFRM_MODE_TUNNEL) ?
-			    (PDBOPTS_ESPCBC_TUNNEL | PDBOPTS_ESPCBC_OUTFMT) :
-			    0);
+	sh_desc->options = 0;
+
 	/* copy Sequence Number
 	 * equivalent to:
 	 * *spi = *(__be32*)(skb_transport_header(skb) + offset);
@@ -193,17 +210,14 @@ static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
 	/* insert keys, leaving space here for the jump instruction */
 	sh_desc_ptr = &sh_desc->end_index[1];
 
-	/*
-	 * process keys, starting with class 2/authentication
-	 * This is assuming keys are immediate for sharedesc
-	 */
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)ctx->key_phys,
-				     ctx->authkeylen * 8 * 2,
+	/* process keys, starting with class 2/authentication */
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (void *)&ctx->key_phys,
+				     ctx->split_key_len * 8,
 				     PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
 				     ITEM_REFERENCE, ITEM_CLASS2);
 
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)(ctx->key +
-				     ctx->split_key_len), ctx->enckeylen * 8,
+	enc_key = ctx->key + ctx->split_key_pad_len;
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, &enc_key, ctx->enckeylen * 8,
 				     PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				     ITEM_INLINE, ITEM_CLASS1);
 
@@ -258,13 +272,9 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 	gfp_t flags = areq->base.flags & CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL :
 		      GFP_ATOMIC;
 	struct device *dev = ctx->dev;
-	struct crypto_async_request *req_base = &areq->base;
-	struct sk_buff *skb = req_base->data;
-	struct dst_entry *dst = skb_dst(skb);
-	struct xfrm_state *x = dst->xfrm;
 	struct ipsec_encap_pdb *sh_desc;
 	int endidx;
-	void *sh_desc_ptr;
+	void *sh_desc_ptr, *enc_key;
 
 	/* build shared descriptor for this session */
 	sh_desc = kzalloc(sizeof(struct ipsec_encap_pdb) +
@@ -279,13 +289,6 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 	 * options byte: IVsrc is RNG
 	 * we do not Prepend IP header to output frame
 	 */
-	debug("xfrm is in %s mode\n", x->props.mode == XFRM_MODE_TUNNEL ?
-	      "tunnel" : "transport");
-
-	if (x->props.mode == XFRM_MODE_TUNNEL) {
-		sh_desc->ip_nh = IPPROTO_IPIP; /* next hdr = IPv4 */
-		sh_desc->options = PDBOPTS_ESPCBC_TUNNEL;
-	}
 #if !defined(DEBUG)
 	sh_desc->options |= PDBOPTS_ESPCBC_IVSRC; /* IV src is RNG */
 #endif
@@ -300,7 +303,7 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 	memcpy(&sh_desc->cbc.iv, "myivmyivmyivmyiv", sizeof(sh_desc->cbc.iv));
 #endif
 
-	/* 
+	/*
 	 * indicate no IP header,
 	 * rather a jump instruction and key specification follow
 	 */
@@ -309,23 +312,14 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 	/* insert keys, leaving space here for the jump instruction */
 	sh_desc_ptr = &sh_desc->ip_hdr[1];
 
-	/*
-	 * process keys, starting with class 2/authentication
-	 * This is assuming keys are immediate for sharedesc
-	 * class 1/cipher key
-	 * n.b., h/w triggers:
-	 * "of_platform jq.31: DECO: desc idx 11: Invalid KEY Command..."
-	 * if split_key_len is used here instead of authkeylen * 2
-	 * for len of class 2 key
-	 */
-
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)ctx->key_phys,
-				     ctx->authkeylen * 8 * 2, PTR_DIRECT,
+	/* process keys, starting with class 2/authentication */
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (void *)&ctx->key_phys,
+				     ctx->split_key_len * 8, PTR_DIRECT,
 				     KEYDST_MD_SPLIT, KEY_COVERED,
 				     ITEM_REFERENCE, ITEM_CLASS2);
 
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)ctx->key +
-				     ctx->split_key_len, ctx->enckeylen * 8,
+	enc_key = ctx->key + ctx->split_key_pad_len;
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, &enc_key, ctx->enckeylen * 8,
 				     PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				     ITEM_INLINE, ITEM_CLASS1);
 
@@ -352,7 +346,7 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 #ifdef DEBUG
 	print_hex_dump(KERN_ERR, "shrdesc@"xstr(__LINE__)": ",
 		       DUMP_PREFIX_ADDRESS, 16, 4, sh_desc,
-			(sh_desc_ptr - (void *)sh_desc + 1 + 4) * 4, 1);
+		       (sh_desc_ptr - (void *)sh_desc + 1 + 4) * 4, 1);
 	caam_desc_disasm((u32 *)sh_desc, DISASM_SHOW_OFFSETS | DISASM_SHOW_RAW);
 #endif
 
@@ -435,14 +429,14 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 		kfree(desc);
 		return -ENOMEM;
 	}
-	desc_pos = cmd_insert_key(desc_pos, (void *)dma_addr_in, authkeylen * 8,
-				  PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				  ITEM_REFERENCE, ITEM_CLASS2);
+	desc_pos = cmd_insert_key(desc_pos, (void *)&dma_addr_in,
+				  authkeylen * 8, PTR_DIRECT, KEYDST_KEYREG,
+				  KEY_CLEAR, ITEM_REFERENCE, ITEM_CLASS2);
 
 	/* Sets MDHA up into an HMAC-INIT */
 	desc_pos = cmd_insert_alg_op(desc_pos, OP_TYPE_CLASS2_ALG,
-				     OP_ALG_ALGSEL_SHA1, OP_ALG_AAI_HMAC,
-				     MDSTATE_INIT, ICV_CHECK_OFF, DIR_DECRYPT);
+				     ctx->alg_op, OP_ALG_AAI_HMAC, MDSTATE_INIT,
+				     ICV_CHECK_OFF, DIR_DECRYPT);
 
 	/*
 	 * do a FIFO_LOAD of zero, this will trigger the internal key expansion
@@ -460,7 +454,7 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 	 * FIFO_STORE with the explicit split-key content store
 	 * (0x26 output type)
 	 */
-	dma_addr_out = dma_map_single(dev, ctx->key, ctx->split_key_len,
+	dma_addr_out = dma_map_single(dev, ctx->key, ctx->split_key_pad_len,
 				      DMA_FROM_DEVICE);
 	if (dma_mapping_error(dev, dma_addr_out)) {
 		dev_err(dev, "unable to map key output memory\n");
@@ -468,9 +462,9 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 		kfree(desc);
 		return -ENOMEM;
 	}
-	desc_pos = cmd_insert_fifo_store(desc_pos, (void *)dma_addr_out,
-					 authkeylen * 2, LDST_CLASS_2_CCB, 0, 0,
-					 0, FIFOST_TYPE_SPLIT_KEK);
+	desc_pos = cmd_insert_fifo_store(desc_pos, (void *)&dma_addr_out,
+					 ctx->split_key_len, LDST_CLASS_2_CCB,
+					 0, 0, 0, FIFOST_TYPE_SPLIT_KEK);
 
 	/* insert job descriptor header */
 	cmd_insert_hdr(desc, 0, desc_pos - desc, SHR_NEVER, SHRNXT_LENGTH,
@@ -490,7 +484,7 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 	init_completion(&result.completion);
 
 	tgt_jq_dev = priv->algapi_jq[per_cpu(cpu_to_job_queue,
-				     smp_processor_id())];
+				     raw_smp_processor_id())];
 	ret = caam_jq_enqueue(tgt_jq_dev, desc, split_key_done, &result);
 	if (!ret) {
 		/* in progress */
@@ -503,7 +497,7 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 #endif
 	}
 
-	dma_unmap_single(dev, dma_addr_out, ctx->split_key_len,
+	dma_unmap_single(dev, dma_addr_out, ctx->split_key_pad_len,
 			 DMA_FROM_DEVICE);
 	dma_unmap_single(dev, dma_addr_in, authkeylen, DMA_TO_DEVICE);
 
@@ -515,6 +509,8 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 static int aead_authenc_setkey(struct crypto_aead *aead,
 			       const u8 *key, unsigned int keylen)
 {
+	/* Sizes for MDHA pads (*not* keys): MD5, SHA1, 224, 256, 384, 512 */
+	static const u8 mdpadlen[] = { 16, 20, 32, 32, 64, 64 };
 	struct caam_ctx *ctx = crypto_aead_ctx(aead);
 	struct device *dev = ctx->dev;
 	struct rtattr *rta = (void *)key;
@@ -546,17 +542,21 @@ static int aead_authenc_setkey(struct crypto_aead *aead,
 	if (keylen > CAAM_MAX_KEY_SIZE)
 		goto badkey;
 
-	/* FIXME: may need to look at keyspec instead of basing on inkeysize */
-	ctx->split_key_len = ALIGN(authkeylen * 2, 16);
+	/* Pick class 2 key length from algorithm submask */
+	ctx->split_key_len = mdpadlen[(ctx->alg_op & OP_ALG_ALGSEL_SUBMASK) >>
+				      OP_ALG_ALGSEL_SHIFT] * 2;
+	ctx->split_key_pad_len = ALIGN(ctx->split_key_len, 16);
 
 #ifdef DEBUG
 	printk(KERN_ERR "keylen %d enckeylen %d authkeylen %d\n",
 	       keylen, enckeylen, authkeylen);
+	printk(KERN_ERR "split_key_len %d split_key_pad_len %d\n",
+	       ctx->split_key_len, ctx->split_key_pad_len);
 	print_hex_dump(KERN_ERR, "key in @"xstr(__LINE__)": ",
 		       DUMP_PREFIX_ADDRESS, 16, 4, key,
 		       CAAM_MAX_KEY_SIZE, 1);
 #endif
-	ctx->key = kzalloc(ctx->split_key_len + enckeylen,
+	ctx->key = kzalloc(ctx->split_key_pad_len + enckeylen,
 			   GFP_KERNEL | GFP_DMA);
 	if (!ctx->key) {
 		dev_err(ctx->dev, "could not allocate key output memory\n");
@@ -568,11 +568,10 @@ static int aead_authenc_setkey(struct crypto_aead *aead,
 		goto badkey;
 
 	/* postpend encryption key to auth split key */
-	memcpy(ctx->key + ctx->split_key_len, key + authkeylen, enckeylen);
+	memcpy(ctx->key + ctx->split_key_pad_len, key + authkeylen, enckeylen);
 
-	ctx->key_phys = dma_map_single(dev, ctx->key,
-				       ctx->split_key_len + enckeylen,
-				       DMA_TO_DEVICE);
+	ctx->key_phys = dma_map_single(dev, ctx->key, ctx->split_key_pad_len +
+				       enckeylen, DMA_TO_DEVICE);
 	if (dma_mapping_error(dev, ctx->key_phys)) {
 		dev_err(dev, "unable to map key i/o memory\n");
 		return -ENOMEM;
@@ -747,11 +746,6 @@ static void sg_to_link_tbl(struct scatterlist *sg, int sg_count,
 	link_tbl_ptr->len |= cpu_to_be32(0x40000000);
 }
 
-static int transport_mode(int options)
-{
-	return !(options & PDBOPTS_ESPCBC_TUNNEL);
-}
-
 /*
  * fill in and submit ipsec_esp job descriptor
  */
@@ -772,7 +766,6 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 	int startidx, endidx, ret, sg_count, assoc_sg_count, len, padlen;
 	int ivsize = crypto_aead_ivsize(aead);
 	dma_addr_t ptr;
-	/* defaults; may be overwritten */
 	struct ipsec_deco_dpovrd dpovrd = {0, 0, 0, 0};
 
 #ifdef DEBUG
@@ -789,8 +782,8 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 	descptr++;
 
 	/* insert shared descriptor pointer */
-	*descptr = ctx->shared_desc_phys;
-	descptr++;
+	*(dma_addr_t *)descptr = ctx->shared_desc_phys;
+	descptr += sizeof(dma_addr_t) / sizeof(u32);
 
 	/* Save current location for computing start index later */
 	startidx = descptr - desc;
@@ -815,11 +808,8 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 					 + areq->cryptlen - 2);
 			/* cryptlen includes padlen / is blocksize aligned */
 			len = areq->cryptlen - padlen - 2;
-
-			if (transport_mode(ctx->shared_encap->options))
-				dpovrd.next_header = *(u8 *)((u8 *)sg_virt
-							     (areq->src) +
-							     areq->cryptlen-1);
+			dpovrd.next_header = *(u8 *)((u8 *)sg_virt(areq->src) +
+						     areq->cryptlen - 1);
 		} else {
 			sg_to_link_tbl(areq->src, sg_count, link_tbl_ptr, 0);
 #ifdef DEBUG
@@ -835,10 +825,9 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 				 ctx->authsize - 2);
 			/* cryptlen includes padlen / is blocksize aligned */
 			len = areq->cryptlen - padlen - 2;
-			if (transport_mode(ctx->shared_encap->options))
-				dpovrd.next_header = *(u8 *)((u8 *)sg_virt(sg) +
-							     sg->length -
-							     ctx->authsize - 1);
+			dpovrd.next_header = *(u8 *)((u8 *)sg_virt(sg) +
+						     sg->length -
+						     ctx->authsize - 1);
 #ifdef DEBUG
 			print_hex_dump(KERN_ERR, "sglastin@"xstr(__LINE__)": ",
 				       DUMP_PREFIX_ADDRESS, 16, 4, sg_virt(sg),
@@ -847,8 +836,7 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 		}
 
 		debug("pad length is %d\n", padlen);
-		if (transport_mode(ctx->shared_encap->options))
-			debug("next header is %d\n", dpovrd.next_header);
+		debug("next header is %d\n", dpovrd.next_header);
 	} else { /* DECAP */
 		debug("seq.num %d\n",
 		      *(u32 *)((u32 *)sg_virt(areq->assoc) + 1));
@@ -895,11 +883,10 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 						   DMA_BIDIRECTIONAL);
 			edesc->link_tbl_phys = ptr;
 		}
-		len =  sizeof(struct iphdr) + areq->assoclen + ivsize +
-		       areq->cryptlen + ctx->authsize;
+		len = sizeof(struct iphdr) + areq->assoclen + ivsize +
+		      areq->cryptlen + ctx->authsize;
 	}
-	descptr = cmd_insert_seq_in_ptr(descptr, (u_int32_t *)ptr, len,
-					edesc->dma_len ?
+	descptr = cmd_insert_seq_in_ptr(descptr, ptr, len, edesc->dma_len ?
 					PTR_SGLIST : PTR_DIRECT);
 
 	/* insert the SEQ OUT (data out) command */
@@ -934,23 +921,12 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 	} else { /* DECAP */
 		len = areq->cryptlen + ctx->authsize;
 		if (!edesc->dma_len) {
-			ptr = sg_dma_address(areq->dst);
-			if (transport_mode(ctx->shared_decap->options)) {
-				ptr -= sizeof(struct iphdr) + areq->assoclen +
-				       ivsize;
-				len += sizeof(struct iphdr) + areq->assoclen +
-				       ivsize;
-			}
+			ptr = sg_dma_address(areq->dst) - sizeof(struct iphdr) -
+			      areq->assoclen - ivsize;
+			len += sizeof(struct iphdr) + areq->assoclen + ivsize;
 		} else {
-			if (!transport_mode(ctx->shared_decap->options)) {
-				link_tbl_ptr->ptr += sizeof(struct iphdr) +
-						     areq->assoclen + ivsize;
-				link_tbl_ptr->len -= sizeof(struct iphdr) +
-						     areq->assoclen + ivsize;
-			} else { /* transport mode */
-				len += sizeof(struct iphdr) + areq->assoclen +
-				       ivsize + ctx->authsize;
-			}
+			len += sizeof(struct iphdr) + areq->assoclen + ivsize +
+			       ctx->authsize;
 			ptr += sg_count * sizeof(struct link_tbl_entry);
 			/* FIXME: need dma_sync since post-map adjustments? */
 #ifdef DEBUG
@@ -961,14 +937,12 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 		}
 	}
 
-	descptr = cmd_insert_seq_out_ptr(descptr, (u_int32_t *)ptr, len,
-					 edesc->dma_len ?
+	descptr = cmd_insert_seq_out_ptr(descptr, ptr, len, edesc->dma_len ?
 					 PTR_SGLIST : PTR_DIRECT);
 
-	if ((direction == DIR_ENCAP) &&
-		transport_mode(ctx->shared_encap->options)) {
+	if (direction == DIR_ENCAP) {
 		/* insert the LOAD command */
-		dpovrd.ovrd_ecn = IPSEC_ENCAP_DECO_DPOVRD_USE;
+		dpovrd.ovrd_ecn |= IPSEC_ENCAP_DECO_DPOVRD_USE;
 		/* DECO class, no s-g, 7 == DPROVRD, 0 offset */
 		descptr = cmd_insert_load(descptr, &dpovrd, LDST_CLASS_DECO,
 					  0, 0x07 << 16, 0, sizeof(dpovrd),
@@ -992,7 +966,7 @@ static int ipsec_esp(struct ipsec_esp_edesc *edesc, struct aead_request *areq,
 #endif
 
 	tgt_jq_dev = priv->algapi_jq[per_cpu(cpu_to_job_queue,
-					     smp_processor_id())];
+					     raw_smp_processor_id())];
 	ret = caam_jq_enqueue(tgt_jq_dev, desc, callback, areq);
 	if (!ret)
 		ret = -EINPROGRESS;
@@ -1074,11 +1048,50 @@ static struct ipsec_esp_edesc *ipsec_esp_edesc_alloc(struct aead_request *areq,
 	return edesc;
 }
 
-static int aead_authenc_encrypt_first(struct aead_request *req)
+static int aead_authenc_encrypt(struct aead_request *areq)
 {
-	printk(KERN_ERR "%s unimplemented\n", __func__);
+	struct aead_givcrypt_request *req =
+		 container_of(areq, struct aead_givcrypt_request, areq);
+	struct ipsec_esp_edesc *edesc;
 
-	return -EINVAL;
+	/* allocate extended descriptor */
+	edesc = ipsec_esp_edesc_alloc(areq, DIR_ENCAP);
+	if (IS_ERR(edesc))
+		return PTR_ERR(edesc);
+
+	return ipsec_esp(edesc, areq, req->giv, DIR_ENCAP,
+			 ipsec_esp_encrypt_done);
+}
+
+static int aead_authenc_encrypt_first(struct aead_request *areq)
+{
+	struct crypto_aead *aead = crypto_aead_reqtfm(areq);
+	struct caam_ctx *ctx = crypto_aead_ctx(aead);
+	struct aead_givcrypt_request *req =
+		 container_of(areq, struct aead_givcrypt_request, areq);
+	int err;
+
+	spin_lock_bh(&ctx->first_lock);
+	if (crypto_aead_crt(aead)->encrypt != aead_authenc_encrypt_first)
+		goto unlock;
+
+	err = build_protocol_desc_ipsec_encap(ctx, areq);
+	if (err) {
+		spin_unlock_bh(&ctx->first_lock);
+		return err;
+	}
+
+	/* copy sequence number to PDB */
+	ctx->shared_encap->seq_num = req->seq;
+
+	/* and the SPI */
+	ctx->shared_encap->spi = *((u32 *)sg_virt(areq->assoc));
+
+	crypto_aead_crt(aead)->encrypt = aead_authenc_encrypt;
+unlock:
+	spin_unlock_bh(&ctx->first_lock);
+
+	return aead_authenc_encrypt(areq);
 }
 
 static int aead_authenc_decrypt(struct aead_request *req)
@@ -1114,8 +1127,8 @@ static int aead_authenc_decrypt_first(struct aead_request *req)
 	}
 
 	/* copy sequence number to PDB */
-	 ctx->shared_decap->seq_num = cpu_to_be32(*(u32 *)((u32 *)
-						sg_virt(req->assoc) + 1));
+	ctx->shared_decap->seq_num = cpu_to_be32(*(u32 *)((u32 *)
+						 sg_virt(req->assoc) + 1));
 
 	crypto_aead_crt(aead)->decrypt = aead_authenc_decrypt;
 unlock:
@@ -1159,7 +1172,7 @@ static int aead_authenc_givencrypt_first(struct aead_givcrypt_request *req)
 	ctx->shared_encap->seq_num = cpu_to_be32(req->seq);
 
 	/* and the SPI */
-	 ctx->shared_encap->spi = cpu_to_be32(*((u32 *)sg_virt(areq->assoc)));
+	ctx->shared_encap->spi = cpu_to_be32(*((u32 *)sg_virt(areq->assoc)));
 
 	crypto_aead_crt(aead)->givencrypt = aead_authenc_givencrypt;
 unlock:
@@ -1176,6 +1189,7 @@ struct caam_alg_template {
 	struct device *dev;
 	int class1_alg_type;
 	int class2_alg_type;
+	int alg_op;
 };
 
 static struct caam_alg_template driver_algs[] = {
@@ -1196,10 +1210,29 @@ static struct caam_alg_template driver_algs[] = {
 			},
 		.class1_alg_type = CIPHER_TYPE_IPSEC_AESCBC,
 		.class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96,
+		.alg_op = OP_ALG_ALGSEL_SHA1,
 	},
 	{
-		.name = "authenc(hmac(sha1),cbc(3des))",
-		.driver_name = "authenc-hmac-sha1-cbc-3des-caam",
+		.name = "authenc(hmac(sha256),cbc(aes))",
+		.driver_name = "authenc-hmac-sha256-cbc-aes-caam",
+		.blocksize = AES_BLOCK_SIZE,
+		.aead = {
+			.setkey = aead_authenc_setkey,
+			.setauthsize = aead_authenc_setauthsize,
+			.encrypt = aead_authenc_encrypt_first,
+			.decrypt = aead_authenc_decrypt_first,
+			.givencrypt = aead_authenc_givencrypt_first,
+			.geniv = "<built-in>",
+			.ivsize = AES_BLOCK_SIZE,
+			.maxauthsize = SHA256_DIGEST_SIZE,
+			},
+		.class1_alg_type = CIPHER_TYPE_IPSEC_AESCBC,
+		.class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_256,
+		.alg_op = OP_ALG_ALGSEL_SHA256,
+	},
+	{
+		.name = "authenc(hmac(sha1),cbc(des3_ede))",
+		.driver_name = "authenc-hmac-sha1-cbc-des3_ede-caam",
 		.blocksize = DES3_EDE_BLOCK_SIZE,
 		.aead = {
 			.setkey = aead_authenc_setkey,
@@ -1213,6 +1246,25 @@ static struct caam_alg_template driver_algs[] = {
 			},
 		.class1_alg_type = CIPHER_TYPE_IPSEC_3DESCBC,
 		.class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96,
+		.alg_op = OP_ALG_ALGSEL_SHA1,
+	},
+	{
+		.name = "authenc(hmac(sha256),cbc(des3_ede))",
+		.driver_name = "authenc-hmac-sha256-cbc-des3_ede-caam",
+		.blocksize = DES3_EDE_BLOCK_SIZE,
+		.aead = {
+			.setkey = aead_authenc_setkey,
+			.setauthsize = aead_authenc_setauthsize,
+			.encrypt = aead_authenc_encrypt_first,
+			.decrypt = aead_authenc_decrypt_first,
+			.givencrypt = aead_authenc_givencrypt_first,
+			.geniv = "<built-in>",
+			.ivsize = DES3_EDE_BLOCK_SIZE,
+			.maxauthsize = SHA256_DIGEST_SIZE,
+			},
+		.class1_alg_type = CIPHER_TYPE_IPSEC_3DESCBC,
+		.class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_256,
+		.alg_op = OP_ALG_ALGSEL_SHA256,
 	},
 	{
 		.name = "authenc(hmac(sha1),cbc(des))",
@@ -1230,6 +1282,25 @@ static struct caam_alg_template driver_algs[] = {
 			},
 		.class1_alg_type = CIPHER_TYPE_IPSEC_DESCBC,
 		.class2_alg_type = AUTH_TYPE_IPSEC_SHA1HMAC_96,
+		.alg_op = OP_ALG_ALGSEL_SHA1,
+	},
+	{
+		.name = "authenc(hmac(sha256),cbc(des))",
+		.driver_name = "authenc-hmac-sha256-cbc-des-caam",
+		.blocksize = DES_BLOCK_SIZE,
+		.aead = {
+			.setkey = aead_authenc_setkey,
+			.setauthsize = aead_authenc_setauthsize,
+			.encrypt = aead_authenc_encrypt_first,
+			.decrypt = aead_authenc_decrypt_first,
+			.givencrypt = aead_authenc_givencrypt_first,
+			.geniv = "<built-in>",
+			.ivsize = DES_BLOCK_SIZE,
+			.maxauthsize = SHA256_DIGEST_SIZE,
+			},
+		.class1_alg_type = CIPHER_TYPE_IPSEC_DESCBC,
+		.class2_alg_type = AUTH_TYPE_IPSEC_SHA2HMAC_256,
+		.alg_op = OP_ALG_ALGSEL_SHA256,
 	},
 };
 
@@ -1238,6 +1309,7 @@ struct caam_crypto_alg {
 	struct device *dev;
 	int class1_alg_type;
 	int class2_alg_type;
+	int alg_op;
 	struct crypto_alg crypto_alg;
 };
 
@@ -1254,6 +1326,7 @@ static int caam_cra_init(struct crypto_tfm *tfm)
 	/* copy descriptor header template value */
 	ctx->class1_alg_type = caam_alg->class1_alg_type;
 	ctx->class2_alg_type = caam_alg->class2_alg_type;
+	ctx->alg_op = caam_alg->alg_op;
 
 	spin_lock_init(&ctx->first_lock);
 
@@ -1316,6 +1389,7 @@ static struct caam_crypto_alg *caam_alg_alloc(struct device *dev,
 
 	t_alg->class1_alg_type = template->class1_alg_type;
 	t_alg->class2_alg_type = template->class2_alg_type;
+	t_alg->alg_op = template->alg_op;
 	t_alg->dev = dev;
 
 	return t_alg;
diff --git a/drivers/crypto/caam/compat.h b/drivers/crypto/caam/compat.h
index caef4e2..85440fd 100644
--- a/drivers/crypto/caam/compat.h
+++ b/drivers/crypto/caam/compat.h
@@ -2,7 +2,7 @@
  * CAAM Descriptor Construction Library
  * Application level usage definitions and prototypes
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -52,6 +52,7 @@
 #include <linux/slab.h>
 #include <linux/types.h>
 #include <linux/debugfs.h>
+#include <linux/circ_buf.h>
 #include <net/xfrm.h>
 
 #include <crypto/algapi.h>
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index b1bbf38..eb6d8b2 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -2,7 +2,7 @@
  * CAAM control-plane driver backend
  * Controller-level driver, kernel property detection, initialization
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -58,27 +58,57 @@
 
 int caam_jq_shutdown(struct device *dev);
 
+#if 0
+static int caam_reset_qi(struct device *ctrldev)
+{
+	struct caam_drv_private *ctrlpriv = dev_get_drvdata(ctrldev);
+	unsigned int timeout = 100000;
+
+	/* initiate flush (required prior to reset) */
+	wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_STOP);
+	while ((rd_reg32(&ctrlpriv->qi->qi_status) & QISTA_STOPD) == 0 &&
+	       --timeout)
+		cpu_relax();
+
+	if ((rd_reg32(&ctrlpriv->qi->qi_status) & QISTA_STOPD) != QISTA_STOPD ||
+	    timeout == 0) {
+		dev_err(ctrldev, "failed to flush queue interface\n");
+		return -EIO;
+	}
+
+	/* initiate reset */
+	timeout = 100000;
+	wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_STOP);
+	while ((rd_reg32(&ctrlpriv->qi->qi_control_lo) & QICTL_STOP) != 0 &&
+	       --timeout)
+		cpu_relax();
+
+	if (timeout == 0) {
+		dev_err(ctrldev, "failed to reset queue interface\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+#endif
+
 static int caam_remove(struct of_device *ofdev)
 {
 	struct device *ctrldev;
 	struct caam_drv_private *ctrlpriv;
 	struct caam_drv_private_jq *jqpriv;
-	int q;
+	int q, ret = 0;
 
 	ctrldev = &ofdev->dev;
 	ctrlpriv = dev_get_drvdata(ctrldev);
 
 	/* shut down JobQs */
 	for (q = 0; q < ctrlpriv->total_jobqs; q++) {
-		caam_jq_shutdown(ctrlpriv->jqdev[q]);
+		ret |= caam_jq_shutdown(ctrlpriv->jqdev[q]);
 		jqpriv = dev_get_drvdata(ctrlpriv->jqdev[q]);
 		irq_dispose_mapping(jqpriv->irq);
 	}
 
-	/* Disconnect QI */
-	if (ctrlpriv->qi_present)
-		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_STOP);
-
 	/* Shut down debug views */
 #ifdef CONFIG_DEBUG_FS
 	debugfs_remove_recursive(ctrlpriv->dfs_root);
@@ -90,7 +120,7 @@ static int caam_remove(struct of_device *ofdev)
 	kfree(ctrlpriv->jqdev);
 	kfree(ctrlpriv);
 
-	return 0;
+	return ret;
 }
 
 
@@ -132,8 +162,15 @@ static int caam_probe(struct of_device *ofdev,
 	/* Get the IRQ of the controller (for security violations only) */
 	ctrlpriv->secvio_irq = of_irq_to_resource(nprop, 0, NULL);
 
-	/* Enable DECO watchdogs in master configuration register */
-	setbits32(&ctrlpriv->ctrl->mcr, MCFGR_WDENABLE);
+	/*
+	 * Enable DECO watchdogs and, if this is a PHYS_ADDR_T_64BIT kernel,
+	 * 36-bit pointers in master configuration register
+	 */
+	setbits32(&ctrlpriv->ctrl->mcr, MCFGR_WDENABLE |
+		  (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));
+
+	if (sizeof(dma_addr_t) == sizeof(u64))
+		dma_set_mask(dev, DMA_BIT_MASK(36));
 
 	/*
 	 * Device tree provides no information on the actual number
@@ -154,7 +191,7 @@ static int caam_probe(struct of_device *ofdev,
 	 * for all, then go probe each one.
 	 */
 	qspec = 0;
-	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-queue")
+	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-ring")
 		qspec++;
 	ctrlpriv->jqdev = kzalloc(sizeof(struct device *) * qspec, GFP_KERNEL);
 	if (ctrlpriv->jqdev == NULL) {
@@ -164,7 +201,7 @@ static int caam_probe(struct of_device *ofdev,
 
 	q = 0;
 	ctrlpriv->total_jobqs = 0;
-	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-queue") {
+	for_each_compatible_node(np, NULL, "fsl,sec4.0-job-ring") {
 		caam_jq_probe(ofdev, np, q);
 		ctrlpriv->total_jobqs++;
 		q++;
diff --git a/drivers/crypto/caam/dcl/Makefile b/drivers/crypto/caam/dcl/Makefile
index 2640007..83e2a26 100644
--- a/drivers/crypto/caam/dcl/Makefile
+++ b/drivers/crypto/caam/dcl/Makefile
@@ -10,5 +10,5 @@
 #
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_DC_LIB) += caam_dcl.o
 
-caam_dcl-objs := disasm.o protoshared.o cmdgen.o jobdesc.o
+caam_dcl-objs := disasm.o cmdgen.o
 
diff --git a/drivers/crypto/caam/dcl/cmdgen.c b/drivers/crypto/caam/dcl/cmdgen.c
index 16b0ca7..2ef5fb2 100644
--- a/drivers/crypto/caam/dcl/cmdgen.c
+++ b/drivers/crypto/caam/dcl/cmdgen.c
@@ -2,7 +2,7 @@
  * CAAM Descriptor Construction Library
  * Descriptor Instruction Generator
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -170,7 +170,7 @@ EXPORT_SYMBOL(cmd_insert_hdr);
  *
  * @descwd  = pointer to target descriptor word to hold this command
  *
- * @key     = pointer to key data as an array of bytes.
+ * @key     = pointer to pointer to key data as an array of bytes.
  *
  * @keylen  = pointer to key size, expressed in bits.
  *
@@ -202,13 +202,13 @@ EXPORT_SYMBOL(cmd_insert_hdr);
  *            OPERATION command. If dest is KEYDST_PK_E or KEYDST_AF_SBOX,
  *            then this must be ITEM_CLASS1.
  **/
-u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
+u_int32_t *cmd_insert_key(u_int32_t *descwd, void *key, u_int32_t keylen,
 			  enum ref_type sgref, enum key_dest dest,
 			  enum key_cover cover, enum item_inline imm,
 			  enum item_purpose purpose)
 {
-	u_int32_t *nextwd, *keybuf;
-	u_int32_t  keysz, keywds;
+	u_int32_t *nextwd;
+	u_int32_t  keysz;
 
 	if ((!descwd) || (!key))
 		return 0;
@@ -224,11 +224,6 @@ u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
 
 	nextwd = descwd;
 
-	/* Convert size (in bits) to adequate byte length */
-	keysz = ((keylen & KEY_LENGTH_MASK) >> 3);
-	if (keylen & 0x00000007)
-		keysz++;
-
 	/* Build command word */
 	*nextwd = CMD_KEY;
 	switch (dest) {
@@ -270,17 +265,24 @@ u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
 	if (sgref == PTR_SGLIST)
 		*nextwd |= KEY_SGF;
 
+	/* Convert size (in bits) to adequate byte length */
+	keysz = ((keylen & KEY_LENGTH_MASK) >> 3);
+	if (keylen & 0x00000007)
+		keysz++;
+
 	*nextwd++ |= keysz;
 
 	if (imm == ITEM_INLINE) {
-		keywds = keysz >> 2;
-		keybuf = (u_int32_t *)key;
-		while (keywds) {
-			*nextwd++ = *keybuf++;
-			keywds--;
-		}
+		memcpy(nextwd, *(void **)key, keysz);
+		nextwd += keysz / sizeof(*nextwd);
 	} else
-		*nextwd++ = (u_int32_t)key;
+		if (sizeof(dma_addr_t) == sizeof(u32))
+			*nextwd++ = *(dma_addr_t *)key;
+		else {
+			*nextwd++ = upper_32_bits(*(dma_addr_t *)key);
+			*nextwd++ = lower_32_bits(*(dma_addr_t *)key);
+		}
+
 	return nextwd;
 }
 EXPORT_SYMBOL(cmd_insert_key);
@@ -689,20 +691,24 @@ EXPORT_SYMBOL(cmd_insert_pkha_op);
  *              - PTR_SGLIST = points to CAAM-specific scatter gather
  *                table.
  **/
-u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
-				 enum ref_type sgref)
+u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, dma_addr_t ptr,
+				 u_int32_t len, enum ref_type sgref)
 {
 	*descwd = CMD_SEQ_IN_PTR | ((sgref == PTR_SGLIST) ? SQIN_SGF : 0) | len;
 
-	*(descwd + 1) = (u_int32_t)ptr;
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		*(descwd + 1) = upper_32_bits(ptr);
+		*(descwd + 2) = lower_32_bits(ptr);
+	} else
+		*(descwd + 1) = ptr;
 
 	if (len > 0xffff) {
 		*descwd |= SQIN_EXT;
-		*(descwd + 2) = len;
-		return descwd + 3;
+		*(descwd + 1 + sizeof(dma_addr_t) / sizeof(u32)) = len;
+		return descwd + 2 + sizeof(dma_addr_t) / sizeof(u32);
 	}
 
-	return descwd + 2;
+	return descwd + 1 + sizeof(dma_addr_t) / sizeof(u32);
 }
 EXPORT_SYMBOL(cmd_insert_seq_in_ptr);
 
@@ -723,21 +729,25 @@ EXPORT_SYMBOL(cmd_insert_seq_in_ptr);
  *              - PTR_SGLIST = points to CAAM-specific scatter gather
  *                table.
  **/
-u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
-				  enum ref_type sgref)
+u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, dma_addr_t ptr,
+				  u_int32_t len, enum ref_type sgref)
 {
 	*descwd = CMD_SEQ_OUT_PTR | ((sgref == PTR_SGLIST) ? SQOUT_SGF : 0) |
 		  len;
 
-	*(descwd + 1) = (u_int32_t)ptr;
+	if (sizeof(dma_addr_t) == sizeof(u64)) {
+		*(descwd + 1) = upper_32_bits(ptr);
+		*(descwd + 2) = lower_32_bits(ptr);
+	} else
+		*(descwd + 1) = ptr;
 
 	if (len > 0xffff) {
 		*descwd |= SQOUT_EXT;
-		*(descwd + 2) = len;
-		return descwd + 3;
+		*(descwd + 1 + sizeof(dma_addr_t) / sizeof(u32)) = len;
+		return descwd + 2 + sizeof(dma_addr_t) / sizeof(u32);
 	}
 
-	return descwd + 2;
+	return descwd + 1 + sizeof(dma_addr_t) / sizeof(u32);
 }
 EXPORT_SYMBOL(cmd_insert_seq_out_ptr);
 
@@ -1042,7 +1052,7 @@ EXPORT_SYMBOL(cmd_insert_seq_store);
  * @descwd = pointer to target descriptor word intended to hold
  *           this instruction.
  *
- * @data   = pointer to data to be loaded
+ * @data   = pointer to pointer to data to be loaded
  *
  * @len    = length of data in bytes
  *
@@ -1062,13 +1072,10 @@ EXPORT_SYMBOL(cmd_insert_seq_store);
  * @type   = FIFO input type, an OR combination of FIFOST_TYPE_
  *           type and last/flush bits for class1 and 2.
  **/
-u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
+u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void **data, u_int32_t len,
 				 u_int32_t class_access, u_int32_t sgflag,
 				 u_int32_t imm, u_int32_t ext, u_int32_t type)
 {
-	int words;
-	u_int32_t *nextin;
-
 	*descwd = CMD_FIFO_STORE | (class_access & CLASS_MASK) | sgflag |
 		  imm | ext | type;
 
@@ -1078,14 +1085,15 @@ u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
 	descwd++;
 
 	if (imm == FIFOLD_IMM) {
-		words = len >> 2;
-		nextin = (u_int32_t *)data;
-		while (words) {
-			*descwd++ = *nextin++;
-			words--;
-		}
+		memcpy(descwd, *(char **)data, len);
+		descwd += len / sizeof(*descwd);
 	} else
-		*descwd++ = (u_int32_t)data;
+		if (sizeof(dma_addr_t) == sizeof(u32))
+			*descwd++ = *(dma_addr_t *)data;
+		else {
+			*descwd++ = upper_32_bits(*(dma_addr_t *)data);
+			*descwd++ = lower_32_bits(*(dma_addr_t *)data);
+		}
 
 	if (ext)
 		*descwd++ = len;
diff --git a/drivers/crypto/caam/dcl/dcl.h b/drivers/crypto/caam/dcl/dcl.h
index 995807e..2e3da7d 100644
--- a/drivers/crypto/caam/dcl/dcl.h
+++ b/drivers/crypto/caam/dcl/dcl.h
@@ -2,7 +2,7 @@
  * CAAM Descriptor Construction Library
  * Application level usage definitions and prototypes
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -160,7 +160,7 @@ u_int32_t *cmd_insert_hdr(u_int32_t *descwd, u_int8_t startidx,
 			  enum shrnext sharenext, enum execorder reverse,
 			  enum mktrust mktrusted);
 
-u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
+u_int32_t *cmd_insert_key(u_int32_t *descwd, void *key, u_int32_t keylen,
 			  enum ref_type sgref, enum key_dest dest,
 			  enum key_cover cover, enum item_inline imm,
 			  enum item_purpose purpose);
@@ -189,11 +189,11 @@ u_int32_t *cmd_insert_alg_op(u_int32_t *descwd, u_int32_t optype,
 
 u_int32_t *cmd_insert_pkha_op(u_int32_t *descwd, u_int32_t pkmode);
 
-u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
-				 enum ref_type sgref);
+u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, dma_addr_t ptr,
+				 u_int32_t len, enum ref_type sgref);
 
-u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
-				  enum ref_type sgref);
+u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, dma_addr_t ptr,
+				  u_int32_t len, enum ref_type sgref);
 
 u_int32_t *cmd_insert_load(u_int32_t *descwd, void *data,
 			   u_int32_t class_access, u_int32_t sgflag,
@@ -221,7 +221,7 @@ u_int32_t *cmd_insert_seq_store(u_int32_t *descwd, u_int32_t class_access,
 				u_int32_t variable_len_flag, u_int32_t src,
 				u_int8_t offset, u_int8_t len);
 
-u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
+u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void **data, u_int32_t len,
 				 u_int32_t class_access, u_int32_t sgflag,
 				 u_int32_t imm, u_int32_t ext, u_int32_t type);
 
diff --git a/drivers/crypto/caam/dcl/disasm.c b/drivers/crypto/caam/dcl/disasm.c
index 84d0083..f0c742b 100644
--- a/drivers/crypto/caam/dcl/disasm.c
+++ b/drivers/crypto/caam/dcl/disasm.c
@@ -5,7 +5,7 @@
  * This is EXPERIMENTAL and incomplete code. It assumes BE32 for the
  * moment, and much functionality remains to be filled in
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -475,8 +475,13 @@ static void show_key(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 		desc_hexdump(keydata, keylen >> 2, 4, leader);
 		(*idx) += keylen >> 2;
 	} else {
-		PRINT("%s@0x%08x\n", leader, *keydata);
-		(*idx)++; /* key pointer follows instruction */
+		PRINT("%s@0x%08x", leader, *keydata);
+		if (sizeof(dma_addr_t) > sizeof(u32))
+			PRINT("_%08x\n", *(keydata + 1));
+		else
+			PRINT("\n");
+		/* key pointer follows instruction */
+		*idx += sizeof(dma_addr_t) / sizeof(u32);
 	}
 	(*idx)++;
 }
@@ -678,7 +683,7 @@ static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 
 	PRINT("\n");
 
-	(*idx)++;
+	*idx += sizeof(dma_addr_t) / sizeof(u32);
 
 	if (*cmd & FIFOLD_IMM) {
 		desc_hexdump(trdata, len >> 2, 4, leader);
@@ -774,8 +779,12 @@ static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 		desc_hexdump(trdata, len >> 2, 4, leader);
 		(*idx) += len >> 2;
 	} else {
-		PRINT("%s@0x%08x\n", leader, *trdata);
-		(*idx)++;
+		PRINT("%s@0x%08x", leader, *trdata);
+		if (sizeof(dma_addr_t) > sizeof(u32))
+			PRINT("_%08x\n", *(trdata + 1));
+		else
+			PRINT("\n");
+		*idx += sizeof(dma_addr_t) / sizeof(u32);
 	}
 
 	if (*cmd & FIFOLDST_EXT) {
@@ -1489,7 +1498,9 @@ static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 		PRINT(" PRE");
 	} else {
 		PRINT(" @0x%08x", *(cmd + 1));
-		(*idx)++;
+		if (sizeof(dma_addr_t) > sizeof(u32))
+			PRINT("_%08x", *(cmd + 2));
+		*idx += sizeof(dma_addr_t) / sizeof(u32);
 	}
 	if (*cmd & SQIN_EXT)
 		PRINT(" EXT");
@@ -1510,7 +1521,9 @@ static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 		PRINT(" PRE");
 	} else {
 		PRINT(" @0x%08x", *(cmd + 1));
-		(*idx)++;
+		if (sizeof(dma_addr_t) > sizeof(u32))
+			PRINT("_%08x", *(cmd + 2));
+		*idx += sizeof(dma_addr_t) / sizeof(u32);
 	}
 	if (*cmd & SQOUT_EXT)
 		PRINT(" EXT");
@@ -1653,8 +1666,13 @@ void caam_desc_disasm(u_int32_t *desc, u_int32_t opts)
 
 		/* Skip sharedesc pointer if SHARED, else display PDB */
 		if (*desc & HDR_SHARED) {
-			stidx = 2; /* just skip past sharedesc ptr */
-			PRINT("%s sharedesc->0x%08x\n", emptyleader, desc[1]);
+			/* just skip past sharedesc ptr */
+			stidx = 1 + sizeof(dma_addr_t) / sizeof(u32);
+			PRINT("%s sharedesc->0x%08x", emptyleader, desc[1]);
+			if (sizeof(dma_addr_t) > sizeof(u32))
+				PRINT("_%08x\n", desc[2]);
+			else
+				PRINT("\n");
 		} else
 			if (stidx > 1) /* >1 means real PDB data exists */
 				desc_hexdump(&desc[1], stidx - 1, 4,
diff --git a/drivers/crypto/caam/dcl/jobdesc.c b/drivers/crypto/caam/dcl/jobdesc.c
deleted file mode 100644
index 69affcb..0000000
--- a/drivers/crypto/caam/dcl/jobdesc.c
+++ /dev/null
@@ -1,666 +0,0 @@
-/*
- * CAAM Descriptor Construction Library
- * Basic job descriptor construction
- *
- * Copyright (c) 2009, Freescale Semiconductor, Inc.
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "../compat.h"
-#include "dcl.h"
-
-/* Sizes for MDHA pads (*not* keys): MD5, SHA1, 224, 256, 384, 512 */
-static const u_int8_t mdpadlen[] = { 16, 20, 32, 32, 64, 64 };
-
-/**
- * cnstr_seq_jobdesc() - Construct simple sequence job descriptor
- * Returns: 0 (for now)
- *
- * @jobdesc - pointer to a buffer to build the target job descriptor
- *            within
- * @jobdescsz - size of target job descriptor buffer
- * @shrdesc - pointer to pre-existing shared descriptor to use with
- *            this job
- * @shrdescsz - size of pre-existing shared descriptor
- * @inbuf - pointer to input frame
- * @insize - size of input frame
- * @outbuf - pointer to output frame
- * @outsize - size of output frame
- *
- * Constructs a simple job descriptor that contains 3 references:
- *   (1) A shared descriptor to do the work. This is normally assumed
- *       to be some sort of a protocol sharedesc, but can be any sharedesc.
- *   (2) A packet/frame for input data
- *   (3) A packet/frame for output data
- *
- * The created descriptor is always a simple reverse-order descriptor,
- * and has no provisions for other content specifications.
- **/
-int cnstr_seq_jobdesc(u_int32_t *jobdesc, u_int16_t *jobdescsz,
-		      u_int32_t *shrdesc, u_int16_t shrdescsz,
-		      void *inbuf, u_int32_t insize,
-		      void *outbuf, u_int32_t outsize)
-{
-	u_int32_t *next;
-
-	/*
-	 * Basic structure is
-	 * - header (assume sharing, reverse order)
-	 * - sharedesc physical address
-	 * - SEQ_OUT_PTR
-	 * - SEQ_IN_PTR
-	 */
-
-	/* Make running pointer past where header will go */
-	next = jobdesc;
-	next++;
-
-	/* Insert sharedesc */
-	*next++ = (u_int32_t)shrdesc;
-
-	/* Sequence pointers */
-	next = cmd_insert_seq_out_ptr(next, outbuf, outsize, PTR_DIRECT);
-	next = cmd_insert_seq_in_ptr(next, inbuf, insize, PTR_DIRECT);
-
-	/* Now update header */
-	*jobdescsz = next - jobdesc; /* add 1 to include header */
-	cmd_insert_hdr(jobdesc, shrdescsz, *jobdescsz, SHR_SERIAL,
-		       SHRNXT_SHARED, ORDER_REVERSE, DESC_STD);
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_seq_jobdesc);
-
-/**
- * Construct a blockcipher request as a single job
- *
- * @descbuf - pointer to buffer for descriptor construction
- * @bufsz - size of constructed descriptor (as output)
- * @data_in - input message
- * @data_out - output message
- * @datasz - size of message
- * @key - cipher key
- * @keylen - size of cipher key
- * @iv - cipher IV
- * @ivlen - size of cipher IV
- * @dir - DIR_ENCRYPT or DIR_DECRYPT
- * @cipher - algorithm from OP_ALG_ALGSEL_
- * @clear - clear descriptor buffer before construction
- **/
-int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
-				u_int8_t *data_in, u_int8_t *data_out,
-				u_int32_t datasz,
-				u_int8_t *key, u_int32_t keylen,
-				u_int8_t *iv, u_int32_t ivlen,
-				enum algdir dir, u_int32_t cipher,
-				u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	start = descbuf++; /* save start for eventual header write */
-
-	if (!descbuf)
-		return -1;
-
-	if (clear)
-		memset(start, 0, (*bufsz * sizeof(u_int32_t)));
-
-	startidx = descbuf - start;
-	descbuf = cmd_insert_seq_in_ptr(descbuf, data_in, datasz,
-					PTR_DIRECT);
-
-	descbuf = cmd_insert_seq_out_ptr(descbuf, data_out, datasz,
-					 PTR_DIRECT);
-
-	descbuf = cmd_insert_load(descbuf, iv, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, (ivlen >> 3),
-				  ITEM_REFERENCE);
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_IMM, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_IMM, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG, cipher,
-				    OP_ALG_AAI_CBC, MDSTATE_COMPLETE,
-				    ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LAST1), 0);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
-					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 0);
-
-	/* Now update the header with size/offsets */
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsz = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_blkcipher_cbc);
-
-/**
- * HMAC as a single job
- * @descbuf - descriptor buffer
- * @bufsize - limit/returned descriptor buffer size
- * @msg     - pointer to message being processed
- * @msgsz   - size of message in bytes
- * @digest  - output buffer for digest (size derived from cipher)
- * @key     - key data (size derived from cipher)
- * @cipher  - OP_ALG_ALGSEL_MD5/SHA1-512
- * @icv     - HMAC comparison for ICV, NULL if no check desired
- * @clear   - clear buffer before writing
- **/
-int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
-			   u_int8_t *msg, u_int32_t msgsz, u_int8_t *digest,
-			   u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
-			   u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int8_t storelen;
-	enum icvsel opicv;
-
-	start = descbuf++;
-
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	switch (cipher) {
-	case OP_ALG_ALGSEL_MD5:
-		storelen = 16;
-		break;
-
-	case OP_ALG_ALGSEL_SHA1:
-		storelen = 20;
-		break;
-
-	case OP_ALG_ALGSEL_SHA224:
-		storelen = 28;
-		break;
-
-	case OP_ALG_ALGSEL_SHA256:
-		storelen = 32;
-		break;
-
-	case OP_ALG_ALGSEL_SHA384:
-		storelen = 48;
-
-	case OP_ALG_ALGSEL_SHA512:
-		storelen = 64;
-
-	default:
-		return -1;
-	}
-
-	if (icv != NULL)
-		opicv = ICV_CHECK_ON;
-	else
-		opicv = ICV_CHECK_OFF;
-
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS2);
-
-	descbuf = cmd_insert_fifo_load(descbuf, msg, msgsz, LDST_CLASS_2_CCB,
-				       0, 0, 0,
-				       (FIFOLD_TYPE_MSG |
-					FIFOLD_TYPE_LASTBOTH));
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
-				    OP_ALG_AAI_HMAC, MDSTATE_COMPLETE,
-				    opicv, DIR_ENCRYPT);
-
-	descbuf = cmd_insert_store(descbuf, digest, LDST_CLASS_2_CCB, 0,
-				   LDST_SRCDST_BYTE_CONTEXT, 0, storelen,
-				   ITEM_REFERENCE);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_hmac);
-
-/**
- * Generate an MDHA split key - cnstr_jobdesc_mdsplitkey()
- *
- * @descbuf - pointer to buffer to hold constructed descriptor
- *
- * @bufsiz - pointer to size of descriptor once constructed
- *
- * @key - HMAC key to generate ipad/opad from. Size is determined
- *        by cipher. Note that SHA224/384 pads are not truncated.
- *
- *                              keysize  splitsize  buffersize
- *        ----------------------------------------------------
- *	  - OP_ALG_ALGSEL_MD5    = 16        32         32
- *	  - OP_ALG_ALGSEL_SHA1   = 20        40         48
- *	  - OP_ALG_ALGSEL_SHA224 = 28        64         64
- *	  - OP_ALG_ALGSEL_SHA256 = 32        64         64
- *	  - OP_ALG_ALGSEL_SHA384 = 48       128        128
- *	  - OP_ALG_ALGSEL_SHA512 = 64       128        128
- *
- * @cipher - HMAC algorithm selection, one of OP_ALG_ALGSEL_
- *
- * @padbuf - buffer to store generated ipad/opad. Should be 2x
- *           the (untruncated) HMAC keysize for chosen cipher
- *           rounded up to the nearest 16-byte boundary
- *           (16 bytes = AES blocksize). See the table under "key"
- *           above.
- **/
-int cnstr_jobdesc_mdsplitkey(u_int32_t *descbuf, u_int16_t *bufsize,
-			     u_int8_t *key, u_int32_t cipher,
-			     u_int8_t *padbuf)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int8_t keylen, storelen;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	/* Pick key length from cipher submask as an enum */
-	keylen = mdpadlen[(cipher & OP_ALG_ALGSEL_SUBMASK) >>
-			  OP_ALG_ALGSEL_SHIFT];
-
-	storelen = keylen * 2;
-
-	/* Load the HMAC key */
-	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS2);
-
-	/*
-	 * Select HMAC op with init only, this sets up key unroll
-	 * Have DECRYPT selected here, although MDHA doesn't care
-	 */
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
-				    OP_ALG_AAI_HMAC, MDSTATE_INIT,
-				    ICV_CHECK_OFF, DIR_DECRYPT);
-
-	/* FIFO load of 0 to kickstart MDHA (this will generate pads) */
-	descbuf = cmd_insert_fifo_load(descbuf, NULL, 0, LDST_CLASS_2_CCB,
-				       0, FIFOLD_IMM, 0,
-				       (FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2));
-
-	/* Wait for store to complete before proceeding */
-	/* This is a tapeout1 dependency */
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_2,
-				  JUMP_TEST_ALL, 0,
-				  1, NULL);
-
-	/* Now store the split key pair with that specific type */
-	descbuf = cmd_insert_fifo_store(descbuf, padbuf, storelen,
-					LDST_CLASS_2_CCB, 0, 0, 0,
-					FIFOST_TYPE_SPLIT_KEK);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_mdsplitkey);
-
-/**
- * Constructs an AES-GCM job descriptor - cnstr_jobdesc_aes_gcm()
- *
- * @descbuf - pointer to buffer that will hold constructed descriptor
- * @bufsize - pointer to size of descriptor once constructed
- * @key - pointer to AES key
- * @keylen - AES key size
- * @ctx - pointer to GCM context. This is a concatenation of:
- *        - MAC (128 bits)
- *        - Yi (128 bits)
- *        - Y0 (128 bits)
- *        - IV (64 bits)
- *        - Text bitsize (64 bits)
- *        See the AESA section of the blockguide for more information
- * @mdstate - select MDSTATE_UPDATE, MDSTATE_INIT, or MDSTATE_FINAL if a
- *            partial MAC operation is desired, else select MDSTATE_COMPLETE
- * @icv - select ICV_CHECK_ON if an ICV mac compare is requested
- * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed for the cipher operation
- * @in - pointer to input text buffer
- * @out - pointer to output text buffer
- * @size - size of data to be processed
- * @mac - pointer to output MAC. This can point to the head of CTX if an
- *        updated MAC is required for subsequent operations
- **/
-int cnstr_jobdesc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
-			  u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
-			  enum mdstatesel mdstate, enum icvsel icv,
-			  enum algdir dir, u_int8_t *in, u_int8_t *out,
-			  u_int16_t size, u_int8_t *mac)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-			     OP_ALG_ALGSEL_AES, OP_ALG_AAI_GCM,
-			     mdstate, icv, dir);
-
-	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB, 0,
-				  LDST_SRCDST_BYTE_CONTEXT, 0, 64,
-				  ITEM_REFERENCE);
-
-	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
-				       0, 0, 0,
-				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
-
-	descbuf = cmd_insert_fifo_store(descbuf, out, size, FIFOLD_CLASS_SKIP,
-					0, 0, 0, FIFOST_TYPE_MESSAGE_DATA);
-
-	descbuf = cmd_insert_store(descbuf, mac, LDST_CLASS_1_CCB, 0,
-				   LDST_SRCDST_BYTE_CONTEXT, 0, 64,
-				   ITEM_REFERENCE);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_aes_gcm);
-
-/**
- * Generate a Kasumi f8 job descriptor - cnstr_jobdesc_kasumi_f8()
- *
- * @descbuf - pointer to buffer that will hold constructed descriptor
- * @bufsize - pointer to size of descriptor once constructed
- * @key - pointer to KFHA cipher key
- * @keylen - cipher key length
- * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed
- * @ctx - points to preformatted f8 context block, containing 32-bit count
- *        (word 0), bearer (word 1 bits 0:5), direction (word 1 bit 6),
- *        ca (word 1 bits 7:16), and cb (word 1 bits 17:31). Refer to the
- *        KFHA section of the block guide for more detail.
- * @in - pointer to input data text
- * @out - pointer to output data text
- * @size - size of data to be processed
- **/
-int cnstr_jobdesc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
-			    u_int8_t *key, u_int32_t keylen,
-			    enum algdir dir, u_int32_t *ctx,
-			    u_int8_t *in, u_int8_t *out, u_int16_t size)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
-				  ITEM_REFERENCE);
-
-	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
-				       0, 0, 0,
-				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
-
-	descbuf = cmd_insert_fifo_store(descbuf, out, size, FIFOLD_CLASS_SKIP,
-					0, 0, 0, FIFOST_TYPE_MESSAGE_DATA);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_kasumi_f8);
-
-/**
- * Generate a Kasumi f9 (authentication) job descriptor -
- * cnstr_jobdesc_kasumi_f9()
- *
- * @descbuf - pointer to buffer that will hold constructed descriptor
- * @bufsize - pointer to size of descriptor once constructed
- * @key - pointer to cipher key
- * @keylen - size of cipher key
- * @dir - select DIR_DECRYPT and DIR_ENCRYPT
- * @ctx - points to preformatted f8 context block, containzing 32-bit count
- *        (word 0), bearer (word 1 bits 0:5), direction (word 1 bit 6),
- *        ca (word 1 bits 7:16), cb (word 1 bits 17:31), fresh (word 2),
- *        and the ICV input (word 3). Refer to the KFHA section of the
- *        block guide for more detail.
- * @in - pointer to input data
- * @size - size of input data
- * @mac - pointer to output MAC
- **/
-int cnstr_jobdesc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
-			    u_int8_t *key, u_int32_t keylen,
-			    enum algdir dir, u_int32_t *ctx,
-			    u_int8_t *in, u_int16_t size, u_int8_t *mac)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F9,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
-				  ITEM_REFERENCE);
-
-	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
-				       0, 0, 0,
-				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
-
-	descbuf = cmd_insert_store(descbuf, mac, LDST_CLASS_1_CCB, 0,
-				   LDST_SRCDST_BYTE_CONTEXT, 0, 4,
-				   ITEM_REFERENCE);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_kasumi_f9);
-
-/**
- * RSA exponentiation as a single job - cnstr_jobdesc_pkha_rsaexp()
- *
- * @descbuf - pointer to buffer to hold descriptor
- * @bufsiz - pointer to size of written descriptor
- * @pkin - Values of A, B, E, and N
- * @out - Encrypted output
- * @out_siz - size of buffer for encrypted output
- * @clear - nonzero if descriptor buffer space is to be cleared
- *          before construction
- **/
-int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
-			      struct pk_in_params *pkin,
-			      u_int8_t *out, u_int32_t out_siz,
-			      u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	/* class=1 dest=e len=8 s=#ram_e_data */
-	descbuf = cmd_insert_key(descbuf, pkin->e, pkin->e_siz, PTR_DIRECT,
-				 KEYDST_PK_E, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	/* class=1 type=n len=8 s=#ram_n_data */
-	descbuf = cmd_insert_fifo_load(descbuf, pkin->n, pkin->n_siz,
-				       LDST_CLASS_1_CCB, 0, 0, 0,
-				       FIFOLD_TYPE_PK_N);
-
-	/* class=1 type=a len=8 s=#ram_a_data */
-	descbuf = cmd_insert_fifo_load(descbuf, pkin->a, pkin->a_siz,
-				       LDST_CLASS_1_CCB, 0, 0, 0,
-				       FIFOLD_TYPE_PK_A);
-
-	/* class=1 type=b len=9 s=#ram_b_data */
-	descbuf = cmd_insert_fifo_load(descbuf, pkin->b, pkin->b_siz,
-				       LDST_CLASS_1_CCB, 0, 0, 0,
-				       FIFOLD_TYPE_PK_B);
-
-	/* alg=8 type=pkha func=f2m_exp dest=b */
-	descbuf = cmd_insert_pkha_op(descbuf, OP_ALG_PKMODE_MOD_EXPO);
-
-	/* type=b len=8 d=#ram_exp_data */
-	descbuf = cmd_insert_fifo_store(descbuf, out, out_siz,
-					LDST_CLASS_1_CCB, 0, 0, 0,
-					FIFOST_TYPE_PKHA_B);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsz = endidx;
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_pkha_rsaexp);
-
-/* FIXME: clear-written reg content should perhaps be defined in desc.h */
-static const u_int32_t clrw_imm = 0x00210000;
-
-/**
- * Binary DSA-verify as a single job - cnstr_jobdesc_dsaverify()
- *
- * @descbuf - pointer to descriptor buffer for construction
- * @bufsz - pointer to size of descriptor constructed (output)
- * @dsadata - pointer to DSA parameters
- * @msg - pointer to input message for verfication
- * @msg_sz - size of message to verify
- * @clear - clear buffer before writing descriptor
- **/
-int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
-			    struct dsa_verify_pdb *dsadata, u_int8_t *msg,
-			    u_int32_t msg_sz, u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	/* Build PDB with pointers to params */
-	memcpy(descbuf, dsadata, sizeof(struct dsa_verify_pdb));
-	descbuf += sizeof(struct dsa_verify_pdb) >> 2;
-
-	startidx = descbuf - start;
-
-	/* SHA1 hash command */
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG,
-				    OP_ALG_ALGSEL_SHA1, OP_ALG_AAI_HASH,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF,
-				    DIR_DECRYPT);
-
-	/* FIFO load of message */
-	descbuf = cmd_insert_fifo_load(descbuf, msg, msg_sz,
-				LDST_CLASS_2_CCB, 0, 0, 0,
-				FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2);
-
-	/* Store SHA-1 hash from context to f */
-	descbuf = cmd_insert_store(descbuf, dsadata->f, LDST_CLASS_2_CCB, 0,
-			    LDST_SRCDST_BYTE_CONTEXT, 0, 20, ITEM_REFERENCE);
-
-	/* Wait for CALM */
-	descbuf = cmd_insert_jump(descbuf, CLASS_2, JUMP_TYPE_LOCAL,
-				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
-
-	/* LOAD immediate to clear-written register */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&clrw_imm, CLASS_NONE,
-				  0, LDST_SRCDST_WORD_CLRW, 0,
-				  sizeof(clrw_imm), ITEM_INLINE);
-
-	/* DSAVERIFY OP | decrypt private | ECC | Binary field */
-	descbuf = cmd_insert_proto_op_unidir(descbuf, OP_PCLID_DSAVERIFY,
-					     OP_PCL_PKPROT_DECRYPT |
-					     OP_PCL_PKPROT_ECC |
-					     OP_PCL_PKPROT_F2M);
-
-	/* Header, factor in PDB offset */
-	endidx = descbuf - start + 1;
-	cmd_insert_hdr(start, startidx, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsz = endidx;
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_jobdesc_dsaverify);
-
diff --git a/drivers/crypto/caam/dcl/protoshared.c b/drivers/crypto/caam/dcl/protoshared.c
deleted file mode 100644
index 78e464f..0000000
--- a/drivers/crypto/caam/dcl/protoshared.c
+++ /dev/null
@@ -1,1682 +0,0 @@
-/*
- * CAAM Descriptor Construction Library
- * Protocol-level Shared Descriptor Constructors
- *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
- * All Rights Reserved
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "../compat.h"
-#include "dcl.h"
-
-/**
- * Protocol-level shared descriptor constructors
- *
- * These build a full protocol-level shared descriptor for semi-autonomous
- * processing of secured traffic through CAAM. Such descriptors function
- * as single-pass processors (integrating cipher and authentication
- * functions into a single logical step) with the added factor of
- * performing protocol-level packet manipulation in the same step
- * in the packet-handling process, by maintaining protocol-level
- * connection state information within the descriptor itself.
- *
- * For each function, the arguments are uniform:
- *
- * Inputs:
- *
- *    * descbuf    = Points to a buffer to construct the descriptor in.
- *                   All CAAM descriptors are built of an array of up to
- *                   63 32-bit words. If the caller wishes to construct
- *                   a descriptor directly in the executable buffer, then
- *                   that buffer must be hardware DMA-able, and physically
- *                   contiguous.
- *
- *    * bufsize    = Points to an unsigned 16-bit word with the max length
- *                   of the buffer to hold the descriptor. This will be
- *                   written back to with the actual size of the descriptor
- *                   once constructed. (Note: bounds checking not yet
- *                   implemented).
- *
- *    * pdb        = Points to a block of data (struct pdbcont) used to
- *                   describe the content if the Protocol Data Block to be
- *                   maintained inside the descriptor. PDB content is
- *                   protocol and mode specific.
- *
- *    * cipherdata = Points to a block of data used to describe the cipher
- *                   information for encryption/decryption of packet
- *                   content:
- *                   - algtype = one of CIPHER_TYPE_IPSEC_xxx
- *                   - key     = pointer to the cipher key data
- *                   - keydata = size of the key data in bits
- *
- *    * authdata   = Points to a block of data used to describe the
- *                   authentication information for validating the
- *                   authenticity of the packet source.
- *                   - algtype = one of AUTH_TYPE_IPSEC_xxx
- *                   - key     = pointer to the HMAC key data
- *                   - keydata = size of the key data in bits
- *
- *    * clear      = If nonzero, buffer is cleared before writing
- *
- * Returns:
- *
- *    * -1 if the descriptor creation failed for any reason, zero
- *      if creation succeeded.
- *
- */
-
-/*
- * IPSec ESP CBC decapsulation case:
- *
- * pdb.opthdrlen      = Size of inbound header to skip over.
- * pdb.transmode      = PDB_TUNNEL/PDB_TRANSPORT for tunnel or transport
- *                      handling for the next header.
- * pdb.pclvers        = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
- * pdb.seq.esn        = PDB_NO_ESN unless extended sequence numbers are to
- *                      be supported, then PDB_INCLUDE_ESN.
- * pdb.seq/antirplysz = PDB_ANTIRPLY_NONE if no antireplay window is to be
- *                      maintained in the PDB. Otherwise may be
- *                      PDB_ANTIRPLY_32 for a 32-entry window, or
- *                      PDB_ANTIRPLY_64 for a 64-entry window.
- *
- **/
-int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t           *descbuf,
-					u_int16_t           *bufsize,
-					struct pdbcont      *pdb,
-					struct cipherparams *cipherdata,
-					struct authparams   *authdata,
-					u_int8_t             clear)
-{
-	u_int32_t *start;
-	u_int8_t   pdbopts;
-	u_int16_t  startidx, endidx;
-
-	start = descbuf++; /* save start for eventual header write */
-			   /* bump to first word of PDB */
-
-	/* first, got to have clean buffer */
-	if (!descbuf)
-		return -1;
-
-	/* Prove other arguments */
-	if (!authdata->key)
-		return -3;
-
-	if (!cipherdata->key)
-		return -4;
-
-	if (!authdata->keylen)
-		return -5;
-
-	if (!cipherdata->keylen)
-		return -6;
-
-	/* If user requested a buffer clear, do it from the start */
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	/* Build PDB, beginning with length and options */
-	pdbopts = 0;
-
-	if (pdb->transmode == PDB_TUNNEL)
-		pdbopts |= PDBOPTS_ESPCBC_TUNNEL;
-
-	if (pdb->pclvers == PDB_IPV6)
-		pdbopts |= PDBOPTS_ESPCBC_IPVSN;
-
-	if (pdb->outfmt == PDB_OUTPUT_DECAP_PDU)
-		pdbopts |= PDBOPTS_ESPCBC_OUTFMT;
-
-	if (pdb->seq.esn == PDB_INCLUDE_ESN)
-		pdbopts |= PDBOPTS_ESPCBC_ESN;
-
-	switch (pdb->seq.antirplysz) {
-	case PDB_ANTIRPLY_32:
-		pdbopts |= PDBOPTS_ESPCBC_ARS32;
-		break;
-
-	case PDB_ANTIRPLY_64:
-		pdbopts |= PDBOPTS_ESPCBC_ARS64;
-		break;
-
-	case PDB_ANTIRPLY_NONE:
-	default:
-		pdbopts |= PDBOPTS_ESPCBC_ARSNONE;
-		break;
-	}
-
-	*descbuf++ = (pdb->opthdrlen << 16) | pdbopts;
-
-	/* Skip reserved section */
-	descbuf += 2;
-
-	/* Skip DECO writeback part */
-	descbuf += 4;
-
-	/* Save current location for computing start index */
-	startidx = descbuf - start;
-
-	/*
-	 * PDB now complete
-	 * Now process keys, starting with class 2/authentication
-	 * This is assuming keys are immediate for sharedesc
-	 */
-	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS2);
-
-	/* Now the class 1/cipher key */
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-
-	/* Insert the operation command */
-	descbuf = cmd_insert_proto_op_ipsec(descbuf,
-					    cipherdata->algtype,
-					    authdata->algtype,
-					    DIR_DECAP);
-
-	/* Now update the header with size/offsets */
-	endidx = descbuf - start + 1; /* add 1 to include header */
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_decap);
-
-/**
- * IPSec ESP CBC encapsulation case:
- *
- * pdbinfo.opthdrlen = Size of outbound IP header to be prepended to
- *                     output.
- * pdbinfo.opthdr    = Pointer to the IP header to be prepended to the
- *                     output, of size opthdrlen.
- * pdbinfo.transmode = PDB_TUNNEL/PDB_TRANSPORT for tunnel/transport
- *                     handling for the next header.
- * pdbinfo.pclvers   = PDB_IPV4/PDB_IPV6 as appropriate for this connection.
- * pdbinfo.seq.esn   = PDB_NO_ESN unless extended sequence numbers are to
- *                     be supported, then PDB_INCLUDE_ESN.
- * pdbinfo.ivsrc     = PDB_IV_FROM_PDB if the IV is to be maintained in
- *                     the PDB, else PDB_IV_FROM_RNG if the IV is to
- *                     be generated internally by CAAM's random number
- *                     generator.
- *
- **/
-int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
-					u_int16_t           *bufsize,
-					struct pdbcont      *pdb,
-					struct cipherparams *cipherdata,
-					struct authparams   *authdata,
-					u_int8_t             clear)
-{
-	u_int32_t *start;
-	u_int8_t   pdbopts;
-	u_int16_t  hdrwds, startidx, endidx;
-	u_int32_t *hdrbuf;
-
-	start = descbuf++; /* save start for eventual header write */
-			   /* bump to first word of PDB */
-
-	/* Verify a clean buffer */
-	if (!descbuf)
-		return -1;
-
-	/* Verify other pertinent arguments */
-	if (!authdata->key)
-		return -3;
-
-	if (!cipherdata->key)
-		return -4;
-
-	if (!authdata->keylen)
-		return -5;
-
-	if (!cipherdata->keylen)
-		return -6;
-
-	/* If user requested a buffer clear, do it from the start */
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	/* Construct PDB, starting with options word */
-	pdbopts = 0;
-
-	if (pdb->transmode == PDB_TUNNEL)
-		pdbopts |= PDBOPTS_ESPCBC_TUNNEL;
-
-	if (pdb->opthdrlen)
-		pdbopts |= PDBOPTS_ESPCBC_INCIPHDR | PDBOPTS_ESPCBC_IPHDRSRC;
-
-	if (pdb->pclvers == PDB_IPV6)
-		pdbopts |= PDBOPTS_ESPCBC_IPVSN;
-
-	if (pdb->seq.esn == PDB_INCLUDE_ESN)
-		pdbopts |= PDBOPTS_ESPCBC_ESN;
-
-	if (pdb->ivsrc == PDB_IV_FROM_RNG)
-		pdbopts |= PDBOPTS_ESPCBC_IVSRC;
-
-	*descbuf++ = pdbopts;
-
-	/* Skip sequence numbers */
-	descbuf += 2;
-
-	/* Skip IV */
-	descbuf += 4;
-
-	/* Skip SPI */
-	descbuf++;
-
-		*descbuf++ = pdb->opthdrlen;
-	/* If PDB-resident IPHeader, set size and append it */
-	if (pdb->opthdr && pdb->opthdrlen) {
-		hdrwds = pdb->opthdrlen >> 2;
-		hdrbuf = (u_int32_t *)pdb->opthdr;
-		while (hdrwds) {
-			*descbuf++ = *hdrbuf++;
-			hdrwds--;
-		}
-	}
-
-	/* Save current location for computing start index */
-	startidx = descbuf - start;
-
-	/*
-	 * Now process keys, starting with class 2/authentication
-	 * This is assuming keys are immediate for sharedesc
-	 */
-	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS2);
-
-	/* Now the class 1/cipher key */
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	/* Now insert the operation command */
-	descbuf = cmd_insert_proto_op_ipsec(descbuf,
-					    cipherdata->algtype,
-					    authdata->algtype,
-					    DIR_ENCAP);
-
-	/*
-	 * Now update the header with size/offsets
-	 * add 1 to include header
-	 */
-	endidx = descbuf - start + 1;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_encap);
-
-/**
- * Construct IPSec ESP encapsulation protocol-level sharedesc
- * Requires a covered MDHA splitkey.
- *
- * Inputs:
- * @descbuf - pointer to buffer used for descriptor construction
- *
- * @bufsize - pointer to size to be written back upon completion
- *
- * @pdb - pointer to the PDB to be used with this descriptor. This
- *       structure will be copied inline to the descriptor under
- *       construction. No error checking will be made. Refer to the
- *       block guide for a detailed discussion of the decapsulation
- *       PDB, and it's unioned sub structure that is cipher-dependent
- *
- * @opthdr - Optional header to be prepended to an encapsulated frame.
- *           Size of the optional header is defined in pdb.opt_hdr_len
- *
- * @cipherdata - Pointer to blockcipher transform definitions.
- *
- * @authdata - Pointer to authentication transform definitions. Note
- *             that since a split key is to be used, the size of the
- *             split key itself is specified (even though the buffer
- *             containing the key may have additional padding depending
- *             on the size).
- **/
-int32_t cnstr_shdsc_ipsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				    struct ipsec_encap_pdb *pdb,
-				    u_int8_t *opthdr,
-				    struct cipherparams *cipherdata,
-				    struct authparams *authdata)
-{
-	u_int32_t *start, *keyjump, opthdrsz;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	/* Compute optional header size, rounded up to descriptor word size */
-	opthdrsz = (pdb->ip_hdr_len + 3) & ~3;
-
-	/* copy in core of PDB */
-	memcpy(descbuf, pdb, sizeof(struct ipsec_encap_pdb));
-	descbuf += sizeof(struct ipsec_encap_pdb) >> 2;
-
-	/*
-	 * If optional header, compute optional header size
-	 * rounded up to descriptor word size, and copy in
-	 */
-	if (pdb->ip_hdr_len) {
-		opthdrsz = (pdb->ip_hdr_len + 3) & ~3;
-		memcpy(descbuf, opthdr, opthdrsz);
-		descbuf += opthdrsz >> 2;
-	}
-
-	startidx = descbuf - start;
-
-	/*
-	 * Insert an empty instruction for a shared-JUMP past the keys
-	 * Update later, once the size of the key block is known
-	 */
-	keyjump = descbuf++;
-
-	/* Insert keys */
-	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
-				 PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
-				 ITEM_REFERENCE, ITEM_CLASS2);
-
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_REFERENCE, ITEM_CLASS1);
-
-	/*
-	 * Key jump can now be written (now that we know the size of the
-	 * key block). This can now happen anytime before the final
-	 * sizes are computed.
-	 */
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_ipsec(descbuf,
-					    cipherdata->algtype,
-					    authdata->algtype,
-					    DIR_ENCAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-	return 0;
-};
-EXPORT_SYMBOL(cnstr_shdsc_ipsec_encap);
-
-/**
- * Construct IPSec ESP decapsulation protocol-level sharedesc
- * Requires a covered MDHA splitkey.
- *
- * Inputs:
- * @descbuf - pointer to buffer used for descriptor construction
- *
- * @bufsize - pointer to size to be written back upon completion
- *
- * @pdb - pointer to the PDB to be used with this descriptor. This
- *       structure will be copied inline to the descriptor under
- *       construction. No error checking will be made. Refer to the
- *       block guide for a detailed discussion of the decapsulation
- *       PDB, and it's unioned sub structure that is cipher-dependent
- *
- * @cipherdata - Pointer to blockcipher transform definitions.
- *
- * @authdata - Pointer to authentication transform definitions. Note
- *             that since a split key is to be used, the size of the
- *             split key itself is specified (even though the buffer
- *             containing the key may have additional padding depending
- *             on the size).
- **/
-int32_t cnstr_shdsc_ipsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct ipsec_decap_pdb *pdb,
-				struct cipherparams *cipherdata,
-				struct authparams *authdata)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	/* copy in PDB */
-	memcpy(descbuf, pdb, sizeof(struct ipsec_decap_pdb));
-	descbuf += sizeof(struct ipsec_decap_pdb) >> 2;
-
-	startidx = descbuf - start;
-
-	/*
-	 * Insert an empty instruction for a shared-JUMP past the keys
-	 * Update later, once the size of the key block is known
-	 */
-	keyjump = descbuf++;
-
-	/* Insert keys */
-	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
-				 PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
-				 ITEM_REFERENCE, ITEM_CLASS2);
-
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_REFERENCE, ITEM_CLASS1);
-
-	/*
-	 * Key jump comes here (now that we know the size of the key block.
-	 * Update before we insert the OP
-	 */
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_ipsec(descbuf,
-					    cipherdata->algtype,
-					    authdata->algtype,
-					    DIR_DECAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-	return 0;
-};
-EXPORT_SYMBOL(cnstr_shdsc_ipsec_decap);
-
-/**
- * IEEE 802.11i WiFi encapsulation
- **/
-int32_t cnstr_shdsc_wifi_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wifi_encap_pdb *pdb,
-				struct cipherparams *cipherdata)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct wifi_encap_pdb));
-	descbuf += sizeof(struct wifi_encap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_wifi(descbuf, DIR_ENCAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_wifi_encap);
-
-/**
- * IEEE 802.11 WiFi decapsulation
- **/
-int32_t cnstr_shdsc_wifi_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wifi_decap_pdb *pdb,
-				struct cipherparams *cipherdata)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct wifi_decap_pdb));
-	descbuf += sizeof(struct wifi_decap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_wifi(descbuf, DIR_DECAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_wifi_decap);
-
-/**
- * 802.16 WiMAX encapsulation
- *
- * @descbuf - Pointer to descriptor build buffer
- *
- * @bufsize - Pointer to value to write size of built descriptor to
- *
- * @pdb - pointer to pre-initialized PDB
- *
- * @cipherdata.keylen - key size in bytes
- * @cipherdata.key - key data to inline
- *
- * @mode - nonzero for OFDMa, else OFDM
- *
- * @clear - nonzero clears descriptor buffer
- *
- **/
-int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_encap_pdb *pdb,
-				struct cipherparams *cipherdata,
-				u_int8_t mode)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct wimax_encap_pdb));
-	descbuf += sizeof(struct wimax_encap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_ENCAP);
-
-	/* Now compute shared header */
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_wimax_encap);
-
-/**
- * 802.16 WiMAX decapsulation
- *
- * @descbuf - Pointer to descriptor build buffer
- *
- * @bufsize - Pointer to value to write size of built descriptor to
- *
- * @pdb - pointer to pre-initialized PDB
- *
- * @cipherdata.keylen - key size in bytes
- * @cipherdata.key - key data to inline
- *
- * @mode - nonzero for OFDMa, else OFDM
- *
- * @clear - nonzero clears descriptor buffer
- **/
-int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_decap_pdb *pdb,
-				struct cipherparams *cipherdata,
-				u_int8_t mode)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct wimax_decap_pdb));
-	descbuf += sizeof(struct wimax_decap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_DECAP);
-
-	/* Now compute shared header */
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_wimax_decap);
-
-/**
- * 802.1AE MacSec encapsulation
- *
- * @descbuf - Pointer to descriptor build buffer
- *
- * @bufsize - Pointer to value to write size of built descriptor to
- *
- * @pdb - pointer to pre-initialized PDB
- *
- * @cipherdata.keylen - key size in bytes
- * @cipherdata.key - key data to inline
- *
- * @clear - nonzero clears descriptor buffer
- **/
-
-int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_encap_pdb *pdb,
-				 struct cipherparams *cipherdata)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct macsec_encap_pdb));
-	descbuf += sizeof(struct macsec_encap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_ENCAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_macsec_encap);
-
-/**
- * 802.1AE MacSec decapsulation
- *
- * @descbuf - Pointer to descriptor build buffer
- *
- * @bufsize - Pointer to value to write size of built descriptor to
- *
- * @pdb - pointer to pre-initialized PDB
- *
- * @cipherdata.keylen - key size in bytes
- * @cipherdata.key - key data to inline
- *
- * @clear - nonzero clears descriptor buffer
- **/
-int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_decap_pdb *pdb,
-				 struct cipherparams *cipherdata)
-{
-	u_int32_t *start, *keyjump;
-	u_int16_t startidx, endidx;
-
-	start = descbuf;
-
-	memcpy(descbuf, pdb, sizeof(struct macsec_decap_pdb));
-	descbuf += sizeof(struct macsec_decap_pdb) >> 2;
-
-	startidx = descbuf - start;
-	keyjump = descbuf++;
-	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
-				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				 ITEM_INLINE, ITEM_CLASS1);
-
-	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
-			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
-			NULL);
-
-	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_DECAP);
-
-	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_macsec_decap);
-
-/**
- * SNOW/f8 (UEA2) as a shared descriptor
- *
- * @descbuf - pointer to descriptor-under-construction buffer
- * @bufsize - points to size to be updated at completion
- * @key - cipher key
- * @keylen - size of key in bits
- * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
- * @count - UEA2 count value (32 bits)
- * @bearer - UEA2 bearer ID (5 bits)
- * @direction - UEA2 direction (1 bit)
- **/
-int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
-			    u_int8_t *key, u_int32_t keylen,
-			    enum algdir dir, u_int32_t count,
-			    u_int8_t bearer, u_int8_t direction)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	u_int64_t COUNT       = count;
-	u_int64_t BEARER      = bearer;
-	u_int64_t DIRECTION   = direction;
-
-	u_int64_t context = (COUNT << 32) | (BEARER << 27) | (DIRECTION << 26);
-
-	start = descbuf++; /* save start for eventual header write */
-
-	/* Verify a clean buffer */
-	if (!descbuf)
-		return -1;
-
-	/* Save current location for computing start index */
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_SNOW, OP_ALG_AAI_F8,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
-					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 0);
-
-	/* Now update the header with size/offsets */
-	endidx = descbuf - start;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_snow_f8);
-
-/**
- * SNOW/f9 (UIA2) as a shared descriptor
- *
- * @descbuf - pointer to descriptor-under-construction buffer
- * @bufsize - points to size to be updated at completion
- * @key - cipher key
- * @keylen - size of key in bits
- * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
- * @count - UEA2 count value (32 bits)
- * @fresh - UEA2 fresh value ID (32 bits)
- * @direction - UEA2 direction (1 bit)
- **/
-int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
-			    u_int8_t *key, u_int32_t keylen,
-			    enum algdir dir, u_int32_t count,
-			    u_int32_t fresh, u_int8_t direction)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	u_int64_t ct = count;
-	u_int64_t fr = fresh;
-	u_int64_t dr = direction;
-
-	u_int64_t context[2];
-
-	context[0] = (ct << 32) | (dr << 26);
-	context[1] = fr;
-
-	start = descbuf++; /* header skip */
-
-	if (!descbuf)
-		return -1;
-
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	/* compute sequences */
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_SNOW, OP_ALG_AAI_F9,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	/* Save lower half of MAC out into a 32-bit sequence */
-	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
-				       LDST_SRCDST_BYTE_CONTEXT, 4, 4);
-
-	endidx = descbuf - start;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_snow_f9);
-
-/**
- * Kasumi/f8 as a shared descriptor
- *
- * @descbuf - pointer to descriptor-under-construction buffer
- * @bufsize - points to size to be updated at completion
- * @key - cipher key
- * @keylen - size of key in bits
- * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
- * @count - count value (32 bits)
- * @bearer - bearer ID (5 bits)
- * @direction - direction (1 bit)
- **/
-int32_t cnstr_shdsc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
-			      u_int8_t *key, u_int32_t keylen,
-			      enum algdir dir, u_int32_t count,
-			      u_int8_t bearer, u_int8_t direction)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	u_int64_t COUNT       = count;
-	u_int64_t BEARER      = bearer;
-	u_int64_t DIRECTION   = direction;
-
-	u_int64_t context = (COUNT << 32) | (BEARER << 27) | (DIRECTION << 26);
-
-	start = descbuf++; /* save start for eventual header write */
-
-	/* Verify a clean buffer */
-	if (!descbuf)
-		return -1;
-
-	/* Save current location for computing start index */
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
-					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 0);
-
-	/* Now update the header with size/offsets */
-	endidx = descbuf - start;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_kasumi_f8);
-
-/**
- * Kasumi/f9 as a shared descriptor
- *
- * @descbuf - pointer to descriptor-under-construction buffer
- * @bufsize - points to size to be updated at completion
- * @key - cipher key
- * @keylen - size of key in bits
- * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
- * @count - count value (32 bits)
- * @fresh - fresh value ID (32 bits)
- * @direction - direction (1 bit)
- **/
-int32_t cnstr_shdsc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
-			      u_int8_t *key, u_int32_t keylen,
-			      enum algdir dir, u_int32_t count,
-			      u_int32_t fresh, u_int8_t direction)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	u_int64_t ct = count;
-	u_int64_t fr = fresh;
-	u_int64_t dr = direction;
-
-	u_int64_t context[2];
-
-	context[0] = (ct << 32) | (dr << 26);
-	context[1] = fr;
-
-	start = descbuf++; /* header skip */
-
-	if (!descbuf)
-		return -1;
-
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	/* compute sequences */
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F9,
-				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
-
-	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	/* Save lower half of MAC out into a 32-bit sequence */
-	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
-				       LDST_SRCDST_BYTE_CONTEXT, 0, 4);
-
-	endidx = descbuf - start;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_kasumi_f9);
-
-/**
- * CBC blockcipher
- * @descbuf - descriptor buffer
- * @bufsize - limit/returned descriptor buffer size
- * @key     - key data to inline
- * @keylen  - key length
- * @iv      - iv data
- * @ivsize  - iv length
- * @dir     - DIR_ENCRYPT/DIR_DECRYPT
- * @cipher  - OP_ALG_ALGSEL_AES/DES/3DES
- * @clear   - clear buffer before writing
- **/
-int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
-				  u_int8_t *key, u_int32_t keylen,
-				  u_int8_t *iv, u_int32_t ivlen,
-				  enum algdir dir, u_int32_t cipher,
-				  u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	start = descbuf++; /* save start for eventual header write */
-
-	if (!descbuf)
-		return -1;
-
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	startidx = descbuf - start;
-
-	/* Insert Key */
-	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	/* Compute variable sequence */
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	/* Set cipher, AES/DES/3DES */
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG, cipher,
-				    OP_ALG_AAI_CBC, MDSTATE_INIT,
-				    ICV_CHECK_OFF, dir);
-
-	/* IV load, convert size */
-	descbuf = cmd_insert_load(descbuf, iv, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_BYTE_CONTEXT, 0, (ivlen >> 3),
-				  ITEM_INLINE);
-
-	/* Insert sequence load/store with VLF */
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
-					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 0);
-
-	/* Now update the header with size/offsets */
-	endidx = descbuf - start;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_cbc_blkcipher);
-
-/**
- * Constructs an AES-GCM shared descriptor - cnstr_shdsc_aes_gcm()
- *
- * @descbuf - pointer to buffer that will hold constructed descriptor
- * @bufsize - pointer to size of descriptor once constructed
- * @key - pointer to AES key
- * @keylen - AES key size
- * @ctx - pointer to GCM context. This is a concatenation of:
- *        - MAC (128 bits)
- *        - Yi (128 bits)
- *        - Y0 (128 bits)
- *        - IV (64 bits)
- *        - Text bitsize (64 bits)
- *        See the AESA section of the blockguide for more information
- * @mdstate - select MDSTATE_UPDATE, MDSTATE_INIT, or MDSTATE_FINAL if a
- *            partial MAC operation is desired, else select MDSTATE_COMPLETE
- * @icv - select ICV_CHECK_ON if an ICV mac compare is requested
- * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed for the cipher operation
- *
- * Input is taken from the input sequence, output is written to the output
- * sequence, and the GCM mac is appended to the output sequence
-**/
-int32_t cnstr_shdsc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
-			    u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
-			    enum mdstatesel mdstate, enum icvsel icv,
-			    enum algdir dir)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-
-	start = descbuf++;
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS1);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-			     OP_ALG_ALGSEL_AES, OP_ALG_AAI_GCM,
-			     mdstate, icv, dir);
-
-	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB, 0,
-				  LDST_SRCDST_BYTE_CONTEXT, 0, 64,
-				  ITEM_REFERENCE);
-
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
-					   LDST_VLF,
-					   FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1,
-					   0);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, FIFOLD_CLASS_SKIP,
-					    LDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 0);
-
-	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
-				       LDST_SRCDST_BYTE_CONTEXT, 0, 64);
-
-	endidx = descbuf - start;
-	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
-		       ORDER_FORWARD, DESC_STD);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_aes_gcm);
-
-
-/**
- * HMAC shared
- * @descbuf - descriptor buffer
- * @bufsize - limit/returned descriptor buffer size
- * @key     - key data to inline (length based on cipher)
- * @cipher  - OP_ALG_ALGSEL_MD5/SHA1-512
- * @icv     - HMAC comparison for ICV, NULL if no check desired
- * @clear   - clear buffer before writing
- **/
-int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
-			 u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
-			 u_int8_t clear)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t mval;
-	u_int8_t storelen;
-	enum icvsel opicv;
-
-	start = descbuf++;
-
-	if (!descbuf)
-		return -1;
-
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	/* Compute fixed-size store based on alg selection */
-	switch (cipher) {
-	case OP_ALG_ALGSEL_MD5:
-		storelen = 16;
-		break;
-
-	case OP_ALG_ALGSEL_SHA1:
-		storelen = 20;
-		break;
-
-	case OP_ALG_ALGSEL_SHA224:
-		storelen = 28;
-		break;
-
-	case OP_ALG_ALGSEL_SHA256:
-		storelen = 32;
-		break;
-
-	case OP_ALG_ALGSEL_SHA384:
-		storelen = 48;
-
-	case OP_ALG_ALGSEL_SHA512:
-		storelen = 64;
-
-	default:
-		return -1;
-	}
-
-	if (icv != NULL)
-		opicv = ICV_CHECK_ON;
-	else
-		opicv = ICV_CHECK_OFF;
-
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
-				 ITEM_CLASS2);
-
-	/* compute sequences */
-	mval = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
-				  4, 0, 0, 0, &mval);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
-				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
-				  4, 0, 0, 0, &mval);
-
-	/* Do operation */
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
-				    OP_ALG_AAI_HMAC, MDSTATE_COMPLETE,
-				    opicv, DIR_ENCRYPT);
-
-	/* Do load (variable length) */
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_2_CCB,
-					   FIFOLDST_VLF,
-					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 0);
-
-	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_2_CCB, 0,
-				       LDST_SRCDST_BYTE_CONTEXT, 0, storelen);
-
-	endidx = descbuf - start;
-
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_shdsc_hmac);
-
-/**
- * 3GPP RLC decapsulation - cnstr_pcl_shdsc_3gpp_rlc_decap()
- *
- * @descbuf - pointer to buffer for descriptor construction
- * @bufsize - size of descriptor written
- * @key - f8 cipher key
- * @keysz - size of cipher key
- * @count - f8 count value
- * @bearer - f8 bearer value
- * @direction - f8 direction value
- * @payload_sz - size of payload (this is not using VLF)
- * @clear - clear descriptor buffer before construction
- **/
-int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				       u_int8_t *key, u_int32_t keysz,
-				       u_int32_t count, u_int32_t bearer,
-				       u_int32_t direction,
-				       u_int16_t payload_sz)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t kctx[2];
-	u_int32_t ififo_cmd;
-	u_int32_t tmp_imm;
-	u_int64_t rlc_segnum_mask = 0x00000fff00000000ull;
-
-	start = descbuf++;
-
-	if (!descbuf)
-		return -1;
-
-	/* build count/bearer/direction as register-loadable words */
-	kctx[0] = count;
-	kctx[1] = ((bearer & 0x1f) << 27) | ((direction & 0x01) << 26);
-
-	startidx = descbuf - start;
-
-	/* Load the cipher key */
-	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	/* Shut off automatic Info FIFO entries */
-	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_DECOCTRL, 0x08, 0x00,
-				  ITEM_INLINE);
-
-	/* Read encrypted 83-byte RLC PDU w/header */
-	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB, 0,
-					   FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1,
-					   83);
-
-	/* Stuff info-fifo with 3-byte then payload-size flush */
-	ififo_cmd = 0x04F00003; /* FIXME: bitdefs in desc.h would be better */
-	descbuf = cmd_insert_load(descbuf, &ififo_cmd,
-				  LDST_CLASS_IND_CCB, 0,
-				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
-				  ITEM_INLINE);
-
-	ififo_cmd = 0x04f00000 | payload_sz;
-	descbuf = cmd_insert_load(descbuf, &ififo_cmd,
-				  LDST_CLASS_IND_CCB, 0,
-				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
-				  ITEM_INLINE);
-
-	/* Now load prebuilt cipher context for KFHA */
-	descbuf = cmd_insert_load(descbuf, kctx, LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_DECO_MATH0, 0, 8,
-				  ITEM_INLINE);
-
-	/* Get PDU header, left align, and store */
-	tmp_imm = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
-				  MATH_SRC1_INFIFO, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	tmp_imm = 4;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG1,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
-				  MOVE_DEST_OUTFIFO, 0, 2);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_IND_CCB, 0,
-					    FIFOST_TYPE_MESSAGE_DATA, 2);
-
-	/* wait for DMA CALM before proceeding */
-	descbuf = cmd_insert_jump(descbuf, CLASS_NONE, JUMP_TYPE_LOCAL,
-				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
-
-	/* reset output FIFO */
-	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_DECOCTRL, 0, 32,
-				  ITEM_INLINE);
-
-	/* Align sequence number with PPDB, add it, then use as c1 context */
-	tmp_imm = 19;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
-				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0, 0,
-				  (u_int32_t *)&rlc_segnum_mask);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
-				  MATH_SRC1_REG2, MATH_DEST_REG0, 8, 0, 0,
-				  0, NULL);
-
-	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH0,
-				  MOVE_DEST_CLASS1CTX, 0, 8);
-
-	/* shift sequence number left 4 */
-	tmp_imm = 16;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG1,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	tmp_imm = payload_sz; /* convert to 32-bit immediate */
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_DECO,
-				  0, LDST_SRCDST_WORD_DECO_MATH3, 0, 4,
-				  ITEM_INLINE);
-
-	/*
-	 * Top of payload loop. Process 8 bytes of payload,
-	 * shift right to M0
-	 */
-	tmp_imm = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
-				  MATH_SRC1_INFIFO, MATH_DEST_REG2,
-				  8, 0, 0, MATH_IFB, &tmp_imm);
-
-	tmp_imm = 4;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG0,
-				  8, 0, 0, MATH_IFB, &tmp_imm);
-
-	/* 64 bits to in fifo */
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_OR, MATH_SRC0_REG0,
-				  MATH_SRC1_REG1, MATH_DEST_REG1, 8, 0, 0, 0,
-				  NULL);
-
-	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
-				  MOVE_DEST_CLASS1INFIFO, 0, 8);
-
-	tmp_imm = 60;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	/* M3 = data processed */
-	tmp_imm = 8;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_REG3,
-				  MATH_SRC1_IMM, MATH_DEST_REG3, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	/* end of 8 byte processing loop, go back to top if more  */
-	descbuf = cmd_insert_jump(descbuf, CLASS_NONE, JUMP_TYPE_LOCAL,
-				  JUMP_TEST_INVALL,
-				  JUMP_COND_MATH_NV | JUMP_COND_MATH_Z,
-				  -11, NULL);
-
-	/* Get c1 data size */
-	tmp_imm = payload_sz; /* convert to 32-bit imm value */
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_1_CCB,
-				  0, LDST_SRCDST_WORD_DATASZ_REG, 0, 4,
-				  ITEM_INLINE);
-
-	/* Set up info-fifo for OP, store, wait for done */
-	ififo_cmd = 0x54f00000 | payload_sz;
-	descbuf = cmd_insert_load(descbuf, &ififo_cmd, LDST_CLASS_IND_CCB, 0,
-				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
-				    OP_ALG_AS_INITFINAL, ICV_CHECK_OFF,
-				    DIR_DECRYPT);
-
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_IND_CCB, 0,
-					    FIFOST_TYPE_MESSAGE_DATA,
-					    payload_sz);
-
-	descbuf = cmd_insert_jump(descbuf, CLASS_1, JUMP_TYPE_LOCAL,
-				  JUMP_TEST_ALL, 0, 1, NULL);
-
-	/*
-	 * Cleanup. Clear mode, and release CHA
-	 */
-	tmp_imm = 1;
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB, 0,
-				  LDST_SRCDST_WORD_CLRW, 0, 4, ITEM_INLINE);
-
-	tmp_imm = 0x10;
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB, 0,
-				  LDST_SRCDST_WORD_CHACTRL, 0, 4, ITEM_INLINE);
-
-	/* Finally, header update once length known */
-	endidx = descbuf - start;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_pcl_shdsc_3gpp_rlc_decap);
-
-int32_t cnstr_pcl_shdsc_3gpp_rlc_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				       u_int8_t *key, u_int32_t keysz,
-				       u_int32_t count, u_int32_t bearer,
-				       u_int32_t direction,
-				       u_int16_t payload_sz)
-{
-	u_int32_t *start;
-	u_int16_t startidx, endidx;
-	u_int32_t kctx[2];
-	u_int32_t tmp_imm;
-
-	start = descbuf++;
-
-	if (!descbuf)
-		return -1;
-
-	/* build count/bearer/direction as register-loadable words */
-	kctx[0] = count;
-	kctx[1] = ((bearer & 0x1f) << 27) | ((direction & 0x01) << 26);
-
-	startidx = descbuf - start;
-
-	descbuf = cmd_insert_seq_load(descbuf, LDST_CLASS_DECO, 0,
-				      LDST_SRCDST_WORD_DECO_MATH1, 0, 2);
-
-	descbuf = cmd_insert_load(descbuf, kctx, LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_DECO_MATH0, 0, 8,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT,
-				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
-				 ITEM_CLASS1);
-
-	descbuf = cmd_insert_seq_fifo_load(descbuf, CLASS_1, 0,
-					   FIFOLD_TYPE_LAST1, payload_sz);
-
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
-				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
-
-	tmp_imm = 4;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	tmp_imm = 15;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
-				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	tmp_imm = 0x0fff0000;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
-				  0, &tmp_imm);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
-				  MATH_SRC1_REG2, MATH_DEST_REG0, 8, 0, 0, 0,
-				  NULL);
-
-	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH0,
-				  MOVE_DEST_CLASS1CTX, 0, 8);
-
-	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
-				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
-				    OP_ALG_AS_INITFINAL, ICV_CHECK_OFF,
-				    DIR_ENCRYPT);
-
-	tmp_imm = payload_sz + 3;
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_DECO_MATH3, 0, 4,
-				  ITEM_INLINE);
-
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_1,
-				  JUMP_TEST_ALL, 0, 1, NULL);
-
-	tmp_imm = 1;
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB,
-				  0, LDST_SRCDST_WORD_CLRW, 0, 4,
-				  ITEM_INLINE);
-
-	tmp_imm = 0x10;
-	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB,
-				  0, LDST_SRCDST_WORD_CHACTRL, 0, 4,
-				  ITEM_INLINE);
-
-	tmp_imm = 0;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_ZERO,
-				  MATH_SRC1_REG2, MATH_DEST_REG2, 8, MATH_NFU,
-				  0, MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
-				  JUMP_TEST_ANY, JUMP_COND_MATH_Z, 2, NULL);
-
-	descbuf = cmd_insert_move(descbuf, MOVE_WAITCOMP, MOVE_SRC_OUTFIFO,
-				  MOVE_DEST_MATH2, 0, 8);
-
-	tmp_imm = 20;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG0, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_OR, MATH_SRC0_REG0,
-				  MATH_SRC1_REG1, MATH_DEST_REG1, 8, 0, 0, 0,
-				  NULL);
-
-	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1, MOVE_DEST_OUTFIFO,
-				  0, 8);
-
-	tmp_imm = 8;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_REG3,
-				  MATH_SRC1_IMM, MATH_DEST_REG3, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	tmp_imm = 44;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
-				  JUMP_TEST_ANY, JUMP_COND_MATH_NV, 4, NULL);
-
-	tmp_imm = 0xfffc;
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG3,
-				  MATH_SRC1_IMM, MATH_DEST_NONE, 4, 0, 0,
-				  MATH_IFB, &tmp_imm);
-
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
-				  JUMP_TEST_ALL, 0, -14, NULL);
-
-	descbuf = cmd_insert_seq_store(descbuf, FIFOLD_CLASS_SKIP, 0,
-				       FIFOST_TYPE_MESSAGE_DATA, 0,
-				       payload_sz + 3);
-
-	endidx = descbuf - start;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
-
-	*bufsize = endidx;
-
-	return 0;
-}
-EXPORT_SYMBOL(cnstr_pcl_shdsc_3gpp_rlc_encap);
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index 1cd2674..03e0f80 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -2,7 +2,7 @@
  * CAAM descriptor composition header
  * Definitions to support CAAM descriptor instruction generation
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
index 0993ea5..ee1540b 100644
--- a/drivers/crypto/caam/error.c
+++ b/drivers/crypto/caam/error.c
@@ -1,7 +1,7 @@
 /*
  * CAAM Error Reporting
  *
- * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,7 @@
 {								\
 	char *tmp;						\
 								\
-	tmp = kmalloc(sizeof(format) + max_alloc, GFP_ATOMIC);  \
+	tmp = kmalloc(sizeof(format) + max_alloc, GFP_ATOMIC);	\
 	sprintf(tmp, format, param);				\
 	strcat(str, tmp);					\
 	kfree(tmp);						\
@@ -70,10 +70,11 @@ static void report_ccb_status(u32 status, char *outstr)
 		"ARC4",
 		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
 		"RNG",
-		"SNOW f8, SNOW f9",
+		"SNOW f8",
 		"Kasumi f8, f9",
 		"All Public Key Algorithms",
 		"CRC",
+		"SNOW f9",
 	};
 	char *err_id_list[] = {
 		"None. No error.",
@@ -89,6 +90,8 @@ static void report_ccb_status(u32 status, char *outstr)
 		"ICV check failed.",
 		"Hardware error.",
 		"Unsupported CCM AAD size.",
+		"Class 1 CHA is not reset",
+		"Invalid CHA combination was selected",
 		"Invalid CHA selected.",
 	};
 	u8 cha_id = (status & JQSTA_CCBERR_CHAID_MASK) >>
@@ -126,51 +129,71 @@ static void report_deco_status(u32 status, char *outstr)
 		char *error_text;
 	} desc_error_list[] = {
 		{ 0x00, "None. No error." },
-		{ 0x01, "Link Length Error. The length in the links do not "
-			"equal the length in the Descriptor." },
-		{ 0x02, "Link Pointer Error. The pointer in link is Null "
-			"(Zero)." },
-		{ 0x03, "Job Queue Control Error. There is a bad value in "
-			"the Job Queue Control register." },
-		{ 0x04, "Invalid DESCRIPTOR Command. The Descriptor command "
+		{ 0x01, "SGT Length Error. The descriptor is trying to read "
+			"more data than is contained in the SGT table." },
+		{ 0x02, "Reserved." },
+		{ 0x03, "Job Ring Control Error. There is a bad value in the "
+			"Job Ring Control register." },
+		{ 0x04, "Invalid Descriptor Command. The Descriptor Command "
 			"field is invalid." },
-		{ 0x05, "Order Error. The commands in the Descriptor are out "
-			"of order." },
-		{ 0x06, "Invalid KEY Command. The key command is invalid." },
-		{ 0x07, "Invalid LOAD Command. The load command is invalid." },
-		{ 0x08, "Invalid STORE Command. The store command is "
-			"invalid." },
-		{ 0x09, "Invalid OPERATION Command. The operation command is "
-			"invalid." },
-		{ 0x0A, "Invalid FIFO LOAD Command. The FIFO load command is "
-			"invalid." },
-		{ 0x0B, "Invalid FIFO STORE Command. The FIFO store command "
-			"is invalid." },
-		{ 0x0C, "Invalid MOVE Command. The move command is invalid." },
-		{ 0x0D, "Invalid JUMP Command. The jump command is invalid." },
-		{ 0x0E, "Invalid MATH Command. The math command is invalid." },
-		{ 0x0F, "Invalid Signed Hash Command. The signed hash command "
-			"is invalid." },
-		{ 0x10, "Invalid Sequence Command. The SEQ KEY, SEQ LOAD, "
-			"SEQ FIFO LOAD, SEQ FIFIO STORE, SEQ IN PTR OR SEQ "
-			"OUT PTR command is invalid." },
-		{ 0x11, "Internal Error. There is an internal error in the "
-			"DECO block. This is a catch all." },
-		{ 0x12, "Init Header Error. The Shared Descriptor is "
-			"invalid." },
-		{ 0x13, "Header Error. Invalid length or parity." },
+		{ 0x05, "Reserved." },
+		{ 0x06, "Invalid KEY Command" },
+		{ 0x07, "Invalid LOAD Command" },
+		{ 0x08, "Invalid STORE Command" },
+		{ 0x09, "Invalid OPERATION Command" },
+		{ 0x0A, "Invalid FIFO LOAD Command" },
+		{ 0x0B, "Invalid FIFO STORE Command" },
+		{ 0x0C, "Invalid MOVE Command" },
+		{ 0x0D, "Invalid JUMP Command. A nonlocal JUMP Command is "
+			"invalid because the target is not a Job Header "
+			"Command, or the jump is from a Trusted Descriptor to "
+			"a Job Descriptor, or because the target Descriptor "
+			"contains a Shared Descriptor." },
+		{ 0x0E, "Invalid MATH Command" },
+		{ 0x0F, "Invalid SIGNATURE Command" },
+		{ 0x10, "Invalid Sequence Command. A SEQ IN PTR OR SEQ OUT PTR "
+			"Command is invalid or a SEQ KEY, SEQ LOAD, SEQ FIFO "
+			"LOAD, or SEQ FIFO STORE decremented the input or "
+			"output sequence length below 0. This error may result "
+			"if a built-in PROTOCOL Command has encountered a "
+			"malformed PDU." },
+		{ 0x11, "Skip data type invalid. The type must be 0xE or 0xF."},
+		{ 0x12, "Shared Descriptor Header Error" },
+		{ 0x13, "Header Error. Invalid length or parity, or certain "
+			"other problems." },
 		{ 0x14, "Burster Error. Burster has gotten to an illegal "
-			"state." },
-		{ 0x15, "Secure Desc Error. The signed hash of a secure "
-			"Descriptor failed." },
-		{ 0x16, "DMA Error. A DMA error was encountered." },
-		{ 0x17, "Burster IFIFO Error. Burster detected a FIFO LOAD "
-			"command and a LOAD command both trying to put data "
-			"into the input FIFO." },
-		{ 0x1A, "Job failed due to JQ reset" },
+			"state" },
+		{ 0x15, "Context Register Length Error. The descriptor is "
+			"trying to read or write past the end of the Context "
+			"Register. A SEQ LOAD or SEQ STORE with the VLF bit "
+			"set was executed with too large a length in the "
+			"variable length register (VSOL for SEQ STORE or VSIL "
+			"for SEQ LOAD)." },
+		{ 0x16, "DMA Error" },
+		{ 0x17, "Reserved." },
+		{ 0x1A, "Job failed due to JR reset" },
 		{ 0x1B, "Job failed due to Fail Mode" },
 		{ 0x1C, "DECO Watchdog timer timeout error" },
-		{ 0x80, "DNR error" },
+		{ 0x1D, "DECO tried to copy a key from another DECO but the "
+			"other DECOs Key Registers were locked" },
+		{ 0x1E, "DECO attempted to copy data from a DECO that had an "
+			"unmasked Descriptor error" },
+		{ 0x1F, "LIODN error. DECO was trying to share from itself or "
+			"from another DECO but the two Non-SEQ LIODN values "
+			"didnt match or the shared from DECOs Descriptor "
+			"required that the SEQ LIODNs be the same and they "
+			"arent." },
+		{ 0x20, "DECO has completed a reset initiated via the DRR "
+			"register" },
+		{ 0x21, "Nonce error. When using EKT (CCM) key encryption "
+			"option in the FIFO STORE Command, the Nonce counter "
+			"reached its maximum value and this encryption mode "
+			"can no longer be used." },
+		{ 0x22, "Meta data is too large (> 511 bytes) for TLS decap "
+			"(input frame; block ciphers) and IPsec decap (output "
+			"frame, when doing the next header byte update) and "
+			"DCRC (output frame)." },
+		{ 0x80, "DNR (do not run) error" },
 		{ 0x81, "undefined protocol command" },
 		{ 0x82, "invalid setting in PDB" },
 		{ 0x83, "Anti-replay LATE error" },
@@ -178,15 +201,24 @@ static void report_deco_status(u32 status, char *outstr)
 		{ 0x85, "Sequence number overflow" },
 		{ 0x86, "Sigver invalid signature" },
 		{ 0x87, "DSA Sign Illegal test descriptor" },
-		{ 0xC1, "Blob command error - Undefined mode" },
-		{ 0xC2, "Blob command error - Secure Memory Blob mode error" },
-		{ 0xC4, "Blob command error - Black Blob key or input size "
+		{ 0x88, "Protocol Format Error - A protocol has seen an error "
+			"in the format of data received. When running RSA, "
+			"this means that formatting with random padding was "
+			"used, and did not follow the form: 0x00, 0x02, 8-to-N "
+			"bytes of non-zero pad, 0x00, F data." },
+		{ 0x89, "Protocol Size Error - A protocol has seen an error in "
+			"size. When running RSA, pdb size N < (size of F) when "
+			"no formatting is used; or pdb size N < (F + 11) when "
+			"formatting is used." },
+		{ 0xC1, "Blob Command error: Undefined mode" },
+		{ 0xC2, "Blob Command error: Secure Memory Blob mode error" },
+		{ 0xC4, "Blob Command error: Black Blob key or input size "
 			"error" },
-		{ 0xC8, "Blob command error: Trusted/Secure mode error" },
-		{ 0x1D, "Shared Descriptor attempted to load key from a "
-			"locked DECO" },
-		{ 0x1E, "Shared Descriptor attempted to share data from a "
-			"DECO that had a Descriptor error" },
+		{ 0xC5, "Blob Command error: Invalid key destination" },
+		{ 0xC8, "Blob Command error: Trusted/Secure mode error" },
+		{ 0xF0, "IPsec TTL or hop limit field either came in as 0, "
+			"or was decremented to 0" },
+		{ 0xF1, "3GPP HFN matches or exceeds the Threshold" },
 	};
 	u8 desc_error = status & JQSTA_DECOERR_ERROR_MASK;
 	int i;
diff --git a/drivers/crypto/caam/error.h b/drivers/crypto/caam/error.h
index 1cbb798..3ad734d 100644
--- a/drivers/crypto/caam/error.h
+++ b/drivers/crypto/caam/error.h
@@ -1,7 +1,7 @@
 /*
  * CAAM Error Reporting code header file
  *
- * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index c74d93e..aeea96e 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -61,6 +61,7 @@ struct caam_jqentry_info {
 	void (*callbk)(struct device *dev, u32 *desc, u32 status, void *arg);
 	void *cbkarg;	/* Argument per ring entry */
 	u32 *desc_addr_virt;	/* Stored virt addr for postprocessing */
+	dma_addr_t desc_addr_dma;	/* Stored bus addr for done matching */
 	u32 desc_size;	/* Stored size for postprocessing, header derived */
 };
 
@@ -78,9 +79,11 @@ struct caam_drv_private_jq {
 	struct caam_jqentry_info *entinfo; 	/* Alloc'ed 1 per ring entry */
 	spinlock_t inplock ____cacheline_aligned; /* Input ring index lock */
 	int inp_ring_write_index;	/* Input index "tail" */
-	int *inpring;	/* Base of input ring, alloc DMA-safe */
+	int head;			/* entinfo (s/w ring) head index */
+	dma_addr_t *inpring;	/* Base of input ring, alloc DMA-safe */
 	spinlock_t outlock ____cacheline_aligned; /* Output ring index lock */
 	int out_ring_read_index;	/* Output index "tail" */
+	int tail;			/* entinfo (s/w ring) tail index */
 	struct jq_outentry *outring;	/* Base of output ring, DMA-safe */
 };
 
diff --git a/drivers/crypto/caam/jq.c b/drivers/crypto/caam/jq.c
index 0b9bff1..7be6607 100644
--- a/drivers/crypto/caam/jq.c
+++ b/drivers/crypto/caam/jq.c
@@ -2,7 +2,7 @@
  * CAAM/SEC 4.x transport/backend driver (prototype)
  * JobQ backend functionality
  *
- * Copyright (c) 2008-2010, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,7 +60,10 @@ irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
 	 * Flag a bug now, but we really need to shut down and
 	 * restart the queue (and fix code).
 	 */
-	BUG_ON(irqstate & JQINT_JQ_ERROR);
+	if (irqstate & JQINT_JQ_ERROR) {
+		dev_err(dev, "job ring error: irqstate: %08x\n", irqstate);
+		BUG();
+	}
 
 	/* mask valid interrupts */
 	setbits32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
@@ -78,7 +81,7 @@ irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
 /* Deferred service handler, run as interrupt-fired tasklet */
 void caam_jq_dequeue(unsigned long devarg)
 {
-	int jobs_in_outring, hw_idx, sw_idx, i;
+	int hw_idx, sw_idx, i, head, tail;
 	struct device *dev = (struct device *)devarg;
 	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
 	void (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);
@@ -88,27 +91,32 @@ void caam_jq_dequeue(unsigned long devarg)
 
 	spin_lock_irqsave(&jqp->outlock, flags);
 
-	jobs_in_outring = rd_reg32(&jqp->qregs->outring_used);
+	head = ACCESS_ONCE(jqp->head);
+	tail = jqp->tail;
+
+	while (CIRC_CNT(head, tail, JOBQ_DEPTH) >= 1 &&
+	       rd_reg32(&jqp->qregs->outring_used)) {
 
-	/* Processing single output entries at this time */
-	while (jobs_in_outring--) {
-		hw_idx = jqp->out_ring_read_index & (JOBQ_DEPTH - 1);
+		hw_idx = jqp->out_ring_read_index;
+		for (i = 0; CIRC_CNT(head, tail + i, JOBQ_DEPTH) >= 1; i++) {
+			sw_idx = (tail + i) & (JOBQ_DEPTH - 1);
 
-		for (i = 0; i < JOBQ_DEPTH; i++) {
-			rmb();
-			if (bus_to_virt((u32)jqp->outring[hw_idx].desc) ==
-			    jqp->entinfo[(hw_idx + i) & (JOBQ_DEPTH - 1)].
-			    desc_addr_virt)
+			smp_read_barrier_depends();
+
+			if (jqp->outring[hw_idx].desc ==
+			    jqp->entinfo[sw_idx].desc_addr_dma)
 				break; /* found */
 		}
-		BUG_ON(i == JOBQ_DEPTH); /*failed to find matching descriptor*/
-
-		sw_idx = (hw_idx + i) & (JOBQ_DEPTH - 1);
+		/* we should never fail to find a matching descriptor */
+		BUG_ON(CIRC_CNT(head, tail + i, JOBQ_DEPTH) <= 0);
 
 		/* Unmap just-run descriptor so we can post-process */
-		dma_unmap_single(dev, (u32)jqp->outring[hw_idx].desc,
+		dma_unmap_single(dev, jqp->outring[hw_idx].desc,
 				 jqp->entinfo[sw_idx].desc_size,
-				 DMA_BIDIRECTIONAL);
+				 DMA_TO_DEVICE);
+
+		/* mark completed, avoid matching on a recycled desc addr */
+		jqp->entinfo[sw_idx].desc_addr_dma = 0;
 
 		/* Stash callback params for use outside of lock */
 		usercall = jqp->entinfo[sw_idx].callbk;
@@ -116,10 +124,25 @@ void caam_jq_dequeue(unsigned long devarg)
 		userdesc = jqp->entinfo[sw_idx].desc_addr_virt;
 		userstatus = jqp->outring[hw_idx].jqstatus;
 
-		/* Remove entry from ring */
-		jqp->entinfo[sw_idx].desc_addr_virt = 0;
-		smp_wmb();
-		jqp->out_ring_read_index++;
+		smp_mb();
+
+		jqp->out_ring_read_index = (jqp->out_ring_read_index + 1) &
+					   (JOBQ_DEPTH - 1);
+
+		/*
+		 * if this job completed out-of-order, do not increment
+		 * the tail.  Otherwise, increment tail by 1 plus the
+		 * number of subsequent jobs already completed out-of-order
+		 */
+		if (sw_idx == tail) {
+			do {
+				tail = (tail + 1) & (JOBQ_DEPTH - 1);
+				smp_read_barrier_depends();
+			} while (CIRC_CNT(head, tail, JOBQ_DEPTH) >= 1 &&
+				 jqp->entinfo[tail].desc_addr_dma == 0);
+
+			jqp->tail = tail;
+		}
 
 		/* set done */
 		wr_reg32(&jqp->qregs->outring_rmvd, 1);
@@ -130,6 +153,9 @@ void caam_jq_dequeue(unsigned long devarg)
 		usercall(dev, userdesc, userstatus, userarg);
 
 		spin_lock_irqsave(&jqp->outlock, flags);
+
+		head = ACCESS_ONCE(jqp->head);
+		tail = jqp->tail;
 	}
 
 	spin_unlock_irqrestore(&jqp->outlock, flags);
@@ -138,7 +164,7 @@ void caam_jq_dequeue(unsigned long devarg)
 		preempt_disable();
 		tasklet_schedule(&jqp->irqtask[smp_processor_id()]);
 		preempt_enable();
-	
+
 		return;
 	}
 
@@ -252,56 +278,48 @@ EXPORT_SYMBOL(caam_jq_deregister);
 				u32 status, void *areq),
 		    void *areq)
 {
-	struct caam_drv_private_jq *jqp;
+	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
+	struct caam_jqentry_info *head_entry;
 	unsigned long flags;
-	int idx;
+	int head, tail, desc_size;
+	dma_addr_t desc_dma;
 
-	jqp = dev_get_drvdata(dev);
-
-	/*
-	 * Write the entry to the ring and update the index
-	 * Note that the index is hardware-calculated
-	 */
-
-	if (!rd_reg32(&jqp->qregs->inpring_avail))
-		return -EBUSY; /* No room */
+	desc_size = (*desc & HDR_JD_LENGTH_MASK) * sizeof(u32);
+	desc_dma = dma_map_single(dev, desc, desc_size, DMA_TO_DEVICE);
+	if (dma_mapping_error(dev, desc_dma)) {
+		dev_err(dev, "caam_jq_enqueue(): can't map jobdesc\n");
+		return -EIO;
+	}
 
-	/*
-	 * Write entry to the tail, and "start" it
-	 * TODO: should be able to walk a list, but maps only
-	 * one jobdesc at a time for now
-	 */
 	spin_lock_irqsave(&jqp->inplock, flags);
-	idx = jqp->inp_ring_write_index & (JOBQ_DEPTH - 1);
 
-	if (jqp->entinfo[idx].desc_addr_virt != 0) {
-		spin_unlock_irqrestore(&jqp->inplock, flags);
-		return -EBUSY; /* no room */
-	}
+	head = jqp->head;
+	tail = ACCESS_ONCE(jqp->tail);
 
-	/* Store off info that the tasklet will need */
-	jqp->entinfo[idx].desc_addr_virt = desc;
-	jqp->entinfo[idx].desc_size = (*desc & HDR_JD_LENGTH_MASK) *
-				       sizeof(u32);
-	jqp->entinfo[idx].callbk = (void *)cbk;
-	jqp->entinfo[idx].cbkarg = areq;
-
-	/* Map and start descriptor */
-	jqp->inpring[idx] = dma_map_single(dev, desc,
-					   (*desc & HDR_JD_LENGTH_MASK) *
-					    sizeof(u32),
-					   DMA_BIDIRECTIONAL);
-	if (dma_mapping_error(dev, jqp->inpring[idx])) {
-		dev_err(dev,
-			"caam_jq_enqueue(): can't map jobdesc\n");
+	if (!rd_reg32(&jqp->qregs->inpring_avail) ||
+	    CIRC_SPACE(head, tail, JOBQ_DEPTH) <= 0) {
 		spin_unlock_irqrestore(&jqp->inplock, flags);
-		return -EIO;
+		dma_unmap_single(dev, desc_dma, desc_size, DMA_TO_DEVICE);
+		return -EBUSY;
 	}
-	/* Bump/wrap index and unlock */
+
+	head_entry = &jqp->entinfo[head];
+	head_entry->desc_addr_virt = desc;
+	head_entry->desc_size = desc_size;
+	head_entry->callbk = (void *)cbk;
+	head_entry->cbkarg = areq;
+	head_entry->desc_addr_dma = desc_dma;
+
+	jqp->inpring[jqp->inp_ring_write_index] = desc_dma;
+
 	smp_wmb();
-	jqp->inp_ring_write_index++;
+
+	jqp->inp_ring_write_index = (jqp->inp_ring_write_index + 1) &
+				    (JOBQ_DEPTH - 1);
+	jqp->head = (head + 1) & (JOBQ_DEPTH - 1);
 
 	wmb();
+
 	wr_reg32(&jqp->qregs->inpring_jobadd, 1);
 
 	spin_unlock_irqrestore(&jqp->inplock, flags);
@@ -310,18 +328,53 @@ EXPORT_SYMBOL(caam_jq_deregister);
 }
 EXPORT_SYMBOL(caam_jq_enqueue);
 
+static int caam_reset_hw_jq(struct device *dev)
+{
+	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
+	unsigned int timeout = 100000;
+
+	/* initiate flush (required prior to reset) */
+	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET);
+	while (((rd_reg32(&jqp->qregs->jqintstatus) & JQINT_ERR_HALT_MASK) ==
+		JQINT_ERR_HALT_INPROGRESS) && --timeout)
+		cpu_relax();
+
+	if ((rd_reg32(&jqp->qregs->jqintstatus) & JQINT_ERR_HALT_MASK) !=
+	    JQINT_ERR_HALT_COMPLETE || timeout == 0) {
+		dev_err(dev, "failed to flush job queue %d\n", jqp->qidx);
+		return -EIO;
+	}
+
+	/* initiate reset */
+	timeout = 100000;
+	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET);
+	while ((rd_reg32(&jqp->qregs->jqcommand) & JQCR_RESET) && --timeout)
+		cpu_relax();
+
+	if (timeout == 0) {
+		dev_err(dev, "failed to reset job queue %d\n", jqp->qidx);
+		return -EIO;
+	}
+
+	return 0;
+}
+
 /*
  * Init JobQ independent of platform property detection
  */
 int caam_jq_init(struct device *dev)
 {
 	struct caam_drv_private_jq *jqp;
-	u32 inpbusaddr, outbusaddr;
+	dma_addr_t inpbusaddr, outbusaddr;
 	int i, error;
 
 	jqp = dev_get_drvdata(dev);
 
-	jqp->inpring = kzalloc(sizeof(u32 *) * JOBQ_DEPTH,
+	error = caam_reset_hw_jq(dev);
+	if (error)
+		return error;
+
+	jqp->inpring = kzalloc(sizeof(dma_addr_t) *JOBQ_DEPTH,
 			       GFP_KERNEL | GFP_DMA);
 	jqp->outring = kzalloc(sizeof(struct jq_outentry) *
 			       JOBQ_DEPTH, GFP_KERNEL | GFP_DMA);
@@ -336,6 +389,9 @@ int caam_jq_init(struct device *dev)
 		return -ENOMEM;
 	}
 
+	for (i = 0; i < JOBQ_DEPTH; i++)
+		jqp->entinfo[i].desc_addr_dma = !0;
+
 	/* Setup rings */
 	inpbusaddr = dma_map_single(dev, jqp->inpring,
 				    sizeof(u32 *) * JOBQ_DEPTH,
@@ -364,6 +420,8 @@ int caam_jq_init(struct device *dev)
 
 	jqp->inp_ring_write_index = 0;
 	jqp->out_ring_read_index = 0;
+	jqp->head = 0;
+	jqp->tail = 0;
 
 	wr_reg64(&jqp->qregs->inpring_base, inpbusaddr);
 	wr_reg64(&jqp->qregs->outring_base, outbusaddr);
@@ -392,9 +450,9 @@ int caam_jq_init(struct device *dev)
 		irq_dispose_mapping(jqp->irq);
 		jqp->irq = 0;
 		dma_unmap_single(dev, inpbusaddr, sizeof(u32 *) * JOBQ_DEPTH,
-		                 DMA_BIDIRECTIONAL);
+				 DMA_BIDIRECTIONAL);
 		dma_unmap_single(dev, outbusaddr, sizeof(u32 *) * JOBQ_DEPTH,
-		                 DMA_BIDIRECTIONAL);
+				 DMA_BIDIRECTIONAL);
 		kfree(jqp->inpring);
 		kfree(jqp->outring);
 		kfree(jqp->entinfo);
@@ -410,17 +468,10 @@ int caam_jq_init(struct device *dev)
  */
 int caam_jq_shutdown(struct device *dev)
 {
-	struct caam_drv_private_jq *jqp;
-	u32 i, used;
-
-	jqp = dev_get_drvdata(dev);
+	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
+	int ret, i;
 
-	/* Stop ring. This just does a blunt flush of output entries */
-	wr_reg32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
-	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET); /* initiate flush */
-	used = rd_reg32(&jqp->qregs->outring_used);
-	wr_reg32(&jqp->qregs->outring_rmvd, used);
-	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET); /* complete flush */
+	ret = caam_reset_hw_jq(dev);
 
 	for_each_possible_cpu(i)
 		tasklet_kill(&jqp->irqtask[i]);
@@ -438,7 +489,7 @@ int caam_jq_shutdown(struct device *dev)
 	kfree(jqp->inpring);
 	kfree(jqp->entinfo);
 
-	return 0;
+	return ret;
 }
 
 /*
diff --git a/drivers/crypto/caam/jq.h b/drivers/crypto/caam/jq.h
index 9c83556..764c796 100644
--- a/drivers/crypto/caam/jq.h
+++ b/drivers/crypto/caam/jq.h
@@ -1,7 +1,7 @@
 /*
  * CAAM public-level include definitions for the JobQ backend
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/crypto/caam/jq_test/Makefile b/drivers/crypto/caam/jq_test/Makefile
deleted file mode 100644
index aaf0af2..0000000
--- a/drivers/crypto/caam/jq_test/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-
-obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_JQ_TEST) += caam_jq_test.o
-
-caam_jq_test-objs := caam_jqtest.o jq_ipsec.o jq_snow.o jq_blkcipher.o
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.c b/drivers/crypto/caam/jq_test/caam_jqtest.c
deleted file mode 100644
index 78b3112..0000000
--- a/drivers/crypto/caam/jq_test/caam_jqtest.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * caam_jqtest.c - Top-level code for a JobQ unit test
- *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-
-#include "caam_jqtest.h"
-
-#define JQTEST_CYCLES 3
-
-static int __init caam_jqtest(void)
-{
-	int stat, i, q, owned_queues, qid[4];
-	struct device *qdev[4], *ctrldev;
-	struct device_node *ctrlnode;
-	struct of_device *ofdev;
-
-	/* Find a CAAM instance via device tree */
-	ctrlnode = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
-	if (ctrlnode == NULL) {
-		printk(KERN_INFO "caam_jqtest: no compatible node found\n");
-		return -1;
-	}
-	ofdev = of_find_device_by_node(ctrlnode);
-	if (ofdev == NULL) {
-		printk(KERN_INFO "caam_jqtest: no device found\n");
-		return -1;
-	}
-	ctrldev = &ofdev->dev;
-
-	/* Get all the queues available */
-	owned_queues = 0;
-	for (q = 0; q < 4; q++) {
-		qid[q] = caam_jq_register(ctrldev, &qdev[q]);
-		if (qid[q] >= 0)
-			owned_queues++;
-	}
-
-	if (!owned_queues) {
-		printk(KERN_INFO "caam_jqtest: no queues available\n");
-		return -1;
-	}
-
-	/* Now run cases */
-	printk(KERN_INFO "caam_jqtest: running cases on %d available queues\n",
-	       owned_queues);
-	for (q = 0; q < owned_queues; q++) {
-		for (i = 0; i < JQTEST_CYCLES; i++) {
-
-			stat = jq_ipsec_esp_split(qdev[q], NO_SHOW_DESC);
-			if (stat)
-				printk(KERN_INFO
-				"jq_ipsec_esp_noterm: fail on queue %d\n",
-				qid[q]);
-
-			stat = jq_aes_cbc_shared(qdev[q], NO_SHOW_DESC);
-			if (stat)
-				printk(KERN_INFO
-				       "jq_aes_cbc_shared: fail on queue %d\n",
-				       qid[q]);
-
-			stat = jq_aes_cbc_job(qdev[q], NO_SHOW_DESC);
-			if (stat)
-				printk(KERN_INFO
-				       "jq_aes_cbc_job: fail on queue %d\n",
-				       qid[q]);
-
-			stat = jq_snow_f8(qdev[q], NO_SHOW_DESC);
-			if (stat)
-				printk(KERN_INFO
-				       "jq_snow_f8: fail on queue %d\n",
-				       qid[q]);
-
-			stat = jq_snow_f9(qdev[q], NO_SHOW_DESC);
-			if (stat)
-				printk(KERN_INFO
-				       "jq_snow_f9: fail on queue %d\n",
-				       qid[q]);
-
-		}
-		printk(KERN_INFO "caam_jqtest: %d cycles on queue %d\n", i, q);
-	}
-
-	/* Deregister, release queues */
-	for (q = 0; q < owned_queues; q++)
-		caam_jq_deregister(qdev[q]);
-
-	return 0;
-}
-
-static void __exit caam_jqtest_remove(void)
-{
-	return;
-}
-
-module_init(caam_jqtest);
-module_exit(caam_jqtest_remove);
-
-MODULE_LICENSE("Dual BSD/GPL");
-MODULE_DESCRIPTION("FSL CAAM JobQ Test Module");
-MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.h b/drivers/crypto/caam/jq_test/caam_jqtest.h
deleted file mode 100644
index a762ee7..0000000
--- a/drivers/crypto/caam/jq_test/caam_jqtest.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * caam_jqtest.h - central header for the JobQ unit test module
- *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef CAAM_JQTEST_H
-#define CAAM_JQTEST_H
-
-#include "../compat.h"
-#include "../desc.h"
-#include "../pdb.h"
-#include "../dcl/dcl.h"
-#include "../jq.h"
-#include "../error.h"
-
-#define SHOW_DESC 1
-#define NO_SHOW_DESC 0
-
-int jq_ipsec_esp_split(struct device *dev, int showdesc);
-int jq_snow_f8(struct device *dev, int showdesc);
-int jq_snow_f9(struct device *dev, int show);
-int jq_aes_cbc_shared(struct device *dev, int show);
-int jq_aes_cbc_job(struct device *dev, int show);
-
-#endif /* CAAM_JQTEST_H */
diff --git a/drivers/crypto/caam/jq_test/jq_blkcipher.c b/drivers/crypto/caam/jq_test/jq_blkcipher.c
deleted file mode 100644
index f050da6..0000000
--- a/drivers/crypto/caam/jq_test/jq_blkcipher.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * jq_blkcipher.c - JobQ unit test for blockcipher examples
- *
- * Copyright (c) 2009, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "caam_jqtest.h"
-
-static const u_int8_t in[] = {
-	0xC4, 0x75, 0xC5, 0xFA, 0x30, 0x86, 0x21, 0x3F,
-	0x1A, 0xEC, 0xDA, 0xA1, 0x0E, 0xBF, 0xF3, 0x71,
-	0xF3, 0x58, 0xB5, 0x81, 0xAA, 0x39, 0x95, 0x2B,
-	0x6D, 0x82, 0xB3, 0x36, 0x0F, 0xD5, 0xCF, 0xDE,
-	0xCD, 0x3F, 0x96, 0x83, 0xEA, 0x2F, 0x69, 0xFA,
-	0x78, 0xCE, 0xF5, 0x63, 0xBC, 0xFF, 0x89, 0xD1,
-	0xE9, 0x6F, 0xDC, 0xF1, 0x74, 0x08, 0xB9, 0x95,
-	0x78, 0x89, 0x80, 0xFD, 0xE6, 0x54, 0xFA, 0x45,
-	0xCF, 0x55, 0x43, 0xEE, 0xCA, 0x25, 0x0C, 0x26,
-	0xF4, 0x91, 0xF2, 0xCC, 0x12, 0xC3, 0x15, 0x8A,
-	0xAB, 0x84, 0xD4, 0xF5, 0x41, 0xF0, 0x28, 0xC2,
-	0x0A, 0x7A, 0x52, 0xC3, 0xB4, 0x81, 0xFC, 0xF0,
-	0x33, 0xFA, 0x6F, 0x34, 0x42, 0xF7, 0x42, 0xEF,
-	0xEE, 0xF2, 0x14, 0x21, 0x11, 0xF0, 0xBB, 0xF5,
-	0x7A, 0x07, 0xE6, 0x43, 0x6A, 0xD3, 0xCD, 0x18,
-	0x8C, 0x8E, 0xD7, 0x38, 0x3B, 0x76, 0xD5, 0x1E,
-	0x18, 0x77, 0x38, 0x60, 0x5F, 0xB4, 0xC6, 0x12,
-	0xF2, 0x2F, 0xB0, 0xD0, 0x49, 0xD2, 0xF4, 0x01,
-	0x02, 0x8E, 0xC6, 0x29, 0x1B, 0x13, 0xC6, 0x7A,
-	0x3E, 0xF0, 0xA9, 0xC9, 0x33, 0x16, 0xCB, 0x3B,
-	0x21, 0xB6, 0x58, 0xB8, 0xD7, 0xE5, 0xC0, 0x5E,
-	0x03, 0x9A, 0x6D, 0x23, 0x70, 0x4E, 0xDC, 0x64,
-	0xAD, 0xA8, 0x2F, 0x5B, 0x2F, 0x0D, 0x38, 0xB3,
-	0x07, 0x5E, 0x17, 0x28, 0x34, 0x77, 0xF4, 0xAE,
-	0xCA, 0xEC, 0x87, 0x35, 0x87, 0xBC, 0x0C, 0x5A,
-	0x7F, 0xEC, 0x9B, 0x3C, 0x3A, 0xCF, 0xA1, 0x04,
-	0x30, 0xFD, 0x3C, 0x50, 0x3F, 0xC9, 0x8B, 0x20,
-	0x16, 0x63, 0x7E, 0x33, 0x57, 0x6E, 0xB7, 0x83,
-	0xBD, 0x11, 0x7B, 0x13, 0x25, 0x15, 0xCD, 0x59,
-	0x06, 0xC8, 0x43, 0xAD, 0x89, 0x9A, 0x46, 0x7C
-};
-
-static const u_int8_t out[] = {
-	0x10, 0x92, 0x99, 0xE1, 0xA2, 0x38, 0x29, 0xCC,
-	0x32, 0x4B, 0xE2, 0x94, 0xA9, 0xE3, 0x9D, 0xBE,
-	0x86, 0x96, 0x1C, 0x60, 0x3A, 0xF8, 0x3C, 0x67,
-	0x3F, 0x6D, 0x7B, 0x34, 0x74, 0x69, 0x4C, 0x8D,
-	0xF1, 0x35, 0x07, 0xB4, 0xB3, 0xD1, 0x0C, 0xB3,
-	0x68, 0x6F, 0x5A, 0x95, 0xD8, 0xA8, 0x0F, 0x99,
-	0xAD, 0x7B, 0xE1, 0x04, 0x05, 0x82, 0x90, 0x06,
-	0xC9, 0xB3, 0x35, 0x34, 0xCE, 0xF0, 0xB2, 0x67,
-	0xA3, 0xF5, 0xDC, 0xFF, 0x4F, 0xDD, 0xEF, 0x5D,
-	0x11, 0x08, 0xB4, 0x9B, 0x7E, 0x7C, 0xAE, 0x78,
-	0x2A, 0x25, 0x9F, 0xF3, 0x24, 0x22, 0x4D, 0xFC,
-	0x23, 0x37, 0x9E, 0xA5, 0xD6, 0xF2, 0xC5, 0x2F,
-	0x7D, 0xB5, 0x32, 0x7B, 0xE8, 0x6A, 0x1B, 0x5A,
-	0xEB, 0xE0, 0x54, 0x2F, 0x25, 0xFD, 0x94, 0xD5,
-	0x8D, 0x71, 0x41, 0x04, 0x75, 0x35, 0xAF, 0x79,
-	0xB7, 0x4B, 0xEE, 0x93, 0xC6, 0x21, 0xE8, 0x99,
-	0xAE, 0x9F, 0xD4, 0xEF, 0x11, 0xEE, 0xD2, 0x17,
-	0x94, 0xC7, 0x42, 0x81, 0xF8, 0x90, 0xA4, 0x56,
-	0xB3, 0x46, 0x10, 0x00, 0x91, 0xDD, 0x2D, 0x31,
-	0x96, 0x72, 0xA1, 0xEF, 0xD2, 0xB2, 0x1C, 0x69,
-	0xA8, 0x76, 0x72, 0xC9, 0x01, 0x1C, 0xD0, 0x8C,
-	0x0D, 0x96, 0x18, 0x63, 0x93, 0x37, 0x42, 0x0E,
-	0x2B, 0x39, 0xB6, 0x23, 0xDA, 0xF7, 0xBB, 0x6B,
-	0xEA, 0x7E, 0x89, 0xE9, 0xEC, 0x58, 0xAE, 0xC1,
-	0x57, 0x1A, 0x21, 0x2A, 0x6D, 0x1D, 0xF1, 0x1B,
-	0x14, 0xCD, 0xC0, 0xB4, 0x28, 0x0C, 0x69, 0x33,
-	0x47, 0x42, 0x6F, 0x4F, 0x67, 0x63, 0x3F, 0x96,
-	0x89, 0xD4, 0x03, 0x31, 0xBB, 0x8C, 0x9F, 0x79,
-	0xEC, 0xAA, 0xE7, 0x07, 0xCE, 0x62, 0x42, 0x8E,
-	0x49, 0xD7, 0x8E, 0x7C, 0x4B, 0x3E, 0xDE, 0x05
-};
-
-static const u_int8_t iv[] = {
-	0x75, 0x16, 0x99, 0x21, 0x49, 0x73, 0x71, 0x63,
-	0x1E, 0x7F, 0xC6, 0x9E, 0x2C, 0xB4, 0xDF, 0x24
-};
-
-static const u_int8_t key[] = {
-	0xEF, 0x4A, 0x6F, 0x4A, 0x52, 0x32, 0xE8, 0x0E,
-	0x2E, 0x3A, 0x3B, 0xF4, 0x00, 0x5E, 0xA7, 0x74,
-	0xFB, 0x93, 0xFE, 0x1C, 0x4D, 0xAD, 0xA3, 0x02,
-	0xE4, 0xF5, 0x71, 0xD7, 0xE6, 0x07, 0xF6, 0x87
-};
-
-#define AES_TESTSET_SIZE 240
-#define AES_KEY_SIZE 32
-#define AES_IV_SIZE 16
-
-static struct completion completion;
-
-void jq_blkcipher_done(struct device *dev, u32 *head, u32 status, void *auxarg)
-{
-	/* Write back returned status, and continue */
-	*(u32 *)auxarg = status;
-	complete(&completion);
-}
-
-int jq_aes_cbc_shared(struct device *dev, int show)
-{
-	int stat, exit, rtnval = 0;
-	u32 *sdesc, *jdesc, *sdmap, *jdmap;
-	u8 *inbuf, *outbuf, *inmap, *outmap;
-	u16 sdsz, jdsz, inbufsz, outbufsz;
-	u32 rqstatus;
-	u8 err[256];
-	u8 testname[] = "jq_aes_cbc_shared";
-
-	sdsz = 64 * sizeof(u32);
-	jdsz = 16 * sizeof(u32);
-	inbufsz = AES_TESTSET_SIZE;
-	outbufsz = AES_TESTSET_SIZE;
-
-	init_completion(&completion);
-
-	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
-	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
-
-
-	if ((sdesc == NULL) || (jdesc == NULL) ||
-	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "%s: can't get buffers\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		return -1;
-	};
-
-	memcpy(inbuf, in, inbufsz);
-	memset(outbuf, 0, outbufsz);
-
-	stat = cnstr_shdsc_cbc_blkcipher(sdesc, &sdsz, (u_int8_t *)key,
-					 AES_KEY_SIZE * 8,
-					 (u_int8_t *)iv, AES_IV_SIZE * 8,
-					 DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: sharedesc construct failed\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		return -1;
-	};
-
-	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
-	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
-
-	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
-			  outmap, outbufsz);
-
-	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
-
-	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
-	}
-
-	init_completion(&completion);
-
-	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done,
-			       (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit)
-		printk(KERN_INFO "%s: interrupted\n", testname);
-
-	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
-	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
-
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
-		       rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-	} else
-		if (memcmp(out, outbuf, outbufsz)) {
-			printk(KERN_INFO "%s: output mismatch\n", testname);
-			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
-			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
-		}
-
-	kfree(sdesc);
-	kfree(jdesc);
-	kfree(inbuf);
-	kfree(outbuf);
-
-	return rtnval;
-}
-
-int jq_aes_cbc_job(struct device *dev, int show)
-{
-	int stat, exit, rtnval = 0;
-	u32 *jdesc;
-	u8 *inbuf, *outbuf, *inmap, *outmap;
-	u8 *keybuf, *keymap, *ivbuf, *ivmap;
-	u16 jdsz, inbufsz, outbufsz;
-	u32 rqstatus;
-	u8 err[256];
-	u8 testname[] = "jq_aes_cbc_job";
-
-	init_completion(&completion);
-
-	jdsz = 64 * sizeof(u32);
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
-
-	inbufsz = AES_TESTSET_SIZE;
-	outbufsz = AES_TESTSET_SIZE;
-	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
-	keybuf = kzalloc(AES_KEY_SIZE, GFP_KERNEL | GFP_DMA);
-	ivbuf = kzalloc(AES_IV_SIZE, GFP_KERNEL | GFP_DMA);
-
-	if ((jdesc == NULL) || (inbuf == NULL) || (outbuf == NULL) ||
-	    (keybuf == NULL) || (ivbuf == NULL)) {
-		printk(KERN_INFO "%s: can't get buffers\n", testname);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		kfree(keybuf);
-		kfree(ivbuf);
-		return -1;
-	};
-
-	memcpy(inbuf, in, inbufsz);
-	memcpy(keybuf, key, AES_KEY_SIZE);
-	memcpy(ivbuf, iv, AES_IV_SIZE);
-	memset(outbuf, 0, outbufsz);
-
-	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
-	keymap = (u8 *)dma_map_single(dev, keybuf, AES_KEY_SIZE, DMA_TO_DEVICE);
-	ivmap = (u8 *)dma_map_single(dev, ivbuf, AES_IV_SIZE, DMA_TO_DEVICE);
-
-	stat = cnstr_jobdesc_blkcipher_cbc(jdesc, &jdsz, inmap, outmap,
-					   AES_TESTSET_SIZE,
-					   (u_int8_t *)keymap,
-					   AES_KEY_SIZE * 8,
-					   (u_int8_t *)ivmap, AES_IV_SIZE * 8,
-					   DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: jobdesc construct failed\n", testname);
-		kfree(jdesc);
-		return -1;
-	};
-
-	if (show == SHOW_DESC)
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-
-	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done,
-			       (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit)
-		printk(KERN_INFO "%s: interrupted\n", testname);
-
-	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
-	dma_unmap_single(dev, (u32)keymap, AES_KEY_SIZE, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)ivmap, AES_IV_SIZE, DMA_TO_DEVICE);
-
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
-		       rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-	} else
-		if (memcmp(out, outbuf, outbufsz)) {
-			printk(KERN_INFO "%s: output mismatch\n", testname);
-			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
-			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
-		}
-
-	kfree(jdesc);
-	kfree(inbuf);
-	kfree(outbuf);
-	kfree(keybuf);
-	kfree(ivbuf);
-
-	return rtnval;
-}
diff --git a/drivers/crypto/caam/jq_test/jq_ipsec.c b/drivers/crypto/caam/jq_test/jq_ipsec.c
deleted file mode 100644
index f3ba49a..0000000
--- a/drivers/crypto/caam/jq_test/jq_ipsec.c
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- * jq_ipsec.c - JobQ unit test for termination-less IPSec examples
- *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "caam_jqtest.h"
-
-
-/* Class 2 padded all the way out to 64 bytes */
-static u8 class_2_key[] = {
-	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
-	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
-	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
-	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
-	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
-	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
-	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f };
-
-static u8 class_1_key[] = {
-	0x00, 0x0e, 0x0f, 0x00, 0x0c, 0x0f, 0x0a, 0x00,
-	0x0a, 0x0f, 0x0a, 0x00, 0x0b, 0x0f, 0x0a, 0x00 };
-
-#define OPTHDRSZ 52
-static const u_int8_t opthdr[] = {
-	0x34, 0x00, 0x10, 0x45, 0x00, 0x40, 0x25, 0x12,
-	0xd2, 0x86, 0x06, 0x40, 0x77, 0x46, 0x43, 0x0a,
-	0xc0, 0x46, 0x43, 0x0a, 0x16, 0x00, 0x22, 0xd0,
-	0x5d, 0x89, 0x18, 0x88, 0x9c, 0xee, 0x19, 0x12,
-	0xbc, 0x21, 0x10, 0x80, 0x00, 0x00, 0x08, 0x98,
-	0x0a, 0x08, 0x01, 0x01, 0x22, 0x75, 0x9a, 0xa6,
-	0xdb, 0x14, 0x3f, 0x08
-};
-
-static const u_int8_t incmp[] = {
-	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
-	0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x06, 0x07,
-	0x18, 0x19, 0x0a, 0x0b, 0x1c, 0x1d, 0x0e, 0x0f,
-	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
-	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
-	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
-	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-};
-
-static struct completion completion;
-
-void jq_ipsec_done(struct device *dev, u32 *head, u32 status, void *auxarg)
-{
-	/* Write back returned status, and continue */
-	*(u32 *)auxarg = status;
-	complete(&completion);
-}
-
-#define SHA1_HMAC_KEYSZ 20
-#define SHA1_HMAC_PADSZ 20
-#define SHA224_HMAC_KEYSZ 28
-#define SHA224_HMAC_PADSZ 32
-#define SHA256_HMAC_KEYSZ 32
-#define SHA256_HMAC_PADSZ 32
-#define SHA384_HMAC_KEYSZ 48
-#define SHA384_HMAC_PADSZ 64
-#define SHA512_HMAC_KEYSZ 64
-#define SHA512_HMAC_PADSZ 64
-
-#define AES_KEYSZ 16
-
-int jq_ipsec_esp_split(struct device *dev, int show)
-{
-	int stat, exit, rtnval = 0;
-	u32 *jdesc, *jdmap, *encapdesc, *encapdmap, *decapdesc, *decapdmap;
-	u32 rqstatus;
-	u8 *hmackeybuf, *spkeybuf, *hmackeymap, *spkeymap;
-	u8 *inbuf, *encapbuf, *decapbuf, *inmap, *encapmap, *decapmap;
-	u8 *cipherkeybuf, *cipherkeymap;
-	u16 jdsz, encapdsz, decapdsz, cipherkeysz, hmackeysz;
-	u16 padsz, inbufsz, encapbufsz, decapbufsz;
-	struct ipsec_encap_pdb encappdb;
-	struct ipsec_decap_pdb decappdb;
-	struct authparams auth;
-	struct cipherparams cipher;
-	u8 err[256];
-	u8 testname[] = "jq_ipsec_esp_split";
-
-	init_completion(&completion);
-
-	/*
-	 * Compute buffer/descriptor sizes
-	 */
-	cipherkeysz = AES_KEYSZ;
-	hmackeysz = SHA1_HMAC_KEYSZ;
-	padsz = SHA1_HMAC_PADSZ;
-	inbufsz = 64;
-	encapbufsz = 8+16+inbufsz+28; /* payload+SPI+IV+pad+padlen+ICV */
-	decapbufsz = inbufsz;
-
-	jdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
-	encapdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
-	decapdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
-
-	/*
-	 * Alloc buffer/descriptor space
-	 */
-	hmackeybuf = kmalloc(hmackeysz, GFP_KERNEL | GFP_DMA);
-	cipherkeybuf = kmalloc(cipherkeysz, GFP_KERNEL | GFP_DMA);
-	spkeybuf = kmalloc(padsz, GFP_KERNEL | GFP_DMA);
-	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	encapbuf = kmalloc(encapbufsz, GFP_KERNEL | GFP_DMA);
-	decapbuf = kmalloc(decapbufsz, GFP_KERNEL | GFP_DMA);
-
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
-	encapdesc = kzalloc(encapdsz, GFP_KERNEL | GFP_DMA);
-	decapdesc = kzalloc(decapdsz, GFP_KERNEL | GFP_DMA);
-
-	if ((hmackeybuf == NULL) || (cipherkeybuf == NULL) ||
-	    (spkeybuf == NULL) || (jdesc == NULL) || (encapdesc == NULL) ||
-	    (decapdesc == NULL) || (inbuf == NULL) || (encapbuf == NULL) ||
-	    (decapbuf == NULL)) {
-		printk(KERN_INFO "%s: can't get buffers\n", testname);
-		rtnval = -1;
-		goto freeup;
-	};
-
-	/*
-	 * First step, generate MD split-key for shared descriptors to use
-	 * Precoat key buffer
-	 */
-	memcpy(hmackeybuf, class_2_key, hmackeysz);
-
-	/* Map job, input key, output splitkey */
-	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
-	hmackeymap = (u8 *)dma_map_single(dev, hmackeybuf, hmackeysz,
-					  DMA_TO_DEVICE);
-	spkeymap = (u8 *)dma_map_single(dev, spkeybuf, padsz,
-					DMA_FROM_DEVICE);
-
-	/*
-	 * Construct keysplitter using mapped HMAC input buffer
-	 * and mapped split key output buffer
-	 */
-	stat = cnstr_jobdesc_mdsplitkey(jdesc, &jdsz, hmackeymap,
-					OP_ALG_ALGSEL_SHA1, spkeymap);
-
-	if (show == SHOW_DESC)
-		caam_desc_disasm(jdesc, DISASM_SHOW_RAW | DISASM_SHOW_OFFSETS);
-
-	/* Execute keysplitter */
-	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit) {
-		printk(KERN_INFO "%s interrupted\n", testname);
-		rtnval = -1;
-	}
-
-	/* Unmap splitter desc, input key, output splitkey */
-	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)hmackeymap, hmackeysz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)spkeymap, padsz, DMA_FROM_DEVICE);
-
-	/* If problem, report, free jobdesc and splitkey, return */
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
-		       rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-		goto freeup;
-	}
-
-	/*
-	 * Now we have a covered HMAC split key. Build our encapsulation
-	 * and decapsulation descriptors
-	 */
-
-	/* Precoat blockcipher key */
-	memcpy(cipherkeybuf, class_1_key, cipherkeysz);
-
-	/*
-	 * Set up a PDB for the encapsulation side. In this case, am not
-	 * doing header prepend
-	 */
-	memset(&encappdb, 0, sizeof(encappdb));
-	/* encappdb.options = PDBOPTS_ESPCBC_TUNNEL; */
-	/* encappdb.opt_hdr_len = OPTHDRSZ; */
-	encappdb.cbc.iv[0] = 0x01234569;
-	encappdb.cbc.iv[1] = 0x89abcdef;
-	encappdb.cbc.iv[2] = 0xfedcba98;
-	encappdb.cbc.iv[3] = 0x76543210;
-
-	/* Set up a PDB for the decapsulation side */
-	/* decappdb.ip_hdr_len = OPTHDRSZ; */
-	decappdb.options = PDBOPTS_ESPCBC_OUTFMT;
-
-	/* Map key buffers before the descbuild */
-	spkeymap = (u8 *)dma_map_single(dev, spkeybuf, padsz, DMA_TO_DEVICE);
-	cipherkeymap = (u8 *)dma_map_single(dev, cipherkeybuf, 16,
-					    DMA_TO_DEVICE);
-
-	/* Now set up transforms with mapped cipher and auth keys */
-	cipher.algtype = CIPHER_TYPE_IPSEC_AESCBC;
-	cipher.key = cipherkeymap;
-	cipher.keylen = cipherkeysz * 8; /* AES keysize in bits */
-
-	auth.algtype = AUTH_TYPE_IPSEC_SHA1HMAC_96;
-	auth.key = spkeymap;
-	auth.keylen = SHA1_HMAC_KEYSZ * 2 * 8;
-
-	/*
-	 * Have our keys, cipher selections, and PDB set up for the
-	 * sharedesc constructor. Now construct it
-	 */
-	stat = cnstr_shdsc_ipsec_encap(encapdesc, &encapdsz, &encappdb,
-				       (u8 *)opthdr, &cipher, &auth);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: encap sharedesc construct failed\n", testname);
-		goto freeup;
-		return -1;
-	};
-
-	stat = cnstr_shdsc_ipsec_decap(decapdesc, &decapdsz, &decappdb,
-				       &cipher, &auth);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: decap sharedesc construct failed\n", testname);
-		goto freeup;
-		return -1;
-	};
-
-	/*
-	 * Starting encapsulation phase. Precoat the input frame
-	 * with a known pattern
-	 */
-	memcpy(inbuf, incmp, inbufsz);
-
-	/*
-	 * Encap shared descriptor is ready to go. Now, map it.
-	 * Also, map the input frame and output frame before building
-	 * a sequence job descriptor to run the frame
-	 */
-	encapdmap = (u32 *)dma_map_single(dev, encapdesc, encapdsz,
-					  DMA_BIDIRECTIONAL);
-	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	encapmap = (u8 *)dma_map_single(dev, encapbuf, encapbufsz,
-					DMA_FROM_DEVICE);
-
-	/* With mapped buffers, build/map jobdesc for this frame */
-	stat = cnstr_seq_jobdesc(jdesc, &jdsz, encapdmap, encapdsz,
-				 inmap, inbufsz, encapmap, encapbufsz);
-
-	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: encap jobdesc construct failed\n", testname);
-		goto freeup;
-		return -1;
-	};
-
-	/* Show it before we run it */
-	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-		caam_desc_disasm(encapdesc, DISASM_SHOW_OFFSETS);
-	}
-
-	/* Enqueue the encapsulation job and block */
-	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit) {
-		printk(KERN_INFO "%s interrupted\n", testname);
-		rtnval = -1;
-	}
-
-	/* Upmap shared desc, job desc, and inputs */
-	dma_unmap_single(dev, (u32)encapdmap, encapdsz, DMA_BIDIRECTIONAL);
-	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)encapmap, encapbufsz, DMA_FROM_DEVICE);
-
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n",
-		       testname, rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-		goto freeup;
-	}
-
-	/*
-	 * Now do decapsulation phase. Map the decapsulation descriptor
-	 * and encapsulation-input/decapsulation-output frames in their
-	 * correct directions
-	 */
-	decapdmap = (u32 *)dma_map_single(dev, decapdesc, decapdsz,
-					  DMA_BIDIRECTIONAL);
-	encapmap = (u8 *)dma_map_single(dev, encapbuf, encapbufsz,
-					DMA_TO_DEVICE);
-	decapmap = (u8 *)dma_map_single(dev, decapbuf, decapbufsz,
-					DMA_FROM_DEVICE);
-
-	/* With mapped buffers, build/map jobdesc for this frame */
-	stat = cnstr_seq_jobdesc(jdesc, &jdsz, decapdmap, decapdsz,
-				 encapmap, encapbufsz, decapmap, decapbufsz);
-
-	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: encap jobdesc construct failed\n", testname);
-		goto freeup;
-		return -1;
-	};
-
-	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-		caam_desc_disasm(decapdesc, DISASM_SHOW_OFFSETS);
-	}
-
-	/* Enqueue the decapsulation job and block */
-	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit) {
-		printk(KERN_INFO "%s interrupted\n", testname);
-		rtnval = -1;
-	}
-
-	/* Upmap shared desc, job desc, inputs and outputs */
-	dma_unmap_single(dev, (u32)decapdmap, decapdsz, DMA_BIDIRECTIONAL);
-	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)encapmap, encapbufsz, DMA_FROM_DEVICE);
-	dma_unmap_single(dev, (u32)decapmap, decapbufsz, DMA_FROM_DEVICE);
-
-
-freeup:
-	kfree(hmackeybuf);
-	kfree(cipherkeybuf);
-	kfree(spkeybuf);
-	kfree(jdesc);
-	kfree(encapdesc);
-	kfree(decapdesc);
-	kfree(inbuf);
-	kfree(encapbuf);
-	kfree(decapbuf);
-	return rtnval;
-}
-
diff --git a/drivers/crypto/caam/jq_test/jq_snow.c b/drivers/crypto/caam/jq_test/jq_snow.c
deleted file mode 100644
index 75c4055..0000000
--- a/drivers/crypto/caam/jq_test/jq_snow.c
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * jq_snow.c - JobQ unit test for SNOW examples
- *
- * Copyright (c) 2009, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "caam_jqtest.h"
-
-/*
- * Case taken from SNOW conformance document, UEA2 case #1
- * Last byte 0x7c from 0x78 on account of length change from
- * 253 bits to 16 bytes
- */
-static u_int8_t snow_key[] = {
-	0xd3, 0xc5, 0xd5, 0x92,
-	0x32, 0x7f, 0xb1, 0x1c,
-	0x40, 0x35, 0xc6, 0x68,
-	0x0a, 0xf8, 0xc6, 0xd1
-};
-
-#define SNOW_F8_TESTSET_SIZE 32
-
-static u_int8_t input_msg_data[] = {
-	0x98, 0x1b, 0xa6, 0x82,
-	0x4c, 0x1b, 0xfb, 0x1a,
-	0xb4, 0x85, 0x47, 0x20,
-	0x29, 0xb7, 0x1d, 0x80,
-	0x8c, 0xe3, 0x3e, 0x2c,
-	0xc3, 0xc0, 0xb5, 0xfc,
-	0x1f, 0x3d, 0xe8, 0xa6,
-	0xdc, 0x66, 0xb1, 0xf0
-};
-
-static u_int8_t output_msg_data[] = {
-	0x5d, 0x5b, 0xfe, 0x75,
-	0xeb, 0x04, 0xf6, 0x8c,
-	0xe0, 0xa1, 0x23, 0x77,
-	0xea, 0x00, 0xb3, 0x7d,
-	0x47, 0xc6, 0xa0, 0xba,
-	0x06, 0x30, 0x91, 0x55,
-	0x08, 0x6a, 0x85, 0x9c,
-	0x43, 0x41, 0xb3, 0x7c
-};
-
-static const u_int32_t count = 0x398a59b4;
-static const u_int8_t bearer = 0x15;
-static const u_int8_t direction = 0x1;
-
-static struct completion completion;
-
-void jq_snow_done(struct device *dev, u32 *head, u32 status, void *auxarg)
-{
-	/* Write back returned status, and continue */
-	*(u32 *)auxarg = status;
-	complete(&completion);
-}
-
-int jq_snow_f8(struct device *dev, int show)
-{
-	int stat, exit, rtnval = 0;
-	u32 *sdesc, *jdesc, *sdmap;
-	u8 *inbuf, *outbuf, *inmap, *outmap;
-	u16 sdsz, jdsz, inbufsz, outbufsz;
-	u32 rqstatus;
-	u8 err[256];
-	u8 testname[] = "jq_snow_f8";
-
-	init_completion(&completion);
-
-	/* Allocate more than necessary for both descs */
-	sdsz = 64 * sizeof(u32);
-	jdsz = 16 * sizeof(u32);
-	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
-
-	/* Allocate buffers */
-	inbufsz = SNOW_F8_TESTSET_SIZE;
-	outbufsz = SNOW_F8_TESTSET_SIZE;
-	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
-
-	if ((sdesc == NULL) || (jdesc == NULL) ||
-	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "%s: can't get buffers\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		return -1;
-	};
-
-	memcpy(inbuf, input_msg_data, inbufsz);
-
-	stat = cnstr_shdsc_snow_f8(sdesc, &sdsz, snow_key, 128,
-				   DIR_ENCRYPT, count, bearer, direction);
-
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: sharedesc construct failed\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		return -1;
-	};
-
-	/* Map data prior to jobdesc build */
-	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
-
-	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
-
-	/* build jobdesc */
-	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
-			  outmap, outbufsz);
-
-	/* Show it before we run it */
-	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
-	}
-
-	/* Enqueue and block*/
-	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit)
-		printk(KERN_INFO "%s: interrupted\n", testname);
-
-	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
-	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
-
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
-		       rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-	} else
-		if (memcmp(output_msg_data, outbuf, outbufsz)) {
-			printk(KERN_INFO "%s: output mismatch\n", testname);
-			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
-			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
-		}
-
-	kfree(sdesc);
-	kfree(jdesc);
-	kfree(inbuf);
-	kfree(outbuf);
-
-	return rtnval;
-}
-
-
-static const unsigned char uia2_key[] =
-{
-    0x2b, 0xd6, 0x45, 0x9f, 0x82, 0xc5, 0xb3, 0x00,
-    0x95, 0x2c, 0x49, 0x10, 0x48, 0x81, 0xff, 0x48
-};
-
-static const unsigned char uia2_in[] =
-{
-    0x33, 0x32, 0x34, 0x62, 0x63, 0x39, 0x38, 0x61,
-    0x37, 0x34, 0x79
-};
-
-static const unsigned char uia2_out[] =
-{
-    0xee, 0x41, 0x9e, 0x0d
-};
-
-static const u_int32_t uia2_count = 0x38a6f056;
-static const u_int32_t uia2_fresh = 0xb8aefda9;
-static const u_int8_t uia2_dir;
-
-int jq_snow_f9(struct device *dev, int show)
-{
-	int stat, exit, rtnval = 0;
-	u32 *sdesc, *jdesc, *sdmap;
-	u8 *inbuf, *outbuf, *inmap, *outmap;
-	u16 sdsz, jdsz, inbufsz, outbufsz;
-	u32 rqstatus;
-	u8 err[256];
-	u8 testname[] = "jq_snow_f9";
-
-	init_completion(&completion);
-
-	/* Allocate more than necessary for both descs */
-	sdsz = 64 * sizeof(u32);
-	jdsz = 16 * sizeof(u32);
-	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
-
-	/* Allocate buffers */
-	inbufsz = 11;
-	outbufsz = 4;
-	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
-
-	if ((sdesc == NULL) || (jdesc == NULL) ||
-	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "%s: can't get buffers\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		return -1;
-	};
-
-	memcpy(inbuf, uia2_in, inbufsz);
-
-	stat = cnstr_shdsc_snow_f9(sdesc, &sdsz, (u_int8_t *)uia2_key, 128,
-				   DIR_ENCRYPT, uia2_count, uia2_fresh,
-				   uia2_dir);
-
-	if (stat) {
-		printk(KERN_INFO
-		       "%s: sharedesc construct failed\n", testname);
-		kfree(sdesc);
-		kfree(jdesc);
-		return -1;
-	};
-
-	/* Map data prior to jobdesc build */
-	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
-	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
-
-	/* build jobdesc */
-	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
-			  outmap, outbufsz);
-
-	/* Show it before we run it */
-	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
-		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
-	}
-
-	/* Enqueue and block*/
-	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&rqstatus);
-	if (stat) {
-		printk(KERN_INFO "%s: can't enqueue\n", testname);
-		rtnval = -1;
-	}
-	exit = wait_for_completion_interruptible(&completion);
-	if (exit)
-		printk(KERN_INFO "%s: interrupted\n", testname);
-
-	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
-	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
-
-	if ((rtnval) || (rqstatus)) {
-		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
-		       rqstatus);
-		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
-	} else
-		if (memcmp(uia2_out, outbuf, outbufsz)) {
-			printk(KERN_INFO "%s: output mismatch\n", testname);
-			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
-			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
-		}
-
-	kfree(sdesc);
-	kfree(jdesc);
-	kfree(inbuf);
-	kfree(outbuf);
-
-	return rtnval;
-}
diff --git a/drivers/crypto/caam/pdb.h b/drivers/crypto/caam/pdb.h
index 3ced12a..3164020 100644
--- a/drivers/crypto/caam/pdb.h
+++ b/drivers/crypto/caam/pdb.h
@@ -1,7 +1,7 @@
 /*
  * CAAM Protocol Data Block (PDB) definition header file
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index d535165..dc0a5ad 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -1,7 +1,7 @@
 /*
  * CAAM hardware register-level view
  *
- * Copyright (c) 2008-2010, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -114,8 +114,6 @@ static inline __be64 rd_reg64(__be64 *reg)
 
 #define wr_reg32(reg, data) out_be32(reg, data)
 #define rd_reg32(reg) in_be32(reg)
-#define wr_reg16(reg, data) out_be16(reg, data)
-#define rd_reg16(reg) in_be16(reg)
 #else /* !CONFIG_PPC32 */
 	/* TODO: define little-endian variant */
 #endif
@@ -125,9 +123,9 @@ static inline __be64 rd_reg64(__be64 *reg)
  * Represents each entry in a JobQ output ring
  */
 struct jq_outentry {
-	u32 *desc;	/* Pointer to completed descriptor */
+	dma_addr_t desc;/* Pointer to completed descriptor */
 	u32 jqstatus;	/* Status for completed descriptor */
-};
+} __packed;
 
 /*
  * caam_perfmon - Performance Monitor/Secure Memory Status/
@@ -173,9 +171,8 @@ struct caam_perfmon {
 
 #define MSTRID_LIODN_MASK	0x0fff
 struct masterid {
-	__be32 lock;		/* lock and make-trusted control bits */
-	__be16 liodn_ns;	/* LIODN for non-sequence access */
-	__be16 liodn_sq;	/* LIODN for sequence access */
+	__be32 liodn_ms;	/* lock and make-trusted control bits */
+	__be32 liodn_ls;	/* LIODN for non-sequence and seq access */
 };
 
 /* Partition ID for DMA configuration */
@@ -189,31 +186,31 @@ struct partid {
 struct rngtst {
 	__be32 mode;		/* RTSTMODEx - Test mode */
 	__be32 rsvd1[3];
-	__be32 reset;		/* Test reset control */
+	__be32 reset;		/* RTSTRESETx - Test reset control */
 	__be32 rsvd2[3];
-	__be32 status;		/* Test status */
+	__be32 status;		/* RTSTSSTATUSx - Test status */
 	__be32 rsvd3;
-	__be32 errstat;	/* Test error status */
+	__be32 errstat;		/* RTSTERRSTATx - Test error status */
 	__be32 rsvd4;
-	__be32 errctl;		/* Test error control */
+	__be32 errctl;		/* RTSTERRCTLx - Test error control */
 	__be32 rsvd5;
-	__be32 entropy;	/* Test entropy */
+	__be32 entropy;		/* RTSTENTROPYx - Test entropy */
 	__be32 rsvd6[15];
-	__be32 verifctl;	/* Test verification control */
+	__be32 verifctl;	/* RTSTVERIFCTLx - Test verification control */
 	__be32 rsvd7;
-	__be32 verifstat;	/* Test verification status */
+	__be32 verifstat;	/* RTSTVERIFSTATx - Test verification status */
 	__be32 rsvd8;
-	__be32 verifdata;	/* Test verification data */
+	__be32 verifdata;	/* RTSTVERIFDx - Test verification data */
 	__be32 rsvd9;
-	__be32 xkey;		/* Test XKEY */
+	__be32 xkey;		/* RTSTXKEYx - Test XKEY */
 	__be32 rsvd10;
-	__be32 oscctctl;	/* Test oscillator counter control */
+	__be32 oscctctl;	/* RTSTOSCCTCTLx - Test osc. counter control */
 	__be32 rsvd11;
-	__be32 oscct;		/* Test oscillator counter */
+	__be32 oscct;		/* RTSTOSCCTx - Test oscillator counter */
 	__be32 rsvd12;
-	__be32 oscctstat;	/* Test oscillator counter status */
+	__be32 oscctstat;	/* RTSTODCCTSTATx - Test osc counter status */
 	__be32 rsvd13[2];
-	__be32 ofifo[4];	/* Test output FIFO */
+	__be32 ofifo[4];	/* RTSTOFIFOx - Test output FIFO */
 	__be32 rsvd14[15];
 };
 
@@ -439,8 +436,10 @@ struct caam_job_queue {
 #define JQINT_ERR_INDEX_SHIFT       16
 #define JQINT_ERR_TYPE_MASK         0xf00
 #define JQINT_ERR_TYPE_SHIFT        8
-#define JQINT_ERR_HALT_MASK         0x0c
+#define JQINT_ERR_HALT_MASK         0xc
 #define JQINT_ERR_HALT_SHIFT        2
+#define JQINT_ERR_HALT_INPROGRESS   0x4
+#define JQINT_ERR_HALT_COMPLETE     0x8
 #define JQINT_JQ_ERROR              0x02
 #define JQINT_JQ_INT                0x01
 
@@ -500,6 +499,7 @@ struct caam_assurance {
 	/* Block access/configuration @ 100/110/120/130 */
 	struct rtic_block memblk[4];	/* Memory Blocks A-D */
 	__be32 rsvd8[32];
+
 	/* Block hashes @ 200/300/400/500 */
 	struct rtic_memhash hash[4];	/* Block hash values A-D */
 	__be32 rsvd_3[640];
@@ -558,10 +558,9 @@ struct caam_queue_if {
 
 /* deco_sg_table - DECO view of scatter/gather table */
  struct deco_sg_table {
-	__be64 addr;	/* Segment Address */
-	__be32 elen;	/* E, F bits + 30-bit length */
-	__be16 bpid;	/* Buffer Pool ID */
-	__be16 len;	/* 16-bit length */
+	__be64 addr;		/* Segment Address */
+	__be32 elen;		/* E, F bits + 30-bit length */
+	__be32 bpid_offset;	/* Buffer Pool ID + 16-bit length */
 };
 
 /*
@@ -632,10 +631,8 @@ struct caam_deco {
 	__be32 op_status_hi;	/* DxOPSTA - DECO Operation Status */
 	__be32 op_status_lo;
 	__be32 rsvd24[2];
-	__be16 ns_liodn;	/* DxLSR - DECO LIODN Status - non-seq */
-	__be16 sq_liodn;	/* DxLSR - DECO LIODN Status - seq */
-	__be16 rsvd25;
-	__be16 td_liodn;	/* DxLSR - DECO LIODN Status - trustdesc */
+	__be32 liodn;		/* DxLSR - DECO LIODN Status - non-seq */
+	__be32 td_liodn;	/* DxLSR - DECO LIODN Status - trustdesc */
 	__be32 rsvd26[6];
 	__be64 math[4];		/* DxMTH - Math register */
 	__be32 rsvd27[8];
-- 
1.6.5.2

