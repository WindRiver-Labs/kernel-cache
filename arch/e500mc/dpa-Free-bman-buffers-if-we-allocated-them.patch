From c5456703c904bd3cfacebf5dc85d3155844f6448 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 9 Aug 2010 18:55:20 +0800
Subject: [PATCH 174/252] dpa: Free bman buffers if we allocated them

From FSL vendor SDK 2.x.

The dpa_bp_free() function was not removing the buffers
from the pool, which meant that an error or a soft-reboot
would leave them there.  This would cause issues, and is
wrong, anyway. However, we don't want to clean out the pool
if the bman driver was the one that created it, so we
resurrect the kernel_pool field, and use that to determine
whether we're responsible for releasing the buffers or not.

Also, use this to determine if we should free the pages, as
we should only do that if we actually allocated them. Same
for dma_unmap.

Signed-off-by: Andy Fleming <afleming@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/dpa/dpa.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 1a54f1c..c6c9a83 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -113,6 +113,7 @@ static const char rtx[][3] = {
 
 struct dpa_bp {
 	struct bman_pool		*pool;
+	bool                            kernel_pool;
 	union {
 		struct list_head	list;
 		uint8_t			bpid;
@@ -205,6 +206,8 @@ _dpa_bp_alloc(struct net_device *net_dev, struct list_head *list,
   			_errno = -ENOMEM;
   			goto _return_bman_free_pool;
   		}
+
+		dpa_bp->kernel_pool = true;
   
  		dpa_bp->paddr = dma_map_single(net_dev->dev.parent,
  						dpa_bp->vaddr,
@@ -230,6 +233,7 @@ _dpa_bp_alloc(struct net_device *net_dev, struct list_head *list,
  			}
  		}
   	} else {
+		dpa_bp->kernel_pool = false;
   		devm_request_mem_region(net_dev->dev.parent, dpa_bp->paddr,
   					dpa_bp->size * dpa_bp->count,
   					KBUILD_MODNAME);
@@ -274,10 +278,16 @@ static void __cold __attribute__((nonnull))
 _dpa_bp_free(struct device *dev, struct dpa_bp *dpa_bp)
 {
 	uint8_t	bpid;
+	struct bm_buffer bmb[8];
+
+	if (dpa_bp->kernel_pool) {
+		 while (bman_acquire(dpa_bp->pool, bmb, 8, 0) == 8)
+			;
 
-	dma_unmap_single(dev, dpa_bp->paddr,
+		dma_unmap_single(dev, dpa_bp->paddr,
 			dpa_bp->size * dpa_bp->count, DMA_BIDIRECTIONAL);
-	free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+		free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+	}
 	bpid = dpa_pool2bpid(dpa_bp);
 	dpa_bp_array[bpid] = 0;
 	bman_free_pool(dpa_bp->pool);
-- 
1.6.5.2

