From ad4641cff7e5a4a1c1d96081602dfd70b9a5164b Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Fri, 1 Jul 2011 09:56:10 +0800
Subject: [PATCH 2/2] Update zl6100 driver for sharing function with PIXIS

zl6100 is power monitoring driver for ZL2006 on P1022DS,
Make it share functions with PIXIS on P1022DS.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-Update-zl6100-driver-for-sharing-functi.patch.

Signed-off-by: Tang Yuantian <b29983@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/hwmon/Kconfig  |    1 +
 drivers/hwmon/zl6100.c |   94 ++----------------------------------------------
 2 files changed, 4 insertions(+), 91 deletions(-)

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 5353d8a..533b6ec 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -590,6 +590,7 @@ config SENSORS_LM90
 config SENSORS_ZL6100
 	tristate "Intersil zl6100 and compatibles"
 	depends on I2C
+	select FSL_PIXIS
 	help
 	  If you say yes here you get support for Intersil ZL6100 sensor chips.
 
diff --git a/drivers/hwmon/zl6100.c b/drivers/hwmon/zl6100.c
index ac8ee68..54ef0a1 100644
--- a/drivers/hwmon/zl6100.c
+++ b/drivers/hwmon/zl6100.c
@@ -51,6 +51,7 @@
 #include <linux/mutex.h>
 #include <linux/device.h>
 #include <linux/delay.h>
+#include <asm/fsl_pixis.h>
 
 #include <linux/slab.h>
 
@@ -67,54 +68,8 @@
  */
 #define LEN_BYTE		0x01	/* read one byte data */
 #define LEN_WORD		0x02	/* read two bytes data */
-#define SCALE_FACTOR	122		/* 2^(-13)*1000,000 */
-#define DIVIDE_FACTOR	1000	/* support the calculation */
 #define ZL6100_ID		"\x10ZL6100-002-FE03"	/* chip id */
 
-/* table for positive exponent */
-int pmbus_2power_pos[] = {
-	1,					/* 0000_0 => 0 */
-	2,					/* 0000_1 => 1 */
-	4,					/* 0001_0 => 2 */
-	8,					/* 0001_1 => 3 */
-	16,					/* 0010_0 => 4 */
-	32,					/* 0010_1 => 5 */
-	64,					/* 0011_0 => 6 */
-	128,				/* 0011_1 => 7 */
-	256,				/* 0100_0 => 8 */
-	512,				/* 0100_1 => 9 */
-	1024,				/* 0101_0 => 10 */
-	2048,				/* 0101_1 => 11 */
-	4096,				/* 0110_0 => 12 */
-	8192,				/* 0110_1 => 13 */
-	16384,				/* 0111_0 => 14 */
-	32678				/* 0111_1 => 15 */
-};
-
-/*
- * table for negative exponent.
- * amplified by 1000,000 times,
- * since Kernel does not support double data type
- */
-int pmbus_2power_neg[] = {
-	15,		/* 1000_0 => 16 (-16) */
-	30,		/* 1000_1 => 17 (-15) */
-	61,		/* 1001_0 => 18 (-14) */
-	122,	/* 1001_1 => 19 (-13) */
-	244,	/* 1010_0 => 20 (-12) */
-	488,	/* 1010_1 => 21 (-11) */
-	976,	/* 1011_0 => 22 (-10) */
-	1953,	/* 1011_1 => 23 (-9) */
-	3906,	/* 1100_0 => 24 (-8) */
-	7812,	/* 1100_1 => 25 (-7) */
-	15625,	/* 1101_0 => 26 (-6) */
-	31250,	/* 1101_1 => 27 (-5) */
-	62500,	/* 1110_0 => 28 (-4) */
-	125000,	/* 1110_1 => 29 (-3) */
-	250000,	/* 1111_0 => 30 (-2) */
-	500000	/* 1111_1 => 31 (-1) */
-};
-
 /**
  * Client data (each client gets its own)
  */
@@ -123,49 +78,6 @@ struct zl6100_data {
 	s32 val;
 };
 
-/*
- * 1. send VOUT_MODE to get data mode and exponent.
- *	 for zl6100: VOUT is LINEAR mode with exponent value -13.
- * 2. send READ_VOUT to get mantissa.
- */
-int pmbus_2volt(int v)
-{
-	int d;
-
-	d =  v * pmbus_2power_neg[3];
-
-	return d;
-}
-
-/*
- * IOUT is Literal data format.
- * 0x1111 1111 1111 1111
- *   ||   |||		   |
- *   | -+- | ----+-----
- *	 |  |  |	 +--> Mantissa X
- *	 |	|  +--------> Mantissa sign
- *	 |  +-----------> Exponent
- *	 +--------------> Exponent sign
- */
-int pmbus_2cur(int v)
-{
-	int d;
-	int n, y;
-
-	n = (v >> 11) & 0xF;
-	y = v & 0x3FF;
-
-	if (v & 0x400)
-		y = -(~(y-1) & 0x3FF);
-
-	if (v & 0x8000)
-		d = y * pmbus_2power_neg[n];
-	else
-		d = y * pmbus_2power_pos[n];
-
-	return d;
-}
-
 /**
  * read zl6100 register
  *
@@ -258,7 +170,7 @@ static int show_volt(struct device *dev, struct device_attribute *attr,
 	if (volt < 0)
 		return sprintf(buf, "%d\n", 0);
 
-	volt = (pmbus_2volt(volt) / DIVIDE_FACTOR) & 0xFFFF;
+	volt = pmbus_2volt(volt);
 
 	return sprintf(buf, "%d\n", volt);
 }
@@ -277,7 +189,7 @@ static int show_curr(struct device *dev, struct device_attribute *attr,
 
 	cur = read_register(client, READ_IOUT, LEN_WORD);
 
-	cur = (pmbus_2cur(cur) / DIVIDE_FACTOR) & 0xFFFF;
+	cur = pmbus_2cur(cur);
 
 	return sprintf(buf, "%d\n", cur);
 }
-- 
1.7.0.2

