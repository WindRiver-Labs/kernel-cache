From b90063eda2cd41cfe177832147b55e09ab735038 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 14 Dec 2010 15:55:37 +0800
Subject: [PATCH 09/28] skb_buff: Add skb_recycle and skb_is_recycleable helper functions

Patch taken from FSL vendor SDK 2.2.

Implment two helper functions:  skb_recycle and skb_is_recycleable
which are invoked directly in DPAA network driver.

Rearrange skb_recycle_check with skb_recycle and skb_is_recycleable, and
the function of skb_recycle_check doesn't change.

Its purpose is to get a bit potential performance improvements.
Under certain condition that a skb can surely be recycled, invoke skb_recycle
directly instead of skb_recycle_check to avoid unnecessary recyclable check.

Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 include/linux/skbuff.h |   16 ++++++++++++++
 net/core/skbuff.c      |   52 ++++++++++++++++++++---------------------------
 2 files changed, 38 insertions(+), 30 deletions(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index e429812..b15cd1d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -461,6 +461,7 @@ static inline struct sk_buff *alloc_skb_header(unsigned int size,
 #endif
 
 extern int skb_recycle_check(struct sk_buff *skb, int skb_size);
+extern void skb_recycle(struct sk_buff *skb);
 
 extern struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
 extern struct sk_buff *skb_clone(struct sk_buff *skb,
@@ -2100,5 +2101,20 @@ static inline void skb_forward_csum(struct sk_buff *skb)
 }
 
 bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
+static inline int skb_is_recycleable(struct sk_buff *skb, int skb_size)
+{
+	if (skb_is_nonlinear(skb) || skb->fclone != SKB_FCLONE_UNAVAILABLE)
+		return 0;
+
+	skb_size = SKB_DATA_ALIGN(skb_size + NET_SKB_PAD);
+	if (skb_end_pointer(skb) - skb->head < skb_size)
+		return 0;
+
+	if (skb_shared(skb) || skb_cloned(skb))
+		return 0;
+
+	return 1;
+}
+
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SKBUFF_H */
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 36ff0d6..0706e7d 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -566,35 +566,10 @@ void consume_skb(struct sk_buff *skb)
 }
 EXPORT_SYMBOL(consume_skb);
 
-/**
- *	skb_recycle_check - check if skb can be reused for receive
- *	@skb: buffer
- *	@skb_size: minimum receive buffer size
- *
- *	Checks that the skb passed in is not shared or cloned, and
- *	that it is linear and its head portion at least as large as
- *	skb_size so that it can be recycled as a receive buffer.
- *	If these conditions are met, this function does any necessary
- *	reference count dropping and cleans up the skbuff as if it
- *	just came from __alloc_skb().
- */
-int skb_recycle_check(struct sk_buff *skb, int skb_size)
+void skb_recycle(struct sk_buff *skb)
 {
 	struct skb_shared_info *shinfo;
 
-	if (irqs_disabled())
-		return 0;
-
-	if (skb_is_nonlinear(skb) || skb->fclone != SKB_FCLONE_UNAVAILABLE)
-		return 0;
-
-	skb_size = SKB_DATA_ALIGN(skb_size + NET_SKB_PAD);
-	if (skb_end_pointer(skb) - skb->head < skb_size)
-		return 0;
-
-	if (skb_shared(skb) || skb_cloned(skb))
-		return 0;
-
 	skb_release_head_state(skb);
 	shinfo = skb_shinfo(skb);
 	atomic_set(&shinfo->dataref, 1);
@@ -606,15 +581,32 @@ int skb_recycle_check(struct sk_buff *skb, int skb_size)
 	shinfo->tx_flags.flags = 0;
 	skb_frag_list_init(skb);
 	memset(&shinfo->hwtstamps, 0, sizeof(shinfo->hwtstamps));
-#ifdef CONFIG_VBUS
-	shinfo->release = NULL;
-	shinfo->priv = NULL;
-#endif
 
 	memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb->data = skb->head + NET_SKB_PAD;
 	skb_reset_tail_pointer(skb);
 
+}
+
+/**
+ *	skb_recycle_check - check if skb can be reused for receive
+ *	@skb: buffer
+ *	@skb_size: minimum receive buffer size
+ *
+ *	Checks that the skb passed in is not shared or cloned, and
+ *	that it is linear and its head portion at least as large as
+ *	skb_size so that it can be recycled as a receive buffer.
+ *	If these conditions are met, this function does any necessary
+ *	reference count dropping and cleans up the skbuff as if it
+ *	just came from __alloc_skb().
+ */
+int skb_recycle_check(struct sk_buff *skb, int skb_size)
+{
+	if (!skb_is_recycleable(skb, skb_size))
+		return 0;
+
+	skb_recycle(skb);
+
 	return 1;
 }
 EXPORT_SYMBOL(skb_recycle_check);
-- 
1.6.5.2

