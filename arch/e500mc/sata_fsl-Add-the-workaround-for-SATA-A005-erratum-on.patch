From de5d61e1b5e2c1ec3088dca82def645f9e0eacd1 Mon Sep 17 00:00:00 2001
From: Lei Xu <B33228@freescale.com>
Date: Fri, 29 Apr 2011 16:15:25 +0800
Subject: [PATCH 151/233] sata_fsl: Add the workaround for SATA-A005 erratum on P2040/P3041/P5020

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0195-sata_fsl-Add-the-workaround-for-SATA-A005-erratum-on.patch

False CRC error is reported after each read command.  Workaround:

1) Read commands should be limited to 8K

2) User should ignore the CRC errors assuming data is not corrupted

3) The software (driver) maintains queue for up to  16 commands

4) The driver will split the queue after READ command  (For example,
if the queue contains the following commands -[wr,wr,wr,rd,wr,wr,wr],
the driver will write to SATA host the following vectors [wr,wr,wr,rd]
and after it finished [wr,wr,wr] )

5) After read command from first divided queue is done the driver clear
error registers

6) Driver should execute the next commands

Signed-off-by: Lei Xu <B33228@freescale.com>
---
 drivers/ata/sata_fsl.c |   64 ++++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 59 insertions(+), 5 deletions(-)

diff --git a/drivers/ata/sata_fsl.c b/drivers/ata/sata_fsl.c
index 7406ffa..475b7e8 100644
--- a/drivers/ata/sata_fsl.c
+++ b/drivers/ata/sata_fsl.c
@@ -258,8 +258,16 @@ struct sata_fsl_host_priv {
 	void __iomem *csr_base;
 	int irq;
 	int data_snoop;
+	u32 quirks;
+#define SATA_FSL_QUIRK_P3P5_ERRATA	(1 << 0)
 };
 
+
+static void sata_fsl_dev_config(struct ata_device *dev)
+{
+		dev->max_sectors = 16;
+}
+
 static inline unsigned int sata_fsl_tag(unsigned int tag,
 					void __iomem *hcr_base)
 {
@@ -964,9 +972,18 @@ static void sata_fsl_error_handler(struct ata_port *ap)
 
 static void sata_fsl_post_internal_cmd(struct ata_queued_cmd *qc)
 {
+	struct sata_fsl_host_priv *host_priv = qc->ap->host->private_data;
+
 	if (qc->flags & ATA_QCFLAG_FAILED)
 		qc->err_mask |= AC_ERR_OTHER;
 
+	/* For P3P5 errata, it need to delay some time after running
+	 * ATA_CMD_ID_ATA command in some hard disk, otherwise it will
+	 * get error and fail. */
+	if ((host_priv->quirks & SATA_FSL_QUIRK_P3P5_ERRATA)
+			&& (qc->tf.command == ATA_CMD_ID_ATA))
+		udelay(2000);
+
 	if (qc->err_mask) {
 		/* make DMA engine forget about the failed command */
 
@@ -1103,25 +1120,48 @@ static void sata_fsl_host_intr(struct ata_port *ap)
 	u32 hstatus, qc_active = 0;
 	struct ata_queued_cmd *qc;
 	u32 SError;
+	u32 serror_mask = 0xFFFF0000;
+	u32 status_mask = INT_ON_ERROR;
 
 	hstatus = ioread32(hcr_base + HSTATUS);
 
 	sata_fsl_scr_read(&ap->link, SCR_ERROR, &SError);
 
-	if (unlikely(SError & 0xFFFF0000)) {
+	/* Workaround for P3041/P5020 SATA errata */
+	if (host_priv->quirks & SATA_FSL_QUIRK_P3P5_ERRATA) {
+		u32 Hcontrol;
+#define HCONTROL_CLEAR_ERROR	(1 << 27)
+		/* Set HControl[27] to clear error registers */
+		Hcontrol = ioread32(hcr_base + HCONTROL);
+		iowrite32(Hcontrol | HCONTROL_CLEAR_ERROR, hcr_base + HCONTROL);
+
+		/* Clear HControl[27] */
+		iowrite32(Hcontrol & (~HCONTROL_CLEAR_ERROR),
+						hcr_base + HCONTROL);
+
+		/* Ignore CRC error and fatal error */
+#define SERROR_CRC_ERROR	(1 << 21)
+		serror_mask &= ~SERROR_CRC_ERROR;
+		status_mask &= ~(INT_ON_FATAL_ERR | INT_ON_SINGL_DEVICE_ERR);
+
+		/* Set CCR register to indicate that command has completed */
+		qc_active = 1;
+	} else {
+		/* Read command completed register */
+		qc_active = ioread32(hcr_base + CC);
+	}
+
+	if (unlikely(SError & serror_mask)) {
 		DPRINTK("serror @host_intr : 0x%x\n", SError);
 		sata_fsl_error_intr(ap);
 	}
 
-	if (unlikely(hstatus & INT_ON_ERROR)) {
+	if (unlikely(hstatus & status_mask)) {
 		DPRINTK("error interrupt!!\n");
 		sata_fsl_error_intr(ap);
 		return;
 	}
 
-	/* Read command completed register */
-	qc_active = ioread32(hcr_base + CC);
-
 	VPRINTK("Status of all queues :\n");
 	VPRINTK("qc_active/CC = 0x%x, CA = 0x%x, CE=0x%x,CQ=0x%x,apqa=0x%x\n",
 		qc_active,
@@ -1348,6 +1388,20 @@ static int sata_fsl_probe(struct of_device *ofdev,
 	else
 		host_priv->data_snoop = DATA_SNOOP_ENABLE_V1;
 
+	if (of_device_is_compatible(ofdev->node, "fsl,p5020-sata") ||
+		of_device_is_compatible(ofdev->node, "fsl,p5010-sata") ||
+		of_device_is_compatible(ofdev->node, "fsl,p2041-sata") ||
+		of_device_is_compatible(ofdev->node, "fsl,p2040-sata") ||
+		of_device_is_compatible(ofdev->node, "fsl,p3041-sata")) {
+		if ((mfspr(SPRN_SVR) & 0xff) == 0x10) {
+			/* Workaround for P3041/P5020 SATA */
+			sata_fsl_ops.dev_config = &sata_fsl_dev_config;
+			sata_fsl_sht.can_queue = 1;
+			pi.flags &= ~ATA_FLAG_NCQ;
+			host_priv->quirks |= SATA_FSL_QUIRK_P3P5_ERRATA;
+		}
+	}
+
 	/* allocate host structure */
 	host = ata_host_alloc_pinfo(&ofdev->dev, ppi, SATA_FSL_MAX_PORTS);
 
-- 
1.7.0.4

