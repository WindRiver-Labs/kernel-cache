From fa9fdfbced618bc6e4d59a7303cc441709edb9ba Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Wed, 4 Aug 2010 15:33:33 +0800
Subject: [PATCH 162/252] qman/bman/pme2: remove low-level tests.

It is from FSL vendor SDK 2.x.

These low-level tests were mostly useful when bringing
up the high-level functionality and debugging simulators.
The high-level tests now fully exercise the same paths.
Moreover, support for core-affine portals must usually
be compiled out for the low-level tests to run, so they're
of limited usefulness.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/hwalloc/Kconfig         |    8 -
 drivers/hwalloc/Makefile        |    2 +-
 drivers/hwalloc/bman_test.c     |   29 +---
 drivers/hwalloc/bman_test.h     |    3 +-
 drivers/hwalloc/bman_test_low.c |  292 --------------------------
 drivers/hwqueue/Kconfig         |    8 -
 drivers/hwqueue/Makefile        |    2 +-
 drivers/hwqueue/qman_test.c     |   21 --
 drivers/hwqueue/qman_test.h     |    1 -
 drivers/hwqueue/qman_test_low.c |  441 ---------------------------------------
 10 files changed, 6 insertions(+), 801 deletions(-)
 delete mode 100644 drivers/hwalloc/bman_test_low.c
 delete mode 100644 drivers/hwqueue/qman_test_low.c

diff --git a/drivers/hwalloc/Kconfig b/drivers/hwalloc/Kconfig
index 9125387..94112a4 100644
--- a/drivers/hwalloc/Kconfig
+++ b/drivers/hwalloc/Kconfig
@@ -54,14 +54,6 @@ config FSL_BMAN_TEST
 	---help---
 	  This option compiles self-test code for Bman.
 
-config FSL_BMAN_TEST_LOW
-	bool "Bman low-level self-test"
-	depends on FSL_BMAN_TEST && FSL_BMAN_PORTAL_DISABLEAUTO
-	default y
-	---help---
-	  This takes an unused portal and portal and performs low-level
-	  API testing with it.
-
 config FSL_BMAN_TEST_HIGH
 	bool "Bman high-level self-test"
 	depends on FSL_BMAN_TEST && !FSL_BMAN_PORTAL_DISABLEAUTO
diff --git a/drivers/hwalloc/Makefile b/drivers/hwalloc/Makefile
index e157d46..0a950d1 100644
--- a/drivers/hwalloc/Makefile
+++ b/drivers/hwalloc/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_FSL_BMAN_CONFIG)	+= bman_config.o
 obj-$(CONFIG_FSL_BMAN_PORTAL)	+= bman_driver.o bman_low.o bman_high.o
 obj-$(CONFIG_FSL_BMAN_TEST)	+= bman_tester.o
-bman_tester-y			 = bman_test.o bman_test_high.o bman_test_low.o
+bman_tester-y			 = bman_test.o bman_test_high.o
diff --git a/drivers/hwalloc/bman_test.c b/drivers/hwalloc/bman_test.c
index dc5ebfb..e3b81d2 100644
--- a/drivers/hwalloc/bman_test.c
+++ b/drivers/hwalloc/bman_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,34 +38,11 @@ MODULE_DESCRIPTION("Bman testing");
 
 static int test_init(void)
 {
-	int loop;
-#ifdef CONFIG_FSL_BMAN_TEST_LOW
-	struct bm_portal *portal;
-	const struct bm_portal_config *config = NULL;
-	u8 num = bm_portal_num();
-
-	while (!config && (num-- > 0)) {
-		portal = bm_portal_get(num);
-		config = bm_portal_config(portal);
-		if (!config->bound)
-			pr_info("Portal %d is available, using it\n", num);
-		else
-			config = NULL;
-	}
-	if (!config) {
-		pr_err("No Bman portals available!\n");
-		return -ENOSYS;
-	}
-#endif
-	loop = 1;
-	while (loop--) {
-#ifdef CONFIG_FSL_BMAN_TEST_LOW
-		bman_test_low(portal);
-#endif
 #ifdef CONFIG_FSL_BMAN_TEST_HIGH
+	int loop = 1;
+	while (loop--)
 		bman_test_high();
 #endif
-	}
 	return 0;
 }
 
diff --git a/drivers/hwalloc/bman_test.h b/drivers/hwalloc/bman_test.h
index ddb1e11..732be6a 100644
--- a/drivers/hwalloc/bman_test.h
+++ b/drivers/hwalloc/bman_test.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -40,7 +40,6 @@
 
 #include <linux/fsl_bman.h>
 
-void bman_test_low(struct bm_portal *portal);
 void bman_test_high(void);
 
 static inline void __hexdump(unsigned long start, unsigned long end,
diff --git a/drivers/hwalloc/bman_test_low.c b/drivers/hwalloc/bman_test_low.c
deleted file mode 100644
index 17ae792..0000000
--- a/drivers/hwalloc/bman_test_low.c
+++ /dev/null
@@ -1,292 +0,0 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "bman_test.h"
-
-/* Assume this is broken, enable it afterwards */
-#define BUG_NO_RCR_ITR
-
-/* Test constants */
-#define TPORTAL		0
-#define TBUFS		10	/* Number released */
-#define TRELEASEMAX	8	/* Maximum released at once */
-#define TACQUIREMAX	8	/* Maximum acquired at once */
-#define TDENTRY		2
-#define TDEXIT		8
-#define TADDRHI		0xabba
-#define TADDRLO		0xdeadbeef
-
-/* Global variables make life simpler */
-static struct bm_portal *portal;
-static struct bm_rcr_entry *rc;
-static struct bm_mc_command *mcc;
-static struct bm_mc_result *mcr;
-static DEFINE_SPINLOCK(mc_lock);
-static const u32 test_thresholds[4] = {TDENTRY, TDEXIT, 0, 0};
-static DECLARE_WAIT_QUEUE_HEAD(queue);
-static int isr_count;
-
-/* Boolean switch for handling RCR_ITR */
-#ifndef BUG_NO_RCR_ITR
-static int rcr_thresh_on;
-#endif
-
-/* Bit-arrray representing releases to check against acquires. */
-static u32 bufs[(TBUFS + 31) / 32];
-static inline int BUFS_get(int idx)
-{
-	return (bufs[idx / 32] & (1 << (idx & 31))) ? 1 : 0;
-}
-static inline void BUFS_set(int idx)
-{
-	bufs[idx / 32] |= (1 << (idx & 31));
-}
-static inline void BUFS_unset(int idx)
-{
-	bufs[idx / 32] &= ~(u32)(1 << (idx & 31));
-}
-
-/* Helper for bm_mc_start() that checks the return code */
-static void mc_start(void)
-{
-	mcc = bm_mc_start(portal);
-	BUG_ON(!mcc);
-}
-
-/* Helper for bm_mc_result() that checks the response */
-static void mc_commit(u8 verb)
-{
-	bm_mc_commit(portal, verb);
-	do {
-		mcr = bm_mc_result(portal);
-	} while (!mcr);
-	BUG_ON((mcr->verb & BM_MCR_VERB_CMD_MASK) !=
-			(verb & BM_MCR_VERB_CMD_MASK));
-}
-
-/* Track RCR consumption */
-static void rcr_update(void)
-{
-#ifndef BUG_NO_RCR_ITR
-	u32 status;
-	u8 fill;
-	while ((fill = bm_rcr_get_fill(portal))) {
-		pr_info("rcr_update: fill==%d\n", fill);
-		bm_rcr_cci_update(portal);
-	}
-	status = bm_isr_status_read(portal);
-	if (status & BM_PIRQ_RCRI) {
-		BUG_ON(!rcr_thresh_on);
-		bm_rcr_set_ithresh(portal, 0);
-		rcr_thresh_on = 0;
-		pr_info("Auto-update of RCR consumption\n");
-		bm_isr_status_clear(portal, progress & BM_PIRQ_RCRI);
-	}
-#else
-	bm_rcr_cci_update(portal);
-#endif
-}
-
-/* Helper for bm_eqcr_start() that tracks ring consumption and checks the
- * return code */
-static void rcr_start(void)
-{
-	/* If there are consumed RCR entries, track them now. The alternative
-	 * is to catch an error in bm_rcr_start(), track consume entries then,
-	 * and then retry bm_rcr_start(). */
-	do {
-		rcr_update();
-		rc = bm_rcr_start(portal);
-	} while (!rc);
-}
-
-/* Helper for bm_rcr_pvb_commit() */
-static void rcr_commit(u8 numbufs)
-{
-	bm_rcr_pvb_commit(portal, BM_RCR_VERB_CMD_BPID_SINGLE | numbufs);
-#ifndef BUG_NO_RCR_ITR
-	if (!rcr_thresh_on && (bm_rcr_get_avail(portal) < 2)) {
-		rcr_thresh_on = 1;
-		bm_rcr_set_ithresh(portal, 1);
-	}
-#endif
-}
-
-static irqreturn_t portal_isr(int irq, void *ptr)
-{
-	pr_info("BMAN portal interrupt, isr_count=%d->%d\n", isr_count,
-		isr_count + 1);
-	isr_count++;
-	bm_isr_inhibit(portal);
-	wake_up(&queue);
-	return IRQ_HANDLED;
-}
-
-void bman_test_low(struct bm_portal *__p)
-{
-	const struct bm_portal_config *config = bm_portal_config(__p);
-	u32 bpid;
-	int i, big_loop = 2;
-	u32 status;
-	int depleted = 1, last_count = 0;
-#define WAIT_ISR() \
-do { \
-	last_count++; \
-	wait_event(queue, isr_count == last_count); \
-} while(0)
-
-	portal = __p;
-
-	i = bm_pool_new(&bpid);
-	if (i)
-		panic("can't allocate bpid");
-	i = bm_pool_set(bpid, test_thresholds);
-	if (i)
-		panic("can't set thresholds");
-
-	/*********************/
-	/* Initialise portal */
-	/*********************/
-	if (bm_rcr_init(portal, bm_rcr_pvb, bm_rcr_cci) ||
-			bm_mc_init(portal) || bm_isr_init(portal))
-		panic("Portal setup failed");
-	bm_isr_enable_write(portal, -1);
-	bm_isr_disable_write(portal, 0);
-	bm_isr_uninhibit(portal);
-	bm_isr_status_clear(portal, 0xffffffff);
-
-	pr_info("low-level test, start ccmode\n");
-
-	if (request_irq(config->irq, portal_isr, 0, "Bman portal 0", NULL))
-		panic("Can't register Bman portal 0 IRQ");
-	/* Enable the BSCN mask bit corresponding to our bpid */
-	bm_isr_bscn_mask(portal, bpid, 1);
-
-	pr_info("Portal %d i/faces initialised\n", TPORTAL);
-
-again:
-	/* The portal's (interrupt) status register should be zero */
-	status = bm_isr_status_read(portal);
-	BUG_ON(status);
-
-	/*************************/
-	/* Release TBUFS buffers */
-	/*************************/
-	for (i = 0; i < TBUFS;) {
-		int j = 0;
-		rcr_start();
-		rc->bpid = bpid;
-		while ((j < TRELEASEMAX) && (i < TBUFS)) {
-			rc->bufs[j].hi = TADDRHI;
-			rc->bufs[j].lo = TADDRLO + i;
-			BUFS_set(i);
-			i++;
-			j++;
-		}
-		rcr_commit(j);
-		if (depleted && (i > TDEXIT)) {
-			WAIT_ISR();
-			do {
-				status = bm_isr_status_read(portal);
-			} while (status != BM_PIRQ_BSCN);
-			bm_isr_status_clear(portal, BM_PIRQ_BSCN);
-			status = bm_isr_status_read(portal);
-			BUG_ON(status);
-			bm_isr_uninhibit(portal);
-			depleted = 0;
-		}
-		pr_info("Releasing %d bufs (%d-%d)\n", j, i - j, i - 1);
-	}
-	rcr_update(); /* RCR should be empty now */
-
-	/****************/
-	/* Acquire bufs */
-	/****************/
-	while (i) {
-		int j;
-		spin_lock_irq(&mc_lock);
-		mc_start();
-		mcc->acquire.bpid = bpid;
-		mc_commit(BM_MCC_VERB_CMD_ACQUIRE |
-			((i < TRELEASEMAX) ? i : TRELEASEMAX));
-		j = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;
-		pr_info("Acquired %d bufs (%d remain)\n", j, i - j);
-		BUG_ON(!j);
-		BUG_ON(j > i);
-		while (j--) {
-			unsigned int idx;
-			BUG_ON(mcr->acquire.bufs[j].hi != TADDRHI);
-			idx = mcr->acquire.bufs[j].lo - TADDRLO;
-			BUG_ON(idx >= TBUFS);
-			BUG_ON(!BUFS_get(idx));
-			BUFS_unset(idx);
-			i--;
-		}
-		spin_unlock_irq(&mc_lock);
-		if (!depleted && (i < TDENTRY)) {
-			WAIT_ISR();
-			do {
-				status = bm_isr_status_read(portal);
-			} while (status != BM_PIRQ_BSCN);
-			bm_isr_status_clear(portal, BM_PIRQ_BSCN);
-			status = bm_isr_status_read(portal);
-			BUG_ON(status);
-			bm_isr_uninhibit(portal);
-			depleted = 1;
-		}
-	}
-
-	/****************************/
-	/* Acquire should give zero */
-	/****************************/
-	mc_start();
-	mcc->acquire.bpid = bpid;
-	mc_commit(BM_MCC_VERB_CMD_ACQUIRE | 1);
-	pr_info("Acquiring 1 buf when pool is empty\n");
-	BUG_ON((mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT));
-	pr_info("Acquire gave %d buffers when pool is empty\n",
-		mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT);
-
-	if (big_loop--)
-		goto again;
-
-	bm_isr_bscn_mask(portal, bpid, 0);
-	free_irq(config->irq, NULL);
-	bm_rcr_finish(portal);
-	bm_mc_finish(portal);
-	bm_isr_status_clear(portal, -1);
-	bm_isr_enable_write(portal, 0);
-	bm_isr_finish(portal);
-
-	bm_pool_free(bpid);
-}
-
diff --git a/drivers/hwqueue/Kconfig b/drivers/hwqueue/Kconfig
index 63795e1..e4ef451 100644
--- a/drivers/hwqueue/Kconfig
+++ b/drivers/hwqueue/Kconfig
@@ -106,14 +106,6 @@ config FSL_QMAN_TEST_STASH_POTATO
 	  across a series of FQs scheduled to different portals (and cpus), with
 	  DQRR, data and context stashing always on.
 
-config FSL_QMAN_TEST_LOW
-	bool "Qman low-level self-test"
-	depends on FSL_QMAN_TEST && FSL_QMAN_PORTAL_DISABLEAUTO
-	default y
-	---help---
-	  This takes an unused portal and portal and performs low-level
-	  API testing with it.
-
 config FSL_QMAN_TEST_HIGH
 	bool "Qman high-level self-test"
 	depends on FSL_QMAN_TEST && !FSL_QMAN_PORTAL_DISABLEAUTO
diff --git a/drivers/hwqueue/Makefile b/drivers/hwqueue/Makefile
index b858520..7c7bc8e 100644
--- a/drivers/hwqueue/Makefile
+++ b/drivers/hwqueue/Makefile
@@ -4,5 +4,5 @@ obj-$(CONFIG_FSL_QMAN_PORTAL)	+= qman_driver.o qman_low.o qman_high.o
 obj-$(CONFIG_FSL_QMAN_FQALLOCATOR) += qman_fqalloc.o
 obj-$(CONFIG_FSL_QMAN_TEST)	+= qman_tester.o
 qman_tester-y			 = qman_test.o qman_test_hotpotato.o \
-				qman_test_high.o qman_test_low.o
+				qman_test_high.o
 qman_tester-$(CONFIG_FSL_QMAN_FQRANGE) += qman_test_fqrange.o
diff --git a/drivers/hwqueue/qman_test.c b/drivers/hwqueue/qman_test.c
index bc7e99a..0d3ede9 100644
--- a/drivers/hwqueue/qman_test.c
+++ b/drivers/hwqueue/qman_test.c
@@ -42,32 +42,11 @@ static int test_init(void)
 #ifdef CONFIG_FSL_QMAN_FQRANGE
 	qman_test_fqrange();
 #endif
-#ifdef CONFIG_FSL_QMAN_TEST_LOW
-	struct qm_portal *portal;
-	const struct qm_portal_config *config = NULL;
-	u8 num = qm_portal_num();
-
-	while (!config && (num-- > 0)) {
-		portal = qm_portal_get(num);
-		config = qm_portal_config(portal);
-		if (!config->bound)
-			pr_info("Portal %d is available, using it\n", num);
-		else
-			config = NULL;
-	}
-	if (!config) {
-		pr_err("No unused Qman portals available!\n");
-		return -ENOSYS;
-	}
-#endif
 	loop = 1;
 	while(loop--) {
 #ifdef CONFIG_FSL_QMAN_TEST_STASH_POTATO
 		qman_test_hotpotato();
 #endif
-#ifdef CONFIG_FSL_QMAN_TEST_LOW
-		qman_test_low(portal);
-#endif
 #ifdef CONFIG_FSL_QMAN_TEST_HIGH
 		qman_test_high();
 #endif
diff --git a/drivers/hwqueue/qman_test.h b/drivers/hwqueue/qman_test.h
index 3888583..24abf41 100644
--- a/drivers/hwqueue/qman_test.h
+++ b/drivers/hwqueue/qman_test.h
@@ -41,7 +41,6 @@
 #include <linux/fsl_qman.h>
 
 void qman_test_hotpotato(void);
-void qman_test_low(struct qm_portal *p);
 void qman_test_high(void);
 void qman_test_fqrange(void);
 
diff --git a/drivers/hwqueue/qman_test_low.c b/drivers/hwqueue/qman_test_low.c
deleted file mode 100644
index 8a91e46..0000000
--- a/drivers/hwqueue/qman_test_low.c
+++ /dev/null
@@ -1,441 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "qman_test.h"
-
-/* DQRR maxfill, and ring/data stashing booleans */
-#define DQRR_MAXFILL	15
-
-/* Test constants */
-#define TWQ		3	/* 0..7, ie. within the channel */
-#define TCONTEXTB	0xabcd9876
-#define TFRAMES		3	/* Number enqueued */
-#define TEQVERB		QM_EQCR_VERB_CMD_ENQUEUE
-#define TTOKEN		0xab
-
-/* Global variables make life simpler */
-static struct qm_portal *portal;
-static struct qm_eqcr_entry *eq;
-static struct qm_dqrr_entry *dq;
-static struct qm_mr_entry *mr;
-static struct qm_mc_command *mcc;
-static struct qm_mc_result *mcr;
-static DECLARE_WAIT_QUEUE_HEAD(queue);
-static int isr_count;
-
-#ifdef CONFIG_FSL_QMAN_FQALLOCATOR
-
-/* Use Bman for dynamic FQ allocation (BPID==0) */
-#include <linux/fsl_bman.h>
-static struct bman_pool *fq_pool;
-static const struct bman_pool_params fq_pool_params;
-static u32 fqid;
-static void alloc_fqid(void)
-{
-	struct bm_buffer buf;
-	int ret;
-	fq_pool = bman_new_pool(&fq_pool_params);
-	BUG_ON(!fq_pool);
-	ret = bman_acquire(fq_pool, &buf, 1, 0);
-	BUG_ON(ret != 1);
-	fqid = buf.lo;
-}
-static void free_fqid(void)
-{
-	struct bm_buffer buf = {
-		.hi = 0,
-		.lo = fqid
-	};
-	int ret = bman_release(fq_pool, &buf, 1, BMAN_RELEASE_FLAG_WAIT);
-	BUG_ON(ret);
-	bman_free_pool(fq_pool);
-}
-
-#else /* !defined(CONFIG_FSL_QMAN_FQALLOCATOR) */
-
-/* No dynamic allocation, use FQID==1 */
-static u32 fqid = 1;
-#define alloc_fqid()	0
-#define free_fqid()	do { ; } while(0)
-
-#endif /* !defined(CONFIG_FSL_QMAN_FQALLOCATOR) */
-
-/* Boolean switch for handling EQCR_ITR */
-static int eqcr_thresh_on;
-
-/* Test frame-descriptor, and another one to track dequeues */
-static struct qm_fd fd, fd_dq;
-
-/* Helpers for initialising and "incrementing" a frame descriptor */
-static void fd_init(struct qm_fd *__fd)
-{
-	__fd->addr_hi = 0xab;		/* high 16-bits */
-	__fd->addr_lo = 0xdeadbeef;	/* low 32-bits */
-	__fd->format = qm_fd_contig_big;
-	__fd->length29 = 0x0000ffff;
-	__fd->cmd = 0xfeedf00d;
-}
-
-static void fd_inc(struct qm_fd *__fd)
-{
-	__fd->addr_lo++;
-	__fd->addr_hi--;
-	__fd->length29--;
-	__fd->cmd++;
-}
-
-/* Helper for qm_mc_start() that checks the return code */
-static void mc_start(void)
-{
-	mcc = qm_mc_start(portal);
-	BUG_ON(!mcc);
-}
-
-/* Helper for qm_mc_result() that checks the response */
-#define mc_commit(v) \
-do { \
-	qm_mc_commit(portal, v); \
-	do { \
-		mcr = qm_mc_result(portal); \
-	} while (!mcr); \
-	BUG_ON((mcr->verb & QM_MCR_VERB_MASK) != v); \
-	BUG_ON(mcr->result != QM_MCR_RESULT_OK); \
-} while(0)
-
-/* Track EQCR consumption */
-static void eqcr_update(void)
-{
-	u32 status = qm_isr_status_read(portal);
-	if (status & QM_PIRQ_EQRI) {
-		int progress = qm_eqcr_cci_update(portal);
-		BUG_ON(!progress);
-		BUG_ON(!eqcr_thresh_on);
-		qm_eqcr_set_ithresh(portal, 0);
-		eqcr_thresh_on = 0;
-		pr_info("Auto-update of EQCR consumption\n");
-		qm_isr_status_clear(portal, progress & QM_PIRQ_EQRI);
-	}
-}
-
-/* Helper for qm_eqcr_start() that tracks ring consumption and checks the
- * return code */
-static void eqcr_start(void)
-{
-	/* If there are consumed EQCR entries, track them now. The alternative
-	 * is to catch an error in qm_eqcr_start(), track consume entries then,
-	 * and then retry qm_eqcr_start(). */
-	do {
-		eqcr_update();
-		eq = qm_eqcr_start(portal);
-	} while (!eq);
-}
-
-/* Wait for EQCR to empty */
-static void eqcr_empty(void)
-{
-	do {
-		eqcr_update();
-	} while (qm_eqcr_get_fill(portal));
-}
-
-/* Helper for qm_eqcr_pvb_commit() */
-static void eqcr_commit(void)
-{
-	qm_eqcr_pvb_commit(portal, TEQVERB);
-	if (!eqcr_thresh_on && (qm_eqcr_get_avail(portal) < 2)) {
-		eqcr_thresh_on = 1;
-		qm_eqcr_set_ithresh(portal, 1);
-	}
-}
-
-/* Track DQRR consumption */
-static void dqrr_update(void)
-{
-	do {
-		qm_dqrr_pvb_update(portal);
-		dq = qm_dqrr_current(portal);
-		if (!dq)
-			qm_dqrr_pvb_prefetch(portal);
-	} while (!dq);
-}
-
-/* Helper for qm_dqrr_cci_consume() */
-static void dqrr_consume_and_next(void)
-{
-	qm_dqrr_next(portal);
-	qm_dqrr_cci_consume_to_current(portal);
-	qm_dqrr_pvb_prefetch(portal);
-}
-
-static void mr_update(void)
-{
-	do {
-		qm_mr_pvb_update(portal);
-		mr = qm_mr_current(portal);
-	} while (!mr);
-}
-
-static void mr_consume_and_next(void)
-{
-	qm_mr_next(portal);
-	qm_mr_cci_consume_to_current(portal);
-}
-
-static irqreturn_t portal_isr(int irq, void *ptr)
-{
-	pr_info("QMAN portal interrupt, isr_count=%d->%d\n", isr_count,
-		isr_count + 1);
-	isr_count++;
-	qm_isr_inhibit(portal);
-	wake_up(&queue);
-	return IRQ_HANDLED;
-}
-
-void qman_test_low(struct qm_portal *__p)
-{
-	cpumask_t oldmask = current->cpus_allowed, newmask = CPU_MASK_NONE;
-	const struct qm_portal_config *config = qm_portal_config(__p);
-	int i;
-	u32 status;
-
-	portal = __p;
-	fd_init(&fd);
-	fd_init(&fd_dq);
-	isr_count = 0;
-
-	pr_info("qman_test_low starting\n");
-
-	/* If the portal is affine, run on the corresponding cpu */
-	if (config->cpu != -1) {
-		cpu_set(config->cpu, newmask);
-		if (set_cpus_allowed(current, newmask))
-			panic("can't schedule to affine cpu");
-	}
-
-	alloc_fqid();
-	/*********************/
-	/* Initialise portal */
-	/*********************/
-	if (qm_eqcr_init(portal, qm_eqcr_pvb, qm_eqcr_cci) ||
-		qm_dqrr_init(portal,
-			qm_dqrr_dpush, qm_dqrr_pvb, qm_dqrr_cci,
-			DQRR_MAXFILL,
-			(config->cpu == -1) ? 0 : 1,
-			(config->cpu == -1) ? 0 : 1) ||
-		qm_mr_init(portal, qm_mr_pvb, qm_mr_cci) ||
-		qm_mc_init(portal) || qm_isr_init(portal))
-		panic("Portal setup failed");
-	/* Set interrupt register values (eg. for post reboot) */
-	qm_isr_enable_write(portal, 0);
-	qm_isr_disable_write(portal, 0);
-	qm_isr_uninhibit(portal);
-	qm_isr_status_clear(portal, 0xffffffff);
-
-	pr_info("low-level test, start ccmode\n");
-
-	if (request_irq(config->irq, portal_isr, 0, "Qman portal 0", NULL))
-		panic("Can't register Qman portal 0 IRQ");
-	pr_info("Portal %d channel i/faces initialised\n", config->channel);
-
-	/*****************/
-	/* Initialise FQ */
-	/*****************/
-	mc_start();
-	mcc->initfq.we_mask = QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_CONTEXTB;
-	mcc->initfq.fqid = fqid;
-	mcc->initfq.count = 0;
-	/* mcc->initfq.fqd.fq_ctrl = 0; */ /* (QM_FQCTRL_***) */
-	mcc->initfq.fqd.dest.channel = config->channel;
-	mcc->initfq.fqd.dest.wq = TWQ;
-	mcc->initfq.fqd.context_b = TCONTEXTB;
-	mc_commit(QM_MCC_VERB_INITFQ_PARKED);
-	pr_info("FQ %d initialised for channel %d, wq %d\n", fqid,
-		config->channel, TWQ);
-
-	/* The portal's (interrupt) status register should be zero */
-	status = qm_isr_status_read(portal);
-	BUG_ON(status);
-
-	/**************************/
-	/* Enqueue TFRAMES frames */
-	/**************************/
-	for (i = 0; i < TFRAMES; i++) {
-		/* Enqueue the test frame-descriptor */
-		eqcr_start();
-		eq->fqid = fqid;
-		memcpy(&eq->fd, &fd, sizeof(fd));
-		eqcr_commit();
-		pr_info("Enqueued frame %d: %08x\n", i, fd.addr_lo);
-		/* Modify the frame-descriptor for next time */
-		fd_inc(&fd);
-	}
-	eqcr_empty();
-
-	/* The portal's (interrupt) status register should be zero */
-	status = qm_isr_status_read(portal);
-	BUG_ON(status);
-
-	/***************/
-	/* Schedule FQ */
-	/***************/
-	/* enable the interrupt source before it asserts */
-	qm_isr_enable_write(portal, QM_DQAVAIL_PORTAL);
-	qm_isr_uninhibit(portal);
-	mc_start();
-	mcc->alterfq.fqid = fqid;
-	mc_commit(QM_MCC_VERB_ALTER_SCHED);
-	pr_info("FQ %d scheduled\n", fqid);
-	/* The interrupt should have fired immediately. */
-	wait_event(queue, isr_count == 1);
-	/* The status register should show DQAVAIL. */
-	do {
-		status = qm_isr_status_read(portal);
-	} while (status != QM_DQAVAIL_PORTAL);
-	/* Writing to clear should fail due to an immediate reassertion */
-	qm_isr_status_clear(portal, status);
-	do {
-		status = qm_isr_status_read(portal);
-	} while (status != QM_DQAVAIL_PORTAL);
-	/* Zeroing the enable register before unihibiting should prevent any
-	 * interrupt */
-	qm_isr_enable_write(portal, 0);
-	qm_isr_uninhibit(portal);
-	BUG_ON(isr_count != 1);
-
-	/******************************/
-	/* SDQCR the remaining frames */
-	/******************************/
-
-	/* Initiate SDQCR (static dequeue command) */
-	qm_dqrr_sdqcr_set(portal, QM_SDQCR_SOURCE_CHANNELS |
-		QM_SDQCR_TYPE_PRIO_QOS | QM_SDQCR_TOKEN_SET(TTOKEN) |
-		QM_SDQCR_CHANNELS_DEDICATED);
-
-	/* The status register should have the sticky 'DQAVAIL' from before, and
-	 * maybe DQRI (it's on its way). */
-	status = qm_isr_status_read(portal);
-	BUG_ON(!(status & QM_DQAVAIL_PORTAL));
-	qm_isr_enable_write(portal, QM_PIRQ_DQRI);
-	wait_event(queue, isr_count == 2);
-	do {
-		status = qm_isr_status_read(portal);
-	} while (!(status & QM_PIRQ_DQRI));
-	/* Writing to clear should fail due to an immediate reassertion. NB
-	 * also, DQAVAIL_PORTAL mightn't disappear right away, the dequeues are
-	 * delayed so the FQ may stay truly-scheduled for a bit... */
-	qm_isr_status_clear(portal, status);
-	do {
-		status = qm_isr_status_read(portal);
-	} while (!(status & QM_PIRQ_DQRI));
-	/* Zeroing the enable register before unihibiting should prevent any
-	 * interrupt */
-	qm_isr_enable_write(portal, 0);
-	qm_isr_uninhibit(portal);
-	BUG_ON(isr_count != 2);
-	for (i = 0; i < TFRAMES; i++)
-	{
-		dqrr_update();
-		BUG_ON((dq->verb & QM_DQRR_VERB_MASK) !=
-				QM_DQRR_VERB_FRAME_DEQUEUE);
-		pr_info("Dequeued SDQCR frame %d: %08x\n", i, dq->fd.addr_lo);
-		if ((i + 1) == TFRAMES)
-			BUG_ON(!(dq->stat & QM_DQRR_STAT_FQ_EMPTY));
-		else
-			BUG_ON(dq->stat & QM_DQRR_STAT_FQ_EMPTY);
-		BUG_ON(dq->stat & QM_DQRR_STAT_FQ_HELDACTIVE);
-		BUG_ON(dq->stat & QM_DQRR_STAT_FQ_FORCEELIGIBLE);
-		BUG_ON(!(dq->stat & QM_DQRR_STAT_FD_VALID));
-		BUG_ON(dq->stat & QM_DQRR_STAT_UNSCHEDULED);
-		BUG_ON(dq->tok != TTOKEN);
-		BUG_ON(dq->fqid != fqid);
-		BUG_ON(dq->contextB != TCONTEXTB);
-		fd_dq.liodn_offset = dq->fd.liodn_offset;
-		fd_dq.eliodn_offset = dq->fd.eliodn_offset;
-		BUG_ON(memcmp(&dq->fd, &fd_dq, sizeof(fd_dq)));
-		/* Modify the frame-descriptor for next time */
-		fd_inc(&fd_dq);
-		dqrr_consume_and_next();
-	}
-	/* Clear stick bits from the status register, and it should
-	 * now remain zero. */
-	status = qm_isr_status_read(portal);
-	qm_isr_status_clear(portal, status);
-	status = qm_isr_status_read(portal);
-	BUG_ON(status);
-
-	pr_info("low-level test, end ccmode\n");
-
-	/*************/
-	/* Retire FQ */
-	/*************/
-	mc_start();
-	mcc->alterfq.fqid = fqid;
-	mc_commit(QM_MCC_VERB_ALTER_RETIRE);
-	pr_info("FQ %d retired\n", fqid);
-
-	/*****************/
-	/* Consume FQRNI */
-	/*****************/
-	mr_update();
-	BUG_ON((mr->verb & QM_MR_VERB_TYPE_MASK) != QM_MR_VERB_FQRNI);
-	pr_info("Received FQRNI message\n");
-	hexdump(mr, 32);
-	BUG_ON(mr->fq.fqid != fqid);
-	BUG_ON(mr->fq.fqs);
-	BUG_ON(mr->fq.contextB != TCONTEXTB);
-	mr_consume_and_next();
-
-	/**********/
-	/* OOS FQ */
-	/**********/
-	mc_start();
-	mcc->alterfq.fqid = fqid;
-	mc_commit(QM_MCC_VERB_ALTER_OOS);
-	pr_info("FQ %d OOS'd\n", fqid);
-
-	/************/
-	/* Teardown */
-	/************/
-	eqcr_empty();
-	free_irq(config->irq, NULL);
-	qm_eqcr_finish(portal);
-	qm_dqrr_finish(portal);
-	qm_mr_finish(portal);
-	qm_mc_finish(portal);
-	qm_isr_finish(portal);
-	free_fqid();
-	if (config->cpu != -1)
-		if (set_cpus_allowed(current, oldmask))
-			panic("can't restore old cpu mask");
-	pr_info("qman_test_low finished\n");
-}
-
-- 
1.6.5.2

