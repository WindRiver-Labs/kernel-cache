From a82124acdb5769619aae6a55ac56590f706a635e Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 21 Dec 2010 13:33:29 +0800
Subject: [PATCH 21/28] DPAA: Update DPA/FMan driver on standard branch

Patch taken from FSL vendor SDK 2.2

Update FMan low level driver/API.
Update Freescale DPA(data-path) ethernet driver.

Add FMAN processor kernel option to support different board.
Change dpa.c(h) to dpaa_eth.c(h)
Remove the ioctls files.
Add Fman operation files: m_manip.c(h).
Modify code style.
Add more asserations and exceptions code o perfect code.
Add process branch for 10G Ethernet operation

integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/dpa/Makefile                           |    2 +-
 drivers/net/dpa/NetCommSw/Kconfig                  |   11 +
 drivers/net/dpa/NetCommSw/Makefile                 |    2 +-
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   |  465 ++--
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   |  131 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |   11 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |   21 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |   28 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    |  139 +-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   | 2156 ++++++++++------
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h   |  311 +++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   | 1775 ++++++------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 1478 ++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  154 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  |  976 ++++---
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h  |  460 +---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |  274 ++-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c |  750 +++---
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |  182 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 1579 ++++++++----
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  211 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |  331 ++-
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c  |    7 +
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h  |    2 -
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      |  949 +++++--
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |   92 +-
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |  323 ++-
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |  418 ++--
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  400 ++-
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |   10 +-
 drivers/net/dpa/NetCommSw/etc/mm.c                 | 1025 ++++----
 drivers/net/dpa/NetCommSw/etc/mm.h                 |   12 +-
 .../net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h   |  192 ++
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h |  326 ++--
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |   29 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |    2 +-
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h |  638 +++--
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  345 ++-
 drivers/net/dpa/NetCommSw/inc/core_ext.h           |   18 +-
 drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h   |   43 +
 drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h      |   14 +-
 drivers/net/dpa/NetCommSw/inc/debug_ext.h          |    9 +-
 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h        |    2 +-
 .../inc/integrations/P4080/dpaa_integration_ext.h  |  133 +-
 .../inc/integrations/P4080/part_integration_ext.h  |  476 +++-
 .../net/dpa/NetCommSw/inc/integrations/part_ext.h  |    2 +
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |   37 +-
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |   10 +-
 drivers/net/dpa/NetCommSw/inc/types_ext.h          |   29 +-
 drivers/net/dpa/NetCommSw/inc/xx_ext.h             |  272 +--
 .../NetCommSw/integrations/P4080/module_strings.c  |    8 +-
 drivers/net/dpa/NetCommSw/ncsw_config.mk           |    8 +-
 .../kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h   |  292 --
 .../2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h      | 1501 ----------
 .../2.6/inc/ioctl/Peripherals/fm_port_ioctls.h     |  595 ----
 .../2.6/inc/ioctl/Peripherals/fm_test_ioctls.h     |  179 --
 .../ioctl/integrations/P4080/integration_ioctls.h  |   47 -
 .../user/env/linux/kernel/2.6/inc/ioctl/ioctls.h   |   96 -
 .../env/linux/kernel/2.6/inc/ioctl/net_ioctls.h    |  365 ---
 .../user/env/linux/kernel/2.6/inc/system/sys_ext.h |  130 +-
 .../2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |    1 +
 .../2.6/system/platform/P4080/platform_p4080_ds.c  |   18 +
 .../user/env/linux/kernel/2.6/system/sys_io.c      |   10 +
 .../kernel/2.6/wrappers/Peripherals/FM/Makefile    |    2 +-
 .../kernel/2.6/wrappers/Peripherals/FM/firmware.S  |    4 -
 .../kernel/2.6/wrappers/Peripherals/FM/fman_test.c |  126 +-
 .../Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin   |  Bin 6576 -> 0 bytes
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c | 1490 +++++++---
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h |   21 +-
 .../2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c |  131 +-
 .../user/env/linux/kernel/2.6/xx/xx_linux.c        |   47 +-
 drivers/net/dpa/dpa-common.h                       |   26 +-
 drivers/net/dpa/dpa-ethtool.c                      |  113 +-
 drivers/net/dpa/dpa.c                              | 2522 -----------------
 drivers/net/dpa/dpa.h                              |   89 -
 drivers/net/dpa/dpaa_eth-common.h                  |  141 +
 drivers/net/dpa/dpaa_eth.c                         | 2869 ++++++++++++++++++++
 drivers/net/dpa/dpaa_eth.h                         |  134 +
 drivers/net/dpa/fm-wrapper.c                       |   19 +-
 drivers/net/dpa/fm-wrapper.h                       |    2 +-
 drivers/net/dpa/fm.c                               |  119 +-
 drivers/net/dpa/fm.h                               |    2 +-
 drivers/net/dpa/fman-conf.h                        |    6 +-
 drivers/net/dpa/mac-api.c                          |   95 +-
 drivers/net/dpa/mac.c                              |   82 +-
 drivers/net/dpa/mac.h                              |    3 +-
 drivers/net/dpa/port-wrapper.c                     |   24 +-
 drivers/net/dpa/port.c                             |   75 +-
 drivers/net/dpa/port.h                             |    2 +-
 drivers/net/dpa/xgmac_mdio.c                       |    3 +-
 drivers/net/dpa/xgmac_mdio.h                       |    3 +-
 91 files changed, 16176 insertions(+), 12486 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
 delete mode 100644 drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin
 delete mode 100644 drivers/net/dpa/dpa.c
 delete mode 100644 drivers/net/dpa/dpa.h
 create mode 100644 drivers/net/dpa/dpaa_eth-common.h
 create mode 100644 drivers/net/dpa/dpaa_eth.c
 create mode 100644 drivers/net/dpa/dpaa_eth.h

diff --git a/drivers/net/dpa/Makefile b/drivers/net/dpa/Makefile
index afd5903..4a5b563 100644
--- a/drivers/net/dpa/Makefile
+++ b/drivers/net/dpa/Makefile
@@ -12,5 +12,5 @@ EXTRA_CFLAGS += -I$(NET_DPA)
 obj-$(CONFIG_FSL_FMAN) += NetCommSw/
 obj-$(CONFIG_DPA) += fsl-mac.o fsl-dpa.o
 
-fsl-dpa-objs	:= dpa-ethtool.o dpa.o xgmac_mdio.o
+fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth.o xgmac_mdio.o
 fsl-mac-objs	:= mac.o mac-api.o
diff --git a/drivers/net/dpa/NetCommSw/Kconfig b/drivers/net/dpa/NetCommSw/Kconfig
index 0abebdb..5b94a17 100644
--- a/drivers/net/dpa/NetCommSw/Kconfig
+++ b/drivers/net/dpa/NetCommSw/Kconfig
@@ -15,6 +15,17 @@ config FSL_FMAN_TEST
 	---help---
 	  This option compiles test code for FMan.
 
+menu "FMAN Processor support"
+choice
+	depends on FSL_FMAN
+	prompt "Processor Type"
+
+config FMAN_P4080
+	bool "P4080"
+
+endchoice
+endmenu
+
 endif # FSL_FMAN
 
 endmenu
diff --git a/drivers/net/dpa/NetCommSw/Makefile b/drivers/net/dpa/NetCommSw/Makefile
index a92ee12..e2db8b5 100644
--- a/drivers/net/dpa/NetCommSw/Makefile
+++ b/drivers/net/dpa/NetCommSw/Makefile
@@ -7,6 +7,6 @@ EXTRA_CFLAGS           += -DVERSION=\"\"
 include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
 #
 obj-y		+= etc/
-obj-y		+= integrations/P4080/
+obj-$(CONFIG_FMAN_P4080)	+= integrations/P4080/
 obj-y		+= Peripherals/FM/
 obj-y		+= user/env/linux/kernel/2.6/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index dceeac0..0b6baa0 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -39,8 +39,6 @@
 #include "fm_hc.h"
 
 
-#define __ERR_MODULE__  MODULE_FM_PCD
-
 #define HC_HCOR_OPCODE_PLCR_PRFL            0x0
 #define HC_HCOR_OPCODE_KG_SCM               0x1
 #define HC_HCOR_OPCODE_SYNC                 0x2
@@ -54,72 +52,15 @@
 #define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
 #define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
 
-#define BUILD_FD(len)                                                           \
-do {                                                                            \
-        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
-        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
-        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
-        FM_FD_SET_LENGTH(&fmFd, len);                                           \
-} while (0)
-
-#define ENQUEUE_FRM(frm)                                                        \
-do {                                                                            \
-    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
-    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
-    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
-    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
-    DBG(TRACE, ("Send Hc 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",       \
-            p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
-    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm);   \
-    if(err)                                                                     \
-        RETURN_ERROR(MINOR, err, ("HC enqueue failed"));                        \
-    while (p_FmHc->wait[savedSeqNum]) ;                                         \
-} while (0)
-
-#define ENQUEUE_FRM_RET_NULL(frm)                                               \
-do {                                                                            \
-    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
-    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
-    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
-    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
-    DBG(TRACE, ("Send Hc Null 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",  \
-            p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
-    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm);   \
-    if(err)  {                                                                  \
-        REPORT_ERROR(MINOR, err, ("HC enqueue failed")); return NULL;           \
-    }                                                                           \
-    while (p_FmHc->wait[savedSeqNum]) ;                                         \
-} while (0)
-
-#define TRY_LOCK                                                                \
-do {                                                                            \
-    uint32_t intFlags;                                                          \
-    intFlags = XX_DisableAllIntr();                                             \
-    if (p_FmHc->lock)                                                           \
-    {                                                                           \
-        XX_RestoreAllIntr(intFlags);                                            \
-        return ERROR_CODE(E_BUSY);                                              \
-    }                                                                           \
-    p_FmHc->lock = TRUE;                                                        \
-    XX_RestoreAllIntr(intFlags);                                                \
-} while (0)
-
-#define TRY_LOCK_RETURN_NULL                                                    \
-do {                                                                            \
-    uint32_t intFlags;                                                          \
-    intFlags = XX_DisableAllIntr();                                             \
-    if (p_FmHc->lock)                                                           \
-    {                                                                           \
-        XX_RestoreAllIntr(intFlags);                                            \
-        REPORT_ERROR(MINOR, E_BUSY, ("nested host-commands!"));                 \
-        return NULL;                                                            \
-    }                                                                           \
-    p_FmHc->lock = TRUE;                                                        \
-    XX_RestoreAllIntr(intFlags);                                                \
+#define BUILD_FD(len)                   \
+do {                                    \
+    memset(&fmFd, 0, sizeof(t_DpaaFD));   \
+    DPAA_FD_SET_ADDR(&fmFd, &hcFrame);    \
+    DPAA_FD_SET_OFFSET(&fmFd, 0);         \
+    DPAA_FD_SET_LENGTH(&fmFd, len);       \
 } while (0)
 
 
-
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
@@ -146,17 +87,16 @@ typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
 } _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
 
 typedef _Packed struct t_FmPcdKgPortRegs {
-    volatile uint32_t                spReg;
-    volatile uint32_t                cppReg;
+    volatile uint32_t                       spReg;
+    volatile uint32_t                       cppReg;
 } _PackedType t_FmPcdKgPortRegs;
 
 typedef _Packed struct t_HcFrame {
-    volatile uint32_t                    opcode;
-    volatile uint32_t                    actionReg;
-    volatile uint32_t                    extraReg;
-    volatile uint32_t                    commandSequence;
-    union
-    {
+    volatile uint32_t                       opcode;
+    volatile uint32_t                       actionReg;
+    volatile uint32_t                       extraReg;
+    volatile uint32_t                       commandSequence;
+    union {
         t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
         t_FmPcdKgInterModuleSchemeRegs      schemeRegsWithoutCounter;
         t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
@@ -171,48 +111,47 @@ typedef _Packed struct t_HcFrame {
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
+
 typedef struct t_FmHc {
     t_Handle                    h_FmPcd;
     t_Handle                    h_HcPortDev;
-    uint32_t                    enqFqid;            /**< Host-Command enqueue Queue Id. */
-    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enquing frames to the QM */
-    t_Handle                    h_QmArg;            /**< A handle to the QM module */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enqueing frames to the QM */
+    t_Handle                    h_QmArg;          /**< A handle to the QM module */
 
     uint32_t                    seqNum;
     volatile bool               wait[32];
 } t_FmHc;
 
 
-static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, volatile uint32_t *p_SeqNum)
 {
-    t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
-    int                     i;
-    t_Error                 err = E_OK;
-
-    ASSERT_COND(p_FmHc);
-
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
-    {
-        memset(&hcFrame, 0, sizeof(hcFrame));
-        hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-        hcFrame.actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
-        hcFrame.extraReg = 0xFFFFF800;
-        hcFrame.commandSequence = p_FmHc->seqNum;
-        memcpy((void*)&hcFrame.hcSpecificData.clsPlanEntries, (void*)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
-
-        BUILD_FD(sizeof(hcFrame));
+    t_Error     err = E_OK;
+    uint32_t    savedSeqNum;
+    uint32_t    intFlags;
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    *p_SeqNum = p_FmHc->seqNum;
+    savedSeqNum = p_FmHc->seqNum;
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);
+    p_FmHc->wait[savedSeqNum] = TRUE;
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    DBG(TRACE, ("Send Hc, SeqNum %d, FD@0x%x, fd offset 0x%x",
+                savedSeqNum,DPAA_FD_GET_ADDR(p_FmFd),DPAA_FD_GET_OFFSET(p_FmFd)));
+    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, (void *)p_FmFd);
+    if(err)
+        RETURN_ERROR(MINOR, err, ("HC enqueue failed"));
 
-        ENQUEUE_FRM(&fmFd);
-    }
+    while (p_FmHc->wait[savedSeqNum]) ;
 
-    return E_OK;
+    return err;
 }
 
+
 static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_OldPointer, t_Handle p_NewPointer)
 {
     t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
+    t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
@@ -229,12 +168,11 @@ static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_Ol
         hcFrame.extraReg   = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_OldPointer);
     if(hcFrame.extraReg == ILLEGAL_BASE)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    ENQUEUE_FRM(&fmFd);
-
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
     return E_OK;
 }
 
@@ -253,6 +191,7 @@ static t_Error CcHcDynamicChangeForNextEngine(t_FmHc *p_FmHc, t_Handle h_OldPoin
 
     return FmPcdCcReleaseModifiedOnlyNextEngine(p_FmHc->h_FmPcd, h_OldPointer, h_NewPointer, TRUE);
 }
+
 static t_Error HcDynamicChangeForKey(t_FmHc *p_FmHc,t_Handle  *h_OldPointersLst, t_Handle h_NewPointer)
 {
 
@@ -289,7 +228,7 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     t_Error         err = E_OK;
 #endif /* !CONFIG_GUEST_PARTITION */
 
-    p_FmHc = XX_Malloc(sizeof(t_FmHc));
+    p_FmHc = (t_FmHc *)XX_Malloc(sizeof(t_FmHc));
     if (!p_FmHc)
     {
         REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC obj"));
@@ -298,7 +237,6 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     memset(p_FmHc,0,sizeof(t_FmHc));
 
     p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
-    p_FmHc->enqFqid             = p_FmHcParams->params.enqFqid;
     p_FmHc->f_QmEnqueue         = p_FmHcParams->params.f_QmEnqueue;
     p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
 
@@ -307,11 +245,12 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
     fmPortParam.portType    = e_FM_PORT_TYPE_OH_HOST_COMMAND;
     fmPortParam.portId      = p_FmHcParams->params.portId;
+    fmPortParam.liodnBase   = p_FmHcParams->params.liodnBase;
     fmPortParam.h_Fm        = p_FmHcParams->h_Fm;
 
     fmPortParam.specificParams.nonRxParams.errFqid      = p_FmHcParams->params.errFqid;
     fmPortParam.specificParams.nonRxParams.dfltFqid     = p_FmHcParams->params.confFqid;
-    fmPortParam.specificParams.nonRxParams.deqSubPortal = p_FmHcParams->params.deqSubPortal;
+    fmPortParam.specificParams.nonRxParams.qmChannel    = p_FmHcParams->params.qmChannel;
 
     p_FmHc->h_HcPortDev = FM_PORT_Config(&fmPortParam);
     if(!p_FmHc->h_HcPortDev)
@@ -324,7 +263,14 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     /* final init */
     if ((err = FM_PORT_Init(p_FmHc->h_HcPortDev)) != E_OK)
     {
-        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+
+    if ((err = FM_PORT_Enable(p_FmHc->h_HcPortDev)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
         FmHcFree(p_FmHc);
         return NULL;
     }
@@ -346,23 +292,26 @@ void FmHcFree(t_Handle h_FmHc)
     XX_Free(p_FmHc);
 }
 
-void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
+void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame   *p_HcFrame;
+    uint32_t    intFlags;
 
     ASSERT_COND(p_FmHc);
 
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
     p_HcFrame  = CAST_UINT64_TO_POINTER_TYPE(t_HcFrame,
-                                             (CAST_POINTER_TO_UINT64(FM_FD_GET_ADDR(p_Fd)) + FM_FD_GET_OFFSET(p_Fd)));
+                                             (CAST_POINTER_TO_UINT64(DPAA_FD_GET_ADDR(p_Fd)) + DPAA_FD_GET_OFFSET(p_Fd)));
 
-    DBG(TRACE, ("Hc Conf 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",
-            p_FmHc,p_HcFrame->commandSequence,FM_FD_GET_ADDR(p_Fd),FM_FD_GET_OFFSET(p_Fd)));
+    DBG(TRACE, ("Hc Conf, SeqNum %d, FD@0x%x, fd offset 0x%x",
+                p_HcFrame->commandSequence,DPAA_FD_GET_ADDR(p_Fd),DPAA_FD_GET_OFFSET(p_Fd)));
 
     if (!(p_FmHc->wait[p_HcFrame->commandSequence]))
-        REPORT_ERROR(MINOR, E_INVALID_FRAME, ("Not an Host-Command frame recieved!"));
+        REPORT_ERROR(MINOR, E_INVALID_FRAME, ("Not an Host-Command frame received!"));
     else
         p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 }
 
 t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
@@ -371,30 +320,23 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     t_Error                             err = E_OK;
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
+    uint32_t                            intFlags;
     uint8_t                             physicalSchemeId, relativeSchemeId;
 
-    if (FmPcdTryLock(p_FmHc->h_FmPcd))
-        return NULL;
-
     if(!p_Scheme->modify)
     {
         /* check that schameId is in range */
         if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
         {
-            FmPcdReleaseLock(p_FmHc->h_FmPcd);
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
             return NULL;
         }
 
         relativeSchemeId = p_Scheme->id.relativeSchemeId;
 
-        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
-        {
-            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE))
             return NULL;
-        }
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
 
         physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
 
@@ -402,11 +344,15 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
         hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
         hcFrame.extraReg = 0xFFFFF800;
-        hcFrame.commandSequence = p_FmHc->seqNum;
 
         BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-        ENQUEUE_FRM_RET_NULL(&fmFd);
+        if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return NULL;
+        }
 
         /* check if this scheme is already used */
         if (FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
@@ -418,21 +364,18 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     }
     else
     {
+        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
         physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
         if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         {
-            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
             return NULL;
         }
-        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
-        {
-            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, TRUE);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        if (err)
             return NULL;
-        }
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
-
     }
 
     err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs);
@@ -447,7 +390,6 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     memcpy(&hcFrame.hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
     //p_NewStruct= (t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData;
     if(!p_Scheme->schemeCounter.update)
@@ -457,7 +399,12 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM_RET_NULL(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        return NULL;
+    }
 
     FmPcdKgValidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
 
@@ -471,18 +418,13 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
     uint8_t                             relativeSchemeId;
     uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
-    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
 
-    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
-    if (err)
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
@@ -500,11 +442,14 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     hcFrame.extraReg = 0xFFFFF800;
     memset(&hcFrame.hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     FmPcdKgInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
 
@@ -518,37 +463,38 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
     uint32_t                            retVal;
     uint8_t                             relativeSchemeId;
     uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
-    if (FmPcdTryLock(p_FmHc->h_FmPcd))
-        return 0;
-
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
     if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
         return 0;
     }
 
-    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
-    if (err)
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("Scheme lock"));
         return 0;
+    }
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        return 0;
+    }
 
     if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
     {
@@ -565,38 +511,32 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 
 t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value)
 {
-
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
     uint8_t                             relativeSchemeId, physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
-    if (FmPcdTryLock(p_FmHc->h_FmPcd))
-        return ERROR_CODE(E_BUSY);
-
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
     if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
-    {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-    }
 
-    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
-    if (err)
-        return err;
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* first read scheme and check that it is valid */
     memset(&hcFrame, 0, sizeof(hcFrame));
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     /* check that scheme is valid */
     if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
@@ -609,19 +549,49 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     /* write counter */
     hcFrame.hcSpecificData.schemeRegs.kgse_spc = value;
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
 
     return E_OK;
 }
 
+t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               hcFrame;
+    t_DpaaFD                fmFd;
+    int                     i;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+        hcFrame.actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+        hcFrame.extraReg = 0xFFFFF800;
+        memcpy((void*)&hcFrame.hcSpecificData.clsPlanEntries, (void*)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+
+        BUILD_FD(sizeof(hcFrame));
+
+        if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    return err;
+}
+#if 0
 t_Handle FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp)
 {
     t_FmHc                          *p_FmHc = (t_FmHc*)h_FmHc;
@@ -646,11 +616,11 @@ t_Handle FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Gr
 
     return h_ClsPlanGrp;
 }
+#endif
 
-t_Error FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp)
+t_Error FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t  grpId)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    uint8_t                             grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
     t_FmPcdKgInterModuleClsPlanSet      clsPlanSet;
 
     /* clear clsPlan entries in memory */
@@ -658,7 +628,7 @@ t_Error FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp)
     clsPlanSet.numOfClsPlanEntries = FmPcdKgGetClsPlanGrpSize(p_FmHc->h_FmPcd, grpId);
     memset(clsPlanSet.vectors, 0, clsPlanSet.numOfClsPlanEntries*sizeof(uint32_t));
 
-    KgHcSetClsPlan(p_FmHc, &clsPlanSet);
+    FmHcPcdKgSetClsPlan(p_FmHc, &clsPlanSet);
 
     FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
 
@@ -668,22 +638,22 @@ t_Error FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp)
 t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_FmPcdPlcrInterModuleProfileRegs              profileRegs;
+    t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
     t_Error                             err = E_OK;
+    uint32_t                            intFlags;
     uint16_t                            profileIndx;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
 
     if (p_Profile->modify)
     {
         profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
-        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, FALSE))
             return NULL;
     }
     else
     {
-        if (FmPcdTryLock(p_FmHc->h_FmPcd))
-            return NULL;
+        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
         err = FmPcdPlcrGetAbsoluteProfileId(p_FmHc->h_FmPcd,
                                             p_Profile->id.newParams.profileType,
                                             p_Profile->id.newParams.h_FmPort,
@@ -694,12 +664,10 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
-        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
-        {
-            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        err = FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, TRUE);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        if (err)
             return NULL;
-        }
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
     }
 
     if(!p_Profile->modify)
@@ -708,11 +676,15 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
         hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
         hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
         hcFrame.extraReg = 0x00008000;
-        hcFrame.commandSequence = p_FmHc->seqNum;
 
         BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-        ENQUEUE_FRM_RET_NULL(&fmFd);
+        if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        {
+            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return NULL;
+        }
 
         /* check if this scheme is already used */
         if (FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
@@ -736,12 +708,16 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
     hcFrame.extraReg = 0x00008000;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     memcpy(&hcFrame.hcSpecificData.profileRegs, &profileRegs, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM_RET_NULL(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        return NULL;
+    }
 
     FmPcdPlcrValidateProfileSw(p_FmHc->h_FmPcd, profileIndx);
 
@@ -756,9 +732,9 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
         return ERROR_CODE(E_BUSY);
 
     FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
@@ -767,12 +743,15 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     hcFrame.actionReg  |= 0x00008000;
     hcFrame.extraReg = 0x00008000;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     memset(&hcFrame.hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
 
@@ -786,9 +765,9 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
         return ERROR_CODE(E_BUSY);
 
     /* first read scheme and check that it is valid */
@@ -796,11 +775,14 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
     hcFrame.extraReg = 0x00008000;
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     /* check that profile is valid */
     if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
@@ -813,12 +795,15 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     hcFrame.actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
     hcFrame.extraReg = 0x00008000;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     hcFrame.hcSpecificData.singleRegForWrite = value;
 
     BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
 
@@ -831,12 +816,12 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
-    t_FmFD                              fmFd;
+    t_DpaaFD                            fmFd;
     uint32_t                            retVal;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
         return 0;
 
     /* first read scheme and check that it is valid */
@@ -844,11 +829,15 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
     hcFrame.extraReg = 0x00008000;
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        return 0;
+    }
 
     /* check that profile is valid */
     if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
@@ -889,8 +878,12 @@ t_Error FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error     err = E_OK;
     t_Handle    h_OldPointer, h_NewPointer;
+    uint32_t    intFlags;
 
-    if ((err = FmPcdCcTreeTryLock(h_CcTree)) != E_OK)
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    err = FmPcdCcTreeTryLock(h_CcTree);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    if (err)
         return err;
 
     err = FmPcdCcModifyNextEngineParamTree(p_FmHc->h_FmPcd, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams,
@@ -912,19 +905,19 @@ t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_
     t_Error     err = E_OK;
     t_Handle    h_OldPointer, h_NewPointer;
     t_List      h_List;
+    uint32_t    intFlags;
 
     INIT_LIST(&h_List);
 
-    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
     err = FmPcdCcModiyNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
     if(err)
     {
@@ -942,20 +935,20 @@ t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error     err = E_OK;
     t_Handle    h_OldPointer, h_NewPointer;
-    t_List      h_List      ;
+    t_List      h_List;
+    uint32_t    intFlags;
 
     INIT_LIST(&h_List);
 
-    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 
     err = FmPcdCcModifyMissNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
     if(err)
@@ -978,19 +971,19 @@ t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
     t_List      h_OldPointersLst;
     t_Error     err = E_OK;
     t_List      h_List;
+    uint32_t    intFlags;
 
     INIT_LIST(&h_List);
 
-    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 
     INIT_LIST(&h_OldPointersLst);
 
@@ -1001,7 +994,7 @@ t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle *)&h_OldPointersLst, h_NewPointer);
 
     FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
 
@@ -1015,21 +1008,21 @@ t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, ui
     t_List      h_OldPointersLst;
     t_Error     err = E_OK;
     t_List      h_List;
+    uint32_t    intFlags;
 
     UNUSED(keySize);
 
     INIT_LIST(&h_List);
 
-    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 
     INIT_LIST(&h_OldPointersLst);
 
@@ -1041,7 +1034,7 @@ t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, ui
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle *)&h_OldPointersLst, h_NewPointer);
 
     FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
 
@@ -1055,21 +1048,21 @@ t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint
     t_Handle    h_NewPointer;
     t_Error     err = E_OK;
     t_List      h_List;
+    uint32_t    intFlags;
 
     UNUSED(keySize);
 
     INIT_LIST(&h_List);
 
-    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 
     INIT_LIST(&h_OldPointersLst);
 
@@ -1080,7 +1073,7 @@ t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle *)&h_OldPointersLst, h_NewPointer);
 
     FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
 
@@ -1094,20 +1087,21 @@ t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex,
     t_Handle    h_NewPointer;
     t_Error     err = E_OK;
     t_List      h_List;
+    uint32_t    intFlags;
+
     UNUSED(keySize);
 
     INIT_LIST(&h_List);
 
-    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
-        return err;
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
 
     if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
     {
-        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
         return err;
     }
 
-    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 
     INIT_LIST(&h_OldPointersLst);
 
@@ -1118,7 +1112,7 @@ t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle *)&h_OldPointersLst, h_NewPointer);
     FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
 
     return err;
@@ -1128,7 +1122,7 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 {
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
+    t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
@@ -1138,11 +1132,11 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* spReg is the first reg, so we can use it both for read and for write */
     if(add)
@@ -1151,11 +1145,11 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
         hcFrame.hcSpecificData.portRegsForRead.spReg &= ~spReg;
 
     hcFrame.actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
-    hcFrame.commandSequence = p_FmHc->seqNum;
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM(&fmFd);
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -1164,7 +1158,7 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
 {
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
+    t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
@@ -1174,12 +1168,11 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
     hcFrame.opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
     hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
     hcFrame.hcSpecificData.singleRegForWrite = cppReg;
 
     BUILD_FD(sizeof(hcFrame));
 
-    ENQUEUE_FRM(&fmFd);
-
+    if ((err = EnQFrm(p_FmHc, &fmFd, &hcFrame.commandSequence)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 98e4c70..5b85d48 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -43,8 +43,8 @@
 #include "endian_ext.h"
 #include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
-#include "fm_common.h"
 
+#include "fm_common.h"
 #include "dtsec.h"
 
 
@@ -97,7 +97,7 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     return E_OK;
 }
 
-static uint8_t GetMiiDiv(uint32_t refClk)
+static uint8_t GetMiiDiv(int32_t refClk)
 {
 #define ABS(a) ((a<0)?(a*-1):a)
     uint32_t    div,tmpClk;
@@ -106,37 +106,37 @@ static uint8_t GetMiiDiv(uint32_t refClk)
     div = 1;
     minRange = (int)(refClk/40 - 1);
 
-    tmpClk = ABS(refClk/60 - 1);
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
     if (tmpClk < minRange)
     {
         div = 2;
         minRange = (int)tmpClk;
     }
-    tmpClk = ABS(refClk/60 - 1);
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
     if (tmpClk < minRange)
     {
         div = 3;
         minRange = (int)tmpClk;
     }
-    tmpClk = ABS(refClk/80 - 1);
+    tmpClk = (uint32_t)ABS(refClk/80 - 1);
     if (tmpClk < minRange)
     {
         div = 4;
         minRange = (int)tmpClk;
     }
-    tmpClk = ABS(refClk/100 - 1);
+    tmpClk = (uint32_t)ABS(refClk/100 - 1);
     if (tmpClk < minRange)
     {
         div = 5;
         minRange = (int)tmpClk;
     }
-    tmpClk = ABS(refClk/140 - 1);
+    tmpClk = (uint32_t)ABS(refClk/140 - 1);
     if (tmpClk < minRange)
     {
         div = 6;
         minRange = (int)tmpClk;
     }
-    tmpClk = ABS(refClk/280 - 1);
+    tmpClk = (uint32_t)ABS(refClk/280 - 1);
     if (tmpClk < minRange)
     {
         div = 7;
@@ -294,6 +294,16 @@ static void DtsecErrException(t_Handle h_Dtsec)
 
 static void FreeInitResources(t_Dtsec *p_Dtsec)
 {
+    if ((p_Dtsec->mdioIrq != 0) && (p_Dtsec->mdioIrq != NO_IRQ))
+    {
+        XX_DisableIntr(p_Dtsec->mdioIrq);
+        XX_FreeIntr(p_Dtsec->mdioIrq);
+    }
+    else if (p_Dtsec->mdioIrq == 0)
+        FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR);
+    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+
     /* release the driver's group hash table */
     FreeHashTable(p_Dtsec->p_MulticastAddrHash);
     p_Dtsec->p_MulticastAddrHash =   NULL;
@@ -393,6 +403,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     int                 i;
     uint32_t            tmpReg32;
     uint64_t            addr;
+    t_Error             err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
@@ -575,7 +586,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, ~MIIMCFG_RESET_MGMT);
     /* Setup the MII Mgmt clock speed */
     WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
-                 (uint32_t)GetMiiDiv((uint32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
+                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
 
 #ifndef VERIFICATION_SUPPORT
     if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
@@ -698,14 +709,14 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     }
 
     if(p_DtsecDriverParam->backPressureNoBackoff)
-        tmpReg32 |= HAFDUP_BP_NO_BACKOFF ;
+        tmpReg32 |= HAFDUP_BP_NO_BACKOFF;
     if(p_DtsecDriverParam->noBackoff)
-        tmpReg32 |= HAFDUP_NO_BACKOFF ;
+        tmpReg32 |= HAFDUP_NO_BACKOFF;
     if(p_DtsecDriverParam->excessDefer)
-        tmpReg32 |= HAFDUP_EXCESS_DEFER ;
+        tmpReg32 |= HAFDUP_EXCESS_DEFER;
     tmpReg32 |= (((uint32_t)p_DtsecDriverParam->maxRetransmission <<
                 HAFDUP_RETRANSMISSION_MAX_SHIFT )& HAFDUP_RETRANSMISSION_MAX);
-    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW) ;
+    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW);
 
     WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
     /***************HAFDUP************************/
@@ -714,6 +725,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     /* Initialize MAXFRM */
     WRITE_UINT32(p_DtsecMemMap->maxfrm,
                  p_DtsecDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId, p_DtsecDriverParam->maxFrameLength);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     /***************MAXFRM************************/
 
     /***************CAM1************************/
@@ -791,14 +805,15 @@ static t_Error DtsecFree(t_Handle h_Dtsec)
 {
     t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
-    SANITY_CHECK_RETURN_ERROR(h_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    FreeInitResources(p_Dtsec);
 
     if (p_Dtsec->p_DtsecDriverParam)
     {
         XX_Free(p_Dtsec->p_DtsecDriverParam);
         p_Dtsec->p_DtsecDriverParam = NULL;
     }
-    FreeInitResources(h_Dtsec);
     XX_Free (h_Dtsec);
 
     return E_OK;
@@ -889,19 +904,14 @@ static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
-#ifdef BUP_FM_LEN_CHECK_ERRATA
-    {
-        t_FmRevisionInfo revInfo;
-        FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
-        if (((revInfo.majorRev == 1) && (revInfo.minorRev == 0)) ||
-                ((revInfo.majorRev == 2) && (revInfo.minorRev == 0)))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
-    }
-#endif /* BUP_FM_LEN_CHECK_ERRATA */
 
+#ifdef BUP_FM_LEN_CHECK_ERRATA
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#else
     p_Dtsec->p_DtsecDriverParam->lengthCheckEnable = newVal;
 
     return E_OK;
+#endif /* BUP_FM_LEN_CHECK_ERRATA */
 }
 
 static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
@@ -1010,22 +1020,54 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
 
     p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
+    if (pauseTime)
+    {
 #ifdef FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                pauseTime += 2;
+        }
+#endif /* FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
+
+        ptv = GET_UINT32(p_MemMap->ptv);
+        ptv |= pauseTime;
+        WRITE_UINT32(p_MemMap->ptv, ptv);
+
+        /* trigger the transmission of a flow-control pause frame */
+        WRITE_UINT32(p_MemMap->maccfg1,
+                     GET_UINT32(p_MemMap->maccfg1) | MACCFG1_TX_FLOW);
+    }
+    else
     {
-        t_FmRevisionInfo revInfo;
-        FmGetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            pauseTime += 2;
+        WRITE_UINT32(p_MemMap->maccfg1,
+                     GET_UINT32(p_MemMap->maccfg1) & ~MACCFG1_TX_FLOW);
     }
-#endif /* FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
 
-    ptv = GET_UINT32(p_MemMap->ptv);
-    ptv |= pauseTime;
-    WRITE_UINT32(p_MemMap->ptv, ptv);
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
-    /* trigger the transmission of a flow-control pause frame */
-    WRITE_UINT32(p_MemMap->tctrl,
-                 GET_UINT32(p_MemMap->tctrl) | TCTRL_TFC_PAUSE);
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+    if (en)
+        tmpReg32 &= ~MACCFG1_RX_FLOW;
+    else
+        tmpReg32 |= MACCFG1_RX_FLOW;
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
 
     return E_OK;
 }
@@ -1034,9 +1076,9 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
 
 static t_Error DtsecReadStatistics(t_Handle h_Dtsec)
 {
-    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap    *p_DtsecMemMap;
-    t_FmMacStatistics *p_Statistics = &p_Dtsec->macStatistics;
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_DtsecMemMap;
+    t_FmMacStatistics   *p_Statistics = &p_Dtsec->macStatistics;
     uint32_t            tmpRdrp, tmpRaln, tmpTdrp;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
@@ -1149,8 +1191,8 @@ static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
-    /*  Initialize MAC Station Address registers (1 & 2)    */
-    /*  Station address have to be swapped (big endian to little endian */
+    /* Initialize MAC Station Address registers (1 & 2)    */
+    /* Station address have to be swapped (big endian to little endian */
     addr = ((*(uint64_t *)p_EnetAddr) >> 16);
     p_Dtsec->addr = addr;
 
@@ -1456,15 +1498,11 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
 static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 {
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-UNUSED(macId);
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("DtsecGetId Not Supported"));
+    *macId = p_Dtsec->macId;
 
     return E_OK;
 }
@@ -1633,7 +1671,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
     p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
 
-    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = DtsecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = DtsecRxIgnoreMacPause;
 
     p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
     p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = DtsecGetStatistics;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index b80439b..0701c93 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -168,8 +168,8 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_exactMatch              FALSE
 #define DEFAULT_debugMode               FALSE
 #define DEFAULT_loopback                FALSE
-#define DEFAULT_actOnRxPauseFrame       FALSE
-#define DEFAULT_actOnTxPauseFrame       FALSE
+#define DEFAULT_actOnRxPauseFrame       TRUE
+#define DEFAULT_actOnTxPauseFrame       TRUE
 
 #define DEFAULT_PreAmLength             0x7
 #define DEFAULT_PreAmRxEn               FALSE
@@ -202,7 +202,6 @@ typedef  uint32_t t_ErrorDisable;
 
 #define DEFAULT_exceptions              ((uint32_t)(IMASK_BREN    | \
                                                     IMASK_RXCEN   | \
-                                                    IMASK_MSROEN  | \
                                                     IMASK_BTEN    | \
                                                     IMASK_TXCEN   | \
                                                     IMASK_TXEEN   | \
@@ -240,8 +239,7 @@ typedef  uint32_t t_ErrorDisable;
 #define TCTRL_THDF                  0x00000800
 #define TCTRL_TTSE                  0x00000040
 #define TCTRL_GTS                   0x00000020
-#define TCTRL_GET_RFC_PAUSE         0x00000010
-#define TCTRL_TFC_PAUSE             0x00000008
+#define TCTRL_TFC_PAUSE             0x00000010
 
 /* PTV offsets */
 #define PTV_PTE_OFST                16
@@ -329,8 +327,9 @@ typedef  uint32_t t_ErrorDisable;
 #define PHY_CR_ANE          0x1000
 #define PHY_CR_FULLDUPLEX   0x0100
 #define PHY_CR_SPEED1       0x0040
-#define PHY_TBICON_SPEED2   0x0020
+
 #define PHY_TBICON_SRESET   0x8000
+#define PHY_TBICON_SPEED2   0x0020
 
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 2038ccc..21012e4 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -131,7 +131,6 @@ t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool newVal)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
-
 /* ........................................................................... */
 
 t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
@@ -293,14 +292,28 @@ t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime)
+t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames(h_FmMac, pauseTime);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-    if (p_FmMacControllerDriver->f_FM_MAC_TxMacPause)
-        return p_FmMacControllerDriver->f_FM_MAC_TxMacPause(h_FmMac, pauseTime);
+    if (p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames(h_FmMac, en);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index b807456..6968392 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -50,8 +50,18 @@
 #define DEFAULT_resetOnInit                 FALSE
 
 
-typedef struct
-{
+typedef struct {
+    uint64_t addr;      /* Ethernet Address  */
+    t_List   node;
+} t_EthHashEntry;
+#define ETH_HASH_ENTRY_OBJ(ptr) LIST_OBJECT(ptr, t_EthHashEntry, node)
+
+typedef struct {
+    uint16_t    size;
+    t_List      *p_Lsts;
+} t_EthHash;
+
+typedef struct {
     t_Error (*f_FM_MAC_Init) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_Free) (t_Handle h_FmMac);
 
@@ -72,7 +82,8 @@ typedef struct
     t_Error (*f_FM_MAC_Disable1588TimeStamp) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
 
-    t_Error (*f_FM_MAC_TxMacPause) (t_Handle h_FmMac, uint16_t pauseTime);
+    t_Error (*f_FM_MAC_SetTxAutoPauseFrames)   (t_Handle h_FmMac, uint16_t pauseTime);
+    t_Error (*f_FM_MAC_SetRxIgnorePauseFrames) (t_Handle h_FmMac, bool en);
 
     t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_GetStatistics) (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
@@ -106,21 +117,12 @@ typedef struct
     uint16_t        clkFreq;
 } t_FmMacControllerDriver;
 
-typedef struct {
-    uint64_t addr;      /* Ethernet Address  */
-    t_List   node;
-} t_EthHashEntry;
-#define ETH_HASH_ENTRY_OBJ(ptr) LIST_OBJECT(ptr, t_EthHashEntry, node)
-
-typedef struct {
-    uint16_t    size;
-    t_List      *p_Lsts;
-} t_EthHash;
 
 t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
 t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
 uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
 
+
 /* ........................................................................... */
 
 static __inline__ t_EthHashEntry *DequeueAddrFromHashEntry(t_List *p_AddrLst)
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index dacdf6c..be38f73 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -43,8 +43,8 @@
 #include "endian_ext.h"
 #include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
-#include "fm_common.h"
 
+#include "fm_common.h"
 #include "tgec.h"
 
 
@@ -103,14 +103,15 @@ static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
 static void TgecErrException(t_Handle h_Tgec)
 {
     t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
-    uint32_t            event;
+    uint32_t            event, imask;
     t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
 
     event = GET_UINT32(p_TgecMemMap->ievent);
     /* do not handle MDIO events */
     event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
 
-    event &= GET_UINT32(p_TgecMemMap->imask);
+    imask = GET_UINT32(p_TgecMemMap->imask);
+    event &= imask;
 
     WRITE_UINT32(p_TgecMemMap->ievent, event);
 
@@ -126,8 +127,13 @@ static void TgecErrException(t_Handle h_Tgec)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
     if(event & IMASK_TX_ER )
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
-    if(event & IMASK_RX_FIFO_OVFL )
+    if(event & IMASK_RX_FIFO_OVFL ) {
+	/* don't flag RX FIFO after the first */
+	imask &= ~IMASK_RX_FIFO_OVFL;
+	WRITE_UINT32(p_TgecMemMap->imask, imask);
+	printk(KERN_ERR "10G MAC got RX FIFO Error = %x\n", event);
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
+    }
     if(event & IMASK_RX_ECC_ER )
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
     if(event & IMASK_RX_JAB_FRM)
@@ -167,6 +173,15 @@ static void TgecException(t_Handle h_Tgec)
 
 static void FreeInitResources(t_Tgec *p_Tgec)
 {
+    if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
+    {
+        XX_DisableIntr(p_Tgec->mdioIrq);
+        XX_FreeIntr(p_Tgec->mdioIrq);
+    }
+    else if (p_Tgec->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));
+    FmUnregisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR);
+
     /* release the driver's group hash table */
     FreeHashTable(p_Tgec->p_MulticastAddrHash);
     p_Tgec->p_MulticastAddrHash =   NULL;
@@ -220,12 +235,13 @@ static t_Error TgecFree(t_Handle h_Tgec)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
 
+    FreeInitResources(p_Tgec);
+
     if (p_Tgec->p_TgecDriverParam)
     {
         XX_Free(p_Tgec->p_TgecDriverParam);
         p_Tgec->p_TgecDriverParam = NULL;
     }
-    FreeInitResources(p_Tgec);
     XX_Free (p_Tgec);
 
     return E_OK;
@@ -241,6 +257,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     t_TgecMemMap            *p_MemMap;
     uint32_t                tmpReg32;
     uint64_t                addr;
+    t_Error                 err;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
@@ -265,19 +282,19 @@ static t_Error TgecInit(t_Handle h_Tgec)
     /* Config */
     tmpReg32 = 0;
     if (p_TgecDriverParam->wanModeEnable)
-       tmpReg32 |= CMD_CFG_WAN_MODE;
+        tmpReg32 |= CMD_CFG_WAN_MODE;
     if (p_TgecDriverParam->promiscuousModeEnable)
-       tmpReg32 |= CMD_CFG_PROMIS_EN;
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
     if (p_TgecDriverParam->padRemovalEnable)
-       tmpReg32 |= CMD_CFG_PAD_EN;
+        tmpReg32 |= CMD_CFG_PAD_EN;
     if (p_TgecDriverParam->crcForwardEnable)
-       tmpReg32 |= CMD_CFG_CRC_FWD;
+        tmpReg32 |= CMD_CFG_CRC_FWD;
     if (p_TgecDriverParam->pauseForwardEnable)
-       tmpReg32 |= CMD_CFG_PAUSE_FWD;
+        tmpReg32 |= CMD_CFG_PAUSE_FWD;
     if (p_TgecDriverParam->pauseIgnore)
-       tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
     if (p_TgecDriverParam->txAddrInsEnable)
-       tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
     if (p_TgecDriverParam->loopbackEnable)
         tmpReg32 |= CMD_CFG_LOOPBACK_EN;
     if (p_TgecDriverParam->cmdFrameEnable)
@@ -285,32 +302,42 @@ static t_Error TgecInit(t_Handle h_Tgec)
     if (p_TgecDriverParam->rxErrorDiscard)
         tmpReg32 |= CMD_CFG_RX_ER_DISC;
     if (p_TgecDriverParam->phyTxenaOn)
-       tmpReg32 |= CMD_CFG_PHY_TX_EN;
+        tmpReg32 |= CMD_CFG_PHY_TX_EN;
     if (p_TgecDriverParam->sendIdleEnable)
-       tmpReg32 |= CMD_CFG_SEND_IDLE;
+        tmpReg32 |= CMD_CFG_SEND_IDLE;
     if (p_TgecDriverParam->noLengthCheckEnable)
-       tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
     if (p_TgecDriverParam->lgthCheckNostdr)
-       tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
+        tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
     if (p_TgecDriverParam->timeStampEnable)
-       tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
+        tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
     if (p_TgecDriverParam->rxSfdAny)
-       tmpReg32 |= RX_SFD_ANY;
+        tmpReg32 |= RX_SFD_ANY;
     if (p_TgecDriverParam->rxPblFwd)
-       tmpReg32 |= CMD_CFG_RX_PBL_FWD;
+        tmpReg32 |= CMD_CFG_RX_PBL_FWD;
     if (p_TgecDriverParam->txPblFwd)
-       tmpReg32 |= CMD_CFG_TX_PBL_FWD;
+        tmpReg32 |= CMD_CFG_TX_PBL_FWD;
     WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
 
     /* Max Frame Length */
     WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MAC_10G, p_Tgec->fmMacControllerDriver.macId, p_TgecDriverParam->maxFrameLength);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Pause Time */
     WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
 
     /* Configure MII */
     tmpReg32  = GET_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status);
-    tmpReg32 |= (MIIMCOM_MDIO_HOLD_4_REG_CLK << 2);
+#ifdef FM_10G_MDIO_HOLD_ERRATA_XAUI3
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            tmpReg32 |= (MIIMCOM_MDIO_HOLD_4_REG_CLK << 2);
+    }
+#endif /* FM_10G_MDIO_HOLD_ERRATA_XAUI3 */
     tmpReg32 &= ~MIIMCOM_DIV_MASK;
      /* (one half of fm clock => 2.5Mhz) */
     tmpReg32 |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
@@ -337,7 +364,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
         if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
             p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
     }
-#endif   /* BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA */
+#endif /* BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA */
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
 
@@ -375,7 +402,6 @@ static t_Error TgecConfigStatistics(t_Handle h_Tgec, bool newVal)
     return E_OK;
 }
 
-#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
 /* .............................................................................. */
 
 static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
@@ -385,11 +411,17 @@ static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("no loopback in this chip rev!"));
+    }
+
     p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
 
     return E_OK;
 }
-#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
 
 /* .............................................................................. */
 
@@ -442,18 +474,14 @@ static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
 #ifdef BUP_FM_LEN_CHECK_ERRATA
-    {
-        t_FmRevisionInfo revInfo;
-        FmGetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if (((revInfo.majorRev == 1) && (revInfo.minorRev == 0))||
-            ((revInfo.majorRev == 2) && (revInfo.minorRev == 0)))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
-    }
-#endif /* BUP_FM_LEN_CHECK_ERRATA */
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#else
     p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
 
     return E_OK;
+#endif /* BUP_FM_LEN_CHECK_ERRATA */
 }
 
 /*****************************************************************************/
@@ -552,14 +580,13 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
     tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
-
     switch (mode)
     {
-        case e_COMM_MODE_RX :
-            tmpReg32 &= ~CMD_CFG_RX_EN ;
+        case e_COMM_MODE_RX:
+            tmpReg32 &= ~CMD_CFG_RX_EN;
             break;
-        case e_COMM_MODE_TX :
-            tmpReg32 &= ~CMD_CFG_TX_EN ;
+        case e_COMM_MODE_TX:
+            tmpReg32 &= ~CMD_CFG_TX_EN;
             break;
         case e_COMM_MODE_RX_AND_TX:
             tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
@@ -567,7 +594,6 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
     }
-
     WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
 
     return E_OK;
@@ -594,13 +620,36 @@ static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
     return E_OK;
 }
 
+/* .............................................................................. */
+
+static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    if (en)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    else
+        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
 /* Counters handling */
 /* .............................................................................. */
 
 static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
 {
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
@@ -908,15 +957,14 @@ static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
 {
     t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
-UNUSED(macId);
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
 
+    UNUSED(macId);
+    UNUSED(p_TgecMemMap);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TgecGetId Not Supported"));
-
-    return E_OK;
 }
 
 /* .............................................................................. */
@@ -973,8 +1021,8 @@ static t_Error TgecAdjustLink(t_Handle h_Tgec, e_EnetSpeed speed, bool fullDuple
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("half-duplex"));
 
     UNUSED(speed);
+    UNUSED(p_Tgec);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-    return E_OK;
 }
 
 /* .............................................................................. */
@@ -1095,9 +1143,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = TgecConfigStatistics;
-#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
     p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
-#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
     p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = TgecConfigWan;
@@ -1118,7 +1164,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
 
-    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = TgecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = TgecRxIgnoreMacPause;
 
     p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = TgecResetCounters;
     p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = TgecGetStatistics;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 307a2a6..037094e 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -42,18 +42,56 @@
 #include "fm_pcd_ext.h"
 #include "fm_muram_ext.h"
 
+#include "fm_common.h"
 #include "fm_hc.h"
-#include "fm_pcd.h"
+#include "fm_cc.h"
 
 
-t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
+uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
 {
-    TRY_LOCK_RET_ERR(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
-    return E_OK;
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+    return p_FmPcdCcNode->parseCode;
 }
-void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+
+uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
 {
-    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+    return p_FmPcdCcNode->offset;
+}
+static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
+    {
+        case(e_FM_PCD_ACTION_EXACT_MATCH):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_KEY):
+                    return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
+                default:
+                    return CC_PRIVATE_INFO_NONE;
+            }
+        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
+                break;
+                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                    return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
+                break;
+                default:
+                  return  CC_PRIVATE_INFO_NONE;
+            }
+       default:
+           break;
+    }
+    return CC_PRIVATE_INFO_NONE;
 }
 
 static void EnqueueAdditionalInfoToRelevantLst(t_List *p_CcNode, t_CcNodeInfo *p_CcInfo)
@@ -61,7 +99,7 @@ static void EnqueueAdditionalInfoToRelevantLst(t_List *p_CcNode, t_CcNodeInfo *p
     uint32_t   intFlags;
 
     intFlags = XX_DisableAllIntr();
-    LIST_AddToTail(&p_CcInfo->h_Node, p_CcNode);
+    LIST_AddToTail(&p_CcInfo->node, p_CcNode);
     XX_RestoreAllIntr(intFlags);
 }
 
@@ -73,7 +111,7 @@ static void CreateNodeInfo(t_List *p_List, uint32_t info)
         if(!p_CcInfo)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         memset(p_CcInfo, 0, sizeof(t_CcNodeInfo));
-        INIT_LIST(&p_CcInfo->h_Node);
+        INIT_LIST(&p_CcInfo->node);
         p_CcInfo->nextCcNodeInfo = (uint32_t)info;
         EnqueueAdditionalInfoToRelevantLst(p_List, p_CcInfo);
 }
@@ -94,8 +132,8 @@ static t_CcNodeInfo * FindNodeInfoAccIndex(t_List *p_List, uint16_t indx)
 
 static t_CcNodeInfo * FindNodeInfoAccId(t_List *p_List, uint16_t indx)
 {
-    t_CcNodeInfo   *p_CcNodeInfo = NULL;
-    t_List      *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo = NULL;
+    t_List          *p_Pos;
 
     LIST_FOR_EACH(p_Pos, p_List)
     {
@@ -115,7 +153,7 @@ static t_CcNodeInfo * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
     if (!LIST_IsEmpty(p_List))
     {
         p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_List->p_Next);
-        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+        LIST_DelAndInit(&p_CcNodeInfo->node);
     }
     XX_RestoreAllIntr(intFlags);
     return p_CcNodeInfo;
@@ -139,7 +177,6 @@ static void ReleaseLst(t_List *p_List)
 
 static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdCc)
 {
-
     if(p_FmPcdCcNode)
     {
             if(p_FmPcdCcNode->p_GlblMask)
@@ -149,12 +186,12 @@ static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdC
             }
             if(p_FmPcdCcNode->h_KeysMatchTable)
             {
-                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_KeysMatchTable);
+                FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), p_FmPcdCcNode->h_KeysMatchTable);
                 p_FmPcdCcNode->h_KeysMatchTable = NULL;
             }
             if(p_FmPcdCcNode->h_AdTable)
             {
-                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_AdTable);
+                FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), p_FmPcdCcNode->h_AdTable);
                 p_FmPcdCcNode->h_AdTable = NULL;
             }
 
@@ -162,7 +199,7 @@ static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdC
             ReleaseLst(&p_FmPcdCcNode->ccPrevNodesLst);
             ReleaseLst(&p_FmPcdCcNode->ccTreeIdLst);
             ReleaseLst(&p_FmPcdCcNode->ccTreesLst);
-
+            ReleaseLst(&p_FmPcdCcNode->manipLst);
 
             XX_Free(p_FmPcdCcNode);
     }
@@ -170,8 +207,8 @@ static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdC
 
 static t_CcNodeInfo * FindNodeInfoAccIdAndAddToRetLst(t_List *p_List, uint16_t nodeId,  t_List *p_ReturnList)
 {
-    t_CcNodeInfo   *p_CcNodeInfo = NULL;
-    t_List      *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo = NULL;
+    t_List          *p_Pos;
 
     LIST_FOR_EACH(p_Pos, p_List)
     {
@@ -179,6 +216,7 @@ static t_CcNodeInfo * FindNodeInfoAccIdAndAddToRetLst(t_List *p_List, uint16_t n
         if(((uint16_t)p_CcNodeInfo->nextCcNodeInfo) == nodeId)
             CreateNodeInfo(p_ReturnList, p_CcNodeInfo->nextCcNodeInfo);
     }
+
     return NULL;
 }
 
@@ -186,95 +224,95 @@ static void  UpdateNodeOwner(t_FmPcd  *p_FmPcd, uint16_t nodeId, bool add)
 {
     ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
     if(add)
-        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners++;
+        ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[nodeId].owners++;
     else
     {
-        ASSERT_COND(p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners);
-        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners--;
+        ASSERT_COND(((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[nodeId].owners);
+        ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[nodeId].owners--;
     }
 }
 
-static t_Handle GetNodeHandler(t_FmPcd *p_FmPcd, uint16_t nodeId)
+static t_FmPcdCcNode* GetNodeHandler(t_FmPcdCc *p_FmPcdCc, uint16_t nodeId)
 {
     ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
-    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
+    return (p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode);
 
 }
 
-static void SetNodeHandler(t_Handle h_FmPcdCc, uint16_t nodeId, t_Handle p_FmPcdCcNode)
+static void SetNodeHandler(t_FmPcdCc *p_FmPcdCc, uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode)
 {
-    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
 
-    ASSERT_COND(!p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode);
+    if(p_FmPcdCcNode)
+        ASSERT_COND(!p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode);
     p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = p_FmPcdCcNode;
 }
 
-static t_Handle FmPcdCcGetTreeHandler(t_Handle h_FmPcd, uint8_t treeId)
+static t_FmPcdCcTree * GetTreeHandler(t_FmPcdCc *p_FmPcdCc, uint8_t treeId)
 {
 
     ASSERT_COND(treeId < FM_PCD_MAX_NUM_OF_CC_TREES);
-    return ((t_FmPcd*)h_FmPcd)->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
+    return p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
 }
 
-static void SetTreeHandler(t_Handle h_FmPcdCc, uint8_t treeId, t_Handle p_FmPcdCcTree)
+static void SetTreeHandler(t_FmPcdCc *p_FmPcdCc, uint8_t treeId, t_FmPcdCcTree *p_FmPcdCcTree)
 {
-    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
 
-    ASSERT_COND(!p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree);
+    if(p_FmPcdCcTree)
+        ASSERT_COND(!p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree);
     p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = p_FmPcdCcTree;
 }
 
-
 static uint8_t GetTreeOwners(t_FmPcd *p_FmPcd, uint8_t treeId)
 {
     ASSERT_COND(treeId < FM_PCD_MAX_NUM_OF_CC_TREES);
-    return p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners;
+    return ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[treeId].owners;
 }
 
 static uint8_t GetNodeOwners(t_FmPcd *p_FmPcd, uint16_t nodeId)
 {
     ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
-    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners;
+    return ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[nodeId].owners;
 }
 
-
 static t_Error OccupyNodeId(t_FmPcd *p_FmPcd, uint16_t *nodeId)
 {
-    uint16_t i = 0;
+    uint32_t    intFlags;
+    uint16_t    i = 0;
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
     for(i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
     {
-        if(!p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].p_FmPcdCcNode)
+        if(!((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[i].occupied && !((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[i].p_FmPcdCcNode)
         {
             *nodeId = i;
-            p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied = TRUE;
-            RELEASE_LOCK(p_FmPcd->lock)
-           return E_OK;
+            ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccNodeArrayEntry[i].occupied = TRUE;
+            FmPcdUnlock(p_FmPcd, intFlags);
+            return E_OK;
         }
 
     }
-    RELEASE_LOCK(p_FmPcd->lock)
+    FmPcdUnlock(p_FmPcd, intFlags);
     RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
 }
 
 static t_Error OccupyTreeId(t_FmPcd *p_FmPcd, uint8_t *treeId)
 {
-    uint16_t i = 0;
+    uint32_t    intFlags;
+    uint16_t    i = 0;
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
     for(i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
     {
-        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].p_FmPcdCcTree)
+        if(!((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[i].occupied && !((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[i].p_FmPcdCcTree)
         {
             *treeId = (uint8_t)i;
-            p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied = TRUE;
-            RELEASE_LOCK(p_FmPcd->lock)
+            ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[i].occupied = TRUE;
+            FmPcdUnlock(p_FmPcd, intFlags);
            return E_OK;
         }
 
     }
-    RELEASE_LOCK(p_FmPcd->lock)
+    FmPcdUnlock(p_FmPcd, intFlags);
     RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
 }
 
@@ -282,7 +320,7 @@ static t_Error OccupyTreeId(t_FmPcd *p_FmPcd, uint8_t *treeId)
 
 static bool CcNodeIsValid(t_FmPcd *p_FmPcd, uint16_t nodeId)
 {
-    t_FmPcdCc *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)p_FmPcd->h_FmPcdCc;
 
     ASSERT_COND(nodeId < FM_PCD_MAX_NUM_OF_CC_NODES);
 
@@ -340,7 +378,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case(HEADER_TYPE_PPPoE):
             switch(field.pppoe)
             {
@@ -352,7 +390,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_VLAN):
             switch(field.vlan)
             {
@@ -364,7 +402,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_MPLS):
             switch(field.mpls)
             {
@@ -376,7 +414,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_IPv4):
             switch(field.ipv4)
             {
@@ -399,7 +437,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_IPv6):
             switch(field.ipv6)
             {
@@ -419,7 +457,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_GRE):
             switch(field.gre)
             {
@@ -431,7 +469,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_MINENCAP):
             switch(field.minencap)
             {
@@ -450,7 +488,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_TCP):
             switch(field.tcp)
             {
@@ -466,7 +504,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     *parseCodeRealSize = CC_SIZE_ILLEGAL;
                     break;
             }
-        break;
+            break;
         case (HEADER_TYPE_UDP):
             switch(field.udp)
             {
@@ -484,35 +522,33 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
             }
             break;
        default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
-                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
-                    break;
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
+            *parseCodeRealSize = CC_SIZE_ILLEGAL;
+            break;
     }
 }
 
-
-
 static void ReleaseNode(t_FmPcdCc *p_FmPcdCc, uint16_t nodeId)
 {
     t_FmPcdCcNode *p_FmPcdCcNode;
 
-    if(p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
+    p_FmPcdCcNode = GetNodeHandler(p_FmPcdCc, nodeId);
+
+    if(p_FmPcdCcNode)
     {
-            p_FmPcdCcNode = (t_FmPcdCcNode *)p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
             ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-            p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = NULL;
+            SetNodeHandler(p_FmPcdCc, nodeId, NULL);
     }
     p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied = FALSE;
 }
 
 static void ReleaseTreeHandler(t_FmPcdCcTree *p_FmPcdTreeNode, t_FmPcdCc *p_FmPcdCc)
 {
-
     if(p_FmPcdTreeNode)
     {
         if(p_FmPcdTreeNode->ccTreeBaseAddr)
         {
-            FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, CAST_UINT64_TO_POINTER(p_FmPcdTreeNode->ccTreeBaseAddr));
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), CAST_UINT64_TO_POINTER(p_FmPcdTreeNode->ccTreeBaseAddr));
             p_FmPcdTreeNode->ccTreeBaseAddr = 0;
         }
 
@@ -521,23 +557,22 @@ static void ReleaseTreeHandler(t_FmPcdCcTree *p_FmPcdTreeNode, t_FmPcdCc *p_FmPc
         ReleaseLst(&p_FmPcdTreeNode->fmPortsLst);
 
         XX_Free(p_FmPcdTreeNode);
-        }
+    }
 }
 
 static void ReleaseTree(t_FmPcdCc *p_FmPcdCc, uint8_t treeId)
 {
     t_FmPcdCcTree *p_FmPcdCcTree;
 
-    if(p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree)
+    p_FmPcdCcTree = GetTreeHandler(p_FmPcdCc, treeId);
+    if(p_FmPcdCcTree)
     {
-            p_FmPcdCcTree = p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
             ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
-            p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = NULL;
+            SetTreeHandler(p_FmPcdCc, treeId, NULL);
     }
     p_FmPcdCc->ccTreeArrayEntry[treeId].occupied = FALSE;
 }
 
-
 static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_NextEngineParamsInfo *p_NextEngineParamsInfo)
 {
     uint16_t                    absoluteProfileId;
@@ -548,16 +583,23 @@ static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEnginePar
 
      switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
-        case(e_FM_PCD_DONE):
-            if(p_FmPcdCcNextEngineParams->params.enqueueParams.ctrlFlow &&
-               !p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
-            if(p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow & ~0x00FFFFFF)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+         case(e_FM_PCD_INVALID):
+             p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_INVALID;
+             err = E_NOT_SUPPORTED;
+             break;
+         case(e_FM_PCD_DONE):
+             if(p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+             {
+                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
+                         !p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+             }
             p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
             break;
         case(e_FM_PCD_KG):
-            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT64(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
             if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
@@ -568,25 +610,26 @@ static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEnginePar
             p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_KG;
             break;
         case(e_FM_PCD_PLCR):
-            if(p_FmPcdCcNextEngineParams->params.plcrParams.ctrlFlow)
+            if(p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
             {
                 /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
                 if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
                 {
-                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &absoluteProfileId);
+                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId, &absoluteProfileId);
                     if(err)
                         RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
                     if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
-                    if(p_FmPcdCcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow &&  (!p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr ||
-                            p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr & ~0x00FFFFFF))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("fqidForCtrlFlowForEnqueueAfterPlcr  must be between 1 and 2^24-1"));
                 }
                 else
                 {
                     p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_PLCR;
-                    p_NextEngineParamsInfo->additionalInfo = p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+                    p_NextEngineParamsInfo->additionalInfo = p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId;
                 }
+               // TODO - add check according to the revision of the chip.
+                // if(!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
+                //       (p_FmPcdCcNextEngineParams->params.plcrParams.newFqid & ~0x00FFFFFF))
+                //    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("newFqid  must be between 1 and 2^24-1"));
             }
             break;
         case(e_FM_PCD_CC):
@@ -602,16 +645,13 @@ static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEnginePar
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
     }
-
-    return E_OK;
+     return err;
 }
 
-
-
-
-
-static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset, bool fromIc, ccPrivateInfo_t icCode)
 {
+    if(!fromIc)
+    {
     switch(src)
     {
         case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
@@ -619,32 +659,41 @@ static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glb
                 return CC_PC_GENERIC_WITH_MASK ;
             else
               return CC_PC_GENERIC_WITHOUT_MASK;
-            break;
-        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
             *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
             if(offset)
                 return CC_PR_OFFSET;
             else
                 return CC_PR_WITHOUT_OFFSET;
-        break;
-        case(e_FM_PCD_EXTRACT_FROM_IC_KEY) :
-            *parseArrayOffset = 0x50;
-            return CC_PC_GENERIC_IC_GMASK;
-            break;
-        case(e_FM_PCD_EXTRACT_FROM_IC_HASH_EXACT_MATCH) :
-            *parseArrayOffset = 0x48;
-            return CC_PC_GENERIC_IC_GMASK;
-            break;
-        case(e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH) :
-            return CC_PC_GENERIC_IC_HASH_INDEXED;
-             break;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
             return CC_PC_ILLEGAL;
     }
+    }
+    else
+    {
+            switch (icCode)
+            {
+                case(CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
+                     *parseArrayOffset = 0x50;
+                     return CC_PC_GENERIC_IC_GMASK;
+                case(CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
+                   *parseArrayOffset = 0x48;
+                   return CC_PC_GENERIC_IC_GMASK;
+                case(CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
+                    *parseArrayOffset = 0x48;
+                     return CC_PC_GENERIC_IC_HASH_INDEXED;
+                case(CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
+                    *parseArrayOffset = 0x16;
+                     return CC_PC_GENERIC_IC_HASH_INDEXED;
+                default:
+                    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+                    break;
+            }
+    }
+    return CC_PC_ILLEGAL;
 }
 
-
 static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
 {
 
@@ -653,7 +702,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
             case(HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
                 return CC_PC_ILLEGAL;
-            break;
 
        case(HEADER_TYPE_ETH):
                 switch(field.eth)
@@ -668,7 +716,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return CC_PC_ILLEGAL;
                 }
-                break;
 
          case(HEADER_TYPE_VLAN):
             switch(field.vlan)
@@ -684,7 +731,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return CC_PC_ILLEGAL;
             }
-            break;
 
         case(HEADER_TYPE_MPLS):
             switch(field.mpls)
@@ -700,7 +746,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
              }
-            break;
 
         case(HEADER_TYPE_IPv4):
             switch(field.ipv4)
@@ -746,7 +791,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-            break;
+
         case(HEADER_TYPE_IPv6):
              switch(field.ipv6)
             {
@@ -784,7 +829,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-            break;
 
         case(HEADER_TYPE_GRE):
             switch(field.gre)
@@ -810,7 +854,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
            }
-           break;
+
         case(HEADER_TYPE_TCP):
             switch(field.tcp)
             {
@@ -824,7 +868,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-            break;
+
         case(HEADER_TYPE_PPPoE):
             switch(field.pppoe)
             {
@@ -834,7 +878,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-            break;
+
         case(HEADER_TYPE_UDP):
             switch(field.udp)
             {
@@ -848,18 +892,16 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-            break;
+
          default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             return CC_PC_ILLEGAL;
-
     }
 }
 
 static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
 {
-
- bool offsetRelevant = FALSE;
+    bool offsetRelevant = FALSE;
 
     if(offset)
         offsetRelevant = TRUE;
@@ -883,13 +925,6 @@ static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uin
             else
                 return CC_PC_PR_SHIM2;
             break;
-        case(HEADER_TYPE_USER_DEFINED_SHIM3):
-            if(offset || glblMask)
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
-            else
-                return CC_PC_PR_SHIM3;
-            break;
-              break;
       case(HEADER_TYPE_LLC_SNAP):
             *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
             break;
@@ -944,13 +979,11 @@ static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uin
             return CC_PR_OFFSET;
         else
             return CC_PR_WITHOUT_OFFSET;
-
 }
 
 static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint32_t offset, uint8_t *parseArrayOffset, e_FmPcdHdrIndex hdrIndex)
 {
-
- bool offsetRelevant = FALSE;
+    bool offsetRelevant = FALSE;
 
     if(offset)
         offsetRelevant = TRUE;
@@ -965,19 +998,21 @@ static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint3
                 case(NET_HEADER_FIELD_ETH_TYPE):
                     *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
                     break;
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                return CC_PC_ILLEGAL;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
             }
             break;
         case(HEADER_TYPE_VLAN):
             switch(field.vlan)
             {
-                case(NET_HEADER_FIELD_VLAN_TCI) :
+                case(NET_HEADER_FIELD_VLAN_TCI):
                     if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
                     else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                         *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                     break;
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
@@ -990,7 +1025,6 @@ static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint3
         return CC_PR_OFFSET;
     else
         return CC_PR_WITHOUT_OFFSET;
-
 }
 
 static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
@@ -998,25 +1032,44 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
     t_AdOfTypeResult                *p_AdResult = (t_AdOfTypeResult*)p_Ad;
     uint32_t                        tmp = 0, tmpNia = 0;
     uint16_t                        profileId;
+    t_Handle                        p_AdNewPtr = NULL;
+
+    p_AdNewPtr = p_AdResult;
 
+#ifdef FM_MANIP_SUPPORT
+    if (p_CcNextEngineParams->h_Manip)
+        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip, p_Ad, &p_AdNewPtr);
+#endif /* FM_MANIP_SUPPORT */
+
+    if(p_AdNewPtr)
+    {
     switch(p_CcNextEngineParams->nextEngine)
     {
         case(e_FM_PCD_DONE):
-            if(p_CcNextEngineParams->params.enqueueParams.ctrlFlow)
-            {
-               tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
-               tmp |= p_CcNextEngineParams->params.enqueueParams.fqidForCtrlFlow;
-            }
-            else
+            if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
             {
-               tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
-               tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                if(p_CcNextEngineParams->params.enqueueParams.overrideFqid)
+                {
+                   tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                   tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+                }
+                else
+                {
+                   tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                   tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                }
             }
-            tmpNia |= NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME;
+        if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+            tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_DISCARD);
+        else
+            tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME);
             break;
         case(e_FM_PCD_KG):
-            if(p_CcNextEngineParams->params.kgParams.ctrlFlow)
+            if(p_CcNextEngineParams->params.kgParams.overrideFqid)
+            {
                 tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
+            }
             else
             {
                 tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
@@ -1024,11 +1077,11 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
             }
             tmpNia = NIA_KG_DIRECT;
             tmpNia |= NIA_ENG_KG;
-            tmpNia |= (uint8_t)(CAST_POINTER_TO_UINT32(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
+            tmpNia |= (uint8_t)(CAST_POINTER_TO_UINT64(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
         break;
         case(e_FM_PCD_PLCR):
             tmp = 0;
-            if(p_CcNextEngineParams->params.plcrParams.ctrlFlow)
+            if(p_CcNextEngineParams->params.plcrParams.overrideParams)
             {
                 tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
 
@@ -1036,53 +1089,79 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
                 if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
                 {
                     tmpNia |= NIA_PLCR_ABSOLUTE;
-                    FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &profileId);
+                    FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
                 }
                 else
-                    profileId = p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+                    profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
-                if(p_CcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow)
-                    tmp |= p_CcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr;
+                tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
                 WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
             }
             else
                tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
-            tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+            tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
            break;
         default:
             return;
     }
-
     WRITE_UINT32(p_AdResult->fqid, tmp);
+
+#ifdef FM_MANIP_SUPPORT
+    if(p_CcNextEngineParams->h_Manip)
+    {
+        tmp = GET_UINT32(p_AdResult->plcrProfile);
+        tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr) - (p_FmPcd->physicalMuramBase)) >> 4;
+        WRITE_UINT32(p_AdResult->plcrProfile, tmp);
+
+        tmpNia |= FM_PCD_AD_RESULT_EXTENDED_MODE;
+        tmpNia |= FM_PCD_AD_RESULT_NADEN;
+    }
+#endif /* FM_MANIP_SUPPORT */
+
     WRITE_UINT32(p_AdResult->nia, tmpNia);
+    }
 }
 
-static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode)
+static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode, t_Handle h_Manip)
 {
     t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_FmPcdCcNode;
     t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                tmpReg32;
+    t_Handle                p_AdNewPtr = NULL;
 
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
-    tmpReg32 |= (uint32_t)((uint64_t)(XX_VirtToPhys(p_Node->h_AdTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase);
-    WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
+    p_AdNewPtr = p_AdContLookup;
 
-    tmpReg32 = 0;
-    tmpReg32 |= p_Node->numOfKeys << 24;
-    tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
-    tmpReg32 |= p_Node->h_KeysMatchTable ?
-                    (uint32_t)((uint64_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase) : 0;
-    WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
+#ifdef FM_MANIP_SUPPORT
+    if (h_Manip)
+        FmPcdManipUpdateAdContLookupForCc(h_Manip, p_Ad, &p_AdNewPtr, (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase)));
+#else
+    UNUSED(h_Manip);
+#endif /* FM_MANIP_SUPPORT */
 
-    tmpReg32 = 0;
-    tmpReg32 |= p_Node->prsArrayOffset << 24;
-    tmpReg32 |= p_Node->offset << 16;
-    tmpReg32 |= p_Node->parseCode;
-    WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+    if(p_AdNewPtr)
+    {
+        tmpReg32 = 0;
+        tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
+        WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
+
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->numOfKeys << 24;
+        tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
+        tmpReg32 |= p_Node->h_KeysMatchTable ?
+                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
+        WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
 
-    COPY_BLOCK((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, p_Node->glblMaskSize);
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->prsArrayOffset << 24;
+        tmpReg32 |= p_Node->offset << 16;
+        tmpReg32 |= p_Node->parseCode;
+        WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+
+        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
+    }
 }
 
 static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
@@ -1095,15 +1174,21 @@ static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEn
             FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
             break;
         case(e_FM_PCD_CC):
-            FillAdOfTypeContLookup( p_Ad,
+            FillAdOfTypeContLookup(p_Ad,
                                    p_FmPcd,
-                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode);
+                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+#ifdef FM_MANIP_SUPPORT
+                                   p_FmPcdCcNextEngineParams->h_Manip
+#else
+                                   NULL
+#endif /* FM_MANIP_SUPPORT */
+                                   );
             UpdateNodeOwner(p_FmPcd,
                             (uint16_t)(((t_FmPcdCcNode *)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId),
                             TRUE);
-        break;
-        default:
-            return;
+            break;
+         default:
+             return;
     }
 }
 
@@ -1116,12 +1201,21 @@ static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_Fm
     t_NextEngineParamsInfo          nextEngineParamsInfo;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE);
 
     err = ValidateNextEngineParams(h_FmPcd, p_FmPcdCcNextEngineParams, &nextEngineParamsInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
+#ifdef FM_MANIP_SUPPORT
+    if(p_FmPcdCcNextEngineParams->h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCc(p_FmPcdCcNextEngineParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_MANIP_SUPPORT */
+
     p_CcOldModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
     if(!p_CcOldModifyAdditionalParams)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
@@ -1135,7 +1229,7 @@ static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_Fm
     }
     memset(p_CcNewModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
 
-    p_CcNewModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+    p_CcNewModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                          FM_PCD_CC_AD_ENTRY_SIZE,
                                          FM_PCD_CC_AD_TABLE_ALIGN);
 
@@ -1146,7 +1240,7 @@ static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_Fm
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
 
     }
-    WRITE_BLOCK((uint8_t *)p_CcNewModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    IOMemSet32((uint8_t *)p_CcNewModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
     if(p_FmPcdCcNextEngineParams)
         NextStepAd((t_Handle)p_CcNewModifyAdditionalParams->p_Ad,p_FmPcdCcNextEngineParams, p_FmPcd);
@@ -1180,7 +1274,7 @@ static t_Error ModifyCcKeyCommon(t_FmPcd *p_FmPcd, t_Handle *h_Pointer,bool allo
     memset(p_ModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
     if(allocateAd)
     {
-        p_ModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+        p_ModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
 
@@ -1191,7 +1285,7 @@ static t_Error ModifyCcKeyCommon(t_FmPcd *p_FmPcd, t_Handle *h_Pointer,bool allo
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
 
         }
-        WRITE_BLOCK((uint8_t *)p_ModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        IOMemSet32((uint8_t *)p_ModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
         p_ModifyAdditionalParams->adAllocated = TRUE;
     }
     *h_Pointer = p_ModifyAdditionalParams;
@@ -1199,12 +1293,10 @@ static t_Error ModifyCcKeyCommon(t_FmPcd *p_FmPcd, t_Handle *h_Pointer,bool allo
     return E_OK;
 }
 
-
 static void ModifyCcCommon2(t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams,
                             t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams,
                             uint16_t indx)
 {
-
     uint32_t    tmpReg;
 
     if(p_CcNewModifyAdditionalParams->fmPcdEngine == e_FM_PCD_CC)
@@ -1220,26 +1312,58 @@ static void ModifyCcCommon2(t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditi
         p_CcOldModifyAdditionalParams->myInfo = 0xffffffff;
 }
 
-static void ReleaseNewNodeCommonPart(t_FmPcdCc *p_FmPcdCc, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static void ReleaseNewNodeCommonPart(t_FmPcdCc *p_FmPcdCc,
+                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     if(p_AdditionalInfo->p_AdTableNew)
-        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_AdTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
     if(p_AdditionalInfo->p_KeysMatchTableNew)
-        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static t_Error BuildNewNodeCommonPart(t_Handle *h_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, int *size, bool mask, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error UpdateGblMask(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keySize, uint8_t *p_Mask)
 {
-    t_FmPcd                *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCc               *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+    if (p_Mask &&
+        !p_FmPcdCcNode->glblMaskUpdated &&
+        (keySize <= 4) &&
+        !p_FmPcdCcNode->lclMask )
+    {
+        memcpy(p_FmPcdCcNode->p_GlblMask, p_Mask,keySize);
+        p_FmPcdCcNode->glblMaskUpdated = TRUE;
+        p_FmPcdCcNode->glblMaskSize = 4;
+    }
+    else if (p_Mask &&
+             (keySize <= 4) &&
+             !p_FmPcdCcNode->lclMask)
+    {
+        if (memcmp(p_FmPcdCcNode->p_GlblMask, p_Mask, keySize) != 0)
+        {
+            p_FmPcdCcNode->lclMask = TRUE;
+            p_FmPcdCcNode->glblMaskSize = 0;
+        }
+    }
+    else if (p_Mask)
+        p_FmPcdCcNode->lclMask = TRUE;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeCommonPart(t_Handle                              *h_FmPcd,
+                                      t_FmPcdCcNode                         *p_FmPcdCcNode,
+                                      int                                   *size,
+                                      bool                                  mask,
+                                      t_FmPcdModifyCcKeyAdditionalParams    *p_AdditionalInfo)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCc           *p_FmPcdCc = (t_FmPcdCc*)p_FmPcd->h_FmPcdCc;
 
-    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd),
                                      (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
                                      FM_PCD_CC_AD_TABLE_ALIGN);
     if(!p_AdditionalInfo->p_AdTableNew)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
 
-    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
 
     if(p_FmPcdCcNode->lclMask || mask)
     {
@@ -1252,19 +1376,19 @@ static t_Error BuildNewNodeCommonPart(t_Handle *h_FmPcd, t_FmPcdCcNode *p_FmPcdC
         *size = p_FmPcdCcNode->ccKeySizeAccExtraction;
     }
 
-    p_AdditionalInfo->p_KeysMatchTableNew =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
-                                         (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
-                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+    p_AdditionalInfo->p_KeysMatchTableNew =
+        (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd),
+                                    (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
+                                    FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
     if(!p_AdditionalInfo->p_KeysMatchTableNew)
     {
-        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
     }
-    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
-
+    IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
 
     p_AdditionalInfo->p_AdTableOld          = p_FmPcdCcNode->h_AdTable;
-    p_AdditionalInfo->p_KeysMatchTableOld   =p_FmPcdCcNode->h_KeysMatchTable;
+    p_AdditionalInfo->p_KeysMatchTableOld   = p_FmPcdCcNode->h_KeysMatchTable;
 
     return E_OK;
 }
@@ -1283,6 +1407,15 @@ static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
+#ifdef FM_MANIP_SUPPORT
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCc(&p_KeyParams->ccNextEngineParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_MANIP_SUPPORT */
+
     p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
 
     err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
@@ -1292,45 +1425,44 @@ static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode
     i = 0;
     for(j = 0; j < p_AdditionalInfo->numOfKeys; j++)
     {
-        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp = CAST_UINT64_TO_POINTER((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
         if(j == keyIndex)
          {
             NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            p_KeysMatchTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
             if(p_AdditionalInfo->lclMask)
             {
                 if(p_KeyParams->p_Mask)
-                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 else
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
             }
          }
          else
          {
-            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + i*FM_PCD_CC_AD_ENTRY_SIZE);
             IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            p_KeysMatchTableNewTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableOld) + i*size*sizeof(uint8_t));
             if(p_AdditionalInfo->lclMask)
             {
                 if(p_FmPcdCcNode->lclMask)
                 {
-                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableOldTmp)+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
                 }
-                else
                 {
-                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->h_KeysMatchTable) + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
            i++;
          }
     }
 
-    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + i*FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_AdditionalInfo->keyIndexForRemove = 0xffff;
@@ -1359,7 +1491,7 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
     {
         if(j == keyIndex)
         {
-            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + j*FM_PCD_CC_AD_ENTRY_SIZE);
             if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
                 p_AdditionalInfo->keyIndexForRemove = keyIndex;
             else
@@ -1368,16 +1500,16 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
         }
         if(j == p_FmPcdCcNode->numOfKeys)
             break;
-         p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
-         p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + j*FM_PCD_CC_AD_ENTRY_SIZE);
          IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-         p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + j*size*sizeof(uint8_t));
-         p_KeysMatchTableNewTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew+ i*size*sizeof(uint8_t));
+         p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableOld) + j*size*sizeof(uint8_t));
+         p_KeysMatchTableNewTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + i*size*sizeof(uint8_t));
          IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
     }
 
-    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + j*FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_AdditionalInfo->nodeIdForAdd = 0xffff;
@@ -1385,7 +1517,6 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
    return E_OK;
 }
 
-
 static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     t_Error                 err = E_OK;
@@ -1402,44 +1533,44 @@ static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcN
 
     for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
     {
-        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + i*FM_PCD_CC_AD_ENTRY_SIZE);
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
         if(j == keyIndex)
         {
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            p_KeysMatchTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
             if(p_AdditionalInfo->lclMask)
             {
                 if(p_Mask)
-                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 else
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
             }
         }
         else
         {
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*size*sizeof(uint8_t));
+            p_KeysMatchTableNewTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->h_KeysMatchTable) + i*size*sizeof(uint8_t));
             if(p_AdditionalInfo->lclMask)
             {
                 if(p_FmPcdCcNode->lclMask)
                 {
-                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableOldTmp)+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
                 }
                 else
                 {
-                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->h_KeysMatchTable) + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    IOMemSet32((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 }
             }
             IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
         }
     }
 
-    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + i*FM_PCD_CC_AD_ENTRY_SIZE);
-    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->h_AdTable) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_AdditionalInfo->nodeIdForAdd = 0xffff;
     p_AdditionalInfo->keyIndexForRemove = 0xffff;
@@ -1461,6 +1592,15 @@ static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNod
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
+#ifdef FM_MANIP_SUPPORT
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCc(&p_KeyParams->ccNextEngineParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_MANIP_SUPPORT */
+
     p_AdditionalInfo->numOfKeys = p_FmPcdCcNode->numOfKeys;
 
     err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (bool)(p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
@@ -1469,48 +1609,48 @@ static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNod
 
     for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
     {
-        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + j*FM_PCD_CC_AD_ENTRY_SIZE);
         if(j == keyIndex)
          {
-            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + i*FM_PCD_CC_AD_ENTRY_SIZE);
             if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
                 p_AdditionalInfo->keyIndexForRemove = keyIndex;
             else
                 p_AdditionalInfo->keyIndexForRemove = 0xffff;
             NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            p_KeysMatchTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            Mem2IOCpy32((void *)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
             if(p_FmPcdCcNode->lclMask)
             {
                 if(p_KeyParams->p_Mask)
-                    IO2IOCpy32((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 else
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
             }
          }
          else
          {
-            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTableOldTmp = CAST_UINT64_TO_POINTER((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
             IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            p_KeysMatchTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableOld) + i*size*sizeof(uint8_t));
             if(p_AdditionalInfo->lclMask)
             {
                 if(p_FmPcdCcNode->lclMask)
-                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    IO2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
                 else
                 {
-                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
-                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                    p_KeysMatchTableOldTmp  = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_KeysMatchTableOld) + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
                 }
             }
-             IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+             IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
          }
     }
 
-    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
-    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableNew) + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdditionalInfo->p_AdTableOld) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
         p_AdditionalInfo->nodeIdForAdd = (uint16_t)nextEngineParamsInfo.additionalInfo;
@@ -1519,7 +1659,6 @@ static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNod
     return E_OK;
 }
 
-
 static void FillNodeWithParams(t_FmPcdCcNode *p_FmPcdCcNodeTo, t_FmPcdCcNode *p_FmPcdCcNodeFrom, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams)
 {
     p_FmPcdCcNodeTo->h_AdTable       = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
@@ -1543,14 +1682,13 @@ static t_Error ModifyWithNodeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_F
     t_FmPcdCcNode                   *p_FmPcdCcNodePrev;
     t_List                          p_List;
 
-
     INIT_LIST(&p_List);
 
     LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccPrevNodesLst)
     {
         p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
         nodeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
-        p_FmPcdCcNodePrev = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, nodeIdPrev);
+        p_FmPcdCcNodePrev = GetNodeHandler((t_FmPcdCc *)p_FmPcd->h_FmPcdCc, nodeIdPrev);
         if(!p_FmPcdCcNodePrev)
             RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
         FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcNodePrev->ccNextNodesLst,nodeId, &p_List);
@@ -1566,6 +1704,7 @@ static t_Error ModifyWithNodeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_F
     ReleaseLst(&p_List);
     return E_OK;
 }
+
 static t_Error ModifyWithTreeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode, t_List  *h_OldLst)
 {
     t_List                          *p_Pos,*p_Pos1;
@@ -1574,14 +1713,13 @@ static t_Error ModifyWithTreeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_F
     t_List                          p_List;
     t_FmPcdCcTree                   *p_FmPcdCcTreePrev;
 
-
     INIT_LIST(&p_List);
 
     LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreeIdLst)
     {
         p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
         treeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
-        p_FmPcdCcTreePrev = (t_FmPcdCcTree *)FmPcdCcGetTreeHandler(p_FmPcd, (uint8_t)treeIdPrev);
+        p_FmPcdCcTreePrev = GetTreeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint8_t)treeIdPrev);
         if(!p_FmPcdCcTreePrev)
             RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
         FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcTreePrev->ccNextNodesLst,nodeId , &p_List);
@@ -1603,8 +1741,8 @@ static t_Error ModifyKeyCommonPart1(t_FmPcdCcNode *p_FmPcdCcNode,  uint8_t keyIn
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
 
-    if(p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL ||
-       p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)
+    if((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+       (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT) || (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
 
     if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
@@ -1625,80 +1763,572 @@ static t_Error ModifyKeyCommonPart1(t_FmPcdCcNode *p_FmPcdCcNode,  uint8_t keyIn
     return E_OK;
 }
 
-t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+static t_Error ModifyKeyCommonPart2(t_FmPcd *p_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_Handle *h_NewPointer)
 {
-    t_FmPcdCcTree                   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_Error                         err = E_OK;
-    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
-    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_Error         err = E_OK;
+    t_FmPcdCcNode   fmPcdCcNode;
 
-    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
+    {
+        err =  ModifyWithNodeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
+    {
+        err =  ModifyWithTreeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+        {
+            ReleaseLst(h_OldLst);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
 
+    memset(&fmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+    FillNodeWithParams(&fmPcdCcNode, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams);
+    err = ModifyCcKeyCommon(p_FmPcd,h_NewPointer, TRUE);
+    if(err)
+    {
+        ReleaseLst(h_OldLst);
+        ReleaseCommonModifyKey(p_FmPcd->h_FmMuram,(t_FmPcdModifyCcAdditionalParams *)*h_NewPointer);
+    }
+    /*TODO - to take care about manips at all*/
+    FillAdOfTypeContLookup(((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->p_Ad,
+                           p_FmPcd,
+                           &fmPcdCcNode,
+#ifdef FM_MANIP_SUPPORT
+                           NULL/*p_FmPcdCcNextEngineParams->h_Manip*/
+#else
+                           NULL
+#endif /* FM_MANIP_SUPPORT */
+                           );
 
-    if(grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+    ((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->h_AdditionalInfo = p_FmPcdModifyCcKeyAdditionalParams;
 
-    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+    return E_OK;
+}
 
-    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint16_t *p_CcArray, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err = E_OK;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
 
-    p_CcOldModifyAdditionalParams = *h_OldPointer;
-    p_CcOldModifyAdditionalParams->p_Ad =
-        CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
-    p_CcOldModifyAdditionalParams->isTree = TRUE;
-    p_CcOldModifyAdditionalParams->h_Node = p_FmPcdCcTree;
-    p_CcNewModifyAdditionalParams  = *h_NewPointer;
-    p_CcNewModifyAdditionalParams->isTree = TRUE;
-    p_CcNewModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+    if(!LIST_IsEmpty(ccNextNodesLst))
+    {
+         LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+         {
+             nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+             p_FmPcdCcNode = GetNodeHandler((t_FmPcdCc *)(((t_FmPcd *)h_FmPcd)->h_FmPcdCc), (uint16_t)nodeIdTmp);
+             if(!p_FmPcdCcNode)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+             if(p_CcArray[(uint16_t)nodeIdTmp] ==0)
+             {
+                 err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst,p_CcArray, treeId);
+                 if(err)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                 CreateNodeInfo(&p_FmPcdCcNode->ccTreesLst, (uint32_t)treeId);
+                 p_CcArray[(uint16_t)nodeIdTmp] = 1;
+             }
+        }
+    }
+    return E_OK;
+}
 
-    ModifyCcCommon2(p_CcOldModifyAdditionalParams, p_CcNewModifyAdditionalParams, (uint8_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+static t_Error RemoveNodesFromTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err = E_OK;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
+    t_CcNodeInfo    *p_CcNodeInfo;
+
+    if(!LIST_IsEmpty(ccNextNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+        {
+            nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+            p_FmPcdCcNode = GetNodeHandler(((t_FmPcdCc *)((t_FmPcd *)h_FmPcd)->h_FmPcdCc), (uint16_t)nodeIdTmp);
+            if(!p_FmPcdCcNode)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+            err = RemoveNodesFromTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst, treeId);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            p_CcNodeInfo = FindNodeInfoAccId(&p_FmPcdCcNode->ccTreesLst, treeId);
+            ASSERT_COND(p_CcNodeInfo);
+            LIST_DelAndInit(&p_CcNodeInfo->node);
+            XX_Free(p_CcNodeInfo);
+        }
+    }
 
     return E_OK;
 }
 
+static t_Error  FmPcdCcUpdateTreeOwner(t_Handle h_FmPcd, uint8_t treeId, bool add)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-static t_Error ModifyKeyCommonPart2(t_FmPcd *p_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_Handle *h_NewPointer)
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[treeId].p_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((treeId < FM_PCD_MAX_NUM_OF_CC_TREES), E_INVALID_VALUE);
+
+    if(add)
+        ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[treeId].owners++;
+    else
+    {
+        if(!((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[treeId].owners)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("this tree wasn't assighned before"))  ;
+        ((t_FmPcdCc*)p_FmPcd->h_FmPcdCc)->ccTreeArrayEntry[treeId].owners--;
+    }
+
+    return E_OK;
+}
+
+#ifdef FM_MANIP_SUPPORT
+
+
+static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, t_Handle h_FmPort, uint32_t requiredAction, t_FmPcdCcNextEngineAndRecuiredActionParams *p_CcNextEngineParamsTmp, 
+                                        t_Handle h_AdTmp, uint16_t numOfEntries)
 {
+            
+    t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
+    uint32_t            tmpReg32;
+    t_Error             err;
+    t_FmPcdCcNode       *p_FmPcdCcNode;
+    int                 i = 0;
+    uint16_t            tmp = 0;
+    uint16_t            profileId;
+    uint8_t             relativeSchemeId, physicalSchemeId;
+     for(i = 0; i < numOfEntries; i++)
+     {
+        if(i == 0)
+            h_AdTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(h_AdTmp) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+        else
+            h_AdTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(h_AdTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
 
-    t_Error         err = E_OK;
-    t_FmPcdCcNode   fmPcdCcNode;
+        if(p_CcNextEngineParamsTmp[i].requiredAction & requiredAction)
+            continue;
+        switch(p_CcNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        {
+            case(e_FM_PCD_CC):
+                p_FmPcdCcNode = p_CcNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
+                ASSERT_COND(p_FmPcdCcNode);
+                if(p_FmPcdCcNode->requiredAction & requiredAction)
+                    break;
+                else
+                {
+                    if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                        tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+                    else
+                        tmp = p_FmPcdCcNode->numOfKeys;
+                    err = FmPcdCcSetRequiredAction(h_FmPcd, h_FmPort, requiredAction, p_FmPcdCcNode->nextEngineAndRequiredAction, p_FmPcdCcNode->h_AdTable, tmp);
+                    if(!err)
+                        p_FmPcdCcNode->requiredAction |= requiredAction;
+                    return err;
+                }
+            break;
+            case(e_FM_PCD_KG) : 
+                physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme)-1);
+                relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
+                if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                    RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+                if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+                if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
+                err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction);
+                if(err == E_OK)
+                    p_CcNextEngineParamsTmp[i].requiredAction = requiredAction;
+                return err;
+                break;
+            case(e_FM_PCD_PLCR) : 
+                if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                {
+                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
+                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
+                }
+                if(p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                {
+                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
+                }
+                else
+                    err =  FmPcdPlcrGetAbsoluteProfileId(h_FmPcd, e_FM_PCD_PLCR_PORT_PRIVATE, h_FmPort, p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
+                if(err)
+                    return err;
+                err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
+                if(err == E_OK)
+                    p_CcNextEngineParamsTmp[i].requiredAction = requiredAction;
+                return err;
+            case(e_FM_PCD_DONE) : 
+                if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                {
+                    tmpReg32 = GET_UINT32(p_AdTmp->nia);
+                    tmpReg32 |= NIA_BMI_AC_WITHOUT_DMA;
+                    WRITE_UINT32(p_AdTmp->nia, tmpReg32);
+                    break;
+                }
+                p_CcNextEngineParamsTmp[i].requiredAction = requiredAction;
+            }
+        }
+     return E_OK;
+       
+    }
 
-    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
+
+static t_Error CcUpdateParam(t_Handle                       h_FmPcd,
+                             t_Handle                       h_FmPort,
+                             t_FmPcdCcNextEngineAndRecuiredActionParams      *p_CcNextEngineParams,
+                             uint16_t                       numOfEntries,
+                             t_Handle                       h_Ad,
+                             bool                           validate,
+                             t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback)
+{
+    int i = 0;
+    t_FmPcdCcNode *p_FmPcdCcNode;
+    uint16_t tmp = 0;
+    t_Error err;
+    uint32_t requiredAction;
+    
+    if(numOfEntries)
     {
-        err =  ModifyWithNodeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        for(i = 0; i < numOfEntries; i++)
+        {
+            if(i == 0)
+                h_Ad = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(h_Ad) + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            else
+                h_Ad = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(h_Ad) + FM_PCD_CC_AD_ENTRY_SIZE);
+            if(p_CcNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                p_FmPcdCcNode = p_CcNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, p_FmPortGetSetCcParamsCallback);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                    requiredAction = FmPcdManipGetRequiredAction(p_CcNextEngineParams[i].nextEngineParams.h_Manip);
+                }
+                else
+                    requiredAction = UPDATE_NIA_ENQ_WITH_DMA;
+                
+                err = FmPcdCcSetRequiredAction(h_FmPcd, h_FmPort,requiredAction, &p_CcNextEngineParams[i], h_Ad, 1);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+                else
+                    tmp = p_FmPcdCcNode->numOfKeys;
+                
+                err = CcUpdateParam(h_FmPcd, h_FmPort, p_FmPcdCcNode->nextEngineAndRequiredAction, tmp, p_FmPcdCcNode->h_AdTable, validate,p_FmPortGetSetCcParamsCallback);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+            else
+            {
+                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate,p_FmPortGetSetCcParamsCallback);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                    requiredAction = FmPcdManipGetRequiredAction(p_CcNextEngineParams[i].nextEngineParams.h_Manip);
+                }
+                else
+                    requiredAction = UPDATE_NIA_ENQ_WITH_DMA;
+                if(requiredAction)
+                {
+                    err = FmPcdCcSetRequiredAction(h_FmPcd,h_FmPort,requiredAction, &p_CcNextEngineParams[i], h_Ad, 1);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
+        }
+    }
+
+    return E_OK;
+}
+
+static uint32_t CcUpdateParams(t_Handle                         h_FmPcd,
+                               t_Handle                         h_FmPort,
+                               t_Handle                         h_FmTree,
+                               bool                             validate,
+                               t_FmPortGetSetCcParamsCallback   *p_FmPortGetSetCcParamsCallback)
+{
+    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+    uint16_t             numOfEntries = 0;
+    int                 i = 0;
+    for(i = 0; i < p_CcTree->numOfGrps; i++)
+        numOfEntries+=p_CcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+
+    return CcUpdateParam(h_FmPcd, h_FmPort, p_CcTree->nextEngineAndRequiredAction, numOfEntries, CAST_UINT64_TO_POINTER(p_CcTree->ccTreeBaseAddr), validate, p_FmPortGetSetCcParamsCallback);
+}
+#endif /* FM_MANIP_SUPPORT */
+
+static t_Error CheckParams(t_Handle             h_FmPcd,
+                           t_FmPcdCcNodeParams  *p_CcNodeParam,
+                           t_FmPcdCcNode        *p_FmPcdCcNode,
+                           uint16_t             *ccInfo,
+                           t_List               *ccNextDifferentNodesLst,
+                           bool                 *isKeyTblAlloc)
+{
+    int                     tmp = 0;
+    t_FmPcdCcKeyParams      *p_KeyParams;
+    t_Error                 err;
+    uint32_t                myInfo;
+    t_NextEngineParamsInfo  nextEngineParamsInfo;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+
+#ifdef FM_MANIP_SUPPORT
+    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCc(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
         if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
-    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
+#endif /* FM_MANIP_SUPPORT */
+
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
     {
-        err =  ModifyWithTreeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)(p_CcNodeParam->keysParams.numOfKeys << 16);
+        CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst, myInfo);
+        if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+            CreateNodeInfo(ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+        ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+    }
+
+    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys],&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if(!p_KeyParams->p_Key)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
+
+
+       err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
         if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+        err = UpdateGblMask(p_FmPcdCcNode,
+                            p_CcNodeParam->keysParams.keySize,
+                            p_KeyParams->p_Mask);
+
+#ifdef FM_MANIP_SUPPORT
+        if(p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            ReleaseLst(h_OldLst);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+            err = FmPcdManipCheckParamsForCc(&p_KeyParams->ccNextEngineParams);
+            if(err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
+#endif /* FM_MANIP_SUPPORT */
 
+        if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        {
+            myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
+            CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
+            if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                CreateNodeInfo(ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+            ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+        }
+        memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp],&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
     }
 
-    memset(&fmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
-    FillNodeWithParams(&fmPcdCcNode, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams);
-    err = ModifyCcKeyCommon(p_FmPcd,h_NewPointer, TRUE);
+    *isKeyTblAlloc = TRUE;
+    return E_OK;
+}
+
+static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(  t_Handle h_FmPcd,
+                                                    t_FmPcdCcNodeParams *p_CcNodeParam, t_FmPcdCcNode *p_FmPcdCcNode,
+                                                    uint16_t *ccInfo,
+                                                    t_List *ccNextDifferentNodesLst,
+                                                    bool *isKeyTblAlloc)
+{
+    int                 tmp = 0;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Error             err;
+    uint32_t            myInfo;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    uint8_t             key = 0x01;
+
+    if(p_FmPcdCcNode->numOfKeys != 1 )
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
     if(err)
+        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+
+#ifdef FM_MANIP_SUPPORT
+    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        ReleaseLst(h_OldLst);
-        ReleaseCommonModifyKey((p_FmPcd->p_FmPcdCc)->h_FmMuram,(t_FmPcdModifyCcAdditionalParams *)*h_NewPointer);
+        err = FmPcdManipCheckParamsForCc(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
-    FillAdOfTypeContLookup(((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->p_Ad, p_FmPcd,&fmPcdCcNode);
+#endif /* FM_MANIP_SUPPORT */
 
-    ((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->h_AdditionalInfo = p_FmPcdModifyCcKeyAdditionalParams;
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+    {
+        myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)(p_CcNodeParam->keysParams.numOfKeys << 16);
+        CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst, myInfo);
+        if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+            CreateNodeInfo(ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+        ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+    }
+
+    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys], &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if(p_KeyParams->p_Mask)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
+        if(memcmp(p_KeyParams->p_Key, &key, 1) != 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+        if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        {
+            myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
+            CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
+            if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                CreateNodeInfo(ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+            ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+        }
+
+#ifdef FM_MANIP_SUPPORT
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCc(&p_KeyParams->ccNextEngineParams);
+            if(err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+#endif /* FM_MANIP_SUPPORT */
+
+    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    }
+
+    *isKeyTblAlloc = FALSE;
+    return E_OK;
+}
+
+static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
+                                            t_FmPcdCcNodeParams *p_CcNodeParam,
+                                            t_FmPcdCcNode *p_FmPcdCcNode,
+                                            uint16_t *ccInfo,
+                                            t_List *ccNextDifferentNodesLst,
+                                            bool *isKeyTblAlloc)
+{
+    int                 tmp = 0, countOnes = 0;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Error             err;
+    uint32_t            myInfo;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    uint16_t            glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
+    uint16_t            countMask = (uint16_t)(glblMask >> 4);
+
+    if(glblMask & 0x000f)
+       RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("icIndxMask has to be with last nibble 0"));
+
+    while (countMask)
+    {
+        countOnes++;
+        countMask=(uint16_t)(countMask>>1);
+    }
+
+    if(!POWER_OF_2(p_FmPcdCcNode->numOfKeys))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTo"));
+    if(p_FmPcdCcNode->numOfKeys != ((uint32_t)1<<countOnes ))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTo"));
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
+    if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+        RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
+
+        if((glblMask & (tmp * 16)) == (tmp * 16))
+        {
+            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+            if(err)
+                RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
+
+#ifdef FM_MANIP_SUPPORT
+            if(p_KeyParams->ccNextEngineParams.h_Manip)
+            {
+                err = FmPcdManipCheckParamsForCc(&p_KeyParams->ccNextEngineParams);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+            }
+#endif /* FM_MANIP_SUPPORT */
+
+            if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+            {
+                myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
+                CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
+                if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                    CreateNodeInfo(ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+                ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+            }
+            memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp],&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        }
+        else
+        {
+            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+            if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+                RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
+        }
+    }
+    *isKeyTblAlloc = FALSE;
+    memcpy(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->p_GlblMask) + 2), &glblMask, 2);
 
     return E_OK;
 }
 
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcTree                   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error                         err = E_OK;
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
+    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad =
+        CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+    p_CcOldModifyAdditionalParams->isTree = TRUE;
+    p_CcOldModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcNewModifyAdditionalParams->isTree = TRUE;
+    p_CcNewModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams, p_CcNewModifyAdditionalParams, (uint8_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+
+    return E_OK;
+}
 
 t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
 {
@@ -1727,9 +2357,9 @@ t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex
     err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
     if(err)
     {
-            ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
-            XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        ReleaseNewNodeCommonPart((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     return E_OK;
@@ -1743,7 +2373,6 @@ t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
     t_Error                         err = E_OK;
     t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
 
-
     err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -1764,12 +2393,12 @@ t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
     err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
     if(err)
     {
-        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        ReleaseNewNodeCommonPart((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
         XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
- return E_OK;
+    return E_OK;
 }
 
 t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_Handle *h_NewPointer)
@@ -1796,12 +2425,12 @@ t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
     err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
     if(err)
     {
-        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        ReleaseNewNodeCommonPart((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
         XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
- return E_OK;
+    return E_OK;
 }
 
 t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
@@ -1818,7 +2447,6 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, ui
     if(keyIndex >= p_FmPcdCcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
 
-
     err = BuildNewNodeModifyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
     if(err)
     {
@@ -1829,16 +2457,14 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, ui
     err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
     if(err)
     {
-        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        ReleaseNewNodeCommonPart((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
         XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
- return E_OK;
+    return E_OK;
 }
 
-
-
 t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
 {
     t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
@@ -1849,7 +2475,6 @@ t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode,
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
 
-
     if(keyIndex >= p_FmPcdCcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
 
@@ -1857,9 +2482,8 @@ t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode,
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-
     p_CcOldModifyAdditionalParams = *h_OldPointer;
-    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * keyIndex);
+    p_CcOldModifyAdditionalParams->p_Ad = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_FmPcdCcNode->h_AdTable) + FM_PCD_CC_AD_ENTRY_SIZE * keyIndex);
     p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
 
     p_CcNewModifyAdditionalParams  = *h_NewPointer;
@@ -1882,7 +2506,6 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdC
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-
     p_CcOldModifyAdditionalParams = *h_OldPointer;
     p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * p_FmPcdCcNode->numOfKeys);
     p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
@@ -1893,62 +2516,6 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdC
 
     return E_OK;
 }
-static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint16_t *p_CcArray, uint8_t treeId)
-{
-    t_List          *p_Pos;
-    t_Error         err = E_OK;
-    t_FmPcdCcNode   *p_FmPcdCcNode;
-    uint32_t        nodeIdTmp;
-    if(!LIST_IsEmpty(ccNextNodesLst))
-     {
-         LIST_FOR_EACH(p_Pos, ccNextNodesLst)
-         {
-             nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
-             p_FmPcdCcNode = (t_FmPcdCcNode *)GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
-             if(!p_FmPcdCcNode)
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-             if(p_CcArray[(uint16_t)nodeIdTmp] ==0)
-             {
-                 err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst,p_CcArray, treeId);
-                 if(err)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-                 CreateNodeInfo(&p_FmPcdCcNode->ccTreesLst, (uint32_t)treeId);
-                 p_CcArray[(uint16_t)nodeIdTmp] = 1;
-             }
-         }
-     }
-    return E_OK;
-}
-
-static t_Error RemoveNodesFromTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint8_t treeId)
-{
-    t_List          *p_Pos;
-    t_Error         err = E_OK;
-    t_FmPcdCcNode   *p_FmPcdCcNode;
-    uint32_t        nodeIdTmp;
-    t_CcNodeInfo    *p_CcNodeInfo;
-    if(!LIST_IsEmpty(ccNextNodesLst))
-    {
-        LIST_FOR_EACH(p_Pos, ccNextNodesLst)
-        {
-            nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
-            p_FmPcdCcNode = GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
-            if(!p_FmPcdCcNode)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-            err = RemoveNodesFromTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst, treeId);
-            if(err)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-            p_CcNodeInfo = FindNodeInfoAccId(&p_FmPcdCcNode->ccTreesLst, treeId);
-            ASSERT_COND(p_CcNodeInfo);
-            LIST_DelAndInit(&p_CcNodeInfo->h_Node);
-            XX_Free(p_CcNodeInfo);
-        }
-    }
-
-    return E_OK;
-}
-
 
 t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood)
 {
@@ -1964,173 +2531,79 @@ t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdO
     uint16_t                        ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointer,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_CcOldModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
 
     if(isAllGood)
     {
-            if(p_CcNewModifyAdditionalParams->isTree)
-                p_CurrentTree = (t_FmPcdCcTree*)p_CcNewModifyAdditionalParams->h_Node;
-            else
-                p_CurrentNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_Node;
-           if(p_CurrentTree)
+        if(p_CcNewModifyAdditionalParams->isTree)
+            p_CurrentTree = (t_FmPcdCcTree*)p_CcNewModifyAdditionalParams->h_Node;
+        else
+            p_CurrentNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_Node;
+        if(p_CurrentTree)
+        {
+            if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
             {
-                    if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
-                    {
-                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
-                        ASSERT_COND(p_NodeForAdd);
-                        CreateNodeInfo(&p_CurrentTree->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
-                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccTreeIdLst, p_CurrentTree->treeId);
-                        if(p_CcNodeInfo)
-                        {
-                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
-                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
-                        }
-                        else
-                            CreateNodeInfo(&p_NodeForAdd->ccTreeIdLst, (uint32_t)((uint32_t)p_CurrentTree->treeId | ((uint32_t)1<<16)));
-                        memset(ccArray, 0, sizeof(uint16_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
-                        err = UpdateNodesWithTree(h_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, p_CurrentTree->treeId);
-                        if(err)
-                            RETURN_ERROR(MAJOR, err, NO_MSG);
-                    }
-                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
-                    {
-                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentTree->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
-                        ASSERT_COND(p_CcNodeInfo);
-                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
-                        ASSERT_COND(p_NodeForRemove);
-                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
-                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccTreeIdLst, p_CurrentTree->treeId);
-                        ASSERT_COND(p_CcNodeInfo1);
-                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
-                        ASSERT_COND(numOfReplec);
-                        numOfReplec -=1;
-                        if(numOfReplec)
-                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
-                        else
-                        {
-                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
-                            XX_Free(p_CcNodeInfo1);
-                        }
-                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
-                        XX_Free(p_CcNodeInfo);
-                        err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, p_CurrentTree->treeId);
-                        if(err)
-                            RETURN_ERROR(MAJOR, err, NO_MSG);
-                     }
+                p_NodeForAdd = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
+                ASSERT_COND(p_NodeForAdd);
+                CreateNodeInfo(&p_CurrentTree->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
+                p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccTreeIdLst, p_CurrentTree->treeId);
+                if(p_CcNodeInfo)
+                {
+                    numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                    p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
+                }
+                else
+                    CreateNodeInfo(&p_NodeForAdd->ccTreeIdLst, (uint32_t)((uint32_t)p_CurrentTree->treeId | ((uint32_t)1<<16)));
+                memset(ccArray, 0, sizeof(uint16_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
+                err = UpdateNodesWithTree(h_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, p_CurrentTree->treeId);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
             }
-            else if(p_CurrentNode)
+            if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
             {
-                   if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
-                    {
-                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
-                        ASSERT_COND(p_NodeForAdd);
-                        CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
-                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
-                        if(p_CcNodeInfo)
-                        {
-                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
-                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
-                        }
-                        else
-                            CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, (uint32_t)((uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16)));
-
-                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
-                        {
-                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-                            memset(ccArray, 0, sizeof(uint16_t)*FM_PCD_MAX_NUM_OF_CC_NODES);
-                            err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
-                            if(err)
-                                RETURN_ERROR(MAJOR, err, NO_MSG);
-                        }
-                    }
-                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
-                    {
-                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
-                        ASSERT_COND(p_CcNodeInfo);
-                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
-                        ASSERT_COND(p_NodeForRemove);
-                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
-                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
-                        ASSERT_COND(p_CcNodeInfo1);
-                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
-                        ASSERT_COND(numOfReplec);
-                        numOfReplec -=1;
-                        if(numOfReplec)
-                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
-                        else
-                        {
-                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
-                            XX_Free(p_CcNodeInfo1);
-                        }
-                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
-                        XX_Free(p_CcNodeInfo);
-                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
-                        {
-                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-                            err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
-                            if(err)
-                                RETURN_ERROR(MAJOR, err, NO_MSG);
-                        }
-                  }
+                p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentTree->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
+                ASSERT_COND(p_CcNodeInfo);
+                p_NodeForRemove = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                ASSERT_COND(p_NodeForRemove);
+                UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccTreeIdLst, p_CurrentTree->treeId);
+                ASSERT_COND(p_CcNodeInfo1);
+                numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
+                ASSERT_COND(numOfReplec);
+                numOfReplec -=1;
+                if(numOfReplec)
+                    p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                else
+                {
+                    LIST_DelAndInit(&p_CcNodeInfo1->node);
+                    XX_Free(p_CcNodeInfo1);
+                }
+                LIST_DelAndInit(&p_CcNodeInfo->node);
+                XX_Free(p_CcNodeInfo);
+                err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, p_CurrentTree->treeId);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
             }
-       }
-         else
-         {
-        if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
-            UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo, FALSE);
-       }
-
-    if(p_CcNewModifyAdditionalParams->p_Ad)
-        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
-
-    XX_Free(h_FmPcdNewPointer);
-    XX_Free(h_FmPcdOldPointer);
-
-    return E_OK;
-}
-t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges)
-{
-    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
-    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdCcKeyAdditionalParams;
-    t_FmPcdCcNode                  *p_CurrentNode = NULL, *p_NodeForAdd, *p_NodeForRemove;
-    uint32_t                        numOfReplec;
-    t_List                          *p_Pos;
-    t_Error                         err = E_OK;
-    uint16_t                        ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
-
-    UNUSED(numOfGoodChanges);
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointer,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_AdditionalInfo,E_INVALID_HANDLE);
-
-            p_FmPcdCcKeyAdditionalParams  = (t_FmPcdModifyCcKeyAdditionalParams *)p_CcNewModifyAdditionalParams->h_AdditionalInfo;
-            p_CurrentNode = (t_FmPcdCcNode *)p_FmPcdCcKeyAdditionalParams->h_CurrentNode;
-            if(p_FmPcdCcKeyAdditionalParams->nodeIdForAdd != 0xffff)
+        }
+        else if(p_CurrentNode)
+        {
+            if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
             {
-                p_NodeForAdd = GetNodeHandler(p_FmPcd, p_FmPcdCcKeyAdditionalParams->nodeIdForAdd);
+                p_NodeForAdd = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
                 ASSERT_COND(p_NodeForAdd);
+                CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
                 p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
                 if(p_CcNodeInfo)
                 {
-                    numOfReplec = p_CcNodeInfo->nextCcNodeInfo >> 16;
-                    numOfReplec +=1;
-                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                    numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                    p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
                 }
                 else
-                {
-                    numOfReplec = (uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16);
-                    CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, numOfReplec);
-                }
-                CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, (((uint32_t)p_FmPcdCcKeyAdditionalParams->keyIndexForAdd << 16) |(uint32_t)p_FmPcdCcKeyAdditionalParams->nodeIdForAdd));
+                    CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, (uint32_t)((uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16)));
+
                 LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
                 {
                     p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
@@ -2140,24 +2613,26 @@ t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLs
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
             }
-            if(p_FmPcdCcKeyAdditionalParams->keyIndexForRemove != 0xffff)
+            if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
             {
-                p_CcNodeInfo =  FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, p_FmPcdCcKeyAdditionalParams->keyIndexForRemove);
+                p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
                 ASSERT_COND(p_CcNodeInfo);
-                p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
-                UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo, FALSE);
+                p_NodeForRemove = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                ASSERT_COND(p_NodeForRemove);
                 p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
-                numOfReplec = p_CcNodeInfo1->nextCcNodeInfo >> 16;
+                UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                ASSERT_COND(p_CcNodeInfo1);
+                numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
                 ASSERT_COND(numOfReplec);
                 numOfReplec -=1;
                 if(numOfReplec)
-                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                    p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
                 else
                 {
-                    LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                    LIST_DelAndInit(&p_CcNodeInfo1->node);
                     XX_Free(p_CcNodeInfo1);
                 }
-                LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                LIST_DelAndInit(&p_CcNodeInfo->node);
                 XX_Free(p_CcNodeInfo);
                 LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
                 {
@@ -2165,26 +2640,119 @@ t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLs
                     err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
                     if(err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                 }
-              }
+                }
+            }
+        }
+    }
+    else
+    {
+        if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+            UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo, FALSE);
+    }
 
-            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
-            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
-            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
-            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+    if(p_CcNewModifyAdditionalParams->p_Ad)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
 
-            p_CurrentNode->h_AdTable    = p_FmPcdCcKeyAdditionalParams->p_AdTableNew;
-            p_CurrentNode->numOfKeys    = p_FmPcdCcKeyAdditionalParams->numOfKeys;
-            p_CurrentNode->lclMask      = p_FmPcdCcKeyAdditionalParams->lclMask;
-            p_CurrentNode->h_KeysMatchTable = p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableNew;
+    XX_Free(h_FmPcdNewPointer);
+    XX_Free(h_FmPcdOldPointer);
+
+    return E_OK;
+}
+
+t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdCcKeyAdditionalParams;
+    t_FmPcdCcNode                  *p_CurrentNode = NULL, *p_NodeForAdd, *p_NodeForRemove;
+    uint32_t                        numOfReplec;
+    t_List                          *p_Pos;
+    t_Error                         err = E_OK;
+    uint16_t                        ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
 
-            XX_Free(p_CcNewModifyAdditionalParams->h_AdditionalInfo);
-            p_CcNewModifyAdditionalParams->h_AdditionalInfo = NULL;
+    UNUSED(numOfGoodChanges);
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointer,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_AdditionalInfo,E_INVALID_HANDLE);
+
+    p_FmPcdCcKeyAdditionalParams  = (t_FmPcdModifyCcKeyAdditionalParams *)p_CcNewModifyAdditionalParams->h_AdditionalInfo;
+    p_CurrentNode = (t_FmPcdCcNode *)p_FmPcdCcKeyAdditionalParams->h_CurrentNode;
+    if(p_FmPcdCcKeyAdditionalParams->nodeIdForAdd != 0xffff)
+    {
+        p_NodeForAdd = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), p_FmPcdCcKeyAdditionalParams->nodeIdForAdd);
+        ASSERT_COND(p_NodeForAdd);
+        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
+        if(p_CcNodeInfo)
+        {
+            numOfReplec = p_CcNodeInfo->nextCcNodeInfo >> 16;
+            numOfReplec +=1;
+            p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+        }
+        else
+        {
+            numOfReplec = (uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16);
+            CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, numOfReplec);
+        }
+        CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, (((uint32_t)p_FmPcdCcKeyAdditionalParams->keyIndexForAdd << 16) |(uint32_t)p_FmPcdCcKeyAdditionalParams->nodeIdForAdd));
+        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            memset(ccArray, 0, sizeof(uint16_t)*FM_PCD_MAX_NUM_OF_CC_NODES);
+            err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+    if(p_FmPcdCcKeyAdditionalParams->keyIndexForRemove != 0xffff)
+    {
+        p_CcNodeInfo =  FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, p_FmPcdCcKeyAdditionalParams->keyIndexForRemove);
+        ASSERT_COND(p_CcNodeInfo);
+        p_NodeForRemove = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+        UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo, FALSE);
+        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
+        numOfReplec = p_CcNodeInfo1->nextCcNodeInfo >> 16;
+        ASSERT_COND(numOfReplec);
+        numOfReplec -=1;
+        if(numOfReplec)
+            p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+        else
+        {
+            LIST_DelAndInit(&p_CcNodeInfo1->node);
+            XX_Free(p_CcNodeInfo1);
+        }
+        LIST_DelAndInit(&p_CcNodeInfo->node);
+        XX_Free(p_CcNodeInfo);
+        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+         }
+     }
+
+    ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+    ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+
+    p_CurrentNode->h_AdTable    = p_FmPcdCcKeyAdditionalParams->p_AdTableNew;
+    p_CurrentNode->numOfKeys    = p_FmPcdCcKeyAdditionalParams->numOfKeys;
+    p_CurrentNode->lclMask      = p_FmPcdCcKeyAdditionalParams->lclMask;
+    p_CurrentNode->h_KeysMatchTable = p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableNew;
+
+    XX_Free(p_CcNewModifyAdditionalParams->h_AdditionalInfo);
+    p_CcNewModifyAdditionalParams->h_AdditionalInfo = NULL;
 
     ReleaseLst(h_FmPcdOldPointersLst);
 
     if(p_CcNewModifyAdditionalParams->p_Ad)
-        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
 
     XX_Free(h_FmPcdNewPointer);
 
@@ -2196,10 +2764,10 @@ uint32_t FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer)
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
-    return (uint32_t)((uint64_t)(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad)) -
-                     p_FmPcd->p_FmPcdCc->physicalMuramBase);
+    return (uint32_t)(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad) -
+                     p_FmPcd->physicalMuramBase);
 }
 
 uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
@@ -2208,37 +2776,14 @@ uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Point
     t_CcNodeInfo                    *p_CcNodeInfo;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(h_Pointer);
-    return (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo))) -
-                      p_FmPcd->p_FmPcdCc->physicalMuramBase);
-}
-
-static t_Error  FmPcdCcUpdateTreeOwner(t_Handle h_FmPcd, uint8_t treeId, bool add)
-{
-
-
-    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((treeId < FM_PCD_MAX_NUM_OF_CC_TREES), E_INVALID_VALUE);
-
-    if(add)
-        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners++;
-    else
-    {
-        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners)
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("this tree wasn't assighned before"))  ;
-        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners--;
-    }
-
-    return E_OK;
+    return (uint32_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo)) -
+                      p_FmPcd->physicalMuramBase);
 }
 
-t_Error     CcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
 
@@ -2252,17 +2797,11 @@ t_Error     CcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_Gr
     return E_OK;
 }
 
-t_Handle CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+t_Handle    FmPcdCcConfig(t_Handle h_FmPcd, t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdCc           *p_FmPcdCc;
-#ifdef CONFIG_GUEST_PARTITION
-    t_FmPcdIcPhysAddr   physicalMuramBase;
-    t_Error             err = E_OK;
-#else
-    t_FmPhysAddr        physicalMuramBase;
-#endif /* CONFIG_GUEST_PARTITION */
 
-    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
     p_FmPcdCc = (t_FmPcdCc *) XX_Malloc(sizeof(t_FmPcdCc));
     if (!p_FmPcdCc)
     {
@@ -2270,26 +2809,16 @@ t_Handle CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
         return NULL;
     }
     memset(p_FmPcdCc, 0, sizeof(t_FmPcdCc));
-
-    p_FmPcdCc->h_FmMuram = p_FmPcdParams->h_FmMuram;
-#ifndef CONFIG_GUEST_PARTITION
-    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
-#else
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GET_PHYS_MURAM_BASE, (uint8_t*)&physicalMuramBase, NULL, NULL);
-    if(err)
-    {
-        REPORT_ERROR(MINOR, err, NO_MSG);
-    }
-#endif /* CONFIG_GUEST_PARTITION */
-    p_FmPcdCc->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+    p_FmPcdCc->h_FmPcd = h_FmPcd;
 
     return p_FmPcdCc;
 }
 
-void CcFree(t_FmPcdCc *p_FmPcdCc)
+void FmPcdCcFree(t_Handle h_FmPcdCc)
 {
+    t_FmPcdCc   *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
+    int         i = 0;
 
-    int i = 0;
     for (i = 0; i < FM_PCD_MAX_NUM_OF_CC_NODES; i++)
         ReleaseNode(p_FmPcdCc, (uint16_t)i);
 
@@ -2297,14 +2826,18 @@ void CcFree(t_FmPcdCc *p_FmPcdCc)
         ReleaseTree(p_FmPcdCc, (uint8_t)i);
 }
 
-t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset)
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset
+#ifdef FM_MANIP_SUPPORT
+        ,t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback, t_Handle h_FmPort
+#endif /* FM_MANIP_SUPPORT */
+)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
     t_Error             err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
 
     err = FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, TRUE);
@@ -2312,9 +2845,14 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     *p_Offset = (uint32_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr)) -
-                           ((t_FmPcd *)p_FmPcd)->p_FmPcdCc->physicalMuramBase);
+                           p_FmPcd->physicalMuramBase);
 
-    return E_OK;
+#ifdef FM_MANIP_SUPPORT
+    err = CcUpdateParams(h_FmPcd, h_FmPort, h_FmPcdCcTree, TRUE, p_FmPortGetSetCcParamsCallback);
+    //*changeNia =  CcCheckForChangeNia(h_FmPcd, (t_Handle)p_FmPcdCcTree);
+#endif /* FM_MANIP_SUPPORT */
+
+    return err;
 }
 
 t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
@@ -2326,6 +2864,57 @@ t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
     return  FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, FALSE);
 }
 
+t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
+{
+    if (TRY_LOCK(NULL, ((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
+}
+
+void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+{
+    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+}
+
+void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
+{
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = GetTreeHandler((t_FmPcdCc *)((t_FmPcd *)h_FmPcd)->h_FmPcdCc, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+    }
+    ReleaseLst(p_List);
+}
+
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+{
+    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+    t_Error         err = E_OK;
+
+    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = GetTreeHandler((t_FmPcdCc *)((t_FmPcd *)h_FmPcd)->h_FmPcdCc, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        err = FmPcdCcTreeTryLock(h_FmPcdCcTree);
+        if(err == E_OK)
+            CreateNodeInfo(p_List, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        else
+            FmPcdCcNodeTreeReleaseLock(h_FmPcd, p_List);
+    }
+
+    return err;
+}
+
 t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
@@ -2348,16 +2937,18 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     t_List                      ccNextDifferentNodesLst;
     uint32_t                    myInfo;
     uint16_t                    ccArray[FM_PCD_MAX_NUM_OF_CC_NODES];
+    t_FmPcdInfoForManip         infoForManip;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE, NULL);
 
     memset(ccInfo, 0, sizeof(uint8_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
     memset(ccArray, 0, sizeof(uint16_t) * FM_PCD_MAX_NUM_OF_CC_NODES);
+    memset(&infoForManip, 0, sizeof(t_FmPcdInfoForManip));
 
     memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
-    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+    p_FmPcdCc = (t_FmPcdCc*)p_FmPcd->h_FmPcdCc;
 
     err = OccupyTreeId(p_FmPcd, &treeId);
     if(err)
@@ -2377,6 +2968,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
 
     INIT_LIST(&p_FmPcdCcTree->ccNextNodesLst);
+    INIT_LIST(&p_FmPcdCcTree->manipLst);
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
     INIT_LIST(&ccNextDifferentNodesLst);
 
@@ -2430,8 +3022,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
         for(j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
         {
-
-            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], &nextEngineParamsInfo);
+            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &nextEngineParamsInfo);
             if(err)
             {
                 ReleaseTree(p_FmPcdCc,treeId);
@@ -2448,14 +3039,30 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
                 ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
             }
-           memcpy(&params[k], &p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
+
+#ifdef FM_MANIP_SUPPORT
+            if(p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
+            {
+                err = FmPcdManipCheckParamsForCc(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j]);
+                if(err)
+                {
+                    ReleaseTree(p_FmPcdCc,treeId);
+                    ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                    return NULL;
+                }
+                CreateNodeInfo(&p_FmPcdCcTree->manipLst,(uint32_t)infoForManip.h_Manip);
+
+           }
+#endif /* FM_MANIP_SUPPORT */
+           memcpy(&params[k], &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
            k++;
         }
     }
 
     p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
     p_FmPcdCcTree->ccTreeBaseAddr =
-        CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+        CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd),
                                                  (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
                                                  FM_PCD_CC_AD_TABLE_ALIGN));
 
@@ -2466,7 +3073,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
-    WRITE_BLOCK(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_CcTreeTmp  = CAST_UINT64_TO_POINTER(p_FmPcdCcTree->ccTreeBaseAddr);
 
@@ -2474,7 +3081,8 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     for(i = 0; i < numOfEntries; i++)
     {
         NextStepAd(p_CcTreeTmp,&params[i],p_FmPcd);
-        p_CcTreeTmp =   (t_Handle)(((uint32_t)p_CcTreeTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+        p_CcTreeTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_CcTreeTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+        memcpy(&p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams, &params[i], sizeof(t_FmPcdCcNextEngineParams));
     }
 
     if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
@@ -2482,7 +3090,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
         {
             p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            p_FmPcdCcNextNode = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
             if(!p_FmPcdCcNextNode)
             {
                 ReleaseTree(p_FmPcdCc,treeId);
@@ -2509,6 +3117,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
+
     return p_FmPcdCcTree;
 }
 
@@ -2520,7 +3129,7 @@ t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
     t_List                      *p_Pos;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
 
     FmPcdDecNetEnvOwners(h_FmPcd, p_CcTree->netEnvId);
@@ -2534,7 +3143,16 @@ t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
         UpdateNodeOwner(p_FmPcd, (uint16_t)nodeIdTmp, FALSE);
     }
 
-    ReleaseTree(p_FmPcd->p_FmPcdCc, p_CcTree->treeId);
+#ifdef FM_MANIP_SUPPORT
+    LIST_FOR_EACH(p_Pos, &p_CcTree->manipLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        FmManipUpdateOwner((t_Handle)nodeIdTmp, FALSE);
+    }
+
+#endif /* FM_MANIP_SUPPORT */
+
+    ReleaseTree((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_CcTree->treeId);
 
     return E_OK;
 }
@@ -2552,17 +3170,17 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     t_Handle            p_AdTableTmp;
     bool                fullField = FALSE;
     uint16_t            nodeId;
-    t_NextEngineParamsInfo nextEngineParamsInfo;
     uint16_t            profileInfo[FM_PCD_PLCR_NUM_ENTRIES];
-    uint16_t            ccInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
-    uint8_t             ccDifferentInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
+    uint16_t            ccInfo[FM_PCD_MAX_NUM_OF_CC_NODES], manipInfo[FM_PCD_MAX_NUM_OF_CC_NODES];
     t_List              *p_Pos;
     t_CcNodeInfo        *p_CcNodeInfo;
-    t_List              ccNextDifferentNodesLst;
+    t_List              ccNextDifferentNodesLst, manipNextDifferentNodesLst;
     uint32_t            myInfo;
+    ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
+    bool                isKeyTblAlloc, fromIc = FALSE;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE,NULL);
+    SANITY_CHECK_RETURN_VALUE((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE,NULL);
 
     if (!p_CcNodeParam->keysParams.keySize ||
         !p_CcNodeParam->keysParams.numOfKeys)
@@ -2573,22 +3191,9 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
 
     memset(profileInfo, 0x00, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
     memset(ccInfo, 0x00, FM_PCD_MAX_NUM_OF_CC_NODES*sizeof(uint16_t));
-    memset(ccDifferentInfo, 0x00, FM_PCD_MAX_NUM_OF_CC_NODES*sizeof(uint8_t));
+    memset(manipInfo, 0x00, FM_PCD_MAX_NUM_OF_CC_NODES*sizeof(uint16_t));
 
-    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
-
-    if((p_CcNodeParam->keysParams.keySize > 4 )&& (p_CcNodeParam->keysParams.p_GlblMask))
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Global Mask is relevant only for keySize less or equal than 4"));
-        return NULL;
-    }
-
-    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
-    if(err)
-    {
-        REPORT_ERROR(MAJOR, err, NO_MSG);
-        return NULL;
-    }
+    p_FmPcdCc = (t_FmPcdCc*)p_FmPcd->h_FmPcdCc;
 
     err = OccupyNodeId(p_FmPcd, &nodeId);
     if(err)
@@ -2606,60 +3211,113 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     }
     memset(p_FmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
 
+    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    memset(p_FmPcdCcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+
+    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+
     INIT_LIST(&p_FmPcdCcNode->ccNextNodesLst);
     INIT_LIST(&p_FmPcdCcNode->ccPrevNodesLst);
     INIT_LIST(&p_FmPcdCcNode->ccTreeIdLst);
     INIT_LIST(&p_FmPcdCcNode->ccTreesLst);
+    INIT_LIST(&p_FmPcdCcNode->manipLst);
 
     INIT_LIST(&ccNextDifferentNodesLst);
+    INIT_LIST(&manipNextDifferentNodesLst);
 
-    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+    if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
+        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
     {
-        myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)(p_CcNodeParam->keysParams.numOfKeys << 16);
-        CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst, myInfo);
-        if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
-            CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
-        ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+            err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, ccInfo, &ccNextDifferentNodesLst, &isKeyTblAlloc);
+            glblMask = FALSE;
+
     }
+    else if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
+        ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
+           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
+           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
+    {
+        if((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
+            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+            return NULL;
+        }
 
-    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+        icCode = IcDefineCode(p_CcNodeParam);
+        fromIc = TRUE;
+        if(icCode == CC_PRIVATE_INFO_NONE)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+            return NULL;
+        }
 
-    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
-    memset(p_FmPcdCcNode->p_GlblMask, 0, p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
+        if((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) || (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+        {
+            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, ccInfo, &ccNextDifferentNodesLst, &isKeyTblAlloc);
 
-    if(p_CcNodeParam->keysParams.p_GlblMask)
-    {
-        memcpy((void*)p_FmPcdCcNode->p_GlblMask,p_CcNodeParam->keysParams.p_GlblMask,p_CcNodeParam->keysParams.keySize);
-        glblMask = TRUE;
-        p_FmPcdCcNode->glblMaskSize = (uint8_t)p_CcNodeParam->keysParams.keySize;
+            glblMask = TRUE;
+        }
+        else
+        {
+            err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, ccInfo, &ccNextDifferentNodesLst, &isKeyTblAlloc);
+            if(p_FmPcdCcNode->glblMaskSize)
+                glblMask = TRUE;
+        }
     }
     else
-     {   memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE);
-         p_FmPcdCcNode->glblMaskSize = CC_GLBL_MASK_SIZE;
-     }
+    {
+        err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, ccInfo, &ccNextDifferentNodesLst, &isKeyTblAlloc);
+        if(p_FmPcdCcNode->glblMaskSize)
+            glblMask = TRUE;
+    }
+
+    if(err)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+
     switch(p_CcNodeParam->extractCcParams.type)
     {
         case(e_FM_PCD_EXTRACT_BY_HDR):
-            switch(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.type)
+            switch(p_CcNodeParam->extractCcParams.extractByHdr.type)
             {
                 case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
-                                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField);
-                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
+                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
                     fullField = TRUE;
+                    if((p_FmPcdCcNode->parseCode != CC_PC_FF_TCI1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_TCI2) && 
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) &&
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
+                       glblMask)
+                    {
+                        glblMask = FALSE;
+                        p_FmPcdCcNode->glblMaskSize = 4;
+                        p_FmPcdCcNode->lclMask = TRUE;
+                    }
                     break;
                 case(e_FM_PCD_EXTRACT_FROM_HDR):
-                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.size;
-                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
                                                                 p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
                         break;
                 case(e_FM_PCD_EXTRACT_FROM_FIELD):
-                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.offset;
-                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.size;
-                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.field,
+                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
                                                     p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
-                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex);
+                                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
                         break;
                 default:
                     ReleaseNode(p_FmPcdCc,nodeId);
@@ -2670,30 +3328,25 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
             break;
         case(e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
-            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.size;
-            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.offset;
-            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset);
-            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_GMASK)
-            {
-                p_FmPcdCcNode->offset +=  p_FmPcdCcNode->prsArrayOffset;
-                p_FmPcdCcNode->prsArrayOffset = 0;
-            }
+            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
+
             if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
-                 ReleaseNode(p_FmPcdCc,nodeId);
-                 REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("Not implemented yet"));
-                 return NULL;
-                if(!glblMask)
-               {
-                   REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("in the type e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH glblMask has to be defined"));
-                   return NULL;
-               }
-                if(p_FmPcdCcNode->sizeOfExtraction != 2)
+                if((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 64)
                 {
-                    REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("in the type e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH sizeOfExtraction has to be 2 bytes"));
-                    return NULL;
+                     ReleaseNode(p_FmPcdCc,nodeId);
+                     ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                     REPORT_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
+                     return NULL;
                 }
-              }
+            }
+            if((p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_GMASK) || (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            {
+                p_FmPcdCcNode->offset +=  p_FmPcdCcNode->prsArrayOffset;
+                p_FmPcdCcNode->prsArrayOffset = 0;
+            }
                 break;
 
        default:
@@ -2711,14 +3364,6 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         return NULL;
     }
 
-    if(((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) || (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)) && (p_FmPcdCcNode->numOfKeys != 1 ))
-    {
-        ReleaseNode(p_FmPcdCc,nodeId);
-        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
-        return NULL;
-    }
-
     if((p_FmPcdCcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
     {
         ReleaseNode(p_FmPcdCc,nodeId);
@@ -2735,59 +3380,19 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         return NULL;
     }
 
+    if(!glblMask)
+        memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE);
+    
     GetCcExtractKeySize(p_FmPcdCcNode->sizeOfExtraction, &p_FmPcdCcNode->ccKeySizeAccExtraction);
 
-    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
-    {
-        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
-        if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
-        {
-
-                if(!p_KeyParams->p_Key)
-                {
-                    ReleaseNode(p_FmPcdCc,nodeId);
-                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-                    REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_Key is not initialized"));
-                    return NULL;
-                }
-
-                if(p_KeyParams->p_Mask && glblMask)
-                {
-                    ReleaseNode(p_FmPcdCc,nodeId);
-                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-                    REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Can not be used globalMask and localMask"));
-                    return NULL;
-                }
-
-        }
-        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
-        if(err)
-        {
-            ReleaseNode(p_FmPcdCc,nodeId);
-            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-            REPORT_ERROR(MAJOR, err, (NO_MSG));
-            return NULL;
-        }
-        if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
-        {
-            myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
-            CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
-            if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
-                CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
-            ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
-        }
-        if(p_KeyParams->p_Mask)
-            p_FmPcdCcNode->lclMask = TRUE;
-    }
-
     if(p_FmPcdCcNode->lclMask)
         size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
     else
         size = p_FmPcdCcNode->ccKeySizeAccExtraction;
 
-    if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
+    if(isKeyTblAlloc)
     {
-        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd),
                                          (uint32_t)(size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1)),
                                          FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if(!p_FmPcdCcNode->h_KeysMatchTable)
@@ -2797,20 +3402,20 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
             return NULL;
         }
-        WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
+        IOMemSet32((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
     }
 
-    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCc->h_FmPcd),
                                      (uint32_t)( (p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
                                      FM_PCD_CC_AD_TABLE_ALIGN);
     if(!p_FmPcdCcNode->h_AdTable)
     {
         ReleaseNode(p_FmPcdCc,nodeId);
         ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
         return NULL;
     }
-    WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_KeysMatchTblTmp    = p_FmPcdCcNode->h_KeysMatchTable;
     p_AdTableTmp         = p_FmPcdCcNode->h_AdTable;
@@ -2820,18 +3425,17 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
 
         if(p_KeysMatchTblTmp)
         {
-
-            COPY_BLOCK((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
 
             if(p_FmPcdCcNode->lclMask && p_KeyParams->p_Mask)
-                COPY_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
+                Mem2IOCpy32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
             else if(p_FmPcdCcNode->lclMask)
-                WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->sizeOfExtraction);
-            p_KeysMatchTblTmp = (t_Handle)(((uint32_t)p_KeysMatchTblTmp) + size * sizeof(uint8_t));
+                IOMemSet32(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->sizeOfExtraction);
+            p_KeysMatchTblTmp = CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_KeysMatchTblTmp) + size * sizeof(uint8_t));
         }
         NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
 
-        p_AdTableTmp =   (t_Handle)(((uint32_t)p_AdTableTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableTmp =   CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_AdTableTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
 
     }
     NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
@@ -2839,13 +3443,12 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     if(fullField == TRUE)
         p_FmPcdCcNode->sizeOfExtraction = 0;
 
-
     if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
     {
         LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
         {
             p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            p_FmPcdCcNextNode = GetNodeHandler((t_FmPcdCc *)(p_FmPcd->h_FmPcdCc), (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
             if(!p_FmPcdCcNextNode)
             {
                 ReleaseNode(p_FmPcdCc,nodeId);
@@ -2870,7 +3473,7 @@ t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
     t_List                      *p_Pos;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc,E_INVALID_STATE);
 
     if(!p_CcNode)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID is not initialized"));
@@ -2885,7 +3488,18 @@ t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
 
     }
 
-    ReleaseNode(p_FmPcd->p_FmPcdCc, p_CcNode->nodeId);
+#ifdef FM_MANIP_SUPPORT
+    LIST_FOR_EACH(p_Pos, &p_CcNode->manipLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        FmManipUpdateOwner((t_Handle)nodeIdTmp, FALSE);
+
+    }
+
+#endif /* FM_MANIP_SUPPORT */
+
+    ReleaseNode((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, p_CcNode->nodeId);
+
     return E_OK;
 }
 
@@ -2894,7 +3508,7 @@ t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
@@ -2905,7 +3519,7 @@ t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
@@ -2916,7 +3530,7 @@ t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcModifyNodeMissNextEngine(p_FmPcd->h_Hc, h_CcNode, p_FmPcdCcNextEngineParams);
@@ -2927,7 +3541,7 @@ t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyI
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
@@ -2938,7 +3552,7 @@ t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyInde
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
@@ -2949,7 +3563,7 @@ t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode,
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
@@ -2960,48 +3574,8 @@ t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyI
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((t_FmPcdCc*)p_FmPcd->h_FmPcdCc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
 }
-
-void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
-{
-    t_List          *p_Pos;
-    t_CcNodeInfo    *p_CcNodeInfo;
-    t_Handle        h_FmPcdCcTree;
-
-    LIST_FOR_EACH(p_Pos, p_List)
-    {
-        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
-        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
-    }
-    ReleaseLst(p_List);
-}
-
-t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
-{
-    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List          *p_Pos;
-    t_CcNodeInfo    *p_CcNodeInfo;
-    t_Handle        h_FmPcdCcTree;
-    t_Error         err = E_OK;
-
-    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
-    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
-    {
-        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
-        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
-        err = FmPcdCcTreeTryLock(h_FmPcdCcTree);
-        if(err == E_OK)
-            CreateNodeInfo(p_List, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
-        else
-            FmPcdCcNodeTreeReleaseLock(h_FmPcd, p_List);
-    }
-
-    return err;
-}
-
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
new file mode 100644
index 0000000..efbcd89
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -0,0 +1,311 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_cc.h
+
+ @Description   FM PCD CC ...
+*//***************************************************************************/
+#ifndef __FM_CC_H
+#define __FM_CC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_pcd.h"
+
+
+/***********************************************************************/
+/*          Coarse classification defines                              */
+/***********************************************************************/
+
+#define CC_PC_FF_MACDST                     0x00
+#define CC_PC_FF_MACSRC                     0x01
+#define CC_PC_FF_ETYPE                      0x02
+
+#define CC_PC_FF_TCI1                       0x03
+#define CC_PC_FF_TCI2                       0x04
+
+#define CC_PC_FF_MPLS1                      0x06
+#define CC_PC_FF_MPLS_LAST                  0x07
+
+#define CC_PC_FF_IPV4DST1                   0x08
+#define CC_PC_FF_IPV4DST2                   0x16
+#define CC_PC_FF_IPV4IPTOS_TC1              0x09
+#define CC_PC_FF_IPV4IPTOS_TC2              0x17
+#define CC_PC_FF_IPV4PTYPE1                 0x0A
+#define CC_PC_FF_IPV4PTYPE2                 0x18
+#define CC_PC_FF_IPV4SRC1                   0x0b
+#define CC_PC_FF_IPV4SRC2                   0x19
+#define CC_PC_FF_IPV4SRC1_IPV4DST1          0x0c
+#define CC_PC_FF_IPV4SRC2_IPV4DST2          0x1a
+#define CC_PC_FF_IPV4TTL                    0x29
+
+
+#define CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1    0x0d /*TODO - CLASS - what is it? TOS*/
+#define CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2    0x1b
+#define CC_PC_FF_IPV6PTYPE1                 0x0e
+#define CC_PC_FF_IPV6PTYPE2                 0x1c
+#define CC_PC_FF_IPV6DST1                   0x0f
+#define CC_PC_FF_IPV6DST2                   0x1d
+#define CC_PC_FF_IPV6SRC1                   0x10
+#define CC_PC_FF_IPV6SRC2                   0x1e
+#define CC_PC_FF_IPV6HOP_LIMIT              0x2a
+#define CC_PC_FF_GREPTYPE                   0x11
+
+#define CC_PC_FF_MINENCAP_PTYPE             0x12
+#define CC_PC_FF_MINENCAP_IPDST             0x13
+#define CC_PC_FF_MINENCAP_IPSRC             0x14
+#define CC_PC_FF_MINENCAP_IPSRC_IPDST       0x15
+
+#define CC_PC_FF_L4PSRC                     0x1f
+#define CC_PC_FF_L4PDST                     0x20
+#define CC_PC_FF_L4PSRC_L4PDST              0x21
+
+#define CC_PC_FF_PPPPID                     0x05
+
+#define CC_PC_PR_SHIM1                      0x22
+#define CC_PC_PR_SHIM2                      0x23
+
+#define CC_PC_GENERIC_WITHOUT_MASK          0x27
+#define CC_PC_GENERIC_WITH_MASK             0x28
+#define CC_PC_GENERIC_IC_GMASK              0x2B
+#define CC_PC_GENERIC_IC_HASH_INDEXED       0x2C
+
+#define CC_PR_OFFSET                        0x25
+#define CC_PR_WITHOUT_OFFSET                0x26
+
+#define CC_PC_PR_ETH_OFFSET                 19
+#define CC_PC_PR_USER_DEFINED_SHIM1_OFFSET  16
+#define CC_PC_PR_USER_DEFINED_SHIM2_OFFSET  17
+#define CC_PC_PR_USER_LLC_SNAP_OFFSET       20
+#define CC_PC_PR_VLAN1_OFFSET               21
+#define CC_PC_PR_VLAN2_OFFSET               22
+#define CC_PC_PR_PPPOE_OFFSET               24
+#define CC_PC_PR_MPLS1_OFFSET               25
+#define CC_PC_PR_MPLS_LAST_OFFSET           26
+#define CC_PC_PR_IP1_OFFSET                 27
+#define CC_PC_PR_IP_LAST_OFFSET             28
+#define CC_PC_PR_MINENC_OFFSET              28
+#define CC_PC_PR_L4_OFFSET                  30
+#define CC_PC_PR_GRE_OFFSET                 29
+#define CC_PC_PR_ETYPE_LAST_OFFSET          23
+#define CC_PC_PR_NEXT_HEADER_OFFSET         31
+
+#define CC_PC_ILLEGAL                       0xff
+#define CC_SIZE_ILLEGAL                     0
+
+#define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
+#define FM_PCD_CC_AD_TABLE_ALIGN            256
+#define FM_PCD_CC_AD_ENTRY_SIZE             16
+#define FM_PCD_CC_NUM_OF_KEYS               255
+
+#define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
+#define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
+#define FM_PCD_AD_RESULT_PLCR_DIS           0x20000000
+#define FM_PCD_AD_RESULT_EXTENDED_MODE      0x80000000
+#define FM_PCD_AD_RESULT_NADEN              0x20000000
+
+
+#define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
+#define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
+
+#define FM_PCD_AD_TYPE_MASK                 0xc0000000
+#define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+
+#define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
+#define CC_GLBL_MASK_SIZE                   4
+
+typedef uint32_t ccPrivateInfo_t; /**< private info of CC: */
+
+#define CC_PRIVATE_INFO_NONE                       0
+#define CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP       0x80000000
+#define CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH        0x40000000
+#define CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH         0x20000000
+#define CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP   0x10000000
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+typedef _Packed struct {
+    volatile uint32_t fqid;
+    volatile uint32_t plcrProfile;
+    volatile uint32_t nia;
+    volatile uint8_t  res[4];
+} _PackedType t_AdOfTypeResult;
+
+typedef _Packed struct {
+    volatile uint32_t ccAdBase;
+    volatile uint32_t matchTblPtr;
+    volatile uint32_t pcAndOffsets;
+    volatile uint32_t gmask;
+} _PackedType t_AdOfTypeContLookup;
+
+typedef _Packed union {
+    volatile t_AdOfTypeResult        adResult;
+    volatile t_AdOfTypeContLookup    adContLookup;
+} _PackedType t_Ad;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+/***********************************************************************/
+/*  Driver's internal structures                                        */
+/***********************************************************************/
+
+typedef struct {
+    t_Handle         p_Ad;
+    e_FmPcdEngine    fmPcdEngine;
+    bool             adAllocated;
+    bool             isTree;
+
+    uint32_t    myInfo;
+    t_List      *h_CcNextNodesLst;
+    t_Handle    h_AdditionalInfo;
+    t_Handle    h_Node;
+} t_FmPcdModifyCcAdditionalParams;
+
+typedef struct {
+    t_Handle p_AdTableNew;
+    t_Handle p_KeysMatchTableNew;
+    t_Handle p_AdTableOld;
+    t_Handle p_KeysMatchTableOld;
+    bool     lclMask;
+    uint16_t numOfKeys;
+    t_Handle h_CurrentNode;
+    uint16_t nodeIdForAdd;
+    uint16_t keyIndexForRemove;
+    uint16_t keyIndexForAdd;
+} t_FmPcdModifyCcKeyAdditionalParams;
+
+
+typedef struct 
+{
+    t_Handle h_Manip;
+    t_Handle h_CcNode;
+}t_CcNextEngineInfo;
+
+typedef struct
+{
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    uint32_t                    requiredAction;
+}t_FmPcdCcNextEngineAndRecuiredActionParams;
+
+
+typedef struct {
+    uint16_t    numOfKeys;
+    bool        glblMaskUpdated;
+    t_Handle    p_GlblMask;
+    bool        lclMask;
+    uint8_t     parseCode;
+    uint8_t     offset;
+    uint8_t     prsArrayOffset;
+    bool        ctrlFlow;
+    uint16_t    nodeId;
+
+    uint8_t     ccKeySizeAccExtraction;
+    uint8_t     sizeOfExtraction;
+    uint8_t     glblMaskSize;
+
+    t_Handle    h_KeysMatchTable;
+    t_Handle    h_AdTable;
+
+    t_List      ccNextNodesLst;
+    t_List      ccPrevNodesLst;
+
+    t_List      ccTreeIdLst;
+    t_List      ccTreesLst;
+
+    t_List      manipLst;
+    
+    uint32_t    requiredAction;
+    t_FmPcdCcNextEngineAndRecuiredActionParams nextEngineAndRequiredAction[256];
+} t_FmPcdCcNode;
+
+typedef struct {
+    t_FmPcdCcNode       *p_FmPcdCcNode;
+    bool                occupied;
+    uint8_t             owners;
+    volatile bool       lock;
+} t_FmPcdCcNodeArray;
+
+typedef struct {
+    uint8_t             numOfEntriesInGroup;
+    uint32_t            totalBitsMask;
+    uint8_t             baseGroupEntry;
+} t_FmPcdCcGroupParam;
+
+
+typedef struct {
+    uint8_t             netEnvId;
+    uint64_t            ccTreeBaseAddr;
+    uint8_t             numOfGrps;
+    t_FmPcdCcGroupParam fmPcdGroupParam[8];
+    t_List              ccNextNodesLst;
+    t_List              manipLst;
+    t_List              fmPortsLst;
+    uint8_t             treeId;
+    volatile bool       lock;
+    t_FmPcdCcNextEngineAndRecuiredActionParams nextEngineAndRequiredAction[256];
+} t_FmPcdCcTree;
+
+typedef struct {
+   e_FmPcdEngine        fmPcdEngine;
+   uint32_t             additionalInfo;
+} t_NextEngineParamsInfo;
+
+typedef struct {
+    t_FmPcdCcTree       *p_FmPcdCcTree;
+    bool                occupied;
+    uint8_t             owners;
+    volatile bool       lock;
+} t_FmPcdCcTreeArray;
+
+typedef struct {
+    t_Handle            h_FmPcd;
+    t_FmPcdCcNodeArray  ccNodeArrayEntry[FM_PCD_MAX_NUM_OF_CC_NODES];
+    t_FmPcdCcTreeArray  ccTreeArrayEntry[FM_PCD_MAX_NUM_OF_CC_TREES];
+} t_FmPcdCc;
+
+
+bool FmPcdManipIsManipNode(t_Handle h_Ad);
+
+
+#endif /* __FM_CC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 48769bd..4404ea0 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -40,10 +40,24 @@
 #include "string_ext.h"
 #include "debug_ext.h"
 #include "net_ext.h"
-#include "fm_pcd.h"
 #include "fm_port_ext.h"
+
+#include "fm_common.h"
+#include "fm_pcd.h"
 #include "fm_hc.h"
 
+#include "fm_pcd_ipc.h"
+
+
+static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
+{
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
+    /* Wait for GO to be idle and read error */
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
+    if (kgar & FM_PCD_KG_KGAR_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
+    return E_OK;
+}
 
 static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDefaults[], uint8_t numOfSwDefaults, uint8_t code)
 {
@@ -51,7 +65,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
 
     switch(code)
     {
-        case( KG_SCH_GEN_PARSE_RESULT):
+        case( KG_SCH_GEN_PARSE_RESULT_N_FQID):
         case( KG_SCH_GEN_DEFAULT):
         case( KG_SCH_GEN_NEXTHDR):
             for(i=0 ; i<numOfSwDefaults ; i++)
@@ -60,7 +74,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             ASSERT_COND(FALSE);
         case( KG_SCH_GEN_SHIM1):
         case( KG_SCH_GEN_SHIM2):
-        case( KG_SCH_GEN_SHIM3):
+        case( KG_SCH_GEN_IP_PID_NO_V):
         case( KG_SCH_GEN_ETH_NO_V):
         case( KG_SCH_GEN_SNAP_NO_V):
         case( KG_SCH_GEN_VLAN1_NO_V):
@@ -108,17 +122,22 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
     }
 }
 
-static uint8_t GetGenCode(e_FmPcdExtractFrom src)
+static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 {
+    *p_Offset = 0;
+
     switch(src)
     {
         case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
             return KG_SCH_GEN_START_OF_FRM;
-        case(e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE):
+        case(e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
             return KG_SCH_GEN_DEFAULT;
-        case(e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT):
-            return KG_SCH_GEN_PARSE_RESULT;
-        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+        case(e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
+            return KG_SCH_GEN_PARSE_RESULT_N_FQID;
+        case(e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
+            *p_Offset = 32;
+            return KG_SCH_GEN_PARSE_RESULT_N_FQID;
+        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
             return KG_SCH_GEN_NEXTHDR;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -227,14 +246,11 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
                 return KG_SCH_GEN_SHIM1;
             case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 return KG_SCH_GEN_SHIM2;
-            case(HEADER_TYPE_USER_DEFINED_SHIM3):
-                return KG_SCH_GEN_SHIM3;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                 return 0;
         }
 }
-
 static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
 {
     if(!ignoreProtocolValidation)
@@ -251,19 +267,17 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-                break;
             case(HEADER_TYPE_VLAN):
                 switch(field.vlan)
                 {
-                case(NET_HEADER_FIELD_VLAN_TCI) :
-                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                        return KG_SCH_GEN_VLAN1;
-                    if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        return KG_SCH_GEN_VLAN2;
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                    case(NET_HEADER_FIELD_VLAN_TCI):
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            return KG_SCH_GEN_VLAN1;
+                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            return KG_SCH_GEN_VLAN2;
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
-                break;
             case(HEADER_TYPE_MPLS):
             case(HEADER_TYPE_IPSEC_AH):
             case(HEADER_TYPE_IPSEC_ESP):
@@ -298,24 +312,38 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-                break;
                 case(HEADER_TYPE_VLAN):
                     switch(field.vlan)
                     {
-                    case(NET_HEADER_FIELD_VLAN_TCI) :
-                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                            return KG_SCH_GEN_VLAN1_NO_V;
-                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                            return KG_SCH_GEN_VLAN2_NO_V;
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
-                        return 0;
+                        case(NET_HEADER_FIELD_VLAN_TCI) :
+                            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                                return KG_SCH_GEN_VLAN1_NO_V;
+                            if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                                return KG_SCH_GEN_VLAN2_NO_V;
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                            return 0;
+                    }
+                case(HEADER_TYPE_IPv4):
+                    switch(field.ipv4)
+                    {
+                        case(NET_HEADER_FIELD_IPv4_PROTO):
+                            return KG_SCH_GEN_IP_PID_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
+                    }
+                case(HEADER_TYPE_IPv6):
+                   switch(field.ipv6)
+                    {
+                        case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                            return KG_SCH_GEN_IP_PID_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
                     }
-                    break;
                 case(HEADER_TYPE_MPLS):
                 case(HEADER_TYPE_LLC_SNAP):
                 case(HEADER_TYPE_PPPoE):
-                case(HEADER_TYPE_IPv4):
-                case(HEADER_TYPE_IPv6):
                 case(HEADER_TYPE_GRE):
                 case(HEADER_TYPE_MINENCAP):
                 case(HEADER_TYPE_USER_DEFINED_L3):
@@ -380,7 +408,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_MPLS):
             switch(field.mpls)
             {
@@ -397,7 +424,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_IPv4):
             switch(field.ipv4)
             {
@@ -433,7 +459,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_IPv6):
              switch(field.ipv6)
             {
@@ -469,7 +494,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_GRE):
             switch(field.gre)
             {
@@ -492,7 +516,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-           break;
         case(HEADER_TYPE_TCP):
             switch(field.tcp)
             {
@@ -506,7 +529,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_UDP):
             switch(field.udp)
             {
@@ -518,7 +540,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_IPSEC_AH):
             switch(field.ipsecAh)
             {
@@ -530,7 +551,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_IPSEC_ESP):
             switch(field.ipsecEsp)
             {
@@ -540,7 +560,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_SCTP):
             switch(field.sctp)
             {
@@ -552,7 +571,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_DCCP):
             switch(field.dccp)
             {
@@ -564,7 +582,6 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         case(HEADER_TYPE_PPPoE):
             switch(field.pppoe)
             {
@@ -576,13 +593,13 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-            break;
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             return 0;
     }
 }
 
+#ifdef UNDER_CONSTRUCTION_FM
 static uint8_t GetFieldSize(e_NetHeaderType hdr, t_FmPcdFields field)
 {
     UNUSED(field);
@@ -613,6 +630,7 @@ static uint8_t GetFieldSize(e_NetHeaderType hdr, t_FmPcdFields field)
             return 0;
     }
 }
+#endif /* UNDER_CONSTRUCTION_FM */
 
 static uint8_t GetKnownFieldId(uint32_t bitMask)
 {
@@ -630,221 +648,200 @@ static uint8_t GetKnownFieldId(uint32_t bitMask)
 
 }
 
-static t_Error AllocClsPlanGrpBlocks(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t *p_BaseEntry)
+static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
 {
-    uint8_t     numOfBlocks, blocksFound=0, first=0;
-    uint8_t     i, j;
-
-    numOfBlocks =  (uint8_t)(sizeOfGrp/CLS_PLAN_NUM_PER_GRP);
+    uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
-
-    /* try to find consequent blocks */
-    first = 0;
-    for(i=p_FmPcd->p_FmPcdKg->clsPlanBase;i<p_FmPcd->p_FmPcdKg->numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP;)
+    /* bitOffset 1-7 --> mask 0x1-0x7F */
+    if(bitOffset<8)
     {
-        if(!p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i])
-        {
-            blocksFound++;
-            i++;
-            if(blocksFound == numOfBlocks)
-                break;
-        }
-        else
-        {
-            blocksFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfBlocks);
-        }
-    }
-
-    if(blocksFound == numOfBlocks)
-    {
-        *p_BaseEntry = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
-        for(j = first; j<first + numOfBlocks; j++)
-            p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[j] = TRUE;
-        RELEASE_LOCK(p_FmPcd->lock);
-        return E_OK;
+        mask = 0;
+        for(i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
+            mask |= walking1Mask;
     }
     else
     {
-        RELEASE_LOCK(p_FmPcd->lock);
-        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+       mask = 0xFF;
+       numOfOnesToClear = 0;
+       if(fqid && bitOffset>24)
+           /* bitOffset 25-31 --> mask 0xFE-0x80 */
+           numOfOnesToClear = (uint8_t)(bitOffset-24);
+       else
+          /* bitOffset 9-15 --> mask 0xFE-0x80 */
+          if(!fqid && bitOffset>8)
+               numOfOnesToClear = (uint8_t)(bitOffset-8);
+       for(i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
+           mask &= ~walking1Mask;
+       /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
     }
+    return mask;
 }
 
-static void FreeClsPlanGrpBlock(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t baseEntry)
-{
-    int     i;
 
-    for(i=baseEntry/CLS_PLAN_NUM_PER_GRP;i<(baseEntry/CLS_PLAN_NUM_PER_GRP+sizeOfGrp/CLS_PLAN_NUM_PER_GRP);i++)
-    {
-        ASSERT_COND( p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i]);
-        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
-    }
-}
-
-t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    protocolOpt_t                   allOptions = 0, tmpOpt;
-    int                             i, j;
-    uint8_t                         numOfOptions = 0, grpId;
-    uint32_t                        walking1Mask, oredVectors = 0, lcvVector;
-    uint8_t                         tmpEntryId;
     t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
     t_Error                         err = E_OK;
-    struct {
-        protocolOpt_t   opt;
-        uint32_t        vector;
-    }                               tmpOptStruct[FM_PCD_MAX_NUM_OF_OPTIONS];
+    uint32_t                        oredVectors = 0;
+    uint32_t                        intFlags;
+    int                             i, j;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+    if (p_Grp->numOfOptions==FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
 
-    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     /* find a new clsPlan group */
-    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
         if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
             break;
-    if(i== PCD_MAX_NUM_OF_PORTS)
+    if(i== FM_MAX_NUM_OF_PORTS)
     {
-        REPORT_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
-        RELEASE_LOCK(p_FmPcd->lock);
-        return NULL;
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
     }
     p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+    p_Grp->clsPlanGrpId = (uint8_t)i;
 
-    TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->clsPlanGrps[i].lock);
-    RELEASE_LOCK(p_FmPcd->lock);
+    if(p_Grp->numOfOptions == 0)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
 
-    grpId = (uint8_t)i;
+    if (!TRY_LOCK(NULL, p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return ERROR_CODE(E_BUSY);
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
 
     p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
-    p_ClsPlanGrp->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1);
-
+    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
     p_ClsPlanGrp->owners = 0;
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
+    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
 
-    FmPcdIncNetEnvOwners(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1));
-
-    /* first count all options */
-    for(i=0;i<p_Grp->numOfOptions;i++)
-        allOptions |= p_Grp->options[i];
-
-    walking1Mask = 0x80000000;
-    while(allOptions)
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<p_Grp->numOfOptions);
+    /* a minimal group of 8 is required */
+    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
-        if (numOfOptions==8)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE,("Too many (more than 8) classification plan basic options selected."));
-            RELEASE_LOCK(p_FmPcd->lock);
-            return NULL;
-        }
+        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->partitionId, &p_ClsPlanGrp->baseEntry);
 
-        if(allOptions & walking1Mask)
+        if(err)
         {
-            allOptions &= ~walking1Mask;
-            /* the internal array now represents the single options considered.
-            it's order defines the location of each option in the
-            classification plan array */
-            tmpOptStruct[numOfOptions].opt = walking1Mask;
-            err = PcdGetVectorForOpt(p_FmPcd,
-                                     (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1),
-                                     walking1Mask,
-                                     &tmpOptStruct[numOfOptions].vector);
-            if(err)
-            {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
-                RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
-                return NULL;
-            }
-            oredVectors  |= tmpOptStruct[numOfOptions].vector;
-            numOfOptions++;
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
         }
-        walking1Mask >>= 1;
-    }
 
-    /* allocate 2^numOfOptions entries */
-    if(numOfOptions > FM_PCD_MAX_NUM_OF_OPTIONS)
-    {
-        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Too many options - no more than %d components allowed.", FM_PCD_MAX_NUM_OF_OPTIONS));
-        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
-        return NULL;
     }
-    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<numOfOptions);
-    /* a minimal group of 8 is required */
-    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
-        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
-
-    err = AllocClsPlanGrpBlocks(p_FmPcd, p_ClsPlanGrp->sizeOfGrp, &p_ClsPlanGrp->baseEntry);
-    if(err)
+    else
     {
-        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
-        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
-        return NULL;
+        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+        kgAlloc.partitionId = p_FmPcd->partitionId;
+        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_KG_CLSPLAN, (uint8_t*)&kgAlloc, NULL, NULL);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        p_ClsPlanGrp->baseEntry = kgAlloc.clsPlanBase;
     }
-
+    /* build classification plan entries parameters */
     p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
-
-    /* set all entries in group to be the non-option vector */
     p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
-    for(i=0;i<p_ClsPlanGrp->sizeOfGrp;i++)
-        p_ClsPlanSet->vectors[i] = ~oredVectors;
 
-    /* now set the relevant values only for user defined option */
-    for(i=0;i<p_Grp->numOfOptions;i++)
+    oredVectors = 0;
+    for(i = 0; i<p_Grp->numOfOptions; i++)
     {
-        tmpEntryId = 0;
-        lcvVector = ~oredVectors;
-        j = 0;
-        tmpOpt = p_Grp->options[i];
-        while(tmpOpt)
-        {
-            /* find each option in the internal array */
-            if((tmpOpt & tmpOptStruct[j].opt) == tmpOptStruct[j].opt)
-            {
-                /* clear that bit */
-                tmpOpt &= ~tmpOptStruct[j].opt;
-                /* j is now the internal array interesting entry */
-                tmpEntryId += (1 << j);
-                lcvVector |= tmpOptStruct[j].vector;
-            }
-            j++;
-        }
-
-        ASSERT_COND(tmpEntryId < p_ClsPlanGrp->sizeOfGrp);
-        p_ClsPlanSet->vectors[tmpEntryId] = lcvVector;
+        oredVectors |= p_Grp->optVectors[i];
+        /* save an array of used options - the indexes represent the power of 2 index */
+        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
     }
+    /* set the classification plan relevant entries so that all bits
+     * relevant to the list of options is cleared
+     */
+    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    /* save an array of used options - the indexes represent the power of 2 index */
-    j=0;
-    while(j<numOfOptions)
+    for(i = 0; i<p_Grp->numOfOptions; i++)
     {
-        p_ClsPlanGrp->optArray[j] = tmpOptStruct[j].opt;
-        j++;
+       /* option i got the place 2^i in the clsPlan array. all entries that
+         * have bit i set, should have the vector bit cleared. So each option
+         * has one location that it is exclusive (1,2,4,8...) and represent the
+         * presence of that option only, and other locations that represent a
+         * combination of options.
+         * e.g:
+         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
+         * now represents a frame with ethernet-BC header - so the bit
+         * representing ethernet-BC should be set and all other option bits
+         * should be cleared.
+         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
+         * vector[1] set, but they also have other bits set:
+         * 3=1+2, options 0 and 1
+         * 6=2+4, options 1 and 2
+         * 7=1+2+4, options 0,1,and 2
+         * 10=2+8, options 1 and 3
+         * etc.
+         * */
+
+        /* now for each option (i), we set their bits in all entries (j)
+         * that contain bit 2^i.
+         */
+        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        {
+            if(j & (1<<i))
+                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+        }
     }
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
 
-    return CAST_UINT32_TO_POINTER((uint32_t)grpId+1);;
+    return E_OK;
 }
 
 void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err;
 
-    /* check that no port is bound to this port */
+    /* check that no port is bound to this clsPlan */
     if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
     {
-       REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
-       return;
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+        return;
     }
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
 
     /* free blocks */
-    FreeClsPlanGrpBlock(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+    if(FmIsMaster(p_FmPcd->h_Fm))
+    {
+        err = KgFreeClsPlanEntries(h_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
+                                    p_FmPcd->partitionId,
+                                    p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+        if(err)
+        {
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return;
+        }
+    }
+    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    {
+        kgAlloc.partitionId = p_FmPcd->partitionId;
+        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_CLSPLAN, (uint8_t*)&kgAlloc, NULL, NULL);
+        if(err)
+        {
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
+        }
+    }
 
     /* clear clsPlan driver structure */
     memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
@@ -857,7 +854,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     t_FmPcdKgScheme         *p_Scheme;
     uint8_t                 i, relativeSchemeId;
     uint32_t                tmp, walking1Mask;
-    uint16_t                pcdPortId;
+    uint8_t                 swPortIndex = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
@@ -868,7 +865,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
         if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
         if(add)
         {
@@ -877,19 +874,19 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
 
             p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
             /* check netEnvId  of the port against the scheme netEnvId */
-            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != DRIVER_PRIVATE_NET_ENV_ID))
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
             /* if next engine is private port policer profile, we need to check that it is valid */
-            SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, p_BindPort->hardwarePortId);
+            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
             if(p_Scheme->nextRelativePlcrProfile)
             {
                 for(j = 0;j<p_Scheme->numOfProfiles;j++)
                 {
-                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort);
-                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles)
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase + p_Scheme->relativeProfileId + j)))
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
                 }
             }
@@ -959,16 +956,133 @@ void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSch
     }
 }
 
-#ifdef FM_MASTER_PARTITION
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeSp;
+    t_Error                 err = E_OK;
+
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+
+    if(add)
+        tmpKgpeSp |= spReg;
+    else
+        tmpKgpeSp &= ~spReg;
+
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    return E_OK;
+}
+
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg;
+
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+
+    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    return WriteKgarWait(p_FmPcd, tmpKgarReg);
+}
+
+static void FmPcdKgUnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
+{
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+}
+
+static t_Error KgBindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    uint32_t                tmpKgpeCpp = 0;
+
+    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
+}
+
+t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
+}
+
+bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+        return TRUE;
+    else
+        return FALSE;
+}
+
 t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            intFlags;
     uint8_t             i,j;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
     {
@@ -991,11 +1105,11 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t par
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
             p_SchemesIds[i] = 0;
         }
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
     }
 
-    RELEASE_LOCK(p_FmPcd->lock);
+    FmPcdUnlock(p_FmPcd, intFlags);
 
     return E_OK;
 }
@@ -1003,50 +1117,52 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t par
 t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            intFlags;
     uint8_t             i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     for(i=0;i<numOfSchemes;i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
         {
-            RELEASE_LOCK(p_FmPcd->lock);
+            FmPcdUnlock(p_FmPcd, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
         }
         if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != partitionId)
         {
-            RELEASE_LOCK(p_FmPcd->lock);
+            FmPcdUnlock(p_FmPcd, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
         }
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
     }
 
-    RELEASE_LOCK(p_FmPcd->lock);
+    FmPcdUnlock(p_FmPcd, intFlags);
     return E_OK;
 }
 
-t_Error  FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First)
+t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
     uint8_t     numOfBlocks, blocksFound=0, first=0;
     uint8_t     i, j;
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     if(!numOfClsPlanEntries)
     {
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         return E_OK;
     }
 
     if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
     {
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
     }
 
@@ -1079,46 +1195,48 @@ t_Error  FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntri
             p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
             p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = partitionId;
         }
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
 
         return E_OK;
     }
     else
     {
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
     }
 }
 
-t_Error  FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base)
+t_Error  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
     uint8_t     numOfBlocks;
-    uint8_t     i;
+    uint8_t     i, baseBlock;
 
     UNUSED( partitionId);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
 
-    for(i=base;i<base+numOfBlocks;i++)
+    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
+    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
         ASSERT_COND(partitionId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
         p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
     }
-    RELEASE_LOCK(p_FmPcd->lock);
+    FmPcdUnlock(p_FmPcd, intFlags);
     return E_OK;
 }
-#endif /* FM_MASTER_PARTITION */
 
-#ifndef CONFIG_GUEST_PARTITION /* master or single */
 t_Error KgEnable(t_FmPcd *p_FmPcd)
 {
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
 
     return E_OK;
@@ -1128,21 +1246,12 @@ t_Error KgDisable(t_FmPcd *p_FmPcd)
 {
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
 
     return E_OK;
 }
 
-static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
-{
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
-    /* Wait for GO to be idle and read error */
-    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
-    if (kgar & FM_PCD_KG_KGAR_ERR)
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
-    return E_OK;
-}
-
 void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1153,6 +1262,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
     for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
@@ -1163,7 +1273,6 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
             WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
 
         WriteKgarWait(p_FmPcd, tmpKgarReg);
-
     }
 }
 
@@ -1172,6 +1281,7 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t                event, schemeIndexes = 0,index = 0, mask = 0;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
     mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
 
@@ -1206,176 +1316,154 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
     }
 }
 
-static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
-{
-    if (p_FmPcd->h_Hc)
-        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
-    else
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-#else
-    {
-        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-        uint32_t                tmpKgarReg = 0, tmpKgpeSp;
-        t_Error                 err = E_OK;
-
-        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-
-        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-
-        tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
-
-        if(add)
-            tmpKgpeSp |= spReg;
-        else
-            tmpKgpeSp &= ~spReg;
-
-        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
-
-        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-}
-
-static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
-{
-    if (p_FmPcd->h_Hc)
-        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
-    else
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-#else
-    {
-        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-        uint32_t                tmpKgarReg;
-
-        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
-
-        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-        return WriteKgarWait(p_FmPcd, tmpKgarReg);
-    }
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-}
-
 /****************************************/
-/*  Internal and Inter-Module routines  */
+/*  API routines                        */
 /****************************************/
-t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                spReg;
-    t_Error                 err = E_OK;
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
 
-    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+    if(payloadOffset >  256)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
+
+    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
 
     return E_OK;
 }
 
-t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                spReg;
-    t_Error                 err = E_OK;
-
-    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
 
+    if(valueId == 0)
+        WRITE_UINT32(p_Regs->kggdv0r,value);
+    else
+        WRITE_UINT32(p_Regs->kggdv1r,value);
     return E_OK;
 }
 
-t_Error FmPcdKgBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpKgpeCpp = 0;
-
-    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
-    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
-}
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0, j = 0;
+    uint8_t             hardwarePortId = 0;
+    uint32_t            tmpKgarReg;
+    t_Error             err = E_OK;
 
-void FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    DECLARE_DUMP;
 
-    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-}
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_KG_DUMP_REGS, NULL, NULL, NULL);
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
+
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
+        DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+
+        DUMP_SUBTITLE(("\n"));
+        for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+        {
+            tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+            DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+
+            DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+            {
+                DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+            }
 
-#if 0
-bool KgSchemeIsValid(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t    tmpReg;
-    uint32_t    tmpKgarReg;
-    t_Error     err = E_OK;
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+        }
+        DUMP_SUBTITLE(("\n"));
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, FALSE);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, FALSE);
-    SANITY_CHECK_RETURN_VALUE(schemeId<p_FmPcd->p_FmPcdKg->numOfSchemes, E_INVALID_STATE, 0);
+        for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+        {
+            SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
-    /* read specified scheme into scheme registers */
-    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(p_FmPcd->p_FmPcdKg->schemesIds[schemeId]);
-    WriteKgarWait(p_FmPcd, tmpKgarReg);
+            tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
-    tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
-    if (tmpReg & KG_SCH_MODE_EN)
-        return TRUE;
-    else
-        return FALSE;
-}
-#endif /* 0 */
+            err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+            if(err)
+                RETURN_ERROR(MINOR, err, NO_MSG);
 
-bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+            DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
 
-    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
-}
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
+            DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+        }
 
-bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+        DUMP_SUBTITLE(("\n"));
+        for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+        {
+            DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+            DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
-        return TRUE;
-    else
-        return FALSE;
+            tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+            err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+            if(err)
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            DUMP_SUBSTRUCT_ARRAY(i, 8)
+                DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+        }
+    }
+    return E_OK;
 }
+#endif /* (defined(DEBUG_ERRORS) && ... */
 
 t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdKg   *p_FmPcdKg;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    uint8_t     i=0;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     UNUSED(p_FmPcd);
     p_FmPcdKg = (t_FmPcdKg *) XX_Malloc(sizeof(t_FmPcdKg));
@@ -1386,24 +1474,24 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
 
-#ifndef CONFIG_GUEST_PARTITION
-    p_FmPcdKg->p_FmPcdKgRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdKgRegs, (FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm)));
-
-    p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
-#endif /* !CONFIG_GUEST_PARTITION */
+    if(FmIsMaster(p_FmPcd->h_Fm))
+    {
+        p_FmPcdKg->p_FmPcdKgRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdKgRegs, (FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm)));
+        p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+    }
 
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
     p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
-    p_FmPcdKg->numOfClsPlanEntries = p_FmPcdParams->numOfClsPlanEntries;
 #else
-    p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
-    for(i = 0;i<FM_PCD_KG_NUM_OF_SCHEMES;i++)
-        p_FmPcdKg->schemesIds[i] = i;
-    p_FmPcdKg->numOfClsPlanEntries = (uint16_t)FM_PCD_MAX_NUM_OF_CLS_PLANS;
-    p_FmPcdKg->clsPlanBase = 0;
+    {
+        uint8_t     i=0;
+        p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+        for(i = 0;i<FM_PCD_KG_NUM_OF_SCHEMES;i++)
+            p_FmPcdKg->schemesIds[i] = i;
+    }
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
-    p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
+    p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     return p_FmPcdKg;
 }
@@ -1412,78 +1500,66 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
 {
     t_Error                     err = E_OK;
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-#ifndef CONFIG_GUEST_PARTITION
     int                         i;
-    t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
-    uint8_t                     hardwarePortId;
+    uint8_t                     hardwarePortId = 0;
     uint32_t                    tmpReg;
-#else
-    t_FmPcdIpcKgAllocParams     kgAlloc;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcKgSchemesParams    kgAlloc;
 #endif /* CONFIG_GUEST_PARTITION */
-
-#ifndef CONFIG_GUEST_PARTITION
-    /**********************KGEER******************/
-    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
-    /**********************KGEER******************/
-    /**********************KGEEER******************/
-    tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
-        FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
-    }
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
-    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
-    /**********************KGEEER******************/
-
-    /**********************KGFDOR******************/
-    WRITE_UINT32(p_Regs->kgfdor,0);
-    /**********************KGFDOR******************/
+        /**********************KGEER******************/
+        WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+        /**********************KGEER******************/
+        /**********************KGEEER******************/
+        tmpReg = 0;
+        if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+        {
+            FmEnableRamsEcc(p_FmPcd->h_Fm);
+            tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+        }
+        if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+            tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+        WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+        /**********************KGEEER******************/
 
-    /**********************KGGDV0R******************/
-    WRITE_UINT32(p_Regs->kggdv0r,0);
-    /**********************KGGDV0R******************/
+        /**********************KGFDOR******************/
+        WRITE_UINT32(p_Regs->kgfdor,0);
+        /**********************KGFDOR******************/
 
-    /**********************KGGDV1R******************/
-    WRITE_UINT32(p_Regs->kggdv1r,0);
-    /**********************KGGDV1R******************/
+        /**********************KGGDV0R******************/
+        WRITE_UINT32(p_Regs->kggdv0r,0);
+        /**********************KGGDV0R******************/
 
-    /**********************KGGCR******************/
-    WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
-    /**********************KGGCR******************/
+        /**********************KGGDV1R******************/
+        WRITE_UINT32(p_Regs->kggdv1r,0);
+        /**********************KGGDV1R******************/
 
-    /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+        /**********************KGGCR******************/
+        WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+        /**********************KGGCR******************/
 
-    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;i++)
-        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
+        /* register even if no interrupts enabled, to allow future enablement */
+        FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
 
-    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
-    {
+        /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+        for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+        {
+            SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
-        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i);
+            err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+            if(err)
+                RETURN_ERROR(MINOR, err, NO_MSG);
 
-        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+            if(err)
+                RETURN_ERROR(MINOR, err, NO_MSG);
+        }
 
-        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        /* enable and enable all scheme interrupts                */
+        WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+        WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
     }
-
-    /* enable and enable all scheme interrupts                */
-    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
-    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
-#endif /* !CONFIG_GUEST_PARTITION */
-
-    if(!p_FmPcd->p_FmPcdKg->numOfClsPlanEntries)
-        /* allocate at least the minimum grp for not using clsPlan */
-        p_FmPcd->p_FmPcdKg->numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
-
     /* In Multi partition, both guest and master should allocate schemes and
        clsPlan entries for future use */
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
@@ -1491,12 +1567,10 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
     kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
     kgAlloc.partitionId = p_FmPcd->partitionId;
-    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_KG_SCHEMES, (uint8_t*)&kgAlloc, NULL, NULL);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
     memcpy(p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.schemesIds, kgAlloc.numOfSchemes);
-    p_FmPcd->p_FmPcdKg->clsPlanBase = kgAlloc.clsPlanBase;
 #else /* master */
     if(p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
@@ -1507,63 +1581,16 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    err = FmPcdKgAllocClsPlanEntries(p_FmPcd,
-                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
-                                p_FmPcd->partitionId,
-                                &p_FmPcd->p_FmPcdKg->clsPlanBase);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
-
 #endif /* CONFIG_GUEST_PARTITION */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
     return E_OK;
 }
 
-#if 0
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
-    {
-        /* For guest XX_SendMessage will initialize the first 8 entries
-           for the driver's empty classification plan. For master it will be set below.
-           We now need to internally (sw) allocate this
-           block (8 entries) in the partition p_FmPcd clsPlan structure.
-           We assume that since this is the first internal allocation, the first 8 entries will be allocated */
-        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
-        clsPlanGrp.numOfOptions = 0;
-        err = FmPcdKgBuildClsPlanGrp(p_FmPcd, &clsPlanGrp, &clsPlanSet);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        ASSERT_COND(clsPlanGrp.clsPlanGrpId==0);
-        ASSERT_COND(clsPlanSet.baseEntry == p_FmPcd->p_FmPcdKg->clsPlanBase);
-
-#ifdef CONFIG_GUEST_PARTITION
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP, (uint8_t*)&p_FmPcd->p_FmPcdKg->clsPlanBase, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
-
-#else /* CONFIG_GUEST_PARTITION --> Master */
-        memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
-        clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanBase;
-        clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
-        KgSetClsPlan(p_FmPcd, &clsPlanSet);
-    }
-#endif /* CONFIG_GUEST_PARTITION */
-
-    /* in master or single partition, we now allocate a private driver group if required */
-#else /* ! CONFIG_MULTI_PARTITION_SUPPORT  --> Single */
-        /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
-        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
-        clsPlanGrp.numOfOptions = 0;
-        if(FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp) !=E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Driver internal clsPlan group id should be '0'"));
-#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
-#endif /* 0 */
-
 t_Error KgFree(t_FmPcd *p_FmPcd)
 {
 #ifdef CONFIG_GUEST_PARTITION
-    t_FmPcdIpcKgAllocParams             kgAlloc;
+    t_FmPcdIpcKgSchemesParams             kgAlloc;
 #endif /* CONFIG_GUEST_PARTITION */
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
     t_Error                             err = E_OK;
@@ -1571,19 +1598,12 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
 
-#ifndef CONFIG_GUEST_PARTITION
-        if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
-            FmPcdKgDestroyClsPlanGrp(p_FmPcd, p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId);
-#endif
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
 #ifdef CONFIG_GUEST_PARTITION
     kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
     kgAlloc.partitionId = p_FmPcd->partitionId;
-    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
-    kgAlloc.isDriverClsPlanGrp = p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
-    kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanBase;
     memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.numOfSchemes);
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_SCHEMES, (uint8_t*)&kgAlloc, NULL, NULL);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 #else /* master */
@@ -1593,49 +1613,97 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
                                 p_FmPcd->p_FmPcdKg->schemesIds);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
-    err = FmPcdKgFreeClsPlanEntries(p_FmPcd,
-                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
-                                p_FmPcd->partitionId,
-                                p_FmPcd->p_FmPcdKg->clsPlanBase);
 #endif /* CONFIG_GUEST_PARTITION */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     return E_OK;
 }
 
-t_Error FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray)
+t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+    t_FmPcd                                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgInterModuleClsPlanGrpParams    grpParams, *p_GrpParams;
+    t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
+    t_FmPcdKgInterModuleClsPlanSet          clsPlanSet;
+    t_Error                                 err;
+
+    memset(&grpParams, 0, sizeof(grpParams));
+    p_GrpParams = &grpParams;
+
+    p_GrpParams->netEnvId = netEnvId;
+    err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
+    if(err)
+        RETURN_ERROR(MINOR,err,NO_MSG);
+    if(p_GrpParams->grpExists)
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+    else
+    {
+        err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, &clsPlanSet);
+        if(err)
+            RETURN_ERROR(MINOR,err,NO_MSG);
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+
+        if (p_FmPcd->h_Hc)
+        {
+            /* write clsPlan entries to memory */
+            err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, &clsPlanSet);
+            if (err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        else
+            /* write clsPlan entries to memory */
+            KgSetClsPlan(p_FmPcd, &clsPlanSet);
+    }
+
+    /* mark if this is an empty classification group */
+    if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        *p_IsEmptyClsPlanGrp = TRUE;
+    else
+        *p_IsEmptyClsPlanGrp = FALSE;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
 
-    /* check that this clsPlan group is valid */
-    if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].used)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid clsPlan group."));
-
-    if(p_ClsPlanGrp->netEnvId != DRIVER_PRIVATE_NET_ENV_ID)
-    /* When netEnvId == DRIVER_PRIVATE_NET_ENV_ID this is a special internal driver group.
-    it is used by ports that do not use the classification plan mechanism, and it is of
-    the minimum size - 8 entries = 1 block. In this case no check is done,
-    any port from any netEnv may be bound to this group. */
-        if(p_ClsPlanGrp->netEnvId != netEnvId)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested clsPlan - difer in netEnvId"));
     /* increment owners number */
     p_ClsPlanGrp->owners++;
 
     /* copy options array for port */
-    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS*sizeof(protocolOpt_t));
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
+
+    /* bind port to the new or existing group */
+    err = KgBindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
 
-void FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-
     t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
 
-     /* decrement owners number */
+    FmPcdKgUnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
+
+    /* decrement owners number */
     ASSERT_COND(p_ClsPlanGrp->owners);
     p_ClsPlanGrp->owners--;
+
+    if(!p_ClsPlanGrp->owners)
+    {
+        if (p_FmPcd->h_Hc)
+            return FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
+        else
+        {
+            /* clear clsPlan entries in memory */
+            clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
+            clsPlanSet.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
+            memset(clsPlanSet.vectors, 0, p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp*sizeof(uint32_t));
+            KgSetClsPlan(p_FmPcd, &clsPlanSet);
+
+            FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
+        }
+	}
+    return E_OK;
 }
 
 t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
@@ -1653,7 +1721,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     uint8_t                             j, curr;
     uint8_t                             id, shift=0, code=0, offset=0, size=0;
     t_FmPcdExtractEntry                 *p_Extract = NULL;
-    t_FmPcdKgExtractedOrForFqid         *p_ExtractOr;
+    t_FmPcdKgExtractedOrParams          *p_ExtractOr;
     bool                                generic = FALSE;
     t_KnownFieldsMasks                  bitMask;
     e_FmPcdKgExtractDfltSelect          swDefault = (e_FmPcdKgExtractDfltSelect)0;
@@ -1661,6 +1729,9 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     uint8_t                             numOfSwDefaults = 0;
     t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
     uint8_t                             currGenId = 0, relativeSchemeId;
+    t_FmRevisionInfo                    revInfo;
+
+    FmGetRevision(p_FmPcd->h_Fm, &revInfo);
 
     if(!p_Scheme->modify)
         relativeSchemeId = p_Scheme->id.relativeSchemeId;
@@ -1687,12 +1758,27 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     else
     {
         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = SCHEME_ALWAYS_DIRECT;
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = ILLEGAL_NETENV;
     }
 
+    if(p_Scheme->nextEngine == e_FM_PCD_INVALID)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
+
+    if(p_Scheme->bypassFqidGeneration)
+    {
+        if (revInfo.majorRev < 4)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
+        if(p_Scheme->baseFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
+    }
+    else
+        if(!p_Scheme->baseFqid)
+            DBG(WARNING, ("baseFqid is 0."));
+
     if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
     {
         direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr = direct;
         absolute = (bool)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
         if(!direct && absolute)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
@@ -1712,7 +1798,13 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
 
     if(p_Scheme->nextEngine == e_FM_PCD_CC)
     {
-        err = CcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
+        if((p_Scheme->kgNextEngineParams.cc.plcrNext) && (p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        {
+            if (revInfo.majorRev < 4)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
+        }
+
+        err = FmPcdCcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
                              p_Scheme->kgNextEngineParams.cc.grpId,
                              &grpBits,
                              &grpBase);
@@ -1720,29 +1812,31 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
             RETURN_ERROR(MAJOR, err, NO_MSG);
         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].ccUnits = grpBits;
 
-        if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+        if((p_Scheme->kgNextEngineParams.cc.plcrNext) && (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
-            if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
-            absolute = FALSE;
-            direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
-            if(direct)
-            {
-                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
-                numOfProfiles = 1;
-            }
-            else
-            {
-                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-                shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
-                numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
-            }
+                if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
+                absolute = FALSE;
+                direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
+                if(direct)
+                {
+                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                    numOfProfiles = 1;
+                }
+                else
+                {
+                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                    shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                    numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+                }
         }
     }
 
     /* if policer is used directly after KG, or after CC */
     if((p_Scheme->nextEngine == e_FM_PCD_PLCR)  ||
-       ((p_Scheme->nextEngine == e_FM_PCD_CC) && (p_Scheme->kgNextEngineParams.cc.plcrNext)))
+       ((p_Scheme->nextEngine == e_FM_PCD_CC) &&
+                   (p_Scheme->kgNextEngineParams.cc.plcrNext) &&
+                   (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
     {
         /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
         if(absolute)
@@ -1754,6 +1848,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
             if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
         }
         else
         {
@@ -1763,6 +1858,19 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
             p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].numOfProfiles = numOfProfiles;
         }
     }
+    else
+    {
+        /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
+        is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
+        if(p_Scheme->bypassFqidGeneration && p_Scheme->numOfUsedExtractedOrs)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
+        if(p_Scheme->bypassFqidGeneration &&
+                p_Scheme->useHash &&
+                p_Scheme->keyExtractAndHashParams.hashDistributionNumOfFqids)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"));
+    }
 
     /* configure all 21 scheme registers */
     tmpReg =  KG_SCH_MODE_EN;
@@ -1803,33 +1911,40 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
 
             if(p_Scheme->kgNextEngineParams.cc.plcrNext)
             {
-                /* find out if absolute or relative */
-                if(absolute)
-                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
-                if(direct)
+                if(!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
                 {
-                    /* mask = 0, base = directProfileId */
-                    p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
-                }
-                else
-                {
-                    if(shift > MAX_PP_SHIFT)
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
-                    if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+                    /* find out if absolute or relative */
+                    if(absolute)
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
+                    if(direct)
+                    {
+                        /* mask = 0, base = directProfileId */
+                        p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+                    }
+                    else
+                    {
+                        if(shift > MAX_PP_SHIFT)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+                        if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
-                    ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
-                    ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
-                    ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
-                    ppcTmp |= (uint32_t)profileId;
+                        ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                        ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                        ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                        ppcTmp |= (uint32_t)profileId;
 
-                    p_SchemeRegs->kgse_ppc = ppcTmp;
+                        p_SchemeRegs->kgse_ppc = ppcTmp;
+                    }
                 }
+                else
+                    ppcTmp = KG_SCH_PP_NO_GEN;
             }
-
             break;
         case(e_FM_PCD_DONE):
-            tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+            if(p_Scheme->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+            else
+                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
             break;
         default:
              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
@@ -1848,6 +1963,13 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         /*  configure kgse_dv1  */
         p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
 
+        if(!p_Scheme->bypassFqidGeneration)
+        {
+            if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
+            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_Scheme->baseFqid)
+                DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
+        }
 
         /*  configure kgse_ekdv  */
         tmpReg = 0;
@@ -1932,30 +2054,30 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                     p_LocalExtractsArray->extractsArray[i].known = TRUE;
                     break;
                 case(e_FM_PCD_EXTRACT_BY_HDR):
-                    switch(p_Extract->extractParams.extractByHdr.type)
+                    switch(p_Extract->extractByHdr.type)
                     {
                         case(e_FM_PCD_EXTRACT_FROM_HDR):
                             generic = TRUE;
                             /* get the header code for the generic extract */
-                            code = GetGenHdrCode(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation);
+                        code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
                             /* set generic register fields */
-                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.size;
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
                             break;
                         case(e_FM_PCD_EXTRACT_FROM_FIELD):
                             generic = TRUE;
                             /* get the field code for the generic extract */
-                            code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
-                                        p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.field, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation,p_Extract->extractParams.extractByHdr.hdrIndex);
-                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.offset;
-                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.size;
+                            code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
+                                        p_Extract->extractByHdr.extractByHdrType.fromField.field, p_Extract->extractByHdr.ignoreProtocolValidation,p_Extract->extractByHdr.hdrIndex);
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                             break;
                         case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                            if(!p_Extract->extractParams.extractByHdr.ignoreProtocolValidation)
+                            if(!p_Extract->extractByHdr.ignoreProtocolValidation)
                             {
                                 /* if we have a known field for it - use it, otherwise use generic */
-                                bitMask = GetKnownProtMask(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex,
-                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                                bitMask = GetKnownProtMask(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
+                                            p_Extract->extractByHdr.extractByHdrType.fullField);
                                 if(bitMask)
                                 {
                                     knownTmp |= bitMask;
@@ -1973,11 +2095,13 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                             {
                                 /* tmp - till we cover more headers under generic */
                                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
+#ifdef UNDER_CONSTRUCTION_FM
                                 /* get the field code for the generic extract */
-                                code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
-                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation, p_Extract->extractParams.extractByHdr.hdrIndex);
+                                code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
+                                            p_Extract->extractByHdr.extractByHdrType.fullField, p_Extract->extractByHdr.ignoreProtocolValidation, p_Extract->extractByHdr.hdrIndex);
                                 offset = 0; //GetFieldOffset
-                                size = GetFieldSize(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                                size = GetFieldSize(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.extractByHdrType.fullField);
+#endif /* UNDER_CONSTRUCTION_FM */
                             }
                             break;
                         default:
@@ -1987,10 +2111,11 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 case(e_FM_PCD_EXTRACT_NON_HDR):
                     /* use generic */
                     generic = TRUE;
+                    offset = 0;
                     /* get the field code for the generic extract */
-                    code = GetGenCode(p_Extract->extractParams.extractNonHdr.src);
-                    offset = p_Extract->extractParams.extractNonHdr.offset;
-                    size = p_Extract->extractParams.extractNonHdr.size;
+                    code = GetGenCode(p_Extract->extractNonHdr.src, &offset);
+                    offset += p_Extract->extractNonHdr.offset;
+                    size = p_Extract->extractNonHdr.size;
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
@@ -2061,16 +2186,25 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         /* kgse_fqb will be written t the end of the routine */
 
         /*  configure kgse_hc  */
-        if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
         if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
         if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
 
         tmpReg = 0;
+
         tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
         tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+
+        if(p_KeyAndHash->symmetricHash)
+        {
+            if((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
+            tmpReg |= KG_SCH_HASH_CONFIG_SYM;
+        }
         p_SchemeRegs->kgse_hc = tmpReg;
 
         /* build the return array describing the order of the extractions */
@@ -2126,37 +2260,42 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         p_SchemeRegs->kgse_dv1 = 0;
     }
 
+    if(p_Scheme->bypassFqidGeneration)
+        p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
+
     /*  configure kgse_spc  */
     if( p_Scheme->schemeCounter.update)
         p_SchemeRegs->kgse_spc = p_Scheme->schemeCounter.value;
 
 
     /* check that are enough generic registers */
-    if(p_Scheme->numOfUsedFqidMasks + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+    if(p_Scheme->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
-    for( i=0 ;i<p_Scheme->numOfUsedFqidMasks ; i++)
+    for( i=0 ;i<p_Scheme->numOfUsedExtractedOrs ; i++)
     {
 
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs = TRUE;
         /*  configure kgse_gec[i]  */
-        p_ExtractOr = &p_Scheme->fqidMasks[i];
+        p_ExtractOr = &p_Scheme->extractedOrs[i];
         switch(p_ExtractOr->type)
         {
             case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
-                code = KG_SCH_GEN_PARSE_RESULT;
+                code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
                 offset = 0;
                 break;
             case(e_FM_PCD_EXTRACT_BY_HDR):
                 /* get the header code for the generic extract */
-                code = GetGenHdrCode(p_ExtractOr->extractParams.extractByHdr.hdr, p_ExtractOr->extractParams.extractByHdr.hdrIndex, p_ExtractOr->extractParams.extractByHdr.ignoreProtocolValidation);
+                code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
                 /* set generic register fields */
                 offset = p_ExtractOr->extractionOffset;
                 break;
             case(e_FM_PCD_EXTRACT_NON_HDR):
                 /* get the field code for the generic extract */
-                code = GetGenCode(p_ExtractOr->extractParams.src);
-                offset = p_ExtractOr->extractionOffset;
+                offset = 0;
+                code = GetGenCode(p_ExtractOr->src, &offset);
+                offset += p_ExtractOr->extractionOffset;
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
@@ -2168,14 +2307,72 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
         genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
         genTmp |= offset;
-        if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_BIT_OFFSET )
-              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (bitOffsetInFqid out of range)"));
-        genTmp |= (uint32_t)(p_ExtractOr->bitOffsetInFqid << KG_SCH_GEN_SIZE_SHIFT);
+        if(!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
+
+        /************************************************************************************
+            bitOffsetInFqid and bitOffsetInPolicerProfile are translated to rotate parameter
+            in the following way:
+
+            Driver API and implementation:
+            ==============================
+            FQID: extracted OR byte may be shifted right 1-31 bits to effect parts of the FQID.
+            if shifted less than 8 bits, or more than 24 bits a mask is set on the bits that
+            are not overlapping FQID.
+                     ------------------------
+                    |      FQID (24)         |
+                     ------------------------
+            --------
+           |        |  extracted OR byte
+            --------
+
+            Policer Profile: extracted OR byte may be shifted right 1-15 bits to effect parts of the
+            PP id. Unless shifted exactly 8 bits to overlap the PP id, a mask is set on the bits that
+            are not overlapping PP id.
+
+                     --------
+                    | PP (8) |
+                     --------
+            --------
+           |        |  extracted OR byte
+            --------
+
+            HW implementation
+            =================
+            FQID and PP construct a 32 bit word in the way describe below. Extracted byte is located
+            as the highest byte of that word and may be rotated to effect any part os the FQID or
+            the PP.
+             ------------------------  --------
+            |      FQID (24)         || PP (8) |
+             ------------------------  --------
+             --------
+            |        |  extracted OR byte
+             --------
+
+        ************************************************************************************/
+
+        if(p_ExtractOr->bitOffsetInFqid)
+        {
+            if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
+            if(p_ExtractOr->bitOffsetInFqid<8)
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
+            else
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInFqid, TRUE);
+        }
+        else /* effect policer profile */
+        {
+            if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
+            genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInPlcrProfile, FALSE);
+        }
+
         genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
-        /* pass all bits */
-        genTmp |= KG_SCH_GEN_MASK;
         /* clear bits that need masking */
-        genTmp &= ~(0xFF << KG_SCH_GEN_MASK_SHIFT) ;
+        genTmp &= ~KG_SCH_GEN_MASK ;
         /* set mask bits */
         genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
         p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
@@ -2193,6 +2390,8 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     fqbTmp |= p_Scheme->baseFqid;
     p_SchemeRegs->kgse_fqb = fqbTmp;
 
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine = p_Scheme->nextEngine;
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction = p_Scheme->kgNextEngineParams.doneAction;
     return E_OK;
 }
 
@@ -2202,7 +2401,8 @@ void  FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
 
     ASSERT_COND(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
 
-    FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
+        FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
     p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = TRUE;
 }
 
@@ -2211,7 +2411,8 @@ void  FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
 
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
+        FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
     p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = FALSE;
 }
 
@@ -2352,20 +2553,6 @@ uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
-bool FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    return p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
-}
-
-uint8_t FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    return p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
-}
-
 uint8_t FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd)
 {
     return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->numOfSchemes;
@@ -2391,209 +2578,102 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
-t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
-
-    return E_OK;
-}
-
-void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
-{
-    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
-}
-
-/****************************************/
-/*  API routines                        */
-/****************************************/
-t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
-{
-   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-
-    if(payloadOffset >  256)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
-
-    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
-
-    return E_OK;
-}
-
-t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
-{
-   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-
-    if(valueId == 0)
-        WRITE_UINT32(p_Regs->kggdv0r,value);
-    else
-        WRITE_UINT32(p_Regs->kggdv1r,value);
-    return E_OK;
-}
-
-t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanGrpParams   clsPlanGrp;
-    t_Handle                    h_ClsPlanFrp;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-
-    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = TRUE;
-
-    /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
-    clsPlanGrp.h_NetEnv = CAST_UINT32_TO_POINTER((uint32_t)DRIVER_PRIVATE_NET_ENV_ID+1);
-    clsPlanGrp.numOfOptions = 0;
-    h_ClsPlanFrp = FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp);
-    if(!h_ClsPlanFrp)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
-    p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanFrp)-1);
-
-    return E_OK;
-}
-
-t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd)
-{
-   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_Error  err = E_OK;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-
-    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
-
-    err = FM_PCD_KgDeleteClsPlanGrp(p_FmPcd, CAST_UINT32_TO_POINTER((uint32_t)(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId+1)));
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    return E_OK;
-}
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
+#ifdef FM_MANIP_SUPPORT
+t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i = 0, j = 0;
-    uint8_t             hardwarePortId;
+    uint8_t             relativeSchemeId, physicalSchemeId;
     uint32_t            tmpKgarReg;
-    t_Error             err = E_OK;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
-
-    DUMP_SUBTITLE(("\n"));
-    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
-    {
-        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        WriteKgarWait(p_FmPcd, tmpKgarReg);
+    t_Error             err;
+    
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+    /* TODO - complete for HC!!! */
+    if (p_FmPcd->h_Hc)
+        DBG(WARNING, ("HC NOT_SUPPORTED applying in sw!"));
 
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
-        }
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+    if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners && 
+       !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This policer profile was assigned before with different action"));
+    else if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners &&
+           p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction)
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners += 1;
+        return E_OK;
     }
-    DUMP_SUBTITLE(("\n"));
-
-    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
     {
-
-        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i);
-
-        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
-
+        if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_DONE && 
+           p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME )
+        {
+            tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+            if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+               RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, (GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) | NIA_BMI_AC_WITHOUT_DMA));
+            /* call indirect command for scheme write */
+            tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+        }
+        else if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_PLCR)
+        {
+            if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr || 
+               (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs &&
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
+                    
+            err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    
     }
+    
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners += 1;
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction = requiredAction;
 
-    DUMP_SUBTITLE(("\n"));
-    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
-    {
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+ return E_OK; 
+}
+#endif /* FM_MANIP_SUPPORT */
 
-        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        DUMP_SUBSTRUCT_ARRAY(i, 8)
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
-    }
-    return E_OK;
+t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    bool        ans;
+    if (intr)
+        ans = TRY_LOCK(NULL, p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
+    else
+        ans = TRY_LOCK(p_FmPcd->h_Spinlock, p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
+    if (ans)
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
 }
-#endif /* (defined(DEBUG_ERRORS) && ... */
-#endif /* !CONFIG_GUEST_PARTITION */
 
+void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+}
 
 t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint32_t                            tmpReg;
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
     uint8_t                             i;
     t_Error                             err = E_OK;
     uint32_t                            tmpKgarReg;
+    uint32_t                            intFlags;
     uint8_t                             physicalSchemeId, relativeSchemeId;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
@@ -2601,15 +2681,6 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgSetScheme(p_FmPcd->h_Hc, p_Scheme);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-        return NULL;
-    }
-#else /* CONFIG_MULTI_PARTITION_SUPPORT */
-
-    TRY_LOCK_RET_NULL(p_FmPcd->lock);
 
     /* if not called for modification, check first that this scheme is unused */
     if(!p_Scheme->modify)
@@ -2618,13 +2689,12 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
         if(p_Scheme->id.relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
         {
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
-            RELEASE_LOCK(p_FmPcd->lock);
             return NULL;
         }
         relativeSchemeId = p_Scheme->id.relativeSchemeId;
 
-        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
-        RELEASE_LOCK(p_FmPcd->lock);
+        if (FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE))
+            return NULL;
 
         physicalSchemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
 
@@ -2634,7 +2704,8 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
         tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
         if (tmpReg & KG_SCH_MODE_EN)
         {
-            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
+                         ("Scheme %d(phys %d) is already used", relativeSchemeId, physicalSchemeId));
             RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
             return NULL;
         }
@@ -2642,18 +2713,22 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
     }
     else
     {
+        intFlags = FmPcdLock(p_FmPcd);
         physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
 
-        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
-        RELEASE_LOCK(p_FmPcd->lock);
-
-        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        /* check that schameId is in range */
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            FmPcdUnlock(p_FmPcd, intFlags);
             return NULL;
         }
+
+        err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, TRUE);
+        FmPcdUnlock(p_FmPcd, intFlags);
+        if (err)
+            return NULL;
     }
 
     err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs);
@@ -2693,18 +2768,15 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
     RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
 
     return CAST_UINT32_TO_POINTER((uint32_t)physicalSchemeId+1);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t             physicalSchemeId;
     uint32_t            tmpKgarReg;
     t_Error             err = E_OK;
     uint8_t             relativeSchemeId;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
@@ -2712,11 +2784,6 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
 
     physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
@@ -2724,7 +2791,8 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
     if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+    if ((err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+       RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* check that no port is bound to this scheme */
     err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
@@ -2744,75 +2812,13 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
     RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
 
     return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-}
-
-t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp)
-{
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
-    t_Handle                        h_ClsPlanGrp;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdKgSetClsPlanGrp(p_FmPcd->h_Hc, p_Grp);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-        return NULL;
-    }
-#else
-    h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmPcd, p_Grp, &clsPlanSet);
-    if(!h_ClsPlanGrp)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
-        return NULL;
-    }
-
-    /* write clsPlan entries to memory */
-    KgSetClsPlan(p_FmPcd, &clsPlanSet);
-
-
-    return h_ClsPlanGrp;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-}
-
-t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp)
-{
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    uint8_t                         grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
-    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdKgDeleteClsPlanGrp(p_FmPcd->h_Hc, h_ClsPlanGrp);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
-    /* clear clsPlan entries in memory */
-    clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
-    clsPlanSet.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
-    memset(clsPlanSet.vectors, 0, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp*sizeof(uint32_t));
-    KgSetClsPlan(p_FmPcd, &clsPlanSet );
-
-    FmPcdKgDestroyClsPlanGrp(h_FmPcd, grpId);
-
-    return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint32_t            tmpKgarReg;
     uint8_t             physicalSchemeId;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
@@ -2820,11 +2826,7 @@ uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgGetSchemeCounter(p_FmPcd->h_Hc, h_Scheme);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
 
-#else
     physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
 
     if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
@@ -2836,16 +2838,13 @@ uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
 
     return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint32_t            tmpKgarReg;
     uint8_t             physicalSchemeId;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
@@ -2853,11 +2852,7 @@ t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgSetSchemeCounter(p_FmPcd->h_Hc, h_Scheme, value);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
 
-#else
     physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
     /* check that schameId is in range */
     if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
@@ -2878,5 +2873,5 @@ t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t
     WriteKgarWait(p_FmPcd, tmpKgarReg);
 
     return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
new file mode 100644
index 0000000..65ab2c7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -0,0 +1,1478 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.c
+
+ @Description   FM PCD manip ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "memcpy_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_manip.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#undef WRITE_UINT16
+#undef GET_UINT16
+#undef WRITE_UINT8
+#undef GET_UINT8
+
+#define WRITE_UINT16(addr, val)  \
+    do{                             \
+            if((int)&(addr) % 4)    \
+                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
+                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
+            else                    \
+                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
+                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
+      }while(0);
+#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
+       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
+       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
+
+
+static void WRITE_UINT8_ERRATA(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+         newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+#define WRITE_UINT8(addr,val) WRITE_UINT8_ERRATA(&addr,val)
+#define GET_UINT8(addr) GET_UINT8_ERRATA(&addr)
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+static t_Error GetPrOffsetByNonHeader(uint8_t *parseArrayOffset)
+{
+    /*For now - the only field in the Parse Array from the NON_BY_TYPE can be e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE*/
+    /*Maybe extended in the future*/
+
+    *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+
+    return E_OK;
+}
+
+void FmManipUpdateOwner(t_Handle h_Manip, bool add)
+{
+
+    if(add)
+        ((t_FmPcdManip *)h_Manip)->owner++;
+    else
+    {
+        ASSERT_COND(((t_FmPcdManip *)h_Manip)->owner);
+        ((t_FmPcdManip *)h_Manip)->owner--;
+    }
+}
+
+static uint8_t GetOwnerOfManipNode(t_Handle h_Manip)
+{
+    return ((t_FmPcdManip *)h_Manip)->owner;
+}
+
+
+static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Handle      p_Ad;
+    uint32_t      tmpReg32 = 0;
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+            {
+                tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
+                tmpReg32 |=  (uint32_t)(icOffset << 16);
+                *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets = tmpReg32;
+                p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET; 
+                p_Manip->icOffset = icOffset;
+            }
+            else
+            {
+                if(p_Manip->icOffset != icOffset)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+            }
+            break;
+    }
+    
+    return E_OK;
+}
+
+static t_Error UpdateMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate, t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback)
+{
+    
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+    uint32_t                tmpReg32;
+    
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+ 
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
+        fmPortGetSetCcParams.setCcParams.psoSize = 16;
+
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+           (p_Manip->updateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+
+    }
+
+   if(p_Manip->updateParams & OFFSET_OF_PR)
+   {
+        tmpReg32 = 0;
+        tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
+        WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
+        p_Manip->updateParams &= ~OFFSET_OF_PR;
+        p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+   }
+   else if (validate)
+   {
+        tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
+        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
+   }
+   
+    return E_OK;
+}
+
+static t_Error UpdateCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate, t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback)
+{
+    
+    t_AdOfTypeContLookup    *p_Ad       ;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+    uint32_t                tmpReg32 = 0;
+    
+    UNUSED(h_Ad);
+    
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+    
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+    }
+    else if (validate)
+    {
+      if((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->updateParams & OFFSET_OF_DATA) || 
+           (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+    }
+ 
+   if(p_Manip->updateParams)
+   {
+
+        tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.poolIdForManip << 8);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
+        WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
+   
+        p_Manip->updateParams &= ~OFFSET_OF_DATA;
+        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+        p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+        p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+   }
+   else if (validate)
+   {
+
+        if((p_Manip->fragParams.poolId != fmPortGetSetCcParams.getCcParams.poolIdForManip) ||
+           (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+   }
+   
+    return E_OK;
+}
+
+static t_Error UpdateCapwapReasm(t_Handle                       h_FmPcd,
+                                 t_Handle                       h_FmPort,
+                                 t_FmPcdManip                   *p_Manip,
+                                 t_Handle                       h_Ad,
+                                 bool                           validate,
+                                 t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback)
+{
+    t_CapwapReasmPram  *p_ReassmTbl;
+    t_Error             err; 
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    uint8_t             i = 0;
+    uint16_t            size;
+    uint32_t            tmpReg32;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    
+    
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    
+    UNUSED(h_Ad);
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+    p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & NUM_OF_TASKS) && !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) && 
+        !(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & OFFSET_OF_PR)) ||
+           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) || 
+           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("buffser pool id  wasn't configured previousely"));
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && (!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) && 
+         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) && (!(p_Manip->shadowUpdateParams & OFFSET_OF_PR))) && 
+           ((p_Manip->updateParams & NUM_OF_TASKS) || 
+           (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR)))
+       
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        err = p_FmPortGetSetCcParamsCallback(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool for header manipulation wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+    }
+    
+    if(p_Manip->updateParams)
+    {
+        
+        if(p_Manip->updateParams & NUM_OF_TASKS)
+        {
+        
+            size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess + fmPortGetSetCcParams.getCcParams.numOfTasks);
+            if(size  > 255)
+                RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
+            
+            p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
+            
+            /*p_ReassmFrmDescrIndxPoolTbl*/
+            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)(size + 1),
+                                              4);
+            if(!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
+           
+            for( i = 0; i < size; i++)
+                WRITE_UINT8(*(uint8_t *)CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) + i),(uint8_t)(i+1));
+                        
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+            
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
+
+            /*p_ReassmFrmDescrPoolTbl*/
+
+            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                                              4);
+            
+           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+       
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
+
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescPoolTblPtr, tmpReg32);
+
+            /*p_TimeOutTbl*/
+
+            p_Manip->fragParams.p_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                                              4);
+
+            if(!p_Manip->fragParams.p_TimeOutTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+           
+            IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+            
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+            WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
+
+       
+            p_Manip->updateParams &= ~NUM_OF_TASKS;
+            p_Manip->shadowUpdateParams |= NUM_OF_TASKS;
+       }
+       
+       if(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)
+       {
+            
+            p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.poolId << 16;
+            WRITE_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes, tmpReg32);
+
+            p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+            p_Manip->shadowUpdateParams |= BUFFER_POOL_ID_FOR_MANIP;
+       }
+        
+        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        {
+            p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= p_Manip->fragParams.dataOffset;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+            p_Manip->updateParams &= ~OFFSET_OF_DATA;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
+        }
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= FM_PCD_MANIP_CAPWAP_REASM_PR_COPY;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+            
+            tmpReg32 = GET_UINT32(p_ReassmTbl->intStatsTblPtr);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.prOffset << 24;
+            WRITE_UINT32(p_ReassmTbl->intStatsTblPtr, tmpReg32);
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+       }
+       else
+       {
+           p_Manip->fragParams.prOffset = 0xff;  
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+
+       }
+    }
+    else if(validate)
+    {
+        if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
+        
+        if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
+    
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        else
+        {
+            if(p_Manip->fragParams.prOffset != 0xff)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
+    }
+    
+    return E_OK;
+}
+
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate,t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error      err;
+    
+    UNUSED(h_FmPcd);
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            err = UpdateMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate,p_FmPortGetSetCcParamsCallback);
+            return err;
+        break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(!p_Manip->h_Frag)
+                break;
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            err = UpdateCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate,p_FmPortGetSetCcParamsCallback);
+            return err;
+        break;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                err = UpdateCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate,p_FmPortGetSetCcParamsCallback);
+                return err;                
+            }
+            break;
+        default:
+            return E_OK;
+
+    }
+    return E_OK;
+
+}
+
+uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    
+    ASSERT_COND(h_Manip);
+    
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            return UPDATE_NIA_ENQ_WITHOUT_DMA;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            return 0;
+        default:
+            return UPDATE_NIA_ENQ_WITH_DMA;
+    }
+
+}
+static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipParams, uint8_t *parseArrayOffset)
+{
+    e_NetHeaderType hdr         = p_ManipParams->manipByHdr.hdr;
+    e_FmPcdHdrIndex hdrIndex    = p_ManipParams->manipByHdr.hdrIndex;
+    bool            byField     = p_ManipParams->manipByHdr.byField;
+    t_FmPcdFields   field;
+
+    if(byField)
+        field = p_ManipParams->manipByHdr.fullField;
+
+    if(byField)
+    {
+        switch(hdr)
+        {
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
+                }
+                break;
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                             *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                        break;
+                    default:
+                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type VLAN with this field not supported"));
+                }
+                break;
+           default:
+               RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header by field not supported"));
+
+
+        }
+    }
+    else
+    {
+        switch(hdr){
+             case(HEADER_TYPE_ETH):
+                 *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+                break;
+            // TODO - to take care about SHIM3
+            //case(HEADER_TYPE_USER_DEFINED_SHIM3):
+            //        *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
+            //    break;
+            //      break;
+          case(HEADER_TYPE_LLC_SNAP):
+                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+                break;
+            case(HEADER_TYPE_PPPoE):
+                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+                break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
+     }
+    }
+    return E_OK;
+}
+
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t                tmpReg32 = 0;
+    uint8_t                 prsArrayOffset;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+
+    if(p_Manip->rmv)
+    {
+        switch(p_ManipParams->rmvSpecificLocationParams.type)
+        {
+            case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                err = GetPrOffsetByHeaderOrField(&p_ManipParams->rmvSpecificLocationParams, &prsArrayOffset);
+                break;
+            case(e_FM_PCD_MANIP_LOC_NON_HDR) :
+                err = GetPrOffsetByNonHeader(&prsArrayOffset);
+                break;
+            default :
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid type of location header manipulation of type Remove"));
+        }
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 |= (uint32_t)prsArrayOffset << 24;
+        tmpReg32 |= HMAN_RMV_HDR;
+    }
+
+    if(p_Manip->insrt)
+        tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_PR | INTERNAL_CONTEXT_OFFSET;
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpReg32;
+
+    /*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree
+    tmpReg32 = 0;
+    tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;
+    *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
+
+    tmpReg32 = 0;
+    tmpReg32 |= HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    *(uint32_t *)&p_Ad->gmask = 0xf0000000;
+
+    return E_OK;
+}
+
+static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    // TODO - to think about it
+    //p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
+
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+
+    if(p_Manip->h_Frag)
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return err;
+}
+
+static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_Handle    p_Table;
+    uint32_t    tmpReg32 = 0;
+    int         i = 0;
+    uint8_t     log2Num;
+    uint8_t     numOfSets;
+    uint32_t    j = 0;
+    
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    
+    if(!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+    
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 4) ||
+            (p_ManipParams->maxNumFramesInProcess > 512))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
+    }
+    else
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 8) ||
+            (p_ManipParams->maxNumFramesInProcess > 2048))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
+    }
+
+    p_Manip->updateParams |= (NUM_OF_TASKS | BUFFER_POOL_ID_FOR_MANIP | OFFSET_OF_PR | OFFSET_OF_DATA);
+
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+
+    p_Table         = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    p_Manip->fragParams.p_AutoLearnHashTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+
+     IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
+   
+    
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
+    
+    tmpReg32 = 0;
+    if(p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    if(p_ManipParams->haltOnDuplicationFrag)
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
+    {
+        i = 8;
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
+    }
+    else
+        i = 4;
+    
+    numOfSets = (uint8_t)((p_ManipParams->maxNumFramesInProcess * 2) / i);
+    LOG2(numOfSets, log2Num);
+    tmpReg32 |= (uint32_t)(log2Num - 1) << 24;
+    
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
+    
+    for(j = 0; j < p_ManipParams->maxNumFramesInProcess * 2; j++)
+    {
+        if(((j / i)  % 2)== 0)
+        {
+            WRITE_UINT32(*(uint32_t *)CAST_UINT64_TO_POINTER((CAST_POINTER_TO_UINT64(p_Manip->fragParams.p_AutoLearnHashTbl) + j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE)), 0x80000000);
+        }
+    }
+    
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->bufferPoolIdAndRisc1SetIndexes, 0x00008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
+
+    p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
+    
+    p_Manip->fragParams.poolIndx =  poolIndex;
+
+
+    return E_OK;
+}
+
+
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP;
+    
+    p_Manip->frag = TRUE;
+    
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_CC_AD_ENTRY_SIZE,
+                                          FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
+   /*TODO - to think how it has to be taken from port*/
+   // tmpReg32 |= (uint32_t)p_ManipParams->offsetInBufferPrefixForFragmentationDataStruct << 8;
+    
+    if(p_ManipParams->headerOptionsCompr)
+        tmpReg32 = FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+    p_Manip->fragParams.poolIndx = poolIndex; 
+
+    return E_OK;
+}
+
+static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_FmPcdManipInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->insrtByTemplateParams;
+    volatile uint8_t                    *p_TemplateSpecificOffset = NULL;
+    uint8_t                             ipVersion = 0xff;
+    t_AdOfTypeContLookup                *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    bool                                ipModify = FALSE;
+    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
+    t_Error                             err = E_OK;
+    uint8_t                             extraAddedBytes = 0, blockSize = 0;
+    uint8_t                             *p_Template = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+
+    if(p_Manip->insrt)
+    {
+        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+             (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+
+         if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+
+         if(p_InsrtByTemplate->size > 128)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+
+         if(p_InsrtByTemplate->size)
+         {
+             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                p_InsrtByTemplate->size,
+                                                FM_PCD_CC_AD_TABLE_ALIGN);
+             if(!p_Manip->p_Template)
+                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
+             tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
+             *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
+         }
+
+         tmpReg32 = 0;
+
+        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+             
+        if(!p_Template)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+             
+        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size);
+
+
+         if(p_InsrtByTemplate->modifyOuterIp)
+         {
+             ipModify = TRUE;
+
+             ipVersion = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+             
+             //p_TemplateSpecificOffset = (uint8_t *)CAST_UINT64_TO_POINTER((CAST_POINTER_TO_UINT64(p_Manip->p_Template)+ p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset));
+
+             //ipVersion = (uint8_t)GET_UINT8(*(uint8_t *)p_TemplateSpecificOffset);
+
+             if((ipVersion & 0xf0) == 0x40)
+                 ipVersion = 4;
+             else if((ipVersion & 0xf0) == 0x60)
+                 ipVersion = 6;
+             else
+                 ipVersion = 0xff;
+
+             if(ipVersion == 4)
+             {
+                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
+
+                 //WRITE_UINT8(*(uint8_t *)(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP))), (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn);
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.caamUsedAfter)
+                 {
+
+                     extraAddedBytes = p_InsrtByTemplate->modifyOuterIpParams.caamParams.extraByteAddedByCaam;
+                     blockSize = p_InsrtByTemplate->modifyOuterIpParams.caamParams.blockSizeUsedByCaam;
+                     /*IP header template - IP totalLength -
+                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
+                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
+                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
+               	/*TODO - to think about not caam*/
+				// else
+                //     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For now only CAAM is supported"));
+                 }
+                 if(blockSize)
+                 {
+                     if (!POWER_OF_2(blockSize))
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
+                     blockSize -= 1;
+                 }
+
+                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+
+                 //WRITE_UINT8(*(uint8_t *)(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1))), blockSize);
+                 //WRITE_UINT8(*(uint8_t *)(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP))), (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes));
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);
+             
+
+                 /*IP header template - relevant only for ipv4 CheckSum = 0*/
+                 //WRITE_UINT16(*(uint8_t *)(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP))), 0x0000);
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+            
+
+                 /*UDP checksum has to be 0*/
+                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 {
+                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+
+                     //p_TemplateSpecificOffset = (uint8_t *)CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_Manip->p_Template)+ p_InsrtByTemplate->modifyOuterIpParams.udpOffset);
+                     //WRITE_UINT16(*(uint8_t *)(CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP))), 0x0000);
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+
+                 }
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+
+                 tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
+             }
+             else
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
+         }
+
+         if(p_InsrtByTemplate->modifyOuterVlan)
+         {
+             if(p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
+
+             //p_TemplateSpecificOffset = (uint8_t *)(p_Manip->p_Template);
+             /*TODO - here is bug - has to be changed*/
+             tmpReg32 = GET_UINT32(*(uint32_t *)CAST_UINT64_TO_POINTER(CAST_POINTER_TO_UINT64(p_TemplateSpecificOffset) + VLAN_TAG_FIELD_OFFSET_FROM_ETH));
+             if(((tmpReg32 & 0xffff0000) != 0x91000000) && ((tmpReg32 & 0xffff0000) != 0x92000000) && ((tmpReg32 & 0xffff0000) != 0x81000000))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
+
+             tmpReg32 = (tmpReg32 & 0xffff1fff) | ((uint32_t)p_InsrtByTemplate->modifyOuterVlanParams.vpri << 13);
+         }
+    
+        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+
+        XX_Free(p_Template);
+    }
+    
+    tmpReg32 = 0;
+    if(p_Manip->h_Frag)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+          tmpReg32 = 0xffff0000;
+
+    if(ipModify)
+        tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
+    else
+        tmpReg32 |= (uint32_t)0x0000ff00;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+
+    return err;
+}
+
+static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    if(p_Manip->h_Ad)
+    {
+        if(p_Manip->muramAllocate)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
+        else
+            XX_Free(p_Manip->h_Ad);
+        p_Manip->h_Ad = NULL;
+    }
+    if(p_Manip->p_Template)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
+        p_Manip->p_Template = NULL;
+    }
+    if(p_Manip->h_Frag)
+    {
+        if(p_Manip->fragParams.p_AutoLearnHashTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
+        if(p_Manip->fragParams.p_TimeOutTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
+
+    }
+}
+
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+{
+
+    if(p_ManipParams->rmv)
+    {
+        switch(p_ManipParams->rmvParams.type)
+        {
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION):
+                switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.type)
+                {
+                    case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                        switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.manipByHdr.hdr)
+                        {
+                            case(HEADER_TYPE_CAPWAP_DTLS) :
+
+                                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                                p_Manip->muramAllocate = TRUE;
+
+                                if(p_ManipParams->insrt)
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+
+                                if(p_ManipParams->fragOrReasm)
+                                {
+                                    if(!p_ManipParams->fragOrReasmParams.frag)
+                                    {
+                                        switch(p_ManipParams->fragOrReasmParams.hdr)
+                                        {
+                                            case(HEADER_TYPE_CAPWAP):
+                                                p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
+                                                break;
+                                            default:
+                                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                        }
+                                    }
+                                    else
+                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
+                                }
+                            break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+
+                        }
+                        break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid type of remove location"));
+
+                }
+            break;
+            case(e_FM_PCD_MANIP_RMV_INT_FRAME_HDR) :
+                /* TODO - check with fm-port driver the offset in buffer-prefix */
+                if(p_ManipParams->insrt || p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For the type of remove e_FM_PCD_MANIP_RMV_INT_FRAME_HDR the only valid option rmv = TRUE, insrt = FALSE, fragOrReasm = FALSE"));
+                p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+                p_Manip->muramAllocate = FALSE;
+            break;
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION) :
+                if  (p_ManipParams->fragOrReasm ||
+                    ((p_ManipParams->insrt) && p_ManipParams->insrtParams.type != e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION the only allowed insertion type is e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+           break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+        }
+    }
+    else if(p_ManipParams->insrt)
+    {
+        switch(p_ManipParams->insrtParams.type)
+        {
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE) :
+
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+                p_Manip->muramAllocate = FALSE;
+
+                if(p_ManipParams->fragOrReasm)
+                {
+                    if(p_ManipParams->fragOrReasmParams.frag)
+                    {
+                           switch(p_ManipParams->fragOrReasmParams.hdr)
+                           {
+                                case(HEADER_TYPE_CAPWAP):
+                                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                                    break;
+                                break;
+                                default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
+                           }
+                    }
+                    else
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
+                }
+            break;
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR) :
+                if(p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of insert can not be fragOrReasm = TRUE"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+            break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+        }
+    }
+    else if(p_ManipParams->fragOrReasm)
+    {
+        if(p_ManipParams->fragOrReasmParams.frag)
+        {
+            switch(p_ManipParams->fragOrReasmParams.hdr)
+             {
+                 case(HEADER_TYPE_CAPWAP):
+                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                     p_Manip->muramAllocate = FALSE;
+                 break;
+                 default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+             }
+        }
+        else
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+
+    p_Manip->insrt = p_ManipParams->insrt;
+    p_Manip->rmv   = p_ManipParams->rmv;
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd,E_INVALID_STATE,NULL);
+
+    p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
+    if(!p_Manip)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_Manip, 0, sizeof(t_FmPcdManip));
+
+    err = CheckManipParamsAndSetType(p_Manip, p_ManipParams);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+        p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            /* HmanType1 */
+            err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->rmvParams, p_Manip);
+            break;
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            /* CapwapFragmentation */
+            err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.capwapFragParams ,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->insrt)
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
+            err = InsrtHdrByTempl(&p_ManipParams->insrtParams, p_Manip, p_FmPcd);
+            break;
+        case(HMAN_OC_CAPWAP_REASSEMBLY) :
+            /*CAPWAP Reassembly*/
+            err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.capwapReasmParams,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->rmv)
+                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
+            err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
+            break;
+       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            /*Application Specific type 1*/
+            err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip);
+            break;
+       default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+    }
+    if(err)
+     {
+         REPORT_ERROR(MAJOR, err, NO_MSG);
+         ReleaseManipHandler(p_Manip, p_FmPcd);
+         XX_Free(p_Manip);
+         return NULL;
+     }
+     return p_Manip;
+}
+
+t_Error FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_HdrManipNode;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+
+    if(p_Manip->owner)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
+
+    ReleaseManipHandler(p_Manip,p_FmPcd);
+
+    XX_Free(h_HdrManipNode);
+
+    return E_OK;
+}
+
+t_Error FmPcdManipCheckParamsForCc(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
+    t_Error                   err;
+    
+    
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_INVALID_HANDLE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+        break;
+        break;
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  && 
+               (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+            err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+    }
+
+    return E_OK;
+}
+
+void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    FmManipUpdateOwner(h_Manip, TRUE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            *p_AdNew = p_Manip->h_Ad;
+            break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+ //           Mem2IOCpy32(p_Ad, p_Manip->h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+            /*TODO - gmask to update*/
+            //WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->gmask,        ((t_AdOfTypeResult *)(p_Manip->h_Ad))->gmask);
+
+
+            *p_AdNew = NULL;
+            break;
+        default:
+            break;
+    }
+}
+
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+    
+    FmManipUpdateOwner(h_Manip, TRUE);
+    
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            //Mem2IOCpy32(p_Ad, p_Manip->h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
+            *p_AdNew = NULL;
+            break;
+        default:
+            break;
+    }
+}
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
new file mode 100644
index 0000000..d74a04e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -0,0 +1,154 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.h
+
+ @Description   FM PCD manip...
+*//***************************************************************************/
+#ifndef __FM_MANIP_H
+#define __FM_MANIP_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_cc.h"
+
+
+/***********************************************************************/
+/*          Header manipulations defines                              */
+/***********************************************************************/
+
+#define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
+#define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
+#define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
+#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 // dummy
+
+#define HMAN_RMV_HDR                               0x80000000
+#define HMAN_INSRT_INT_FRM_HDR                     0x40000000
+
+#define UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP        6
+#define UDP_UDPCHECKSUM_FIELD_SIZE                  2
+
+#define IP_DSCECN_FIELD_OFFSET_FROM_IP              1
+#define IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP         2
+#define IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP         10
+#define VLAN_TAG_FIELD_OFFSET_FROM_ETH              12
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE               80
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN              8
+#define FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE                 32
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE 4
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE      8
+
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES          0x40000000
+#define FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG           0x10000000
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS    0x08000000
+#define FM_PCD_MANIP_CAPWAP_REASM_PR_COPY                          0x00800000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN              0x80000000
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct {
+    volatile uint32_t mode;
+    volatile uint32_t autoLearnHashTblPtr;
+    volatile uint32_t intStatsTblPtr;
+    volatile uint32_t reasmFrmDescPoolTblPtr;
+    volatile uint32_t reasmFrmDescIndexPoolTblPtr;
+    volatile uint32_t timeOutTblPtr;
+    volatile uint32_t bufferPoolIdAndRisc1SetIndexes;
+    volatile uint32_t risc23SetIndexes;
+    volatile uint32_t risc4SetIndexesAndExtendedStatsTblPtr;
+    volatile uint32_t extendedStatsTblPtr;
+    volatile uint32_t expirationDelay;
+    volatile uint32_t totalProcessedFragCounter;
+    volatile uint32_t totalUnsuccessfulReasmFramesCounter;
+    volatile uint32_t totalDuplicatedFragCounter;
+    volatile uint32_t totalMalformdFragCounter;
+    volatile uint32_t totalTimeOutCounter;
+    volatile uint32_t totalSetBusyCounter;
+    volatile uint32_t totalRfdPoolBusyCounter;
+    volatile uint32_t totalDiscardedFragsCounter;
+    volatile uint32_t totalMoreThan16FramesCounter;
+} _PackedType t_CapwapReasmPram;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+/***********************************************************************/
+/*  Driver's internal structures                                       */
+/***********************************************************************/
+
+typedef struct
+{
+    t_Handle p_AutoLearnHashTbl;
+    t_Handle p_ReassmFrmDescrPoolTbl;
+    t_Handle p_ReassmFrmDescrIndxPoolTbl;
+    t_Handle p_TimeOutTbl;
+    uint8_t  maxNumFramesInProcess;
+    uint8_t  numOfTasks;
+    uint8_t  poolId;
+    uint8_t  prOffset;
+    uint16_t  dataOffset;
+    uint8_t  poolIndx;
+}t_FragParams;
+
+typedef struct{
+    bool            muramAllocate;
+    t_Handle        h_Ad;
+    uint32_t        type;
+    bool            rmv;
+    bool            insrt;
+    uint8_t         *p_Template;
+    t_Handle        h_Frag;
+    bool            frag;
+    uint16_t        sizeForFragmentation;
+    uint8_t         owner;
+    uint32_t        updateParams;
+    uint32_t        shadowUpdateParams;
+    t_FragParams    fragParams;
+    uint8_t         icOffset;
+} t_FmPcdManip;
+
+
+#endif /* __FM_MANIP_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 4e8bd0a..261d7c6 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -45,48 +45,55 @@
 #include "fm_ext.h"
 #include "fm_pcd_ext.h"
 
+#include "fm_common.h"
 #include "fm_pcd.h"
-#ifdef FM_MASTER_PARTITION
 #include "fm_pcd_ipc.h"
-#endif /* FM_MASTER_PARTITION */
 #include "fm_hc.h"
 
 
-#ifndef CONFIG_GUEST_PARTITION
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
-    if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
-
-    if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
-
     if(!p_FmPcd->h_Fm)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
 
-    if(!p_FmPcd->f_Exception)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
+    if(FmIsMaster(p_FmPcd->h_Fm))
+    {
+        if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
 
-    if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
+        if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
 
-   if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
+        if(!p_FmPcd->f_Exception)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
 
+        if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
+
+        if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
+    }
 
     return E_OK;
 }
-#endif  /* !CONFIG_GUEST_PARTITION */
 
-#ifdef FM_MASTER_PARTITION
-t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+static t_Error  FmPcdHandleIpcMsg(t_Handle  h_FmPcd, 
+                                  uint8_t   *p_Msg, 
+                                  uint32_t  msgLength, 
+                                  uint8_t   **p_Reply, 
+                                  uint32_t  *p_ReplyLength)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t                     schemeId;
-    t_Error                     err = E_OK;
-    t_FmPcdKgInterModuleClsPlanSet           clsPlanSet;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err = E_OK;
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+    uint32_t                        msgId;
+    uint8_t                         *p_MsgBody;
 
+UNUSED(p_Reply);UNUSED(p_ReplyLength); /* TODO - change the routine here to use reply msg!!! */
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength > sizeof(uint32_t)), E_INVALID_VALUE);
+    msgId = ((uint32_t *)p_Msg)[0];
+    p_MsgBody = (uint8_t *)(&((uint32_t *)p_Msg)[1]);
 
     switch(msgId)
     {
@@ -96,9 +103,8 @@ t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG
             /* count partitions registrations */
             if(p_FmPcd->enabled)
                 p_FmPcd->numOfEnabledGuestPartitionsPcds++;
-            return p_FmPcd->enabled;
-            //case (FM_PCD_CLEAR_PORT_PARAMS):
-                //return FmPcdDeletePortParams(h_FmPcd, (t_FmPcdInterModulePortDeleteParams*)msgBody);
+            *(bool*)p_MsgBody = p_FmPcd->enabled;
+            break;
         case (FM_PCD_GUEST_DISABLE):
             if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
             {
@@ -107,101 +113,165 @@ t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG
             }
             else
                 RETURN_ERROR(MINOR, E_INVALID_STATE,("Trying to disable an unregistered partition"));
-        case (FM_PCD_ALLOC_KG_RSRC):
+        case (FM_PCD_ALLOC_KG_SCHEMES):
             {
                 err = FmPcdKgAllocSchemes(h_FmPcd,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                                            ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->numOfSchemes,
+                                            ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->partitionId,
+                                            ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->schemesIds);
                 if(err)
                     RETURN_ERROR(MINOR, err, NO_MSG);
 
-                err = FmPcdKgAllocClsPlanEntries(h_FmPcd,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
-                                            &((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+            }
+            break;
+        case (FM_PCD_ALLOC_KG_CLSPLAN):
+            {
+                err = KgAllocClsPlanEntries(h_FmPcd,
+                                            ((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->numOfClsPlanEntries,
+                                            ((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->partitionId,
+                                            &((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->clsPlanBase);
                 if(err)
                     RETURN_ERROR(MINOR, err, NO_MSG);
-                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
-
             }
             break;
-
         case (FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP):
             {
                 memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
-                clsPlanSet.baseEntry = *(uint8_t*)msgBody;
+                clsPlanSet.baseEntry = *(uint8_t*)p_MsgBody;
                 clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
                 KgSetClsPlan(h_FmPcd, &clsPlanSet);
             }
             break;
-        case (FM_PCD_FREE_KG_RSRC):
+        case (FM_PCD_FREE_KG_SCHEMES):
             {
                 err = FmPcdKgFreeSchemes(h_FmPcd,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                                         ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->numOfSchemes,
+                                         ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->partitionId,
+                                         ((t_FmPcdIpcKgSchemesParams*)p_MsgBody)->schemesIds);
                 if(err)
                     RETURN_ERROR(MINOR, err, NO_MSG);
-
-                err = FmPcdKgFreeClsPlanEntries(h_FmPcd,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
-                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+            }
+            break;
+        case (FM_PCD_FREE_KG_CLSPLAN):
+            {
+                err = KgFreeClsPlanEntries(h_FmPcd,
+                                           ((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->numOfClsPlanEntries,
+                                           ((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->partitionId,
+                                           ((t_FmPcdIpcKgClsPlanParams*)p_MsgBody)->clsPlanBase);
                 if(err)
                     RETURN_ERROR(MINOR, err, NO_MSG);
-                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
-
-                if(((t_FmPcdIpcKgAllocParams*)msgBody)->isDriverClsPlanGrp)
-                {
-                    memset(clsPlanSet.vectors, 0x00, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
-                    clsPlanSet.baseEntry = ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase;
-                    clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
-                    KgSetClsPlan(h_FmPcd, &clsPlanSet);
-                }
             }
             break;
         case (FM_PCD_ALLOC_PROFILES):
             return PlcrAllocProfiles(h_FmPcd,
-                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
-                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
-                                        &((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+                                     ((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->hardwarePortId,
+                                     ((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->num,
+                                     &((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->plcrProfilesBase);
         case (FM_PCD_FREE_PROFILES):
             return PlcrFreeProfiles(h_FmPcd,
-                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
-                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
-                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+                                    ((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->hardwarePortId,
+                                    ((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->num,
+                                    ((t_FmPcdIpcPlcrAllocParams*)p_MsgBody)->plcrProfilesBase);
 
         case (FM_PCD_ALLOC_SHARED_PROFILES):
             return PlcrAllocSharedProfiles(h_FmPcd,
-                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
-                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+                                           ((t_FmPcdIpcSharedPlcrAllocParams*)p_MsgBody)->num,
+                                           ((t_FmPcdIpcSharedPlcrAllocParams*)p_MsgBody)->profilesIds);
         case (FM_PCD_FREE_SHARED_PROFILES):
             PlcrFreeSharedProfiles(h_FmPcd,
-                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
-                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+                                   ((t_FmPcdIpcSharedPlcrAllocParams*)p_MsgBody)->num,
+                                   ((t_FmPcdIpcSharedPlcrAllocParams*)p_MsgBody)->profilesIds);
             break;
-        case (FM_PCD_GET_PHYS_MURAM_BASE):
-            return FmGetPhysicalMuramBase(p_FmPcd->h_Fm, (t_FmPhysAddr*)msgBody);
         case(FM_PCD_GET_SW_PRS_OFFSET):
-            ((t_FmPcdIpcSwPrsLable*)msgBody)->offset = FmPcdGetSwPrsOffset(h_FmPcd, ((t_FmPcdIpcSwPrsLable*)msgBody)->hdr, ((t_FmPcdIpcSwPrsLable*)msgBody)->indexPerHdr);
-            if(((t_FmPcdIpcSwPrsLable*)msgBody)->offset == ILLEGAL_BASE)
+            ((t_FmPcdIpcSwPrsLable*)p_MsgBody)->offset =
+                FmPcdGetSwPrsOffset(h_FmPcd,
+                                    (e_NetHeaderType)((t_FmPcdIpcSwPrsLable*)p_MsgBody)->enumHdr,
+                                    ((t_FmPcdIpcSwPrsLable*)p_MsgBody)->indexPerHdr);
+            if(((t_FmPcdIpcSwPrsLable*)p_MsgBody)->offset == ILLEGAL_BASE)
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
-
-
             break;
-       /* case(FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS):
-            return FmPcdKgGetSetSchemeParams(h_FmPcd, (t_FmPcdInterModuleKgSchemeParams*)msgBody);*/
         case(FM_PCD_FREE_KG_SCHEME_HC):
-            schemeId = *(uint8_t*)msgBody;
-            FmPcdKgInvalidateSchemeSw(h_FmPcd, schemeId);
+            FmPcdKgInvalidateSchemeSw(h_FmPcd, *(uint8_t*)p_MsgBody);
+            break;
+        case(FM_PCD_GET_COUNTER):
+            ((t_FmPcdIpcGetCounter*)p_MsgBody)->val = FM_PCD_GetCounter(h_FmPcd, (e_FmPcdCounters)(((t_FmPcdIpcGetCounter*)p_MsgBody)->enumId));
             break;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+       case(FM_PCD_DUMP_REGS):
+            return FM_PCD_DumpRegs(h_FmPcd);
+       case(FM_PCD_KG_DUMP_REGS):
+            return FM_PCD_KgDumpRegs(h_FmPcd);
+       case(FM_PCD_PLCR_DUMP_REGS):
+            return FM_PCD_PlcrDumpRegs(h_FmPcd);
+       case(FM_PCD_PLCR_PROFILE_DUMP_REGS):
+            return FM_PCD_PlcrProfileDumpRegs(h_FmPcd, *(t_Handle*)p_MsgBody);
+       case(FM_PCD_PRS_DUMP_REGS):
+            return FM_PCD_PrsDumpRegs(h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+            break;
+       case(FM_PCD_PRS_INC_PORT_STATS):
+           PrsIncludePortInStatistics(h_FmPcd,
+                                      (((t_FmPcdIpcPrsIncludePort*)p_MsgBody)->hardwarePortId), 
+                                      (((t_FmPcdIpcPrsIncludePort*)p_MsgBody)->include));
+           break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
     }
     return E_OK;
 }
-#endif /* FM_MASTER_PARTITION */
+
+void FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId)
+{
+    p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = clsPlanGrpId;
+}
+
+t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_GrpParams)
+{
+    uint8_t netEnvId = p_GrpParams->netEnvId;
+    int     i, k, j;
+
+    if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
+    {
+        p_GrpParams->grpExists = TRUE;
+        p_GrpParams->clsPlanGrpId = p_FmPcd->netEnvs[netEnvId].clsPlanGrpId;
+        return E_OK;
+    }
+
+    for(i=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* if an option exists, add it to the opts list */
+            if(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+            {
+                /* check if this option already exists, add if it doesn't */
+                for(j = 0;j<p_GrpParams->numOfOptions;j++)
+                {
+                    if(p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                        break;
+                }
+                p_GrpParams->optVectors[j] |= p_FmPcd->netEnvs[netEnvId].unitsVectors[i];
+                if(j == p_GrpParams->numOfOptions)
+                {
+                    p_GrpParams->options[p_GrpParams->numOfOptions] = p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt;
+                    p_GrpParams->numOfOptions++;
+                }
+            }
+        }
+
+    if(p_GrpParams->numOfOptions == 0)
+    {
+        if(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
+        {
+            p_GrpParams->grpExists = TRUE;
+            p_GrpParams->clsPlanGrpId = p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
+        }
+    }
+
+    return E_OK;
+
+}
 
 t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector)
 {
@@ -269,11 +339,11 @@ bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t uni
 void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint16_t        pcdPortId;
+    uint16_t        swPortIndex = 0;
 
-    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort = h_FmPort;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort = h_FmPort;
 }
 
 uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
@@ -283,6 +353,12 @@ uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
     return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
 }
 
+uint32_t FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->netEnvs[netEnvId].macsecVector;
+}
 
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
@@ -295,15 +371,14 @@ void FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
     ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners--;
 }
 
-t_Error FmPcdTryLock(t_Handle h_FmPcd)
+uint32_t FmPcdLock(t_Handle h_FmPcd)
 {
-    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->lock);
-    return E_OK;
+    return XX_LockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock);
 }
 
-void FmPcdReleaseLock(t_Handle h_FmPcd)
+void FmPcdUnlock(t_Handle h_FmPcd, uint32_t intFlags)
 {
-    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->lock);
+    XX_UnlockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock, intFlags);
 }
 
 /**********************************************************************************************************/
@@ -312,7 +387,9 @@ void FmPcdReleaseLock(t_Handle h_FmPcd)
 
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 {
-    t_FmPcd *p_FmPcd = NULL;
+    t_FmPcd             *p_FmPcd = NULL;
+    t_FmPhysAddr        physicalMuramBase;
+    uint8_t             i;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcdParams, E_INVALID_HANDLE,NULL);
 
@@ -335,6 +412,13 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 
     p_FmPcd->h_Fm = p_FmPcdParams->h_Fm;
 
+    p_FmPcd->h_FmMuram = p_FmPcdParams->h_FmMuram;
+    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
+    p_FmPcd->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+
+    for(i = 0; i<FM_MAX_NUM_OF_PORTS; i++)
+        p_FmPcd->netEnvs[i].clsPlanGrpId = ILLEGAL_CLS_PLAN;
+
 #ifndef CONFIG_MULTI_PARTITION_SUPPORT
     if (p_FmPcdParams->useHostCommand)
 #endif  /* !CONFIG_MULTI_PARTITION_SUPPORT */
@@ -367,8 +451,8 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 
     if(p_FmPcdParams->ccSupport)
     {
-        p_FmPcd->p_FmPcdCc = (t_FmPcdCc *)CcConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdCc)
+        p_FmPcd->h_FmPcdCc = FmPcdCcConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->h_FmPcdCc)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Cc"));
             FM_PCD_Free(p_FmPcd);
@@ -385,7 +469,6 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
             FM_PCD_Free(p_FmPcd);
             return NULL;
         }
-
     }
 
     if(p_FmPcdParams->prsSupport)
@@ -399,18 +482,20 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_FmPcd->h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPcd->h_Spinlock)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd spinlock"));
+        FM_PCD_Free(p_FmPcd);
+        return NULL;
+    }
+
     p_FmPcd->partitionId = FmGetPartitionId(p_FmPcd->h_Fm);
-#ifdef FM_MASTER_PARTITION
     p_FmPcd->numOfEnabledGuestPartitionsPcds = 0;
-#endif /* FM_MASTER_PARTITION */
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
-#ifndef CONFIG_GUEST_PARTITION
     p_FmPcd->f_Exception                = p_FmPcdParams->f_Exception;
     p_FmPcd->f_FmPcdIndexedException    = p_FmPcdParams->f_ExceptionId;
     p_FmPcd->h_App                      = p_FmPcdParams->h_App;
-#endif  /* !CONFIG_GUEST_PARTITION */
 
     return p_FmPcd;
 }
@@ -423,13 +508,14 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
-#ifdef CONFIG_GUEST_PARTITION
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ALIVE, NULL, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-#else
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+    {
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ALIVE, NULL, NULL, NULL);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
     CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
-#endif /* CONFIG_GUEST_PARTITION */
 
     if(p_FmPcd->p_FmPcdKg)
     {
@@ -445,23 +531,22 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-#ifndef CONFIG_GUEST_PARTITION
-    if(p_FmPcd->p_FmPcdPrs)
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
-        err = PrsInit(p_FmPcd);
+        if(p_FmPcd->p_FmPcdPrs)
+        {
+            err = PrsInit(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+         /* register to inter-core messaging mechanism */
+        memset(p_FmPcd->fmPcdModuleName, 0, MODULE_NAME_SIZE);
+        if(Sprint (p_FmPcd->fmPcdModuleName, "FM-%d.PCD",FmGetId(p_FmPcd->h_Fm)) != 8)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsg, p_FmPcd);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-#endif  /* CONFIG_GUEST_PARTITION */
-#ifdef FM_MASTER_PARTITION
-     /* register to inter-core messaging mechanism */
-    memset(p_FmPcd->fmPcdModuleName, 0, MODULE_NAME_SIZE);
-    if(Sprint (p_FmPcd->fmPcdModuleName, "FM-%d.PCD",FmGetId(p_FmPcd->h_Fm)) != 8)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-    err = XX_RegisterMessageHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsg, p_FmPcd);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-#endif /* FM_MASTER_PARTITION */
 
     XX_Free(p_FmPcd->p_FmPcdDriverParam);
     p_FmPcd->p_FmPcdDriverParam = NULL;
@@ -474,14 +559,14 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 t_Error FM_PCD_Free(t_Handle h_FmPcd)
 {
     t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
-#ifdef CONFIG_GUEST_PARTITION
-    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-#endif /* CONFIG_GUEST_PARTITION */
     t_Error                             err = E_OK;
 
     if(p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
+    if (p_FmPcd->h_Spinlock)
+        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
+
     if(p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
@@ -494,6 +579,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         XX_Free(p_FmPcd->p_FmPcdKg);
         p_FmPcd->p_FmPcdKg = NULL;
     }
+
     if(p_FmPcd->p_FmPcdPlcr)
     {
         if((err = PlcrFree(p_FmPcd)) != E_OK)
@@ -501,17 +587,20 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
+
     if(p_FmPcd->p_FmPcdPrs)
     {
-        PrsFree(p_FmPcd);
+        if(FmIsMaster(p_FmPcd->h_Fm))
+            PrsFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPrs);
         p_FmPcd->p_FmPcdPrs = NULL;
     }
-    if(p_FmPcd->p_FmPcdCc)
+
+    if(p_FmPcd->h_FmPcdCc)
     {
-        CcFree(p_FmPcd->p_FmPcdCc);
-        XX_Free(p_FmPcd->p_FmPcdCc);
-        p_FmPcd->p_FmPcdCc = NULL;
+        FmPcdCcFree(p_FmPcd->h_FmPcdCc);
+        XX_Free(p_FmPcd->h_FmPcdCc);
+        p_FmPcd->h_FmPcdCc = NULL;
     }
 
     if (p_FmPcd->h_Hc)
@@ -520,9 +609,8 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         p_FmPcd->h_Hc = NULL;
     }
 
-#ifdef FM_MASTER_PARTITION
-    XX_UnregisterMessageHandler(p_FmPcd->fmPcdModuleName);
-#endif /* FM_MASTER_PARTITION */
+    XX_IpcUnregisterMsgHandler(p_FmPcd->fmPcdModuleName);
+
     FmUnregisterPcd(p_FmPcd->h_Fm);
 
     XX_Free(p_FmPcd);
@@ -534,34 +622,40 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
 
-#ifndef CONFIG_GUEST_PARTITION
-    if(p_FmPcd->p_FmPcdKg)
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
-        err = KgEnable(p_FmPcd);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        if(p_FmPcd->p_FmPcdKg)
+        {
+            err = KgEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
 
-    if(p_FmPcd->p_FmPcdPlcr)
-    {
-        err = PlcrEnable(p_FmPcd);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        if(p_FmPcd->p_FmPcdPlcr)
+        {
+            err = PlcrEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
 
-    if(p_FmPcd->p_FmPcdPrs)
+        if(p_FmPcd->p_FmPcdPrs)
+        {
+            err = PrsEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        p_FmPcd->enabled = TRUE;
+    }
+    else
     {
-        err = PrsEnable(p_FmPcd);
+        bool enabled;
+
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ENABLED, (uint8_t*)&enabled, NULL, NULL);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_FmPcd->enabled = enabled;
     }
-    p_FmPcd->enabled = TRUE;
-
     return E_OK;
-
-#else
-    return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ENABLED, NULL, NULL, NULL);
-#endif /* !CONFIG_GUEST_PARTITION */
 }
 
 t_Error FM_PCD_Disable(t_Handle h_FmPcd)
@@ -569,42 +663,42 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd)
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
 
-#ifndef CONFIG_GUEST_PARTITION
-#ifdef FM_MASTER_PARTITION
-    if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
-#endif /* FM_MASTER_PARTITION */
-    if(p_FmPcd->p_FmPcdKg)
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
-        err = KgDisable(p_FmPcd);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
+        if(p_FmPcd->p_FmPcdKg)
+        {
+            err = KgDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
 
-    if(p_FmPcd->p_FmPcdPlcr)
-    {
-        err = PlcrDisable(p_FmPcd);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        if(p_FmPcd->p_FmPcdPlcr)
+        {
+            err = PlcrDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
 
-    if(p_FmPcd->p_FmPcdPrs)
-    {
-        err = PrsDisable(p_FmPcd);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-    p_FmPcd->enabled = FALSE;
+        if(p_FmPcd->p_FmPcdPrs)
+        {
+            err = PrsDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        p_FmPcd->enabled = FALSE;
 
-    return E_OK;
-#else
-    return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GUEST_DISABLE, NULL, NULL, NULL);
-#endif /* !CONFIG_GUEST_PARTITION */
+        return E_OK;
+    }
+    else
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GUEST_DISABLE, NULL, NULL, NULL);
 }
 
 t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                intFlags;
     uint8_t                 bitId = 0;
     uint8_t                 i, j, k;
     uint8_t                 netEnvCurrId;
@@ -615,24 +709,28 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
 
-    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     /* find a new netEnv */
-    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
         if(!p_FmPcd->netEnvs[i].used)
             break;
 
-    if(i== PCD_MAX_NUM_OF_PORTS)
+    if(i== FM_MAX_NUM_OF_PORTS)
     {
-        REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", PCD_MAX_NUM_OF_PORTS));
-        RELEASE_LOCK(p_FmPcd->lock);
+        REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
+        FmPcdUnlock(p_FmPcd, intFlags);
         return NULL;
     }
 
     p_FmPcd->netEnvs[i].used = TRUE;
 
-    TRY_LOCK_RET_NULL(p_FmPcd->netEnvs[i].lock);
-    RELEASE_LOCK(p_FmPcd->lock);
+    if (!TRY_LOCK(NULL, p_FmPcd->netEnvs[i].lock))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return NULL;
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
 
     netEnvCurrId = (uint8_t)i;
 
@@ -725,14 +823,16 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
                 break;
-            case(HEADER_TYPE_USER_DEFINED_SHIM3):
-                p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000004;
-                break;
             default:
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Only 3 SHIMs supported"));
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Requested SHIM not supported"));
             }
         else
+        {
             p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
+
+            if(IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+                p_FmPcd->netEnvs[netEnvCurrId].macsecVector = p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
+        }
     }
 
     /* define a set of hardware parser LCV's according to the defined netenv */
@@ -769,7 +869,8 @@ t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    TRY_LOCK_RET_ERR(p_FmPcd->netEnvs[netEnvId].lock);
+    if (!TRY_LOCK(p_FmPcd->h_Spinlock, p_FmPcd->netEnvs[netEnvId].lock))
+        return ERROR_CODE(E_BUSY);
     /* check that no port is bound to this netEnv */
     if(p_FmPcd->netEnvs[netEnvId].owners)
     {
@@ -787,7 +888,7 @@ t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
     return E_OK;
 }
 
-void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd)
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
@@ -796,7 +897,166 @@ void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd)
     FmHcTxConf(p_FmPcd->h_Hc, p_Fd);
 }
 
-#ifndef CONFIG_GUEST_PARTITION
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+    {
+        t_Error                 err;
+        t_FmPcdIpcGetCounter    counterParams;
+
+        counterParams.enumId = (uint32_t)counter;
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
+        if(err )
+            REPORT_ERROR(MINOR, err, NO_MSG);
+
+        return counterParams.val;
+    }
+    else
+    {
+        switch(counter)
+        {
+            case(e_FM_PCD_KG_COUNTERS_TOTAL):
+                if(!p_FmPcd->p_FmPcdKg)
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                    return 0;
+                }
+                break;
+            case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+            case(e_FM_PCD_PLCR_COUNTERS_RED):
+            case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+            case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+            case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+            case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+                if(!p_FmPcd->p_FmPcdPlcr)
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                    return 0;
+                }
+                /* check that counters are enabled */
+                if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                    return 0;
+                }
+                break;
+            case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+            case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+            case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+            case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+            case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+            case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+            case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+            case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+            case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+            case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+            case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+                if(!p_FmPcd->p_FmPcdPrs)
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                    return 0;
+                }
+                break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+                return 0;
+        }
+        switch(counter)
+        {
+            case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
+            case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
+            case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
+            case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
+            case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
+            case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
+            case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
+            case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
+            case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
+            case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
+            case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
+            case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
+            case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
+            case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+                   return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
+            case(e_FM_PCD_KG_COUNTERS_TOTAL):
+                   return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
+
+            /*Policer statictics*/
+            case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
+            case(e_FM_PCD_PLCR_COUNTERS_RED):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
+            case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
+            case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
+            case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
+            case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+                    return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
+
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+                return 0;
+        }
+    }
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_DUMP_REGS, NULL, NULL, NULL);
+    else
+    {
+        if (p_FmPcd->p_FmPcdKg)
+            FM_PCD_KgDumpRegs(h_FmPcd);
+        if (p_FmPcd->p_FmPcdPlcr)
+            FM_PCD_PlcrDumpRegs(h_FmPcd);
+        if (p_FmPcd->p_FmPcdPrs)
+            FM_PCD_PrsDumpRegs(h_FmPcd);
+    }
+    return E_OK;
+ }
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
 t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -804,6 +1064,9 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
+
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
     {
@@ -826,6 +1089,9 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetException - guest mode!"));
+
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
 
     if(bitMask)
@@ -851,8 +1117,6 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
             break;
             case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
             case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
-            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
                 if(!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
             break;
@@ -887,22 +1151,6 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
                 break;
-            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
-                if(enable)
-                    tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
-                else
-                    tmpReg &= ~FM_PCD_PRS_ILLEGAL_ACCESS;
-                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
-                break;
-            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
-                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
-                if(enable)
-                    tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
-                else
-                    tmpReg &= ~FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
-                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
-                break;
             case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
                 if(enable)
@@ -965,126 +1213,89 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
     return E_OK;
 }
 
-uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
 {
     t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    switch(counter)
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ForceIntr - guest mode!"));
+
+    switch(exception)
     {
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
             if(!p_FmPcd->p_FmPcdKg)
-            {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
-                return 0;
-            }
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
             if(!p_FmPcd->p_FmPcdPlcr)
-            {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
-                return 0;
-            }
-            /* check that counters are enabled */
-            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
-            {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
-                return 0;
-            }
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if(!p_FmPcd->p_FmPcdPrs)
-            {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
-                return 0;
-            }
+        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+           if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
-            return 0;
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
+
     }
-    switch(counter)
+    switch(exception)
     {
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
-               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
-
-        /*Policer statictics*/
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
-
+        case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
+            break;
+        case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
+            break;
         default:
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
-            return 0;
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
+
+    return E_OK;
 }
 
+
 t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
 {
     t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1092,6 +1303,9 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ModifyCounter - guest mode!"));
+
     switch(counter)
     {
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
@@ -1215,119 +1429,41 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
 return E_OK;
 }
 
-
-
-t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
-{
-    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    switch(exception)
-    {
-        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-            if(!p_FmPcd->p_FmPcdKg)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
-            break;
-        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-            if(!p_FmPcd->p_FmPcdPlcr)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
-            break;
-        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-        case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
-        case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
-            if(!p_FmPcd->p_FmPcdPrs)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
-
-    }
-    switch(exception)
-    {
-        case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
-            break;
-        case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_ILLEGAL_ACCESS);
-           break;
-        case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-             WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_PORT_ILLEGAL_ACCESS);
-            break;
-        case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
-            break;
-        case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
-            break;
-        case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
-            break;
-        case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
-            break;
-        case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
-            break;
-        case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE);
-            break;
-        case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:
-            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
-            break;
-        default:
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
-    }
-
-    return E_OK;
-}
-
 #ifdef VERIFICATION_SUPPORT
 void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t            base;
+    uint64_t            base;
 
     SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_BackdoorSet - guest mode!"));
+
     switch(moduleId)
     {
+#ifdef SC1023
+        case e_MODULE_ID_FM_PRS:
+#else
         case e_MODULE_ID_FM1_PRS:
         case e_MODULE_ID_FM2_PRS:
+#endif
             base = FmGetPcdPrsBaseAddr(p_FmPcd);
             break;
+#ifdef SC1023
+        case e_MODULE_ID_FM_PLCR:
+#else
         case e_MODULE_ID_FM1_PLCR:
         case e_MODULE_ID_FM2_PLCR:
+#endif
             base = FmGetPcdPlcrBaseAddr(p_FmPcd);
             break;
+#ifdef SC1023
+        case e_MODULE_ID_FM_KG:
+#else
         case e_MODULE_ID_FM1_KG:
         case e_MODULE_ID_FM2_KG:
+#endif
             base = FmGetPcdKgBaseAddr(p_FmPcd);
             break;
         default:
@@ -1341,22 +1477,37 @@ void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset,
 uint32_t      FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t            base;
+    uint64_t            base;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_BackdoorGet - guest mode!"));
+
     switch(moduleId)
     {
+#ifdef SC1023
+        case(e_MODULE_ID_FM_PRS):
+#else
         case e_MODULE_ID_FM1_PRS:
         case e_MODULE_ID_FM2_PRS:
+#endif
             base = FmGetPcdPrsBaseAddr(p_FmPcd);
             break;
+#ifdef SC1023
+        case e_MODULE_ID_FM_PLCR:
+#else
         case e_MODULE_ID_FM1_PLCR:
         case e_MODULE_ID_FM2_PLCR:
+#endif
             base = FmGetPcdPlcrBaseAddr(p_FmPcd);
             break;
+#ifdef SC1023
+        case e_MODULE_ID_FM_KG:
+#else
         case e_MODULE_ID_FM1_KG:
         case e_MODULE_ID_FM2_KG:
+#endif
             base = FmGetPcdKgBaseAddr(p_FmPcd);
             break;
         default:
@@ -1368,24 +1519,3 @@ uint32_t      FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t
 }
 #endif /*VERIFICATION_SUPPORT*/
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if (p_FmPcd->p_FmPcdKg)
-        FM_PCD_KgDumpRegs(h_FmPcd);
-    if (p_FmPcd->p_FmPcdPlcr)
-        FM_PCD_PlcrDumpRegs(h_FmPcd);
-    if (p_FmPcd->p_FmPcdPrs)
-        FM_PCD_PrsDumpRegs(h_FmPcd);
-    return E_OK;
- }
-#endif /* (defined(DEBUG_ERRORS) && ... */
-#endif /* ! CONFIG_GUEST_PARTITION */
-
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 86efc6c..15d7681 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -43,8 +43,6 @@
 #include "list_ext.h"
 #include "fm_pcd_ext.h"
 
-#include "fm_common.h"
-
 
 #define __ERR_MODULE__  MODULE_FM_PCD
 
@@ -57,55 +55,8 @@
 /****************************/
 /* General defines          */
 /****************************/
-
-#define PCD_PORTS_TABLE                     {1,2,3,4,5,6,7,8,9,10,11,16}
-
-#define SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId) \
-do {                                                                    \
-    uint8_t pcdPortsTable[] = PCD_PORTS_TABLE;                          \
-    pcdPortId = 0;                                                      \
-    while((hardwarePortId != pcdPortsTable[pcdPortId]) &&               \
-          (pcdPortId<PCD_MAX_NUM_OF_PORTS))                             \
-        pcdPortId++;                                                    \
-} while (0)
-
-#define GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, i)       \
-do {                                                                    \
-    uint8_t pcdPortsTable[] = PCD_PORTS_TABLE;                          \
-    hardwarePortId = pcdPortsTable[i];                                  \
-} while (0)
-
-
-#define ILLEGAL_PCD_PORTID                  0xFF
-#define ILLEGAL_CLS_PLAN                    0xFF
-
-#define GET_PCD_PORTID_BY_RELATIVE(portId,type,id)      \
-switch(type) {                              \
-    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):   \
-        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
-            portId = ILLEGAL_PCD_PORTID;    \
-        else                                \
-            portId = id; break;             \
-     case(e_FM_PORT_TYPE_RX):               \
-        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
-            portId = ILLEGAL_PCD_PORTID;    \
-        else                                \
-            portId = id+FM_MAX_NUM_OF_OH_PORTS;\
-        break;                              \
-      case(e_FM_PORT_TYPE_RX_10G):          \
-        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
-            portId = ILLEGAL_PCD_PORTID;    \
-        else                                \
-            portId = id+FM_MAX_NUM_OF_OH_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS;    \
-        break;                              \
-      default:                              \
-        portId = ILLEGAL_PCD_PORTID;        \
-}
-
-#define IS_PRIVATE_HEADER(hdr)              ((hdr == HEADER_TYPE_USER_DEFINED_SHIM1 ) ||   \
-                                             (hdr == HEADER_TYPE_USER_DEFINED_SHIM2) ||    \
-                                             (hdr == HEADER_TYPE_USER_DEFINED_SHIM3))
-
+#define ILLEGAL_CLS_PLAN    0xff
+#define ILLEGAL_NETENV      0xff
 /****************************/
 /* Error defines           */
 /****************************/
@@ -119,18 +70,16 @@ switch(type) {                              \
 
 #define FM_PCD_EX_PRS_DOUBLE_ECC                    0x02000000
 #define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
-#define FM_PCD_EX_PRS_ILLEGAL_ACCESS                0x00800000
-#define FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS           0x00400000
 
 #define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
 switch(exception){                                                  \
-    case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                      \
+    case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                          \
         bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
-    case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                    \
+    case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                        \
         bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
-    case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:                \
+    case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:                    \
         bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
-    case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:              \
+    case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:                  \
         bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
     case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
         bitMask = FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE; break;    \
@@ -138,15 +87,10 @@ switch(exception){                                                  \
         bitMask = FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE; break;     \
     case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:                         \
         bitMask = FM_PCD_EX_PRS_DOUBLE_ECC; break;                  \
-    case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:                     \
-        bitMask = FM_PCD_EX_PRS_ILLEGAL_ACCESS; break;              \
     case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:                         \
         bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
-    case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:                \
-        bitMask = FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS; break;         \
     default: bitMask = 0;break;}
 
-
 /***********************************************************************/
 /*          SW parser L4 shells patch                                  */
 /***********************************************************************/
@@ -183,8 +127,6 @@ switch(exception){                                                  \
 #define FM_PCD_PRS_SINGLE_ECC               0x00004000
 #define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
 #define FM_PCD_PRS_DOUBLE_ECC               0x00004000
-#define FM_PCD_PRS_PORT_ILLEGAL_ACCESS      0xffff0000
-#define FM_PCD_PRS_ILLEGAL_ACCESS           0x00008000
 #define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
 
 /* others */
@@ -195,13 +137,9 @@ switch(exception){                                                  \
 #define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
     prsPortId = (uint8_t)(hardwarePortId & 0x0f)
 
-#define GET_FM_PCD_PORT_ID_FROM_PRS(pcdPortId, prsPortId) \
-    pcdPortId = (prsPortId == 0) ? 0x10:prsPortId;
-
 #define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
     bitMask = 0x80000000>>prsPortId
 
-
 /***********************************************************************/
 /*          Keygen defines                                             */
 /***********************************************************************/
@@ -310,7 +248,7 @@ typedef struct {
 #define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
 #define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
 
-#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000      /* - Full bit replacement. {PBNUM[0:N-1]
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
                                                            1-> 2^N specific locations. */
 #define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
                                                            2-> 2^(N-1) base locations. */
@@ -373,107 +311,6 @@ typedef struct {
 
 #define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
 
-/***********************************************************************/
-/*          Coarse classification defines                              */
-/***********************************************************************/
-
-#define CC_PC_FF_MACDST            0x00
-#define CC_PC_FF_MACSRC            0x01
-#define CC_PC_FF_ETYPE             0x02
-
-#define CC_PC_FF_TCI1              0x03
-#define CC_PC_FF_TCI2              0x04
-
-#define CC_PC_FF_MPLS1             0x06
-#define CC_PC_FF_MPLS_LAST         0x07
-
-#define CC_PC_FF_IPV4DST1          0x08
-#define CC_PC_FF_IPV4DST2          0x16
-#define CC_PC_FF_IPV4IPTOS_TC1     0x09
-#define CC_PC_FF_IPV4IPTOS_TC2     0x17
-#define CC_PC_FF_IPV4PTYPE1        0x0A
-#define CC_PC_FF_IPV4PTYPE2        0x18
-#define CC_PC_FF_IPV4SRC1          0x0b
-#define CC_PC_FF_IPV4SRC2          0x19
-#define CC_PC_FF_IPV4SRC1_IPV4DST1 0x0c
-#define CC_PC_FF_IPV4SRC2_IPV4DST2 0x1a
-#define CC_PC_FF_IPV4TTL           0x29
-
-
-#define CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1    0x0d /*TODO - CLASS - what is it? TOS*/
-#define CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2    0x1b
-#define CC_PC_FF_IPV6PTYPE1                 0x0e
-#define CC_PC_FF_IPV6PTYPE2                 0x1c
-#define CC_PC_FF_IPV6DST1                   0x0f
-#define CC_PC_FF_IPV6DST2                   0x1d
-#define CC_PC_FF_IPV6SRC1                   0x10
-#define CC_PC_FF_IPV6SRC2                   0x1e
-#define CC_PC_FF_IPV6HOP_LIMIT              0x2a
-#define CC_PC_FF_GREPTYPE                   0x11
-
-#define CC_PC_FF_MINENCAP_PTYPE             0x12
-#define CC_PC_FF_MINENCAP_IPDST             0x13
-#define CC_PC_FF_MINENCAP_IPSRC             0x14
-#define CC_PC_FF_MINENCAP_IPSRC_IPDST       0x15
-
-#define CC_PC_FF_L4PSRC                     0x1f
-#define CC_PC_FF_L4PDST                     0x20
-#define CC_PC_FF_L4PSRC_L4PDST              0x21
-
-#define CC_PC_FF_PPPPID                     0x05
-
-
-#define CC_PC_PR_SHIM1                      0x22
-#define CC_PC_PR_SHIM2                      0x23
-#define CC_PC_PR_SHIM3                      0x24
-
-#define CC_PC_GENERIC_WITHOUT_MASK          0x27
-#define CC_PC_GENERIC_WITH_MASK             0x28
-#define CC_PC_GENERIC_IC_GMASK              0x2B
-#define CC_PC_GENERIC_IC_HASH_INDEXED       0x2C
-
-#define CC_PR_OFFSET                        0x25
-#define CC_PR_WITHOUT_OFFSET                0x26
-
-#define CC_PC_PR_ETH_OFFSET                 19
-#define CC_PC_PR_USER_DEFINED_SHIM1_OFFSET  16
-#define CC_PC_PR_USER_DEFINED_SHIM2_OFFSET  17
-#define CC_PC_PR_USER_DEFINED_SHIM3_OFFSET  18
-#define CC_PC_PR_USER_LLC_SNAP_OFFSET       20
-#define CC_PC_PR_VLAN1_OFFSET               21
-#define CC_PC_PR_VLAN2_OFFSET               22
-#define CC_PC_PR_PPPOE_OFFSET               24
-#define CC_PC_PR_MPLS1_OFFSET               25
-#define CC_PC_PR_MPLS_LAST_OFFSET           26
-#define CC_PC_PR_IP1_OFFSET                 27
-#define CC_PC_PR_IP_LAST_OFFSET             28
-#define CC_PC_PR_MINENC_OFFSET              28
-#define CC_PC_PR_L4_OFFSET                  30
-#define CC_PC_PR_GRE_OFFSET                 29
-#define CC_PC_PR_ETYPE_LAST_OFFSET          23
-#define CC_PC_PR_NEXT_HEADER_OFFSET         31
-
-#define CC_PC_ILLEGAL                       0xff
-#define CC_SIZE_ILLEGAL                     0
-
-#define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
-#define FM_PCD_CC_AD_TABLE_ALIGN            256
-#define FM_PCD_CC_AD_ENTRY_SIZE             16
-#define FM_PCD_CC_NUM_OF_KEYS               255
-
-#define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
-#define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
-#define FM_PCD_AD_RESULT_PLCR_DIS           0x20000000
-
-#define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
-#define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
-
-#define FM_PCD_AD_TYPE_MASK                 0xc0000000
-#define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
-
-#define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
-#define CC_GLBL_MASK_SIZE                   4
-
 /****************************/
 /* Defaults                 */
 /****************************/
@@ -482,10 +319,10 @@ typedef struct {
 #define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
 #define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
 #define DEFAULT_fmPcdPlcrExceptions             0
-#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC  |  FM_PCD_EX_PRS_ILLEGAL_ACCESS | FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
+
 #define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
 #define DEFAULT_numOfUsedProfilesPerWindow      16
-#define DEFAULT_fmPcdPrsPortIdStatictics        FM_PCD_PRS_PPSC_ALL_PORTS
 #define DEFAULT_numOfSharedPlcrProfiles         4
 
 /***********************************************************************/
@@ -603,117 +440,43 @@ typedef _Packed struct {
     volatile uint32_t fcscs;
 } _PackedType t_FmPcdPrsRegs;
 
-typedef _Packed struct {
-    volatile uint32_t fqid;
-    volatile uint32_t plcrProfile;
-    volatile uint32_t nia;
-    volatile uint8_t  res[4];
-} _PackedType t_AdOfTypeResult;
-
-typedef _Packed struct {
-    volatile uint32_t ccAdBase;
-    volatile uint32_t matchTblPtr;
-    volatile uint32_t pcAndOffsets;
-    volatile uint32_t gmask;
-} _PackedType t_AdOfTypeContLookup;
-
-typedef _Packed union {
-    volatile t_AdOfTypeResult        adResult;
-    volatile t_AdOfTypeContLookup    adContLookup;
-} _PackedType t_Ad;
-
 #define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
+
 /***********************************************************************/
-/*  Driver's internal structures                                        */
+/*  Driver's internal structures                                       */
 /***********************************************************************/
 
+typedef struct {
+    t_Handle        h_Manip;
+    bool            keepRes;
+    e_FmPcdEngine   nextEngine;
+    uint8_t         parseCode;
+} t_FmPcdInfoForManip;
+
 /**************************************************************************//**
- @Description   Structure for PLCR profile parameters.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
+ @Description   A structure of parameters to communicate
+                between the port and PCD regarding the KG scheme.
 *//***************************************************************************/
-
-#if 0
-typedef struct t_FmPcdPlcrProfileGetParams {
-    uint16_t        relativeProfileId;                  /* IN/OUT: get the user policer profile id.
-                                                   Depending on 'isAbsolute' below, return
-                                                   either the relative or absolute profile */
-
-    bool            isAbsolute;                 /* OUT: Return true if the profile is abosulte else port based */
-    uint8_t         hardwarePortId;             /* OUT: Global port id, must be cleared if called by a
-                                                   non-port (KG, CC). */
-} t_FmPcdPlcrProfileGetParams;
-#endif /* 0 */
-
-typedef struct
-{
-    t_Handle         p_Ad;
-    e_FmPcdEngine    fmPcdEngine;
-    bool             adAllocated;
-    bool             isTree;
-
-//    bool        isCcNextEngine;
-    //uint32_t    nextEngineInfo;
-    uint32_t    myInfo;
-    t_List      *h_CcNextNodesLst;
-    t_Handle    h_AdditionalInfo;
-    t_Handle    h_Node;
-}t_FmPcdModifyCcAdditionalParams;
-
-typedef struct
-{
-    t_Handle p_AdTableNew;
-    t_Handle p_KeysMatchTableNew;
-    t_Handle p_AdTableOld;
-    t_Handle p_KeysMatchTableOld;
-    bool     lclMask;
-    uint16_t  numOfKeys;
-    t_Handle h_CurrentNode;
-    uint16_t nodeIdForAdd;
-    uint16_t keyIndexForRemove;
-    uint16_t keyIndexForAdd;
-}t_FmPcdModifyCcKeyAdditionalParams;
-
 typedef struct {
-    uint16_t    numOfKeys;
-    t_Handle    p_GlblMask;
-    bool        lclMask;
-    uint8_t     parseCode;
-    uint8_t     offset;
-    uint8_t     prsArrayOffset;
-    bool        ctrlFlow;
-    uint16_t    nodeId;
-
-    uint8_t     ccKeySizeAccExtraction;
-    uint8_t     sizeOfExtraction;
-    uint8_t     glblMaskSize;
-
-    t_Handle    h_KeysMatchTable;
-    t_Handle    h_AdTable;
-
-    t_List      ccNextNodesLst;
-    t_List      ccPrevNodesLst;
-
-    t_List      ccTreeIdLst;
-    t_List      ccTreesLst;
-} t_FmPcdCcNode;
+    uint8_t                     netEnvId;    /* in */
+    uint8_t                     numOfDistinctionUnits; /* in */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
+    uint32_t                    vector; /* out */
+} t_NetEnvParams;
 
 typedef struct {
     volatile bool       lock;
     bool                used;
     uint8_t             owners;
     uint8_t             netEnvId;
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t             partitionId;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     uint8_t             baseEntry;
     uint16_t            sizeOfGrp;
-    protocolOpt_t       optArray[FM_PCD_MAX_NUM_OF_OPTIONS];
+    protocolOpt_t       optArray[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
 } t_FmPcdKgClsPlanGrp;
 
 typedef struct {
@@ -727,132 +490,68 @@ typedef struct {
     uint16_t            relativeProfileId;
     uint16_t            numOfProfiles;
     t_FmPcdKgKeyOrder   orderedArray;
+    e_FmPcdEngine       nextEngine;
+    e_FmPcdDoneAction   doneAction;
+    uint8_t             pointedOwners;
+    uint32_t            requiredAction;
+    bool                extractedOrs;
+    uint8_t             bitOffsetInPlcrProfile;
+    bool                directPlcr;
 } t_FmPcdKgScheme;
 
-#ifndef CONFIG_GUEST_PARTITION
-typedef struct
-{
+typedef struct {
     bool    allocated;
     uint8_t ownerId;    /* partitionId for KG in CONFIG_MULTI_PARTITION_SUPPORT only,
                            portId for PLCR in any environment */
 } t_FmPcdAllocMng;
-#endif /* CONFIG_GUEST_PARTITION */
 
 typedef struct {
-#ifndef CONFIG_GUEST_PARTITION
     t_FmPcdKgRegs                   *p_FmPcdKgRegs;
     uint32_t                        schemeExceptionsBitMask;
-#endif
     uint8_t                         numOfSchemes;
     uint8_t                         schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgScheme                 schemes[FM_PCD_KG_NUM_OF_SCHEMES];
-    t_FmPcdKgClsPlanGrp             clsPlanGrps[PCD_MAX_NUM_OF_PORTS];
-    bool                            clsPlanUsedBlocks[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
-    bool                            isDriverEmptyClsPlanGrp;
+    t_FmPcdKgClsPlanGrp             clsPlanGrps[FM_MAX_NUM_OF_PORTS];
     uint8_t                         emptyClsPlanGrpId;
-    uint16_t                        numOfClsPlanEntries;
-    uint8_t                         clsPlanBase;
-
-#ifdef FM_MASTER_PARTITION
-    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES]; /* only for MASTER ! */
     t_FmPcdAllocMng                 clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
-#endif  /* FM_MASTER_PARTITION */
 } t_FmPcdKg;
 
-
 typedef struct {
-    uint16_t profilesBase;
-    uint16_t numOfProfiles;
-    t_Handle h_FmPort;
+    uint16_t            profilesBase;
+    uint16_t            numOfProfiles;
+    t_Handle            h_FmPort;
 } t_FmPcdPlcrMapParam;
 
 typedef struct {
     bool                valid;
     volatile bool       lock;
-#ifndef CONFIG_GUEST_PARTITION
-    t_FmPcdAllocMng     profilesMng;
-#endif /* ! CONFIG_GUEST_PARTITION */
+ 	t_FmPcdAllocMng     profilesMng;
+   	uint8_t             pointedOwners;
+    uint32_t            requiredAction; 
 } t_FmPcdPlcrProfile;
 
 typedef struct {
-#ifndef CONFIG_GUEST_PARTITION
     t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
-#endif /* ! CONFIG_GUEST_PARTITION */
     t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
     uint16_t                        numOfSharedProfiles;
     uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
-    t_FmPcdPlcrMapParam             portsMapping[PCD_MAX_NUM_OF_PORTS];
+    t_FmPcdPlcrMapParam             portsMapping[FM_MAX_NUM_OF_PORTS];
 } t_FmPcdPlcr;
 
 typedef struct {
-#ifndef CONFIG_GUEST_PARTITION
     uint32_t                        *p_SwPrsCode;
     uint32_t                        *p_CurrSwPrs;
     uint8_t                         currLabel;
     t_FmPcdPrsRegs                  *p_FmPcdPrsRegs;
-#endif /* ! CONFIG_GUEST_PARTITION */
     t_FmPcdPrsLabelParams           labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
     uint32_t                        fmPcdPrsPortIdStatistics;
 } t_FmPcdPrs;
 
 typedef struct {
-    t_FmPcdCcNode   *p_FmPcdCcNode;
-    bool            occupied;
-    uint8_t         owners;
-    volatile bool   lock;
-} t_FmPcdCcNodeArray;
-
-typedef struct {
-    uint32_t indexInGroupParam;
-} t_FmPcdCcGroupAdditionalParam;
-
-typedef struct {
-    uint8_t     numOfEntriesInGroup;
-    uint32_t    totalBitsMask;
-    uint8_t     baseGroupEntry;
-} t_FmPcdCcGroupParam;
-
-typedef struct {
-    uint8_t             netEnvId;
-    uint64_t            ccTreeBaseAddr;
-    uint8_t             numOfGrps;
-    t_FmPcdCcGroupParam fmPcdGroupParam[8];
-    t_List              ccNextNodesLst;
-    t_List              fmPortsLst;
-    uint8_t             treeId;
-    volatile bool       lock;
-} t_FmPcdCcTree;
-
-#if 0
-typedef struct {
-    uint32_t nextCcNodeInfo;
-    t_List   h_Node;
-} t_CcNodeInfo;
-#endif /* 0 */
-
-typedef struct {
-   e_FmPcdEngine  fmPcdEngine;
-   uint32_t       additionalInfo;
-} t_NextEngineParamsInfo;
-
-typedef struct {
-    t_FmPcdCcTree   *p_FmPcdCcTree;
-    bool            occupied;
-    uint8_t         owners;
-    volatile bool   lock;
-} t_FmPcdCcTreeArray;
-
-typedef struct {
-    t_Handle               h_FmMuram;
-    t_FmPcdCcNodeArray     ccNodeArrayEntry[FM_PCD_MAX_NUM_OF_CC_NODES];
-    t_FmPcdCcTreeArray     ccTreeArrayEntry[FM_PCD_MAX_NUM_OF_CC_TREES];
-    uint64_t               physicalMuramBase;
-} t_FmPcdCc;
-
-typedef struct {
     struct {
-        e_NetHeaderType    hdr;
-        protocolOpt_t      opt;        /* only one option !! */
+        e_NetHeaderType             hdr;
+        protocolOpt_t               opt; /* only one option !! */
     } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
 } t_FmPcdIntDistinctionUnit;
 
@@ -860,9 +559,11 @@ typedef struct {
     volatile bool               lock;
     bool                        used;
     uint8_t                     owners;
+    uint8_t                     clsPlanGrpId;
     t_FmPcdIntDistinctionUnit   units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
     uint32_t                    unitsVectors[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
     uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint32_t                    macsecVector;
 } t_FmPcdNetEnv;
 
 typedef struct {
@@ -873,30 +574,27 @@ typedef struct {
 
 typedef struct {
     t_Handle                    h_Fm;
+    t_Handle                    h_FmMuram;
+    uint64_t                    physicalMuramBase;
     volatile bool               lock;
+    t_Handle                    h_Spinlock;
     bool                        enabled;
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t                     partitionId;            /**< Guest Partition Id */
-#ifdef FM_MASTER_PARTITION
     uint8_t                     numOfEnabledGuestPartitionsPcds;
-#endif /* FM_MASTER_PARTITION */
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     char                        fmPcdModuleName[MODULE_NAME_SIZE];
 
-    t_FmPcdNetEnv               netEnvs[PCD_MAX_NUM_OF_PORTS+1]; /* +1 for the private netenv used for clsPlan */
+    t_FmPcdNetEnv               netEnvs[FM_MAX_NUM_OF_PORTS];
     t_FmPcdKg                   *p_FmPcdKg;
     t_FmPcdPlcr                 *p_FmPcdPlcr;
     t_FmPcdPrs                  *p_FmPcdPrs;
-    t_FmPcdCc                   *p_FmPcdCc;
+    t_Handle                    h_FmPcdCc;
 
     t_Handle                    h_Hc;
 
-#ifndef CONFIG_GUEST_PARTITION
     uint32_t                    exceptions;
     t_FmPcdExceptionCallback    *f_Exception;
     t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
-#endif /* !CONFIG_GUEST_PARTITION */
 
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
 } t_FmPcd;
@@ -905,16 +603,6 @@ typedef struct {
 /***********************************************************************/
 /*  PCD internal routines                                              */
 /***********************************************************************/
-/**************************************************************************//**
- @Description   A structure of parameters to communicate
-                between the port and PCD regarding the KG scheme.
-*//***************************************************************************/
-typedef struct {
-    uint8_t                     netEnvId;    /* in */
-    uint8_t                     numOfDistinctionUnits; /* in */
-    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
-    uint32_t                    vector; /* out */
-} t_NetEnvParams;
 
 /**************************************************************************//**
 
@@ -930,9 +618,11 @@ typedef struct {
  @{
 *//***************************************************************************/
 
-t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
 t_Error     PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector);
+t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
 bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector);
+t_Error     PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_GrpParams);
+void        FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId);
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     KgInit(t_FmPcd *p_FmPcd);
@@ -941,15 +631,14 @@ void        KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set
 bool        KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId);
 t_Error     KgEnable(t_FmPcd *p_FmPcd);
 t_Error     KgDisable(t_FmPcd *p_FmPcd);
+t_Error     KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First);
+t_Error     KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base);
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+/* only for MULTI partittion */
 t_Error     FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
 t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
-t_Error     FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First);
-t_Error     FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base);
-#else /* single */
+/* only for SINGLE partittion */
 t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     PlcrInit(t_FmPcd *p_FmPcd);
@@ -966,10 +655,35 @@ t_Error     PrsInit(t_FmPcd *p_FmPcd);
 t_Error     PrsEnable(t_FmPcd *p_FmPcd);
 t_Error     PrsDisable(t_FmPcd *p_FmPcd);
 void        PrsFree(t_FmPcd *p_FmPcd );
+t_Error     PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include);
+
+t_Handle    FmPcdCcConfig(t_Handle h_FmPcd, t_FmPcdParams *p_FmPcdParams);
+void        FmPcdCcFree(t_Handle h_FmPcdCc);
+t_Error     FmPcdCcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
+uint8_t FmPcdCcGetOffset(t_Handle h_CcNode);
+uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode);
+
+void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
+t_Error     FmPcdManipCheckParamsForCc(t_FmPcdCcNextEngineParams *p_InfoForManip);
+void        FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew);
+void        FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset);
+uint32_t    FmPcdManipCheckNia(t_Handle h_FmPcd, t_Handle h_Ad);
+void        FmManipUpdateOwner(t_Handle h_Manip, bool add);
+
 
-t_Handle    CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
-void        CcFree(t_FmPcdCc *p_FmPcdCc);
-t_Error     CcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
+static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    ASSERT_COND(p_FmPcd);
+    return p_FmPcd->h_FmMuram;
+}
+
+static __inline__ uint64_t FmPcdGetMuramPhysBase(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    ASSERT_COND(p_FmPcd);
+    return p_FmPcd->physicalMuramBase;
+}
 
 
 #endif /* __FM_PCD_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 58d0380..44d2ca9 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -48,7 +48,7 @@
 
  @{
 *//***************************************************************************/
-
+#if 0
 /**************************************************************************//**
  @Group         FM_PCD_IPC_grp FM PCD Inter-Partition messaging Unit
 
@@ -71,6 +71,12 @@ typedef uint32_t fmPcdIpcEngines_t; /**< options as defined below: */
 #define FM_PCD_IPC_CC                   0x20000000          /**< Coarse classification indicated */
 #define FM_PCD_IPC_PLCR                 0x10000000          /**< Policer indicated */
 /* @} */
+#endif
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
 
 
 /**************************************************************************//**
@@ -79,15 +85,15 @@ typedef uint32_t fmPcdIpcEngines_t; /**< options as defined below: */
                 by the FM module.
                 Fields commented 'OUT' will be filled by FM before returning to port.
 *//***************************************************************************/
-typedef struct
+typedef _Packed struct t_FmPcdIpcSwPrsLable
 {
-    e_NetHeaderType         hdr;                            /**< IN. The existance of this header will envoke
-                                                                 the sw parser code. */
-    uint8_t                 indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
-                                                                 attachments for the same header, use this
-                                                                 index to distinguish between them. */
-    uint32_t                offset;                         /**< OUT. MURAM offset for the labeled code. */
-}t_FmPcdIpcSwPrsLable;
+    uint32_t    enumHdr;                        /**< IN. The existance of this header will envoke
+                                                     the sw parser code. */
+    uint8_t     indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
+                                                     attachments for the same header, use this
+                                                     index to distinguish between them. */
+    uint32_t    offset;                         /**< OUT. MURAM offset for the labeled code. */
+} _PackedType t_FmPcdIpcSwPrsLable;
 
 
 /**************************************************************************//**
@@ -98,44 +104,51 @@ typedef struct
                 Some fields are optional (depending on configuration) and
                 will be analized by the port and FM modules accordingly.
 *//***************************************************************************/
-typedef struct
+typedef  struct t_FmPcdIpcKgSchemesParams
 {
     uint8_t     partitionId;                                /**< IN */
     uint8_t     numOfSchemes;                               /**< IN */
-    uint8_t     schemesIds[FM_PCD_IPC_KG_NUM_OF_SCHEMES];   /**< OUT */
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];       /**< OUT */
+} _PackedType t_FmPcdIpcKgSchemesParams;
+
+typedef  struct t_FmPcdIpcKgClsPlanParams
+{
+    uint8_t     partitionId;                                /**< IN */
     uint16_t    numOfClsPlanEntries;                        /**< IN */
-    uint8_t     clsPlanBase;                                /**< OUT */
-    bool        isDriverClsPlanGrp;                         /**< IN */
-} t_FmPcdIpcKgAllocParams;
+    uint8_t     clsPlanBase;                                /**< IN in alloc/OUT in free */
+} _PackedType t_FmPcdIpcKgClsPlanParams;
 
-typedef struct
+typedef _Packed struct t_FmPcdIpcPlcrAllocParams
 {
     uint16_t num;
     uint8_t  hardwarePortId;
     uint16_t plcrProfilesBase;
-} t_FmPcdIpcPlcrAllocParams;
+} _PackedType t_FmPcdIpcPlcrAllocParams;
 
-typedef struct
+typedef _Packed struct t_FmPcdIpcSharedPlcrAllocParams
 {
-    uint16_t    num;                                    /**< IN */
-    uint16_t    profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
-} t_FmPcdIpcSharedPlcrAllocParams;
+    uint16_t  num;                                    /**< IN */
+    uint16_t  profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
+} _PackedType t_FmPcdIpcSharedPlcrAllocParams;
 
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
+typedef _Packed struct t_FmPcdIpcGetCounter
+{
+    uint32_t  enumId;     /* IN */
+    uint32_t  val;        /* OUT */
+} _PackedType t_FmPcdIpcGetCounter;
 
-typedef _Packed struct t_FmPcdIcPhysAddr {
-    volatile uint8_t  high;
-    volatile uint32_t low;
-} _PackedType t_FmPcdIcPhysAddr;
+typedef _Packed struct t_FmPcdIpcPrsIncludePort
+{
+    uint8_t hardwarePortId;     /* IN */
+    bool    include;            /* IN */
+} _PackedType t_FmPcdIpcPrsIncludePort;
 
 #define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
+#if 0
 /**************************************************************************//**
  @Function      FM_PCD_GET_SET_PORT_PARAMS
 
@@ -145,8 +158,7 @@ typedef _Packed struct t_FmPcdIcPhysAddr {
  @Param[in/out] t_FmPcdIcPortInitParams
 
 *//***************************************************************************/
-#define FM_PCD_GET_SET_PORT_PARAMS              20
-
+#define FM_PCD_GET_SET_PORT_PARAMS              1
 /**************************************************************************//**
  @Function      FM_PCD_CLEAR_PORT_PARAMS
 
@@ -155,59 +167,211 @@ typedef _Packed struct t_FmPcdIcPhysAddr {
  @Param[in/out] t_FmPcdIcPortInitParams
 
 *//***************************************************************************/
-#define FM_PCD_CLEAR_PORT_PARAMS                21
+#define FM_PCD_CLEAR_PORT_PARAMS                2
+#endif
 
-#define FM_PCD_ALLOC_KG_RSRC                    22
-#define FM_PCD_FREE_KG_RSRC                     23
-#define FM_PCD_ALLOC_PROFILES                   24
-#define FM_PCD_FREE_PROFILES                    25
-#define FM_PCD_GET_PHYS_MURAM_BASE              26
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_KG_SCHEMES
+
+ @Description   Used by FM PCD front-end in order to allocate KG resources
+
+ @Param[in/out] t_FmPcdIpcKgAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_KG_SCHEMES                 3
 
 /**************************************************************************//**
- @Function      FM_PCD_GET_SW_PRS_OFFSET
+ @Function      FM_PCD_FREE_KG_SCHEMES
+
+ @Description   Used by FM PCD front-end in order to Free KG resources
+
+ @Param[in/out] t_FmPcdIpcKgSchemesParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_SCHEMES                  4
 
- @Description   Used by FM PORT module to get the SW parser offset of the start of
-                code relevant to a given label..
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_PROFILES
 
- @Param[in/out] t_FmPcdIcSwPrsLable
+ @Description   Used by FM PCD front-end in order to allocate Policer profiles
 
+ @Param[in/out] t_FmPcdIpcKgSchemesParams Pointer
 *//***************************************************************************/
-#define FM_PCD_GET_SW_PRS_OFFSET                27
+#define FM_PCD_ALLOC_PROFILES                   5
 
-#define FM_PCD_ALLOC_SHARED_PROFILES            28
-#define FM_PCD_FREE_SHARED_PROFILES             29
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_PROFILES
+
+ @Description   Used by FM PCD front-end in order to Free Policer profiles
+
+ @Param[in/out] t_FmPcdIpcPlcrAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_PROFILES                    6
 
 /**************************************************************************//**
- @Function      FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS
+ @Function      FM_PCD_GET_PHYS_MURAM_BASE
+
+ @Description   Used by FM PCD front-end in order to get MURAM base address
 
- @Description   Used by FM HC module to get and set keygen scheme parameters
+ @Param[in/out] t_FmPcdIcPhysAddr Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_PHYS_MURAM_BASE              7
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SW_PRS_OFFSET
+
+ @Description   Used by FM front-end to get the SW parser offset of the start of
+                code relevant to a given label.
+
+ @Param[in/out] t_FmPcdIpcSwPrsLable Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_SW_PRS_OFFSET                8
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_SHARED_PROFILES
 
- @Param[in/out] t_FmPcdIcKgSchemeParams
+ @Description   Used by FM PCD front-end in order to allocate shared profiles
 
+ @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
 *//***************************************************************************/
-#define FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS      30
+#define FM_PCD_ALLOC_SHARED_PROFILES            9
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_SHARED_PROFILES
+
+ @Description   Used by FM PCD front-end in order to free shared profiles
+
+ @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_SHARED_PROFILES             10
 
 /**************************************************************************//**
  @Function      FM_PCD_FREE_KG_SCHEME_HC
 
- @Description   Used by FM HC  module in order to update owners counter
+ @Description   Used by FM HC module in order to update owners counter
                 if PCD Network environment.
 
- @Param[in]     scheme id
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_SCHEME_HC                12
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP
+
+ @Description   Used by FM front-end in order to allocate an
+                empty classification plan group.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP         14
+
+/**************************************************************************//**
+ @Function      FM_PCD_MASTER_IS_ENABLED
+
+ @Description   Used by FM front-end in order to verify
+                PCD enablement.
+
+ @Param[in]     bool Pointer
+*//***************************************************************************/
+#define FM_PCD_MASTER_IS_ENABLED                15
+
+/**************************************************************************//**
+ @Function      FM_PCD_GUEST_DISABLE
+
+ @Description   Used by FM front-end to inform back-end when
+                front-end PCD is disabled
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_GUEST_DISABLE                    16
+
+/**************************************************************************//**
+ @Function      FM_PCD_DUMP_REGS
+
+ @Description   Used by FM front-end to dump all PCD registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_DUMP_REGS                        17
+
+/**************************************************************************//**
+ @Function      FM_PCD_KG_DUMP_REGS
+
+ @Description   Used by FM front-end to dump KG registers
 
+ @Param[in]     None
 *//***************************************************************************/
-#define FM_PCD_FREE_KG_SCHEME_HC                31
+#define FM_PCD_KG_DUMP_REGS                     18
 
-#define FM_PCD_MASTER_IS_ALIVE                  32
+/**************************************************************************//**
+ @Function      FM_PCD_PLCR_DUMP_REGS
 
-#define FM_PCD_FREE_PLCR_PROFILE_HC             33
+ @Description   Used by FM front-end to dump PLCR registers
 
-#define FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP         34
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_PLCR_DUMP_REGS                   19
 
-#define FM_PCD_MASTER_IS_ENABLED                35
+/**************************************************************************//**
+ @Function      FM_PCD_PLCR_PROFILE_DUMP_REGS
 
-#define FM_PCD_GUEST_DISABLE                    36
+ @Description   Used by FM front-end to dump PLCR specified profile registers
 
+ @Param[in]     t_Handle Pointer
+*//***************************************************************************/
+#define FM_PCD_PLCR_PROFILE_DUMP_REGS           20
+
+/**************************************************************************//**
+ @Function      FM_PCD_PRS_DUMP_REGS
+
+ @Description   Used by FM front-end to dump PRS registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_PRS_DUMP_REGS                    21
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_KG_CLSPLAN
+
+ @Description   Used by FM PCD front-end in order to Free KG classification plan entries
+
+ @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_CLSPLAN                     22
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_KG_CLSPLAN
+
+ @Description   Used by FM PCD front-end in order to allocate KG classification plan entries
+
+ @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_KG_CLSPLAN                    23
+
+/**************************************************************************//**
+ @Function      FM_PCD_MASTER_IS_ALIVE
+
+ @Description   Used by FM front-end to check that back-end exists
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_MASTER_IS_ALIVE                  24
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_COUNTER
+
+ @Description   Used by FM front-end to read PCD counters
+
+ @Param[in/out] t_FmPcdIpcGetCounter Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_COUNTER                      25
+
+/**************************************************************************//**
+ @Function      FM_PCD_PRS_INC_PORT_STATS
+
+ @Description   Used by FM front-end to set/clear statistics for port
+
+ @Param[in/out] t_FmPcdIpcPrsIncludePort Pointer
+*//***************************************************************************/
+#define FM_PCD_PRS_INC_PORT_STATS               26
 /** @} */ /* end of FM_PCD_IPC_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 5c5c334..7faa3c9 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -41,8 +41,11 @@
 #include "debug_ext.h"
 #include "net_ext.h"
 #include "fm_ext.h"
+
+#include "fm_common.h"
 #include "fm_pcd.h"
 #include "fm_hc.h"
+#include "fm_pcd_ipc.h"
 
 
 static bool FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
@@ -71,10 +74,10 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
         case e_FM_PCD_DONE :
             switch (p_NextEngineParams->action)
             {
-                case e_FM_PCD_PLCR_DROP_FRAME :
+                case e_FM_PCD_DROP_FRAME :
                     nia |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
                     break;
-                case e_FM_PCD_PLCR_ENQ_FRAME:
+                case e_FM_PCD_ENQ_FRAME:
                     nia |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
                     break;
                 default:
@@ -115,6 +118,7 @@ static uint32_t FPP_Function(uint32_t fpp)
     else
         return 16 + fpp;
 }
+
 static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
                                 uint32_t rate,
                                 uint64_t tsuInTenthNano,
@@ -153,47 +157,6 @@ static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
      * this value as fraction - see spec.
      */
     *p_Fraction = (((tmp<<fppShift)<<16) - ((*p_Integer<<16)*div))/div;
-
-}
-static void CheckValidRateRange(t_FmPcd *p_FmPcd)
-{
-    //uint64_t    timeStampPeriod;
-//    uint64_t    maxVal = 0xffffffff0000LL; /* [bytes per timeStamp unit] max value which will be legal  for fpp adjustement calculation - for not being "too big"*/
-    //uint32_t    minVal = 0x00010000;     /*  [bytes per timeStamp unit] min value which will be legal  for fpp adjustement calculation - for not being "too small"*/
-//    uint64_t    tempMaxLimit;
-//    uint64_t    tempMinLimit;
-    /*TODO */
-#if 0
-   timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
-
-    /*With current timestamp configuration there can not be a MaxLimit,
-      which means that any rate above MinLimit can be served by Policer*/
-    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
-    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
-    //tempMaxLimit = tempMaxLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
-    //tempMaxLimit = tempMaxLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
-    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
-
-    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
-    tempMinLimit = minVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
-    tempMinLimit = tempMinLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
-    tempMinLimit = tempMinLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
-    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
-
-    XX_Print("Valid range for ByteMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
-
-    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
-    //tempMaxLimit = maxVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
-    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 0 (number of shifts done to fpp)*/
-
-    tempMinLimit = minVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
-    tempMinLimit = minVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
-    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
-
-    XX_Print("Valid range for PacketMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
-#else
-    UNUSED(p_FmPcd);
-#endif /* 0 */
 }
 
 /* .......... */
@@ -238,7 +201,6 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
         if(fppShift > 15)
         {
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
-            CheckValidRateRange(p_FmPcd);
             return;
         }
     }
@@ -281,27 +243,26 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
 
 }
 
-#ifndef CONFIG_GUEST_PARTITION
 static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
 {
     t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
 
     while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
 
 }
-#endif /* CONFIG_GUEST_PARTITION */
 
 /*********************************************/
 /*............Policer Exception..............*/
 /*********************************************/
-#ifndef CONFIG_GUEST_PARTITION
 static void PcdPlcrException(t_Handle h_FmPcd)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t event, mask;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
     mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
 
@@ -326,6 +287,7 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
     t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t            event, captureReg, mask;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
     mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
 
@@ -351,38 +313,39 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
     }
 }
 
-#endif /* !CONFIG_GUEST_PARTITION */
-
 t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-#endif /* CONFIG_GUEST_PARTITION */
     t_Error                     err = E_OK;
     uint16_t                    base;
-    uint16_t                    pcdPortId;
+    uint16_t                    swPortIndex = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-#ifdef CONFIG_GUEST_PARTITION
-    /* Alloc resources using IPC messaging */
-    ipcPlcrParams.num = numOfProfiles;
-    ipcPlcrParams.hardwarePortId = hardwarePortId;
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-    base = ipcPlcrParams.plcrProfilesBase;
-#else /* master */
-    err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-#endif /* CONFIG_GUEST_PARTITION */
+    if(!numOfProfiles)
+        return E_OK;
 
-    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+    {
+        /* Alloc resources using IPC messaging */
+        ipcPlcrParams.num = numOfProfiles;
+        ipcPlcrParams.hardwarePortId = hardwarePortId;
+        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+        base = ipcPlcrParams.plcrProfilesBase;
+    }
+    else /* master */
+    {
+        err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = numOfProfiles;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = base;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
 
     return E_OK;
 }
@@ -390,35 +353,34 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
 t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-#endif /* CONFIG_GUEST_PARTITION */
     t_Error                     err = E_OK;
-    uint16_t                    pcdPortId;
+    uint16_t                    swPortIndex = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-#ifdef CONFIG_GUEST_PARTITION
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+    {
     /* Alloc resources using IPC messaging */
-    ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+    ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
     ipcPlcrParams.hardwarePortId = hardwarePortId;
-    ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+    ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
     err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
     if(err)
         RETURN_ERROR(MAJOR, err,NO_MSG);
-#else /* master */
-    err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-#endif /* CONFIG_GUEST_PARTITION */
-
-    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = 0;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = 0;
+    }
+    else /* master */
+    {
+        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
 
     return E_OK;
-
 }
 
 bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
@@ -430,15 +392,19 @@ bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 }
 
 
-#ifndef CONFIG_GUEST_PARTITION
 t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
 {
     t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     uint32_t        profilesFound, log2Num, tmpReg32;
+    uint32_t        intFlags;
     uint16_t        first, i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if(!numOfProfiles)
+        return E_OK;
+
     ASSERT_COND(hardwarePortId);
 
     if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
@@ -447,11 +413,11 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
     if (!POWER_OF_2(numOfProfiles))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
-    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    intFlags = FmPcdLock(p_FmPcd);
 
     if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
     {
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
     }
 
@@ -461,7 +427,7 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
     {
         if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
         {
-            profilesFound++;
+            profilesFound++; 
             i++;
             if(profilesFound == numOfProfiles)
                 break;
@@ -483,7 +449,7 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
     }
     else
     {
-        RELEASE_LOCK(p_FmPcd->lock);
+        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
@@ -497,10 +463,9 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
 
     *p_Base = first;
 
-    RELEASE_LOCK(p_FmPcd->lock);
+    FmPcdUnlock(p_FmPcd, intFlags);
 
     return E_OK;
-
 }
 
 t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
@@ -510,6 +475,10 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if(!numOfProfiles)
+        return E_OK;
+
     if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
@@ -534,7 +503,6 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
     }
 
     return E_OK;
-
 }
 
 t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
@@ -545,6 +513,7 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
 #if 0 //- default
         else
         {
@@ -571,8 +540,8 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
         p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
         p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
     }
-    return E_OK;
 
+    return E_OK;
 }
 
 void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
@@ -581,6 +550,7 @@ void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     for(i=0;i<numOfProfiles; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
@@ -588,7 +558,62 @@ void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t
     }
 }
 
-#endif /* ! CONFIG_GUEST_PARTITION */
+t_Error PlcrEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+
+t_Error PlcrDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   uint32_t tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
+
+    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
+    if(enable)
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    else
+        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
+
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
+
+    return E_OK;
+}
+
 
 t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
 {
@@ -817,12 +842,9 @@ t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
 
-#ifndef CONFIG_GUEST_PARTITION
     p_FmPcdPlcr->p_FmPcdPlcrRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPlcrRegs , (FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm)));
     p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
     p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
-#endif /* !CONFIG_GUEST_PARTITION */
-
     p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
 
     return p_FmPcdPlcr;
@@ -834,129 +856,111 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     t_FmPcdPlcr                 *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
     uint32_t                    tmpReg32 = 0;
     t_Error                     err = E_OK;
-#ifndef CONFIG_GUEST_PARTITION
     t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-#else
     t_FmPcdIpcSharedPlcrAllocParams    ipcSharedPlcrParams;
-#endif /* !CONFIG_GUEST_PARTITION */
 
-#ifdef CONFIG_GUEST_PARTITION
-    /* Alloc resources using IPC messaging */
-    ipcSharedPlcrParams.num = p_FmPcdPlcr->numOfSharedProfiles;
-    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-    memcpy(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds,ipcSharedPlcrParams.profilesIds, sizeof(uint16_t)*ipcSharedPlcrParams.num);
-#else /* master */
-    err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-#endif /* CONFIG_GUEST_PARTITION */
-
-#ifndef CONFIG_GUEST_PARTITION
-
-    /**********************FMPL_GCR******************/
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
-    if(p_Param->plcrAutoRefresh)
-        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
-    tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
-
-    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
-    /**********************FMPL_GCR******************/
-
-    /**********************FMPL_EEVR******************/
-    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
-    /**********************FMPL_EEVR******************/
-    /**********************FMPL_EIER******************/
-    tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+    if(p_FmPcdPlcr->numOfSharedProfiles)
     {
-        FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+        if(!FmIsMaster(p_FmPcd->h_Fm))
+        {
+            /* Alloc resources using IPC messaging */
+            ipcSharedPlcrParams.num = p_FmPcdPlcr->numOfSharedProfiles;
+            err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+            if(err)
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+            memcpy(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds,ipcSharedPlcrParams.profilesIds, sizeof(uint16_t)*ipcSharedPlcrParams.num);
+        }
+        else /* master */
+        {
+            err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+            if(err)
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+        }
+    }
+
+    if(FmIsMaster(p_FmPcd->h_Fm))
+    {
+        /**********************FMPL_GCR******************/
+        tmpReg32 = 0;
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+        if(p_Param->plcrAutoRefresh)
+            tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
+        tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+
+        WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
+        /**********************FMPL_GCR******************/
+
+        /**********************FMPL_EEVR******************/
+        WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
+        /**********************FMPL_EEVR******************/
+        /**********************FMPL_EIER******************/
+        tmpReg32 = 0;
+        if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+        {
+            FmEnableRamsEcc(p_FmPcd->h_Fm);
+            tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+        }
+        if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+            tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+        WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
+        /**********************FMPL_EIER******************/
+
+        /**********************FMPL_EVR******************/
+        WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
+        /**********************FMPL_EVR******************/
+        /**********************FMPL_IER******************/
+        tmpReg32 = 0;
+        if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+            tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+        if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+            tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+        WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
+        /**********************FMPL_IER******************/
+
+        /* register even if no interrupts enabled, to allow future enablement */
+        FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, PcdPlcrErrorException, p_FmPcd);
+        FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, PcdPlcrException, p_FmPcd);
+
+        /* driver initializes one DFLT profile at the last entry*/
+        /**********************FMPL_DPMR******************/
+        tmpReg32 = 0;//FM_PCD_PLCR_NUM_ENTRIES-1;
+        WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+        p_FmPcd->p_FmPcdPlcr->profiles[0].profilesMng.allocated = TRUE;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
-        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
-    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
-    /**********************FMPL_EIER******************/
-
-    /**********************FMPL_EVR******************/
-    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
-    /**********************FMPL_EVR******************/
-    /**********************FMPL_IER******************/
-    tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
-        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
-        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
-    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
-    /**********************FMPL_IER******************/
-
-    /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, PcdPlcrErrorException, p_FmPcd);
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, PcdPlcrException, p_FmPcd);
-
-    /* driver initializes one DFLT profile at the last entry*/
-    p_FmPcd->p_FmPcdPlcr->profiles[FM_PCD_PLCR_NUM_ENTRIES-1].profilesMng.allocated = TRUE;
-
-    /**********************FMPL_DPMR******************/
-    tmpReg32 = FM_PCD_PLCR_NUM_ENTRIES-1;
-    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
-
-#endif /* CONFIG_GUEST_PARTITION */
+
     return E_OK;
 }
 
 t_Error PlcrFree(t_FmPcd *p_FmPcd)
 {
-#ifdef CONFIG_GUEST_PARTITION
     t_Error err;
-#endif /* CONFIG_GUEST_PARTITION */
+    t_FmPcdIpcSharedPlcrAllocParams    ipcSharedPlcrParams;
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
 
     if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
-#ifdef CONFIG_GUEST_PARTITION
     {
-        /* Alloc resources using IPC messaging */
-        ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
-        memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
-        err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
-        if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
+        if(!FmIsMaster(p_FmPcd->h_Fm))
+        {
+            /* Alloc resources using IPC messaging */
+            ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+            memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+            err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+            if(err)
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+        }
+        else
+            PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
     }
-#else /* master */
-        PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
-#endif /* CONFIG_GUEST_PARTITION */
-    return E_OK;
-}
-
-#ifndef CONFIG_GUEST_PARTITION
-t_Error PlcrEnable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-
-    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
-
-    return E_OK;
-}
-
-t_Error PlcrDisable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-
-    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
-
     return E_OK;
 }
-#endif /* CONFIG_GUEST_PARTITION */
 
-t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
-                                e_FmPcdProfileTypeSelection profileType,
-                                t_Handle  h_FmPort,
-                                uint16_t relativeProfile,
-                                uint16_t *p_AbsoluteId)
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+                                          e_FmPcdProfileTypeSelection   profileType,
+                                          t_Handle                      h_FmPort,
+                                          uint16_t                      relativeProfile,
+                                          uint16_t                      *p_AbsoluteId)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
@@ -966,10 +970,10 @@ t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
     {
         case e_FM_PCD_PLCR_PORT_PRIVATE:
             /* get port PCD id from port handle */
-            for(i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+            for(i=0;i<FM_MAX_NUM_OF_PORTS;i++)
                 if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
                     break;
-            if (i ==  PCD_MAX_NUM_OF_PORTS)
+            if (i ==  FM_MAX_NUM_OF_PORTS)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
 
             if(!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
@@ -992,21 +996,21 @@ t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
 uint16_t FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint16_t        pcdPortId;
+    uint16_t        swPortIndex = 0;
 
-    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
 }
 
 uint16_t FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint16_t        pcdPortId;
+    uint16_t        swPortIndex = 0;
 
-    SET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
 
 }
 uint32_t FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId)
@@ -1056,14 +1060,20 @@ uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
        default:
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             return 0;
-
     }
 }
 
-t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId)
+t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr)
 {
-    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
-    return E_OK;
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    bool            ans;
+    if (intr)
+        ans = TRY_LOCK(NULL, p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
+    else
+        ans = TRY_LOCK(p_FmPcd->h_Spinlock, p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
+    if (ans)
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
 }
 
 void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId)
@@ -1079,31 +1089,21 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
                               t_FmPcdPlcrProfileParams *p_Profile)
 {
     t_FmPcd                             *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     t_FmPcdPlcr                         *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
     t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
     t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
+    uint32_t                            intFlags;
     uint16_t                            absoluteProfileId;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg32;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-        return NULL;
-    }
-
-#else
     SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
 
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
 
     if (p_Profile->modify)
     {
@@ -1113,11 +1113,12 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
             return NULL;
         }
-        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+        if (FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, FALSE))
+            return NULL;
     }
     else
     {
-        TRY_LOCK_RET_NULL(p_FmPcd->lock);
+        intFlags = FmPcdLock(p_FmPcd);
         err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,
                                             p_Profile->id.newParams.profileType,
                                             p_Profile->id.newParams.h_FmPort,
@@ -1130,13 +1131,14 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
         }
         if(err)
         {
-            RELEASE_LOCK(p_FmPcd->lock);
+            FmPcdUnlock(p_FmPcd, intFlags);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
-        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
-
-        RELEASE_LOCK(p_FmPcd->lock);
+        err = FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, TRUE);
+        FmPcdUnlock(p_FmPcd, intFlags);
+        if (err)
+            return NULL;
     }
 
     /* if no override, check first that this scheme is unused */
@@ -1189,29 +1191,21 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
     RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
 
     return CAST_UINT32_TO_POINTER((uint32_t)absoluteProfileId+1);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
     uint32_t        tmpReg32;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((profileIndx <= FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
-    SANITY_CHECK_RETURN_ERROR((profileIndx <= FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
 
     FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
 
@@ -1221,7 +1215,6 @@ t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
     WritePar(p_FmPcd, tmpReg32);
 
     return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 /* ......... */
@@ -1231,24 +1224,17 @@ t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
 uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
     t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE,0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE,0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE,0);
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdPlcrGetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
-    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE,0);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE,0);
 
     if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
     {
@@ -1258,7 +1244,7 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
 
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
-    if (!(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode) & FM_PCD_PLCR_PEMODE_PI))
+    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
         return 0;
@@ -1268,50 +1254,115 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
     {
         case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
             return (GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc));
-            break;
         case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
             return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc);
-            break;
         case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
             return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc);
-            break;
         case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
             return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc);
-            break;
         case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
             return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc);
-            break;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            return 0;
+            break;
     }
 
     return 0;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
+#ifdef FM_MANIP_SUPPORT
+t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
+{
+    t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32;
+
+    /* TODO - complete for HC!!! */
+    if (p_FmPcd->h_Hc)
+        DBG(WARNING, ("HC NOT_SUPPORTED applying in sw!"));
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return 0;
+    }
+
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
+        return 0;
+    }
+    
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].valid);
+    
+    if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners && 
+       !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This policer profile was assigned before with different action"));
+    else if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners &&
+           p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction)
+    {
+        p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners += 1;
+        return E_OK;
+    }
+    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners += 1;
+    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction = requiredAction;
+    if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+    {
+        
+            
+            tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
+            if(!(tmpReg32 & NIA_ENG_BMI))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,("In this case allowed next engine is BMI"));
+            tmpReg32 |= NIA_BMI_AC_WITHOUT_DMA;
+            WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia, tmpReg32);
+            tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+            tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
+            WritePar(p_FmPcd, tmpReg32);
+            
+            
+            tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
+            if(!(tmpReg32 & NIA_ENG_BMI))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,("In this case allowed next engine is BMI"));
+            tmpReg32 |= NIA_BMI_AC_WITHOUT_DMA;
+            WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia, tmpReg32);
+            tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+            tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
+            WritePar(p_FmPcd, tmpReg32);
+     
+            tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
+            if(!(tmpReg32 & NIA_ENG_BMI))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,("In this case allowed next engine is BMI"));
+            tmpReg32 |= NIA_BMI_AC_WITHOUT_DMA;
+            WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia, tmpReg32);
+            tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+            tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
+            WritePar(p_FmPcd, tmpReg32);
+            
+            p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+    }
+    return E_OK;
+}
+#endif /* FM_MANIP_SUPPORT */
+
 t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
 {
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
     t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
     t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
     uint32_t        tmpReg32;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdPlcrSetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter, value);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcr, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
 
     switch (counter)
     {
@@ -1341,8 +1392,7 @@ t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmP
     tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
     WritePar(p_FmPcd, tmpReg32);
 
-     return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    return E_OK;
 }
 
 t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
@@ -1358,45 +1408,6 @@ t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSha
     return E_OK;
 }
 
-t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
-{
-   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
-#ifndef CONFIG_GUEST_PARTITION
-   uint32_t tmpReg32;
-#else
-    UNUSED(enable);
-#endif /* !CONFIG_GUEST_PARTITION */
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-#ifndef CONFIG_GUEST_PARTITION
-    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
-    if(enable)
-        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
-    else
-        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
-#else
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-#endif
-    return E_OK;
-}
-
-#ifndef CONFIG_GUEST_PARTITION
-t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
-{
-   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-
-    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
-
-    return E_OK;
-}
 
 /* ... */
 
@@ -1412,37 +1423,43 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
-
-
-    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
-    DUMP_SUBSTRUCT_ARRAY(i, 63)
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_PLCR_DUMP_REGS, NULL, NULL, NULL);
+    else
     {
-        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
-    }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+        DUMP_SUBSTRUCT_ARRAY(i, 63)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
+        }
 
-    return E_OK;
+        return E_OK;
+    }
 }
+
 t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1456,35 +1473,38 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
-
-    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
-
-    tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
-    WritePar(p_FmPcd, tmpReg);
-
-    DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
-
-    DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pects);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-
-    return E_OK;
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_PLCR_PROFILE_DUMP_REGS, (uint8_t*)&h_Profile, NULL, NULL);
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+
+        p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
+        WritePar(p_FmPcd, tmpReg);
+
+        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
+
+        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+
+        return E_OK;
+    }
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
-#endif /* ! CONFIG_GUEST_PARTITION */
-
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index ce70bba..4ffac19 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -39,17 +39,17 @@
 #include "error_ext.h"
 #include "string_ext.h"
 #include "debug_ext.h"
+#include "net_ext.h"
 
+#include "fm_common.h"
 #include "fm_pcd.h"
-#include "net_ext.h"
+#include "fm_pcd_ipc.h"
 
 
 t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdPrs  *p_FmPcdPrs;
-#ifndef CONFIG_GUEST_PARTITION
     uint64_t    baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
-#endif /* !CONFIG_GUEST_PARTITION */
 
     UNUSED(p_FmPcd);
     UNUSED(p_FmPcdParams);
@@ -62,27 +62,21 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
 
-#ifndef CONFIG_GUEST_PARTITION
     p_FmPcdPrs->p_SwPrsCode  = CAST_UINT64_TO_POINTER_TYPE(uint32_t, baseAddr);
     p_FmPcdPrs->p_FmPcdPrsRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPrsRegs, (baseAddr + PRS_REGS_OFFSET));
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = DEFAULT_fmPcdPrsPortIdStatictics;
-#else
     p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
     p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
     p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
-#endif /* !CONFIG_GUEST_PARTITION */
 
     return p_FmPcdPrs;
 }
 
-#ifndef CONFIG_GUEST_PARTITION
 static void PcdPrsErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t                event, mask;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
     mask = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
 
@@ -97,11 +91,6 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
 
     if(event & FM_PCD_PRS_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_PRS_ILLEGAL_ACCESS)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
-    if(event & FM_PCD_PRS_PORT_ILLEGAL_ACCESS)
-/* TODO - change to indexed? how? */
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
 }
 
 static void PcdPrsException(t_Handle h_FmPcd)
@@ -109,6 +98,7 @@ static void PcdPrsException(t_Handle h_FmPcd)
     t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t            event;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr);
     event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
 
@@ -130,6 +120,7 @@ static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t
     int                     i;
     t_FmPcdPrsLabelParams   *p_Label;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
 
@@ -148,10 +139,12 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-    uint32_t            i, j, tmpReg;
+    uint32_t            tmpReg;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
 #ifdef FM_PRS_MEM_ERRATA
     {
+        uint32_t            i;
         uint32_t            regsToGlobalOffset = 0x840;
         uint32_t            firstPortToGlobalOffset = 0x45800;
         uint32_t            globalAddr = (uint32_t)p_Regs - regsToGlobalOffset;
@@ -195,9 +188,8 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /**********************PEVER******************/
 
     /**********************PERR******************/
-    WRITE_UINT32(p_Regs->perr, (FM_PCD_PRS_DOUBLE_ECC  |
-                               FM_PCD_PRS_PORT_ILLEGAL_ACCESS |
-                               FM_PCD_PRS_ILLEGAL_ACCESS));
+    WRITE_UINT32(p_Regs->perr, FM_PCD_PRS_DOUBLE_ECC);
+
     /**********************PERR******************/
 
     /**********************PERER******************/
@@ -207,10 +199,6 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS)
-        tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
-        tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
     WRITE_UINT32(p_Regs->perer, tmpReg);
     /**********************PERER******************/
 
@@ -220,6 +208,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 
 #ifdef FM_PRS_L4_SHELL_ERRATA
     {
+        uint32_t            i, j;
         t_FmRevisionInfo    revInfo;
         uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
 
@@ -246,10 +235,9 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     return E_OK;
 }
 
-#ifndef CONFIG_GUEST_PARTITION
-
 void PrsFree(t_FmPcd *p_FmPcd )
 {
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR);
     /* register even if no interrupts enabled, to allow future enablement */
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL);
@@ -259,6 +247,7 @@ t_Error PrsEnable(t_FmPcd *p_FmPcd )
 {
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
 
     return E_OK;
@@ -268,26 +257,23 @@ t_Error PrsDisable(t_FmPcd *p_FmPcd )
 {
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) & ~FM_PCD_PRS_RPIMAC_EN);
 
     return E_OK;
 }
 
-#endif /* CONFIG_GUEST_PARTITION */
-
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
+t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t    bitMask = 0;
     uint8_t     prsPortId;
 
-    SANITY_CHECK_RETURN((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
-    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
     GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
-    GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId) ;
+    GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId);
 
     if(include)
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
@@ -295,30 +281,47 @@ void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, b
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+
+    return E_OK;
+}
+
+t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
+
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(((t_FmPcd *)h_FmPcd)->h_Fm))
+    {
+        prsIncludePortParams.hardwarePortId = hardwarePortId;
+        prsIncludePortParams.include = include;
+        return XX_SendMessage(((t_FmPcd *)h_FmPcd)->fmPcdModuleName, FM_PCD_PRS_INC_PORT_STATS, (uint8_t*)&prsIncludePortParams, NULL, NULL);
+    }
+    else
+        return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
 }
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-#endif /* ! CONFIG_GUEST_PARTITION */
 
 uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
 {
-#ifdef CONFIG_GUEST_PARTITION
     t_Error                 err = E_OK;
     t_FmPcdIpcSwPrsLable    labelParams;
 
-    labelParams.hdr = hdr;
-    labelParams.indexPerHdr = indexPerHdr;
-    err = XX_SendMessage(((t_FmPcd *)h_FmPcd)->fmPcdModuleName, FM_PCD_GET_SW_PRS_OFFSET, (uint8_t*)&labelParams, NULL, NULL);
-    if(err)
-        REPORT_ERROR(MAJOR, err, NO_MSG);
-    XX_Free(labelParams.p_SwPrsLabel);
-
-    return  labelParams.offset;
-#else
-    return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
-#endif /* CONFIG_GUEST_PARTITION */
+    if(!FmIsMaster(((t_FmPcd *)h_FmPcd)->h_Fm))
+    {
+        labelParams.enumHdr = (uint32_t)hdr;
+        labelParams.indexPerHdr = indexPerHdr;
+        err = XX_SendMessage(((t_FmPcd *)h_FmPcd)->fmPcdModuleName, FM_PCD_GET_SW_PRS_OFFSET, (uint8_t*)&labelParams, NULL, NULL);
+        if(err)
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+        return  labelParams.offset;
+    }
+    else
+        return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
 }
 
-#ifndef CONFIG_GUEST_PARTITION
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -326,6 +329,11 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+    {
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
+        return;
+    }
     if(enable)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
     else
@@ -345,6 +353,9 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_PrsLoadSw - guest mode!"));
+
     if(!p_SwPrs->override)
     {
         if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
@@ -394,6 +405,9 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPrsMaxCycleLimit - guest mode!"));
+
     p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
 
     return E_OK;
@@ -411,38 +425,42 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
-
-    return E_OK;
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_PRS_DUMP_REGS, NULL, NULL, NULL);
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
+        DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
+
+        return E_OK;
+    }
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
-#endif  /* !CONFIG_GUEST_PARTITION */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 85cc815..ded88d5 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -53,8 +53,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 {
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
     t_Error             ans = E_OK;
-    uint8_t             i;
     uint32_t            unusedMask;
+    uint8_t             i;
+	uint8_t             j;
+	bool                found;
+    t_FmRevisionInfo 	revInfo;
+
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
 
     if (p_FmPort->imEn)
     {
@@ -68,30 +73,54 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
-            /* pools id may be 0-31 */
             /* external buffer pools */
-            if(!p_Params->rxExtBufPools.numOfPoolsUsed)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+            if(!p_Params->extBufPools.numOfPoolsUsed)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if(p_Params->rxExtBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", BM_MAX_NUM_OF_EXT_POOLS));
+            if(p_Params->extBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", FM_PORT_MAX_NUM_OF_EXT_POOLS));
 
-            for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+            for(i=0;i<p_Params->extBufPools.numOfPoolsUsed;i++)
             {
-                if(p_Params->rxExtBufPools.rxExtBufPool[i].id >= BM_MAX_NUM_OF_EXT_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].id can't be larger than %d", BM_MAX_NUM_OF_EXT_POOLS));
-                if(!p_Params->rxExtBufPools.rxExtBufPool[i].size)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].size is 0"));
+                if(p_Params->extBufPools.extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[i].id can't be larger than %d", BM_MAX_NUM_OF_POOLS));
+                if(!p_Params->extBufPools.extBufPool[i].size)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[i].size is 0"));
             }
 
-            /* up to rxExtBufPools.numOfPoolsUsed pools may be defined */
-            if((p_Params->bufPoolDepletion.numOfPools > p_Params->rxExtBufPools.numOfPoolsUsed))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+            /* backup BM pools indication is valid only for some chip deriviatives */
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+			if (revInfo.majorRev < 3)
+			{
+				if(p_Params->p_BackupBmPools)
+				{
+					if(p_Params->p_BackupBmPools->numOfBackupPools >= p_Params->extBufPools.numOfPoolsUsed)
+						RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"));
+					found = FALSE;
+					for(i = 0;i<p_Params->p_BackupBmPools->numOfBackupPools;i++)
+						for(j=0;j<p_Params->extBufPools.numOfPoolsUsed;j++)
+							if(p_Params->p_BackupBmPools->poolIds[i] == p_Params->extBufPools.extBufPool[j].id)
+								found = TRUE;
+					if (!found)
+						RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
+				}
+			}
+
+			/* up to extBufPools.numOfPoolsUsed pools may be defined */
+            if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
+            {
+                if((p_Params->bufPoolDepletion.numOfPools > p_Params->extBufPools.numOfPoolsUsed))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
 
+                if(!p_Params->bufPoolDepletion.numOfPools)
+                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+            }
             /* Check that part of IC that needs copying is small enough to enter start margin */
             if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
+        	if(p_Params->partitionId & ~FM_LIODN_OFFSET_MASK)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId is larger than %d", FM_LIODN_OFFSET_MASK+1));
             {
                 t_FmRevisionInfo revInfo;
                 FmGetRevision(p_FmPort->h_Fm, &revInfo);
@@ -103,10 +132,6 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
                         DBG(WARNING, ("partitionId number is out of rev1 range - MSB bits cleard."));
                     }
                 }
-                else
-                    if ((revInfo.majorRev == 2) && (revInfo.minorRev == 0))
-                        if(p_Params->partitionId & ~FM_LIODN_OFFSET_MASK)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId is larger than %d", FM_LIODN_OFFSET_MASK+1));
             }
         }
 
@@ -115,7 +140,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         else
         {
-            if(p_Params->deqSubPortal > MAX_QMI_DEQ_SUBPORTAL)
+            if(p_Params->deqSubPortal >= MAX_QMI_DEQ_SUBPORTAL)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", MAX_QMI_DEQ_SUBPORTAL));
 
             /* to protect HW internal-context from overwrite */
@@ -173,6 +198,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+
+		if ((revInfo.majorRev > 3) && (revInfo.minorRev == 0))
+		{
+			/* Check that not larger than 16 */
+			if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+				RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+		}
     }
 
     /****************************************/
@@ -245,7 +277,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
     /*   All ports                          */
     /****************************************/
-    /* Check that divisible by 16 and not larger than 240 */
+
+   /* Check that divisible by 16 and not larger than 240 */
     if(p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
     if(p_Params->intContext.intContextOffset % OFFSET_UNITS)
@@ -290,161 +323,263 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
     }
 }
 
-static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
-    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
-    uint32_t                tmpReg;
-    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
-    uint32_t                vector = 0, errorsToEnq = 0;
-    uint16_t                bufSize = 0;
-    int                     i=0, j=0, k=0;
-    bool                    found;
-    uint8_t                 orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-    uint16_t                sizesArray[BM_MAX_NUM_OF_EXT_POOLS];
-    uint8_t                 count = 0;
-    t_FmPortPerformanceCnt  performanceContersParams;
-    t_Error                 err;
+    t_FmPortExtPools            *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
+    t_FmPortBufPoolDepletion    *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
+    volatile uint32_t           *p_ExtBufRegs;
+    volatile uint32_t           *p_BufPoolDepletionReg;
+    bool                        rxPort, opSupport = FALSE, backUpSupport = FALSE;
+    bool                        found;
+    uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
+    uint8_t                     count = 0;
+    uint8_t                     numOfPools;
+    uint16_t                    bufSize = 0, largestBufSize = 0;
+    int                         i=0, j=0, k=0;
+    uint32_t                    tmpReg, vector, minFifoSizeRequired=0;
+    t_FmRevisionInfo 			revInfo;
+
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+	if (revInfo.majorRev > 3)
+	{
+		opSupport = TRUE;
+		backUpSupport = TRUE;
+	}
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
-    memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
+    memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmPortExtPools));
 
-    /* check that port is not busy */
-    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
-         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
+            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_mpd;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+    		if (opSupport)
+    		{
+				p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
+				p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
+				rxPort = FALSE;
+				break;
+    		}
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for port type"));
+    }
 
-    /* Set Config register */
-    tmpReg = 0;
-    if (p_FmPort->imEn)
-        tmpReg |= BMI_PORT_CFG_IM;
-    /* No discard - all error frames go to error queue */
-    else if (p_Params->frmDiscardOverride)
-        tmpReg |= BMI_PORT_CFG_FDOVR;
+    /* First we copy the external buffers pools information to an ordered local array */
+    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    {
+        /* get pool size */
+        bufSize = p_ExtBufPools->extBufPool[i].size;
 
-    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
+        /* keep sizes in an array according to poolId for direct access */
+        sizesArray[p_ExtBufPools->extBufPool[i].id] =  bufSize;
 
-    if (!p_FmPort->imEn)
-    {
-        /* define external buffer pools */
-        /* First we copy the external buffers pools information to an ordered local array */
-        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+        /* save poolId in an ordered array according to size */
+        for (j=0;j<=i;j++)
         {
-            /* get pool size */
-            bufSize = p_Params->rxExtBufPools.rxExtBufPool[i].size;
-            /* check if pool size is not too big */
-            if(bufSize > p_Params->fifoBufs.num )
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Pool %d size is bigger than ports commited fifo size",
-                                                        p_Params->rxExtBufPools.rxExtBufPool[i].id));
-            /* keep sizes in an array according to poolId for direct access */
-            sizesArray[p_Params->rxExtBufPools.rxExtBufPool[i].id] =  bufSize;
-
-            /* save poolId in an ordered array according to size */
-            for (j=0;j<=i;j++)
+            /* this is the next free place in the array */
+            if (j==i)
+                orderedArray[i] = p_ExtBufPools->extBufPool[i].id;
+            else
             {
-                /* this is the next free place in the array */
-                if (j==i)
-                    orderedArray[i] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
-                else
+                /* find the right place for this poolId */
+                if(bufSize < sizesArray[orderedArray[j]])
                 {
-                    /* find the right place for this poolId */
-                    if(bufSize < sizesArray[orderedArray[j]])
-                    {
-                        /* move the poolIds one place ahead to make room for this poolId */
-                        for(k=i;k>j;k--)
-                           orderedArray[k] = orderedArray[k-1];
+                    /* move the poolIds one place ahead to make room for this poolId */
+                    for(k=i;k>j;k--)
+                       orderedArray[k] = orderedArray[k-1];
 
-                        /* now k==j, this is the place for the new size */
-                        orderedArray[k] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
-                        break;
-                    }
+                    /* now k==j, this is the place for the new size */
+                    orderedArray[k] = p_ExtBufPools->extBufPool[i].id;
+                    break;
                 }
             }
         }
+    }
 
-        /* build the register value */
-        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+    /* build the register value */
+
+    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    {
+        tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
+        tmpReg |= (orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
+        tmpReg |= sizesArray[orderedArray[i]];
+        /* functionality available only for some deriviatives */
+		if (backUpSupport)
+		{
+			if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+				for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+					if(orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+					{
+						tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
+						break;
+					}
+		}
+		WRITE_UINT32(*(p_ExtBufRegs+i), tmpReg);
+    }
+
+	if (backUpSupport)
+		if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+			XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
+
+	if(opSupport)
+        numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
+    else
+    	numOfPools = FM_PORT_MAX_NUM_OF_EXT_POOLS;
+
+    /* clear unused pools */
+    for(i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
+        WRITE_UINT32(*(p_ExtBufRegs+i), 0);
+
+    p_FmPort->p_FmPortDriverParam->largestBufSize = largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if(revInfo.majorRev > 3)
         {
-            tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
-            tmpReg |= (orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
-            tmpReg |= sizesArray[orderedArray[i]];
-            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], tmpReg);
+            if(p_ExtBufPools->numOfPoolsUsed == 1)
+                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
+            else
+            {
+                uint32_t secondLargestBuffer = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
+                minFifoSizeRequired = (uint32_t)(((secondLargestBuffer % BMI_FIFO_UNITS) ?
+                                    ((secondLargestBuffer/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    secondLargestBuffer) +
+                                    (7*BMI_FIFO_UNITS));
+            }
+
         }
+        else
+        {
+            minFifoSizeRequired = (uint32_t)(((largestBufSize % BMI_FIFO_UNITS) ?
+                                    ((largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    largestBufSize) +
+                                    (7*BMI_FIFO_UNITS));
+        }
+        if(p_FmPort->p_FmPortDriverParam->fifoBufs.num < minFifoSizeRequired)
+        {
+            p_FmPort->p_FmPortDriverParam->fifoBufs.num = minFifoSizeRequired;
+            DBG(WARNING, ("FIFO size for Rx port enlarged to %d",minFifoSizeRequired));
+        }
+    }
 
-        /* clear unused pools */
-        for(i=p_Params->rxExtBufPools.numOfPoolsUsed;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
-            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], 0);
+    /* check if pool size is not too big */
+    if(largestBufSize > p_FmPort->p_FmPortDriverParam->fifoBufs.num )
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Pool %d size is bigger than ports commited fifo size",
+                                                p_ExtBufPools->extBufPool[i].id));
 
-        /* pool depletion */
-        tmpReg = 0;
-        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
+    /* pool depletion */
+    tmpReg = 0;
+    if(p_BufPoolDepletion->numberOfPoolsModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        found = FALSE;
+        vector = 0;
+        count = 0;
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            /* calculate vector for number of pools depletion */
-            found = FALSE;
-            vector = 0;
-            count = 0;
-            for(i=0;i<BM_MAX_NUM_OF_EXT_POOLS;i++)
+            if(p_BufPoolDepletion->poolsToConsider[i])
             {
-                if(p_Params->bufPoolDepletion.poolsToConsider[i])
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
-                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
+                    if (i == orderedArray[j])
                     {
-                        if (i == orderedArray[j])
-                        {
-                            vector |= 0x80000000 >> j;
-                            found = TRUE;
-                            count++;
-                            break;
-                        }
+                        vector |= 0x80000000 >> j;
+                        found = TRUE;
+                        count++;
+                        break;
                     }
-                    if (!found)
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
-                    else
-                        found = FALSE;
                 }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
             }
-            if (count < p_Params->bufPoolDepletion.numOfPools)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
-
-            /* configure num of pools and vector for number of pools mode */
-            tmpReg |= ((p_Params->bufPoolDepletion.numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
-            tmpReg |= vector;
         }
+        if (count < p_BufPoolDepletion->numOfPools)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
+
+        /* configure num of pools and vector for number of pools mode */
+        tmpReg |= ((p_BufPoolDepletion->numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
+        tmpReg |= vector;
+    }
 
-        if(p_Params->bufPoolDepletion.singlePoolModeEnable)
+    if(p_BufPoolDepletion->singlePoolModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        found = FALSE;
+        vector = 0;
+        count = 0;
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            /* calculate vector for number of pools depletion */
-            found = FALSE;
-            vector = 0;
-            count = 0;
-            for(i=0;i<BM_MAX_NUM_OF_EXT_POOLS;i++)
+            if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                if(p_Params->bufPoolDepletion.poolsToConsiderForSingleMode[i])
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
-                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
-                    {
-                        if (i == orderedArray[j])
-                         {
-                            vector |= 0x00000080 >> j;
-                            found = TRUE;
-                            count++;
-                            break;
-                        }
+                    if (i == orderedArray[j])
+                     {
+                        vector |= 0x00000080 >> j;
+                        found = TRUE;
+                        count++;
+                        break;
                     }
-                    if (!found)
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
-                    else
-                        found = FALSE;
                 }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
             }
-            if (!count)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
-
-            /* configure num of pools and vector for number of pools mode */
-            tmpReg |= vector;
         }
+        if (!count)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
 
-        WRITE_UINT32(p_Regs->fmbm_mpd, tmpReg);
+        /* configure num of pools and vector for number of pools mode */
+        tmpReg |= vector;
     }
 
+    WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
+
+    return E_OK;
+}
+
+static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    uint32_t                tmpReg;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t                errorsToEnq = 0;
+    t_FmPortPerformanceCnt  performanceContersParams;
+    t_Error                 err;
+
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Set Config register */
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+    /* No discard - all error frames go to error queue */
+    else if (p_Params->frmDiscardOverride)
+        tmpReg |= BMI_PORT_CFG_FDOVR;
+
+    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
+
+#if 0
+    if (!p_FmPort->imEn)
+    {
+        /* define external buffer pools and pool depletion*/
+        err = SetExtBufferPools(p_FmPort);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif
     /* Configure dma attributes */
     tmpReg = 0;
     tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
@@ -471,7 +606,6 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
 
     /* IC parameters */
-
     tmpReg = 0;
     tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
     tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
@@ -482,10 +616,9 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     if (!p_FmPort->imEn)
     {
         /* check if the largest external buffer pool is large enough */
-        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins >
-                sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]])
+        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins > p_Params->largestBufSize)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]]));
+                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, p_Params->largestBufSize));
 
         /* buffer margins */
         tmpReg = 0;
@@ -495,11 +628,18 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
     }
 #if 0 /* in our driver p_Params->bufMargins.startMargins is always aligned to 16 */
-    /* if p_Params->bufMargins.startMargins is not devisible by 16 (usually for alignment),
+    /* if p_Params->bufMargins.startMargins is not divisible by 16 (usually for alignment),
     than we give a buffer (16 bytes) in order to avoid HW using the end of the previous buffer */
     if(p_Params->bufMargins.startMargins % FRAME_OFFSET_UNITS)
         WRITE_UINT32(p_Regs->fmbm_rim, 1 << BMI_RIM_FOF_SHIFT);
 #endif
+    if(p_FmPort->internalBufferOffset)
+    {
+        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+        WRITE_UINT32(p_Regs->fmbm_rim, tmpReg << BMI_IM_FOF_SHIFT);
+    }
 
     /* NIA */
     if (p_FmPort->imEn)
@@ -560,7 +700,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
 static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
 {
     t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
-    uint32_t            tmpReg, tmpRateLimitScale;
+    uint32_t            tmpReg;
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
     /*uint32_t            rateCountUnit;*/
     t_FmPortPerformanceCnt  performanceContersParams;
@@ -619,6 +759,10 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     {
         WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_QMI_DEQ);
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        /* The line bellow is a trick so the FM will not release the buffer
+           to BM nor will try to enq the frame to QM */
+        if(!p_Params->dfltFqid && p_Params->dontReleaseBuf)
+            WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
     }
 
     /* command attribute */
@@ -642,38 +786,6 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
     }
 
-    /* rate limit */
-    if(p_Params->enRateLimit)
-    {
-        /* normally, we use 1 usec as the reference count */
-        uint8_t     factor = 1, countUnitBit;
-
-        /* if ratelimit is too small for a 1usec factor, multiply the factor */
-        countUnitBit = p_Params->count1MicroBit;
-        while (p_Params->rateLimit.rateLimit < 16000/factor)
-        {
-            if (countUnitBit==31)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
-
-            countUnitBit++;
-            factor <<= 1;
-        }
-        /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
-        if (p_Params->rateLimit.rateLimit > 16384000*factor)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
-
-        tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit*factor/16000 - 1);
-
-        if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
-
-        tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
-        WRITE_UINT32(p_Regs->fmbm_trlmt, tmpReg);
-
-        tmpRateLimitScale = ((31 - countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
-        WRITE_UINT32(p_Regs->fmbm_trlmts, tmpRateLimitScale);
-    }
-
     /* statistics & performance counters */
     WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
 
@@ -690,11 +802,11 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
 
 static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 {
-    t_FmPortOhBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
-    uint32_t            tmpReg, tmpRateLimitScale, errorsToEnq = 0;
-    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    uint32_t            rateCountUnit;
+    t_FmPortOhBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+    uint32_t                tmpReg, errorsToEnq = 0;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
     t_FmPortPerformanceCnt  performanceContersParams;
+    t_FmRevisionInfo 		revInfo;
 
     /* check that port is not busy */
     if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
@@ -755,24 +867,15 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         /* NIA */
         WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
 
-        /* rate limit */
-        if(p_Params->enRateLimit)
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev > 3) && (p_Params->enBufPoolDepletion))
         {
-            /* normally, we use 1 usec as the reference count */
-            rateCountUnit = 1000;
-            /* TODO - if ratelimit is out of range, change rateCountUnit */
-            if(p_Params->rateLimit.rateLimit < 16000)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 16*timeStampPeriod as initialized in main FM module"));
-
-            tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/16 * rateCountUnit - 1);
-            if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
-
-            tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
-            WRITE_UINT32(p_Regs->fmbm_orlmt, tmpReg);
+            t_Error     err;
 
-            tmpRateLimitScale = ((31 - p_Params->count1MicroBit - 1) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
-            WRITE_UINT32(p_Regs->fmbm_orlmts, tmpRateLimitScale);
+            /* define external buffer pools */
+            err = SetExtBufferPools(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
         }
     }
     else
@@ -783,6 +886,13 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
     WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
 
+    if(p_FmPort->internalBufferOffset)
+    {
+        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+        WRITE_UINT32(p_Regs->fmbm_oim, tmpReg << BMI_IM_FOF_SHIFT);
+    }
     /* statistics & performance counters */
     WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
 
@@ -850,8 +960,9 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue type"));
-                break;
         }
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+
         switch(p_Params->deqPrefetchOption)
         {
             case(e_FM_PORT_DEQ_NO_PREFETCH):
@@ -865,8 +976,8 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
-                break;
         }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
         tmpReg |= p_Params->deqByteCnt;
         tmpReg |= p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
 
@@ -908,7 +1019,6 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
          default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-            break;
     }
 
     /* Set counter */
@@ -948,6 +1058,14 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             *p_Ptr = &p_BmiRegs->fmbm_rffc;
             break;
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+#ifdef FM_PORT_COUNTERS_ERRATA_IPG19249
+            {
+                t_FmRevisionInfo revInfo;
+                FmGetRevision(p_FmPort->h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available for O/H ports in rev1"));
+            }
+#endif /* FM_PORT_COUNTERS_ERRATA_IPG19249 */
             *p_Ptr = &p_BmiRegs->fmbm_rfldec;
             break;
         case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
@@ -958,7 +1076,6 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-            break;
     }
 
     return E_OK;
@@ -989,7 +1106,6 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
-            break;
     }
 
     /* Set counter */
@@ -1027,7 +1143,6 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
-            break;
     }
 
     return E_OK;
@@ -1065,7 +1180,6 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
-            break;
     }
 
     /* Set counter */
@@ -1093,7 +1207,15 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
            *p_Ptr = &p_BmiRegs->fmbm_offc;
             break;
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
+#ifdef FM_PORT_COUNTERS_ERRATA_IPG19249
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available for O/H ports in rev1"));
+        }
+#endif /* FM_PORT_COUNTERS_ERRATA_IPG19249 */
+          *p_Ptr = &p_BmiRegs->fmbm_ofldec;
             break;
         case(e_FM_PORT_COUNTERS_WRED_DISCARD):
            *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
@@ -1121,6 +1243,9 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
     u_FmPcdHdrPrsOpts            *p_prsOpts;
     uint32_t                    tmpReg = 0, tmpPrsOffset;
 
+    if(IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
+
     if(p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
 
@@ -1142,6 +1267,19 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
                         ("Header must be equal or higher than IPv4"));
                 tmpReg |= (hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
+            case(HEADER_TYPE_PPPoE):
+                if(p_prsOpts->pppoePrsOptions.enableMTUCheck)
+                {
+#ifdef FM_PPPOE_NO_MTU_CHECK
+                    t_FmRevisionInfo revInfo;
+                    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Invalid parser option"));
+                    else
+#endif /* FM_PPPOE_NO_MTU_CHECK */
+                        tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
+                }
+                break;
             case(HEADER_TYPE_IPv6):
                 if(p_prsOpts->ipv6PrsOptions.routingHdrDisable)
                     tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_DIS;
@@ -1155,7 +1293,6 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
-                break;
         }
     }
 
@@ -1214,17 +1351,24 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
              p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
 
     /* Translate margin and intContext params to FM parameters */
-    if (!POWER_OF_2(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.dataAlign must be a power of 2."));
+#ifdef FM_PORT_ALIGN_ERRATA_IPG19155
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign % 64)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bufferPrefixContent.dataAlign must be a 64 multiply."));
+    }
+#endif /* FM_PORT_ALIGN_ERRATA_IPG19155 */
 
     /* Initialize with illegal value. Later we'll set legal values. */
     p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.hashResultOffset= (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
     p_FmPort->bufferOffsets.debugOffset     = (uint32_t)ILLEGAL_BASE;
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+#endif /* DEBUG */
 
     /* Internally the driver supports 4 options
        1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
@@ -1237,15 +1381,15 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
     /* This 'if' covers options  2 & 4. We copy from beginning of context with or without debug. */
     /* If passAllOtherPCDInfo explicitly requested, or passDebugInfo+prs/ts --> we also take passAllOtherPCDInfo */
     if ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
         || (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo &&
          (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ||
           p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
           p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult))
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+#endif /* DEBUG */
        )
     {
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
         if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
         {
             p_FmPort->p_FmPortDriverParam->intContext.size = 240;
@@ -1253,7 +1397,7 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
                 (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 128);
         }
         else
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+#endif /* DEBUG */
             p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
         /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
         p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 16;
@@ -1272,7 +1416,7 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
     }
     else
     {
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
         if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
         {
             /* This case covers option 3 */
@@ -1281,7 +1425,7 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
             p_FmPort->bufferOffsets.debugOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
         }
         else
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+#endif /* DEBUG */
         {
             /* This case covers the options under 1 */
             /* Copy size must be in 16-byte granularity. */
@@ -1313,21 +1457,29 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
     p_FmPort->p_FmPortDriverParam->bufMargins.startMargins =
         (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
                    p_FmPort->p_FmPortDriverParam->intContext.size);
+#ifdef FM_MANIP_SUPPORT
+    /* save extra space for manip in both external and internal buffers */
+    if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace)
+    {
+        p_FmPort->bufferOffsets.manipOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
+        p_FmPort->p_FmPortDriverParam->internalBufferOffset =
+            (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
+    }
+#endif /* FM_MANIP_SUPPORT */
 
     /* align data start */
-    tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins &
-                     (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-1));
+    tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins %
+                     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign);
     if (tmp)
         p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-tmp);
     p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+    p_FmPort->internalBufferOffset = p_FmPort->p_FmPortDriverParam->internalBufferOffset;
 
     return E_OK;
 }
 
-/********************************************/
-/*  Inter-module API                        */
-/********************************************/
-t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
@@ -1337,13 +1489,13 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
     volatile uint32_t                   *p_BmiInitPrsResult=NULL;
     volatile uint32_t                   *p_BmiCcBase=NULL;
-    uint8_t                             hdrNum, L3HdrNum;
+    uint8_t                             hdrNum, L3HdrNum, greHdrNum;
     int                                 i;
+    bool                                isEmptyClsPlanGrp;
     uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
     uint16_t                            absoluteProfileId;
     uint8_t                             physicalSchemeId;
     uint32_t                            ccTreePhysOffset;
-
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
@@ -1395,6 +1547,18 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
+        case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
             break;
@@ -1419,17 +1583,16 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
-       break;
+            break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     if(p_FmPort->pcdEngines & FM_PCD_KG)
@@ -1445,25 +1608,41 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->schemesPerPortVector |= 1 << (31 - physicalSchemeId);
         }
 
-        err = FmPortPcdKgSwBindClsPlanGrp(p_FmPort,
-                                          p_PcdParams->p_KgParams->useClsPlan,
-                                          (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_ClsPlanGrp)-1));
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
+                                            p_FmPort->hardwarePortId,
+                                            p_FmPort->netEnvId,
+                                            p_FmPort->optArray,
+                                            &p_FmPort->clsPlanGrpId,
+                                            &isEmptyClsPlanGrp);
+         if(err)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
+
+         p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
     }
 
     /* set PCD port parameter */
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset
+#ifdef FM_MANIP_SUPPORT
+        ,FmPortGetSetCcParams, h_FmPort
+#endif /* FM_MANIP_SUPPORT */
+        );
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
         p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+
     }
 
-    /* NIA after BMI*/
+    /***************************/
+    /* configure NIA after BMI */
+    /***************************/
+    /* rfne may contain FDCS bits, so first we read them. */
+    p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+
+    /* If policer is used directly after BMI or PRS */
     if((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
         ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
                 (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
@@ -1481,28 +1660,28 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
         }
         else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
-        {
-            /* rfne may contain FDCS bits, so first we read them. */
-            tmpReg |= GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             /* update BMI NIA */
-            p_FmPort->savedBmiNia = (uint32_t)(NIA_ENG_PLCR | tmpReg);
-            //WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
-        }
+            p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
     }
 
-    /* all cases but e_FM_PORT_PCD_SUPPORT_PLCR_ONLY, use parser */
-    if (!(p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY))
+    /* if CC is used directly after BMI */
+    if((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
+            (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG) ||
+        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR))
     {
-        ASSERT_COND(p_FmPort->pcdEngines & FM_PCD_PRS);
-        /* Go to Parser */
+        if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
+        p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+         /* check that prs start offset == RIM[FOF] */
+    }
 
+    if (p_FmPort->pcdEngines & FM_PCD_PRS)
+    {
+        /* if PRS is used it is always first */
         GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
         if (hdrNum == ILLEGAL_HDR_NUM)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
-        /* rfne may contain FDCS bits, so first we read them. */
-        tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia = tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE));
-        //WRITE_UINT32(*p_BmiNia, tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE)));
+        p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE));
         ASSERT_COND(p_PcdParams->p_PrsParams);
         /* set after parser NIA */
         tmpReg = 0;
@@ -1525,7 +1704,11 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                             break;
                     if(i == p_PcdParams->p_KgParams->numOfSchemes)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
-
+#ifdef FM_MANIP_SUPPORT                    
+                    err = FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PcdParams->p_KgParams->h_DirectScheme, UPDATE_NIA_ENQ_WITH_DMA);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+#endif /* FM_MANIP_SUPPORT */
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
@@ -1534,7 +1717,6 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
-                break;
         }
 
         /* set start parsing offset */
@@ -1607,6 +1789,10 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
         tmpHxs[hdrNum] |= L3HdrNum  << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
 
+        /* for GRE, disable errors */
+        GET_PRS_HDR_NUM(greHdrNum, HEADER_TYPE_GRE);
+        tmpHxs[greHdrNum] |= PRS_HDR_ERROR_DIS;
+
         /* config additional params for specific headers */
         for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
         {
@@ -1666,10 +1852,15 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         /* enable parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
-    }
 
-    if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
-        p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+        if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+            p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+
+    } /* end parser */
+    else
+        p_FmPort->privateInfo = 0;
+
+    WRITE_UINT32(*p_BmiPrsStartOffset, GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
 
     /* set initial parser result - used for all engines */
     for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
@@ -1687,7 +1878,7 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     return E_OK;
 }
 
-t_Error FmPortDeletePcd(t_Handle h_FmPort)
+static t_Error DeletePcd(t_Handle h_FmPort)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
@@ -1717,15 +1908,12 @@ t_Error FmPortDeletePcd(t_Handle h_FmPort)
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     /* "cut" PCD out of the port's flow - go to BMI */
-    //tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
-    //WRITE_UINT32(*p_BmiNia, NIA_ENG_BMI | tmpReg);
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
     if(p_FmPort->pcdEngines | FM_PCD_PRS)
@@ -1737,7 +1925,12 @@ t_Error FmPortDeletePcd(t_Handle h_FmPort)
     }
 
     if(p_FmPort->pcdEngines & FM_PCD_KG)
-        FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+    {
+        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        p_FmPort->useClsPlan = FALSE;
+    }
 
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
@@ -1753,35 +1946,64 @@ t_Error FmPortDeletePcd(t_Handle h_FmPort)
     return E_OK;
 }
 
-void          FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort)
+
+/********************************************/
+/*  Inter-module API                        */
+/********************************************/
+void FmPortSetMacsecLcv(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    uint32_t                    macsecEn = BMI_PORT_CFG_EN_MACSEC;
+    uint32_t                    lcv, walking1Mask = 0x80000000;
+    uint8_t                     cnt = 0;
 
-    FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
+        return;
+    }
+
+    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+    /* get LCV for MACSEC */
+    if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
+    {
+        while(!(lcv & walking1Mask))
+        {
+            cnt++;
+            walking1Mask >>= 1;
+        }
+
+        macsecEn |= cnt << BMI_PORT_CFG_MS_SEL_SHIFT;
+     }
+
+     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
 }
 
-t_Error          FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId)
+void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err = E_OK;
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    uint32_t                    tmpReg;
 
-    if(useClsPlan)
-    {
-        p_FmPort->useClsPlan = TRUE;
-        p_FmPort->clsPlanGrpId = newClsPlanGrpId;
-        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->netEnvId, newClsPlanGrpId, p_FmPort->optArray);
-    }
-    else
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
     {
-        if(!FmPcdKgIsEmptyClsPlanGrp(p_FmPort->h_FmPcd))
-            RETURN_ERROR(MINOR, E_CONFLICT, ("A port is defined to be without clsPlan, but PCD was configured so that all ports use the clsPlan mechanism"));
-        p_FmPort->clsPlanGrpId = FmPcdKgGetEmptyClsPlanGrpId(p_FmPort->h_FmPcd);
-        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, DRIVER_PRIVATE_NET_ENV_ID, p_FmPort->clsPlanGrpId, p_FmPort->optArray);
+        REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Tx ports only"));
+        return;
     }
-    if(err)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPortPcdKgSwBindClsPlanGrp failed. "));
 
-    return E_OK;
+    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfca;
+    tmpReg = GET_UINT32(*p_BmiCfgReg) & ~BMI_CMD_ATTR_MACCMD_MASK;
+    tmpReg |= BMI_CMD_ATTR_MACCMD_SECURED;
+    tmpReg |= ((dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT) & BMI_CMD_ATTR_MACCMD_SC_MASK);
+
+    WRITE_UINT32(*p_BmiCfgReg, tmpReg);
 }
 
 uint8_t FmPortGetNetEnvId(t_Handle h_FmPort)
@@ -1799,11 +2021,6 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
     return ((t_FmPort*)h_FmPort)->pcdEngines;
 }
 
-uint8_t  FmPortGetClsPlanId(t_Handle h_FmPort)
-{
-    return ((t_FmPort*)h_FmPort)->clsPlanGrpId;
-}
-
 t_Error FmPortAttachPCD(t_Handle h_FmPort)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -1818,10 +2035,9 @@ t_Error FmPortAttachPCD(t_Handle h_FmPort)
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-            break;
     }
 
     /* check that current NIA is BMI to BMI */
@@ -1833,6 +2049,62 @@ t_Error FmPortAttachPCD(t_Handle h_FmPort)
     return E_OK;
 }
 
+t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    int                 tmpInt;
+    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+
+  /*TODO - BUG*/
+    if((p_CcParams->getCcParams.type & OFFSET_OF_PR) && (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
+    {
+        p_CcParams->getCcParams.prOffset = (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
+        p_CcParams->getCcParams.type &= ~OFFSET_OF_PR;
+    }
+    if((p_CcParams->getCcParams.type & OFFSET_OF_DATA) && (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
+    {
+        p_CcParams->getCcParams.dataOffset = (uint16_t)p_FmPort->bufferOffsets.dataOffset;
+        p_CcParams->getCcParams.type &= ~OFFSET_OF_DATA;
+    }
+    if(p_CcParams->getCcParams.type & NUM_OF_TASKS)
+    {
+        p_CcParams->getCcParams.numOfTasks = p_FmPort->numOfTasks;
+        p_CcParams->getCcParams.type &= ~NUM_OF_TASKS;
+    }
+    if(p_CcParams->getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+    {
+        if(p_CcParams->getCcParams.poolIndex < p_FmPort->extBufPools.numOfPoolsUsed)
+        {
+            p_CcParams->getCcParams.poolIdForManip = p_FmPort->extBufPools.extBufPool[p_CcParams->getCcParams.poolIndex].id;
+            p_CcParams->getCcParams.type &= ~BUFFER_POOL_ID_FOR_MANIP;
+        }
+    }
+    if(p_CcParams->setCcParams.type & UPDATE_NIA)
+    {
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_CcParams->setCcParams.nia);
+    }
+    if(p_CcParams->setCcParams.type & UPDATE_PSO)
+    {
+        /* get PCD registers pointers */
+         switch(p_FmPort->portType)
+         {
+             case(e_FM_PORT_TYPE_RX_10G):
+             case(e_FM_PORT_TYPE_RX):
+                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+                 break;
+             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+                 break;
+             default:
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+         }
+        /* set start parsing offset */
+        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
+        if(tmpInt>0)
+            WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
+    }
+    return E_OK;
+}
 /**********************************         End of inter-module routines ********************************/
 
 /****************************************/
@@ -1871,24 +2143,25 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
 
     /* calculate global portId number */
-    GET_GLOBAL_PORTID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
 
     /* Initialize FM port parameters for initialization phase only */
     p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
                                                                     = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+#ifdef DEBUG
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo= DEFAULT_PORT_bufferPrefixContent_debugInfo;
+#endif /* DEBUG */
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
-#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
     p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
 
     /* resource distribution. */
     p_FmPort->p_FmPortDriverParam->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
@@ -1897,14 +2170,36 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->openDmas.extra                   = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
     p_FmPort->p_FmPortDriverParam->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
     p_FmPort->p_FmPortDriverParam->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+    p_FmPort->numOfTasks = (uint8_t)p_FmPort->p_FmPortDriverParam->tasks.num;
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            p_FmPort->p_FmPortDriverParam->fifoBufs.extra           = 0;
+            p_FmPort->p_FmPortDriverParam->openDmas.extra           = 0;
+            p_FmPort->p_FmPortDriverParam->tasks.extra              = 0;
+        }
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345 */
 
     p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
+#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_IPG19339
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+                p_FmPort->p_FmPortDriverParam->color              = e_FM_PORT_COLOR_OVERRIDE;
+    }
+#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_IPG19339 */
     p_FmPort->p_FmPortDriverParam->syncReq                          = DEFAULT_PORT_syncReq;
 #ifdef FM_PORT_SYNC_ERRATA_FMAN6
     {
         t_FmRevisionInfo revInfo;
         FmGetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+        if (/*(revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&*/
             (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
                 p_FmPort->p_FmPortDriverParam->syncReq              = FALSE;
     }
@@ -1933,6 +2228,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     case(e_FM_PORT_TYPE_TX):
         p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
+    p_FmPort->p_FmPortDriverParam->dontReleaseBuf                   = FALSE;
     case(e_FM_PORT_TYPE_TX_10G):
         if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
             p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
@@ -1940,11 +2236,13 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
         p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
     case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        p_FmPort->p_FmPortDriverParam->enRateLimit                  = FALSE;
     case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
@@ -1959,8 +2257,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
         return NULL;
     }
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
     if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
@@ -1972,7 +2272,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     {
         if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
             (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
-            p_FmPort->txFifoDeqPipelineDepth = 2;//DEFAULT_PORT_txFifoDeqPipelineDepth_IM;
+            p_FmPort->txFifoDeqPipelineDepth = DEFAULT_PORT_txFifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
     }
     else
@@ -1982,9 +2282,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         case(e_FM_PORT_TYPE_RX):
         case(e_FM_PORT_TYPE_RX_10G):
             /* Initialize FM port parameters for initialization phase only */
-            memcpy(&p_FmPort->p_FmPortDriverParam->rxExtBufPools,
-                   &p_FmPortParams->specificParams.rxParams.rxExtBufPools,
-                   sizeof(t_FmPortRxExtPools));
+            memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
+                   &p_FmPortParams->specificParams.rxParams.extBufPools,
+                   sizeof(t_FmPortExtPools));
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.rxParams.rxPartitionId;
@@ -2002,7 +2302,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         case(e_FM_PORT_TYPE_TX_10G):
         case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
-            p_FmPort->p_FmPortDriverParam->deqSubPortal                 = p_FmPortParams->specificParams.nonRxParams.deqSubPortal;
+            p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
+                (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
             break;
         default:
@@ -2030,6 +2331,15 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 
+    p_FmPort->h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPort->h_Spinlock)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
     return p_FmPort;
 }
 
@@ -2048,6 +2358,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     t_FmPortDriverParam             *p_Params;
     t_Error                         err = E_OK;
     t_FmInterModulePortInitParams   fmParams;
+    uint32_t                        minFifoSizeRequired = 0;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
@@ -2064,6 +2375,28 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = CAST_UINT64_TO_POINTER_TYPE(u_FmPortBmiRegs , (p_Params->baseAddr + BMI_PORT_REGS_OFFSET));
     p_FmPort->p_FmPortPrsRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortPrsRegs, (p_Params->baseAddr + PRS_PORT_REGS_OFFSET));
 
+    /* For O/H ports, check fifo size and update if neccassary */
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    {
+        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
+        if (p_Params->fifoBufs.num < minFifoSizeRequired)
+        {
+            p_Params->fifoBufs.num = minFifoSizeRequired;
+            DBG(WARNING, ("FIFO size enlarged to %d", minFifoSizeRequired));
+        }
+    }
+
+    /* For Rx Ports, call the external Buffer routine which also checks fifo
+       size and updates it if neccassary */
+    if(((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        && !p_FmPort->imEn)
+    {
+        /* define external buffer pools and pool depletion*/
+        err = SetExtBufferPools(p_FmPort);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -2076,9 +2409,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraOpenDmas = (uint8_t)p_Params->openDmas.extra;
     fmParams.sizeOfFifo = p_Params->fifoBufs.num;
     fmParams.extraSizeOfFifo = p_Params->fifoBufs.extra;
-
     fmParams.independentMode = p_FmPort->imEn;
     fmParams.portPartition = p_Params->partitionId;
+    fmParams.liodnBase = p_Params->liodnBase;
 
     switch(p_FmPort->portType)
     {
@@ -2090,7 +2423,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
-            fmParams.useRateLimit = p_Params->enRateLimit;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -2101,10 +2433,9 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* get params for use in init */
-    p_Params->count1MicroBit = fmParams.count1MicroBit;
-    p_Params->fmMuramPhysBaseAddr = 0;
-    memcpy(((uint8_t *)&p_Params->fmMuramPhysBaseAddr)+(sizeof(uint64_t)-sizeof(t_FmPhysAddr)),
-                                (uint8_t *)&fmParams.fmMuramPhysBaseAddr, sizeof(t_FmPhysAddr));
+    p_Params->fmMuramPhysBaseAddr =
+        (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
+                   ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
 
     /**********************/
     /* Init BMI Registers */
@@ -2144,9 +2475,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     FmPortDriverParamFree(p_FmPort);
 
-    /* enable port. */
-    FM_PORT_Enable(p_FmPort);
-
     return E_OK;
 }
 
@@ -2171,7 +2499,16 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     if(p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
-    FM_PORT_Disable(p_FmPort);
+    if (p_FmPort->enabled)
+    {
+        /* Force the disable if the port still enabled */
+        p_FmPort->enabled = 1;
+        FM_PORT_Disable(p_FmPort);
+    }
+
+    if (p_FmPort->h_Spinlock)
+        XX_FreeSpinlock(p_FmPort->h_Spinlock);
+
     FmPortDriverParamFree(p_FmPort);
 
     if (p_FmPort->imEn)
@@ -2179,7 +2516,9 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
@@ -2199,6 +2538,16 @@ t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpen
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_NumOfOpenDmas->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345 */
+
     memcpy(&p_FmPort->p_FmPortDriverParam->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
 
     return E_OK;
@@ -2211,9 +2560,19 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
 
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_NumOfTasks->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345 */
+
     memcpy(&p_FmPort->p_FmPortDriverParam->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
 
     return E_OK;
@@ -2226,6 +2585,16 @@ t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_SizeOfFifo->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345 */
+
     memcpy(&p_FmPort->p_FmPortDriverParam->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
     return E_OK;
@@ -2259,6 +2628,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
     return E_OK;
 }
 
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2267,12 +2637,34 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
-
     p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
-
     return E_OK;
 }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_BackupBmPools)
+{
+    t_FmPort 			*p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmRevisionInfo 	revInfo;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+	if (revInfo.majorRev > 3)
+	{
+		p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmPortBackupBmPools *)XX_Malloc(sizeof(t_FmPortBackupBmPools));
+		if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+			RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
+		memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmPortBackupBmPools));
+	}
+	else
+		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigBackupPools"));
+
+	return E_OK;
+}
 t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2345,6 +2737,36 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion
     return E_OK;
 }
 
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+
+    p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, &p_FmPortObservedBufPoolDepletion->poolDepletionParams, sizeof(t_FmPortBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, &p_FmPortObservedBufPoolDepletion->poolsParams, sizeof(t_FmPortExtPools));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+
+    memcpy(&p_FmPort->extBufPools, p_FmPortExtPools, sizeof(t_FmPortExtPools));
+
+    return E_OK;
+}
+
 t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2418,56 +2840,60 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->color = color;
+    p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_IPG19339
     {
         t_FmRevisionInfo revInfo;
         FmGetRevision(p_FmPort->h_Fm, &revInfo);
         if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("port-sync!"));
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDfltColor!"));
     }
-#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
-
-    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_IPG19339 */
+    p_FmPort->p_FmPortDriverParam->color = color;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
-
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("port-sync!"));
+    }
+#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
-
-    memcpy(&p_FmPort->p_FmPortDriverParam->rateLimit, p_RateLimit, sizeof(t_FmPortRateLimit));
-    p_FmPort->p_FmPortDriverParam->enRateLimit = TRUE;
+    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
 
     return E_OK;
 }
 
+
 t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2619,11 +3045,12 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
     if(p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
 
-    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.pcdInfoOffset);
+    return CAST_UINT64_TO_POINTER_TYPE(uint8_t, (CAST_POINTER_TO_UINT64(p_Data) +
+                                                 p_FmPort->bufferOffsets.pcdInfoOffset));
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-uint8_t *FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
+#ifdef DEBUG
+uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2633,9 +3060,10 @@ uint8_t *FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
     if(p_FmPort->bufferOffsets.debugOffset == ILLEGAL_BASE)
         return NULL;
 
-    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.debugOffset);
+    return CAST_UINT64_TO_POINTER_TYPE(uint8_t, (CAST_POINTER_TO_UINT64(p_Data) +
+                                                 p_FmPort->bufferOffsets.debugOffset));
 }
-#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+#endif /* DEBUG */
 
 t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 {
@@ -2647,25 +3075,22 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
     if(p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
 
-    return (t_FmPrsResult *)((uint32_t)p_Data + p_FmPort->bufferOffsets.prsResultOffset);
+    return CAST_UINT32_TO_POINTER_TYPE(t_FmPrsResult, (CAST_POINTER_TO_UINT64(p_Data) +
+                                                       p_FmPort->bufferOffsets.prsResultOffset));
 }
 
-t_Error FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data, uint64_t *p_Ts)
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint64_t                    *p_DataTs;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
     if(p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("illegal timeStampOffset"));
-
-    p_DataTs = CAST_UINT32_TO_POINTER_TYPE(uint64_t,((CAST_POINTER_TO_UINT32(p_Data) + p_FmPort->bufferOffsets.timeStampOffset)));
-
-    *p_Ts = *p_DataTs;
+        return NULL;
 
-    return E_OK;
+    return CAST_UINT64_TO_POINTER_TYPE(uint64_t, (CAST_POINTER_TO_UINT64(p_Data) +
+                                                  p_FmPort->bufferOffsets.timeStampOffset));
 }
 
 uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
@@ -2678,7 +3103,8 @@ uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
     if(p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
         return NULL;
 
-    return (uint8_t *)((uint32_t)p_Data + p_FmPort->bufferOffsets.hashResultOffset);
+    return CAST_UINT64_TO_POINTER_TYPE(uint8_t, (CAST_POINTER_TO_UINT64(p_Data) +
+                                                 p_FmPort->bufferOffsets.hashResultOffset));
 }
 
 t_Error FM_PORT_Disable(t_Handle h_FmPort)
@@ -2686,12 +3112,24 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t           *p_BmiCfgReg = NULL;
     volatile uint32_t           *p_BmiStatusReg = NULL;
+    uint32_t                    intFlags;
     bool                        rxPort = FALSE;
     int                         tries;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
+    intFlags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    p_FmPort->enabled--;
+    /* If the port is enabled and we're not in the first time, just decrement the counter and skip */
+    if (p_FmPort->enabled > 0)
+    {
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+        return E_OK;
+    }
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+    SANITY_CHECK_RETURN_ERROR((p_FmPort->enabled == 0), E_INVALID_STATE);
+
     switch(p_FmPort->portType)
     {
         case(e_FM_PORT_TYPE_RX_10G):
@@ -2720,19 +3158,25 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
                      GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & ~QMI_PORT_CFG_EN);
         /* wait for QMI to finish Handling dequeue tnums */
-        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_TNUM_BSY) ;
-        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) ;
+        tries=1000;
+        while ((GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) &&
+                --tries)
+            XX_UDelay(1);
+        if (!tries)
+            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
     }
 
     /* Disable BMI */
     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
 
+
     if (p_FmPort->imEn)
         FmPortImDisable(p_FmPort);
 
-    tries=100;
+    tries=5000;
     while ((GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) &&
-            --tries) ;
+            --tries)
+        XX_UDelay(1);
 
     if (!tries)
         RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
@@ -2745,10 +3189,21 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t           *p_BmiCfgReg = NULL;
     bool                        rxPort = FALSE;
+    uint32_t                    intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
+    intFlags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    /* If the port already enabled just increment the counter and skip */
+    if (p_FmPort->enabled > 0)
+    {
+        p_FmPort->enabled++;
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+        return E_OK;
+    }
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+
     if (p_FmPort->imEn)
         FmPortImEnable(p_FmPort);
 
@@ -2779,6 +3234,111 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     /* Enable BMI */
     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
 
+    p_FmPort->enabled = 1;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t            tmpRateLimit, tmpRateLimitScale;
+    volatile uint32_t   *p_RateLimitReg, *p_RateLimitScaleReg;
+    t_FmRevisionInfo    revInfo;
+    uint8_t             factor, countUnitBit;
+    uint16_t            baseGran;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
+            baseGran = 16000;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
+            baseGran = 10000;
+           break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);  /* TimeStamp per nano seconds units */
+    /* normally, we use 1 usec as the reference count */
+    factor = 1;
+    /* if ratelimit is too small for a 1usec factor, multiply the factor */
+    while (p_RateLimit->rateLimit < baseGran/factor)
+    {
+        if (countUnitBit==31)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
+
+        countUnitBit++;
+        factor <<= 1;
+    }
+    /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
+    if (p_RateLimit->rateLimit > (baseGran*(1<<10)*factor))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
+
+    tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
+
+    if(!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
+
+    tmpRateLimitScale = ((31 - countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
+
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+    else
+    {
+        if (revInfo.majorRev > 3)
+        {
+            switch(p_RateLimit->rateLimitDivider)
+            {
+                case(e_FM_PORT_DUAL_RATE_LIMITER_NONE):
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
+                    break;
+                default:
+                    break;
+            }
+            tmpRateLimit |= BMI_RATE_LIMIT_BURST_SIZE_GRAN;
+        }
+        else
+        {
+            if(p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
+
+            if(p_RateLimit->maxBurstSize % 1000)
+            {
+                p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
+                DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
+            }
+            else
+                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize/1000);
+        }
+        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+
+    }
+    WRITE_UINT32(*p_RateLimitScaleReg, tmpRateLimitScale);
+    WRITE_UINT32(*p_RateLimitReg, tmpRateLimit);
+
     return E_OK;
 }
 
@@ -2825,7 +3385,6 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     if(enable)
@@ -2860,7 +3419,6 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     /* check parameters */
@@ -2891,7 +3449,6 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     tmpReg = 0;
@@ -2932,7 +3489,6 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            break;
     }
 
     tmpReg = GET_UINT32(*p_BmiStcReg);
@@ -2967,8 +3523,10 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
+#ifndef VERIFICATION_SUPPORT
     if(GET_UINT32(*p_ErrDiscard) & errs)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Selectd Errors that were configured to cause frame discard."));
+#endif
 
     WRITE_UINT32(*p_ErrQReg, errs);
 
@@ -2983,7 +3541,7 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
 
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_EXT_POOLS, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
@@ -3032,7 +3590,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             bmiCounter = FALSE;
         case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
-        break;
+            break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
             bmiCounter = TRUE;
             break;
@@ -3065,11 +3623,10 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
-            break;
+                break;
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
                 return 0;
-                break;
         }
         return GET_UINT32(*p_Reg);
     }
@@ -3088,20 +3645,15 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         {
            case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
-            break;
             case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
-            break;
             case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
-            break;
             case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
-            break;
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
                 return 0;
-                break;
         }
     }
 }
@@ -3125,7 +3677,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
         case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
-        break;
+            break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
             bmiCounter = TRUE;
             break;
@@ -3167,19 +3719,18 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
         {
            case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
-            break;
+                break;
             case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
-            break;
+                break;
             case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
-            break;
+                break;
             case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
-            break;
+                break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
-                break;
         }
     }
     return E_OK;
@@ -3290,10 +3841,12 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
-    err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
-    if(err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
-
+    if(numOfProfiles)
+    {
+        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
 
     return E_OK;
@@ -3337,7 +3890,7 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
     if(p_FmPcdKgScheme->direct)
     {
@@ -3345,20 +3898,20 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
         /* check that this scheme is bound to this port */
         if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - physicalSchemeId))))
         {
-            RELEASE_LOCK(p_FmPort->lock);
+            XX_UnlockSpinlock(p_FmPort->h_Spinlock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
         }
 
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
         if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         {
-            RELEASE_LOCK(p_FmPort->lock);
+            XX_UnlockSpinlock(p_FmPort->h_Spinlock);
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
         }
 
         if(!FmPcdKgIsSchemeValidSw(p_FmPort->h_FmPcd, relativeSchemeId))
         {
-            RELEASE_LOCK(p_FmPort->lock);
+            XX_UnlockSpinlock(p_FmPort->h_Spinlock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
         }
 
@@ -3367,7 +3920,7 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     else /* change to indirect scheme */
         WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
 
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
     return E_OK;
 }
 
@@ -3405,10 +3958,10 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
-        RELEASE_LOCK(p_FmPort->lock);
+        XX_UnlockSpinlock(p_FmPort->h_Spinlock);
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
     }
 
@@ -3426,7 +3979,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
         /* update BMI NIA */
         WRITE_UINT32(*p_BmiNia, tmpReg);
     }
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
     return E_OK;
 }
 
@@ -3434,10 +3987,10 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                            ccTreePhysOffset;
-    volatile uint32_t                   *p_BmiCcBase=NULL;
     t_Error                             err = E_OK;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
     volatile uint32_t                   *p_BmiNia=NULL;
+    uint32_t                            ccTreePhysOffset;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
 
@@ -3453,10 +4006,9 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-            break;
     }
 
     /* check that current NIA is BMI to BMI */
@@ -3473,23 +4025,31 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
                 break;
             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
-            break;
+                break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-                break;
         }
 
-        TRY_LOCK_RET_ERR(p_FmPort->lock);
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset);
+        XX_LockSpinlock(p_FmPort->h_Spinlock);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset
+#ifdef FM_MANIP_SUPPORT
+                , FmPortGetSetCcParams, h_FmPort
+#endif
+        );
         if(err)
         {
-            RELEASE_LOCK(p_FmPort->lock);
+            XX_UnlockSpinlock(p_FmPort->h_Spinlock);
             RETURN_ERROR(MINOR, err, NO_MSG);
         }
         WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
 
         p_FmPort->ccTreeId = h_CcTree;
-        RELEASE_LOCK(p_FmPort->lock);
+
+//#ifdef FM_MANIP_SUPPORT
+//        if (ccNia == NIA_FM_CTL_AC_FRAG)
+//            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, ccNia);
+//#endif
+        XX_UnlockSpinlock(p_FmPort->h_Spinlock);
     }
     else
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse CLassification not defined for this port."));
@@ -3509,19 +4069,18 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
 
-   /* may add here checks for:
+    /* TODO - may add here checks for:
         SP (or in sw: schemes)
         CPP (or in sw clsPlan)
         Parser enabled and configured(?)
         Tree(?)
         Profile - only if direct.
-        Scheme - only if direct */
-
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+        Scheme - only if direct
+    */
 
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     err = FmPortAttachPCD(h_FmPort);
-
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return err;
 }
@@ -3546,10 +4105,9 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-            break;
     }
 
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
@@ -3564,18 +4122,20 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     t_Error                                 err = E_OK;
     uint8_t                                 i;
 
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
-
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
-    err = FmPortSetPcd( h_FmPort, p_PcdParams);
+    err = SetPcd( h_FmPort, p_PcdParams);
     if(err)
     {
-        RELEASE_LOCK(p_FmPort->lock);
+        XX_UnlockSpinlock(p_FmPort->h_Spinlock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -3584,38 +4144,27 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.netEnvId = p_FmPort->netEnvId;
         schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
         schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
-        schemeBind.useClsPlan = p_PcdParams->p_KgParams->useClsPlan;
+        schemeBind.useClsPlan = p_FmPort->useClsPlan;
         for(i = 0;i<schemeBind.numOfSchemes;i++)
             schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
 
         err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if(err)
         {
-            FmPortDeletePcd(p_FmPort);
-            RELEASE_LOCK(p_FmPort->lock);
+            DeletePcd(p_FmPort);
+            XX_UnlockSpinlock(p_FmPort->h_Spinlock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-
-        err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-        if(err)
-        {
-            FmPortDeletePcd(p_FmPort);
-            FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        }
     }
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    if(( p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
-#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     err = FmPortAttachPCD(h_FmPort);
 
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return err;
 }
@@ -3626,6 +4175,12 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
     t_Error                                 err = E_OK;
 
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
     if(p_FmPort->pcdEngines & FM_PCD_KG)
     {
         /* unbind all schemes */
@@ -3634,37 +4189,36 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-
-        FmPcdKgUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
     }
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     /* we do it anyway, instead of checking if included */
-    FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
-#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+    if (FmIsMaster(p_FmPort->h_Fm) &&
+        (p_FmPort->pcdEngines & FM_PCD_PRS))
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+
+    FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
-    err = FmPortDeletePcd( h_FmPort);
+    err = DeletePcd( h_FmPort);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
-
     return E_OK;
 }
 
+#if 0 /* may be used in the future to add "ModifyNetEnv" */
 t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error             err = E_OK;
+    volatile uint32_t   *p_BmiNia=NULL;
     uint32_t            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint32_t            intFlags;
     int                 i = 0;
     uint8_t             hdrNum;
-    volatile uint32_t   *p_BmiNia=NULL;
-
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
 
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
 
@@ -3677,33 +4231,29 @@ t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Han
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-            break;
     }
 
     /* check that current NIA is BMI to BMI */
     if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    /* deal with SW */
-    FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
+    /* unbind current */
+    FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
 
-    err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
-    if(err)
-    {
-        RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    /* bind new */
+    err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
+                                         p_FmPort->hardwarePortId,
+                                         p_FmPort->netEnvId,
+                                         p_FmPort->optArray,
+                                         &p_FmPort->clsPlanGrpId,
+                                         &isEmptyClsPlanGrp);
+      if(err)
+          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
-    /* deal with HW */
-    err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-    if(err)
-    {
-        RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+      p_FmPort->useClsPlan = isEmptyClsPlanGrp;
 
     /************************************/
     /* Parser classification group plan parameters           */
@@ -3799,10 +4349,11 @@ t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Han
     /* enable parser */
     WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
 
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return E_OK;
 }
+#endif
 
 t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
 {
@@ -3827,10 +4378,10 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
         tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
     }
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     p_FmPort->schemesPerPortVector |= tmpScmVec;
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return err;
 }
@@ -3857,10 +4408,10 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
         tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
     }
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     p_FmPort->schemesPerPortVector &= ~tmpScmVec;
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return err;
 }
@@ -3870,8 +4421,8 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t   *p_BmiPrsStartOffset = NULL;
     volatile uint32_t   *p_BmiNia = NULL;
-    uint8_t             hdrNum;
     uint32_t            tmpReg;
+    uint8_t             hdrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3898,19 +4449,19 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    XX_LockSpinlock(p_FmPort->h_Spinlock);
     /* set the first header */
     GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
-    if (hdrNum == ILLEGAL_HDR_NUM)
+    if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
     {
-        RELEASE_LOCK(p_FmPort->lock);
+        XX_UnlockSpinlock(p_FmPort->h_Spinlock);
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
     }
     WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE) | tmpReg));
 
     /* set start parsing offset */
     WRITE_UINT32(*p_BmiPrsStartOffset, p_FmPcdPrsStart->parsingOffset);
-    RELEASE_LOCK(p_FmPort->lock);
+    XX_UnlockSpinlock(p_FmPort->h_Spinlock);
 
     return E_OK;
 }
@@ -3918,12 +4469,12 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortQmiRegs *p_FmPortQmiRegs;
-    t_Error         err = E_OK;
-    char            arr[30];
-    uint8_t         flag;
-    int             i=0;
+    t_FmPort        	*p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         	err = E_OK;
+    char            	arr[30];
+    uint8_t         	flag;
+    int             	i=0;
+    t_FmRevisionInfo 	revInfo;
 
     DECLARE_DUMP;
 
@@ -3932,8 +4483,6 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
 
-    p_FmPortQmiRegs = p_FmPort->p_FmPortQmiRegs;
-
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
@@ -3951,7 +4500,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         case (e_FM_PORT_TYPE_RX_10G):
             strcpy(arr, "PORT_TYPE_RX_10G");
             flag = 1;
-          break;
+            break;
         case (e_FM_PORT_TYPE_TX):
             strcpy(arr, "PORT_TYPE_TX");
             flag = 2;
@@ -3961,8 +4510,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
             flag = 2;
             break;
         default:
-            return E_INVALID_VALUE;
-            break ;
+            return ERROR_CODE(E_INVALID_VALUE);
     }
 
     DUMP_TITLE(p_FmPort->hardwarePortId, ("PortId for %s %d", arr, p_FmPort->portId ));
@@ -4001,6 +4549,19 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
+
+        FmGetRevision(p_FmPort->h_Fm, &revInfo);
+		if ((revInfo.majorRev > 3) && (revInfo.minorRev == 0))
+    	{
+    		DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
+
+			DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS)
+			{
+				DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi[i], sizeof(uint32_t));
+			}
+			DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
+    	}
+
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
@@ -4076,7 +4637,6 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdbg);
-
         break;
     case(2):
 
@@ -4106,12 +4666,10 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
-
         break;
 
    default:
-       RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
-        break;
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
     }
 
 
@@ -4146,11 +4704,24 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
     int                 i;
     uint8_t             mod;
     uint32_t            tmpReg = 0;
+    t_FmRevisionInfo 	revInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("available for Tx ports only"));
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+
+	if ((revInfo.majorRev > 3) && (revInfo.minorRev == 0))
+    {
+    	if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    }
+    else
+    	if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_RX) )
+    		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+
 
     /* to minimize memory access (groups may belong to the same regsiter, and may
     be out of order), we first collect all information into a 256 booleans array,
@@ -4187,11 +4758,23 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     int                 i;
     uint8_t             mod;
     uint32_t            tmpReg = 0;
+    t_FmRevisionInfo 	revInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("available for Rx ports only"));
+    FmGetRevision(p_FmPort->h_Fm, &revInfo);
+
+	if ((revInfo.majorRev > 3) && (revInfo.minorRev == 0))
+    {
+    	if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    }
+    else
+    	if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    			(p_FmPort->portType != e_FM_PORT_TYPE_RX) )
+    		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
 
     /* to minimize memory access (groups may belong to the same regsiter, and may
     be out of order), we first collect all information into a 256 booleans array,
@@ -4218,4 +4801,60 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     return  E_OK;
 
 }
+#ifdef VERIFICATION_SUPPORT
+#ifdef SC1023
+void FM_PORT_BackdoorSet (t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset, uint32_t value)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN(h_FmPort, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM_BMI:
+            base = (uint32_t)(p_FmPort->p_FmPortBmiRegs) ;
+            break;
+        case e_MODULE_ID_FM_QMI:
+            base = (uint32_t)(p_FmPort->p_FmPortQmiRegs) ;
+            break;
+        case e_MODULE_ID_FM_PRS:
+            base = (uint32_t)(p_FmPort->p_FmPortPrsRegs) ;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return;
+
+    }
+    WRITE_UINT32(*(uint32_t*)(base+offset), value);
+}
+
+uint32_t      FM_PORT_BackdoorGet(t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset)
+{
+    t_FmPort            *p_FmPort= (t_FmPort *)h_FmPort;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM_BMI:
+            base = (uint32_t)(p_FmPort->p_FmPortBmiRegs) ;
+            break;
+        case e_MODULE_ID_FM_QMI:
+            base = (uint32_t)(p_FmPort->p_FmPortQmiRegs) ;
+            break;
+        case e_MODULE_ID_FM_PRS:
+            base = (uint32_t)(p_FmPort->p_FmPortPrsRegs) ;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+
+    }
+
+    return GET_UINT32(*(uint32_t*)(base+offset));
+}
+#endif /*SC1023*/
+#endif /*VERIFICATION_SUPPORT*/
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 509607d..2146ac5 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -63,26 +63,28 @@
 *//***************************************************************************/
 #define DEFAULT_PORT_deqHighPriority                    TRUE
 #define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 #define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_FULL_PREFETCH
 #define DEFAULT_PORT_deqPrefetchOption_HC               e_FM_PORT_DEQ_NO_PREFETCH
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 #define DEFAULT_PORT_deqByteCnt                         2000
 #define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
 #define DEFAULT_PORT_bufferPrefixContent_passPrsResult  FALSE
 #define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
 #define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo    FALSE
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
 #define DEFAULT_PORT_bufferPrefixContent_debugInfo      FALSE
-#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+#endif /* DEBUG */
 #define DEFAULT_PORT_bufferPrefixContent_dataAlign      DATA_ALIGNMENT
 #define DEFAULT_PORT_cheksumLastBytesIgnore             0
 #define DEFAULT_PORT_cutBytesFromEnd                    4
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          1
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          2
 #define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          2
 #define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         8
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
-#define DEFAULT_PORT_rxFifoPriElevationLevel            (160*KILOBYTE)
-#define DEFAULT_PORT_rxFifoThreshold                    (128*KILOBYTE)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
+#define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
 #define DEFAULT_PORT_frmDiscardOverride                 FALSE
 #define DEFAULT_PORT_dmaSwapData                        e_FM_PORT_DMA_NO_SWP
 #define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
@@ -96,6 +98,9 @@
 #define DEFAULT_PORT_syncReq                            TRUE
 #define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
 #define DEFAULT_PORT_errorsToDiscard                    FM_PORT_FRM_ERR_CLS_DISCARD
+#define DEFAULT_dualRateLimitScaleDown                  e_FM_PORT_DUAL_RATE_LIMITER_NONE
+#define DEFAULT_rateLimitBurstSizeHighGranularity       FALSE
+#define DEFAULT_exception                               IM_EV_BSY
 
 /* Host command port MUST NOT be changed to more than 1 !!! */
 #define DEFAULT_PORT_numOfTasks(type)                   \
@@ -113,8 +118,8 @@
                  (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
 
 #define DEFAULT_PORT_numOfOpenDmas(type)                \
-    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
-                (type == e_FM_PORT_TYPE_TX_10G)) ? 4 : 1)
+    (uint32_t)((type == e_FM_PORT_TYPE_TX_10G) ? 10 :   \
+               ((type == e_FM_PORT_TYPE_RX_10G) ? 4 : 1))
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)           \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
@@ -128,7 +133,7 @@
                 (type == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :  \
                (((type == e_FM_PORT_TYPE_RX) ||                     \
                  (type == e_FM_PORT_TYPE_TX) ||                     \
-                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1*KILOBYTE)))
+                 (type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1536)))
 
 #define DEFAULT_PORT_extraSizeOfFifo(type)              \
     (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
@@ -137,9 +142,10 @@
 #define DEFAULT_PORT_txBdRingLength                 16
 #define DEFAULT_PORT_rxBdRingLength                 128
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
-#define DEFAULT_PORT_Im_fwExtStructsMemAttr         MEMORY_ATTR_CACHEABLE
+#define DEFAULT_PORT_ImfwExtStructsMemAttr          MEMORY_ATTR_CACHEABLE
 
 #define OH_PIPELINE_DEPTH                           2
+
 /**************************************************************************//**
  @Description       Memory Mapped Registers
 *//***************************************************************************/
@@ -149,6 +155,9 @@
 #endif /* defined(__MWERKS__) && ... */
 #define MEM_MAP_START
 
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS	8
+#define FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS	256
+
 typedef _Packed struct
 {
     volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
@@ -174,13 +183,13 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
     volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
     volatile uint32_t   reserved2[0x23];/**< (0x074 0x0FF)  */
-    volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
                                         /**< Buffer Manager pool Information-*/
-    volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
                                         /**< Allocate Counter-*/
     volatile uint32_t   reserved3[8];
-                                        /**< 0x140 - 0x15F reserved -*/
-    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS/32];
+                                        /**< 0x130/0x140 - 0x15F reserved -*/
+    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
                                         /**< Congestion Group Map*/
     volatile uint32_t   fmbm_mpd;       /**< BM Pool Depletion  */
     volatile uint32_t   reserved4[0x1F];/**< (0x184 0x1FF) */
@@ -262,7 +271,17 @@ typedef _Packed struct
     volatile uint32_t   fmbm_ofene;     /**< O/H Frame Enqueue Next Engine  */
     volatile uint32_t   fmbm_orlmts;    /**< O/H Rate Limiter Scale  */
     volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
-    volatile uint32_t   reserved1[0x61];/**< (0x07C - 0x1FF) */
+    volatile uint32_t   reserved0a[0x21];
+                                        /**< 0x07C - 0x0FF Reserved */
+    volatile uint32_t   fmbm_oebmpi[FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS];
+                                        /**< Buffer Manager Observed Pool Information */
+    volatile uint32_t   reserved0b[0x16];
+                                        /**< 0x108 - 0x15F Reserved */
+    volatile uint32_t   fmbm_ocgm;      /**< Observed Congestion Group Map */
+    volatile uint32_t   reserved0c[0x7];/**< 0x164 - 0x17F Reserved */
+    volatile uint32_t   fmbm_ompd;      /**< Observed BMan Pool Depletion */
+    volatile uint32_t   reserved0d[0x1F];
+                                        /**< 0x184 - 0x1FF Reserved */
     volatile uint32_t   fmbm_ostc;      /**< O/H Statistics Counters  */
     volatile uint32_t   fmbm_ofrc;      /**< O/H Frame Counter  */
     volatile uint32_t   fmbm_ofdc;      /**< O/H Frames Discard Counter  */
@@ -371,6 +390,7 @@ typedef _Packed struct
  @Description       BMI defines
 *//***************************************************************************/
 #define BMI_PORT_CFG_EN                         0x80000000
+#define BMI_PORT_CFG_EN_MACSEC                  0x00800000
 #define BMI_PORT_CFG_FDOVR                      0x02000000
 #define BMI_PORT_CFG_IM                         0x01000000
 #define BMI_PORT_STATUS_BSY                     0x80000000
@@ -388,9 +408,14 @@ typedef _Packed struct
 #define BMI_CMD_RX_MR_DEF                       (BMI_CMD_MR_LEAC | BMI_CMD_MR_SLEAC | BMI_CMD_MR_MA | BMI_CMD_MR_DEAS)
 #define BMI_CMD_ATTR_ORDER                      0x80000000
 #define BMI_CMD_ATTR_SYNC                       0x02000000
+#define BMI_CMD_ATTR_MACCMD_MASK                0x0000ff00
+#define BMI_CMD_ATTR_MACCMD_OVERRIDE            0x00008000
+#define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
+#define BMI_CMD_ATTR_MACCMD_SC_MASK             0x00000f00
 
 #define BMI_EXT_BUF_POOL_VALID                  0x80000000
 #define BMI_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define BMI_EXT_BUF_POOL_BACKUP                 0x20000000
 #define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
 #define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA|\
                                                 FM_PORT_FRM_ERR_PHYSICAL        |\
@@ -404,6 +429,7 @@ typedef _Packed struct
                                                 FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
                                                 FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
                                                 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED |\
                                                 FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
                                                 FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW))
@@ -413,6 +439,11 @@ typedef _Packed struct
                                                   FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT))
 
 #define BMI_RATE_LIMIT_EN                       0x80000000
+#define BMI_RATE_LIMIT_BURST_SIZE_GRAN          0x80000000
+#define BMI_RATE_LIMIT_SCALE_BY_2               0x00000001
+#define BMI_RATE_LIMIT_SCALE_BY_4               0x00000002
+#define BMI_RATE_LIMIT_SCALE_BY_8               0x00000003
+
 #define BMI_PRS_RESULT_HIGH                     0x00000000
 #define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
 
@@ -425,6 +456,7 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
                                                  FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
                                                  FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                 FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED |\
                                                  FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
                                                  FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
@@ -434,12 +466,13 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 
 /* shifts */
+#define BMI_PORT_CFG_MS_SEL_SHIFT               16
 #define BMI_DMA_ATTR_SWP_SHIFT                  30
 #define BMI_DMA_ATTR_IC_CACHE_SHIFT             28
 #define BMI_DMA_ATTR_HDR_CACHE_SHIFT            26
 #define BMI_DMA_ATTR_SG_CACHE_SHIFT             24
 
-#define BMI_RIM_FOF_SHIFT                       28
+#define BMI_IM_FOF_SHIFT                        28
 #define BMI_PR_PORTID_SHIFT                     24
 
 #define BMI_RX_FIFO_PRI_ELEVATION_SHIFT         16
@@ -459,6 +492,10 @@ typedef _Packed struct
 
 #define BMI_CMD_ATTR_COLOR_SHIFT                26
 #define BMI_CMD_ATTR_COM_MODE_SHIFT             16
+#define BMI_CMD_ATTR_MACCMD_SHIFT               8
+#define BMI_CMD_ATTR_MACCMD_OVERRIDE_SHIFT      15
+#define BMI_CMD_ATTR_MACCMD_SECURED_SHIFT       12
+#define BMI_CMD_ATTR_MACCMD_SC_SHIFT            8
 
 #define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         16
 #define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
@@ -499,6 +536,7 @@ typedef _Packed struct
 #define MAX_NUM_OF_DMAS                         16
 #define MAX_NUM_OF_EXTRA_DMAS                   8
 #define MAX_BURST_SIZE                          1024
+#define FRAG_EXTRA_SPACE                        32
 
 /**************************************************************************//**
  @Description       QMI defines
@@ -519,11 +557,9 @@ typedef _Packed struct
 #define QMI_DEQ_CFG_TYPE2                       0x20000000
 #define QMI_DEQ_CFG_TYPE3                       0x30000000
 
+#define QMI_DEQ_CFG_SUBPORTAL_MASK              0x1f
 #define QMI_DEQ_CFG_SUBPORTAL_SHIFT             20
 
-/* sizes */
-#define MAX_QMI_DEQ_SUBPORTAL                   15
-
 /**************************************************************************//**
  @Description       PARSER defines
 *//***************************************************************************/
@@ -537,6 +573,7 @@ typedef _Packed struct
 
 #define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
 #define PRS_HDR_IPV6_ROUTE_HDR_DIS              0x00008000
+#define PRS_HDR_PPPOE_MTU_CHECK_EN              0x80000000
 #define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
 #define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
 #define PRS_CAC_STOP                            0x00000001
@@ -615,6 +652,12 @@ typedef _Packed struct
 
 #define IM_MODE_SET_BO(val)                     (uint32_t)((val << (31-IM_MODE_BO_SHIFT)) & IM_MODE_BO_MASK)
 
+#define IM_RXQD_BSYINTM                         0x0008
+#define IM_RXQD_RXFINTM                         0x0010
+#define IM_RXQD_FPMEVT_SEL_MASK                 0x0003
+
+#define IM_EV_BSY                               0x40000000
+#define IM_EV_RX                                0x80000000
 
 typedef struct {
     t_Handle                    h_FmMuram;
@@ -668,62 +711,69 @@ typedef struct{
     uint32_t      timeStampOffset;
     uint32_t      hashResultOffset;
     uint32_t      pcdInfoOffset;
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint32_t      manipOffset;
+#ifdef DEBUG
     uint32_t      debugOffset;
-#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+#endif /* DEBUG */
     } t_FmPortBufferOffsets;
 
 typedef struct
 {
-    uint32_t                    dfltFqid;
-    uint32_t                    confFqid;
-    uint32_t                    errFqid;
-    uint64_t                    baseAddr;
-    uint8_t                     deqSubPortal;
-    bool                        deqHighPriority;
-    e_FmPortDeqType             deqType;
-    e_FmPortDeqPrefetchOption   deqPrefetchOption;
-    uint16_t                    deqByteCnt;
-    uint8_t                     cheksumLastBytesIgnore;
-    uint8_t                     cutBytesFromEnd;
-    t_FmPortBufPoolDepletion    bufPoolDepletion;
-    uint8_t                     pipelineDepth;
-    uint16_t                    fifoLowComfLevel;
-    bool                        frmDiscardOverride;
-    bool                        enRateLimit;
-    t_FmPortRateLimit           rateLimit;
-    bool                        enBufPoolDepletion;
-    uint16_t                    partitionId;
-    t_FmPortRxExtPools          rxExtBufPools;
-    t_FmPortRsrc                openDmas;
-    t_FmPortRsrc                tasks;
-    t_FmPortRsrc                fifoBufs;
-    e_FmPortDmaSwap             dmaSwapData;
-    e_FmPortDmaCache            dmaIntContextCacheAttr;
-    e_FmPortDmaCache            dmaHeaderCacheAttr;
-    e_FmPortDmaCache            dmaScatterGatherCacheAttr;
-    bool                        dmaReadOptimize;
-    bool                        dmaWriteOptimize;
-    uint32_t                    txFifoMinFillLevel;
-    uint32_t                    txFifoLowComfLevel;
-    uint32_t                    rxFifoPriElevationLevel;
-    uint32_t                    rxFifoThreshold;
-    t_FmPortBufMargins          bufMargins;
-    t_FmPortIntContextDataCopy  intContext;
-    bool                        syncReq;
-    e_FmPortColor               color;
-    fmPortFrameErrSelect_t      errorsToDiscard;
-    fmPortFrameErrSelect_t      errorsToEnq;
-//    uint32_t                    timeStampPeriod;
-    uint8_t                     count1MicroBit;
-    uint64_t                    fmMuramPhysBaseAddr;
-    bool                        forwardReuseIntContext;
-    bool                        l4Checksum;
-    t_FmPortBufferPrefixContent bufferPrefixContent;
+    uint32_t                            dfltFqid;
+    uint32_t                            confFqid;
+    uint32_t                            errFqid;
+    uint64_t                            baseAddr;
+    uint8_t                             deqSubPortal;
+    bool                                deqHighPriority;
+    e_FmPortDeqType                     deqType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    e_FmPortDeqPrefetchOption           deqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+    uint16_t                            deqByteCnt;
+    uint8_t                             cheksumLastBytesIgnore;
+    uint8_t                             cutBytesFromEnd;
+    t_FmPortBufPoolDepletion            bufPoolDepletion;
+    uint8_t                             pipelineDepth;
+    uint16_t                            fifoLowComfLevel;
+    bool                                frmDiscardOverride;
+    bool                                enRateLimit;
+    t_FmPortRateLimit                   rateLimit;
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;
+    bool                                enBufPoolDepletion;
+    uint16_t                            partitionId;
+    uint16_t                            liodnBase;
+    t_FmPortExtPools                    extBufPools;
+    t_FmPortRsrc                        openDmas;
+    t_FmPortRsrc                        tasks;
+    t_FmPortRsrc                        fifoBufs;
+    e_FmPortDmaSwap                     dmaSwapData;
+    e_FmPortDmaCache                    dmaIntContextCacheAttr;
+    e_FmPortDmaCache                    dmaHeaderCacheAttr;
+    e_FmPortDmaCache                    dmaScatterGatherCacheAttr;
+    bool                                dmaReadOptimize;
+    bool                                dmaWriteOptimize;
+    uint32_t                            txFifoMinFillLevel;
+    uint32_t                            txFifoLowComfLevel;
+    uint32_t                            rxFifoPriElevationLevel;
+    uint32_t                            rxFifoThreshold;
+    t_FmPortBufMargins                  bufMargins;
+    t_FmPortIntContextDataCopy          intContext;
+    bool                                syncReq;
+    e_FmPortColor                       color;
+    fmPortFrameErrSelect_t              errorsToDiscard;
+    fmPortFrameErrSelect_t              errorsToEnq;
+    uint64_t                            fmMuramPhysBaseAddr;
+    bool                                forwardReuseIntContext;
+    bool                                l4Checksum;
+    t_FmPortBufferPrefixContent         bufferPrefixContent;
+    uint8_t                             internalBufferOffset;
+    t_FmPortBackupBmPools               *p_BackupBmPools;
+    bool                                dontReleaseBuf;
+    uint16_t                            largestBufSize;
 #ifdef VERIFICATION_SUPPORT
-    bool                        intContextConfigured;
+    bool                                intContextConfigured;
 #endif
-}t_FmPortDriverParam;
+} t_FmPortDriverParam;
 
 typedef struct
 {
@@ -731,6 +781,7 @@ typedef struct
     t_Handle                    h_FmPcd;
     uint8_t                     portId;
     e_FmPortType                portType;
+    int                         enabled;
     char                        name[MODULE_NAME_SIZE];
     uint8_t                     hardwarePortId;
     uint16_t                    fmClkFreq;
@@ -740,7 +791,7 @@ typedef struct
     fmPcdEngines_t              pcdEngines;
     uint32_t                    savedBmiNia;
     uint8_t                     netEnvId;
-    uint32_t                    optArray[FM_PCD_MAX_NUM_OF_OPTIONS];
+    uint32_t                    optArray[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
     uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
     uint8_t                     privateInfo;
     uint32_t                    schemesPerPortVector;
@@ -756,14 +807,17 @@ typedef struct
     uint8_t                     txFifoDeqPipelineDepth;
     t_FmPortDriverParam         *p_FmPortDriverParam;
     volatile bool               lock;
+    t_Handle                    h_Spinlock;
     t_FmPortExceptionCallback   *f_Exception;
     t_Handle                    h_App;
+    uint8_t                     internalBufferOffset;
+    uint8_t                     fmanCtrlEventId;
+    uint32_t                    exceptions;
+    bool                        polling;
+    uint8_t                     numOfTasks;
+    t_FmPortExtPools            extBufPools;
 } t_FmPort;
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
-t_Error FmPortDeletePcd(t_Handle h_FmPort);
-#endif
 
 t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
 t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
@@ -775,13 +829,16 @@ t_Error FmPortImEnable  (t_FmPort *p_FmPort);
 t_Error FmPortImDisable (t_FmPort *p_FmPort);
 t_Error FmPortImRx      (t_FmPort *p_FmPort);
 
+void    FmPortSetMacsecLcv(t_Handle h_FmPort);
+void    FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci);
+
 
-static __inline__ uint8_t * BD_BUFFER (t_FmImBd *p_Bd)
+static __inline__ uint8_t * BdBufferGet (t_PhysToVirt *f_PhysToVirt, t_FmImBd *p_Bd)
 {
-    uint64_t    physAddr = (uint64_t)((uint64_t)GET_UINT16(p_Bd->buff.high) << 32);
+    uint64_t    physAddr = (uint64_t)((uint64_t)GET_UINT8(p_Bd->buff.high) << 32);
     physAddr |= GET_UINT32(p_Bd->buff.low);
 
-    return (uint8_t *)XX_PhysToVirt((physAddress_t)(physAddr));
+    return (uint8_t *)f_PhysToVirt((physAddress_t)(physAddr));
 }
 
 static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t value)
@@ -790,9 +847,9 @@ static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t valu
     WRITE_UINT32(fmPhysAddr->low,(uint32_t)value);
 }
 
-static __inline__ void BD_BUFFER_SET(t_FmImBd *p_Bd, uint8_t *p_Buffer)
+static __inline__ void BdBufferSet(t_VirtToPhys *f_VirtToPhys, t_FmImBd *p_Bd, uint8_t *p_Buffer)
 {
-    uint64_t    physAddr = (uint64_t)(XX_VirtToPhys(p_Buffer));
+    uint64_t    physAddr = (uint64_t)(f_VirtToPhys(p_Buffer));
     SET_ADDR(&p_Bd->buff, physAddr);
 }
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 4c02f74..5c8f6a1 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -46,30 +46,25 @@
 #define TX_CONF_STATUS_UNSENT 0x1
 
 #ifdef CORE_8BIT_ACCESS_ERRATA
-#define MY_WRITE_UINT16(addr, val)                          \
-do {                                                        \
-    if (addr%4)                                             \
-    {                                                       \
-        uint32_t    newAddr = (uint32_t)((addr>>2)<<2);     \
-        uint32_t    tmp = GET_UINT32(newAddr);              \
-        tmp = (uint32_t)((tmp & 0xffff0000) | val);         \
-        WRITE_UINT32(newAddr, tmp);                         \
-    }                                                       \
-    else                                                    \
-    {                                                       \
-        uint32_t    tmp = GET_UINT32(addr);                 \
-        tmp = (uint32_t)((tmp & 0x0000ffff) | (((uint32_t)val)<<16));\
-        WRITE_UINT32(addr, tmp);                            \
-    }                                                       \
-} while (0)
-
-#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
-#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
-#else
-#define MY_WRITE_UINT16 WRITE_UINT16
-#define MY_GET_UINT16   GET_UINT16
+#undef WRITE_UINT16
+#undef GET_UINT16
+
+#define WRITE_UINT16(addr, val)  \
+    do{                             \
+            if((int)&(addr) % 4)    \
+                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
+                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
+            else                    \
+                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
+                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
+      }while(0);
+
+#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
+       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
+       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
 #endif /* CORE_8BIT_ACCESS_ERRATA */
 
+
 typedef enum e_TxConfType
 {
      e_TX_CONF_TYPE_CHECK      = 0  /**< check if all the buffers were touched by the muxator, no confirmation callback */
@@ -78,6 +73,20 @@ typedef enum e_TxConfType
 } e_TxConfType;
 
 
+static void ImException(t_Handle h_FmPort, uint32_t event)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    ASSERT_COND(((event & IM_EV_RX) && FmIsMaster(p_FmPort->h_Fm)) ||
+                !FmIsMaster(p_FmPort->h_Fm));
+
+    if (event & IM_EV_RX)
+        FmPortImRx(p_FmPort);
+    if ((event & IM_EV_BSY) && p_FmPort->f_Exception)
+        p_FmPort->f_Exception(p_FmPort->h_App, e_FM_PORT_EXCEPTION_IM_BUSY);
+}
+
+#ifdef UNDER_CONSTRUCTION_FM
 static void DiscardCurrentTxFrame(t_FmPort *p_FmPort)
 {
     uint16_t   cleanBdId = p_FmPort->im.firstBdOfFrameId;
@@ -97,8 +106,10 @@ static void DiscardCurrentTxFrame(t_FmPort *p_FmPort)
         cleanBdId = GetNextBdId(p_FmPort, cleanBdId);
     } while (cleanBdId != p_FmPort->im.currBdId);
 
+    p_FmPort->im.currBdId = cleanBdId;
     p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
 }
+#endif /* UNDER_CONSTRUCTION_FM */
 
 static t_Error TxConf(t_FmPort *p_FmPort, e_TxConfType confType)
 {
@@ -128,12 +139,12 @@ static t_Error TxConf(t_FmPort *p_FmPort, e_TxConfType confType)
             {
                 if ((confType == e_TX_CONF_TYPE_FLUSH) && (bdStatus & BD_R_E))
                     p_FmPort->im.f_TxConf(p_FmPort->h_App,
-                                          BD_BUFFER(BD_GET(confBdId)),
+                                          BdBufferGet(XX_PhysToVirt, BD_GET(confBdId)),
                                           TX_CONF_STATUS_UNSENT,
                                           p_FmPort->im.p_BdShadow[confBdId]);
                 else
                     p_FmPort->im.f_TxConf(p_FmPort->h_App,
-                                          BD_BUFFER(BD_GET(confBdId)),
+                                          BdBufferGet(XX_PhysToVirt, BD_GET(confBdId)),
                                           0,
                                           p_FmPort->im.p_BdShadow[confBdId]);
             }
@@ -172,18 +183,34 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
     uint16_t                length;
     uint16_t                errors/*, reportErrors*/;
     uint8_t                 *p_CurData, *p_Data;
+    uint32_t                flags;
 
     ASSERT_COND(p_FmPort);
 
+    flags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    if (p_FmPort->lock)
+    {
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, flags);
+        return E_OK;
+    }
+    p_FmPort->lock = TRUE;
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, flags);
+
     bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
 
     while (!(bdStatus & BD_R_E)) /* while there is data in the Rx BD */
     {
+        if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_NewUserPriv)) == NULL)
+        {
+            p_FmPort->lock = FALSE;
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+        }
+
         if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
             p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
 
         errors = 0;
-        p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+        p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
         h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
         length = (uint16_t)((bdStatus & BD_L) ?
                             ((bdStatus & BD_LENGTH_MASK) - p_FmPort->im.rxFrameAccumLength):
@@ -202,10 +229,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
             p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
         }
 
-        if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_NewUserPriv)) == NULL)
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
-
-        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+        BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, BD_GET(p_FmPort->im.currBdId), p_Data);
 
         BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
 
@@ -213,8 +237,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
 
         p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
-
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
         /* Pass the buffer if one of the conditions is true:
         - There are no errors
         - This is a part of a larger frame ( the application has already received some buffers )
@@ -232,11 +255,14 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
                                               p_CurData,
                                               h_CurrUserPriv))
+        {
+            p_FmPort->lock = FALSE;
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Failed freeing data buffer"));
+        }
 
         bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
     }
-
+    p_FmPort->lock = FALSE;
     return E_OK;
 }
 
@@ -251,8 +277,8 @@ t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
     p_FmPort->im.dataMemId                      = p_FmPortParams->specificParams.imRxTxParams.dataMemId;
     p_FmPort->im.dataMemAttributes              = p_FmPortParams->specificParams.imRxTxParams.dataMemAttributes;
 
-    p_FmPort->im.fwExtStructsMemId      = DEFAULT_PORT_ImfwExtStructsMemId;
-    p_FmPort->im.fwExtStructsMemAttr    = DEFAULT_PORT_Im_fwExtStructsMemAttr;
+    p_FmPort->im.fwExtStructsMemId              = DEFAULT_PORT_ImfwExtStructsMemId;
+    p_FmPort->im.fwExtStructsMemAttr            = DEFAULT_PORT_ImfwExtStructsMemAttr;
 
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
@@ -261,6 +287,12 @@ t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
         p_FmPort->im.rxPool.f_GetBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_GetBuf;
         p_FmPort->im.rxPool.f_PutBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PutBuf;
         p_FmPort->im.rxPool.bufferSize      = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.bufferSize;
+        p_FmPort->im.rxPool.f_PhysToVirt    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PhysToVirt;
+        if (!p_FmPort->im.rxPool.f_PhysToVirt)
+            p_FmPort->im.rxPool.f_PhysToVirt = XX_PhysToVirt;
+        p_FmPort->im.rxPool.f_VirtToPhys    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_VirtToPhys;
+        if (!p_FmPort->im.rxPool.f_VirtToPhys)
+            p_FmPort->im.rxPool.f_VirtToPhys = XX_VirtToPhys;
         p_FmPort->im.f_RxStore              = p_FmPortParams->specificParams.imRxTxParams.f_RxStore;
 
         p_FmPort->im.mrblr                  = 0x8000;
@@ -273,6 +305,12 @@ t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
         if (p_FmPort->im.mrblr != p_FmPort->im.rxPool.bufferSize)
             DBG(WARNING, ("Max-Rx-Buffer-Length set to %d", p_FmPort->im.mrblr));
         p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
+        p_FmPort->exceptions                = DEFAULT_exception;
+        if (FmIsMaster(p_FmPort->h_Fm))
+            p_FmPort->polling               = FALSE;
+        else
+            p_FmPort->polling               = TRUE;
+        p_FmPort->fmanCtrlEventId           = (uint8_t)NO_IRQ;
     }
     else
     {
@@ -299,8 +337,21 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must be power of 2!!!"));
         if (p_FmPort->im.mrblr < 256)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
-        if(p_FmPort->p_FmPortDriverParam->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+        if(p_FmPort->p_FmPortDriverParam->partitionId & ~FM_LIODN_OFFSET_MASK)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId is larger than %d", FM_LIODN_OFFSET_MASK+1));
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            {
+                if(p_FmPort->p_FmPortDriverParam->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+                {
+                    p_FmPort->p_FmPortDriverParam->partitionId =
+                        (uint16_t)(p_FmPort->p_FmPortDriverParam->partitionId & (FM_MAX_NUM_OF_PARTITIONS-1));
+                    DBG(WARNING, ("partitionId number is out of rev1 range - MSB bits cleard."));
+                }
+            }
+        }
 /* TODO - add checks */
     }
     else
@@ -319,6 +370,9 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
     uint16_t    log2Num;
     uint8_t     *p_Data/*, *p_Tmp*/;
     int         i;
+    t_Error     err;
+    uint16_t    tmpReg16;
+    uint32_t    tmpReg32;
 
     ASSERT_COND(p_FmPort);
 
@@ -331,10 +385,22 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
+#ifdef FM_IM_LARGE_MRBLR_ERRATA_FMANb
+         {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 4) && (revInfo.minorRev == 0))
+                if (p_FmPort->im.mrblr > 1024)
+                {
+                    p_FmPort->im.mrblr = 1024;
+                    DBG(WARNING, ("Max-Rx-Buffer-Length set to %d", p_FmPort->im.mrblr));
+                }
+        }
+#endif /* FM_IM_LARGE_MRBLR_ERRATA_FMANb */
         p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
         if (!p_FmPort->im.p_BdRing)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD ring!!!"));
-        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+        IOMemSet32(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
         if (!p_FmPort->im.p_BdShadow)
@@ -349,7 +415,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
 
             if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_BufContext)) == NULL)
                 RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
-            BD_BUFFER_SET(p_Bd, p_Data);
+            BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, p_Bd, p_Data);
             p_FmPort->im.p_BdShadow[i] = h_BufContext;
         }
 
@@ -364,24 +430,53 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
 
         LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
 
         /* Initialize Rx QD */
         tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
         SET_ADDR(&p_FmPort->im.p_FmPortImPram->rxQd.bdRingBase, tmpPhysBase);
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
                      (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+        if (!p_FmPort->polling || p_FmPort->exceptions)
+        {
+            /* Allocate, configure and register interrupts */
+            err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
+            tmpReg16 = (uint16_t)(p_FmPort->fmanCtrlEventId & IM_RXQD_FPMEVT_SEL_MASK);
+            tmpReg32 = 0;
+
+            if(p_FmPort->exceptions & IM_EV_BSY)
+            {
+                tmpReg16 |= IM_RXQD_BSYINTM;
+                tmpReg32 |= IM_EV_BSY;
+            }
+            if(!p_FmPort->polling)
+            {
+                tmpReg16 |= IM_RXQD_RXFINTM;
+                tmpReg32 |= IM_EV_RX;
+            }
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+
+            FmRegisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, ImException , (t_Handle)p_FmPort);
+
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+        }
+        else
+            p_FmPort->fmanCtrlEventId = (uint8_t)NO_IRQ;
     }
     else
     {
         p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
         if (!p_FmPort->im.p_BdRing)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Tx BD ring!!!"));
-        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+        IOMemSet32(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
         if (!p_FmPort->im.p_BdShadow)
@@ -402,7 +497,7 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
         /* Initialize Tx QD */
         tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
         SET_ADDR(&p_FmPort->im.p_FmPortImPram->txQd.bdRingBase, tmpPhysBase);
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
 
         /* Update the IM PRAM address in the BMI */
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
@@ -410,6 +505,13 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
                                 p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
     }
 
+#if 0 //def FM_MACSEC_SUPPORT
+	if (((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)) &&
+         (p_FmPort->portId == 0))
+        FmPortSetMacsecCmd(p_FmPort, 15);
+#endif /* FM_MACSEC_SUPPORT */
+
     return E_OK;
 }
 
@@ -426,7 +528,18 @@ void FmPortImFree(t_FmPort *p_FmPort)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
-        /* Try first clean what has recieved */
+        if (!p_FmPort->polling || p_FmPort->exceptions)
+        {
+            /* De-Allocate and unregister interrupts */
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, 0);
+
+            FmFreeFmanCtrlEventReg(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, 0);
+
+            FmUnregisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+        }
+        /* Try first clean what has received */
         FmPortImRx(p_FmPort);
 
         /* Now, get rid of the the empty buffer! */
@@ -434,9 +547,9 @@ void FmPortImFree(t_FmPort *p_FmPort)
 
         while (bdStatus & BD_R_E) /* while there is data in the Rx BD */
         {
-            p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+            p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
 
-            BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), NULL);
+            BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, BD_GET(p_FmPort->im.currBdId), NULL);
             BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
 
             p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
@@ -497,6 +610,105 @@ t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
     return E_OK;
 }
 
+t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort, 
+                                                       uint8_t  memId, 
+                                                       uint32_t memAttributes)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.fwExtStructsMemId              = memId;
+    p_FmPort->im.fwExtStructsMemAttr            = memAttributes;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    if (!FmIsMaster(p_FmPort->h_Fm))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available on master-partition only;"
+                                                  "in guest-partiotions, IM is always in polling!"));
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->polling = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error     err;
+    uint16_t    tmpReg16;
+    uint32_t    tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if(exception == e_FM_PORT_EXCEPTION_IM_BUSY)
+    {
+        if(enable)
+        {
+            p_FmPort->exceptions |= IM_EV_BSY;
+            if(p_FmPort->fmanCtrlEventId == NO_IRQ)
+            {
+                /* Allocate, configure and register interrupts */
+                err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
+
+                FmRegisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, ImException, (t_Handle)p_FmPort);
+                tmpReg16 = (uint16_t)((p_FmPort->fmanCtrlEventId & IM_RXQD_FPMEVT_SEL_MASK) | IM_RXQD_BSYINTM);
+                tmpReg32 = IM_EV_BSY;
+            }
+            else
+            {
+                tmpReg16 = (uint16_t)(GET_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen) | IM_RXQD_BSYINTM);
+                tmpReg32 = FmGetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId) | IM_EV_BSY;
+            }
+
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+        }
+        else
+        {
+            p_FmPort->exceptions &= ~IM_EV_BSY;
+            if (!p_FmPort->exceptions && p_FmPort->polling)
+            {
+                FmFreeFmanCtrlEventReg(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+                FmUnregisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+                FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, 0);
+                WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, 0);
+                p_FmPort->fmanCtrlEventId = (uint8_t)NO_IRQ;
+            }
+            else
+            {
+                tmpReg16 = (uint16_t)(GET_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen) & ~IM_RXQD_BSYINTM);
+                WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+                tmpReg32 = FmGetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId) & ~IM_EV_BSY;
+                FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+            }
+        }
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Invalid exception."));
+
+    return E_OK;
+}
+
 t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
                        uint8_t                *p_Data,
                        uint16_t               length,
@@ -521,11 +733,11 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
         /* Confirm the current BD - BD is available */
         if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConf))
             p_FmPort->im.f_TxConf (p_FmPort->h_App,
-                                   BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                   BdBufferGet(XX_PhysToVirt, BD_GET(p_FmPort->im.currBdId)),
                                    0,
                                    p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
 
-        bdStatus |= length;
+        bdStatus = length;
 
         /* if this is the first BD of a frame */
         if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
@@ -539,7 +751,7 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
         else
             firstBuffer = FALSE;
 
-        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+        BdBufferSet(XX_VirtToPhys, BD_GET(p_FmPort->im.currBdId), p_Data);
         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_BufContext;
 
         /* deal with last */
@@ -556,7 +768,7 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
                 BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.firstBdOfFrameId), p_FmPort->im.txFirstBdStatus);
                 p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
             }
-            MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(GetNextBdId(p_FmPort, p_FmPort->im.currBdId)<<4));
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(GetNextBdId(p_FmPort, p_FmPort->im.currBdId)<<4));
         }
         else if (!firstBuffer) /* mid frame buffer */
             BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), bdStatus | BD_R_E);
@@ -568,13 +780,28 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
         /* Discard current frame. Return error.   */
         if (p_FmPort->im.firstBdOfFrameId != IM_ILEGAL_BD_ID)
         {
-            ASSERT_COND(p_FmPort->im.firstBdOfFrameId != p_FmPort->im.currBdId);
             /* Error:    No free BD */
             /* Response: Discard current frame. Return error.   */
-            DiscardCurrentTxFrame(p_FmPort);
+            uint16_t   cleanBdId = p_FmPort->im.firstBdOfFrameId;
+
+            ASSERT_COND(p_FmPort->im.firstBdOfFrameId != p_FmPort->im.currBdId);
+
+            /* Since firstInFrame is not NULL, one buffer at least has already been
+               inserted into the BD ring. Using do-while covers the situation of a
+               frame spanned throughout the whole Tx BD ring (p_CleanBd is incremented
+               prior to testing whether or not it's equal to TxBd). */
+            do
+            {
+                BD_STATUS_AND_LENGTH_SET(BD_GET(cleanBdId), 0);
+                /* Advance BD pointer */
+                cleanBdId = GetNextBdId(p_FmPort, cleanBdId);
+            } while (cleanBdId != p_FmPort->im.currBdId);
+
+            p_FmPort->im.currBdId = cleanBdId;
+            p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
         }
 
-        return E_FULL;
+        return ERROR_CODE(E_FULL);
     }
 
     return E_OK;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 3e7737b..98126b6 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -46,6 +46,7 @@
 #include "ncsw_ext.h"
 
 #include "fm_rtc.h"
+#include "fm_common.h"
 
 
 /*****************************************************************************/
@@ -104,6 +105,12 @@ static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Trigger %d signal polarity", i));
         }
     }
+#ifdef  FM_1588_SRC_CLK_FMAN1
+    if ((p_RtcDriverParam->srcClk==e_FM_RTC_SOURCE_CLOCK_SYSTEM) && p_RtcDriverParam->invertInputClkPhase)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Can not use invertInputClkPhase when source clock is e_FM_RTC_SOURCE_CLOCK_SYSTEM"));
+
+#endif /* FM_1588_SRC_CLK_FMAN1 */
+
     return E_OK;
 }
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
index 3f11786..3bbfdec 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -44,8 +44,6 @@
 #include "std_ext.h"
 #include "fm_rtc_ext.h"
 
-#include "fm_common.h"
-
 
 #define __ERR_MODULE__  MODULE_FM_RTC
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
index 015a599..b5f89ae 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -58,7 +58,6 @@
 /****************************************/
 static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
-    uint8_t     i;
 
     if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
@@ -90,9 +89,18 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     if(USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq) > DMA_MAX_WATCHDOG)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0xffffffff"));
 
-    for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
-        if (p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_BASE_MASK)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
+#ifdef FM_PARTITION_ARRAY
+    {
+        t_FmRevisionInfo revInfo;
+        uint8_t     i;
+
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
+                if (p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_BASE_MASK)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
+    }
+#endif /* FM_PARTITION_ARRAY */
 
     if(p_Fm->totalFifoSize % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
@@ -126,7 +134,7 @@ static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
         memset(moduleName, 0, MODULE_NAME_SIZE);
         if(Sprint (moduleName, "FM-%d-%d",p_Fm->fmId, p_Fm->intrMng[macEvent].partitionId) != 6)
         fmIpcIsr.pendingReg = pendingReg;
-        fmIpcIsr.err = FALSE;
+        fmIpcIsr.boolErr = FALSE;
         err = XX_SendMessage(moduleName, FM_GUEST_ISR, (uint8_t*)&fmIpcIsr, NULL, NULL);
         if(err)
             REPORT_ERROR(MINOR, err, NO_MSG);
@@ -136,22 +144,6 @@ static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
 }
 #endif /*FM_MASTER_PARTITION */
 
-static uint8_t  GetPartition(t_Fm *p_Fm, uint16_t liodn)
-{
-    int         i;
-    uint32_t    tmpReg;
-
-    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
-    {
-        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2]);
-        if (liodn == (uint16_t)((tmpReg & DMA_HIGH_LIODN_MASK )>> DMA_LIODN_SHIFT))
-            return (uint8_t)i;
-        if (liodn == (uint16_t)(tmpReg & DMA_LOW_LIODN_MASK))
-            return (uint8_t)(i+1);
-    }
-    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Partition not found in LIODN table"));
-    return 0;
-}
 
 static void    BmiErrEvent(t_Fm *p_Fm)
 {
@@ -175,6 +167,8 @@ static void    BmiErrEvent(t_Fm *p_Fm)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
     if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
+    if(event & BMI_ERR_INTR_EN_DISPATCH_RAM_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_DISPATCH_RAM_ECC);
 }
 
 static void    QmiErrEvent(t_Fm *p_Fm)
@@ -202,9 +196,10 @@ static void    DmaErrEvent(t_Fm *p_Fm)
 {
     uint64_t            addr=0;
     uint32_t            status, mask, tmpReg=0;
-    uint8_t             tnum, partition;
+    uint8_t             tnum;
     uint8_t             hardwarePortId;
     uint8_t             relativePortId;
+    uint16_t            liodn;
 
     status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
     mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
@@ -224,22 +219,21 @@ static void    DmaErrEvent(t_Fm *p_Fm)
 
     if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
     {
-        ASSERT_COND(p_Fm->h_FmPorts[((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT)]);
         hardwarePortId = (uint8_t)(((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
-        GET_RELATIVE_PORTID(relativePortId, hardwarePortId);
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
         tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
-        partition = GetPartition(p_Fm, (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK));
+        liodn = (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK);
         ASSERT_COND(p_Fm->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
-        p_Fm->f_BusError(p_Fm->h_App, p_Fm->portsTypes[hardwarePortId] , relativePortId, addr, tnum, partition) ;
+        p_Fm->f_BusError(p_Fm->h_App, p_Fm->portsTypes[hardwarePortId], relativePortId, addr, tnum, liodn);
     }
     if(mask & DMA_MODE_ECC)
     {
         if (status & DMA_STATUS_READ_ECC)
-            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_READ_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_READ_ECC);
         if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
-            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC);
         if (status & DMA_STATUS_FM_WRITE_ECC)
-            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC) ;
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC);
     }
 }
 
@@ -312,25 +306,6 @@ static void QmiEvent(t_Fm *p_Fm)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
 }
 
-static void CtlEvent(t_Fm *p_Fm, uint32_t pending)
-{
-    uint32_t    eventRegBitMask = FPM_EVENT_FM_CTL_0;
-    uint8_t     i;
-    uint32_t    event;
-
-    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
-    {
-       if (pending & eventRegBitMask)
-       {
-            event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i]);
-            /* clear event bits */
-            WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], event);
-            p_Fm->f_FmCtlIsr[i](p_Fm, event);
-       }
-       eventRegBitMask >>= 1;
-    }
-}
-
 static void UnimplementedIsr(t_Handle h_Arg)
 {
     UNUSED(h_Arg);
@@ -338,7 +313,7 @@ static void UnimplementedIsr(t_Handle h_Arg)
     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
 }
 
-static void UnimplementedFmCtlIsr(t_Handle h_Arg, uint32_t event)
+static void UnimplementedFmanCtrlIsr(t_Handle h_Arg, uint32_t event)
 {
     UNUSED(h_Arg); UNUSED(event);
 
@@ -384,6 +359,8 @@ static void FreeInitResources(t_Fm *p_Fm)
        FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr));
     if (p_Fm->fifoBaseAddr)
        FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->fifoBaseAddr));
+    if (p_Fm->resAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->resAddr));
 }
 
 static t_Error ClearIRam(t_Fm *p_Fm)
@@ -397,11 +374,11 @@ static t_Error ClearIRam(t_Fm *p_Fm)
     WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
     while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
 
-    for (i=0; i < (FM_IRAM_SIZE / 4); i++)
+    for (i=0; i < (FM_IRAM_SIZE/4); i++)
         WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
-    WRITE_UINT32(p_Iram->iadd,0x0);
-    /* verify that writing has completed */
+
+    WRITE_UINT32(p_Iram->iadd, FM_IRAM_SIZE - 4);
     while (GET_UINT32(p_Iram->idata) != 0xffffffff) ;
 
     return E_OK;
@@ -415,7 +392,6 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
     uint8_t         compTo16;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-
     /* Enable the auto-increment */
     WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
     while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
@@ -428,9 +404,9 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         for (i=0; i < ((16-compTo16) / 4); i++)
             WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
-    WRITE_UINT32(p_Iram->iadd,0x0);
+    WRITE_UINT32(p_Iram->iadd,p_Fm->p_FmDriverParam->firmware.size-4);
     /* verify that writing has completed */
-    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[0]) ;
+    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[(p_Fm->p_FmDriverParam->firmware.size / 4)-1]) ;
 
     if (p_Fm->p_FmDriverParam->fwVerify)
     {
@@ -443,7 +419,6 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
                               p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
         WRITE_UINT32(p_Iram->iadd, 0x0);
     }
-
     /* Enable patch from IRAM */
     WRITE_UINT32(p_Iram->iready, IRAM_READY);
 
@@ -459,45 +434,133 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
 /****************************************/
 
 #ifdef FM_MASTER_PARTITION
-t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+static t_Error     FmHandleIpcMsg(t_Handle  h_Fm, 
+                                  uint8_t   *p_Msg, 
+                                  uint32_t  msgLength, 
+                                  uint8_t   **p_Reply, 
+                                  uint32_t  *p_ReplyLength)
 {
     t_Fm    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                        msgId;
+    uint8_t                         *p_MsgBody;
 
+UNUSED(p_Reply);UNUSED(p_ReplyLength); /* TODO - change the routine here to use reply msg!!! */
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength > sizeof(uint32_t)), E_INVALID_VALUE);
+    msgId = ((uint32_t *)p_Msg)[0];
+    p_MsgBody = (uint8_t *)(&((uint32_t *)p_Msg)[1]);
 
     switch(msgId)
     {
         case (FM_GET_SET_PORT_PARAMS):
-            return FmGetSetPortParams(h_Fm, (t_FmInterModulePortInitParams*)msgBody);
-         case (FM_RESUME_STALLED_PORT):
-            return FmResumeStalledPort(h_Fm, msgBody[0]);
+        {
+            t_FmInterModulePortInitParams   initParams;
+            t_Error                         err;
+
+            initParams.hardwarePortId = ((t_FmIpcPortInitParams*)p_MsgBody)->hardwarePortId;
+            initParams.portType = (e_FmPortType)((t_FmIpcPortInitParams*)p_MsgBody)->enumPortType;
+            initParams.independentMode = (bool)(((t_FmIpcPortInitParams*)p_MsgBody)->boolIndependentMode);
+            initParams.portPartition = ((t_FmIpcPortInitParams*)p_MsgBody)->portPartition;
+            initParams.numOfTasks = ((t_FmIpcPortInitParams*)p_MsgBody)->numOfTasks;
+            initParams.numOfExtraTasks = ((t_FmIpcPortInitParams*)p_MsgBody)->numOfExtraTasks;
+            initParams.numOfOpenDmas = ((t_FmIpcPortInitParams*)p_MsgBody)->numOfOpenDmas;
+            initParams.numOfExtraOpenDmas = ((t_FmIpcPortInitParams*)p_MsgBody)->numOfExtraOpenDmas;
+            initParams.sizeOfFifo = ((t_FmIpcPortInitParams*)p_MsgBody)->sizeOfFifo;
+            initParams.extraSizeOfFifo = ((t_FmIpcPortInitParams*)p_MsgBody)->extraSizeOfFifo;
+            initParams.deqPipelineDepth = ((t_FmIpcPortInitParams*)p_MsgBody)->deqPipelineDepth;
+            initParams.liodnBase = ((t_FmIpcPortInitParams*)p_MsgBody)->liodnBase;
+            err = FmGetSetPortParams(h_Fm, &initParams);
+            if(err)
+				return err;
+			else
+			{
+                ((t_FmIpcPortInitParams*)p_MsgBody)->fmMuramPhysBaseAddr.high = initParams.fmMuramPhysBaseAddr.high;
+                ((t_FmIpcPortInitParams*)p_MsgBody)->fmMuramPhysBaseAddr.low = initParams.fmMuramPhysBaseAddr.low;
+            }
+        }
+            break;
+        case (FM_RESUME_STALLED_PORT):
+            return FmResumeStalledPort(h_Fm, p_MsgBody[0]);
         case (FM_IS_PORT_STALLED):
-            ((t_FmIpcPortIsStalled*)msgBody)->isStalled = FmIsPortStalled(h_Fm, (uint8_t)(((t_FmIpcPortIsStalled*)msgBody)->hardwarePortId));
+            ((t_FmIpcPortIsStalled*)p_MsgBody)->boolIsStalled = (uint8_t)FmIsPortStalled(h_Fm, (uint8_t)(((t_FmIpcPortIsStalled*)p_MsgBody)->hardwarePortId));
             break;
         case (FM_RESET_MAC):
-        {
-            t_FmIpcMacReset ipcParams;
-            memcpy(msgBody, (uint8_t *)&ipcParams, sizeof(t_FmIpcMacReset));
-            return FmResetMac(p_Fm, (e_FmMacType)ipcParams.type, ipcParams.id);
-        }
+            return FmResetMac(p_Fm, (e_FmMacType)(((t_FmIpcMacParams*)p_MsgBody)->enumType), ((t_FmIpcMacParams*)p_MsgBody)->id);
+        case (FM_SET_MAC_MAX_FRAME):
+            return FmSetMacMaxFrame(p_Fm, (e_FmMacType)(((t_FmIpcMacMaxFrameParams*)p_MsgBody)->macParams.enumType),
+                                    ((t_FmIpcMacMaxFrameParams*)p_MsgBody)->macParams.id,
+                                    ((t_FmIpcMacMaxFrameParams*)p_MsgBody)->maxFrameLength);
         case (FM_GET_CLK_FREQ):
-            *(uint16_t*)msgBody = p_Fm->fmClkFreq;
+            *(uint16_t*)p_MsgBody = p_Fm->fmClkFreq;
             break;
         case (FM_FREE_PORT):
-            FmFreePortParams(h_Fm, (t_FmInterModulePortFreeParams*)msgBody);
+        {
+            t_FmInterModulePortFreeParams   portParams;
+
+            portParams.hardwarePortId = ((t_FmIpcPortFreeParams*)p_MsgBody)->hardwarePortId;
+            portParams.portType = (e_FmPortType)(((t_FmIpcPortFreeParams*)p_MsgBody)->enumPortType);
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+            portParams.deqPipelineDepth = ((t_FmIpcPortFreeParams*)p_MsgBody)->deqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+            FmFreePortParams(h_Fm, &portParams);
+        }
             break;
         case (FM_REGISTER_INTR):
-            p_Fm->intrMng[((t_FmIpcRegisterIntr*)msgBody)->event].partitionId = ((t_FmIpcRegisterIntr*)msgBody)->partitionId;
+            p_Fm->intrMng[((t_FmIpcRegisterIntr*)p_MsgBody)->event].partitionId = ((t_FmIpcRegisterIntr*)p_MsgBody)->partitionId;
             break;
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        case (FM_DUMP_REGS):
+            return FM_DumpRegs(h_Fm);
         case (FM_DUMP_PORT_REGS):
-            return FmDumpPortRegs(h_Fm, msgBody[0]);
+            return FmDumpPortRegs(h_Fm, p_MsgBody[0]);
 #endif /* (defined(DEBUG_ERRORS) && ... */
         case (FM_GET_REV):
+        {
+            t_FmRevisionInfo fmRevInfo;
+
+            FmGetRevision(h_Fm, &fmRevInfo);
+            ((t_FmIpcRevisionInfo*)p_MsgBody)->majorRev = fmRevInfo.majorRev;
+            ((t_FmIpcRevisionInfo*)p_MsgBody)->minorRev = fmRevInfo.minorRev;
+        }
+            break;
+        case (FM_DMA_STAT):
+        {
+            t_FmDmaStatus dmaStatus;
+
+            FM_GetDmaStatus(h_Fm, &dmaStatus);
+            ((t_FmIpcDmaStatus*)p_MsgBody)->boolCmqNotEmpty = (uint8_t)dmaStatus.cmqNotEmpty;
+            ((t_FmIpcDmaStatus*)p_MsgBody)->boolBusError = (uint8_t)dmaStatus.busError;
+            ((t_FmIpcDmaStatus*)p_MsgBody)->boolReadBufEccError = (uint8_t)dmaStatus.readBufEccError;
+            ((t_FmIpcDmaStatus*)p_MsgBody)->boolWriteBufEccSysError = (uint8_t)dmaStatus.writeBufEccSysError;
+            ((t_FmIpcDmaStatus*)p_MsgBody)->boolWriteBufEccFmError = (uint8_t)dmaStatus.writeBufEccFmError;
+        }
+            break;
+        case (FM_ALLOC_FMAN_CTRL_EVENT_REG):
+             return FmAllocFmanCtrlEventReg(h_Fm, p_MsgBody);
+        case (FM_FREE_FMAN_CTRL_EVENT_REG):
+            FmFreeFmanCtrlEventReg(h_Fm, *p_MsgBody);
+            break;
+        case (FM_GET_TIMESTAMP_SCALE):
+            *(uint32_t*)p_MsgBody = FmGetTimeStampScale(h_Fm);
+            break;
         case (FM_GET_COUNTER):
-        case (FM_GET_TIMESTAMP):
-        case (FM_GET_TIMESTAMP_PERIOD):
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+           ((t_FmIpcGetCounter*)p_MsgBody)->val = FM_GetCounter(h_Fm, (e_FmCounters)(((t_FmIpcGetCounter*)p_MsgBody)->enumId));
+            break;
+        case (FM_SET_FMAN_CTRL_EVENTS_ENABLE):
+            FmSetFmanCtrlIntr(h_Fm, ((t_FmIpcFmanEvents*)p_MsgBody)->eventRegId, ((t_FmIpcFmanEvents*)p_MsgBody)->enableEvents);
+            break;
+        case (FM_GET_FMAN_CTRL_EVENTS_ENABLE):
+            ((t_FmIpcFmanEvents*)p_MsgBody)->enableEvents = FmGetFmanCtrlIntr(h_Fm, ((t_FmIpcFmanEvents*)p_MsgBody)->eventRegId);
+            break;
+        case (FM_GET_PHYS_MURAM_BASE):
+        {
+            t_FmPhysAddr physAddr;
+
+            FmGetPhysicalMuramBase(h_Fm, &physAddr);
+            ((t_FmIpcPhysAddr*)p_MsgBody)->high    = physAddr.high;
+            ((t_FmIpcPhysAddr*)p_MsgBody)->low     = physAddr.low;
+            break;
+        }
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
     }
@@ -541,19 +604,43 @@ t_Handle FmGetMuramHandle(t_Handle h_Fm)
     return (p_Fm->h_FmMuram);
 }
 
-t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr)
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
     /* General FM driver initialization */
-    fmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
-    fmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
+    p_FmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
+    p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
 
     return E_OK;
 }
 
+t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint8_t     i;
+
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        if (!p_Fm->usedEventRegs[i])
+        {
+            p_Fm->usedEventRegs[i] = TRUE;
+            *p_EventId = i;
+            break;
+        }
+
+    if (i==FM_NUM_OF_FMAN_CTRL_EVENT_REGS)
+        RETURN_ERROR(MAJOR, E_BUSY, ("No resource - Fman controller event register."));
+
+    return E_OK;
+}
+
+void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
+{
+    ((t_Fm*)h_Fm)->usedEventRegs[eventId] = FALSE;
+}
+
 void FmRegisterIntr(t_Handle h_Fm,
                         e_FmEventModules        module,
                         uint8_t                 modId,
@@ -582,15 +669,43 @@ void FmUnregisterIntr(t_Handle h_Fm,
     GET_FM_MODULE_EVENT(module, modId,intrType, event);
 
     ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
-    p_Fm->intrMng[event].f_Isr = NULL;
+    p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
     p_Fm->intrMng[event].h_SrcHandle = NULL;
 }
 
-void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event))
+void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvents)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
 
-    p_Fm->f_FmCtlIsr[eventRegId] = f_Isr;
+    ASSERT_COND(eventRegId < FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId], enableEvents);
+}
+
+uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId]);
+}
+
+void  FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Arg, uint32_t event), t_Handle    h_Arg)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+
+    p_Fm->fmanCtrlIntr[eventRegId].f_Isr = f_Isr;
+    p_Fm->fmanCtrlIntr[eventRegId].h_SrcHandle = h_Arg;
+}
+
+void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+
+    p_Fm->fmanCtrlIntr[eventRegId].f_Isr = NULL;
+    p_Fm->fmanCtrlIntr[eventRegId].h_SrcHandle = UnimplementedFmanCtrlIsr;
 }
 
 void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
@@ -620,7 +735,6 @@ t_Handle  FmGetPcdHandle(t_Handle h_Fm)
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
 
     return p_Fm->h_Pcd;
-
 }
 
 uint8_t FmGetId(t_Handle h_Fm)
@@ -636,20 +750,13 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
     uint32_t    tmpReg;
-    uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
-    uint8_t     enqTh;
-    uint8_t     deqTh;
-    bool        update = FALSE;
+    uint8_t     hardwarePortId = p_PortParams->hardwarePortId, relativePortId;
+    uint32_t    minFifoSizeRequired = 0;
+    uint16_t    macMaxFrameLength = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    /* return parameters */
-    if (p_PortParams->useRateLimit)
-    {
-        if(!p_Fm->enabledTimeStamp)
-            FmEnableTimeStamp(p_Fm);
-        p_PortParams->count1MicroBit = p_Fm->count1MicroBit;
-    }
+    XX_LockSpinlock(p_Fm->h_Spinlock);
 
     if(p_PortParams->independentMode)
     {
@@ -662,18 +769,23 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         if(p_Fm->hcPortInitialized)
+        {
+            XX_UnlockSpinlock(p_Fm->h_Spinlock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
+        }
         else
             p_Fm->hcPortInitialized = TRUE;
     }
     p_Fm->portsTypes[hardwarePortId] = p_PortParams->portType;
 
-    /* check that there are enough uncommited tasks */
-    if(p_PortParams->numOfExtraTasks > p_Fm->extraTasksPoolSize)
-        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
-
-    if((p_Fm->accumulatedNumOfTasks + p_PortParams->numOfTasks) > p_Fm->totalNumOfTasks-p_Fm->extraTasksPoolSize)
+    p_Fm->extraTasksPoolSize = (uint8_t)MAX(p_Fm->extraTasksPoolSize, p_PortParams->numOfExtraTasks);
+    /* check that there are enough uncommitted tasks */
+    if((p_Fm->accumulatedNumOfTasks + p_PortParams->numOfTasks) >
+       (p_Fm->totalNumOfTasks - p_Fm->extraTasksPoolSize))
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfTasks and extra tasks pool exceed total numOfTasks."));
+    }
     else
     {
         p_Fm->accumulatedNumOfTasks += p_PortParams->numOfTasks;
@@ -681,10 +793,14 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                     (p_PortParams->numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
     }
-
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
+        uint8_t     enqTh;
+        uint8_t     deqTh;
+        bool        update = FALSE;
+
         /* update qmi ENQ/DEQ threshold */
         p_Fm->accumulatedNumOfDeqTnums += p_PortParams->deqPipelineDepth;
         tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
@@ -711,13 +827,37 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         if(update)
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+#ifdef FM_LOW_END_RESTRICTION
+#if 0
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndx,hardwarePortId);
+    if(FM_CHECK_PORT_RESTRICTIONS(p_Fm->portInitialized, swPortIndx))
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
+    }
+#else
+    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+    {
+        if(p_Fm->lowEndRestriction)
+        {
+            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
+        }
+        else
+            p_Fm->lowEndRestriction = TRUE;
+    }
+#endif /* 0 */
+#endif /* FM_LOW_END_RESTRICTION */
 
+    p_Fm->extraOpenDmasPoolSize = (uint8_t)MAX(p_Fm->extraOpenDmasPoolSize, p_PortParams->numOfExtraOpenDmas);
     /* check that there are enough uncommited open DMA's */
-    if(p_PortParams->numOfExtraOpenDmas > p_Fm->extraOpenDmasPoolSize)
-        p_Fm->extraOpenDmasPoolSize = p_PortParams->numOfExtraOpenDmas;
-
-    if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) > p_Fm->maxNumOfOpenDmas)
+    if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) >
+       p_Fm->maxNumOfOpenDmas)
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfOpenDmas."));
+    }
     else
     {
         p_Fm->accumulatedNumOfOpenDmas += p_PortParams->numOfOpenDmas;
@@ -731,13 +871,55 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
     }
 
-    /* we leave FM_MAX_NUM_OF_RX_PORTS spare bufferes for excessive buffers */
-        /* check that there are enough uncommited tasks */
-    if(p_PortParams->extraSizeOfFifo > p_Fm->extraFifoPoolSize)
-        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
+    /* if nessaccary, update sizeOfFifo field. */
+    if((p_PortParams->portType == e_FM_PORT_TYPE_TX) || (p_PortParams->portType == e_FM_PORT_TYPE_RX))
+    {
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
+        macMaxFrameLength = p_Fm->macMaxFrameLengths1G[relativePortId];
+    }
+#if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
+    if((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) || (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
+        macMaxFrameLength = p_Fm->macMaxFrameLengths10G[relativePortId];
+    }
+#endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
 
-    if((p_Fm->accumulatedFifoSize + p_PortParams->sizeOfFifo) > (p_Fm->totalFifoSize - p_Fm->extraTasksPoolSize))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total fifo size."));
+    if((p_PortParams->portType == e_FM_PORT_TYPE_TX) || (p_PortParams->portType == e_FM_PORT_TYPE_TX_10G))
+    {
+        if(p_PortParams->independentMode)
+            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
+                                (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                macMaxFrameLength) +
+                                (3*BMI_FIFO_UNITS));
+        else
+            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
+                                   (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                   macMaxFrameLength) +
+                                   (p_PortParams->deqPipelineDepth+3)*BMI_FIFO_UNITS);
+    }
+    else
+            if(((p_PortParams->portType == e_FM_PORT_TYPE_RX) || (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
+                && p_PortParams->independentMode)
+                minFifoSizeRequired = (uint32_t)(((macMaxFrameLength % BMI_FIFO_UNITS) ?
+                                                 ((macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                                 macMaxFrameLength) +
+                                                 (4*BMI_FIFO_UNITS));
+    if (minFifoSizeRequired && (p_PortParams->sizeOfFifo < minFifoSizeRequired))
+    {
+        p_PortParams->sizeOfFifo = minFifoSizeRequired;
+        DBG(WARNING, ("FIFO size enlarged to %d", minFifoSizeRequired));
+    }
+
+    /* we leave FM_MAX_NUM_OF_RX_PORTS spare buffers for excessive buffers
+       check that there are enough uncommitted FIFO buffs */
+    p_Fm->extraFifoPoolSize = MAX(p_Fm->extraFifoPoolSize, p_PortParams->extraSizeOfFifo);
+    if((p_Fm->accumulatedFifoSize + p_PortParams->sizeOfFifo) >
+       (p_Fm->totalFifoSize - p_Fm->extraFifoPoolSize))
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
+    }
     else
     {
         p_Fm->accumulatedFifoSize += p_PortParams->sizeOfFifo;
@@ -749,7 +931,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
     if(p_PortParams->independentMode)
     {
-        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (e_FM_PORT_TYPE_RX_10G))
+        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
             tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
         else
             tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
@@ -766,7 +948,31 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
 
+    {
+#ifdef FM_PARTITION_ARRAY
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev >= 2) && (revInfo.minorRev == 0))
+#endif /* FM_PARTITION_ARRAY */
+        {
+            /* set LIODN base for this port */
+            tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
+            if(hardwarePortId%2)
+            {
+                tmpReg &= ~FM_LIODN_BASE_MASK;
+                tmpReg |= (uint32_t)p_PortParams->liodnBase;
+            }
+            else
+            {
+                tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
+                tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
+            }
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+        }
+    }
+
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
 
     return E_OK;
 }
@@ -776,8 +982,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
     uint32_t    tmpReg;
     uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
-    uint8_t     enqTh;
-    uint8_t     deqTh;
     uint8_t     numOfTasks;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
@@ -809,9 +1013,25 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
     //WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0);
 
+#ifdef FM_PORT_DISABLED_ERRATA_IPG19430
+    /* this errata means that when a port is taken down, other port may not use its
+     * resources for a while as it may still be using it (in case of reject).
+     */
+        {
+            t_FmRevisionInfo revInfo;
+            FmGetRevision(p_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                XX_UDelay(100000);
+        }
+#endif /* FM_PORT_DISABLED_ERRATA_IPG19430 */
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
+        uint8_t     enqTh;
+        uint8_t     deqTh;
+
         tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
         /* update qmi ENQ/DEQ threshold */
         p_Fm->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
@@ -830,8 +1050,12 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
-    return;
+#ifdef FM_LOW_END_RESTRICTION
+    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+        p_Fm->lowEndRestriction = FALSE;
+#endif /* FM_LOW_END_RESTRICTION */
 }
 
 bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
@@ -878,7 +1102,6 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
                 break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-               break;
         }
     }
     else
@@ -899,7 +1122,6 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
                 break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-                break;
         }
     }
 
@@ -909,6 +1131,23 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     return E_OK;
 }
 
+t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+#if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
+    if (type == e_FM_MAC_10G)
+        p_Fm->macMaxFrameLengths10G[macId] = mtu;
+    else
+#else
+    UNUSED(type);
+#endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+        p_Fm->macMaxFrameLengths1G[macId] = mtu;
+
+    return E_OK;
+
+}
+
 uint16_t FmGetClockFreq(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -924,7 +1163,7 @@ uint32_t    FmGetTimeStampScale(t_Handle h_Fm)
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
 
     if(!p_Fm->enabledTimeStamp)
-        FmEnableTimeStamp(h_Fm);
+        FmEnableTimeStamp(p_Fm);
     return p_Fm->count1MicroBit;
 }
 
@@ -974,14 +1213,18 @@ void FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     FM_GetRevision(h_Fm, p_FmRevisionInfo);
 }
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
 uint8_t FmGetPartitionId(t_Handle h_Fm)
 {
     t_Fm     *p_Fm = (t_Fm*)h_Fm;
 
     return p_Fm->partitionId;
 }
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+bool FmIsMaster(t_Handle h_Fm)
+{
+    UNUSED(h_Fm);
+    return TRUE;
+}
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
@@ -1010,9 +1253,10 @@ t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 /****************************************/
 t_Handle FM_Config(t_FmParams *p_FmParam)
 {
-    t_Fm        *p_Fm;
-    uint8_t     i;
-    uint64_t    baseAddr = p_FmParam->baseAddr;
+    t_Fm        		*p_Fm;
+    uint8_t     		i;
+    uint64_t    		baseAddr = p_FmParam->baseAddr;
+    t_FmRevisionInfo 	revInfo;
 
     SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
                                (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
@@ -1042,7 +1286,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
     p_Fm->h_App             = p_FmParam->h_App;
     p_Fm->fmClkFreq         = p_FmParam->fmClkFreq;
-    p_Fm->f_Exception      = p_FmParam->f_Exception;
+    p_Fm->f_Exception       = p_FmParam->f_Exception;
     p_Fm->f_BusError        = p_FmParam->f_BusError;
     p_Fm->p_FmFpmRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmFpmRegs, (baseAddr + FM_MM_FPM));
     p_Fm->p_FmBmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmBmiRegs, (baseAddr + FM_MM_BMI));
@@ -1057,32 +1301,51 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->totalNumOfTasks   = DEFAULT_totalNumOfTasks;
     p_Fm->totalFifoSize     = DEFAULT_totalFifoSize;
     p_Fm->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
-    p_Fm->extraFifoPoolSize     = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+    p_Fm->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
     p_Fm->exceptions            = DEFAULT_exceptions;
 
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+    FmGetRevision(p_Fm, &revInfo);
+    if (revInfo.majorRev < 4)
+    	p_Fm->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
+
+    p_Fm->h_Spinlock = XX_InitSpinlock();
+    if (!p_Fm->h_Spinlock)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("cant allocate spinlock!"));
+        return NULL;
+    }
+
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
     {
         t_FmRevisionInfo revInfo;
         FmGetRevision(p_Fm, &revInfo);
         if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
             p_Fm->exceptions  &= ~FM_EX_BMI_LIST_RAM_ECC;
     }
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
-
-#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
     {
         t_FmRevisionInfo revInfo;
         FmGetRevision(p_Fm, &revInfo);
         if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            p_Fm->exceptions  &= ~FM_EX_IRAM_ECC;
+            p_Fm->exceptions  &= ~FM_EX_BMI_PIPELINE_ECC;
     }
-#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
-
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
+    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
         p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
-    /* Initialize FM driver parameters parameters (for initialization phase only) */
-    memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS*sizeof(uint16_t));
+
+#ifdef FM_PARTITION_ARRAY
+    {
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            /* Initialize FM driver parameters parameters (for initialization phase only) */
+            memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS*sizeof(uint16_t));
+    }
+#endif /* FM_PARTITION_ARRAY */
 
     /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
     p_Fm->p_FmDriverParam->enCounters                           = FALSE;
@@ -1096,8 +1359,8 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
     p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
     p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
-    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh               = DEFAULT_fmCtl1DispTh;
-    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh               = DEFAULT_fmCtl2DispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
 
     p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
     p_Fm->p_FmDriverParam->dmaBusProtect.privilegeBusProtect    = DEFAULT_privilegeBusProtect;
@@ -1117,6 +1380,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq can't be '0'"));
         return NULL;
     }
+
     p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency               = DEFAULT_dmaCommQLow;
     p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency              = DEFAULT_dmaCommQHigh;
     p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency             = DEFAULT_dmaReadIntBufLow;
@@ -1185,6 +1449,8 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* FM_MASTER_PARTITION */
     uint32_t                tmpReg, cfgReg = 0;
     int                     i;
+    uint16_t                periodInFmClocks;
+    uint8_t                 remainder;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
@@ -1199,18 +1465,32 @@ t_Error FM_Init(t_Handle h_Fm)
     /*************************************/
     /* Load FMan-Controller code to Iram */
     /*************************************/
+#ifndef VERIFICATION_SUPPORT
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+#endif
     if (p_Fm->p_FmDriverParam->firmware.p_Code &&
         (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
+#ifdef FM_MANIP_SUPPORT
+    /* save first 256 byte in MURAM */
+    p_Fm->resAddr = CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                             256,
+                                                             0));
+    if (!p_Fm->resAddr )
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for reserved Area failed"));
+
+    WRITE_BLOCK(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_Fm->resAddr), 0, 256);
+
+#endif /* FM_MANIP_SUPPORT */
+
     /* General FM driver initialization */
     p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
     for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
         p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
-    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
-        p_Fm->f_FmCtlIsr[i] = UnimplementedFmCtlIsr;
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        p_Fm->fmanCtrlIntr[i].f_Isr = UnimplementedFmanCtrlIsr;
 
     /**********************/
     /* Init DMA Registers */
@@ -1280,16 +1560,23 @@ t_Error FM_Init(t_Handle h_Fm)
 #endif /* VERIFICATION_SUPPORT */
     /* VirtToPhys */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
-                 (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr))) -
+                 (uint32_t)(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr)) -
                             p_Fm->fmMuramPhysBaseAddr));
 
-    /* liodn-partitions */
-    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+#ifdef FM_PARTITION_ARRAY
     {
-        tmpReg = (((uint32_t)p_FmDriverParam->liodnPerPartition[i] << DMA_LIODN_SHIFT) |
-                    (uint32_t)p_FmDriverParam->liodnPerPartition[i+1]);
-        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
+        t_FmRevisionInfo revInfo;
+        FmGetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            /* liodn-partitions */
+            for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+            {
+                tmpReg = (((uint32_t)p_FmDriverParam->liodnPerPartition[i] << DMA_LIODN_SHIFT) |
+                            (uint32_t)p_FmDriverParam->liodnPerPartition[i+1]);
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
+            }
     }
+#endif /* FM_PARTITION_ARRAY */
 
     /**********************/
     /* Init FPM Registers */
@@ -1329,7 +1616,7 @@ t_Error FM_Init(t_Handle h_Fm)
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
 
     /* clear all fmCtls event registers */
-    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
 
 #ifndef VERIFICATION_SUPPORT
@@ -1350,6 +1637,7 @@ t_Error FM_Init(t_Handle h_Fm)
         tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
 
+    tmpReg = 0;
     if(p_Fm->exceptions & FM_EX_IRAM_ECC)
     {
         tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
@@ -1378,7 +1666,7 @@ t_Error FM_Init(t_Handle h_Fm)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
     }
 
-    tmpReg = (uint32_t)((uint64_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr))) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = (uint32_t)(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
     tmpReg = tmpReg / BMI_FIFO_ALIGN;
 
     tmpReg |= ((p_Fm->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
@@ -1390,13 +1678,18 @@ t_Error FM_Init(t_Handle h_Fm)
 
     /* define unmaskable exceptions, enable and clear events */
     tmpReg = 0;
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC|BMI_ERR_INTR_EN_PIPELINE_ECC|BMI_ERR_INTR_EN_STATISTICS_RAM_ECC));
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
+												BMI_ERR_INTR_EN_PIPELINE_ECC |
+												BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
+												BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
     if(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC)
         tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
     if(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC)
         tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
     if(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
         tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+    if(p_Fm->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
 
     /**********************/
@@ -1412,6 +1705,24 @@ t_Error FM_Init(t_Handle h_Fm)
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
 
+    if(p_Fm->p_FmDriverParam->tnumAgingPeriod)
+    {
+        /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
+        periodInFmClocks = (uint16_t)(p_Fm->p_FmDriverParam->tnumAgingPeriod*p_Fm->fmClkFreq);
+        /* periodInFmClocks must be a 64 multiply */
+        remainder = (uint8_t)(periodInFmClocks % 64);
+        if (remainder > 64)
+            tmpReg = (uint32_t)((periodInFmClocks/64) + 1);
+        else
+        {
+            tmpReg = (uint32_t)(periodInFmClocks/64);
+            if(!tmpReg)
+                tmpReg = 1;
+        }
+        tmpReg <<= QMI_TAPC_TAP;
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_tapc, tmpReg);
+
+    }
     tmpReg = 0;
     /* Clear interrupt events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
@@ -1424,8 +1735,9 @@ t_Error FM_Init(t_Handle h_Fm)
        because it's the same reg for QMI enable */
     if(p_Fm->p_FmDriverParam->enCounters)
         cfgReg = QMI_CFG_EN_COUNTERS;
-
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
     if (p_Fm->irq != NO_IRQ)
     {
@@ -1440,7 +1752,7 @@ t_Error FM_Init(t_Handle h_Fm)
     }
 
 #ifdef FM_MASTER_PARTITION
-    err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
+    err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 #endif /* FM_MASTER_PARTITION */
@@ -1493,26 +1805,30 @@ t_Error FM_Free(t_Handle h_Fm)
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, 0);
 
 #ifdef FM_MASTER_PARTITION
-    XX_UnregisterMessageHandler(p_Fm->fmModuleName);
+    XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 #endif /* FM_MASTER_PARTITION */
 
     if (p_Fm->irq != NO_IRQ)
     {
-        XX_FreeIntr(p_Fm->irq);
         XX_DisableIntr(p_Fm->irq);
+        XX_FreeIntr(p_Fm->irq);
     }
 
     if (p_Fm->errIrq != NO_IRQ)
     {
-        XX_FreeIntr(p_Fm->errIrq);
         XX_DisableIntr(p_Fm->errIrq);
+        XX_FreeIntr(p_Fm->errIrq);
     }
 
+    if (p_Fm->h_Spinlock)
+        XX_FreeSpinlock(p_Fm->h_Spinlock);
+
     if(p_Fm->p_FmDriverParam)
     {
         XX_Free(p_Fm->p_FmDriverParam);
         p_Fm->p_FmDriverParam = NULL;
     }
+
     FreeInitResources(p_Fm);
 
     XX_Free(p_Fm);
@@ -1888,33 +2204,34 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
 
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 {
-    t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    bitMask = 0;
+    t_Fm        		*p_Fm = (t_Fm*)h_Fm;
+    uint32_t    	 	bitMask = 0;
+    t_FmRevisionInfo 	revInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
-    {
-        t_FmRevisionInfo revInfo;
-        if((exception == e_FM_EX_IRAM_ECC) && (enable))
-        {
-            FmGetRevision(p_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_IRAM_ECC!"));
-        }
-    }
-#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
-    {
-        t_FmRevisionInfo revInfo;
-        if((exception == e_FM_EX_IRAM_ECC) && (enable))
-        {
-            FmGetRevision(p_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
-        }
-    }
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+	if((exception == e_FM_EX_BMI_PIPELINE_ECC) && (enable))
+	{
+		FmGetRevision(p_Fm, &revInfo);
+		if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+			RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECC!"));
+	}
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+	if((exception == e_FM_EX_BMI_LIST_RAM_ECC) && (enable))
+	{
+		FmGetRevision(p_Fm, &revInfo);
+		if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+			RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
+	}
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
+	if((exception == e_FM_EX_BMI_DISPATCH_RAM_ECC) && (enable))
+	{
+		FmGetRevision(p_Fm, &revInfo);
+		if (revInfo.majorRev > 3)
+			RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
+	}
 
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
@@ -1941,6 +2258,24 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
     return E_OK;
 }
 
+t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    t_FmRevisionInfo revInfo;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+
+    FmGetRevision(h_Fm, &revInfo);
+    if (revInfo.majorRev < 3)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigTnumAgingPeriod!"));
+
+    p_Fm->p_FmDriverParam->tnumAgingPeriod = tnumAgingPeriod;
+
+    return E_OK;
+
+}
+
 /****************************************************/
 /*       API Run-time Control uint functions        */
 /****************************************************/
@@ -1955,7 +2290,7 @@ t_Handle FM_GetPcdHandle(t_Handle h_Fm)
 void FM_EventIsr(t_Handle h_Fm)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                pending;
+    uint32_t                pending, event;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
@@ -1972,8 +2307,6 @@ void FM_EventIsr(t_Handle h_Fm)
         p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
     if(pending & INTR_EN_KG)
         p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
-    if(pending & FPM_EVENT_FM_CTL)
-        CtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
     if(pending & INTR_EN_TMR)
             p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 
@@ -2041,6 +2374,72 @@ void FM_EventIsr(t_Handle h_Fm)
 #endif /* FM_MASTER_PARTITION */
            p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
     }
+    /* IM port events may belong to different partitions */
+    if(pending & INTR_EN_REV0)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[0]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[0]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[0], event);
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_0].partitionId)
+        	/*TODO IPC ISR For Fman Ctrl */
+        	ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_0, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->fmanCtrlIntr[0].f_Isr(p_Fm->fmanCtrlIntr[0].h_SrcHandle, event);
+
+    }
+    if(pending & INTR_EN_REV1)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[1]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[1]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[1], event);
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_1].partitionId)
+        	/*TODO IPC ISR For Fman Ctrl */
+        	ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_1, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->fmanCtrlIntr[1].f_Isr(p_Fm->fmanCtrlIntr[1].h_SrcHandle, event);
+
+    }
+    if(pending & INTR_EN_REV2)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[2]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[2]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[2], event);
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_2].partitionId)
+        	/*TODO IPC ISR For Fman Ctrl */
+        	ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_2, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+           p_Fm->fmanCtrlIntr[2].f_Isr(p_Fm->fmanCtrlIntr[2].h_SrcHandle, event);
+    }
+    if(pending & INTR_EN_REV3)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[3]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[3]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[3], event);
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_3].partitionId)
+        	/*TODO IPC ISR For Fman Ctrl */
+        	ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_2, pendin3);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->fmanCtrlIntr[3].f_Isr(p_Fm->fmanCtrlIntr[3].h_SrcHandle, event);
+    }
+#ifdef FM_MACSEC_SUPPORT
+    if(pending & INTR_EN_MACSEC_MAC0)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_MACSEC_MAC0, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].h_SrcHandle);
+    }
+#endif /* FM_MACSEC_SUPPORT */
 }
 
 void FM_ErrorIsr(t_Handle h_Fm)
@@ -2119,76 +2518,74 @@ void FM_ErrorIsr(t_Handle h_Fm)
         else
 #endif /* FM_MASTER_PARTITION */
             p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
-
     }
+#ifdef FM_MACSEC_SUPPORT
+    if(pending & ERR_INTR_EN_MACSEC_MAC0)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_MACSEC_MAC0, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].h_SrcHandle);
+    }
+#endif /* FM_MACSEC_SUPPORT */
 }
 
-t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth)
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    int         j, i;
+    int         i;
     uint8_t     sum;
     uint8_t     hardwarePortId=0;
-    uint8_t     portPrecent[FM_MAX_NUM_OF_PORTS];
-    uint32_t    tmpReg;
-    uint8_t     relativePortId, remain, shift, weight, maxPercent = 0;
+    uint32_t    tmpRegs[8] = {0,0,0,0,0,0,0,0};
+    uint8_t     relativePortId, shift, weight, maxPercent = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
-    memset(portPrecent, 0, FM_MAX_NUM_OF_PORTS);
-    for(i=0;i<FM_NUM_OF_PORT_TYPES;i++)
-        for(j=0;j<FM_MAX_NUM_OF_PORTS_PER_TYPE;j++)
-        {
-            if((*p_PortsBandwidth)[i][j])
-            {
-                GET_GLOBAL_PORTID(hardwarePortId, i,j);
-                portPrecent[hardwarePortId] = (*p_PortsBandwidth)[i][j];
-            }
-        }
-
     /* check that all ports add up to 100% */
     sum = 0;
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-        sum +=portPrecent[i];
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+        sum +=p_PortsBandwidth->portsBandwidths[i].bandwidth;
     if (sum != 100)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
 
-    tmpReg = 0;
     /* find highest precent */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
     {
-        if (portPrecent[i] > maxPercent)
-            maxPercent = portPrecent[i];
+        if (p_PortsBandwidth->portsBandwidths[i].bandwidth > maxPercent)
+            maxPercent = p_PortsBandwidth->portsBandwidths[i].bandwidth;
     }
 
     /* calculate weight for each port */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        weight = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT )/maxPercent);
-        remain = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT ) - maxPercent*weight);
-
-        /* round the remain to add 1 if it is bigger than 0.5 */
-        if (remain*2 > maxPercent)
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    {
+        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT )/maxPercent);
+        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exect division
+           is not reached, we round up so that:
+           0 until maxPercent/PORT_MAX_WEIGHT get "1"
+           maxPercent/PORT_MAX_WEIGHT+1 until (maxPercent/PORT_MAX_WEIGHT)*2 get "2"
+           ...
+           maxPercent - maxPercent/PORT_MAX_WEIGHT until maxPercent get "PORT_MAX_WEIGHT: */
+        if((uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT ) % maxPercent))
             weight++;
 
         /* find the location of this port within the register */
-        relativePortId = (uint8_t)(i % 8);
+        SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, p_PortsBandwidth->portsBandwidths[i].type,p_PortsBandwidth->portsBandwidths[i].relativePortId);
+        relativePortId = (uint8_t)(hardwarePortId % 8);
         shift = (uint8_t)(32-4*(relativePortId+1));
 
 
-        if(weight)
+        if(weight > 1)
             /* Add this port to tmpReg */
-            tmpReg |= ((weight-1) << shift);
-
-        /* each 8 ports result in one register, write this register */
-        if (relativePortId == 7 && tmpReg)
-        {
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i/8], tmpReg);
-            tmpReg = 0;
-        }
+            /* (each 8 ports result in one register)*/
+            tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
     }
 
+    for(i=0;i<8;i++)
+        if(tmpRegs[i])
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i], tmpRegs[i]);
 
     return E_OK;
 }
@@ -2349,12 +2746,12 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
                 {
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
                     t_FmRevisionInfo revInfo;
                     FmGetRevision(p_Fm, &revInfo);
                     if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
                         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11 */
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 }
                 else
@@ -2364,12 +2761,20 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case(e_FM_EX_BMI_PIPELINE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
+                {
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+                    t_FmRevisionInfo revInfo;
+                    FmGetRevision(p_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECC!"));
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
                     tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+                }
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-              case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
+             case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
                     tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
@@ -2377,29 +2782,40 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-            case(e_FM_EX_IRAM_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
-                if(enable)
-                {
-#ifdef FM_IRAM_ECC_ERR_IRQ_ERRATA
-                    t_FmRevisionInfo revInfo;
-                    FmGetRevision(p_Fm, &revInfo);
-                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_IRAM_ECC!"));
-#endif   /* FM_IRAM_ECC_ERR_IRQ_ERRATA */
-                    /* enable ECC if not enabled */
-                    FmEnableRamsEcc(p_Fm);
-                    /* enable ECC interrupts */
-                    tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
-                }
-                else
-                {
-                    /* ECC mechanism may be disabled, depending on driver status  */
-                    FmDisableRamsEcc(p_Fm);
-                    tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
-                }
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
-                break;
+             case(e_FM_EX_BMI_DISPATCH_RAM_ECC):
+				 {
+            	   t_FmRevisionInfo 	revInfo;
+            	   FmGetRevision(p_Fm, &revInfo);
+            	   if ((revInfo.majorRev > 3) && (revInfo.minorRev == 0))
+            	   {
+            		   tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+            		   if(enable)
+            			   tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+            		   else
+            			   tmpReg &= ~BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+            		   WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+            	   }
+            	   else
+                       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC"));
+				 }
+				 break;
+             case(e_FM_EX_IRAM_ECC):
+            	 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+				if(enable)
+				{
+					/* enable ECC if not enabled */
+					FmEnableRamsEcc(p_Fm);
+					/* enable ECC interrupts */
+					tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+				}
+				else
+				{
+					/* ECC mechanism may be disabled, depending on driver status  */
+					FmDisableRamsEcc(p_Fm);
+					tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
+				}
+				WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+				break;
 
              case(e_FM_EX_MURAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
@@ -2650,6 +3066,11 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
             break;
+        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, FM_EX_BMI_DISPATCH_RAM_ECC);
+            break;
         default:
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
@@ -2805,4 +3226,48 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
+#ifdef VERIFICATION_SUPPORT
+#ifdef SC1023
+void FM_BackdoorSet (t_Handle h_Fm, e_ModuleId moduleId, uint32_t offset, uint32_t value)
+{
+    t_Fm             	*p_Fm = (t_Fm*)h_Fm;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM_FPM:
+            base = (uint32_t)(p_Fm->baseAddr+ FM_MM_FPM) ;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return;
+
+    }
+    WRITE_UINT32(*(uint32_t*)(base+offset), value);
+}
+
+uint32_t      FM_BackdoorGet(t_Handle h_Fm, e_ModuleId moduleId, uint32_t offset)
+{
+    t_Fm            *p_Fm= (t_Fm *)h_Fm;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM_FPM:
+            base = (uint32_t)(p_Fm->baseAddr+ FM_MM_FPM) ;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+
+    }
+    return GET_UINT32(*(uint32_t*)(base+offset));
+}
+#endif /*SC1023*/
+#endif /*VERIFICATION_SUPPORT*/
+
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
index 8e66b12..86fa293 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -45,6 +45,7 @@
 
 #define __ERR_MODULE__  MODULE_FM
 
+#define FM_MAX_NUM_OF_HW_PORT_IDS           64
 
 /**************************************************************************//**
  @Description       Exceptions
@@ -64,6 +65,7 @@
 #define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
 #define FM_EX_IRAM_ECC                      0x00040000
 #define FM_EX_NURAM_ECC                     0x00020000
+#define FM_EX_BMI_DISPATCH_RAM_ECC        	0x00010000
 
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
     case e_FM_EX_DMA_BUS_ERROR:                                         \
@@ -92,6 +94,8 @@
         bitMask = FM_EX_BMI_PIPELINE_ECC; break;                        \
     case e_FM_EX_BMI_STATISTICS_RAM_ECC:                                \
         bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;                  \
+    case e_FM_EX_BMI_DISPATCH_RAM_ECC:                                  \
+        bitMask = FM_EX_BMI_DISPATCH_RAM_ECC; break;                    \
     case e_FM_EX_IRAM_ECC:                                              \
         bitMask = FM_EX_IRAM_ECC; break;                                \
     case e_FM_EX_MURAM_ECC:                                             \
@@ -114,11 +118,12 @@
                                             FM_EX_BMI_LIST_RAM_ECC          |\
                                             FM_EX_BMI_PIPELINE_ECC          |\
                                             FM_EX_BMI_STATISTICS_RAM_ECC    |\
+                                            FM_EX_BMI_DISPATCH_RAM_ECC    	|\
                                             FM_EX_IRAM_ECC                  |\
                                             FM_EX_NURAM_ECC                 )
-#define DEFAULT_totalNumOfTasks             96
-#define DEFAULT_totalFifoSize               (132*KILOBYTE)
-#define DEFAULT_maxNumOfOpenDmas            24
+#define DEFAULT_totalNumOfTasks             (BMI_MAX_NUM_OF_TASKS*3/4)
+#define DEFAULT_totalFifoSize               (BMI_MAX_FIFO_SIZE*3/4)
+#define DEFAULT_maxNumOfOpenDmas            (BMI_MAX_NUM_OF_DMAS*3/4)
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   16
 #define DEFAULT_prsDispTh                   16
@@ -138,12 +143,12 @@
 #define DEFAULT_stopAtBusError              FALSE
 #define DEFAULT_axiDbgNumOfBeats            1
 #define DEFAULT_dmaCamNumOfEntries          32
-#define DEFAULT_dmaCommQLow                 16
-#define DEFAULT_dmaCommQHigh                24
-#define DEFAULT_dmaReadIntBufLow            64
-#define DEFAULT_dmaReadIntBufHigh           96
-#define DEFAULT_dmaWriteIntBufLow           64
-#define DEFAULT_dmaWriteIntBufHigh          96
+#define DEFAULT_dmaCommQLow                 ((DMA_THRESH_MAX_COMMQ+1)/2)
+#define DEFAULT_dmaCommQHigh                ((DMA_THRESH_MAX_COMMQ+1)*3/4)
+#define DEFAULT_dmaReadIntBufLow            ((DMA_THRESH_MAX_BUF+1)/2)
+#define DEFAULT_dmaReadIntBufHigh           ((DMA_THRESH_MAX_BUF+1)*3/4)
+#define DEFAULT_dmaWriteIntBufLow           ((DMA_THRESH_MAX_BUF+1)/2)
+#define DEFAULT_dmaWriteIntBufHigh          ((DMA_THRESH_MAX_BUF+1)*3/4)
 #define DEFAULT_dmaSosEmergency             0
 #define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
 #define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
@@ -153,6 +158,7 @@
 #define DEFAULT_haltOnUnrecoverableEccError FALSE   /* do not change! if changed, must be disabled for rev1 ! */
 #define DEFAULT_externalEccRamsEnable       FALSE
 #define DEFAULT_VerifyUcode                 FALSE
+#define DEFAULT_tnumAgingPeriod             0
 
 /**************************************************************************//**
  @Description       Modules registers offsets
@@ -261,7 +267,12 @@ typedef _Packed struct
     volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
     volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
     volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
-    volatile uint32_t   Reserved1[11];
+    volatile uint32_t   Reserved1a[7];
+    volatile uint32_t   fmqm_tapc;      /**<  Tnum Aging Period Control */
+    volatile uint32_t   fmqm_dmcvc;     /**<  Dequeue MAC Command Valid Counter */
+    volatile uint32_t   fmqm_difdcc;    /**<  Dequeue Invalid FD Command Counter */
+    volatile uint32_t   fmqm_da1v;      /**<  Dequeue A1 Valid Counter */
+    volatile uint32_t   Reserved1b;
     volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
     volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
     volatile uint32_t   Reserved3[2];
@@ -380,8 +391,6 @@ typedef _Packed struct
 #define DMA_TRANSFER_TNUM_SHIFT             16
 
 /* sizes */
-#define DMA_THRESH_MAX_COMMQ                31
-#define DMA_THRESH_MAX_BUF                  127
 #define DMA_MAX_WATCHDOG                    0xffffffff
 
 /* others */
@@ -452,13 +461,12 @@ typedef _Packed struct
 
 #define FPM_THR2_QMI_ENQ_SHIFT          24
 #define FPM_THR2_QMI_DEQ_SHIFT          0
-#define FPM_THR2_FM_CTL1_SHIFT            16
-#define FPM_THR2_FM_CTL2_SHIFT            8
+#define FPM_THR2_FM_CTL1_SHIFT          16
+#define FPM_THR2_FM_CTL2_SHIFT          8
 
 #define FPM_EV_MASK_CAT_ERR_SHIFT       1
 #define FPM_EV_MASK_DMA_ERR_SHIFT       0
 
-
 #define FPM_REV1_MAJOR_SHIFT            8
 #define FPM_REV1_MINOR_SHIFT            0
 
@@ -479,10 +487,8 @@ typedef _Packed struct
 #define FPM_EVENT_FM_CTL_BRK              0x00000080
 
 /* others */
-#define NUM_OF_FM_CTL_EVENT_REGS          4
 #define FPM_MAX_DISP_LIMIT              31
 
-
 /**************************************************************************//**
  @Description       BMI defines
 *//***************************************************************************/
@@ -491,6 +497,7 @@ typedef _Packed struct
 #define BMI_ERR_INTR_EN_PIPELINE_ECC        0x80000000
 #define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
 #define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
+#define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC  	0x10000000
 #define BMI_NUM_OF_TASKS_MASK               0x3F000000
 #define BMI_NUM_OF_DMAS_MASK                0x00000F00
 #define BMI_FIFO_SIZE_MASK                  0x000003FF
@@ -506,12 +513,7 @@ typedef _Packed struct
 #define BMI_NUM_OF_DMAS_SHIFT           8
 #define BMI_EXTRA_NUM_OF_DMAS_SHIFT     0
 
-/* sizes */
-#define BMI_MAX_NUM_OF_TASKS            128
-#define BMI_MAX_NUM_OF_DMAS             32
-
 /* others */
-#define PORT_MAX_WEIGHT                 16
 #define BMI_FIFO_ALIGN                  0x100
 
 
@@ -532,11 +534,7 @@ typedef _Packed struct
 
 /* shifts */
 #define QMI_CFG_ENQ_SHIFT               8
-
-
-/* others */
-#define QMI_DEF_TNUMS_THRESH            48
-#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_TAPC_TAP                    22
 
 
 /**************************************************************************//**
@@ -546,13 +544,19 @@ typedef _Packed struct
 #define IRAM_IADD_AIE                   0x80000000
 #define IRAM_READY                      0x80000000
 
+typedef struct {
+    void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
+    t_Handle    h_SrcHandle;
+} t_FmanCtrlIntrSrc;
 
 
 typedef struct
 {
  /*   uint8_t                     numOfPartitions; */
     bool                        resetOnInit;
+#ifdef FM_PARTITION_ARRAY
     uint16_t                    liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS];
+#endif
     bool                        enCounters;
     t_FmThresholds              thresholds;
     t_FmDmaBusProtect           dmaBusProtect;
@@ -579,30 +583,31 @@ typedef struct
     bool                        enMuramTestMode;
     bool                        enIramTestMode;
     bool                        externalEccRamsEnable;
+    uint16_t                    tnumAgingPeriod;
     t_FmPcdFirmwareParams       firmware;
     bool                        fwVerify;
 } t_FmDriverParam;
 
-typedef void (t_FmCtlIsr)( t_Handle h_Fm, uint32_t event);
+typedef void (t_FmanCtrlIsr)( t_Handle h_Fm, uint32_t event);
 
 typedef struct
 {
     uint8_t                     fmId;
     t_Handle                    h_Pcd;
-    t_Handle                    h_FmPorts[FM_MAX_NUM_OF_PORTS]; /* Handles to all partitions ports */
-    e_FmPortType                portsTypes[FM_MAX_NUM_OF_PORTS];
+    e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
+//    bool                        portInitialized[FM_MAX_NUM_OF_PORTS];
     char                        fmModuleName[MODULE_NAME_SIZE];
     t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
     uint16_t                    fmClkFreq;
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+//#ifdef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t                     partitionId;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+//#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    uint64_t                    baseAddr;
 
 #ifdef CONFIG_GUEST_PARTITION
     char                        fmMasterModuleName[MODULE_NAME_SIZE];
 #else
-    uint64_t                    baseAddr;
     t_Handle                    h_FmMuram;
     uint64_t                    fmMuramPhysBaseAddr;
     bool                        enabledTimeStamp;
@@ -616,9 +621,15 @@ typedef struct
     uint8_t                     accumulatedNumOfTasks;
     uint32_t                    accumulatedFifoSize;
     uint8_t                     accumulatedNumOfOpenDmas;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     uint8_t                     accumulatedNumOfDeqTnums;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+#ifdef FM_LOW_END_RESTRICTION
+    bool                        lowEndRestriction;
+#endif /* FM_LOW_END_RESTRICTION */
     uint32_t                    exceptions;
     uint64_t                    camBaseAddr;                    /* save for freeing */
+    uint64_t                    resAddr;
     uint64_t                    fifoBaseAddr;                   /* save for freeing */
     int                         irq;
     int                         errIrq;
@@ -629,7 +640,8 @@ typedef struct
     t_FmExceptionsCallback      *f_Exception;
     t_FmBusErrorCallback        *f_BusError;
     t_Handle                    h_App;                          /* Application handle */
-    t_FmCtlIsr                  *f_FmCtlIsr[NUM_OF_FM_CTL_EVENT_REGS];
+    t_FmanCtrlIntrSrc           fmanCtrlIntr[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];    /* FM exceptions user callback */
+    bool                        usedEventRegs[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];
     bool                        ramsEccEnable;
     bool                        explicitEnable;
     bool                        internalCall;
@@ -637,10 +649,16 @@ typedef struct
     uint32_t                    extraFifoPoolSize;
     uint8_t                     extraTasksPoolSize;
     uint8_t                     extraOpenDmasPoolSize;
+    t_Handle                    h_Spinlock;
+#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    uint16_t                    macMaxFrameLengths10G[FM_MAX_NUM_OF_10G_MACS];
+#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS) */
+    uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
     t_FmDriverParam             *p_FmDriverParam;
 #endif /* CONFIG_GUEST_PARTITION */
 } t_Fm;
 
+
 /**************************************************************************//**
  @Function      FM_Isr
 
@@ -651,9 +669,9 @@ typedef struct
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
 #ifdef CONFIG_GUEST_PARTITION
-void FM_ErrorIsr(t_Handle h_Fm);
-void FM_EventIsr(t_Handle h_Fm);
+void FM_ErrorIsr(t_Handle h_Fm, uint32_t pending);
+void FM_EventIsr(t_Handle h_Fm, uint32_t pending);
 #endif /* !CONFIG_GUEST_PARTITION */
 
-#endif /* __FM_H */
 
+#endif /* __FM_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
index bb80c7d..56e2a8f 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -42,10 +42,19 @@
 #include "sprint_ext.h"
 #include "debug_ext.h"
 #include "fm_muram_ext.h"
+
 #include "fm_common.h"
 #include "fm_ipc.h"
 #include "fm.h"
 
+
+static void UnimplementedIsr(t_Handle h_Arg)
+{
+    UNUSED(h_Arg);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
 /****************************************/
 /*       Inter-Module functions        */
 /****************************************/
@@ -60,6 +69,24 @@ void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
 
 }
 
+void  FmUnregisterPcd(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(!p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("No PCD"));
+
+    p_Fm->h_Pcd = NULL;
+
+}
+
+uint8_t FmGetPartitionId(t_Handle h_Fm)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->partitionId;
+}
+
 t_Handle  FmGetPcdHandle(t_Handle h_Fm)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
@@ -79,22 +106,66 @@ uint8_t FmGetId(t_Handle h_Fm)
 
 t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
 {
+    t_FmIpcPortInitParams 	portParams;
+	t_Error					err;
+
+    portParams.hardwarePortId = p_PortParams->hardwarePortId;
+    portParams.enumPortType = (uint32_t)p_PortParams->portType;
+    portParams.boolIndependentMode = (uint8_t)p_PortParams->independentMode;
+    portParams.portPartition = p_PortParams->portPartition;
+    portParams.numOfTasks = p_PortParams->numOfTasks;
+    portParams.numOfExtraTasks = p_PortParams->numOfExtraTasks;
+    portParams.numOfOpenDmas = p_PortParams->numOfOpenDmas;
+    portParams.numOfExtraOpenDmas = p_PortParams->numOfExtraOpenDmas;
+    portParams.sizeOfFifo = p_PortParams->sizeOfFifo;
+    portParams.extraSizeOfFifo = p_PortParams->extraSizeOfFifo;
+    portParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
+    portParams.liodnBase = p_PortParams->liodnBase;
+
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)p_PortParams, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)&portParams, NULL, NULL);
+	if(err)
+		RETURN_ERROR(MINOR, err, NO_MSG);
+
+	p_PortParams->fmMuramPhysBaseAddr.high = portParams.fmMuramPhysBaseAddr.high;
+	p_PortParams->fmMuramPhysBaseAddr.low = portParams.fmMuramPhysBaseAddr.low;
+
+	return E_OK;
 }
 
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 {
-    t_Error err;
+    t_Error                 err;
+    t_FmIpcPortFreeParams   portParams;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
+    portParams.hardwarePortId = p_PortParams->hardwarePortId;
+    portParams.enumPortType = (uint32_t)p_PortParams->portType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    portParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
     err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_FREE_PORT, (uint8_t*)p_PortParams, NULL, NULL);
     if(err)
         REPORT_ERROR(MINOR, err, NO_MSG);
 }
 
+void FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Error             err;
+    t_FmIpcRevisionInfo revInfo;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_REV, (uint8_t*)&revInfo, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    p_FmRevisionInfo->majorRev = revInfo.majorRev;
+    p_FmRevisionInfo->minorRev = revInfo.minorRev;
+}
 
 bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
 {
@@ -108,7 +179,7 @@ bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
     if(err)
         REPORT_ERROR(MINOR, err, NO_MSG);
 
-    return isStalled.isStalled;
+    return (bool)(isStalled.boolIsStalled);
 }
 
 t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
@@ -120,50 +191,121 @@ t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
 
 t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 {
-    t_FmIpcMacReset macReset;
+    t_FmIpcMacParams macParams;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-    macReset.id = macId;
-    macReset.type = (e_FmIpcMacType)type;
+    macParams.id = macId;
+    macParams.enumType = (uint32_t)type;
 
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_RESET_MAC, (uint8_t*)&macReset, NULL, NULL);
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_RESET_MAC, (uint8_t*)&macParams, NULL, NULL);
 }
 
-uint16_t FmGetClockFreq(t_Handle h_Fm)
+t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t maxFrameLength)
+{
+    t_FmIpcMacMaxFrameParams macMaxFrameLengthParams;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    macMaxFrameLengthParams.macParams.id = macId;
+    macMaxFrameLengthParams.macParams.enumType = (uint32_t)type;
+    macMaxFrameLengthParams.maxFrameLength = (uint16_t)maxFrameLength;
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_SET_MAC_MAX_FRAME, (uint8_t*)&macMaxFrameLengthParams, NULL, NULL);
+}
+
+t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
 {
+
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_ALLOC_FMAN_CTRL_EVENT_REG, p_EventId, NULL, NULL);
+}
+
+void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
+{
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_FREE_FMAN_CTRL_EVENT_REG, &eventId, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, uint32_t enableEvents)
+{
+    t_FmIpcFmanEvents    fmanCtrl;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    fmanCtrl.eventRegId = eventRegId;
+    fmanCtrl.enableEvents = enableEvents;
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_SET_FMAN_CTRL_EVENTS_ENABLE, (uint8_t*)&fmanCtrl, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_FmIpcFmanEvents       fmanCtrl;
+    t_Error                 err;
+
+    fmanCtrl.eventRegId = eventRegId;
+    err = XX_SendMessage(p_Fm->fmMasterModuleName, FM_GET_FMAN_CTRL_EVENTS_ENABLE, (uint8_t*)&fmanCtrl, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return fmanCtrl.enableEvents;
+
+}
+
+uint16_t FmGetClockFreq(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
     return ((t_Fm*)h_Fm)->fmClkFreq;
 }
 
-uint32_t FmGetTimeStampPeriod(t_Handle h_Fm)
+uint32_t    FmGetTimeStampScale(t_Handle h_Fm)
 {
-    uint32_t                timeStampPeriod;
+    uint32_t                timeStampScale;
     t_Error                 err;
 
     SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
 
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_TIMESTAMP_PERIOD, (uint8_t*)&timeStampPeriod, NULL, NULL);
-    if(err )
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_TIMESTAMP_SCALE, (uint8_t*)&timeStampScale, NULL, NULL);
+    if(err)
         REPORT_ERROR(MINOR, err, NO_MSG);
 
-    return timeStampPeriod;
+    return timeStampScale;
 }
 
-t_Error FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+static t_Error     FmHandleIpcMsg(t_Handle  h_Fm,
+                                  uint8_t   *p_Msg,
+                                  uint32_t  msgLength,
+                                  uint8_t   **p_Reply,
+                                  uint32_t  *p_ReplyLength)
 {
     t_Fm    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                        msgId;
+    uint8_t                         *p_MsgBody;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength > sizeof(uint32_t)), E_INVALID_VALUE);
+    msgId = ((uint32_t *)p_Msg)[0];
+    p_MsgBody = (uint8_t *)(&((uint32_t *)p_Msg)[1]);
 
     switch(msgId)
     {
         case (FM_GUEST_ISR):
-            if(((t_FmIpcIsr*)msgBody)->err)
-                FM_ErrorIsr(h_Fm, uint32_t ((t_FmIpcIsr*)msgBody)->pending);
+            if(((t_FmIpcIsr*)p_MsgBody)->boolErr)
+                FM_ErrorIsr(h_Fm,  ((t_FmIpcIsr*)p_MsgBody)->pendingReg);
             else
-                FM_EventIsr(h_Fm, uint32_t ((t_FmIpcIsr*)msgBody)->pending);
+                FM_EventIsr(h_Fm,  ((t_FmIpcIsr*)p_MsgBody)->pendingReg);
         break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
@@ -174,16 +316,17 @@ t_Error FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_S
 void FmRegisterIntr(t_Handle h_Fm,
                         e_FmEventModules        module,
                         uint8_t                 modId,
-                        bool                    err,
+                        e_FmIntrType            intrType,
                         void (*f_Isr) (t_Handle h_Arg),
                         t_Handle    h_Arg)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     uint8_t             event= 0;
-    t_FmIpcRegisterIntr *fmIpcRegisterIntr;
+    t_FmIpcRegisterIntr fmIpcRegisterIntr;
+    t_Error             err;
 
     /* register in local FM structure */
-    GET_FM_MODULE_EVENT(module, modId,err, event);
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
     ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
     p_Fm->intrMng[event].f_Isr = f_Isr;
     p_Fm->intrMng[event].h_SrcHandle = h_Arg;
@@ -191,7 +334,69 @@ void FmRegisterIntr(t_Handle h_Fm,
     /* register in Master FM structure */
     fmIpcRegisterIntr.event = event;
     fmIpcRegisterIntr.partitionId = p_Fm->partitionId;
-    return XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_REGISTER_INTR, (uint8_t*)&fmIpcRegisterIntr, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_REGISTER_INTR, (uint8_t*)&fmIpcRegisterIntr, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+void FmUnregisterIntr(t_Handle h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint8_t             event= 0;
+
+    /* register in local FM structure */
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    p_Fm->intrMng[event].f_Isr = NULL;
+    p_Fm->intrMng[event].h_SrcHandle = NULL;
+    /* no need to unregister in master, as all registration does is pass partition id */
+}
+
+void  FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Arg, uint32_t event), t_Handle    h_Arg)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    UNUSED(p_Fm);
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+    ASSERT_COND(0);
+    /* TODO */
+}
+
+void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+    ASSERT_COND(0);
+    UNUSED(p_Fm);
+    /* TODO */
+}
+
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_FmIpcPhysAddr fmIpcPhysAddr;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_PHYS_MURAM_BASE, (uint8_t*)&fmIpcPhysAddr, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    p_FmPhysAddr->low     = fmIpcPhysAddr.low;
+    p_FmPhysAddr->high    = fmIpcPhysAddr.high;
+
+    return E_OK;
+}
+
+bool FmIsMaster(t_Handle h_Fm)
+{
+    UNUSED(h_Fm);
+    return FALSE;
 }
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -203,6 +408,7 @@ t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 }
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
 
+
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
@@ -222,8 +428,8 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
 
     /* Initialize FM parameters which will be kept by the driver */
     p_Fm->fmId              = p_FmParam->fmId;
-    p_Fm->partitionId              = p_FmParam->partitionId;
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+    p_Fm->partitionId       = p_FmParam->partitionId;
+    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
         p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
 
     /* build the FM guest partition IPC address */
@@ -269,7 +475,7 @@ t_Error FM_Init(t_Handle h_Fm)
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
 
-    err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
+    err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -294,6 +500,8 @@ t_Error FM_Free(t_Handle h_Fm)
     if (!p_Fm)
         return ERROR_CODE(E_INVALID_HANDLE);
 
+    XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
+
     XX_Free(p_Fm);
 
     return E_OK;
@@ -315,13 +523,17 @@ t_Handle FM_GetPcdHandle(t_Handle h_Fm)
 
 void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
 {
-    t_Error err;
+    t_Error             err;
+    t_FmIpcRevisionInfo fmIpcRevisionInfo;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
-    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_REV, (uint8_t*)p_FmRevisionInfo, NULL, NULL);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_REV, (uint8_t*)&fmIpcRevisionInfo, NULL, NULL);
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
+
+    p_FmRevisionInfo->majorRev = fmIpcRevisionInfo.majorRev;
+    p_FmRevisionInfo->minorRev = fmIpcRevisionInfo.minorRev;
 }
 
 uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
@@ -331,7 +543,7 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 
     SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
 
-    counterParams.id = (e_FmIpcCounters)counter;
+    counterParams.enumId = (uint32_t)counter;
     err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
     if(err )
         REPORT_ERROR(MINOR, err, NO_MSG);
@@ -339,10 +551,22 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     return counterParams.val;
 }
 
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
+{
+    t_Error         err;
+    t_FmDmaStatus   dmaStats;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmMasterModuleName, FM_DMA_STAT, (uint8_t*)&dmaStats, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+}
+
 void FM_ErrorIsr(t_Handle h_Fm, uint32_t pending)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                pending;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
@@ -362,7 +586,6 @@ void FM_ErrorIsr(t_Handle h_Fm, uint32_t pending)
 void FM_EventIsr(t_Handle h_Fm, uint32_t pending)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                pending;
 
     SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
 
@@ -393,4 +616,46 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
+/**************************************************/
+/*     TMP - should be united with fm.c           */
+/**************************************************/
+
+t_Error FmEnableRamsEcc(t_Handle h_Fm)
+{
+    UNUSED(h_Fm);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FmDisableRamsEcc(t_Handle h_Fm)
+{
+   UNUSED(h_Fm);
+   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PRS);
+}
+
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_KG);
+}
+
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PLCR);
+}
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index dce6b89..701a041 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -58,265 +58,341 @@
  @{
 *//***************************************************************************/
 
-#define FM_IC_PHYS_ADDRESS_SIZE    6
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   Structure for finding out whether a port is stalled.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef _Packed struct
+{
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    uint8_t             boolIsStalled;        /**< OUT. TRUE if FM PORT is stalled */
+} _PackedType t_FmIpcPortIsStalled;
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef _Packed struct
+{
+    uint8_t         id;
+    uint32_t        enumType;
+} _PackedType t_FmIpcMacParams;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef _Packed struct
+{
+    t_FmIpcMacParams    macParams;
+    uint16_t            maxFrameLength;
+} _PackedType t_FmIpcMacMaxFrameParams;
 
 /**************************************************************************//**
  @Description   FM physical Address
 *//***************************************************************************/
-//typedef uint8_t fmIpcPhysAddr_t[FM_IC_PHYS_ADDRESS_SIZE];
+typedef _Packed struct t_FmIpcPhysAddr
+{
+    volatile uint8_t    high;
+    volatile uint32_t   low;
+} _PackedType t_FmIpcPhysAddr;
 
 /**************************************************************************//**
- @Description   Structure for port-FM communication during FM_PORT_Init.
+ @Description   Structure for IPC communication during FM_PORT_Init.
                 Fields commented 'IN' are passed by the port module to be used
                 by the FM module.
                 Fields commented 'OUT' will be filled by FM before returning to port.
                 Some fields are optional (depending on configuration) and
                 will be analized by the port and FM modules accordingly.
 *//***************************************************************************/
-//typedef struct
-//{
-//    uint8_t             hardwarePortId;       /**< IN. port Id */
-//    e_FmPortIcType      portType;           /**< IN. Port type */
-//    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
-//    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
-//    uint8_t             portPartition;      /**< IN. Port's requested resource */
-//    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
-//    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
-//    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
-//    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
-//    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
-//    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
-//    fmIcPhysAddr_t      fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
-//} t_FmIcPortInitParams;
+typedef _Packed struct t_FmIpcPortInitParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    uint32_t            enumPortType;       /**< IN. Port type */
+    uint8_t             boolIndependentMode;/**< IN. TRUE if FM Port operates in independent mode */
+    uint16_t            portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
+                                                 LIODN base for this port, to be
+                                                 used together with LIODN offset. */
+    t_FmIpcPhysAddr     fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} _PackedType t_FmIpcPortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortFreeParams {
+    uint8_t             hardwarePortId;         /**< IN. port Id */
+    uint32_t            enumPortType;           /**< IN. Port type */
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+} _PackedType t_FmIpcPortFreeParams;
 
 /**************************************************************************//**
- @Description   Structure for finding out whether a port is stalled.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
+ @Description   Structure for defining DMA status
 *//***************************************************************************/
-typedef struct
+typedef _Packed struct t_FmIpcDmaStatus {
+    uint8_t    boolCmqNotEmpty;            /**< Command queue is not empty */
+    uint8_t    boolBusError;               /**< Bus error occured */
+    uint8_t    boolReadBufEccError;        /**< Double ECC error on buffer Read */
+    uint8_t    boolWriteBufEccSysError;    /**< Double ECC error on buffer write from system side */
+    uint8_t    boolWriteBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+} _PackedType t_FmIpcDmaStatus;
+
+typedef _Packed struct t_FmIpcGetCounter
 {
-    uint8_t             hardwarePortId;       /**< IN. port Id */
-    bool                isStalled;          /**< OUT. TRUE if FM PORT is stalled */
-} t_FmIpcPortIsStalled;
+    uint32_t        enumId;     /* IN */
+    uint32_t        val;        /* OUT */
+} _PackedType t_FmIpcGetCounter;
 
+typedef _Packed struct t_FmIpcRegisterIntr
+{
+    uint8_t         partitionId;    /* IN */
+    uint32_t        event;          /* IN */
+} _PackedType t_FmIpcRegisterIntr;
 
+typedef _Packed struct t_FmIpcIsr
+{
+    uint8_t         boolErr;        /* IN */
+    uint32_t        pendingReg;     /* IN */
+} _PackedType t_FmIpcIsr;
 
 /**************************************************************************//**
- @Description   enum for defining MAC types
+ @Description   structure for returning revision information
 *//***************************************************************************/
-typedef enum
-{
-    e_FM_IPC_MAC_10G,
-    e_FM_IPC_MAC_1G
-} e_FmIpcMacType;
+typedef _Packed struct t_FmIpcRevisionInfo {
+    uint8_t         majorRev;               /**< OUT: Major revision */
+    uint8_t         minorRev;               /**< OUT: Minor revision */
+} _PackedType t_FmIpcRevisionInfo;
+
 
 /**************************************************************************//**
- @Description   A structure of parameters for specifying a MAC.
+ @Description   structure for setting Fman contriller events
 *//***************************************************************************/
-typedef struct
-{
-    uint8_t         id;
-    e_FmIpcMacType   type;
-} t_FmIpcMacReset;
+typedef _Packed struct t_FmIpcFmanEvents {
+    uint8_t         eventRegId;               /**< IN: Fman controller event register id */
+    uint32_t        enableEvents;             /**< IN/OUT: required enabled events mask */
+} _PackedType t_FmIpcFmanEvents;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
 
 
+/***************************************************************************/
+/************************ FRONT-END-TO-BACK-END*****************************/
+/***************************************************************************/
+
 /**************************************************************************//**
- @Function      FM_RESET_MAC
+ @Function      FM_GET_TIMESTAMP_SCALE
 
- @Description   Used by MAC module to reset the MAC registers
+ @Description   Used by FM front-end.
 
- @Param[in]     t_FmIpcMacReset  .
+ @Param[out]    uint32_t Pointer
+*//***************************************************************************/
+#define FM_GET_TIMESTAMP_SCALE      1
+
+/**************************************************************************//**
+ @Function      FM_GET_COUNTER
 
- @Return        E_OK on success; Error code otherwise.
+ @Description   Used by FM front-end.
+
+ @Param[in/out] t_FmIpcGetCounter Pointer
 *//***************************************************************************/
-//#define FM_RESET_MAC                10
+#define FM_GET_COUNTER              2
 
 /**************************************************************************//**
- @Function      FM_GET_SET_PORT_PARAMS
+ @Function      FM_DUMP_REGS
 
- @Description   Used by FM PORT module in order to set and get parameters in/from
-                FM module on FM PORT initialization time.
+ @Description   Used by FM front-end for the PORT module in order to set and get
+                parameters in/from master FM module on FM PORT initialization time.
+
+ @Param         None
+*//***************************************************************************/
+#define FM_DUMP_REGS                3
+
+/**************************************************************************//**
+ @Function      FM_GET_SET_PORT_PARAMS
 
- @Param[in/out] t_FmIcPortInitParams
+ @Description   Used by FM front-end for the PORT module in order to set and get
+                parameters in/from master FM module on FM PORT initialization time.
 
+ @Param[in/out] t_FmIcPortInitParams Pointer
 *//***************************************************************************/
-//#define FM_GET_SET_PORT_PARAMS      11
+#define FM_GET_SET_PORT_PARAMS      4
 
 /**************************************************************************//**
- @Function      FM_IS_PORT_STALLED
+ @Function      FM_FREE_PORT
 
- @Description   Used by FM PORT module in order to check whether
-                an FM port is stalled.
+ @Description   Used by FM front-end for the PORT module when a port is freed
+                to free all FM PORT resources.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_FREE_PORT                5
 
- @Param[in/out] t_FmIcPortIsStalled
+/**************************************************************************//**
+ @Function      FM_RESET_MAC
+
+ @Description   Used by front-end for the MAC module to reset the MAC registers
 
+ @Param[in]     t_FmIpcMacParams Pointer .
 *//***************************************************************************/
-//#define FM_IS_PORT_STALLED          12
+#define FM_RESET_MAC                6
 
 /**************************************************************************//**
  @Function      FM_RESUME_STALLED_PORT
 
- @Description   Used by FM PORT module in order to release a stalled
-                FM Port.
+ @Description   Used by FM front-end for the PORT module in order to
+                release a stalled FM Port.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_RESUME_STALLED_PORT      7
+
+/**************************************************************************//**
+ @Function      FM_IS_PORT_STALLED
 
- @Param[in]     hardwarePortId
+ @Description   Used by FM front-end for the PORT module in order to check whether
+                an FM port is stalled.
 
+ @Param[in/out] t_FmIcPortIsStalled Pointer
 *//***************************************************************************/
-//#define FM_RESUME_STALLED_PORT     13
+#define FM_IS_PORT_STALLED          8
 
 /**************************************************************************//**
  @Function      FM_DUMP_PORT_REGS
 
- @Description   Used by FM PORT module in order to dump all port registers
-                that are a part of the FM module.
-
- @Param[in]     hardwarePortId
+ @Description   Used by FM front-end for the PORT module in order to dump
+                all port registers.
 
- @Return        E_OK on success; Error code otherwise.
+ @Param[in]     uint8_t Pointer
 *//***************************************************************************/
-//#define FM_DUMP_PORT_REGS           14
-
+#define FM_DUMP_PORT_REGS           9
 
 /**************************************************************************//**
- @Function      FM_FREE_PORT
-
- @Description   Used by FM PORT module when a port is freed to free all FM resources.
+ @Function      FM_GET_REV
 
- @Param[in]     hardwarePortId
+ @Description   Used by FM front-end for the PORT module in order to dump
+                all port registers.
 
- @Return        None.
+ @Param[in]     uint8_t Pointer
 *//***************************************************************************/
-//#define FM_FREE_PORT                15
+#define FM_GET_REV                  10
 
+/**************************************************************************//**
+ @Function      FM_REGISTER_INTR
 
+ @Description   Used by FM front-end to register an interrupt handler to
+                be called upon interrupt for guest.
 
-/*=============================*/
-/**************************************************************************//**
- @Description   enum for defining port types
+ @Param[out]    t_FmIpcRegisterIntr Pointer
 *//***************************************************************************/
+#define FM_REGISTER_INTR            11
 
 /**************************************************************************//**
- @Description   enum for defining port types
+ @Function      FM_GET_CLK_FREQ
+
+ @Description   Used by FM Front-end to read the FM clock frequency.
+
+ @Param[out]    uint32_t Pointer
 *//***************************************************************************/
-typedef enum e_FmIpcPortType {
-    e_FM_IPC_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
-                                             host command, so must have exclusive id) */
-    e_FM_IPC_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
-                                             offline parsing ports, so must have exclusive id) */
-    e_FM_IPC_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
-    e_FM_IPC_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
-    e_FM_IPC_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
-    e_FM_IPC_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
-    e_FM_IPC_PORT_TYPE_DUMMY
-} e_FmIpcPortType;
+#define FM_GET_CLK_FREQ             12
 
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
+/**************************************************************************//**
+ @Function      FM_DMA_STAT
+
+ @Description   Used by FM front-end to read the FM DMA status.
+
+ @Param[out]    t_FmIpcDmaStatus Pointer
+*//***************************************************************************/
+#define FM_DMA_STAT                 13
 
 /**************************************************************************//**
- @Description   FM physical Address
+ @Function      FM_ALLOC_FMAN_CTRL_EVENT_REG
+
+ @Description   Used by FM front-end to allocate event register.
+
+ @Param[out]    Event register id Pointer
 *//***************************************************************************/
-typedef _Packed struct t_FmIpcPhysAddr
-{
-    volatile uint16_t high;
-    volatile uint32_t low;
-} _PackedType t_FmIpcPhysAddr;
+#define FM_ALLOC_FMAN_CTRL_EVENT_REG 14
 
-#define MEM_MAP_END
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
+/**************************************************************************//**
+ @Function      FM_FREE_FMAN_CTRL_EVENT_REG
 
+ @Description   Used by FM front-end to free locate event register.
 
-#define FM_GET_TIMESTAMP            1
-#define FM_GET_TIMESTAMP_PERIOD     2
-#define FM_GET_COUNTER              3
-#define FM_DUMP_REGS                4
-#define FM_GET_SET_PORT_PARAMS      5
-#define FM_FREE_PORT                6
-#define FM_RESET_MAC                7
-#define FM_RESUME_STALLED_PORT      8
-#define FM_IS_PORT_STALLED          9
-#define FM_DUMP_PORT_REGS           10
-#define FM_GET_REV                  11
-#define FM_REGISTER_INTR            12
-#define FM_GUEST_ISR                13
-#define FM_GET_CLK_FREQ             14
+ @Param[in]    uint8_t Pointer - Event register id
+*//***************************************************************************/
+#define FM_FREE_FMAN_CTRL_EVENT_REG 15
 
 /**************************************************************************//**
- @Description   Structure for IPC communication during FM_PORT_Init.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-                Some fields are optional (depending on configuration) and
-                will be analized by the port and FM modules accordingly.
+ @Function      FM_SET_FMAN_CTRL_EVENTS_ENABLE
+
+ @Description   Used by FM front-end to enable events in the FPM
+                Fman controller event register.
+
+ @Param[in]    t_FmIpcFmanEvents Pointer
 *//***************************************************************************/
-typedef struct t_FmIpcPortInitParams {
-    uint8_t             hardwarePortId;       /**< IN. port Id */
-    e_FmIpcPortType     portType;           /**< IN. Port type */
-    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
-    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
-    uint8_t             portPartition;      /**< IN. Port's requested resource */
-    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
-    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
-    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
-    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
-    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
-    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
-    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
-    t_FmIpcPhysAddr     fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
-} t_FmIpcPortInitParams;
+#define FM_SET_FMAN_CTRL_EVENTS_ENABLE 16
 
 /**************************************************************************//**
- @Description   Structure for port-FM communication during FM_PORT_Free.
+ @Function      FM_SET_FMAN_CTRL_EVENTS_ENABLE
+
+ @Description   Used by FM front-end to enable events in the FPM
+                Fman controller event register.
+
+ @Param[in/out] t_FmIpcFmanEvents Pointer
 *//***************************************************************************/
-typedef struct t_FmIpcPortFreeParams {
-    uint8_t             hardwarePortId;         /**< IN. port Id */
-    e_FmIpcPortType     portType;               /**< IN. Port type */
-    uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
-} t_FmIpcPortFreeParams;
+#define FM_GET_FMAN_CTRL_EVENTS_ENABLE 17
+
+/**************************************************************************//**
+ @Function      FM_SET_MAC_MAX_FRAME
+
+ @Description   Used by FM front-end to set MAC's MTU/RTU's in
+                back-end.
 
+ @Param[in/out] t_FmIpcMacMaxFrameParams Pointer
+*//***************************************************************************/
+#define FM_SET_MAC_MAX_FRAME 18
 
 /**************************************************************************//**
- @Description   enum for defining FM counters
+ @Function      FM_GET_PHYS_MURAM_BASE
+
+ @Description   Used by FM front-end in order to get MURAM base address
+
+ @Param[in/out] t_FmIpcPhysAddr Pointer
 *//***************************************************************************/
-typedef enum e_FmIpcCounters {
-    e_FM_IPC_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
-    e_FM_IPC_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
-    e_FM_IPC_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
-    e_FM_IPC_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
-    e_FM_IPC_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
-    e_FM_IPC_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
-    e_FM_IPC_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
-    e_FM_IPC_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
-    e_FM_IPC_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
-    e_FM_IPC_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
-    e_FM_IPC_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
-    e_FM_IPC_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
-    e_FM_IPC_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
-} e_FmIpcCounters;
+#define FM_GET_PHYS_MURAM_BASE  19
 
-typedef struct t_FmIpcGetCounter
-{
-    e_FmIpcCounters id;         /* IN */
-    uint32_t        val;        /* OUT */
-} t_FmIpcGetCounter;
+/***************************************************************************/
+/************************ BACK-END-TO-FRONT-END*****************************/
+/***************************************************************************/
 
-typedef struct t_FmIpcRegisterIntr
-{
-    uint8_t         partitionId;    /* IN */
-    uint32_t        event;          /* IN */
-} t_FmIpcRegisterIntr;
+/**************************************************************************//**
+ @Function      FM_GUEST_ISR
 
-typedef struct t_FmIpcIsr
-{
-    bool            err;            /* IN */
-    uint32_t        pendingReg;     /* IN */
-} t_FmIpcIsr;
+ @Description   Used by FM back-end to report an interrupt to the front-end.
+
+ @Param[out]    t_FmIpcIsr Pointer
+*//***************************************************************************/
+#define FM_GUEST_ISR                1
 
 /** @} */ /* end of FM_IPC_grp group */
 /** @} */ /* end of FM_grp group */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index aa93ecd..665e6cd 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -45,7 +45,6 @@
 
 
 #define CLS_PLAN_NUM_PER_GRP                        8
-#define DRIVER_PRIVATE_NET_ENV_ID                   PCD_MAX_NUM_OF_PORTS
 
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
@@ -102,6 +101,7 @@ typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
+
 typedef struct {
     uint8_t             baseEntry;
     uint16_t            numOfClsPlanEntries;
@@ -120,41 +120,68 @@ typedef struct t_FmPcdKgInterModuleBindPortToSchemes {
 } t_FmPcdKgInterModuleBindPortToSchemes;
 
 
-#define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, h_Node)
-
 typedef struct {
     uint32_t nextCcNodeInfo;
-    t_List   h_Node;
+    t_List   node;
 } t_CcNodeInfo;
 
+typedef struct
+{
+    t_Handle h_Manip;
+    t_List   node;
+}t_ManipInfo;
+#define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, node)
 
-#define TRY_LOCK_RET_ERR(lock)                                  \
-do {                                                            \
-    uint32_t intFlags;                                          \
-    intFlags = XX_DisableAllIntr();                             \
-    if (lock)                                                   \
-    {                                                           \
-        XX_RestoreAllIntr(intFlags);                            \
-        return ERROR_CODE(E_BUSY);                              \
-    }                                                           \
-    lock = TRUE;                                                \
-    XX_RestoreAllIntr(intFlags);                                \
-} while (0)
+typedef struct
+{
+    uint32_t    type;
+    uint8_t     prOffset;
 
-#define TRY_LOCK_RET_NULL(lock)                                 \
-do {                                                            \
-    uint32_t intFlags;                                          \
-    intFlags = XX_DisableAllIntr();                             \
-    if (lock)                                                   \
-    {                                                           \
-        XX_RestoreAllIntr(intFlags);                            \
-        return NULL;                                            \
-    }                                                           \
-    lock = TRUE;                                                \
-    XX_RestoreAllIntr(intFlags);                                \
-} while (0)
+    uint16_t     dataOffset;
+    uint8_t      poolIndex;
+
+    uint8_t     poolIdForManip;
+    uint8_t     numOfTasks;
+}t_GetCcParams;
 
-#define RELEASE_LOCK(lock) lock = FALSE;
+typedef struct
+{
+    uint32_t type;
+    int      psoSize;
+    uint32_t nia;
+
+}t_SetCcParams;
+typedef struct
+{
+    t_GetCcParams getCcParams;
+    t_SetCcParams setCcParams;
+}t_FmPortGetSetCcParams;
+
+
+static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, uint32_t flag)
+{
+    uint32_t intFlags;
+    if (h_Spinlock)
+        intFlags = XX_LockIntrSpinlock(h_Spinlock);
+    else
+        intFlags = XX_DisableAllIntr();
+    if (flag)
+    {
+        if (h_Spinlock)
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+        else
+            XX_RestoreAllIntr(intFlags);
+        return FALSE;
+    }
+    flag = TRUE;
+    if (h_Spinlock)
+        XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+    else
+        XX_RestoreAllIntr(intFlags);
+    return TRUE;
+}
+
+#define RELEASE_LOCK(flag) flag = FALSE;
 
 #if defined (CONFIG_GUEST_PARTITION) && !defined (CONFIG_MULTI_PARTITION_SUPPORT)
 #error "CONFIG_MULTI_PARTITION_SUPPORT must be defined!"
@@ -163,6 +190,29 @@ do {                                                            \
 #endif /* defined (CONFIG_GUEST_PARTITION) && ... */
 
 /**************************************************************************//**
+ @Collection   Defines used for manipulation CC and BMI
+
+ @{
+*//***************************************************************************/
+
+#define INTERNAL_CONTEXT_OFFSET                 0x80000000
+#define OFFSET_OF_PR                            0x40000000
+#define BUFFER_POOL_ID_FOR_MANIP                0x20000000
+#define NUM_OF_TASKS                            0x10000000
+#define OFFSET_OF_DATA                          0x08000000
+
+#define UPDATE_NIA                              0x80000000
+#define UPDATE_PSO                              0x40000000
+
+/**************************************************************************//**
+ @Collection   Defines used for manipulation CC and CC
+
+ @{
+*//***************************************************************************/
+
+#define UPDATE_NIA_ENQ_WITHOUT_DMA              0x80000000
+#define UPDATE_NIA_ENQ_WITH_DMA                 0x40000000
+/**************************************************************************//**
  @Collection   Defines used for enabling/disabling FM interrupts
 
  @{
@@ -184,6 +234,8 @@ typedef uint32_t t_FmBlockErrIntrEnable;
 #define ERR_INTR_EN_1G_MAC1     0x00002000
 #define ERR_INTR_EN_1G_MAC2     0x00001000
 #define ERR_INTR_EN_1G_MAC3     0x00000800
+#define ERR_INTR_EN_MACSEC_MAC0 0x00000200
+
 
 typedef uint32_t t_FmBlockIntrEnable;
 
@@ -205,17 +257,22 @@ typedef uint32_t t_FmBlockIntrEnable;
 #define INTR_EN_1G_MAC1         0x00400000
 #define INTR_EN_1G_MAC2         0x00200000
 #define INTR_EN_1G_MAC3         0x00100000
+#define INTR_EN_MACSEC_MAC0     0x00000001
 
 /* @} */
 
 
-#define PCD_MAX_NUM_OF_PORTS        (FM_MAX_NUM_OF_OH_PORTS +       \
+#define FM_MAX_NUM_OF_PORTS         (FM_MAX_NUM_OF_OH_PORTS +       \
                                      FM_MAX_NUM_OF_1G_RX_PORTS +    \
-                                     FM_MAX_NUM_OF_10G_RX_PORTS)
+                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
+                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)
+
 #define MODULE_NAME_SIZE            30
 #define DUMMY_PORT_ID               0
 
 #define FM_LIODN_OFFSET_MASK        0x3FF
+
 /**************************************************************************//**
   @Description       NIA Description
 *//***************************************************************************/
@@ -234,6 +291,7 @@ typedef uint32_t t_FmBlockIntrEnable;
 #define NIA_FM_CTL_AC_HC            0x0000000C
 #define NIA_FM_CTL_AC_IND_MODE_TX   0x00000008
 #define NIA_FM_CTL_AC_IND_MODE_RX   0x0000000A
+#define NIA_FM_CTL_AC_FRAG          0x0000000e
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -247,85 +305,124 @@ typedef uint32_t t_FmBlockIntrEnable;
 #define NIA_KG_CC_EN                0x00000200
 #define NIA_PLCR_ABSOLUTE           0x00008000
 
+#define NIA_BMI_AC_WITHOUT_DMA      0x00000200
+
 /**************************************************************************//**
  @Description       Port Id defines
 *//***************************************************************************/
-#define BASE_HO_PORTID              1
-#define BASE_RX_PORTID              8
-#define BASE_RX10_PORTID            0x10
-#define BASE_TX_PORTID              0x28
-#define BASE_TX10_PORTID            0x30
-#define LAST_HO_PORTID              7
-#define LAST_RX_PORTID              0xB
-#define LAST_TX_PORTID              0x2B
-#define LAST_RX10_PORTID            0x10
-#define LAST_TX10_PORTID            0x30
-
-#define GET_GLOBAL_PORTID(port, type, id)               \
-switch(type){                                           \
-    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):            \
-    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):               \
-        port = (uint8_t)(BASE_HO_PORTID + id);          \
-        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
-        break;                                          \
-    case(e_FM_PORT_TYPE_RX):                            \
-        port = (uint8_t)(BASE_RX_PORTID + id);          \
-        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
-        break;                                          \
-    case(e_FM_PORT_TYPE_RX_10G):                        \
-        port = (uint8_t)(BASE_RX10_PORTID + id);        \
-        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
-        break;                                          \
-    case(e_FM_PORT_TYPE_TX):                            \
-        port = (uint8_t)(BASE_TX_PORTID + id);          \
-        if (id > (LAST_TX_PORTID-BASE_TX_PORTID))       \
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
-        break;                                          \
-    case(e_FM_PORT_TYPE_TX_10G):                        \
-        port = (uint8_t)(BASE_TX10_PORTID + id);        \
-        if (id > (LAST_TX10_PORTID-BASE_TX10_PORTID))   \
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
-        break;                                          \
-    default:                                            \
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type")); \
-        break;                                          \
+#define BASE_OH_PORTID              1
+#define BASE_1G_RX_PORTID           8
+#define BASE_10G_RX_PORTID          0x10
+#define BASE_1G_TX_PORTID           0x28
+#define BASE_10G_TX_PORTID          0x30
+
+#define FM_PCD_PORT_OH_BASE_INDX        0
+#define FM_PCD_PORT_1G_RX_BASE_INDX     (FM_PCD_PORT_OH_BASE_INDX+FM_MAX_NUM_OF_OH_PORTS)
+#define FM_PCD_PORT_10G_RX_BASE_INDX    (FM_PCD_PORT_1G_RX_BASE_INDX+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_PCD_PORT_1G_TX_BASE_INDX     (FM_PCD_PORT_10G_RX_BASE_INDX+FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_PCD_PORT_10G_TX_BASE_INDX    (FM_PCD_PORT_1G_TX_BASE_INDX+FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define SW_PORT_ID_TO_HW_PORT_ID(port, type, relativePortId)            \
+switch(type){                                           				\
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):            				\
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):               				\
+        if (relativePortId >= FM_MAX_NUM_OF_OH_PORTS)               	\
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); 	\
+        port = (uint8_t)(BASE_OH_PORTID + relativePortId);          	\
+        break;                                          				\
+    case(e_FM_PORT_TYPE_RX):                            				\
+        if (relativePortId >= FM_MAX_NUM_OF_1G_RX_PORTS)            	\
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); 	\
+        port = (uint8_t)(BASE_1G_RX_PORTID + relativePortId);          	\
+        break;                                          				\
+    case(e_FM_PORT_TYPE_RX_10G):                        				\
+        if (relativePortId >= FM_MAX_NUM_OF_10G_RX_PORTS)           	\
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); 	\
+        port = (uint8_t)(BASE_10G_RX_PORTID + relativePortId);        	\
+        break;                                          				\
+    case(e_FM_PORT_TYPE_TX):                            				\
+        if (relativePortId >= FM_MAX_NUM_OF_1G_TX_PORTS)            	\
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); 	\
+        port = (uint8_t)(BASE_1G_TX_PORTID + relativePortId);          	\
+        break;                                          				\
+    case(e_FM_PORT_TYPE_TX_10G):                        				\
+        if (relativePortId >= FM_MAX_NUM_OF_10G_TX_PORTS)           	\
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); 	\
+        port = (uint8_t)(BASE_10G_TX_PORTID + relativePortId);        	\
+        break;                                          				\
+    default:                                            				\
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type")); 	\
+        break;                                          				\
 }
 
-#define GET_RELATIVE_PORTID(relativePortId, hardwarePortId)                           \
-{   if ((hardwarePortId>=BASE_HO_PORTID) && (hardwarePortId<=LAST_HO_PORTID))           \
-        relativePortId = (uint8_t)(hardwarePortId-BASE_HO_PORTID);                    \
-    else if ((hardwarePortId>=BASE_TX10_PORTID) && (hardwarePortId<=LAST_TX10_PORTID))  \
-        relativePortId = (uint8_t)(hardwarePortId-BASE_TX10_PORTID);                  \
-    else if ((hardwarePortId>=BASE_TX_PORTID) && (hardwarePortId<=LAST_TX_PORTID))      \
-        relativePortId = (uint8_t)(hardwarePortId-BASE_TX_PORTID);                    \
-    else if ((hardwarePortId>=BASE_RX10_PORTID) && (hardwarePortId<=LAST_RX10_PORTID))  \
-        relativePortId = (uint8_t)(hardwarePortId-BASE_RX10_PORTID);                  \
-    else if ((hardwarePortId>=BASE_RX_PORTID) && (hardwarePortId<=LAST_RX_PORTID))      \
-        relativePortId = (uint8_t)(hardwarePortId-BASE_RX_PORTID);                    \
-    else {                                                                          \
-        relativePortId = (uint8_t)DUMMY_PORT_ID;                                    \
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));                \
-    }                                                                               \
+#define HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId)                                                    \
+{   if ((hardwarePortId>=BASE_OH_PORTID) && (hardwarePortId<BASE_OH_PORTID+FM_MAX_NUM_OF_OH_PORTS))                 \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_OH_PORTID);                                                  \
+    else if ((hardwarePortId>=BASE_10G_TX_PORTID) && (hardwarePortId<BASE_10G_TX_PORTID+FM_MAX_NUM_OF_10G_TX_PORTS))\
+        relativePortId = (uint8_t)(hardwarePortId-BASE_10G_TX_PORTID);                                              \
+    else if ((hardwarePortId>=BASE_1G_TX_PORTID) && (hardwarePortId<BASE_1G_TX_PORTID+FM_MAX_NUM_OF_1G_TX_PORTS))  \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_1G_TX_PORTID);                                               \
+    else if ((hardwarePortId>=BASE_10G_RX_PORTID) && (hardwarePortId<BASE_10G_RX_PORTID+FM_MAX_NUM_OF_10G_RX_PORTS)) \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_10G_RX_PORTID);                                              \
+    else if ((hardwarePortId>=BASE_1G_RX_PORTID) && (hardwarePortId<BASE_1G_RX_PORTID+FM_MAX_NUM_OF_1G_RX_PORTS))   \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_1G_RX_PORTID);                                               \
+    else {                                                                                                          \
+        relativePortId = (uint8_t)DUMMY_PORT_ID;                                                                    \
+        ASSERT_COND(TRUE);                                                                                         \
+    }                                                                                                               \
 }
 
+#define HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId)                                     \
+do {                                                                                                \
+    if ((hardwarePortId>=BASE_OH_PORTID) && (hardwarePortId<BASE_OH_PORTID+FM_MAX_NUM_OF_OH_PORTS)) \
+        swPortIndex = (uint8_t)(hardwarePortId-BASE_OH_PORTID+FM_PCD_PORT_OH_BASE_INDX);            \
+    else if ((hardwarePortId>=BASE_1G_RX_PORTID) &&                                                 \
+             (hardwarePortId<BASE_1G_RX_PORTID+FM_MAX_NUM_OF_1G_RX_PORTS))                          \
+        swPortIndex = (uint8_t)(hardwarePortId-BASE_1G_RX_PORTID+FM_PCD_PORT_1G_RX_BASE_INDX);      \
+    else if ((hardwarePortId>=BASE_10G_RX_PORTID) &&                                                \
+             (hardwarePortId<BASE_10G_RX_PORTID+FM_MAX_NUM_OF_10G_RX_PORTS))                        \
+        swPortIndex = (uint8_t)(hardwarePortId-BASE_10G_RX_PORTID+FM_PCD_PORT_10G_RX_BASE_INDX);    \
+    else if ((hardwarePortId>=BASE_1G_TX_PORTID) &&                                                 \
+             (hardwarePortId<BASE_1G_TX_PORTID+FM_MAX_NUM_OF_1G_TX_PORTS))                          \
+        swPortIndex = (uint8_t)(hardwarePortId-BASE_1G_TX_PORTID+FM_PCD_PORT_1G_TX_BASE_INDX);      \
+    else if ((hardwarePortId>=BASE_10G_TX_PORTID) &&                                                \
+             (hardwarePortId<BASE_10G_TX_PORTID+FM_MAX_NUM_OF_10G_TX_PORTS))                        \
+        swPortIndex = (uint8_t)(hardwarePortId-BASE_10G_TX_PORTID+FM_PCD_PORT_10G_TX_BASE_INDX);    \
+    else ASSERT_COND(FALSE);                                                                        \
+} while (0)
+
+#define SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, swPortIndex)                                         \
+do {                                                                                                    \
+    if ((swPortIndex>=FM_PCD_PORT_OH_BASE_INDX) && (swPortIndex<FM_PCD_PORT_1G_RX_BASE_INDX))           \
+        hardwarePortId = (uint8_t)(swPortIndex-FM_PCD_PORT_OH_BASE_INDX+BASE_OH_PORTID);                \
+    else if ((swPortIndex>=FM_PCD_PORT_1G_RX_BASE_INDX) && (swPortIndex<FM_PCD_PORT_10G_RX_BASE_INDX))  \
+        hardwarePortId = (uint8_t)(swPortIndex-FM_PCD_PORT_1G_RX_BASE_INDX+BASE_1G_RX_PORTID);          \
+    else if ((swPortIndex>=FM_PCD_PORT_10G_RX_BASE_INDX) && (swPortIndex<FM_MAX_NUM_OF_PORTS))          \
+        hardwarePortId = (uint8_t)(swPortIndex-FM_PCD_PORT_10G_RX_BASE_INDX+BASE_10G_RX_PORTID);        \
+    else if ((swPortIndex>=FM_PCD_PORT_1G_TX_BASE_INDX) && (swPortIndex<FM_PCD_PORT_10G_TX_BASE_INDX))  \
+        hardwarePortId = (uint8_t)(swPortIndex-FM_PCD_PORT_1G_TX_BASE_INDX+BASE_1G_TX_PORTID);          \
+    else if ((swPortIndex>=FM_PCD_PORT_10G_TX_BASE_INDX) && (swPortIndex<FM_MAX_NUM_OF_PORTS))          \
+        hardwarePortId = (uint8_t)(swPortIndex-FM_PCD_PORT_10G_TX_BASE_INDX+BASE_10G_TX_PORTID);        \
+    else ASSERT_COND(FALSE);                                                                            \
+} while (0)
+
 #define BMI_FIFO_UNITS                      0x100
-#define BMI_MAX_FIFO_SIZE                   (160*KILOBYTE)
 
-typedef struct
-{
+typedef struct {
     void        (*f_Isr) (t_Handle h_Arg);
     t_Handle    h_SrcHandle;
 #ifdef FM_MASTER_PARTITION
     uint8_t     partitionId;
-#endif
+#endif /* FM_MASTER_PARTITION */
 } t_FmIntrSrc;
 
 #define ILLEGAL_HDR_NUM                         0xFF
 #define NO_HDR_NUM                              FM_PCD_PRS_NUM_OF_HDRS
 
+#define IS_PRIVATE_HEADER(hdr)              ((hdr == HEADER_TYPE_USER_DEFINED_SHIM1 ) ||   \
+                                             (hdr == HEADER_TYPE_USER_DEFINED_SHIM2))
+#define IS_SPECIAL_HEADER(hdr)              (hdr == HEADER_TYPE_MACSEC)
+
 #define GET_PRS_HDR_NUM(num, hdr)                           \
 switch(hdr)                                                 \
 {   case(HEADER_TYPE_ETH):              num = 0;  break;    \
@@ -347,7 +444,7 @@ switch(hdr)                                                 \
     case(HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;    \
     case(HEADER_TYPE_USER_DEFINED_SHIM1):                   \
     case(HEADER_TYPE_USER_DEFINED_SHIM2):                   \
-    case(HEADER_TYPE_USER_DEFINED_SHIM3):                   \
+    case(HEADER_TYPE_MACSEC):                               \
         num = NO_HDR_NUM; break;                            \
     default:                                                \
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
@@ -370,6 +467,7 @@ switch(hdr)                                                 \
 /***********************************************************************/
 /* maskes */
 #define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_NO_GEN                        0x10000000
 #define KG_SCH_PP_SHIFT_LOW                     0x0000F000
 #define KG_SCH_MODE_NIA_PLCR                    0x40000000
 #define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
@@ -382,6 +480,8 @@ switch(hdr)                                                 \
 #define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
 #define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
 #define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
+#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
 
 #define FM_PCD_KG_KGAR_GO                       0x80000000
 #define FM_PCD_KG_KGAR_READ                     0x40000000
@@ -424,10 +524,10 @@ typedef uint8_t t_GenericCodes;
 
 #define KG_SCH_GEN_SHIM1                       0x70
 #define KG_SCH_GEN_DEFAULT                     0x10
-#define KG_SCH_GEN_PARSE_RESULT                0x20
+#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
 #define KG_SCH_GEN_START_OF_FRM                0x40
 #define KG_SCH_GEN_SHIM2                       0x71
-#define KG_SCH_GEN_SHIM3                       0x72
+#define KG_SCH_GEN_IP_PID_NO_V                 0x72
 #define KG_SCH_GEN_ETH                         0x03
 #define KG_SCH_GEN_ETH_NO_V                    0x73
 #define KG_SCH_GEN_SNAP                        0x04
@@ -496,7 +596,8 @@ typedef uint8_t t_GenericCodes;
 #define MAX_KG_SCH_SIZE                     16
 #define MASK_FOR_GENERIC_BASE_ID            0x20
 #define MAX_HASH_SHIFT                      40
-#define MAX_KG_SCH_BIT_OFFSET               23
+#define MAX_KG_SCH_FQID_BIT_OFFSET          31
+#define MAX_KG_SCH_PP_BIT_OFFSET            15
 #define MAX_DIST_FQID_SHIFT                 23
 
 #define GET_MASK_SEL_SHIFT(shift,i)             \
@@ -529,6 +630,7 @@ switch(i) {                                     \
     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
 }
 
+#define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
 
 typedef struct {
     uint16_t num;
@@ -536,14 +638,33 @@ typedef struct {
     uint16_t plcrProfilesBase;
 } t_FmPortPcdInterModulePlcrParams;
 
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct t_FmPcdKgInterModuleClsPlanGrpParams {
+    uint8_t         netEnvId;   /* IN */
+    bool            grpExists;  /* OUT (unused in FmPcdKgBuildClsPlanGrp)*/
+    uint8_t         clsPlanGrpId;  /* OUT */
+    bool            emptyClsPlanGrp; /* OUT */
+    uint8_t         numOfOptions;   /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+    protocolOpt_t   options[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+                                    /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+    uint32_t        optVectors[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+                               /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+} t_FmPcdKgInterModuleClsPlanGrpParams;
+
+typedef t_Error (t_FmPortGetSetCcParamsCallback)(t_Handle h_FmPort,
+                                      t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
+
 
 uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
 uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
+uint32_t    FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId);
 void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
 void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
 void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
-t_Error     FmPcdTryLock(t_Handle h_FmPcd);
-void        FmPcdReleaseLock(t_Handle h_FmPcd);
+uint32_t    FmPcdLock(t_Handle h_FmPcd);
+void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
 
 t_Error     FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood);
 t_Error     FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges);
@@ -564,12 +685,12 @@ void        FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List);
 bool        FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId);
 uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
-t_Error     FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray);
-void        FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
-bool        FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd);
-uint8_t     FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd);
+//t_Error     FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray);
+//void        FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+//bool        FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd);
+//uint8_t     FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd);
 t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
-t_Handle    FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
 uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
 uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
 uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
@@ -591,17 +712,13 @@ uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
 uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
-t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr);
 void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
 
 t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
 t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
-t_Error     FmPcdKgBindPortToClsPlanGrp(t_Handle p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
-void        FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId);
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-void        FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+t_Error     FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
 
 t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
 t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
@@ -613,39 +730,41 @@ uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
 uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
 t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
-t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
-                                e_FmPcdProfileTypeSelection profileType,
-                                t_Handle  h_FmPort,
-                                uint16_t relativeProfile,
-                                uint16_t *p_AbsoluteId);
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+                                          e_FmPcdProfileTypeSelection   profileType,
+                                          t_Handle                      h_FmPort,
+                                          uint16_t                      relativeProfile,
+                                          uint16_t                      *p_AbsoluteId);
 void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
-t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId);
+t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
 void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);
 
-t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset);
+uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
+uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
+
+t_Error     FmPcdManipUpdate(t_Handle h_FmPcd,t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, t_FmPortGetSetCcParamsCallback *p_FmPortGetSetCcParamsCallback);
+t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
+uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
+t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset
+#ifdef FM_MANIP_SUPPORT
+        ,t_FmPortGetSetCcParamsCallback *p_GetSetCcParamsCallback, t_Handle h_FmPort
+#endif /* FM_MANIP_SUPPORT */
+);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
-#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
-t_Error     FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
-#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
-
+t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
+t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction);
 
-t_Error     FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
-t_Error     FmPortDeletePcd(t_Handle h_FmPort);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
 uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
-uint8_t     FmPortGetClsPlanId(t_Handle h_FmPort);
-t_Error     FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId);
 void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
 t_Error     FmPortAttachPCD(t_Handle h_FmPort);
+t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
+t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 
-
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-uint8_t     FmGetPartitionId(t_Handle h_Fm);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 /**************************************************************************//**
  @Function      FmRegisterIntr
 
@@ -705,8 +824,8 @@ void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Ha
  @Description   enum for defining MAC types
 *//***************************************************************************/
 typedef enum e_FmMacType {
-    e_FM_MAC_10G,               /**< 10G MAC */
-    e_FM_MAC_1G                 /**< 1G MAC */
+    e_FM_MAC_10G = 0,               /**< 10G MAC */
+    e_FM_MAC_1G                     /**< 1G MAC */
 } e_FmMacType;
 
 /**************************************************************************//**
@@ -720,10 +839,6 @@ typedef enum e_FmMacType {
 typedef struct t_FmInterModulePortInitParams {
     uint8_t             hardwarePortId;     /**< IN. port Id */
     e_FmPortType        portType;           /**< IN. Port type */
-    bool                useRateLimit;       /**< IN. AN indication whether rate limit
-                                                 is used, to enable timestamp. */
-    uint8_t             count1MicroBit;     /**< OUT. an indication of which TS bit
-                                                 counts closest to 1 Microsecond. */
     bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
     uint16_t            portPartition;      /**< IN. Port's requested resource */
     uint8_t             numOfTasks;         /**< IN. Port's requested resource */
@@ -733,6 +848,9 @@ typedef struct t_FmInterModulePortInitParams {
     uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
     uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
     uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
+                                                 LIODN base for this port, to be
+                                                 used together with LIODN offset. */
     t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
 } t_FmInterModulePortInitParams;
 
@@ -742,7 +860,9 @@ typedef struct t_FmInterModulePortInitParams {
 typedef struct t_FmInterModulePortFreeParams {
     uint8_t             hardwarePortId;     /**< IN. port Id */
     e_FmPortType        portType;           /**< IN. Port type */
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 } t_FmInterModulePortFreeParams;
 
 /**************************************************************************//**
@@ -913,9 +1033,6 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 *//***************************************************************************/
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
 
-#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
-t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
-#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
 void        FmUnregisterPcd(t_Handle h_Fm);
 t_Handle    FmGetPcdHandle(t_Handle h_Fm);
@@ -923,6 +1040,15 @@ bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
 t_Error     FmEnableRamsEcc(t_Handle h_Fm);
 t_Error     FmDisableRamsEcc(t_Handle h_Fm);
 void        FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+t_Error     FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId);
+void        FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId);
+void        FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvents);
+uint32_t    FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId);
+void        FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event), t_Handle    h_Arg);
+void        FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId);
+t_Error     FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu);
+bool        FmIsMaster(t_Handle h_Fm);
+uint8_t     FmGetPartitionId(t_Handle h_Fm);
 
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index 4506e24..3600ae8 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -37,6 +37,9 @@
 #include "error_ext.h"
 
 
+#define __ERR_MODULE__  MODULE_FM_PCD
+
+
 typedef struct t_FmHcParams {
     t_Handle        h_Fm;
     t_Handle        h_FmPcd;
@@ -47,13 +50,14 @@ typedef struct t_FmHcParams {
 t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
 void        FmHcFree(t_Handle h_FmHc);
 
-void        FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd);
+void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
 t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 
-t_Handle    FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp);
-t_Error     FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp);
+t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
+//t_Handle    FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp);
+t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
 
 t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value);
 uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.c b/drivers/net/dpa/NetCommSw/etc/mm.c
index ede02ad..a240220 100644
--- a/drivers/net/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/dpa/NetCommSw/etc/mm.c
@@ -40,393 +40,126 @@
 #include "mm.h"
 
 
-/* Prototypes of the internal MM routines */
-static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name);
-
-static t_Error  MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end);
-static t_Error  MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd);
-static void     MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB);
-static t_Error  MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end);
-
-static t_Error  MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size);
-static t_Error  FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size);
-static t_Error  BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name);
 
 
 /**********************************************************************
- *                     MM API routines set                            *
+ *                     MM internal routines set                       *
  **********************************************************************/
 
-/*****************************************************************************/
-t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
+/****************************************************************
+ *  Routine:   InitBusyBlock
+ *
+ *  Description:
+ *      Initializes a new busy block of "size" bytes and started
+ *      rom "base" address. Each busy block has a name that
+ *      specified the purpose of the memory allocation.
+ *
+ *  Arguments:
+ *      busyBlock - handle to the busyBlock object
+ *      base      - base address of the busy block
+ *      size      - size of the busy block
+ *      name      - name that specified the busy block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for busy block.
+ ****************************************************************/
+static t_Error InitBusyBlock(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name)
 {
-    t_MM        *p_MM;
-    uint64_t    newBase, newSize;
-    int         i;
-
-    if (!size)
-    {
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size (should be positive)"));
-    }
-
-    /* Initializes a new MM object */
-    p_MM = (t_MM *)XX_Malloc(sizeof(t_MM));
-    if (!p_MM)
-    {
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    }
+    t_BusyBlock *p_BusyBlock;
+    int         n, nameLen;
 
-    /* initializes a new memory block */
-    if ( MemBlock_Init((t_Handle *)&p_MM->memBlocks, base, size) != E_OK )
+    p_BusyBlock = (t_BusyBlock *)XX_Malloc(sizeof(t_BusyBlock));
+    if ( !p_BusyBlock )
     {
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     }
 
-    /* A busy list is empty */
-    p_MM->busyBlocks = 0;
-
-    /*Initializes a new free block for each free list*/
-    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
-    {
-        newBase = MAKE_ALIGNED( base, (0x1 << i) );
-        newSize = size - (newBase - base);
-
-        if ( FreeBlock_Init((t_Handle *)&p_MM->freeBlocks[i], newBase, newSize ) != E_OK)
-        {
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-        }
-    }
+    p_BusyBlock->base = base;
+    p_BusyBlock->end = base + size;
+    nameLen = (int)strlen(name);
+    n = (nameLen > MM_MAX_NAME_LEN - 1) ? MM_MAX_NAME_LEN-1 : nameLen;
+    strncpy(p_BusyBlock->name, name, (uint32_t)n);
+    p_BusyBlock->name[n] = '\0';
+    p_BusyBlock->p_Next = 0;
 
-    *h_MM = p_MM;
+    *busyBlock = p_BusyBlock;
 
     return (E_OK);
 }
 
-
-/*****************************************************************************/
-uint64_t MM_Get(t_Handle h_MM, uint64_t size, int alignment, char* name)
-{
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_FreeBlock *p_FreeB;
-    t_BusyBlock *p_NewBusyB;
-    uint64_t    holdBase, holdEnd;
-    int         i = 0, j;
-
-    SANITY_CHECK_RETURN_VALUE(p_MM, E_INVALID_HANDLE, (uint64_t)ILLEGAL_BASE);
-
-    /* checks that alignment value is greater then zero */
-    if (alignment == 0)
-    {
-        alignment = 1;
-    }
-
-    j = alignment;
-
-    /* checks if alignment is a power of two, if it correct and if the
-       required size is multiple of the given alignment. */
-    while ((j & 0x1) == 0)
-    {
-        i++;
-        j = j >> 1;
-    }
-
-    /* if the given alignment isn't power of two, returns an error */
-    if (j != 1)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("alignment (should be power of 2)"));
-        return (uint64_t)ILLEGAL_BASE;
-    }
-
-    if (i > MM_MAX_ALIGNMENT)
-    {
-        return (MM_GetGreaterAlignment(p_MM, size, alignment, name));
-    }
-
-    /* look for a block of the size greater or equal to the required size. */
-    p_FreeB = p_MM->freeBlocks[i];
-    while ( p_FreeB && (p_FreeB->end - p_FreeB->base) < size )
-        p_FreeB = p_FreeB->p_Next;
-
-    /* If such block is found */
-    if ( !p_FreeB )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    holdBase = p_FreeB->base;
-    holdEnd = holdBase + size;
-
-    /* init a new busy block */
-    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* calls Update routine to update a lists of free blocks */
-    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* insert the new busy block into the list of busy blocks */
-    MM_AddBusy ( p_MM, p_NewBusyB );
-
-    return (holdBase);
-}
-
-
-/*****************************************************************************/
-uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
-{
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_FreeBlock *p_FreeB;
-    t_BusyBlock *p_NewBusyB;
-    bool        blockIsFree = FALSE;
-
-    ASSERT_COND(p_MM);
-
-    p_FreeB = p_MM->freeBlocks[0]; /* The biggest free blocks are in the
-                                      free list with alignment 1 */
-    while ( p_FreeB )
-    {
-        if ( base >= p_FreeB->base && (base+size) <= p_FreeB->end )
-        {
-            blockIsFree = TRUE;
-            break;
-        }
-        else
-            p_FreeB = p_FreeB->p_Next;
-    }
-
-    if ( !blockIsFree )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* init a new busy block */
-    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, base, size, name ) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* calls Update routine to update a lists of free blocks */
-    if ( MM_CutFree ( p_MM, base, base+size ) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* insert the new busy block into the list of busy blocks */
-    MM_AddBusy ( p_MM, p_NewBusyB );
-    return (base);
-}
-
-
-/*****************************************************************************/
-uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, int alignment, uint64_t min, char* name)
-{
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_FreeBlock *p_FreeB;
-    t_BusyBlock *p_NewBusyB;
-    uint64_t    holdBase, holdEnd;
-    int         i=0, j = alignment;
-
-    ASSERT_COND(p_MM);
-
-    /* checks if alignment is a power of two, if it correct and if the
-       required size is multiple of the given alignment. */
-    while ((j & 0x1) == 0)
-    {
-        i++;
-        j = j >> 1;
-    }
-
-    if ( (j != 1) || (i > MM_MAX_ALIGNMENT) )
-    {
-        return (uint64_t)(ILLEGAL_BASE);
-    }
-
-    p_FreeB = p_MM->freeBlocks[i];
-
-    /* look for the first block that contains the minimum
-       base address. If the whole required size may be fit
-       into it, use that block, otherwise look for the next
-       block of size greater or equal to the required size. */
-    while ( p_FreeB && (min >= p_FreeB->end))
-            p_FreeB = p_FreeB->p_Next;
-
-    /* If such block is found */
-    if ( !p_FreeB )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* if this block is large enough, use this block */
-    holdBase = ( min <= p_FreeB->base ) ? p_FreeB->base : min;
-    if ((holdBase + size) <= p_FreeB->end )
-    {
-        holdEnd = holdBase + size;
-    }
-    else
-    {
-        p_FreeB = p_FreeB->p_Next;
-        while ( p_FreeB && ((p_FreeB->end - p_FreeB->base) < size) )
-            p_FreeB = p_FreeB->p_Next;
-
-        /* If such block is found */
-        if ( !p_FreeB )
-            return (uint64_t)(ILLEGAL_BASE);
-
-        holdBase = p_FreeB->base;
-        holdEnd = holdBase + size;
-    }
-
-    /* init a new busy block */
-    if ( BusyBlock_Init((t_Handle *)&p_NewBusyB, holdBase, size, name) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* calls Update routine to update a lists of free blocks */
-    if ( MM_CutFree( p_MM, holdBase, holdEnd ) != E_OK )
-        return (uint64_t)(ILLEGAL_BASE);
-
-    /* insert the new busy block into the list of busy blocks */
-    MM_AddBusy( p_MM, p_NewBusyB );
-
-    return (holdBase);
-}
-
-
-/*****************************************************************************/
-uint64_t MM_Put(t_Handle h_MM, uint64_t base)
+/****************************************************************
+ *  Routine:   InitNewBlock
+ *
+ *  Description:
+ *      Initializes a new memory block of "size" bytes and started
+ *      from "base" address.
+ *
+ *  Arguments:
+ *      memBlock- handle to the memBlock object
+ *      base    - base address of the memory block
+ *      size    - size of the memory block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for memBlock object.
+ ****************************************************************/
+static t_Error InitNewBlock(t_Handle *memBlock, uint64_t base, uint64_t size)
 {
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_BusyBlock *p_BusyB, *p_PrevBusyB;
-    uint64_t    size;
-
-    ASSERT_COND(p_MM);
+    t_MemBlock *p_MemBlock;
 
-    /* Look for a busy block that have the given base value.
-     * That block will be returned back to the memory.
-     */
-    p_PrevBusyB = 0;
-    p_BusyB = p_MM->busyBlocks;
-    while ( p_BusyB && base != p_BusyB->base )
+    p_MemBlock = (t_MemBlock *)XX_Malloc(sizeof(t_MemBlock));
+    if ( !p_MemBlock )
     {
-        p_PrevBusyB = p_BusyB;
-        p_BusyB = p_BusyB->p_Next;
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     }
 
-    if ( !p_BusyB )
-        return (0);
-
-    if ( MM_AddFree( p_MM, p_BusyB->base, p_BusyB->end ) != E_OK )
-        return (0);
-
-    /* removes a busy block form the list of busy blocks */
-    if ( p_PrevBusyB )
-        p_PrevBusyB->p_Next = p_BusyB->p_Next;
-    else
-        p_MM->busyBlocks = p_BusyB->p_Next;
-
-    size = p_BusyB->end - p_BusyB->base;
-
-    XX_Free(p_BusyB);
-
-    return (size);
-}
-
-
-/*****************************************************************************/
-uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
-{
-    t_MM        *p_MM = (t_MM *)h_MM;
-    uint64_t    end = base + size;
-
-    ASSERT_COND(p_MM);
-
-    if ( MM_CutBusy( p_MM, base, end ) != E_OK )
-        return (0);
+    p_MemBlock->base = base;
+    p_MemBlock->end = base+size;
+    p_MemBlock->p_Next = 0;
 
-    if ( MM_AddFree ( p_MM, base, end ) != E_OK )
-        return (0);
+    *memBlock = p_MemBlock;
 
-    return (size);
+    return (E_OK);
 }
 
-
-/*****************************************************************************/
-t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
+/****************************************************************
+ *  Routine:   InitFreeBlock
+ *
+ *  Description:
+ *      Initializes a new free block of of "size" bytes and
+ *      started from "base" address.
+ *
+ *  Arguments:
+ *      freeBlock - handle to the freeBlock object
+ *      base      - base address of the free block
+ *      size      - size of the free block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for a free block.
+ ****************************************************************/
+static t_Error InitFreeBlock(t_Handle *freeBlock, uint64_t base, uint64_t size)
 {
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_MemBlock  *p_MemB, *p_NewMemB;
-    t_Error     errCode;
-
-    ASSERT_COND(p_MM);
-
-    /* find a last block in the list of memory blocks to insert a new
-     * memory block
-     */
-    p_MemB = p_MM->memBlocks;
-    while ( p_MemB->p_Next )
-    {
-        if ( base >= p_MemB->base && base < p_MemB->end )
-        {
-            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
-        }
-        p_MemB = p_MemB->p_Next;
-    }
-    /* check for a last memory block */
-    if ( base >= p_MemB->base && base < p_MemB->end )
-    {
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
-    }
+    t_FreeBlock *p_FreeBlock;
 
-    /* create a new memory block */
-    if ( MemBlock_Init( (t_Handle *)&p_NewMemB, base, size ) != E_OK )
+    p_FreeBlock = (t_FreeBlock *)XX_Malloc(sizeof(t_FreeBlock));
+    if ( !p_FreeBlock )
     {
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     }
 
-    /* append a new memory block to the end of the list of memory blocks */
-    p_MemB->p_Next = p_NewMemB;
+    p_FreeBlock->base = base;
+    p_FreeBlock->end = base + size;
+    p_FreeBlock->p_Next = 0;
 
-    /* add a new free block to the free lists */
-    errCode = MM_AddFree(p_MM, base, base+size);
-    if (errCode)
-    {
-        p_MemB->p_Next = 0;
-        XX_Free(p_NewMemB);
-        return ((t_Error)errCode);
-    }
+    *freeBlock = p_FreeBlock;
 
     return (E_OK);
 }
 
-
-/*****************************************************************************/
-void        MM_Dump(t_Handle h_MM, void *buff)
-{
-    t_MM        *p_MM = (t_MM *)h_MM;
-    t_FreeBlock *p_FreeB;
-    t_BusyBlock *p_BusyB;
-    int          i;
-
-    p_BusyB = p_MM->busyBlocks;
-    Sprint(buff, "List of busy blocks:\n");
-    while (p_BusyB)
-    {
-        Sprint(buff, "\t0x%lx: (%s: b=0x%lx, e=0x%lx)\n",
-                (uint32_t)p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
-        p_BusyB = p_BusyB->p_Next;
-    }
-
-    Sprint(buff, "\nLists of free blocks according to alignment:\n");
-    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
-    {
-        Sprint(buff, "%d alignment:\n", (0x1 << i));
-        p_FreeB = p_MM->freeBlocks[i];
-        while (p_FreeB)
-        {
-            Sprint(buff, "\t0x%lx: (b=0x%lx, e=0x%lx)\n",
-                     (uint32_t)p_FreeB, p_FreeB->base, p_FreeB->end );
-            p_FreeB = p_FreeB->p_Next;
-        }
-        Sprint(buff, "\n");
-    }
-}
-
-
-/**********************************************************************
- *                     MM internal routines set                       *
- **********************************************************************/
-
 /****************************************************************
- *  Routine:    MM_AddFree
+ *  Routine:    AddFree
  *
  *  Description:
  *      Adds a new free block to the free lists. It updates each
@@ -443,7 +176,7 @@ void        MM_Dump(t_Handle h_MM, void *buff)
  *
  *
  ****************************************************************/
-static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
+static t_Error AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
 {
     t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
     uint32_t    alignment;
@@ -492,7 +225,7 @@ static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
                 }
                 else if ( (end < p_CurrB->base) && ((end-alignBase) >= alignment) )
                 {
-                    if ( FreeBlock_Init((t_Handle *)&p_NewB,
+                    if ( InitFreeBlock((t_Handle *)&p_NewB,
                                         alignBase,
                                         end-alignBase) != E_OK )
                     {
@@ -535,7 +268,7 @@ static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
          */
         if ( !p_CurrB && ((((uint64_t)(end-base)) & ((uint64_t)(alignment-1))) == 0) )
         {
-            if ( FreeBlock_Init((t_Handle *)&p_NewB, alignBase, end-base) != E_OK )
+            if ( InitFreeBlock((t_Handle *)&p_NewB, alignBase, end-base) != E_OK )
             {
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
             }
@@ -558,9 +291,8 @@ static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
     return (E_OK);
 }
 
-
 /****************************************************************
- *  Routine:      MM_CutFree
+ *  Routine:      CutFree
  *
  *  Description:
  *      Cuts a free block from holdBase to holdEnd from the free lists.
@@ -579,7 +311,7 @@ static t_Error MM_AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
  *      otherwise returns an error code.
  *
  ****************************************************************/
-static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
+static t_Error CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
 {
     t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
     uint64_t    alignBase, base, end;
@@ -608,7 +340,7 @@ static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
                         p_PrevB->p_Next = p_CurrB->p_Next;
                     else
                         p_MM->freeBlocks[i] = p_CurrB->p_Next;
-                    XX_Free( p_CurrB );
+                    XX_Free(p_CurrB);
                 }
                 else
                 {
@@ -622,7 +354,7 @@ static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
                 {
                     if ( (alignBase < end) && ((end-alignBase) >= alignment) )
                     {
-                        if ( FreeBlock_Init( (t_Handle *)&p_NewB,
+                        if ( InitFreeBlock( (t_Handle *)&p_NewB,
                                              alignBase,
                                              (end-alignBase)) != E_OK )
                         {
@@ -658,9 +390,8 @@ static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
     return (E_OK);
 }
 
-
 /****************************************************************
- *  Routine:     MM_AddBusy
+ *  Routine:     AddBusy
  *
  *  Description:
  *      Adds a new busy block to the list of busy blocks. Note,
@@ -675,7 +406,7 @@ static t_Error MM_CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
  *      None.
  *
  ****************************************************************/
-static void MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
+static void AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
 {
     t_BusyBlock *p_CurrBusyB, *p_PrevBusyB;
 
@@ -698,9 +429,8 @@ static void MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
         p_MM->busyBlocks = p_NewBusyB;
 }
 
-
 /****************************************************************
- *  Routine:    MM_CutBusy
+ *  Routine:    CutBusy
  *
  *  Description:
  *      Cuts a block from base to end from the list of busy blocks.
@@ -722,7 +452,7 @@ static void MM_AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
  *      E_OK on success, E_NOMEMORY otherwise.
  *
  ****************************************************************/
-static t_Error MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
+static t_Error CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
 {
     t_BusyBlock  *p_CurrB, *p_PrevB, *p_NewB;
 
@@ -769,7 +499,7 @@ static t_Error MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
             {
                 if ( end < p_CurrB->end && end > p_CurrB->base )
                 {
-                    if ( BusyBlock_Init((t_Handle *)&p_NewB,
+                    if ( InitBusyBlock((t_Handle *)&p_NewB,
                                         end,
                                         p_CurrB->end-end,
                                         p_CurrB->name ) != E_OK )
@@ -793,124 +523,8 @@ static t_Error MM_CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
     return (E_OK);
 }
 
-
 /****************************************************************
- *  Routine:   MemBlock_Init
- *
- *  Description:
- *      Initializes a new memory block of "size" bytes and started
- *      from "base" address.
- *
- *  Arguments:
- *      memBlock- handle to the memBlock object
- *      base    - base address of the memory block
- *      size    - size of the memory block
- *
- *  Return value:
- *      E_OK is returned on success. E_NOMEMORY is returned
- *      if can't allocate memory for memBlock object.
- ****************************************************************/
-static t_Error MemBlock_Init(t_Handle *memBlock, uint64_t base, uint64_t size)
-{
-    t_MemBlock *p_MemBlock;
-
-    p_MemBlock = (t_MemBlock *)XX_Malloc(sizeof(t_MemBlock));
-    if ( !p_MemBlock )
-    {
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    }
-
-    p_MemBlock->base = base;
-    p_MemBlock->end = base+size;
-    p_MemBlock->p_Next = 0;
-
-    *memBlock = p_MemBlock;
-
-    return (E_OK);
-}
-
-
-/****************************************************************
- *  Routine:   FreeBlock_Init
- *
- *  Description:
- *      Initializes a new free block of of "size" bytes and
- *      started from "base" address.
- *
- *  Arguments:
- *      freeBlock - handle to the freeBlock object
- *      base      - base address of the free block
- *      size      - size of the free block
- *
- *  Return value:
- *      E_OK is returned on success. E_NOMEMORY is returned
- *      if can't allocate memory for a free block.
- ****************************************************************/
-static t_Error FreeBlock_Init(t_Handle *freeBlock, uint64_t base, uint64_t size)
-{
-    t_FreeBlock *p_FreeBlock;
-
-    p_FreeBlock = (t_FreeBlock *)XX_Malloc(sizeof(t_FreeBlock));
-    if ( !p_FreeBlock )
-    {
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    }
-
-    p_FreeBlock->base = base;
-    p_FreeBlock->end = base + size;
-    p_FreeBlock->p_Next = 0;
-
-    *freeBlock = p_FreeBlock;
-
-    return (E_OK);
-}
-
-
-/****************************************************************
- *  Routine:   BusyBlock_Init
- *
- *  Description:
- *      Initializes a new busy block of "size" bytes and started
- *      rom "base" address. Each busy block has a name that
- *      specified the purpose of the memory allocation.
- *
- *  Arguments:
- *      busyBlock - handle to the busyBlock object
- *      base      - base address of the busy block
- *      size      - size of the busy block
- *      name      - name that specified the busy block
- *
- *  Return value:
- *      E_OK is returned on success. E_NOMEMORY is returned
- *      if can't allocate memory for busy block.
- ****************************************************************/
-static t_Error BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name)
-{
-    t_BusyBlock *p_BusyBlock;
-    int         n, nameLen;
-
-    p_BusyBlock = (t_BusyBlock *)XX_Malloc(sizeof(t_BusyBlock));
-    if ( !p_BusyBlock )
-    {
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    }
-
-    p_BusyBlock->base = base;
-    p_BusyBlock->end = base + size;
-    nameLen = (int)strlen(name);
-    n = (nameLen > MM_MAX_NAME_LEN - 1) ? MM_MAX_NAME_LEN-1 : nameLen;
-    strncpy(p_BusyBlock->name, name, (uint32_t)n);
-    p_BusyBlock->name[n] = '\0';
-    p_BusyBlock->p_Next = 0;
-
-    *busyBlock = p_BusyBlock;
-
-    return (E_OK);
-}
-
-
-/****************************************************************
- *  Routine:     MM_GetGreaterAlignment
+ *  Routine:     MmGetGreaterAlignment
  *
  *  Description:
  *      Allocates a block of memory according to the given size
@@ -920,7 +534,7 @@ static t_Error BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size,
  *      and checks if it has the required size of bytes of the required
  *      alignment. If no blocks found returns ILLEGAL_BASE.
  *      After the block is found and data is allocated, it calls
- *      the internal MM_CutFree routine to update all free lists
+ *      the internal CutFree routine to update all free lists
  *      do not include a just allocated block. Of course, each
  *      free list contains a free blocks with the same alignment.
  *      It is also creates a busy block that holds
@@ -938,7 +552,7 @@ static t_Error BusyBlock_Init(t_Handle *busyBlock, uint64_t base, uint64_t size,
  *      ILLEGAL_BASE if can't allocate a block
  *
  ****************************************************************/
-static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name)
+static uint64_t MmGetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment, char* name)
 {
     t_FreeBlock *p_FreeB;
     t_BusyBlock *p_NewBusyB;
@@ -971,20 +585,76 @@ static uint64_t MM_GetGreaterAlignment(t_MM *p_MM, uint64_t size, int alignment,
     holdEnd = alignBase + size;
 
     /* init a new busy block */
-    if ( BusyBlock_Init ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
         return (uint64_t)(ILLEGAL_BASE);
 
     /* calls Update routine to update a lists of free blocks */
-    if ( MM_CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+    if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
         return (uint64_t)(ILLEGAL_BASE);
 
     /* insert the new busy block into the list of busy blocks */
-    MM_AddBusy ( p_MM, p_NewBusyB );
+    AddBusy ( p_MM, p_NewBusyB );
 
     return (holdBase);
 }
 
 
+/**********************************************************************
+ *                     MM API routines set                            *
+ **********************************************************************/
+
+/*****************************************************************************/
+t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM;
+    uint64_t    newBase, newSize;
+    int         i;
+
+    if (!size)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size (should be positive)"));
+    }
+
+    /* Initializes a new MM object */
+    p_MM = (t_MM *)XX_Malloc(sizeof(t_MM));
+    if (!p_MM)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_MM->h_Spinlock = XX_InitSpinlock();
+    if (!p_MM->h_Spinlock)
+    {
+        XX_Free(p_MM);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MM spinlock!"));
+    }
+
+    /* initializes a new memory block */
+    if ( InitNewBlock((t_Handle *)&p_MM->memBlocks, base, size) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
+    /*Initializes a new free block for each free list*/
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        newBase = MAKE_ALIGNED( base, (0x1 << i) );
+        newSize = size - (newBase - base);
+
+        if ( InitFreeBlock((t_Handle *)&p_MM->freeBlocks[i], newBase, newSize ) != E_OK)
+        {
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
+    }
+
+    *h_MM = p_MM;
+
+    return (E_OK);
+}
+
 /*****************************************************************************/
 void MM_Free(t_Handle h_MM)
 {
@@ -1027,10 +697,358 @@ void MM_Free(t_Handle h_MM)
         XX_Free(p_Block);
     }
 
+    if (p_MM->h_Spinlock)
+        XX_FreeSpinlock(p_MM->h_Spinlock);
+
     /* release memory allocated for MM object itself */
     XX_Free(p_MM);
 }
 
+/*****************************************************************************/
+uint64_t MM_Get(t_Handle h_MM, uint64_t size, int alignment, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    uint32_t    intFlags;
+    int         i = 0, j;
+
+    SANITY_CHECK_RETURN_VALUE(p_MM, E_INVALID_HANDLE, (uint64_t)ILLEGAL_BASE);
+
+    /* checks that alignment value is greater then zero */
+    if (alignment == 0)
+    {
+        alignment = 1;
+    }
+
+    j = alignment;
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    /* if the given alignment isn't power of two, returns an error */
+    if (j != 1)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("alignment (should be power of 2)"));
+        return (uint64_t)ILLEGAL_BASE;
+    }
+
+    if (i > MM_MAX_ALIGNMENT)
+    {
+        return (MmGetGreaterAlignment(p_MM, size, alignment, name));
+    }
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    /* look for a block of the size greater or equal to the required size. */
+    p_FreeB = p_MM->freeBlocks[i];
+    while ( p_FreeB && (p_FreeB->end - p_FreeB->base) < size )
+        p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    holdBase = p_FreeB->base;
+    holdEnd = holdBase + size;
+
+    /* init a new busy block */
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy ( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (holdBase);
+}
+
+/*****************************************************************************/
+uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint32_t    intFlags;
+    bool        blockIsFree = FALSE;
+
+    ASSERT_COND(p_MM);
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_FreeB = p_MM->freeBlocks[0]; /* The biggest free blocks are in the
+                                      free list with alignment 1 */
+
+    while ( p_FreeB )
+    {
+        if ( base >= p_FreeB->base && (base+size) <= p_FreeB->end )
+        {
+            blockIsFree = TRUE;
+            break;
+        }
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    if ( !blockIsFree )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* init a new busy block */
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, base, size, name ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree ( p_MM, base, base+size ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy ( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (base);
+}
+
+/*****************************************************************************/
+uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, int alignment, uint64_t min, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd;
+    uint32_t    intFlags;
+    int         i=0, j = alignment;
+
+    ASSERT_COND(p_MM);
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    if ( (j != 1) || (i > MM_MAX_ALIGNMENT) )
+    {
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_FreeB = p_MM->freeBlocks[i];
+
+    /* look for the first block that contains the minimum
+       base address. If the whole required size may be fit
+       into it, use that block, otherwise look for the next
+       block of size greater or equal to the required size. */
+    while ( p_FreeB && (min >= p_FreeB->end))
+            p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* if this block is large enough, use this block */
+    holdBase = ( min <= p_FreeB->base ) ? p_FreeB->base : min;
+    if ((holdBase + size) <= p_FreeB->end )
+    {
+        holdEnd = holdBase + size;
+    }
+    else
+    {
+        p_FreeB = p_FreeB->p_Next;
+        while ( p_FreeB && ((p_FreeB->end - p_FreeB->base) < size) )
+            p_FreeB = p_FreeB->p_Next;
+
+        /* If such block is found */
+        if ( !p_FreeB )
+        {
+            XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+            return (uint64_t)(ILLEGAL_BASE);
+        }
+
+        holdBase = p_FreeB->base;
+        holdEnd = holdBase + size;
+    }
+
+    /* init a new busy block */
+    if ( InitBusyBlock((t_Handle *)&p_NewBusyB, holdBase, size, name) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (holdBase);
+}
+
+/*****************************************************************************/
+uint64_t MM_Put(t_Handle h_MM, uint64_t base)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_BusyBlock *p_BusyB, *p_PrevBusyB;
+    uint64_t    size;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    /* Look for a busy block that have the given base value.
+     * That block will be returned back to the memory.
+     */
+    p_PrevBusyB = 0;
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_BusyB = p_MM->busyBlocks;
+    while ( p_BusyB && base != p_BusyB->base )
+    {
+        p_PrevBusyB = p_BusyB;
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    if ( !p_BusyB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    if ( AddFree( p_MM, p_BusyB->base, p_BusyB->end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    /* removes a busy block form the list of busy blocks */
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_BusyB->p_Next;
+    else
+        p_MM->busyBlocks = p_BusyB->p_Next;
+
+    size = p_BusyB->end - p_BusyB->base;
+
+    XX_Free(p_BusyB);
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (size);
+}
+
+/*****************************************************************************/
+uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    uint64_t    end = base + size;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    if ( CutBusy( p_MM, base, end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    if ( AddFree ( p_MM, base, end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (size);
+}
+
+/*****************************************************************************/
+t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemB, *p_NewMemB;
+    t_Error     errCode;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    /* find a last block in the list of memory blocks to insert a new
+     * memory block
+     */
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_MemB = p_MM->memBlocks;
+    while ( p_MemB->p_Next )
+    {
+        if ( base >= p_MemB->base && base < p_MemB->end )
+        {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+        }
+        p_MemB = p_MemB->p_Next;
+    }
+    /* check for a last memory block */
+    if ( base >= p_MemB->base && base < p_MemB->end )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+    }
+
+    /* create a new memory block */
+    if ( InitNewBlock( (t_Handle *)&p_NewMemB, base, size ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* append a new memory block to the end of the list of memory blocks */
+    p_MemB->p_Next = p_NewMemB;
+
+    /* add a new free block to the free lists */
+    errCode = AddFree(p_MM, base, base+size);
+    if (errCode)
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        p_MemB->p_Next = 0;
+        XX_Free(p_NewMemB);
+        return ((t_Error)errCode);
+    }
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (E_OK);
+}
 
 /*****************************************************************************/
 uint64_t MM_GetMemBlock(t_Handle h_MM, int index)
@@ -1051,7 +1069,6 @@ uint64_t MM_GetMemBlock(t_Handle h_MM, int index)
         return (uint64_t)ILLEGAL_BASE;
 }
 
-
 /*****************************************************************************/
 uint64_t MM_GetBase(t_Handle h_MM)
 {
@@ -1064,7 +1081,6 @@ uint64_t MM_GetBase(t_Handle h_MM)
     return  p_MemBlock->base;
 }
 
-
 /*****************************************************************************/
 bool MM_InRange(t_Handle h_MM, uint64_t addr)
 {
@@ -1081,3 +1097,34 @@ bool MM_InRange(t_Handle h_MM, uint64_t addr)
         return FALSE;
 }
 
+/*****************************************************************************/
+void MM_Dump(t_Handle h_MM, void *buff)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_BusyB;
+    int          i;
+
+    p_BusyB = p_MM->busyBlocks;
+    Sprint(buff, "List of busy blocks:\n");
+    while (p_BusyB)
+    {
+        Sprint(buff, "\t0x%lx: (%s: b=0x%lx, e=0x%lx)\n",
+                (uint32_t)p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    Sprint(buff, "\nLists of free blocks according to alignment:\n");
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        Sprint(buff, "%d alignment:\n", (0x1 << i));
+        p_FreeB = p_MM->freeBlocks[i];
+        while (p_FreeB)
+        {
+            Sprint(buff, "\t0x%lx: (b=0x%lx, e=0x%lx)\n",
+                     (uint32_t)p_FreeB, p_FreeB->base, p_FreeB->end );
+            p_FreeB = p_FreeB->p_Next;
+        }
+        Sprint(buff, "\n");
+    }
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.h b/drivers/net/dpa/NetCommSw/etc/mm.h
index ce90b19..0bdb7e3 100644
--- a/drivers/net/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/dpa/NetCommSw/etc/mm.h
@@ -90,12 +90,12 @@ typedef struct t_BusyBlock
 /* t_MM data structure defines parameters of the MM object */
 typedef struct t_MM
 {
-    t_MemBlock*  memBlocks;     /* List of memory blocks (Memory list) */
-    t_BusyBlock* busyBlocks;    /* List of busy blocks (Busy list) */
-    t_FreeBlock* freeBlocks[MM_MAX_ALIGNMENT + 1];
-                                /* Alignment lists of free blocks (Free lists) */
+    t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
+    t_BusyBlock     *busyBlocks;    /* List of busy blocks (Busy list) */
+    t_FreeBlock     *freeBlocks[MM_MAX_ALIGNMENT + 1];
+                                    /* Alignment lists of free blocks (Free lists) */
+    t_Handle        h_Spinlock;
 } t_MM;
 
 
-#endif
-
+#endif /* __MM_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
new file mode 100644
index 0000000..d43aa6a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -0,0 +1,192 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dpaa_ext.h
+
+ @Description   DPAA Application Programming Interface.
+*//***************************************************************************/
+#ifndef __DPAA_EXT_H
+#define __DPAA_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+/**************************************************************************//**
+ @Group         DPAA_grp Data Path Acceleration Architecture API
+
+ @Description   DPAA API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   Frame descriptor
+*//***************************************************************************/
+typedef _Packed struct t_DpaaFD {
+    volatile uint32_t    id;                 /**< FD id */
+    volatile uint32_t    addrl;              /**< Data Address */
+    volatile uint32_t    length;             /**< Frame length */
+    volatile uint32_t    status;             /**< FD status */
+} _PackedType t_DpaaFD;
+
+/**************************************************************************//**
+ @Description   enum for defining frame format
+*//***************************************************************************/
+typedef enum e_DpaaFDFormatType {
+    e_DPAA_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
+                                                    small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
+                                                    (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
+                                                    and small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
+                                                    big length (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
+                                                    No LENGTH or OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_DUMMY
+} e_DpaaFDFormatType;
+
+/**************************************************************************//**
+ @Collection   Frame descriptor macros
+*//***************************************************************************/
+#define DPAA_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
+#define DPAA_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define DPAA_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
+#define DPAA_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
+#define DPAA_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
+#define DPAA_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
+#define DPAA_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
+#define DPAA_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
+#define DPAA_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
+
+#define DPAA_FD_GET_DD(fd)            ((((t_DpaaFD *)fd)->id & DPAA_FD_DD_MASK) >> (31-1))            /**< Macro to get FD DD field */
+#define DPAA_FD_GET_PID(fd)           (((((t_DpaaFD *)fd)->id & DPAA_FD_PID_MASK) >> (31-7)) | \
+                                        ((((t_DpaaFD *)fd)->id & DPAA_FD_ELIODN_MASK) >> (31-19-6)))            /**< Macro to get FD PID field */
+#define DPAA_FD_GET_BPID(fd)          ((((t_DpaaFD *)fd)->id & DPAA_FD_BPID_MASK) >> (31-15))         /**< Macro to get FD BPID field */
+#define DPAA_FD_GET_ADDRH(fd)         (((t_DpaaFD *)fd)->id & DPAA_FD_ADDRH_MASK)                     /**< Macro to get FD ADDRH field */
+#define DPAA_FD_GET_ADDRL(fd)         ((t_DpaaFD *)fd)->addrl                                       /**< Macro to get FD ADDRL field */
+#define DPAA_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)DPAA_FD_GET_ADDRH(fd) << 32) | (uint64_t)DPAA_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define DPAA_FD_GET_FORMAT(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_FORMAT_MASK) >> (31-2))    /**< Macro to get FD FORMAT field */
+#define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))   /**< Macro to get FD OFFSET field */
+#define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                /**< Macro to get FD LENGTH field */
+#define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                      /**< Macro to get FD STATUS field */
+#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))
+
+#define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | ((val << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
+/**< Macro to set FD PID field or LIODN offset*/
+#define DPAA_FD_SET_PID(fd,val)       (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~(DPAA_FD_PID_MASK|DPAA_FD_ELIODN_MASK)) | (((val << (31-7)) & DPAA_FD_PID_MASK) | (((val>>6) << (31-19)) & DPAA_FD_ELIODN_MASK))))
+#define DPAA_FD_SET_BPID(fd,val)      (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_BPID_MASK) | ((val  << (31-15)) & DPAA_FD_BPID_MASK))) /**< Macro to set FD BPID field */
+#define DPAA_FD_SET_ADDRH(fd,val)     (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_ADDRH_MASK) | (val & DPAA_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
+#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = val                                 /**< Macro to set FD ADDRL field */
+#define DPAA_FD_SET_ADDR(fd,val)                                      \
+do {                                                                \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));             \
+    DPAA_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
+    DPAA_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
+} while (0)                                                                                     /**< Macro to set FD ADDR field */
+#define DPAA_FD_SET_FORMAT(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_FORMAT_MASK) | ((val  << (31-2))& DPAA_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
+#define DPAA_FD_SET_OFFSET(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_OFFSET_MASK) | ((val << (31-11))& DPAA_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
+#define DPAA_FD_SET_LENGTH(fd,val)    (((t_DpaaFD *)fd)->length = (((t_DpaaFD *)fd)->length & ~DPAA_FD_LENGTH_MASK) | (val & DPAA_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
+#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = val                                /**< Macro to set FD STATUS field */
+
+/* @} */
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table Entry
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGTE {
+    volatile uint32_t    addrh;        /**< Buffer Address high */
+    volatile uint32_t    addrl;        /**< Buffer Address low */
+    volatile uint32_t    length;       /**< Buffer length */
+    volatile uint32_t    offset;       /**< SGTE offset */
+} _PackedType t_DpaaSGTE;
+
+#define DPAA_NUM_OF_SG_TABLE_ENTRY 16
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGT {
+    t_DpaaSGTE    tableEntry[DPAA_NUM_OF_SG_TABLE_ENTRY];
+} _PackedType t_DpaaSGT;
+
+/**************************************************************************//**
+ @Collection   Frame Scatter/Gather Table Entry macros
+*//***************************************************************************/
+#define DPAA_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
+#define DPAA_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
+#define DPAA_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
+#define DPAA_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
+#define DPAA_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
+#define DPAA_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
+#define DPAA_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
+
+#define DPAA_SGTE_GET_ADDRH(sgte)         (((t_DpaaSGTE *)sgte)->addrh & DPAA_SGTE_ADDRH_MASK)                /**< Macro to get SGTE ADDRH field */
+#define DPAA_SGTE_GET_ADDRL(sgte)         ((t_DpaaSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
+#define DPAA_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)DPAA_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)DPAA_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
+#define DPAA_SGTE_GET_EXTENSION(sgte)     ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_E_MASK) >> (31-0))       /**< Macro to get SGTE EXTENSION field */
+#define DPAA_SGTE_GET_FINAL(sgte)         ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_F_MASK) >> (31-1))       /**< Macro to get SGTE FINAL field */
+#define DPAA_SGTE_GET_LENGTH(sgte)        (((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_LENGTH_MASK)              /**< Macro to get SGTE LENGTH field */
+#define DPAA_SGTE_GET_BPID(sgte)          ((((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_BPID_MASK) >> (31-15))   /**< Macro to get SGTE BPID field */
+#define DPAA_SGTE_GET_OFFSET(sgte)        (((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_OFFSET_MASK)              /**< Macro to get SGTE OFFSET field */
+#define DPAA_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(DPAA_SGTE_GET_PHYS_ADDR(sgte))
+
+#define DPAA_SGTE_SET_ADDRH(sgte,val)     (((t_DpaaSGTE *)sgte)->addrh = ((((t_DpaaSGTE *)sgte)->addrh & ~DPAA_SGTE_ADDRH_MASK) | (val & DPAA_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
+#define DPAA_SGTE_SET_ADDRL(sgte,val)     ((t_DpaaSGTE *)sgte)->addrl = val                                 /**< Macro to set SGTE ADDRL field */
+#define DPAA_SGTE_SET_ADDR(sgte,val)                                      \
+do {                                                                    \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
+    DPAA_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));              \
+    DPAA_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);                        \
+} while (0)                                                                                     /**< Macro to set SGTE ADDR field */
+#define DPAA_SGTE_SET_EXTENSION(sgte,val) (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_E_MASK) | ((val  << (31-0))& DPAA_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
+#define DPAA_SGTE_SET_FINAL(sgte,val)     (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_F_MASK) | ((val  << (31-1))& DPAA_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
+#define DPAA_SGTE_SET_LENGTH(sgte,val)    (((t_DpaaSGTE *)sgte)->length = (((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_LENGTH_MASK) | (val & DPAA_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
+#define DPAA_SGTE_SET_BPID(sgte,val)      (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_BPID_MASK) | ((val  << (31-15))& DPAA_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
+#define DPAA_SGTE_SET_OFFSET(sgte,val)    (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_OFFSET_MASK) | ((val << (31-11))& DPAA_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
+/* @} */
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+/** @} */ /* end of DPAA_grp group */
+
+#endif /* __DPAA_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 64955bc..7f240d7 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -31,7 +31,7 @@
  */
 
 /**************************************************************************//**
- @File          FM_ext.h
+ @File          fm_ext.h
 
  @Description   FM Application Programming Interface.
 *//***************************************************************************/
@@ -40,6 +40,7 @@
 
 #include "error_ext.h"
 #include "std_ext.h"
+#include "dpaa_ext.h"
 
 
 /**************************************************************************//**
@@ -78,14 +79,14 @@
  @Description   enum for defining port types
 *//***************************************************************************/
 typedef enum e_FmPortType {
-    e_FM_PORT_TYPE_OH_OFFLINE_PARSING,  /**< Offline parsing port (id's: 0-6, share id's with
-                                             host command, so must have exclusive id) */
-    e_FM_PORT_TYPE_OH_HOST_COMMAND,     /**< Host command port (id's: 0-6, share id's with
-                                             offline parsing ports, so must have exclusive id) */
-    e_FM_PORT_TYPE_RX,                  /**< 1G Rx port (id's: 0-3) */
-    e_FM_PORT_TYPE_RX_10G,              /**< 10G Rx port (id's: 0) */
-    e_FM_PORT_TYPE_TX,                  /**< 1G Tx port (id's: 0-3) */
-    e_FM_PORT_TYPE_TX_10G,              /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port (id's: 0-6, share id's with
+                                                 host command, so must have exclusive id) */
+    e_FM_PORT_TYPE_OH_HOST_COMMAND,         /**< Host command port (id's: 0-6, share id's with
+                                                 offline parsing ports, so must have exclusive id) */
+    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port (id's: 0-3) */
+    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port (id's: 0) */
+    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port (id's: 0-3) */
+    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port (id's: 0) */
     e_FM_PORT_TYPE_DUMMY
 } e_FmPortType;
 
@@ -119,6 +120,7 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
 #define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
 #define FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
 #define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
 /* @} */
 
@@ -172,78 +174,11 @@ typedef _Packed struct t_FmPrsResult {
 #define FM_PR_L2_PPPoE            0x0800    /**< */
 
 /**************************************************************************//**
- @Description   Frame descriptor
-*//***************************************************************************/
-typedef _Packed struct t_FmFD {
-    volatile uint32_t    id;                 /**< FD id */
-    volatile uint32_t    addrl;              /**< Data Address */
-    volatile uint32_t    length;             /**< Frame length */
-    volatile uint32_t    status;             /**< FD status */
-} _PackedType t_FmFD;
-
-/**************************************************************************//**
- @Description   enum for defining frame format
-*//***************************************************************************/
-typedef enum e_FmFDFormatType {
-    e_FM_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
-                                                  small length (9b OFFSET, 20b LENGTH) */
-    e_FM_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
-                                                  (29b LENGTH ,No OFFSET) */
-    e_FM_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
-                                                  and small length (9b OFFSET, 20b LENGTH) */
-    e_FM_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
-                                                  big length (29b LENGTH ,No OFFSET) */
-    e_FM_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
-                                                  No LENGTH or OFFSET) */
-    e_FM_FD_FORMAT_TYPE_DUMMY
-} e_FmFDFormatType;
-
-/**************************************************************************//**
- @Collection   Frame descriptor macros
-*//***************************************************************************/
-#define FM_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
-#define FM_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
-#define FM_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
-#define FM_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
-#define FM_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
-#define FM_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
-#define FM_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
-#define FM_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
-#define FM_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
-
-#define FM_FD_GET_DD(fd)            ((((t_FmFD *)fd)->id & FM_FD_DD_MASK) >> (31-1))            /**< Macro to get FD DD field */
-#define FM_FD_GET_PID(fd)           (((((t_FmFD *)fd)->id & FM_FD_PID_MASK) >> (31-7)) | \
-                                        ((((t_FmFD *)fd)->id & FM_FD_LIODN_MASK) >> (31-19-6)))            /**< Macro to get FD PID field */
-#define FM_FD_GET_BPID(fd)          ((((t_FmFD *)fd)->id & FM_FD_BPID_MASK) >> (31-15))         /**< Macro to get FD BPID field */
-#define FM_FD_GET_ADDRH(fd)         (((t_FmFD *)fd)->id & FM_FD_ADDRH_MASK)                     /**< Macro to get FD ADDRH field */
-#define FM_FD_GET_ADDRL(fd)         ((t_FmFD *)fd)->addrl                                       /**< Macro to get FD ADDRL field */
-#define FM_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)FM_FD_GET_ADDRH(fd) << 32) | (uint64_t)FM_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
-#define FM_FD_GET_FORMAT(fd)        ((((t_FmFD *)fd)->length & FM_FD_FORMAT_MASK) >> (31-2))    /**< Macro to get FD FORMAT field */
-#define FM_FD_GET_OFFSET(fd)        ((((t_FmFD *)fd)->length & FM_FD_OFFSET_MASK) >> (31-11))   /**< Macro to get FD OFFSET field */
-#define FM_FD_GET_LENGTH(fd)        (((t_FmFD *)fd)->length & FM_FD_LENGTH_MASK)                /**< Macro to get FD LENGTH field */
-#define FM_FD_GET_STATUS(fd)        ((t_FmFD *)fd)->status                                      /**< Macro to get FD STATUS field */
-#define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(FM_FD_GET_PHYS_ADDR(fd))
-
-#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1)) & FM_FD_DD_MASK )))      /**< Macro to set FD DD field */
-/**< Macro to set FD PID field or LIODN offset*/
-#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~(FM_FD_PID_MASK|FM_FD_ELIODN_MASK)) | (((val << (31-7)) & FM_FD_PID_MASK) | (((val>>6) << (31-19)) & FM_FD_ELIODN_MASK))))
-#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15)) & FM_FD_BPID_MASK))) /**< Macro to set FD BPID field */
-#define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
-#define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to set FD ADDRL field */
-#define FM_FD_SET_ADDR(fd,val)                                      \
-do {                                                                \
-    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val)); \
-    FM_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
-    FM_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
-} while (0)                                                                                     /**< Macro to set FD ADDR field */
-#define FM_FD_SET_FORMAT(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_FORMAT_MASK) | ((val  << (31-2))& FM_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
-#define FM_FD_SET_OFFSET(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_OFFSET_MASK) | ((val << (31-11))& FM_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
-#define FM_FD_SET_LENGTH(fd,val)    (((t_FmFD *)fd)->length = (((t_FmFD *)fd)->length & ~FM_FD_LENGTH_MASK) | (val & FM_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
-#define FM_FD_SET_STATUS(fd,val)    ((t_FmFD *)fd)->status = val                                /**< Macro to set FD STATUS field */
-
+ @Collection   FM Frame descriptor macros
+*//***************************************************************************/
 #define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
 #define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
-#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
+#define FM_FD_CMD_UPD  0x20000000      /* Update Prepended Data */
 #define FM_FD_CMD_DTC  0x10000000      /* Do TCP Checksum */
 
 #define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
@@ -252,66 +187,61 @@ do {                                                                \
 /* @} */
 
 /**************************************************************************//**
- @Description   Frame Scatter/Gather Table Entry
-*//***************************************************************************/
-typedef _Packed struct t_FmSGTE {
-    volatile uint32_t    addrh;        /**< Buffer Address high */
-    volatile uint32_t    addrl;        /**< Buffer Address low */
-    volatile uint32_t    length;       /**< Buffer length */
-    volatile uint32_t    offset;       /**< SGTE offset */
-} _PackedType t_FmSGTE;
-
-#define FM_NUM_OF_SG_TABLE_ENTRY 16
-
-/**************************************************************************//**
- @Description   Frame Scatter/Gather Table
-*//***************************************************************************/
-typedef _Packed struct t_FmSGT {
-    t_FmSGTE    tableEntry[FM_NUM_OF_SG_TABLE_ENTRY];
-} _PackedType t_FmSGT;
+ @Description   Context A
+*//***************************************************************************/
+typedef _Packed struct t_FmContextA {
+    volatile uint32_t    command;
+    volatile uint8_t     res0[4];
+} _PackedType t_FmContextA;
+
+typedef uint32_t t_FmContextB;
+
+/**************************************************************************//**
+ @Collection   Context A macros
+*//***************************************************************************/
+#define FM_CONTEXTA_OVERRIDE_MASK       0x80000000
+#define FM_CONTEXTA_ICMD_MASK           0x40000000
+#define FM_CONTEXTA_A1_VALID_MASK       0x20000000
+#define FM_CONTEXTA_MACCMD_MASK         0x00ff0000
+#define FM_CONTEXTA_MACCMD_VALID_MASK   0x00800000
+#define FM_CONTEXTA_MACCMD_SECURED_MASK 0x00100000
+#define FM_CONTEXTA_MACCMD_SC_MASK      0x000f0000
+#define FM_CONTEXTA_A1_MASK             0x0000ffff
+
+#define FM_CONTEXTA_GET_OVVERIDE(contextA)                 ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_OVERRIDE_MASK) >> (31-0))
+#define FM_CONTEXTA_GET_ICMD(contextA)                     ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_ICMD_MASK) >> (31-1))
+#define FM_CONTEXTA_GET_A1_VALID(contextA)                 ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_A1_VALID_MASK) >> (31-2))
+#define FM_CONTEXTA_GET_A1(contextA)                       ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_A1_MASK) >> (31-31))
+#define FM_CONTEXTA_GET_MACCMD(contextA)                   ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_MASK) >> (31-15))
+#define FM_CONTEXTA_GET_MACCMD_VALID(contextA)             ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_VALID_MASK) >> (31-8))
+#define FM_CONTEXTA_GET_MACCMD_SECURED(contextA)           ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_SECURED_MASK) >> (31-11))
+#define FM_CONTEXTA_GET_MACCMD_SECURE_CHANNEL(contextA)    ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_SC_MASK) >> (31-15))
+
+#define FM_CONTEXTA_SET_OVVERIDE(contextA,val)              (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_OVERRIDE_MASK) | ((val << (31-0)) & FM_CONTEXTA_OVERRIDE_MASK) ))
+#define FM_CONTEXTA_SET_ICMD(contextA,val)                  (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_ICMD_MASK) | ((val << (31-1)) & FM_CONTEXTA_ICMD_MASK) ))
+#define FM_CONTEXTA_SET_A1_VALID(contextA,val)              (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_A1_VALID_MASK) | ((val << (31-2)) & FM_CONTEXTA_A1_VALID_MASK) ))
+#define FM_CONTEXTA_SET_A1(contextA,val)                    (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_A1_MASK) | ((val << (31-31)) & FM_CONTEXTA_A1_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD(contextA,val)                (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_MASK) | ((val << (31-15)) & FM_CONTEXTA_MACCMD_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_VALID(contextA,val)          (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_VALID_MASK) | ((val << (31-8)) & FM_CONTEXTA_MACCMD_VALID_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_SECURED(contextA,val)        (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_SECURED_MASK) | ((val << (31-11)) & FM_CONTEXTA_MACCMD_SECURED_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_SECURE_CHANNEL(contextA,val) (((t_FmContextA *)contextA)->command = ((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_SC_MASK) | ((val << (31-15)) & FM_CONTEXTA_MACCMD_SC_MASK) ))
+/* @} */
 
 /**************************************************************************//**
- @Collection   Frame Scatter/Gather Table Entry macros
+ @Collection   Context B macros
 *//***************************************************************************/
-#define FM_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
-#define FM_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
-#define FM_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
-#define FM_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
-#define FM_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
-#define FM_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
-#define FM_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
+#define FM_CONTEXTB_FQID_MASK            0x00ffffff
 
-#define FM_SGTE_GET_ADDRH(sgte)         (((t_FmSGTE *)sgte)->addrh & FM_SGTE_ADDRH_MASK)                /**< Macro to get SGTE ADDRH field */
-#define FM_SGTE_GET_ADDRL(sgte)         ((t_FmSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
-#define FM_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)FM_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)FM_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
-#define FM_SGTE_GET_EXTENSION(sgte)     ((((t_FmSGTE *)sgte)->length & FM_SGTE_E_MASK) >> (31-0))       /**< Macro to get SGTE EXTENSION field */
-#define FM_SGTE_GET_FINAL(sgte)         ((((t_FmSGTE *)sgte)->length & FM_SGTE_F_MASK) >> (31-1))       /**< Macro to get SGTE FINAL field */
-#define FM_SGTE_GET_LENGTH(sgte)        (((t_FmSGTE *)sgte)->length & FM_SGTE_LENGTH_MASK)              /**< Macro to get SGTE LENGTH field */
-#define FM_SGTE_GET_BPID(sgte)          ((((t_FmSGTE *)sgte)->offset & FM_SGTE_BPID_MASK) >> (31-15))   /**< Macro to get SGTE BPID field */
-#define FM_SGTE_GET_OFFSET(sgte)        (((t_FmSGTE *)sgte)->offset & FM_SGTE_OFFSET_MASK)              /**< Macro to get SGTE OFFSET field */
-#define FM_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(FM_SGTE_GET_PHYS_ADDR(sgte))
+#define FM_CONTEXTB_GET_FQID(contextB)                  (*((t_FmContextB *)contextB) & FM_CONTEXTB_FQID_MASK)
 
-#define FM_SGTE_SET_ADDRH(sgte,val)     (((t_FmSGTE *)sgte)->addrh = ((((t_FmSGTE *)sgte)->addrh & ~FM_SGTE_ADDRH_MASK) | (val & FM_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
-#define FM_SGTE_SET_ADDRL(sgte,val)     ((t_FmSGTE *)sgte)->addrl = val                                 /**< Macro to set SGTE ADDRL field */
-#define FM_SGTE_SET_ADDR(sgte,val)                                      \
-do {                                                                    \
-    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
-    FM_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));              \
-    FM_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);                        \
-} while (0)                                                                                     /**< Macro to set SGTE ADDR field */
-#define FM_SGTE_SET_EXTENSION(sgte,val) (((t_FmSGTE *)sgte)->length = ((((t_FmSGTE *)sgte)->length & ~FM_SGTE_E_MASK) | ((val  << (31-0))& FM_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
-#define FM_SGTE_SET_FINAL(sgte,val)     (((t_FmSGTE *)sgte)->length = ((((t_FmSGTE *)sgte)->length & ~FM_SGTE_F_MASK) | ((val  << (31-1))& FM_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
-#define FM_SGTE_SET_LENGTH(sgte,val)    (((t_FmSGTE *)sgte)->length = (((t_FmSGTE *)sgte)->length & ~FM_SGTE_LENGTH_MASK) | (val & FM_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
-#define FM_SGTE_SET_BPID(sgte,val)      (((t_FmSGTE *)sgte)->offset = ((((t_FmSGTE *)sgte)->offset & ~FM_SGTE_BPID_MASK) | ((val  << (31-15))& FM_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
-#define FM_SGTE_SET_OFFSET(sgte,val)    (((t_FmSGTE *)sgte)->offset = ((((t_FmSGTE *)sgte)->offset & ~FM_SGTE_OFFSET_MASK) | ((val << (31-11))& FM_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
+#define FM_CONTEXTB_SET_FQID(contextB,val)              (*((t_FmContextB *)contextB) = ((*((t_FmContextB *)contextB) & ~FM_CONTEXTB_FQID_MASK) | (val & FM_CONTEXTB_FQID_MASK)))
+/* @} */
 
 #define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
-/* @} */
-
 
 /**************************************************************************//**
  @Description   FM Exceptions
@@ -330,6 +260,7 @@ typedef enum e_FmExceptions {
     e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
     e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
     e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
     e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
     e_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
 } e_FmExceptions;
@@ -372,14 +303,14 @@ typedef void (t_FmExceptionsCallback) ( t_Handle              h_App,
  @Param[in]     portId      - Port id - relative to type.
  @Param[in]     addr        - Address that caused the error
  @Param[in]     tnum        - Owner of error
- @Param[in]     partition   - memory partition
+ @Param[in]     liodn       - Logical IO device number
 *//***************************************************************************/
 typedef void (t_FmBusErrorCallback) ( t_Handle        h_App,
                                       e_FmPortType    portType,
                                       uint8_t         portId,
                                       uint64_t        addr,
                                       uint8_t         tnum,
-                                      uint8_t         partition);
+                                      uint16_t        liodn);
 
 /**************************************************************************//**
  @Description   structure for defining Ucode patch for loading.
@@ -398,12 +329,16 @@ typedef struct t_FmParams {
     uint8_t                 partitionId;            /**< FM Partition Id */
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 #ifndef CONFIG_GUEST_PARTITION
-    uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual).*/
+    uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual);
+                                                         NOTE that this should include ALL common regs of the FM including
+                                                         the PCD regs area. */
     t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
                                                          to be used by the FM */
     uint16_t                fmClkFreq;              /**< In Mhz */
+#ifdef FM_PARTITION_ARRAY
     uint16_t                liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS]; /**< For each partition, LIODN should be configured here. */
-    t_FmExceptionsCallback  *f_Exception ;          /**< An application callback routine to
+#endif /* FM_PARTITION_ARRAY */
+    t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to
                                                          handle exceptions.*/
     t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to
                                                          handle exceptions.*/
@@ -462,8 +397,8 @@ t_Error FM_Free(t_Handle h_Fm);
 /**************************************************************************//**
  @Group         FM_advanced_init_grp    FM Advanced Configuration Unit
 
- @Description   Configuration functions used to change default values.
-
+ @Description   Configuration functions used to change default values;
+                Note: Advanced init routines are not available for guest partition.
  @{
 *//***************************************************************************/
 
@@ -472,13 +407,13 @@ t_Error FM_Free(t_Handle h_Fm);
 *//***************************************************************************/
 typedef enum e_FmDmaDbgCntMode {
     e_FM_DMA_DBG_NO_CNT             = 0,    /**< No counting */
-    e_FM_DMA_DBG_CNT_DONE           = 1,    /**< Count DONE commands */
-    e_FM_DMA_DBG_CNT_COMM_Q_EM      = 2,    /**< count command queue emergency signals */
-    e_FM_DMA_DBG_CNT_INT_READ_EM    = 3,    /**< Count Internal Read buffer emergency signal */
-    e_FM_DMA_DBG_CNT_INT_WRITE_EM   = 4,    /**< Count Internal Write buffer emergency signal */
-    e_FM_DMA_DBG_CNT_FPM_WAIT       = 5,    /**< Count FPM WAIT signal */
-    e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC  = 6,    /**< Single bit ECC errors. */
-    e_FM_DMA_DBG_CNT_RAW_WAR_PROT   = 7     /**< Number of times there was a need for RAW & WAR protection. */
+    e_FM_DMA_DBG_CNT_DONE,                  /**< Count DONE commands */
+    e_FM_DMA_DBG_CNT_COMM_Q_EM,             /**< count command queue emergency signals */
+    e_FM_DMA_DBG_CNT_INT_READ_EM,           /**< Count Internal Read buffer emergency signal */
+    e_FM_DMA_DBG_CNT_INT_WRITE_EM,          /**< Count Internal Write buffer emergency signal */
+    e_FM_DMA_DBG_CNT_FPM_WAIT,              /**< Count FPM WAIT signal */
+    e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC,         /**< Single bit ECC errors. */
+    e_FM_DMA_DBG_CNT_RAW_WAR_PROT           /**< Number of times there was a need for RAW & WAR protection. */
 } e_FmDmaDbgCntMode;
 
 /**************************************************************************//**
@@ -579,9 +514,9 @@ typedef struct t_FmThresholds {
                                                                  queued in the QMI enqueue dispatch queue*/
     uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
                                                                  queued in the QMI dequeue dispatch queue*/
-    uint8_t                 fmCtl1DispTh;                    /**< This is the number pf packets that may be
+    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
                                                                  queued in fmCtl1 dispatch queue*/
-    uint8_t                 fmCtl2DispTh;                    /**< This is the number pf packets that may be
+    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
                                                                  queued in fmCtl2 dispatch queue*/
 } t_FmThresholds;
 
@@ -1070,6 +1005,26 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 *//***************************************************************************/
 t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 
+/**************************************************************************//**
+ @Function      FM_ConfigTnumAgingPeriod
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration for aging of dequeue TNUM's
+                in the QMI.[DEFAULT_tnumAgingPeriod]
+                Note that this functionality is not available in all chips.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     tnumAgingPeriod     Tnum Aging Period in microseconds.
+                                    Note that period is recalculated in units of
+                                    64 FM clocks. Driver will pick the closest
+                                    possible period.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
+
 /** @} */ /* end of FM_advanced_init_grp group */
 /** @} */ /* end of FM_init_grp group */
 
@@ -1091,18 +1046,35 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 /**************************************************************************//**
  @Collection   General FM defines.
 *//***************************************************************************/
-#define FM_NUM_OF_PORT_TYPES               e_FM_PORT_TYPE_DUMMY    /**< Number of port types */
-#define FM_MAX_NUM_OF_PORTS_PER_TYPE       7                       /**< Max number of ports of the same type */
+#define FM_MAX_NUM_OF_VALID_PORTS   (FM_MAX_NUM_OF_OH_PORTS +       \
+                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
+                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)
 /* @} */
 
 /**************************************************************************//**
- @Description   Port id by type and relative id.
-                This type is a 2 dimentional array of port id's according
-                to port types.used to pass per-port parameters.
-                Note that not all places in the array are valid e.g
-                array[e_FM_PORT_TYPE_TX_10G][1] is not a valid indexes pair.
+ @Description   Structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+*//***************************************************************************/
+typedef struct t_FmPortBandwidth {
+    e_FmPortType        type;           /**< FM port type */
+    uint8_t             relativePortId; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} t_FmPortBandwidth;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
 *//***************************************************************************/
-typedef uint8_t t_PortsParam[FM_NUM_OF_PORT_TYPES][FM_MAX_NUM_OF_PORTS_PER_TYPE];
+typedef struct t_FmPortsBandwidthParams {
+    uint8_t             numOfPorts;         /**< num of ports listed in the array below */
+    t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
+                                            /**< for each port, it's bandwidth (all port's
+                                                 bandwidths must add up to 100.*/
+} t_FmPortsBandwidthParams;
 
 /**************************************************************************//**
  @Description   DMA Emergency control on MURAM
@@ -1116,19 +1088,19 @@ typedef enum e_FmDmaMuramPort {
  @Description   enum for defining FM counters
 *//***************************************************************************/
 typedef enum e_FmCounters {
-    e_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
-    e_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
-    e_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
-    e_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
-    e_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
-    e_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
-    e_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
-    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
-    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
-    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+    e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,              /**< QMI total enqueued frames counter */
+    e_FM_COUNTERS_DEQ_TOTAL_FRAME,                  /**< QMI total dequeued frames counter */
+    e_FM_COUNTERS_DEQ_0,                            /**< QMI 0 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_1,                            /**< QMI 1 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_2,                            /**< QMI 2 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_3,                            /**< QMI 3 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_FROM_DEFAULT,                 /**< QMI dequeue from default queue counter */
+    e_FM_COUNTERS_DEQ_FROM_CONTEXT,                 /**< QMI dequeue from FQ context counter */
+    e_FM_COUNTERS_DEQ_FROM_FD,                      /**< QMI dequeue from FD command field counter */
+    e_FM_COUNTERS_DEQ_CONFIRM,                      /**< QMI dequeue confirm counter */
+    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,       /**< DMA semaphor reject due to full entry counter */
+    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,       /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT              /**< DMA semaphor reject due to sync counter */
 } e_FmCounters;
 
 /**************************************************************************//**
@@ -1170,6 +1142,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
  @Function      FM_SetException
 
  @Description   Calling this routine enables/disables the specified exception.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     exception       The exception to be selected.
@@ -1185,16 +1158,17 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
  @Function      FM_SetPortsBandwidth
 
  @Description   Sets relative weights between ports when accessing common resources.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_PortsBandwidth    A table of ports bandwidth in percentage, i.e.
+ @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
                                     total must equal 100.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth);
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
 
 /**************************************************************************//**
  @Function      FM_EnableRamsEcc
@@ -1206,6 +1180,7 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth);
                 setting of ECC, this routine effects IRAM ECC only.
                 This routine is also called by the driver if an ECC exception is
                 enabled.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm            A handle to an FM Module.
 
@@ -1225,6 +1200,7 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm);
                 setting of ECC, this routine effects IRAM ECC only.
                 In opposed to FM_EnableRamsEcc, this routine must be called
                 explicitly to disable all Rams ECC.
+				Note: Not available for guest partition.
 
 
  @Param[in]     h_Fm            A handle to an FM Module.
@@ -1270,6 +1246,7 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
  @Function      FM_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
  @Param[in]     counter     The requested counter.
@@ -1285,6 +1262,7 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
  @Function      FM_Resume
 
  @Description   Release FM after halt FM command or after unrecoverable ECC error.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
 
@@ -1296,6 +1274,7 @@ void FM_Resume(t_Handle h_Fm);
  @Function      FM_SetDmaEmergency
 
  @Description   Manual emergency set
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
  @Param[in]     muramPort   MURAM direction select.
@@ -1311,6 +1290,7 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
  @Function      FM_SetDmaExtBusPri
 
  @Description   Manual emergency set
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     pri     External bus priority select
@@ -1325,6 +1305,7 @@ void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
  @Function      FM_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
+				Note: Not available for guest partition.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     exception       An exception to be forced.
@@ -1342,7 +1323,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
  @Description   Reads the DMA current status
 
  @Param[in]     h_Fm                A handle to an FM Module.
- @Param[out]     p_FmDmaStatus      A structure of DMA status parameters.
+ @Param[out]    p_FmDmaStatus      A structure of DMA status parameters.
 
  @Return        None
 
@@ -1366,6 +1347,7 @@ t_Handle FM_GetPcdHandle(t_Handle h_Fm);
 #ifndef CONFIG_GUEST_PARTITION
 /**************************************************************************//**
  @Function      FM_ErrorIsr
+				Note: Not available for guest partition.
 
  @Description   FM interrupt-service-routine for errors.
 
@@ -1377,6 +1359,7 @@ void FM_ErrorIsr(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_EventIsr
+				Note: Not available for guest partition.
 
  @Description   FM interrupt-service-routine for normal events.
 
@@ -1409,5 +1392,14 @@ t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 /** @} */ /* end of FM_grp group */
 /** @} */ /* end of DPAA_grp group */
 
+#ifdef VERIFICATION_SUPPORT
+#ifdef SC1023
+void            FM_BackdoorSet (t_Handle h_Fm, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+uint32_t        FM_BackdoorGet(t_Handle h_Fm, e_ModuleId moduleId, uint32_t offset);
+#endif /*SC1023*/
+#endif /*VERIFICATION_SUPPORT*/
+
+
+
 
 #endif /* __FM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index a8c41b8..6347246 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -455,19 +455,36 @@ t_Error FM_MAC_Enable1588TimeStamp(t_Handle h_Fm);
 t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
 
 /**************************************************************************//**
- @Function      FM_MAC_TxMacPause
+ @Function      FM_MAC_SetTxAutoPauseFrames
 
- @Description   Enable transmition of  Pause frame
+ @Description   Enable/Disable transmition of Pause-Frames.
 
  @Param[in]     h_FmMac     A handle to a FM MAC Module.
  @Param[in]     pauseTime   Pause quanta value used with transmitted pause frames.
-                            Each quanta represents a 512 bit-times.
+                            Each quanta represents a 512 bit-times; Note that '0'
+                            as an input here will be used as disabling the
+                            transmission of the pause-frames.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime);
+t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetRxIgnorePauseFrames
+
+ @Description   Enable/Disable ignoring of Pause-Frames.
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     en          boolean indicates whether to ignore the incoming pause
+                            frames or not.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en);
 
 /**************************************************************************//**
  @Function      FM_MAC_ResetCounters
@@ -671,7 +688,7 @@ t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg,
 *//***************************************************************************/
 t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
-#if (DEBUG_ERRORS > 0)
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
  @Function      FM_MAC_DumpRegs
 
@@ -684,7 +701,7 @@ t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, u
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
 t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
-#endif /* (DEBUG_ERRORS > 0) */
+#endif /* (defined(DEBUG_ERRORS) && ... */
 
 /** @} */ /* end of FM_mac_runtime_control_grp group */
 /** @} */ /* end of FM_mac_grp group */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index 1321d9d..fb24a00 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -31,7 +31,7 @@
  */
 
 /**************************************************************************//**
- @File          FM_muram_ext.h
+ @File          fm_muram_ext.h
 
  @Description   FM MURAM Application Programming Interface.
 *//***************************************************************************/
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 89d219c..6e69fe4 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -81,13 +81,16 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
 #define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
 #define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
+#define FM_PCD_MANIP                                0x08000000          /**< Manipulation indicated */
 
-#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
 
 #define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
 #define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                        /**< Maximum number of netenv distinction units */
-#define FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
+                                                                        /**< number of distinction units is limited by
+                                                                             register size (32), - reserved bits for
+                                                                             private headers. */
+
 #define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
 #define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
 #define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
@@ -106,8 +109,12 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
                                                                              the end of the SW parser area */
 #define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_OFFSET-FM_PCD_PRS_SW_TAIL_SIZE)
                                                                         /**< Max possible size of SW parser code */
+
+#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Max possible size of insertion template for
+                                                                             insert manipulation*/
 /* @} */
 
+
 /**************************************************************************//**
  @Group         FM_PCD_init_grp FM PCD Initialization Unit
 
@@ -157,9 +164,7 @@ typedef enum e_FmPcdExceptions {
     e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
     e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
     e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
-    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
-    e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
-    e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                       /**< Parser single ECC */
 } e_FmPcdExceptions;
 
 
@@ -188,12 +193,11 @@ typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
  @Description   A callback for enquing frame onto a QM queue.
 
  @Param[in]     h_App           - User's application descriptor.
- @Param[in]     fqid            - Frame queue ID on which frame should be enqueued.
  @Param[in]     p_Fd            - Frame descriptor for the frame.
 
  @Return        E_OK on success; Error code otherwise.
  *//***************************************************************************/
-typedef t_Error (t_FmPcdQmEnqueueCallback) ( t_Handle h_QmArg, uint32_t fqid, void *p_Fd);
+typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
 
 /**************************************************************************//**
  @Description   A structure for Host-Command
@@ -204,16 +208,15 @@ typedef t_Error (t_FmPcdQmEnqueueCallback) ( t_Handle h_QmArg, uint32_t fqid, vo
                 initialization routine.
  *//***************************************************************************/
 typedef struct t_FmPcdHcParams {
-#ifndef CONFIG_GUEST_PARTITION
     uint64_t                    portBaseAddr;       /**< Host-Command Port Virtual Address of
                                                          memory mapped registers.*/
     uint8_t                     portId;             /**< Host-Command Port Id (0-6 relative
                                                          to Host-Command/Offline parsing ports) */
+    uint16_t                    liodnBase;          /**< TODO */
     uint32_t                    errFqid;            /**< Host-Command Port Error Queue Id. */
     uint32_t                    confFqid;           /**< Host-Command Port Confirmation queue Id. */
-    uint8_t                     deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
-#endif /* !CONFIG_GUEST_PARTITION */
-    uint32_t                    enqFqid;            /**< Host-Command enqueue Queue Id. */
+    uint32_t                    qmChannel;          /**< Host-Command port - QM-channel dedicated to
+                                                         this portwill be used by the FM for dequeue. */
     t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Call back routine for enquing a frame to the QM */
     t_Handle                    h_QmArg;            /**< A handle of the QM module */
 } t_FmPcdHcParams;
@@ -232,23 +235,20 @@ typedef struct t_FmPcdParams {
                                                              of the FM ports */
     t_Handle                    h_Fm;                   /**< A handle to the FM module */
     t_Handle                    h_FmMuram;              /**< Relevant only if ccEnable is enabled. */
-
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
-    uint16_t                    numOfClsPlanEntries;    /**< Number of clsPlan entries dedicated to this partition,
-                                                             Must be a power of 2. */
-#else
-    bool                        useHostCommand;
-#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+    uint8_t                     numOfSchemes;           /**< Relevant for Multi partition only: Number of
+                                                             schemes dedicated to this partition. */
+    bool                        useHostCommand;         /**< Relevant and optional for single partition.
+                                                             Ignored (and assereted by driver) in Multi partition */
     t_FmPcdHcParams             hc;                     /**< Host Command parameters */
 
-#ifndef CONFIG_GUEST_PARTITION
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine to be called of PCD exception */
-    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine to be used for a single scheme and
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Relevant for master (or single core only: Callback routine
+                                                             to be called of PCD exception */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Relevant for master (or single core only: Callback routine
+                                                             to be used for a single scheme and
                                                              profile exceptions */
-    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
+    t_Handle                    h_App;                  /**< Relevant for master (or single core only: A handle to an
+                                                             application layer object; This handle will
                                                              be passed by the driver upon calling the above callbacks */
-#endif /* !CONFIG_GUEST_PARTITION */
 } t_FmPcdParams;
 
 
@@ -317,6 +317,7 @@ t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSha
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
                 By default all exceptions are enabled.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -332,6 +333,7 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
                 By default autorefresh is enabled.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     enable          TRUE to enable, FALSE to disable
@@ -346,6 +348,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
  @Description   Calling this routine changes the internal data structure for
                 the maximum parsing time from its default value
                 [DEFAULT_prsMaxParseCycleLimit].
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     value           0 to disable the mechanism, or new
@@ -465,43 +468,6 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd);
 *//***************************************************************************/
 t_Error FM_PCD_Disable(t_Handle h_FmPcd);
 
-/**************************************************************************//**
- @Function      FM_PCD_KgSetEmptyClsPlanGrp
-
- @Description   This routine may always be called, and MUST be called when
-                not all ports in the partition are actively using the classification
-                plan mechanism.
-                When called, the driver automatically saves 8 classification
-                plans for ports that do NOT use the classification plan mechanism, to
-                avoid this (in order to save those entries) this routine may
-                be ommited when all ports are using the classification
-                plan machanism.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
- *//***************************************************************************/
-t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgDeleteEmptyClsPlanGrp
-
- @Description   This routine may be called only when all ports in the
-                system are actively using the classification plan scheme.
-                In such cases, if empty clsPlan was already set,
-                it is recommended in order to save resources.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
-                Note that this routine may not be called if any of the FM ports
-                is not using the classification plan mechanism.
-*//***************************************************************************/
-t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd);
 
 /**************************************************************************//**
  @Function      FM_PCD_GetCounter
@@ -520,11 +486,11 @@ t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd);
 *//***************************************************************************/
 uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
 
-#ifndef CONFIG_GUEST_PARTITION
 /**************************************************************************//**
 @Function      FM_PCD_PrsLoadSw
 
 @Description   This routine may be called in order to load software parsing code.
+				Note: Not available for guest partition.
 
 
 @Param[in]     h_FmPcd         FM PCD module descriptor.
@@ -545,6 +511,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
                 by the keygen when parser does not recognize a required
                 field/header.
                 By default default values are 0.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     valueId         0,1 - one of 2 global default values.
@@ -561,6 +528,7 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 
  @Description   Calling this routine allows the keygen to access data past
                 the parser finidhing point.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     payloadOffset   the number of bytes beyond the parser location.
@@ -576,6 +544,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
  @Function      FM_PCD_SetException
 
  @Description   Calling this routine enables/disables PCD interrupts.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -591,6 +560,7 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
  @Function      FM_PCD_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd     FM PCD module descriptor.
  @Param[in]     counter     The requested counter.
@@ -604,6 +574,7 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
 
 /**************************************************************************//**
  @Function      FM_PCD_SetPlcrStatistics
+				Note: Not available for guest partition.
 
  @Description   This routine may be used to enable/disable policer statistics
                 counter. By default the statistics is enabled.
@@ -619,6 +590,7 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
  @Function      FM_PCD_SetPrsStatistics
 
  @Description   Defines whether to gather parser statistics including all ports.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd     FM PCD module descriptor.
  @Param[in]     enable      TRUE to enable, FALSE to disable.
@@ -628,12 +600,12 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
  @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
-#endif /* !CONFIG_GUEST_PARTITION */
 
 /**************************************************************************//**
  @Function      FM_PCD_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
+				Note: Not available for guest partition.
 
  @Param[in]     h_FmPcd     FM PCD module descriptor.
  @Param[in]     exception       An exception to be forced.
@@ -657,7 +629,7 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
  @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
                 option was selected in the initialization.
 *//***************************************************************************/
-void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd);
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
@@ -700,7 +672,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
 t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
 
 /**************************************************************************//**
- @Function      FM_PCD_PlcrDumpRegs
+ @Function      FM_PCD_PlcrProfileDumpRegs
 
  @Description   Dumps all PCD Plcr registers
 
@@ -778,12 +750,13 @@ uint32_t     FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t
                 parameters as required by keygen (when coarse classification
                 is the next engine after this scheme).
 *//***************************************************************************/
-#define FM_PCD_MAX_NUM_OF_CC_NODES      255
-#define FM_PCD_MAX_NUM_OF_CC_TREES      8
-#define FM_PCD_MAX_NUM_OF_CC_GROUPS     16
-#define FM_PCD_MAX_NUM_OF_CC_UNITS      4
-#define FM_PCD_MAX_NUM_OF_KEYS          256
-#define FM_PCD_MAX_SIZE_OF_KEY          56
+#define FM_PCD_MAX_NUM_OF_CC_NODES          255
+#define FM_PCD_MAX_NUM_OF_CC_TREES          8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS         16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS          4
+#define FM_PCD_MAX_NUM_OF_KEYS              256
+#define FM_PCD_MAX_SIZE_OF_KEY              56
+#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP 16
 /* @} */
 
 /**************************************************************************//**
@@ -827,11 +800,12 @@ typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
  @Description   All PCD engines
 *//***************************************************************************/
 typedef enum e_FmPcdEngine {
-    e_FM_PCD_DONE,      /**< No PCD Engine indicated */
-    e_FM_PCD_KG,        /**< Keygen indicated */
-    e_FM_PCD_CC,        /**< Coarse classification indicated */
-    e_FM_PCD_PLCR,      /**< Policer indicated */
-    e_FM_PCD_PRS        /**< Parser indicated */
+    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_FM_PCD_KG,            /**< Keygen indicated */
+    e_FM_PCD_CC,            /**< Coarse classification indicated */
+    e_FM_PCD_PLCR,          /**< Policer indicated */
+    e_FM_PCD_PRS            /**< Parser indicated */
 } e_FmPcdEngine;
 
 /**************************************************************************//**
@@ -848,13 +822,14 @@ typedef enum e_FmPcdExtractByHdrType {
                 (when it is not the header)
 *//***************************************************************************/
 typedef enum e_FmPcdExtractFrom {
-    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
-    e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
-    e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
-    e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE, /**< Extract from the point where parsing had finished */
-    e_FM_PCD_EXTRACT_FROM_IC_KEY,               /**< Extract from Internal Context where extracted Key by Keygen is saved*/
-    e_FM_PCD_EXTRACT_FROM_IC_HASH_EXACT_MATCH,  /**< Extract from Internal Context where Hash Value calculated by Keygen is saved. Mechanism of the exact match by CC is used.*/
-    e_FM_PCD_EXTRACT_FROM_IC_HASH_INDEXED_MATCH /**< Extract from Internal Context where Hash Value calculated by Keygen is saved. Mechanism of the indexed match by CC is used.*/
+    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
 } e_FmPcdExtractFrom;
 
 /**************************************************************************//**
@@ -982,10 +957,10 @@ typedef enum e_FmPcdPlcrRateMode {
 /**************************************************************************//**
  @Description   An enum for defining action of frame
 *//***************************************************************************/
-typedef enum e_FmPcdPlcrDoneAction {
-    e_FM_PCD_PLCR_ENQ_FRAME,            /**< Enqueue frame */
-    e_FM_PCD_PLCR_DROP_FRAME            /**< Drop frame */
-} e_FmPcdPlcrDoneAction;
+typedef enum e_FmPcdDoneAction {
+    e_FM_PCD_ENQ_FRAME = 0,        /**< Enqueue frame */
+    e_FM_PCD_DROP_FRAME            /**< Drop frame */
+} e_FmPcdDoneAction;
 
 /**************************************************************************//**
  @Description   A structure for selecting the policer counter
@@ -999,6 +974,60 @@ typedef enum e_FmPcdPlcrProfileCounters {
 } e_FmPcdPlcrProfileCounters;
 
 /**************************************************************************//**
+ @Description   A structure for selecting action
+*//***************************************************************************/
+typedef enum e_FmPcdAction {
+    e_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} e_FmPcdAction;
+
+#ifdef FM_MANIP_SUPPORT
+/**************************************************************************//**
+ @Description   An enum for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum t_FmPcdManipInsrtType {
+    e_FM_PCD_MANIP_INSRT_NONE = 0,                          /**< No insertion */
+    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR,   /**< Insert internal frame header to start of frame */
+    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE         /**< Insert template to start of frame*/
+} e_FmPcdManipInsrtType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipRmvParamsType {
+    e_FM_PCD_MANIP_RMV_NONE = 0,                                        /**< No remove */
+    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION,      /**< Remove from start of frame till (excluding) specified indication */
+    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,   /**< Remove from start of frame till (including) specified indication */
+    e_FM_PCD_MANIP_RMV_INT_FRAME_HDR                                   /**< Remove internal frame header to start of frame */
+} e_FmPcdManipRmvParamsType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of location
+*//***************************************************************************/
+typedef enum e_FmPcdManipLocateType {
+    e_FM_PCD_MANIP_LOC_BY_HDR = 0,            /**< Locate according to header */
+    e_FM_PCD_MANIP_LOC_NON_HDR                /**< Locate from data that is not the header */
+} e_FmPcdManipLocateType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of Timeout mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemTimeOutMode {
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< limits the time of the reassm process from the first frag to the last */
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< limits the time of receiving the fragment */
+} e_FmPcdManipReassemTimeOutMode;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemWaysNumber {
+    e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+    e_FM_PCD_MANIP_EIGHT_WAYS_HASH
+} e_FmPcdManipReassemWaysNumber;
+#endif /* FM_MANIP_SUPPORT */
+
+/**************************************************************************//**
  @Description   A Union of protocol dependent special options
 *//***************************************************************************/
 typedef union u_FmPcdHdrProtocolOpt {
@@ -1094,10 +1123,13 @@ typedef struct t_FmPcdExtractEntry {
         } extractByHdr;
         struct {                        /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
             e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
+            e_FmPcdAction               action;         /**< Relevant for CC Only */
+            uint16_t                    icIndxMask;     /**< Relevant only for CC where
+                                                             action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
             uint8_t                     offset;         /**< Byte offset */
             uint8_t                     size;           /**< Size in byte */
         } extractNonHdr;
-    } extractParams;
+    };
 } t_FmPcdExtractEntry;
 
 /**************************************************************************//**
@@ -1135,17 +1167,23 @@ typedef struct t_FmPcdKgKeyExtractAndHashParams {
                                                                   types not specified in this array will get undefined value. */
     uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
     t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
-    uint8_t                     hashShift;                   /**< Select the 24 bits out of the 64 hash result */
+    uint8_t                     hashShift;                   /**< hash result right shift. Select the 24 bits out of the 64 hash
+                                                                  result. 0 means using the 24 LSB's, otherwise use the
+                                                                  24 LSB's after shifting right.*/
     uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
                                                                   of queues for the key and hash functionality */
     uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                        symmetricHash;               /**< TRUE to generate the same hash for frames with swapped source and
+                                                                  destination fields on all layers; If TRUE, driver will check that for
+                                                                  all layers, if SRC extraction is selected, DST extraction must also be
+                                                                  selected, and vice versa. */
 } t_FmPcdKgKeyExtractAndHashParams;
 
 /**************************************************************************//**
  @Description   A structure of parameters for defining a single
                 Fqid mask (extracted OR).
 *//***************************************************************************/
-typedef struct t_FmPcdKgExtractedOrForFqid {
+typedef struct t_FmPcdKgExtractedOrParams {
     e_FmPcdExtractType              type;               /**< Extraction type select */
     union {
         struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
@@ -1156,13 +1194,35 @@ typedef struct t_FmPcdKgExtractedOrForFqid {
                                                         /**< continue extraction even if protocol is not recognized */
         } extractByHdr;
         e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
-    } extractParams;
+    } ;
     uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
     e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
                                                              field not found */
     uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
-    uint8_t                         bitOffsetInFqid;    /**< out of 24 bits Qid  (max offset = 16) */
-} t_FmPcdKgExtractedOrForFqid;
+    uint8_t                         bitOffsetInFqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bitOffsetInPlcrProfile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+} t_FmPcdKgExtractedOrParams;
 
 /**************************************************************************//**
  @Description   A structure for configuring scheme counter
@@ -1200,7 +1260,7 @@ typedef struct t_FmPcdKgPlcrProfile {
             uint8_t     fqidOffsetRelativeProfileIdBase;/**< OR of KG results without the qid base
                                                          This parameter should
                                                          indicate the policer profile offset within the port's
-                                                         policer profiles windowor SHARED window depends on sharedProfile */
+                                                         policer profiles window or SHARED window depends on sharedProfile */
             uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
         } indirectProfile;
     } profileSelect;
@@ -1214,45 +1274,57 @@ typedef struct t_FmPcdKgCc {
     uint8_t                 grpId;              /**< CC group id within the CC tree */
     bool                    plcrNext;           /**< TRUE if after CC, in case of data frame,
                                                      policing is required. */
-    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE */
+    bool                    bypassPlcrProfileGeneration;
+                                                /**< TRUE to bypass keygen policer profile
+                                                     generation (profile selected is the one selected at
+                                                     port initialization). */
+    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE and bypassPlcrProfileGeneration=FALSE */
 } t_FmPcdKgCc;
 
 /**************************************************************************//**
  @Description   A structure for initializing a keygen single scheme
 *//***************************************************************************/
 typedef struct t_FmPcdKgSchemeParams {
-    bool                                modify;                 /**< IN: TRUE to change an existing scheme */
+    bool                                modify;                 /**< TRUE to change an existing scheme */
     union
     {
-        uint8_t                         relativeSchemeId;       /**< IN: if modify=FALSE:Partition relative scheme id */
-        t_Handle                        h_Scheme;               /**< IN: if modify=TRUE: a handle of the existing scheme */
+        uint8_t                         relativeSchemeId;       /**< if modify=FALSE:Partition relative scheme id */
+        t_Handle                        h_Scheme;               /**< if modify=TRUE: a handle of the existing scheme */
     }id;
-    bool                                alwaysDirect;           /**< IN: This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
                                                                      it when matching   */
-    struct {                                                    /**< IN: HL Relevant only if alwaysDirect = FALSE */
-        t_Handle                        h_NetEnv;               /**< IN: A handle to the Network environment as returned
+    struct {                                                    /**< HL Relevant only if alwaysDirect = FALSE */
+        t_Handle                        h_NetEnv;               /**< A handle to the Network environment as returned
                                                                      by FM_PCD_SetNetEnvCharacteristics() */
-        uint8_t                         numOfDistinctionUnits;  /**< IN: Number of netenv units listed in unitIds array */
+        uint8_t                         numOfDistinctionUnits;  /**< Number of netenv units listed in unitIds array */
         uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];      /**< Indexes as passed to SetNetEnvCharacteristics array*/
     } netEnvParams;
-    bool                                useHash;                /**< IN: use the KG Hash functionality  */
+    bool                                useHash;                /**< use the KG Hash functionality  */
     t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
-                                                                /**< IN: used only if useHash = TRUE */
-    uint32_t                            baseFqid;               /**< IN: Base FQID */
-    uint8_t                             numOfUsedFqidMasks;     /**< IN: Number of Fqid masks listed in fqidMasks array*/
-    t_FmPcdKgExtractedOrForFqid         fqidMasks[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                                /**< used only if useHash = TRUE */
+    bool                                bypassFqidGeneration;   /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                                     In such a case FQID after KG will be the default FQID
+                                                                     defined for the relevant port, or the FQID defined by CC
+                                                                     in cases where CC was the previous engine. */
+    uint32_t                            baseFqid;               /**< Base FQID; Relevant only if bypassFqidGeneration = FALSE;
+                                                                     If hash is used and an even distribution is expected
+                                                                     according to hashDistributionNumOfFqids, baseFqid must be aligned to
+                                                                     hashDistributionNumOfFqids.  */
+    uint8_t                             numOfUsedExtractedOrs;  /**< Number of Fqid masks listed in extractedOrs array*/
+    t_FmPcdKgExtractedOrParams          extractedOrs[FM_PCD_KG_NUM_OF_GENERIC_REGS];
                                                                 /**< IN: FM_PCD_KG_NUM_OF_GENERIC_REGS
                                                                      registers are shared between qidMasks
                                                                      functionality and some of the extraction
-                                                                     actions. Normally only some will be used
+                                                                     actions; Normally only some will be used
                                                                      for qidMask. Driver will return error if
                                                                      resource is full at initialization time. */
-    e_FmPcdEngine                       nextEngine;             /**< IN: may be BMI, PLCR or CC */
-    union {                                                     /**< IN: depends on nextEngine */
-        t_FmPcdKgPlcrProfile            plcrProfile;            /**< IN: Used when next engine is PLCR */
-        t_FmPcdKgCc                     cc;                     /**< IN: Used when next engine is CC */
+    e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
+    union {                                                     /**< depends on nextEngine */
+        e_FmPcdDoneAction               doneAction;             /**< Used when next engine is BMI (done) */
+        t_FmPcdKgPlcrProfile            plcrProfile;            /**< Used when next engine is PLCR */
+        t_FmPcdKgCc                     cc;                     /**< Used when next engine is CC */
     } kgNextEngineParams;
-    t_FmPcdKgSchemeCounter              schemeCounter;          /**< IN: A strcucture of parameters for updating
+    t_FmPcdKgSchemeCounter              schemeCounter;          /**< A structure of parameters for updating
                                                                      the scheme counter */
 } t_FmPcdKgSchemeParams;
 
@@ -1261,7 +1333,7 @@ typedef struct t_FmPcdKgSchemeParams {
                 next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextCcParams {
-    t_Handle    h_CcNode;                           /**< A handle of the next CC node */
+    t_Handle    h_CcNode;               /**< A handle of the next CC node */
 } t_FmPcdCcNextCcParams;
 
 /**************************************************************************//**
@@ -1269,22 +1341,19 @@ typedef struct t_FmPcdCcNextCcParams {
                 next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextPlcrParams {
-    bool        ctrlFlow;                           /**< TRUE if this is a control flow, FALSE
-                                                         if this is data flow. */
-    bool        sharedProfile;                      /**< Relevant only if ctrlFlow=TRUE:
-                                                         TRUE if this profile is shared between ports */
-    uint16_t    relativeProfileIdForCtrlFlow;        /**< Relevant only if ctrlFlow=TRUE:
-                                                         (for data flow porfile id
-                                                         is taken from keygen).
-                                                         This parameter should
-                                                         indicate the policer profile offset within the port's
-                                                         policer profiles or from SHARED window.*/
-    bool        fqidEnqForCtrlFlow;                 /**< Relevant only if ctrlFlow=TRUE:
-                                                         TRUE if after the policer the frame should
-                                                         be enqueued rather than return to Keygen */
-    uint32_t    fqidForCtrlFlowForEnqueueAfterPlcr; /**< Relevant only if ctrlFlow=TRUE:
-                                                         if fqidEnqForCtrlFlow= TRUE, FQID for enquing
-                                                         the frame. Unused otherwize. */
+    bool        overrideParams;         /**< TRUE if CC override previously decided parameters*/
+    bool        sharedProfile;          /**< Relevant only if overrideParams=TRUE:
+                                             TRUE if this profile is shared between ports */
+    uint16_t    newRelativeProfileId;   /**< Relevant only if overrideParams=TRUE:
+                                             (otherwise profile id is taken from keygen);
+                                             This parameter should indicate the policer
+                                             profile offset within the port's
+                                             policer profiles or from SHARED window.*/
+    uint32_t    newFqid;                /**< Relevant only if overrideParams=TRUE:
+                                             FQID for enquing the frame;
+                                             In earlier chips  if policer next engine is KEYGEN,
+                                             this parameter can be 0, because the KEYGEN
+                                             always decides the enqueue FQID.*/
 } t_FmPcdCcNextPlcrParams;
 
 /**************************************************************************//**
@@ -1292,10 +1361,13 @@ typedef struct t_FmPcdCcNextPlcrParams {
                 next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextEnqueueParams {
-    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
-                                         if this is data flow */
-    uint32_t    fqidForCtrlFlow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
-                                         (for data flow FQID is taken from keygen). */
+
+    e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME*/
+    uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                             (otherwise FQID is taken from keygen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME*/
 } t_FmPcdCcNextEnqueueParams;
 
 /**************************************************************************//**
@@ -1303,9 +1375,12 @@ typedef struct t_FmPcdCcNextEnqueueParams {
                 next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextKgParams {
-    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
-                                         if this is data flow */
-    t_Handle    h_DirectScheme;     /**< Direct scheme handle to go to. */
+    bool        overrideFqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
+                                             Note - this parameters unrelevant for earlier chips*/
+    uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                             (otherwise FQID is taken from keygen),
+                                             Note - this parameters unrelevant for earlier chips*/
+    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
 } t_FmPcdCcNextKgParams;
 
 /**************************************************************************//**
@@ -1315,11 +1390,16 @@ typedef struct t_FmPcdCcNextEngineParams {
     e_FmPcdEngine                       nextEngine;    /**< User has to init parameters
                                                             according to nextEngine definition */
     union {
-            t_FmPcdCcNextCcParams       ccParams;      /**< Parameters in case next engine is CC */
-            t_FmPcdCcNextPlcrParams     plcrParams;    /**< Parameters in case next engine is PLCR */
-            t_FmPcdCcNextEnqueueParams  enqueueParams; /**< Parameters in case next engine is BMI */
-            t_FmPcdCcNextKgParams       kgParams;      /**< Parameters in case next engine is KG */
+        t_FmPcdCcNextCcParams           ccParams;      /**< Parameters in case next engine is CC */
+        t_FmPcdCcNextPlcrParams         plcrParams;    /**< Parameters in case next engine is PLCR */
+        t_FmPcdCcNextEnqueueParams      enqueueParams; /**< Parameters in case next engine is BMI */
+        t_FmPcdCcNextKgParams           kgParams;      /**< Parameters in case next engine is KG */
     } params;
+#ifdef FM_MANIP_SUPPORT
+    t_Handle                            h_Manip;       /**< Handler to headerManip.
+                                                            Relevant if next engine of the type result
+                                                            (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+#endif /* FM_MANIP_SUPPORT */
 } t_FmPcdCcNextEngineParams;
 
 /**************************************************************************//**
@@ -1329,8 +1409,10 @@ typedef struct t_FmPcdCcKeyParams {
     uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize*/
     uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
                                                  in keySize. p_Key and p_Mask (if defined) has to be
-                                                 of the same size defined in the keySize*/
-    t_FmPcdCcNextEngineParams   ccNextEngineParams; /**< parameters for the next for the defined Key in the p_Key*/
+                                                 of the same size defined in the keySize */
+    t_FmPcdCcNextEngineParams   ccNextEngineParams;
+                                            /**< parameters for the next for the defined Key in
+                                                 the p_Key */
 } t_FmPcdCcKeyParams;
 
 /**************************************************************************//**
@@ -1340,16 +1422,21 @@ typedef struct t_KeysParams {
     uint8_t                     numOfKeys;      /**< num Of relevant Keys  */
     uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
                                                      the type FULL_FIELD keySize has to be as standard size of the relevant
-                                                     key. In the another type of extraction keySize has to be as size of extraction. */
-
-    uint8_t                     *p_GlblMask;    /**< optional and can be initialized if:
-                                                     keySize <=4 or  maskForKey is not initialized */
+                                                     key. In the another type of extraction keySize has to be as size of extraction.
+                                                     In the case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP the size of keySize has to be 2*/
+
+   // uint8_t                     *p_GlblMask;    /**< optional and can be initialized if:
+  //                                                   keySize <=4 or  maskForKey is not initialized
+   //                                                  In the case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP
+   //                                                  the last nibble (4 bits ajusted to right) of the value of GlblMask
+   //                                                  has to be 0*/
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
                                                 /**< it's array with numOfKeys entries each entry in
                                                      the array of the type t_FmPcdCcKeyParams */
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
                                                 /**< parameters for the next step of
-                                                      unfound (or undefined)  key */
+                                                     unfound (or undefined)  key . Not relevant in the case
+                                                     of action = e_FM_PCD_ACTION_INDEXED_LOOKUP*/
 } t_KeysParams;
 
 /**************************************************************************//**
@@ -1358,8 +1445,7 @@ typedef struct t_KeysParams {
 typedef struct t_FmPcdCcNodeParams {
     t_FmPcdExtractEntry         extractCcParams;    /**< params which defines extraction parameters */
     t_KeysParams                keysParams;         /**< params which defines Keys parameters of the
-                                                         extraction defined in  extractParams */
-
+                                                         extraction defined in extractCcParams */
 } t_FmPcdCcNodeParams;
 
 /**************************************************************************//**
@@ -1386,7 +1472,8 @@ typedef struct t_FmPcdCcGrpParams {
     uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
                                                                 /**< Indexes of the units as defined in
                                                                      FM_PCD_SetNetEnvCharacteristics() */
-    t_FmPcdCcNextEngineParams   *p_NextEnginePerEntriesInGrp;   /**< Max size is 16 - if only one group used */
+    t_FmPcdCcNextEngineParams   nextEnginePerEntriesInGrp[FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                /**< Max size is 16 - if only one group used */
 } t_FmPcdCcGrpParams;
 
 /**************************************************************************//**
@@ -1399,23 +1486,6 @@ typedef struct t_FmPcdCcTreeParams {
     t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];   /**< Parameters for each group. */
 } t_FmPcdCcTreeParams;
 
-/**************************************************************************//**
- @Description   A structure for initializing a keygen classification plan group
-*//***************************************************************************/
-typedef struct t_FmPcdKgClsPlanGrpParams {
-    t_Handle        h_NetEnv;                       /**< A handle to the Network environment as returned
-                                                         by FM_PCD_SetNetEnvCharacteristics() */
-
-    uint8_t         numOfOptions;                   /**< Number of options, to define the size of the
-                                                         following array. */
-    protocolOpt_t   options[FM_PCD_MAX_NUM_OF_CLS_PLANS];
-                                                    /**< an option may be a basic one, such as ipv6Multicast1,
-                                                         or a combination of the basic ones such as
-                                                         (ethBroadcast | ethMulticast) or
-                                                         (ethBroadcast | ipv4Unicast2 | mplsStacked).
-                                                         No more than a total of 8 basic options may
-                                                         participate in this array. */
-} t_FmPcdKgClsPlanGrpParams;
 
 /**************************************************************************//**
  @Description   A structure for defining parameters for byte rate
@@ -1427,7 +1497,8 @@ typedef struct t_FmPcdPlcrByteRateModeParams {
 } t_FmPcdPlcrByteRateModeParams;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
+ @Description   A structure for selcting the policer profile RFC-2698 or
+                RFC-4115 parameters
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
     e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
@@ -1442,7 +1513,7 @@ typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
  @Description   A union for defining Policer next engine parameters
 *//***************************************************************************/
 typedef union u_FmPcdPlcrNextEngineParams {
-        e_FmPcdPlcrDoneAction           action;             /**< Action - when next engine is BMI (done) */
+        e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
         t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
                                                                  is PLCR, must be a SHARED profile */
         t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is Keygen */
@@ -1459,7 +1530,7 @@ typedef struct t_FmPcdPlcrProfileParams {
             t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
             uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
         } newParams;                                                /**< use it when modify=FALSE */
-        t_Handle                        h_Profile;                  /***< A handle to a profile - use it when modify=TRUE */
+        t_Handle                        h_Profile;                  /**< A handle to a profile - use it when modify=TRUE */
     } id;
     e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
     e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
@@ -1487,6 +1558,136 @@ typedef struct t_FmPcdPlcrProfileParams {
     bool                                trapProfileOnFlowC;         /**< Trap on flow C */
 } t_FmPcdPlcrProfileParams;
 
+#ifdef FM_MANIP_SUPPORT
+/**************************************************************************//**
+ @Description   A structure for selecting the location of manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipLocationParams {
+    e_FmPcdManipLocateType              type;           /**< location of manipulation type select */
+    struct {                                            /**< used when type = e_FM_PCD_MANIP_BY_HDR */
+            e_NetHeaderType             hdr;            /**< Header selection */
+            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared. */
+            bool                        byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
+            t_FmPcdFields               fullField;      /**< Relevant only when byField = TRUE: Extract field */
+   } manipByHdr;
+} t_FmPcdManipLocationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining insert manipulation
+                of the type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+*//***************************************************************************/
+typedef struct t_FmPcdManipInsrtByTemplateParams {
+    uint8_t         size;                               /**< size of insert template to the start of the frame.*/
+    uint8_t         hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE]; /**< array of the insertion template.*/
+
+    bool            modifyOuterIp;                      /**< TRUE if user want to modify some fields in outer IP.*/
+    struct {
+        uint16_t    ipOuterOffset;                      /**< offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint16_t    dscpEcn;                            /**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
+                                                             in IPV4 dscpEsn only byte - it has to be adjusted to the right*/
+        bool        udpPresent;                         /**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint8_t     udpOffset;                          /**< offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
+        uint8_t     ipIdentGenId;                       /**< Used by FMan-CTRL to calc IP-identification field,relevant if modifyOuterIp = TRUE.*/
+        bool        caamUsedAfter;                      /**< TRUE if CAAM will be used later, relevant if modifyOuterIp = TRUE.*/
+        struct {
+            uint8_t blockSizeUsedByCaam;                /**< Used by FMan-CTRL to calc the IP-total-len field, relevant if modifyOuterIp = TRUE and caamUsedAfter = TRUE.*/
+            uint8_t extraByteAddedByCaam;               /**< Used by FMan-CTRL to calc the IP-total-len field, relevant if modifyOuterIp = TRUE and caamUsedAfter = TRUE.*/
+        } caamParams;
+    } modifyOuterIpParams;
+
+    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify vpri field in the outer VLAN header*/
+    struct {
+        uint8_t     vpri;                               /**< value of vpri, relevant if modifyOuterVlan = TRUE
+                                                             vpri only 3 bits, it has to be adjusted to the right*/
+    } modifyOuterVlanParams;
+} t_FmPcdManipInsrtByTemplateParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP fragmentation
+*//***************************************************************************/
+typedef struct t_CapwapFragmentationParams {
+    uint16_t         sizeForFragmentation;              /**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
+    bool             headerOptionsCompr;                /**< TRUE - first fragment include the CAPWAP header options field,
+                                                             and all other fragments exclude the CAPWAP options field,
+                                                             FALSE - all fragments include CAPWAP header options field. */
+} t_CapwapFragmentationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP Re-assembly
+*//***************************************************************************/
+typedef struct t_CapwapReassemblyParams {
+    uint8_t                         maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
+                                                                 It has to be power of 2.
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+    bool                            haltOnDuplicationFrag;  /**< In the case of TRUE, Reassembly process halted due to duplicated fragment,
+                                                                 and all processed fragments passed for enqueue with error indication.
+                                                                 In the case of FALSE, only duplicated fragment passed for enqueue with error indication */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry needed for reassembly process */
+} t_CapwapReassemblyParams;
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation/reassembly
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragOrReasmParams {
+    bool                                frag;               /**< TRUE if using the structure for fragmentation,
+                                                                 otherwise this structure is used for reassembly */
+    uint8_t                             extBufPoolIndx;      /**< Index of the buffer pool ID which was configured for port
+                                                                 and can be used for manipulation */
+    e_NetHeaderType                     hdr;                /**< Header selection */
+    union {
+        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_CAPWAP */
+        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_CAPWAP */
+    };
+} t_FmPcdManipFragOrReasmParams;
+
+/**************************************************************************//**
+ @Description   structure for defining insert manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipInsrtParams {
+    e_FmPcdManipInsrtType                       type;       /**< Type of insert manipulation */
+    union {
+        t_FmPcdManipInsrtByTemplateParams       insrtByTemplateParams;
+                                                            /**< parameters for insert manipulation, relevant if
+                                                                 type = e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE */
+    };
+} t_FmPcdManipInsrtParams;
+
+/**************************************************************************//**
+ @Description   structure for defining remove manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipRmvParams {
+    e_FmPcdManipRmvParamsType                   type;   /**< Type of remove manipulation */
+    t_FmPcdManipLocationParams                  rmvSpecificLocationParams;
+                                                        /**< Specified location of remove manipulation */
+} t_FmPcdManipRmvParams;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipParams {
+    bool                                        rmv;                /**< TRUE, if defined remove manipulation */
+    t_FmPcdManipRmvParams                       rmvParams;          /**< Parameters for remove manipulation, relevant if rmv = TRUE */
+
+    bool                                        insrt;              /**< TRUE, if defined insert manipulation */
+    t_FmPcdManipInsrtParams                     insrtParams;        /**< Parameters for insert manipulation, relevant if insrt = TRUE */
+
+    bool                                        fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
+    t_FmPcdManipFragOrReasmParams               fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation, relevant if fragOrReasm = TRUE */
+} t_FmPcdManipParams;
+
+/**************************************************************************//**
+ @Description   structure for defining statistics
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    uint8_t     test;
+} t_FmPcdStatsParams;
+#endif /* FM_MANIP_SUPPORT */
+
 
 /**************************************************************************//**
  @Function      FM_PCD_SetNetEnvCharacteristics
@@ -1545,51 +1746,6 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams *
 t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv);
 
 /**************************************************************************//**
- @Function      FM_PCD_KgSetClsPlanGrp
-
- @Description   Define a classification plan group..
-                A classification plan group is a set of classification plan
-                entries consisting of a number of protocol options (as listed
-                in HW spec), that is a subset of a previously defined environment,
-                and that is relevant for one or more ports that will use that
-                same environment.
-                By specifying an option, the application means it would use that
-                option for distinction between frames at either a keygen scheme
-                keygen or a coarse classification action descriptor.
-                When RX ports that want to use the classification plan mechanism
-                are initialized, they will be bound to a classification plan
-                group. Usage of the classification plan is optional.
-                If not all ports use classification plan, it is user's responsibility
-                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
-                will then allocate a minimal number of entries for that use, and all
-                ports that do not use the classification plan mechanism will
-                be internally bound to that empty group.
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     p_GrpParams     A structure of classification plan parameters.
-
- @Return        A handle to the initialized object on success; NULL code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_GrpParams);
-
-/**************************************************************************//**
- @Function      FM_PCD_KgDeleteClsPlanGrp
-
- @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
-                to it - pass all LCV bits.
-
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_ClsPlanGrp    a handle to an classification-plan-group.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp);
-
-/**************************************************************************//**
  @Function      FM_PCD_KgSetScheme
 
  @Description   Initializing or modifying and enabling a scheme for the keygen.
@@ -1730,7 +1886,7 @@ t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeModifyNextEngine
 
- @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
 
  @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
@@ -1892,7 +2048,51 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter,    uint32_t value);
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+
+#ifdef FM_MANIP_SUPPORT
+/**************************************************************************//**
+ @Function      FM_PCD_ManipSetNode
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdManipParams  A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipDeleteNode
+
+ @Description   Delete an existing manip node.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_HdrManipNode  A handle to a Manip node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error  FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   TODO.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdstatsParams  A structure of parameters defining the statistics
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcdstatsParams);
+#endif /* FM_MANIP_SUPPORT */
 
 /** @} */ /* end of FM_PCD_Runtime_tree_buildgrp group */
 /** @} */ /* end of FM_PCD_Runtime_grp group */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index b3452f3..dd3528e 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -93,14 +93,16 @@ typedef enum e_FmPortPcdSupport {
     e_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
     e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
     e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR,  /**< Use Parser, Keygen and Policer */
+    e_FM_PORT_PCD_SUPPORT_CC_ONLY,              /**< Use only Coarse Classification */
+    e_FM_PORT_PCD_SUPPORT_CC_AND_KG,            /**< Use Coarse Classification,and Keygen */
+    e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR    /**< Use Coarse Classification, Keygen and Policer */
 } e_FmPortPcdSupport;
 
 /**************************************************************************//**
  @Description   Port interrupts
 *//***************************************************************************/
 typedef enum e_FmPortExceptions {
-    e_FM_PORT_EXCEPTION_PRS_ILLEGAL_ACCESS = 0,         /**< Parser port illegal access */
     e_FM_PORT_EXCEPTION_IM_BUSY                         /**< Independent-Mode Rx-BSUY */
 } e_FmPortExceptions;
 
@@ -108,10 +110,7 @@ typedef enum e_FmPortExceptions {
 /**************************************************************************//**
  @Collection    General FM Port defines
 *//***************************************************************************/
-#define BM_MAX_NUM_OF_EXT_POOLS             64          /**< Total number of external BM pools */
 #define FM_PORT_PRS_RESULT_NUM_OF_WORDS     8           /**< Number of 4 bytes words in parser result */
-#define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Number of external BM pools per Rx port */
-#define FM_PORT_NUM_OF_CONGESTION_GRPS      256         /**< Total number of congestion groups in QM */
 /* @} */
 
 
@@ -122,6 +121,7 @@ typedef enum e_FmPortExceptions {
 
  @{
 *//***************************************************************************/
+
 /**************************************************************************//**
  @Description   Exceptions user callback routine, will be called upon an
                 exception passing the exception identification.
@@ -185,11 +185,11 @@ typedef struct t_FmPortExtPoolParams {
  @Description   A structure for informing the driver about the external
                 buffer pools allocated in the BM and used by this port.
 *//***************************************************************************/
-typedef struct t_FmPortRxExtPools {
+typedef struct t_FmPortExtPools {
     uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
-    t_FmPortExtPoolParams   rxExtBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    t_FmPortExtPoolParams   extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
                                                 /**< Parameters for each port */
-} t_FmPortRxExtPools;
+} t_FmPortExtPools;
 
 /**************************************************************************//**
  @Description   structure for additional Rx port parameters
@@ -198,8 +198,8 @@ typedef struct t_FmPortRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
     uint32_t                dfltFqid;           /**< Default Queue Id.  */
     uint16_t                rxPartitionId;      /**< Port's partition id. */
-    t_FmPortRxExtPools      rxExtBufPools;      /**< Which external buffer pools are used
-                                                     (up to 8), and their sizes. */
+    t_FmPortExtPools        extBufPools;        /**< Which external buffer pools are used
+                                                     (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
 } t_FmPortRxParams;
 
 /**************************************************************************//**
@@ -210,7 +210,8 @@ typedef struct t_FmPortNonRxParams {
     uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
                                                      0 means no Tx confirmation for processed
                                                      frames. For OP - default Rx queue. */
-    uint8_t                 deqSubPortal;       /**< Subportal for dequeue. */
+    uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
+                                                     by the FM for dequeue. */
 #ifdef FM_OP_PARTITION_ERRATA_FMAN16
     uint16_t                opPartitionId;      /**< For Offline Parsing ports only. Port's partition id. */
 #endif  /* FM_OP_PARTITION_ERRATA_FMAN16 */
@@ -247,6 +248,8 @@ typedef struct t_FmPortParams {
     e_FmPortType                portType;           /**< Port type */
     uint8_t                     portId;             /**< Port Id - relative to type */
     bool                        independentModeEnable;/**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
+                                                         used together with LIODN offset. */
     u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
                                                          type. */
 
@@ -319,6 +322,7 @@ typedef enum e_FmPortDeqType {
                                          and override Intra-Class Scheduling */
 } e_FmPortDeqType;
 
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 /**************************************************************************//**
  @Description   enum for defining QM frame dequeue
 *//***************************************************************************/
@@ -331,6 +335,7 @@ typedef enum e_FmPortDeqPrefetchOption {
                                          no dedicated portId tnums are waiting. */
 
 } e_FmPortDeqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 /**************************************************************************//**
  @Description   enum for defining port DMA swap mode
@@ -347,8 +352,8 @@ typedef enum e_FmPortDmaSwap {
  @Description   enum for defining port DMA cache attributes
 *//***************************************************************************/
 typedef enum e_FmPortDmaCache {
-    e_FM_PORT_DMA_NO_STASH,         /**< Cacheable, no Allocate (No Stashing) */
-    e_FM_PORT_DMA_STASH             /**< Cacheable and Allocate (Stashing on) */
+    e_FM_PORT_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_PORT_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
 } e_FmPortDmaCache;
 
 /**************************************************************************//**
@@ -361,6 +366,7 @@ typedef enum e_FmPortColor {
     e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
 } e_FmPortColor;
 
+
 /**************************************************************************//**
  @Description   struct for defining FM port resources
 *//***************************************************************************/
@@ -370,31 +376,56 @@ typedef struct t_FmPortRsrc {
 } t_FmPortRsrc;
 
 /**************************************************************************//**
- @Description   struct for defining pool depeltion criteria
+ @Description   struct for defining pool depletion criteria
 *//***************************************************************************/
 typedef struct t_FmPortBufPoolDepletion {
     bool        numberOfPoolsModeEnable;            /**< select mode in which pause frames will be sent after
                                                          a number of pools are depleted */
     uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
                                                          invoke pause frames transmission. */
-    bool        poolsToConsider[BM_MAX_NUM_OF_EXT_POOLS];
+    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
-                                                         deplition (Note - this pool must be used by this port!) */
+                                                         depletion (Note - this pool must be used by this port!) */
     bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
                                                          a single of pools are depleted */
-    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_EXT_POOLS];
+    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
-                                                         deplition (Note - this pool must be used by this port!) */
+                                                         depletion (Note - this pool must be used by this port!) */
 } t_FmPortBufPoolDepletion;
 
 /**************************************************************************//**
+ @Description   struct for defining observed pool depletion
+*//***************************************************************************/
+typedef struct t_FmPortObservedBufPoolDepletion {
+    t_FmPortBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
+    t_FmPortExtPools            poolsParams;        /**< Which external buffer pools are observed
+                                                         (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
+                                                         and their sizes. */
+} t_FmPortObservedBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   struct for defining Dual Tx rate limiting scale
+*//***************************************************************************/
+typedef enum e_FmPortDualRateLimiterScaleDown {
+    e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} e_FmPortDualRateLimiterScaleDown;
+
+/**************************************************************************//**
  @Description   struct for defining Tx rate limiting
 *//***************************************************************************/
 typedef struct t_FmPortRateLimit {
-    uint16_t    maxBurstSize;           /**< in KBytes */
-    uint32_t    rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                             offline parsing ports. Rate limit refers to
-                                             data rate (rather than line rate). */
+    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
 } t_FmPortRateLimit;
 
 /**************************************************************************//**
@@ -413,21 +444,38 @@ typedef struct t_FmPortPerformanceCnt {
  @Description   struct for defining buffer content.
 *//***************************************************************************/
 typedef struct t_FmPortBufferPrefixContent {
-    uint16_t    privDataSize;               /**< Number of bytes to be left at the beginning
-                                                 of the external buffer */
-    bool        passPrsResult;              /**< TRUE to pass the parse result to/from the FM */
-    bool        passTimeStamp;              /**< TRUE to pass the timeStamp to/from the FM */
-    bool        passHashResult;             /**< TRUE to pass the KG hash result to/from the FM */
-    bool        passAllOtherPCDInfo;        /**< Add all other Internal-Context information:
-                                                 AD, hash-result, key, etc.  */
-    uint16_t    dataAlign;                  /**< 0 to use driver's default alignment, other value
-                                                 for selecting a data alignment (must be a
-                                                 power of 2) */
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    bool        passDebugInfo;                  /**< Debug */
-#endif /* (defined(DEBUG_ERRORS) && ... */
+    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer */
+    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM */
+    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM */
+    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM */
+    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
+                                         for selecting a data alignment (must be a
+                                         power of 2) */
+#ifdef DEBUG
+    bool        passDebugInfo;      /**< Debug-information */
+#endif /* DEBUG*/
+#ifdef FM_MANIP_SUPPORT
+    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size) */
+#endif /* FM_MANIP_SUPPORT */
 } t_FmPortBufferPrefixContent;
 
+/**************************************************************************//**
+ @Description   struct for defining backup Bm Pools.
+*//***************************************************************************/
+typedef struct t_FmPortBackupBmPools {
+    uint8_t     numOfBackupPools;        /**< Number of BM backup pools -
+                                             must be smaller than the total number of
+                                             pools defined for the specified port.*/
+    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< numOfBackupPools pool id's, specifying which
+                                             pools should be used only as backup. Pool
+                                             id's specified here must be a subset of the
+                                             pools used by the specified port.*/
+} t_FmPortBackupBmPools;
+
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigNumOfOpenDmas
@@ -518,13 +566,14 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
 
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDeqPrefetchOption
 
  @Description   Calling this routine changes the dequeue prefetch option parameter in the
                 internal driver data base from its default configuration
                 [DEFAULT_PORT_deqPrefetchOption]
-
+                Note: Available for some chips only
 
                 May be used for Non-Rx ports only
 
@@ -536,6 +585,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
 t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDeqByteCnt
@@ -753,25 +803,69 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
 t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion);
 
 /**************************************************************************//**
- @Function      FM_PORT_ConfigRateLimit
+ @Function      FM_PORT_ConfigObservedPoolDepletion
 
- @Description   Calling this routine enables rate limit algorithm.
-                By default, this functionality is disabled.
-                Note that rate-limit mechanism uses the FM time stamp.
-                The selected rate limit specified here would be
-                rounded to the nearest power of 2 multiplication
-                (i.e. up to twice the required rate).
+ @Description   Calling this routine enables a mechanism to stop port enqueue
+                depending on the depletion status of selected BM pools.
+                It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
 
-                May be used for Tx and offline parsing ports only
+                Note: Available for some chips only
+
+                May be used for Offline Parsing ports only
+
+ @Param[in]     h_FmPort                            A handle to a FM Port module.
+ @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
 
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     p_RateLimit     A structure of rate limit parameters
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigExtBufPools
+
+ @Description   This routine should be called for offline parsing ports
+                that internally use BM buffer pools. In such cases, e.g. for fragmentation and
+                re-assembly, the FM needs new BM buffers. By calling this routine the user
+                specifies the BM buffer pools that should be used.
+
+                Note: Available for some chips only
+
+                May be used for Offline Parsing ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPortExtPools    A structure of parameters for the external pools.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools);
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+                defined for this port as backup pools.
+                A pool configured to be a backup pool will be used only if all other
+                enabled non-backup pools are depleted.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortBackupBmPools   An array of pool id's. All pools specified here will
+                                        be defined as backup pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_FmPortBackupBmPools);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigFrmDiscardOverride
@@ -842,7 +936,7 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
 
                 May be used for all port types
 
- @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     h_FmPort               A handle to a FM Port module.
  @Param[in]     intContextCacheAttr    New selection
 
  @Return        E_OK on success; Error code otherwise.
@@ -962,6 +1056,27 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
 
 /**************************************************************************//**
+ @Function      FM_PORT_ConfigDontReleaseTxBufToBM
+
+ @Description   This routine should be called if no Tx confirmation
+                is done, and yet buffers should not be released to the BM.
+                Normally, buffers are returned using the Tx confirmation
+                process. When Tx confirmation is not used (defFqid=0),
+                buffers are typically released to the BM. This routine
+                may be called to avoid this behavior and not release the
+                buffers.
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort);
+
+/**************************************************************************//**
  @Function      FM_PORT_ConfigRxL4ChecksumVerify
 
  @Description   This routine is relevant for Rx ports that are routed to transmission.
@@ -1040,6 +1155,39 @@ t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
 
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMFmanCtrlExternalStructsMemory
+
+ @Description   Configures memory partition and attributes for FMan-Controller
+                data structures (e.g. BD rings).
+                Calling this routine changes the internal driver data base 
+                from its default configuration 
+                [DEFAULT_PORT_ImfwExtStructsMemId , DEFAULT_PORT_ImfwExtStructsMemAttr].
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     memId           Memory partition ID.
+ @Param[in]     memAttributes   Memory attributes mask (a combination of MEMORY_ATTR_x flags).
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort, 
+                                                       uint8_t  memId, 
+                                                       uint32_t memAttributes);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMPolling
+
+ @Description   Changes the Rx flow from interrupt driven (default) to polling.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
+
 /** @} */ /* end of FM_PORT_advanced_init_grp group */
 /** @} */ /* end of FM_PORT_init_grp group */
 
@@ -1139,7 +1287,7 @@ uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
 *//***************************************************************************/
 uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#ifdef DEBUG
 /**************************************************************************//**
  @Function      FM_PORT_GetBufferDebugInfo
 
@@ -1154,7 +1302,7 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
 uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data);
-#endif /*(defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))*/
+#endif /* DEBUG */
 
 /**************************************************************************//**
  @Function      FM_PORT_GetBufferPrsResult
@@ -1188,13 +1336,12 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
 
  @Param[in]     h_FmPort    - FM PORT module descriptor
  @Param[in]     p_Data      - A pointer to the data buffer.
- @Param[out]    p_Ts        - A pointer to 64 bit time stamp.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        A pointer to the hash result on success, NULL otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data, uint64_t *p_Ts);
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
 
 /**************************************************************************//**
  @Function      FM_PORT_GetBufferHashResult
@@ -1244,6 +1391,27 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort);
 t_Error FM_PORT_Enable(t_Handle h_FmPort);
 
 /**************************************************************************//**
+ @Function      FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded to the nearest power of 2 multiplication
+                (i.e. up to twice the required rate).
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_RateLimit     A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
  @Function      FM_PORT_SetStatisticsCounters
 
  @Description   Calling this routine enables/disables port's statistics counters.
@@ -1405,7 +1573,7 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32
                 Each call to this routine may add one or more congestion
                 groups to be considered relevant to this port.
 
-                May be used for Rx ports only
+                May be used for Rx, or  RX+OP ports only (depending on chip)
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
@@ -1427,7 +1595,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
                 Each call to this routine may remove one or more congestion
                 groups to be considered relevant to this port.
 
-                May be used for Rx ports only
+                May be used for Rx, or RX+OP ports only (depending on chip)
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
@@ -1489,6 +1657,22 @@ t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
 t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
 
 /**************************************************************************//**
+ @Function      FM_PORT_SetIMExceptions
+
+ @Description   Calling this routine enables/disables FM PORT interrupts.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_FmPort        FM PORT module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
+
+/**************************************************************************//**
  @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
 
  @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
@@ -1536,6 +1720,11 @@ typedef union u_FmPcdHdrPrsOpts {
         uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
                                                          on VLAN TAG on top of 0x8100 and 0x88A8 */
     } vlanPrsOptions;
+    /* PPP */
+    struct{
+        bool            enableMTUCheck;             /**< Check validity of MTU according to RFC2516 */
+    } pppoePrsOptions;
+
     /* IPV6 */
     struct{
         bool            routingHdrDisable;          /**< Disable routing header */
@@ -1584,9 +1773,8 @@ typedef struct t_FmPortPcdPrsParams {
                                                                          start parsing */
     e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header axpected at
                                                                          'parsingOffset' */
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics.*/
-#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
+                                                                         NOTE: this field is not valid when the FN is in "guest" mode. */
     uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
                                                                          special parameters */
     t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
@@ -1618,9 +1806,6 @@ typedef struct t_FmPortPcdKgParams {
     t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
                                                         /**< Array of 'numOfSchemes' schemes handles for the
                                                              port to be bound to */
-    bool                useClsPlan;                     /**< TRUE to use the classification plan mechanism */
-    t_Handle            h_ClsPlanGrp;                   /**< clssification-Plan must be of the same h_NetEnv
-                                                             of this port */
     bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
                                                              regardless of parser result */
     t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
@@ -1631,9 +1816,13 @@ typedef struct t_FmPortPcdKgParams {
  @Description   struct for defining policer parameters
 *//***************************************************************************/
 typedef struct t_FmPortPcdPlcrParams {
-    t_Handle                h_Profile;          /**< Selected profile handle. relevant only if
+    t_Handle                h_Profile;          /**< Selected profile handle; Relevant for one of
+                                                     following cases:
                                                      e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
-                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected */
+                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                     or if any flow uses a KG scheme were policer
+                                                     profile is not generated
+                                                     (bypassPlcrProfileGeneration selected) */
 } t_FmPortPcdPlcrParams;
 
 /**************************************************************************//**
@@ -1730,7 +1919,7 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init().
+ @Cautions      Allowed only following FM_PORT_AttachPCD().
 *//***************************************************************************/
 t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
 
@@ -1817,27 +2006,6 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
 
 /**************************************************************************//**
- @Function      FM_PORT_PcdKgModifyClsPlanGrp
-
- @Description   This routine may be called for ports using the KG functionality of the PCD,
-                if the user wishes to replace the classification plan
-                group that the port uses, to start using the classification plan mechanism or to stop
-                using it. The routine may not be called while port
-                receives packets using the PCD functionalities, therefore port must be first detached
-                from the PCD, only than the routine may be called, and than port be attached to PCD again.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     useClsPlan          TRUE to use a pre-defined group, FALSE to stop using one.
- @Param[in]     h_NewClsPlanGrp     A handle of a classification plan group that was already set.
-                                    The handle as returned from the SetClsPlanGrp routine.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
-*//***************************************************************************/
-t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
-
-/**************************************************************************//**
  @Function      FM_PORT_PcdKgBindSchemes
 
  @Description   These routines may be called for adding more schemes for the
@@ -1961,5 +2129,10 @@ t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
 /** @} */ /* end of FM_PORT_grp group */
 /** @} */ /* end of FM_grp group */
 
-
+#ifdef VERIFICATION_SUPPORT
+#ifdef SC1023
+void            FM_PORT_BackdoorSet (t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+uint32_t        FM_PORT_BackdoorGet(t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset);
+#endif /*SC1023*/
+#endif /*VERIFICATION_SUPPORT*/
 #endif /* __FM_PORT_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/core_ext.h b/drivers/net/dpa/NetCommSw/inc/core_ext.h
index ea073b1..3114ed1 100644
--- a/drivers/net/dpa/NetCommSw/inc/core_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/core_ext.h
@@ -31,9 +31,13 @@
  */
 
 /**************************************************************************//**
- @File          core_std_ext.h
+ @File          core_ext.h
 
- @Description   TODO
+ @Description   Generic interface to basic core operations.
+ 
+                The system integrator must ensure that this interface is 
+                mapped to a specific core implementation, by including the 
+                appropriate header file.
 *//***************************************************************************/
 #ifndef __CORE_EXT_H
 #define __CORE_EXT_H
@@ -51,6 +55,15 @@
 
 
 /**************************************************************************//**
+ @Function      CORE_GetId
+
+ @Description   Returns the core ID in the system.
+
+ @Return        Core ID.
+*//***************************************************************************/
+uint32_t CORE_GetId(void);
+
+/**************************************************************************//**
  @Function      CORE_MemoryBarrier
 
  @Description   This routine will cause the core to stop executing any commands
@@ -63,3 +76,4 @@ void CORE_MemoryBarrier(void);
 
 
 #endif /* __CORE_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
index 2ca002e..4757f79 100644
--- a/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -76,6 +76,28 @@ void        L1Cache_BroadCastDisable(void);
 #define CORE_MemoryBarrier      E500_MemoryBarrier
 #define CORE_InstructionSync    E500_InstructionSync
 
+#define CORE_SetDozeMode        E500_SetDozeMode
+#define CORE_SetNapMode         E500_SetNapMode
+#define CORE_SetSleepMode       E500_SetSleepMode
+#define CORE_SetJogMode         E500_SetJogMode
+#define CORE_SetDeepSleepMode   E500_SetDeepSleepMode
+
+#define CORE_RecoverDozeMode    E500_RecoverDozeMode
+#define CORE_RecoverNapMode     E500_RecoverNapMode
+#define CORE_RecoverSleepMode   E500_RecoverSleepMode
+#define CORE_RecoverJogMode     E500_RecoverJogMode
+
+void E500_SetDozeMode(void);
+void E500_SetNapMode(void);
+void E500_SetSleepMode(void);
+void E500_SetJogMode(void);
+t_Error E500_SetDeepSleepMode(uint32_t bptrAddress);
+
+void E500_RecoverDozeMode(void);
+void E500_RecoverNapMode(void);
+void E500_RecoverSleepMode(void);
+void E500_RecoverJogMode(void);
+
 
 /**************************************************************************//**
  @Group         E500_id E500 Application Programming Interface
@@ -150,6 +172,16 @@ void E500_DCacheFlush(void);
 *//***************************************************************************/
 void E500_ICacheFlush(void);
 
+/**************************************************************************//**
+ @Function      E500_DCacheSetStashId
+
+ @Description   Set Stash Id for data cache
+
+ @Param[in]     stashId     the stash id to be set.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheSetStashId(uint8_t stashId);
 
 /**************************************************************************//**
  @Description   E500mc L2 Cache Operation Mode
@@ -196,6 +228,17 @@ void E500_L2CacheDisable(void);
 void E500_L2CacheFlush(void);
 
 /**************************************************************************//**
+ @Function      E500_L2SetStashId
+
+ @Description   Set Stash Id
+
+ @Param[in]     stashId     the stash id to be set.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_L2SetStashId(uint8_t stashId);
+
+/**************************************************************************//**
  @Function      E500_AddressBusStreamingEnable
 
  @Description   Enables address bus streaming on the CCB.
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
index 7de7164..5a32db6 100644
--- a/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -33,7 +33,10 @@
 /**************************************************************************//**
  @File          ppc_ext.h
 
- @Description   TODO
+ @Description   Core API for PowerPC cores
+ 
+                These routines must be implemented by each specific PowerPC 
+                core driver.
 *//***************************************************************************/
 #ifndef __PPC_EXT_H
 #define __PPC_EXT_H
@@ -45,15 +48,6 @@
 
 
 /**************************************************************************//**
- @Function      CORE_GetId
-
- @Description   Returns the core ID in the system.
-
- @Return        Core ID.
-*//***************************************************************************/
-uint32_t CORE_GetId(void);
-
-/**************************************************************************//**
  @Function      CORE_TestAndSet
 
  @Description   This routine tries to atomically test-and-set an integer
diff --git a/drivers/net/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
index 60ec35a..b513c86 100644
--- a/drivers/net/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
@@ -185,18 +185,19 @@
 *//***************************************************************************/
 #define DUMP_VAR(st, phrase) \
     do { \
+        void *addr = (void *)&((st)->phrase); \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpVarSize = sizeof((st)->phrase); \
         switch (dumpVarSize) \
         { \
             case 1:  DUMP_Print("0x%08X: 0x%02x%14s\t%s\r\n", \
-                                &((st)->phrase), GET_UINT8((st)->phrase), "", dumpSubStr); break; \
+                                addr, GET_UINT8((st)->phrase), "", dumpSubStr); break; \
             case 2:  DUMP_Print("0x%08X: 0x%04x%12s\t%s\r\n", \
-                                &((st)->phrase), GET_UINT16((st)->phrase), "", dumpSubStr); break; \
+                                addr, GET_UINT16((st)->phrase), "", dumpSubStr); break; \
             case 4:  DUMP_Print("0x%08X: 0x%08x%8s\t%s\r\n", \
-                                &((st)->phrase), GET_UINT32((st)->phrase), "", dumpSubStr); break; \
+                                addr, GET_UINT32((st)->phrase), "", dumpSubStr); break; \
             case 8:  DUMP_Print("0x%08X: 0x%016llx\t%s\r\n", \
-                                &((st)->phrase), GET_UINT64((st)->phrase), dumpSubStr); break; \
+                                addr, GET_UINT64((st)->phrase), dumpSubStr); break; \
             default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
         } \
     } while (0)
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
index 0a0f21d..52da42d 100644
--- a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -99,7 +99,7 @@ typedef struct
     uint32_t    blockOffset;
     uint32_t    blockSize;
 #endif /* DEBUG_MEM_LEAKS */
-
+    t_Handle    h_Spinlock;
 } t_MemorySegment;
 
 
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
index 9ace54d..176cac2 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/dpaa_integration_ext.h
@@ -42,14 +42,47 @@
 #include "std_ext.h"
 
 
+typedef enum {
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+} e_DpaaSwPortal;
+
+typedef enum {
+    e_DPAA_DCP0 = 0,
+    e_DPAA_DCP1,
+    e_DPAA_DCP2,
+    e_DPAA_DCP3
+} e_DpaaDcp;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS  10
+#define DPAA_MAX_NUM_OF_DC_PORTALS   4
+
 /*****************************************************************************
  QMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define QMAN_WQ_CS_CFG_ERRATA
-#define QMAN_SFDR_LEAK_ERRATA_5
+#define QMAN_PM_DCP_COUNTERS_ERRATA_QMAN1
+#define QMAN_FQD_AVOID_BLK_ERRATA_QMAN2
+#define QMAN_DBG_TRC_EV_ERRATA_QMAN3
+#define QMAN_WQ_CS_CFG_ERRATA_QMAN4
+#define QMAN_SFDR_LEAK_ERRATA_QMAN5
+#define QMAN_FQ_TD_THRESH_ERRATA_QMAN6
+#define QMAN_FQ_INIT_ON_PARKED_ERRATA_QMAN7
+#define QMAN_NESN_ORR_ERRATA_QMAN8
+#define QMAN_ERN_REJ_CODE6_ERRATA_QMAN9
+#define QMAN_ERN_MOULTI_CORE_ERRATA_QMAN10
 
-#define QM_MAX_NUM_OF_PORTALS   10
-#define QM_MAX_NUM_OF_WQ        8
+#define QM_MAX_NUM_OF_POOL_CHANNELS 15
+#define QM_MAX_NUM_OF_WQ            8
+#define QM_MAX_NUM_OF_SWP_AS        4
+#define QM_MAX_NUM_OF_CGR           64
 
 typedef enum {
     e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
@@ -105,21 +138,26 @@ typedef enum {
     e_QM_FQ_CHANNEL_FMAN1_SP10,
     e_QM_FQ_CHANNEL_FMAN1_SP11,
 
-    e_QM_FQ_CHANNEL_CAAM = 0x80,
+    e_QM_FQ_CHANNEL_CAAM_SP0 = 0x80,
+    e_QM_FQ_CHANNEL_CAAM_SP1,
+    e_QM_FQ_CHANNEL_CAAM_SP2,
+    e_QM_FQ_CHANNEL_CAAM_SP3,
+    e_QM_FQ_CHANNEL_CAAM_SP4,
+
     e_QM_FQ_CHANNEL_PME = 0xa0
 } e_QmFQChannel;
 
 /*****************************************************************************
  BMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS     64
-#define BM_MAX_NUM_OF_PORTALS   10
+#define BM_MAX_NUM_OF_POOLS         64
 
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
 #define INTG_MAX_NUM_OF_FM          2
 
+/* Ports defines */
 #define FM_MAX_NUM_OF_1G_RX_PORTS   4
 #define FM_MAX_NUM_OF_10G_RX_PORTS  1
 #define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
@@ -130,19 +168,45 @@ typedef enum {
 #define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
 #define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
 #define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_PCD_PORTS     (FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OH_PORTS)
-#define FM_MAX_NUM_OF_PORTS         64
 
-#define FM_MURAM_SIZE               (160*KILOBYTE)
-#define FM_IRAM_SIZE                (4*KILOBYTE)
-#define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
-#define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
-#define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            8           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               12
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+/* Rams defines */
+#define FM_MURAM_SIZE                   (160*KILOBYTE)
+#define FM_IRAM_SIZE                    (64*KILOBYTE)
 
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256             /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32              /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256             /**< Number of classification plan entries. */
+
+/* RTC defines */
 #define FM_RTC_NUM_OF_ALARMS            2
 #define FM_RTC_NUM_OF_PERIODIC_PULSES   2
 #define FM_RTC_NUM_OF_EXT_TRIGGERS      2
 
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define MAX_QMI_DEQ_SUBPORTAL           12
+#define QMI_DEF_TNUMS_THRESH            48
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            31
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             32
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+
 /**************************************************************************//**
  @Description   Enum for inter-module interrupts registration
 *//***************************************************************************/
@@ -154,6 +218,7 @@ typedef enum e_FmEventModules{
     e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
     e_FM_MOD_TMR,                   /**< Timer event */
     e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
+    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
     e_FM_MOD_DUMMY_LAST
 } e_FmEventModules;
 
@@ -188,6 +253,10 @@ typedef enum e_FmInterModuleEvent {
     e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
     e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
     e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
+    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
+    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
+    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
     e_FM_EV_DUMMY_LAST
 } e_FmInterModuleEvent;
 
@@ -229,27 +298,55 @@ typedef enum e_FmInterModuleEvent {
                  case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
                  }                                                                                  \
             break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
+            else switch(id){                                                                        \
+                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
+                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
+                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
+                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
+                 }                                                                                  \
+            break;                                                                                  \
         default:event = e_FM_EV_DUMMY_LAST;                                                         \
         break;}
 
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* p4080-rev1 unique features */
+#define FM_PARTITION_ARRAY
+#define FM_PPPOE_NO_MTU_CHECK
+
+/* p4080 unique features */
+#define FM_QMI_DEQ_OPTIONS_SUPPORT
+#define FM_NO_DISPATCH_RAM_ECC
+
 #ifndef SIMULATOR
-#define FM_10G_MAC_NO_CTRL_LOOPBACK
-#define BUP_FM_10G_TX_ECC_FRMS_ERRATA
+#define FM_10G_TX_ECC_FRMS_ERRATA_FMAN11
 #endif /* !SIMULATOR */
 
 /* FM erratas */
 #define FM_OP_PARTITION_ERRATA_FMAN16
-#define FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN11
-#define FM_IRAM_ECC_ERR_IRQ_ERRATA
+#define FM_1588_SRC_CLK_FMAN1
+#define FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+#define FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
 #define FM_PORT_SYNC_ERRATA_FMAN6
 #define FM_PRS_MEM_ERRATA
 #define FM_IEEE_BAD_TS_ERRATA_IPG28055
 #define FM_HALT_SIG_ERRATA_GEN_CCB310
 #define FM_PRS_L4_SHELL_ERRATA
 #define FM_1G_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+#define FM_10G_MDIO_HOLD_ERRATA_XAUI3
+#define FM_10G_PCS_ALIGNMENT_ERRATA_XAUI4
 #define BUP_FM_LEN_CHECK_ERRATA
 #define BUP_FM_10G_REM_N_LCL_FLT_EX_ERRATA
 #define BUP_FM_MDIO_ERRATA
+#define FM_PORT_COUNTERS_ERRATA_IPG19249
+#define FM_PORT_ALIGN_ERRATA_IPG19155
+#define FM_OP_PORT_QMAN_REJECT_ERRATA_IPG19339
+#define FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+#define FM_PORT_DISABLED_ERRATA_IPG19430
+#define FM_PORT_OTF_CHANGES_ERRATA_IPG20370         FM_PORT_EXCESSIVE_BUDGET_ERRATA_IPG22345
+#define FM_IM_LARGE_MRBLR_ERRATA_FMANb
 
 
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
index fecd7c3..e14242b 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -41,6 +41,8 @@
 
 #include "std_ext.h"
 #include "dpaa_integration_ext.h"
+
+
 /**************************************************************************//**
  @Group         P4080_chip_id P4080 Application Programming Interface
 
@@ -63,44 +65,51 @@ typedef enum e_ModuleId
     e_MODULE_ID_DUART_2,
     e_MODULE_ID_DUART_3,
     e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LA,
+    e_MODULE_ID_LBC,
+    e_MODULE_ID_PAMU,
     e_MODULE_ID_QM,                 /**< Queue manager module */
     e_MODULE_ID_BM,                 /**< Buffer manager module */
     e_MODULE_ID_QM_CE_PORTAL_0,
-    e_MODULE_ID_QM_CE_PORTAL_1,
-    e_MODULE_ID_QM_CE_PORTAL_2,
-    e_MODULE_ID_QM_CE_PORTAL_3,
-    e_MODULE_ID_QM_CE_PORTAL_4,
-    e_MODULE_ID_QM_CE_PORTAL_5,
-    e_MODULE_ID_QM_CE_PORTAL_6,
-    e_MODULE_ID_QM_CE_PORTAL_7,
-    e_MODULE_ID_QM_CE_PORTAL_8,
     e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
     e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
     e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
     e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
     e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
     e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
     e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
     e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
     e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
     e_MODULE_ID_BM_CE_PORTAL_0,
-    e_MODULE_ID_BM_CE_PORTAL_1,
-    e_MODULE_ID_BM_CE_PORTAL_2,
-    e_MODULE_ID_BM_CE_PORTAL_3,
-    e_MODULE_ID_BM_CE_PORTAL_4,
-    e_MODULE_ID_BM_CE_PORTAL_5,
-    e_MODULE_ID_BM_CE_PORTAL_6,
-    e_MODULE_ID_BM_CE_PORTAL_7,
-    e_MODULE_ID_BM_CE_PORTAL_8,
     e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
     e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
     e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
     e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
     e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
     e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
     e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
     e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
     e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
     e_MODULE_ID_FM1,                /**< Frame manager #1 module */
     e_MODULE_ID_FM1_RTC,            /**< FM Real-Time-Clock */
     e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
@@ -135,8 +144,6 @@ typedef enum e_ModuleId
     e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
     e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
     e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM1_RISC0,          /**< FM risc #0 */
-    e_MODULE_ID_FM1_RISC1,          /**< FM risc #1 */
     e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
     e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
     e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
@@ -177,17 +184,19 @@ typedef enum e_ModuleId
     e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
     e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
     e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
-    e_MODULE_ID_FM2_RISC0,          /**< FM risc #0 */
-    e_MODULE_ID_FM2_RISC1,          /**< FM risc #1 */
     e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
     e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
     e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
     e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
     e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
 
+    e_MODULE_ID_SEC,                /**< Security Engine Controller (SEC 4.0)    */
+    e_MODULE_ID_SEC_DCL,            /**< SEC 4.0 Descriptor Construction Library */
     e_MODULE_ID_MPIC,               /**< MPIC */
     e_MODULE_ID_GPIO,               /**< GPIO */
     e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
     e_MODULE_ID_DUMMY_LAST
 } e_ModuleId;
 
@@ -206,6 +215,20 @@ typedef enum e_TransSrc
     e_TRANS_SRC_DMA             = 0x15, /**< DMA                     */
 } e_TransSrc;
 
+/**************************************************************************//**
+ @Description   Local Access Window Target interface ID
+*//***************************************************************************/
+typedef enum e_LaTgtId
+{
+    e_LA_TARGET_BMAN    = 0x18,  /**< BMAN target interface ID */
+    e_LA_TARGET_LBC     = 0x1F,  /**< Local Bus target interface ID */
+    e_LA_TARGET_QMAN    = 0x3C,  /**< QMAN target interface ID */
+    e_LA_TARGET_CPC_DDR1= 0x10,  /**< DDR controller 1 or CPC1 SRAM */
+    e_LA_TARGET_CPC_DDR2= 0x11,  /**< DDR controller 2 or CPC2 SRAM */
+    e_LA_TARGET_DCSR    = 0x1D,  /**< DCSR */
+    e_LA_TARGET_NONE    = 0xFF   /**< None */
+} e_LaTgtId;
+
 /***************************************************************
     P4080 general routines
 ****************************************************************/
@@ -239,6 +262,66 @@ typedef struct
 } t_P4080Params;
 
 /**************************************************************************//**
+ @Description   structure representing P4080 PAMU initialization parameters
+*//***************************************************************************/
+typedef struct
+{
+    uint64_t        baseAddress;        /**< base address (virtual) */
+    uint32_t        memPartitionId;     /**< mem partition id */
+    int             irq;
+    int             errIrq;
+    t_Handle        h_P4080;
+} t_P4080PamuParams;
+
+typedef struct
+{
+ 	uint64_t    windowPbase;      /**< phys base addr */
+ 	uint64_t    windowSize;       /**< size in bytes - not size is 2^window_size */
+ 	uint64_t    windowTbase;      /**< xlated base addr */
+ 	int         addrXlate;
+ 	int         stashId;
+ 	int         snoopId;          /**< snoop group id */
+ 	bool        opXlate;
+ 	int         omi;              /**< operation mapping table index */
+ 	bool        coherence;
+ 	int         permissions;
+} t_PamuWin;
+
+
+//TODO - add define for 16
+typedef struct
+{
+    t_PamuWin   pamuWindows[16];     /**< array of windows */
+ 	uint64_t    totalWindowSize;  /**< size in bytes - not size is 2^window_size */
+    int         windowCount;      /**< number of sub windows */
+} t_P4080PamuLiodnParamsNew;
+
+
+//ehud original structure unused for now
+typedef struct
+{
+    uint32_t        liodn;
+    uint64_t        windowAddr;
+    uint64_t        windowSize;
+    uint32_t        cacheStashId;
+    bool            coherency;
+    uint8_t         snoopCoreId;
+    bool            operationMapping;
+    uint32_t        omi;
+    uint32_t        subWindowCnt;
+
+} t_P4080PamuLiodnParams;
+
+/**************************************************************************//**
+ @Description   structure representing P4080 SERDES initialization parameters
+*//***************************************************************************/
+typedef struct
+{
+    uint64_t        baseAddress;      /**< base address (virtual) */
+    t_Handle        h_P4080;
+} t_P4080SerdesParams;
+
+/**************************************************************************//**
  @Description   SERDES lanes activation
 *//***************************************************************************/
 typedef enum e_SerDesLaneActivation
@@ -390,6 +473,65 @@ uint32_t P4080_GetDdrFactor(t_Handle h_P4080);
 t_Error  P4080_GetFmFactor(t_Handle h_P4080, uint8_t fmIndex, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
 
 /**************************************************************************//**
+ @Function      P4080_LAWForce
+
+ @Description  	Allocation of a local access window in a specific address.
+
+               	The routine allocates memory space window at the requested
+               	address, according to the requested size and owner.
+
+ @Param[in]     h_P4080     - The handle of the initialized P4080 object.
+ @Param[in]     id          - Target interface id.
+ @Param[in]     size        - Size of window, at least 4KB and no more than
+                              2GB, must be a power of 2.
+ @Param[in]     address     - Base address for the window.
+ @Param[in]     entry       - Entry number in la matrix.
+
+ @Return        Number of allocated window (0-7) or LA83_ILLEGAL_LAW
+                If either size or address are illegal, No window
+                available or failed to allocate a block of the
+                requested size.
+*//***************************************************************************/
+t_Error P4080_LAWForce(t_Handle h_P4080, e_LaTgtId id, uint64_t size, uint64_t address, uint8_t entry);
+
+/**************************************************************************//**
+ @Function      P4080_LAWClear
+
+ @Description  	Release of a local access window.
+
+                The routine releases the memory block associated with a specific
+                local access window, and disables this window. On termination,
+                the routine modifies the current available window index to point
+                to the freed window. This is useful in case all windows are busy.
+                It may be of no significance or a little inefficient in other cases.
+
+ @Param      	h_P4080     - (In) The handle of the initialized P4080 object.
+ @Param         lawNum      - (In) window number (0-9) as returned by the window
+                                   allocation routine.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P4080_LAWClear(t_Handle h_P4080, uint8_t lawNum);
+
+/**************************************************************************//**
+ @Function      P4080_LAWFindId
+
+ @Description  	The routine finds the target ID and window ID that matches a
+                specific address.
+
+                It does that by going through all windows and comparing the
+                address to their start address and size.
+
+ @Param      	h_P4080     - (In) The handle of the initialized P4080 object.
+ @Param      	address     - (In) Address for testing.
+ @Param      	p_WinId     - (Out) Receives the matching window ID.
+
+ @Return        Target ID as defined in 'la_ext.h' (LA_ID_XXX) or LA_ID_NONE
+                if no match.
+*//***************************************************************************/
+uint32_t P4080_LAWFindId(t_Handle h_P4080, uint64_t address, uint32_t *p_WinId);
+
+/**************************************************************************//**
  @Function      P4080_Reset
 
  @Description   Reset the chip.
@@ -401,8 +543,38 @@ void P4080_Reset(t_Handle h_P4080);
 t_Error P4080_CoreTimeBaseEnable(t_Handle h_P4080);
 t_Error P4080_CoreTimeBaseDisable(t_Handle h_P4080);
 
+typedef enum e_SrdsPrtcl {
+    SRDS_PRTCL_NONE = 0,
+    SRDS_PRTCL_PCIE1,
+    SRDS_PRTCL_PCIE2,
+    SRDS_PRTCL_PCIE3,
+    SRDS_PRTCL_SRIO1,
+    SRDS_PRTCL_SRIO2,
+    SRDS_PRTCL_SGMII_FM1,
+    SRDS_PRTCL_SGMII_FM2,
+    SRDS_PRTCL_XAUI_FM1,
+    SRDS_PRTCL_XAUI_FM2,
+    SRDS_PRTCL_AURORA
+} e_SrdsPrtcl;
+
 t_P4080DevParams * P4080_GetDevicesConfiguration(t_Handle h_P4080);
 t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
+uint32_t P4080_GetRcwSrdsPrtcl(t_Handle h_P4080);
+bool P4080_IsDeviceConfiguredInRcw(t_Handle h_P4080, e_SrdsPrtcl device);
+bool P4080_IsSrdsLaneEnabledInRcw(t_Handle h_P4080, uint32_t lane);
+t_Error P4080_PamuDisableBypass(t_Handle h_P4080, uint8_t pamuId, bool disable);
+
+t_Handle P4080_SERDES_ConfigAndInit(t_P4080SerdesParams *p_SerdesParams);
+t_Error P4080_SERDES_Free(t_Handle h_P4080Serdes);
+t_Error P4080_SERDES_SetBankLoopback(t_Handle h_4080Serdes, uint8_t serdesBank);
+t_Error P4080_SERDES_ClearBankLoopback(t_Handle h_4080Serdes, uint8_t serdesBank);
+t_Error P4080_SERDES_BankDisable(t_Handle h_4080Serdes, uint8_t serdesBank, bool disable);
+t_Error P4080_SERDES_SetErratas(t_Handle h_4080Serdes);
+t_Error P4080_SERDES_SetXaui4Errata(t_Handle h_P4080Serdes, uint8_t serdesBank);
+
+t_Handle P4080_PAMU_ConfigAndInit(t_P4080PamuParams *p_PamuParams);
+t_Error P4080_PAMU_AddLiodnEntry(t_Handle h_P4080Pamu, uint32_t liodn, t_P4080PamuLiodnParamsNew *p_LiodnParams);
+t_Error P4080_PAMU_Free(t_Handle h_P4080Pamu);
 
 /** @} */ /* end of P4080_init_grp group */
 /** @} */ /* end of P4080_grp group */
@@ -415,48 +587,89 @@ t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
 #define MODULE_MEM              0x00010000
 #define MODULE_MM               0x00020000
 #define MODULE_CORE             0x00030000
-#define MODULE_PM               0x00040000
-#define MODULE_P4080            0x00050000
-#define MODULE_P4080_PLTFRM     0x00060000
+#define MODULE_P4080            0x00040000
+#define MODULE_P4080_PLTFRM     0x00050000
+#define MODULE_PM               0x00060000
 #define MODULE_MMU              0x00070000
 #define MODULE_EPIC             0x00080000
-#define MODULE_DUART            0x00090000
-#define MODULE_SERDES           0x000a0000
-#define MODULE_PIO              0x000b0000
-#define MODULE_QM               0x000c0000
-#define MODULE_BM               0x000d0000
-#define MODULE_FM               0x000e0000
-#define MODULE_FM_MURAM         0x000f0000
-#define MODULE_FM_PCD           0x00100000
-#define MODULE_FM_RTC           0x00110000
-#define MODULE_FM_MAC           0x00120000
-#define MODULE_FM_PORT          0x00130000
+#define MODULE_CPC              0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_SEC_DCL          0x00100000
+#define MODULE_LA               0x00110000
+#define MODULE_LBC              0x00120000
+#define MODULE_PAMU             0x00130000
+#define MODULE_FM               0x00140000
+#define MODULE_FM_MURAM         0x00150000
+#define MODULE_FM_PCD           0x00160000
+#define MODULE_FM_RTC           0x00170000
+#define MODULE_FM_MAC           0x00180000
+#define MODULE_FM_PORT          0x00190000
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  16
+
+#define PAMU_PICS_AVICS_ERRATA_PAMU3
 
 /*****************************************************************************
  LA INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
 #define LA_NUM_OF_WINDOWS       32                      /**< Number of local access windows */
 
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
 /**************************************************************************//**
- @Description   Local Access Window Target interface ID
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
 *//***************************************************************************/
-typedef enum e_LaTgtId
-{
-    e_LA_ID_PCIE1   = 0x00,  /**< PCI Express 1 target interface ID */
-    e_LA_ID_PCIE2   = 0x01,  /**< PCI Express 2 target interface ID */
-    e_LA_ID_PCIE3   = 0x02,  /**< PCI Express 3 target interface ID */
-    e_LA_ID_RIO1    = 0x08,  /**< RapidIO 1 target interface ID */
-    e_LA_ID_RIO2    = 0x09,  /**< RapidIO 2 target interface ID */
-    e_LA_ID_LS      = 0x0F,  /**< Local Space target interface ID */
-    e_LA_ID_MC1     = 0x10,  /**< DDR controller 1 or CPC1 SRAM target interface ID */
-    e_LA_ID_MC2     = 0x11,  /**< DDR controller 2 or CPC2 SRAM target interface ID */
-    e_LA_ID_IM      = 0x14,  /**< Interleaved DDR controllers or CPC SRAM target interface ID */
-    e_LA_ID_BMAN    = 0x18,  /**< BMAN target interface ID */
-    e_LA_ID_DCSR    = 0x1D,  /**< DCSR target interface ID */
-    e_LA_ID_LBC     = 0x1F,  /**< Local Bus target interface ID */
-    e_LA_ID_QMAN    = 0x3C,  /**< QMAN target interface ID */
-    e_LA_ID_NONE    = 0xFF  /**< None */
-} e_LaTgtId;
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_ATOMIC_WRITE    0x00800000  /**< Atomic write error */
+#define LBC_ERR_ATOMIC_READ     0x00400000  /**< Atomic read error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_ATOMIC_WRITE | \
+                                 LBC_ERR_ATOMIC_READ | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL
+#define LBC_ATOMIC_OPERATION_SUPPORT
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
 
 /*****************************************************************************
  GPIO INTEGRATION-SPECIFIC DEFINITIONS
@@ -489,8 +702,167 @@ typedef enum e_LaTgtId
 /*****************************************************************************
  SerDes INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
+#define SRDS_MAX_LANES      18
+#define SRDS_MAX_BANK       3
+
+#define SRDS_LANES  \
+{                   \
+    { 0, 152, 0 },     \
+    { 1, 153, 0 },     \
+    { 2, 154, 0 },     \
+    { 3, 155, 0 },     \
+    { 4, 156, 0 },     \
+    { 5, 157, 0 },     \
+    { 6, 158, 0 },     \
+    { 7, 159, 0 },     \
+    { 8, 160, 0 },     \
+    { 9, 161, 0 },     \
+    { 16, 162, 1 },    \
+    { 17, 163, 1 },    \
+    { 18, 164, 1 },    \
+    { 19, 165, 1 },    \
+    { 20, 170, 2 },    \
+    { 21, 171, 2 },    \
+    { 22, 172, 2 },    \
+    { 23, 173, 2 },    \
+}
+
+#define SRDS_PRTCL_OPTIONS \
+{   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,          \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,          \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,          \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE2, SRDS_PRTCL_PCIE2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,          \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1,SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                   \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO2, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO2, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                                          \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO2, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                                          \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO2, SRDS_PRTCL_NONE, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                                          \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3,                                                                                                                                \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1},                                                                                                                   \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2, SRDS_PRTCL_SGMII_FM2,                                                                                                                \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1, SRDS_PRTCL_SGMII_FM1},                                                                                                               \
+    {SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE1, SRDS_PRTCL_PCIE3, SRDS_PRTCL_PCIE3, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_SRIO1, SRDS_PRTCL_AURORA, SRDS_PRTCL_AURORA,                  \
+     SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2, SRDS_PRTCL_XAUI_FM2,                                                                                                                    \
+     SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1, SRDS_PRTCL_XAUI_FM1}                                                                                                                    \
+}
+
 #ifndef SIMULATOR
+#define SERDES_REIDL_RCTL_ERRATA_SERDES2
+#define SERDES_TEQ_TYPE_ERRATA_SERDES3
+#define SERDES_TX_CLK_ERRATA_SERDES4
+#define SERDES_PEX_PLL_BANDWIDTH_ERRATA_SERDES5
+#define SERDES_OPAD_CTL_ERRATA_SERDES6
+
+/*
+ * The values of CONFIG_SYS_P4080_ERRATUM_SERDES8_BANK2/3 should be the
+ * intended value of SRDS_LPD_B2/SRDS_LPD_B3, rather than the 0xf that
+ * must be in the RCW.
+ */
+#define SERDES_PLL_JITTER_ERRATA_SERDES8
+#define SERDES_PLL_JITTER_ERRATA_SERDES8_BANK2 0x0
+#define SERDES_PLL_JITTER_ERRATA_SERDES8_BANK3 0x4
+
 #define SERDES_ERRATA
 #endif /* !SIMULATOR */
 
+
 #endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
index 3d5efdd..0a49d3a 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
@@ -56,6 +56,8 @@
       defined(SC1023)  || \
       defined(P2020)   || \
       defined(P4080)   || \
+      defined(P3040)   || \
+      defined(P5020)   || \
       defined(MSC814x))
 #error "unable to proceed without chip-definition"
 #endif /* !(defined(MPC834x) || ... */
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
index 9652c11..b273c9a 100644
--- a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -98,11 +98,14 @@
 
 #define UNUSED(X) (X=X)
 
-#define KILOBYTE            0x400       /* 1024 */
-#define MEGABYTE            0x100000    /* 1024*1024 */
+#define KILOBYTE            0x400                   /* 1024 */
+#define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
+#define GIGABYTE            (KILOBYTE * MEGABYTE)   /* 1024*1024*1024 */
 
 #define NO_IRQ              (-1)
 
+#define NCSW_MASTER_ID      (0)
+
 /* Macro for checking if a number is a power of 2 */
 #define POWER_OF_2(n)   (!((n) & ((n)-1)))
 
@@ -214,7 +217,7 @@ typedef enum e_DiagMode
     e_DIAG_MODE_CHIP_LOOPBACK,  /**< Loopback in the chip but not in the
                                      controller; e.g. IO-pins, SerDes, etc. */
     e_DIAG_MODE_PHY_LOOPBACK,   /**< Loopback in the external PHY */
-    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line */
+    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line (beyond the PHY) */
     e_DIAG_MODE_CTRL_ECHO,      /**< Echo incoming data by the controller */
     e_DIAG_MODE_PHY_ECHO        /**< Echo incoming data by the PHY */
 } e_DiagMode;
@@ -257,7 +260,6 @@ typedef uint32_t    t_Mutex;
 *//***************************************************************************/
 typedef uint32_t    t_Error;
 
-
 /**************************************************************************//**
  @Description   General prototype of interrupt service routine (ISR).
 
@@ -267,7 +269,6 @@ typedef uint32_t    t_Error;
  *//***************************************************************************/
 typedef void (t_Isr)(t_Handle handle);
 
-
 /**************************************************************************//**
  @Anchor        mem_attr
 
@@ -321,6 +322,28 @@ typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
                                    t_Handle h_BufContext);
 
 /**************************************************************************//**
+ @Function      t_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+typedef void * t_PhysToVirt(physAddress_t addr);
+
+/**************************************************************************//**
+ @Function      t_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+typedef physAddress_t t_VirtToPhys(void *addr);
+
+/**************************************************************************//**
  @Description   Buffer Pool Information Structure.
 *//***************************************************************************/
 typedef struct t_BufferPoolInfo
@@ -330,6 +353,10 @@ typedef struct t_BufferPoolInfo
     t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
     uint16_t            bufferSize;     /**< Buffer size (in bytes) */
 
+    t_PhysToVirt        *f_PhysToVirt;  /**< User callback to translate pool buffers 
+                                             physical addresses to virtual addresses  */
+    t_VirtToPhys        *f_VirtToPhys;  /**< User callback to translate pool buffers 
+                                             virtual addresses to physical addresses */
 } t_BufferPoolInfo;
 
 
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
index b49d42f..7cb9458 100644
--- a/drivers/net/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -322,6 +322,12 @@ typedef uint8_t headerFieldMpls_t;
 #define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
 
 
+typedef uint8_t headerFieldMacsec_t;
+
+#define NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
 typedef enum {
     HEADER_TYPE_NONE = 0,
     HEADER_TYPE_PAYLOAD,
@@ -348,19 +354,21 @@ typedef enum {
     HEADER_TYPE_MPLS,
     HEADER_TYPE_IPSEC_AH,
     HEADER_TYPE_IPSEC_ESP,
+    HEADER_TYPE_MACSEC,
     HEADER_TYPE_GRE,
     HEADER_TYPE_MINENCAP,
     HEADER_TYPE_DCCP,
     HEADER_TYPE_ICMP,
     HEADER_TYPE_IGMP,
     HEADER_TYPE_ARP,
+    HEADER_TYPE_CAPWAP,
+    HEADER_TYPE_CAPWAP_DTLS,
     HEADER_TYPE_RFC2684,
     HEADER_TYPE_USER_DEFINED_L2,
     HEADER_TYPE_USER_DEFINED_L3,
     HEADER_TYPE_USER_DEFINED_L4,
     HEADER_TYPE_USER_DEFINED_SHIM1,
     HEADER_TYPE_USER_DEFINED_SHIM2,
-    HEADER_TYPE_USER_DEFINED_SHIM3,
     MAX_HEADER_TYPE_COUNT
 } e_NetHeaderType;
 
diff --git a/drivers/net/dpa/NetCommSw/inc/types_ext.h b/drivers/net/dpa/NetCommSw/inc/types_ext.h
index bdd1723..3907630 100644
--- a/drivers/net/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/types_ext.h
@@ -74,21 +74,32 @@ static __inline__ void TypesChecker(void)
     int             on = ON, off = OFF;
     bool            tr = TRUE, fls = FALSE;
     struct strct    *p_Strct = NULL;
+    physAddress_t   addr = 0x100;
 
     on      = off;
     tr      = fls;
     p_Strct = p_Strct;
     size++;
 
-
-    WRITE_UINT8 (*(uint8_t  *)UINT8_MAX,  GET_UINT8 (*(uint8_t  *)UINT8_MIN ));
-    WRITE_UINT16(*(uint16_t *)UINT16_MAX, GET_UINT16(*(uint16_t *)UINT16_MIN));
-    WRITE_UINT32(*(uint32_t *)UINT32_MAX, GET_UINT32(*(uint32_t *)UINT32_MIN));
-    WRITE_UINT64(*(uint64_t *)UINT64_MAX, GET_UINT64(*(uint64_t *)UINT64_MIN));
-    WRITE_UINT8 (*(uint8_t  *)INT8_MAX,   GET_UINT8 (*(uint8_t  *)UINT8_MIN ));
-    WRITE_UINT16(*(uint16_t *)INT16_MAX,  GET_UINT16(*(uint16_t *)INT16_MIN ));
-    WRITE_UINT32(*(uint32_t *)INT32_MAX,  GET_UINT32(*(uint32_t *)INT32_MIN ));
-    WRITE_UINT64(*(uint64_t *)INT64_MAX,  GET_UINT64(*(uint64_t *)INT64_MIN ));
+    WRITE_UINT8(*((uint8_t*)((size_t)(addr))),
+                 GET_UINT8(*((uint8_t*)((size_t)(addr)))));
+
+    WRITE_UINT8(*((uint8_t*)((size_t)(UINT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(UINT8_MIN)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(UINT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(UINT16_MIN)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(UINT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(UINT32_MIN)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(UINT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(UINT64_MIN)))));
+    WRITE_UINT8(*((uint8_t*)((size_t)(INT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(INT8_MIN)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(INT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(INT16_MIN)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(INT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(INT32_MIN)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
 }
 
 
diff --git a/drivers/net/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
index 4a839f6..4622b06 100644
--- a/drivers/net/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
@@ -379,137 +379,6 @@ void XX_BottomHalf(void);
 
 
 /*****************************************************************************/
-/*                        Semaphore Service Routines                         */
-/*****************************************************************************/
-typedef t_Handle t_SemaphoreHandle;
-typedef t_Handle t_MutexHandle;
-
-/**************************************************************************//**
- @Function      XX_InitSemaphore
-
- @Description   Creates a counting semaphore.
-
- @Param[in]     initialCount - initial counter value.
-
- @Return        Semaphore handle is returned on success. NULL is returned
-                otherwise.
-*//***************************************************************************/
-t_SemaphoreHandle XX_InitSemaphore(int initialCount);
-
-/**************************************************************************//**
- @Function      XX_InitBinSemaphore
-
- @Description   creates a binary semaphore, which is a semaphore with maximum
-                count of 1.
-
- @Param[in]     initialCount - initial counter value, should be of course
-                               either 0 or 1.
-
- @Return        Semaphore handle is returned on success. NULL is returned
-                otherwise.
-*//***************************************************************************/
-t_SemaphoreHandle XX_InitBinSemaphore(int initialCount);
-
-/**************************************************************************//**
- @Function      XX_FreeSemaphore
-
- @Description   Frees the memory allocated for the semaphore creation.
-
- @Param[in]     h_Semaphore - A handle to a semaphore.
-
- @Return        None.
-*//***************************************************************************/
-void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore);
-
-/**************************************************************************//**
- @Function      XX_InitMutex
-
- @Description   Creates a mutex.
-
- @Return        Mutex handle is returned on success. NULL is returned
-                otherwise.
-*//***************************************************************************/
-t_MutexHandle XX_InitMutex(void);
-
-/**************************************************************************//**
- @Function      XX_InitMutexLocked
-
- @Description   Creates a mutex and locks it.
-
- @Return        Mutex handle is returned on success; NULL otherwise.
-*//***************************************************************************/
-t_MutexHandle XX_InitMutexLocked(void);
-
-/**************************************************************************//**
- @Function      XX_FreeMutex
-
- @Description   Frees the memory allocated for the mutex creation.
-
- @Param[in]     h_Mutex - A handle to a mutex.
-
- @Return        None.
-*//***************************************************************************/
-void XX_FreeMutex(t_MutexHandle h_Mutex);
-
-/**************************************************************************//**
- @Function      XX_DownSemaphore
-
- @Description   Decrements the counter of the semaphore by 1; When counter
-                reaches 0, the semaphore is locked.
-
- @Param[in]     h_Semaphore - A handle to a semaphore.
-
- @Return        None.
-*//***************************************************************************/
-void XX_DownSemaphore(t_SemaphoreHandle h_Semaphore);
-
-/**************************************************************************//**
- @Function      XX_UpSemaphore
-
- @Description   Increments the counter of the semaphore by 1; When counter
-                passes 0, the semaphore is unlocked.
-
- @Param[in]     h_Semaphore - A handle to a semaphore.
-
- @Return        None.
-*//***************************************************************************/
-void XX_UpSemaphore(t_SemaphoreHandle h_Semaphore);
-
-/**************************************************************************//**
- @Function      XX_TryLock
-
- @Description   Tries to lock a mutex.
-
- @Param[in]     h_Mutex - A handle to a mutex.
-
- @Return        1 - on success. 0 - otherwise.
-*//***************************************************************************/
-int XX_TryLock(t_MutexHandle h_Mutex);
-
-/**************************************************************************//**
- @Function      XX_Lock
-
- @Description   Locks a mutex.
-
- @Param[in]     h_Mutex - A handle to a mutex.
-
- @Return        None.
-*//***************************************************************************/
-void XX_Lock(t_MutexHandle h_Mutex);
-
-/**************************************************************************//**
- @Function      XX_Unlock
-
- @Description   Unlocks a mutex.
-
- @Param[in]     h_Mutex - A handle to a mutex.
-
- @Return        None.
-*//***************************************************************************/
-void XX_Unlock(t_MutexHandle h_Mutex);
-
-
-/*****************************************************************************/
 /*                        Spinlock Service Routines                          */
 /*****************************************************************************/
 
@@ -748,10 +617,12 @@ void * XX_PhysToVirt(physAddress_t addr);
 *//***************************************************************************/
 physAddress_t XX_VirtToPhys(void *addr);
 
+/* NOTE - This MACRO is temporary and deprecated. Don't use it! */
 #define XXX_VirtToPhys(addr)  XX_VirtToPhys(CAST_UINT32_TO_POINTER(addr))
 
-#define MSG_BODY_SIZE       512
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+
+
+
 /**************************************************************************//**
  @Group         xx_ipc  XX Inter-Partition-Communication API
 
@@ -759,61 +630,146 @@ physAddress_t XX_VirtToPhys(void *addr);
 
  @{
 *//***************************************************************************/
-typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
-typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+
+#define XX_IPC_MAX_ADDR_NAME_LENGTH 16
+//#define XX_MAX_IPC_MSG_BODY_LENGTH  256
+
 
 /**************************************************************************//**
- @Function      XX_RegisterMessageHandler
+ @Function      t_IpcMsgCompletionCallback
+
+ @Description   TODO
 
- @Description   This routine is used to register to the XX messaging mechanism.
+ @Param[in]     h_Arg           - TODO
+ @Param[in]     p_Msg           - TODO
+ @Param[in]     msgLength       - TODO
+ @Param[out]    p_Reply         - TODO
+ @Param[out]    p_ReplyLength   - TODO
+*//***************************************************************************/
+typedef void    (t_IpcMsgCompletionCallback)(t_Handle   h_Arg, 
+                                             uint8_t    *p_Msg, 
+                                             uint32_t   msgLength, 
+                                             uint8_t    *p_Reply, 
+                                             uint32_t   replyLength);
 
- @Param[in]     p_Addr          - The module address.
- @Param[in]     f_MsgHandlerCB  - The module callback; It will be called when the
+/**************************************************************************//**
+ @Function      t_IpcMsgHandlerCallback
+
+ @Description   TODO
+
+ @Param[in]     h_Module        - TODO
+ @Param[in]     p_Msg           - TODO
+ @Param[in]     msgLength       - TODO
+ @Param[out]    p_Reply         - TODO
+ @Param[out]    p_ReplyLength   - TODO
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+typedef t_Error (t_IpcMsgHandlerCallback)(t_Handle  h_Module, 
+                                          uint8_t   *p_Msg, 
+                                          uint32_t  msgLength, 
+                                          uint8_t   **p_Reply, 
+                                          uint32_t  *p_ReplyLength);
+
+
+/**************************************************************************//**
+ @Function      XX_IpcRegisterMsgHandler
+
+ @Description   This routine is used to register to the XX ipc messaging mechanism.
+
+ @Param[in]     addr            - The module address.
+ @Param[in]     f_MsgHandler    - The module callback; It will be called when the
                                   module gets message.
- @Param[in]     h_Mod           - The module arg; It will be passed to the module
+ @Param[in]     h_Module        - The module argument; It will be passed to the module
                                   whithin the callback when it gets message.
 
- @Return        E_OK is returned on success. error code is returned otherwise.
+ @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
-t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod);
+t_Error XX_IpcRegisterMsgHandler(char                       addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandlerCallback    *f_MsgHandler,
+                                 t_Handle                   h_Module);
 
 /**************************************************************************//**
- @Function      XX_UnregisterMessageHandler
+ @Function      XX_IpcUnregisterMsgHandler
 
- @Description   This routine is used to unregister to the XX messaging mechanism.
+ @Description   This routine is used to unregister the message handler from 
+                the XX ipc messaging mechanism.
 
- @Param[in]     p_Addr          - The module address.
+ @Param[in]     addr          - The module address.
 
- @Return        E_OK is returned on success. error code is returned otherwise.
+ @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
-t_Error XX_UnregisterMessageHandler (char *p_Addr);
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
 
 /**************************************************************************//**
- @Function      XX_SendMessage
+ @Function      XX_IpcInitSession
+
+ @Description   This routine initializes IPC session between sender and receiver.
 
- @Description   This routine is used to send messages to modules registered to the
-                XX messaging mechanism.
+ @Param[in]     destAddr      - The destination module address name.
+ @Param[in]     srcAddr       - The source module address name.
 
- @Param[in]     p_DestAddr      - The destination module address.
- @Param[in]     msgId           - The message ID.
- @Param[in]     msgBody         - The message body (up to 64 bytes).
+ @Return        IPC session handle on success; NULL otherwise.
+*//***************************************************************************/
+t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH], 
+                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
+
+/**************************************************************************//**
+ @Function      XX_IpcFreeSession
+
+ @Description   This routine disconnect the sender and the receiver from the same ipc connection.
+
+ @Param[in]     h_Session      - The IPC session handle.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcFreeSession(t_Handle h_Session);
+
+#if 0
+/**************************************************************************//**
+ @Function      XX_IpcSendMessage
+
+ @Description   This routine is used to send a message to a connection which is
+                registered to the XX messaging mechanism.
+
+ @Param[in]     h_Session       - The handle of the connection that was initialized
+                                  by calling to the XX_IpcInitConnection().
+ @Param[in]     p_Msg           - The message body (the length of this message is
+                                  msgLength bytes).
+ @Param[in]     msgLength       - The length of the message body - should not exceed the 
+                                  MAX_IPC_MSG_BODY_LENGTH.
+ @Param[in]     p_Reply         - TODO
+ @Param[in]     replyLength     - TODO
  @Param[in]     f_CompletionCB  - The caller callback; It will be called after the
                                   message will be handled by the destination module.
                                   NOTE - if passing here NULL, the routine will be
-                                  blocking untill the destination module will
+                                  blocking until the destination module will
                                   handle the message.
- @Param[in]     h_CBArg         - The caller handler; This argument will be
+ @Param[in]     h_Arg           - The caller handler; This argument will be
                                   passed to whithin the completion routine.
 
- @Return        E_OK is returned on success. error code is returned otherwise.
+ @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
+t_Error XX_IpcSendMessage(t_Handle                      h_Session,
+                          uint8_t                       *p_Msg,
+                          uint32_t                      msgLength,
+                          uint8_t                       *p_Reply,
+                          uint32_t                      replyLength,
+                          t_IpcMsgCompletionCallback    *f_Completion,
+                          t_Handle                      h_Arg)
+
+#else
+#define MSG_BODY_SIZE       512
+typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
 t_Error XX_SendMessage(char                 *p_DestAddr,
                        uint32_t             msgId,
                        uint8_t              msgBody[MSG_BODY_SIZE],
                        t_MsgCompletionCB    *f_CompletionCB,
                        t_Handle             h_CBArg);
-/** @} */ /* end of xx_ic group */
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+#endif /* 1 */
+
+/** @} */ /* end of xx_ipc group */
 /** @} */ /* end of xx_id group */
 
 
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
index 8e07b61..bfff0ed 100644
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
@@ -37,16 +37,22 @@ const char *moduleStrings[] =
     ,"MEM"                      /* MODULE_ */
     ,"MM"                       /* MODULE_MM */
     ,"CORE"                     /* MODULE_CORE */
-    ,"PM"                       /* MODULE_PM */
     ,"P4080"                    /* MODULE_P4080 */
     ,"P4080-Pltaform"           /* MODULE_P4080_PLTFRM */
+    ,"PM"                       /* MODULE_PM */
     ,"MMU"                      /* MODULE_MMU */
     ,"MPIC"                     /* MODULE_MPIC */
+    ,"L3 cache (CPC)"           /* MODULE_CPC */
     ,"DUART"                    /* MODULE_DUART */
     ,"SerDes"                   /* MODULE_SERDES */
     ,"PIO"                      /* MODULE_PIO */
     ,"QM"                       /* MODULE_QM */
     ,"BM"                       /* MODULE_BM */
+    ,"SEC"                      /* MODULE_SEC */
+    ,"SEC-DCL"                  /* MODULE_SEC_DCL */
+    ,"LA"                       /* MODULE_LA */
+    ,"LBC"                      /* MODULE_LBC */
+    ,"PAMU"                     /* MODULE_PAMU */
     ,"FM"                       /* MODULE_FM */
     ,"FM-MURAM"                 /* MODULE_FM_MURAM */
     ,"FM-PCD"                   /* MODULE_FM_PCD */
diff --git a/drivers/net/dpa/NetCommSw/ncsw_config.mk b/drivers/net/dpa/NetCommSw/ncsw_config.mk
index 4931c5e..6b0e28b 100644
--- a/drivers/net/dpa/NetCommSw/ncsw_config.mk
+++ b/drivers/net/dpa/NetCommSw/ncsw_config.mk
@@ -13,10 +13,12 @@ EXTRA_CFLAGS += -I$(NCSW)/inc/cores
 EXTRA_CFLAGS += -I$(NCSW)/inc/etc
 EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
 EXTRA_CFLAGS += -I$(NCSW)/inc/integrations
+ifeq ($(CONFIG_FMAN_P4080),y)
 EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P4080
+endif
 EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc
 EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/system
 EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/wrappers/Peripherals
-EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl
-EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/Peripherals
-EXTRA_CFLAGS += -I$(NCSW)/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/Peripherals
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/integrations/P4080
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
deleted file mode 100644
index 9108d0d..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
+++ /dev/null
@@ -1,292 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          fm_ioctls.h
-
- @Description   FM Char device ioctls
-*//***************************************************************************/
-#ifndef __FM_IOCTLS_H
-#define __FM_IOCTLS_H
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   FM Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    FM IOCTL device ('/dev') definitions
-*//***************************************************************************/
-#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
-
-#define DEV_FM_MINOR_BASE           0
-#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)
-#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)
-#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + 7)
-#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + 5)
-#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + 5)
-
-#define FM_IOC_NUM(n)       n
-#define FM_PCD_IOC_NUM(n)   (n+20)
-#define FM_PORT_IOC_NUM(n)  (n+50)
-/* @} */
-
-#define IOC_FM_MAX_NUM_OF_PORTS         64
-
-/**************************************************************************//**
- @Collection   FM Frame error
-*//***************************************************************************/
-typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
-
-#define IOC_FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
-#define IOC_FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
-                                                                             error (SGMII and TBI modes), FIFO parity error. PHY
-                                                                             Sequence error, PHY error control character detected. */
-#define IOC_FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
-#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
-#define IOC_FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
-#define IOC_FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
-#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
-#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
-#define IOC_FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
-#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
-#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
-#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
-#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
-#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
-#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
-#define IOC_FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
-#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
-/* @} */
-
-
-/**************************************************************************//**
- @Description   enum for defining port types
-*//***************************************************************************/
-typedef enum ioc_fm_port_type {
-    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
-                                             host command, so must have exclusive id) */
-    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
-                                             offline parsing ports, so must have exclusive id) */
-    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
-    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
-    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
-    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
-    e_IOC_FM_PORT_TYPE_DUMMY
-} ioc_fm_port_type;
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_lib_grp FM library
-
- @Description   FM API functions, definitions and enums
-                The FM module is the main driver module and is a mandatory module
-                for FM driver users. Before any further module initialization,
-                this module must be initialized.
-                The FM is a "single-tone" module. It is responsible of the common
-                HW modules: FPM, DMA, common QMI, common BMI initializations and
-                run-time control routines. This module must be initialized always
-                when working with any of the FM modules.
-                NOTE - We assumes that the FML will be initialize only by core No. 0!
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   FM Exceptions
-*//***************************************************************************/
-typedef enum ioc_fm_exceptions {
-    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
-    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
-    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
-    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
-    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
-    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
-    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
-    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
-    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
-    e_IOC_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
-                                                 of invalid port id. */
-    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
-    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
-    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
-    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
-    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
-} ioc_fm_exceptions;
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
-
- @Description   FM Runtime control unit API functions, definitions and enums.
-                The FM driver provides a set of control routines for each module.
-                These routines may only be called after the module was fully
-                initialized (both configuration and initialization routines were
-                called). They are typically used to get information from hardware
-                (status, counters/statistics, revision etc.), to modify a current
-                state or to force/enable a required action. Run-time control may
-                be called whenever necessary and as many times as needed.
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection   General FM defines.
-*//***************************************************************************/
-#define IOC_FM_NUM_OF_PORT_TYPES            e_IOC_FM_PORT_TYPE_DUMMY
-#define IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE    7
-/* @} */
-
-/**************************************************************************//**
- @Description   Port id by type and relative id
-*//***************************************************************************/
-typedef uint8_t ioc_ports_param_t[IOC_FM_NUM_OF_PORT_TYPES][IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE];
-
-/**************************************************************************//**
- @Description   enum for defining FM counters
-*//***************************************************************************/
-typedef enum ioc_fm_counters {
-    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
-    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
-    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
-    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
-    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
-} ioc_fm_counters;
-
-typedef struct ioc_fm_obj_t {
-    void            *obj;
-} ioc_fm_obj_t;
-
-/**************************************************************************//**
- @Description   structure for returning revision information
-*//***************************************************************************/
-typedef struct ioc_fm_revision_info_t {
-    uint8_t         major;               /**< Major revision */
-    uint8_t         minor;               /**< Minor revision */
-} ioc_fm_revision_info_t;
-
-/**************************************************************************//**
- @Description   structure for FM counters
-*//***************************************************************************/
-typedef struct ioc_fm_counters_params_t {
-    ioc_fm_counters cnt;                /**< The requested counter */
-    uint32_t        val;                /**< The requested value to get/set from/into the counter */
-} ioc_fm_counters_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_IOC_SET_PORTS_BANDWIDTH
-
- @Description   Sets relative weights between ports when accessing common resources.
-
- @Param[in]     ioc_ports_param_t   A table of ports bandwidth in percentage, i.e.
-                                    total must equal 100.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_ports_param_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_GET_REVISION
-
- @Description   Returns the FM revision
-
- @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
-
- @Return        None.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_GET_COUNTER
-
- @Description   Reads one of the FM counters.
-
- @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_Init().
-                Note that it is user's responsibilty to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_SET_COUNTER
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_IOC_FORCE_INTR
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     ioc_fm_exceptions   An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
-
-/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
-/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp */
-
-
-#endif /* __FM_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
deleted file mode 100644
index 616661f..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
+++ /dev/null
@@ -1,1501 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/******************************************************************************
- @File          fm_pcd_ioctls.h
-
- @Description   FM PCD ...
-*//***************************************************************************/
-#ifndef __FM_PCD_IOCTLS_H
-#define __FM_PCD_IOCTLS_H
-
-#include "net_ioctls.h"
-#include "fm_ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   FM Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PCD_grp FM PCD
-
- @Description   FM PCD API functions, definitions and enums
-
-                The FM PCD module is responsible for the initialization of all
-                global classifying FM modules. This includes the parser general and
-                common registers, the key generator global and common registers,
-                and the Policer global and common registers.
-                In addition, the FM PCD SW module will initialize all required
-                key generator schemes, coarse classification flows, and Policer
-                profiles. When An FM module is configured to work with one of these
-                entities, it will register to it using the FM PORT API. The PCD
-                module will manage the PCD resources - i.e. resource management of
-                Keygen schemes, etc.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    General PCD defines
-*//***************************************************************************/
-#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
-
-#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
-#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
-#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                            /**< Maximum number of netenv distinction units */
-#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
-#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
-#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
-#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
-                                                                                 For reason of HW implemetation, in most
-                                                                                 cases less than this will be allowed. The
-                                                                                 driver will return error in initialization
-                                                                                 time if resource is overused. */
-#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
-#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
-#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
-
-#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
-/* @} */
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
-
- @Description   FM PCD Runtime Unit
-
-                The runtime control allows creation of PCD infrastructure modules
-                such as Network Environment Characteristics, Classification Plan
-                Groups and Coarse Classification Trees.
-                It also allows on-the-fly initialization, modification and removal
-                of PCD modules such as Keygen schemes, coarse classification nodes
-                and Policer profiles.
-
-
-                In order to explain the programming model of the PCD driver interface
-                a few terms should be explained, and will be used below.
-                  * Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the shim headers (1-3). May be a header with a special
-                    option (see below).
-                  * Interchangeable Headers Group- This is a group of Headers recognized
-                    by either one of them. For example, if in a specific context the user
-                    chooses to treat IPv4 and IPV6 in the same way, they may create an
-                    Interchangable Headers Unit consisting of these 2 headers.
-                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
-                    Group.
-                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
-                    ipv6, includes multicast, broadcast and other protocol specific options.
-                    In terms of hardware it relates to the options available in the classification
-                    plan.
-                  * Network Environment Characteristics - a set of Distinction Units that define
-                    the total recognizable header selection for a certain environment. This is
-                    NOT the list of all headers that will ever appear in a flow, but rather
-                    everything that needs distinction in a flow, where distinction is made by keygen
-                    schemes and coarse classification action descriptors.
-
-                The PCD runtime modules initialization is done in stages. The first stage after
-                initializing the PCD module itself is to establish a Network Flows Environment
-                Definition. The application may choose to establish one or more such environments.
-                Later, when needed, the application will have to state, for some of its modules,
-                to which single environment it belongs.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   PCD counters
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_counters {
-    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
-    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
-    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
-} ioc_fm_pcd_counters;
-
-/**************************************************************************//**
- @Description   PCD interrupts
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_exceptions {
-    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
-    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
-    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
-    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
-    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
-    e_IOC_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
-    e_IOC_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
-} ioc_fm_pcd_exceptions;
-
-/**************************************************************************//**
- @Description   structure for FM counters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_counters_params_t {
-    ioc_fm_pcd_counters cnt;                /**< The requested counter */
-    uint32_t            val;                /**< The requested value to get/set from/into the counter */
-} ioc_fm_pcd_counters_params_t;
-
-/**************************************************************************//**
- @Description   structure for FM exception definitios
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_exception_params_t {
-    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
-    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
-} ioc_fm_pcd_exception_params_t;
-
-/**************************************************************************//**
- @Description   A structure for sw parser labels
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_label_params_t {
-    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
-                                                                 resolution), relative to Parser RAM. */
-    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
-                                                                 the sw parser code. */
-    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
-                                                                 attachments for the same header, use this
-                                                                 index to distinguish between them. */
-} ioc_fm_pcd_prs_label_params_t;
-
-/**************************************************************************//**
- @Description   A structure for sw parser
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_sw_params_t {
-    bool                            override;           /**< FALSE to invoke a check that nothing else
-                                                             was loaded to this address, including
-                                                             internal patched.
-                                                             TRUE to override any existing code.*/
-    uint32_t                        size;               /**< SW parser code size */
-    uint16_t                        base;               /**< SW parser base (in instruction counts!
-                                                             muat be larger than 0x20)*/
-    uint8_t                         *p_code;            /**< SW parser code */
-    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
-                                                        /**< SW parser data (parameters) */
-    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
-    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
-                                                        /**< SW parser labels table, containing n
-                                                             umOfLabels entries */
-} ioc_fm_pcd_prs_sw_params_t;
-
-/**************************************************************************//**
- @Description   A structure to set the a KeyGen default value
- *//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
-    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
-    uint32_t                        value;                  /**< The requested default value */
-} ioc_fm_pcd_kg_dflt_value_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_ENABLE
-
- @Description   This routine should be called after PCD is initialized for enabling all
-                PCD engines according to their existing configuration.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_DISABLE
-
- @Description   This routine may be called when PCD is enabled in order to
-                disable all PCD engines. It may be called
-                only when none of the ports in the system are using the PCD.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
-
- /**************************************************************************//**
- @Function      FM_PCD_IOC_PRS_LOAD_SW
-
- @Description   This routine may be called only when all ports in the
-                system are actively using the classification plan scheme.
-                In such cases it is recommended in order to save resources.
-                The driver automatically saves 8 classification plans for
-                ports that do NOT use the classification plan mechanism, to
-                avoid this (in order to save those entries) this routine may
-                be called.
-
- @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP
-
- @Description   This routine may always be called, and MUST be called when
-                not all ports in the partition are actively using the classification
-                plan mechanism.
-                When called, the driver automatically saves 8 classification
-                plans for ports that do NOT use the classification plan mechanism, to
-                avoid this (in order to save those entries) this routine may
-                be ommited when all ports are using the classification
-                plan machanism.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
- *//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(4))
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP
-
- @Description   This routine may be called only when all ports in the
-                system are actively using the classification plan scheme.
-                In such cases, if empty clsPlan was already set,
-                it is recommended in order to save resources.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
-                Note that this routine may not be called if any of the FM ports
-                is not using the classification plan mechanism.
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(5))
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
-
- @Description   Calling this routine sets a global default value to be used
-                by the keygen when parser does not recognize a required
-                field/header.
-                By default default values are 0.
-
- @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
-
- @Description   Calling this routine allows the keygen to access data past
-                the parser finidhing point.
-
- @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
-
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_SET_EXCEPTION
-
- @Description   Calling this routine enables/disables PCD interrupts.
-
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_GET_COUNTER
-
- @Description   Reads one of the FM PCD counters.
-
- @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
-
- @Return        Counter's current value.
-
- @Cautions      Allowed only following FM_PCD_Init().
-                Note that it is user's responsibilty to call this routine only
-                for enabled counters, and there will be no indication if a
-                disabled counter is accessed.
-*//***************************************************************************/
-#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_SET_COUNTER
-
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-
- @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_FORCE_INTR
-
- @Description   Causes an interrupt event on the requested source.
-
- @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
-
-/**************************************************************************//**
- @Collection    Definitions of coarse classification
-                parameters as required by keygen (when coarse classification
-                is the next engine after this scheme).
-*//***************************************************************************/
-#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_NODES     255
-#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_TREES     8
-#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP     16
-#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS         4
-#define IOC_FM_PCD_MAX_NUM_OF_KEYS             256
-#define IOC_FM_PCD_MAX_SIZE_OF_KEY             56
-/* @} */
-
-/**************************************************************************//**
- @Collection    A set of definitions to allow protocol
-                special option description.
-*//***************************************************************************/
-typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
-
-typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
-#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
-#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
-
-typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
-#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
-
-typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
-#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
-
-typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
-#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
-#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
-#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
-#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
-
-typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
-#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
-#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
-#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
-/* @} */
-
-/**************************************************************************//**
- @Description   All PCD engines
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_engine {
-    e_IOC_FM_PCD_DONE,      /**< No PCD Engine indicated */
-    e_IOC_FM_PCD_KG,        /**< Parser indicated */
-    e_IOC_FM_PCD_CC,        /**< Keygen indicated */
-    e_IOC_FM_PCD_PLCR,      /**< Coarse classification indicated */
-    e_IOC_FM_PCD_PRS        /**< Policer indicated */
-} ioc_fm_pcd_engine;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction by header types
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_by_hdr_type {
-    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
-    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
-    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
-} ioc_fm_pcd_extract_by_hdr_type;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction source
-                (when it is not the header)
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_from {
-    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
-    e_IOC_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
-    e_IOC_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
-    e_IOC_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
-} ioc_fm_pcd_extract_from;
-
-/**************************************************************************//**
- @Description   An enum for selecting extraction type
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_extract_type {
-    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
-    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
-    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
-} ioc_fm_pcd_extract_type;
-
-/**************************************************************************//**
- @Description   An enum for selecting a default
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_kg_extract_dflt_select {
-    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
-    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
-    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
-    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
-    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
-} ioc_fm_pcd_kg_extract_dflt_select;
-
-/**************************************************************************//**
- @Description   An enum defining all default groups -
-                each group shares a default value, one of 4 user
-                initialized values.
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
-    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
-    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
-    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
-    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
-    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
-    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
-    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
-    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
-    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
-    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
-    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
-    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
-    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
-                                                 any data extraction that is not the full
-                                                 field described above  */
-    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
-                                                 any data extraction without validation */
-    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
-                                                 extraction from parser result or
-                                                 direct use of default value  */
-} ioc_fm_pcd_kg_known_fields_dflt_types;
-
-/**************************************************************************//**
- @Description   enum for defining header index when headers may repeat
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_hdr_index {
-    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
-                                                     to specify regular IP (not tunneled). */
-    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
-    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
-    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
-    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
-} ioc_fm_pcd_hdr_index;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile functional type
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_profile_type_selection {
-    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
-    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
-} ioc_fm_pcd_profile_type_selection;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile algorithem
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_algorithm_selection {
-    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
-    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
-    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
-} ioc_fm_pcd_plcr_algorithm_selection;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile color mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_color_mode {
-    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
-    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
-} ioc_fm_pcd_plcr_color_mode;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile color functional mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_color {
-    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
-    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
-    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
-    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
-} ioc_fm_pcd_plcr_color;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile packet frame length selector
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_frame_length_select {
-  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
-  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
-  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
-  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
-} ioc_fm_pcd_plcr_frame_length_select;
-
-/**************************************************************************//**
- @Description   An enum for selecting rollback frame
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
-  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
-  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
-} ioc_fm_pcd_plcr_roll_back_frame_select;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile packet or byte mode
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_rate_mode {
-    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
-    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
-} ioc_fm_pcd_plcr_rate_mode;
-
-/**************************************************************************//**
- @Description   An enum for defining action of frame
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_done_action {
-    e_IOC_FM_PCD_PLCR_ENQ_FRAME,    /**< Enqueue frame */
-    e_IOC_FM_PCD_PLCR_DROP_FRAME    /**< Drop frame */
-} ioc_fm_pcd_plcr_done_action;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer counter
-*//***************************************************************************/
-typedef enum ioc_fm_pcd_plcr_profile_counters {
-    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
-    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
-} ioc_fm_pcd_plcr_profile_counters;
-
-/**************************************************************************//**
- @Description   A type used for returning the order of the key extraction.
-                each value in this array represents the index of the extraction
-                command as defined by the user in the initialization extraction array.
-                The valid size of this array is the user define number of extractions
-                required (also marked by the second '0' in this array).
-*//***************************************************************************/
-typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-
-/**************************************************************************//**
- @Description   A Union of protocol dependent special options
-*//***************************************************************************/
-typedef union ioc_fm_pcd_hdr_protocol_opt_u {
-    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
-    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
-    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
-    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
-    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
-} ioc_fm_pcd_hdr_protocol_opt_u;
-
-/**************************************************************************//**
- @Description   A union holding all known protocol fields
-*//***************************************************************************/
-typedef union ioc_fm_pcd_fields_u {
-    ioc_header_field_eth_t        eth;        /**< eth      */
-    ioc_header_field_vlan_t       vlan;       /**< vlan     */
-    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
-    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
-    ioc_header_field_mpls_t       mpls;       /**< mpls     */
-    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
-    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
-    ioc_header_field_udp_t        udp;        /**< udp      */
-    ioc_header_field_tcp_t        tcp;        /**< tcp      */
-    ioc_header_field_sctp_t       sctp;       /**< sctp     */
-    ioc_header_field_dccp_t       dccp;       /**< dccp     */
-    ioc_header_field_gre_t        gre;        /**< gre      */
-    ioc_header_field_minencap_t   minencap;   /**< minencap */
-    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
-    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
-} ioc_fm_pcd_fields_u;
-
-/**************************************************************************//**
- @Description   structure for defining header extraction for key generation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_from_hdr_t {
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} ioc_fm_pcd_from_hdr_t;
-
-/**************************************************************************//**
- @Description   structure for defining field extraction for key generation
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_from_field_t {
-    ioc_fm_pcd_fields_u field;          /**< Field selection */
-    uint8_t             size;           /**< Size in byte */
-    uint8_t             offset;         /**< Byte offset */
-} ioc_fm_pcd_from_field_t;
-
-/**************************************************************************//**
- @Description   A structure of parameters used to define a single network
-                environment unit.
-                A unit should be defined if it will later be used by one or
-                more PCD engines to distinguich between flows.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_distinction_unit_t {
-    struct {
-        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
-        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
-    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
-} ioc_fm_pcd_distinction_unit_t;
-
-/**************************************************************************//**
- @Description   A structure of parameters used to define the different
-                units supported by a specific PCD Network Environment
-                Characteristics module. Each unit represent
-                a protocol or a group of protocols that may be used later
-                by the different PCD engined to distinguich between flows.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_net_env_params_t {
-    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
-    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                                /**< An array of numOfDistinctionUnits of the
-                                                                     different units to be identified */
-    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
-} ioc_fm_pcd_net_env_params_t;
-
-/**************************************************************************//**
- @Description   structure for defining a single extraction action
-                when creating a key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_extract_entry_t {
-    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
-    union {
-        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
-            ioc_net_header_type             hdr;            /**< Header selection */
-            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
-            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
-                                                                  IP. Otherwise should be cleared.*/
-            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
-            union {
-                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
-                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
-                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
-            } extract_by_hdr_type;
-        } extract_by_hdr;
-        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
-            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
-            uint8_t                         offset;         /**< Byte offset */
-            uint8_t                         size;           /**< Size in byte */
-        } extract_non_hdr;
-    } extract_params;
-} ioc_fm_pcd_extract_entry_t;
-
-/**************************************************************************//**
- @Description   A structure for defining masks for each extracted
-                field in the key.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extract_mask_t {
-    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
-    uint8_t                offset;                      /**< Byte offset */
-    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
-} ioc_fm_pcd_kg_extract_mask_t;
-
-/**************************************************************************//**
- @Description   A structure for defining default selection per groups
-                of fields
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extract_dflt_t {
-    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
-    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
-} ioc_fm_pcd_kg_extract_dflt_t;
-
-/**************************************************************************//**
- @Description   A structure for defining all parameters needed for
-                generation a key and using a hash function
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
-    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
-    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
-    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
-    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
-    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
-    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
-    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
-    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
-    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
-                                                                             of queues for the key and hash functionality */
-    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
-} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
-
-/**************************************************************************//**
- @Description   A structure of parameters for defining a single
-                Qid mask (extracted OR).
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_extracted_or_for_fqid_t {
-    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
-    union{
-        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
-            ioc_net_header_type             hdr;
-            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
-                                                                     IP. Otherwise should be cleared.*/
-            bool                            ignore_protocol_validation;
-        } extract_by_hdr;
-        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
-    } extract_params;
-    uint8_t                                 extraction_offset;  /**< Offset for extraction */
-    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
-                                                                     field not found */
-    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
-    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
-} ioc_fm_pcd_kg_extracted_or_for_fqid_t;
-
-/**************************************************************************//**
- @Description   A structure for configuring scheme counter
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_counter_t {
-    bool        update;     /**< FALSE to keep the current counter state
-                                 and continue from that point, TRUE to update/reset
-                                 the counter when the scheme is written. */
-    uint32_t    value;      /**< If update=TRUE, this value will be written into the
-                                 counter. clear this field to reset the counter. */
-} ioc_fm_pcd_kg_scheme_counter_t;
-
-/**************************************************************************//**
- @Description   A structure for defining policer profile
-                parameters as required by keygen (when policer
-                is the next engine after this scheme).
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_plcr_profile_t {
-    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
-                                                             (i.e. managed by master partition) May not be TRUE
-                                                             if profile is after Coarse Classification*/
-    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
-                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
-                                                             together with fqidOffsetShift and numOfProfiles
-                                                             parameters, to define a range of profiles from
-                                                             which the keygen result will determine the
-                                                             destination policer profile.  */
-    union{
-        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
-                                                             This parameter should
-                                                             indicate the policer profile offset within the port's
-                                                             policer profiles or SHARED window. */
-        struct {
-            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
-            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
-                                                             This parameter should
-                                                             indicate the policer profile offset within the port's
-                                                             policer profiles windowor SHARED window depends on sharedProfile */
-            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
-        } indirect_profile_id;
-    } profile_select;
-} ioc_fm_pcd_kg_plcr_profile_t;
-
-/**************************************************************************//**
- @Description   A structure for CC parameters if CC is the next engine after KG
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_cc_t {
-    void                            *tree_id;           /**< CC Tree id */
-    uint8_t                         grp_id;             /**< CC group id within the CC tree */
-    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
-                                                             policing is required. */
-    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
-} ioc_fm_pcd_kg_cc_t;
-
-/**************************************************************************//**
- @Description   A structure for initializing a keygen single scheme
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_params_t {
-    bool                                modify;         /**< enables changing an existing scheme */
-    union
-    {
-        uint8_t                         relative_scheme_id;/**< IN: if modify=FALSE:Partition relative scheme id */
-        void                            *scheme_id;      /**< IN: if modify=TRUE: a handle of the existing scheme */
-    } scm_id;
-    bool                                always_direct;  /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
-                                                             it when matching   */
-    struct                                              /**< HL Relevant only if alwaysDirect = FALSE */
-    {
-        void                            *net_env_id;     /**< Network environment id  */
-        uint8_t                         num_of_distinction_units; /**< Number of netenv units listed in unit_ids array */
-        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
-                                                        /**< Indexes as passed to SetNetEnvCharacteristics array*/
-    } netEnvParams;
-    bool                                use_hash;       /**< use the KG Hash functionality */
-    ioc_fm_pcd_kg_key_extract_and_hash_params_t     key_extract_and_hash_params;
-                                                        /**< used only if useHash = TRUE */
-    uint32_t                            base_fqid;      /**< Base FQID */
-    uint8_t                             num_of_used_fqid_masks;  /**< Number of Fqid masks listed in fqid_masks array */
-    ioc_fm_pcd_kg_extracted_or_for_fqid_t           fqid_masks[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                                        /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
-                                                             registers are shared between qidMasks
-                                                             functionality and some of the extraction
-                                                             actions. Normally only some will be used
-                                                             for qidMask. Driver will return error if
-                                                             resource is full at initialization time. */
-    ioc_fm_pcd_engine                   next_engine;    /**< may be BMI, PLCR or CC */
-    union{                                              /**< depends on nextEngine */
-        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;   /**< Used when next engine is PLCR */
-        ioc_fm_pcd_kg_cc_t              cc;             /**< Used when next engine is CC */
-    } kg_next_engine_params;
-    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter; /**< A strcucture of parameters for updating
-                                                             the scheme counter */
-    ioc_fm_pcd_kg_key_order_t           ordered_array;  /**< OUT: A structure holding the order of the key extraction.
-                                                             Relevant only is 'useHash' is TRUE. each value in this
-                                                             array represents the index of the
-                                                             extraction command as defined by the application in
-                                                             the initialization extraction array.
-                                                             The valid size of this array is the application define number of extractions
-                                                             required (also marked by the second '0' in this array).*/
-    void                                *id;            /**< OUT: Returns the scheme Id to be used */
-} ioc_fm_pcd_kg_scheme_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining CC params when CC is the
-                next engine after a CC node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_cc_params_t {
-    void        *cc_node_id;                   /**< Id of the next CC node */
-} ioc_fm_pcd_cc_next_cc_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining PLCR params when PLCR is the
-                next engine after a CC node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
-    bool        ctrl_flow;                      /**< TRUE if this is a control flow, FALSE
-                                                     if this is data flow */
-    bool        shared_profile;                 /**< Relevant only if ctrlFlow=TRUE:
-                                                     TRUE if this profile is shared between ports */
-    uint16_t    plcr_profile_num_for_ctrl_flow; /**< Valid if ctrlFlow=TRUE,Proile id for control flow
-                                                     (for data flow porfile id
-                                                     is taken from keygen) */
-    bool        fqid_enq_ctrl_flow;             /**< TRUE if after the policer the frame should
-                                                     be enqueued rather than return to Keygen */
-    uint32_t    fqid_for_ctrl_flow_for_bmi_after_plcr; /**< Valid if fqidEnqForCtrlFlow= TRUE, FQID for enquing
-                                                         the frame */
-} ioc_fm_pcd_cc_next_plcr_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining enqueue params when BMI is the
-                next engine after a CC node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
-    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
-                                             if this is data flow */
-    uint32_t    fqid_for_cntrl_flow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
-                                             (for data flow FQID is taken from keygen) */
-} ioc_fm_pcd_cc_next_enqueue_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining KG params when KG is the
-                next engine after a CC node
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_kg_params_t {
-    bool        ctrl_flow;              /**< TRUE if this is a control flow, FALSE
-                                             if this is data flow */
-    void        *direct_scheme_id;      /**< Direct scheme id to go to */
-} ioc_fm_pcd_cc_next_kg_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining next engine params after a CC node.
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_next_engine_params_t {
-    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
-                                                                     to nextEngine definition */
-    union {
-            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
-            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
-            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
-            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
-    } params;
-} ioc_fm_pcd_cc_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining a single CC Key parameters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_key_params_t {
-    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
-    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
-                                         in keySize. p_Key and p_Mask (if defined) has to be
-                                         of the same size defined in the keySize */
-
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                    /**< parameters for the next for the defined Key in the p_Key */
-} ioc_fm_pcd_cc_key_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining CC Keys parameters
-*//***************************************************************************/
-typedef struct ioc_keys_params_t {
-    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
-    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
-                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
-                                                             key. In the another type of extraction keySize has to be as size of extraction. */
-
-    uint8_t                             *p_glbl_mask;   /**< optional and can be initialized if :
-                                                             keySize <=4 or  maskForKey is not initialized*/
-    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
-                                                        /**< it's array with numOfKeys entries each entry in
-                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
-                                                        /**< parameters for the next step of
-                                                             unfound (or undefined) key */
-} ioc_keys_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining the CC node params
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_params_t {
-    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
-    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
-                                                                 extraction defined in  extractParams */
-    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
-} ioc_fm_pcd_cc_node_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining each CC tree group in term of
-                NetEnv units and the action to be taken in each case.
-                the unit_ids list must be in order from lower to higher indexes.
-
-                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
-                structures where each defines the next action to be taken for
-                each units combination. for example:
-                num_of_distinction_units = 2
-                unit_ids = {1,3}
-                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - not found; unit 3 - not found;
-                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - not found; unit 3 - found;
-                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - found; unit 3 - not found;
-                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
-                                                    unit 1 - found; unit 3 - found;
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_grp_params_t {
-    uint8_t                             num_of_distinction_units;   /**< up to 4 */
-    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
-                                                                    /**< Indexes of the units as defined in
-                                                                         FM_PCD_SetNetEnvCharacteristics */
-    ioc_fm_pcd_cc_next_engine_params_t  *p_next_engine_per_entries_in_grp;
-                                                                    /**< Max size is 16 - if only one group used  */
-} ioc_fm_pcd_cc_grp_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining the CC tree groups
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_tree_params_t {
-        void                            *net_env_id;    /**< Id of the Network environment as returned
-                                                             by FM_PCD_SetNetEnvCharacteristics */
-        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
-        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP];
-                                                        /**< Max 8 groups (of 2) for the 16 nodes root */
-        void                            *id;            /**< output parameter; Returns the tree Id to be used */
-} ioc_fm_pcd_cc_tree_params_t;
-
-/**************************************************************************//**
- @Description   A structure for initializing a keygen classification plan group
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_cls_plan_grp_params_t {
-    void                *net_env_id;    /**< Id of the Network environment as returned
-                                             by FM_PCD_SetNetEnvCharacteristics */
-    uint8_t             num_of_pptions; /**< Number of options, to define the size of the
-                                             following array. */
-    ioc_protocol_opt_t  options[IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS];
-                                        /**< an option may be ipv6Multicast1,
-                                             (ethBroadcast | ethMulticast) or
-                                             (ethBroadcast | ipv4Unicast2 | mplsStacked) */
-    void                *id;            /**< output parameter; Returns the classification-group Id to be used */
-} ioc_fm_pcd_kg_cls_plan_grp_params_t;
-
-/**************************************************************************//**
- @Description   A structure for defining parameters for byte rate
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
-    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
-    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
-                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
-} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
-    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
-    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
-    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
-    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
-    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
-    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
-} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
-
-/**************************************************************************//**
- @Description   A union for defining Policer next engine parameters
-*//***************************************************************************/
-typedef union ioc_fm_pcd_plcr_next_engine_params_u {
-        ioc_fm_pcd_plcr_done_action     action;             /**< Action - when next engine is BMI (done) */
-        void                            *plcr_profile_id;   /**< Policer profile id -  when next engine is PLCR*/
-        void                            *direct_scheme_id;  /**< Direct scheme id - when next engine is Keygen */
-} ioc_fm_pcd_plcr_next_engine_params_u;
-
-typedef struct fm_pcd_port_params_t {
-    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
-    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
-} fm_pcd_port_params_t;
-
-/**************************************************************************//**
- @Description   A structure for selcting the policer profile entry parameters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_plcr_profile_params_t {
-    bool                                        modify;                     /**< TRUE to change an existing profile */
-    union {
-        struct {
-            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
-            fm_pcd_port_params_t                *p_port;                    /**< FM-Port id of port for this profile */
-            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
-        } new_params;
-        void                                    *profile_id;                /**< policer-profile id */
-    } profile_select;
-    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
-    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
-
-    union {
-        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
-                                                                                 any incoming packet with the deflt value. */
-        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
-                                                                                 pre-color value of 2b11. */
-    } color;
-
-    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
-
-    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
-
-    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
-
-    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
-    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
-
-    bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
-    bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
-    bool                                        trap_profile_on_flow_C;     /**< Trap on flow C */
-    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
-} ioc_fm_pcd_plcr_profile_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC tree next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
-    void                                *id;                /**< CC tree Id to be used */
-    uint8_t                             grp_indx;           /**< A Group index in the tree */
-    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                                            /**< parameters for the next for the defined Key in the p_Key */
-} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
-                                                            /**< parameters for the next for the defined Key in the p_Key */
-} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node key and next engine
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
-                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
-} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
-
-/**************************************************************************//**
- @Description   A structure for remove CC node key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-} ioc_fm_pcd_cc_node_remove_key_params_t;
-
-/**************************************************************************//**
- @Description   A structure for modifying CC node key
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
-    void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
-                                                                 NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
-    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
-                                                                 in keySize. p_Key and p_Mask (if defined) has to be
-                                                                 of the same size defined in the keySize */
-} ioc_fm_pcd_cc_node_modify_key_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
-
- @Description   Define a set of Network Environment Charecteristics.
-                When setting an environment it is important to understand its
-                application. It is not meant to describe the flows that will run
-                on the ports using this environment, but what the user means TO DO
-                with the PCD mechanisms in order to parse-classify-distribute those
-                frames.
-                By specifying a distinction unit, the user means it would use that option
-                for distinction between frames at either a keygen scheme keygen or a coarse
-                classification action descriptor. Using interchangeable headers to define a
-                unit means that the user is indifferent to which of the interchangeable
-                headers is present in the frame, and they want the distinction to be based
-                on the presence of either one of them.
-                Depending on context, there are limitations to the use of environments. A
-                port using the PCD functionality is bound to an environment. Some or even
-                all ports may share an environment but also an environment per port is
-                possible. When initializing a scheme, a classification plan group (see below),
-                or a coarse classification tree, one of the initialized environments must be
-                stated and related to. When a port is bound to a scheme, a classification
-                plan group, or a coarse classification tree, it MUST be bound to the same
-                environment.
-                The different PCD modules, may relate (for flows definition) ONLY on
-                distinction units as defined by their environment. When initializing a
-                scheme for example, it may not choose to select IPV4 as a match for
-                recognizing flows unless it was defined in the relating environment. In
-                fact, to guide the user through the configuration of the PCD, each module's
-                characterization in terms of flows is not done using protocol names, but using
-                environment indexes.
-                In terms of HW implementation, the list of distinction units sets the LCV vectors
-                and later used for match vector, classification plan vectors and coarse classification
-                indexing.
-
- @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
-
- @Description   Deletes a set of Network Environment Charecteristics.
-
- @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
-
- @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
-#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_CLS_PLAN_GRP
-
- @Description   Define a classification plan group..
-                A classification plan group is a set of classification plan
-                entries consisting of a number of protocol options (as listed
-                in HW spec), that is a subset of a previously defined environment,
-                and that is relevant for one or more ports that will use that
-                same environment.
-                By specifying an option, the application means it would use that
-                option for distinction between frames at either a keygen scheme
-                keygen or a coarse classification action descriptor.
-                When RX ports that want to use the classification plan mechanism
-                are initialized, they will be bound to a classification plan
-                group. Usage of the classification plan is optional.
-                If not all ports use classification plan, it is user's responsibility
-                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
-                will then allocate a minimal number of entries for that use, and all
-                ports that do not use the classification plan mechanism will
-                be internally bound to that empty group.
-
- @Param[in,out] ioc_fm_pcd_kg_cls_plan_grp_params_t  A structure of classification plan parameters.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_CLS_PLAN_GRP  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(22), ioc_fm_pcd_kg_cls_plan_grp_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_DEL_CLS_PLAN
-
- @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
-                to it - pass all LCV bits.
-
- @Param[in]     ioc_fm_obj_t         index of plan entry to be deleted.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_DEL_CLS_PLAN  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(23), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_SET_SCHEME
-
- @Description   Initializing or modifying and enabling a scheme for the keygen.
-                This routine should be called for adding or modifying a scheme.
-                When a scheme needs modifying, the API requires that it will be
-                rewritten. In such a case 'override' should be TRUE. If  the
-                routine is called for a valid scheme and 'override' is FALSE,
-                it will return error.
-
- @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_KG_DEL_SCHEME
-
- @Description   Deleting an initialized scheme.
-
- @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_BUILD_TREE
-
- @Description   This routine must be called to define a complete coarse
-                classification tree. This is the way to define coarse
-                classification to a certain flow - the keygen schemes
-                may point only to trees defined in this way.
-
- @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
-
- @Return        0 on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_DELETE_TREE
-
- @Description   Deleting an built tree.
-
- @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_SET_NODE
-
- @Description   This routine should be called for each CC (coarse classification)
-                node. The whole CC tree should be built bottom up so that each
-                node points to already defined nodes. p_NodeId returns the node
-                Id to be used by other nodes.
-
- @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
-
- @Return        0 on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
-
- @Cautions      Allowed only following PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_SET_NODE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), ioc_fm_pcd_cc_node_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_CcDeleteNode
-
- @Description   Deleting an built node.
-
- @Param[in]     ioc_fm_obj_t    An id of a CC-node.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
-
- @Description   Modify the Next Engine Parameters in the entry of the tree.
-
- @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcBuildTree().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
-
- @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
-
- @Description   Modify the Next Engine Parameters of the Miss key case of the node.
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode().
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
-
- @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
-
- @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
-
- @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
-
- @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
-
- @Description   Modify the key  in the index defined by the keyIndex .
-
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  A pointer to a structure with the relevant parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
-                the node that points to this node
-*//***************************************************************************/
-#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_PLCR_SET_PROFILE
-
- @Description   Sets a profile entry in the policer profile table.
-                The routine overrides any existing value.
-
- @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
-                                                    policer profile entry.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
-
-/**************************************************************************//**
- @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
-
- @Description   Delete a profile entry in the policer profile table.
-                The routine set entry to invalid.
-
- @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PCD_Init().
-*//***************************************************************************/
-#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
-
-/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
-/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp group */
-
-
-#endif /* __FM_PCD_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
deleted file mode 100644
index 2101b3f..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
+++ /dev/null
@@ -1,595 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/******************************************************************************
- @File          fm_port_ioctls.h
-
- @Description   FM Port routines
-*//***************************************************************************/
-#ifndef __FM_PORT_IOCTLS_H
-#define __FM_PORT_IOCTLS_H
-
-#include "net_ioctls.h"
-#include "fm_ioctls.h"
-#include "fm_pcd_ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
-
- @Description   FM Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_grp FM Port
-
- @Description   FM Port API
-
-                The FM uses a general module called "port" to represent a Tx port
-                (MAC), an Rx port (MAC), offline parsing flow or host command
-                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
-                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
-                Host command/Offline parsing ports. The SW driver manages these
-                ports as sub-modules of the FM, i.e. after an FM is initialized,
-                its ports may be initialized and operated upon.
-                The port is initialized aware of its type, but other functions on
-                a port may be indifferent to its type. When necessary, the driver
-                verifies coherency and returns error if applicable.
-                On initialization, user specifies the port type and it's index
-                (relative to the port's type). Host command and Offline parsing
-                ports share the same id range, I.e user may not initialized host
-                command port 0 and offline parsing port 0.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
-
- @Description   FM Port Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Collection    General FM Port defines
-*//***************************************************************************/
-#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
-/* @} */
-
-
-/**************************************************************************//**
- @Description   struct for defining port PCD modes
-*//***************************************************************************/
-typedef enum ioc_fm_port_pcd_support {
-    e_IOC_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
-    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
-} ioc_fm_port_pcd_support;
-
-/**************************************************************************//**
- @Description   enum for defining FM Port counters
-*//***************************************************************************/
-typedef enum fm_port_counters {
-    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
-    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
-    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
-    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
-    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
-} fm_port_counters;
-
-
-/**************************************************************************//**
- @Description   Structure for Port id parameters.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-*//***************************************************************************/
-typedef struct ioc_fm_port_congestion_groups_t {
-    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
-    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
-} ioc_fm_port_congestion_groups_t;
-
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_DISABLE
-
- @Description   Gracefully disable an FM port. The port will not start new tasks after all
-                tasks associated with the port are terminated.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-                This is a blocking routine, it returns after port is
-                gracefully stopped, i.e. the port will not except new frames,
-                but it will finish all frames or tasks which were already began
-*//***************************************************************************/
-#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_ENABLE
-
- @Description   A runtime routine provided to allow disable/enable of port.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
-
- @Description   Errors selected for this routine will cause a frame with that error
-                to be enqueued to error queue.
-                Errors not selected for this routine will cause a frame with that error
-                to be enqueued to the one of the other port queues.
-                By default all errors are defined to be enqueued to error queue.
-                Errors that were configured to be discarded (at initialization)
-                may not be selected here.
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_frame_err_select_t)
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
-
- @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   A structure of scheme parameters
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_kg_scheme_select_t {
-    bool        direct;                     /**< TRUE is the scheme should be accessed directly */
-    void        *scheme_id;                 /**< Scheme id */
-} ioc_fm_pcd_kg_scheme_select_t;
-
-/**************************************************************************//**
- @Description    A structure for defining the Parser starting point
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_start_t {
-    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
-                                             start parsing */
-    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
-                                             'parsingOffset' */
-} ioc_fm_pcd_prs_start_t;
-
-/**************************************************************************//**
- @Description   Scheme is'd structure
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_port_schemes_params_t {
-    uint8_t     num_of_schemes;
-    void        *schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
-} ioc_fm_pcd_port_schemes_params_t;
-
-/**************************************************************************//**
- @Description   classification-plan-group structure
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_port_cls_plan_params_t {
-    bool        use_cls_plan;       /**< TRUE to use a pre-defined group, FALSE to stop using one. */
-    void        *new_cls_plan_grp;  /**< An id of a classification plan group that was already set. */
-} ioc_fm_pcd_port_cls_plan_params_t;
-
-/**************************************************************************//**
- @Description   Union for defining port protocol parameters for parser
-*//***************************************************************************/
-typedef union ioc_fm_pcd_hdr_prs_opts_u {
-    /* MPLS */
-    struct {
-        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
-                                                             interpreted as described in HW spec table. When the bit
-                                                             is cleared, the parser will advance to MPLS next parse */
-        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
-    } mpls_prs_options;
-    /* VLAN */
-    struct {
-        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
-                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
-        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
-                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
-    } vlan_prs_options;
-    /* IPV6 */
-    struct {
-        bool                routing_hdr_disable;        /**< Disable routing header */
-    } ipv6_prs_options;
-
-    /* UDP */
-    struct {
-        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
-    } udp_prs_options;
-
-    /* TCP */
-    struct {
-        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
-    } tcp_prs_options;
-} ioc_fm_pcd_hdr_prs_opts_u;
-
-
-/**************************************************************************//**
- @Description   A structure for defining each header for the parser
-*//***************************************************************************/
-typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
-    ioc_net_header_type         hdr;                /**< Selected header */
-    bool                        err_disable;        /**< TRUE to disable error indication */
-    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
-                                                         header is recognized by the HW parser. */
-    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
-                                                         attachments exists for the same header,
-                                                         (in the main sw parser code) use this
-                                                         index to distinguish between them. */
-    bool                        use_prs_opts;       /**< TRUE to use parser options. */
-    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
-                                                         defining the parser options selected.*/
-} ioc_fm_pcd_prs_additional_hdr_params_t;
-
-/**************************************************************************//**
- @Description   struct for defining port PCD parameters
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_prs_params_t {
-    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
-                                                                             port information into the parser result. This information
-                                                                             may be extracted by Keygen and be used for frames
-                                                                             distribution when a per-port distinction is required,
-                                                                             it may also be used as a port logical id for analyazing
-                                                                             incoming frames. */
-    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
-                                                                             start parsing */
-    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
-                                                                             'parsingOffset' */
-    bool                                    include_in_prs_statistics;  /**< TRUE to include this port in the parser statistics.*/
-    uint8_t                                 num_of_hdrs_with_additional_params;
-                                                        /**< Normally 0, some headers may get
-                                                             special parameters */
-    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
-                                                        /**< A structure of additional parameters
-                                                             for each header that requires them */
-    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
-                                                                             indicate a VLAN tag (in addition to the TPID values
-                                                                             0x8100 and 0x88A8). */
-    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
-    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
-                                                                             indicate a VLAN tag (in addition to the TPID values
-                                                                             0x8100 and 0x88A8). */
-    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
-} ioc_fm_port_pcd_prs_params_t;
-
-/**************************************************************************//**
- @Description   struct for defining coarse alassification parameters
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_cc_params_t {
-    void                *cc_tree_id; /**< CC tree id */
-} ioc_fm_port_pcd_cc_params_t;
-
-/**************************************************************************//**
- @Description   struct for defining keygen parameters
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_kg_params_t {
-    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
-    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
-                                                        /**< Array of 'numOfSchemes' schemes for the
-                                                             port to be bound to */
-    bool                use_cls_plan;                   /**< TRUE to use the classification plan mechanism */
-    void                *cls_plan_grp_id;               /**< clsPlan must be of the same netEnvId
-                                                             of this port */
-    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
-                                                             regardless of parser result */
-    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
-} ioc_fm_port_pcd_kg_params_t;
-
-/**************************************************************************//**
- @Description   struct for defining policer parameters
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_plcr_params_t {
-    void                *plcr_profile_id;               /**< relevant only if
-                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
-                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
-} ioc_fm_port_pcd_plcr_params_t;
-
-/**************************************************************************//**
- @Description   struct for defining port PCD parameters
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_params_t {
-    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
-                                                         Describes the active PCD engines for this port. */
-    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
-    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
-    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
-    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
-    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
-} ioc_fm_port_pcd_params_t;
-
-/**************************************************************************//**
- @Description   FQID parameters structure
-*//***************************************************************************/
-typedef struct ioc_fm_port_pcd_fqids_params_t {
-    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
-    uint8_t             alignment;  /**< Alignment required for this port */
-    uint32_t            base_fqid;  /**< output parameter - the base fqid */
-} ioc_fm_port_pcd_fqids_params_t;
-
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
-
- @Description   Allocates FQID's
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_SET_PCD
-
- @Description   Calling this routine defines the port's PCD configuration.
-                It changes it from its default configuration which is PCD
-                disabled (BMI to BMI) and configures it according to the passed
-                parameters.
-
-                May be used for Rx and offline parsing ports only
-
- @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
-                                            configuration.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_DELETE_PCD
-
- @Description   Calling this routine releases the port's PCD configuration.
-                The port returns to its default configuration which is PCD
-                disabled (BMI to BMI) and all PCD configuration is removed.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode  only
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_DETACH_PCD
-
- @Description   Calling this routine detaches the port from its PCD functionality.
-                The port returns to its default flow which is BMI to BMI.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode only
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_ATTACH_PCD
-
- @Description   This routine may be called after FM_PORT_DetachPCD was called,
-                to return to the originally configured PCD support flow.
-                The couple of routines are used to allow PCD configuration changes
-                that demand that PCD will not be used while changes take place.
-
-                May be used for Rx and offline parsing ports which are
-                in PCD mode only
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
-
- @Description   This routine may be called only for ports that use the Policer in
-                order to allocate private policer profiles.
-
- @Param[in]     uint16_t       The number of required policer profiles
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
-
- @Description   This routine should be called for freeing private policer profiles.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
-
- @Description   This routine may be called only for ports that use the keygen in
-                order to change the initial scheme frame should be routed to.
-                The change may be of a scheme id (in case of direct mode),
-                from direct to indirect, or from indirect to direct - specifying the scheme id.
-
- @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
-                                                a scheme is direct/indirect, and if direct - scheme id.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
-
- @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
-                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
-                should be routed to. The change may be of a profile and/or absolute/direct mode
-                selection.
-
- @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
-
- @Description   This routine may be called to change this port connection to
-                a pre-initializes coarse classification Tree.
-
- @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP
-
- @Description   This routine may be called for ports using the KG functionality of the PCD,
-                if the user wishes to replace the classification plan
-                group that the port uses, to start using the classification plan mechanism or to stop
-                using it. The routine may not be called while port
-                receives packets using the PCD functionalities, therefor port must be first detached
-                from the PCD, only than the routine may be called, and than port be attached to PCD again.
-
- @Param[in]     ioc_fm_pcd_port_cls_plan_params_t  the parameters of the new classification-plan-group
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(29), ioc_fm_pcd_port_cls_plan_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
-
- @Description   These routines may be called for modifying the binding of ports
-                to schemes. The scheme itself is not added,
-                just this specific port starts using it.
-
- @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
-
- @Description   These routines may be called for modifying the binding of ports
-                to schemes. The scheme itself is not removed or invalidated,
-                just this specific port stops using it.
-
- @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
-
-/**************************************************************************//**
- @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
-
- @Description   Runtime change of the parser start offset within the header.
-
- @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
-                                        start point for the parser.
-
- @Return        0 on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-#define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
-
-/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
-/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
-/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
-/** @} */ /* end of lnx_ioctl_FM_grp group */
-
-
-#endif /* __FM_PORT_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
deleted file mode 100644
index 0c39267..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          fm_test_ioctls.h
-
- @Description   FM Char device ioctls
-*//***************************************************************************/
-#ifndef __FM_TEST_IOCTLS_H
-#define __FM_TEST_IOCTLS_H
-
-#include "ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
-
- @Description   FM-Test Linux ioctls definitions and enums
-
- @{
-*//***************************************************************************/
-
-#define IOC_FMT_MAX_NUM_OF_PORTS        24
-
-/**************************************************************************//**
- @Collection    TEST Parameters
-*//***************************************************************************/
-/**************************************************************************//**
-  @Description: Name of the FM-Test chardev
-*//***************************************************************************/
-#define DEV_FM_TEST_NAME                "fm-test-port"
-
-#define DEV_FM_TEST_PORTS_MINOR_BASE    0
-#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
-
-#define FMT_PORT_IOC_NUM(n)             n
-/* @} */
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_lib_grp FM-Test library
-
- @Description   TODO
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   TODO
-*//***************************************************************************/
-typedef uint8_t ioc_fmt_xxx_t;
-
-
-/**************************************************************************//**
- @Description   FM Port buffer content description
-*//***************************************************************************/
-typedef struct ioc_fmt_buff_context_t {
-    void            *p_user_priv;
-    uint8_t         fm_prs_res[32];
-    uint8_t         fm_time_stamp[8];
-} ioc_fmt_buff_context_t;
-
-
-/**************************************************************************//**
- @Description   Buffer descriptor
-*//***************************************************************************/
-typedef struct ioc_fmt_buff_desc_t {
-    uint32_t               qid;
-    void                   *p_data;
-    uint32_t               size;
-    uint32_t               status;
-    ioc_fmt_buff_context_t buff_context;
-} ioc_fmt_buff_desc_t;
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
-
- @Description   TODO
- @{
-*//***************************************************************************/
-
-/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
-
- @Description   TODO
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Description   FM-Test FM port type
-*//***************************************************************************/
-typedef enum ioc_fmt_port_type {
-    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
-    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
-} ioc_fmt_port_type;
-
-/**************************************************************************//**
- @Description   TODO
-*//***************************************************************************/
-typedef struct ioc_fmt_port_param_t {
-    uint8_t             fm_id;
-    ioc_fmt_port_type   fm_port_type;
-    uint8_t             fm_port_id;
-    uint32_t            num_tx_queues;
-} ioc_fmt_port_param_t;
-
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_INIT
-
- @Description   TODO
-
- @Param[in]     ioc_fmt_port_param_t  TODO
-
- @Cautions      Allowed only after the FM equivalent port is already initialized.
-*//***************************************************************************/
-#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_SET_DIAG_MODE
-
- @Description   TODO
-
- @Param[in]     ioc_diag_mode  TODO
-
- @Cautions      Allowed only following FMT_PORT_IOC_INIT().
-*//***************************************************************************/
-#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
-
-/**************************************************************************//**
- @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
-
- @Description   Set IP header manipulations for this port.
-
- @Param[in]     int     1 to enable; 0 to disable
-
- @Cautions      Allowed only following FMT_PORT_IOC_INIT().
-*//***************************************************************************/
-#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
-
-/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
-/** @} */ /* end of lnx_ioctl_FMT_grp */
-
-
-#endif /* __FM_TEST_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
deleted file mode 100644
index 5385e0a..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/integrations/P4080/integration_ioctls.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          integration_ioctls.h
-
- @Description   External header file for Integration unit routines.
-*//***************************************************************************/
-
-#ifndef __INTG_IOCTLS_H
-#define __INTG_IOCTLS_H
-
-
-#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
-#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+2)
-
-
-#endif /* __INTG_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
deleted file mode 100644
index fbcd416..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          ioctls.h
-
- @Description   Structures and definitions for Command Relay Ioctls
-*//***************************************************************************/
-
-#ifndef __IOCTLS_H__
-#define __IOCTLS_H__
-
-#include <asm/ioctl.h>
-
-#include "integration_ioctls.h"
-
-
-/**************************************************************************//**
- @Group         lnx_ioctl_ncsw_grp    NeCommSw Linux User-Space (IOCTL) API
- @{
-*//***************************************************************************/
-
-#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
-                                                 the NCSW Linux module commands */
-
-
-/**************************************************************************//**
- @Description   IOCTL Memory allocation types.
-*//***************************************************************************/
-typedef enum ioc_mem_type {
-    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
-    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
-    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
-    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
-    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
-} ioc_mem_type;
-
-/**************************************************************************//**
- @Description   Enumeration (bit flags) of communication modes (Transmit,
-                receive or both).
-*//***************************************************************************/
-typedef enum ioc_comm_mode {
-      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
-    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
-    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
-    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
-} ioc_comm_mode;
-
-/**************************************************************************//**
- @Description   General Diagnostic Mode
-*//***************************************************************************/
-typedef enum ioc_diag_mode
-{
-    e_IOC_DIAG_MODE_NONE = 0,
-    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
-    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
-                                         E.g. IO-pins, SerDes, etc. */
-    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
-    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
-    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
-    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
-} ioc_diag_mode;
-
-/** @} */ /* end of lnx_ioctl_ncsw_grp */
-
-
-#endif /* __IOCTLS_H__ */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
deleted file mode 100644
index 25d6c8d..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/net_ioctls.h
+++ /dev/null
@@ -1,365 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**************************************************************************//**
- @File          net_ioctls.h
-
- @Description   This file contains common and general netcomm headers definitions.
-*//***************************************************************************/
-#ifndef __NET_IOCTLS_H
-#define __NET_IOCTLS_H
-
-#include "ioctls.h"
-
-
-typedef uint8_t ioc_header_field_ppp_t;
-
-#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
-#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
-#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_pppoe_t;
-
-#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
-#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
-#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
-#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
-#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
-#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
-#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
-#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
-
-#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
-#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
-
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
-#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
-
-
-typedef uint8_t ioc_header_field_eth_t;
-
-#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
-#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
-#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
-#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
-#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
-#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
-#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
-
-
-typedef uint16_t ioc_header_field_ipv4_t;
-
-#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
-#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
-#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
-#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
-#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
-#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
-#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
-#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
-#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
-#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
-#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
-#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
-#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
-#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
-#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
-#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
-
-
-typedef uint8_t ioc_header_field_ipv6_t;
-
-#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
-#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
-#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
-#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
-#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
-#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
-#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
-#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
-
-#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
-#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
-#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
-#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
-#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
-#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
-
-#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
-#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
-#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
-#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
-#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
-
-
-typedef uint16_t ioc_header_field_tcp_t;
-
-#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
-#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
-#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
-#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
-#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
-#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
-#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
-#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
-#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
-
-
-typedef uint8_t ioc_header_field_sctp_t;
-
-#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
-#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
-
-
-typedef uint8_t ioc_header_field_dccp_t;
-
-#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
-#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_udp_t;
-
-#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
-#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
-#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
-#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
-#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
-
-#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
-#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
-#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
-#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
-#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
-#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
-
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
-#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
-#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
-#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
-#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
-#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
-#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
-#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
-#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
-#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
-#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
-#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
-#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
-
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
-#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
-
-
-typedef uint8_t ioc_header_field_vlan_t;
-
-#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
-#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
-#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
-#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
-#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
-#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 5)
-#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
-
-
-typedef uint8_t ioc_header_field_llc_t;
-
-#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
-#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
-#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
-#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
-
-#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
-#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_snap_t;
-
-#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
-#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
-#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_llc_snap_t;
-
-#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
-#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
-
-#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
-#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
-#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
-#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
-#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
-#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
-#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
-#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
-#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
-#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
-
-#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
-#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
-#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
-#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
-#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
-#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
-#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
-
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
-#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
-
-#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
-#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
-#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
-#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
-#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
-
-
-typedef uint8_t ioc_header_field_gre_t;
-
-#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
-#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_minencap_t;
-
-#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
-#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
-#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
-#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
-
-
-typedef uint8_t ioc_header_field_ipsec_ah_t;
-
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
-#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
-
-
-typedef uint8_t ioc_header_field_ipsec_esp_t;
-
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
-#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
-
-
-typedef uint8_t ioc_header_field_mpls_t;
-
-#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
-#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
-
-
-typedef enum {
-    e_IOC_NET_HEADER_TYPE_NONE = 0,
-    e_IOC_NET_HEADER_TYPE_PAYLOAD,
-    e_IOC_NET_HEADER_TYPE_ETH,
-    e_IOC_NET_HEADER_TYPE_VLAN,
-    e_IOC_NET_HEADER_TYPE_IPv4,
-    e_IOC_NET_HEADER_TYPE_IPv6,
-    e_IOC_NET_HEADER_TYPE_TCP,
-    e_IOC_NET_HEADER_TYPE_UDP,
-    e_IOC_NET_HEADER_TYPE_IPHC,
-    e_IOC_NET_HEADER_TYPE_SCTP,
-    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
-    e_IOC_NET_HEADER_TYPE_PPPoE,
-    e_IOC_NET_HEADER_TYPE_PPP,
-    e_IOC_NET_HEADER_TYPE_PPPMUX,
-    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
-    e_IOC_NET_HEADER_TYPE_L2TPv2,
-    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
-    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
-    e_IOC_NET_HEADER_TYPE_LLC,
-    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
-    e_IOC_NET_HEADER_TYPE_NLPID,
-    e_IOC_NET_HEADER_TYPE_SNAP,
-    e_IOC_NET_HEADER_TYPE_MPLS,
-    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
-    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
-    e_IOC_NET_HEADER_TYPE_GRE,
-    e_IOC_NET_HEADER_TYPE_MINENCAP,
-    e_IOC_NET_HEADER_TYPE_DCCP,
-    e_IOC_NET_HEADER_TYPE_ICMP,
-    e_IOC_NET_HEADER_TYPE_IGMP,
-    e_IOC_NET_HEADER_TYPE_ARP,
-    e_IOC_NET_HEADER_TYPE_RFC2684,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
-    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM3,
-    MAX_e_IOC_NET_HEADER_TYPE_COUNT
-} ioc_net_header_type;
-
-
-#endif /* __NET_IOCTLS_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
index 6c0ca4e..39ca94c 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
@@ -187,7 +187,7 @@ typedef enum e_SysModule
     e_SYS_SUBMODULE_SRIO_MU,
     e_SYS_SUBMODULE_SPI_CTRL,
     e_SYS_SUBMODULE_ETSEC,
-    e_SYS_SUBMODULE_USB,
+    e_SYS_SUBMODULE_USB_CTRL,
     e_SYS_SUBMODULE_UCC_GETH,
     e_SYS_SUBMODULE_UCC_ATM_COMMON,
     e_SYS_SUBMODULE_UCC_ATM_AAL2_COMMON,
@@ -272,47 +272,6 @@ typedef enum e_SysModule
 } e_SysModule;
 
 /**************************************************************************//**
- @Function      SYS_GetHandle
-
- @Description   Returns a specific object handle.
-
-                This routine may be used to get the handle of any module or
-                sub-module in the system.
-
-                For singleton objects, it is recommended to use the
-                SYS_GetUniqueHandle() routine.
-
- @Param[in]     module  - Module/sub-module type.
- @Param[in]     id      - For sub-modules, this is the unique object ID;
-                          For modules, this value must always be zero.
-
- @Return        The handle of the specified object if exists;
-                NULL if the object is not known or is not initialized.
-*//***************************************************************************/
-t_Handle SYS_GetHandle(e_SysModule module, uint32_t id);
-
-/**************************************************************************//**
- @Function      SYS_GetUniqueHandle
-
- @Description   Returns a specific object handle (for singleton objects).
-
-                This routine may be used to get the handle of any singleton
-                module or sub-module in the system.
-
-                This routine simply calls the SYS_GetHandle() routine with
-                the \c id parameter set to zero.
-
- @Param[in]     module - Module/sub-module type.
-
- @Return        The handle of the specified object if exists;
-                NULL if the object is not known or is not initialized.
-*//***************************************************************************/
-static __inline__ t_Handle SYS_GetUniqueHandle(e_SysModule module)
-{
-    return SYS_GetHandle(module, 0);
-}
-
-/**************************************************************************//**
  @Description   System Object Descriptor
 
                 This is the generic object descriptor for the system layout.
@@ -404,7 +363,7 @@ typedef struct t_SysSubModuleDescriptor
 #define SYS_NULL_OBJECT_ID          0xFFFFFFFF
                                     /**< Object ID representing no object */
 
-#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)(_id))
+#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)((uint32_t)_id))
                                     /**< Macro for casting an object ID to a handle */
 #define CAST_HANDLE_TO_ID(_h)       ((uint32_t)(_h))
                                     /**< Macro for casting a handle to an object ID */
@@ -635,6 +594,71 @@ void SYS_Free(void);
 *//***************************************************************************/
 int SYS_RunLayout(t_SysUseCaseLayout *p_UcLayout);
 
+/**************************************************************************//**
+ @Function      SYS_GetHandle
+
+ @Description   Returns a specific object handle.
+
+                This routine may be used to get the handle of any module or
+                sub-module in the system.
+
+                For singleton objects, it is recommended to use the
+                SYS_GetUniqueHandle() routine.
+
+ @Param[in]     module  - Module/sub-module type.
+ @Param[in]     id      - For sub-modules, this is the unique object ID;
+                          For modules, this value must always be zero.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+t_Handle SYS_GetHandle(e_SysModule module, uint32_t id);
+
+/**************************************************************************//**
+ @Function      SYS_GetUniqueHandle
+
+ @Description   Returns a specific object handle (for singleton objects).
+
+                This routine may be used to get the handle of any singleton
+                module or sub-module in the system.
+
+                This routine simply calls the SYS_GetHandle() routine with
+                the \c id parameter set to zero.
+
+ @Param[in]     module - Module/sub-module type.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+static __inline__ t_Handle SYS_GetUniqueHandle(e_SysModule module)
+{
+    return SYS_GetHandle(module, 0);
+}
+
+/**************************************************************************//**
+ @Function      SYS_CreateObject
+
+ @Description   Initializes a module or sub-module using the information
+                provided in the object descriptor.
+
+ @Param[in]     p_ObjectDesc - Object descriptor.
+
+ @Return        E_OK in case of success; error code otherwise.
+*//***************************************************************************/
+t_Error SYS_CreateObject(t_SysObjectDescriptor *p_ObjectDesc);
+
+/**************************************************************************//**
+ @Function      SYS_FreeObject
+
+ @Description   Frees a module or sub-module.
+
+ @Param[in]     module  - Module/sub-module type.
+ @Param[in]     id      - For sub-modules, this is the unique object ID;
+                          For modules, this value must always be zero.
+
+ @Return        E_OK in case of success; error code otherwise.
+*//***************************************************************************/
+t_Error SYS_FreeObject(e_SysModule module, uint32_t id);
 
 /**************************************************************************//**
  @Function      USER_BuildLayout
@@ -803,16 +827,6 @@ t_Error SYS_ForceHandle(e_SysModule module, uint32_t id, t_Handle h_Module);
 *//***************************************************************************/
 void SYS_RemoveForcedHandle(e_SysModule module, uint32_t id);
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-t_Error SYS_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod);
-t_Error SYS_UnregisterMessageHandler (char *p_Addr);
-t_Error SYS_SendMessage(char                 *p_DestAddr,
-                        uint32_t             msgId,
-                        uint8_t              msgBody[MSG_BODY_SIZE],
-                        t_MsgCompletionCB    *f_CompletionCB,
-                        t_Handle             h_CBArg);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
-
 /** @} */ /* end of sys_mod_grp */
 /** @} */ /* end of sys_grp */
 
@@ -867,6 +881,16 @@ t_Error SYS_SendMessage(char                 *p_DestAddr,
                          ("Number of advanced-configuration entries exceeded")); \
     } while (0)
 
+#define ADD_ADV_CONFIG_FIND_LOCATION(_func)                                     \
+    for (i=0; TRUE; i++) {                                                      \
+        if (i == max)                                                           \
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,                                \
+                         ("Number of advanced-configuration entries exceeded"));\
+        p_Entry = &p_Entrys[i];                                             \
+        if (!p_Entry->p_Function || (p_Entry->p_Function == _func))         \
+            break;                                                          \
+    }                                                                       \
+
 #define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)           \
     {                                                           \
         t_SysObjectAdvConfigEntry   *p_Entry;                   \
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
index ae065eb..3659c96 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -46,6 +46,7 @@
 #include "fm_pcd_ext.h"
 #include "fm_port_ext.h"
 #include "fm_mac_ext.h"
+#include "fm_rtc_ext.h"
 
 
 /**************************************************************************//**
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
index cf50478..ddfcc1f 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/platform/P4080/platform_p4080_ds.c
@@ -71,6 +71,13 @@ typedef struct t_Platform
     uint32_t                localBusFreqHz;
 } t_Platform;
 
+
+uint32_t ram_virt_addr;
+uint32_t ram_phys_addr;
+uint32_t ram_size;
+
+
+
 /*---------------------------------------------------------------------------*/
 /*                       P4080-MDS Platform Init                             */
 /*---------------------------------------------------------------------------*/
@@ -89,6 +96,15 @@ t_Handle PLATFORM_Init(t_PlatformParam *p_PlatformParam)
     }
     memset(p_Platform, 0, sizeof(t_Platform));
 
+    ram_virt_addr = (uint32_t)phys_to_virt(0);
+    ram_phys_addr = 0x0;
+    ram_size      = 0x20000000;
+    if (SYS_RegisterIoMap((uint64_t)ram_virt_addr, (uint64_t)ram_phys_addr, ram_size) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("RAM memory map"));
+        return NULL;
+    }
+
     return p_Platform;
 }
 
@@ -100,6 +116,8 @@ t_Error PLATFORM_Free(t_Handle h_Platform)
     if (!p_Platform)
         RETURN_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
 
+    SYS_UnregisterIoMap((uint64_t)ram_virt_addr);
+
     XX_Free(p_Platform);
 
     return E_OK;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
index 82cf0aa..8fe6034 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/system/sys_io.c
@@ -120,7 +120,17 @@ static t_IoMap * FindIoMapByPhysAddr(uint64_t addr)
     {
         p_IoMap = IOMAP_OBJECT(p_Pos);
         if ((addr >= p_IoMap->physAddr) && (addr < p_IoMap->physAddr+p_IoMap->size))
+        {
+            /* This is optimization - put the latest in the list-head - like a cache */
+            if (mapsList.p_Next != &p_IoMap->node)
+            {
+                uint32_t intFlags = XX_DisableAllIntr();
+                LIST_DelAndInit(&p_IoMap->node);
+                LIST_Add(&p_IoMap->node, &mapsList);
+                XX_RestoreAllIntr(intFlags);
+            }
             return p_IoMap;
+        }
     }
 
     return NULL;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
index 9c69110..73354b9 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/Makefile
@@ -12,4 +12,4 @@ EXTRA_CFLAGS += -I$(NET_DPA)
 obj-y		+= fsl-ncsw-PFM.o
 obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
 
-fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o firmware.o
+fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
deleted file mode 100644
index 54c3771..0000000
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/firmware.S
+++ /dev/null
@@ -1,4 +0,0 @@
-	.section .firmware,"a"
-	.globl p4080_fman_firmware
-p4080_fman_firmware:
-	.incbin "../linux/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin"
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
index 5325b82..b81ce57 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
@@ -97,6 +97,7 @@ typedef struct {
     uint8_t             id;
     ioc_fmt_port_type   portType;
     ioc_diag_mode       diag;
+    bool                echo;
     bool                ip_header_manip;
     struct fm_port      *p_TxPort;
     t_Handle            h_TxFmPortDev;
@@ -439,7 +440,8 @@ bool is_fman_test (void     *mac_dev,
         if (!p_FmTestPort)
             return false;
 
-        XX_Free(buffer);
+        if(buffer!=NULL)
+            XX_Free(buffer);
         return true;
     }
 
@@ -462,15 +464,26 @@ bool is_fman_test (void     *mac_dev,
         temp_buf++;
     }
 
-    if (fman_test_flag)
+    if (fman_test_flag /*|| p_FmTestPort->echo*/)
     {
         DBG(TRACE, ("Port %d got FMUC frame\n", p_FmTestPort->id));
         dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_RxFmPortDev);
+
         p_FmTestFrame = (t_FmTestFrame *)XX_Malloc(sizeof(t_FmTestFrame));
+        /* dump frame... no more space left on device */
+        if(p_FmTestFrame == NULL) 
+            return false;
+
         memset(p_FmTestFrame, 0, sizeof(t_FmTestFrame));
         INIT_LIST(&p_FmTestFrame->node);
 
         p_FmTestFrame->buff.p_data = (uint8_t *)XX_Malloc(size * sizeof(uint8_t));
+        /* No more space left on device*/
+        if(p_FmTestFrame->buff.p_data == NULL){
+            XX_Free(p_FmTestFrame);
+            return false;
+        }
+
         p_FmTestFrame->buff.size = size-dataOffset;
         p_FmTestFrame->buff.qid = queueId;
 
@@ -661,6 +674,15 @@ static int fm_test_ioctl(struct inode *inode, struct file *file, unsigned int cm
             break;
         }
 
+        case FMT_PORT_IOC_SET_DPAECHO_MODE:
+        {
+            if (get_user(p_FmTestPort->echo, (int *)arg)) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+            break;
+        }
+
         case FMT_PORT_IOC_SET_IP_HEADER_MANIP:
         {
             if (get_user(p_FmTestPort->ip_header_manip, (int *)arg)) {
@@ -682,7 +704,7 @@ ssize_t fm_test_read (struct file *file, char __user *buf, size_t size, loff_t *
 {
     t_FmTestPort        *p_FmTestPort;
     t_FmTestFrame       *p_FmTestFrame;
-    ssize_t             cnt;
+    ssize_t             cnt = 0;
 
     p_FmTestPort = file->private_data;
     if (!p_FmTestPort || !p_FmTestPort->valid)
@@ -692,31 +714,81 @@ ssize_t fm_test_read (struct file *file, char __user *buf, size_t size, loff_t *
     if (!p_FmTestFrame)
         return 0;
 
-    cnt = sizeof(ioc_fmt_buff_desc_t);
-    if (size<cnt) {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
-        return 0;
-    }
-    if (copy_to_user(buf, &p_FmTestFrame->buff, cnt)) {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
-        return 0;
-    }
+    if (!p_FmTestPort->echo) {
+        cnt = sizeof(ioc_fmt_buff_desc_t);
+        if (size<cnt) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+            return 0;
+        }
+        if (copy_to_user(buf, &p_FmTestFrame->buff, cnt)) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return 0;
+        }
 
-    ((ioc_fmt_buff_desc_t *)buf)->p_data = buf+sizeof(ioc_fmt_buff_desc_t);
+        ((ioc_fmt_buff_desc_t *)buf)->p_data = buf+sizeof(ioc_fmt_buff_desc_t);
 
-    cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
-    if (size<cnt) {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
-        return 0;
-    }
+        cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
+        if (size<cnt) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+            return 0;
+        }
 
-    if (copy_to_user(buf+sizeof(ioc_fmt_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
-        return 0;
+        if (copy_to_user(buf+sizeof(ioc_fmt_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return 0;
+        }
+
+        XX_Free(p_FmTestFrame->buff.p_data);
+        XX_Free(p_FmTestFrame);
     }
+    else {
+        uint8_t  *p_Data = NULL;
+        uint32_t frameSize =0;
+        t_DpaaFD fd;
+        int      _errno = 0;
+
+        p_Data = (uint8_t *)p_FmTestFrame->buff.p_data;
+        frameSize = p_FmTestFrame->buff.size;
+        /* paranoia ...*/
+        if(!p_Data){
+            XX_Free(p_FmTestFrame);
+            return 0;
+        }
 
-    XX_Free(p_FmTestFrame->buff.p_data);
-    XX_Free(p_FmTestFrame);
+        /* Debug routine 
+        { int k;
+          printk("\n#FRAME DUMP -->\n");
+            printk("  FRAME Size=%u \n",frameSize);
+            printk("  FRAME dataOffset=%u \n",dataOffset);
+            for(k=0;k<frameSize;k++)
+                printk("%x ",p_Data[k]);
+            printk("\n\n");
+        }*/
+
+        /* Set frame descriptor... */
+        memset(&fd, 0, sizeof(fd));
+        DPAA_FD_SET_ADDR(&fd, p_Data);
+        DPAA_FD_SET_OFFSET(&fd, 0);
+        DPAA_FD_SET_LENGTH(&fd, frameSize);
+
+        /* Enqueue frame... */
+        _errno = qman_enqueue(p_FmTestPort->p_TxFqs[0], (struct qm_fd*)&fd, 0);
+        if (_errno) {
+            XX_Free(p_FmTestFrame);
+            XX_Free(p_Data);
+            return 0;
+        }
+
+        XX_Free(p_FmTestFrame);
+    }
 
     return cnt;
 }
@@ -725,7 +797,7 @@ ssize_t fm_test_write (struct file *file, const char __user *buf, size_t size, l
 {
     t_FmTestPort        *p_FmTestPort;
     ioc_fmt_buff_desc_t buffDesc;
-    t_FmFD              fd;
+    t_DpaaFD            fd;
     uint8_t             *p_Data;
     uint32_t            dataOffset;
     int                 _errno;
@@ -757,9 +829,9 @@ ssize_t fm_test_write (struct file *file, const char __user *buf, size_t size, l
     }
 
     memset(&fd, 0, sizeof(fd));
-    FM_FD_SET_ADDR(&fd, p_Data);
-    FM_FD_SET_OFFSET(&fd, dataOffset);
-    FM_FD_SET_LENGTH(&fd, buffDesc.size);
+    DPAA_FD_SET_ADDR(&fd, p_Data);
+    DPAA_FD_SET_OFFSET(&fd, dataOffset);
+    DPAA_FD_SET_LENGTH(&fd, buffDesc.size);
 
     DBG(TRACE, ("buffDesc qId %d, fqid %d, frame len %d, fq 0x%8x\n",
                 buffDesc.qid, qman_fq_fqid(p_FmTestPort->p_TxFqs[buffDesc.qid]), buffDesc.size,p_FmTestPort->p_TxFqs[buffDesc.qid]));
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fsl_fman_ucode_p4080_91_1.bin
deleted file mode 100644
index b3cbcec31ce5ec50bf82c36c2442f3a534214532..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 6576
zcmcIo4QyLi6+Z91o0n@ROP?J#b;ycenzT)SC@I?{S6zr5Ct2II*#;C!w`!q3qNswc
z7%8sQuxt|u#1NIXK~*+wXqzU1CJmMiBU*5N+Ld$&(~at7?;(<=>jdWK1w6@F)|u~K
z+o{*Ou!&*y_W7Of-gD3YISx_d^LO<0D!1R*9&R^#zx;)-m|y<Vp0D1s=bpX$=>30`
zMXvJxcNcg5k9Ypp`^=%z7JVJQW$#o9GX6YIb#x~wcsA$p!825RexmTyeq4Ae&lR3*
zKs*nrIXc9!bS#eL#j3@s!!oe^SOKgCtRU7$u&&4YXpRQ%%c)oz7Q@ni79w_ta?}>e
zQNr_%KS6VJobq`)l{zsqLbZP$X-~v=*U$iwvMxlb*po?-a_^L)tm`bi7x#T_W|W4+
z-gTjTPV8fp4(fq)yWWrv>x{S_B(leSCys|nfA}K#hJ&Q&EX7~Q=jZicijD`d$4DE)
zJ4l`PwbI&lQ_3WC7N3S-+E^RDOq&l(k<O=R+osdB?rvq5xU;ac@P854i}?1d@WoTa
zaDHpy{I;v{3&hwI^>s`BJy+uw%khq@@P_k(zh2~j)75y9|G4D;v8(YS{{p`JYFx^1
zY&|W{FRh5PDW#7|d~rpbPkFX-iC=dOytc@{suB+S*KU*d)1^wdw4aop-l~WT`^fw0
zZ<X-OI4yGTiUo75w|!G#-%M%We8UtKabAYo3-}V)mrtn$`_msv^iqt>FOmMC;{Ct9
z2F?ol)5&Y#yojHugu_0pXrC7=;gGNBKYFerzTiK4rXs%JKYIKcc+r3KXeGSNf8VWy
zm-+7-74ggd8?1y^@L#;NPuRbL{|;Qn5&sMMN&8Cl%l?yi$-ld<fm6{x+pommxGPWd
zf%9~F$N5rhZ7ttZz%P{J-B;rm%ki7b@!#!@jaaw6nv1`&Hb6XK&a(?QTbs@&UdYqx
z(>u1bUx|a>c7~rnyr3WUm&vxgoVVB`_zB)+d#*3vBl3gT6wjO?<FBoxq!T-|7xM2u
zA!@NaU%;!cz<*G}i}_Yv;wfY<(qtd7Hm9zr>+c?U_~N@i91gzw9X*&Pc3s+FN}9WO
z)swqTBfpZiSlxc+?yRAJn!fN<Ub)fjd(i8r^jWu0Blq?i0&R)Avz{C?7as1UDnWlL
zPk(o})e!olt}5xXc)uj*e!AD|9~z>}NIOlVR~@FDg1*%;o6@v+e+^~ENO5<9FV4Ds
z^@7i^UrWCxWK${q8mmnkznmhEyYs-2Op1Zueggm3{(=5B8Kp4%p+UCS{Gt8C>iU`P
z-Oq9Eb<iBpR7U;eMr?7$%8V-HEaS=NL)3u2cR}dwSFlG(*Q)A%nvHtu?2(~evm;(U
zIm#2j<hg9LMww7@k%QCM(e~9uQr@k?4)i%8GkWZLVSg38+^AO(JP+hA$-Uy<tfZwa
ze0Kyd*w|5<)6Vfu3W9d7NIM7GIncb%=ILX?_W{UQcGu0tyL{p<ciRC&=qL1s9L+*+
zv0vzpUVT#NpBW*t4)}Ax8?6a%67*k-J;JtvFH^_>wu7l0{>D3zkr^denV5<p=$HNE
znI5IvXCpOQCe?1*BgWu#ifXMWC1z4XB>cCw(~$i?Gon3Yry`f!sE^~h^sq8lWsmd^
zT3tL5-%~^7?*m_`p#+=9oH4Y^X{N;S&iq^Ucx3R+RQ?^|(<ky-Qmg1JVuLv?ZMox^
zf3iI-%#E!f3@m5;Rdi0(D9sd3_Q_=@tk@ml3HElxjoPF$gWOmRS^GRWdu;Ael^fg|
zU!Qc^wuF-*^0|>UN1V;ku(QQHwBXYfZDjTEoUR*`?XFSWSp8*xuK+*z3~_dyU!in%
zOIa-7oU^J6@)L5Fs{A2Ji@jD%#15sU9+0=7hbi<>-B^pz;hd@$<sV-*X!UN&O=xf9
z9-G|WCaHs}7~DQJ_o%h6F(>73jwB%eA~(`<#M#7i&gS5T3Cx5Cr>bbXZj#kaiEK<$
zgbqT6%NQ3qS(V+amC;PZY`#szk?^-0ZK@M~R__ne&;OLq%kzkLKi)+g{CbFZ<rs*(
zCk9lNy!MDW2)m|mj$2*9gz)c+_mRgjdAMXJ%%<c-jIa}<u#gk-sW?Lgdl_fdZ$M_q
z0Uy`GPF`n4V{$k|)q<xJX%AaCXQ#}?!sg<<6Kj|6@_VZi7V+Z8kP4iMyZqoM=3&WS
z@Km`4TOm$)hoAWC*)9z=DHw1g^@?ip*OQ&ZCNRIlHi}>6uZweqoM|DZnFealBBq#}
z)Zo)@tf_ypi=<4DPepEoky9%IWMY;Uc~*nG;)d$sM>D74bCo#LP(wD~ApM+q89BOd
zePSAzHNGM2#t;M1rpG?j3fpV^v0pt%ED++gYda${&s5Fe?&cQ5X>BaoQ}c)TQ9t8H
zpUo@vqHYxHvIZZ&Dt!EGKL2|`7xJ*Wv_W+5({5i)zpx=zhZWUwnUpr<M!v+!Odmr{
z_b^}j5%)IqguW(n??7$d*&^!9X<<+JYtdmsey937tZft?=+`LWo2TPG5_i5S>ytQB
zI$t>Z3vpI86DsokO_dV#Rzw{_oq9~l6VVI<atZpchR{>)Ku_qCHTIjL*MP5_y-GSr
zdHd@74{LK(Zp6dwF~|bjUm?p|LKewi$OBy#bnen}xJ#8XLO#?*E@A{ae$NP{j}09B
zHfo+Wgcve}UH*f<Ke>j!gJt^8egJ*96!kqQ_?E|zh#i#~Uc^AHv$x=X*hT)1gWQk!
zHGZ_r_b-X_@cnSf_oY~TWh63fk3=4y9P@?U$i^pUPNF}LYTr7n!<Jo*s5||rsYWus
zx1J8GIVCfO-aSUO_UK5*<Ty{VZ-!-lIxFUq$Y~w%c_i>am}bZ8wfOEP5g#5&Q`;py
zlTx+GaSF%#n-+e<#@|?_TtlC6Avg5tze1k}iuw!*ee6`UV`fatPj&}$qTfu8QO=ES
ze3CKFr9P>mJ|Z?w6=Ea4M?*h1j;hE_)HuVDy+_t=<d9kGSIk;Q#u0XZQNO}`;|bvX
zup;M{rQ$cXkbOmG{@8%R#oq<gz))D$u9EE$Ga7OobFukIKrtVoD)U(8ltOBap*p>*
z6HE&d>NKD5%%fM?<Q&+Y`00IAXGK>hvs;^#2`!g8II|RW{dRJ<Hc{pzYQz`O2TrX@
zHsGA!W2m^pYlO^W*;}vJA8S(lAw#u#f=NR)j|rLJqgtoUD`qwCE2kqrg7243j#3iw
z{jDqWC%#*gx}a!1O&UF;R`a87B-StL4eH`2Grz%*5Td6sI}pAr3qALiCShA|=9H*s
zjS2Luu(Q%5dS0Cq4JWh9>LbsGNXJYPInasOh(!oGtTq&SCfik`7%Dv@=PS@*(^k>{
zoalyJcIC#xxv}@0yWW6o_RHojC$=FedX7;IKDT^Ynb6-(S(|u5^udFF*)H!<TMaLC
zU*xoYK0J&*lD!rEUCj+0Jiiz==0XlG_z8Wp-Sz0-W=_19aCdXTCNdZAszDLss12k!
zrXlzR#tAy3pScl@J&|WZeukxEaV#(9<>g|&!gmkidS&sujybPM#4_j_=(-!l45p-w
znG}6yZ8OPwFZ+ce`<N0?P$A3yrc;myXBhq|#NBR<>u5sY!yE9_Ra4Y#wLvZPzw)!C
z`R_e<RdJRX^U-XNq1oqCkHg=GMBX1?PSMP$?;XqtwefxRG_boKl@s;8iyCK78fF0V
zBW6f~@2lM|o3blzsD{0(As3$+&AXUsl*w)*IXN0k21Ng>0)0H>3Rx$6O!V$2m*O`j
zS$mX(HQF3Lc=0CM-YVyobLhdsKOW$V2lg~kLdV=V>KnA8s}cdd%|QQUZdbkHEHjfY
z-j~l6<=FEf%P}nUpFJ6jNE_^_CsxgQQMN^x??U$78%{W}_2DyYj_g~SbC41Js5y}t
z_YtdVGwf5o6Vv0EoqL<Z@qH~MWnMX#LofU%(_r_KeZjlTzTcl6`@h=v>&Qz5_2HB7
z@rnf*;Nvp8^ABM6kAKK^|7_+I?B26FKYfa7#jJ!_s6+0--m5yCh?zWtJhpp$3HxQ^
zgcUWC+3pqtf4}Tts$p0$*m^f?ealA0Sw5G5t^b9PWbytRL@sthcNH<-f!I=^|MGJE
zWy~S=K7j5^K4jgO{J(S;^DOd&zob%VwyUW#Gpdq3W?T}nE&9HUKm0x$W>h6GK`+r}
zyM2r7(V@p-_Y`6zZ;uAwVLE4L(6bQxk=b4!Xab+3KmIA0oQ$>QWbTg{(pPipjb;G*
z(WepfbR^kID+Pb#&_klu#P=5ZowWZL8S-9{^Cx9Kg#)^2Aa|JCvj#qG#BYm*oWJcu
zw*SX7WBEK{?xD%<#^m(NkP$sy#-Ggh^@C1qRUzMdo0InGf_&MYH3noIWXv?Iu2qTn
z-ZkWIiYbLz3Gs(o8Q;CJWdDW_R5vwIPf<4+>SoL+)J?>wwU6){(MZa=xr`V3_gde`
FzX7Q^O)3BY

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 9096290..10ed3ee 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -63,6 +63,7 @@
 #include <asm/qe.h>        /* For struct qe_firmware */
 #include <sysdev/fsl_soc.h>
 #include <asm/kexec.h>
+#include <linux/stat.h>	   /* For file access mask */
 
 /* NetCommSw Headers --------------- */
 #include "std_ext.h"
@@ -95,404 +96,834 @@
 
 static t_LnxWrpFm   lnxWrpFm;
 
+typedef enum e_FmDmaMatchStatistics {
+    e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+    e_FM_DMA_COUNTERS_BUS_ERROR,
+    e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+    e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+    e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR
+}e_FmDmaMatchStatistics;
+
+/* FM PORT STATISTICS */
+typedef struct{
+    const char *statisticName;
+    uint8_t statisticCounter;
+}t_SysfsStats;
+
+static const t_SysfsStats fmSysfsStats[] = {
+    /* FM statistics */
+    {
+        .statisticName = "enq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "deq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_DEQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "deq_0",
+        .statisticCounter = e_FM_COUNTERS_DEQ_0,
+    },
+    {
+        .statisticName = "deq_1",
+        .statisticCounter = e_FM_COUNTERS_DEQ_1,
+    },
+    {
+        .statisticName = "deq_2",
+        .statisticCounter = e_FM_COUNTERS_DEQ_2,
+    },
+    {
+        .statisticName = "deq_from_default",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_DEFAULT,
+    },
+    {
+        .statisticName = "deq_from_context",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_CONTEXT,
+    },
+    {
+        .statisticName = "deq_from_fd",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_FD,
+    },
+    {
+        .statisticName = "deq_confirm",
+        .statisticCounter = e_FM_COUNTERS_DEQ_CONFIRM,
+    },
+    /* FM:DMA  statistics */
+    {
+        .statisticName = "cmq_not_empty",
+        .statisticCounter = e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+    },
+    {
+        .statisticName = "bus_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_BUS_ERROR,
+    },
+    {
+        .statisticName = "read_buf_ecc_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+    },
+    {
+        .statisticName = "write_buf_ecc_sys_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+    },
+    {
+        .statisticName = "write_buf_ecc_fm_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR,
+    },
+    /* FM:PCD  statistics */
+    {
+        .statisticName = "pcd_enq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "pcd_kg_total",
+        .statisticCounter = e_FM_PCD_KG_COUNTERS_TOTAL,
+    },
+    {
+        .statisticName = "pcd_plcr_yellow",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_YELLOW,
+    },
+    {
+        .statisticName = "pcd_plcr_red",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RED,
+    },
+    {
+        .statisticName = "pcd_plcr_recolored_to_red",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,
+    },
+    {
+        .statisticName = "pcd_plcr_recolored_to_yellow",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,
+    },
+    {
+        .statisticName = "pcd_plcr_total",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_TOTAL,
+    },
+    {
+        .statisticName = "pcd_plcr_length_mismatch",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,
+    },
+    {
+        .statisticName = "pcd_prs_parse_dispatch",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,
+    },
+    {
+        .statisticName = "pcd_prs_l2_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l3_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l4_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_shim_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l2_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_l3_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_l4_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_shim_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_soft_prs_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_soft_prs_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_hard_prs_cycle_incl_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_read_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_read_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_write_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_write_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_fpm_command_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES,
+    },
+    {}
+};
 
-static int fm_proc_dump_stats(char *buffer, char **start, off_t offset,
-                              int length, int *eof, void *data)
+static const t_SysfsStats portSysfsStats[] = {
+    /* RX/TX/OH common statistics */
+    {
+        .statisticName = "port_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_FRAME,
+    },
+    {
+        .statisticName = "port_discard_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_DISCARD_FRAME,
+    },
+    {
+        .statisticName = "port_dealloc_buf",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEALLOC_BUF,
+    },
+    {
+        .statisticName = "port_enq_total",
+        .statisticCounter = e_FM_PORT_COUNTERS_ENQ_TOTAL,
+    },
+    /* TX/OH */
+    {
+        .statisticName = "port_length_err",
+        .statisticCounter = e_FM_PORT_COUNTERS_LENGTH_ERR,
+    },
+    {
+        .statisticName = "port_unsupprted_format",
+        .statisticCounter = e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,
+    },
+    {
+        .statisticName = "port_deq_total",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_TOTAL,
+    },
+    {
+        .statisticName = "port_deq_from_default",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,
+    },
+    {
+        .statisticName = "port_deq_confirm",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_CONFIRM,
+    },
+    /* RX/OH */
+    {
+        .statisticName = "port_rx_bad_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_BAD_FRAME,
+    },
+    {
+        .statisticName = "port_rx_large_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_LARGE_FRAME ,
+    },
+    {
+        .statisticName = "port_rx_out_of_buffers_discard",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,
+    },
+    {
+        .statisticName = "port_rx_filter_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_FILTER_FRAME,
+    },
+    /* TODO: Particular statistics for OH ports */
+    {}
+};
+
+static uint8_t find_fm_statistic_counter_by_name(const char *attr_name, t_SysfsStats *sysfs_stats, uint8_t *offset)
 {
-    t_LnxWrpFmDev               *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
-    t_FmDmaStatus               fmDmaStatus;
-    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    int i = 0;
+
+    while(sysfs_stats[i].statisticName != NULL)
+    {
+        if(strcmp(sysfs_stats[i].statisticName, attr_name) == 0){
+            if(offset != NULL)
+                *offset = i;
+            return sysfs_stats[i].statisticCounter;
+        }
+
+        i++;
+    }
+    /* Should never get here! */
+    BUG();
+    return 0;
+}
+
+static ssize_t show_fm_port_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    t_LnxWrpFmDev               *p_LnxWrpFmDev     = NULL;
     unsigned long               flags;
-    int                         numOfWrittenChars;
+    int                         n = 0;
+    uint8_t                     counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    if (p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    if (p_LnxWrpFmDev == NULL)
+        BUG();
 
     if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    if (!p_LnxWrpFmPortDev->h_Dev)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
-        return 0;
+        n = snprintf( buf, PAGE_SIZE,
+            "\tFM Port not configured... \n");
+        return n;
     }
 
-    local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff, "FM driver statistics:\n");
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&portSysfsStats[0], NULL);
 
-    memset(&fmDmaStatus, 0, sizeof(fmDmaStatus));
-    FM_GetDmaStatus(p_LnxWrpFmDev->h_Dev, &fmDmaStatus);
-    ProcBuff_Write (h_ProcBuff,
-                    "\tFM DMA statistics:\n"
-                    "cmqNotEmpty: %c\n"
-                    "busError: %c\n"
-                    "readBufEccError: %c\n"
-                    "writeBufEccSysError: %c\n"
-                    "writeBufEccFmError: %c\n",
-                    fmDmaStatus.cmqNotEmpty ? "T" : "F",
-                    fmDmaStatus.busError ? "T" : "F",
-                    fmDmaStatus.readBufEccError ? "T" : "F",
-                    fmDmaStatus.writeBufEccSysError ? "T" : "F",
-                    fmDmaStatus.writeBufEccFmError ? "T" : "F"
-                    );
-    ProcBuff_Write (h_ProcBuff,
-                    "\tFM counters:\n"
-                    "e_FM_COUNTERS_ENQ_TOTAL_FRAME: %d\n"
-                    "e_FM_COUNTERS_DEQ_TOTAL_FRAME: %d\n"
-                    "e_FM_COUNTERS_DEQ_0: %d\n"
-                    "e_FM_COUNTERS_DEQ_1: %d\n"
-                    "e_FM_COUNTERS_DEQ_2: %d\n"
-                    "e_FM_COUNTERS_DEQ_FROM_DEFAULT: %d\n"
-                    "e_FM_COUNTERS_DEQ_FROM_CONTEXT: %d\n"
-                    "e_FM_COUNTERS_DEQ_FROM_FD: %d\n"
-                    "e_FM_COUNTERS_DEQ_CONFIRM: %d\n"
-                    "e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT: %d\n"
-                    "e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT: %d\n"
-                    "e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT: %d\n",
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_ENQ_TOTAL_FRAME),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_TOTAL_FRAME),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_0),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_1),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_2),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_FROM_DEFAULT),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_FROM_CONTEXT),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_FROM_FD),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_DEQ_CONFIRM),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT),
-                    FM_GetCounter(p_LnxWrpFmDev->h_Dev, e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT)
-                    );
-
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    if(counter == e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR){
+        uint32_t fmRev = 0;
+
+        fmRev = (uint32_t)(*CAST_UINT64_TO_POINTER_TYPE(volatile uint32_t, (p_LnxWrpFmDev->fmBaseAddr+0x000c30c4)) & 0xffff);
+        local_irq_save(flags);
+
+        if (fmRev == 0x0100)
+            n = snprintf( buf, PAGE_SIZE, "counter not available for revision 1\n");
+
+        local_irq_restore(flags);     
+        return n;
+    }
+
+    local_irq_save(flags);
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d Port %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            p_LnxWrpFmPortDev->id,
+            FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, (e_FmPortCounters)counter));
     local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
 
-    return numOfWrittenChars;
-}
+    return n;
+}
+
+/* FM PORT RX/TX/OH statistics */
+static DEVICE_ATTR(port_frame                       , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_discard_frame               , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_dealloc_buf                 , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_enq_total                   , S_IRUGO, show_fm_port_stats, NULL);
+/* FM PORT TX/OH statistics */
+static DEVICE_ATTR(port_length_err                  , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_unsupprted_format           , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_total                   , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_from_default            , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_confirm                 , S_IRUGO, show_fm_port_stats, NULL);
+/* FM PORT RX/OH statistics */
+static DEVICE_ATTR(port_rx_bad_frame                , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_large_frame              , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_out_of_buffers_discard   , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_filter_frame             , S_IRUGO, show_fm_port_stats, NULL);
+
+/* FM PORT TX statistics */
+static struct attribute *fm_tx_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    &dev_attr_port_length_err.attr,
+    &dev_attr_port_unsupprted_format.attr,
+    &dev_attr_port_deq_total.attr,
+    &dev_attr_port_deq_from_default.attr,
+    &dev_attr_port_deq_confirm.attr,
+    NULL
+};
+
+static const struct attribute_group fm_tx_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_tx_port_dev_stats_attributes
+};
+
+/* FM PORT RX statistics */
+static struct attribute *fm_rx_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    &dev_attr_port_rx_bad_frame.attr,
+    &dev_attr_port_rx_large_frame.attr,
+    &dev_attr_port_rx_out_of_buffers_discard.attr,
+    &dev_attr_port_rx_filter_frame.attr,
+    NULL
+};
+
+static const struct attribute_group fm_rx_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_rx_port_dev_stats_attributes
+};
+
+/* TODO: add particular OH ports statistics */
+static struct attribute *fm_oh_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    /*TX*/
+    &dev_attr_port_length_err.attr,
+    &dev_attr_port_unsupprted_format.attr,
+    &dev_attr_port_deq_total.attr,
+    &dev_attr_port_deq_from_default.attr,
+    &dev_attr_port_deq_confirm.attr,
+    /*RX*/
+    &dev_attr_port_rx_bad_frame.attr,
+    &dev_attr_port_rx_large_frame.attr,
+    &dev_attr_port_rx_out_of_buffers_discard.attr,
+    /*&dev_attr_port_rx_filter_frame.attr,*/
+    NULL
+};
+
+static const struct attribute_group fm_oh_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_oh_port_dev_stats_attributes
+};
 
-static int fm_pcd_proc_dump_stats(char *buffer, char **start, off_t offset,
-                                  int length, int *eof, void *data)
+static ssize_t show_fm_port_regs(struct device *dev, struct device_attribute *attr, char *buf)
 {
-    t_LnxWrpFmDev               *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
-    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
-    unsigned long               flags;
-    int                         numOfWrittenChars;
+    unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+#endif
 
-    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_PcdDev)
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM-PCD not initialized!"));
-        return 0;
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    local_irq_save(flags);
+
+    if (!p_LnxWrpFmPortDev->h_Dev){
+        n = snprintf( buf, PAGE_SIZE,
+            "\tFM Port not configured... \n");
+        return n;
     }
+    else{
+        n = snprintf(buf, PAGE_SIZE, "FM port driver registers dump.\n");
+        FM_PORT_DumpRegs(p_LnxWrpFmPortDev->h_Dev);
+    }
+
+    local_irq_restore(flags);
+
+    return n;
+#else
 
     local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff,
-                    "\tFM-PCD counters:\n"
-                    "e_FM_COUNTERS_ENQ_TOTAL_FRAME: %d\n"
-                    "e_FM_PCD_KG_COUNTERS_TOTAL: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_YELLOW: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_RED: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_TOTAL: %d\n"
-                    "e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES: %d\n"
-                    "e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES: %d\n",
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_COUNTERS_ENQ_TOTAL_FRAME),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_KG_COUNTERS_TOTAL),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_YELLOW),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_RED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_TOTAL),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES),
-                    FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES)
-                    );
-
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    n = snprintf(buf, PAGE_SIZE, "Debug level is too low to dump registers!!!\n");
     local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
 
-    return numOfWrittenChars;
+    return n;
+#endif
 }
 
-static void fm_tx_port_proc_dump_stats(t_Handle *h_ProcBuff,
-				t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+static DEVICE_ATTR(fm_port_regs,0x644,show_fm_port_regs,NULL);
+
+static int fm_port_sysfs_create(struct device *dev)
 {
-	t_LnxWrpFmDev *p_LnxWrpFmDev = (
-			t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
-	ProcBuff_Write(*h_ProcBuff, "\tFM %d TX Port %d counters:\n"
-#ifdef PERFORMANCE_COUNTERS
-	/* TODO: Initialize the performance counters from userspace... */
-		"e_FM_PORT_COUNTERS_CYCLE=%d\n"
-		"e_FM_PORT_COUNTERS_TASK_UTIL=%d\n"
-		"e_FM_PORT_COUNTERS_QUEUE_UTIL=%d\n"
-		"e_FM_PORT_COUNTERS_DMA_UTIL=%d\n"
-             	"e_FM_PORT_COUNTERS_FIFO_UTIL=%d\n"
-#endif
-		"e_FM_PORT_COUNTERS_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_DISCARD_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_DEALLOC_BUF=%d\n"
-		"e_FM_PORT_COUNTERS_LENGTH_ERR=%d\n"
-		"e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT=%d\n"
-		"e_FM_PORT_COUNTERS_DEQ_TOTAL=%d\n"
-		"e_FM_PORT_COUNTERS_ENQ_TOTAL=%d\n"
-		"e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT=%d\n"
-		"e_FM_PORT_COUNTERS_DEQ_CONFIRM=%d\n",
-		p_LnxWrpFmDev->id,
-		p_LnxWrpFmPortDev->id,
-#ifdef PERFORMANCE_COUNTERS
-	/* TODO: Initialize the performance counters from userspace... */
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_CYCLE),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_TASK_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_QUEUE_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DMA_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FIFO_UTIL),
-#endif
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DISCARD_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEALLOC_BUF),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_LENGTH_ERR),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_TOTAL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_ENQ_TOTAL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_CONFIRM));
-}
-
-static void fm_rx_port_proc_dump_stats(t_Handle *h_ProcBuff,t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
-{
-    t_LnxWrpFmDev *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
-
-    ProcBuff_Write(*h_ProcBuff,
-            "\tFM %d RX Port %d counters:\n"
-#ifdef PERFORMANCE_COUNTERS
-		/* TODO: Initialize the performance counters from userspace... */
-		"e_FM_PORT_COUNTERS_CYCLE=%d\n"
-		"e_FM_PORT_COUNTERS_TASK_UTIL=%d\n"
-		"e_FM_PORT_COUNTERS_QUEUE_UTIL=%d\n"
-		"e_FM_PORT_COUNTERS_DMA_UTIL=%d\n"
-		"e_FM_PORT_COUNTERS_FIFO_UTIL=%d\n"
-			"e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION=%d\n"
-#endif
-		"e_FM_PORT_COUNTERS_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_DISCARD_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_DEALLOC_BUF=%d\n"
-		"e_FM_PORT_COUNTERS_RX_BAD_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_RX_LARGE_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD=%d\n"
-		"e_FM_PORT_COUNTERS_RX_FILTER_FRAME=%d\n"
-		"e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR=%d\n"
-		"e_FM_PORT_COUNTERS_ENQ_TOTAL=%d\n",
-		p_LnxWrpFmDev->id,
-		p_LnxWrpFmPortDev->id,
-#ifdef PERFORMANCE_COUNTERS
-	/* TODO: Initialize the performance counters from userspace... */
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_CYCLE),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_TASK_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_QUEUE_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DMA_UTIL),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FIFO_UTIL),
-#endif
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DISCARD_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEALLOC_BUF),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_BAD_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_LARGE_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_FILTER_FRAME),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR),
-	FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_ENQ_TOTAL));
-}
-
-static int fm_port_proc_dump_stats(char *buffer, char **start, off_t offset,
-                                   int length, int *eof, void *data)
-{
-    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)data;
-    t_LnxWrpFmDev               *p_LnxWrpFmDev;
-    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
-    unsigned long               flags;
-    int                         numOfWrittenChars;
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = NULL;
 
-    if (!p_LnxWrpFmPortDev || !p_LnxWrpFmPortDev->h_Dev)
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM-Port not initialized!"));
-        return 0;
-    }
+    if(dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    /* store to remove them when module si disabled */
+    p_LnxWrpFmPortDev->dev_attr_regs = &dev_attr_fm_port_regs;
+
+    /* Registers dump entry - in future will be moved to debugfs */
+    if(device_create_file(dev,&dev_attr_fm_port_regs) !=0 )
+         return -EIO;
+
+    /* FM Ports statistics */
+    switch(p_LnxWrpFmPortDev->settings.param.portType){
+        case e_FM_PORT_TYPE_TX:
+        case e_FM_PORT_TYPE_TX_10G:
+            if (sysfs_create_group(&dev->kobj, &fm_tx_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_RX:
+        case e_FM_PORT_TYPE_RX_10G :
+            if (sysfs_create_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING :
+        case e_FM_PORT_TYPE_OH_HOST_COMMAND :
+            if (sysfs_create_group(&dev->kobj, &fm_oh_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_DUMMY:
+        default:
+            BUG();
+        break;
+    };
+
+    return 0;
+}
+
+static void fm_port_sysfs_destroy(struct device *dev)
+{
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = NULL;
+
+    /* this function has never been tested !!! */
+
+    if(dev == NULL)
+        BUG();
+
+    p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    /* The name attribute will be freed also by these 2 functions? Hell knows... */
+    switch(p_LnxWrpFmPortDev->settings.param.portType){
+        case e_FM_PORT_TYPE_TX:
+        case e_FM_PORT_TYPE_TX_10G:
+            sysfs_remove_group(&dev->kobj, &fm_tx_port_dev_stats_attr_grp);
+        break;
+        case e_FM_PORT_TYPE_RX:
+        case e_FM_PORT_TYPE_RX_10G :
+            sysfs_remove_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp);
+        break;
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING :
+        case e_FM_PORT_TYPE_OH_HOST_COMMAND :
+            /* Not supported yet... */
+            printk( KERN_WARNING "Statistics for port type not supported... \n");
+        break;
+        case e_FM_PORT_TYPE_DUMMY :
+        default :
+            BUG();
+        break;
+    };
+
+    device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_regs);
+}
+
+/* Fm stats and regs dumps via sysfs */
+static ssize_t show_fm_dma_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    t_FmDmaStatus  fmDmaStatus;
+    unsigned long  flags = 0;
+    unsigned n = 0;
+    uint8_t counter_value = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
 
-    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
     if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
-        return 0;
-    }
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
 
     local_irq_save(flags);
 
-    switch(p_LnxWrpFmPortDev->settings.param.portType){
-    case e_FM_PORT_TYPE_RX:
-    case e_FM_PORT_TYPE_RX_10G :
-        fm_rx_port_proc_dump_stats(&h_ProcBuff,p_LnxWrpFmPortDev);
+    memset(&fmDmaStatus, 0, sizeof(fmDmaStatus));
+    FM_GetDmaStatus(p_LnxWrpFmDev->h_Dev, &fmDmaStatus);
+
+    switch(counter){
+        case e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY:
+            counter_value = fmDmaStatus.cmqNotEmpty;
+        break;
+        case e_FM_DMA_COUNTERS_BUS_ERROR:
+            counter_value = fmDmaStatus.busError;
+        break;
+        case e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR:
+            counter_value = fmDmaStatus.readBufEccError;
         break;
-    case e_FM_PORT_TYPE_TX:
-    case e_FM_PORT_TYPE_TX_10G:
-        fm_tx_port_proc_dump_stats(&h_ProcBuff,p_LnxWrpFmPortDev);
+        case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR:
+            counter_value = fmDmaStatus.writeBufEccSysError;
         break;
-    default:
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported statistics !"));
+        case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR:
+            counter_value = fmDmaStatus.writeBufEccFmError;
+        break;
+        default:
+            BUG();
         break;
     };
 
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    n = snprintf( buf, PAGE_SIZE, "\tFM %u counter: %c\n",
+            p_LnxWrpFmDev->id,
+            counter_value?'T':'F' );
+
+    local_irq_restore(flags);
+
+    return n;
+}
+
+static ssize_t show_fm_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    unsigned long  flags = 0;
+    unsigned n = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
+
+    local_irq_save(flags);
+
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            FM_GetCounter(p_LnxWrpFmDev->h_Dev, (e_FmCounters)counter));
 
     local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
 
-    return numOfWrittenChars;
+    return n;
 }
 
-static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
-                             int length, int *eof, void *data)
+static ssize_t show_fm_pcd_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    unsigned long  flags = 0;
+    unsigned n = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
+
+    local_irq_save(flags);
+
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, (e_FmPcdCounters)counter));
+
+    local_irq_restore(flags);
+
+    return n;
+}
+
+/* FM */
+static DEVICE_ATTR(enq_total_frame              , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_total_frame              , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_0                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_1                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_2                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_default             , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_context             , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_fd                  , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_confirm                  , S_IRUGO, show_fm_stats, NULL);
+/* FM:DMA */
+static DEVICE_ATTR(cmq_not_empty            , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(bus_error                , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(read_buf_ecc_error       , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(write_buf_ecc_sys_error  , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(write_buf_ecc_fm_error   , S_IRUGO, show_fm_dma_stats, NULL);
+/* FM:PCD */
+static DEVICE_ATTR(pcd_enq_total_frame                          , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_kg_total                                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_yellow                              , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_red                                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_recolored_to_red                    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_recolored_to_yellow                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_total                               , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_length_mismatch                     , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_parse_dispatch                       , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l2_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l3_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l4_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_shim_parse_result_returned           , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l2_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l3_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l4_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_shim_parse_result_returned_with_err  , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_soft_prs_cycles                      , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_soft_prs_stall_cycles                , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_hard_prs_cycle_incl_stall_cycles     , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_read_cycles                    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_read_stall_cycles              , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_write_cycles                   , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_write_stall_cycles             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_fpm_command_stall_cycles             , S_IRUGO, show_fm_pcd_stats, NULL);
+
+static struct attribute *fm_dev_stats_attributes[] = {
+    &dev_attr_enq_total_frame.attr,
+    &dev_attr_deq_total_frame.attr,
+    &dev_attr_deq_0.attr,
+    &dev_attr_deq_1.attr,
+    &dev_attr_deq_2.attr,
+    &dev_attr_deq_from_default.attr,
+    &dev_attr_deq_from_context.attr,
+    &dev_attr_deq_from_fd.attr,
+    &dev_attr_deq_confirm.attr,
+    &dev_attr_cmq_not_empty.attr,
+    &dev_attr_bus_error.attr,
+    &dev_attr_read_buf_ecc_error.attr,
+    &dev_attr_write_buf_ecc_sys_error.attr,
+    &dev_attr_write_buf_ecc_fm_error.attr,
+    &dev_attr_pcd_enq_total_frame.attr,
+    &dev_attr_pcd_kg_total.attr,
+    &dev_attr_pcd_plcr_yellow.attr,
+    &dev_attr_pcd_plcr_red.attr,
+    &dev_attr_pcd_plcr_recolored_to_red.attr,
+    &dev_attr_pcd_plcr_recolored_to_yellow.attr,
+    &dev_attr_pcd_plcr_total.attr,
+    &dev_attr_pcd_plcr_length_mismatch.attr,
+    &dev_attr_pcd_prs_parse_dispatch.attr,
+    &dev_attr_pcd_prs_l2_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l3_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l4_parse_result_returned.attr,
+    &dev_attr_pcd_prs_shim_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l2_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_l3_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_l4_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_shim_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_soft_prs_cycles.attr,
+    &dev_attr_pcd_prs_soft_prs_stall_cycles.attr,
+    &dev_attr_pcd_prs_hard_prs_cycle_incl_stall_cycles.attr,
+    &dev_attr_pcd_prs_muram_read_cycles.attr,
+    &dev_attr_pcd_prs_muram_read_stall_cycles.attr,
+    &dev_attr_pcd_prs_muram_write_cycles.attr,
+    &dev_attr_pcd_prs_muram_write_stall_cycles.attr,
+    &dev_attr_pcd_prs_fpm_command_stall_cycles.attr,
+    NULL
+};
+
+static const struct attribute_group fm_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_dev_stats_attributes
+};
+
+static ssize_t show_fm_regs(struct device *dev, struct device_attribute *attr, char *buf)
 {
     unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = NULL;
+#endif
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
-    char            *next = buffer;
-    unsigned        size = length;
-    int             t;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
 
     local_irq_save(flags);
-    t = scnprintf(next, size, "FM driver registers dump.\n");
-    size -= t;
-    next += t;
+
+    n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
 
     if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
+        return -EIO;
     else
         FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
 
     local_irq_restore(flags);
-    *eof = 1;
-
-    return length - size;
-
 #else
-    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
-    int         numOfWrittenChars;
 
     local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    n = snprintf(buf, PAGE_SIZE, "Debug level is too low to dump registers!!!\n");
     local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
-
-    return numOfWrittenChars;
 #endif /* (defined(DEBUG_ERRORS) && ... */
+
+    return n;
 }
 
-static int fm_pcd_proc_dump_regs(char *buffer, char **start, off_t offset,
-                             int length, int *eof, void *data)
+static ssize_t show_pcd_regs(struct device *dev, struct device_attribute *attr, char *buf)
 {
     unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = NULL;
+#endif
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
-    char            *next = buffer;
-    unsigned        size = length;
-    int             t;
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
 
     local_irq_save(flags);
-    t = scnprintf(next, size, "FM driver registers dump.\n");
-    size -= t;
-    next += t;
+    n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
 
     if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_PcdDev)
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
+        return -EIO;
     else
         FM_PCD_DumpRegs(p_LnxWrpFmDev->h_PcdDev);
 
     local_irq_restore(flags);
-    *eof = 1;
-
-    return length - size;
-
 #else
-    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
-    int         numOfWrittenChars;
 
     local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    n = snprintf(buf, PAGE_SIZE,  "Debug level is too low to dump registers!!!\n");
     local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
 
-    return numOfWrittenChars;
 #endif /* (defined(DEBUG_ERRORS) && ... */
+
+    return n;
 }
 
-static int fm_port_proc_dump_regs(char *buffer, char **start, off_t offset,
-                                  int length, int *eof, void *data)
+static DEVICE_ATTR(fm_regs, S_IRUGO, show_fm_regs, NULL);
+static DEVICE_ATTR(fm_pcd_regs, S_IRUGO, show_pcd_regs, NULL);
+
+static int fm_sysfs_create(struct device *dev)
 {
-    unsigned long   flags;
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)data;
-    char            *next = buffer;
-    unsigned        size = length;
-    int             t;
+    if(dev == NULL)
+        return -EIO;
 
-    local_irq_save(flags);
-    t = scnprintf(next, size, "FM port driver registers dump.\n");
-    size -= t;
-    next += t;
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
 
-    if (!p_LnxWrpFmPortDev->h_Dev)
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM port not initialized!"));
-    else
-        FM_PORT_DumpRegs(p_LnxWrpFmPortDev->h_Dev);
+    /* store to remove them when module si disabled */
+    p_LnxWrpFmDev->dev_attr_regs = &dev_attr_fm_regs;
+    p_LnxWrpFmDev->dev_pcd_attr_regs = &dev_attr_fm_pcd_regs;
+    
+    /* Create sysfs statistics group for FM module */
+    if (sysfs_create_group(&dev->kobj, &fm_dev_stats_attr_grp) !=0)
+        return -EIO;
 
-    local_irq_restore(flags);
-    *eof = 1;
+    /* Registers dump entry - in future will be moved to debugfs */
+    if (device_create_file(dev,&dev_attr_fm_regs) != 0 ||
+        device_create_file(dev,&dev_attr_fm_pcd_regs) != 0)
+        return -EIO;
 
-    return length - size;
+    return 0;
+}
 
-#else
-    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
-    int         numOfWrittenChars;
+static void fm_sysfs_distroy(struct device *dev)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
 
-    local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
-    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
-    local_irq_restore(flags);
-    ProcBuff_Free(h_ProcBuff);
+    if(dev == NULL)
+        BUG();
 
-    return numOfWrittenChars;
-#endif /* (defined(DEBUG_ERRORS) && ... */
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    /* this function has never been tested !!! */
+    sysfs_remove_group(&dev->kobj, &fm_dev_stats_attr_grp);
+    device_remove_file(dev,p_LnxWrpFmDev->dev_attr_regs);
 }
 
 static irqreturn_t fm_irq(int irq, void *_dev)
@@ -520,15 +951,19 @@ static irqreturn_t fm_err_irq(int irq, void *_dev)
 }
 
 static volatile int   hcFrmRcv = 0;
+static spinlock_t     lock;
 
 static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
                                                    struct qman_fq              *fq,
                                                    const struct qm_dqrr_entry  *dq)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = ((t_FmTestFq *)fq)->h_Arg;
+    unsigned long flags;
 
-    FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_FmFD *)&dq->fd);
+    FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_DpaaFD *)&dq->fd);
+    spin_lock_irqsave(&lock, flags);
     hcFrmRcv--;
+    spin_unlock_irqrestore(&lock, flags);
 
     return qman_cb_dqrr_consume;
 }
@@ -604,24 +1039,26 @@ static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
     return fq;
 }
 
-static t_Error QmEnqueueCB (t_Handle h_Arg, uint32_t fqid, void *p_Fd)
+static t_Error QmEnqueueCB (t_Handle h_Arg, void *p_Fd)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
     int             _errno, timeout=1000000;
+    unsigned long flags;
 
     ASSERT_COND(p_LnxWrpFmDev);
-    UNUSED(fqid);
 
-    hcFrmRcv++;
-//MemDisp((uint8_t*)p_Fd,sizeof(t_FmFD));
+   spin_lock_irqsave(&lock, flags);
+   hcFrmRcv++;
+   spin_unlock_irqrestore(&lock, flags);
+//MemDisp((uint8_t*)p_Fd,sizeof(t_DpaaFD));
     _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
     if (_errno)
         RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
 
-    while (hcFrmRcv && --timeout)
+   while (hcFrmRcv && --timeout)
     {
-        udelay(1);
-        cpu_relax();
+       udelay(1);
+       cpu_relax();
     }
     BUG_ON(!timeout);
 
@@ -712,13 +1149,17 @@ typedef _Packed struct {
 
     t_Plr       *p_Plr;
     t_Ppids     *p_Ppids;
-    int         i;
+    int         i,j;
     uint32_t    fmRev;
-    uint8_t     physRxPortId[] = {0x8,0x9,0xa,0xb,0x10};
-    uint8_t     physOhPortId[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
+    static const uint8_t     phys1GRxPortId[] = {0x8,0x9,0xa,0xb,0xc};
+    static const uint8_t     phys10GRxPortId[] = {0x10};
+    static const uint8_t     physOhPortId[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
+    static const uint8_t     phys1GTxPortId[] = {0x28,0x29,0x2a,0x2b,0x2c};
+    static const uint8_t     phys10GTxPortId[] = {0x30};
+
+    fmRev = (uint32_t)(*CAST_UINT64_TO_POINTER_TYPE(volatile uint32_t, (p_LnxWrpFmDev->fmBaseAddr+FM_FPM_IP_REV_1_OFFSET)));
+    fmRev &= 0xffff;
 
-    fmRev = (uint32_t)(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,
-			(p_LnxWrpFmDev->fmBaseAddr+FM_FPM_IP_REV_1_OFFSET)));
     p_Plr = CAST_UINT64_TO_POINTER_TYPE(t_Plr, (p_LnxWrpFmDev->fmBaseAddr+FM_DMA_PLR_OFFSET));
 #ifdef MODULE
     for (i=0;i<FM_MAX_NUM_OF_PARTITIONS/2;i++)
@@ -726,16 +1167,75 @@ typedef _Packed struct {
 #endif /* MODULE */
 
     for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
-        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] =
-            (uint16_t)((i%2) ?
+    {
+        uint16_t liodnBase = (uint16_t)((i%2) ?
                        (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
                        ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT));
+#ifdef FM_PARTITION_ARRAY
+        p_LnxWrpFmDev->fmDevSettings.param.liodnPerPartition[i] = liodnBase;
+#endif /* FM_PARTITION_ARRAY */
+
+        if ((i >= phys1GRxPortId[0]) &&
+             (i <= phys1GRxPortId[FM_MAX_NUM_OF_1G_RX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys1GRxPortId); j++)
+                if (phys1GRxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys1GRxPortId));
+            p_LnxWrpFmDev->rxPorts[j].settings.param.liodnBase = liodnBase;
+        }
+        else if (FM_MAX_NUM_OF_10G_RX_PORTS &&
+                 (i >= phys10GRxPortId[0]) &&
+                 (i <= phys10GRxPortId[FM_MAX_NUM_OF_10G_RX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys10GRxPortId); j++)
+                if (phys10GRxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys10GRxPortId));
+            p_LnxWrpFmDev->rxPorts[FM_MAX_NUM_OF_1G_RX_PORTS+j].settings.param.liodnBase = liodnBase;
+        }
+        else if ((i >= physOhPortId[0]) &&
+                 (i <= physOhPortId[FM_MAX_NUM_OF_OH_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(physOhPortId); j++)
+                if (physOhPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(physOhPortId));
+            if (j == 0)
+                p_LnxWrpFmDev->hcPort.settings.param.liodnBase = liodnBase;
+            else
+                p_LnxWrpFmDev->opPorts[j - 1].settings.param.liodnBase = liodnBase;
+        }
+        else if ((i >= phys1GTxPortId[0]) &&
+                  (i <= phys1GTxPortId[FM_MAX_NUM_OF_1G_TX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys1GTxPortId); j++)
+                if (phys1GTxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys1GTxPortId));
+            p_LnxWrpFmDev->txPorts[j].settings.param.liodnBase = liodnBase;
+        }
+        else if (FM_MAX_NUM_OF_10G_TX_PORTS &&
+                 (i >= phys10GTxPortId[0]) &&
+                 (i <= phys10GTxPortId[FM_MAX_NUM_OF_10G_TX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys10GTxPortId); j++)
+                if (phys10GTxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys10GTxPortId));
+            p_LnxWrpFmDev->txPorts[FM_MAX_NUM_OF_1G_TX_PORTS+j].settings.param.liodnBase = liodnBase;
+        }
+    }
 
     p_Ppids = CAST_UINT64_TO_POINTER_TYPE(t_Ppids, (p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET));
 
-    for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
+    for (i=0; i<FM_MAX_NUM_OF_1G_RX_PORTS; i++)
             p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.rxPartitionId =
-                p_Ppids->fmbm_ppid[physRxPortId[i]-1];
+                p_Ppids->fmbm_ppid[phys1GRxPortId[i]-1];
+
+    for (i=0; i<FM_MAX_NUM_OF_10G_RX_PORTS; i++)
+            p_LnxWrpFmDev->rxPorts[FM_MAX_NUM_OF_1G_RX_PORTS+i].settings.param.specificParams.rxParams.rxPartitionId =
+                p_Ppids->fmbm_ppid[phys10GRxPortId[i]-1];
 
 #ifdef FM_OP_PARTITION_ERRATA_FMAN16
     for (i=0; i<FM_MAX_NUM_OF_OH_PORTS; i++)
@@ -743,7 +1243,7 @@ typedef _Packed struct {
         /* OH port #0 is host-command, don't need this workaround */
         if (i == 0)
             continue;
-        if ((fmRev & 0xffff) == 0x0100)
+        if (fmRev == 0x0100)
             p_LnxWrpFmDev->opPorts[i-1].settings.param.specificParams.nonRxParams.opPartitionId =
                 p_Ppids->fmbm_ppid[physOhPortId[i]-1];
     }
@@ -754,10 +1254,14 @@ typedef _Packed struct {
 
 #ifndef NO_OF_SUPPORT
 /* The default address for the Fman microcode in flash. Having a default
- * allows older systems to continue functioning.  0xFEF000000 is the address
+ * allows older systems to continue functioning.  0xEF000000 is the address
  * where the firmware is normally on a P4080DS.
  */
-static phys_addr_t P4080_UCAddr = 0xfef000000;
+#ifdef CONFIG_PHYS_64BIT
+static phys_addr_t P4080_UCAddr = 0xfef000000ull;
+#else
+static phys_addr_t P4080_UCAddr = 0xef000000;
+#endif
 
 
 /**
@@ -787,51 +1291,70 @@ __setup("fman_ucode=", FmanUcodeAddrParam);
  * the Fman microcode.  We use the QE Firmware structure because Fman microcode
  * is similar to QE microcode, so there's no point in defining a new layout.
  *
- * We also never iounmap() the memory because we might reset the Fman at any
- * time.
+ * Current versions of U-Boot embed the Fman firmware into the device tree,
+ * so we check for that first.  Each Fman node in the device tree contains a
+ * node or a pointer to node that holds the firmware.  Technically, we should
+ * be fetching the firmware node for the current Fman, but we don't have that
+ * information any more, so we assume that there is only one firmware node in
+ * the device tree, and that all Fmen use the same firmware.
+ *
+ * If we have an older U-Boot, then we assume that the firmware is located in
+ * flash at physical address 'P4080_UCAddr'
  */
 #ifdef	CONFIG_PPC85xx_VT_MODE
 extern struct qe_firmware p4080_fman_firmware;
 #endif
-static struct qe_firmware *FindFmanMicrocode(void)
-{
-    static struct qe_firmware *P4080_UCPatch;
-
-    if (!P4080_UCPatch) {
-        unsigned long P4080_UCSize;
-        struct qe_header *hdr;
-
+static const struct qe_firmware *FindFmanMicrocode(void)
+{
+    static const struct qe_firmware *P4080_UCPatch;
+    struct device_node *np;
+    unsigned long P4080_UCSize;
+    const struct qe_header *hdr;
+
+    if (P4080_UCPatch)
+	    return P4080_UCPatch;
+
+    /* The firmware should be inside the device tree. */
+    np = of_find_compatible_node(NULL, NULL, "fsl,fman-firmware");
+    if (np) {
+	    P4080_UCPatch = of_get_property(np, "fsl,firmware", NULL);
+	    if (P4080_UCPatch)
+		    return P4080_UCPatch;
+	    else
+		    REPORT_ERROR(WARNING, E_NOT_FOUND, ("firmware node is incomplete"));
+    }
 #ifdef	CONFIG_PPC85xx_VT_MODE
 	P4080_UCPatch = &p4080_fman_firmware;
 #else
+    /* If not, then we have a legacy U-Boot.  The firmware is in flash. */
 
-        /* Only map enough to the get the core structure */
-        P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
-        if (!P4080_UCPatch) {
-            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
-            return NULL;
-        }
+    /* Only map enough to the get the core structure */
+    P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
+    if (!P4080_UCPatch) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+        return NULL;
+    }
 #endif
+    /* Make sure it really is a QE Firmware blob */
+    hdr = &P4080_UCPatch->header;
+    if (!hdr ||
+        (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+        (hdr->magic[2] != 'F')) {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
+        return NULL;
+    }
 
-        /* Make sure it really is a QE Firmware blob */
-        hdr = &P4080_UCPatch->header;
-        if (!hdr ||
-            (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
-            (hdr->magic[2] != 'F')) {
-            REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
-            return NULL;
-        }
-
-        /* Now we call ioremap again, this time to pick up the whole blob */
-        P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
+    /* Now we call ioremap again, this time to pick up the whole blob. We never
+     * iounmap() the memory because we might reset the Fman at any time.
+     */
+    P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
 #ifndef	CONFIG_PPC85xx_VT_MODE
-        iounmap(P4080_UCPatch);
-        P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
+    iounmap((void *)P4080_UCPatch);
+    P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
 #endif
-        if (!P4080_UCPatch) {
-            REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
-            return NULL;
-        }
+    if (!P4080_UCPatch) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+        return NULL;
     }
 
     return P4080_UCPatch;
@@ -899,7 +1422,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
         return NULL;
     }
     BUG_ON(lenp != sizeof(uint32_t));
-    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = *uint32_prop;
+    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = (*uint32_prop + 500000)/1000000; /* In MHz, rounded */
 
     /* Get the MURAM base address and size */
     memset(&name, 0, sizeof(struct of_device_id));
@@ -920,6 +1443,25 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
         }
     }
 
+    /* Get the RTC base address and size */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("rtc") >= sizeof(name.name));
+    strcpy(name.name, "rtc");
+    BUG_ON(strlen("fsl,fman-rtc") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-rtc");
+    for_each_child_of_node(fm_node, dev_node) {
+        if (likely(of_match_node(&name, dev_node) != NULL)) {
+            _errno = of_address_to_resource(dev_node, 0, &res);
+            if (unlikely(_errno < 0)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+                return NULL;
+            }
+
+            p_LnxWrpFmDev->fmRtcBaseAddr = res.start;
+            p_LnxWrpFmDev->fmRtcMemSize = res.end + 1 - res.start;
+        }
+    }
+
     /* Get all PCD nodes */
     memset(&name, 0, sizeof(struct of_device_id));
     BUG_ON(strlen("parser") >= sizeof(name.name));
@@ -1093,7 +1635,8 @@ static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
         }
         BUG_ON(lenp != sizeof(uint32_t));
         p_LnxWrpFmPortDev->txCh = *uint32_prop;
-        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.qmChannel = p_LnxWrpFmPortDev->txCh;
     }
     else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx") ||
              of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
@@ -1120,7 +1663,7 @@ static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
         }
         BUG_ON(lenp != sizeof(uint32_t));
         p_LnxWrpFmPortDev->txCh = *uint32_prop;
-        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.qmChannel = p_LnxWrpFmPortDev->txCh;
     }
     else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx") ||
              of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
@@ -1185,14 +1728,14 @@ static void LnxwrpFmDevBusErrorCb(t_Handle        h_App,
                                   uint8_t         portId,
                                   uint64_t        addr,
                                   uint8_t         tnum,
-                                  uint8_t         partition)
+                                  uint16_t        liodn)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
 
     ASSERT_COND(p_LnxWrpFmDev);
 
     /* do nothing */
-    UNUSED(portType);UNUSED(portId);UNUSED(addr);UNUSED(tnum);UNUSED(partition);
+    UNUSED(portType);UNUSED(portId);UNUSED(addr);UNUSED(tnum);UNUSED(liodn);
 }
 
 static void LnxwrpFmPcdDevExceptionsCb( t_Handle h_App, e_FmPcdExceptions exception)
@@ -1225,7 +1768,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
     struct resource     *dev_res;
     int                 _errno;
-    uint32_t            fmPhysAddr, muramPhysAddr;
+    uint64_t            fmPhysAddr, muramPhysAddr;
 
     if (!p_LnxWrpFmDev->active)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
@@ -1267,6 +1810,21 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr, (uint64_t)muramPhysAddr, p_LnxWrpFmDev->fmMuramMemSize) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM MURAM memory map"));
 
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        uint64_t rtcPhysAddr = p_LnxWrpFmDev->fmRtcBaseAddr;
+        dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize, "fman-rtc");
+        if (unlikely(dev_res == NULL))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+
+        p_LnxWrpFmDev->fmRtcBaseAddr = CAST_POINTER_TO_UINT64(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize));
+        if (unlikely(p_LnxWrpFmDev->fmRtcBaseAddr == 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+        if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmRtcBaseAddr, (uint64_t)rtcPhysAddr, p_LnxWrpFmDev->fmRtcMemSize) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC memory map"));
+    }
+
     if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr, (uint64_t)fmPhysAddr, p_LnxWrpFmDev->fmMemSize) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM memory map"));
 
@@ -1336,25 +1894,33 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
                     QMAN_FQ_FLAG_TO_DCPORTAL,
                     p_LnxWrpFmPortDev->txCh,
                     0);
+        if (!p_LnxWrpFmDev->hc_tx_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
+
         p_LnxWrpFmDev->hc_tx_conf_fq  =
             FqAlloc(p_LnxWrpFmDev,
                     0,
                     QMAN_FQ_FLAG_NO_ENQUEUE,
                     p_LnxWrpFmDev->hcCh,
                     7);
+        if (!p_LnxWrpFmDev->hc_tx_conf_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
+
         p_LnxWrpFmDev->hc_tx_err_fq  =
             FqAlloc(p_LnxWrpFmDev,
                     0,
                     QMAN_FQ_FLAG_NO_ENQUEUE,
                     p_LnxWrpFmDev->hcCh,
                     7);
+        if (!p_LnxWrpFmDev->hc_tx_err_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
 
         fmPcdParams.hc.portBaseAddr = p_LnxWrpFmPortDev->baseAddr;
         fmPcdParams.hc.portId = p_LnxWrpFmPortDev->id;
+        fmPcdParams.hc.liodnBase = p_LnxWrpFmPortDev->settings.param.liodnBase;
         fmPcdParams.hc.errFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_err_fq);
         fmPcdParams.hc.confFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
-        fmPcdParams.hc.deqSubPortal = (p_LnxWrpFmPortDev->txCh & 0x1f);
-        fmPcdParams.hc.enqFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_fq);
+        fmPcdParams.hc.qmChannel = p_LnxWrpFmPortDev->txCh;
         fmPcdParams.hc.f_QmEnqueue = QmEnqueueCB;
         fmPcdParams.hc.h_QmArg = (t_Handle)p_LnxWrpFmDev;
 
@@ -1366,7 +1932,7 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
                                                        LNXWRP_FM_NUM_OF_SHARED_PROFILES))!= E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-	if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
+        if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (p_LnxWrpFmDev->err_irq == 0) {
@@ -1375,8 +1941,9 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,FALSE);
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,FALSE);
             FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,FALSE);
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,FALSE);
-            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,FALSE);
         }
     }
 
@@ -1385,7 +1952,7 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
-    struct qe_firmware *fw;
+    const struct qe_firmware *fw;
 
     if (!p_LnxWrpFmDev->active)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
@@ -1413,6 +1980,9 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
 
+    if (FM_ConfigMaxNumOfOpenDmas(p_LnxWrpFmDev->h_Dev,BMI_MAX_NUM_OF_DMAS) != E_OK)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
     if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
@@ -1425,18 +1995,36 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_SYSTEM_WRITE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_FM_WRITE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_STALL_ON_TASKS , FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_DOUBLE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
-	/* TODO: FmDisableRamsEcc assert for ramsEccOwners.
-	 * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
+        /* TODO: FmDisableRamsEcc assert for ramsEccOwners.
+         * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DOUBLE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_LIST_RAM_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_PIPELINE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STATISTICS_RAM_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_SINGLE_ECC, FALSE);
+    }
+
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        t_FmRtcParams   fmRtcParam;
+
+        memset(&fmRtcParam, 0, sizeof(fmRtcParam));
+        fmRtcParam.h_App = p_LnxWrpFmDev;
+        fmRtcParam.h_Fm = p_LnxWrpFmDev->h_Dev;
+        fmRtcParam.baseAddress = p_LnxWrpFmDev->fmRtcBaseAddr;
+
+        if(!(p_LnxWrpFmDev->h_RtcDev = FM_RTC_Config(&fmRtcParam)))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-RTC"));
+
+        if (FM_RTC_Init(p_LnxWrpFmDev->h_RtcDev) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC"));
     }
 
+//    return InitFmPcdDev(p_LnxWrpFmDev);
     return E_OK;
 }
 
@@ -1490,19 +2078,19 @@ static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
                 schemeParam.netEnvParams.unitIds[0] = 0;
                 schemeParam.baseFqid = p_LnxWrpFmPortDev->pcdBaseQ;
                 schemeParam.nextEngine = e_FM_PCD_DONE;
-                schemeParam.numOfUsedFqidMasks = 0;
+                schemeParam.numOfUsedExtractedOrs = 0;
                 schemeParam.useHash = TRUE;
                 schemeParam.keyExtractAndHashParams.numOfUsedExtracts = 3;
                 for(j=0; j<schemeParam.keyExtractAndHashParams.numOfUsedExtracts; j++)
                 {
                     schemeParam.keyExtractAndHashParams.extractArray[j].type = e_FM_PCD_EXTRACT_BY_HDR;
-                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.hdr = HEADER_TYPE_IPv4;
-                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.ignoreProtocolValidation = FALSE;
-                    schemeParam.keyExtractAndHashParams.extractArray[j].extractParams.extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractByHdr.hdr = HEADER_TYPE_IPv4;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractByHdr.ignoreProtocolValidation = FALSE;
+                    schemeParam.keyExtractAndHashParams.extractArray[j].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
                 }
-                schemeParam.keyExtractAndHashParams.extractArray[0].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
-                schemeParam.keyExtractAndHashParams.extractArray[1].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
-                schemeParam.keyExtractAndHashParams.extractArray[2].extractParams.extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+                schemeParam.keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+                schemeParam.keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+                schemeParam.keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
 
                 if(schemeParam.useHash)
                 {
@@ -1575,35 +2163,49 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
 
     if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
-             (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX))
+        (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX))
     {
-        t_Error         errCode;
+        t_Error errCode = E_OK;
         if ((errCode = FM_PORT_ConfigDeqHighPriority(p_LnxWrpFmPortDev->h_Dev, TRUE)) != E_OK)
              RETURN_ERROR(MAJOR, errCode, NO_MSG);
         if ((errCode = FM_PORT_ConfigDeqPrefetchOption(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_DEQ_FULL_PREFETCH)) != E_OK)
              RETURN_ERROR(MAJOR, errCode, NO_MSG);
     }
 
-	{
-		t_FmPortRsrc    portRsrc;
-		t_Error         errCode;
+    /* Set for 10G ports for performace purposes... */
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        t_Error      errCode = E_OK;
+        t_FmPortRsrc numOfOpenDmas;
+        numOfOpenDmas.num = FM_PORT_10G_NUM_OF_OPEN_DMA;
+        numOfOpenDmas.extra = 0;
 
-		if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
-			portRsrc.num = 21504;
-		else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
-			portRsrc.num = 23040;
-		else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)
-			portRsrc.num = 10752;
-		else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)
-			portRsrc.num = 11520;
-		else /* Offline-Parsing port */
-			portRsrc.num = 10752;
+        if ((errCode = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev, &numOfOpenDmas)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+    }
 
-		portRsrc.extra = 0;
+    {
+        t_FmPortRsrc    portRsrc;
+        t_Error         errCode;
+
+        if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
+            portRsrc.num = 21504;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+            portRsrc.num = 23040;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)
+            portRsrc.num = 10752;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)
+            portRsrc.num = 11520;
+        else
+            portRsrc.num = 10752;
+
+        portRsrc.extra = 0;
+
+        if ((errCode = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev, &portRsrc)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+    }
 
-		if ((errCode = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev, &portRsrc)) != E_OK)
-		     RETURN_ERROR(MAJOR, errCode, NO_MSG);
-	}
     /* Call the driver's advanced configuration routines, if requested:
        Compare the function pointer of each entry to the available routines,
        and invoke the matching routine with proper casting of arguments. */
@@ -1623,19 +2225,19 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
 /* TODO: Implement f_FM_MAC_SetException...
-	if (((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev)->err_irq == 0) {
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_CMD_CMPL,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_REM_FAULT,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_LOC_FAULT,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_1TX_ECC_ER,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_UNFL,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_OVFL,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_ER,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_FIFO_OVFL,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_ECC_ER,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_JAB_FRM,FALSE);
-	FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_OVRSZ_FRM,FALSE);
+    if (((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev)->err_irq == 0) {
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_CMD_CMPL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_REM_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_LOC_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_1TX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_UNFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_JAB_FRM,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_OVRSZ_FRM,FALSE);
     }
 */
 
@@ -1660,10 +2262,18 @@ static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (p_LnxWrpFmDev->h_MuramDev)
         FM_MURAM_Free(p_LnxWrpFmDev->h_MuramDev);
 
-    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr);
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        SYS_UnregisterIoMap(p_LnxWrpFmDev->fmRtcBaseAddr);
+        devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmDev->fmRtcBaseAddr));
+        __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize);
+    }
+    SYS_UnregisterIoMap(p_LnxWrpFmDev->fmMuramBaseAddr);
     devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmDev->fmMuramBaseAddr));
-    SYS_UnregisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr);
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
+    SYS_UnregisterIoMap(p_LnxWrpFmDev->fmBaseAddr);
     devm_iounmap(p_LnxWrpFmDev->dev, CAST_UINT64_TO_POINTER(p_LnxWrpFmDev->fmBaseAddr));
+    release_mem_region(p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
 //    devm_release_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
 }
 
@@ -1751,8 +2361,8 @@ static int fm_open(struct inode *inode, struct file *file)
             return -EINVAL;
 
         /* if trying to open port, check if it initialized */
-	if (!p_LnxWrpFmPortDev->h_Dev)
-		return -ENODEV;
+        if (!p_LnxWrpFmPortDev->h_Dev)
+            return -ENODEV;
 
         p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)fm_port_bind(p_LnxWrpFmPortDev->dev);
         file->private_data = p_LnxWrpFmPortDev;
@@ -1873,23 +2483,16 @@ static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_devi
                   "fm%d", p_LnxWrpFmDev->id);
     device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, DEV_FM_PCD_MINOR_BASE), NULL,
                   "fm%d-pcd", p_LnxWrpFmDev->id);
+    dev_set_drvdata(p_LnxWrpFmDev->dev, p_LnxWrpFmDev);
 
-    /* Register to the /proc for debug and statistics API */
-    if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(p_LnxWrpFmDev->name, NULL)) == NULL) ||
-        ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
-        ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL) ||
-        ((p_LnxWrpFmDev->proc_fm_pcd = proc_mkdir("fm-pcd", p_LnxWrpFmDev->proc_fm)) == NULL) ||
-        ((p_LnxWrpFmDev->proc_fm_pcd_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm_pcd, fm_pcd_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
-        ((p_LnxWrpFmDev->proc_fm_pcd_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm_pcd, fm_pcd_proc_dump_stats, p_LnxWrpFmDev)) == NULL)
-        )
+   /* create sysfs entries for stats and regs */
+    if ( fm_sysfs_create(p_LnxWrpFmDev->dev) !=0 )
     {
         FreeFmDev(p_LnxWrpFmDev);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to sysfs entry - fm!!!"));
         return -EIO;
     }
 
-    dev_set_drvdata(p_LnxWrpFmDev->dev, p_LnxWrpFmDev);
-
     DBG(TRACE, ("FM%d probed", p_LnxWrpFmDev->id));
 
     return 0;
@@ -1903,12 +2506,7 @@ static int __devexit fm_remove(struct of_device *of_dev)
     dev = &of_dev->dev;
     p_LnxWrpFmDev = dev_get_drvdata(dev);
 
-    remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm_pcd);
-    remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm_pcd);
-    remove_proc_entry("fm-pcd", p_LnxWrpFmDev->proc_fm);
-    remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
-    remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
-    remove_proc_entry(p_LnxWrpFmDev->name, NULL);
+    fm_sysfs_distroy(dev);
 
     DBG(TRACE, ("destroy fm_class"));
     device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, DEV_FM_MINOR_BASE));
@@ -1957,7 +2555,9 @@ static struct of_platform_driver fm_driver = {
     .match_table    = fm_match,
     .owner          = THIS_MODULE,
     .probe          = fm_probe,
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
     .shutdown	    = fm_shutdown,
+#endif
     .remove         = __devexit_p(fm_remove)
 };
 
@@ -1971,7 +2571,6 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
 
     if ((p_LnxWrpFmPortDev = ReadFmPortDevTreeNode(of_dev)) == NULL)
         return -EIO;
-
     if (ConfigureFmPortDev(p_LnxWrpFmPortDev) != E_OK)
         return -EIO;
 
@@ -2025,14 +2624,12 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
 
     device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor), NULL, p_LnxWrpFmPortDev->name);
 
-    /* Register to the /proc for debug and statistics API */
-    if (((p_LnxWrpFmPortDev->proc = proc_mkdir(p_LnxWrpFmPortDev->name, p_LnxWrpFmDev->proc_fm)) == NULL) ||
-        ((p_LnxWrpFmPortDev->proc_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmPortDev->proc, fm_port_proc_dump_regs, p_LnxWrpFmPortDev)) == NULL) ||
-        ((p_LnxWrpFmPortDev->proc_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmPortDev->proc, fm_port_proc_dump_stats, p_LnxWrpFmPortDev)) == NULL)
-        )
+    /* create sysfs entries for stats and regs */
+
+    if (fm_port_sysfs_create(dev) !=0 )
     {
         FreeFmDev(p_LnxWrpFmDev);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to sys entry - fm port!!!"));
         return -EIO;
     }
 
@@ -2050,9 +2647,7 @@ static int __devexit fm_port_remove(struct of_device *of_dev)
     dev = &of_dev->dev;
     p_LnxWrpFmPortDev = dev_get_drvdata(dev);
 
-    remove_proc_entry("stats", p_LnxWrpFmPortDev->proc_stats);
-    remove_proc_entry("regs", p_LnxWrpFmPortDev->proc_regs);
-    remove_proc_entry(p_LnxWrpFmPortDev->name, p_LnxWrpFmPortDev->proc);
+    fm_port_sysfs_destroy(dev);
 
     p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
     device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor));
@@ -2140,7 +2735,9 @@ static struct of_platform_driver fm_port_driver = {
     .match_table    = fm_port_match,
     .owner          = THIS_MODULE,
     .probe          = fm_port_probe,
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
     .shutdown	    = fm_port_shutdown,
+#endif
     .remove         = __devexit_p(fm_port_remove)
 };
 #endif /* !NO_OF_SUPPORT */
@@ -2154,6 +2751,7 @@ t_Handle LNXWRP_FM_Init(void)
 #endif /* NO_OF_SUPPORT */
 
     memset(&lnxWrpFm, 0, sizeof(lnxWrpFm));
+    spin_lock_init(&lock);
 
 #ifdef NO_OF_SUPPORT
     for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
@@ -2206,7 +2804,7 @@ t_Handle LNXWRP_FM_Init(void)
 #ifdef CONFIG_FSL_FMAN_TEST
     /* Seed the QMan allocator so we'll have enough queues to run PCD with
        dinamically fqid-range allocation */
-    qman_release_fqid_range(0x100, 0x100);
+    qman_release_fqid_range(0x400, 0x400);
 #endif /* CONFIG_FSL_FMAN_TEST */
 
     return &lnxWrpFm;
@@ -2304,12 +2902,12 @@ void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *param
     p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.errFqid  = params->errq;
     p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.dfltFqid = params->defq;
 
-    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.numOfPoolsUsed = params->num_pools;
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.numOfPoolsUsed = params->num_pools;
     for (i=0; i<params->num_pools; i++)
     {
-        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].id =
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.extBufPool[i].id =
             params->pool_param[i].id;
-        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.rxExtBufPools.rxExtBufPool[i].size =
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.extBufPool[i].size =
             params->pool_param[i].size;
     }
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
index e259c0b..a6a1962 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -57,6 +57,7 @@
 
 #define LNXWRP_FM_NUM_OF_SHARED_PROFILES    16
 
+#define FM_PORT_10G_NUM_OF_OPEN_DMA             12   /* Use only for 10G ports - RX and TX */
 
 typedef enum {
     e_NO_PCD = 0,
@@ -91,9 +92,8 @@ typedef struct {
     t_Handle                    h_LnxWrpFmDev;
     uint16_t                    txCh;
     struct device               *dev;
-    struct proc_dir_entry       *proc;
-    struct proc_dir_entry       *proc_regs;
-    struct proc_dir_entry       *proc_stats;
+    struct device_attribute     *dev_attr_stats;
+    struct device_attribute     *dev_attr_regs;
 } t_LnxWrpFmPortDev;
 
 typedef struct {
@@ -125,6 +125,8 @@ typedef struct {
     uint32_t                    fmMemSize;
     uint64_t                    fmMuramBaseAddr;
     uint32_t                    fmMuramMemSize;
+    uint64_t                    fmRtcBaseAddr;
+    uint32_t                    fmRtcMemSize;
     int                         irq;
     int                         err_irq;
     t_WrpFmDevSettings          fmDevSettings;
@@ -134,6 +136,7 @@ typedef struct {
 
     t_Handle                    h_MuramDev;
     t_Handle                    h_PcdDev;
+    t_Handle                    h_RtcDev;
 
     t_LnxWrpFmPortDev           hcPort;
     t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OH_PORTS-1];
@@ -145,12 +148,12 @@ typedef struct {
     struct resource             *res;
     int                         major;
     struct class                *fm_class;
-    struct proc_dir_entry       *proc_fm;
-    struct proc_dir_entry       *proc_fm_regs;
-    struct proc_dir_entry       *proc_fm_stats;
-    struct proc_dir_entry       *proc_fm_pcd;
-    struct proc_dir_entry       *proc_fm_pcd_regs;
-    struct proc_dir_entry       *proc_fm_pcd_stats;
+    struct device_attribute     *dev_attr_stats;
+    struct device_attribute     *dev_attr_regs;
+
+    struct device_attribute     *dev_pcd_attr_stats;
+    struct device_attribute     *dev_pcd_attr_regs;
+
     struct qman_fq              *hc_tx_conf_fq, *hc_tx_err_fq, *hc_tx_fq;
 } t_LnxWrpFmDev;
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
index 599cc95..06029a1 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -77,7 +77,6 @@
 static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg)
 {
     t_Error err = E_READ_FAILED;
-
     switch (cmd)
     {
         case FM_PCD_IOC_PRS_LOAD_SW:
@@ -153,11 +152,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             return FM_PCD_KgSetAdditionalDataAfterParsing(p_LnxWrpFmDev->h_PcdDev, (uint8_t)payloadOffset);
         }
 
-        case FM_PCD_IOC_KG_SET_EMPTY_CLS_PLAN_GRP:
-            return FM_PCD_KgSetEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
-        case FM_PCD_IOC_KG_DELETE_EMPTY_CLS_PLAN_GRP:
-            return FM_PCD_KgDeleteEmptyClsPlanGrp(p_LnxWrpFmDev->h_PcdDev);
-
         case FM_PCD_IOC_KG_SET_DFLT_VALUE:
         {
             ioc_fm_pcd_kg_dflt_value_params_t *param;
@@ -204,35 +198,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             return FM_PCD_DeleteNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, id.obj);
         }
 
-        case FM_PCD_IOC_KG_SET_CLS_PLAN_GRP:
-        {
-            ioc_fm_pcd_kg_cls_plan_grp_params_t *param;
-
-            param = (ioc_fm_pcd_kg_cls_plan_grp_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t));
-            if (!param)
-                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
-
-            if (copy_from_user(param, (ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t))) {
-                XX_Free(param);
-                RETURN_ERROR(MINOR, err, NO_MSG);
-            }
-
-            param->id = FM_PCD_KgSetClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgClsPlanGrpParams*)param);
-            if (param->id && !copy_to_user((ioc_fm_pcd_kg_cls_plan_grp_params_t *)arg, param, sizeof(ioc_fm_pcd_kg_cls_plan_grp_params_t)))
-                err = E_OK;
-
-            XX_Free(param);
-            break;
-        }
-
-        case FM_PCD_IOC_KG_DEL_CLS_PLAN:
-        {
-            ioc_fm_obj_t id;
-            if (copy_from_user(&id, (ioc_fm_obj_t *)arg, sizeof(ioc_fm_obj_t)))
-                break;
-            return FM_PCD_KgDeleteClsPlanGrp(p_LnxWrpFmDev->h_PcdDev, id.obj);
-        }
-
         case FM_PCD_IOC_KG_SET_SCHEME:
         {
             ioc_fm_pcd_kg_scheme_params_t               *param;
@@ -265,7 +230,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         case FM_PCD_IOC_CC_SET_NODE:
         {
             ioc_fm_pcd_cc_node_params_t *param;
-            uint8_t                     gbl_mask[4];
             uint8_t                     *keys;
             uint8_t                     *masks;
             int                         i,k;
@@ -289,19 +253,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
-            if (param->keys_params.p_glbl_mask &&
-                (param->keys_params.key_size <= 4)) {
-                if (copy_from_user(&gbl_mask,
-                                   param->keys_params.p_glbl_mask,
-                                   param->keys_params.key_size)) {
-                    XX_Free(masks);
-                    XX_Free(keys);
-                    XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-                param->keys_params.p_glbl_mask = gbl_mask;
-            }
-
             for (i=0,k=0; i<param->keys_params.num_of_keys; i++, k+=IOC_FM_PCD_MAX_SIZE_OF_KEY) {
                 if (copy_from_user(&keys[k],
                                param->keys_params.key_params[i].p_key,
@@ -346,9 +297,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         case FM_PCD_IOC_CC_BUILD_TREE:
         {
             ioc_fm_pcd_cc_tree_params_t         *param;
-            ioc_fm_pcd_cc_next_engine_params_t  *next_engine_per_entries_in_grp;
-            uint8_t                             numOfEntriesInGroup;
-            int                                 i;
 
             param = (ioc_fm_pcd_cc_tree_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_params_t));
             if (!param)
@@ -359,36 +307,11 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
-            for (i=0; i<param->num_of_groups; i++) {
-                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp) {
-                    numOfEntriesInGroup = (uint8_t)( 0x01 << param->fm_pcd_cc_group_params[i].num_of_distinction_units);
-                    if ((numOfEntriesInGroup ==0 ) || (numOfEntriesInGroup >= 16)) {
-                        XX_Free(param);
-                        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numOfEntriesInGroup"));
-                    }
-
-                    next_engine_per_entries_in_grp =
-                        (ioc_fm_pcd_cc_next_engine_params_t *)XX_Malloc(numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t));
-                    if (!next_engine_per_entries_in_grp)
-                        RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
-
-                    if (copy_from_user(next_engine_per_entries_in_grp,
-                                       param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp,
-                                       numOfEntriesInGroup*sizeof(ioc_fm_pcd_cc_next_engine_params_t))) {
-                        XX_Free(param);
-                        RETURN_ERROR(MINOR, err, NO_MSG);
-                    }
-                    param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp = next_engine_per_entries_in_grp;
-                }
-            }
-
             param->id = FM_PCD_CcBuildTree(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
+
             if (param->id && !copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_tree_params_t)))
                 err = E_OK;
 
-            for (i=0; i<param->num_of_groups; i++)
-                if (param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp)
-                    XX_Free(param->fm_pcd_cc_group_params[i].p_next_engine_per_entries_in_grp);
             XX_Free(param);
             break;
         }
@@ -456,7 +379,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 
         case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE:
         {
-            ioc_fm_pcd_cc_tree_modify_next_engine_params_t            *param;
+            ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param;
 
             param = (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
             if (!param)
@@ -657,19 +580,19 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
     {
         case FM_IOC_SET_PORTS_BANDWIDTH:
         {
-            ioc_ports_param_t *param;
+            t_FmPortsBandwidthParams *param;
 
-            param = (ioc_ports_param_t *)XX_Malloc(sizeof(ioc_ports_param_t));
+            param = (t_FmPortsBandwidthParams *)XX_Malloc(sizeof(t_FmPortsBandwidthParams));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
-            if (copy_from_user(param, (ioc_ports_param_t *)arg, sizeof(ioc_ports_param_t)))
+            if (copy_from_user(param, (t_FmPortsBandwidthParams *)arg, sizeof(t_FmPortsBandwidthParams)))
             {
                 XX_Free(param);
                 return err;
             }
 
-            err =  FM_SetPortsBandwidth(p_LnxWrpFmDev->h_Dev,(t_PortsParam*)param);
+            err =  FM_SetPortsBandwidth(p_LnxWrpFmDev->h_Dev, param);
             XX_Free(param);
             return err;
         }
@@ -772,6 +695,26 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             return FM_PORT_SetErrorsRoute(p_LnxWrpFmPortDev->h_Dev, (fmPortFrameErrSelect_t)errs);
         }
 
+        case FM_PORT_IOC_SET_RATE_LIMIT:
+        {
+            ioc_fm_port_rate_limit_t        *param;
+
+            param = (ioc_fm_port_rate_limit_t *)XX_Malloc(sizeof(ioc_fm_port_rate_limit_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            if (copy_from_user(param, (ioc_fm_port_rate_limit_t *)arg, sizeof(ioc_fm_port_rate_limit_t)))
+            {
+                XX_Free(param);
+                RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+            }
+
+            err =  FM_PORT_SetRateLimit(p_LnxWrpFmPortDev->h_Dev, (t_FmPortRateLimit *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
         case FM_PORT_IOC_ALLOC_PCD_FQIDS:
         {
             ioc_fm_port_pcd_fqids_params_t        *param;
@@ -813,7 +756,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             ioc_fm_port_pcd_kg_params_t     *port_pcd_kg_params;
             ioc_fm_port_pcd_plcr_params_t   *port_pcd_plcr_params;
             uint8_t                         copy_fail = 0;
-
             if ((port_pcd_params = (ioc_fm_port_pcd_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_params_t)))) {
                 if ((port_pcd_prs_params = (ioc_fm_port_pcd_prs_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_prs_params_t)))) {
                     if ((port_pcd_cc_params = (ioc_fm_port_pcd_cc_params_t *)XX_Malloc(sizeof(ioc_fm_port_pcd_cc_params_t)))) {
@@ -1006,27 +948,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         case FM_PORT_IOC_ATTACH_PCD:
             return FM_PORT_AttachPCD(p_LnxWrpFmPortDev->h_Dev);
 
-        case FM_PORT_IOC_PCD_KG_MODIFY_CLS_PLAN_GRP:
-        {
-            ioc_fm_pcd_port_cls_plan_params_t        *param;
-
-            param = (ioc_fm_pcd_port_cls_plan_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_port_cls_plan_params_t));
-            if (!param)
-                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
-
-            if (copy_from_user(param, (ioc_fm_pcd_port_cls_plan_params_t *)arg, sizeof(ioc_fm_pcd_port_cls_plan_params_t)))
-            {
-                XX_Free(param);
-                RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
-            }
-            err = FM_PORT_PcdKgModifyClsPlanGrp (p_LnxWrpFmPortDev->h_Dev,
-                                                 param->use_cls_plan,
-                                                 param->new_cls_plan_grp);
-
-            XX_Free(param);
-            return err;
-        }
-
         case FM_PORT_IOC_PCD_CC_MODIFY_TREE:
         {
             ioc_fm_obj_t id;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
index ff985bd..4b62be9 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
@@ -136,25 +136,6 @@ static bool in_big_phys_area (uint32_t addr)
 }
 #endif /* BIGPHYSAREA_ENABLE */
 
-#ifdef CONFIG_PREEMPT_RT
-uint32_t XX_DisableAllIntr_nort(void)
-{
-    unsigned long flags;
-
-    local_irq_save_nort(flags);
-
-    return (uint32_t)flags;
-}
-
-void XX_RestoreAllIntr_nort(uint32_t flags)
-{
-    local_irq_restore_nort(flags);
-}
-#else
-#define        XX_DisableAllIntr_nort(flags)   XX_DisableAllIntr(flags)
-#define        XX_RestoreAllIntr_nort(flags)   XX_RestoreAllIntr(flags)
-#endif
-
 void * xx_Malloc(uint32_t n)
 {
     void        *a;
@@ -393,7 +374,7 @@ uint32_t XX_DisableAllIntr(void)
 
 void XX_RestoreAllIntr(uint32_t flags)
 {
-    local_irq_restore(flags);
+    local_irq_restore((unsigned long)flags);
 }
 
 t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
@@ -524,9 +505,9 @@ t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data)
     INIT_WORK(p_Task, routine, data);
 #else
     t_Tasklet *p_Task = (t_Tasklet *)XX_Malloc(sizeof(t_Tasklet));
-    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
     p_Task->h_Data = data;
     p_Task->f_Callback = routine;
+    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
 #endif    /* LINUX_VERSION_CODE */
 
     return (t_TaskletHandle)p_Task;
@@ -605,6 +586,7 @@ t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet)
 }
 
 
+#if 0
 /*****************************************************************************/
 /*                       Semaphore Service Routines                          */
 /*****************************************************************************/
@@ -648,7 +630,7 @@ void XX_Unlock(t_MutexHandle h_Mutex)
     up((struct semaphore *)h_Mutex);
 }
 
-
+#endif /* 0 */
 /*****************************************************************************/
 /*                         Spinlock Service Routines                         */
 /*****************************************************************************/
@@ -795,7 +777,6 @@ void XX_UDelay(uint32_t usecs)
     udelay(usecs);
 }
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
 typedef struct {
     char            *p_Addr;
     t_MsgHandler    *f_MsgHandlerCB;
@@ -814,7 +795,7 @@ static void EnqueueMsgHndlr(t_MsgHndlr *p_MsgHndlr)
     LIST_AddToTail(&p_MsgHndlr->node, &msgHndlrList);
     XX_RestoreAllIntr(intFlags);
 }
-
+/* TODO: add this for multiplatform support
 static t_MsgHndlr * DequeueMsgHndlr(void)
 {
     t_MsgHndlr *p_MsgHndlr = NULL;
@@ -830,7 +811,7 @@ static t_MsgHndlr * DequeueMsgHndlr(void)
 
     return p_MsgHndlr;
 }
-
+*/
 static t_MsgHndlr * FindMsgHndlr(char *p_Addr)
 {
     t_MsgHndlr  *p_MsgHndlr;
@@ -899,4 +880,18 @@ t_Error XX_SendMessage(char                 *p_DestAddr,
 
     return ans;
 }
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Error XX_IpcRegisterMsgHandler(char                       addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandlerCallback    *f_MsgHandler,
+                                 t_Handle                   h_Module)
+{
+    UNUSED(addr);UNUSED(f_MsgHandler);UNUSED(h_Module);
+    return E_OK;
+}
+
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH])
+{
+    UNUSED(addr);
+    return E_OK;
+}
+
diff --git a/drivers/net/dpa/dpa-common.h b/drivers/net/dpa/dpa-common.h
index ed1d70d..3a23a59 100644
--- a/drivers/net/dpa/dpa-common.h
+++ b/drivers/net/dpa/dpa-common.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,30 +44,22 @@
 
 #define __hot
 
-#define cpu_pr_xxx(level, format, arg...) \
-	do {								\
-		int __id, __hid;					\
-		__id = raw_smp_processor_id();				\
-		__hid = get_hard_smp_processor_id(__id);		\
-		pr_##level("cpu%d/%d: " format, __hid, __id, ##arg);	\
-	} while (0)
-
 #define cpu_pr_emerg(format, arg...)	\
-	cpu_pr_xxx(emerg, format, ##arg)
+	pr_emerg("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_alert(format, arg...)	\
-	cpu_pr_xxx(alert, format, ##arg)
+	pr_alert("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_crit(format, arg...)	\
-	cpu_pr_xxx(crit, format, ##arg)
+	pr_crit("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_err(format, arg...)	\
-	cpu_pr_xxx(err, format, ##arg)
+	pr_err("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_warning(format, arg...)	\
-	cpu_pr_xxx(warning, format, ##arg)
+	pr_warning("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_notice(format, arg...)	\
-	cpu_pr_xxx(notice, format, ##arg)
+	pr_notice("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_info(format, arg...)	\
-	cpu_pr_xxx(info, format, ##arg)
+	pr_info("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 #define cpu_pr_debug(format, arg...)	\
-	cpu_pr_xxx(debug, format, ##arg)
+	pr_debug("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
 
 /* Keep these in sync with the dev_*() definitions from linux/device.h */
 #define cpu_dev_emerg(dev, format, arg...)	\
diff --git a/drivers/net/dpa/dpa-ethtool.c b/drivers/net/dpa/dpa-ethtool.c
index 3cead01..3eea79b 100644
--- a/drivers/net/dpa/dpa-ethtool.c
+++ b/drivers/net/dpa/dpa-ethtool.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -32,35 +32,27 @@
 
 #include <linux/string.h>
 
-#include "dpa.h"
+#include "dpaa_eth.h"
 
 static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
 {
 	int			 _errno;
 	struct dpa_priv_s	*priv;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
 
 	if (priv->mac_dev == NULL) {
-		cpu_netdev_info(net_dev,
-				"%s:%hu:%s(): This is a MAC-less interface\n",
-				__file__, __LINE__, __func__);
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
 		return -ENODEV;
 	}
 	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
-			       __file__, __LINE__, __func__);
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
 		return -ENODEV;
 	}
 
 	_errno = phy_ethtool_gset(priv->mac_dev->phy_dev, et_cmd);
 	if (unlikely(_errno < 0))
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_ethtool_gset() = %d\n",
-			       __file__, __LINE__, __func__, _errno);
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+		cpu_netdev_err(net_dev, "phy_ethtool_gset() = %d\n", _errno);
 
 	return _errno;
 }
@@ -70,28 +62,20 @@ static int __cold dpa_set_settings(struct net_device *net_dev, struct ethtool_cm
 	int			 _errno;
 	struct dpa_priv_s	*priv;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
 
 	if (priv->mac_dev == NULL) {
-		cpu_netdev_info(net_dev,
-				"%s:%hu:%s(): This is a MAC-less interface\n",
-				__file__, __LINE__, __func__);
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
 		return -ENODEV;
 	}
 	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
-			       __file__, __LINE__, __func__);
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
 		return -ENODEV;
 	}
 
 	_errno = phy_ethtool_sset(priv->mac_dev->phy_dev, et_cmd);
 	if (unlikely(_errno < 0))
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_ethtool_sset() = %d\n",
-			       __file__, __LINE__, __func__, _errno);
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+		cpu_netdev_err(net_dev, "phy_ethtool_sset() = %d\n", _errno);
 
 	return _errno;
 }
@@ -100,8 +84,6 @@ static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_dr
 {
 	int		 _errno;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
 	strncpy(drvinfo->driver, KBUILD_MODNAME,
 		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->driver)-1] = 0;
 	strncpy(drvinfo->version, VERSION,
@@ -109,39 +91,23 @@ static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_dr
 	_errno = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%X", 0);
 
 	if (unlikely(_errno >= sizeof(drvinfo->fw_version))) {	/* Truncated output */
-		cpu_netdev_notice(net_dev, "%s:%hu:%s(): snprintf() = %d\n",
-				  __file__, __LINE__, __func__, _errno);
+		cpu_netdev_notice(net_dev, "snprintf() = %d\n", _errno);
 	} else if (unlikely(_errno < 0)) {
-		cpu_netdev_warn(net_dev, "%s:%hu:%s(): snprintf() = %d\n",
-				__file__, __LINE__, __func__, _errno);
+		cpu_netdev_warn(net_dev, "snprintf() = %d\n", _errno);
 		memset(drvinfo->fw_version, 0, sizeof(drvinfo->fw_version));
 	}
 	strncpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),
 		sizeof(drvinfo->bus_info) - 1)[sizeof(drvinfo->bus_info)-1] = 0;
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
 }
 
 uint32_t __cold dpa_get_msglevel(struct net_device *net_dev)
 {
-	uint32_t	 msg_enable;
-
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	msg_enable = ((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable;
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
-	return msg_enable;
+	return ((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable;
 }
 
 void __cold dpa_set_msglevel(struct net_device *net_dev, uint32_t msg_enable)
 {
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
 	((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable = msg_enable;
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
 }
 
 int __cold dpa_nway_reset(struct net_device *net_dev)
@@ -149,19 +115,14 @@ int __cold dpa_nway_reset(struct net_device *net_dev)
 	int			 _errno;
 	struct dpa_priv_s	*priv;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
 
 	if (priv->mac_dev == NULL) {
-		cpu_netdev_info(net_dev,
-				"%s:%hu:%s(): This is a MAC-less interface\n",
-				__file__, __LINE__, __func__);
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
 		return -ENODEV;
 	}
 	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
-			       __file__, __LINE__, __func__);
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
 		return -ENODEV;
 	}
 
@@ -169,19 +130,15 @@ int __cold dpa_nway_reset(struct net_device *net_dev)
 	if (priv->mac_dev->phy_dev->autoneg) {
 		_errno = phy_start_aneg(priv->mac_dev->phy_dev);
 		if (unlikely(_errno < 0))
-			cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_start_aneg() = %d\n",
-				       __file__, __LINE__, __func__, _errno);
+			cpu_netdev_err(net_dev, "phy_start_aneg() = %d\n",
+					_errno);
 	}
 
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
 void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringparam *et_ringparam)
 {
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
 	et_ringparam->rx_max_pending	   = 0;
 	et_ringparam->rx_mini_max_pending  = 0;
 	et_ringparam->rx_jumbo_max_pending = 0;
@@ -191,59 +148,48 @@ void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringpar
 	et_ringparam->rx_mini_pending	   = 0;
 	et_ringparam->rx_jumbo_pending	   = 0;
 	et_ringparam->tx_pending	   = 0;
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
 }
 
 void __cold dpa_get_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
 {
 	struct dpa_priv_s	*priv;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
 
 	if (priv->mac_dev == NULL) {
-		cpu_netdev_info(net_dev,
-				"%s:%hu:%s(): This is a MAC-less interface\n",
-				__file__, __LINE__, __func__);
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
 		return;
 	}
 	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
-			       __file__, __LINE__, __func__);
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
 		return;
 	}
 
 	et_pauseparam->autoneg	= priv->mac_dev->phy_dev->autoneg;
-
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
 }
 
 int __cold dpa_set_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
 {
 	struct dpa_priv_s	*priv;
 
-	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
 
 	if (priv->mac_dev == NULL) {
-		cpu_netdev_info(net_dev,
-				"%s:%hu:%s(): This is a MAC-less interface\n",
-				__file__, __LINE__, __func__);
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
 		return -ENODEV;
 	}
 	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
-			       __file__, __LINE__, __func__);
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
 		return -ENODEV;
 	}
 
 	priv->mac_dev->phy_dev->autoneg = et_pauseparam->autoneg;
 
-	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+	return 0;
+}
 
+u32 dpa_get_rx_csum(struct net_device *dev)
+{
 	return 0;
 }
 
@@ -259,7 +205,8 @@ const struct ethtool_ops dpa_ethtool_ops __devinitconst = {
 	.get_pauseparam		= dpa_get_pauseparam,
 	.set_pauseparam		= dpa_set_pauseparam,
 	.get_tx_csum		= ethtool_op_get_tx_csum,
-	.set_tx_csum		= ethtool_op_set_tx_csum,
+	.set_tx_csum		= ethtool_op_set_tx_ipv6_csum,
+	.get_rx_csum		= dpa_get_rx_csum,
 	.get_sg			= ethtool_op_get_sg,
 	.set_sg			= ethtool_op_set_sg,
 	.get_tso		= ethtool_op_get_tso,
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
deleted file mode 100644
index 142bb22..0000000
--- a/drivers/net/dpa/dpa.c
+++ /dev/null
@@ -1,2522 +0,0 @@
-/* Copyright (c) 2008 - 2010, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/sort.h>
-#include <linux/of_mdio.h>
-#include <linux/of_platform.h>
-#include <linux/io.h>
-#include <linux/etherdevice.h>
-#include <linux/if_arp.h>	/* arp_hdr_len() */
-#include <linux/if_vlan.h>	/* VLAN_HLEN */
-#include <linux/icmp.h>		/* struct icmphdr */
-#include <linux/ip.h>		/* struct iphdr */
-#include <linux/udp.h>		/* struct udphdr */
-#include <linux/tcp.h>		/* struct tcphdr */
-#include <linux/highmem.h>
-#include <linux/percpu.h>
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
-#endif
-#ifdef CONFIG_PPC85xx_VT_MODE
-#include <vbi/vbi.h>
-#endif
-
-#include "linux/fsl_bman.h"
-
-#include "fsl_fman.h"
-#include "fm_ext.h"
-
-#ifdef CONFIG_FSL_FMAN_TEST
-#include "fsl_fman_test.h"
-#endif /* CONFIG_FSL_FMAN_TEST */
-
-#include "dpa.h"
-
-#define ARRAY2_SIZE(arr)	(ARRAY_SIZE(arr) * ARRAY_SIZE((arr)[0]))
-
-#define DPA_NETIF_FEATURES	0
-#define DEFAULT_COUNT		256
-#define DPA_MAX_TX_BACKLOG	512
-
-#define DPA_DESCRIPTION "FSL DPA Ethernet driver"
-
-MODULE_LICENSE("Dual BSD/GPL");
-
-MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
-
-MODULE_DESCRIPTION(DPA_DESCRIPTION);
-
-static uint8_t debug = 0;
-module_param(debug, byte, S_IRUGO);
-MODULE_PARM_DESC(debug, "Module/Driver verbosity level");
-
-static uint16_t __devinitdata tx_timeout = 1000;
-module_param(tx_timeout, ushort, S_IRUGO);
-MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
-
-#ifdef CONFIG_DEBUG_FS
-static struct dentry *dpa_debugfs_root;
-#endif
-
-static const char rtx[][3] = {
-	[RX] = "RX",
-	[TX] = "TX"
-};
-
-#ifdef	CONFIG_PPC85xx_VT_MODE
-static u64 guest_dma_offset;
-
-#define dpa_bus_to_virt(addr) 	\
-	__va(addr - guest_dma_offset)
-#else
-#define	dpa_bus_to_virt(addr)	\
-	bus_to_virt(addr)
-#endif
-
-/* BM */
-
-#ifdef DEBUG
-#define GFP_DPA_BP     (GFP_DMA | __GFP_ZERO | GFP_ATOMIC)
-#else
-#define GFP_DPA_BP     (GFP_DMA | GFP_ATOMIC)
-#endif
-
-#define DPA_BP_HEAD	64
-#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + (s))
-
-#define DPA_HASH_MULTIPLE 2
-
-#define FM_FD_STAT_ERRORS							  \
-	(FM_PORT_FRM_ERR_DMA			| FM_PORT_FRM_ERR_PHYSICAL	| \
-	 FM_PORT_FRM_ERR_SIZE			| FM_PORT_FRM_ERR_CLS_DISCARD	| \
-	 FM_PORT_FRM_ERR_EXTRACTION		| FM_PORT_FRM_ERR_NO_SCHEME	| \
-	 FM_PORT_FRM_ERR_ILL_PLCR		| FM_PORT_FRM_ERR_PRS_TIMEOUT	| \
-	 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT	| FM_PORT_FRM_ERR_PRS_HDR_ERR)
-
-struct dpa_bp {
-	struct bman_pool		*pool;
-	bool                            kernel_pool;
-	union {
-		struct list_head	list;
-		uint8_t			bpid;
-	};
-	size_t				count;
-	size_t				size;
- 	dma_addr_t			paddr;
- 	void				*vaddr;
-};
-
-static const size_t dpa_bp_size[] __devinitconst = {
-	/* Keep these sorted */
-	DPA_BP_SIZE(FSL_FMAN_PHY_MAXFRM)
-};
-
-static struct dpa_bp *dpa_bp_array[64];
-
-static void __cold dpa_bp_depletion(struct bman_portal	*portal,
-				    struct bman_pool	*pool,
-				    void		*cb_ctx,
-				    int			 depleted)
-{
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	BUG();
-
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-}
-
-static struct dpa_bp * __must_check __attribute__((nonnull))
-dpa_size2pool(const struct list_head *list, size_t size)
-{
-	struct dpa_bp	*dpa_bp;
-
-	list_for_each_entry(dpa_bp, list, list) {
-		if (DPA_BP_SIZE(size) <= dpa_bp->size)
-			return dpa_bp;
-	}
-	return ERR_PTR(-ENODEV);
-}
-
-static struct dpa_bp * __must_check __attribute__((nonnull))
-dpa_bpid2pool(int bpid)
-{
-	return dpa_bp_array[bpid];
-}
-
-static int __cold __must_check __attribute__((nonnull))
-dpa_pool2bpid(const struct dpa_bp *dpa_bp)
-{
-	return bman_get_params(dpa_bp->pool)->bpid;
-}
-
-static int __devinit __must_check __cold __attribute__((nonnull))
-_dpa_bp_alloc(struct net_device *net_dev, struct list_head *list,
-		struct dpa_bp *dpa_bp)
-{
-	int			 _errno;
-	struct bman_pool_params	 bp_params;
-	const struct dpa_priv_s	*priv;
-
-	BUG_ON(dpa_bp->size == 0);
-	BUG_ON(dpa_bp->count == 0);
-
-	bp_params.flags		= BMAN_POOL_FLAG_DEPLETION;
-	bp_params.cb		= dpa_bp_depletion;
-	bp_params.cb_ctx	= dpa_bp;
-
-	if (dpa_bp->bpid == 0)
-		bp_params.flags |= BMAN_POOL_FLAG_DYNAMIC_BPID;
-	else
-		bp_params.bpid = dpa_bp->bpid;
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	dpa_bp->pool = bman_new_pool(&bp_params);
-	if (unlikely(dpa_bp->pool == NULL)) {
-		if (netif_msg_drv(priv))
-			cpu_dev_err(net_dev->dev.parent, "%s:%hu:%s(): "
-				    "bman_new_pool() failed\n",
-				    __file__, __LINE__, __func__);
-		return -ENODEV;
-	}
-
-	  	if (dpa_bp->paddr == 0) {
- 		int i;
- 		dpa_bp->vaddr = alloc_pages_exact(dpa_bp->size * dpa_bp->count,
- 						GFP_DPA_BP);
- 		if (!dpa_bp->vaddr) {
-  			_errno = -ENOMEM;
-  			goto _return_bman_free_pool;
-  		}
-
-		dpa_bp->kernel_pool = true;
-  
- 		dpa_bp->paddr = dma_map_single(net_dev->dev.parent,
- 						dpa_bp->vaddr,
- 						dpa_bp->size * dpa_bp->count,
- 						DMA_BIDIRECTIONAL);
- 
- 		if (dpa_bp->paddr == 0) {
- 			_errno = -EIO;
- 			goto _return_free_pages_exact;
- 		}
- 
- 		for (i = 0; i < dpa_bp->count; i++) {
- 			struct bm_buffer bmb;
-  
- 			bmb.hi = 0;
- 			bmb.lo = dpa_bp->paddr + i * dpa_bp->size;
- 
- 			_errno = bman_release(dpa_bp->pool, &bmb, 1,
- 						BMAN_RELEASE_FLAG_WAIT |
- 						BMAN_RELEASE_FLAG_WAIT_INT);
- 			if (_errno < 0) {
- 				goto _return_bman_acquire;
- 			}
- 		}
-  	} else {
-		dpa_bp->kernel_pool = false;
-  		devm_request_mem_region(net_dev->dev.parent, dpa_bp->paddr,
-  					dpa_bp->size * dpa_bp->count,
-  					KBUILD_MODNAME);
-		dpa_bp->vaddr = devm_ioremap_prot(net_dev->dev.parent,
-					dpa_bp->paddr,
-						  dpa_bp->size * dpa_bp->count,
-						  0);
-		if (unlikely(dpa_bp->vaddr == NULL)) {
-			if (netif_msg_drv(priv))
-				cpu_dev_err(net_dev->dev.parent, "%s:%hu:%s(): "
-					    "devm_ioremap() failed\n",
-					    __file__, __LINE__, __func__);
-			_errno = -EIO;
-			goto _return_bman_free_pool;
-		}
-	}
-
-	list_add_tail(&dpa_bp->list, list);
-	dpa_bp_array[dpa_pool2bpid(dpa_bp)] = dpa_bp;
-
-	return 0;
-
-_return_bman_acquire:
-	dma_unmap_single(net_dev->dev.parent, dpa_bp->paddr,
-				dpa_bp->size * dpa_bp->count,
-				DMA_BIDIRECTIONAL);
-_return_free_pages_exact:
-	free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
-_return_bman_free_pool:
-	bman_free_pool(dpa_bp->pool);
-
-	return _errno;
-}
-
-static inline void * __must_check __attribute__((nonnull))
-dpa_phys2virt(const struct dpa_bp *dpa_bp, const struct bm_buffer *bmb)
-{
-	return dpa_bp->vaddr + (bmb->lo - dpa_bp->paddr);
-}
-
-static void __cold __attribute__((nonnull))
-_dpa_bp_free(struct device *dev, struct dpa_bp *dpa_bp)
-{
-	uint8_t	bpid;
-	struct bm_buffer bmb[8];
-
-	if (dpa_bp->kernel_pool) {
-		 while (bman_acquire(dpa_bp->pool, bmb, 8, 0) == 8)
-			;
-
-		dma_unmap_single(dev, dpa_bp->paddr,
-			dpa_bp->size * dpa_bp->count, DMA_BIDIRECTIONAL);
-		free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
-	}
-	bpid = dpa_pool2bpid(dpa_bp);
-	dpa_bp_array[bpid] = 0;
-	bman_free_pool(dpa_bp->pool);
-	list_del(&dpa_bp->list);
-}
-
-static void __cold __attribute__((nonnull))
-dpa_bp_free(struct device *dev, struct list_head *list)
-{
-	struct dpa_bp	*dpa_bp, *tmp;
-
-	list_for_each_entry_safe(dpa_bp, tmp, list, list)
-		_dpa_bp_free(dev, dpa_bp);
-}
-
-/* QM */
-
-struct dpa_fq {
-	struct qman_fq	 	 fq_base;
-	struct list_head	 list;
-	struct net_device	*net_dev;
-	bool			 init;
-};
-
-static struct qman_fq * __devinit __cold __must_check __attribute__((nonnull))
-_dpa_fq_alloc(struct list_head		*list,
-	      struct dpa_fq		*dpa_fq,
-	      uint32_t			 fqid,
-	      uint32_t			 flags,
-	      uint16_t			 channel,
-	      uint8_t			 wq)
-{
-	int			 _errno;
-	const struct dpa_priv_s	*priv;
-	struct device		*dev;
-	struct qman_fq		*fq;
-	struct qm_mcc_initfq	 initfq;
-
-	priv = (typeof(priv))netdev_priv(dpa_fq->net_dev);
-	dev = dpa_fq->net_dev->dev.parent;
-
-	if (fqid == 0) {
-		flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
-		flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
-	} else {
-		flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
-	}
-
-	dpa_fq->init	= !(flags & QMAN_FQ_FLAG_NO_MODIFY);
-
-	_errno = qman_create_fq(fqid, flags, &dpa_fq->fq_base);
-	if (unlikely(_errno)) {
-		if (netif_msg_drv(priv))
-			cpu_dev_err(dev,
-				"%s:%hu:%s(): qman_create_fq() failed\n",
-				__file__, __LINE__, __func__);
-		return ERR_PTR(_errno);
-	}
-	fq = &dpa_fq->fq_base;
-
-	if (dpa_fq->init) {
-		initfq.we_mask		= QM_INITFQ_WE_DESTWQ;
-		initfq.fqd.dest.channel	= channel;
-		initfq.fqd.dest.wq	= wq;
-
-		_errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
-		if (unlikely(_errno < 0)) {
-			if (netif_msg_drv(priv))
-				cpu_dev_err(dev,
-					"%s:%hu:%s(): qman_init_fq(%u) = %d\n",
-					__file__, __LINE__, __func__,
-					qman_fq_fqid(fq), _errno);
-			qman_destroy_fq(fq, 0);
-			return ERR_PTR(_errno);
-		}
-	}
-
-	list_add_tail(&dpa_fq->list, list);
-
-	return fq;
-}
-
-static int __cold __attribute__((nonnull))
-_dpa_fq_free(struct device *dev, struct qman_fq *fq)
-{
-	int			 _errno, __errno;
-	struct dpa_fq		*dpa_fq;
-	const struct dpa_priv_s	*priv;
-
-	_errno = 0;
-
-	dpa_fq = container_of(fq, struct dpa_fq, fq_base);
-	priv = (typeof(priv))netdev_priv(dpa_fq->net_dev);
-
-	if (dpa_fq->init) {
-		_errno = qman_retire_fq(fq, NULL);
-		if (unlikely(_errno < 0) && netif_msg_drv(priv))
-			cpu_dev_err(dev,
-				"%s:%hu:%s(): qman_retire_fq(%u) = %d\n",
-				__file__, __LINE__, __func__, qman_fq_fqid(fq),
-				_errno);
-
-		__errno = qman_oos_fq(fq);
-		if (unlikely(__errno < 0) && netif_msg_drv(priv)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): qman_oos_fq(%u) = %d\n",
-					__file__, __LINE__, __func__,
-					qman_fq_fqid(fq), __errno);
-			if (_errno >= 0)
-				_errno = __errno;
-		}
-	}
-
-	qman_destroy_fq(fq, 0);
-	list_del(&dpa_fq->list);
-
-	return _errno;
-}
-
-static int __cold __attribute__((nonnull))
-dpa_fq_free(struct device *dev, struct list_head *list)
-{
-	int		 _errno, __errno;
-	struct dpa_fq	*dpa_fq, *tmp;
-
-	_errno = 0;
-	list_for_each_entry_safe(dpa_fq, tmp, list, list) {
-		__errno = _dpa_fq_free(dev, (struct qman_fq *)dpa_fq);
-		if (unlikely(__errno < 0) && _errno >= 0)
-			_errno = __errno;
-	}
-
-	return _errno;
-}
-
-struct dpa_fd {
-	struct qm_fd		 fd;
-	struct list_head	 list;
-};
-
-static inline ssize_t __const __must_check __attribute__((nonnull))
-dpa_fd_length(const struct qm_fd *fd)
-{
-	if ((fd->format & 0x3) == 0)
-		return fd->length20;
-	else
-		return fd->length29;
-}
-
-static inline ssize_t __const __must_check __attribute__((nonnull))
-dpa_fd_offset(const struct qm_fd *fd)
-{
-	if ((fd->format == qm_fd_contig) || (fd->format == qm_fd_sg))
-		return fd->offset;
-	else
-		return 0;
-}
-
-static int __must_check __attribute__((nonnull))
-dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
-{
-	int				 _errno, __errno, i, j;
-	const struct dpa_priv_s		*priv;
-	const struct qm_sg_entry	*sgt;
-	struct dpa_bp		*_dpa_bp, *dpa_bp;
-	struct bm_buffer		 _bmb, bmb[8];
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	_bmb.hi	= fd->addr_hi;
-	_bmb.lo	= fd->addr_lo;
-
-	_dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(_dpa_bp));
-
-	_errno = 0;
-	if (fd->format == qm_fd_sg) {
-		sgt = (dpa_phys2virt(_dpa_bp, &_bmb) + dpa_fd_offset(fd));
-
-		i = 0;
-		do {
-			dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-			BUG_ON(IS_ERR(dpa_bp));
-
-			j = 0;
-			do {
-				BUG_ON(sgt[i].extension);
-
-				bmb[j].hi	= sgt[i].addr_hi;
-				bmb[j].lo	= sgt[i].addr_lo;
-				j++; i++;
-			} while (j < ARRAY_SIZE(bmb) &&
-					!sgt[i-1].final &&
-					sgt[i-1].bpid == sgt[i].bpid);
-
-			__errno = bman_release(dpa_bp->pool, bmb, j, 0);
-			if (unlikely(__errno < 0)) {
-				if (netif_msg_drv(priv) && net_ratelimit())
-					cpu_netdev_err(net_dev,	"%s:%hu:%s(): "
-					       "bman_release(%hu) = %d\n",
-					       __file__, __LINE__, __func__,
-					       bman_get_params(dpa_bp->pool)->bpid,
-					       _errno);
-				if (_errno >= 0)
-  					_errno = __errno;
-  			}
-  		} while (!sgt[i-1].final);
-  	}
-  
- 	__errno = bman_release(_dpa_bp->pool, &_bmb, 1, 0);
- 	if (unlikely(__errno < 0)) {
- 		if (netif_msg_drv(priv) && net_ratelimit())
- 			cpu_netdev_err(net_dev, "%s:%hu:%s(): "
-  					"bman_release(%hu) = %d\n",
-  					__file__, __LINE__, __func__,
-  					bman_get_params(_dpa_bp->pool)->bpid,
-  					__errno);
- 		if (_errno >= 0)
- 			_errno = __errno;
-  	}
-  
-  	return _errno;
-}
-
-/* net_device */
-
-#define NN_ALLOCATED_SPACE(net_dev)	max((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
-#define NN_RESERVED_SPACE(net_dev)	min((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
-
-#define TT_ALLOCATED_SPACE(net_dev)	\
-	max(sizeof(struct icmphdr), max(sizeof(struct udphdr), sizeof(struct tcphdr)))
-#define TT_RESERVED_SPACE(net_dev)	\
-	min(sizeof(struct icmphdr), min(sizeof(struct udphdr), sizeof(struct tcphdr)))
-
-static enum qman_cb_dqrr_result __hot
-ingress_dqrr(struct qman_portal		*portal,
-	     struct qman_fq		*fq,
-	     const struct qm_dqrr_entry	*dq,
-	     uint8_t			 _rtx,
-	     uint8_t			 ed)
-{
-	struct net_device		*net_dev;
-	struct dpa_priv_s		*priv;
-	struct dpa_percpu_priv_s	*percpu_priv;
-	struct dpa_fd			*dpa_fd;
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = netdev_priv(net_dev);
-
-	if (netif_msg_intr(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s[%s][%hu]()\n",
-			       __file__, __func__, rtx[_rtx], ed);
-
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
-	percpu_priv->hwi[_rtx][ed]++;
-
-	if (list_empty(&percpu_priv->free_list)) {
-		dpa_fd = devm_kzalloc(net_dev->dev.parent,
-				sizeof(*dpa_fd), GFP_ATOMIC);
-		if (unlikely(dpa_fd == NULL)) {
-			if (netif_msg_rx_err(priv) && net_ratelimit())
-				cpu_netdev_err(net_dev,
-					"%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-			goto _return;
-		}
-	} else {
-		dpa_fd = list_first_entry(&percpu_priv->free_list,
-					typeof(*dpa_fd), list);
-		list_del(&dpa_fd->list);
-	}
-
-	dpa_fd->fd = dq->fd;
-
-	list_add_tail(&dpa_fd->list, &percpu_priv->fd_list[_rtx][ed]);
-	percpu_priv->count[_rtx][ed]++;
-	percpu_priv->max[_rtx][ed] = max(percpu_priv->max[_rtx][ed],
-					 percpu_priv->count[_rtx][ed]);
-
-	if (_rtx == TX && percpu_priv->count[_rtx][ed] > DPA_MAX_TX_BACKLOG)
-		netif_tx_stop_all_queues(net_dev);
-
-	tasklet_schedule(&percpu_priv->dpa_task);
-
-_return:
-	if (netif_msg_intr(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s[%s][%hu]() ->\n",
-			       __file__, __func__, rtx[_rtx], ed);
-
-	return qman_cb_dqrr_consume;
-}
-
-static enum qman_cb_dqrr_result
-ingress_rx_error_dqrr(struct qman_portal		*portal,
-		      struct qman_fq			*fq,
-		      const struct qm_dqrr_entry	*dq)
-{
-#ifdef CONFIG_FSL_FMAN_TEST
-{
-	struct net_device	*net_dev;
-	const struct dpa_priv_s	*priv;
-	void			*virt = dpa_bus_to_virt(dq->fd.addr_lo);
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	/* No support yet for more than 32 bit address */
-	BUG_ON(dq->fd.addr_hi);
-	if (is_fman_test((void *)priv->mac_dev,
-			 FMT_RX_ERR_Q,
-			 virt,
-			 dq->fd.length20 + dq->fd.offset))
-		return qman_cb_dqrr_consume;
-}
-#endif	/* CONFIG_FSL_FMAN_TEST */
-
-	return ingress_dqrr(portal, fq, dq, RX, 0);
-}
-
-static enum qman_cb_dqrr_result __hot
-ingress_rx_default_dqrr(struct qman_portal		*portal,
-			struct qman_fq			*fq,
-			const struct qm_dqrr_entry	*dq)
-{
-#ifdef CONFIG_FSL_FMAN_TEST
-{
-	int				 _errno, i;
-	const struct net_device		*net_dev;
-	const struct dpa_priv_s		*priv;
-	struct dpa_fq			*dpa_fq;
-	void				*virt;
-	uint32_t			 fqid = 0;
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	for(i=0; i<priv->num; i++) {
-		if((dq->fqid >= priv->ranges[i].base) &&
-		   (dq->fqid < (priv->ranges[i].base+priv->ranges[i].count))) {
-			fqid = dq->fqid - priv->ranges[i].base;
-			break;
-		}
-	}
-
-	if (i == priv->num)
-		fqid = FMT_RX_DFLT_Q;
-
-	if (fqid == FMT_RX_DFLT_Q) {
-		list_for_each_entry(dpa_fq, priv->dpa_fq_list + RX, list) {
-			if (dq->fqid ==
-				qman_fq_fqid((struct qman_fq *)dpa_fq)) {
-				fqid = FMT_RX_ERR_Q;
-				break;
-			}
-		}
-		if (fqid == FMT_RX_ERR_Q)
-			fqid = FMT_RX_DFLT_Q;
-		else
-			BUG();
-	}
-
-    virt = dpa_bus_to_virt(dq->fd.addr_lo);
-    /* No support yet for more than 32 bit address */
-    BUG_ON(dq->fd.addr_hi);
-    if (is_fman_test((void *)priv->mac_dev,
-                     fqid,
-                     virt,
-                     dq->fd.length20 + dq->fd.offset)) {
-        _errno = dpa_fd_release(net_dev, &dq->fd);
-        if (unlikely(_errno < 0)) {
-            dump_stack();
-            panic("Can't release buffer to the BM during RX\n");
-        }
-	return qman_cb_dqrr_consume;
-    }
-}
-#endif /* CONFIG_FSL_FMAN_TEST */
-
-	return ingress_dqrr(portal, fq, dq, RX, 1);
-}
-
-static enum qman_cb_dqrr_result
-ingress_tx_error_dqrr(struct qman_portal		*portal,
-		      struct qman_fq			*fq,
-		      const struct qm_dqrr_entry	*dq)
-{
-#ifdef CONFIG_FSL_FMAN_TEST
-{
-	const struct net_device	*net_dev;
-	const struct dpa_priv_s	*priv;
-	void   *virt = dpa_bus_to_virt(dq->fd.addr_lo);
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	/* No support yet for more than 32 bit address */
-	BUG_ON(dq->fd.addr_hi);
-	if (is_fman_test((void *)priv->mac_dev,
-			 FMT_TX_ERR_Q,
-			 virt,
-			 dq->fd.length20 + dq->fd.offset))
-		return qman_cb_dqrr_consume;
-}
-#endif /* CONFIG_FSL_FMAN_TEST */
-
-	return ingress_dqrr(portal, fq, dq, TX, 0);
-}
-
-static enum qman_cb_dqrr_result __hot
-ingress_tx_default_dqrr(struct qman_portal		*portal,
-			struct qman_fq			*fq,
-			const struct qm_dqrr_entry	*dq)
-{
-#ifdef CONFIG_FSL_FMAN_TEST
-{
-	struct net_device		*net_dev;
-	const struct dpa_priv_s		*priv;
-	void   *virt = dpa_bus_to_virt(dq->fd.addr_lo);
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = netdev_priv(net_dev);
-
-    /* No support yet for more than 32 bit address */
-	BUG_ON(dq->fd.addr_hi);
-	if (is_fman_test((void *)priv->mac_dev,
-			 FMT_TX_CONF_Q,
-			 virt,
-			 dq->fd.length20 + dq->fd.offset))
-		return qman_cb_dqrr_consume;
-}
-#endif /* CONFIG_FSL_FMAN_TEST */
-
-	return ingress_dqrr(portal, fq, dq, TX, 1);
-}
-
-static void egress_ern(struct qman_portal	*portal,
-		       struct qman_fq		*fq,
-		       const struct qm_mr_entry	*msg)
-{
-	int			 _errno;
-	struct net_device	*net_dev;
-	const struct dpa_priv_s	*priv;
-	struct sk_buff		*skb;
-	struct dpa_percpu_priv_s	*percpu_priv;
-
-	net_dev = ((struct dpa_fq *)fq)->net_dev;
-	priv = (typeof(priv))netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
-
-	if (netif_msg_intr(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	if (priv->mac_dev) {
-		skb = *(typeof(&skb))dpa_bus_to_virt(msg->ern.fd.addr_lo);
-
-		BUG_ON(net_dev != skb->dev);
-
-		dma_unmap_single(net_dev->dev.parent, msg->ern.fd.addr_lo,
-				skb_headlen(skb), DMA_TO_DEVICE);
-
-		dev_kfree_skb_irq(skb);
-	} else {
-		_errno = dpa_fd_release(net_dev, &msg->ern.fd);
-		if (unlikely(_errno < 0)) {
-			dump_stack();
-			panic("Can't release buffer to the BM during a TX\n");
-		}
-	}
-
-	percpu_priv->stats.tx_dropped++;
-	percpu_priv->stats.tx_fifo_errors++;
-
-	if (netif_msg_intr(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static const struct qman_fq ingress_fqs[][2] __devinitconst = {
-	[RX] = {
-		/* Error */
-		{.cb = {ingress_rx_error_dqrr, NULL, NULL, NULL} },
-		 /* Default */
-		{.cb = {ingress_rx_default_dqrr, NULL, NULL, NULL} }
-	},
-	[TX] = {
-		/* Error */
-		{.cb = {ingress_tx_error_dqrr, NULL, NULL, NULL} },
-		 /* Default */
-		{.cb = {ingress_tx_default_dqrr, NULL, NULL, NULL} }
-	}
-};
-
-static const struct qman_fq _egress_fqs __devinitconst = {
-	.cb = {NULL, egress_ern, NULL, NULL}
-};
-
-static struct net_device_stats * __cold
-dpa_get_stats(struct net_device *net_dev)
-{
-	struct dpa_priv_s *priv = netdev_priv(net_dev);
-	unsigned long *netstats;
-	unsigned long *cpustats;
-	int i, j;
-	struct dpa_percpu_priv_s	*percpu_priv;
-	int numstats = sizeof(net_dev->stats) / sizeof(unsigned long);
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	netstats = (unsigned long *)&net_dev->stats;
-
-	memset(netstats, 0, sizeof(net_dev->stats));
-
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		cpustats = (unsigned long *)&percpu_priv->stats;
-
-		for (j = 0; j < numstats; j++)
-			netstats[j] += cpustats[j];
-	}
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
-	return &net_dev->stats;
-}
-
-static int __cold dpa_change_mtu(struct net_device *net_dev, int new_mtu)
-{
-	const struct dpa_priv_s	*priv;
-	const int max_mtu =
-		FSL_FMAN_PHY_MAXFRM - (VLAN_ETH_HLEN + ETH_FCS_LEN);
-	const int min_mtu = 64;
-
-	priv = netdev_priv(net_dev);
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	/* Make sure we don't exceed the Ethernet controller's MAXFRM */
-	if (new_mtu < min_mtu || new_mtu > max_mtu) {
-		if (netif_msg_drv(priv))
-			cpu_netdev_err(net_dev,
-				"%s:%hu:%s():"
-				"Invalid L3 mtu %d "
-				"(must be between %d and %d).\n",
-				__file__, __LINE__, __func__,
-				new_mtu, min_mtu, max_mtu);
-		return -EINVAL;
-	}
-	net_dev->mtu = new_mtu;
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	return 0;
-}
-
-static void __cold dpa_change_rx_flags(struct net_device *net_dev, int flags)
-{
-	int			 _errno;
-	const struct dpa_priv_s	*priv;
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	if ((flags & IFF_PROMISC) != 0 && priv->mac_dev != NULL) {
-		_errno = priv->mac_dev->change_promisc(priv->mac_dev);
-		if (unlikely(_errno < 0) && netif_msg_drv(priv))
-			cpu_netdev_err(net_dev,
-				"%s:%hu:%s(): mac_dev->change_promisc() = %d\n",
-				__file__, __LINE__, __func__, _errno);
-	}
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static int dpa_process_one(struct net_device *net_dev, struct sk_buff *skb,
-				struct dpa_bp *dpa_bp, const struct qm_fd *fd)
-{
-	int err;
-
- 	memcpy(skb_put(skb, dpa_fd_length(fd)),
- 			dpa_phys2virt(dpa_bp, (struct bm_buffer *)fd) +
- 			dpa_fd_offset(fd),
- 			dpa_fd_length(fd));
-  
- 	err = dpa_fd_release(net_dev, fd);
- 	if (err < 0) {
- 		dump_stack();
- 		panic("Can't release buffer to BM during RX\n");		
-	}
-
-	return 0;
-}
-
-static void _dpa_rx_error(struct net_device		*net_dev,
-			  const struct dpa_priv_s	*priv,
-			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct dpa_fd		*dpa_fd)
-{
-	int _errno;
-
-	if (netif_msg_hw(priv) && net_ratelimit())
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): FD status = 0x%08x\n",
-			       __file__, __LINE__, __func__,
-			       dpa_fd->fd.status & FM_FD_STAT_ERRORS);
-
-	percpu_priv->stats.rx_errors++;
-	percpu_priv->stats.rx_packets++;
-	percpu_priv->stats.rx_bytes += dpa_fd_length(&dpa_fd->fd);
-
-	_errno = dpa_fd_release(net_dev, &dpa_fd->fd);
-	if (unlikely(_errno < 0)) {
-		dump_stack();
-		panic("Can't release buffer to the BM during RX\n");
-	}
-}
-
-static void _dpa_tx_error(struct net_device		*net_dev,
-			  const struct dpa_priv_s	*priv,
-			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct dpa_fd		*dpa_fd)
-{
-	struct sk_buff *skb;
-
-	if (netif_msg_hw(priv) && net_ratelimit())
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): FD status = 0x%08x\n",
-			       __file__, __LINE__, __func__,
-			       dpa_fd->fd.status & FM_FD_STAT_ERRORS);
-
-	percpu_priv->stats.tx_errors++;
-
-	skb = *(typeof(&skb))bus_to_virt(dpa_fd->fd.addr_lo);
-
-	dma_unmap_single(net_dev->dev.parent, dpa_fd->fd.addr_lo,
-			 skb_headlen(skb), DMA_TO_DEVICE);
-
-	if (skb_queue_len(&percpu_priv->rx_recycle) < DEFAULT_COUNT &&
-	    skb_recycle_check(skb, NET_IP_ALIGN + ETH_HLEN +
-			      NN_ALLOCATED_SPACE(net_dev) +
-			      TT_ALLOCATED_SPACE(net_dev)))
-		__skb_queue_head(&percpu_priv->rx_recycle, skb);
-	else
-		dev_kfree_skb(skb);
-}
-
-static void __hot _dpa_rx(struct net_device		*net_dev,
-			  const struct dpa_priv_s	*priv,
-			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct dpa_fd		*dpa_fd)
-{
-	int _errno;
-	struct dpa_bp *dpa_bp;
-	size_t size;
-	struct sk_buff *skb;
-
-	if (unlikely(dpa_fd->fd.status & FM_FD_STAT_ERRORS) != 0) {
-		if (netif_msg_hw(priv) && net_ratelimit())
-			cpu_netdev_warn(net_dev,
-					"%s:%hu:%s(): FD status = 0x%08x\n",
-					__file__, __LINE__, __func__,
-					dpa_fd->fd.status & FM_FD_STAT_ERRORS);
-
-		percpu_priv->stats.rx_errors++;
-
-		goto _return_dpa_fd_release;
-	}
-
-	percpu_priv->stats.rx_packets++;
-	percpu_priv->stats.rx_bytes += dpa_fd_length(&dpa_fd->fd);
-
-	dpa_bp = dpa_bpid2pool(dpa_fd->fd.bpid);
-	BUG_ON(IS_ERR(dpa_bp));
-
-	if (dpa_fd->fd.format == qm_fd_sg) {
-		percpu_priv->stats.rx_dropped++;
-		if (netif_msg_rx_status(priv) && net_ratelimit())
-			cpu_netdev_err(net_dev, "%s:%hu:%s(): Dropping a SG frame\n",
-			       __file__, __LINE__, __func__);
-		goto _return_dpa_fd_release;
-	}
-
-	skb = NULL;
-	size = dpa_fd_length(&dpa_fd->fd);
-
-	/* FMan has stripped off the FCS from the frame, don't count it in.
-	 *
-	 * Because we don't know whether this is an ETH or VLAN frame,
-	 * we'll restrict the VLAN frame's L3 PDU rather than letting a
-	 * larger ETH frame slip through and risk a buffer overflow.
-	 */
-	if (size - ETH_HLEN > net_dev->mtu) {
-		percpu_priv->stats.rx_dropped++;
-		goto _return_dpa_fd_release;
-	}
-
-	if (skb == NULL) {
-		skb = __netdev_alloc_skb(net_dev,
-				DPA_BP_HEAD + NET_IP_ALIGN + size, GFP_ATOMIC);
-		if (unlikely(skb == NULL)) {
-			if (netif_msg_rx_err(priv) && net_ratelimit())
-				cpu_netdev_err(net_dev, "%s:%hu:%s(): "
-					       "__netdev_alloc_skb() failed\n",
-					       __file__, __LINE__, __func__);
-
-			percpu_priv->stats.rx_dropped++;
-
-			goto _return_dpa_fd_release;
-		}
-	}
-
-	skb_reserve(skb, NET_IP_ALIGN+DPA_BP_HEAD);
-
-	/* Fill the SKB */
-	_errno = dpa_process_one(net_dev, skb, dpa_bp, &dpa_fd->fd);
-
-	if (unlikely(_errno < 0)) {
-		percpu_priv->stats.rx_dropped++;
-		goto _return_dev_kfree_skb;
-	}
-
-	skb->protocol = eth_type_trans(skb, net_dev);
-
-#ifdef CONFIG_FSL_FMAN_TEST
-	fman_test_ip_manip((void *)priv->mac_dev, skb->data);
-#endif /* CONFIG_FSL_FMAN_TEST */
-
-	if (unlikely(netif_receive_skb(skb) != NET_RX_SUCCESS))
-		percpu_priv->stats.rx_dropped++;
-  
-  	net_dev->last_rx = jiffies;
-  
-  	return;
-  
-_return_dev_kfree_skb:
-	dev_kfree_skb(skb);
-_return_dpa_fd_release:
-	_errno = dpa_fd_release(net_dev, &dpa_fd->fd);
-	if (unlikely(_errno < 0)) {
-		dump_stack();
-		panic("Can't release buffer to the BM during RX\n");
-	}
-}
-
-static void __hot _dpa_tx(struct net_device		*net_dev,
-			  const struct dpa_priv_s	*priv,
-			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct dpa_fd		*dpa_fd)
-{
-	struct sk_buff	*skb;
-
-	if (unlikely(dpa_fd->fd.status & FM_FD_STAT_ERRORS) != 0) {
-		if (netif_msg_hw(priv) && net_ratelimit())
-			cpu_netdev_warn(net_dev,
-					"%s:%hu:%s(): FD status = 0x%08x\n",
-					__file__, __LINE__, __func__,
-					dpa_fd->fd.status & FM_FD_STAT_ERRORS);
-
-		percpu_priv->stats.tx_errors++;
-	}
-
-	skb = *(typeof(&skb))dpa_bus_to_virt(dpa_fd->fd.addr_lo);
-
-	BUG_ON(net_dev != skb->dev);
-
-	dma_unmap_single(net_dev->dev.parent, dpa_fd->fd.addr_lo,
-			 skb_headlen(skb), DMA_TO_DEVICE);
-
-	if (skb_queue_len(&percpu_priv->rx_recycle) < DEFAULT_COUNT &&
-	    skb_recycle_check(skb, NET_IP_ALIGN + ETH_HLEN +
-			      NN_ALLOCATED_SPACE(net_dev) +
-			      TT_ALLOCATED_SPACE(net_dev)))
-		__skb_queue_head(&percpu_priv->rx_recycle, skb);
-	else
-		dev_kfree_skb(skb);
-}
-
-static void (*const _dpa_work[][2])(struct net_device		*net_dev,
-				    const struct dpa_priv_s	*priv,
-				    struct dpa_percpu_priv_s	*percpu_priv,
-				    const struct dpa_fd		*dpa_fd) =
-{
-	[RX] = {_dpa_rx_error, _dpa_rx},
-	[TX] = {_dpa_tx_error, _dpa_tx}
-};
-
-static void __hot dpa_tasklet(unsigned long data)
-{
-	int i, j;
-	struct net_device *net_dev;
-	const struct dpa_priv_s *priv;
-	struct dpa_percpu_priv_s *percpu_priv =
-				(struct dpa_percpu_priv_s *)data;
-	struct dpa_fd *dpa_fd, *tmp;
-	unsigned int quota = 0;
-	unsigned int retry = 0;
-
-	net_dev = percpu_priv->net_dev;
-	priv = netdev_priv(net_dev);
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	BUG_ON(percpu_priv != per_cpu_ptr(priv->percpu_priv,
-					  smp_processor_id()));
-
-	percpu_priv->swi++;
-
-	/* RX, TX */
-	for (i = ARRAY_SIZE(percpu_priv->fd_list) - 1; i >= 0; i--) {
-		/* Error, default*/
-		for (j = 0; j < ARRAY_SIZE(percpu_priv->fd_list[i]); j++) {
-			list_for_each_entry_safe(dpa_fd, tmp,
-						 &percpu_priv->fd_list[i][j],
-						 list) {
-			_dpa_work[i][j](net_dev, priv, percpu_priv, dpa_fd);
-
-			local_irq_disable();
-			list_del(&dpa_fd->list);
-			percpu_priv->count[i][j]--;
-			percpu_priv->total[i][j]++;
-			list_add_tail(&dpa_fd->list, &percpu_priv->free_list);
-			local_irq_enable();
-
-			if (++quota > 32) {
-				quota = 0;
-				retry = 1;
-				break;
-			}
-			}
-		}
-	}
-
-	if (netif_queue_stopped(net_dev) &&
-			percpu_priv->count[TX][1] < DPA_MAX_TX_BACKLOG)
-		netif_tx_wake_all_queues(net_dev);
-
-	/* Try again later if we're not done */
-	if (retry)
-		tasklet_schedule(&percpu_priv->dpa_task);
-
-	if (netif_msg_drv(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
-{
-	int			 _errno, __errno;
-	const struct dpa_priv_s	*priv;
-	struct device		*dev;
-	struct qm_fd		 fd;
-	struct dpa_bp		*dpa_bp = NULL;
-	struct bm_buffer	*bmb = NULL;
-	unsigned int	headroom;
-	struct dpa_percpu_priv_s *percpu_priv;
-
-	priv = netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
-	dev = net_dev->dev.parent;
-
-	if (netif_msg_tx_queued(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	/* We don't have yet support for SG */
-	SKB_LINEAR_ASSERT(skb);
-
-	memset(&fd, 0, sizeof(fd));
-	fd.format	= qm_fd_contig;
-
-	headroom = skb_headroom(skb);
-
-	if (headroom < sizeof(skb)) {
-		struct sk_buff *skb_new;
-
-		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
-		if (!skb_new) {
-			percpu_priv->stats.tx_errors++;
-			kfree_skb(skb);
-			return NETDEV_TX_OK;
-		}
-		kfree_skb(skb);
-		skb = skb_new;
-		headroom = DPA_BP_HEAD;
-	}
-
-	fd.offset	= headroom;
-
-	if (priv->mac_dev) {
-		*((typeof(&skb))skb_push(skb, headroom)) = skb;
-
-		fd.addr_lo = dma_map_single(dev, skb->data, skb_headlen(skb),
-				DMA_TO_DEVICE);
-		if (unlikely(fd.addr_lo == 0)) {
-			if (netif_msg_tx_err(priv)  && net_ratelimit())
-				cpu_netdev_err(net_dev,
-				"%s:%hu:%s(): dma_map_single() failed\n",
-				__file__, __LINE__, __func__);
-			_errno = -EIO;
-			goto _return_dev_kfree_skb;
-		}
-
-		fd.length20	= skb_headlen(skb) - headroom;
-	} else {
-		dpa_bp = dpa_size2pool(&priv->dpa_bp_list, skb_headlen(skb));
-		BUG_ON(IS_ERR(dpa_bp));
-
-		bmb = (typeof(bmb))&fd;
-
-		_errno = bman_acquire(dpa_bp->pool, bmb, 1, 0);
-		if (unlikely(_errno <= 0)) {
-			if (netif_msg_tx_err(priv) && net_ratelimit())
-				cpu_netdev_err(net_dev,
-					"%s:%hu:%s(): bman_acquire() = %d\n",
-					__file__, __LINE__, __func__, _errno);
-			percpu_priv->stats.tx_errors++;
-			goto _return_dev_kfree_skb;
-		}
-
-		fd.length20	= skb_headlen(skb);
-		fd.cmd		= FM_FD_CMD_FCO;
-
-		/* Copy the packet payload */
-		skb_copy_from_linear_data(skb,
-			dpa_phys2virt(dpa_bp, bmb) + dpa_fd_offset(&fd),
-			dpa_fd_length(&fd));
-	}
-
-	_errno = qman_enqueue(priv->egress_fqs[skb_get_queue_mapping(skb)],
-			&fd, 0);
-	if (unlikely(_errno < 0)) {
-		if (netif_msg_tx_err(priv) && net_ratelimit())
-			cpu_netdev_err(net_dev,
-				"%s:%hu:%s(): qman_enqueue() = %d\n",
-				__file__, __LINE__, __func__, _errno);
-		percpu_priv->stats.tx_errors++;
-		percpu_priv->stats.tx_fifo_errors++;
-		goto _return_buffer;
-	}
-
-	net_dev->trans_start = jiffies;
-
-	percpu_priv->stats.tx_packets++;
-	percpu_priv->stats.tx_bytes += dpa_fd_length(&fd);
-
-	_errno = NETDEV_TX_OK;
-
-	if (priv->mac_dev)
-		goto _return;
-	else
-		goto _return_dev_kfree_skb;
-
-_return_buffer:
-	if (priv->mac_dev)
-		dma_unmap_single(dev, fd.addr_lo, skb_headlen(skb),
-			DMA_TO_DEVICE);
-	else {
-		__errno = dpa_fd_release(net_dev, &fd);
-		if (unlikely(__errno < 0)) {
-			dump_stack();
-			panic("Can't release buffer to the BM during a TX\n");
-		}
-	}
-_return_dev_kfree_skb:
-	dev_kfree_skb(skb);
-_return:
-	if (netif_msg_tx_queued(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-static int __cold dpa_start(struct net_device *net_dev)
-{
-	int			 _errno, i;
-	const struct dpa_priv_s	*priv;
-	struct mac_device	*mac_dev;
-
-	priv = netdev_priv(net_dev);
-	mac_dev = priv->mac_dev;
-
-	if (netif_msg_ifup(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	if (mac_dev) {
-		_errno = mac_dev->init_phy(net_dev);
-		if (unlikely(_errno < 0)) {
-			if (netif_msg_ifup(priv))
-				cpu_netdev_err(net_dev,
-					"%s:%hu:%s(): init_phy() = %d\n",
-					__file__, __LINE__, __func__, _errno);
-			goto _return;
-		}
-
-		for_each_port_device(i, mac_dev->port_dev)
-			fm_port_enable(mac_dev->port_dev[i]);
-
-		_errno = priv->mac_dev->start(mac_dev);
-		if (unlikely(_errno < 0)) {
-			if (netif_msg_ifup(priv))
-				cpu_netdev_err(net_dev,
-					"%s:%hu:%s(): mac_dev->start() = %d\n",
-					__file__, __LINE__, __func__, _errno);
-			goto _return_port_dev_stop;
-		}
-	}
-
-	netif_tx_start_all_queues(net_dev);
-
-	_errno = 0;
-	goto _return;
-
-_return_port_dev_stop:
-	for_each_port_device(i, mac_dev->port_dev)
-		fm_port_disable(mac_dev->port_dev[i]);
-_return:
-	if (netif_msg_ifup(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-static int __cold dpa_stop(struct net_device *net_dev)
-{
-	int			 _errno, __errno, i;
-	const struct dpa_priv_s	*priv;
-	struct mac_device	*mac_dev;
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-	mac_dev = priv->mac_dev;
-
-	if (netif_msg_ifdown(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	netif_tx_stop_all_queues(net_dev);
-
-	_errno = 0;
-	if (mac_dev) {
-		__errno = mac_dev->stop(mac_dev);
-		if (unlikely(__errno < 0)) {
-			if (netif_msg_ifdown(priv))
-				cpu_netdev_err(net_dev,
-					"%s:%hu:%s(): mac_dev->stop() = %d\n",
-					__file__, __LINE__, __func__, __errno);
-			if (likely(_errno >= 0))
-				_errno = __errno;
-		}
-
-		for_each_port_device(i, mac_dev->port_dev)
-			fm_port_disable(mac_dev->port_dev[i]);
-
-		if (mac_dev->phy_dev)
-			phy_disconnect(mac_dev->phy_dev);
-		mac_dev->phy_dev = NULL;
-	}
-
-	if (netif_msg_ifdown(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-static void __cold dpa_timeout(struct net_device *net_dev)
-{
-	const struct dpa_priv_s	*priv;
-	struct dpa_percpu_priv_s *percpu_priv;
-
-	priv = netdev_priv(net_dev);
-	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
-
-	if (netif_msg_timer(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	if (netif_msg_timer(priv))
-		cpu_netdev_crit(net_dev, "Transmit timeout latency: %lu ms\n",
-				(jiffies - net_dev->trans_start) * 1000 / HZ);
-
-	percpu_priv->stats.tx_errors++;
-
-	if (netif_msg_timer(priv))
-		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static int __devinit __cold __pure __must_check __attribute__((nonnull))
-dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
-{
-	return ((struct dpa_bp *)dpa_bp0)->size -
-			((struct dpa_bp *)dpa_bp1)->size;
-}
-
-static struct dpa_bp * __devinit __cold __must_check __attribute__((nonnull))
-dpa_bp_probe(struct of_device *_of_dev, size_t *count)
-{
-	int			 i, lenp, na, ns;
-	struct device		*dev;
-	struct device_node	*dev_node;
-	const phandle		*phandle_prop;
-	const uint32_t		*uint32_prop;
-	struct dpa_bp		*dpa_bp;
-
-	dev = &_of_dev->dev;
-
-	/* Get the buffer pools to be used */
-	phandle_prop = (typeof(phandle_prop))of_get_property(_of_dev->node,
-					"fsl,bman-buffer-pools", &lenp);
-	if (phandle_prop == NULL) {
-		dpa_bp = NULL;
-		goto _return_count;
-	}
-
-	*count = lenp / sizeof(phandle);
-	dpa_bp = (typeof(dpa_bp))devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
-	if (unlikely(dpa_bp == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
-			    __file__, __LINE__, __func__);
-		dpa_bp = ERR_PTR(-ENOMEM);
-		goto _return_count;
-	}
-
-	dev_node = of_find_node_by_path("/");
-	if (unlikely(dev_node == NULL)) {
-		cpu_dev_err(dev,
-			"%s:%hu:%s(): of_find_node_by_path(/) failed\n",
-			__file__, __LINE__, __func__);
-		dpa_bp = ERR_PTR(-EINVAL);
-		goto _return_count;
-	}
-
-	na = of_n_addr_cells(dev_node);
-	ns = of_n_size_cells(dev_node);
-	of_node_put(dev_node);
-
-	for (i = 0; i < *count; i++) {
-		dev_node = of_find_node_by_phandle(phandle_prop[i]);
-		if (unlikely(dev_node == NULL)) {
-			cpu_dev_err(dev,
-			      "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
-				__file__, __LINE__, __func__);
-			return ERR_PTR(-EFAULT);
-		}
-
-		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
-			cpu_dev_err(dev, "%s:%hu:%s(): !of_device_is_compatible(%s, fsl,bpool)\n",
-				    __file__, __LINE__, __func__, dev_node->full_name);
-			dpa_bp = ERR_PTR(-EINVAL);
-			goto _return_of_node_put;
-		}
-
-		uint32_prop = of_get_property(dev_node, "fsl,bpid", &lenp);
-		if (unlikely(uint32_prop == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,bpid) failed\n",
-				    __file__, __LINE__, __func__, dev_node->full_name);
-			dpa_bp = ERR_PTR(-EINVAL);
-			goto _return_of_node_put;
-		}
-		BUG_ON(lenp != sizeof(uint32_t));
-		dpa_bp[i].bpid = *uint32_prop;
-
-		uint32_prop = of_get_property(dev_node, "fsl,bpool-cfg", &lenp);
-		if (uint32_prop != NULL) {
-			BUG_ON(lenp != (2 * ns + na) * sizeof(uint32_t));
-
-			dpa_bp[i].count	= of_read_number(uint32_prop, ns);
-			dpa_bp[i].size	= of_read_number(uint32_prop + ns, ns);
-			dpa_bp[i].paddr	= of_read_number(uint32_prop + 2 * ns,
-						na);
-		}
-
-		of_node_put(dev_node);
-	}
-
-	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
-
-	goto _return;
-
-_return_of_node_put:
-	of_node_put(dev_node);
-_return_count:
-	*count = 0;
-_return:
-	return dpa_bp;
-}
-
-static struct mac_device * __devinit __cold __must_check
-__attribute__((nonnull))
-dpa_mac_probe(struct of_device *_of_dev)
-{
-	struct device		*dpa_dev, *dev;
-	struct device_node	*mac_node;
-	int			 lenp;
-	const phandle		*phandle_prop;
-	struct of_device	*of_dev;
-	struct mac_device	*mac_dev;
-
-	phandle_prop = of_get_property(_of_dev->node, "fsl,fman-mac", &lenp);
-	if (phandle_prop == NULL)
-		return NULL;
-
-	BUG_ON(lenp != sizeof(phandle));
-
-	dpa_dev = &_of_dev->dev;
-
-	mac_node = of_find_node_by_phandle(*phandle_prop);
-	if (unlikely(mac_node == NULL)) {
-		cpu_dev_err(dpa_dev,
-			    "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
-			__file__, __LINE__, __func__);
-		return ERR_PTR(-EFAULT);
-	}
-
-	of_dev = of_find_device_by_node(mac_node);
-	if (unlikely(of_dev == NULL)) {
-		cpu_dev_err(dpa_dev,
-			"%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
-			__file__, __LINE__, __func__, mac_node->full_name);
-		of_node_put(mac_node);
-		return ERR_PTR(-EINVAL);
-	}
-	of_node_put(mac_node);
-
-	dev = &of_dev->dev;
-
-	mac_dev = (typeof(mac_dev))dev_get_drvdata(dev);
-	if (unlikely(mac_dev == NULL)) {
-		cpu_dev_err(dpa_dev,
-			"%s:%hu:%s(): dev_get_drvdata(%s) failed\n",
-			__file__, __LINE__, __func__, dev_name(dev));
-		return ERR_PTR(-EINVAL);
-	}
-
-	return mac_dev;
-}
-
-static const char fsl_qman_frame_queues[][25] __devinitconst = {
-	[RX] = "fsl,qman-frame-queues-rx",
-	[TX] = "fsl,qman-frame-queues-tx"
-};
-
-#ifdef CONFIG_FSL_QMAN_FQRANGE
-static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
-						uint32_t	 num,
-						uint8_t		 alignment,
-						uint32_t	*base_fqid)
-{
-	int			 _errno, i;
-	struct net_device	*net_dev;
-	struct dpa_priv_s	*priv;
-	struct dpa_fq		*dpa_fq;
-	struct qman_fq		*ingress_fq;
-	int					 num_allocated;
-	u32					 base_allocated;
-
-	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	num_allocated = qman_alloc_fqid_range(&base_allocated, num, alignment, 0);
-	if ((num_allocated <= 0) ||
-		(num_allocated < num) ||
-		(base_allocated % alignment)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev, "%s:%hu:%s(): Failed to allocate an FQs range (%d)\n",
-				    __file__, __LINE__, __func__, num);
-		_errno = -EINVAL;
-		goto _return;
-	}
-
-	cpu_dev_dbg(dev, "wanted %d align %d, got %d fqids@%d\n",num, alignment, num_allocated, base_allocated);
-
-	*base_fqid = base_allocated;
-
-	dpa_fq = (typeof(dpa_fq))devm_kzalloc(dev, num_allocated * sizeof(*dpa_fq), GFP_KERNEL);
-	if (unlikely(dpa_fq == NULL)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
-				    __file__, __LINE__, __func__);
-		_errno = -ENOMEM;
-		goto _return;
-	}
-
-	for (i = 0, ingress_fq = NULL; i < num_allocated; i++, dpa_fq++) {
-		dpa_fq->fq_base	= ingress_fqs[RX][1];
-		dpa_fq->net_dev	= net_dev;
-		ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, base_allocated++,
-					   QMAN_FQ_FLAG_NO_ENQUEUE, priv->channel, 7);
-		if (IS_ERR(ingress_fq)) {
-			_errno = PTR_ERR(ingress_fq);
-			goto _return;
-		}
-	}
-
-	BUG_ON(priv->num >= (sizeof(priv->ranges)/sizeof(struct pcd_range)));
-	priv->ranges[priv->num].base    = *base_fqid;
-	priv->ranges[priv->num++].count = num;
-
-	_errno = 0;
-
-_return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-#else
-static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
-						uint32_t	 num,
-						uint8_t		 alignment,
-						uint32_t	*base_fqid)
-{
-	int			 _errno, i;
-	struct net_device	*net_dev;
-	struct dpa_priv_s	*priv;
-	struct dpa_fq		*dpa_fq;
-	struct qman_fq		*ingress_fq;
-	uint32_t			 total_num_fqs = num + alignment;
-	uint32_t			 padding = 0;
-	uint32_t			prev_fqid;
-
-	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	dpa_fq = devm_kzalloc(dev, total_num_fqs * sizeof(*dpa_fq), GFP_KERNEL);
-	if (unlikely(dpa_fq == NULL)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-		_errno = -ENOMEM;
-		goto _return;
-	}
-
-	for (i = 0, ingress_fq = NULL; i < total_num_fqs; i++, dpa_fq++) {
-		dpa_fq->fq_base	= ingress_fqs[RX][1];
-		dpa_fq->net_dev	= net_dev;
-		prev_fqid = (ingress_fq ? qman_fq_fqid(ingress_fq) : 0);
-		ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, 0,
-				QMAN_FQ_FLAG_NO_ENQUEUE, priv->channel, 7);
-		if (IS_ERR(ingress_fq)) {
-			_errno = PTR_ERR(ingress_fq);
-			goto _return;
-		}
-
-		if (prev_fqid && ((prev_fqid - 1) != qman_fq_fqid(ingress_fq))) {
-			if (netif_msg_probe(priv))
-				cpu_dev_err(dev, "%s:%hu:%s(): Failed to allocate a contiguous range of FQs\n",
-					    __file__, __LINE__, __func__);
-			_errno = -EINVAL;
-			goto _return;
-		}
-
-		cpu_dev_dbg(dev, "%s:%s(): ingress_pcd_fqs[%d] = %u\n",
-			    __file__, __func__, i, qman_fq_fqid(ingress_fq));
-	}
-
-	*base_fqid = qman_fq_fqid(ingress_fq);
-	if (alignment)
-		padding = alignment - (*base_fqid % alignment);
-	*base_fqid += padding;
-	BUG_ON((total_num_fqs-padding)<num);
-
-	BUG_ON(priv->num >= (sizeof(priv->ranges)/sizeof(struct pcd_range)));
-	priv->ranges[priv->num].base    = *base_fqid;
-	priv->ranges[priv->num++].count = num;
-
-	cpu_dev_dbg(dev, "%s:%s(): pcd_fqs base %u\n", __file__, __func__,
-			*base_fqid);
-
-	_errno = 0;
-
-_return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-#endif /* CONFIG_FSL_QMAN_FQRANGE */
-
-static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
-{
-	return smp_processor_id();
-}
-
-static const struct net_device_ops dpa_netdev_ops = {
-	.ndo_open = dpa_start,
-	.ndo_start_xmit = dpa_tx,
-	.ndo_stop = dpa_stop,
-	.ndo_change_rx_flags = dpa_change_rx_flags,
-	.ndo_tx_timeout = dpa_timeout,
-	.ndo_get_stats = dpa_get_stats,
-	.ndo_set_mac_address = eth_mac_addr,
-	.ndo_validate_addr = eth_validate_addr,
-	.ndo_select_queue = dpa_select_queue,
-	.ndo_change_mtu = dpa_change_mtu,
-};
-
-static int __devinit __cold __attribute__((nonnull))
-dpa_init_probe(struct of_device *_of_dev)
-{
-	int				 _errno, i, j, lenp;
-	struct device			*dev;
-	struct mac_device		*mac_dev;
-	struct dpa_bp			*dpa_bp;
-	struct fm_port_rx_params	 rx_port_param;
-	struct fm_port_non_rx_params	 tx_port_param;
-	struct fm_port_pcd_param	 rx_port_pcd_param;
-	size_t				 count;
-	struct device_node		*dpa_node;
-	const uint32_t			*uint32_prop;
-	uint32_t	    ingress_fqids[ARRAY_SIZE(fsl_qman_frame_queues)][2];
-
-	dev = &_of_dev->dev;
-
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
-	dpa_node = _of_dev->node;
-
-	if (!of_device_is_available(dpa_node))
-		return -ENODEV;
-
-	/* FM */
-
-	mac_dev = dpa_mac_probe(_of_dev);
-	if (IS_ERR(mac_dev)) {
-		_errno = PTR_ERR(mac_dev);
-		goto _return;
-	} else if(mac_dev == NULL) {
-		cpu_dev_err(dev, "%s:%hu:%s(): "
-			    "Missing the %s/fsl,fman-mac property\n",
-			    __file__, __LINE__, __func__, dpa_node->full_name);
-		_errno = -EINVAL;
-		goto _return;
-	}
-
-	/* BM */
-
-	dpa_bp = dpa_bp_probe(_of_dev, &count);
-	if (IS_ERR(dpa_bp)) {
-		_errno = PTR_ERR(dpa_bp);
-		goto _return;
-	} else if (unlikely(dpa_bp == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): "
-			    "Missing %s/fsl,bman-buffer-pools property\n",
-			    __file__, __LINE__, __func__, dpa_node->full_name);
-		_errno = -EINVAL;
-		goto _return;
-	}
-
-	rx_port_param.num_pools = min(ARRAY_SIZE(rx_port_param.pool_param), count);
-	for (i = 0; i < rx_port_param.num_pools; i++) {
-		rx_port_param.pool_param[i].id	 = dpa_bp[i].bpid;
-		rx_port_param.pool_param[i].size = dpa_bp[i].size;
-
-		cpu_dev_dbg(dev, "%s:%s(): dpa_bp[%d] = {%hu, %u}\n",
-				__file__, __func__, i,
-				rx_port_param.pool_param[i].id,
-				rx_port_param.pool_param[i].size);
-	}
-	devm_kfree(dev, dpa_bp);
-
-	/* QM */
-
-	for (i = 0; i < ARRAY_SIZE(ingress_fqids); i++) {
-		uint32_prop = (typeof(uint32_prop))of_get_property(dpa_node,
-				fsl_qman_frame_queues[i], &lenp);
-		if (unlikely(uint32_prop == NULL)) {
-			cpu_dev_err(dev,
-				"%s:%hu:%s(): of_get_property(%s, %s) failed\n",
-				__file__, __LINE__, __func__,
-				dpa_node->full_name, fsl_qman_frame_queues[i]);
-			_errno = -EINVAL;
-			goto _return;
-		}
-		BUG_ON(lenp != ARRAY_SIZE(ingress_fqids[i]) * 2 * sizeof(uint32_t));
-
-		for (j = 0; j < ARRAY_SIZE(ingress_fqids[i]); j++) {
-			ingress_fqids[i][j] = uint32_prop[j * 2];
-			BUG_ON(uint32_prop[j * 2 + 1] != 1);
-		}
-	}
-
-	/* Set error FQs */
-	rx_port_param.errq	= ingress_fqids[RX][0];
-	tx_port_param.errq	= ingress_fqids[TX][0];
-
-	/* Set default FQs */
-	rx_port_param.defq	= ingress_fqids[RX][1];
-	tx_port_param.defq	= ingress_fqids[TX][1];
-
-	rx_port_param.priv_data_size	=
-		tx_port_param.priv_data_size	= 32;
-	rx_port_param.parse_results	=
-		tx_port_param.parse_results	= true;
-	rx_port_param.hash_results	=
-		tx_port_param.hash_results	= false;
-
-	fm_set_rx_port_params(mac_dev->port_dev[RX], &rx_port_param);
-
-	/* Set PCD FQs */
-	rx_port_pcd_param.cb	= dpa_alloc_pcd_fqids;
-	rx_port_pcd_param.dev	= dev;
-	fm_port_pcd_bind(mac_dev->port_dev[RX], &rx_port_pcd_param);
-
-	fm_set_tx_port_params(mac_dev->port_dev[TX], &tx_port_param);
-
-	for_each_port_device(i, mac_dev->port_dev)
-		fm_port_enable(mac_dev->port_dev[i]);
-
-	_errno = 0;
-
-_return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-#ifdef CONFIG_DEBUG_FS
-static int __cold dpa_debugfs_show(struct seq_file *file, void *offset)
-{
-	int				 i, j, k;
-	struct dpa_priv_s		*priv;
-	struct dpa_percpu_priv_s	*percpu_priv, total;
-
-	BUG_ON(offset == NULL);
-
-	priv = (typeof(priv))netdev_priv((struct net_device *)file->private);
-
-	memset(&total, 0, sizeof(total));
-
-	seq_printf(file, "      hwi[RX]    hwi[TX]    swi        "
-		   "total[RX]  max[RX]    total[TX]  max[TX]\n");
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		for (j = 0; j < ARRAY_SIZE(total.total); j++)
-			for (k = 0; k < ARRAY_SIZE(total.total[j]); k++) {
-				total.total[j][k] += percpu_priv->total[j][k];
-				total.max[j][k]	  += percpu_priv->max[j][k];
-				total.hwi[j][k]	  += percpu_priv->hwi[j][k];
-			}
-		total.swi += percpu_priv->swi;
-
-		seq_printf(file, "%hu/%hu   0x%08x 0x%08x 0x%08x "
-			   "0x%08x 0x%08x 0x%08x 0x%08x\n",
-			   get_hard_smp_processor_id(i), i,
-			   percpu_priv->hwi[RX][1], percpu_priv->hwi[TX][1],
-			   percpu_priv->swi,
-			   percpu_priv->total[RX][1], percpu_priv->max[RX][1],
-			   percpu_priv->total[TX][1], percpu_priv->max[TX][1]);
-	}
-	seq_printf(file, "Total 0x%08x 0x%08x 0x%08x "
-		   "0x%08x 0x%08x 0x%08x 0x%08x\n",
-		   total.hwi[RX][1], total.hwi[TX][1], total.swi,
-		   total.total[RX][1], total.max[RX][1],
-		   total.total[TX][1], total.max[TX][1]);
-
-	return 0;
-}
-
-static int __cold dpa_debugfs_open(struct inode *inode, struct file *file)
-{
-	int	_errno;
-	const struct net_device	*net_dev;
-
-	if (unlikely(_errno < 0)) {
-		net_dev = (struct net_device *)inode->i_private;
-
-		if (netif_msg_drv((struct dpa_priv_s *)netdev_priv(net_dev)))
-			cpu_netdev_err(net_dev, "%s:%hu:%s(): "
-				       "single_open() = %d\n",
-				       __file__, __LINE__, __func__, _errno);
-	}
-	return _errno;
-}
-
-static const struct file_operations dpa_debugfs_fops = {
-	.open		= dpa_debugfs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-#endif
-
-static const uint32_t default_fqids[][6] __devinitconst = {
-	[RX] = {0, 1, 0, 1},
-	[TX] = {0, 1, 0, 1, 0, ARRAY_SIZE(((struct dpa_priv_s *)0)->egress_fqs)}
-};
-
-static int __devinit __cold __attribute__((nonnull))
-dpa_probe(struct of_device *_of_dev)
-{
-	int				 _errno, i, j, k, lenp;
-	struct device			*dev;
-	struct device_node		*dpa_node, *dev_node;
-	struct net_device		*net_dev;
-	struct dpa_priv_s		*priv;
-	struct dpa_bp			*dpa_bp;
-	struct dpa_fq			*dpa_fq;
-	struct dpa_percpu_priv_s	*percpu_priv;
-	struct fm_port_rx_params	 rx_port_param;
-	struct fm_port_non_rx_params	 tx_port_param;
-	struct fm_port_pcd_param	 rx_port_pcd_param;
-	size_t				 count;
-	const uint32_t			*uint32_prop;
-	const uint8_t			*mac_addr;
-	struct qman_fq			*ingress_fq;
-	uint32_t		   ingress_fqids[ARRAY_SIZE(ingress_fqs)][2];
-	const uint32_t		  *fqids[ARRAY_SIZE(fsl_qman_frame_queues)];
-	int			   num_fqids[ARRAY_SIZE(fsl_qman_frame_queues)];
-	uint32_t		   num_fqs[ARRAY_SIZE(fsl_qman_frame_queues)];
-	uint32_t		   fqid;
-	uint8_t			   wq;
-
-	dev = &_of_dev->dev;
-
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
-	dpa_node = _of_dev->node;
-
-	if (!of_device_is_available(dpa_node))
-		return -ENODEV;
-
-	/*
-	 * Allocate this early, so we can store relevant information in
-	 * the private area
-	 */
-	net_dev = alloc_etherdev_mq(sizeof(*priv),
-			ARRAY_SIZE(priv->egress_fqs));
-	if (unlikely(net_dev == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): alloc_etherdev_mq() failed\n",
-				__file__, __LINE__, __func__);
-		_errno = -ENOMEM;
-		goto _return;
-	}
-
-	/* Do this here, so we can be verbose early */
-	SET_NETDEV_DEV(net_dev, dev);
-	dev_set_drvdata(dev, net_dev);
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	priv->msg_enable = netif_msg_init(debug, -1);
-
-	/* BM */
-
-	dpa_bp = dpa_bp_probe(_of_dev, &count);
-	if (IS_ERR(dpa_bp)) {
-		_errno = PTR_ERR(dpa_bp);
-		goto _return_free_netdev;
-	} else if (dpa_bp == NULL) {
-		if (netif_msg_probe(priv))
-			cpu_dev_info(dev, "Using private BM buffer pools\n");
-
-		count = ARRAY_SIZE(dpa_bp_size);
-		dpa_bp = devm_kzalloc(dev, count * sizeof(*dpa_bp), GFP_KERNEL);
-		if (unlikely(dpa_bp == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-			_errno = -ENOMEM;
-			goto _return_free_netdev;
-		}
-
-		for (i = 0; i < count; i++) {
-			dpa_bp[i].count	= DEFAULT_COUNT;
-			dpa_bp[i].size	= dpa_bp_size[i];
-		}
-	} else if (count == ARRAY_SIZE(dpa_bp_size)) {
-		for (i = 0, j = 0; i < count; i++) {
-			if (dpa_bp[i].count == 0 && dpa_bp[i].size == 0 &&
-					dpa_bp[i].paddr == 0) {
-				dpa_bp[i].count	= DEFAULT_COUNT;
-				dpa_bp[i].size	= dpa_bp_size[i];
-				j++;
-			}
-		}
-		BUG_ON(j > 0 && j < count);
-	}
-
-	INIT_LIST_HEAD(&priv->dpa_bp_list);
-
-	for (i = 0; i < count; i++) {
-		_errno = _dpa_bp_alloc(net_dev, &priv->dpa_bp_list, dpa_bp + i);
-		if (unlikely(_errno < 0))
-			goto _return_dpa_bp_free;
-	}
-
-	/* QM */
-
-	dev_node = of_parse_phandle(dpa_node, "fsl,qman-channel", 0);
-	if (unlikely(dev_node == NULL)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev,
-		       "%s:%hu:%s: of_parse_phandle(fsl,qman-channel) failed\n",
-				__file__, __LINE__, __func__);
-		_errno = -EFAULT;
-		goto _return_dpa_bp_free;
-	}
-
-	uint32_prop = (typeof(uint32_prop))of_get_property(dev_node,
-			"fsl,qman-channel-id", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,qman-channel-id) failed\n",
-				    __file__, __LINE__, __func__, dpa_node->full_name);
-		of_node_put(dev_node);
-		_errno = -EINVAL;
-		goto _return_dpa_bp_free;
-	}
-	of_node_put(dev_node);
-	BUG_ON(lenp != sizeof(uint32_t));
-	priv->channel = *uint32_prop;
-
-	for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)
-		INIT_LIST_HEAD(priv->dpa_fq_list + i);
-
-	priv->percpu_priv = (typeof(priv->percpu_priv))__alloc_percpu(
-		sizeof(*priv->percpu_priv), __alignof__(*priv->percpu_priv));
-	if (unlikely(priv->percpu_priv == NULL)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev,
-				"%s:%hu:%s(): __alloc_percpu() failed\n",
-				__file__, __LINE__, __func__);
-		_errno = -ENOMEM;
-		goto _return_dpa_bp_free;
-	}
-
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		percpu_priv->net_dev = net_dev;
-		tasklet_init(&percpu_priv->dpa_task, dpa_tasklet,
-				(unsigned long)percpu_priv);
-
-		for (j = 0; j < ARRAY_SIZE(percpu_priv->fd_list); j++)
-			for (k = 0; k < ARRAY_SIZE(percpu_priv->fd_list[j]);
-			     k++)
-				INIT_LIST_HEAD(&percpu_priv->fd_list[j][k]);
-		INIT_LIST_HEAD(&percpu_priv->free_list);
-		skb_queue_head_init(&percpu_priv->rx_recycle);
-	}
-
-	/* FM */
-
-	priv->mac_dev = dpa_mac_probe(_of_dev);
-	if (IS_ERR(priv->mac_dev)) {
-		_errno = PTR_ERR(priv->mac_dev);
-		goto _return_free_percpu;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(fqids); i++) {
-		fqids[i] = (typeof(fqids[i]))of_get_property(dpa_node,
-				fsl_qman_frame_queues[i], &lenp);
-		if (unlikely(fqids[i] == NULL)) {
-			if (netif_msg_probe(priv))
-				cpu_dev_info(dev,
-					"Using dynamic %s QM frame queues\n",
-					rtx[i]);
-			num_fqids[i] = 0;
-		} else
-			num_fqids[i] = lenp / (sizeof(*fqids[i]) * 2);
-
-		for (j = 0, num_fqs[i] = 0; j < num_fqids[i]; j++)
-			num_fqs[i] += fqids[i][j * 2 + 1];
-	}
-
-	if(priv->mac_dev == NULL) {
-		if (netif_msg_probe(priv))
-			cpu_dev_info(dev, "This is a MAC-less interface\n");
-
-		/* Get the MAC address */
-		mac_addr = of_get_mac_address(dpa_node);
-		if (unlikely(mac_addr == NULL)) {
-			if (netif_msg_probe(priv))
-				cpu_dev_err(dev,
-				"%s:%hu:%s(): of_get_mac_address(%s) failed\n",
-				__file__, __LINE__, __func__,
-				dpa_node->full_name);
-			_errno = -EINVAL;
-			goto _return_free_percpu;
-		}
-
-		memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
-		memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
-
-		/* QM */
-
-		/* For now, stick to the idea that we have to have
-		 * static declarations on MAC-less devices */
-		for (i = 0; i < ARRAY_SIZE(fqids); i++)
-			if (unlikely(fqids[i] == NULL)) {
-			     if (netif_msg_probe(priv))
-				cpu_dev_err(dev, "%s:%hu:%s(): "
-			     "MAC-less interfaces require %s FQ declarations\n",
-			      __file__, __LINE__, __func__, rtx[i]);
-				_errno = -EINVAL;
-				goto _return_free_percpu;
-			}
-
-		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_fqs[RX],
-					GFP_KERNEL);
-		if (unlikely(dpa_fq == NULL)) {
-			if (netif_msg_probe(priv))
-				cpu_dev_err(dev,
-					"%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-			_errno = -ENOMEM;
-			goto _return_free_percpu;
-		}
-
-		for (i = 0; i < num_fqids[RX]; i++) {
-			for (j = 0; j < fqids[RX][2 * i + 1]; j++, dpa_fq++) {
-				fqid = fqids[RX][2 * i] ?
-				       fqids[RX][2 * i] + j : 0;
-				/* The work queue will be set to the value
-				 * of the fqid mod 8.  This way, system
-				 * architects can choose the priority
-				 * of the frame queue by statically
-				 * assigning the fqid
-				 */
-				wq = fqid ?
-					fqid % net_dev->num_tx_queues :
-					net_dev->num_tx_queues - 1;
-
-				dpa_fq->fq_base = ingress_fqs[RX][1];
-				dpa_fq->net_dev	= net_dev;
-				ingress_fq = _dpa_fq_alloc(
-						priv->dpa_fq_list + RX,
-						dpa_fq, fqid,
-						QMAN_FQ_FLAG_NO_ENQUEUE,
-						priv->channel, wq);
-				if (IS_ERR(ingress_fq)) {
-					_errno = PTR_ERR(ingress_fq);
-					goto _return_dpa_fq_free;
-				}
-
-
-				cpu_dev_dbg(dev,
-					"%s:%s(): ingress_fqs[%d] = %u\n",
-					__file__, __func__, j,
-					qman_fq_fqid(ingress_fq));
-			}
-		}
-
-		BUG_ON(num_fqs[TX] != net_dev->num_tx_queues);
-
-		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_fqs[TX],
-					GFP_KERNEL);
-		if (unlikely(dpa_fq == NULL)) {
-			if (netif_msg_probe(priv))
-				cpu_dev_err(dev,
-					"%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-			_errno = -ENOMEM;
-			goto _return_free_percpu;
-		}
-
-		for (i = 0; i < fqids[TX][1]; i++, dpa_fq++) {
-			fqid = fqids[TX][0] ? fqids[TX][0] + i : 0;
-
-			dpa_fq->fq_base = _egress_fqs;
-			dpa_fq->net_dev	= net_dev;
-			priv->egress_fqs[i] = _dpa_fq_alloc(
-					priv->dpa_fq_list + TX, dpa_fq, fqid,
-					QMAN_FQ_FLAG_NO_MODIFY, 0, 0);
-			if (IS_ERR(priv->egress_fqs[i])) {
-				_errno = PTR_ERR(priv->egress_fqs[i]);
-				goto _return_dpa_fq_free;
-			}
-
-			cpu_dev_dbg(dev, "%s:%s(): egress_fqs[%d] = %u\n",
-					__file__, __func__, i,
-					qman_fq_fqid(priv->egress_fqs[i]));
-		}
-	} else {
-		net_dev->mem_start	= priv->mac_dev->res->start;
-		net_dev->mem_end	= priv->mac_dev->res->end;
-
-		memcpy(net_dev->perm_addr, priv->mac_dev->addr,
-			net_dev->addr_len);
-		memcpy(net_dev->dev_addr, priv->mac_dev->addr,
-			net_dev->addr_len);
-
-		/* BM */
-		rx_port_param.num_pools =
-			min(ARRAY_SIZE(rx_port_param.pool_param), count);
-		i = 0;
-		list_for_each_entry(dpa_bp, &priv->dpa_bp_list, list) {
-			if (i >= rx_port_param.num_pools)
-				break;
-
-			rx_port_param.pool_param[i].id = dpa_pool2bpid(dpa_bp);
-			rx_port_param.pool_param[i].size = dpa_bp->size;
-
-			cpu_dev_dbg(dev, "%s:%s(): dpa_bp[%d] = {%hu, %u}\n",
-					__file__, __func__,
-					i, rx_port_param.pool_param[i].id,
-					rx_port_param.pool_param[i].size);
-
-			i++;
-		}
-
-		/* QM */
-
-		for (i = 0; i < ARRAY_SIZE(fqids); i++)
-			if (!fqids[i]) {
-				fqids[i] = default_fqids[i];
-				num_fqids[i] = ARRAY_SIZE(default_fqids[i]) / 2;
-
-				num_fqs[i] = 0;
-				for (j = 0; j < num_fqids[i]; j++)
-					num_fqs[i] += fqids[i][j * 2 + 1];
-			}
-
-		dpa_fq = devm_kzalloc(dev,
-				sizeof(*dpa_fq) * (num_fqs[TX] + num_fqs[RX]),
-				GFP_KERNEL);
-		if (unlikely(dpa_fq == NULL)) {
-			if (netif_msg_probe(priv))
-				cpu_dev_err(dev,
-					"%s:%hu:%s(): devm_kzalloc() failed\n",
-					__file__, __LINE__, __func__);
-			_errno = -ENOMEM;
-			goto _return_free_percpu;
-		}
-
-		/* device tree has default,error, but local array is reversed */
-		for (i = 0; i < ARRAY_SIZE(ingress_fqids); i++) {
-			ingress_fqids[i][1] = fqids[i][0];
-			ingress_fqids[i][0] = fqids[i][2];
-		}
-
-		for (i = 0; i < ARRAY_SIZE(ingress_fqs); i++) {
-			/* Error, default */
-			for (j = 0; j < ARRAY_SIZE(ingress_fqs[i]); j++,
-					dpa_fq++) {
-				dpa_fq->fq_base	= ingress_fqs[i][j];
-				dpa_fq->net_dev	= net_dev;
-				ingress_fq = _dpa_fq_alloc(
-						priv->dpa_fq_list + RX,
-						dpa_fq, ingress_fqids[i][j],
-						QMAN_FQ_FLAG_NO_ENQUEUE,
-						priv->channel, 7);
-				if (IS_ERR(ingress_fq)) {
-					_errno = PTR_ERR(ingress_fq);
-					goto _return_dpa_fq_free;
-				}
-
-				ingress_fqids[i][j] = qman_fq_fqid(ingress_fq);
-
-				cpu_dev_dbg(dev,
-					"%s:%s(): ingress_fqs[%s][%d] = %u\n",
-					__file__, __func__, rtx[i], j,
-					ingress_fqids[i][j]);
-			}
-		}
-
-		/* Loop through the remaining FQ assignments */
-		for (; i < num_fqids[RX]; i++) {
-			for (j = 0; j < fqids[RX][2 * i + 1]; j++, dpa_fq++) {
-				fqid = fqids[RX][2 * i] ?
-				       fqids[RX][2 * i] + j : 0;
-				wq = fqid ?
-					fqid % net_dev->num_tx_queues :
-					net_dev->num_tx_queues - 1;
-
-				dpa_fq->fq_base = ingress_fqs[RX][1];
-				dpa_fq->net_dev	= net_dev;
-				ingress_fq = _dpa_fq_alloc(
-						priv->dpa_fq_list + RX,
-						dpa_fq, fqid,
-						QMAN_FQ_FLAG_NO_ENQUEUE,
-						priv->channel, wq);
-				if (IS_ERR(ingress_fq)) {
-					_errno = PTR_ERR(ingress_fq);
-					goto _return_dpa_fq_free;
-				}
-
-				cpu_dev_dbg(dev,
-					"%s:%s(): ingress_fqs[%d] = %u\n",
-					__file__, __func__, j,
-					qman_fq_fqid(ingress_fq));
-			}
-		}
-
-		BUG_ON(fqids[TX][5] != net_dev->num_tx_queues);
-
-		for (i = 0; i < net_dev->num_tx_queues; i++, dpa_fq++) {
-			fqid = fqids[TX][4] ? fqids[TX][4] + i : 0;
-
-			dpa_fq->fq_base	= _egress_fqs;
-			dpa_fq->net_dev	= net_dev;
-			priv->egress_fqs[i] = _dpa_fq_alloc(
-				priv->dpa_fq_list + TX, dpa_fq, fqid,
-				QMAN_FQ_FLAG_TO_DCPORTAL,
-				fm_get_tx_port_channel(
-					priv->mac_dev->port_dev[TX]),
-				7);
-			if (IS_ERR(priv->egress_fqs[i])) {
-				_errno = PTR_ERR(priv->egress_fqs[i]);
-				goto _return_dpa_fq_free;
-			}
-
-			cpu_dev_dbg(dev, "%s:%s(): egress_fqs[%d] = %u\n",
-					__file__, __func__, i,
-					qman_fq_fqid(priv->egress_fqs[i]));
-		}
-
-		net_dev->mem_start	= priv->mac_dev->res->start;
-		net_dev->mem_end	= priv->mac_dev->res->end;
-
-		memcpy(net_dev->perm_addr, priv->mac_dev->addr,
-			net_dev->addr_len);
-		memcpy(net_dev->dev_addr, priv->mac_dev->addr,
-			net_dev->addr_len);
-
-		/* Set error FQs */
-		rx_port_param.errq	= ingress_fqids[RX][0];
-		tx_port_param.errq	= ingress_fqids[TX][0];
-
-		/* Set default FQs */
-		rx_port_param.defq	= ingress_fqids[RX][1];
-		tx_port_param.defq	= ingress_fqids[TX][1];
-
-		rx_port_param.priv_data_size =
-			 tx_port_param.priv_data_size = 32;
-		rx_port_param.parse_results =
-			tx_port_param.parse_results = true;
-		rx_port_param.hash_results	=
-			tx_port_param.hash_results	= false;
-
-		fm_set_rx_port_params(priv->mac_dev->port_dev[RX],
-			&rx_port_param);
-
-		/* Set PCD FQs */
-		rx_port_pcd_param.cb	= dpa_alloc_pcd_fqids;
-		rx_port_pcd_param.dev	= dev;
-		fm_port_pcd_bind(priv->mac_dev->port_dev[RX],
-			&rx_port_pcd_param);
-
-		fm_set_tx_port_params(priv->mac_dev->port_dev[TX],
-			&tx_port_param);
-	}
-
-	net_dev->netdev_ops = &dpa_netdev_ops;
-	net_dev->features		|= DPA_NETIF_FEATURES;
-	SET_ETHTOOL_OPS(net_dev, &dpa_ethtool_ops);
-	net_dev->needed_headroom	 = DPA_BP_HEAD;
-	net_dev->watchdog_timeo		 = tx_timeout * HZ / 1000;
-
-	_errno = register_netdev(net_dev);
-	if (unlikely(_errno < 0)) {
-		if (netif_msg_probe(priv))
-			cpu_dev_err(dev,
-				"%s:%hu:%s(): register_netdev() = %d\n",
-				__file__, __LINE__, __func__, _errno);
-		goto _return_dpa_fq_free;
-	}
-
-#ifdef CONFIG_DEBUG_FS
-	priv->debugfs_file = debugfs_create_file(net_dev->name, S_IRUGO,
-						 dpa_debugfs_root, net_dev,
-						 &dpa_debugfs_fops);
-	if (unlikely(priv->debugfs_file == NULL)) {
-		_errno = -ENOMEM;
-		if (netif_msg_probe(priv))
-			cpu_netdev_err(net_dev, "%s:%hu:%s(): "
-				       "debugfs_create_file(%s/%s/%s) = %d\n",
-				       __file__, __LINE__, __func__,
-				       powerpc_debugfs_root->d_iname,
-				       dpa_debugfs_root->d_iname, net_dev->name,
-				       _errno);
-		goto _return_unregister_netdev;
-	}
-#endif
-
-	goto _return;
-
-#ifdef CONFIG_DEBUG_FS
-_return_unregister_netdev:
-	unregister_netdev(net_dev);
-#endif
-_return_dpa_fq_free:
-	for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)
-		dpa_fq_free(dev, priv->dpa_fq_list + i);
-_return_free_percpu:
-	free_percpu(priv->percpu_priv);
-_return_dpa_bp_free:
-	dpa_bp_free(dev, &priv->dpa_bp_list);
-_return_free_netdev:
-	dev_set_drvdata(dev, NULL);
-	free_netdev(net_dev);
-_return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-static const struct of_device_id dpa_match[] __devinitconst = {
-	{
-		.compatible	= "fsl,dpa-ethernet-init"
-	},
-	{
-		.compatible	= "fsl,dpa-ethernet"
-	},
-	{}
-};
-MODULE_DEVICE_TABLE(of, dpa_match);
-
-static int __devinit __cold
-_dpa_probe(struct of_device *_of_dev, const struct of_device_id *match)
-{
-	return match ==
-		dpa_match ? dpa_init_probe(_of_dev) : dpa_probe(_of_dev);
-}
-
-static int __devexit __cold dpa_remove(struct of_device *of_dev)
-{
-	int			 _errno, __errno, i;
-	struct device		*dev;
-	struct net_device	*net_dev;
-	struct dpa_priv_s	*priv;
-
-	dev = &of_dev->dev;
-	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	if (netif_msg_probe(priv))
-		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
-
-	dev_set_drvdata(dev, NULL);
-	unregister_netdev(net_dev);
-
-	for (i = 0, _errno = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++) {
-		__errno = dpa_fq_free(dev, priv->dpa_fq_list + i);
-		if (unlikely(__errno < 0) && _errno >= 0)
-			_errno = __errno;
-	}
-
-	free_percpu(priv->percpu_priv);
-
-	dpa_bp_free(dev, &priv->dpa_bp_list);
-
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(priv->debugfs_file);
-#endif
-
-	free_netdev(net_dev);
-
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-
-static struct of_platform_driver dpa_driver = {
-	.name		= KBUILD_MODNAME,
-	.match_table	= dpa_match,
-	.owner		= THIS_MODULE,
-	.probe		= _dpa_probe,
-#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
-	.shutdown	= dpa_remove,
-#endif
-	.remove		= __devexit_p(dpa_remove)
-};
-
-static int __init __cold dpa_load(void)
-{
-	int	 _errno;
-
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
-
-#ifdef CONFIG_DEBUG_FS
-	dpa_debugfs_root = debugfs_create_dir(KBUILD_MODNAME,
-					      powerpc_debugfs_root);
-	if (unlikely(dpa_debugfs_root == NULL)) {
-		_errno = -ENOMEM;
-		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): "
-			   "debugfs_create_dir(%s/"KBUILD_MODNAME") = %d\n",
-			   __file__, __LINE__, __func__,
-			   powerpc_debugfs_root->d_iname, _errno);
-		goto _return;
-	}
-#endif
-#ifdef	CONFIG_PPC85xx_VT_MODE
-	vbi_get_guest_dma_addr((void *)virt_to_phys((void *)PAGE_OFFSET),
-				&guest_dma_offset);
-#endif
-	_errno = of_register_platform_driver(&dpa_driver);
-	if (unlikely(_errno < 0)) {
-		cpu_pr_err(KBUILD_MODNAME
-			": %s:%hu:%s(): of_register_platform_driver() = %d\n",
-			__file__, __LINE__, __func__, _errno);
-		goto _return_debugfs_remove;
-	}
-
-	goto _return;
-
-_return_debugfs_remove:
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(dpa_debugfs_root);
-#endif
-_return:
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-module_init(dpa_load);
-
-static void __exit __cold dpa_unload(void)
-{
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	of_unregister_platform_driver(&dpa_driver);
-
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(dpa_debugfs_root);
-#endif
-
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-}
-module_exit(dpa_unload);
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
deleted file mode 100644
index 695e3da..0000000
--- a/drivers/net/dpa/dpa.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* Copyright (c) 2008 - 2010, Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __DPA_H
-#define __DPA_H
-
-#include <linux/ethtool.h>	/* struct ethtool_ops */
-#include <linux/netdevice.h>
-#include <linux/list.h>		/* struct list_head */
-#include <linux/workqueue.h>	/* struct work_struct */
-#include <linux/skbuff.h>
-#ifdef CONFIG_DEBUG_FS
-#include <linux/dcache.h>	/* struct dentry */
-#endif
-
-#include "linux/fsl_qman.h"	/* struct qman_fq */
-
-#include "dpa-common.h"
-
-#include "mac.h"		/* struct mac_device */
-
-struct pcd_range {
-	uint32_t			 base;
-	uint32_t			 count;
-};
-
-struct dpa_percpu_priv_s {
-	struct net_device	*net_dev;
-	struct tasklet_struct    dpa_task;
-	struct list_head	 fd_list[2][2];
-	struct list_head	 free_list;
-	struct sk_buff_head	 rx_recycle;
-	size_t			 count[2][2], total[2][2], max[2][2], hwi[2][2];
-	size_t			 swi;
-	struct net_device_stats	 stats;
-};
-
-struct dpa_priv_s {
-	struct list_head	 dpa_bp_list;
-
-	uint16_t		 channel;
-	struct list_head	 dpa_fq_list[2];
-	struct qman_fq		*egress_fqs[8];
-
-	int					 num;
-	struct pcd_range	 ranges[4];
-
-	struct mac_device	*mac_dev;
-
-	struct dpa_percpu_priv_s	*percpu_priv;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry			*debugfs_file;
-#endif
-
-	uint32_t		 msg_enable;	/* net_device message level */
-};
-
-extern const struct ethtool_ops dpa_ethtool_ops;
-
-#endif	/* __DPA_H */
diff --git a/drivers/net/dpa/dpaa_eth-common.h b/drivers/net/dpa/dpaa_eth-common.h
new file mode 100644
index 0000000..cc220dd
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth-common.h
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_COMMON_H
+#define __DPA_COMMON_H
+
+#include <linux/kernel.h>	/* pr_*() */
+#include <linux/device.h>	/* dev_*() */
+#include <linux/smp.h>		/* hard_smp_processor_id() */
+
+#ifndef hard_smp_processor_id
+#define hard_smp_processor_id() smp_processor_id()
+#endif
+
+/* The basename of the source file is being compiled */
+#define __file__ KBUILD_BASENAME".c"
+
+#define __hot
+
+#define cpu_printk(level, format, arg...) \
+	pr_##level("cpu%d/%d: " format, hard_smp_processor_id(), \
+			smp_processor_id(), ##arg)
+#define cpu_pr_emerg(format, arg...)	\
+	cpu_printk(emerg, format, ##arg)
+#define cpu_pr_alert(format, arg...)	\
+	cpu_printk(alert, format, ##arg)
+#define cpu_pr_crit(format, arg...)	\
+	cpu_printk(crit, format, ##arg)
+#define cpu_pr_err(format, arg...)	\
+	cpu_printk(err, format, ##arg)
+#define cpu_pr_warning(format, arg...)	\
+	cpu_printk(warning, format, ##arg)
+#define cpu_pr_notice(format, arg...)	\
+	cpu_printk(notice, format, ##arg)
+#define cpu_pr_info(format, arg...)	\
+	cpu_printk(info, format, ##arg)
+#define cpu_pr_debug(format, arg...)	\
+	cpu_printk(debug, format, ##arg)
+
+/* Keep this in sync with the dev_*() definitions from linux/device.h */
+#define cpu_dev_printk(level, dev, format, arg...) \
+	cpu_pr_##level("%s: %s: " format, dev_driver_string(dev), \
+			dev_name(dev), ##arg)
+
+#define cpu_dev_emerg(dev, format, arg...)	\
+	cpu_dev_printk(emerg, dev, format, ##arg)
+#define cpu_dev_alert(dev, format, arg...)	\
+	cpu_dev_printk(alert, dev, format, ##arg)
+#define cpu_dev_crit(dev, format, arg...)	\
+	cpu_dev_printk(crit, dev, format, ##arg)
+#define cpu_dev_err(dev, format, arg...)	\
+	cpu_dev_printk(err, dev, format, ##arg)
+#define cpu_dev_warn(dev, format, arg...)	\
+	cpu_dev_printk(warning, dev, format, ##arg)
+#define cpu_dev_notice(dev, format, arg...)	\
+	cpu_dev_printk(notice, dev, format, ##arg)
+#define cpu_dev_info(dev, format, arg...)	\
+	cpu_dev_printk(info, dev, format, ##arg)
+#define cpu_dev_dbg(dev, format, arg...)	\
+	cpu_dev_printk(debug, dev, format, ##arg)
+
+#define dpaa_eth_printk(level, dev, format, arg...) \
+	cpu_dev_printk(level, dev, "%s:%hu:%s() " format, \
+			__file__, __LINE__, __func__, ##arg)
+
+#define dpaa_eth_emerg(dev, format, arg...)	\
+	dpaa_eth_printk(emerg, dev, format, ##arg)
+#define dpaa_eth_alert(dev, format, arg...)	\
+	dpaa_eth_printk(alert, dev, format, ##arg)
+#define dpaa_eth_crit(dev, format, arg...)	\
+	dpaa_eth_printk(crit, dev, format, ##arg)
+#define dpaa_eth_err(dev, format, arg...)	\
+	dpaa_eth_printk(err, dev, format, ##arg)
+#define dpaa_eth_warning(dev, format, arg...)	\
+	dpaa_eth_printk(warning, dev, format, ##arg)
+#define dpaa_eth_notice(dev, format, arg...)	\
+	dpaa_eth_printk(notice, dev, format, ##arg)
+#define dpaa_eth_info(dev, format, arg...)	\
+	dpaa_eth_printk(info, dev, format, ##arg)
+#define dpaa_eth_debug(dev, format, arg...)	\
+	dpaa_eth_printk(debug, dev, format, ##arg)
+
+#define cpu_netdev_emerg(net_dev, format, arg...)	\
+	dpaa_eth_emerg((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_alert(net_dev, format, arg...)	\
+	dpaa_eth_alert((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_crit(net_dev, format, arg...)	\
+	dpaa_eth_crit((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_err(net_dev, format, arg...)		\
+	dpaa_eth_err((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_warn(net_dev, format, arg...)	\
+	dpaa_eth_warning((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_notice(net_dev, format, arg...)	\
+	dpaa_eth_notice((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_info(net_dev, format, arg...)	\
+	dpaa_eth_info((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_dbg(net_dev, format, arg...)		\
+	dpaa_eth_debug((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+
+enum {RX, TX};
+/* Used for the "compatible" property of the OH ports */
+enum {OH_INIT, OH_SHARED};
+
+#endif	/* __DPA_COMMON_H */
diff --git a/drivers/net/dpa/dpaa_eth.c b/drivers/net/dpa/dpaa_eth.c
new file mode 100644
index 0000000..7e38069
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth.c
@@ -0,0 +1,2869 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sort.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>	/* arp_hdr_len() */
+#include <linux/if_vlan.h>	/* VLAN_HLEN */
+#include <linux/icmp.h>		/* struct icmphdr */
+#include <linux/ip.h>		/* struct iphdr */
+#include <linux/udp.h>		/* struct udphdr */
+#include <linux/tcp.h>		/* struct tcphdr */
+#include <linux/net.h>		/* net_ratelimit() */
+#include <linux/if_ether.h>	/* ETH_P_IP and ETH_P_IPV6 */
+#include <linux/highmem.h>
+#include <linux/percpu.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+#ifdef CONFIG_PPC85xx_VT_MODE
+#include <vbi/vbi.h>
+#endif
+#include <linux/fsl_bman.h>
+
+#include "fsl_fman.h"
+#include "fm_ext.h"
+
+#include "mac.h"
+#include "dpaa_eth.h"
+
+#define ARRAY2_SIZE(arr)	(ARRAY_SIZE(arr) * ARRAY_SIZE((arr)[0]))
+
+#define DPA_NETIF_FEATURES	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)
+#define DEFAULT_COUNT		64
+#define DEFAULT_BUF_SIZE DPA_BP_SIZE(FSL_FMAN_PHY_MAXFRM);
+#define DPA_MAX_TX_BACKLOG	512
+
+#define DPA_BP_REFILL (1 | (smp_processor_id() << 16))
+#define DPA_BP_FINE ((smp_processor_id() << 16))
+#define DPA_BP_REFILL_NEEDED 1
+
+/*
+ * Values for the L3R field of the FM Parse Results
+ */
+/* L3 Type field: First IP Present IPv4 */
+#define FM_L3_PARSE_RESULT_IPV4	0x8000
+/* L3 Type field: First IP Present IPv6 */
+#define FM_L3_PARSE_RESULT_IPV6	0x4000
+
+/*
+ * Values for the L4R field of the FM Parse Results
+ */
+/* L4 Type field: UDP */
+#define FM_L4_PARSE_RESULT_UDP	0x40
+/* L4 Type field: TCP */
+#define FM_L4_PARSE_RESULT_TCP	0x20
+
+#define DPA_DESCRIPTION "FSL DPAA Ethernet driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Andy Fleming <afleming@freescale.com>");
+
+MODULE_DESCRIPTION(DPA_DESCRIPTION);
+
+static uint8_t debug = -1;
+module_param(debug, byte, S_IRUGO);
+MODULE_PARM_DESC(debug, "Module/Driver verbosity level");
+
+static uint16_t __devinitdata tx_timeout = 1000;
+module_param(tx_timeout, ushort, S_IRUGO);
+MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *dpa_debugfs_root;
+#endif
+
+static const char rtx[][3] = {
+	[RX] = "RX",
+	[TX] = "TX"
+};
+
+#ifdef CONFIG_PPC85xx_VT_MODE
+static u64 guest_dma_offset;
+
+#define dpa_bus_to_virt(addr)  \
+       __va(addr - guest_dma_offset)
+#else
+#define dpa_bus_to_virt(addr)   \
+       bus_to_virt(addr)
+#endif
+ 
+static const char dpa_oh_compatibles[][24] __devinitconst = {
+	/* The dpa-ethernet node owns the OH port and must initialize it */
+	[OH_INIT] = "fsl,fman-port-oh",
+	/* The dpa-ethernet node must not initialize the OH port */
+	[OH_SHARED] = "fsl,fman-port-oh-shared",
+};
+
+/* BM */
+
+#ifdef DEBUG
+#define GFP_DPA_BP	(GFP_DMA | __GFP_ZERO | GFP_ATOMIC)
+#else
+#define GFP_DPA_BP	(GFP_DMA | GFP_ATOMIC)
+#endif
+
+#define DPA_PRIV_DATA_SIZE 16
+#define DPA_PARSE_RESULTS_SIZE 32
+#define DPA_HASH_RESULTS_SIZE 16
+#define DPA_BP_HEAD (DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
+			DPA_HASH_RESULTS_SIZE)
+#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + (s) + NET_IP_ALIGN)
+
+#define FM_FD_STAT_ERRORS						\
+	(FM_PORT_FRM_ERR_DMA | FM_PORT_FRM_ERR_PHYSICAL	| \
+	 FM_PORT_FRM_ERR_SIZE | FM_PORT_FRM_ERR_CLS_DISCARD | \
+	 FM_PORT_FRM_ERR_EXTRACTION | FM_PORT_FRM_ERR_NO_SCHEME	| \
+	 FM_PORT_FRM_ERR_ILL_PLCR | FM_PORT_FRM_ERR_PRS_TIMEOUT	| \
+	 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT | FM_PORT_FRM_ERR_PRS_HDR_ERR)
+
+static struct dpa_bp *dpa_bp_array[64];
+
+static struct dpa_bp *default_pool;
+
+static struct dpa_bp *dpa_bpid2pool(int bpid)
+{
+	return dpa_bp_array[bpid];
+}
+
+static void dpa_bp_depletion(struct bman_portal	*portal,
+		struct bman_pool *pool, void *cb_ctx, int depleted)
+{
+	if (net_ratelimit())
+		pr_err("Invalid Pool depleted notification!\n");
+}
+
+static void bmb_free(struct dpa_bp *bp, struct bm_buffer *bmb)
+{
+	int i;
+	struct sk_buff **skbh;
+	struct sk_buff *skb;
+
+	for (i = 0; i < 8; i++) {
+		dma_addr_t addr = bm_buf_addr(&bmb[i]);
+		if (!addr)
+			break;
+
+		skbh = (struct sk_buff **)bus_to_virt(addr);
+		skb = *skbh;
+
+		dma_unmap_single(bp->dev, addr, bp->size, DMA_FROM_DEVICE);
+
+		dev_kfree_skb(skb);
+	}
+}
+
+static void dpa_bp_add_8(struct dpa_bp *dpa_bp)
+{
+	struct bm_buffer bmb[8];
+	struct sk_buff **skbh;
+	dma_addr_t addr;
+	int i;
+	struct sk_buff *skb;
+	int err;
+	unsigned int *count_ptr;
+
+	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+
+	for (i = 0; i < 8; i++) {
+		skb = dev_alloc_skb(dpa_bp->skb_size);
+		if (!skb) {
+			printk(KERN_ERR "dev_alloc_skb() failed\n");
+			bm_buffer_set64(&bmb[i], 0);
+			break;
+		}
+
+		skbh = (struct sk_buff **)(skb->head + NET_IP_ALIGN);
+		*skbh = skb;
+
+		addr = dma_map_single(dpa_bp->dev, skb->head + NET_IP_ALIGN,
+				dpa_bp->size, DMA_FROM_DEVICE);
+
+		bm_buffer_set64(&bmb[i], addr);
+	}
+
+	err = bman_release(dpa_bp->pool, bmb, i, 0);
+
+	if (err < 0)
+		bmb_free(dpa_bp, bmb);
+	else
+		*count_ptr += i;
+}
+
+static void dpa_make_private_pool(struct dpa_bp *dpa_bp)
+{
+	int i;
+
+	dpa_bp->percpu_count = __alloc_percpu(sizeof(*dpa_bp->percpu_count),
+			__alignof__(*dpa_bp->percpu_count));
+
+	dpa_bp->skb_size = NET_IP_ALIGN + dpa_bp->size;
+
+	/* Give each cpu an allotment of "count" buffers */
+	for_each_online_cpu(i) {
+		int *thiscount;
+		int *countptr;
+		int j;
+		thiscount = per_cpu_ptr(dpa_bp->percpu_count,
+				smp_processor_id());
+		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
+
+		for (j = 0; j < dpa_bp->count; j += 8)
+			dpa_bp_add_8(dpa_bp);
+
+		/* Adjust the counts */
+		*countptr = j;
+
+		if (countptr != thiscount)
+			*thiscount = *thiscount - j;
+	}
+}
+
+static int dpa_make_shared_pool(struct dpa_bp *bp)
+{
+	if (dpa_bp_array[bp->bpid]) {
+		bp->vaddr = dpa_bp_array[bp->bpid]->vaddr;
+		return 0;
+	}
+
+	devm_request_mem_region(bp->dev, bp->paddr, bp->size * bp->count,
+			KBUILD_MODNAME);
+	bp->vaddr = devm_ioremap_prot(bp->dev, bp->paddr,
+			bp->size * bp->count, 0);
+	if (bp->vaddr == NULL) {
+		cpu_pr_err("Could not map memory for pool %d\n", bp->bpid);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int __devinit __must_check __attribute__((nonnull))
+dpa_bp_alloc(struct dpa_bp *dpa_bp)
+{
+	int err;
+	struct bman_pool_params	 bp_params;
+	struct platform_device *pdev;
+
+	BUG_ON(dpa_bp->size == 0);
+	BUG_ON(dpa_bp->count == 0);
+
+	bp_params.flags = BMAN_POOL_FLAG_DEPLETION;
+	bp_params.cb = dpa_bp_depletion;
+	bp_params.cb_ctx = dpa_bp;
+
+	/* We support two options.  Either a global shared pool, or
+	 * a specified pool */
+	if (dpa_bp->kernel_pool && default_pool) {
+		atomic_inc(&default_pool->refs);
+		return 0;
+	}
+
+	if (dpa_bp->bpid == 0)
+		bp_params.flags |= BMAN_POOL_FLAG_DYNAMIC_BPID;
+	else
+		bp_params.bpid = dpa_bp->bpid;
+
+	dpa_bp->pool = bman_new_pool(&bp_params);
+	if (unlikely(dpa_bp->pool == NULL)) {
+		cpu_pr_err("bman_new_pool() failed\n");
+		return -ENODEV;
+	}
+
+	dpa_bp->bpid = bman_get_params(dpa_bp->pool)->bpid;
+
+	pdev = platform_device_register_simple("dpaa_eth_bpool",
+			dpa_bp->bpid, NULL, 0);
+	if (IS_ERR(pdev)) {
+		err = PTR_ERR(pdev);
+		goto pdev_register_failed;
+	}
+
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(40)))
+		goto pdev_mask_failed;
+
+	dpa_bp->dev = &pdev->dev;
+
+	if (dpa_bp->kernel_pool) {
+		dpa_make_private_pool(dpa_bp);
+		if (!default_pool)
+			default_pool = dpa_bp;
+	} else {
+		err = dpa_make_shared_pool(dpa_bp);
+		if (err)
+			goto make_shared_pool_failed;
+	}
+
+	if (!dpa_bp_array[dpa_bp->bpid])
+		dpa_bp_array[dpa_bp->bpid] = dpa_bp;
+
+	atomic_set(&dpa_bp->refs, 1);
+
+	return 0;
+
+make_shared_pool_failed:
+pdev_mask_failed:
+	platform_device_unregister(pdev);
+pdev_register_failed:
+	bman_free_pool(dpa_bp->pool);
+
+	return err;
+}
+
+static void __cold __attribute__((nonnull))
+_dpa_bp_free(struct dpa_bp *dpa_bp)
+{
+	uint8_t	bpid;
+
+	if (!atomic_dec_and_test(&dpa_bp->refs))
+		return;
+
+	if (dpa_bp->kernel_pool) {
+		int num;
+
+		do {
+			struct bm_buffer bmb[8];
+			int i;
+
+			num = bman_acquire(dpa_bp->pool, bmb, 8, 0);
+
+			for (i = 0; i < num; i++) {
+				dma_addr_t addr = bm_buf_addr(&bmb[i]);
+				struct sk_buff **skbh = bus_to_virt(addr);
+				struct sk_buff *skb = *skbh;
+
+				dma_unmap_single(dpa_bp->dev, addr,
+						dpa_bp->size, DMA_FROM_DEVICE);
+
+				dev_kfree_skb_any(skb);
+			}
+		} while (num == 8);
+	}
+
+	bpid = dpa_bp->bpid;
+	dpa_bp_array[bpid] = 0;
+	bman_free_pool(dpa_bp->pool);
+}
+
+static void __cold __attribute__((nonnull))
+dpa_bp_free(struct dpa_priv_s *priv, struct dpa_bp *dpa_bp)
+{
+	int i;
+
+	for (i = 0; i < priv->bp_count; i++)
+		_dpa_bp_free(&priv->dpa_bp[i]);
+}
+
+/* QM */
+
+struct dpa_fq {
+	struct qman_fq		 fq_base;
+	struct list_head	 list;
+	struct net_device	*net_dev;
+	bool			 init;
+	uint32_t fqid;
+	uint32_t flags;
+	uint16_t channel;
+	uint8_t wq;
+};
+
+static int __devinit __must_check __attribute__((nonnull))
+_dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qman_fq		*fq;
+	struct qm_mcc_initfq	 initfq;
+
+	priv = netdev_priv(dpa_fq->net_dev);
+	dev = dpa_fq->net_dev->dev.parent;
+
+	if (dpa_fq->fqid == 0)
+		dpa_fq->flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+
+	dpa_fq->init = !(dpa_fq->flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+	_errno = qman_create_fq(dpa_fq->fqid, dpa_fq->flags, &dpa_fq->fq_base);
+	if (_errno) {
+		dpaa_eth_err(dev, "qman_create_fq() failed\n");
+		return _errno;
+	}
+	fq = &dpa_fq->fq_base;
+
+	if (dpa_fq->init) {
+		initfq.we_mask = QM_INITFQ_WE_DESTWQ;
+		initfq.fqd.dest.channel	= dpa_fq->channel;
+		initfq.fqd.dest.wq = dpa_fq->wq;
+		initfq.we_mask |= QM_INITFQ_WE_TDTHRESH | QM_INITFQ_WE_FQCTRL;
+		qm_fqd_taildrop_set(&initfq.fqd.td, 0x4000, 1);
+		initfq.fqd.fq_ctrl = QM_FQCTRL_TDE | QM_FQCTRL_PREFERINCACHE;
+		if (dpa_fq->flags & QMAN_FQ_FLAG_NO_ENQUEUE) {
+			initfq.we_mask |= QM_INITFQ_WE_CONTEXTA;
+			initfq.fqd.fq_ctrl |=
+				QM_FQCTRL_CTXASTASHING | QM_FQCTRL_AVOIDBLOCK;
+			initfq.fqd.context_a.stashing.exclusive =
+				QM_STASHING_EXCL_DATA | QM_STASHING_EXCL_CTX |
+				QM_STASHING_EXCL_ANNOTATION;
+			initfq.fqd.context_a.stashing.data_cl = 2;
+			initfq.fqd.context_a.stashing.annotation_cl = 1;
+			initfq.fqd.context_a.stashing.context_cl =
+				DIV_ROUND_UP(sizeof(struct qman_fq), 64);
+		};
+
+		_errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+		if (_errno < 0) {
+			dpaa_eth_err(dev, "qman_init_fq(%u) = %d\n",
+					qman_fq_fqid(fq), _errno);
+			qman_destroy_fq(fq, 0);
+			return _errno;
+		}
+	}
+
+	dpa_fq->fqid = qman_fq_fqid(fq);
+	list_add_tail(&dpa_fq->list, list);
+
+	return 0;
+}
+
+static int __cold __attribute__((nonnull))
+_dpa_fq_free(struct device *dev, struct qman_fq *fq)
+{
+	int			 _errno, __errno;
+	struct dpa_fq		*dpa_fq;
+	const struct dpa_priv_s	*priv;
+
+	_errno = 0;
+
+	dpa_fq = container_of(fq, struct dpa_fq, fq_base);
+	priv = netdev_priv(dpa_fq->net_dev);
+
+	if (dpa_fq->init) {
+		_errno = qman_retire_fq(fq, NULL);
+		if (unlikely(_errno < 0) && netif_msg_drv(priv))
+			dpaa_eth_err(dev, "qman_retire_fq(%u) = %d\n",
+					qman_fq_fqid(fq), _errno);
+
+		__errno = qman_oos_fq(fq);
+		if (unlikely(__errno < 0) && netif_msg_drv(priv)) {
+			dpaa_eth_err(dev, "qman_oos_fq(%u) = %d\n",
+					qman_fq_fqid(fq), __errno);
+			if (_errno >= 0)
+				_errno = __errno;
+		}
+	}
+
+	qman_destroy_fq(fq, 0);
+	list_del(&dpa_fq->list);
+
+	return _errno;
+}
+
+static int __cold __attribute__((nonnull))
+dpa_fq_free(struct device *dev, struct list_head *list)
+{
+	int		 _errno, __errno;
+	struct dpa_fq	*dpa_fq, *tmp;
+
+	_errno = 0;
+	list_for_each_entry_safe(dpa_fq, tmp, list, list) {
+		__errno = _dpa_fq_free(dev, (struct qman_fq *)dpa_fq);
+		if (unlikely(__errno < 0) && _errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_length(const struct qm_fd *fd)
+{
+	return fd->length20;
+}
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_offset(const struct qm_fd *fd)
+{
+	return fd->offset;
+}
+
+static int __must_check __attribute__((nonnull))
+dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
+{
+	int				 _errno, __errno, i, j;
+	const struct dpa_priv_s		*priv;
+	const struct qm_sg_entry	*sgt;
+	struct dpa_bp		*_dpa_bp, *dpa_bp;
+	struct bm_buffer		 _bmb, bmb[8];
+
+	priv = netdev_priv(net_dev);
+
+	_bmb.hi	= fd->addr_hi;
+	_bmb.lo	= fd->addr_lo;
+
+	_dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(_dpa_bp));
+
+	_errno = 0;
+	if (fd->format == qm_fd_sg) {
+		sgt = (bus_to_virt(bm_buf_addr(&_bmb)) + dpa_fd_offset(fd));
+
+		i = 0;
+		do {
+			dpa_bp = dpa_bpid2pool(sgt[i].bpid);
+			BUG_ON(IS_ERR(dpa_bp));
+
+			j = 0;
+			do {
+				BUG_ON(sgt[i].extension);
+
+				bmb[j].hi	= sgt[i].addr_hi;
+				bmb[j].lo	= sgt[i].addr_lo;
+				j++; i++;
+			} while (j < ARRAY_SIZE(bmb) &&
+					!sgt[i-1].final &&
+					sgt[i-1].bpid == sgt[i].bpid);
+
+			__errno = bman_release(dpa_bp->pool, bmb, j, 0);
+			if (unlikely(__errno < 0)) {
+				if (netif_msg_drv(priv) && net_ratelimit())
+					cpu_netdev_err(net_dev,
+						"bman_release(%hu) = %d\n",
+						dpa_bp->bpid, _errno);
+				if (_errno >= 0)
+					_errno = __errno;
+			}
+		} while (!sgt[i-1].final);
+	}
+
+	__errno = bman_release(_dpa_bp->pool, &_bmb, 1, 0);
+	if (unlikely(__errno < 0)) {
+		if (netif_msg_drv(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "bman_release(%hu) = %d\n",
+					_dpa_bp->bpid, __errno);
+		if (_errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+/* net_device */
+
+#define NN_ALLOCATED_SPACE(net_dev) \
+		max((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+#define NN_RESERVED_SPACE(net_dev) \
+		min((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+
+#define TT_ALLOCATED_SPACE(net_dev) \
+	max(sizeof(struct icmphdr), max(sizeof(struct udphdr), \
+		sizeof(struct tcphdr)))
+#define TT_RESERVED_SPACE(net_dev) \
+	min(sizeof(struct icmphdr), min(sizeof(struct udphdr), \
+		sizeof(struct tcphdr)))
+
+static struct net_device_stats * __cold
+dpa_get_stats(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	unsigned long *netstats;
+	unsigned long *cpustats;
+	int i, j;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	int numstats = sizeof(net_dev->stats) / sizeof(unsigned long);
+
+	netstats = (unsigned long *)&net_dev->stats;
+
+	memset(netstats, 0, sizeof(net_dev->stats));
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+
+		cpustats = (unsigned long *)&percpu_priv->stats;
+
+		for (j = 0; j < numstats; j++)
+			netstats[j] += cpustats[j];
+	}
+
+	return &net_dev->stats;
+}
+
+static int dpa_change_mtu(struct net_device *net_dev, int new_mtu)
+{
+	const struct dpa_priv_s *priv;
+	const int max_mtu = FSL_FMAN_PHY_MAXFRM - (VLAN_ETH_HLEN + ETH_FCS_LEN);
+	const int min_mtu = 64;
+
+	priv = netdev_priv(net_dev);
+
+	/* Make sure we don't exceed the Ethernet controller's MAXFRM */
+	if (new_mtu < min_mtu || new_mtu > max_mtu) {
+		cpu_netdev_err(net_dev, "Invalid L3 mtu %d "
+				"(must be between %d and %d).\n",
+				new_mtu, min_mtu, max_mtu);
+		return -EINVAL;
+	}
+	net_dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static void __cold dpa_change_rx_flags(struct net_device *net_dev, int flags)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (!priv->mac_dev)
+		return;
+
+	if ((flags & IFF_PROMISC) != 0) {
+		_errno = priv->mac_dev->change_promisc(priv->mac_dev);
+		if (unlikely(_errno < 0) && netif_msg_drv(priv))
+			cpu_netdev_err(net_dev,
+				       "mac_dev->change_promisc() = %d\n",
+				       _errno);
+	}
+}
+
+static int dpa_process_one(struct dpa_percpu_priv_s *percpu_priv,
+		struct sk_buff *skb, struct dpa_bp *bp, const struct qm_fd *fd)
+{
+	int *countptr;
+
+	countptr = per_cpu_ptr(bp->percpu_count, smp_processor_id());
+
+	(*countptr)--;
+
+	skb_put(skb, dpa_fd_length(fd) + dpa_fd_offset(fd) +
+				NET_IP_ALIGN - NET_SKB_PAD);
+	skb_pull(skb, dpa_fd_offset(fd) + NET_IP_ALIGN - NET_SKB_PAD);
+
+	dma_unmap_single(bp->dev, qm_fd_addr(fd), bp->size, DMA_FROM_DEVICE);
+
+	return 0;
+}
+
+static void _dpa_rx_error(struct net_device *net_dev,
+		const struct dpa_priv_s	*priv,
+		struct dpa_percpu_priv_s *percpu_priv,
+		const struct qm_fd *fd)
+{
+	int _errno;
+
+	if (netif_msg_hw(priv) && net_ratelimit())
+		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+				fd->status & FM_FD_STAT_ERRORS);
+
+	percpu_priv->stats.rx_errors++;
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += dpa_fd_length(fd);
+
+	_errno = dpa_fd_release(net_dev, fd);
+	if (unlikely(_errno < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+}
+
+static void _dpa_tx_error(struct net_device		*net_dev,
+			  const struct dpa_priv_s	*priv,
+			  struct dpa_percpu_priv_s	*percpu_priv,
+			  const struct qm_fd		*fd)
+{
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	dma_addr_t addr = qm_fd_addr(fd);
+	struct dpa_bp *bp = priv->dpa_bp;
+
+	if (netif_msg_hw(priv) && net_ratelimit())
+		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+				fd->status & FM_FD_STAT_ERRORS);
+
+	percpu_priv->stats.tx_errors++;
+
+	skbh = (struct sk_buff **)bus_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb(skb);
+}
+
+static void __hot _dpa_rx(struct net_device *net_dev,
+		const struct dpa_priv_s *priv,
+		struct dpa_percpu_priv_s *percpu_priv,
+		const struct qm_fd *fd)
+{
+	int _errno;
+	int *countptr;
+	struct dpa_bp *dpa_bp;
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	dma_addr_t addr = qm_fd_addr(fd);
+
+	skbh = (struct sk_buff **)bus_to_virt(addr);
+	prefetch(skbh);
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.rx_errors++;
+
+		goto _return_dpa_fd_release;
+	}
+
+	if (unlikely(fd->format != qm_fd_contig)) {
+		percpu_priv->stats.rx_dropped++;
+		if (netif_msg_rx_status(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "Dropping a SG frame\n");
+		goto _return_dpa_fd_release;
+	}
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+
+	skb = *skbh;
+	prefetch(skb);
+
+	/* Fill the SKB */
+	dpa_process_one(percpu_priv, skb, dpa_bp, fd);
+
+	skb->protocol = eth_type_trans(skb, net_dev);
+
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += skb->len;
+
+	if (unlikely(skb->len > net_dev->mtu)) {
+		if ((skb->protocol != ETH_P_8021Q) ||
+				(skb->len > net_dev->mtu + 4)) {
+			percpu_priv->stats.rx_dropped++;
+			goto drop_large_frame;
+		}
+	}
+
+	if (unlikely(netif_receive_skb(skb) == NET_RX_DROP))
+		percpu_priv->stats.rx_dropped++;
+
+	net_dev->last_rx = jiffies;
+
+	return;
+
+drop_large_frame:
+	countptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	(*countptr)++;
+	skb_recycle(skb);
+_return_dpa_fd_release:
+	_errno = dpa_fd_release(net_dev, fd);
+	if (unlikely(_errno < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+}
+
+static void dpaa_eth_napi_disable(struct dpa_priv_s *priv)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int i;
+
+	if (priv->shared)
+		return;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		napi_disable(&percpu_priv->napi);
+	}
+}
+
+static void dpaa_eth_napi_enable(struct dpa_priv_s *priv)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int i;
+
+	if (priv->shared)
+		return;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		napi_enable(&percpu_priv->napi);
+	}
+}
+
+static int dpaa_eth_poll(struct napi_struct *napi, int budget)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int cleaned = qman_poll_dqrr(budget);
+	int *countptr;
+
+	percpu_priv = container_of(napi, struct dpa_percpu_priv_s, napi);
+
+	countptr = per_cpu_ptr(percpu_priv->dpa_bp->percpu_count,
+				smp_processor_id());
+
+	if (*countptr < DEFAULT_COUNT / 4) {
+		int i;
+
+		for (i = 0; i < percpu_priv->dpa_bp->count; i += 8)
+			dpa_bp_add_8(percpu_priv->dpa_bp);
+	}
+
+	if (cleaned < budget) {
+		napi_complete(napi);
+		qman_irqsource_add(QM_PIRQ_DQRI);
+	}
+
+	return cleaned;
+}
+
+static void __hot _dpa_tx(struct net_device		*net_dev,
+			  const struct dpa_priv_s	*priv,
+			  struct dpa_percpu_priv_s	*percpu_priv,
+			  const struct qm_fd		*fd)
+{
+	struct sk_buff **skbh;
+	struct sk_buff	*skb;
+	dma_addr_t addr = qm_fd_addr(fd);
+	struct dpa_bp *bp = priv->dpa_bp;
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.tx_errors++;
+	}
+
+	skbh = (struct sk_buff **)bus_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb(skb);
+}
+
+static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
+{
+	int i;
+
+	for (i = 0; i < priv->bp_count; i++)
+		if (DPA_BP_SIZE(size) <= priv->dpa_bp[i].size)
+			return &priv->dpa_bp[i];
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void * __must_check __attribute__((nonnull))
+dpa_phys2virt(const struct dpa_bp *dpa_bp, dma_addr_t addr)
+{
+	return dpa_bp->vaddr + (addr - dpa_bp->paddr);
+}
+
+/**
+ * Turn on HW checksum computation for this outgoing frame.
+ * If the current protocol is not something we support in this regard
+ * (or if the stack has already computed the SW checksum), we do nothing.
+ *
+ * Returns 0 if all goes well (or HW csum doesn't apply), and a negative value
+ * otherwise.
+ *
+ * Note that this function may modify the fd->cmd field and the skb data buffer
+ * (the Parse Results area).
+ */
+static inline int dpa_enable_tx_csum(struct dpa_priv_s *dpa_priv,
+	struct sk_buff *skb, struct qm_fd *fd, char *parse_results)
+{
+	t_FmPrsResult *parse_result = NULL;
+	struct iphdr *iph = NULL;
+	int l4_proto;
+	int retval = 0;
+
+	if (!dpa_priv->mac_dev || skb->ip_summed != CHECKSUM_PARTIAL)
+		goto return_success;
+
+	/* Note: L3 csum seems to be already computed in sw, but we can't choose
+	 * L4 alone from the FM configuration anyway. */
+	iph = ip_hdr(skb);
+	BUG_ON(iph == NULL);
+	l4_proto = ntohs(iph->protocol);
+
+	/* Fill in some fields of the Parse Results array, so the FMan
+	 * can find them as if they came from the FMan Parser. */
+	parse_result = (t_FmPrsResult *)parse_results;
+
+	/* Fill in the relevant L4 parse result fields */
+	switch (l4_proto) {
+	case IPPROTO_UDP:
+		parse_result->l4r = FM_L4_PARSE_RESULT_UDP;
+		break;
+	case IPPROTO_TCP:
+		parse_result->l4r = FM_L4_PARSE_RESULT_TCP;
+		break;
+	default:
+		/* This can as well be a BUG() */
+		if (netif_msg_tx_err(dpa_priv) && net_ratelimit())
+			printk(KERN_ALERT
+				"%s:%hu:%s(): can't compute HW csum"
+				"for L4 proto 0x%x\n",
+				__file__, __LINE__, __func__, l4_proto);
+		retval = -EIO;
+		goto return_error;
+	}
+
+	/* Fill in the relevant L3 parse result fields */
+	switch (ntohs(skb->protocol)) {
+	case ETH_P_IP:
+		parse_result->l3r = FM_L3_PARSE_RESULT_IPV4;
+		break;
+	case ETH_P_IPV6:
+		parse_result->l3r = FM_L3_PARSE_RESULT_IPV6;
+		break;
+	default:
+		/* We shouldn't even be here */
+		if (netif_msg_tx_err(dpa_priv) && net_ratelimit())
+			printk(KERN_ALERT
+				"%s:%hu:%s(): can't compute HW csum"
+				"for L3 proto 0x%x\n",
+				__file__, __LINE__, __func__,
+				ntohs(skb->protocol));
+		retval = -EIO;
+		goto return_error;
+	}
+
+	/* - Can't assume the MAC header was either set, or zeroed.
+	 * - skb->data always starts with the MAC header. */
+	skb_set_mac_header(skb, 0);
+
+	/* At index 0 is IPOffset_1 as defined in the Parse Results */
+	parse_result->ip_off[0] = skb_network_header(skb) -
+		skb_mac_header(skb);
+	parse_result->l4_off = skb_transport_header(skb) -
+		skb_mac_header(skb);
+
+	/* Enable L3 (and L4, if TCP or UDP) HW checksum. */
+	fd->cmd |= FM_FD_CMD_RPD | FM_FD_CMD_DTC;
+
+return_error:
+return_success:
+	return retval;
+}
+
+static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
+			struct dpa_percpu_priv_s *percpu, int queue,
+			struct qm_fd *fd)
+{
+	int err;
+
+	prefetchw(&percpu->start_tx);
+	err = qman_enqueue(priv->egress_fqs[queue], fd, 0);
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(priv->net_dev, "qman_enqueue() = %d\n",
+					err);
+		percpu->stats.tx_errors++;
+		percpu->stats.tx_fifo_errors++;
+		return err;
+	}
+
+	percpu->stats.tx_packets++;
+	percpu->stats.tx_bytes += dpa_fd_length(fd);
+
+	return NETDEV_TX_OK;
+}
+
+static int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct dpa_bp *dpa_bp;
+	struct bm_buffer bmb;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct dpa_priv_s *priv;
+	struct device *dev;
+	struct qm_fd fd;
+	int queue_mapping;
+	int err;
+	void *dpa_bp_vaddr;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	dev = net_dev->dev.parent;
+
+	memset(&fd, 0, sizeof(fd));
+	fd.format = qm_fd_contig;
+
+	queue_mapping = skb_get_queue_mapping(skb);
+
+	dpa_bp = dpa_size2pool(priv, skb_headlen(skb));
+	if (unlikely(IS_ERR(dpa_bp))) {
+		err = PTR_ERR(dpa_bp);
+		goto bpools_too_small_error;
+	}
+
+	err = bman_acquire(dpa_bp->pool, &bmb, 1, 0);
+	if (unlikely(err <= 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "bman_acquire() = %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		if (err == 0)
+			err = -ENOMEM;
+		goto buf_acquire_failed;
+	}
+	fd.bpid = dpa_bp->bpid;
+
+	fd.length20 = skb_headlen(skb);
+	fd.cmd = FM_FD_CMD_FCO;
+	fd.addr_hi = bmb.hi;
+	fd.addr_lo = bmb.lo;
+	fd.offset = DPA_BP_HEAD + NET_IP_ALIGN;
+
+	dpa_bp_vaddr = dpa_phys2virt(dpa_bp, bm_buf_addr(&bmb));
+
+	/* Copy the packet payload */
+	skb_copy_from_linear_data(skb, dpa_bp_vaddr + dpa_fd_offset(&fd),
+		dpa_fd_length(&fd));
+
+	/* Enable L3/L4 hardware checksum computation, if applicable */
+	err = dpa_enable_tx_csum(priv, skb, &fd,
+		dpa_bp_vaddr + DPA_PRIV_DATA_SIZE);
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "Tx HW csum error: %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		goto l3_l4_csum_failed;
+	}
+
+	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+
+l3_l4_csum_failed:
+bpools_too_small_error:
+buf_acquire_failed:
+	/* We're done with the skb */
+	dev_kfree_skb(skb);
+
+	return err;
+}
+
+static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qm_fd		 fd;
+	unsigned int	headroom;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct sk_buff **skbh;
+	dma_addr_t addr;
+	struct dpa_bp *dpa_bp;
+	int queue_mapping;
+	int *countptr;
+	int err;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	dev = net_dev->dev.parent;
+
+	memset(&fd, 0, sizeof(fd));
+	fd.format = qm_fd_contig;
+
+	headroom = skb_headroom(skb);
+	queue_mapping = skb_get_queue_mapping(skb);
+
+	if (headroom < sizeof(skb) + NET_IP_ALIGN) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
+		if (!skb_new) {
+			percpu_priv->stats.tx_errors++;
+			kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+		kfree_skb(skb);
+		skb = skb_new;
+		headroom = DPA_BP_HEAD;
+	}
+
+	skbh = (struct sk_buff **)(skb->head + NET_IP_ALIGN);
+	*skbh = skb;
+
+	dpa_bp = priv->dpa_bp;
+
+	countptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+
+	/* Enable L3/L4 hardware checksum computation.
+	 *
+	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may
+	 * need to write into the skb. */
+	err = dpa_enable_tx_csum(priv, skb, &fd,
+		skb->head + DPA_PRIV_DATA_SIZE + NET_IP_ALIGN);
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "HW csum error: %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		goto l3_l4_csum_failed;
+	}
+
+	addr = dma_map_single(dpa_bp->dev, skb->head + NET_IP_ALIGN,
+				dpa_bp->size, DMA_TO_DEVICE);
+	if (unlikely(addr == 0)) {
+		if (netif_msg_tx_err(priv)  && net_ratelimit())
+			cpu_netdev_err(net_dev, "dma_map_single() failed\n");
+		err = -EIO;
+		goto dma_map_failed;
+	}
+
+	fd.addr_hi = upper_32_bits(addr);
+	fd.addr_lo = lower_32_bits(addr);
+	fd.length20 = skb->len;
+	fd.offset = headroom - NET_IP_ALIGN;
+
+	if (likely(skb_is_recycleable(skb, dpa_bp->skb_size)
+			&& (*countptr + 1 <= dpa_bp->count))) {
+		fd.cmd |= FM_FD_CMD_FCO;
+		fd.bpid = dpa_bp->bpid;
+		skb_recycle(skb);
+		skb = NULL;
+		(*countptr)++;
+		percpu_priv->tx_returned++;
+	}
+
+	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+
+	if (unlikely(err < 0)) {
+		if (fd.cmd & FM_FD_CMD_FCO)
+			(*countptr)--;
+		goto xmit_failed;
+	}
+
+	net_dev->trans_start = jiffies;
+
+	return NETDEV_TX_OK;
+
+xmit_failed:
+	dma_unmap_single(dev, addr, dpa_bp->size, DMA_TO_DEVICE);
+l3_l4_csum_failed:
+dma_map_failed:
+	if (skb)
+		dev_kfree_skb(skb);
+
+	return err;
+}
+
+static enum qman_cb_dqrr_result
+ingress_rx_error_dqrr(struct qman_portal		*portal,
+		      struct qman_fq			*fq,
+		      const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_rx_error(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result __hot
+shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
+		const struct qm_dqrr_entry *dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	int err;
+	const struct qm_fd *fd = &dq->fd;
+	struct dpa_bp *dpa_bp;
+	size_t size;
+	struct sk_buff *skb;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.rx_errors++;
+
+		goto out;
+	}
+
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += dpa_fd_length(fd);
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(dpa_bp));
+
+	if (fd->format == qm_fd_sg) {
+		percpu_priv->stats.rx_dropped++;
+		if (netif_msg_rx_status(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev,
+				"%s:%hu:%s(): Dropping a SG frame\n",
+				__file__, __LINE__, __func__);
+		goto out;
+	}
+
+	size = dpa_fd_length(fd);
+
+	skb = __netdev_alloc_skb(net_dev,
+			DPA_BP_HEAD + NET_IP_ALIGN + size, GFP_ATOMIC);
+	if (unlikely(skb == NULL)) {
+		if (netif_msg_rx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "Could not alloc skb\n");
+
+		percpu_priv->stats.rx_dropped++;
+
+		goto out;
+	}
+
+	skb_reserve(skb, NET_IP_ALIGN+DPA_BP_HEAD);
+
+	/* Fill the SKB */
+	memcpy(skb_put(skb, dpa_fd_length(fd)),
+			dpa_phys2virt(dpa_bp, qm_fd_addr(fd)) +
+			dpa_fd_offset(fd), dpa_fd_length(fd));
+
+	skb->protocol = eth_type_trans(skb, net_dev);
+
+	if (unlikely(skb->len > net_dev->mtu)) {
+		if ((skb->protocol != ETH_P_8021Q) ||
+				(skb->len > net_dev->mtu + 4)) {
+			percpu_priv->stats.rx_dropped++;
+			dev_kfree_skb_any(skb);
+			goto out;
+		}
+	}
+
+	if (unlikely(netif_rx(skb) != NET_RX_SUCCESS))
+		percpu_priv->stats.rx_dropped++;
+
+	net_dev->last_rx = jiffies;
+
+out:
+	err = dpa_fd_release(net_dev, fd);
+	if (unlikely(err < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+
+	return qman_cb_dqrr_consume;
+}
+
+
+static enum qman_cb_dqrr_result __hot
+ingress_rx_default_dqrr(struct qman_portal		*portal,
+			struct qman_fq			*fq,
+			const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (unlikely(dpaa_eth_napi_schedule(percpu_priv))) {
+		percpu_priv->in_interrupt++;
+		return qman_cb_dqrr_stop;
+	}
+
+	prefetchw(&percpu_priv->ingress_calls);
+
+	_dpa_rx(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result
+ingress_tx_error_dqrr(struct qman_portal		*portal,
+		      struct qman_fq			*fq,
+		      const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_tx_error(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result __hot
+ingress_tx_default_dqrr(struct qman_portal		*portal,
+			struct qman_fq			*fq,
+			const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	percpu_priv->tx_confirm++;
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_tx(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void shared_ern(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	struct net_device *net_dev;
+	const struct dpa_priv_s	*priv;
+	int err;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct dpa_fq *dpa_fq = (struct dpa_fq *)fq;
+
+	net_dev = dpa_fq->net_dev;
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	err = dpa_fd_release(net_dev, &msg->ern.fd);
+	if (unlikely(err < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during a TX\n");
+	}
+
+	percpu_priv->stats.tx_dropped++;
+	percpu_priv->stats.tx_fifo_errors++;
+}
+
+static void egress_ern(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	dma_addr_t addr = qm_fd_addr(&msg->ern.fd);
+	struct dpa_bp *bp;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+	bp = priv->dpa_bp;
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	skbh = (struct sk_buff **)bus_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb_any(skb);
+
+	percpu_priv->stats.tx_dropped++;
+	percpu_priv->stats.tx_fifo_errors++;
+}
+
+static const struct qman_fq rx_shared_fq __devinitconst = {
+		.cb = {shared_rx_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq rx_private_defq __devinitconst = {
+		.cb = {ingress_rx_default_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq rx_private_errq __devinitconst = {
+		.cb = {ingress_rx_error_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq tx_private_defq __devinitconst = {
+		.cb = {ingress_tx_default_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq tx_private_errq __devinitconst = {
+		.cb = {ingress_tx_error_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq dummyq __devinitconst = {
+		.cb = {NULL, NULL, NULL, NULL}
+};
+static const struct qman_fq private_egress_fq __devinitconst = {
+	.cb = {NULL, egress_ern, NULL, NULL}
+};
+static const struct qman_fq shared_egress_fq __devinitconst = {
+	.cb = {NULL, shared_ern, NULL, NULL}
+};
+
+static int __cold dpa_start(struct net_device *net_dev)
+{
+	int err, i;
+	struct dpa_priv_s *priv;
+	struct mac_device *mac_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	if (!mac_dev)
+		goto no_mac;
+
+	dpaa_eth_napi_enable(priv);
+
+	err = mac_dev->init_phy(net_dev);
+	if (err < 0) {
+		if (netif_msg_ifup(priv))
+			cpu_netdev_err(net_dev, "init_phy() = %d\n", err);
+		goto init_phy_failed;
+	}
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_enable(mac_dev->port_dev[i]);
+
+	err = priv->mac_dev->start(mac_dev);
+	if (err < 0) {
+		if (netif_msg_ifup(priv))
+			cpu_netdev_err(net_dev, "mac_dev->start() = %d\n", err);
+		goto mac_start_failed;
+	}
+
+no_mac:
+	netif_tx_start_all_queues(net_dev);
+
+	return 0;
+
+mac_start_failed:
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_disable(mac_dev->port_dev[i]);
+
+init_phy_failed:
+	dpaa_eth_napi_disable(priv);
+
+	return err;
+}
+
+static int __cold dpa_stop(struct net_device *net_dev)
+{
+	int _errno, i;
+	struct dpa_priv_s *priv;
+	struct mac_device *mac_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	netif_tx_stop_all_queues(net_dev);
+
+	if (!mac_dev)
+		return 0;
+
+	_errno = mac_dev->stop(mac_dev);
+	if (unlikely(_errno < 0))
+		if (netif_msg_ifdown(priv))
+			cpu_netdev_err(net_dev, "mac_dev->stop() = %d\n",
+					_errno);
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_disable(mac_dev->port_dev[i]);
+
+	if (mac_dev->phy_dev)
+		phy_disconnect(mac_dev->phy_dev);
+	mac_dev->phy_dev = NULL;
+
+	dpaa_eth_napi_disable(priv);
+
+	return _errno;
+}
+
+static void __cold dpa_timeout(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv;
+	struct dpa_percpu_priv_s *percpu_priv;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (netif_msg_timer(priv))
+		cpu_netdev_crit(net_dev, "Transmit timeout latency: %lu ms\n",
+				(jiffies - net_dev->trans_start) * 1000 / HZ);
+
+	percpu_priv->stats.tx_errors++;
+}
+
+static int __devinit dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
+{
+	return ((struct dpa_bp *)dpa_bp0)->size -
+			((struct dpa_bp *)dpa_bp1)->size;
+}
+
+static struct dpa_bp * __devinit __cold __must_check __attribute__((nonnull))
+dpa_bp_probe(struct of_device *_of_dev, size_t *count)
+{
+	int			 i, lenp, na, ns;
+	struct device		*dev;
+	struct device_node	*dev_node;
+	const phandle		*phandle_prop;
+	const uint32_t		*bpid;
+	const uint32_t		*bpool_cfg;
+	struct dpa_bp		*dpa_bp;
+	int has_kernel_pool = 0;
+	int has_shared_pool = 0;
+
+	dev = &_of_dev->dev;
+
+	/* The default is one, if there's no property */
+	*count = 1;
+
+	/* There are three types of buffer pool configuration:
+	 * 1) No bp assignment
+	 * 2) A static assignment to an empty configuration
+	 * 3) A static assignment to one or more configured pools
+	 *
+	 * We don't support using multiple unconfigured pools.
+	 */
+
+	/* Get the buffer pools to be used */
+	phandle_prop = of_get_property(_of_dev->node,
+					"fsl,bman-buffer-pools", &lenp);
+
+	if (phandle_prop)
+		*count = lenp / sizeof(phandle);
+	else {
+		if (default_pool)
+			return default_pool;
+
+		has_kernel_pool = 1;
+	}
+
+	dpa_bp = devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
+	if (unlikely(dpa_bp == NULL)) {
+		dpaa_eth_err(dev, "devm_kzalloc() failed\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	dev_node = of_find_node_by_path("/");
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev, "of_find_node_by_path(/) failed\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	na = of_n_addr_cells(dev_node);
+	ns = of_n_size_cells(dev_node);
+
+	for (i = 0; i < *count && phandle_prop; i++) {
+		of_node_put(dev_node);
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			dpaa_eth_err(dev, "of_find_node_by_phandle() failed\n");
+			return ERR_PTR(-EFAULT);
+		}
+
+		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
+			dpaa_eth_err(dev,
+				"!of_device_is_compatible(%s, fsl,bpool)\n",
+				dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+
+		bpid = of_get_property(dev_node, "fsl,bpid", &lenp);
+		if ((bpid == NULL) || (lenp != sizeof(*bpid))) {
+			dpaa_eth_err(dev, "fsl,bpid property not found.\n");
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+		dpa_bp[i].bpid = *bpid;
+
+		bpool_cfg = of_get_property(dev_node, "fsl,bpool-cfg", &lenp);
+		if (bpool_cfg && (lenp == (2 * ns + na) * sizeof(*bpool_cfg))) {
+			dpa_bp[i].count	= of_read_number(bpool_cfg, ns);
+			dpa_bp[i].size	= of_read_number(bpool_cfg + ns, ns);
+			dpa_bp[i].paddr	=
+				of_read_number(bpool_cfg + 2 * ns, na);
+
+#warning We are ignoring configuration values, here
+			if (dpa_bp[i].paddr == 0)
+				has_kernel_pool = 1;
+			else
+				has_shared_pool = 1;
+		} else {
+			has_kernel_pool = 1;
+		}
+
+		if (i > 0)
+			has_shared_pool = 1;
+	}
+
+	if (has_kernel_pool && has_shared_pool) {
+		dpaa_eth_err(dev, "Invalid buffer pool configuration "
+			"for node %s\n", dev_node->full_name);
+		dpa_bp = ERR_PTR(-EINVAL);
+		goto _return_of_node_put;
+	} else if (has_kernel_pool) {
+		dpa_bp->count = DEFAULT_COUNT;
+		dpa_bp->size = DEFAULT_BUF_SIZE;
+		dpa_bp->kernel_pool = 1;
+	}
+
+	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
+
+	return dpa_bp;
+
+_return_of_node_put:
+	if (dev_node)
+		of_node_put(dev_node);
+
+	return dpa_bp;
+}
+
+static int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
+			size_t count)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	int i;
+
+	if (dpa_bp->kernel_pool) {
+		priv->shared = 0;
+
+		if (netif_msg_probe(priv))
+			cpu_netdev_info(net_dev,
+				"Using private BM buffer pools\n");
+	} else {
+		priv->shared = 1;
+	}
+
+	priv->dpa_bp = dpa_bp;
+	priv->bp_count = count;
+
+	for (i = 0; i < count; i++) {
+		int err;
+		err = dpa_bp_alloc(&dpa_bp[i]);
+		if (err < 0) {
+			dpa_bp_free(priv, dpa_bp);
+			priv->dpa_bp = NULL;
+			return err;
+		}
+
+		/* For now, just point to the default pool.
+		 * We can add support for more pools, later
+		 */
+		if (dpa_bp->kernel_pool)
+			priv->dpa_bp = default_pool;
+	}
+
+	return 0;
+}
+
+static struct mac_device * __devinit __cold __must_check
+__attribute__((nonnull))
+dpa_mac_probe(struct of_device *_of_dev)
+{
+	struct device		*dpa_dev, *dev;
+	struct device_node	*mac_node;
+	int			 lenp;
+	const phandle		*phandle_prop;
+	struct of_device	*of_dev;
+	struct mac_device	*mac_dev;
+
+	phandle_prop = of_get_property(_of_dev->node, "fsl,fman-mac", &lenp);
+	if (phandle_prop == NULL)
+		return NULL;
+
+	BUG_ON(lenp != sizeof(phandle));
+
+	dpa_dev = &_of_dev->dev;
+
+	mac_node = of_find_node_by_phandle(*phandle_prop);
+	if (unlikely(mac_node == NULL)) {
+		dpaa_eth_err(dpa_dev, "of_find_node_by_phandle() failed\n");
+		return ERR_PTR(-EFAULT);
+	}
+
+	of_dev = of_find_device_by_node(mac_node);
+	if (unlikely(of_dev == NULL)) {
+		dpaa_eth_err(dpa_dev, "of_find_device_by_node(%s) failed\n",
+				mac_node->full_name);
+		of_node_put(mac_node);
+		return ERR_PTR(-EINVAL);
+	}
+	of_node_put(mac_node);
+
+	dev = &of_dev->dev;
+
+	mac_dev = dev_get_drvdata(dev);
+	if (unlikely(mac_dev == NULL)) {
+		dpaa_eth_err(dpa_dev, "dev_get_drvdata(%s) failed\n",
+				dev_name(dev));
+		return ERR_PTR(-EINVAL);
+	}
+
+	return mac_dev;
+}
+
+static const char fsl_qman_frame_queues[][25] __devinitconst = {
+	[RX] = "fsl,qman-frame-queues-rx",
+	[TX] = "fsl,qman-frame-queues-tx"
+};
+
+#ifdef CONFIG_DEBUG_FS
+static int __cold dpa_debugfs_show(struct seq_file *file, void *offset)
+{
+	int				 i;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv, total;
+	struct dpa_bp *dpa_bp;
+	int *countptr;
+	unsigned int count_total = 0;
+
+	BUG_ON(offset == NULL);
+
+	priv = netdev_priv((struct net_device *)file->private);
+
+	dpa_bp = priv->dpa_bp;
+
+	memset(&total, 0, sizeof(total));
+
+	seq_printf(file, "\tirqs\trx\trecycle\tconfirm\tbp count\tneed\n");
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
+
+		total.in_interrupt += percpu_priv->in_interrupt;
+		total.ingress_calls += percpu_priv->stats.rx_packets;
+		total.tx_returned += percpu_priv->tx_returned;
+		total.tx_confirm += percpu_priv->tx_confirm;
+		count_total += *countptr;
+
+		seq_printf(file, "%hu/%hu\t%u\t%lu\t%u\t%u\t%d\n",
+				get_hard_smp_processor_id(i), i,
+				percpu_priv->in_interrupt,
+				percpu_priv->stats.rx_packets,
+				percpu_priv->tx_returned,
+				percpu_priv->tx_confirm,
+				*countptr);
+	}
+	seq_printf(file, "Total\t%u\t%u\t%u\t%u\t%d\n",
+			total.in_interrupt,
+			total.ingress_calls,
+			total.tx_returned,
+			total.tx_confirm, count_total);
+
+	return 0;
+}
+
+static int __cold dpa_debugfs_open(struct inode *inode, struct file *file)
+{
+	int			 _errno;
+	const struct net_device	*net_dev;
+
+	_errno = single_open(file, dpa_debugfs_show, inode->i_private);
+	if (unlikely(_errno < 0)) {
+		net_dev = (struct net_device *)inode->i_private;
+
+		if (netif_msg_drv((struct dpa_priv_s *)netdev_priv(net_dev)))
+			cpu_netdev_err(net_dev, "single_open() = %d\n",
+					_errno);
+	}
+	return _errno;
+}
+
+static const struct file_operations dpa_debugfs_fops = {
+	.open		= dpa_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
+static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
+{
+	return smp_processor_id();
+}
+
+static const struct net_device_ops dpa_private_ops = {
+	.ndo_open = dpa_start,
+	.ndo_start_xmit = dpa_tx,
+	.ndo_stop = dpa_stop,
+	.ndo_change_rx_flags = dpa_change_rx_flags,
+	.ndo_tx_timeout = dpa_timeout,
+	.ndo_get_stats = dpa_get_stats,
+	.ndo_set_mac_address = eth_mac_addr,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_select_queue = dpa_select_queue,
+	.ndo_change_mtu = dpa_change_mtu,
+};
+
+static const struct net_device_ops dpa_shared_ops = {
+	.ndo_open = dpa_start,
+	.ndo_start_xmit = dpa_shared_tx,
+	.ndo_stop = dpa_stop,
+	.ndo_change_rx_flags = dpa_change_rx_flags,
+	.ndo_tx_timeout = dpa_timeout,
+	.ndo_get_stats = dpa_get_stats,
+	.ndo_set_mac_address = eth_mac_addr,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+static int __devinit dpa_get_channel(struct device *dev,
+					struct device_node *dpa_node)
+{
+	struct device_node *dev_node;
+	const uint32_t *channel_id;
+	int lenp;
+
+	dev_node = of_parse_phandle(dpa_node, "fsl,qman-channel", 0);
+	if (dev_node == NULL) {
+		dpaa_eth_err(dev, "Could not find fsl,qman-channel property\n");
+		return -EFAULT;
+	}
+
+	channel_id = of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
+	if ((channel_id == NULL) || (lenp < sizeof(*channel_id))) {
+		dpaa_eth_err(dev, "Could not get fsl,qman-channel-id in %s\n",
+				dev_node->full_name);
+		of_node_put(dev_node);
+		return -EINVAL;
+	}
+	of_node_put(dev_node);
+	return *channel_id;
+}
+
+struct fqid_cell {
+	uint32_t start;
+	uint32_t count;
+};
+
+static const struct fqid_cell default_fqids[][3] __devinitconst = {
+	[RX] = { {0, 1}, {0, 1} },
+	[TX] = { {0, 1}, {0, 1}, {0, DPAA_ETH_TX_QUEUES} }
+};
+
+static int __devinit
+dpa_fq_probe(struct of_device *_of_dev, struct list_head *list,
+		struct dpa_fq **defq, struct dpa_fq **errq,
+		struct dpa_fq **fqs, int ptype)
+{
+	struct device_node *np = _of_dev->node;
+	struct device *dev = &_of_dev->dev;
+	const struct fqid_cell *fqids;
+	int i, j, lenp;
+	int num_fqids;
+	struct dpa_fq *dpa_fq;
+	int err = 0;
+
+	fqids = of_get_property(np, fsl_qman_frame_queues[ptype], &lenp);
+	if (fqids == NULL) {
+		fqids = default_fqids[ptype];
+		num_fqids = (ptype == RX) ? 2 : 3;
+	} else
+		num_fqids = lenp / sizeof(*fqids);
+
+	for (i = 0; i < num_fqids; i++) {
+		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * fqids[i].count,
+					GFP_KERNEL);
+		if (dpa_fq == NULL) {
+			dpaa_eth_err(dev, "devm_kzalloc() failed\n");
+			return -ENOMEM;
+		}
+
+		/* The first queue is the Error queue */
+		if (i == 0 && errq) {
+			*errq = dpa_fq;
+
+			if (fqids[i].count != 1) {
+				dpaa_eth_err(dev, "Too many error queues!\n");
+				err = -EINVAL;
+				goto invalid_error_queues;
+			}
+		}
+
+		/* The second queue is the the Default queue */
+		if (i == 1 && defq) {
+			*defq = dpa_fq;
+
+			if (fqids[i].count != 1) {
+				dpaa_eth_err(dev, "Too many default queues!\n");
+				err = -EINVAL;
+				goto invalid_default_queues;
+			}
+		}
+
+		/*
+		 * All subsequent queues are gathered together.
+		 * The first 8 will be used by the private linux interface
+		 * if these are TX queues
+		 */
+		if (i == 2 || (!errq && i == 0 && fqs))
+			*fqs = dpa_fq;
+
+#warning We lost the 8-queue enforcement
+
+#define DPA_NUM_WQS 8
+		for (j = 0; j < fqids[i].count; j++) {
+			dpa_fq[j].fqid = fqids[i].start ?
+				fqids[i].start + j : 0;
+			dpa_fq[j].wq = dpa_fq[j].fqid ?
+				dpa_fq[j].fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
+			list_add_tail(&dpa_fq[j].list, list);
+		}
+	}
+
+invalid_default_queues:
+invalid_error_queues:
+	return err;
+}
+
+static void dpa_setup_ingress(struct dpa_priv_s *priv, struct dpa_fq *fq,
+			const struct qman_fq *template)
+{
+	fq->fq_base = *template;
+	fq->net_dev = priv->net_dev;
+
+	fq->flags = QMAN_FQ_FLAG_NO_ENQUEUE;
+	fq->channel = priv->channel;
+}
+
+static void dpa_setup_egress(struct dpa_priv_s *priv,
+				struct list_head *head, struct dpa_fq *fq,
+				struct fm_port *port)
+{
+	struct list_head *ptr = &fq->list;
+	int i = 0;
+
+	while (true) {
+		struct dpa_fq *iter = list_entry(ptr, struct dpa_fq, list);
+		if (priv->shared)
+			iter->fq_base = shared_egress_fq;
+		else
+			iter->fq_base = private_egress_fq;
+
+		iter->net_dev = priv->net_dev;
+		priv->egress_fqs[i++] = &iter->fq_base;
+
+		if (port) {
+			iter->flags = QMAN_FQ_FLAG_TO_DCPORTAL;
+			iter->channel = fm_get_tx_port_channel(port);
+		} else
+			iter->flags = QMAN_FQ_FLAG_NO_MODIFY;
+
+		if (list_is_last(ptr, head))
+			break;
+
+		ptr = ptr->next;
+	}
+}
+
+static void dpa_setup_ingress_queues(struct dpa_priv_s *priv,
+		struct list_head *head, struct dpa_fq *fq)
+{
+	struct list_head *ptr = &fq->list;
+
+	while (true) {
+		struct dpa_fq *iter = list_entry(ptr, struct dpa_fq, list);
+
+		if (priv->shared)
+			dpa_setup_ingress(priv, iter, &rx_shared_fq);
+		else
+			dpa_setup_ingress(priv, iter, &rx_private_defq);
+
+		if (list_is_last(ptr, head))
+			break;
+
+		ptr = ptr->next;
+	}
+}
+
+#define dpaa_eth_init_port(type, port, param, errq_id, defq_id) \
+{ \
+	param.errq = errq_id; \
+	param.defq = defq_id; \
+	param.priv_data_size = DPA_PRIV_DATA_SIZE; \
+	param.parse_results = true; \
+	param.hash_results = true; \
+	fm_set_##type##_port_params(port, &param); \
+}
+
+static void __devinit
+dpaa_eth_init_tx_port(struct fm_port *port, struct dpa_fq *errq,
+			struct dpa_fq *defq)
+{
+	struct fm_port_non_rx_params tx_port_param;
+
+	dpaa_eth_init_port(tx, port, tx_port_param, errq->fqid, defq->fqid);
+}
+
+static void __devinit
+dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
+			struct dpa_fq *errq, struct dpa_fq *defq)
+{
+	struct fm_port_rx_params rx_port_param;
+	int i;
+
+	count = min(ARRAY_SIZE(rx_port_param.pool_param), count);
+	rx_port_param.num_pools = count;
+	for (i = 0; i < count; i++) {
+		if (i >= rx_port_param.num_pools)
+			break;
+
+		rx_port_param.pool_param[i].id = bp[i].bpid;
+		rx_port_param.pool_param[i].size = bp[i].size;
+	}
+
+	dpaa_eth_init_port(rx, port, rx_port_param, errq->fqid, defq->fqid);
+}
+
+static void dpa_rx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
+			struct dpa_fq *defq, struct dpa_fq *errq,
+			struct dpa_fq *fqs)
+{
+	if (fqs)
+		dpa_setup_ingress_queues(priv, head, fqs);
+
+	/* Only real devices need default/error queues set up */
+	if (!priv->mac_dev)
+		return;
+
+	if (defq->fqid == 0 && netif_msg_probe(priv))
+		cpu_pr_info("Using dynamic RX QM frame queues\n");
+
+	if (priv->shared) {
+		dpa_setup_ingress(priv, defq, &rx_shared_fq);
+		dpa_setup_ingress(priv, errq, &rx_shared_fq);
+	} else {
+		dpa_setup_ingress(priv, defq, &rx_private_defq);
+		dpa_setup_ingress(priv, errq, &rx_private_errq);
+	}
+}
+
+static void dpa_tx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
+			struct dpa_fq *defq, struct dpa_fq *errq,
+			struct dpa_fq *fqs, struct fm_port *port)
+{
+	if (fqs)
+		dpa_setup_egress(priv, head, fqs, port);
+
+	/* Only real devices need default/error queues set up */
+	if (!priv->mac_dev)
+		return;
+
+	if (defq->fqid == 0 && netif_msg_probe(priv))
+		cpu_pr_info("Using dynamic TX QM frame queues\n");
+
+	/* The shared driver doesn't use tx confirmation */
+	if (priv->shared) {
+		dpa_setup_ingress(priv, defq, &dummyq);
+		dpa_setup_ingress(priv, errq, &dummyq);
+	} else {
+		dpa_setup_ingress(priv, defq, &tx_private_defq);
+		dpa_setup_ingress(priv, errq, &tx_private_errq);
+	}
+}
+
+static int dpa_netdev_init(struct device_node *dpa_node,
+		struct net_device *net_dev)
+{
+	int err;
+	const uint8_t *mac_addr;
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct device *dev = net_dev->dev.parent;
+
+	if (!priv->mac_dev) {
+		/* Get the MAC address */
+		mac_addr = of_get_mac_address(dpa_node);
+		if (mac_addr == NULL) {
+			if (netif_msg_probe(priv))
+				dpaa_eth_err(dev, "No MAC address found!\n");
+			return -EINVAL;
+		}
+	} else {
+		net_dev->mem_start = priv->mac_dev->res->start;
+		net_dev->mem_end = priv->mac_dev->res->end;
+
+		mac_addr = priv->mac_dev->addr;
+	}
+
+	memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
+	memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
+
+	SET_ETHTOOL_OPS(net_dev, &dpa_ethtool_ops);
+	net_dev->needed_headroom = DPA_BP_HEAD;
+	net_dev->watchdog_timeo = tx_timeout * HZ / 1000;
+
+	net_dev->features |= DPA_NETIF_FEATURES;
+
+	err = register_netdev(net_dev);
+	if (err < 0) {
+		dpaa_eth_err(dev, "register_netdev() = %d\n", err);
+		return err;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	priv->debugfs_file = debugfs_create_file(net_dev->name, S_IRUGO,
+						 dpa_debugfs_root, net_dev,
+						 &dpa_debugfs_fops);
+	if (unlikely(priv->debugfs_file == NULL)) {
+		cpu_netdev_err(net_dev, "debugfs_create_file(%s/%s/%s) = %d\n",
+				powerpc_debugfs_root->d_iname,
+				dpa_debugfs_root->d_iname,
+				net_dev->name, err);
+
+		unregister_netdev(net_dev);
+		return -ENOMEM;
+	}
+#endif
+
+	return 0;
+}
+
+static int dpa_shared_netdev_init(struct device_node *dpa_node,
+				struct net_device *net_dev)
+{
+	net_dev->netdev_ops = &dpa_shared_ops;
+
+	return dpa_netdev_init(dpa_node, net_dev);
+}
+
+static int dpa_private_netdev_init(struct device_node *dpa_node,
+				struct net_device *net_dev)
+{
+	int i;
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct dpa_percpu_priv_s *percpu_priv;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		percpu_priv->net_dev = net_dev;
+
+		percpu_priv->dpa_bp = priv->dpa_bp;
+		netif_napi_add(net_dev, &percpu_priv->napi, dpaa_eth_poll, 32);
+	}
+
+	net_dev->netdev_ops = &dpa_private_ops;
+
+	return dpa_netdev_init(dpa_node, net_dev);
+}
+
+static int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
+				uint8_t alignment, uint32_t *base_fqid)
+{
+	dpaa_eth_crit(dev, "callback not implement!\n");
+	BUG();
+
+	return 0;
+}
+
+/* Allocation code for the OH port's PCD frame queues */
+static int __devinit __cold dpa_alloc_oh_pcd_fqids(struct device *dev,
+	uint32_t num,
+	uint8_t alignment,
+	uint32_t *base_fqid)
+{
+	/* FIXME This callback is not used by the FMD/DPAA in the usual
+	 * use-case scenarios.
+	 * We should consider removing it altogether; the DPAA should not
+	 * maintain it. */
+	dpaa_eth_crit(dev, "callback not implemented!\n");
+	BUG();
+
+	return 0;
+}
+
+static inline void dpaa_oh_config_init(struct device *dpa_eth_dev)
+{
+	struct net_device	*dpa_eth_net_dev;
+	struct dpa_priv_s	*dpa_eth_priv;
+
+	BUG_ON(dpa_eth_dev == NULL);
+	dpa_eth_net_dev = (struct net_device *)dev_get_drvdata(dpa_eth_dev);
+	BUG_ON(dpa_eth_net_dev == NULL);
+	dpa_eth_priv = (struct dpa_priv_s *)netdev_priv(dpa_eth_net_dev);
+	BUG_ON(dpa_eth_priv == NULL);
+
+	dpa_eth_priv->num_oh_bindings = 0;
+}
+
+/* Allocate, initialize, and return a new dpa_oh_config */
+static inline struct dpa_oh_config_s *dpaa_oh_config_alloc(void)
+{
+	struct dpa_oh_config_s	*oh_config;
+
+	oh_config = kzalloc(sizeof(struct dpa_oh_config_s), GFP_KERNEL);
+	if (oh_config == NULL) {
+		printk(KERN_ALERT "%s:%hu:%s(): Error allocating priv data for OH config\n",
+			__file__, __LINE__, __func__);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&oh_config->pcd_ranges);
+
+	return oh_config;
+}
+
+/*
+ * Bind the oh config to the ethernet device's private data and update the
+ * number of bindings in the latter.
+ *
+ * Return the new number of OH bindings that are in the ethernet device's
+ * private data.
+ */
+static inline int
+dpaa_oh_config_bind(struct dpa_oh_config_s *oh_cfg, struct device *dpa_eth_dev)
+{
+	struct net_device	*dpa_eth_net_dev;
+	struct dpa_priv_s	*dpa_eth_priv;
+
+	BUG_ON(dpa_eth_dev == NULL);
+	dpa_eth_net_dev = (struct net_device *)dev_get_drvdata(dpa_eth_dev);
+	BUG_ON(dpa_eth_net_dev == NULL);
+	dpa_eth_priv = (struct dpa_priv_s *)netdev_priv(dpa_eth_net_dev);
+	BUG_ON(dpa_eth_priv == NULL);
+
+	dpa_eth_priv->oh_bindings[dpa_eth_priv->num_oh_bindings] = oh_cfg;
+
+	return ++dpa_eth_priv->num_oh_bindings;
+}
+
+/*
+ * Probing function for the OH ports found referenced by dpa-ethernet nodes.
+ * Meant to be called from the probing function of the dpa-ethernet node.
+ *
+ * @of_dpa_dev	This is the parent dpa-ethernet node's device (not the OH node's)
+ */
+static int dpaa_oh_probe(struct of_device *of_dpa_dev)
+{
+	struct device		*dpa_dev;
+	/* The dpa-ethernet node containing the OH port binding */
+	struct device_node	*dpa_eth_node;
+	const phandle		*oh_port_handles;
+	struct dpa_oh_config_s	*oh_config;
+	int			lenp, retval = 0, i, j;
+	/* The FMan OH port referenced by the dpa-ethernet node via a phandle */
+	struct device_node	*oh_port;
+	struct of_device	*oh_of_dev;
+	struct device		*oh_port_dev;
+	int			oh_port_count;
+	uint32_t		*oh_all_queues;
+	uint32_t		queues_count;
+	uint32_t		crt_fqid_base;
+	uint32_t		crt_fq_count;
+	struct fm_port_non_rx_params	oh_port_tx_params;
+	struct fm_port_pcd_param	oh_port_pcd_params;
+	/* Which .compatible property is found in the OH node. */
+	int8_t fman_port_oh_compat;
+	int8_t fman_port_oh_shared_compat;
+
+
+	BUG_ON(of_dpa_dev == NULL);
+	dpa_dev = &of_dpa_dev->dev;
+	dpa_eth_node = of_dpa_dev->node;
+	BUG_ON(dpa_eth_node == NULL);
+
+	/* This should have been already checked by the dpa probe function;
+	 * we're only re-asserting that. */
+	BUG_ON(!of_device_is_available(dpa_eth_node));
+
+	/*
+	 * Find the referenced OH node(s)
+	 */
+
+	oh_port_handles = of_get_property(dpa_eth_node, "fsl,fman-oh-ports",
+		&lenp);
+	if (oh_port_handles == NULL) {
+		dpaa_eth_info(dpa_dev, "no OH port bindings on node %s\n",
+			dpa_eth_node->full_name);
+		retval = 0;
+		goto return_success;
+	}
+
+	BUG_ON(lenp % sizeof(*oh_port_handles));
+	oh_port_count = lenp / sizeof(*oh_port_handles);
+	if (oh_port_count > DPAA_ETH_MAX_OH_PORT_BINDINGS) {
+		dpaa_eth_err(dpa_dev, "a maximum of %d OH port bindings "
+			"is allowed on node %s\n",
+			DPAA_ETH_MAX_OH_PORT_BINDINGS, dpa_eth_node->full_name);
+		retval = -EINVAL;
+		goto return_error;
+	}
+	dpaa_eth_debug(dpa_dev, "processing %d OH port handles...\n",
+		oh_port_count);
+
+	/* Read and save configuration for each OH port */
+	dpaa_oh_config_init(dpa_dev);
+	for (i = 0; i < oh_port_count; i++) {
+		int num_oh_bindings;
+
+		oh_port = of_find_node_by_phandle(oh_port_handles[i]);
+		if (oh_port == NULL) {
+			dpaa_eth_err(dpa_dev,
+				"can't find OH node referred from node %s\n",
+				dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		dpaa_eth_debug(dpa_dev, "found OH port handle.\n");
+
+		/* Exactly one of these must be defined. */
+		fman_port_oh_compat = of_device_is_compatible(oh_port,
+			dpa_oh_compatibles[OH_INIT]);
+		fman_port_oh_shared_compat = of_device_is_compatible(oh_port,
+			dpa_oh_compatibles[OH_SHARED]);
+		if (!fman_port_oh_compat && !fman_port_oh_shared_compat) {
+			dpaa_eth_err(dpa_dev,
+				"OH node %s[%d] referred from node %s is not"
+				"compatible with either %s or %s properties\n",
+				oh_port->full_name, i, dpa_eth_node->full_name,
+				dpa_oh_compatibles[OH_INIT],
+				dpa_oh_compatibles[OH_SHARED]);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		if (fman_port_oh_compat && fman_port_oh_shared_compat) {
+			dpaa_eth_err(dpa_dev, "OH node %s[%d] referred from "
+				"node %s can't be compatible with both "
+				"%s and %s properties.\n",
+				oh_port->full_name, i, dpa_eth_node->full_name,
+				dpa_oh_compatibles[OH_INIT],
+				dpa_oh_compatibles[OH_SHARED]);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		dpaa_eth_info(dpa_dev, "OH port is %s compatible.\n",
+			fman_port_oh_compat ? dpa_oh_compatibles[OH_INIT] :
+				dpa_oh_compatibles[OH_SHARED]);
+
+		/*
+		 * If we're not the "owner" of the OH node, we're done here.
+		 *
+		 * The OH port must be initialized exactly once.
+		 * The following scenarios are of interest:
+		 *	- the node is Linux-private (will always initialize it);
+		 *	- the node is shared between two Linux partitions
+		 *	  (only one of them will initialize it);
+		 *	- the node is shared between a Linux and a LWE partition
+		 *	  (Linux will initialize it).
+		 * Because we can't deduce which case we're in
+		 * based on the parent dpa-ethernet node's compatible property,
+		 * we must define our own compatibility.
+		 */
+		if (fman_port_oh_shared_compat) {
+			dpaa_eth_notice(dpa_dev, "Shared OH port %s bound to "
+				"device %s is to be initialized by the "
+				"partition that owns it.\n",
+				oh_port->full_name, dpa_eth_node->full_name);
+			continue;
+		}
+
+		/* Allocate, then bind OH config private area */
+		oh_config = dpaa_oh_config_alloc();
+		if (oh_config == NULL) {
+			dpaa_eth_err(dpa_dev, "Error allocating config for "
+				"OH binding of node %s\n",
+				dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		num_oh_bindings = dpaa_oh_config_bind(oh_config, dpa_dev);
+		BUG_ON(num_oh_bindings != i + 1);
+
+		/*
+		 * Read FQ ids/nums for the OH node
+		 */
+		oh_all_queues = (uint32_t *)of_get_property(oh_port,
+			"fsl,qman-frame-queues-oh", &lenp);
+		if (oh_all_queues == NULL) {
+			dpaa_eth_err(dpa_dev, "No frame queues have been "
+				"defined for OH node %s bound to node %s\n",
+				oh_port->full_name, dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+
+		/* Check that at least OH error and default FQs are there */
+		BUG_ON(lenp % (2 * sizeof(*oh_all_queues)));
+		queues_count = lenp / (2 * sizeof(*oh_all_queues));
+		if (queues_count < 2) {
+			dpaa_eth_err(dpa_dev, "Error and Default queues must be"
+				" defined for OH binding[%d] of node %s\n",
+				i, dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+
+		/*
+		 * Read the FQIDs/ranges and store the OH configuration
+		 * into the net device's priv area
+		 */
+		dpaa_eth_debug(dpa_dev, "Reading %d queues...\n", queues_count);
+		j = 0;
+
+		/* Error FQID - must be present */
+		crt_fqid_base = oh_all_queues[j++];
+		crt_fq_count = oh_all_queues[j++];
+		if (crt_fq_count != 1) {
+			dpaa_eth_err(dpa_dev, "Error FQ count must be exactly 1"
+				" (read %d instead). Problem found in OH node "
+				"%s bound to node %s.\n",
+				crt_fq_count, oh_port->full_name,
+				dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		oh_config->error_fqid = crt_fqid_base;
+		dpaa_eth_debug(dpa_dev, "Read %d Error FQIDs from base %d.\n",
+			crt_fq_count, crt_fqid_base);
+
+		/* Default FQID - must be present */
+		crt_fqid_base = oh_all_queues[j++];
+		crt_fq_count = oh_all_queues[j++];
+		if (crt_fq_count != 1) {
+			dpaa_eth_err(dpa_dev, "Default FQ count must be exactly"
+				" 1 (read %d instead). Problem found in OH node"
+				" %s bound to node %s.\n",
+				crt_fq_count, oh_port->full_name,
+				dpa_eth_node->full_name);
+			retval = -EINVAL;
+			goto return_error;
+		}
+		oh_config->default_fqid = crt_fqid_base;
+		dpaa_eth_debug(dpa_dev, "Read %d Default FQIDs from base %d.\n",
+			crt_fq_count, crt_fqid_base);
+
+		/*
+		 * PCD range(s). These are optional; if declared, however,
+		 * the application that needs them ought to initialize them all.
+		 * This way we can keep track of all FQs initialized on the OH,
+		 * either on behalf of the driver, or the applications.
+		 */
+		while (j < 2 * queues_count) {
+			struct list_head *new_pcd_range =
+				kzalloc(sizeof(struct pcd_range), GFP_KERNEL);
+			if (new_pcd_range == NULL) {
+				dpaa_eth_err(dpa_dev, "can't alloc PCD range");
+				retval = -ENOMEM;
+				goto return_error;
+			}
+
+			crt_fqid_base = oh_all_queues[j++];
+			crt_fq_count = oh_all_queues[j++];
+
+			((struct pcd_range *)new_pcd_range)->base =
+				crt_fqid_base;
+			((struct pcd_range *)new_pcd_range)->count =
+				crt_fq_count;
+
+			list_add_tail(new_pcd_range, &oh_config->pcd_ranges);
+			dpaa_eth_debug(dpa_dev,
+				"Read %d PCD FQIDs from base %d.\n",
+				crt_fq_count,
+				crt_fqid_base);
+		}
+
+		/* Get a handle to the fm_port so we can set
+		 * its configuration params */
+		oh_of_dev = of_find_device_by_node(oh_port);
+		BUG_ON(oh_of_dev == NULL);
+		oh_port_dev = &oh_of_dev->dev;
+
+		BUG_ON(oh_config == NULL);
+		oh_config->oh_port = fm_port_bind(oh_port_dev);
+		BUG_ON(oh_config->oh_port == NULL);
+
+		/* Set Tx params */
+		dpaa_eth_init_port(tx, oh_config->oh_port, oh_port_tx_params,
+			oh_config->error_fqid, oh_config->default_fqid);
+		/* Set PCD params */
+		oh_port_pcd_params.cb = dpa_alloc_oh_pcd_fqids;
+		oh_port_pcd_params.dev = oh_port_dev;
+		fm_port_pcd_bind(oh_config->oh_port, &oh_port_pcd_params);
+
+		/* Enable the OH port */
+		fm_port_enable(oh_config->oh_port);
+		dpaa_eth_notice(dpa_dev, "OH port (%s) enabled.\n",
+			oh_port->full_name);
+	}
+
+return_error:
+return_success:
+	return retval;
+}
+
+static int __devinit
+dpaa_eth_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int err, i;
+	struct device *dev;
+	struct device_node *dpa_node;
+	struct dpa_bp *dpa_bp;
+	struct dpa_fq *dpa_fq, *tmp;
+	struct list_head rxfqlist;
+	struct list_head txfqlist;
+	size_t count;
+	struct net_device *net_dev = NULL;
+	struct dpa_priv_s *priv = NULL;
+	struct dpa_fq *rxdefault = NULL;
+	struct dpa_fq *txdefault = NULL;
+	struct dpa_fq *rxerror = NULL;
+	struct dpa_fq *txerror = NULL;
+	struct dpa_fq *rxextra = NULL;
+	struct dpa_fq *txfqs = NULL;
+	struct fm_port *rxport = NULL;
+	struct fm_port *txport = NULL;
+	struct mac_device *mac_dev;
+	int proxy_enet;
+
+	dev = &_of_dev->dev;
+
+	dpa_node = _of_dev->node;
+
+	if (!of_device_is_available(dpa_node))
+		return -ENODEV;
+
+	/*
+	 * If it's not an fsl,dpa-ethernet node, we just serve as a proxy
+	 * initializer driver, and don't do any linux device setup
+	 */
+	proxy_enet = strcmp(match->compatible, "fsl,dpa-ethernet");
+
+	/*
+	 * Allocate this early, so we can store relevant information in
+	 * the private area
+	 */
+	if (!proxy_enet) {
+		net_dev = alloc_etherdev_mq(sizeof(*priv), DPAA_ETH_TX_QUEUES);
+		if (!net_dev) {
+			dpaa_eth_err(dev, "alloc_etherdev_mq() failed\n");
+			return -ENOMEM;
+		}
+
+		/* Do this here, so we can be verbose early */
+		SET_NETDEV_DEV(net_dev, dev);
+		dev_set_drvdata(dev, net_dev);
+
+		priv = netdev_priv(net_dev);
+		priv->net_dev = net_dev;
+
+		priv->msg_enable = netif_msg_init(debug, -1);
+	}
+
+	/* Get the buffer pools assigned to this interface */
+	dpa_bp = dpa_bp_probe(_of_dev, &count);
+	if (IS_ERR(dpa_bp)) {
+		err = PTR_ERR(dpa_bp);
+		goto bp_probe_failed;
+	}
+
+	mac_dev = dpa_mac_probe(_of_dev);
+	if (IS_ERR(mac_dev)) {
+		err = PTR_ERR(mac_dev);
+		goto mac_probe_failed;
+	} else if (mac_dev) {
+		rxport = mac_dev->port_dev[RX];
+		txport = mac_dev->port_dev[TX];
+	}
+
+	INIT_LIST_HEAD(&rxfqlist);
+	INIT_LIST_HEAD(&txfqlist);
+
+	if (rxport)
+		err = dpa_fq_probe(_of_dev, &rxfqlist, &rxdefault, &rxerror,
+				&rxextra, RX);
+	else
+		err = dpa_fq_probe(_of_dev, &rxfqlist, NULL, NULL,
+				&rxextra, RX);
+
+	if (err < 0)
+		goto rx_fq_probe_failed;
+
+	if (txport)
+		err = dpa_fq_probe(_of_dev, &txfqlist, &txdefault, &txerror,
+				&txfqs, TX);
+	else
+		err = dpa_fq_probe(_of_dev, &txfqlist, NULL, NULL, &txfqs, TX);
+
+	if (err < 0)
+		goto tx_fq_probe_failed;
+
+	/*
+	 * Now we have all of the configuration information.
+	 * We support a number of configurations:
+	 * 1) Private interface - An optimized linux ethernet driver with
+	 *    a real network connection.
+	 * 2) Shared interface - A device intended for virtual connections
+	 *    or for a real interface that is shared between partitions
+	 * 3) Proxy initializer - Just configures the MAC on behalf of
+	 *    another partition
+	 */
+
+	/* bp init */
+	if (net_dev) {
+		err = dpa_bp_create(net_dev, dpa_bp, count);
+
+		if (err < 0)
+			goto bp_create_failed;
+
+		priv->mac_dev = mac_dev;
+
+		priv->channel = dpa_get_channel(dev, dpa_node);
+
+		if (priv->channel < 0) {
+			err = priv->channel;
+			goto get_channel_failed;
+		}
+
+		dpa_rx_fq_init(priv, &rxfqlist, rxdefault, rxerror, rxextra);
+		dpa_tx_fq_init(priv, &txfqlist, txdefault, txerror, txfqs,
+				txport);
+
+		/* Add the FQs to the interface, and make them active */
+		INIT_LIST_HEAD(priv->dpa_fq_list);
+
+		list_for_each_entry_safe(dpa_fq, tmp, &rxfqlist, list) {
+			err = _dpa_fq_alloc(priv->dpa_fq_list, dpa_fq);
+			if (err < 0)
+				goto fq_alloc_failed;
+		}
+
+		list_for_each_entry_safe(dpa_fq, tmp, &txfqlist, list) {
+			err = _dpa_fq_alloc(priv->dpa_fq_list, dpa_fq);
+			if (err < 0)
+				goto fq_alloc_failed;
+		}
+
+	}
+
+	/* All real interfaces need their ports initialized */
+	if (mac_dev) {
+		struct fm_port_pcd_param rx_port_pcd_param;
+
+		dpaa_eth_init_rx_port(rxport, dpa_bp, count, rxerror,
+				rxdefault);
+		dpaa_eth_init_tx_port(txport, txerror, txdefault);
+
+		rx_port_pcd_param.cb = dpa_alloc_pcd_fqids;
+		rx_port_pcd_param.dev = dev;
+		fm_port_pcd_bind(rxport, &rx_port_pcd_param);
+	}
+
+	/*
+	 * Proxy interfaces need to be started, and the allocated
+	 * memory freed
+	 */
+	if (!net_dev) {
+		devm_kfree(&_of_dev->dev, dpa_bp);
+		devm_kfree(&_of_dev->dev, rxdefault);
+		devm_kfree(&_of_dev->dev, rxerror);
+		devm_kfree(&_of_dev->dev, txdefault);
+		devm_kfree(&_of_dev->dev, txerror);
+
+		for_each_port_device(i, mac_dev->port_dev)
+			fm_port_enable(mac_dev->port_dev[i]);
+
+		return 0;
+	}
+
+	/* Now we need to initialize either a private or shared interface */
+	priv->percpu_priv = __alloc_percpu(sizeof(*priv->percpu_priv),
+					   __alignof__(*priv->percpu_priv));
+	if (priv->percpu_priv == NULL) {
+		dpaa_eth_err(dev, "__alloc_percpu() failed\n");
+		err = -ENOMEM;
+		goto alloc_percpu_failed;
+	}
+
+	if (priv->shared)
+		err = dpa_shared_netdev_init(dpa_node, net_dev);
+	else
+		err = dpa_private_netdev_init(dpa_node, net_dev);
+
+	if (err < 0)
+		goto netdev_init_failed;
+
+	/* Check the OH port bindings */
+	if (dpaa_oh_probe(_of_dev)) {
+		dpaa_eth_err(dev, "error probing OH port(s)\n");
+		err = -EINVAL;
+		goto oh_probe_failed;
+	}
+
+	return 0;
+
+oh_probe_failed:
+netdev_init_failed:
+	if (net_dev)
+		free_percpu(priv->percpu_priv);
+alloc_percpu_failed:
+fq_alloc_failed:
+	if (net_dev)
+		dpa_fq_free(dev, priv->dpa_fq_list);
+get_channel_failed:
+	if (net_dev)
+		dpa_bp_free(priv, priv->dpa_bp);
+bp_create_failed:
+tx_fq_probe_failed:
+rx_fq_probe_failed:
+mac_probe_failed:
+bp_probe_failed:
+	dev_set_drvdata(dev, NULL);
+	if (net_dev)
+		free_netdev(net_dev);
+
+	return err;
+}
+
+static const struct of_device_id dpa_match[] __devinitconst = {
+	{
+		.compatible	= "fsl,dpa-ethernet"
+	},
+	{
+		.compatible	= "fsl,dpa-ethernet-init"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, dpa_match);
+
+static int __devexit __cold dpa_remove(struct of_device *of_dev)
+{
+	int			 _errno, __errno, i;
+	struct device		*dev;
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+
+	dev = &of_dev->dev;
+	net_dev = dev_get_drvdata(dev);
+	priv = netdev_priv(net_dev);
+
+	dev_set_drvdata(dev, NULL);
+	unregister_netdev(net_dev);
+
+	for (i = 0, _errno = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++) {
+		__errno = dpa_fq_free(dev, priv->dpa_fq_list + i);
+		if (unlikely(__errno < 0) && _errno >= 0)
+			_errno = __errno;
+	}
+
+	free_percpu(priv->percpu_priv);
+
+	dpa_bp_free(priv, priv->dpa_bp);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(priv->debugfs_file);
+#endif
+
+	free_netdev(net_dev);
+
+	return _errno;
+}
+
+static struct of_platform_driver dpa_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= dpa_match,
+	.owner		= THIS_MODULE,
+	.probe		= dpaa_eth_probe,
+#if defined(CONFIG_PPC85xx_VT_MODE) || defined(CONFIG_KEXEC)
+	.shutdown	= dpa_remove,
+#endif
+	.remove		= __devexit_p(dpa_remove)
+};
+
+static int __init __cold dpa_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+
+#ifdef CONFIG_DEBUG_FS
+	dpa_debugfs_root = debugfs_create_dir(KBUILD_MODNAME,
+					      powerpc_debugfs_root);
+	if (unlikely(dpa_debugfs_root == NULL)) {
+		_errno = -ENOMEM;
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): "
+			   "debugfs_create_dir(%s/"KBUILD_MODNAME") = %d\n",
+			   __file__, __LINE__, __func__,
+			   powerpc_debugfs_root->d_iname, _errno);
+		goto _return;
+	}
+#endif
+#ifdef	CONFIG_PPC85xx_VT_MODE
+	vbi_get_guest_dma_addr((void *)virt_to_phys((void *)PAGE_OFFSET),
+		&guest_dma_offset);
+#endif
+	_errno = of_register_platform_driver(&dpa_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME
+			": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			__file__, __LINE__, __func__, _errno);
+		goto _return_debugfs_remove;
+	}
+
+	goto _return;
+
+#ifdef CONFIG_DEBUG_FS
+_return_debugfs_remove:
+	debugfs_remove(dpa_debugfs_root);
+#endif
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(dpa_load);
+
+static void __exit __cold dpa_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&dpa_driver);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(dpa_debugfs_root);
+#endif
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(dpa_unload);
diff --git a/drivers/net/dpa/dpaa_eth.h b/drivers/net/dpa/dpaa_eth.h
new file mode 100644
index 0000000..5d071bb
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth.h
@@ -0,0 +1,134 @@
+/* 
+ * Copyright 2008-2010 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_H
+#define __DPA_H
+
+#include <linux/ethtool.h>	/* struct ethtool_ops */
+#include <linux/netdevice.h>
+#include <linux/list.h>		/* struct list_head */
+#include <linux/workqueue.h>	/* struct work_struct */
+#include <linux/skbuff.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/dcache.h>	/* struct dentry */
+#endif
+
+#include <linux/fsl_qman.h>	/* struct qman_fq */
+
+#include "dpaa_eth-common.h"
+
+#include "mac.h"		/* struct mac_device */
+
+
+/* number of Tx queues to FMan */
+#define DPAA_ETH_TX_QUEUES	8
+/* of the 7 available OH ports, the first is reserved for Host Commands */
+#define DPAA_ETH_MAX_OH_PORT_BINDINGS	6
+
+
+/* OH port configuration */
+struct dpa_oh_config_s {
+	uint32_t		error_fqid;
+	uint32_t		default_fqid;
+	struct list_head	pcd_ranges; /* list of struct pcd_range */
+	struct fm_port		*oh_port;
+};
+
+struct pcd_range {
+	uint32_t			 base;
+	uint32_t			 count;
+};
+
+struct dpa_bp {
+	struct bman_pool		*pool;
+	uint8_t				bpid;
+	struct device			*dev;
+	size_t				count;
+	size_t				size;
+	dma_addr_t			paddr;
+	void				*vaddr;
+	int kernel_pool;
+	int *percpu_count;
+	int *needs_refill;
+	unsigned int skb_size;
+	atomic_t refs;
+};
+
+struct dpa_percpu_priv_s {
+	struct net_device	*net_dev;
+	u32			start_tx;
+	u32			in_interrupt;
+	u32			ingress_calls;
+	u32			tx_returned;
+	u32			tx_confirm;
+	struct dpa_bp *dpa_bp;
+	struct napi_struct napi;
+	struct net_device_stats	 stats;
+};
+
+struct dpa_priv_s {
+	struct dpa_bp *dpa_bp;
+	size_t bp_count;
+	int shared;
+	struct net_device *net_dev;
+
+	uint16_t		 channel;	/* "fsl,qman-channel-id" */
+	struct list_head	 dpa_fq_list[2];
+	struct qman_fq		*egress_fqs[DPAA_ETH_TX_QUEUES];
+
+	struct mac_device	*mac_dev;
+
+	struct dpa_percpu_priv_s	*percpu_priv;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*debugfs_file;
+#endif
+
+	uint32_t		 msg_enable;	/* net_device message level */
+
+	int			 num_oh_bindings;
+	struct dpa_oh_config_s	*oh_bindings[DPAA_ETH_MAX_OH_PORT_BINDINGS];
+};
+
+extern const struct ethtool_ops dpa_ethtool_ops;
+
+static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
+{
+	if (unlikely(in_irq())) {
+		/* Disable QMan IRQ and invoke NAPI */
+		qman_irqsource_remove(QM_PIRQ_DQRI);
+		napi_schedule(&percpu_priv->napi);
+		return 1;
+	} else
+		return 0;
+}
+
+#endif	/* __DPA_H */
diff --git a/drivers/net/dpa/fm-wrapper.c b/drivers/net/dpa/fm-wrapper.c
index e8f5ed5..0e3d5d1 100644
--- a/drivers/net/dpa/fm-wrapper.c
+++ b/drivers/net/dpa/fm-wrapper.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -35,7 +36,7 @@
 #include <linux/of_platform.h>
 #include <sysdev/fsl_soc.h>
 
-#include "dpa-common.h"
+#include "dpaa_eth-common.h"
 #include "fm.h"
 #include "fm-wrapper.h"
 
@@ -56,7 +57,7 @@ static void fm_exception(t_Handle _fm_dev, e_FmExceptions exception)
 {
 	struct fm_device	*fm_dev;
 
-	fm_dev = (typeof(fm_dev))_fm_dev;
+	fm_dev = (struct fm_device *)_fm_dev;
 
 	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
 
@@ -72,7 +73,7 @@ static void fm_bus_error(t_Handle	_fm_dev,
 {
 	struct fm_device	*fm_dev;
 
-	fm_dev = (typeof(fm_dev))_fm_dev;
+	fm_dev = (struct fm_device *)_fm_dev;
 
 	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
 
@@ -84,7 +85,7 @@ static int __devinit __cold init(struct fm_device *fm_dev)
 	struct fm_priv_s	*priv;
 	int			 i;
 
-	priv = (typeof(priv))fmdev_priv(fm_dev);
+	priv = fmdev_priv(fm_dev);
 
 	priv->fm.id			= fm_dev->cell_index;
 	priv->fm.prsActive		= fm_dev->parser_res != NULL;
@@ -128,11 +129,9 @@ static irqreturn_t isr(int irq, void *_fm_dev)
 	struct fm_device	*fm_dev;
 	struct fm_priv_s	*priv;
 
-	fm_dev = (typeof(fm_dev))_fm_dev;
+	fm_dev = _fm_dev;
 
-	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
-
-	priv = (typeof(priv))fmdev_priv(fm_dev);
+	priv = fmdev_priv(fm_dev);
 
 	if (likely(priv->fm.h_Dev != NULL)) {
 		FM_Isr(priv->fm.h_Dev);
@@ -140,8 +139,6 @@ static irqreturn_t isr(int irq, void *_fm_dev)
 	} else
 		_errno = IRQ_NONE;
 
-	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
diff --git a/drivers/net/dpa/fm-wrapper.h b/drivers/net/dpa/fm-wrapper.h
index e328c21..f523f07 100644
--- a/drivers/net/dpa/fm-wrapper.h
+++ b/drivers/net/dpa/fm-wrapper.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008,2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/fm.c b/drivers/net/dpa/fm.c
index 9474c68..8df001c 100644
--- a/drivers/net/dpa/fm.c
+++ b/drivers/net/dpa/fm.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -36,7 +37,7 @@
 #include <linux/irq.h>
 #include <linux/io.h>		/* devm_ioremap() */
 
-#include "dpa-common.h"
+#include "dpaa_eth-common.h"
 #include "fm.h"
 
 static struct fm_device * __devinit __cold
@@ -44,7 +45,7 @@ alloc_fmdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct fm_devi
 {
 	struct fm_device	*fm_dev;
 
-	fm_dev = (typeof(fm_dev))devm_kzalloc(dev, sizeof(*fm_dev) + sizeof_priv, GFP_KERNEL);
+	fm_dev = devm_kzalloc(dev, sizeof(*fm_dev) + sizeof_priv, GFP_KERNEL);
 	if (likely(fm_dev == NULL))
 		fm_dev = ERR_PTR(-ENOMEM);
 	else {
@@ -82,13 +83,10 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 
 	dev = &of_dev->dev;
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	fm_dev = alloc_fmdev(dev, fm_sizeof_priv, fm_setup);
 	if (IS_ERR(fm_dev)) {
 		_errno = PTR_ERR(fm_dev);
-		cpu_dev_err(dev, "%s:%hu:%s(): alloc_fmdev() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "alloc_fmdev() = %d\n", _errno);
 		goto _return;
 	}
 
@@ -98,19 +96,18 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 	for (i = 0; i < ARRAY_SIZE(irqf); i++) {
 		interrupt = of_irq_to_resource(fm_node, i, NULL);
 		if (unlikely(interrupt == NO_IRQ)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_irq_to_resource(%d) = %d\n",
-				    __file__, __LINE__, __func__, i, NO_IRQ);
+			dpaa_eth_err(dev,
+				"of_irq_to_resource(%d) = NO_IRQ\n", i);
 			_errno = -EINVAL;
 			goto _return_dev_set_drvdata;
 		}
 
 		if (unlikely(!can_request_irq(interrupt, irqf[i])))
-			cpu_dev_warn(dev, "%s:%hu:%s(): can_request_irq(%d) failed\n",
-				     __file__, __LINE__, __func__, i);
+			dpaa_eth_warn(dev, "can_request_irq(%d) failed\n", i);
 		_errno = devm_request_irq(dev, interrupt, fm_dev->isr, irqf[i], "fman", fm_dev);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_request_irq(%d) = %d\n",
-				    __file__, __LINE__, __func__, i, _errno);
+			dpaa_eth_err(dev, "devm_request_irq(%d) = %d\n",
+					i, _errno);
 			goto _return_dev_set_drvdata;
 		}
 	}
@@ -118,15 +115,13 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 	/* Get the port/device address */
 	_errno = of_address_to_resource(fm_node, 0, &res);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource() = %d\n",
-			__file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "of_address_to_resource() = %d\n", _errno);
 		goto _return_dev_set_drvdata;
 	}
 
 	fm_dev->res = devm_request_mem_region(dev, res.start, res.end + 1 - res.start, "fman");
 	if (unlikely(fm_dev->res == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_request_mem_region(fman) failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "devm_request_mem_region(fman) failed\n");
 		_errno = -EBUSY;
 		goto _return_dev_set_drvdata;
 	}
@@ -134,16 +129,15 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 	fm_dev->vaddr = devm_ioremap(dev,
 				     fm_dev->res->start, fm_dev->res->end + 1 - fm_dev->res->start);
 	if (unlikely(fm_dev->vaddr == 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
 		_errno = -EIO;
 		goto _return_dev_set_drvdata;
 	}
 
-	uint32_prop = (typeof(uint32_prop))of_get_property(fm_node, "cell-index", &lenp);
+	uint32_prop = of_get_property(fm_node, "cell-index", &lenp);
 	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
-			    __file__, __LINE__, __func__, fm_node->full_name);
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				fm_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
@@ -152,16 +146,16 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 
 	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-muram");
 	if (unlikely(dev_node == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-muram) failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-muram) failed\n");
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 
 	_errno = of_address_to_resource(dev_node, 0, &res);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-			    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				dev_node->full_name, _errno);
 		goto _return_of_node_put;
 	}
 	of_node_put(dev_node);
@@ -169,8 +163,7 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 	fm_dev->muram_res = __devm_request_region(dev, fm_dev->res,
 						  res.start, res.end + 1 - res.start, "muram");
 	if (unlikely(fm_dev->res == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(muram) failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "__devm_request_region(muram) failed\n");
 		_errno = -EBUSY;
 		goto _return_dev_set_drvdata;
 	}
@@ -178,22 +171,21 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 	fm_dev->muram_vaddr = devm_ioremap(dev, fm_dev->muram_res->start,
 					   fm_dev->muram_res->end + 1 - fm_dev->muram_res->start);
 	if (unlikely(fm_dev->muram_vaddr == 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
 		_errno = -EIO;
 		goto _return_dev_set_drvdata;
 	}
 
 	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-parser");
 	if (unlikely(dev_node == NULL))
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-parser) failed. "
-				 "Won't be using the parser\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-parser) failed. "
+			"Won't be using the parser\n");
 	else {
 		_errno = of_address_to_resource(dev_node, 0, &res);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
 			goto _return_of_node_put;
 		}
 		of_node_put(dev_node);
@@ -202,8 +194,8 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 							   res.start, res.end + 1 - res.start,
 							   "parser");
 		if (unlikely(fm_dev->res == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(parser) failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev,
+				"__devm_request_region(parser) failed\n");
 			_errno = -EBUSY;
 			goto _return_dev_set_drvdata;
 		}
@@ -213,23 +205,23 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 			fm_dev->parser_res->start,
 			fm_dev->parser_res->end + 1 - fm_dev->parser_res->start);
 		if (unlikely(fm_dev->parser_vaddr == 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
 			_errno = -EIO;
 			goto _return_dev_set_drvdata;
 		}
 	}
 
-	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-keygen");
-	if (unlikely(dev_node == NULL))
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-keygen) failed. "
-				 "Won't be using the KeyGen\n",
-			    __file__, __LINE__, __func__);
-	else {
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL,
+						"fsl,fman-keygen");
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-keygen) failed. "
+			"Won't be using the KeyGen\n");
+	} else {
 		_errno = of_address_to_resource(dev_node, 0, &res);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
 			goto _return_of_node_put;
 		}
 		of_node_put(dev_node);
@@ -238,8 +230,8 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 							   res.start, res.end + 1 - res.start,
 							   "keygen");
 		if (unlikely(fm_dev->res == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(keygen) failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev,
+				"__devm_request_region(keygen) failed\n");
 			_errno = -EBUSY;
 			goto _return_dev_set_drvdata;
 		}
@@ -249,8 +241,7 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 			fm_dev->keygen_res->start,
 			fm_dev->keygen_res->end + 1 - fm_dev->keygen_res->start);
 		if (unlikely(fm_dev->keygen_vaddr == 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
 			_errno = -EIO;
 			goto _return_dev_set_drvdata;
 		}
@@ -258,14 +249,14 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 
 	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-policer");
 	if (unlikely(dev_node == NULL))
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-policer) failed. "
-				 "Won't be using the policer\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-policer) failed. "
+			"Won't be using the policer\n");
 	else {
 		_errno = of_address_to_resource(dev_node, 0, &res);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
 			goto _return_of_node_put;
 		}
 		of_node_put(dev_node);
@@ -274,8 +265,8 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 							    res.start, res.end + 1 - res.start,
 							    "policer");
 		if (unlikely(fm_dev->res == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(policer) failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev,
+				"__devm_request_region(policer) failed\n");
 			_errno = -EBUSY;
 			goto _return_dev_set_drvdata;
 		}
@@ -285,8 +276,7 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 			fm_dev->policer_res->start,
 			fm_dev->policer_res->end + 1 - fm_dev->policer_res->start);
 		if (unlikely(fm_dev->policer_vaddr == 0)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
 			_errno = -EIO;
 			goto _return_dev_set_drvdata;
 		}
@@ -294,8 +284,7 @@ static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_d
 
 	_errno = fm_dev->init(fm_dev);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): port_dev->init() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
 		goto _return_dev_set_drvdata;
 	}
 
@@ -306,8 +295,6 @@ _return_of_node_put:
 _return_dev_set_drvdata:
 	dev_set_drvdata(dev, NULL);
 _return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
@@ -318,12 +305,8 @@ static int __devexit __cold fm_remove(struct of_device *of_dev)
 
 	dev = &of_dev->dev;
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	_errno = free_fmdev((struct fm_device *)dev_get_drvdata(dev));
 
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
diff --git a/drivers/net/dpa/fm.h b/drivers/net/dpa/fm.h
index b694228..e01e710 100644
--- a/drivers/net/dpa/fm.h
+++ b/drivers/net/dpa/fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008,2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/fman-conf.h b/drivers/net/dpa/fman-conf.h
index 7be24fb..ded24ab 100644
--- a/drivers/net/dpa/fman-conf.h
+++ b/drivers/net/dpa/fman-conf.h
@@ -5,7 +5,7 @@
  *  \mainpage
  *  \section	Legal
  *
- *  Copyright (c) 2008, Freescale Semiconductor, Inc.
+ *  Copyright (c) 2008,2010 Freescale Semiconductor, Inc.
  *  All rights reserved.
  *
  *  Redistribution and use in source and binary forms, with or without
@@ -1345,7 +1345,7 @@ static inline struct fman_keygen __iomem *fm_keygen_create(void *regs)
 {
 	struct fman_keygen	*fm_keygen;
 
-	fm_keygen = (typeof(fm_keygen))kzalloc(sizeof(*fm_keygen), GFP_KERNEL);
+	fm_keygen = kzalloc(sizeof(*fm_keygen), GFP_KERNEL);
 	if (likely(fm_keygen != NULL))
 		fm_keygen->mmap = (typeof(fm_keygen->mmap))regs;
 
@@ -1528,7 +1528,7 @@ fm_keygen_entry_start(struct fman_keygen		*fm_keygen,	/**< KeyGen handle */
 	while(fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
 		cpu_relax();
 
-	fm_keygen_entry = (typeof(fm_keygen_entry))kzalloc(sizeof(*fm_keygen_entry), GFP_KERNEL);
+	fm_keygen_entry = kzalloc(sizeof(*fm_keygen_entry), GFP_KERNEL);
 	if (likely(fm_keygen_entry != NULL)) {
 		fm_keygen_entry->fm_keygen = fm_keygen;
 
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 2389ce5..7b199fd 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -36,8 +37,8 @@
 #include <linux/phy.h>
 #include <linux/netdevice.h>
 
-#include "dpa-common.h"
-#include "dpa.h"
+#include "dpaa_eth-common.h"
+#include "dpaa_eth.h"
 #include "mac.h"
 
 #include "error_ext.h"	/* GET_ERROR_TYPE, E_OK */
@@ -98,7 +99,7 @@ static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exception)
 {
 	struct mac_device	*mac_dev;
 
-	mac_dev = (typeof(mac_dev))_mac_dev;
+	mac_dev = (struct mac_device *)_mac_dev;
 
 	cpu_dev_dbg(mac_dev->dev, "%s:%s() -> %d\n", __file__, __func__, exception);
 }
@@ -111,7 +112,7 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	t_FmMacParams		param;
 	uint32_t			version;
 
-	priv = (typeof(priv))macdev_priv(mac_dev);
+	priv = macdev_priv(mac_dev);
 
 	param.baseAddr =  (typeof(param.baseAddr))(uintptr_t)devm_ioremap(
 		mac_dev->dev, mac_dev->res->start, 0x2000);
@@ -127,9 +128,7 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 
 	priv->mac = FM_MAC_Config(&param);
 	if (unlikely(priv->mac == NULL)) {
-		cpu_dev_err(mac_dev->dev,
-				"%s:%hu:%s(): FM_MAC_Config() failed\n",
-				__file__, __LINE__, __func__);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Config() failed\n");
 		_errno = -EINVAL;
 		goto _return;
 	}
@@ -137,18 +136,16 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	err = FM_MAC_ConfigMaxFrameLength(priv->mac, FSL_FMAN_PHY_MAXFRM);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(mac_dev->dev,
-		"%s:%hu:%s(): FM_MAC_ConfigMaxFrameLength() = 0x%08x\n",
-		 __file__, __LINE__, __func__, err);
-	goto _return_fm_mac_free;
+		dpaa_eth_err(mac_dev->dev,
+			"FM_MAC_ConfigMaxFrameLength() = 0x%08x\n", err);
+		goto _return_fm_mac_free;
 	}
 
 	err = FM_MAC_ConfigPadAndCrc(priv->mac, true);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(mac_dev->dev,
-			"%s:%hu:%s(): FM_MAC_ConfigPadAndCrc() = 0x%08x\n",
-			__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev,
+			"FM_MAC_ConfigPadAndCrc() = 0x%08x\n", err);
 		goto _return_fm_mac_free;
 	}
 
@@ -156,9 +153,8 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 		err = FM_MAC_ConfigHalfDuplex(priv->mac, mac_dev->half_duplex);
 		_errno = -GET_ERROR_TYPE(err);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(mac_dev->dev,
-				"%s:%hu: FM_MAC_ConfigHalfDuplex() = 0x%08x\n",
-				__file__, __LINE__, err);
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_ConfigHalfDuplex() = 0x%08x\n", err);
 			goto _return_fm_mac_free;
 		}
 	}
@@ -166,8 +162,8 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 		err = FM_MAC_ConfigResetOnInit(priv->mac, true);
 		_errno = -GET_ERROR_TYPE(err);
 		if (unlikely(_errno < 0)) {
-			cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigResetOnInit() = 0x%08x\n",
-				    __file__, __LINE__, __func__, err);
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_ConfigResetOnInit() = 0x%08x\n", err);
 			goto _return_fm_mac_free;
 		}
 	}
@@ -175,18 +171,27 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	err = FM_MAC_Init(priv->mac);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(mac_dev->dev,
-			"%s:%hu:%s(): FM_MAC_Init() = 0x%08x\n",
-			__file__, __LINE__, __func__, err);
+ 		dpaa_eth_err(mac_dev->dev, "FM_MAC_Init() = 0x%08x\n", err);
 		goto _return_fm_mac_free;
 	}
 
+	/* For 10G MAC, disable Tx ECC exception */
+	if (macdev2enetinterface(mac_dev) == e_ENET_MODE_XGMII_10000) {
+		err = FM_MAC_SetException(priv->mac,
+					  e_FM_MAC_EX_10G_1TX_ECC_ER, FALSE);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_SetException() = 0x%08x\n", err);
+			goto _return_fm_mac_free;
+		}
+	}
+
 	err = FM_MAC_GetVesrion(priv->mac, &version);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(mac_dev->dev,
-			"%s:%hu:%s(): FM_MAC_GetVesrion() = 0x%08x\n",
-			__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_GetVesrion() = 0x%08x\n",
+ 				err);
 		goto _return_fm_mac_free;
 	}
 	cpu_dev_info(mac_dev->dev, "FMan %s version: 0x%08x\n",
@@ -199,9 +204,7 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 _return_fm_mac_free:
 	err = FM_MAC_Free(priv->mac);
 	if (unlikely(-GET_ERROR_TYPE(err) < 0))
-		cpu_dev_err(mac_dev->dev,
-				"%s:%hu:%s(): FM_MAC_Free() = 0x%08x\n",
-				__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Free() = 0x%08x\n", err);
 _return:
 	return _errno;
 }
@@ -216,9 +219,7 @@ static int __cold start(struct mac_device *mac_dev)
 			e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev,
-				"%s:%hu:%s(): FM_MAC_Enable() = 0x%08x\n",
-				__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Enable() = 0x%08x\n", err);
 
 	if (phy_dev) {
 		if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
@@ -243,9 +244,7 @@ static int __cold stop(struct mac_device *mac_dev)
 				e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev,
-				"%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
-				__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Disable() = 0x%08x\n", err);
 
 	return _errno;
 }
@@ -260,9 +259,8 @@ static int __cold change_promisc(struct mac_device *mac_dev)
 			mac_dev->promisc = !mac_dev->promisc);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev,
-			"%s:%hu:%s(): FM_MAC_SetPromiscuous() = 0x%08x\n",
-			__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_SetPromiscuous() = 0x%08x\n", err);
 
 	return _errno;
 }
@@ -283,9 +281,8 @@ static void adjust_link(struct net_device *net_dev)
 			phy_dev->speed, phy_dev->duplex);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev,
-			"%s:%hu:%s(): FM_MAC_AdjustLink() = 0x%08x\n",
-			__file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_AdjustLink() = 0x%08x\n",
+				err);
 
 	return;
 }
@@ -309,9 +306,7 @@ static int dtsec_init_phy(struct net_device *net_dev)
 		phy_dev = of_phy_connect(net_dev, mac_dev->phy_node,
 				&adjust_link, 0, mac_dev->phy_if);
 	if (unlikely(phy_dev == NULL) || IS_ERR(phy_dev)) {
-		cpu_netdev_err(net_dev,
-				"%s:%hu:%s(): Could not connect to PHY %s\n",
-				__file__, __LINE__, __func__,
+		cpu_netdev_err(net_dev, "Could not connect to PHY %s\n",
 				mac_dev->phy_node ?
 					mac_dev->phy_node->full_name :
 					mac_dev->fixed_bus_id);
@@ -340,9 +335,7 @@ static int xgmac_init_phy(struct net_device *net_dev)
 		phy_dev = of_phy_attach(net_dev, mac_dev->phy_node, 0,
 				mac_dev->phy_if);
 	if (unlikely(phy_dev == NULL) || IS_ERR(phy_dev)) {
-		cpu_netdev_err(net_dev,
-				"%s:%hu:%s(): Could not attach to PHY %s\n",
-				__file__, __LINE__, __func__,
+		cpu_netdev_err(net_dev, "Could not attach to PHY %s\n",
 				mac_dev->phy_node ?
 					mac_dev->phy_node->full_name :
 					mac_dev->fixed_bus_id);
@@ -363,19 +356,17 @@ static int __cold uninit(struct mac_device *mac_dev)
 	t_Error			 err;
 	const struct mac_priv_s	*priv;
 
-	priv = (typeof(priv))macdev_priv(mac_dev);
+	priv = macdev_priv(mac_dev);
 
 	err = FM_MAC_Disable(priv->mac, e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Disable() = 0x%08x\n", err);
 
 	err = FM_MAC_Free(priv->mac);
 	__errno = -GET_ERROR_TYPE(err);
 	if (unlikely(__errno < 0)) {
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Free() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Free() = 0x%08x\n", err);
 		if (_errno < 0)
 			_errno = __errno;
 	}
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index fb37e2d..349fb88 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -35,7 +36,7 @@
 #include <linux/device.h>
 #include <linux/phy.h>
 
-#include "dpa-common.h"
+#include "dpaa_eth-common.h"
 
 #include "lnxwrp_fm_ext.h"
 
@@ -98,8 +99,8 @@ alloc_macdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct mac_de
 {
 	struct mac_device	*mac_dev;
 
-	mac_dev = (typeof(mac_dev))devm_kzalloc(dev, sizeof(*mac_dev) + sizeof_priv, GFP_KERNEL);
-	if (likely(mac_dev == NULL))
+	mac_dev = devm_kzalloc(dev, sizeof(*mac_dev) + sizeof_priv, GFP_KERNEL);
+	if (unlikely(mac_dev == NULL))
 		mac_dev = ERR_PTR(-ENOMEM);
 	else {
 		mac_dev->dev = dev;
@@ -143,8 +144,6 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 
 	dev = &_of_dev->dev;
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	mac_node = _of_dev->node;
 
 	for (i = 0; i < ARRAY_SIZE(mac_match) - 1 && match != mac_match + i; i++);
@@ -153,32 +152,30 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	mac_dev = alloc_macdev(dev, mac_sizeof_priv[i], mac_setup[i]);
 	if (IS_ERR(mac_dev)) {
 		_errno = PTR_ERR(mac_dev);
-		cpu_dev_err(dev, "%s:%hu:%s(): alloc_macdev() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "alloc_macdev() = %d\n", _errno);
 		goto _return;
 	}
 
 	/* Get the FM node */
 	dev_node = of_get_parent(mac_node);
 	if (unlikely(dev_node == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
-			    __file__, __LINE__, __func__, mac_node->full_name);
+		dpaa_eth_err(dev, "of_get_parent(%s) failed\n",
+				mac_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 
 	of_dev = of_find_device_by_node(dev_node);
 	if (unlikely(of_dev == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
+		dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+				dev_node->full_name);
 		_errno = -EINVAL;
 		goto _return_of_node_put;
 	}
 
 	mac_dev->fm_dev = fm_bind(&of_dev->dev);
 	if (unlikely(mac_dev->fm_dev == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): fm_bind(%s) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
+		dpaa_eth_err(dev, "fm_bind(%s) failed\n", dev_node->full_name);
 		_errno = -ENODEV;
 		goto _return_of_node_put;
 	}
@@ -189,8 +186,8 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	/* Get the address of the memory mapped registers */
 	_errno = of_address_to_resource(mac_node, 0, &res);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-			    __file__, __LINE__, __func__, mac_node->full_name, _errno);
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				mac_node->full_name, _errno);
 		goto _return_dev_set_drvdata;
 	}
 
@@ -199,8 +196,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 		fm_get_mem_region(mac_dev->fm_dev),
 		res.start, res.end + 1 - res.start, "mac");
 	if (unlikely(mac_dev->res == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_mem_region(mac) failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "__devm_request_mem_region(mac) failed\n");
 		_errno = -EBUSY;
 		goto _return_dev_set_drvdata;
 	}
@@ -208,8 +204,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	mac_dev->vaddr = devm_ioremap(dev, mac_dev->res->start,
 				      mac_dev->res->end + 1 - mac_dev->res->start);
 	if (unlikely(mac_dev->vaddr == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
 		_errno = -EIO;
 		goto _return_dev_set_drvdata;
 	}
@@ -217,8 +212,8 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	/* Get the cell-index */
 	uint32_prop = of_get_property(mac_node, "cell-index", &lenp);
 	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
-			    __file__, __LINE__, __func__, mac_node->full_name);
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				mac_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
@@ -228,18 +223,18 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	/* Get the MAC address */
 	mac_addr = of_get_mac_address(mac_node);
 	if (unlikely(mac_addr == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_mac_address(%s) failed\n",
-			    __file__, __LINE__, __func__, mac_node->full_name);
+		dpaa_eth_err(dev, "of_get_mac_address(%s) failed\n",
+				mac_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 	memcpy(mac_dev->addr, mac_addr, sizeof(mac_dev->addr));
 
 	/* Get the port handles */
-	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "fsl,port-handles", &lenp);
+	phandle_prop = of_get_property(mac_node, "fsl,port-handles", &lenp);
 	if (unlikely(phandle_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, port-handles) failed\n",
-			    __file__, __LINE__, __func__, mac_node->full_name);
+		dpaa_eth_err(dev, "of_get_property(%s, port-handles) failed\n",
+				mac_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
@@ -249,24 +244,23 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 		/* Find the port node */
 		dev_node = of_find_node_by_phandle(phandle_prop[i]);
 		if (unlikely(dev_node == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
-				    __file__, __LINE__, __func__);
+			dpaa_eth_err(dev, "of_find_node_by_phandle() failed\n");
 			_errno = -EINVAL;
 			goto _return_of_node_put;
 		}
 
 		of_dev = of_find_device_by_node(dev_node);
 		if (unlikely(of_dev == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
-				    __file__, __LINE__, __func__, dev_node->full_name);
+			dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+					dev_node->full_name);
 			_errno = -EINVAL;
 			goto _return_of_node_put;
 		}
 
 		mac_dev->port_dev[i] = fm_port_bind(&of_dev->dev);
 		if (unlikely(mac_dev->port_dev[i] == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): dev_get_drvdata(%s) failed\n",
-				    __file__, __LINE__, __func__, dev_node->full_name);
+			dpaa_eth_err(dev, "dev_get_drvdata(%s) failed\n",
+					dev_node->full_name);
 			_errno = -EINVAL;
 			goto _return_of_node_put;
 		}
@@ -274,11 +268,13 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	}
 
 	/* Get the PHY connection type */
-	char_prop = (typeof(char_prop))of_get_property(mac_node, "phy-connection-type", NULL);
+	char_prop = (const char *)of_get_property(mac_node,
+						"phy-connection-type", NULL);
 	if (unlikely(char_prop == NULL)) {
-		cpu_dev_warn(dev, "%s:%hu:%s(): of_get_property(%s, phy-connection-type) "
-			     "failed. Defaulting to MII\n",
-			     __file__, __LINE__, __func__, mac_node->full_name);
+		dpaa_eth_warning(dev,
+				"of_get_property(%s, phy-connection-type) "
+				"failed. Defaulting to MII\n",
+				mac_node->full_name);
 		mac_dev->phy_if = PHY_INTERFACE_MODE_MII;
 	} else
 		mac_dev->phy_if = str2phy(char_prop);
@@ -312,12 +308,12 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 
 	_errno = mac_dev->init(mac_dev);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): mac_dev->init() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "mac_dev->init() = %d\n", _errno);
 		goto _return_dev_set_drvdata;
 	}
 
-	cpu_dev_info(dev, "FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
+	cpu_dev_info(dev,
+		"FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
 		     mac_dev->addr[0], mac_dev->addr[1], mac_dev->addr[2],
 		     mac_dev->addr[3], mac_dev->addr[4], mac_dev->addr[5]);
 
@@ -328,8 +324,6 @@ _return_of_node_put:
 _return_dev_set_drvdata:
 	dev_set_drvdata(dev, NULL);
 _return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
@@ -342,8 +336,6 @@ static int __devexit __cold mac_remove(struct of_device *of_dev)
 	dev = &of_dev->dev;
 	mac_dev = (struct mac_device *)dev_get_drvdata(dev);
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	for_each_port_device(i, mac_dev->port_dev)
 		fm_port_unbind(mac_dev->port_dev[i]);
 
@@ -351,8 +343,6 @@ static int __devexit __cold mac_remove(struct of_device *of_dev)
 
 	_errno = free_macdev(mac_dev);
 
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
index 1d38d07..c909ef1 100644
--- a/drivers/net/dpa/mac.h
+++ b/drivers/net/dpa/mac.h
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (C) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/dpa/port-wrapper.c b/drivers/net/dpa/port-wrapper.c
index 6088824..aa3505e 100644
--- a/drivers/net/dpa/port-wrapper.c
+++ b/drivers/net/dpa/port-wrapper.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -34,7 +35,7 @@
 #include <linux/io.h>		/* in_be32() */
 #include <linux/of_platform.h>
 
-#include "dpa-common.h"
+#include "dpaa_eth-common.h"
 #include "fm.h"			/* fmdev_priv() */
 #include "fm-wrapper.h"		/* struct fm_priv_s */
 #include "port.h"
@@ -79,7 +80,7 @@ init(const struct port_device *port_dev, uint8_t logical_index)
 {
 	struct port_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	priv->port->id		= logical_index;
 	priv->port->baseAddr	= (typeof(priv->port->baseAddr))port_dev->vaddr;
@@ -101,7 +102,7 @@ static int __devinit __cold init_rx(struct port_device *port_dev)
 	struct rx_priv_s	*priv;
 	uint8_t			 logical_index;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	logical_index = port_dev->cell_index - BASE_RX_PORTID;
 	priv->port.port =
@@ -126,7 +127,7 @@ static int __cold __attribute__((nonnull)) _init_rx(const struct port_device *po
 {
 	const struct rx_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	priv->port.port->active	= true;
 
@@ -153,9 +154,10 @@ set_bp_info_rx(struct port_device *port_dev, const struct port_bp_info *bp_info,
 	int			 i;
 	struct rx_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
-	priv->param.num_pools = min(count, (typeof(count))ARRAY_SIZE(priv->param.pool_param));
+	priv->param.num_pools = min(count,
+			(uint8_t)ARRAY_SIZE(priv->param.pool_param));
 	for (i = 0; i < priv->param.num_pools; i++) {
 		priv->param.pool_param[i].id	= bp_info[i].bpid;
 		priv->param.pool_param[i].size	= bp_info[i].size;
@@ -169,7 +171,7 @@ static int __cold start_rx(struct port_device *port_dev)
 	int			 _errno;
 	const struct rx_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	if (unlikely(!priv->port.port->active)) {
 		_errno = _init_rx(port_dev);
@@ -204,7 +206,7 @@ static int __devinit __cold init_tx(struct port_device *port_dev)
 	struct tx_priv_s	*priv;
 	uint8_t			 logical_index;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	logical_index = port_dev->cell_index - BASE_TX_PORTID;
 	priv->port.port =
@@ -224,7 +226,7 @@ static int __cold __attribute__((nonnull)) _init_tx(const struct port_device *po
 {
 	const struct tx_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	priv->port.port->active	= true;
 
@@ -250,7 +252,7 @@ static int __cold start_tx(struct port_device *port_dev)
 	int			 _errno;
 	const struct tx_priv_s	*priv;
 
-	priv = (typeof(priv))portdev_priv(port_dev);
+	priv = portdev_priv(port_dev);
 
 	if (unlikely(!priv->port.port->active)) {
 		_errno = _init_tx(port_dev);
diff --git a/drivers/net/dpa/port.c b/drivers/net/dpa/port.c
index defe101..df73b0b 100644
--- a/drivers/net/dpa/port.c
+++ b/drivers/net/dpa/port.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -35,22 +36,23 @@
 #include <linux/device.h>
 #include <linux/io.h>		/* devm_ioremap() */
 
-#include "dpa-common.h"
+#include "dpaa_eth-common.h"
 #include "port.h"
 
 static struct port_device * __devinit __cold
-alloc_portdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct port_device *port_dev))
+alloc_portdev(struct device *dev, size_t sizeof_priv,
+		void (*setup)(struct port_device *port_dev))
 {
-	struct port_device	*port_dev;
+	struct port_device *port_dev;
 
-	port_dev = (typeof(port_dev))devm_kzalloc(dev, sizeof(*port_dev) + sizeof_priv, GFP_KERNEL);
-	if (likely(port_dev == NULL))
-		port_dev = ERR_PTR(-ENOMEM);
-	else {
-		port_dev->dev = dev;
-		dev_set_drvdata(dev, port_dev);
-		setup(port_dev);
-	}
+	port_dev = devm_kzalloc(dev, sizeof(*port_dev) + sizeof_priv,
+			GFP_KERNEL);
+	if (port_dev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	port_dev->dev = dev;
+	dev_set_drvdata(dev, port_dev);
+	setup(port_dev);
 
 	return port_dev;
 }
@@ -90,8 +92,6 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 
 	dev = &_of_dev->dev;
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	port_node = _of_dev->node;
 
 	for (i = 0; i < ARRAY_SIZE(port_match) - 1 && match != port_match + i; i++);
@@ -99,47 +99,45 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 
 	port_dev = alloc_portdev(dev, port_sizeof_priv[i], port_setup[i]);
 	if (IS_ERR(port_dev)) {
+		dpaa_eth_err(dev, "alloc_portdev() = %d\n", _errno);
 		_errno = PTR_ERR(port_dev);
-		cpu_dev_err(dev, "%s:%hu:%s(): alloc_portdev() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
 		goto _return;
 	}
 
 	/* Get the FM node */
 	fm_node = of_get_parent(port_node);
 	if (unlikely(fm_node == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
-			    __file__, __LINE__, __func__, port_node->full_name);
+		dpaa_eth_err(dev, "of_get_parent(%s) failed\n",
+				port_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 
 	of_dev = of_find_device_by_node(fm_node);
 	if (unlikely(of_dev == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
-			    __file__, __LINE__, __func__, fm_node->full_name);
+		dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+				fm_node->full_name);
 		of_node_put(fm_node);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 	of_node_put(fm_node);
 
-	port_dev->fm_dev = (typeof(port_dev->fm_dev))dev_get_drvdata(&of_dev->dev);
+	port_dev->fm_dev = dev_get_drvdata(&of_dev->dev);
 	BUG_ON(port_dev->fm_dev == NULL);
 
 	/* Get the address of the memory mapped registers */
 	_errno = of_address_to_resource(port_node, 0, &res);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-			    __file__, __LINE__, __func__, port_node->full_name, _errno);
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				port_node->full_name, _errno);
 		goto _return_dev_set_drvdata;
 	}
 
 	port_dev->res = __devm_request_region(dev, port_dev->fm_dev->res,
 					      res.start, res.end + 1 - res.start, port_type[i]);
 	if (unlikely(port_dev->res == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_mem_region(port) failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "__devm_request_mem_region(port) failed\n");
 		_errno = -EBUSY;
 		goto _return_dev_set_drvdata;
 	}
@@ -147,16 +145,15 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 	port_dev->vaddr = devm_ioremap(dev, port_dev->res->start,
 				       port_dev->res->end + 1 - port_dev->res->start);
 	if (unlikely(port_dev->vaddr == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
-			    __file__, __LINE__, __func__);
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
 		_errno = -EIO;
 		goto _return_dev_set_drvdata;
 	}
 
-	uint32_prop = (typeof(uint32_prop))of_get_property(port_node, "cell-index", &lenp);
+	uint32_prop = of_get_property(port_node, "cell-index", &lenp);
 	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
-			    __file__, __LINE__, __func__, port_node->full_name);
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				port_node->full_name);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
@@ -164,11 +161,12 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 	port_dev->cell_index = *uint32_prop;
 
 	if (match != port_match + RX) {
-		uint32_prop = (typeof(uint32_prop))of_get_property(port_node,
-								   "fsl,qman-channel-id", &lenp);
+		uint32_prop = of_get_property(port_node,
+				"fsl,qman-channel-id", &lenp);
 		if (unlikely(uint32_prop == NULL)) {
-			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,qman-channel-id) failed\n",
-				    __file__, __LINE__, __func__, port_node->full_name);
+			dpaa_eth_err(dev,
+				"of_get_property(%s, fsl,qman-channel-id)"
+				" failed\n", port_node->full_name);
 			_errno = -EINVAL;
 			goto _return_dev_set_drvdata;
 		}
@@ -178,8 +176,7 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 
 	_errno = port_dev->init(port_dev);
 	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): port_dev->init() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
+		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
 		goto _return_dev_set_drvdata;
 	}
 
@@ -188,8 +185,6 @@ static int __devinit __cold port_probe(struct of_device *_of_dev, const struct o
 _return_dev_set_drvdata:
 	dev_set_drvdata(dev, NULL);
 _return:
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
@@ -200,12 +195,8 @@ static int __devexit __cold port_remove(struct of_device *of_dev)
 
 	dev = &of_dev->dev;
 
-	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
-
 	_errno = free_portdev((struct port_device *)dev_get_drvdata(dev));
 
-	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
-
 	return _errno;
 }
 
diff --git a/drivers/net/dpa/port.h b/drivers/net/dpa/port.h
index 69e6334..ad44a4c 100644
--- a/drivers/net/dpa/port.h
+++ b/drivers/net/dpa/port.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008,2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/dpa/xgmac_mdio.c b/drivers/net/dpa/xgmac_mdio.c
index 67c4a92..4d320a1 100644
--- a/drivers/net/dpa/xgmac_mdio.c
+++ b/drivers/net/dpa/xgmac_mdio.c
@@ -1,4 +1,5 @@
-/* Copyright (C) 2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/dpa/xgmac_mdio.h b/drivers/net/dpa/xgmac_mdio.h
index 854e03f..dac164b 100644
--- a/drivers/net/dpa/xgmac_mdio.h
+++ b/drivers/net/dpa/xgmac_mdio.h
@@ -1,4 +1,5 @@
-/* Copyright (C) 2009 Freescale Semiconductor, Inc. All rights reserved.
+/* Copyright (C) 2009-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
-- 
1.6.5.2

