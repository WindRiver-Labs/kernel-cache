From 80f9a1964b5d0dd6c742e78ebb27e9ec5504530f Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Mon, 5 Sep 2011 13:12:41 +0800
Subject: [PATCH] Fix compile warnings from gianfar

These warning happens when compiling gianfar driver:
drivers/net/gianfar.c:331: warning: assignment makes pointer from integer without a cast
drivers/net/gianfar.c:409: warning: assignment makes pointer from integer without a cast
drivers/net/gianfar.c:419: warning: assignment makes integer from pointer without a cast
drivers/net/gianfar.c:1160: warning: assignment from incompatible pointer type
drivers/net/gianfar.c:1145: warning: 'get_cpu_number' defined but not used
drivers/net/gianfar_ethtool.c:859: warning: 'gfar_dump_filer_table' defined but not used
drivers/net/gianfar_1588.c:488: warning: ignoring return value of
'copy_to_user', declared with attribute warn_unused_result
drivers/net/gianfar_1588.c:492: warning: ignoring return value of
'copy_to_user', declared with attribute warn_unused_result
drivers/net/gianfar_1588.c:496: warning: ignoring return value of
'copy_to_user', declared with attribute warn_unused_result
drivers/net/gianfar_1588.c:514: warning: ignoring return value of
'copy_to_user', declared with attribute warn_unused_result
drivers/net/gianfar.c:1737: warning: statement with no effect
drivers/net/gianfar.c:1770: warning: statement with no effect
drivers/net/gianfar.c:1824: warning: statement with no effect
drivers/net/gianfar.c:1829: warning: statement with no effect
drivers/net/gianfar.c: In function 'gfar_probe':
drivers/net/gianfar.c:1159: warning: unused variable 'j'

Fix this problem by:
- Make convert data type from assignment properly
- Remove unused function get_cpu_number and gfar_dump_filer_table
- Explicitly ignore the return value of copy_to_user
- Remove unneeded input parameter 'state' from pmc_enable_wake
- Wrap 'int j' in CONFIG_WRHV

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 arch/powerpc/sysdev/fsl_pmc.c |    3 +-
 arch/powerpc/sysdev/fsl_soc.h |    5 +-
 drivers/net/gianfar.c         |   85 ++++------------------------------------
 drivers/net/gianfar_1588.c    |    8 ++--
 drivers/net/gianfar_ethtool.c |   10 -----
 5 files changed, 16 insertions(+), 95 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_pmc.c b/arch/powerpc/sysdev/fsl_pmc.c
index 8253ce4..15f86ec 100644
--- a/arch/powerpc/sysdev/fsl_pmc.c
+++ b/arch/powerpc/sysdev/fsl_pmc.c
@@ -48,7 +48,6 @@ void mpc85xx_enter_deep_sleep(u64 ccsrbar, u32 powmgtreq);
 /**
  * pmc_enable_wake - enable OF device as wakeup event source
  * @ofdev: OF device affected
- * @state: PM state from which device will issue wakeup events
  * @enable: True to enable event generation; false to disable
  *
  * This enables the device as a wakeup event source, or disables it.
@@ -59,7 +58,7 @@ void mpc85xx_enter_deep_sleep(u64 ccsrbar, u32 powmgtreq);
  * Error code depending on the platform is returned if both the platform and
  * the native mechanism fail to enable the generation of wake-up events
  */
-int pmc_enable_wake(struct of_device *ofdev, suspend_state_t state, bool enable)
+int pmc_enable_wake(struct of_device *ofdev, bool enable)
 {
 	int ret = 0;
 	struct device_node *clk_np;
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index ccc4fbf..9c0a122 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -24,11 +24,10 @@ struct device_node;
 extern void fsl_rstcr_restart(char *cmd);
 
 #ifdef CONFIG_FSL_PMC
-int pmc_enable_wake(struct of_device *ofdev, suspend_state_t state,
-		bool enable);
+int pmc_enable_wake(struct of_device *ofdev, bool enable);
 void pmc_enable_lossless(int enable);
 #else
-#define pmc_enable_wake(ofdev, state, enable)	(-EINVAL)
+#define pmc_enable_wake(ofdev, enable)	(-EINVAL)
 #define pmc_enable_lossless(enable) do {} while (0);
 #endif
 
diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index b303be3..2513532 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -331,7 +331,7 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
 
 	/* Allocate memory for the buffer descriptors */
-	vaddr = alloc_bds(priv, &addr);
+	vaddr = (void *) alloc_bds(priv, &addr);
 
 	if (!vaddr) {
 		if (netif_msg_ifup(priv))
@@ -408,7 +408,7 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	/* Alloc wake up rx buffer, wake up buffer need 64 bytes aligned */
 		rx_queue = priv->rx_queue[priv->num_rx_queues - 1];
 		rx_queue->cur_rx = rx_queue->rx_bd_base;
-		vaddr = (unsigned long) dma_alloc_coherent(&priv->ofdev->dev,
+		vaddr = dma_alloc_coherent(&priv->ofdev->dev,
 			priv->wk_buffer_size * rx_queue->rx_ring_size  \
 			+ RXBUF_ALIGNMENT, &addr, GFP_KERNEL);
 		if (vaddr == 0) {
@@ -419,7 +419,7 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 			goto wk_buf_fail;
 		}
 
-		priv->wk_buf_vaddr = vaddr;
+		priv->wk_buf_vaddr = (unsigned long) vaddr;
 		priv->wk_buf_paddr = addr;
 		wk_buf_vaddr = (unsigned long)(vaddr + RXBUF_ALIGNMENT) \
 						& ~(RXBUF_ALIGNMENT - 1);
@@ -1145,75 +1145,6 @@ static void gfar_detect_errata(struct gfar_private *priv)
 			 priv->errata);
 }
 
-static int get_cpu_number(unsigned char *eth_pkt, int len)
-{
-	u32 addr1, addr2, ports;
-	struct ipv6hdr *ip6;
-	struct iphdr *ip;
-	u32 hash, ihl;
-	u8 ip_proto;
-	int cpu;
-	struct ethhdr *eth;
-	static u32 simple_hashrnd;
-	static int simple_hashrnd_initialized;
-
-	if (len < ETH_HLEN)
-		return -1;
-	else
-		eth = eth_pkt;
-
-	if (unlikely(!simple_hashrnd_initialized)) {
-		get_random_bytes(&simple_hashrnd, 4);
-		simple_hashrnd_initialized = 1;
-	}
-
-	switch (eth->h_proto) {
-	case __constant_htons(ETH_P_IP):
-		if (len < (ETH_HLEN + sizeof(*ip)))
-			return -1;
-
-		ip = (struct iphdr *) (eth_pkt + ETH_HLEN);
-		ip_proto = ip->protocol;
-		addr1 = ip->saddr;
-		addr2 = ip->daddr;
-		ihl = ip->ihl;
-		break;
-	case __constant_htons(ETH_P_IPV6):
-		if (len < (ETH_HLEN + sizeof(*ip6)))
-			return -1;
-
-		ip6 = (struct ipv6hdr *)(eth_pkt + ETH_HLEN);
-		ip_proto = ip6->nexthdr;
-		addr1 = ip6->saddr.s6_addr32[3];
-		addr2 = ip6->daddr.s6_addr32[3];
-		ihl = (40 >> 2);
-		break;
-	default:
-		return -EINVAL;
-	}
-	ports = 0;
-	switch (ip_proto) {
-	case IPPROTO_TCP:
-	case IPPROTO_UDP:
-	case IPPROTO_DCCP:
-	case IPPROTO_ESP:
-	case IPPROTO_AH:
-	case IPPROTO_SCTP:
-	case IPPROTO_UDPLITE:
-		if (len < (ETH_HLEN + (ihl * 4) + 4))
-			ports = *((u32 *) (eth_pkt + ETH_HLEN + (ihl * 4)));
-		break;
-
-	default:
-		break;
-	}
-
-	hash = jhash_3words(addr1, addr2, ports, simple_hashrnd);
-	cpu = hash & 0x1;
-
-	return cpu_online(cpu) ? cpu : -1;
-}
-
 /* Set up the ethernet device structure, private data,
  * and anything else we need before we start */
 static int gfar_probe(struct of_device *ofdev,
@@ -1228,7 +1159,9 @@ static int gfar_probe(struct of_device *ofdev,
 	u32 rstat = 0, tstat = 0, rqueue = 0, tqueue = 0;
 	u32 isrg = 0;
 	u32 __iomem *baddr;
+#ifdef CONFIG_WRHV
 	int j;
+#endif
 
 	err = gfar_of_init(ofdev, &dev);
 
@@ -1743,7 +1676,7 @@ static int gfar_suspend(struct device *dev)
 		(priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET);
 
 	if (arp_packet) {
-		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 1);
+		pmc_enable_wake(priv->ofdev, 1);
 		pmc_enable_lossless(1);
 		gfar_arp_suspend(ndev);
 		return 0;
@@ -1776,7 +1709,7 @@ static int gfar_suspend(struct device *dev)
 		disable_napi(priv);
 
 		if (magic_packet) {
-			pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 1);
+			pmc_enable_wake(priv->ofdev, 1);
 			/* Enable interrupt on Magic Packet */
 			gfar_write(&regs->imask, IMASK_MAG);
 
@@ -1830,12 +1763,12 @@ static int gfar_resume(struct device *dev)
 		(priv->device_flags & FSL_GIANFAR_DEV_HAS_ARP_PACKET);
 
 	if (arp_packet) {
-		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 0);
+		pmc_enable_wake(priv->ofdev, 0);
 		pmc_enable_lossless(0);
 		gfar_arp_resume(ndev);
 		return 0;
 	} else if (magic_packet) {
-		pmc_enable_wake(priv->ofdev, PM_SUSPEND_MEM, 0);
+		pmc_enable_wake(priv->ofdev, 0);
 	}
 
 	if (!netif_running(ndev)) {
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index d7550e0..c5d134d 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -485,15 +485,15 @@ int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case PTP_GET_RX_TIMESTAMP_PDELAY_RESP:
 		retval = gfar_get_rx_time(priv, ifr, &rx_time, cmd);
 		if (retval == 0)
-			copy_to_user(ifr->ifr_data, &rx_time, sizeof(rx_time));
+			(void) copy_to_user(ifr->ifr_data, &rx_time, sizeof(rx_time));
 		break;
 	case PTP_GET_TX_TIMESTAMP:
 		gfar_get_tx_timestamp(regs, &tx_time);
-		copy_to_user(ifr->ifr_data, &tx_time, sizeof(tx_time));
+		(void) copy_to_user(ifr->ifr_data, &tx_time, sizeof(tx_time));
 		break;
 	case PTP_GET_CNT:
 		gfar_get_curr_cnt(priv->ptimer, &curr_time);
-		copy_to_user(ifr->ifr_data, &curr_time, sizeof(curr_time));
+		(void) copy_to_user(ifr->ifr_data, &curr_time, sizeof(curr_time));
 		break;
 	case PTP_SET_CNT:
 		cnt = (struct gfar_ptp_time *)ifr->ifr_data;
@@ -511,7 +511,7 @@ int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case PTP_GET_ADDEND:
 		/* return initial timer add value
 		 * to calculate drift correction */
-		copy_to_user(ifr->ifr_data, &freq_compensation,
+		(void) copy_to_user(ifr->ifr_data, &freq_compensation,
 				sizeof(freq_compensation));
 		break;
 	case PTP_CLEANUP_TIMESTAMP_BUFFERS:
diff --git a/drivers/net/gianfar_ethtool.c b/drivers/net/gianfar_ethtool.c
index b488e6e..f22a43a 100644
--- a/drivers/net/gianfar_ethtool.c
+++ b/drivers/net/gianfar_ethtool.c
@@ -856,16 +856,6 @@ static void ethflow_to_filer_rules(struct gfar_private *priv, u64 ethflow,
 
 }
 
-static void gfar_dump_filer_table(struct gfar_private *priv)
-{
-	u32 fcr, fpr, far;
-	for (far = 0; far <= priv->max_filer_rules; far++) {
-		gfar_read_filer(priv, far, &fcr, &fpr);
-		if (fcr != RQFCR_CMP_NOMATCH)
-			printk(KERN_INFO"[%d] fcr %x, fpr %x\n", far, fcr, fpr);
-	}
-}
-
 static int gfar_ethflow_to_filer_table(struct gfar_private *priv, u64 ethflow, u64 class)
 {
 	unsigned int last_rule_idx = priv->cur_filer_idx;
-- 
1.7.0.2

