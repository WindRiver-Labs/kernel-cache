From 4bf7d72dab60de372ae5834967e5c8b3994ccb37 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 21 Sep 2010 11:19:23 -0400
Subject: [PATCH 244/252] kexec/ppc32/36-bit: fix load of vmlinux

Using 64-bit phys_addr_t for 36-bit addressing used the top 32-bit
of the address to build the crashkernel entry in the device-tree,
which would end up being 0 pretty much all the time. This broke the
verification that the crash kernel fit in the reserved memory

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Integrated-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/kernel/machine_kexec.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/kernel/machine_kexec.c b/arch/powerpc/kernel/machine_kexec.c
index bb3d893..feff367 100644
--- a/arch/powerpc/kernel/machine_kexec.c
+++ b/arch/powerpc/kernel/machine_kexec.c
@@ -145,6 +145,7 @@ int overlaps_crashkernel(unsigned long start, unsigned long size)
 
 /* Values we need to export to the second kernel via the device tree. */
 static unsigned long kernel_end;
+static unsigned long crashk_base;
 static unsigned long crashk_size;
 
 static struct property kernel_end_prop = {
@@ -156,7 +157,7 @@ static struct property kernel_end_prop = {
 static struct property crashk_base_prop = {
 	.name = "linux,crashkernel-base",
 	.length = sizeof(unsigned long),
-	.value = &crashk_res.start,
+	.value = &crashk_base,
 };
 
 static struct property crashk_size_prop = {
@@ -180,6 +181,7 @@ static void __init export_crashk_values(struct device_node *node)
 		prom_remove_property(node, prop);
 
 	if (crashk_res.start != 0) {
+		crashk_base = crashk_res.start;
 		prom_add_property(node, &crashk_base_prop);
 		crashk_size = crashk_res.end - crashk_res.start + 1;
 		prom_add_property(node, &crashk_size_prop);
-- 
1.6.5.2

