From 5c531e7891dfcbbf0366b05fdc9d073e215430b9 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 21 Sep 2010 15:00:59 -0400
Subject: [PATCH 168/233] kexec/ppc32: Disable local interrupts earlier

Reduce the window while interrupts are enabled when the kernel
is going down in the fast-reboot case.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/kernel/machine_kexec_32.c |   21 +++++++++++++--------
 1 files changed, 13 insertions(+), 8 deletions(-)

diff --git a/arch/powerpc/kernel/machine_kexec_32.c b/arch/powerpc/kernel/machine_kexec_32.c
index 0bb34b0..b5702cc 100644
--- a/arch/powerpc/kernel/machine_kexec_32.c
+++ b/arch/powerpc/kernel/machine_kexec_32.c
@@ -140,8 +140,6 @@ static void _smp_kexec_secondary_cpu_down(void *arg)
 
 	struct kimage *image = (struct kimage *)arg;
 
-	local_irq_disable();
-
 	rnkss = (u32)&relocate_new_kernel_secondary_spin;
 	rnkss = virt_to_phys((void *)kexec_find_reloc(image, rnkss));
 
@@ -167,7 +165,6 @@ static void _smp_kexec_wait_for_secondaries(void *arg)
 				  * optimized out. */
 	unsigned int ncpus;
 
-	local_irq_disable();
 	ready = (void*)kexec_find_reloc((struct kimage *)arg,
 				(u32)&relocate_new_kernel_ready);
 	ncpus = num_online_cpus()-1;
@@ -195,6 +192,12 @@ static void _smp_handle_non_kexecing_cpu(void *arg)
 	/* NOT REACHED */
 }
 
+static void _smp_handle_non_kexecing_cpu_and_irq_disable(void *arg)
+{
+	hard_irq_disable();
+	_smp_handle_non_kexecing_cpu(arg);
+}
+
 static struct kimage * __crash_smp_flag = NULL;
 void default_kexec_stop_cpus(void *arg)
 {
@@ -204,17 +207,19 @@ void default_kexec_stop_cpus(void *arg)
 	 * a spin; if we're CPU0, call CPUn to put themselves on a spin,
 	 * then do the rest of the shutdown sequence. */
 
-	/* if this is coming while handling a crash, the CPUs that did not
+	/* If this is coming while handling a crash, the CPUs that did not
 	 * crash are already spinning in a loop with their interrupts locked:
 	 * get them out of that loop and execute their normal kexec shutdown
-	 * sequence */
-	preempt_disable();
-	/* shutdown cpu 1 and wait for it */
+	 * sequence.  The CPU that did crash also has its interrupts
+	 * disabled */
 	if(kexec_is_handling_crash()) {
 		__crash_smp_flag = arg;
 		smp_mb();
 	} else {
-		smp_call_function(_smp_handle_non_kexecing_cpu, arg, 0);
+		preempt_disable();
+		smp_call_function(_smp_handle_non_kexecing_cpu_and_irq_disable,
+					arg, 0);
+		hard_irq_disable();
 	}
 	/* get hardware CPU# from special Processor Identity Register */
 	if (mfspr(SPRN_PIR) == 0) {
-- 
1.7.0.4

