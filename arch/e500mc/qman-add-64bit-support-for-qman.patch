From d2f24f8db43ae346102fb856ab0a8cbfd2d7e09a Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 21 Apr 2010 15:23:16 +0800
Subject: [PATCH 117/252] qman: add 64bit support for qman

When we enable "Large physical address support" in kernel config,
the dma_addr_t will change to u64. This will trigger several BUG_ON
in qman driver. So add the support for 64bit dma_addr_t and remove
these BUG_ON.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/hwqueue/qman_config.c |   12 ++++++++----
 drivers/hwqueue/qman_high.c   |    3 +--
 2 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index 25f3f50..ba2876a 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -436,8 +436,11 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 	pr_info("Using %s property '%s'\n", node->full_name, name);
 	/* Props are 64-bit, but dma_addr_t is (currently) 32-bit */
 	BUG_ON(sizeof(*addr) != 4);
-	BUG_ON(pint[0] || pint[2]);
+	BUG_ON(pint[2]);
 	*addr = pint[1];
+#ifdef CONFIG_PHYS_64BIT
+	*addr |= (u64)pint[0] << 32;
+#endif
 	*sz = pint[3];
 	/* Keep things simple, it's either all in the DRAM range or it's all
 	 * outside. */
@@ -477,7 +480,6 @@ static int __init fsl_qman_init(struct device_node *node)
 	u16 id;
 	u8 major, minor;
 
-	BUG_ON(sizeof(dma_addr_t) != sizeof(u32));
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
 		pr_err("Can't get %s property '%s'\n", node->full_name, "reg");
@@ -495,9 +497,11 @@ static int __init fsl_qman_init(struct device_node *node)
 	if (!qman_ip_rev)
 		qman_ip_rev = ((u16)major << 8) | minor;
 	/* FQD memory */
-	qm_set_memory(qm, qm_memory_fqd, 0, (u32)fqd_a, 1, 0, 0, fqd_sz);
+	qm_set_memory(qm, qm_memory_fqd, (u16)((u64)fqd_a >> 32), (u32)fqd_a,
+			1, 0, 0, fqd_sz);
 	/* PFDR memory */
-	qm_set_memory(qm, qm_memory_pfdr, 0, (u32)pfdr_a, 1, 0, 0, pfdr_sz);
+	qm_set_memory(qm, qm_memory_pfdr, (u16)((u64)pfdr_a >> 32), (u32)pfdr_a,
+			1, 0, 0, pfdr_sz);
 	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
 	/* thresholds */
 	qm_set_pfdr_threshold(qm, 32, 32);
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 6ddea06..83ebf63 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -910,7 +910,6 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	if ((flags & QMAN_INITFQ_FLAG_NULL) ||
 			fq_isclear(fq, QMAN_FQ_FLAG_TO_DCPORTAL)) {
 		dma_addr_t phys_fq;
-		BUG_ON(sizeof(phys_fq) > sizeof(u32));
 		mcc->initfq.we_mask |= QM_INITFQ_WE_CONTEXTB;
 		mcc->initfq.fqd.context_b = (flags & QMAN_INITFQ_FLAG_NULL) ?
 						0 : (u32)fq;
@@ -923,7 +922,7 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		}
 		phys_fq = dma_map_single(&p->pdev->dev, fq, sizeof(*fq),
 					DMA_TO_DEVICE);
-		mcc->initfq.fqd.context_a.context_hi = 0;
+		mcc->initfq.fqd.context_a.context_hi = (u32)((u64)phys_fq >> 32);
 		mcc->initfq.fqd.context_a.context_lo = (u32)phys_fq;
 	}
 	if (flags & QMAN_INITFQ_FLAG_LOCAL) {
-- 
1.6.5.2

