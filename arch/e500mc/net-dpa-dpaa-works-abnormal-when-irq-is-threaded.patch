From 56aa000367515da9817610810dce2161238261db Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 11 Jan 2011 14:55:10 +0800
Subject: [PATCH 25/28] net/dpa: dpaa works abnormal when irq is threaded

In preempt-rt/cgl kernel, hardirq is threaded, which means
we can't use in_irq() to judge whether kernel runs in a hardirq
context or not, so here use flag PFE_HARDIRQ/PF_HARDIRQ instead.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/net/dpa/dpaa_eth.h |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/drivers/net/dpa/dpaa_eth.h b/drivers/net/dpa/dpaa_eth.h
index 5d071bb..31a2d39 100644
--- a/drivers/net/dpa/dpaa_eth.h
+++ b/drivers/net/dpa/dpaa_eth.h
@@ -122,7 +122,17 @@ extern const struct ethtool_ops dpa_ethtool_ops;
 
 static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 {
+/* in preempt-rt kernel, flag PFE_HARDIRQ is set in hardirq-thread */
+#if defined(CONFIG_PREEMPT_RT)
+	if (unlikely(current->extra_flags & PFE_HARDIRQ)) {
+/* this branch is for cgl kernel, which uses PF_HARDIRQ
+ * as hardirq-thread flag
+ */
+#elif defined(CONFIG_PREEMPT_HARDIRQS)
+	if (unlikely(current->flags & PF_HARDIRQ)) {
+#else
 	if (unlikely(in_irq())) {
+#endif
 		/* Disable QMan IRQ and invoke NAPI */
 		qman_irqsource_remove(QM_PIRQ_DQRI);
 		napi_schedule(&percpu_priv->napi);
-- 
1.6.5.2

