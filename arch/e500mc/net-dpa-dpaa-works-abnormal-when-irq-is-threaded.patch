From d89a538080f1869e35bc5e0e02472c9e33d3c95c Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 11 Jan 2011 14:55:10 +0800
Subject: [PATCH 219/233] net/dpa: dpaa works abnormal when irq is threaded

In preempt-rt/cgl kernel, hardirq is threaded, which means
we can't use in_irq() to judge whether kernel runs in a hardirq
context or not, so here use flag PFE_HARDIRQ/PF_HARDIRQ instead.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/net/dpa/dpaa_eth.h |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/drivers/net/dpa/dpaa_eth.h b/drivers/net/dpa/dpaa_eth.h
index b4295e9..bc8fc89 100644
--- a/drivers/net/dpa/dpaa_eth.h
+++ b/drivers/net/dpa/dpaa_eth.h
@@ -111,7 +111,17 @@ extern const struct ethtool_ops dpa_ethtool_ops;
 
 static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 {
+/* in preempt-rt kernel, flag PFE_HARDIRQ is set in hardirq-thread */
+#if defined(CONFIG_PREEMPT_RT)
+	if (unlikely(current->extra_flags & PFE_HARDIRQ)) {
+/* this branch is for cgl kernel, which uses PF_HARDIRQ
+ * as hardirq-thread flag
+ */
+#elif defined(CONFIG_PREEMPT_HARDIRQS)
+	if (unlikely(current->flags & PF_HARDIRQ)) {
+#else
 	if (unlikely(in_irq())) {
+#endif
 		/* Disable QMan IRQ and invoke NAPI */
 		int ret = qman_irqsource_remove(QM_PIRQ_DQRI);
 		if (likely(!ret)) {
-- 
1.7.0.4

