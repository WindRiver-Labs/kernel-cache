From f1d4cc0405f861d561346a5528ecaf748049711e Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Wed, 29 Jun 2011 15:00:17 +0800
Subject: [PATCH 205/233] WRHV/p4080: Bypass configure B/QMAN FBPR BAR

While booting guest OS, VxWorks will think that BAR address configured
from Linux as invalid address. And often BootROM will configure that as well.
So here we assume FBPR BAR is already configured correctly if that value is
nonzero, then don't configure that again on Linux.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
[rebase it onto QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c |   11 ++++--
 drivers/staging/fsl_qbman/qman_config.c |   61 +++++++++++++++++--------------
 2 files changed, 41 insertions(+), 31 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index c4e0f81..18fe24c 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -242,9 +242,14 @@ static void bm_set_memory(struct bman *bm, u64 ba, int prio, u32 size)
 			is_power_of_2(size));
 	/* choke if '[e]ba' has lower-alignment than 'size' */
 	DPA_ASSERT(!(ba & (size - 1)));
-	bm_out(FBPR_BARE, upper_32_bits(ba));
-	bm_out(FBPR_BAR, lower_32_bits(ba));
-	bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	/* We assume FBPR BAR is already configured correctly
+	 * if that value is nonzero.
+	 */
+	if ((bm_in(FBPR_BAR)) == 0) {
+		bm_out(FBPR_BARE, upper_32_bits(ba));
+		bm_out(FBPR_BAR, lower_32_bits(ba));
+		bm_out(FBPR_AR, (prio ? 0x40000000 : 0) | (exp - 1));
+	}
 }
 
 /*****************/
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 80b1e34..6312f54 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -573,14 +573,6 @@ static int __init fsl_qman_init(struct device_node *node)
 	s = of_get_property(node, "fsl,hv-claimable", &ret);
 	if (s && !strcmp(s, "standby"))
 		standby = 1;
-	if (!standby) {
-		ret = parse_mem_property(node, "fsl,qman-fqd",
-					&fqd_a, &fqd_sz, 1);
-		BUG_ON(ret);
-		ret = parse_mem_property(node, "fsl,qman-pfdr",
-					&pfdr_a, &pfdr_sz, 0);
-		BUG_ON(ret);
-	}
 	/* Global configuration */
 	regs = ioremap(res.start, res.end - res.start + 1);
 	qm = qm_create(regs);
@@ -606,26 +598,39 @@ static int __init fsl_qman_init(struct device_node *node)
 		pr_info("  -> in standby mode\n");
 		return 0;
 	}
-	/* FQD memory */
-	qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
-	/* PFDR memory */
-	qm_set_memory(qm, qm_memory_pfdr, pfdr_a, 1, 0, 0, pfdr_sz);
-	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
-	/* thresholds */
-	qm_set_pfdr_threshold(qm, 512, 64);
-	qm_set_sfdr_threshold(qm, 128);
-	/* clear stale PEBI bit from interrupt status register */
-	qm_err_isr_status_clear(qm, QM_EIRQ_PEBI);
-	/* corenet initiator settings */
-	qm_set_corenet_initiator(qm);
-	/* HID settings */
-	qm_set_hid(qm);
-	/* Set scheduling weights to defaults */
-	for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
-		qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
-	/* We are not prepared to accept ERNs for hardware enqueues */
-	qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
-	qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	/* We assume FQD BAR is already configured correctly
+	 * if that value is nonzero.
+	 */
+	if((__qm_in(qm, REG_FQD_BARE + REG_offset_BAR)) == 0) {
+		if (!standby) {
+			ret = parse_mem_property(node, "fsl,qman-fqd",
+						&fqd_a, &fqd_sz, 1);
+			BUG_ON(ret);
+			ret = parse_mem_property(node, "fsl,qman-pfdr",
+						&pfdr_a, &pfdr_sz, 0);
+			BUG_ON(ret);
+		}
+		/* FQD memory */
+		qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
+		/* PFDR memory */
+		qm_set_memory(qm, qm_memory_pfdr, pfdr_a, 1, 0, 0, pfdr_sz);
+		qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
+		/* thresholds */
+		qm_set_pfdr_threshold(qm, 512, 64);
+		qm_set_sfdr_threshold(qm, 128);
+		/* clear stale PEBI bit from interrupt status register */
+		qm_err_isr_status_clear(qm, QM_EIRQ_PEBI);
+		/* corenet initiator settings */
+		qm_set_corenet_initiator(qm);
+		/* HID settings */
+		qm_set_hid(qm);
+		/* Set scheduling weights to defaults */
+		for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
+			qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
+		/* We are not prepared to accept ERNs for hardware enqueues */
+		qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
+		qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	}
 	return 0;
 }
 
-- 
1.7.0.4

