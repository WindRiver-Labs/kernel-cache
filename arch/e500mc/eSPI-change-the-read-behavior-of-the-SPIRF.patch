From 23c970f3bf94c990742657faced538ad5c966b66 Mon Sep 17 00:00:00 2001
From: Mingkai Hu <Mingkai.hu@freescale.com>
Date: Mon, 30 Aug 2010 17:50:48 +0800
Subject: [PATCH 140/233] eSPI: change the read behavior of the SPIRF

commit e6289d63a6f39237a027dcee46366ba158cb8406 upstream
correspond to vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0110-eSPI-change-the-read-behavior-of-the-SPIRF.patch

The user must read N bytes of SPIRF (1 <= N <= 4) that do not exceed the
amount of data in the receive FIFO, so read the SPIRF byte by byte when
the data in receive FIFO is less than 4 bytes.

On Simics, when read N bytes that exceed the amout of data in receive
FIFO, we can't read the data out, so we can't clear the rx count, the
CPU will loop on the espi rx interrupt.

Signed-off-by: Mingkai Hu <Mingkai.hu@freescale.com>
---
 drivers/spi/spi_fsl_espi.c |   21 ++++++++++++++++++---
 1 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/drivers/spi/spi_fsl_espi.c b/drivers/spi/spi_fsl_espi.c
index eddd2f7..478bf94 100644
--- a/drivers/spi/spi_fsl_espi.c
+++ b/drivers/spi/spi_fsl_espi.c
@@ -390,16 +390,31 @@ static void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)
 {
 	/* We need handle RX first */
 	if (events & SPIE_NE) {
-		u32 rx_data;
+		u32 rx_data, tmp;
+		u8 rx_data_8;
 
 		/* Spin until RX is done */
 		while (SPIE_RXCNT(events) < min(4, mspi->len)) {
 			cpu_relax();
 			events = mpc8xxx_spi_read_reg(&mspi->espi_base->event);
 		}
-		mspi->len -= 4;
 
-		rx_data = mpc8xxx_spi_read_reg(&mspi->espi_base->receive);
+		if (mspi->len >= 4) {
+			rx_data = mpc8xxx_spi_read_reg(
+					&mspi->espi_base->receive);
+		} else {
+			tmp = mspi->len;
+			rx_data = 0;
+			while (tmp--) {
+				rx_data_8 = in_8((u8 *)
+						&mspi->espi_base->receive);
+				rx_data |= (rx_data_8 << (tmp * 8));
+			}
+
+			rx_data <<= (4 - mspi->len) * 8;
+		}
+
+		mspi->len -= 4;
 
 		if (mspi->rx)
 			mspi->get_rx(rx_data, mspi);
-- 
1.7.0.4

