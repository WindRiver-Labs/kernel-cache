From 4bf74b92e5b2dcade720cfb74bc76cd42323ee0e Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 16 Sep 2010 13:28:45 +0800
Subject: [PATCH 188/252] crypto: caam - algapi: convert cipher key to inlined in shared descriptor

Patch taken from FSL vendor SDK 2.1.

Change key specification in shared descriptor to inline the cipher key.
the protected ('covered') authentication key can't be immediate/inlined,
even if it would fit in a descriptor (CAAM_MAX_DESC_SIZE).

This results in faster performance since the h/w doesn't have to make
the additional access to memory to obtain the cipher key.  A consistent
throughput improvement of 8kpps was observed in a 64-byte packet test.

Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/crypto/caam/algapi.c |   42 ++++++++++++++++++++++++------------------
 1 files changed, 24 insertions(+), 18 deletions(-)

diff --git a/drivers/crypto/caam/algapi.c b/drivers/crypto/caam/algapi.c
index c8a96f7..7d4b0a2 100644
--- a/drivers/crypto/caam/algapi.c
+++ b/drivers/crypto/caam/algapi.c
@@ -94,7 +94,7 @@ struct caam_ctx {
 	struct device *dev;
 	int class1_alg_type;
 	int class2_alg_type;
-	u8 key[CAAM_MAX_KEY_SIZE];
+	u8 *key;
 	dma_addr_t key_phys;
 	unsigned int keylen;
 	unsigned int enckeylen;
@@ -118,7 +118,6 @@ struct ipsec_deco_dpovrd {
 	u8 next_header;	/* reserved if decap */
 } __packed;
 
-
 static DEFINE_PER_CPU(int, cpu_to_job_queue);
 
 static int aead_authenc_setauthsize(struct crypto_aead *authenc,
@@ -158,7 +157,7 @@ static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
 
 	/* build shared descriptor for this session */
 	sh_desc = kzalloc(sizeof(struct ipsec_decap_pdb) +
-			 (sizeof(u32) + CAAM_MAX_KEY_SIZE) * 2 +
+			 ctx->split_key_len + ctx->enckeylen +
 			 sizeof(struct iphdr), GFP_DMA | flags);
 	if (!sh_desc) {
 		dev_err(dev, "could not allocate shared descriptor\n");
@@ -200,10 +199,10 @@ static int build_protocol_desc_ipsec_decap(struct caam_ctx *ctx,
 				     PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
 				     ITEM_REFERENCE, ITEM_CLASS2);
 
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)(ctx->key_phys +
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)(ctx->key +
 				     ctx->split_key_len), ctx->enckeylen * 8,
 				     PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				     ITEM_REFERENCE, ITEM_CLASS1);
+				     ITEM_INLINE, ITEM_CLASS1);
 
 	/* insert jump instruction now that we are at the jump target */
 	cmd_insert_jump((u32 *)&sh_desc->end_index[0], JUMP_TYPE_LOCAL, CLASS_2,
@@ -266,7 +265,7 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 
 	/* build shared descriptor for this session */
 	sh_desc = kzalloc(sizeof(struct ipsec_encap_pdb) +
-			 (sizeof(u32) + CAAM_MAX_KEY_SIZE) * 2 +
+			 ctx->split_key_len + ctx->enckeylen +
 			 52 /*sizeof(struct iphdr)*/, GFP_DMA | flags);
 	if (!sh_desc) {
 		dev_err(dev, "could not allocate shared descriptor\n");
@@ -298,7 +297,7 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 	memcpy(&sh_desc->cbc.iv, "myivmyivmyivmyiv", sizeof(sh_desc->cbc.iv));
 #endif
 
-	/*
+	/* 
 	 * indicate no IP header,
 	 * rather a jump instruction and key specification follow
 	 */
@@ -322,10 +321,10 @@ static int build_protocol_desc_ipsec_encap(struct caam_ctx *ctx,
 				     KEYDST_MD_SPLIT, KEY_COVERED,
 				     ITEM_REFERENCE, ITEM_CLASS2);
 
-	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)ctx->key_phys +
+	sh_desc_ptr = cmd_insert_key(sh_desc_ptr, (char *)ctx->key +
 				     ctx->split_key_len, ctx->enckeylen * 8,
 				     PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
-				     ITEM_REFERENCE, ITEM_CLASS1);
+				     ITEM_INLINE, ITEM_CLASS1);
 
 	/* insert jump instruction now that we are at the jump target */
 	cmd_insert_jump((u32 *)&sh_desc->ip_hdr[0], JUMP_TYPE_LOCAL, CLASS_BOTH,
@@ -420,9 +419,6 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 	struct device *tgt_jq_dev;
 	int ret = 0;
 
-	/* FIXME: may need to look at keyspec instead of basing on inkeysize */
-	ctx->split_key_len = ALIGN(authkeylen * 2, 16);
-
 	desc = kzalloc(MAX_CAAM_DESCSIZE, GFP_KERNEL | GFP_DMA);
 	desc_pos = desc;
 
@@ -461,10 +457,11 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 	 * FIFO_STORE with the explicit split-key content store
 	 * (0x26 output type)
 	 */
-	dma_addr_out = dma_map_single(dev, &ctx->key, ctx->split_key_len,
+	dma_addr_out = dma_map_single(dev, ctx->key, ctx->split_key_len,
 				      DMA_FROM_DEVICE);
 	if (dma_mapping_error(dev, dma_addr_out)) {
 		dev_err(dev, "unable to map key output memory\n");
+		kfree(ctx->key);
 		kfree(desc);
 		return -ENOMEM;
 	}
@@ -478,7 +475,7 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 
 #ifdef DEBUG
 	print_hex_dump(KERN_ERR, "ctx.key@"xstr(__LINE__)": ",
-		       DUMP_PREFIX_ADDRESS, 16, 4, &ctx->key,
+		       DUMP_PREFIX_ADDRESS, 16, 4, ctx->key,
 		       CAAM_MAX_KEY_SIZE, 1);
 	print_hex_dump(KERN_ERR, "jobdesc@"xstr(__LINE__)": ",
 		       DUMP_PREFIX_ADDRESS, 16, 4, desc,
@@ -498,7 +495,7 @@ static u32 gen_split_key(struct device *dev, struct caam_ctx *ctx,
 		ret = result.err;
 #ifdef DEBUG
 		print_hex_dump(KERN_ERR, "ctx.key@"xstr(__LINE__)": ",
-			       DUMP_PREFIX_ADDRESS, 16, 4, &ctx->key,
+			       DUMP_PREFIX_ADDRESS, 16, 4, ctx->key,
 			       CAAM_MAX_KEY_SIZE, 1);
 #endif
 	}
@@ -546,6 +543,9 @@ static int aead_authenc_setkey(struct crypto_aead *aead,
 	if (keylen > CAAM_MAX_KEY_SIZE)
 		goto badkey;
 
+	/* FIXME: may need to look at keyspec instead of basing on inkeysize */
+	ctx->split_key_len = ALIGN(authkeylen * 2, 16);
+
 #ifdef DEBUG
 	printk(KERN_ERR "keylen %d enckeylen %d authkeylen %d\n",
 	       keylen, enckeylen, authkeylen);
@@ -553,13 +553,19 @@ static int aead_authenc_setkey(struct crypto_aead *aead,
 		       DUMP_PREFIX_ADDRESS, 16, 4, key,
 		       CAAM_MAX_KEY_SIZE, 1);
 #endif
+	ctx->key = kzalloc(ctx->split_key_len + enckeylen,
+			   GFP_KERNEL | GFP_DMA);
+	if (!ctx->key) {
+		dev_err(ctx->dev, "could not allocate key output memory\n");
+		return -ENOMEM;
+	}
+
 	ret = gen_split_key(dev, ctx, key, authkeylen);
 	if (ret)
 		goto badkey;
 
 	/* postpend encryption key to auth split key */
-	memcpy((char *)&ctx->key + ctx->split_key_len,
-	       key + authkeylen, enckeylen);
+	memcpy(ctx->key + ctx->split_key_len, key + authkeylen, enckeylen);
 
 	ctx->key_phys = dma_map_single(dev, ctx->key,
 				       ctx->split_key_len + enckeylen,
@@ -570,7 +576,7 @@ static int aead_authenc_setkey(struct crypto_aead *aead,
 	}
 #ifdef DEBUG
 	print_hex_dump(KERN_ERR, "ctx.key@"xstr(__LINE__)": ",
-		       DUMP_PREFIX_ADDRESS, 16, 4, &ctx->key,
+		       DUMP_PREFIX_ADDRESS, 16, 4, ctx->key,
 		       CAAM_MAX_KEY_SIZE, 1);
 #endif
 
-- 
1.6.5.2

