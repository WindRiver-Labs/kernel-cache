From 0b1fe057a8b94b8a08431aab202496c6ade0b0ce Mon Sep 17 00:00:00 2001
From: Roy Zang <tie-fei.zang@freescale.com>
Date: Fri, 16 Oct 2009 16:26:55 +0800
Subject: [PATCH 054/252] Add support for getting device platform data to I2C device

There is no standard way of getting device platform data from
dts file to the I2C device when it's probed. This patch adds
a function pointer to the of_modalias_table to get such bindings
properties into device's platform data.

Signed-off-by: Mingkai Hu <Mingkai.hu@freescale.com>
[Applied FSL SDK 2.0.3 patch
"0001-Add-support-for-getting-device-platform-data-to-I2C.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/of/base.c   |    9 ++++++++-
 drivers/of/of_i2c.c |    3 ++-
 drivers/of/of_spi.c |    2 +-
 include/linux/of.h  |    3 ++-
 4 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/drivers/of/base.c b/drivers/of/base.c
index 71d26a7..3d0c1c0 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -566,6 +566,7 @@ EXPORT_SYMBOL(of_find_matching_node);
 struct of_modalias_table {
 	char *of_device;
 	char *modalias;
+	const void *(*binder)(struct device_node *node);
 };
 static struct of_modalias_table of_modalias_table[] = {
 	{ "fsl,mcu-mpc8349emitx", "mcu-mpc8349emitx" },
@@ -578,6 +579,7 @@ static struct of_modalias_table of_modalias_table[] = {
  * @node:	pointer to a device tree node
  * @modalias:	Pointer to buffer that modalias value will be copied into
  * @len:	Length of modalias value
+ * @platform_data: pointer to device's platform specific data
  *
  * Based on the value of the compatible property, this routine will determine
  * an appropriate modalias value for a particular device tree node.  Two
@@ -589,7 +591,8 @@ static struct of_modalias_table of_modalias_table[] = {
  *
  * This routine returns 0 on success
  */
-int of_modalias_node(struct device_node *node, char *modalias, int len)
+int of_modalias_node(struct device_node *node, char *modalias, int len,
+	const void **platform_data)
 {
 	int i, cplen;
 	const char *compatible;
@@ -601,6 +604,10 @@ int of_modalias_node(struct device_node *node, char *modalias, int len)
 		if (!of_device_is_compatible(node, compatible))
 			continue;
 		strlcpy(modalias, of_modalias_table[i].modalias, len);
+
+		if (platform_data && of_modalias_table[i].binder)
+			*platform_data = of_modalias_table[i].binder(node);
+
 		return 0;
 	}
 
diff --git a/drivers/of/of_i2c.c b/drivers/of/of_i2c.c
index a3a708e..f2ef7d5 100644
--- a/drivers/of/of_i2c.c
+++ b/drivers/of/of_i2c.c
@@ -28,7 +28,8 @@ void of_register_i2c_devices(struct i2c_adapter *adap,
 		const __be32 *addr;
 		int len;
 
-		if (of_modalias_node(node, info.type, sizeof(info.type)) < 0)
+		if (of_modalias_node(node, info.type, sizeof(info.type),
+			(const void **)&info.platform_data) < 0)
 			continue;
 
 		addr = of_get_property(node, "reg", &len);
diff --git a/drivers/of/of_spi.c b/drivers/of/of_spi.c
index f65f48b..c40da1c 100644
--- a/drivers/of/of_spi.c
+++ b/drivers/of/of_spi.c
@@ -39,7 +39,7 @@ void of_register_spi_devices(struct spi_master *master, struct device_node *np)
 
 		/* Select device driver */
 		if (of_modalias_node(nc, spi->modalias,
-				     sizeof(spi->modalias)) < 0) {
+				     sizeof(spi->modalias), NULL) < 0) {
 			dev_err(&master->dev, "cannot find modalias for %s\n",
 				nc->full_name);
 			spi_dev_put(spi);
diff --git a/include/linux/of.h b/include/linux/of.h
index a367e19..86cba8e 100644
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@ -190,7 +190,8 @@ extern int of_n_addr_cells(struct device_node *np);
 extern int of_n_size_cells(struct device_node *np);
 extern const struct of_device_id *of_match_node(
 	const struct of_device_id *matches, const struct device_node *node);
-extern int of_modalias_node(struct device_node *node, char *modalias, int len);
+extern int of_modalias_node(struct device_node *node, char *modalias, int len,
+	const void **platform_data);
 extern struct device_node *of_parse_phandle(struct device_node *np,
 					    const char *phandle_name,
 					    int index);
-- 
1.6.5.2

