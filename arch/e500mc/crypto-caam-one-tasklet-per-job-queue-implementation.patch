From 89187069438c09632403618ff3cfc320cc55c071 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Sun, 12 Sep 2010 20:07:07 +0800
Subject: [PATCH 190/252] crypto: caam - one tasklet per job queue implementation

Patch taken from FSL vendor SDK 2.1.

given multiple job queues are in use, multiple interrupts
may be serviced concurrently by more than one core.

this patch further extends the performance benefits that arise
from parallel IRQ processing into the BH (back half) IRQ processing.

at BH exit time, the tasklet_(re)scheduling action has been made
mutually exclusive with the reenablement of h/w interrupts to avoid
doubly scheduling the same queue's tasklet onto two cores, when its IRQ
has been re-affined to another core (observed via "failed to find
matching descriptor" BUG_ON).

8-way 60-byte PKTGEN (from an 8572) performance has exceeded testing
capability; crypto now comes almost 'for free' in this scenario.
Toying with pktgen delays (to maximize its output while keeping in
harmony with dpa_rx), the following kpps were measured:

                    no-IPSec   IPSec
pgset "delay 2000":   406018  404340
pgset "delay 1500":   365580  357550
pgset "delay 2500":   417517  403126
pgset "delay 3000":   331382  330823
pgset "delay 2750":   418986  418713
pgset "delay 2250":   411013  405573
pgset "delay 2625":   420039  406935
pgset "delay 2575":   414329  405703

Prior to this patch, ~250kpps full-IPSec was measured using the same
apparatus (albeit without the delay tuning, i.e, delay was set to 0):

                    no-IPSec   IPSec
pgset "delay 0":      320114  315474
pgset "delay 0":      320480  317869
pgset "delay 0":      320903  315597

..a 26% improvement, up to 62% with a tuned pktgen.

further testing should be performed to determine the true performance
ceiling.

[also fixed a CodingStyle alignment problem whilst in the area]

Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/crypto/caam/intern.h |    2 +-
 drivers/crypto/caam/jq.c     |   50 +++++++++++++++++++++++++----------------
 2 files changed, 31 insertions(+), 21 deletions(-)

diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index ad90f53..c74d93e 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -69,7 +69,7 @@ struct caam_drv_private_jq {
 	struct device *parentdev;	/* points back to controller dev */
 	int qidx;
 	struct caam_job_queue *qregs;	/* points to JobQ's register space */
-	struct tasklet_struct irqtask;
+	struct tasklet_struct irqtask[NR_CPUS];
 	int irq;			/* One per queue */
 	int assign;			/* busy/free */
 
diff --git a/drivers/crypto/caam/jq.c b/drivers/crypto/caam/jq.c
index 0b20f53..0b9bff1 100644
--- a/drivers/crypto/caam/jq.c
+++ b/drivers/crypto/caam/jq.c
@@ -2,7 +2,7 @@
  * CAAM/SEC 4.x transport/backend driver (prototype)
  * JobQ backend functionality
  *
- * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * Copyright (c) 2008-2010, Freescale Semiconductor, Inc.
  * All Rights Reserved
  *
  * Redistribution and use in source and binary forms, with or without
@@ -68,7 +68,9 @@ irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
 	/* Have valid interrupt at this point, just ACK and trigger */
 	wr_reg32(&jqp->qregs->jqintstatus, irqstate);
 
-	tasklet_schedule(&jqp->irqtask);
+	preempt_disable();
+	tasklet_schedule(&jqp->irqtask[smp_processor_id()]);
+	preempt_enable();
 
 	return IRQ_HANDLED;
 }
@@ -132,11 +134,16 @@ void caam_jq_dequeue(unsigned long devarg)
 
 	spin_unlock_irqrestore(&jqp->outlock, flags);
 
+	if (rd_reg32(&jqp->qregs->outring_used)) {
+		preempt_disable();
+		tasklet_schedule(&jqp->irqtask[smp_processor_id()]);
+		preempt_enable();
+	
+		return;
+	}
+
 	/* reenable / unmask IRQs */
 	clrbits32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
-
-	if (rd_reg32(&jqp->qregs->outring_used))
-		tasklet_schedule(&jqp->irqtask);
 }
 
 /**
@@ -310,7 +317,7 @@ int caam_jq_init(struct device *dev)
 {
 	struct caam_drv_private_jq *jqp;
 	u32 inpbusaddr, outbusaddr;
-	int error;
+	int i, error;
 
 	jqp = dev_get_drvdata(dev);
 
@@ -374,24 +381,24 @@ int caam_jq_init(struct device *dev)
 		  (JOBQ_INTC_TIME_THLD << JQCFG_ICTT_SHIFT));
 
 	/* Connect job queue interrupt handler. */
-	tasklet_init(&jqp->irqtask, caam_jq_dequeue, (u32)dev);
+	for_each_possible_cpu(i)
+		tasklet_init(&jqp->irqtask[i], caam_jq_dequeue, (u32)dev);
+
 	error = request_irq(jqp->irq, caam_jq_interrupt, 0,
 			    "caam-jobq", dev);
 	if (error) {
 		dev_err(dev, "can't connect JobQ %d interrupt (%d)\n",
 			jqp->qidx, jqp->irq);
-			irq_dispose_mapping(jqp->irq);
-			jqp->irq = 0;
-			dma_unmap_single(dev, inpbusaddr,
-					 sizeof(u32 *) * JOBQ_DEPTH,
-					 DMA_BIDIRECTIONAL);
-			dma_unmap_single(dev, outbusaddr,
-					 sizeof(struct jq_outentry) * JOBQ_DEPTH,
-					 DMA_BIDIRECTIONAL);
-			kfree(jqp->inpring);
-			kfree(jqp->outring);
-			kfree(jqp->entinfo);
-			return -EINVAL;
+		irq_dispose_mapping(jqp->irq);
+		jqp->irq = 0;
+		dma_unmap_single(dev, inpbusaddr, sizeof(u32 *) * JOBQ_DEPTH,
+		                 DMA_BIDIRECTIONAL);
+		dma_unmap_single(dev, outbusaddr, sizeof(u32 *) * JOBQ_DEPTH,
+		                 DMA_BIDIRECTIONAL);
+		kfree(jqp->inpring);
+		kfree(jqp->outring);
+		kfree(jqp->entinfo);
+		return -EINVAL;
 	}
 
 	jqp->assign = JOBQ_UNASSIGNED;
@@ -404,7 +411,7 @@ int caam_jq_init(struct device *dev)
 int caam_jq_shutdown(struct device *dev)
 {
 	struct caam_drv_private_jq *jqp;
-	u32 used;
+	u32 i, used;
 
 	jqp = dev_get_drvdata(dev);
 
@@ -415,6 +422,9 @@ int caam_jq_shutdown(struct device *dev)
 	wr_reg32(&jqp->qregs->outring_rmvd, used);
 	wr_reg32(&jqp->qregs->jqcommand, JQCR_RESET); /* complete flush */
 
+	for_each_possible_cpu(i)
+		tasklet_kill(&jqp->irqtask[i]);
+
 	/* Release interrupt */
 	free_irq(jqp->irq, dev);
 
-- 
1.6.5.2

