From cbbe9a63d967cf32d83596a8f18a9847f04be9c3 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <geoff.thorpe@freescale.com>
Date: Thu, 23 Jul 2009 16:03:44 -0400
Subject: [PATCH 020/252] pme2: add pme2_have_control(), and fix non-ctrl plane linux

pme2_have_control() checks at run-time to see if ccsr space is
available. Also changed API for pme_attr_get_attr() to return error.

Updated scan test to not run on non-ctrl plane (it depends on sample
db to be present, which may not be the case if sample db is still
running on the control plane).

Signed-off-by: Geoff Thorpe <geoff.thorpe@freescale.com>
Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
[Cleanly applied the FSL SDK 2.0.3 patch:
"0002-pme2-add-pme2_have_control-and-fix-non-ctrl-plan.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/match/pme2_ctrl.c      |   61 ++++++++++++++++++++++++++++++---------
 drivers/match/pme2_db.c        |   15 ++++++++--
 drivers/match/pme2_private.h   |    4 +-
 drivers/match/pme2_test.h      |    1 -
 drivers/match/pme2_test_scan.c |   33 ++++++++++++++--------
 include/linux/fsl_pme.h        |    5 ++-
 6 files changed, 86 insertions(+), 33 deletions(-)

diff --git a/drivers/match/pme2_ctrl.c b/drivers/match/pme2_ctrl.c
index f781df8..559c5dc 100644
--- a/drivers/match/pme2_ctrl.c
+++ b/drivers/match/pme2_ctrl.c
@@ -239,8 +239,14 @@ static ssize_t pme_generic_store(const char *buf, size_t count,
 
 static ssize_t pme_generic_show(char *buf, enum pme_attr attr, const char *fmt)
 {
-	u32 data = pme_attr_get(attr);
-	return snprintf(buf, PAGE_SIZE, fmt, data);
+	u32 data;
+	int ret;
+
+	ret =  pme_attr_get(attr, &data);
+	if (!ret)
+		return snprintf(buf, PAGE_SIZE, fmt, data);
+	else
+		return ret;
 }
 
 static ssize_t pme_generic_stat_show(char *buf, enum pme_attr attr)
@@ -317,6 +323,10 @@ static ssize_t pme_store_update_interval(struct device_driver *pme,
 {
 	unsigned long val;
 
+	if (!pme2_have_control()) {
+		PMEPRERR("not on ctrl-plane\n");
+		return -ENODEV;
+	}
 	if (strict_strtoul(buf, 0, &val)) {
 		pr_err("pme: invalid input %s\n", buf);
 		return -EINVAL;
@@ -331,6 +341,8 @@ static ssize_t pme_store_update_interval(struct device_driver *pme,
 }
 static ssize_t pme_show_update_interval(struct device_driver *pme, char *buf)
 {
+	if (!pme2_have_control())
+		return -ENODEV;
 	return snprintf(buf, PAGE_SIZE, "%u\n", pme_stat_interval);
 }
 static DRIVER_ATTR(update_interval, (S_IRUSR | S_IWUSR),
@@ -778,26 +790,36 @@ module_exit(pme2_ctrl_exit);
  * sysfs attributes.
  */
 
+int pme2_have_control(void)
+{
+	return global_pme ? 1 : 0;
+}
+EXPORT_SYMBOL(pme2_have_control);
+
 int pme2_exclusive_set(struct qman_fq *fq)
 {
-	if (!global_pme)
+	if (!pme2_have_control())
 		return -ENODEV;
 	pme_out(global_pme, EFQC, PME_EFQC(1, qman_fq_fqid(fq)));
 	return 0;
 }
-EXPORT_SYMBOL(pme2_exclusive_set);
 
-void pme2_exclusive_unset(void)
+int pme2_exclusive_unset(void)
 {
+	if (!pme2_have_control())
+		return -ENODEV;
 	pme_out(global_pme, EFQC, PME_EFQC(0, 0));
+	return 0;
 }
-EXPORT_SYMBOL(pme2_exclusive_unset);
 
 int pme_attr_set(enum pme_attr attr, u32 val)
 {
 	u32 mask;
 	u32 attr_val;
 
+	if (!pme2_have_control())
+		return -ENODEV;
+
 	/* Check if Buffer size configuration */
 	if (attr >= pme_attr_bsc_first && attr <= pme_attr_bsc_last) {
 		u32 bsc_pool_id = attr - pme_attr_bsc_first;
@@ -1009,11 +1031,14 @@ int pme_attr_set(enum pme_attr attr, u32 val)
 }
 EXPORT_SYMBOL(pme_attr_set);
 
-u32 pme_attr_get(enum pme_attr attr)
+int pme_attr_get(enum pme_attr attr, u32 *val)
 {
 	u32 mask;
 	u32 attr_val;
 
+	if (!pme2_have_control())
+		return -ENODEV;
+
 	/* Check if Buffer size configuration */
 	if (attr >= pme_attr_bsc_first && attr <= pme_attr_bsc_last) {
 		u32 bsc_pool_id = attr - pme_attr_bsc_first;
@@ -1026,7 +1051,8 @@ u32 pme_attr_get(enum pme_attr attr)
 		attr_val = pme_in(global_pme, BSC0 + ((bsc_pool_id/8)*4));
 		attr_val = attr_val >> ((7-bsc_pool_offset)*4);
 		attr_val = attr_val & 0x0000000F;
-		return attr_val;
+		*val = attr_val;
+		return 0;
 	}
 
 	switch (attr) {
@@ -1320,9 +1346,10 @@ u32 pme_attr_get(enum pme_attr attr)
 
 	default:
 		pr_err("pme: Unknown attr %u\n", attr);
-		return 0;
+		return -EINVAL;
 	};
-	return attr_val;
+	*val = attr_val;
+	return 0;
 }
 EXPORT_SYMBOL(pme_attr_get);
 
@@ -1361,6 +1388,7 @@ int pme_stat_get(enum pme_attr *stat, u64 *value, int reset)
 {
 	int i, ret = 0;
 	int value_set = 0;
+	u32 val;
 
 	spin_lock_irq(&stat_lock);
 	if (stat == NULL || value == NULL) {
@@ -1369,7 +1397,9 @@ int pme_stat_get(enum pme_attr *stat, u64 *value, int reset)
 	} else {
 		for (i = 0; i < sizeof(stat_list)/sizeof(enum pme_attr); i++) {
 			if (stat_list[i] == *stat) {
-				pme_stats[i] += pme_attr_get(stat_list[i]);
+				ret = pme_attr_get(stat_list[i], &val);
+				/* Do I need to check ret */
+				pme_stats[i] += val;
 				*value = pme_stats[i];
 				value_set = 1;
 				if (reset)
@@ -1403,13 +1433,16 @@ static void accumulator_update_interval(u32 interval)
 
 static void accumulator_update(struct work_struct *work)
 {
-	int i;
+	int i, ret;
 	u32 local_interval;
+	u32 val;
 
 	spin_lock_irq(&stat_lock);
 	local_interval = pme_stat_interval;
-	for (i = 0; i < sizeof(stat_list)/sizeof(enum pme_attr); i++)
-		pme_stats[i] += pme_attr_get(stat_list[i]);
+	for (i = 0; i < sizeof(stat_list)/sizeof(enum pme_attr); i++) {
+		ret = pme_attr_get(stat_list[i], &val);
+		pme_stats[i] += val;
+	}
 	spin_unlock_irq(&stat_lock);
 	if (local_interval)
 		schedule_delayed_work(&accumulator_work,
diff --git a/drivers/match/pme2_db.c b/drivers/match/pme2_db.c
index adccbf4..2696c80 100644
--- a/drivers/match/pme2_db.c
+++ b/drivers/match/pme2_db.c
@@ -274,7 +274,7 @@ static int ioctl_sre_reset(unsigned long arg)
 {
 	struct pme_db_sre_reset reset_vals;
 	int i;
-	int srrr_val;
+	u32 srrr_val;
 	int ret = 0;
 
 	if (copy_from_user(&reset_vals, (struct pme_db_sre_reset __user *)arg,
@@ -314,9 +314,14 @@ static int ioctl_sre_reset(unsigned long arg)
 	pme_attr_set(pme_attr_srrr, reset_vals.rule_repetitions);
 	do {
 		mdelay(PME_PMFA_SRE_POLL_MS);
-		srrr_val = pme_attr_get(pme_attr_srrr);
+		ret = pme_attr_get(pme_attr_srrr, &srrr_val);
+		if (!ret) {
+			PMEPRCRIT("pme2: Error reading srrr\n");
+			/* bail */
+			break;
+		}
 		/* Check for error */
-		if (srrr_val & 0x10000000) {
+		else if (srrr_val & 0x10000000) {
 			PMEPRERR("pme2: Error in SRRR\n");
 			ret = -EIO;
 		}
@@ -442,6 +447,10 @@ static int __init fsl_pme2_db_init(void)
 	int err = 0;
 
 	pr_info("Freescale pme2 db driver\n");
+	if (!pme2_have_control()) {
+		PMEPRERR("not on ctrl-plane\n");
+		return -ENODEV;
+	}
 	err = misc_register(&fsl_pme2_db_dev);
 	if (err) {
 		PMEPRERR("cannot register device\n");
diff --git a/drivers/match/pme2_private.h b/drivers/match/pme2_private.h
index e95223e..5597c67 100644
--- a/drivers/match/pme2_private.h
+++ b/drivers/match/pme2_private.h
@@ -131,9 +131,9 @@ union pme_cmd {
 struct qman_fq *slabfq_alloc(void);
 void slabfq_free(struct qman_fq *fq);
 
-/* Hook from pme2_high to pme2_driver */
+/* Hook from pme2_high to pme2_ctrl */
 int pme2_exclusive_set(struct qman_fq *fq);
-void pme2_exclusive_unset(void);
+int pme2_exclusive_unset(void);
 
 /* Hook from pme2_low to pme2_sample_db */
 void pme2_sample_db(void);
diff --git a/drivers/match/pme2_test.h b/drivers/match/pme2_test.h
index 5a6576a..34e6442 100644
--- a/drivers/match/pme2_test.h
+++ b/drivers/match/pme2_test.h
@@ -39,7 +39,6 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/completion.h>
-
 #include <linux/fsl_pme.h>
 #include <linux/fsl_bman.h>
 
diff --git a/drivers/match/pme2_test_scan.c b/drivers/match/pme2_test_scan.c
index 2ee815e..0437b8b 100644
--- a/drivers/match/pme2_test_scan.c
+++ b/drivers/match/pme2_test_scan.c
@@ -57,10 +57,6 @@ struct scan_ctx {
 	struct qm_fd result_fd;
 };
 
-static struct bman_pool *pool;
-static u32 pme_bpid;
-static void *bman_buffers_virt_base;
-static dma_addr_t bman_buffers_phys_base;
 static DECLARE_COMPLETION(scan_comp);
 
 static void scan_cb(struct pme_ctx *ctx, const struct qm_fd *fd,
@@ -73,6 +69,13 @@ static void scan_cb(struct pme_ctx *ctx, const struct qm_fd *fd,
 	complete(&scan_comp);
 }
 
+#ifdef CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
+
+static struct bman_pool *pool;
+static u32 pme_bpid;
+static void *bman_buffers_virt_base;
+static dma_addr_t bman_buffers_phys_base;
+
 static void release_buffer(dma_addr_t addr)
 {
 	struct bm_buffer bufs_in;
@@ -94,7 +97,7 @@ static void empty_buffer(void)
 			pr_info("st: Acquired buffer\n");
 	} while (!ret);
 }
-
+#endif /*CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID*/
 
 void pme2_test_scan(void)
 {
@@ -198,7 +201,7 @@ void pme2_test_scan(void)
 	BUG_ON(ret);
 
 	/* Check with bman */
-#if CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
+#ifdef CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
 	/* reconfigure */
 	ret = pme_ctx_reconfigure_tx(&a_scan_ctx.base_ctx, pme_bpid, 5);
 	BUG_ON(ret);
@@ -423,7 +426,7 @@ void pme2_test_scan(void)
 static int pme2_test_scan_init(void)
 {
 	int big_loop = 2;
-#if CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
+#ifdef CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
 	u32 bpid_size = CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID_SIZE;
 
 	struct bman_pool_params pparams = {
@@ -435,12 +438,13 @@ static int pme2_test_scan_init(void)
 			0
 		}
 	};
-	pr_info("st: About to allocate bpool\n");
-	pool = bman_new_pool(&pparams);
-	if (!pool) {
-		pr_err("st: can't allocate buffer pool, not the ctrl-plane\n");
+	if (!pme2_have_control()) {
+		pr_err("st: Not the ctrl-plane\n");
 		return 0;
 	}
+
+	pr_info("st: About to allocate bpool\n");
+	pool = bman_new_pool(&pparams);
 	BUG_ON(!pool);
 	pme_bpid = bman_get_params(pool)->bpid;
 	pr_info("st: Allocate buffer pool id %d\n", pme_bpid);
@@ -459,9 +463,14 @@ static int pme2_test_scan_init(void)
 	pme_attr_set(pme_attr_bsc(pme_bpid), bpid_size);
 	/* realease to the specified buffer pool */
 #endif
+	if (!pme2_have_control()) {
+		pr_err("st: Not the ctrl-plane\n");
+		return 0;
+	}
+
 	while (big_loop--)
 		pme2_test_scan();
-#if CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
+#ifdef CONFIG_FSL_PME2_TEST_SCAN_WITH_BPID
 	pme_attr_set(pme_attr_bsc(pme_bpid), 0);
 	empty_buffer();
 	bman_free_pool(pool);
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 840f178..328686d 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -563,6 +563,9 @@ int pme_ctx_pmtcc(struct pme_ctx *ctx, u32 flags, struct qm_fd *fd,
 int pme_ctx_exclusive_inc(struct pme_ctx *ctx, u32 flags);
 void pme_ctx_exclusive_dec(struct pme_ctx *ctx);
 
+/* Does pme have access to ccsr */
+int pme2_have_control(void);
+
 /**************************/
 /* control-plane only API */
 /**************************/
@@ -642,7 +645,7 @@ enum pme_attr {
 #define pme_attr_bsc(n) (pme_attr_bsc_first + (n))
 /* Get/set driver attributes */
 int pme_attr_set(enum pme_attr attr, u32 val);
-u32 pme_attr_get(enum pme_attr attr);
+int pme_attr_get(enum pme_attr attr, u32 *val);
 #endif /* defined(CONFIG_FSL_PME2_CTRL) */
 
 #endif /* __KERNEL__ */
-- 
1.6.5.2

