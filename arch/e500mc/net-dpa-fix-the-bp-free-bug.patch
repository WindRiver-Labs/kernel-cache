From fea3fe4d0fac919a6bcdec36481c4950eb49d437 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Fri, 23 Sep 2011 13:01:03 +0800
Subject: [PATCH] net/dpa: fix the bp free bug

We need to free all the skb buffers in the BMAN buffer pool
before the dpa is removed. At present we free 8 skbs each time.
But the bman_acquire will return error when the buffer number
in the pool is less than 8. So we also need to drain the remainder
one by one.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/dpa/dpaa_eth.c |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/drivers/net/dpa/dpaa_eth.c b/drivers/net/dpa/dpaa_eth.c
index c561d53..0fdec09 100644
--- a/drivers/net/dpa/dpaa_eth.c
+++ b/drivers/net/dpa/dpaa_eth.c
@@ -385,13 +385,13 @@ _dpa_bp_free(struct dpa_bp *dpa_bp)
 		return;
 
 	if (bp->kernel_pool) {
-		int num;
+		int num = 8;
 
 		do {
 			struct bm_buffer bmb[8];
-			int i;
+			int i, free = num;
 
-			num = bman_acquire(bp->pool, bmb, 8, 0);
+			num = bman_acquire(bp->pool, bmb, free, 0);
 
 			for (i = 0; i < num; i++) {
 				dma_addr_t addr = bm_buf_addr(&bmb[i]);
@@ -403,7 +403,12 @@ _dpa_bp_free(struct dpa_bp *dpa_bp)
 
 				dev_kfree_skb_any(skb);
 			}
-		} while (num == 8);
+
+			/* Acquire is all-or-nothing, so we drain in 8s, then in
+			 * 1s for the remainder. */
+			if (num < 0 && free == 8)
+				num = 1;
+		} while (num > 0);
 	}
 
 	dpa_bp_array[bp->bpid] = 0;
-- 
1.7.0.4

