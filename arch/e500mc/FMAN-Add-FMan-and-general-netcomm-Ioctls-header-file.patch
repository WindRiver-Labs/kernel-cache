From c4934869a0973b7ecccd0c0b5f4c963853a4a44c Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 2 Dec 2010 11:20:37 +0800
Subject: [PATCH 10/28] FMAN: Add FMan and general netcomm Ioctls header files

Patch taken from FSL vendor SDK 2.2.

FM Linux ioctls definitions and enums.
Common and general netcomm headers definitions.
Structures and definitions for Command Relay Ioctls.

Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 include/linux/fmd/Kbuild                           |    5 +
 include/linux/fmd/Peripherals/Kbuild               |    4 +
 include/linux/fmd/Peripherals/fm_ioctls.h          |  293 ++++
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      | 1447 ++++++++++++++++++++
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |  611 +++++++++
 include/linux/fmd/Peripherals/fm_test_ioctls.h     |  190 +++
 include/linux/fmd/integrations/P4080/Kbuild        |    1 +
 .../fmd/integrations/P4080/integration_ioctls.h    |   47 +
 include/linux/fmd/ioctls.h                         |   96 ++
 include/linux/fmd/net_ioctls.h                     |  365 +++++
 10 files changed, 3059 insertions(+), 0 deletions(-)
 create mode 100644 include/linux/fmd/Kbuild
 create mode 100644 include/linux/fmd/Peripherals/Kbuild
 create mode 100644 include/linux/fmd/Peripherals/fm_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_pcd_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_port_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_test_ioctls.h
 create mode 100644 include/linux/fmd/integrations/P4080/Kbuild
 create mode 100644 include/linux/fmd/integrations/P4080/integration_ioctls.h
 create mode 100644 include/linux/fmd/ioctls.h
 create mode 100644 include/linux/fmd/net_ioctls.h

diff --git a/include/linux/fmd/Kbuild b/include/linux/fmd/Kbuild
new file mode 100644
index 0000000..c63d7d2
--- /dev/null
+++ b/include/linux/fmd/Kbuild
@@ -0,0 +1,5 @@
+header-y += integrations/P4080/
+header-y += Peripherals/
+
+header-y += ioctls.h
+header-y += net_ioctls.h
diff --git a/include/linux/fmd/Peripherals/Kbuild b/include/linux/fmd/Peripherals/Kbuild
new file mode 100644
index 0000000..43883ef
--- /dev/null
+++ b/include/linux/fmd/Peripherals/Kbuild
@@ -0,0 +1,4 @@
+header-y += fm_ioctls.h
+header-y += fm_port_ioctls.h
+header-y += fm_pcd_ioctls.h
+header-y += fm_test_ioctls.h
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
new file mode 100644
index 0000000..162821b
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -0,0 +1,293 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
+
+#define FM_IOC_NUM(n)       n
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+50)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
+
+#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT               0x04000000  /**< Offline parsing only! Unsupported Format */
+#define IOC_FFM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define IOC_FFM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define IOC_FFM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                         Sequence error, PHY error control character detected. */
+#define IOC_FFM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define IOC_FFM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define IOC_FFM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define IOC_FFM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define IOC_FFM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define IOC_FFM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< */
+#define IOC_FFM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< */
+#define IOC_FFM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define IOC_FFM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define IOC_FFM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define IOC_FFM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define IOC_FFM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define IOC_FFM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
+#define IOC_FFM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_IOC_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
+    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} ioc_fm_exceptions;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define IOC_FM_NUM_OF_PORT_TYPES            e_IOC_FM_PORT_TYPE_DUMMY
+#define IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE    7
+/* @} */
+
+/**************************************************************************//**
+ @Description   Port id by type and relative id
+*//***************************************************************************/
+typedef uint8_t ioc_ports_param_t[IOC_FM_NUM_OF_PORT_TYPES][IOC_FM_MAX_NUM_OF_PORTS_PER_TYPE];
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_ports_param_t   A table of ports bandwidth in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_ports_param_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+
+#endif /* __FM_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 0000000..b413440
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,1447 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                            /**< Maximum number of netenv distinction units */
+#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                                 For reason of HW implemetation, in most
+                                                                                 cases less than this will be allowed. The
+                                                                                 driver will return error in initialization
+                                                                                 time if resource is overused. */
+#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
+    e_IOC_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
+    e_IOC_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+} ioc_fm_pcd_exceptions;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                            override;           /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                        size;               /**< SW parser code size */
+    uint16_t                        base;               /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                         *p_code;            /**< SW parser code */
+    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_ENABLE
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DISABLE
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_IOC_PRS_LOAD_SW
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finidhing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_EXCEPTION
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_NODES     255
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_TREES     8
+#define IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP     16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS         4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS             256
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY             56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP 16
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,            /**< Keygen indicated */
+    e_IOC_FM_PCD_CC,            /**< Coarse classification indicated */
+    e_IOC_FM_PCD_PLCR,          /**< Policer indicated */
+    e_IOC_FM_PCD_PRS            /**< Parser indicated */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_IOC_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_IOC_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_done_action {
+    e_IOC_FM_PCD_ENQ_FRAME = 0,    /**< Enqueue frame */
+    e_IOC_FM_PCD_DROP_FRAME    /**< Drop frame */
+} ioc_fm_pcd_done_action;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   A structure for selecting action
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_action {
+    e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_IOC_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} ioc_fm_pcd_action;
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t        eth;        /**< eth      */
+    ioc_header_field_vlan_t       vlan;       /**< vlan     */
+    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
+    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
+    ioc_header_field_mpls_t       mpls;       /**< mpls     */
+    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
+    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
+    ioc_header_field_udp_t        udp;        /**< udp      */
+    ioc_header_field_tcp_t        tcp;        /**< tcp      */
+    ioc_header_field_sctp_t       sctp;       /**< sctp     */
+    ioc_header_field_dccp_t       dccp;       /**< dccp     */
+    ioc_header_field_gre_t        gre;        /**< gre      */
+    ioc_header_field_minencap_t   minencap;   /**< minencap */
+    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
+    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< An array of numOfDistinctionUnits of the
+                                                                     different units to be identified */
+    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                                  IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
+                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
+            } extract_by_hdr_type;
+        } extract_by_hdr;
+        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
+            uint16_t                        ic_indx_mask;   /**< Relevant only for CC where
+                                                                 action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in byte */
+        } extract_non_hdr;
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union{
+        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
+} ioc_fm_pcd_kg_extracted_or_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
+                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                             together with fqidOffsetShift and numOfProfiles
+                                                             parameters, to define a range of profiles from
+                                                             which the keygen result will determine the
+                                                             destination policer profile.  */
+    union{
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile_id;
+    } profile_select;
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    bool                            bypass_plcr_profile_generation;
+                                                        /**< TRUE to bypass keygen policer profile
+                                                             generation (profile selected is the one selected at
+                                                             port initialization). */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< enables changing an existing scheme */
+    union
+    {
+        uint8_t                         relative_scheme_id;
+                                                         /**< if modify=FALSE:Partition relative scheme id */
+        void                            *scheme_id;      /**< if modify=TRUE: a handle of the existing scheme */
+    } scm_id;
+    bool                                always_direct;   /**< This scheme is reached only directly, i.e.
+                                                              no need for match vector. Keygen will ignore
+                                                              it when matching   */
+    struct                                               /**< HL Relevant only if alwaysDirect = FALSE */
+    {
+        void                            *net_env_id;     /**< Network environment id  */
+        uint8_t                         num_of_distinction_units;
+                                                         /**< Number of netenv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                         /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                use_hash;        /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+                                                         /**< used only if useHash = TRUE */
+    bool                                bypass_fqid_generation;
+                                                         /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                              In such a case FQID after KG will be the default FQID
+                                                              defined for the relevant port, or the FQID defined by CC
+                                                              in cases where CC was the previous engine. */
+    uint32_t                            base_fqid;       /**< Base FQID */
+    uint8_t                             numOfUsedExtractedOrs;
+                                                         /**< Number of Fqid masks listed in extractedOrs array*/
+    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                         /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                              registers are shared between qidMasks
+                                                              functionality and some of the extraction
+                                                              actions; Normally only some will be used
+                                                              for qidMask. Driver will return error if
+                                                              resource is full at initialization time. */
+    ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
+    union{                                               /**< depends on nextEngine */
+        ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;  /**< A strcucture of parameters for updating
+                                                              the scheme counter */
+    void                                *id;             /**< Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                             /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        override_params;                         /**< TRUE if CC override previously decided parameters*/
+    bool        shared_profile;                          /**< Relevant only if overrideParams=TRUE:
+                                                         TRUE if this profile is shared between ports */
+    uint16_t    new_relative_profileId;                   /**< Relevant only if overrideParams=TRUE:
+                                                         (otherwise profile id
+                                                         is taken from keygen);
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or from SHARED window.*/
+    uint32_t    new_fqid;                                /**< Relevant only if overrideParams=TRUE:
+                                                         FQID for enquing the frame;
+                                                          In earlier chips  if policer next engine is KEYGEN,
+                                                          this parameter can be 0, because the KEYGEN always decides
+                                                          the enqueue FQID.*/
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
+    bool                    override_fqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
+                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                                 (otherwise FQID is taken from keygen),
+                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool       override_fqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
+                                          Note - this parameters unrelevant for earlier chips*/
+    uint32_t   new_fqid;                 /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                         (otherwise FQID is taken from keygen),
+                                          Note - this parameters unrelevant for earlier chips*/
+    void    *p_direct_scheme;         /**< Direct scheme handle to go to. */
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
+                                                                     to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+    } params;
+#ifdef FM_MANIP_SUPPORT
+    void                                        *p_manip;       /**< Handler to headerManip.
+                                                                     Relevant if next engine of the type result
+                                                                     (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+#endif /* FM_MANIP_SUPPORT */
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
+    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
+                                         in keySize. p_Key and p_Mask (if defined) has to be
+                                         of the same size defined in the keySize */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                    /**< parameters for the next for the defined Key in
+                                         the p_Key */
+
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
+    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
+                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                             key. In the another type of extraction keySize has to be as size of extraction. */
+    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                        /**< it's array with numOfKeys entries each entry in
+                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                        /**< parameters for the next step of
+                                                             unfound (or undefined) key */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
+                                                                 extraction defined in  extractParams */
+    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unit_ids list must be in order from lower to higher indexes.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics */
+    ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                    /**< Max size is 16 - if only one group used */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network environment as returned
+                                                             by FM_PCD_SetNetEnvCharacteristics */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_PCD_CC_GROUP];
+                                                        /**< Parameters for each group. */
+        void                            *id;            /**< output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or
+                RFC 4115 parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
+    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
+    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
+        void                       *p_profile;          /**< Policer profile handle -  used when next engine
+                                                             is PLCR, must be a SHARED profile */
+        void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            void                               *p_port;                     /**< Type of policer profile */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;
+        void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                                 any incoming packet with the deflt value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
+                                                                                 pre-color value of 2b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
+
+    bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
+    bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
+    bool                                        trap_profile_on_flow_C;     /**< Trap on flow C */
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC tree next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key and next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for remove CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
+    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                                 of the same size defined in the keySize */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_SCHEME
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'override' should be TRUE. If  the
+                routine is called for a valid scheme and 'override' is FALSE,
+                it will return error.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_SCHEME
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_BUILD_TREE
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_DELETE_TREE
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_SET_NODE
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_SET_NODE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), ioc_fm_pcd_cc_node_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_SET_PROFILE
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PCD_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
new file mode 100644
index 0000000..911c277
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,611 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+    e_IOC_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+} ioc_fm_port_pcd_support;
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} fm_port_counters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
+    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
+} ioc_fm_port_congestion_groups_t;
+
+/**************************************************************************//**
+ @Description   struct for defining Dual Tx rate limiting scale
+*//***************************************************************************/
+typedef enum fm_port_dual_rate_limiter_scale_down {
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   struct for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit {
+    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DISABLE
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ENABLE
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_RATE_LIMIT
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded to the nearest power of 2 multiplication
+                (i.e. up to twice the required rate).
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE is the scheme should be accessed directly */
+    void        *scheme_id;                 /**< Scheme id */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description    A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+/**************************************************************************//**
+ @Description   Scheme is'd structure
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;
+    void        *schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
+                                                         attachments exists for the same header,
+                                                         (in the main sw parser code) use this
+                                                         index to distinguish between them. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
+                                                                             port information into the parser result. This information
+                                                                             may be extracted by Keygen and be used for frames
+                                                                             distribution when a per-port distinction is required,
+                                                                             it may also be used as a port logical id for analyazing
+                                                                             incoming frames. */
+    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
+                                                                             start parsing */
+    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
+                                                                             'parsingOffset' */
+    bool                                    includeInPrsStatistics;     /**< TRUE to include this port in the parser statistics;
+                                                                              NOTE: this field is not valid when the FN is in "guest" mode. */
+    uint8_t                                 num_of_hdrs_with_additional_params;
+                                                        /**< Normally 0, some headers may get
+                                                             special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< A structure of additional parameters
+                                                             for each header that requires them */
+    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< relevant only if
+                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_PCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DELETE_PCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DETACH_PCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ATTACH_PCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
+
+ @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
+                                        start point for the parser.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_test_ioctls.h b/include/linux/fmd/Peripherals/fm_test_ioctls.h
new file mode 100644
index 0000000..0f82b82
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,190 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        24
+
+/**************************************************************************//**
+ @Collection    TEST Parameters
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+
+/**************************************************************************//**
+ @Description   FM Port buffer content description
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[32];
+    uint8_t         fm_time_stamp[8];
+} ioc_fmt_buff_context_t;
+
+
+/**************************************************************************//**
+ @Description   Buffer descriptor
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TODO
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test FM port type
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TODO
+
+ @Param[in]     ioc_fmt_port_param_t  TODO
+
+ @Cautions      Allowed only after the FM equivalent port is already initialized.
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DIAG_MODE
+
+ @Description   TODO
+
+ @Param[in]     ioc_diag_mode  TODO
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
+
+ @Description   Set IP header manipulations for this port.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DPAECHO_MODE
+
+ @Description   Set DPA in echo mode - all frame are sent back.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/include/linux/fmd/integrations/P4080/Kbuild b/include/linux/fmd/integrations/P4080/Kbuild
new file mode 100644
index 0000000..e548d67
--- /dev/null
+++ b/include/linux/fmd/integrations/P4080/Kbuild
@@ -0,0 +1 @@
+header-y += integration_ioctls.h
diff --git a/include/linux/fmd/integrations/P4080/integration_ioctls.h b/include/linux/fmd/integrations/P4080/integration_ioctls.h
new file mode 100644
index 0000000..13628fd
--- /dev/null
+++ b/include/linux/fmd/integrations/P4080/integration_ioctls.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
+
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/include/linux/fmd/ioctls.h b/include/linux/fmd/ioctls.h
new file mode 100644
index 0000000..fbcd416
--- /dev/null
+++ b/include/linux/fmd/ioctls.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NeCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
+                                                 the NCSW Linux module commands */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum ioc_diag_mode
+{
+    e_IOC_DIAG_MODE_NONE = 0,
+    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
+} ioc_diag_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
new file mode 100644
index 0000000..6b5eae3
--- /dev/null
+++ b/include/linux/fmd/net_ioctls.h
@@ -0,0 +1,365 @@
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 5)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MACSEC,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    MAX_e_IOC_NET_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
-- 
1.6.5.2

