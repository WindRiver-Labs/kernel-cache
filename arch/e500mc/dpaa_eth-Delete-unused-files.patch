From 39b1bf2a6a0ba6af5ac01804504040f7b58ba176 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Mon, 16 May 2011 18:56:53 -0500
Subject: [PATCH 126/233] dpaa_eth: Delete unused files

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0156-dpaa_eth-Delete-unused-files.patch

A bunch of files were unused, but hadn't been pruned from the tree

Reported-by: Stefan Szabo <SZBS001@freescale.com>
---
 drivers/net/dpa/dpa-common.h   |  100 ---
 drivers/net/dpa/fm-wrapper.c   |  151 ----
 drivers/net/dpa/fm-wrapper.h   |   43 --
 drivers/net/dpa/fm.c           |  360 ---------
 drivers/net/dpa/fm.h           |  117 ---
 drivers/net/dpa/fman-conf.h    | 1598 ----------------------------------------
 drivers/net/dpa/port-wrapper.c |  300 --------
 drivers/net/dpa/port.c         |  242 ------
 drivers/net/dpa/port.h         |   75 --
 9 files changed, 0 insertions(+), 2986 deletions(-)
 delete mode 100644 drivers/net/dpa/dpa-common.h
 delete mode 100644 drivers/net/dpa/fm-wrapper.c
 delete mode 100644 drivers/net/dpa/fm-wrapper.h
 delete mode 100644 drivers/net/dpa/fm.c
 delete mode 100644 drivers/net/dpa/fm.h
 delete mode 100644 drivers/net/dpa/fman-conf.h
 delete mode 100644 drivers/net/dpa/port-wrapper.c
 delete mode 100644 drivers/net/dpa/port.c
 delete mode 100644 drivers/net/dpa/port.h

diff --git a/drivers/net/dpa/dpa-common.h b/drivers/net/dpa/dpa-common.h
deleted file mode 100644
index a59ef2a..0000000
--- a/drivers/net/dpa/dpa-common.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __DPA_COMMON_H
-#define __DPA_COMMON_H
-
-#include <linux/kernel.h>	/* pr_*() */
-#include <linux/device.h>	/* dev_*() */
-#include <linux/smp.h>		/* hard_smp_processor_id() */
-#ifndef CONFIG_SMP
-#include <asm/smp.h>		/* hard_smp_processor_id() */
-#endif
-
-#define __file__ KBUILD_BASENAME".c"	/* The basename of the source file is being compiled */
-
-#define __hot
-
-#define cpu_pr_emerg(format, arg...)	\
-	pr_emerg("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_alert(format, arg...)	\
-	pr_alert("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_crit(format, arg...)	\
-	pr_crit("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_err(format, arg...)	\
-	pr_err("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_warning(format, arg...)	\
-	pr_warning("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_notice(format, arg...)	\
-	pr_notice("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_info(format, arg...)	\
-	pr_info("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-#define cpu_pr_debug(format, arg...)	\
-	pr_debug("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
-
-/* Keep these in sync with the dev_*() definitions from linux/device.h */
-#define cpu_dev_emerg(dev, format, arg...)	\
-	cpu_pr_emerg("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_alert(dev, format, arg...)	\
-	cpu_pr_alert("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_crit(dev, format, arg...)	\
-	cpu_pr_crit("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_err(dev, format, arg...)	\
-	cpu_pr_err("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_warn(dev, format, arg...)	\
-	cpu_pr_warning("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_notice(dev, format, arg...)	\
-	cpu_pr_notice("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_info(dev, format, arg...)	\
-	cpu_pr_info("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-#define cpu_dev_dbg(dev, format, arg...)	\
-	cpu_pr_debug("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
-
-#define cpu_netdev_emerg(net_dev, format, arg...)	\
-	cpu_dev_emerg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_alert(net_dev, format, arg...)	\
-	cpu_dev_alert((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_crit(net_dev, format, arg...)	\
-	cpu_dev_crit((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_err(net_dev, format, arg...)		\
-	cpu_dev_err((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_warn(net_dev, format, arg...)	\
-	cpu_dev_warn((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_notice(net_dev, format, arg...)	\
-	cpu_dev_notice((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_info(net_dev, format, arg...)	\
-	cpu_dev_info((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-#define cpu_netdev_dbg(net_dev, format, arg...)		\
-	cpu_dev_dbg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
-
-enum {RX, TX};
-
-#endif	/* __DPA_COMMON_H */
diff --git a/drivers/net/dpa/fm-wrapper.c b/drivers/net/dpa/fm-wrapper.c
deleted file mode 100644
index 94238db..0000000
--- a/drivers/net/dpa/fm-wrapper.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/io.h>		/* in_be32() */
-#include <linux/of_platform.h>
-#include <sysdev/fsl_soc.h>
-
-#include "dpaa_eth-common.h"
-#include "fm.h"
-#include "fm-wrapper.h"
-
-#include "lnxwrp_fm_ext.h"	/* fm_init() */
-
-#define FM_DESCRIPTION "FSL FMan wrapper based driver"
-
-MODULE_LICENSE("Dual BSD/GPL");
-
-MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
-
-MODULE_DESCRIPTION(FM_DESCRIPTION);
-
-const char	*fm_driver_description __initconst = FM_DESCRIPTION;
-const size_t	 fm_sizeof_priv __devinitconst = sizeof(struct fm_priv_s);
-
-static void fm_exception(t_Handle _fm_dev, e_FmExceptions exception)
-{
-	struct fm_device	*fm_dev;
-
-	fm_dev = (struct fm_device *)_fm_dev;
-
-	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
-
-	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static void fm_bus_error(t_Handle	_fm_dev,
-			 e_FmPortType	port_type,
-			 uint8_t	cell_index,
-			 uint64_t	addr,
-			 uint8_t	tnum,
-			 uint8_t	partition)
-{
-	struct fm_device	*fm_dev;
-
-	fm_dev = (struct fm_device *)_fm_dev;
-
-	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
-
-	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
-}
-
-static int __devinit __cold init(struct fm_device *fm_dev)
-{
-	struct fm_priv_s	*priv;
-	int			 i;
-
-	priv = fmdev_priv(fm_dev);
-
-	priv->fm.id			= fm_dev->cell_index;
-	priv->fm.prsActive		= fm_dev->parser_res != NULL;
-	priv->fm.kgActive		= fm_dev->keygen_res != NULL;
-	priv->fm.plcrActive		= fm_dev->policer_res != NULL;
-	priv->fm.pcdActive		= priv->fm.prsActive	||
-					  priv->fm.kgActive	||
-					  priv->fm.plcrActive;
-	priv->fm.fmBaseAddr		= (typeof(priv->fm.fmBaseAddr))fm_dev->vaddr;
-	priv->fm.fmMemSize		= fm_dev->res->end + 1 - fm_dev->res->start;
-	priv->fm.fmMuramBaseAddr	= (typeof(priv->fm.fmMuramBaseAddr))fm_dev->muram_vaddr;
-	priv->fm.fmMuramMemSize		= fm_dev->muram_res->end + 1 - fm_dev->muram_res->start;
-
-	priv->fm.fmDevSettings.param.fmId		= fm_dev->cell_index;
-	priv->fm.fmDevSettings.param.h_App		= &priv->fm;
-	priv->fm.fmDevSettings.param.fmClkFreq		= fsl_get_sys_freq();
-
-	/* Ugly hack! */
-	for (i = 0; i < ARRAY_SIZE(priv->fm.fmDevSettings.param.liodnPerPartition); i++)
-		priv->fm.fmDevSettings.param.liodnPerPartition[i] =
-			in_be32(fm_dev->vaddr + 0xc2000 + 0x60	+ sizeof(uint32_t) * (i / 2)) >>
-			16 * (1 - (i & 1));
-
-	priv->fm.fmDevSettings.param.f_Exceptions	= fm_exception;
-	priv->fm.fmDevSettings.param.f_BusError		= fm_bus_error;
-
-	priv->fm.fmDevSettings.advConfig	= priv->fm_config;
-
-	priv->fm.fmPcdDevSettings.advConfig	= priv->pcd_config;
-
-	priv->fm.active	= true;
-
-	fm_init(&priv->fm);
-
-	return 0;
-}
-
-static irqreturn_t isr(int irq, void *_fm_dev)
-{
-	irqreturn_t		 _errno;
-	struct fm_device	*fm_dev;
-	struct fm_priv_s	*priv;
-
-	fm_dev = _fm_dev;
-
-	priv = fmdev_priv(fm_dev);
-
-	if (likely(priv->fm.h_Dev != NULL)) {
-		FM_Isr(priv->fm.h_Dev);
-		_errno = IRQ_HANDLED;
-	} else
-		_errno = IRQ_NONE;
-
-	return _errno;
-}
-
-static void __devinit __cold setup(struct fm_device *fm_dev)
-{
-	fm_dev->init	= init;
-	fm_dev->isr	= isr;
-	fm_dev->uninit	= NULL;
-}
-
-void (*const fm_setup)(struct fm_device *fm_dev) __devinitconst = setup;
diff --git a/drivers/net/dpa/fm-wrapper.h b/drivers/net/dpa/fm-wrapper.h
deleted file mode 100644
index ae663a3..0000000
--- a/drivers/net/dpa/fm-wrapper.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __FM_WRAPPER_H
-#define __FM_WRAPPER_H
-
-#include "lnxwrp_fm.h"	/* t_LnxWrpFmDev */
-
-struct fm_priv_s {
-	t_LnxWrpFmDev			fm;
-	t_SysObjectAdvConfigEntry	fm_config[FM_MAX_NUM_OF_ADV_SETTINGS],
-					pcd_config[FM_MAX_NUM_OF_ADV_SETTINGS];
-};
-
-#endif	/* __FM_WRAPPER_H */
diff --git a/drivers/net/dpa/fm.c b/drivers/net/dpa/fm.c
deleted file mode 100644
index e97d8c3..0000000
--- a/drivers/net/dpa/fm.c
+++ /dev/null
@@ -1,360 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/of_platform.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/io.h>		/* devm_ioremap() */
-
-#include "dpaa_eth-common.h"
-#include "fm.h"
-
-static struct fm_device * __devinit __cold
-alloc_fmdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct fm_device *fm_dev))
-{
-	struct fm_device	*fm_dev;
-
-	fm_dev = devm_kzalloc(dev, sizeof(*fm_dev) + sizeof_priv, GFP_KERNEL);
-	if (likely(fm_dev == NULL))
-		fm_dev = ERR_PTR(-ENOMEM);
-	else {
-		fm_dev->dev = dev;
-		dev_set_drvdata(dev, fm_dev);
-		setup(fm_dev);
-	}
-
-	return fm_dev;
-}
-
-static int __devexit __cold free_fmdev(struct fm_device *fm_dev)
-{
-	dev_set_drvdata(fm_dev->dev, NULL);
-
-	return likely(fm_dev->uninit) ? fm_dev->uninit(fm_dev) : 0;
-}
-
-struct resource * __cold fm_mem_region(struct of_device *of_dev)
-{
-	return ((struct fm_device *)dev_get_drvdata(&of_dev->dev))->res;
-}
-EXPORT_SYMBOL(fm_mem_region);
-
-const uint16_t irqf[] __devinitconst = {0};
-
-static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_device_id *match)
-{
-	int			 _errno, interrupt, i, lenp;
-	struct device		*dev;
-	struct device_node	*fm_node, *dev_node;
-	struct fm_device	*fm_dev;
-	struct resource		 res;
-	const uint32_t		*uint32_prop;
-
-	dev = &of_dev->dev;
-
-	fm_dev = alloc_fmdev(dev, fm_sizeof_priv, fm_setup);
-	if (IS_ERR(fm_dev)) {
-		_errno = PTR_ERR(fm_dev);
-		dpaa_eth_err(dev, "alloc_fmdev() = %d\n", _errno);
-		goto _return;
-	}
-
-	fm_node = of_dev->node;
-
-	/* Get the FM interrupts */
-	for (i = 0; i < ARRAY_SIZE(irqf); i++) {
-		interrupt = of_irq_to_resource(fm_node, i, NULL);
-		if (unlikely(interrupt == NO_IRQ)) {
-			dpaa_eth_err(dev,
-				"of_irq_to_resource(%d) = NO_IRQ\n", i);
-			_errno = -EINVAL;
-			goto _return_dev_set_drvdata;
-		}
-
-		if (unlikely(!can_request_irq(interrupt, irqf[i])))
-			dpaa_eth_warn(dev, "can_request_irq(%d) failed\n", i);
-		_errno = devm_request_irq(dev, interrupt, fm_dev->isr, irqf[i], "fman", fm_dev);
-		if (unlikely(_errno < 0)) {
-			dpaa_eth_err(dev, "devm_request_irq(%d) = %d\n",
-					i, _errno);
-			goto _return_dev_set_drvdata;
-		}
-	}
-
-	/* Get the port/device address */
-	_errno = of_address_to_resource(fm_node, 0, &res);
-	if (unlikely(_errno < 0)) {
-		dpaa_eth_err(dev, "of_address_to_resource() = %d\n", _errno);
-		goto _return_dev_set_drvdata;
-	}
-
-	fm_dev->res = devm_request_mem_region(dev, res.start, res.end + 1 - res.start, "fman");
-	if (unlikely(fm_dev->res == NULL)) {
-		dpaa_eth_err(dev, "devm_request_mem_region(fman) failed\n");
-		_errno = -EBUSY;
-		goto _return_dev_set_drvdata;
-	}
-
-	fm_dev->vaddr = devm_ioremap(dev,
-				     fm_dev->res->start, fm_dev->res->end + 1 - fm_dev->res->start);
-	if (unlikely(fm_dev->vaddr == 0)) {
-		dpaa_eth_err(dev, "devm_ioremap() failed\n");
-		_errno = -EIO;
-		goto _return_dev_set_drvdata;
-	}
-
-	uint32_prop = of_get_property(fm_node, "cell-index", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
-				fm_node->full_name);
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-	BUG_ON(lenp != sizeof(uint32_t));
-	fm_dev->cell_index = *uint32_prop;
-
-	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-muram");
-	if (unlikely(dev_node == NULL)) {
-		dpaa_eth_err(dev,
-			"of_find_compatible_node(fsl,fman-muram) failed\n");
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-
-	_errno = of_address_to_resource(dev_node, 0, &res);
-	if (unlikely(_errno < 0)) {
-		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
-				dev_node->full_name, _errno);
-		goto _return_of_node_put;
-	}
-	of_node_put(dev_node);
-
-	fm_dev->muram_res = __devm_request_region(dev, fm_dev->res,
-						  res.start, res.end + 1 - res.start, "muram");
-	if (unlikely(fm_dev->res == NULL)) {
-		dpaa_eth_err(dev, "__devm_request_region(muram) failed\n");
-		_errno = -EBUSY;
-		goto _return_dev_set_drvdata;
-	}
-
-	fm_dev->muram_vaddr = devm_ioremap(dev, fm_dev->muram_res->start,
-					   fm_dev->muram_res->end + 1 - fm_dev->muram_res->start);
-	if (unlikely(fm_dev->muram_vaddr == 0)) {
-		dpaa_eth_err(dev, "devm_ioremap() failed\n");
-		_errno = -EIO;
-		goto _return_dev_set_drvdata;
-	}
-
-	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-parser");
-	if (unlikely(dev_node == NULL))
-		dpaa_eth_err(dev,
-			"of_find_compatible_node(fsl,fman-parser) failed. "
-			"Won't be using the parser\n");
-	else {
-		_errno = of_address_to_resource(dev_node, 0, &res);
-		if (unlikely(_errno < 0)) {
-			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
-					dev_node->full_name, _errno);
-			goto _return_of_node_put;
-		}
-		of_node_put(dev_node);
-
-		fm_dev->parser_res = __devm_request_region(dev, fm_dev->res,
-							   res.start, res.end + 1 - res.start,
-							   "parser");
-		if (unlikely(fm_dev->res == NULL)) {
-			dpaa_eth_err(dev,
-				"__devm_request_region(parser) failed\n");
-			_errno = -EBUSY;
-			goto _return_dev_set_drvdata;
-		}
-
-		fm_dev->parser_vaddr = devm_ioremap(
-			dev,
-			fm_dev->parser_res->start,
-			fm_dev->parser_res->end + 1 - fm_dev->parser_res->start);
-		if (unlikely(fm_dev->parser_vaddr == 0)) {
-			dpaa_eth_err(dev, "devm_ioremap() failed\n");
-			_errno = -EIO;
-			goto _return_dev_set_drvdata;
-		}
-	}
-
-	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL,
-						"fsl,fman-keygen");
-	if (unlikely(dev_node == NULL)) {
-		dpaa_eth_err(dev,
-			"of_find_compatible_node(fsl,fman-keygen) failed. "
-			"Won't be using the KeyGen\n");
-	} else {
-		_errno = of_address_to_resource(dev_node, 0, &res);
-		if (unlikely(_errno < 0)) {
-			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
-					dev_node->full_name, _errno);
-			goto _return_of_node_put;
-		}
-		of_node_put(dev_node);
-
-		fm_dev->keygen_res = __devm_request_region(dev, fm_dev->res,
-							   res.start, res.end + 1 - res.start,
-							   "keygen");
-		if (unlikely(fm_dev->res == NULL)) {
-			dpaa_eth_err(dev,
-				"__devm_request_region(keygen) failed\n");
-			_errno = -EBUSY;
-			goto _return_dev_set_drvdata;
-		}
-
-		fm_dev->keygen_vaddr = devm_ioremap(
-			dev,
-			fm_dev->keygen_res->start,
-			fm_dev->keygen_res->end + 1 - fm_dev->keygen_res->start);
-		if (unlikely(fm_dev->keygen_vaddr == 0)) {
-			dpaa_eth_err(dev, "devm_ioremap() failed\n");
-			_errno = -EIO;
-			goto _return_dev_set_drvdata;
-		}
-	}
-
-	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-policer");
-	if (unlikely(dev_node == NULL))
-		dpaa_eth_err(dev,
-			"of_find_compatible_node(fsl,fman-policer) failed. "
-			"Won't be using the policer\n");
-	else {
-		_errno = of_address_to_resource(dev_node, 0, &res);
-		if (unlikely(_errno < 0)) {
-			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
-					dev_node->full_name, _errno);
-			goto _return_of_node_put;
-		}
-		of_node_put(dev_node);
-
-		fm_dev->policer_res = __devm_request_region(dev, fm_dev->res,
-							    res.start, res.end + 1 - res.start,
-							    "policer");
-		if (unlikely(fm_dev->res == NULL)) {
-			dpaa_eth_err(dev,
-				"__devm_request_region(policer) failed\n");
-			_errno = -EBUSY;
-			goto _return_dev_set_drvdata;
-		}
-
-		fm_dev->policer_vaddr = devm_ioremap(
-			dev,
-			fm_dev->policer_res->start,
-			fm_dev->policer_res->end + 1 - fm_dev->policer_res->start);
-		if (unlikely(fm_dev->policer_vaddr == 0)) {
-			dpaa_eth_err(dev, "devm_ioremap() failed\n");
-			_errno = -EIO;
-			goto _return_dev_set_drvdata;
-		}
-	}
-
-	_errno = fm_dev->init(fm_dev);
-	if (unlikely(_errno < 0)) {
-		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
-		goto _return_dev_set_drvdata;
-	}
-
-	goto _return;
-
-_return_of_node_put:
-	of_node_put(dev_node);
-_return_dev_set_drvdata:
-	dev_set_drvdata(dev, NULL);
-_return:
-	return _errno;
-}
-
-static int __devexit __cold fm_remove(struct of_device *of_dev)
-{
-	int		 _errno;
-	struct device	*dev;
-
-	dev = &of_dev->dev;
-
-	_errno = free_fmdev((struct fm_device *)dev_get_drvdata(dev));
-
-	return _errno;
-}
-
-static const struct of_device_id fm_match[] __devinitconst = {
-	{
-		.compatible	= "fsl,fman"
-	},
-	{}
-};
-MODULE_DEVICE_TABLE(of, fm_match);
-
-static struct of_platform_driver fm_driver = {
-	.name		= KBUILD_MODNAME,
-	.match_table	= fm_match,
-	.owner		= THIS_MODULE,
-	.probe		= fm_probe,
-	.remove		= __devexit_p(fm_remove)
-};
-
-static int __init __cold fm_load(void)
-{
-	int	 _errno;
-
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", fm_driver_description);
-
-	_errno = of_register_platform_driver(&fm_driver);
-	if (unlikely(_errno < 0)) {
-		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
-		       __file__, __LINE__, __func__, _errno);
-		goto _return;
-	}
-
-	goto _return;
-
-_return:
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-module_init(fm_load);
-
-static void __exit __cold fm_unload(void)
-{
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	of_unregister_platform_driver(&fm_driver);
-
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-}
-module_exit(fm_unload);
diff --git a/drivers/net/dpa/fm.h b/drivers/net/dpa/fm.h
deleted file mode 100644
index 0db26ef..0000000
--- a/drivers/net/dpa/fm.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __FM_H
-#define __FM_H
-
-#include <linux/ioport.h>	/* struct resource */
-#include <linux/of_device.h>	/* struct of_device */
-#include <linux/irqreturn.h>	/* irqreturn_t */
-
-#define FM_FD_STAT_DME	       0x01000000      /* DMA Error - QMI */
-#define FM_FD_STAT_FHE	       0x00080000      /* Physical Error - BMI */
-#define FM_FD_STAT_FSE	       0x00040000      /* Frame Size Error - BMI */
-#define FM_FD_STAT_DIS	       0x00020000      /* Discarded frame - BMI */
-#define FM_FD_STAT_EOF	       0x00008000      /* Extract Out of Frame - KEYGEN */
-#define FM_FD_STAT_NSS	       0x00004000      /* No Scheme Selected - KEYGEN */
-#define FM_FD_STAT_FCL	       0x00000c00      /* Frame Color - Policer */
-#define FM_FD_STAT_IPP	       0x00000200      /* Illegal Policer Profile - Policer */
-#define FM_FD_STAT_PTE	       0x00000080      /* Parser Timeout Exceeded - Parser */
-#define FM_FD_STAT_ISP	       0x00000040      /* Invalid Soft Parser Instruction - Parser */
-#define FM_FD_STAT_PHE	       0x00000020      /* Parsing Header Error - Parser */
-#define FM_FD_STAT_ERRORS      (FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |     \
-				FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |     \
-				FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |     \
-				FM_FD_STAT_PHE)
-
-#define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
-#define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
-#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
-#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
-#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
-#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
-#define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
-
-/* Parse results memory layout */
-struct fman_parse_results {
-	uint8_t		lpid;
-	uint8_t		shimr;
-	uint16_t	l2r;
-	uint16_t	l3r;
-	uint8_t		l4r;
-	uint8_t		cplan;
-	uint16_t	nxthdr;
-	uint16_t	cksum;
-	uint32_t	lcv;
-	uint8_t		shim_off[3];
-	uint8_t		eth_off;
-	uint8_t		llc_snap_off;
-	uint8_t		vlan_off;
-	uint8_t		etype_off;
-	uint8_t		pppoe_off;
-	uint8_t		mpls_off;
-	uint8_t		ip_off;
-	uint8_t		gre_off;
-	uint8_t		l4_off;
-	uint8_t		nxthdr_off;
-} __packed;
-
-struct fm_device {
-	struct device	*dev;
-	void		*priv;
-	uint8_t		 cell_index;
-	struct resource	*res;
-	void		*vaddr;
-
-	struct resource	*muram_res;
-	void		*muram_vaddr;
-	struct resource	*parser_res;
-	void		*parser_vaddr;
-	struct resource	*keygen_res;
-	void		*keygen_vaddr;
-	struct resource	*policer_res;
-	void		*policer_vaddr;
-
-	int (*init)(struct fm_device *fm_dev);
-	irqreturn_t (*isr)(int irq, void *_fm_dev);
-	int (*uninit)(struct fm_device *fm_dev);
-};
-
-static inline void * __attribute((nonnull)) fmdev_priv(const struct fm_device *fm_dev)
-{
-	return (void *)fm_dev + sizeof(*fm_dev);
-}
-
-extern const char	*fm_driver_description;
-extern const size_t	 fm_sizeof_priv;
-extern void (* const fm_setup)(struct fm_device *fm_dev);
-
-#endif	/* __FM_H */
diff --git a/drivers/net/dpa/fman-conf.h b/drivers/net/dpa/fman-conf.h
deleted file mode 100644
index e6768f8..0000000
--- a/drivers/net/dpa/fman-conf.h
+++ /dev/null
@@ -1,1598 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     - Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     - Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     - Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * \section	Introduction
- *
- * This document details the low-level API that is provided for configuration of the Frame Manager
- * (FMan) block in the Freescale DPA architecture (P4080). These API is used to set up
- * classification, parsing, QoS and other FMan features.
- *
- * Both the FMan LLD/API and this document are work in progress. The implementation is incremental
- * and centered around, on one side, the functionality implemented in the FMan model/simulator
- * and, on the other side, the functionality used in the applications using this driver/API.
- *
- * As far as BG compliance goes, this driver/API is supposedly based on version/revision .79.
- * However, where a discrepancy between the BGs and the model/simulator was identified the decision
- * was made to be follow the model/simulator for the sake of maximizing the working feature set.
- *
- * The API is designed to have a consistent look-and-feel with the B/QMan drivers/API. Beyond
- * that, the code tries to follow the Linux coding style and conventions.
- *
- * \section	Virtualization
- *
- * Certain components/modules of the FMan can be virtualized easier then others. The \ref BMI,
- * \ref QMI, \ref Parser, \ref MAC and \ref MDIO can be virtualized easier, in the sense of being
- * able to assign them to a hypervisor partition and be able to control them without the need to
- * access global resources that might affect the stability and functionality of other hypervisor
- * partitions. This virtualization is achieved by having registers mapped in a 4 KB page that can
- * be mapped in the MMU to a single partition.
- *
- * Other blocks in the FMan such as the KeyGen, policer, etc. can be used by multiple partitions
- * but their cofiguration needs to be programmed/done by a single partition (control-plane
- * partition) on behalf of the other partitions (data-plane partitions).
- *
- * For more information on virtualization and partitioning please refer to the Freescale hypervisor
- * documentation.
- */
-
-#ifndef __FMAN_CONF_H
-#define __FMAN_CONF_H
-
-/** \defgroup	Port	Port
- *  \defgroup	BMI	BMI - BMan interface
- *  \defgroup	QMI	QMI - QMan interface
- *  \defgroup	Parser	Parser
- *  \defgroup	KeyGen	KeyGen - Key generator
- *  \defgroup	DMA	DMA
- *  \defgroup	FPM	FPM - FMan processing manager
- *  \defgroup	Policer	Policer
- *  \defgroup	MAC	MAC
- *  \defgroup	MDIO	MDIO
- */
-
-/* Register level abstraction */
-
-/** \addtogroup	Port
- *  \details	A port contains the registers for the \ref BMI, \ref QMI and \ref Parser
- *  @{
- */
-
-/** \addtogroup	BMI
- *  @{
- */
-
-/** \internal
- *  \brief	BMI commmon port register layout
- *
- *  This is a FMan LLD private data structure and should _not_ be used anywhere including in the
- *  FMan LLD.
- *
- *  It is the method of choice for describing the FMan registers offsets and it exists only for that
- *  purpose.
- *
- */
-struct fm_bmi_common_mmap_s {
-	uint32_t	FMBM_INIT;	/* Initialization */
-	uint32_t	FMBM_CFG[3];	/* Configuration */
-	uint8_t		reserved0[0x10];
-	uint32_t	FMBM_IVER;	/* Interrupt EVent */
-	uint32_t	FMBM_IER;	/* Interrupt Enable */
-	uint32_t	FMBM_IFR;	/* Interrupt Force */
-	uint8_t		reserved1[0x14];
-	uint32_t	FMBM_ARB[8];	/* Arbitration */
-	uint32_t	FMBM_BCMA;	/* Buffers Command Mutual Exclusive Access */
-	uint32_t	FMBM_EBC;	/* External Buffers Command */
-	uint32_t	FMBM_EBCR;	/* External Buffers Command Result */
-	uint32_t	FMBM_EPRH;	/* External PointeR High */
-	uint32_t	FMBM_EPRL;	/* External PointeR Low */
-	uint8_t		reserved2[0x18];
-	uint32_t	FMBM_DTC[3];	/* Debug Trap Counter */
-	uint8_t		reserved3[0x4];
-	uint32_t	FMBM_DCV[12];	/* Debug Compare Value */
-	uint32_t	FMBM_DCM[12];	/* Debug Compare Mask */
-	uint32_t	FMBM_GDE;	/* Global Debug Enable */
-	uint32_t	FMBM_PP[63];	/* Port Parameters */
-	uint8_t		reserved4[0x4];
-	uint32_t	FMBM_IPS;	/* Internal Probe Select */
-	uint32_t	FMBM_PFS[63];	/* Port FIFO Size */
-	uint32_t	FMBM_IPD;	/* Internal Probe Data */
-	uint32_t	FMBM_PPID[63];	/* Port Partition ID */
-} __aligned(0x400) __packed;
-
-#define FM_BMI_COMMON_INIT_STR	0x80000000		/* Start */
-
-#define FM_BMI_COMMON_CFG0_FBPS(n)	((n) << 16)	/* Free Buffer Pool Size */
-#define FM_BMI_COMMON_CFG0_FMBM_OF(n)	(n)		/* Free Buffer Pool OFfset */
-#define FM_BMI_COMMON_CFG1_TNTSKS(n)	((n) << 16)	/* Total Number of TaSKS */
-#define FM_BMI_COMMON_CFG1_TDMA(n)	(n)		/* Total DMA */
-
-/** \internal
- *  \brief		BMI offline parsing/host command port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_bmi_oh_mmap_s {
-	uint8_t		reserved0[0x400];
-} __aligned(0x400) __packed;
-
-/** \internal
- *  \brief		BMI Rx port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_bmi_rx_mmap_s {
-	uint32_t	FMBM_RCFG;	/* Configuration */
-	uint32_t	FMBM_RST;	/* Status */
-	uint32_t	FMBM_RDA;	/* DMA Attributes */
-	uint32_t	FMBM_RFP;	/* FIFO Parameters */
-	uint32_t	FMBM_RFED;	/* Frame End Data */
-	uint32_t	FMBM_RICP;	/* Internal Context Parameters */
-	uint32_t	FMBM_RIM;	/* Internal Margins */
-	uint32_t	FMBM_REBM;	/* External Buffer Margins */
-	uint32_t	FMBM_RFNE;	/* Frame Next Engine */
-	uint32_t	FMBM_RFCA;	/* Frame Command Attributes */
-	uint32_t	FMBM_RFPNE;	/* Frame Parser Next Engine */
-	uint32_t	FMBM_RPSO;	/* Parse Start Offset */
-	uint32_t	FMBM_RPP;	/* Policer Profile */
-	uint32_t	FMBM_RCCB;	/* Coarse Classification Base */
-	uint8_t		reserved0[0x8];
-	uint32_t	FMBM_RPRAI[8];	/* Parse Results Array Initialization */
-	uint32_t	FMBM_RFQID;	/* Frame Queue ID */
-	uint32_t	FMBM_REFQID;	/* Error Frame Queue ID */
-	uint32_t	FMBM_RFSDM;	/* Frame Status Discard Mask */
-	uint32_t	FMBM_RFSEM;	/* Frame Status Error Mask */
-	uint32_t	FMBM_RFENE;	/* Frame Enqueue Next Engine */
-	uint8_t		reserved1[0x8c];
-	uint32_t	FMBM_EBMPI[8];	/* Buffer Manager Pool Information */
-	uint32_t	FMBM_ACNT[8];	/* Allocate CouNTer */
-	uint8_t		reserved2[0x20];
-	uint32_t	FMBM_CGM[8];	/* Congestion Group Map */
-	uint32_t	FMBM_MPD;	/* Pool Depletion */
-	uint8_t		reserved3[0x7c];
-	uint32_t	FMBM_RSTC;	/* STatistics Counter */
-	uint32_t	FMBM_RFRC;	/* FRame Counter */
-	uint32_t	FMBM_RBFC;	/* Bad Frames Counter */
-	uint32_t	FMBM_RLFC;	/* Large Frames Counter */
-	uint32_t	FMBM_RFFC;	/* Filter Frames Counter */
-	uint32_t	FMBM_RFDC;	/* Frames Discard Counter */
-	uint32_t	FMBM_RFLDEC;	/* Frames List DMA Error Counter */
-	uint32_t	FMBM_RODC;	/* Out of buffers Discard Counter */
-	uint32_t	FMBM_RBDC;	/* Buffers Deallocate Counter */
-	uint8_t		reserved4[0x5c];
-	uint32_t	FMBM_RPC;	/* Performance Counters */
-	uint32_t	FMBM_RPCP;	/* Performance Count Parameters */
-	uint32_t	FMBM_RCCN;	/* Cycle CouNter */
-	uint32_t	FMBM_RTUC;	/* Task Utilization Counter */
-	uint32_t	FMBM_RRQUC;	/* Receive Queue Utilization Counter */
-	uint32_t	FMBM_RDUC;	/* DMA Utilization Counter */
-	uint32_t	FMBM_RFUC;	/* FIFO Utilization Counter */
-	uint32_t	FMBM_RPAC;	/* Pause Activation Counter */
-	uint8_t		reserved5[0x60];
-	uint32_t	FMBM_RDCFG[3];	/* Debug ConFiGuration */
-	uint8_t		reserved6[0x74];
-	uint32_t	FMBM_RIBA;	/* Internal Buffer Allocation */
-	uint32_t	FMBM_RIBD;	/* Internal Buffer Deallocation */
-	uint32_t	FMBM_RIBC;	/* Internal Buffer Chain */
-	uint32_t	FMBM_RIBLF;	/* Internal Buffer Link Follow */
-	uint8_t		reserved7[0x70];
-} __aligned(0x400) __packed;
-
-#define FM_BMI_RX_RCFG_EN		0x80000000	/* ENable */
-#define FM_BMI_RX_RCFG_FDOVR		0x02000000	/* Frame Discard OVerRide */
-#define FM_BMI_RX_RCFG_IM		0x01000000	/* Independent Mode */
-
-#define FM_BMI_RX_RFED_CSI(n)		((n) << 24)	/* CheckSum Ignore */
-#define FM_BMI_RX_RFED_CFED(n)		((n) << 16)	/* Chop Frame's End Data */
-
-#define FM_BMI_RX_RICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
-#define FM_BMI_RX_RICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
-#define FM_BMI_RX_RICP_ICSZ(n)		(n)		/* Internat Context SiZe */
-
-#define FM_BMI_RX_RIM_FOF(n)		((n) << 24)	/* Frame OFfset */
-
-#define FM_BMI_RX_REBM_BSM(n)		((n) << 16)	/* Buffer Start Margin */
-#define FM_BMI_RX_REBM_BEM(n)		(n)		/* Buffer End Margin */
-
-#define FM_BMI_RX_RFNE_NIA(n)		(n)		/* Next Invoked Action */
-
-#define FM_BMI_RX_RFCA_OR		0x80000000	/* ORder definition */
-#define FM_BMI_RX_RFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
-#define FM_BMI_RX_RFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
-#define FM_BMI_RX_RFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
-#define FM_BMI_RX_RFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
-#define FM_BMI_RX_RFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
-#define FM_BMI_RX_RFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
-
-#define FM_BMI_RX_RFPNE_HPNIA(n)	(n)		/* Hardware Parser Next Invoked Action */
-
-#define FM_BMI_RX_RPSO_PSO(n)		(n)		/* Parsing Start Offset */
-
-#define FM_BMI_RX_RPP_PNUM(n)		(n)		/* Policer profile */
-
-#define FM_BMI_RX_RCCB_CBASE(n)		(n)		/* Coarse classification BASE */
-
-#define FM_BMI_RX_RPRAI_PRA(n)		(n)		/* Parse Results Array */
-
-#define FM_BMI_RX_RFQID_DFQID(n)	(n)		/* Default Frame Queue ID */
-
-#define FM_BMI_RX_REFQID_EFQID(n)	(n)		/* Error Frame Queue ID */
-
-#define FM_BMI_RX_RFSDM_FSDM(n)		(n)		/* Frame Status Discard Mask */
-
-#define FM_BMI_RX_RFSEM_FSEM(n)		(n)		/* Frame Status Error Mask */
-
-#define FM_BMI_RX_RFENE_NIA(n)		(n)		/* Next Invoked Action */
-
-#define FM_BMI_RX_EBMPI_VAL		0x80000000	/* Valid */
-#define FM_BMI_RX_EBMPI_ADCE		0x40000000	/* Allocate/Deallocate Coutners Enable */
-#define FM_BMI_RX_EBMPI_BPID(n)		((n) << 16)	/* Buffer Pool ID */
-#define FM_BMI_RX_EBMPI_PBS(n)		(n)		/* Pool Buffer Size */
-
-/** \internal
- *  \brief		BMI Tx port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_bmi_tx_mmap_s {
-	uint32_t	FMBM_TCFG;	/* Configuration */
-	uint32_t	FMBM_TST;	/* STatus */
-	uint32_t	FMBM_TDA;	/* DMA Attributes */
-	uint32_t	FMBM_TFP;	/* FIFO Parameters */
-	uint32_t	FMBM_TFED;	/* Frame End Data */
-	uint32_t	FMBM_TICP;	/* Internal Context Paramenters */
-	uint32_t	FMBM_TFNE;	/* Frame Next Engine */
-	uint32_t	FMBM_TFCA;	/* Framme Command Attributes */
-	uint32_t	FMBM_TCFQID;	/* Confirmation Queue ID */
-	uint32_t	FMBM_TEFQID;	/* Error Frame Queue ID */
-	uint32_t	FMBM_TFENE;	/* Frame Enqueue Next Engine */
-	uint32_t	FMBM_TRLMTS;	/* Rate LiMiTer Scale */
-	uint32_t	FMBM_TRLMT;	/* Rate LiMiTer */
-	uint8_t		reserved0[0x1cc];
-	uint32_t	FMBM_TSTC;	/* STatistics Counter */
-	uint32_t	FMBM_TFRC;	/* FRame Counter */
-	uint32_t	FMBM_TFDC;	/* Frames Discard Counter */
-	uint32_t	FMBM_TFLEDC;	/* Framees Length Error Discard Counter */
-	uint32_t	FMBM_TFUFDC;	/* Frames Unsupported Format Discard Counter */
-	uint32_t	FMBM_TBDC;	/* Buffer Deallocate Counter */
-	uint8_t		reserved1[0x68];
-	uint32_t	FMBM_TPC;	/* Performance Counters */
-	uint32_t	FMBM_TPCP;	/* Performance Count Parameters */
-	uint32_t	FMBM_TCCN;	/* Cycle Counter */
-	uint32_t	FMBM_TTUC;	/* Tasks Utilization Counter */
-	uint32_t	FMBM_TTCQUC;	/* Transmit Confirm Queue Utilization Counter */
-	uint32_t	FMBM_TDUC;	/* DMA Utilization Counter */
-	uint32_t	FMBM_TFUC;	/* FIFO Utilization Counter */
-	uint8_t		reserved2[0x64];
-	uint32_t	FMBM_TDCFG[3];	/* Debug ConFiGuration */
-	uint8_t		reserved3[0x74];
-	uint32_t	FMBM_TIBA;	/* Internal Buffer Allocation */
-	uint32_t	FMBM_TIBD;	/* Internal Buffer Deallocation */
-	uint32_t	FMBM_TIBC;	/* Internal Buffer Chain */
-	uint32_t	FMBM_TIBLF;	/* Internal Buffer Link Follow */
-	uint8_t		reserved4[0x70];
-} __aligned(0x400) __packed;
-
-#define FM_BMI_TX_TCFG_EN		0x80000000	/* ENable  */
-#define FM_BMI_TX_TCFG_IM		0x01000000	/* Independent Mode */
-
-#define FM_BMI_TX_TFP_MFL(n)		((n) << 16)	/* Minimum Fill Level */
-#define FM_BMI_TX_TFP_DPDE(n)		((n) << 12)	/* Dequeue Pipeline Depth */
-#define FM_BMI_TX_TFP_FLCL(n)		(n)		/* FIFO Low Comfort Level */
-
-#define FM_BMI_TX_TICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
-#define FM_BMI_TX_TICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
-#define FM_BMI_TX_TICP_ICSZ(n)		(n)		/* Internat Context SiZe */
-
-#define FM_BMI_TX_TFNE_NIA(n)		(n)		/* Next Invoked Action */
-
-#define FM_BMI_TX_TFCA_OR		0x80000000	/* ORder definition */
-#define FM_BMI_TX_TFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
-#define FM_BMI_TX_TFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
-#define FM_BMI_TX_TFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
-#define FM_BMI_TX_TFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
-#define FM_BMI_TX_TFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
-#define FM_BMI_TX_TFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
-
-#define FM_BMI_TX_TCFQID_CFQID(n)	(n)		/* Confirmation Frame Queue ID */
-
-#define FM_BMI_TX_TFENE_NIA(n)		(n)		/* Next Invoked Action */
-
-/** \internal
- *  \brief		The BMI part of a port
- *  \copydetails	fm_bmi_common_mmap_s
- */
-union fm_port_bmi_mmap_u {
-	struct fm_bmi_common_mmap_s	common;
-	struct fm_bmi_oh_mmap_s		oh;
-	struct fm_bmi_rx_mmap_s		rx;
-	struct fm_bmi_tx_mmap_s		tx;
-} __aligned(0x400) __packed;
-
-/** BMI common register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
- *			prefix
- *
- *  Use this macro to get the offset of a BMI common register. This offset is suitable for using
- *  with the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that initializes the internal (MURAM) free buffer pool by writing
- *  into the FMBM_INIT register:
- *
- *  \code
- *		...
- *	struct fman_port *common_port;
- *		...
- *	common_port = fm_port_create(0xfe480000);
- *		...
- *	fm_port_out(common_port, FM_BMI_COMMON(INIT), FM_BMI_COMMON_INIT_STR);
- *		...
- *	fm_port_destroy(common_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_BMI_COMMON(reg)	\
-	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_common_mmap_s, FMBM_##reg))
-
-/** BMI offline parsing/host command register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
- *			prefix
- *
- *  Use this macro to get the offset of a BMI offline parsing/host command register. This offset is
- *  suitable for using with the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables a O/H port for TX by writing into the FMBM_OCFG
- *  register:
- *
- *  \code
- *		...
- *	struct fman_port *oh_port;
- *		...
- *	oh_port = fm_port_create(0xfe481000);
- *		...
- *	fm_port_out(oh_port, FM_BMI_OH(OCFG), FM_BMI_OH_OCFG_EN);
- *		...
- *	fm_port_destroy(oh_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_BMI_OH(reg)		\
-	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_oh_mmap_s, FMBM_##reg))
-
-/** BMI RX register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
- *			prefix
- *
- *  Use this macro to get the offset of a BMI RX register. This offset is suitable for using with
- *  the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that reads the status of a RX port by reading from the FMBM_RST
- *  register:
- *
- *  \code
- *		...
- *	struct fman_port *rx_port;
- *		...
- *	rx_port = fm_port_create(0xfe488000);
- *		...
- *	while (fm_port_in(rx_port, FM_BMI_RX(RST)) & FM_BMI_RX_RST_BSY)
- *		cpu_relax();
- *	/ * Port not busy * /
- *		...
- *	fm_port_destroy(rx_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_BMI_RX(reg)		\
-	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_rx_mmap_s, FMBM_##reg))
-
-/** BMI TX register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
- *			prefix
- *
- *  Use this macro to get the offset of a BMI TX register. This offset is suitable for using with
- *  the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables TX by writing into the FMBM_TCFG register:
- *
- *  \code
- *		...
- *	struct fman_port *tx_port;
- *		...
- *	tx_port = fm_port_create(0xfe4a8000);
- *		...
- *	fm_port_out(tx_port, FM_BMI_TX(TCFG), FM_BMI_TX_RCFG_EN);
- *		...
- *	fm_port_destroy(tx_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_BMI_TX(reg)		\
-	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_tx_mmap_s, FMBM_##reg))
-
-/** @} */
-
-/** \addtogroup	QMI
- *  @{
- */
-
-/** \internal
- *  \brief		QMI common port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_qmi_common_mmap_s {
-	uint32_t	FMQM_GC;	/* Global Configuration */
-	uint8_t		reserved0[4];
-	uint32_t	FMQM_EIE;	/* Error Interrupt Event */
-	uint32_t	FMQM_EIEN;	/* Error Interrupt Enable */
-	uint32_t	FMQM_EIF;	/* Error Interrupt Force */
-	uint8_t		reserved1[0x3ec];
-} __aligned(0x400) __packed;
-
-#define FM_QMI_COMMON_GC_EN		0x80000000	/* ENable */
-#define FM_QMI_COMMON_GC_ACC		0x40000000	/* All Counters Clear */
-#define FM_QMI_COMMON_GC_STEN		0x10000000	/* global STatistics Enable */
-#define FM_QMI_COMMON_GC_SR		0x01000000	/* Soft Reset */
-
-#define FM_QMI_IRQ_DEE			0x80000000	/* Double-bit ECC Error */
-
-/** \internal
- *  \brief		QMI offline parsing/host command and Tx port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_qmi_oh_tx_mmap_s {
-	uint8_t		reserved0[0x30];
-	uint32_t	FMQM_PDC;	/* Dequeue Configuration */
-	uint8_t		reserved1[0x3cc];
-} __aligned(0x400) __packed;
-
-#define FM_QMI_OH_PDC_PRI		0x80000000	/* Priority */
-#define FM_QMI_OH_PDC_OPT(n)		((n) << 28)	/* dequeue OPTions */
-#define FM_QMI_OH_PDC_PF		0x02000000	/* PreFetch */
-#define FM_QMI_OH_PDC_FRM		0x01000000	/* FRaMe count */
-/* Sub-Portal */
-#define FM_QMI_OH_PDC_SP_MASK		0x00f00000
-#define FM_QMI_OH_PDC_SP(n)		((n) << 20 & FM_QMI_OH_PDC_SP_MASK)
-#define FM_QMI_OH_PDC_WQ(n)		((n) << 16)	/* Work Queue */
-#define FM_QMI_OH_PDC_BC(n)		(n)		/* Byte Count */
-
-#define FM_QMI_TX_PDC_PRI		FM_QMI_OH_PDC_PRI
-#define FM_QMI_TX_PDC_OPT		FM_QMI_OH_PDC_OPT
-#define FM_QMI_TX_PDC_PF		FM_QMI_OH_PDC_PF
-#define FM_QMI_TX_PDC_FRM		FM_QMI_OH_PDC_FRM
-#define FM_QMI_TX_PDC_SP		FM_QMI_OH_PDC_SP
-#define FM_QMI_TX_PDC_WQ		FM_QMI_OH_PDC_WQ
-#define FM_QMI_TX_PDC_BC		FM_QMI_OH_PDC_BC
-
-/** \internal
- *  \brief		QMI Rx port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_qmi_rx_mmap_s {
-	uint8_t		reserved0[0x400];
-} __aligned(0x400) __packed;
-
-/** \internal
- *  \brief		The QMI part of a port
- *  \copydetails	fm_bmi_common_mmap_s
- */
-union fm_port_qmi_mmap_u {
-	struct fm_qmi_common_mmap_s	common;
-	struct fm_qmi_oh_tx_mmap_s	oh;
-	struct fm_qmi_rx_mmap_s		rx;
-	struct fm_qmi_oh_tx_mmap_s	tx;
-} __aligned(0x400) __packed;
-
-/** QMI common register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
- *			prefix
- *
- *  Use this macro to get the offset of a QMI common register. This offset is suitable for using
- *  with the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables QMI enqueues and dequeues by writing into the FMQM_GC
- *  register:
- *
- *  \code
- *		...
- *	struct fman_port *common_port;
- *		...
- *	common_port = fm_port_create(0xfe480000);
- *		...
- *	fm_port_out(common_port, FM_QMI_COMMON(GC),
- *			FM_QMI_COMMON_GC_ENQ_EN | FM_QMI_COMMON_GC_DEQ_EN);
- *		...
- *	fm_port_destroy(common_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_QMI_COMMON(reg)	\
-	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_common_mmap_s, FMQM_##reg))
-
-/** QMI offline parsing/host command register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
- *			prefix
- *
- *  Use this macro to get the offset of a QMI offline parsing/host command register. This offset is
- *  suitable for using with the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables a O/H port by writing into the FMQM_PC register:
- *
- *  \code
- *		...
- *	struct fman_port *oh_port;
- *		...
- *	oh_port = fm_port_create(0xfe481000);
- *		...
- *	fm_port_out(oh_port, FM_QMI_OH(PC), FM_QMI_OH_PC_EN);
- *		...
- *	fm_port_destroy(oh_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_QMI_OH(reg)		\
-	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
-
-/** QMI RX register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
- *			prefix
- *
- *  Use this macro to get the offset of a QMI RX register. This offset is suitable for using with
- *  the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that reads the enqueue status of a RX port by reading from the
- *  FMQM_PS register:
- *
- *  \code
- *		...
- *	struct fman_port *rx_port;
- *		...
- *	rx_port = fm_port_create(0xfe488000);
- *		...
- *	while (fm_port_in(rx_port, FM_QMI_RX(PS)) & FM_QMI_RX_PS_PBSY_ET)
- *		cpu_relax();
- *	/ * Port not busy with enqueues * /
- *		...
- *	fm_port_destroy(rx_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_QMI_RX(reg)		\
-	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_rx_mmap_s, FMQM_##reg))
-
-/** QMI TX register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
- *			prefix
- *
- *  Use this macro to get the offset of a QMI TX register. This offset is suitable for using with
- *  the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables a TX port by writing into the FMQM_PC register:
- *
- *  \code
- *		...
- *	struct fman_port *tx_port;
- *		...
- *	tx_port = fm_port_create(0xfe4a8000);
- *		...
- *	fm_port_out(tx_port, FM_QMI_TX(PC), FM_QMI_TX_PC_EN);
- *		...
- *	fm_port_destroy(tx_port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_QMI_TX(reg)		\
-	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
-
-/** @} */
-
-/** \addtogroup	Parser
- *  @{
- */
-
-/** \internal
- *  \brief		Parser common/global register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_parser_common_mmap_s {
-	uint8_t		FMPR_PMDA[0x800];	/* Parse Memory Direct Access */
-	uint32_t	FMPR_SXPAW[0x10];	/* Soft eXamination Parameter Array */
-	uint32_t	FMPR_RPCLIM;		/* Parsing Cycle LImit */
-	uint32_t	FMPR_RPIMAC;		/* Internal Memory Access Control */
-	uint32_t	FMPR_PMEEC;		/* Parse Memory EEC Error Capture */
-	uint8_t		reserved0[0x14];
-	uint32_t	FMPR_PEVR;		/* Event */
-	uint32_t	FMPR_PEVER;		/* Event Enable */
-	uint8_t		reserved1[4];
-	uint32_t	FMPR_PERR;		/* Error */
-	uint32_t	FMPR_PERER;		/* Error Enable */
-	uint8_t		reserved2[0x78c];
-} __aligned(0x1000) __packed;
-
-#define FM_PARSER_COMMON_RPCLIM_RHPCLIM(n)	(n)		/* maximum Parse Cycle LIMit */
-
-#define FM_PARSER_COMMON_RPIMAC_PSTAT		0x00000100	/* Parser STATus */
-#define FM_PARSER_COMMON_RPIMAC_PEN		0x00000001	/* Parser ENable */
-
-#define FM_PARSER_COMMON_PMEEC_CAP		0x80000000	/* CAPtured error indication */
-#define FM_PARSER_COMMON_PMEEC_CET		0x40000000	/* Captured Error Type */
-#define FM_PARSER_COMMON_PMEEC_SERCNT(n)	((n) << 16)	/* Soft ERror CouNTer */
-#define FM_PARSER_COMMON_PMEEC_MEMADDR(n)	(n)		/* ECC error MEMory ADDRess */
-
-#define FM_PARSER_IRQ_SPI(n)			(1 << (16 + (n)))	/* Stopped Port is not Idle */
-#define FM_PARSER_IRQ_SCM			0x00004000	/* Single-bit ECC is at Max */
-
-#define FM_PARSER_EIRQ_IA(n)			(1 << (16 + (n)))	/* Illegal Access */
-#define FM_PARSER_EIRQ_IAG			FM_PARSER_EIRQ_IA(-1)	/* Illegal Access Global*/
-#define FM_PARSER_EIRQ_ECCE			0x00004000		/* ECC multiple-bit Error */
-
-/** \internal
- *  \brief		The parser part of a port
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_port_parser_mmap_s {
-	uint8_t		FMPR_PMDA[0x80];	/* Parse Memory Direct Access */
-	uint8_t		reserved0[0x378];
-	uint32_t	FMPR_PCAC;		/* Configuration Access Control */
-	uint32_t	FMPR_PCTPID;		/* Configured TPID */
-} __aligned(0x400) __packed;
-
-#define FM_PARSER_PCAC_PSTAT	0x00000100	/* Port STATus */
-#define FM_PARSER_PCAC_PSTOP	0x00000001	/* Port STOP */
-
-/** Parser common/global register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
- *			prefix
- *
- *  Use this macro to get the offset of a parser common/global register. This offset is suitable
- *  for using with the fm_in() and fm_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that disables the parser by writing into the FMPR_RPIMAC register:
- *
- *  \code
- *		...
- *	struct fman *fm;
- *		...
- *	fm = fm_create(0xfe400000);
- *		...
- *	fm_out(fm, FM_PARSER_COMMON(RPIMAC), 0);
- *		...
- *	fm_destroy(fm);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_PARSER_COMMON(reg)	\
-	(offsetof(struct fm_mmap_s, parser) + offsetof(struct fm_parser_common_mmap_s, FMPR_##reg))
-
-/** Parser register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
- *			prefix
- *
- *  Use this macro to get the offset of a parser register. This offset is suitable for using with
- *  the fm_port_in() and fm_port_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that stops a parser port by writing and reading the FMPR_PCAC
- *  register:
- *
- *  \code
- *		...
- *	struct fman_port *port;
- *		...
- *	port = fm_port_create(0xfe488000);
- *		...
- *	fm_port_out(port, FM_PARSER(PCAC), FM_PARSER_PCAC_PSTOP);
- *	while (fm_port_in(port, FM_PARSER(PCAC)) & FM_PARSER_PCAP_PSTAT)
- *		cpu_relax();
- *	/ * The port is stopped * /
- *		...
- *	fm_port_destroy(port);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_PARSER(reg)		\
-	(offsetof(struct fm_port_mmap_s, parser) + offsetof(struct fm_port_parser_mmap_s, FMPR_##reg))
-
-/** @} */
-
-/* Port */
-
-/** \internal
- *  \brief		Aggregated port register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_port_mmap_s {
-	union fm_port_bmi_mmap_u	bmi;
-	union fm_port_qmi_mmap_u	qmi;
-	struct fm_port_parser_mmap_s	parser;
-	uint8_t				reserved0[0x400];
-} __aligned(0x1000) __packed;
-
-/** @} */
-
-/* Policer */
-
-/** \addtogroup	Policer
- *  @{
- */
-
-/** \internal
- *  \brief		Policer register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_policer_mmap_s {
-	uint8_t		reserved0[0x8c];
-	uint32_t	FMPL_PAR;		/* Profile Action */
-	uint32_t	FMPL_PE_MODE;		/* Profile Entry Mode */
-	uint8_t		reserved1[0xf6c];
-} __aligned(0x1000) __packed;
-
-/** Policer register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPL_"
- *			prefix
- *
- *  Use this macro to get the offset of a policer register. This offset is suitable for using with
- *  the fm_in() and fm_out() functions.
- *
- *  \hideinitializer
- */
-#define FM_POLICER(reg)	\
-	(offsetof(struct fm_mmap_s, policer) + offsetof(struct fm_policer_mmap_s, FMPL_##reg))
-
-/** @} */
-
-/* KeyGen */
-
-/** \addtogroup KeyGen
- *  @{
- */
-
-/** \internal
- *  \brief		KeyGen scheme register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_keygen_scheme_entry_mmap_s {
-	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
-	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
-	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
-	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
-	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
-	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
-	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
-	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
-	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
-	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
-	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
-	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
-	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
-} __aligned(0x100) __packed;
-
-/** \internal
- *  \brief		KeyGen register layout
- *  \copydetails	fm_bmi_common_mmap_s
- *  \todo		Identified a suitable overlaying scheme for port partitions, classification
- *			plans and classification schemes
- */
-struct fm_keygen_mmap_s {
-	uint32_t	FMKG_GCR;	/* General Configuration */
-	uint32_t	FMKG_ER;	/* Event */
-	uint32_t	FMKG_EMR;	/* Event Mask */
-	uint32_t	FMKG_EER;	/* Error Event */
-	uint32_t	FMKG_EEMR;	/* Error Event Mask */
-	uint32_t	FMKG_SER;	/* Scheme Event */
-	uint32_t	FMKG_SEMR;	/* Scheme Event Mask */
-	uint32_t	FMKG_SEER;	/* Scheme Error Event */
-	uint32_t	FMKG_SEEMR;	/* Scheme Error Event Mask */
-	uint32_t	FMKG_GSR;	/* Global Status */
-	uint32_t	FMKG_TPC;	/* Total Packet Counter */
-	uint32_t	FMKG_SERC;	/* Soft Error Capture */
-	uint8_t		reserved0[0x10];
-	uint32_t	FMKG_FDOR;	/* Frame Data Offset */
-	uint32_t	FMKG_GDVR[2];	/* Global Default Value */
-	uint8_t		reserved1[0xb4];
-	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
-	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
-	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
-	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
-	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
-	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
-	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
-	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
-	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
-	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
-	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
-	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
-	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
-	uint8_t		reserved2[0xa8];
-	uint32_t	FMKG_AR;	/* Action */
-	uint8_t		reserved3[0xe00];
-} __aligned(0x1000) __packed;
-
-#define FM_KEYGEN_GCR_EN		0x80000000		/* ENable */
-#define FM_KEYGEN_GCR_DEFNIA(n)		(n)			/* DEFault Next Invoked Action */
-
-#define FM_KEYGEN_EIRQ_DECC		0x80000000		/* Double-bit ECC error */
-#define FM_KEYGEN_EIRQ_IEE		0x40000000		/* Initialization Entry Error */
-#define FM_KEYGEN_EIRQ_KSO		0x20000000		/* KeyGen Size Overflow */
-
-#define FM_KEYGEN_SIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme interrupt */
-
-#define FM_KEYGEN_SEIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme error interrupt */
-
-#define FM_KEYGEN_GSR_BSY		0x80000000		/* Busy */
-
-#define FM_KEYGEN_TPC_TPCNT(n)		(n)			/* Total Packet CouNTer */
-
-#define FM_KEYGEN_SERC_CAP		0x80000000		/* CAPtured error indication */
-#define FM_KEYGEN_SERC_CET		0x40000000		/* Captured Error Type */
-#define FM_KEYGEN_SERC_SERCNT(n)	((n) << 16)		/* Soft ERror CouNTer */
-#define FM_KEYGEN_SERC_ET		0x00008000		/* Entry Type */
-#define FM_KEYGEN_SERC_SOFS(n)		((n) << 8)		/* Scheme OFfSet capture */
-#define FM_KEYGEN_SERC_NUM(n)		(n)			/* Scheme/Classification plan NUMber capture */
-
-#define FM_KEYGEN_FDOR_OFFSET(n)	(n)			/* OFFSET to the end of the parsing point */
-
-#define FM_KEYGEN_GDVR_DV(n)		(n)			/* Default Value */
-
-#define FM_KEYGEN_AR_GO			0x80000000		/* Activate the atomic scheme entry access */
-#define FM_KEYGEN_AR_RW			0x40000000		/* Read/Write access type */
-#define FM_KEYGEN_AR_PORTID(n)		((n) << 24)		/* Port ID */
-/* SELect entry */
-#define FM_KEYGEN_AR_SEL_MASK		0x00c00000
-#define FM_KEYGEN_AR_SEL(n)		((n) << 22 & FM_KEYGEN_AR_SEL_MASK)
-/* Scheme/Classification NUMber */
-#define FM_KEYGEN_AR_NUM_MASK		0x001f0000
-#define FM_KEYGEN_AR_NUM(n)		((n) << 16 & FM_KEYGEN_AR_NUM_MASK)
-#define FM_KEYGEN_AR_WSEL(n)		(n)			/* Word SELect */
-
-#define FM_KEYGEN_SE_MODE_SI		0x80000000		/* Scheme Initialization bit */
-#define FM_KEYGEN_SE_MODE_IM		0x40000000		/* Index Mode */
-#define FM_KEYGEN_SE_MODE_PL		0x01000000		/* PoLicer type */
-#define FM_KEYGEN_SE_MODE_NIA(n)	(n)			/* scheme Next Instruction Address */
-#define FM_KEYGEN_EKFC_PORTID		0x80000000		/* PORT ID */
-#define FM_KEYGEN_EKFC_MACDST		0x40000000		/* MAC DeSTination address */
-#define FM_KEYGEN_EKFC_MACSRC		0x20000000		/* MAC SouRCe address */
-#define FM_KEYGEN_EKFC_TC1		0x10000000		/* TCI from the first VLAN header */
-#define FM_KEYGEN_EKFC_TC2		0x08000000		/* TCI from the second VLAN header */
-#define FM_KEYGEN_EKFC_ETYPE		0x04000000		/* Ethernet TYPE */
-#define FM_KEYGEN_EKFC_PPPSID		0x02000000		/* PPPoE Session ID */
-#define FM_KEYGEN_EKFC_PPPPID		0x01000000		/* PPPoE Protocol ID */
-#define FM_KEYGEN_EKFC_MPLS1		0x00800000		/* MPLS from first label */
-#define FM_KEYGEN_EKFC_MPLS2		0x00400000		/* MPLS from seconf label */
-#define FM_KEYGEN_EKFC_MPLS3		0x00200000		/* MPLS from third label */
-#define FM_KEYGEN_EKFC_IPSRC		0x00100000		/* IP SouRCe address */
-#define FM_KEYGEN_EKFC_IPDST		0x00080000		/* IP DeSTination Address */
-#define FM_KEYGEN_EKFC_PTYPE		0x00040000		/* IP Protocol TYPE */
-#define FM_KEYGEN_EKFC_IPTOS		0x00020000		/* IP Type Of Service */
-#define FM_KEYGEN_EKFC_TIPSRC		0x00008000		/* Tunneled IP SouRCe address */
-#define FM_KEYGEN_EKFC_TIPDST		0x00004000		/* Tunneled IP DeSTination address */
-#define FM_KEYGEN_EKFC_TIPTYPE		0x00002000		/* Tunneled IP Protocol TYPE */
-#define FM_KEYGEN_EKFC_TIPTOS		0x00001000		/* Tunneled IP Type Of Service */
-#define FM_KEYGEN_EKFC_IPSECSPI		0x00000400		/* IPSEC SPI */
-#define FM_KEYGEN_EKFC_IPSECNH		0x00000200		/* IPSEC Next Header */
-#define FM_KEYGEN_EKFC_L4PSRC		0x00000004		/* L4 Protocol SouRCe port */
-#define FM_KEYGEN_EKFC_L4PDST		0x00000002		/* L4 Protocol DeSTination port */
-#define FM_KEYGEN_EKFC_TFLG		0x00000001		/* TCP FLaGs */
-
-#define FM_KEYGEN_EKDV_MACDV(n)		((n) << 30)		/*  */
-#define FM_KEYGEN_EKDV_TCDV(n)		((n) << 28)		/*  */
-#define FM_KEYGEN_EKDV_ETYPEDV(n)	((n) << 26)		/*  */
-#define FM_KEYGEN_EKDV_PPPSIDDV(n)	((n) << 24)		/*  */
-#define FM_KEYGEN_EKDV_PPPPIDDV(n)	((n) << 22)		/*  */
-#define FM_KEYGEN_EKDV_MPLSDV(n)	((n) << 20)		/*  */
-#define FM_KEYGEN_EKDV_IPADV(n)		((n) << 18)		/*  */
-#define FM_KEYGEN_EKDV_PTYPEDV(n)	((n) << 16)		/*  */
-#define FM_KEYGEN_EKDV_IPTOSDV(n)	((n) << 14)		/*  */
-#define FM_KEYGEN_EKDV_IP6FLDV(n)	((n) << 12)		/*  */
-#define FM_KEYGEN_EKDV_IPSECSPIDV(n)	((n) << 10)		/*  */
-#define FM_KEYGEN_EKDV_L4PDV(n)		((n) << 8)		/*  */
-#define FM_KEYGEN_EKDV_TFLAGDV(n)	((n) << 6)		/*  */
-
-#define FM_KEYGEN_BMCH_MCS0(n)		((n) << 26)		/* Mask Command Select 0 */
-#define FM_KEYGEN_BMCH_MCS1(n)		((n) << 20)		/* Mask Command Select 1 */
-#define FM_KEYGEN_BMCH_MO0(n)		((n) << 16)		/* Mask Offset0 */
-#define FM_KEYGEN_BMCH_MCS2(n)		((n) << 10)		/* Mask Command Select 2 */
-#define FM_KEYGEN_BMCH_MCS3(n)		((n) << 4)		/* Mast Command Select 3 */
-#define FM_KEYGEN_BMCH_MO1(n)		(n)			/* Mask Offst 1 */
-
-#define FM_KEYGEN_BMCL_BM0(n)		((n) << 24)		/* Bit Mask 0 */
-#define FM_KEYGEN_BMCL_BM1(n)		((n) << 16)		/* Bit Mask 1 */
-#define FM_KEYGEN_BMCL_BM2(n)		((n) << 8)		/* Bit Mask 2 */
-#define FM_KEYGEN_BMCL_BM3(n)		(n)			/* Bit Mask 3 */
-
-#define FM_KEYGEN_FQB_MO2(n)		((n) << 28)		/* Mask Offset 2 */
-#define FM_KEYGEN_FQB_MO3(n)		((n) << 24)		/* Mask Offset 3*/
-#define FM_KEYGEN_FQB_FQBASE(n)		(n)			/* Frame Queue Base */
-
-/* Hash SHIFT right */
-#define FM_KEYGEN_HC_HSHIFT_MASK	0x3f000000
-#define FM_KEYGEN_HC_HSHIFT(n)		((n) << 24 & FM_KEYGEN_HC_HSHIFT)
-/* Hash MASK */
-#define FM_KEYGEN_HC_HMASK_MASK		0x00ffffff
-#define FM_KEYGEN_HC_HMASK(n)		((n) & FM_KEYGEN_HC_HMASK_MASK)
-
-#define FM_KEYGEN_PPC_PPS(n)		((n) << 12)		/* Policer Profile Shift */
-#define FM_KEYGEN_PPC_PPMASK(n)		((n) << 16)		/* Policer Profile MASK */
-#define FM_KEYGEN_PPC_PPBASE(n)		(n)			/* Policer Profile BASE */
-
-#define FM_KEYGEN_GEC_V			0x80000000		/* Valid */
-#define FM_KEYGEN_GEC_DV(n)		((n) << 29)		/* Default Value */
-#define FM_KEYGEN_GEC_SIZE(n)		((n) << 24)		/* SIZE */
-#define FM_KEYGEN_GEC_MASK(n)		((n) << 16)		/* MASK */
-#define FM_KEYGEN_GEC_TYPE		0x00008000		/* command TYPE */
-#define FM_KEYGEN_GEC_HT(n)		((n) << 8)		/* Header Type */
-#define FM_KEYGEN_GEC_EO(n)		(n)			/* Extract Offset */
-
-#define FM_KEYGEN_SPC_PC(n)		(n)			/* Packet Counter */
-
-#define FM_KEYGEN_DV_DV(n)		(n)			/* Default Value */
-
-#define FM_KEYGEN_DC_DE			0x80000000		/* Debug Enable */
-
-#define FM_KEYGEN_MV_MV(n)		(n)			/* Match Vector */
-
-/** KeyGen register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMKG_"
- *			prefix
- *
- *  Use this macro to get the offset of a KeyGen register. This offset is suitable for using with
- *  the fm_keygen_in() and fm_keygen_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that enables the KeyGen by writing into the FMKG_GCR register:
- *
- *  \code
- *		...
- *	struct fman_keygen *keygen;
- *		...
- *	keygen = fm_keygen_create(0xfe4c1000);
- *		...
- *	fm_keygen_out(keygen, FM_KEYGEN(GCR), FM_KEYGEN_GCR_EN);
- *		...
- *	fm_keygen_destroy(keygen);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_KEYGEN(reg)	\
-	(offsetof(struct fm_mmap_s, keygen) + offsetof(struct fm_keygen_mmap_s, FMKG_##reg))
-
-/** @} */
-
-/* DMA */
-
-/** \addtogroup	DMA
- *  @{
- */
-
-/** \internal
- *  \brief		DMA register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_dma_mmap_s {
-	uint8_t		reserved0[0x60];
-	uint32_t	FMDM_PLR[32];	/* PID-LIODN */
-	uint8_t		reserved1[0xf20];
-} __aligned(0x1000) __packed;
-
-#define FM_DMA(reg) (offsetof(struct fm_mmap_s, dma) + offsetof(struct fm_dma_mmap_s, FMDM_##reg))
-
-/** @} */
-
-/* FPM */
-
-/** \addtogroup	FPM
- *  @{
- */
-
-/** \internal
- *  \brief		FPM register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_fpm_mmap_s {
-	uint32_t	FMFP_TNC;	/* TNUM control */
-	uint32_t	FMFP_PRC;	/* PoRt_id Control */
-	uint8_t		reserved0[0x18];
-	uint32_t	FMFP_REV[8];	/* RISC EVent */
-	uint32_t	FMFP_REE[8];	/* RISC Event Enable */
-	uint8_t		reserved1[0xfa0];
-} __aligned(0x1000) __packed;
-
-#define FM_FPM(reg) (offsetof(struct fm_mmap_s, fpm) + offsetof(struct fm_fpm_mmap_s, FMFP_##reg))
-
-/** @} */
-
-/* dTSEC */
-
-/** \addtogroup MAC
- * @{
- */
-
-/** \internal
- *  \brief		dTSEC register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_dtsec_mmap_s {
-	uint8_t		reserved0[0x100];
-	uint32_t	MACCFG[2];	/* MAC ConFiGuration */
-	uint8_t		reserved1[0xef8];
-} __aligned(0x1000) __packed;
-
-/** dTSEC register offset
- *
- *  \param[in]	reg	The name of a register as it appears in the BG
- *
- *  Use this macro to get the offset of a dTSEC register. This offset is suitable for using with
- *  the fm_mac_in() and fm_mac_out() functions.
- *
- *  \par	Example:
- *
- *  Here is a sequence of code that initializes a dTSEC to append a CRC to all frames by writing
- *  into the MACCFG2 register:
- *
- *  \code
- *		...
- *	struct fman_mac *mac;
- *		...
- *	mac = fm_mac_create(0xfe4e0000);
- *		...
- *	fm_mac_out(mac, FM_DTSEC(MACCFG[1]), FM_DTSEC_MACCFG2_CRC_EN);
- *		...
- *	fm_mac_destroy(mac);
- *		...
- *  \endcode
- *
- *  \hideinitializer
- */
-#define FM_DTSEC(reg) offsetof(struct fm_dtsec_mmap_s, reg)
-
-/** @} */
-
-/** \addtogroup MDIO
- *  @{
- */
-
-/** \internal
- *  \brief		MDIO register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_mdio_mmap_s {
-	uint8_t	reserved[0x1000];
-}  __aligned(0x1000) __packed;
-
-/** @} */
-
-/** \internal
- *  \brief		Aggregated dTSEC and MDIO register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_dtsec_mdio_mmap_s {
-	struct fm_dtsec_mmap_s	dtsec;
-	struct fm_mdio_mmap_s	mdio;
-}  __aligned(0x2000) __packed;
-
-/* FMan */
-
-/** \internal
- *  \brief		Aggregated FMan register layout
- *  \copydetails	fm_bmi_common_mmap_s
- */
-struct fm_mmap_s {
-	uint8_t				MURAM[0x80000];
-	struct fm_port_mmap_s		ports[0x40];
-	struct fm_policer_mmap_s	policer;
-	struct fm_keygen_mmap_s		keygen;
-	struct fm_dma_mmap_s		dma;
-	struct fm_fpm_mmap_s		fpm;
-	uint8_t				reserved1[0x3000];
-	struct fm_parser_common_mmap_s	parser;
-	uint8_t				reserved2[0x18000];
-	struct fm_dtsec_mdio_mmap_s	dtsec_mdio[4];
-	uint8_t				reserved3[0x18000];
-} __aligned(0x100000) __packed;
-
-/** Parse results memory layout */
-struct fman_parse_results {
-	uint8_t		lpid;
-	uint8_t		shimr;
-	uint16_t	l2r;
-	uint16_t	l3r;
-	uint8_t		l4r;
-	uint8_t		cplan;
-	uint16_t	nxthdr;
-	uint16_t	cksum;
-	uint32_t	lcv;
-	uint8_t		shim_off[3];
-	uint8_t		eth_off;
-	uint8_t		llc_snap_off;
-	uint8_t		vlan_off;
-	uint8_t		etype_off;
-	uint8_t		pppoe_off;
-	uint8_t		mpls_off;
-	uint8_t		ip_off;
-	uint8_t		gre_off;
-	uint8_t		l4_off;
-	uint8_t		nxthdr_off;
-} __packed;
-
-/* Low-level abstractions */
-
-/** \struct	fman
- *  \brief	Handle to a FMan object/device
- *  \details	Used with the fm_in() and fm_out() register access functions
- */
-struct fman;
-
-/** Get a handle to a FMan device/object
- *
- *  \note	For an usage example please see FM_PARSER_COMMON()
- */
-static inline struct fman __iomem *fm_create(void *regs)
-{
-	return (struct fman *)regs;
-}
-
-/** Read a 32-bit register from the FMan CCSR memory space
- *
- *  \note	Use this function as a last resort. It's preferable to use more specific functions
- *		such as fm_port_in(), etc.
- */
-static inline uint32_t fm_in(const struct fman *fm,	/**< FMan handle */
-			     off_t reg_off)		/**< Register offset */
-{
-	return in_be32((void *)((uintptr_t)fm + reg_off));
-}
-
-/** Write a 32-bit register into the FMan CCSR memory space
- *
- *  \note		Use this function as a last resort. It's preferable to use more specific
- *			functions such as fm_port_out(), etc.
- *
- *  \copydetails	fm_create
- */
-static inline void fm_out(struct fman *fm,	/**< FMan handle */
-			  off_t reg_off,	/**< Register offset */
-			  uint32_t val)		/**< Register value */
-{
-	out_be32((void *)((uintptr_t)fm + reg_off), val);
-}
-
-/** Release a handle to a FMan device
- *
- *  \copydetails	fm_create
- */
-static inline void fm_destroy(struct fman *regs __maybe_unused)
-{
-}
-
-/** \addtogroup	Port
- *  @{
- */
-
-/** Hardware port IDs */
-enum fm_port {
-	fm_port_common,
-	fm_port_oh0,
-	fm_port_oh1,
-	fm_port_oh2,
-	fm_port_oh3,
-	fm_port_oh4,
-	fm_port_oh5,
-	fm_port_oh6,
-	fm_port_rx0,
-	fm_port_rx1,
-	fm_port_rx2,
-	fm_port_rx3,
-	fm_port_rx4 = 0x10,
-	fm_port_tx0 = 0x28,
-	fm_port_tx1,
-	fm_port_tx2,
-	fm_port_tx3,
-	fm_port_tx4 = 0x30
-} __packed;
-
-/** \struct	fman_port
- *  \brief	Port handle
- *  \details	Used with the fm_port_in() and fm_port_out() register access functions
- */
-struct fman_port;
-
-/** Get a handle to a port
- *
- *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_RX(),
- *		FM_BMI_TX(), FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_RX(), FM_QMI_TX() or/and
- *		FM_PARSER().
- */
-static inline struct fman_port __iomem *fm_port_create(void *regs)
-{
-	return (struct fman_port *)regs;
-}
-
-/** Read a 32-bit register from a port CCSR memory space
- *
- *  \note	For an usage example please see one of FM_BMI_RX(), FM_QMI_RX() or/and FM_PARSER().
- */
-static inline uint32_t fm_port_in(const struct fman_port *fm_port,	/**< Port handle */
-				  off_t reg_off)			/**< Register offset */
-{
-	return in_be32((void *)((uintptr_t)fm_port + reg_off));
-}
-
-/** Write a 32-bit register to a port CCSR memory space
- *
- *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_TX(),
- *		FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_TX() or/and FM_PARSER().
- */
-static inline void fm_port_out(struct fman_port *fm_port,	/**< Port handle */
-			       off_t reg_off,			/**< Register offset */
-			       uint32_t val)			/**< Register value */
-{
-	out_be32((void *)((uintptr_t)fm_port + reg_off), val);
-}
-
-/** Release a handle to a port
- *
- *  \copydetails	fm_port_create
- */
-static inline void fm_port_destroy(struct fman_port *regs __maybe_unused)
-{
-}
-
-/** @} */
-
-/** \addtogroup	KeyGen
- *  @{
- */
-
-/** KeyGen handle
- */
-struct fman_keygen {
-	struct fm_keygen_mmap_s	*mmap;
-	bool			 busy;
-};
-
-/** Get a handle to KeyGen
- *
- *  \note	For a usage example please see FM_KEYGEN() or fm_keygen_entry_start().
- *
- *  \todo	No memory allocation
- */
-static inline struct fman_keygen __iomem *fm_keygen_create(void *regs)
-{
-	struct fman_keygen	*fm_keygen;
-
-	fm_keygen = kzalloc(sizeof(*fm_keygen), GFP_KERNEL);
-	if (likely(fm_keygen != NULL))
-		fm_keygen->mmap = (typeof(fm_keygen->mmap))regs;
-
-	return fm_keygen;
-}
-
-static inline struct fman *keygen_to_fman(struct fman_keygen *fm_keygen)
-{
-	return (struct fman *)container_of(fm_keygen->mmap, struct fm_mmap_s, keygen);
-}
-
-/** Read a 32-bit register from the KeyGen CCSR memory space */
-static inline uint32_t fm_keygen_in(struct fman_keygen *fm_keygen, off_t reg_off)
-{
-	return fm_in(keygen_to_fman(fm_keygen), reg_off);
-}
-
-/** Write a 32-bit register to the KeyGen CCSR memory space
- *
- *  \copydetails	fm_keygen_create
- */
-static inline void fm_keygen_out(struct fman_keygen *fm_keygen, off_t reg_off, uint32_t val)
-{
-	fm_out(keygen_to_fman(fm_keygen), reg_off, val);
-}
-
-/** Release a handle to KeyGen
- *
- *  \copydetails	fm_keygen_create
- *
- *  \todo		No memory allocation
- */
-static inline void fm_keygen_destroy(struct fman_keygen *fm_keygen)
-{
-	kfree(fm_keygen);
-}
-
-/** @} */
-
-/** \addtogroup	MAC
- *  @{
- */
-
-/** \struct	fman_mac
- *  \brief	MAC handle
- *  \details	Used with the fm_mac_in() and fm_mac_out() register access functions
- *  \note	Currently supports only the dTSEC(s).
- */
-struct fman_mac;
-
-/** Get a handle to a MAC
- *
- *  \note	For an usage example see FM_DTSEC()
- */
-static inline struct fman_mac __iomem *fm_mac_create(void *regs)
-{
-	return (struct fman_mac *)regs;
-}
-
-/** Read a 32-bit register from a MAC CCSR memory space */
-static inline uint32_t fm_mac_in(const struct fman_mac *fm_mac,	/**< MAC handle */
-				 off_t reg_off)			/**< Register offset */
-{
-	return in_be32((void *)((uintptr_t)fm_mac + reg_off));
-}
-
-/** Write a 32-bit register to a MAC CCSR memory space
- *
- *  \copydetails	fm_mac_create
- */
-static inline void fm_mac_out(struct fman_mac *fm_mac,	/**< MAC handle */
-			      off_t reg_off,		/**< Register offset */
-			      uint32_t val)		/**< Register value */
-{
-	out_be32((void *)((uintptr_t)fm_mac + reg_off), val);
-}
-
-/** Release a handle to a MAC
- *
- *  \copydetails	fm_mac_create
- */
-static inline void fm_mac_destroy(struct fman_mac *regs __maybe_unused)
-{
-}
-
-/** @} */
-
-#define FM_FD_STAT_DME		0x01000000	/* DMA Error - QMI */
-#define FM_FD_STAT_FHE		0x00080000	/* Physical Error - BMI */
-#define FM_FD_STAT_FSE		0x00040000	/* Frame Size Error - BMI */
-#define FM_FD_STAT_DIS		0x00020000	/* Discarded frame - BMI */
-#define FM_FD_STAT_EOF		0x00008000	/* Extract Out of Frame - KEYGEN */
-#define FM_FD_STAT_NSS		0x00004000	/* No Scheme Selected - KEYGEN */
-#define FM_FD_STAT_FCL		0x00000c00	/* Frame Color - Policer */
-#define FM_FD_STAT_IPP		0x00000200	/* Illegal Policer Profile - Policer */
-#define FM_FD_STAT_PTE		0x00000080	/* Parser Timeout Exceeded - Parser */
-#define FM_FD_STAT_ISP		0x00000040	/* Invalid Soft Parser Instruction - Parser */
-#define FM_FD_STAT_PHE		0x00000020	/* Parsing Header Error - Parser */
-#define FM_FD_STAT_ERRORS	(FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |	\
-				 FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |	\
-				 FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |	\
-				 FM_FD_STAT_PHE)
-
-#define FM_FD_CMD_FCO	0x80000000	/* Frame queue Context Override */
-#define FM_FD_CMD_RPD	0x40000000	/* Read Prepended Data */
-#define FM_FD_CMD_UDP	0x20000000	/* Update Prepended Data */
-#define FM_FD_CMD_BMF	0x10000000	/* Buffer Must not be Freed */
-#define FM_FD_CMD_DTC	0x08000000	/* Do TCP Checksum */
-#define FM_FD_CMD_DME	0x01000000	/* DMA Error */
-#define FM_FD_CMD_CFQ	0x00ffffff	/* Confirmation Frame Queue */
-
-/* High-level abstractions */
-
-/* KeyGen */
-
-/** \addtogroup	KeyGen
- *  @{
- */
-
-/** KeyGen entry types
- *
- *  The Keygen uses the same registers area to overlay three different functionalities. Access to
- *  register sets should be guarded with calls to fm_keygen_entry_start() and fm_keygen_commit().
- */
-enum fman_keygen_entry_type {
-	fman_keygen_scheme,	/**< Classification scheme */
-	fman_keygen_plan,	/**< Classification plan */
-	fman_keygen_port	/**< Port partition */
-} __packed;
-
-/** KeyGen entry handle */
-struct fman_keygen_entry {
-	struct fman_keygen		*fm_keygen;
-	uint32_t			 ar;
-};
-
-/** Start reading/writing a new KeyGen entry
- *
- *  Once a KeyGen entry handle is aquired, use the fm_keygen_in() and fm_keygen_out() to access the
- *  entry registers and activate the entry using fm_keygen_commit(). In order to abandon an entry
- *  before activating it and start a new kind of entry use again fm_keygen_entry_start().
- *
- *  \par	Example:
- *
- *  Here is a partial sequence of code that ilustrates how to program/write a classification scheme:
- *
- *  \code
- *		...
- *	struct fman_keygen		*keygen;
- *	struct fman_keygen_entry	*keygen_entry;
- *		...
- *	keygen = fm_keygen_create(0xfe4c1000);
- *		...
- *	keygen_entry = fm_keygen_entry_start(keygen, false, fman_keygen_scheme, 0);
- *		...
- *	/ * Hash based on the IP source and destination addresses and TOS bits * /
- *	fm_keygen_out(keygen, FM_KEYGEN(SE_EKFC), FM_KEYGEN_EKFC_IPSRC |
- *						  FM_KEYGEN_EKFC_IPDST |
- *						  FM_KEYGEN_EKFC_IPTOS);
- *		...
- *	fm_keygen_commit(keygen_entry);
- *		...
- *	fm_keygen_destroy(keygen);
- *		...
- *  \endcode
- *
- *  \todo	No memory allocation
- */
-static inline struct fman_keygen_entry *
-fm_keygen_entry_start(struct fman_keygen		*fm_keygen,	/**< KeyGen handle */
-		      bool				 read,		/**< Read or write  */
-		      enum fman_keygen_entry_type	 type,		/**< Entry type */
-		      uint8_t				 index)		/**< Entry index */
-{
-	struct fman_keygen_entry	*fm_keygen_entry;
-
-	if (fm_keygen->busy == true)
-		return NULL;
-
-	while(fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
-		cpu_relax();
-
-	fm_keygen_entry = kzalloc(sizeof(*fm_keygen_entry), GFP_KERNEL);
-	if (likely(fm_keygen_entry != NULL)) {
-		fm_keygen_entry->fm_keygen = fm_keygen;
-
-		fm_keygen_entry->ar = FM_KEYGEN_AR_GO		|
-				      FM_KEYGEN_AR_SEL(type)	|
-				      FM_KEYGEN_AR_NUM(index);
-		if (read == true) {
-			fm_keygen_entry->ar |= FM_KEYGEN_AR_RW;
-			fm_keygen_out(fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
-			while (fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
-				cpu_relax();
-		}
-
-		fm_keygen->busy = true;
-	}
-
-	return fm_keygen_entry;
-}
-
-/** Activate the current KeyGen entry
- *
- *  \note	For an usage example please see fm_keygen_entry_start()
- *
- *  \todo	No memory allocation
- */
-static inline void fm_keygen_commit(struct fman_keygen_entry *fm_keygen_entry)
-{
-	BUG_ON(fm_keygen_entry->fm_keygen->busy == false);
-
-	if ((fm_keygen_entry->ar & FM_KEYGEN_AR_RW) == 0)	/* Write access type */
-		fm_keygen_out(fm_keygen_entry->fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
-
-	fm_keygen_entry->fm_keygen->busy = false;
-	kfree(fm_keygen_entry);
-}
-
-/** @} */
-
-enum fm_isr_reg {
-	fm_isr_status,
-	fm_isr_enable
-} __packed;
-
-/** FMan engine code
- *
- *  To be used by/with fm_nia() for building the NIA codes for the \ref BMI, \ref KeyGen, etc.
- */
-enum fm_engine {
-	fm_risc,		/**< RISC */
-	fm_parser = 0x11,	/**< \ref Parser \hideinitializer */
-	fm_keygen,		/**< \ref KeyGen*/
-	fm_policer,		/**< \ref Policer */
-	fm_bmi,			/**< \ref BMI */
-	fm_qmi_enqueue,		/**< \ref QMI */
-	fm_qmi_dequeue		/**< \ref QMI */
-} __packed;
-
-#define FM_NIA_OPR_SHIFT	23
-#define FM_NIA_OPR_MASK		0x00800000
-#define FM_NIA_ENG_SHIFT	18
-#define FM_NIA_ENG_MASK		0x007c0000
-#define FM_NIA_AC_SHIFT		0
-#define FM_NIA_AC_MASK		0x0003ffff
-
-/** Build NIA codes */
-static inline uint32_t fm_nia(bool opr,			/**< Use order preservation */
-			      enum fm_engine eng,	/**< Next engine */
-			      uint32_t ac)		/**< Action code */
-{
-	return (opr	<< FM_NIA_OPR_SHIFT	& FM_NIA_OPR_MASK)	|
-	       (eng	<< FM_NIA_ENG_SHIFT	& FM_NIA_ENG_MASK)	|
-	       (ac	<< FM_NIA_AC_SHIFT	& FM_NIA_AC_MASK);
-}
-
-#endif	/* __FMAN_CONF_H */
diff --git a/drivers/net/dpa/port-wrapper.c b/drivers/net/dpa/port-wrapper.c
deleted file mode 100644
index 185ebee..0000000
--- a/drivers/net/dpa/port-wrapper.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/io.h>		/* in_be32() */
-#include <linux/of_platform.h>
-
-#include "dpaa_eth-common.h"
-#include "fm.h"			/* fmdev_priv() */
-#include "fm-wrapper.h"		/* struct fm_priv_s */
-#include "port.h"
-
-#include "fm_common.h"		/* BASE_RX/TX_PORTID */
-#include "lnxwrp_fm.h"		/* t_LnxWrpFmPortDev */
-#include "lnxwrp_fm_ext.h"
-
-#define PORT_DESCRIPTION "FSL FMan port wrapper based driver"
-
-MODULE_LICENSE("Dual BSD/GPL");
-
-MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
-
-MODULE_DESCRIPTION(PORT_DESCRIPTION);
-
-struct port_priv_s {
-	t_LnxWrpFmPortDev		*port;
-	t_SysObjectAdvConfigEntry	 config[FM_MAX_NUM_OF_ADV_SETTINGS];
-};
-
-struct rx_priv_s {
-	struct port_priv_s	port;
-	fm_port_rx_params_t	param;
-};
-
-struct tx_priv_s {
-	struct port_priv_s	port;
-	fm_port_non_rx_params_t	param;
-};
-
-const char	*port_driver_description __initconst = PORT_DESCRIPTION;
-const size_t	 port_sizeof_priv[] __devinitconst = {
-	[RX] = sizeof(struct rx_priv_s),
-	[TX] = sizeof(struct tx_priv_s)
-};
-
-/* RX */
-
-static int __devinit __cold __attribute__((nonnull))
-init(const struct port_device *port_dev, uint8_t logical_index)
-{
-	struct port_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	priv->port->id		= logical_index;
-	priv->port->baseAddr	= (typeof(priv->port->baseAddr))port_dev->vaddr;
-	priv->port->memSize	= port_dev->res->end + 1 - port_dev->res->start;
-
-	priv->port->settings.param.fmId		= port_dev->fm_dev->cell_index;
-	priv->port->settings.param.portId	= logical_index;
-	priv->port->settings.param.h_App	= priv->port;
-
-	priv->port->settings.advConfig		= priv->config;
-
-	priv->port->h_LnxWrpFmDev	= &((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm;
-
-	return 0;
-}
-
-static int __devinit __cold init_rx(struct port_device *port_dev)
-{
-	struct rx_priv_s	*priv;
-	uint8_t			 logical_index;
-
-	priv = portdev_priv(port_dev);
-
-	logical_index = port_dev->cell_index - BASE_RX_PORTID;
-	priv->port.port =
-		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.rxPorts + logical_index;
-
-	priv->port.port->settings.param.portType	= e_FM_PORT_TYPE_RX;
-
-	/* Ugly hack! */
-	priv->port.port->settings.param.specificParams.rxParams.rxPartitionId	=
-		in_be32(port_dev->fm_dev->vaddr + 0x80000 + 0x300 +
-			sizeof(uint32_t) * port_dev->cell_index);
-
-	priv->param.priv_data_size	= 16;
-	priv->param.parse_results	= true;
-
-	priv->port.port->defPcd	= e_FM_PCD_PARSE_RESULTS;
-
-	return init(port_dev, logical_index);
-}
-
-static int __cold __attribute__((nonnull)) _init_rx(const struct port_device *port_dev)
-{
-	const struct rx_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	priv->port.port->active	= true;
-
-	fm_set_rx_port_params(priv->port.port, &priv->param);
-
-	return 0;
-}
-
-static int __devinit __cold set_default_fq_rx(struct port_device *port_dev, uint32_t fq)
-{
-	((struct rx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
-	return 0;
-}
-
-static int __devinit __cold set_error_fq_rx(struct port_device *port_dev, uint32_t fq)
-{
-	((struct rx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
-	return 0;
-}
-
-static int __devinit __cold
-set_bp_info_rx(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count)
-{
-	int			 i;
-	struct rx_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	priv->param.num_pools = min(count,
-			(uint8_t)ARRAY_SIZE(priv->param.pool_param));
-	for (i = 0; i < priv->param.num_pools; i++) {
-		priv->param.pool_param[i].id	= bp_info[i].bpid;
-		priv->param.pool_param[i].size	= bp_info[i].size;
-	}
-
-	return 0;
-}
-
-static int __cold start_rx(struct port_device *port_dev)
-{
-	int			 _errno;
-	const struct rx_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	if (unlikely(!priv->port.port->active)) {
-		_errno = _init_rx(port_dev);
-		if (unlikely(_errno < 0))
-			goto _return;
-	}
-
-	fm_port_enable(priv->port.port);
-	_errno = 0;
-
-_return:
-	return _errno;
-}
-
-static int __cold stop(struct port_device *port_dev)
-{
-	fm_port_disable(((struct port_priv_s *)portdev_priv(port_dev))->port);
-	return 0;
-}
-
-#ifdef CONFIG_BUG
-static uint8_t get_lpid(const struct port_device *port_dev)
-{
-	return port_dev->fm_dev->cell_index << 6 | port_dev->cell_index;
-}
-#endif
-
-/* TX */
-
-static int __devinit __cold init_tx(struct port_device *port_dev)
-{
-	struct tx_priv_s	*priv;
-	uint8_t			 logical_index;
-
-	priv = portdev_priv(port_dev);
-
-	logical_index = port_dev->cell_index - BASE_TX_PORTID;
-	priv->port.port =
-		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.txPorts + logical_index;
-
-	priv->port.port->settings.param.portType = e_FM_PORT_TYPE_TX;
-
-	priv->port.port->settings.param.specificParams.nonRxParams.deqSubPortal	=
-		port_dev->channel & 0xf;
-
-	priv->port.port->defPcd	= e_NO_PCD;
-
-	return init(port_dev, logical_index);
-}
-
-static int __cold __attribute__((nonnull)) _init_tx(const struct port_device *port_dev)
-{
-	const struct tx_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	priv->port.port->active	= true;
-
-	fm_set_tx_port_params(priv->port.port, &priv->param);
-
-	return 0;
-}
-
-static int __devinit __cold set_default_fq_tx(struct port_device *port_dev, uint32_t fq)
-{
-	((struct tx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
-	return 0;
-}
-
-static int __devinit __cold set_error_fq_tx(struct port_device *port_dev, uint32_t fq)
-{
-	((struct tx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
-	return 0;
-}
-
-static int __cold start_tx(struct port_device *port_dev)
-{
-	int			 _errno;
-	const struct tx_priv_s	*priv;
-
-	priv = portdev_priv(port_dev);
-
-	if (unlikely(!priv->port.port->active)) {
-		_errno = _init_tx(port_dev);
-		if (unlikely(_errno < 0))
-			goto _return;
-	}
-
-	fm_port_enable(priv->port.port);
-	_errno = 0;
-
-_return:
-	return _errno;
-}
-
-static void __devinit __cold setup_rx(struct port_device *port_dev)
-{
-	port_dev->init			= init_rx;
-	port_dev->start			= start_rx;
-	port_dev->stop			= stop;
-	port_dev->set_default_fq	= set_default_fq_rx;
-	port_dev->set_error_fq		= set_error_fq_rx;
-	port_dev->set_bp_info		= set_bp_info_rx;
-#ifdef CONFIG_BUG
-	port_dev->get_lpid		= get_lpid;
-#endif
-	port_dev->uninit		= NULL;
-}
-
-static void __devinit __cold setup_tx(struct port_device *port_dev)
-{
-	port_dev->init			= init_tx;
-	port_dev->start			= start_tx;
-	port_dev->stop			= stop;
-	port_dev->set_default_fq	= set_default_fq_tx;
-	port_dev->set_error_fq		= set_error_fq_tx;
-	port_dev->set_bp_info		= NULL;
-#ifdef CONFIG_BUG
-	port_dev->get_lpid		= NULL;
-#endif
-	port_dev->uninit		= NULL;
-}
-
-void (*const port_setup[])(struct port_device *port_dev) __devinitconst = {
-	[RX] = setup_rx,
-	[TX] = setup_tx
-};
diff --git a/drivers/net/dpa/port.c b/drivers/net/dpa/port.c
deleted file mode 100644
index ff5430e..0000000
--- a/drivers/net/dpa/port.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/of_platform.h>
-#include <linux/device.h>
-#include <linux/io.h>		/* devm_ioremap() */
-
-#include "dpaa_eth-common.h"
-#include "port.h"
-
-static struct port_device * __devinit __cold
-alloc_portdev(struct device *dev, size_t sizeof_priv,
-		void (*setup)(struct port_device *port_dev))
-{
-	struct port_device *port_dev;
-
-	port_dev = devm_kzalloc(dev, sizeof(*port_dev) + sizeof_priv,
-			GFP_KERNEL);
-	if (port_dev == NULL)
-		return ERR_PTR(-ENOMEM);
-
-	port_dev->dev = dev;
-	dev_set_drvdata(dev, port_dev);
-	setup(port_dev);
-
-	return port_dev;
-}
-
-static int __devexit __cold free_portdev(struct port_device *port_dev)
-{
-	dev_set_drvdata(port_dev->dev, NULL);
-
-	return likely(port_dev->uninit) ? port_dev->uninit(port_dev) : 0;
-}
-
-static const struct of_device_id port_match[] __devinitconst = {
-	[RX] = {
-		.compatible	= "fsl,fman-port-rx"
-	},
-	[TX] = {
-		.compatible	= "fsl,fman-port-tx"
-	},
-	{}
-};
-MODULE_DEVICE_TABLE(of, port_match);
-
-static const char port_type[][8] __devinitconst = {
-	[RX] = "port-rx",
-	[TX] = "port-tx"
-};
-
-static int __devinit __cold port_probe(struct of_device *_of_dev, const struct of_device_id *match)
-{
-	int			 _errno, i, lenp;
-	struct device		*dev;
-	struct device_node	*port_node, *fm_node;
-	struct port_device	*port_dev;
-	struct of_device	*of_dev;
-	struct resource		 res;
-	const uint32_t		*uint32_prop;
-
-	dev = &_of_dev->dev;
-
-	port_node = _of_dev->node;
-
-	for (i = 0; i < ARRAY_SIZE(port_match) - 1 && match != port_match + i; i++);
-	BUG_ON(i >= ARRAY_SIZE(port_match) - 1);
-
-	port_dev = alloc_portdev(dev, port_sizeof_priv[i], port_setup[i]);
-	if (IS_ERR(port_dev)) {
-		dpaa_eth_err(dev, "alloc_portdev() = %d\n", _errno);
-		_errno = PTR_ERR(port_dev);
-		goto _return;
-	}
-
-	/* Get the FM node */
-	fm_node = of_get_parent(port_node);
-	if (unlikely(fm_node == NULL)) {
-		dpaa_eth_err(dev, "of_get_parent(%s) failed\n",
-				port_node->full_name);
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-
-	of_dev = of_find_device_by_node(fm_node);
-	if (unlikely(of_dev == NULL)) {
-		dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
-				fm_node->full_name);
-		of_node_put(fm_node);
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-	of_node_put(fm_node);
-
-	port_dev->fm_dev = dev_get_drvdata(&of_dev->dev);
-	BUG_ON(port_dev->fm_dev == NULL);
-
-	/* Get the address of the memory mapped registers */
-	_errno = of_address_to_resource(port_node, 0, &res);
-	if (unlikely(_errno < 0)) {
-		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
-				port_node->full_name, _errno);
-		goto _return_dev_set_drvdata;
-	}
-
-	port_dev->res = __devm_request_region(dev, port_dev->fm_dev->res,
-					      res.start, res.end + 1 - res.start, port_type[i]);
-	if (unlikely(port_dev->res == NULL)) {
-		dpaa_eth_err(dev, "__devm_request_mem_region(port) failed\n");
-		_errno = -EBUSY;
-		goto _return_dev_set_drvdata;
-	}
-
-	port_dev->vaddr = devm_ioremap(dev, port_dev->res->start,
-				       port_dev->res->end + 1 - port_dev->res->start);
-	if (unlikely(port_dev->vaddr == NULL)) {
-		dpaa_eth_err(dev, "devm_ioremap() failed\n");
-		_errno = -EIO;
-		goto _return_dev_set_drvdata;
-	}
-
-	uint32_prop = of_get_property(port_node, "cell-index", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
-				port_node->full_name);
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-	BUG_ON(lenp != sizeof(uint32_t));
-	port_dev->cell_index = *uint32_prop;
-
-	if (match != port_match + RX) {
-		uint32_prop = of_get_property(port_node,
-				"fsl,qman-channel-id", &lenp);
-		if (unlikely(uint32_prop == NULL)) {
-			dpaa_eth_err(dev,
-				"of_get_property(%s, fsl,qman-channel-id)"
-				" failed\n", port_node->full_name);
-			_errno = -EINVAL;
-			goto _return_dev_set_drvdata;
-		}
-		BUG_ON(lenp != sizeof(uint32_t));
-		port_dev->channel = *uint32_prop;
-	}
-
-	_errno = port_dev->init(port_dev);
-	if (unlikely(_errno < 0)) {
-		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
-		goto _return_dev_set_drvdata;
-	}
-
-	goto _return;
-
-_return_dev_set_drvdata:
-	dev_set_drvdata(dev, NULL);
-_return:
-	return _errno;
-}
-
-static int __devexit __cold port_remove(struct of_device *of_dev)
-{
-	int		 _errno;
-	struct device	*dev;
-
-	dev = &of_dev->dev;
-
-	_errno = free_portdev((struct port_device *)dev_get_drvdata(dev));
-
-	return _errno;
-}
-
-static struct of_platform_driver port_driver = {
-	.name		= KBUILD_MODNAME,
-	.match_table	= port_match,
-	.owner		= THIS_MODULE,
-	.probe		= port_probe,
-	.remove		= __devexit_p(port_remove)
-};
-
-static int __init __cold port_load(void)
-{
-	int	 _errno;
-
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", port_driver_description);
-
-	_errno = of_register_platform_driver(&port_driver);
-	if (unlikely(_errno < 0)) {
-		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
-			   __file__, __LINE__, __func__, _errno);
-		goto _return;
-	}
-
-	goto _return;
-
-_return:
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-
-	return _errno;
-}
-module_init(port_load);
-
-static void __exit __cold port_unload(void)
-{
-	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
-
-	of_unregister_platform_driver(&port_driver);
-
-	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
-}
-module_exit(port_unload);
diff --git a/drivers/net/dpa/port.h b/drivers/net/dpa/port.h
deleted file mode 100644
index 5d8f4d3..0000000
--- a/drivers/net/dpa/port.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *	 notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *	 notice, this list of conditions and the following disclaimer in the
- *	 documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *	 names of its contributors may be used to endorse or promote products
- *	 derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __PORT_H
-#define __PORT_H
-
-#include <linux/device.h>	/* struct device */
-
-#include "fm.h"			/* struct fm_device */
-
-struct port_bp_info {
-	uint8_t	bpid;
-	size_t	size;
-};
-
-struct port_device {
-	struct device		*dev;
-	void			*priv;
-	uint8_t			 cell_index;
-	struct resource		*res;
-	void			*vaddr;
-	uint16_t		 channel;
-
-	struct fm_device	*fm_dev;
-
-	int (*init)(struct port_device *port_dev);
-	int (*set_default_fq)(struct port_device *port_dev, uint32_t fq);
-	int (*set_error_fq)(struct port_device *port_dev, uint32_t fq);
-	int (*set_bp_info)(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count);
-	int (*start)(struct port_device *port_dev);
-	int (*stop)(struct port_device *port_dev);
-#ifdef CONFIG_BUG
-	uint8_t (*get_lpid)(const struct port_device *port_dev);
-#endif
-	int (*uninit)(struct port_device *port_dev);
-};
-
-static inline void * __attribute((nonnull)) portdev_priv(const struct port_device *port_dev)
-{
-	return (void *)port_dev + sizeof(*port_dev);
-}
-
-extern const char	*port_driver_description;
-extern const size_t	 port_sizeof_priv[];
-extern void (*const port_setup[])(struct port_device *port_dev);
-
-#endif	/* __PORT_H */
-- 
1.7.0.4

