From 56ec947295e377d1eb50d3a3434be58dfd47d050 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Wed, 4 Aug 2010 14:37:54 +0800
Subject: [PATCH 157/252] drivers : hwalloc : bman_high : changed local_irq_xxxx() to spin_lock_irqsave()

Signed-off-by: Patrik Lindergren <patrik.lindergren@windriver.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/hwalloc/bman_high.c |   28 ++++++++++++++++++----------
 1 files changed, 18 insertions(+), 10 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index edf0c22..f2446d6 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -65,6 +65,7 @@ struct bman_portal {
 	 * you'll never guess the hash-function ... */
 	struct bman_pool *cb[64];
 	char irqname[MAX_IRQNAME];
+	spinlock_t lock;
 };
 
 /* GOTCHA: this object type refers to a pool, it isn't *the* pool. There may be
@@ -83,21 +84,25 @@ struct bman_pool {
 /* (De)Registration of depletion notification callbacks */
 static void depletion_link(struct bman_portal *portal, struct bman_pool *pool)
 {
+	unsigned long flags;
+
 	pool->portal = portal;
-	local_irq_disable();
+	spin_lock_irqsave(&portal->lock, flags);
 	pool->next = portal->cb[pool->params.bpid];
 	portal->cb[pool->params.bpid] = pool;
 	if (!pool->next)
 		/* First object for that bpid on this portal, enable the BSCN
 		 * mask bit. */
 		bm_isr_bscn_mask(portal->p, pool->params.bpid, 1);
-	local_irq_enable();
+	spin_unlock_irqrestore(&portal->lock, flags);
 }
 static void depletion_unlink(struct bman_pool *pool)
 {
 	struct bman_pool *it, *last = NULL;
 	struct bman_pool **base = &pool->portal->cb[pool->params.bpid];
-	local_irq_disable();
+	unsigned long flags;
+
+	spin_lock_irqsave(&pool->portal->lock, flags);
 	it = *base;	/* <-- gotcha, don't do this prior to the irq_disable */
 	while (it != pool) {
 		last = it;
@@ -111,7 +116,7 @@ static void depletion_unlink(struct bman_pool *pool)
 		/* Last object for that bpid on this portal, disable the BSCN
 		 * mask bit. */
 		bm_isr_bscn_mask(pool->portal->p, pool->params.bpid, 0);
-	local_irq_enable();
+	spin_unlock_irqrestore(&pool->portal->lock, flags);
 }
 
 static u32 __poll_portal_slow(struct bman_portal *p, struct bm_portal *lowp,
@@ -150,6 +155,7 @@ struct bman_portal *bman_create_portal(struct bm_portal *__p,
 	portal = kmalloc(sizeof(*portal), GFP_KERNEL);
 	if (!portal)
 		return NULL;
+	spin_lock_init(&portal->lock);
 	if (bm_rcr_init(__p, bm_rcr_pvb, bm_rcr_cce)) {
 		pr_err("Bman RCR initialisation failed\n");
 		goto fail_rcr;
@@ -259,6 +265,7 @@ static u32 __poll_portal_slow(struct bman_portal *p, struct bm_portal *lowp,
 				u32 is)
 {
 	struct bman_depletion tmp;
+	unsigned long flags;
 	u32 ret = is;
 
 	/* There is a gotcha to be aware of. If we do the query before clearing
@@ -278,13 +285,13 @@ static u32 __poll_portal_slow(struct bman_portal *p, struct bm_portal *lowp,
 			bm_isr_status_clear(lowp, BM_PIRQ_BSCN);
 		}
 		is &= ~BM_PIRQ_BSCN;
-		local_irq_disable();
+		spin_lock_irqsave(&p->lock, flags);
 		bm_mc_start(lowp);
 		bm_mc_commit(lowp, BM_MCC_VERB_CMD_QUERY);
 		while (!(mcr = bm_mc_result(lowp)))
 			cpu_relax();
 		tmp = mcr->query.ds.state;
-		local_irq_enable();
+		spin_unlock_irqrestore(&p->lock, flags);
 		for (i = 0; i < 2; i++) {
 			int idx = i * 32;
 			/* tmp is a mask of currently-depleted pools.
@@ -312,11 +319,11 @@ static u32 __poll_portal_slow(struct bman_portal *p, struct bm_portal *lowp,
 	}
 
 	if (is & BM_PIRQ_RCRI) {
-		local_irq_disable();
+		spin_lock_irqsave(&p->lock, flags);
 		p->rcr_cons += bm_rcr_cce_update(lowp);
 		bm_rcr_set_ithresh(lowp, 0);
 		wake_up(&p->queue);
-		local_irq_enable();
+		spin_unlock_irqrestore(&p->lock, flags);
 		bm_isr_status_clear(lowp, BM_PIRQ_RCRI);
 		is &= ~BM_PIRQ_RCRI;
 	}
@@ -660,9 +667,10 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 	struct bman_portal *p = get_affine_portal();
 	struct bm_mc_command *mcc;
 	struct bm_mc_result *mcr;
+	unsigned long flags;
 	u8 ret;
 
-	local_irq_disable();
+	spin_lock_irqsave(&p->lock, flags);
 	mcc = bm_mc_start(p->p);
 	mcc->acquire.bpid = pool->params.bpid;
 	bm_mc_commit(p->p, BM_MCC_VERB_CMD_ACQUIRE |
@@ -671,7 +679,7 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 		cpu_relax();
 	ret = num = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;
 	memcpy(&bufs[0], &mcr->acquire.bufs[0], num * sizeof(bufs[0]));
-	local_irq_enable();
+	spin_unlock_irqrestore(&p->lock, flags);
 	put_affine_portal();
 	return ret;
 }
-- 
1.6.5.2

