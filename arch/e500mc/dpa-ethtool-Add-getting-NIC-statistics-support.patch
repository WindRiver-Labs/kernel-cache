From 86fde5d01e43124975b9f1b80892a30ef2862852 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Tue, 5 Jun 2012 15:03:53 +0800
Subject: [PATCH] dpa/ethtool: Add getting NIC statistics support

dpa NIC driver can't support dump statistics by ethtool,
"ethtool -S ethX" always return "no stats available" error.

Since NetCommSw has provided interfaces to dump statistics
from registers, so we only need to implement ethtool's
interfaces by call NetCommSw's interfaces to support this
feature.

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 drivers/net/dpa/dpa-ethtool.c |   68 ++++++++++++++++++++++++++++++++++++++++-
 drivers/net/dpa/mac-api.c     |   34 +++++++++++++++++++++
 drivers/net/dpa/mac.h         |    1 +
 3 files changed, 102 insertions(+), 1 deletion(-)

diff --git a/drivers/net/dpa/dpa-ethtool.c b/drivers/net/dpa/dpa-ethtool.c
index 4658e88..fb15a3f 100644
--- a/drivers/net/dpa/dpa-ethtool.c
+++ b/drivers/net/dpa/dpa-ethtool.c
@@ -33,6 +33,38 @@
 
 #include "dpaa_eth.h"
 
+static char stat_gstrings[][ETH_GSTRING_LEN] = {
+	"tx-rx-64-frames",
+	"tx-rx-65-127-frames",
+	"tx-rx-128-255-frames",
+	"tx-rx-256-511-frames",
+	"tx-rx-512-1023-frames",
+	"tx-rx-1024-1518-frames",
+	"tx-rx-1519-1522-good-vlan",
+	"rx-64-invalid-fcs",
+	"rx-jabber-invalid-fcs",
+	"rx-dropped-by-lack-resource",
+	"rx-alignment-error",
+	"rx-undersize-packets",
+	"rx-oversize-packets",
+	"rx-pause-frame-packets",
+	"tx-pause-frame-packets",
+	"rx-bytes",
+	"rx-packets",
+	"receive-multicast-frames",
+	"receive-broadcast-frames",
+	"rx-dropped-frames",
+	"rx-error-frames",
+	"tx-bytes",
+	"tx-packets",
+	"tx-multicast-frames",
+	"tx-broadcast-frames",
+	"tx-dropped-frames",
+	"tx-error-frames",
+};
+
+#define DPA_STATS_LEN ARRAY_SIZE(stat_gstrings)
+
 static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
 {
 	int			 _errno;
@@ -97,6 +129,7 @@ static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_dr
 	}
 	strncpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),
 		sizeof(drvinfo->bus_info) - 1)[sizeof(drvinfo->bus_info)-1] = 0;
+	drvinfo->n_stats = DPA_STATS_LEN;
 }
 
 uint32_t __cold dpa_get_msglevel(struct net_device *net_dev)
@@ -212,6 +245,36 @@ int __cold dpa_set_pauseparam(struct net_device *net_dev, struct ethtool_pausepa
 	return 0;
 }
 
+static void dpa_get_ethtool_stats(struct net_device *netdev,
+				struct ethtool_stats *stats, u64 *data)
+{
+	struct dpa_priv_s       *priv = netdev_priv(netdev);
+	int			_errno;
+
+	_errno = priv->mac_dev->get_stats(priv->mac_dev, data);
+	if (_errno < 0) {
+		if (netif_msg_drv(priv))
+			cpu_netdev_err(netdev,
+				"mac_dev->get_stats = %d\n",
+				_errno);
+	}
+}
+
+static void dpa_get_strings(struct net_device *netdev, u32 stringset, u8 *buf)
+{
+	memcpy(buf, stat_gstrings, DPA_STATS_LEN * ETH_GSTRING_LEN);
+}
+
+static int dpa_sset_count(struct net_device *netdev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return DPA_STATS_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
 u32 dpa_get_rx_csum(struct net_device *dev)
 {
 	cpu_netdev_info(dev, "Can't automatically tell the status of "
@@ -253,5 +316,8 @@ const struct ethtool_ops dpa_ethtool_ops __devinitconst = {
 	.get_ufo		= ethtool_op_get_ufo,
 	.set_ufo		= ethtool_op_set_ufo,
 	.get_flags		= ethtool_op_get_flags,
-	.set_flags		= ethtool_op_set_flags
+	.set_flags		= ethtool_op_set_flags,
+	.get_strings            = dpa_get_strings,
+	.get_sset_count         = dpa_sset_count,
+	.get_ethtool_stats      = dpa_get_ethtool_stats,
 };
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index aa8fe5f..b514713 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -44,6 +44,7 @@
 #include "fm_mac_ext.h"
 #include "fm_rtc_ext.h"
 #include "NetCommSw/Peripherals/FM/MAC/dtsec.h"
+#include "NetCommSw/inc/Peripherals/fm_mac_ext.h"
 
 #define MAC_DESCRIPTION "FSL FMan MAC API based driver"
 
@@ -631,6 +632,38 @@ static int __cold get_pause_frame(struct mac_device *mac_dev, bool *tx, bool *rx
 	return _errno;			
 }
 
+static int __cold mac_get_statistics(struct mac_device *mac_dev, u64 *data)
+{
+	int	_errno = 0;
+	t_Error err;
+	t_FmMacStatistics *p_Statistics;
+	int i;
+	u64 *buf;
+
+	p_Statistics = kmalloc(sizeof(t_FmMacStatistics), GFP_ATOMIC);
+	if (!p_Statistics) {
+		dpaa_eth_err(mac_dev->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+
+	err = FM_MAC_GetStatistics(
+		((struct mac_priv_s *)macdev_priv(mac_dev))->mac, p_Statistics);
+	 _errno = -GET_ERROR_TYPE(err);
+	if (_errno < 0) {
+		dpaa_eth_err(mac_dev->dev,
+			"FM_MAC_GetTxPauseFrames() = 0x%08x\n", err);
+		goto out;
+	}
+
+	buf = (u64 *) p_Statistics;
+	for (i = 0; i < sizeof(t_FmMacStatistics)/sizeof(u64); i++)
+		data[i] = buf[i];
+
+out:
+	kfree(p_Statistics);	
+	return _errno;
+}
+
 static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
 {
 	mac_dev->init_phy	= dtsec_init_phy;
@@ -651,6 +684,7 @@ static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
 	mac_dev->fm_rtc_set_drift	= fm_rtc_set_drift;
 	mac_dev->set_pause_frame 	= set_pause_frame;
 	mac_dev->get_pause_frame	= get_pause_frame;
+	mac_dev->get_stats		= mac_get_statistics;
 }
 
 static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
index a94a94e..b391e0f 100644
--- a/drivers/net/dpa/mac.h
+++ b/drivers/net/dpa/mac.h
@@ -93,6 +93,7 @@ struct mac_device {
 	int (*fm_rtc_set_drift)(struct net_device *net_dev, uint32_t drift);
 	int (*set_pause_frame)(struct mac_device *mac_dev, struct ethtool_pauseparam *pause);
 	int (*get_pause_frame)(struct mac_device *mac_dev, bool *tx, bool *rx);
+	int (*get_stats)(struct mac_device *mac_dev, uint64_t *p_Statistics);
 };
 
 struct mac_address {
-- 
1.7.9.7

