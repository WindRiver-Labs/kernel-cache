From 268ab1234d7a1e037e4c5778073e06b82299599b Mon Sep 17 00:00:00 2001
From: Kumar Gala <galak@kernel.crashing.org>
Date: Thu, 26 Aug 2010 01:24:33 -0500
Subject: [PATCH 104/233] fmd: Add FMD13 - initialization and configuration code for Frame Manager

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0132-fmd-Add-FMD13-initialization-and-configuration-code-.patch

Signed-off-by: Shlomi Gridish <gridish@freescale.com>
Signed-off-by: Timur Tabi <timur@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Signed-off-by: Sorin Pistirica <sorin.pistirica@freescale.com>
Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Signed-off-by: Stefan Szabo <stefan.szabo@freescale.com>
[context adjustment]
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 Documentation/networking/fman.txt                  |  232 +
 arch/powerpc/include/asm/immap_qe.h                |   49 +-
 drivers/Kconfig                                    |    2 +
 drivers/net/dpa/NetCommSw/Kconfig                  |   34 +
 drivers/net/dpa/NetCommSw/Makefile                 |   13 +
 .../net/dpa/NetCommSw/Peripherals/FM/HC/Makefile   |   15 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   | 1956 ++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile  |   14 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   | 1928 ++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |  634 +++
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |  120 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   78 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |  560 +++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |  197 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    | 1267 +++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h    |  482 ++
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |  121 +
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |   81 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile  |   21 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile  |   19 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   | 3452 +++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h   |  319 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   | 3252 +++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 2637 ++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  310 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  | 1825 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h  |  715 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |  325 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c | 1750 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |  543 +++
 .../net/dpa/NetCommSw/Peripherals/FM/Port/Makefile |   19 +
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 5102 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  893 ++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |  791 +++
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile  |   15 +
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c  |  859 ++++
 .../net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h  |  217 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      | 4615 ++++++++++++++++++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |  717 +++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |   35 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |  454 ++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_muram.c    |  145 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   | 1322 +++++
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |  101 +
 drivers/net/dpa/NetCommSw/etc/Makefile             |   11 +
 drivers/net/dpa/NetCommSw/etc/error.c              |  118 +
 drivers/net/dpa/NetCommSw/etc/list.c               |   70 +
 drivers/net/dpa/NetCommSw/etc/memcpy.c             |  665 +++
 drivers/net/dpa/NetCommSw/etc/mm.c                 | 1128 +++++
 drivers/net/dpa/NetCommSw/etc/mm.h                 |  101 +
 drivers/net/dpa/NetCommSw/etc/sprint.c             |   86 +
 drivers/net/dpa/NetCommSw/events_mapping.h         |   51 +
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |  363 ++
 .../net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h   |  206 +
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h | 1374 ++++++
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |  708 +++
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |  144 +
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h | 2341 +++++++++
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    | 2194 +++++++++
 .../net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h |  564 +++
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |   75 +
 drivers/net/dpa/NetCommSw/inc/core_ext.h           |   81 +
 drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h   |  402 ++
 drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h      |  130 +
 drivers/net/dpa/NetCommSw/inc/ctype_ext.h          |   96 +
 drivers/net/dpa/NetCommSw/inc/debug_ext.h          |  259 +
 drivers/net/dpa/NetCommSw/inc/endian_ext.h         |  446 ++
 drivers/net/dpa/NetCommSw/inc/enet_ext.h           |  154 +
 drivers/net/dpa/NetCommSw/inc/error_ext.h          |  553 +++
 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h       |  357 ++
 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h        |  317 ++
 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h     |  173 +
 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h         |  300 ++
 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h     |  125 +
 .../inc/integrations/P1023/dpaa_integration_ext.h  |  333 ++
 .../NetCommSw/inc/integrations/P1023/part_ext.h    |   81 +
 .../inc/integrations/P1023/part_integration_ext.h  |  689 +++
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |  450 ++
 .../inc/integrations/P3040_P4080_P5020/part_ext.h  |   83 +
 .../P3040_P4080_P5020/part_integration_ext.h       |  331 ++
 drivers/net/dpa/NetCommSw/inc/math_ext.h           |   98 +
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |  413 ++
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |  391 ++
 drivers/net/dpa/NetCommSw/inc/std_ext.h            |   48 +
 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h         |   48 +
 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h         |  161 +
 drivers/net/dpa/NetCommSw/inc/string_ext.h         |   55 +
 drivers/net/dpa/NetCommSw/inc/types_ext.h          |  111 +
 drivers/net/dpa/NetCommSw/inc/xx_ext.h             |  880 ++++
 .../net/dpa/NetCommSw/integrations/P1023/Makefile  |    9 +
 .../NetCommSw/integrations/P1023/module_strings.c  |   74 +
 .../integrations/P3040_P4080_P5020/Makefile        |    9 +
 .../P3040_P4080_P5020/module_strings.c             |   62 +
 drivers/net/dpa/NetCommSw/ncsw_config.mk           |   33 +
 drivers/net/dpa/NetCommSw/p1023_dflags.h           |   67 +
 drivers/net/dpa/NetCommSw/p3040_4080_5020_dflags.h |   64 +
 drivers/net/dpa/NetCommSw/src/Makefile             |   13 +
 drivers/net/dpa/NetCommSw/src/inc/procbuff_ext.h   |   58 +
 .../dpa/NetCommSw/src/inc/system/platform_ext.h    |  209 +
 .../src/inc/system/platform_p4080_ds_ext.h         |   64 +
 drivers/net/dpa/NetCommSw/src/inc/system/sys_ext.h |  928 ++++
 .../net/dpa/NetCommSw/src/inc/system/sys_io_ext.h  |   46 +
 drivers/net/dpa/NetCommSw/src/inc/types_linux.h    |  200 +
 .../src/inc/wrappers/Peripherals/fsl_fman.h        |  272 ++
 .../src/inc/wrappers/Peripherals/fsl_fman_test.h   |   83 +
 .../src/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |  162 +
 .../src/modules/integrations/P4080/FM/Makefile     |   11 +
 .../src/modules/integrations/P4080/FM/fmm.c        |  205 +
 .../src/modules/integrations/P4080/FM/mod_config.h |   41 +
 drivers/net/dpa/NetCommSw/src/system/Makefile      |   13 +
 .../NetCommSw/src/system/platform/P4080/Makefile   |   11 +
 .../src/system/platform/P4080/platform_p4080_ds.c  |  122 +
 drivers/net/dpa/NetCommSw/src/system/sys_io.c      |  189 +
 drivers/net/dpa/NetCommSw/src/util/Makefile        |   11 +
 drivers/net/dpa/NetCommSw/src/util/procbuff.c      |  121 +
 drivers/net/dpa/NetCommSw/src/util/procbuff.h      |   48 +
 .../NetCommSw/src/wrappers/Peripherals/FM/Makefile |   16 +
 .../src/wrappers/Peripherals/FM/fm_compat_ioctls.h |  377 ++
 .../src/wrappers/Peripherals/FM/fman_test.c        | 1029 ++++
 .../src/wrappers/Peripherals/FM/lnxwrp_fm.c        | 3050 ++++++++++++
 .../src/wrappers/Peripherals/FM/lnxwrp_fm.h        |  201 +
 .../Peripherals/FM/lnxwrp_fm_compat_ioctls.c       |  789 +++
 .../src/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c | 2444 ++++++++++
 drivers/net/dpa/NetCommSw/src/xx/Makefile          |   17 +
 drivers/net/dpa/NetCommSw/src/xx/ctype.c           |   67 +
 .../net/dpa/NetCommSw/src/xx/integrations/Makefile |    9 +
 .../NetCommSw/src/xx/integrations/P4080/Makefile   |   13 +
 .../src/xx/integrations/P4080/xx_integration.c     |  202 +
 drivers/net/dpa/NetCommSw/src/xx/stdlib.c          |  264 +
 drivers/net/dpa/NetCommSw/src/xx/udivdi3.c         |  132 +
 drivers/net/dpa/NetCommSw/src/xx/xx.h              |   48 +
 drivers/net/dpa/NetCommSw/src/xx/xx_linux.c        |  929 ++++
 include/linux/Kbuild                               |    1 +
 include/linux/fmd/Kbuild                           |    5 +
 include/linux/fmd/Peripherals/Kbuild               |    4 +
 include/linux/fmd/Peripherals/fm_ioctls.h          |  324 ++
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      | 1534 ++++++
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |  662 +++
 include/linux/fmd/Peripherals/fm_test_ioctls.h     |  208 +
 include/linux/fmd/integrations/Kbuild              |    1 +
 .../linux/fmd/integrations/integration_ioctls.h    |   47 +
 include/linux/fmd/ioctls.h                         |   96 +
 include/linux/fmd/net_ioctls.h                     |  383 ++
 143 files changed, 71966 insertions(+), 11 deletions(-)
 create mode 100644 Documentation/networking/fman.txt
 create mode 100644 drivers/net/dpa/NetCommSw/Kconfig
 create mode 100644 drivers/net/dpa/NetCommSw/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/etc/error.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/list.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/memcpy.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.c
 create mode 100644 drivers/net/dpa/NetCommSw/etc/mm.h
 create mode 100644 drivers/net/dpa/NetCommSw/etc/sprint.c
 create mode 100644 drivers/net/dpa/NetCommSw/events_mapping.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/core_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ctype_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/debug_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/endian_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/enet_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/error_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/math_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/net_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/std_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/string_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/types_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/xx_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P1023/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P1023/module_strings.c
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
 create mode 100644 drivers/net/dpa/NetCommSw/ncsw_config.mk
 create mode 100644 drivers/net/dpa/NetCommSw/p1023_dflags.h
 create mode 100644 drivers/net/dpa/NetCommSw/p3040_4080_5020_dflags.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/procbuff_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/system/platform_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/system/platform_p4080_ds_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/system/sys_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/system/sys_io_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/types_linux.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman_test.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/fmm.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/mod_config.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/system/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/system/platform/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/system/platform/P4080/platform_p4080_ds.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/system/sys_io.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/util/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/util/procbuff.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/util/procbuff.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fm_compat_ioctls.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fman_test.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_compat_ioctls.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/ctype.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/integrations/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/xx_integration.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/stdlib.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/udivdi3.c
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/xx.h
 create mode 100644 drivers/net/dpa/NetCommSw/src/xx/xx_linux.c
 create mode 100644 include/linux/fmd/Kbuild
 create mode 100644 include/linux/fmd/Peripherals/Kbuild
 create mode 100644 include/linux/fmd/Peripherals/fm_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_pcd_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_port_ioctls.h
 create mode 100644 include/linux/fmd/Peripherals/fm_test_ioctls.h
 create mode 100644 include/linux/fmd/integrations/Kbuild
 create mode 100644 include/linux/fmd/integrations/integration_ioctls.h
 create mode 100644 include/linux/fmd/ioctls.h
 create mode 100644 include/linux/fmd/net_ioctls.h

diff --git a/Documentation/networking/fman.txt b/Documentation/networking/fman.txt
new file mode 100644
index 0000000..a2d7f6d
--- /dev/null
+++ b/Documentation/networking/fman.txt
@@ -0,0 +1,232 @@
+The FMan driver
+Sysfs file description
+
+Author: Andrei Sorin Pistirica <sorin.pistirica@freescale.com>
+Updated: 2010-12-08
+
+FMAN SYSFS statistics counters
+------------------------------
+The document contains statistics counters description for every type of
+FMAN port and for all FMAN modules  as well (FMAN, FMAN:DMA and FMAN:PCD).
+Every counter is related to a specific register mapped as well.
+
+Port type: Tx
+-------------
+port_frame: FMBM_TFRC
+    "counts the total number of frames flowing on the Tx port, regardless of
+     whether they got transmitted or discarded."
+
+port_discard_frame: FMBM_TFDC
+    "counts the number of frames that were discarded due to DMA error indication
+     that was sensed during the process of frame payload or frame context
+     loading."
+
+port_dealloc_buf:FMBM_TBDC
+    "counts the number of buffer deallocate operations."
+
+port_enq_total:FMQM_PnETFC
+    "counts the number of enqueue operations preformed for this portID."
+
+port_length_err:FMBM_TFLEDC
+    "counts the number of frames that were discarded due to frame length error."
+
+port_unsupprted_format:FMBM_TFUFDC
+    "counts the number of frames that were discarded due to frame format
+     error - frame descriptor contains unsupported format."
+
+port_deq_total:FMQM_PnDTFC
+    "counts the total number of FDs that dequeued from the QMan for this
+     portID."
+
+port_deq_from_default:FMQM_PnDDCFQC
+    "counts the number of time the portID used the default confirmation FQID
+     from the BMI.s FMBM_TDCFQID"
+
+port_deq_confirm:FMQM_PnDCC
+    "counts the number of times the PortID got a FD from the dequeue response
+     that require confirmation."
+
+Port type: Rx
+-------------
+port_frame:FMBM_RFRC
+    "counts the total number of frames received on the Rx port."
+
+port_discard_frame:FMBM_RFDC
+    "counts the number of frames received on the Rx port that were not able
+     to enter the receive queue system due to WRED algorithm."
+
+port_dealloc_buf:FMBM_RBDC
+    "counts the number of buffer deallocate operations."
+
+port_enq_total:FMQM_PnETFC
+    "counts the number of enqueue operations preformed for this portID"
+
+port_rx_bad_frame:FMBM_RBFC
+    "counts the number of frames received on the Rx port with an error
+     indication"
+
+port_rx_large_frame:FMBM_RLFC
+    "counts the number of frames received on the Rx port with an over size
+     indication. Over size indication is marked when frame size exceeds the
+     maximum configured in the corresponding MAC configuration register"
+
+port_rx_out_of_buffers_discard:FMBM_RODC
+    "counts the number of frames received on the Rx port that were not able
+     to enter the receive queue system due to lack of external buffers, or
+     the lack of suitable buffers that cause the S/G list to grow beyond 16
+     entries, or the lack of suitable buffer to hold S/G list (including
+     start margin), or the lack of suitable buffer to hold the frame header
+     (including start margin)."
+
+port_rx_filter_frame:FMBM_RFFC
+    "counts the number of frames received on the Rx port that were filtered
+     out by the parse and classify modules of the Fman"
+
+Port type: Oh
+-------------
+Oh ports have the same counters as RX and TX ports. The counters are listed
+below and the description can be found at the other ports (above):
+    port_frame
+    port_discard_frame
+    port_dealloc_buf
+    port_enq_total
+    port_length_err
+    port_unsupprted_format
+    port_deq_total
+    port_deq_from_default
+    port_deq_confirm
+    port_rx_bad_frame
+    port_rx_large_frame
+    port_rx_out_of_buffers_discard
+
+Fman:
+-----
+enq_total_frame:FMQM_ETFC
+    "counts the total number of enqueue operations the QMI performed."
+
+deq_total_frame:FMQM_DTFC
+    "counts the total number of FDs that dequeued from the Qman."
+
+deq_0:FMQM_DC0
+    "counts the number of times the QMI received a NULL FD from the QMan as a
+     response to a dequeue request (command)"
+
+deq_1:FMQM_DC1
+    "counts the number of times the QMI got 1 FD from the QMan as a response
+     to a dequeue request (command)"
+
+deq_2:FMQM_DC2
+    "counts the number of times the QMI got 2 FD from the QMan as a response
+     to a dequeue request (command)"
+
+deq_from_default:FMQM_DDCFQC
+    "counts the number of times the QMI used the default confirmation FQID
+     from the BMI's FMBM_TCFQID"
+
+deq_from_context:FMQM_CBCFQC
+    "counts the number of times the QMI used the override confirmation FQID
+     from the FD command field"
+
+deq_from_fd:FMQM_DFOCFQC
+    "counts the number of times the QMI used the override confirmation FQID
+     from the FD command field"
+
+deq_confirm:(FMQM_DCC
+    "counts the number of times the QMI gets an FD from the dequeue response
+     that requires confirmation"
+
+Fman: DMA
+---------
+The FMAN:DMA counters are read from FMDMSR register. They reports bus error
+events that are recognized by the FMan DMA controller on all of the
+FMan DMA channels.
+    The counters are:
+        cmq_not_empty
+        bus_error
+        read_buf_ecc_error
+        write_buf_ecc_sys_error
+        write_buf_ecc_fm_error
+
+Fman: PCD
+---------
+pcd_kg_total:FMKG_TPC
+    "count of packets passed in the keygen on all schemes"
+
+pcd_plcr_yellow:FMPL_YPC
+    "counts the total number of YELLOW packets that exit the Policer"
+
+pcd_plcr_red:FMPL_RPC
+    "counter counts the total number of RED packets that exit the Policer"
+
+pcd_plcr_recolored_to_red:FMPL_RRPC
+    "counts the number of packets that changed color to RED by the Policer"
+
+pcd_plcr_recolored_to_yellow:FMPL_RYPC
+    "counts the number of packets that changed color to YELLOW by the Policer"
+
+pcd_plcr_total:FMPL_TPC
+    "counts the total number of packets passed in the Policer"
+
+pcd_plcr_length_mismatch:FMPL_FLMC
+    "counts the number of packets with length mismatch indicated by an offset
+     value of 0xFF in the selected parser result entry or when the calculated
+     frame offset result is greater than the packet full length provided by
+     FD length"
+
+pcd_prs_parse_dispatch:FMPR_PDS
+    "counts the number of times the parser block was dispatched by FPM"
+
+pcd_prs_l2_parse_result_returned:FMPR_L2RRS
+    "counts the number of times L2 parse result was returned (including with
+     errors)"
+
+pcd_prs_l3_parse_result_returned:FMPR_L3RRS
+    "counts the number of times L3 parse result was returned (including with
+     errors)
+
+pcd_prs_l4_parse_result_returned:FMPR_L4RRS
+    "counts the number of times L4 parse result was returned (including with
+     errors)"
+
+pcd_prs_shim_parse_result_returned:FMPR_SRRS
+    "counts the number of times Shim parse result was returned (including with
+     errors)"
+
+pcd_prs_l2_parse_result_returned_with_err:FMPR_L2RRES
+    "counts the number of times L2 parse result was returned with errors"
+
+pcd_prs_l3_parse_result_returned_with_err:FMPR_L3RRES
+    "counts the number of times L3 parse result was returned with errors"
+
+pcd_prs_l4_parse_result_returned_with_err:FMPR_L4RRES
+    "counts the number of times L4 parse result was returned with errors"
+
+pcd_prs_shim_parse_result_returned_with_err:FMPR_SRRES
+    "counts the number of times Shim parse result was returned with errors"
+
+pcd_prs_soft_prs_cycles:FMPR_SPCS
+    "counts the number of cycles spent executing soft parser instruction
+     (including stall cycles)"
+
+pcd_prs_soft_prs_stall_cycles:FMPR_SPSCS
+    "counts the number of cycles stalled waiting for parser internal memory
+     reads while executing soft parser instruction."
+
+pcd_prs_hard_prs_cycle_incl_stall_cycles:FMPR_HXSCS
+    "counts the number of cycles spent executing hard parser (including stall
+     cycles)"
+
+pcd_prs_muram_read_cycles:FMPR_MRCS
+    "counts the number of cycles while performing FMan Memory read"
+
+pcd_prs_muram_read_stall_cycles:FMPR_MRSCS
+    "counts the number of cycles stalled while performing FMan Memory read"
+
+pcd_prs_muram_write_cycles:FMPR_MWCS
+    "counts the number of cycles while performing FMan Memory write"
+
+pcd_prs_muram_write_stall_cycles:FMPR_MWSCS
+    "counts the number of cycles stalled while performing FMan Memory write"
+
+pcd_prs_fpm_command_stall_cycles:FMPR_FCSCS
+    "counts the number of cycles stalled while performing a FPM command"
diff --git a/arch/powerpc/include/asm/immap_qe.h b/arch/powerpc/include/asm/immap_qe.h
index 4e10f50..c1b805e 100644
--- a/arch/powerpc/include/asm/immap_qe.h
+++ b/arch/powerpc/include/asm/immap_qe.h
@@ -1,18 +1,45 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /*
  * QUICC Engine (QE) Internal Memory Map.
  * The Internal Memory Map for devices with QE on them. This
  * is the superset of all QE devices (8360, etc.).
-
- * Copyright (C) 2006. Freescale Semicondutor, Inc. All rights reserved.
  *
  * Authors: 	Shlomi Gridish <gridish@freescale.com>
  * 		Li Yang <leoli@freescale.com>
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
+
 #ifndef _ASM_POWERPC_IMMAP_QE_H
 #define _ASM_POWERPC_IMMAP_QE_H
 #ifdef __KERNEL__
@@ -469,11 +496,11 @@ extern phys_addr_t get_qe_base(void);
 
 static inline unsigned long immrbar_virt_to_phys(void *address)
 {
-	if ( ((u32)address >= (u32)qe_immr) &&
-			((u32)address < ((u32)qe_immr + QE_IMMAP_SIZE)) )
-		return (unsigned long)(address - (u32)qe_immr +
-				(u32)get_qe_base());
-	return (unsigned long)virt_to_phys(address);
+	if ( ((uintptr_t )address >= (uintptr_t )qe_immr) &&
+			((uintptr_t )address < ((uintptr_t )qe_immr + QE_IMMAP_SIZE)) )
+		return (unsigned long)(address - (uintptr_t )qe_immr +
+				(uintptr_t )get_qe_base());
+	return (phys_addr_t)virt_to_phys(address);
 }
 
 #endif /* __KERNEL__ */
diff --git a/drivers/Kconfig b/drivers/Kconfig
index a6481af..17384e1 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -113,4 +113,6 @@ source "drivers/staging/Kconfig"
 source "drivers/platform/Kconfig"
 
 source "drivers/wrhv/Kconfig"
+
+source "drivers/net/dpa/NetCommSw/Kconfig"
 endmenu
diff --git a/drivers/net/dpa/NetCommSw/Kconfig b/drivers/net/dpa/NetCommSw/Kconfig
new file mode 100644
index 0000000..cf84529
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Kconfig
@@ -0,0 +1,34 @@
+menu "Frame Manager support"
+
+menuconfig FSL_FMAN
+	bool "Freescale Frame Manager (datapath) support"
+	# depends on PPC_E500MC
+	default y
+	---help---
+	  If unsure, say Y.
+
+if FSL_FMAN
+
+config FSL_FMAN_TEST
+	bool "FMan test module"
+	default n
+	---help---
+	  This option compiles test code for FMan.
+
+menu "FMAN Processor support"
+choice
+	depends on FSL_FMAN
+	prompt "Processor Type"
+
+config FMAN_P3040_P4080_P5020
+	bool "P3040 P4080 5020"
+
+config FMAN_P1023
+        bool "P1023"
+
+endchoice
+endmenu
+
+endif # FSL_FMAN
+
+endmenu
diff --git a/drivers/net/dpa/NetCommSw/Makefile b/drivers/net/dpa/NetCommSw/Makefile
new file mode 100644
index 0000000..f1c9ab3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= etc/
+obj-${CONFIG_FMAN_P3040_P4080_P5020}	+= integrations/P3040_P4080_P5020/
+obj-${CONFIG_FMAN_P1023} 	        += integrations/P1023/
+obj-y		+= Peripherals/FM/
+obj-y		+= src/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
new file mode 100644
index 0000000..3ec3824
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Hc.o
+
+fsl-ncsw-Hc-objs	:=   hc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
new file mode 100644
index 0000000..83681b1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -0,0 +1,1956 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "string_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+
+
+#define HC_HCOR_OPCODE_PLCR_PRFL                                0x0
+#define HC_HCOR_OPCODE_KG_SCM                                   0x1
+#define HC_HCOR_OPCODE_SYNC                                     0x2
+#define HC_HCOR_OPCODE_CC                                       0x3
+#define HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT                 0x5
+#ifdef FM_RMU_ASSIST_SUPPORT
+#define HC_HCOR_OPCODE_RMU_DRBL_INIT                            0x6
+#define HC_HCOR_OPCODE_RMU_DRBL_SET_CNTS                        0x7
+#define HC_HCOR_OPCODE_RMU_DRBL_FREE                            0x8
+#define HC_HCOR_OPCODE_RMU_MSG_INIT                             0x9
+#define HC_HCOR_OPCODE_RMU_MSG_CHANGE_CLASSIFICATION_ENTRY      0xA
+#define HC_HCOR_OPCODE_RMU_MSG_CHANGE_BUFFER_PROFILE_ENTRY      0xB
+#define HC_HCOR_OPCODE_RMU_MSG_FREE                             0xC
+#endif /* FM_RMU_ASSIST_SUPPORT */
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT                     0xC
+#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION                0x11
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+#define HC_HCOR_GBL                         0x20000000
+
+#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
+#define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
+#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdPlcrInterModuleProfileRegs))
+#define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
+#define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
+
+#define BUILD_FD(len)                     \
+do {                                      \
+    memset(&fmFd, 0, sizeof(t_DpaaFD));   \
+    DPAA_FD_SET_ADDR(&fmFd, p_HcFrame);    \
+    DPAA_FD_SET_OFFSET(&fmFd, 0);         \
+    DPAA_FD_SET_LENGTH(&fmFd, len);       \
+} while (0)
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
+    volatile uint32_t kgse_mode;    /**< MODE */
+    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
+    volatile uint32_t kgse_hc;      /**< Hash Command */
+    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
+    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                    /**< Generic Extract Command */
+    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
+
+typedef _Packed struct t_FmPcdKgPortRegs {
+    volatile uint32_t                       spReg;
+    volatile uint32_t                       cppReg;
+} _PackedType t_FmPcdKgPortRegs;
+
+typedef _Packed struct t_HcFrame {
+    volatile uint32_t                           opcode;
+    volatile uint32_t                           actionReg;
+    volatile uint32_t                           extraReg;
+    volatile uint32_t                           commandSequence;
+    union {
+        t_FmPcdKgInterModuleSchemeRegs          schemeRegs;
+        t_FmPcdKgInterModuleSchemeRegs          schemeRegsWithoutCounter;
+        t_FmPcdPlcrInterModuleProfileRegs       profileRegs;
+        volatile uint32_t                       singleRegForWrite;    /* for writing SP, CPP, profile counter */
+        t_FmPcdKgPortRegs                       portRegsForRead;
+        volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
+        t_FmPcdCcCapwapReassmTimeoutParams      ccCapwapReassmTimeout;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        t_FmPcdCcIpReassmTimeoutParams          ccIpReassmTimeout;
+        t_FmPcdCcIpFragInitParams               ccIpFragInitialization;
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+#ifdef FM_RMU_ASSIST_SUPPORT
+        t_FmRmuDrblInitHcData                   drblInitHcData;
+        t_FmRmuDrblSetCntsHcData                drblSetCntsHcData;
+        t_FmRmuMsgInitHcData                    msgInitHcData;
+        t_FmRmuMsgClassChangeHcData             msgClassChangeHcData;
+        t_FmRmuBufferProfileChangeHcData        bufferProfileChangeHcData;
+        t_FmRmuMsgFreeHcData                    msgFreeHcData;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+    } hcSpecificData;
+} _PackedType t_HcFrame;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct t_FmHc {
+    t_Handle                    h_FmPcd;
+    t_Handle                    h_HcPortDev;
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enqueing frames to the QM */
+    t_Handle                    h_QmArg;          /**< A handle to the QM module */
+
+    uint32_t                    seqNum;
+    volatile bool               wait[32];
+} t_FmHc;
+
+
+static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, volatile uint32_t *p_SeqNum)
+{
+    t_Error     err = E_OK;
+    uint32_t    savedSeqNum;
+    uint32_t    intFlags;
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    *p_SeqNum = p_FmHc->seqNum;
+    savedSeqNum = p_FmHc->seqNum;
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);
+    p_FmHc->wait[savedSeqNum] = TRUE;
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    DBG(TRACE, ("Send Hc, SeqNum %d, FD@0x%x, fd offset 0x%x",
+                savedSeqNum,DPAA_FD_GET_ADDR(p_FmFd),DPAA_FD_GET_OFFSET(p_FmFd)));
+    err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, (void *)p_FmFd);
+    if(err)
+        RETURN_ERROR(MINOR, err, ("HC enqueue failed"));
+
+    while (p_FmHc->wait[savedSeqNum]) ;
+
+    return err;
+}
+
+static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, t_Handle p_OldPointer, t_Handle p_NewPointer)
+{
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC);
+    p_HcFrame->actionReg  = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_NewPointer);
+    if(p_HcFrame->actionReg == ILLEGAL_BASE)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    }
+
+    p_HcFrame->actionReg  |=  0xc0000000;
+        p_HcFrame->extraReg   = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_OldPointer);
+    if(p_HcFrame->extraReg == ILLEGAL_BASE)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    }
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+static t_Error HcDynamicChange(t_FmHc *p_FmHc,t_List *h_OldPointersLst, t_List *h_NewPointersLst, t_Handle *h_Params)
+{
+
+    t_List      *p_PosOld, *p_PosNew;
+    uint16_t    i = 0;
+    t_Error     err = E_OK;
+    uint8_t     numOfModifiedPtr;
+
+    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_NewPointersLst) == LIST_NumOfObjs(h_OldPointersLst)),E_INVALID_STATE);
+
+    numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_NewPointersLst);
+    p_PosNew = LIST_FIRST(h_NewPointersLst);
+    p_PosOld = LIST_FIRST(h_OldPointersLst);
+    for(i = 0; i < numOfModifiedPtr; i++)
+    {
+        err = CcHcDoDynamicChange(p_FmHc, p_PosOld, p_PosNew);
+        if(err)
+        {
+            FmPcdCcReleaseModifiedDataStructure(p_FmHc->h_FmPcd, h_OldPointersLst, h_NewPointersLst, i, h_Params);
+            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
+        }
+        p_PosNew = LIST_NEXT(p_PosNew);
+        p_PosOld = LIST_NEXT(p_PosOld);
+    }
+
+    err = FmPcdCcReleaseModifiedDataStructure(p_FmHc->h_FmPcd, h_OldPointersLst, h_NewPointersLst, i, h_Params);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
+{
+    t_FmHc          *p_FmHc;
+    t_FmPortParams  fmPortParam;
+    t_Error         err = E_OK;
+
+    p_FmHc = (t_FmHc *)XX_Malloc(sizeof(t_FmHc));
+    if (!p_FmHc)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC obj"));
+        return NULL;
+    }
+    memset(p_FmHc,0,sizeof(t_FmHc));
+
+    p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
+    p_FmHc->f_QmEnqueue         = p_FmHcParams->params.f_QmEnqueue;
+    p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
+
+    if (!FmIsMaster(p_FmHcParams->h_Fm))
+        return (t_Handle)p_FmHc;
+
+    memset(&fmPortParam, 0, sizeof(fmPortParam));
+    fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
+    fmPortParam.portType    = e_FM_PORT_TYPE_OH_HOST_COMMAND;
+    fmPortParam.portId      = p_FmHcParams->params.portId;
+    fmPortParam.liodnBase   = p_FmHcParams->params.liodnBase;
+    fmPortParam.h_Fm        = p_FmHcParams->h_Fm;
+
+    fmPortParam.specificParams.nonRxParams.errFqid      = p_FmHcParams->params.errFqid;
+    fmPortParam.specificParams.nonRxParams.dfltFqid     = p_FmHcParams->params.confFqid;
+    fmPortParam.specificParams.nonRxParams.qmChannel    = p_FmHcParams->params.qmChannel;
+
+    p_FmHc->h_HcPortDev = FM_PORT_Config(&fmPortParam);
+    if(!p_FmHc->h_HcPortDev)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        XX_Free(p_FmHc);
+        return NULL;
+    }
+
+    /* final init */
+    if ((err = FM_PORT_Init(p_FmHc->h_HcPortDev)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+
+    if ((err = FM_PORT_Enable(p_FmHc->h_HcPortDev)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+
+    return (t_Handle)p_FmHc;
+}
+
+void FmHcFree(t_Handle h_FmHc)
+{
+    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+
+    if (!p_FmHc)
+        return;
+
+    if (p_FmHc->h_HcPortDev)
+        FM_PORT_Free(p_FmHc->h_HcPortDev);
+
+    XX_Free(p_FmHc);
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmHcDumpRegs(t_Handle h_FmHc)
+{
+    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmHc->h_HcPortDev, E_INVALID_HANDLE);
+
+    return  FM_PORT_DumpRegs(p_FmHc->h_HcPortDev);
+
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame   *p_HcFrame;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_FmHc);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    p_HcFrame  = (t_HcFrame *)PTR_MOVE(DPAA_FD_GET_ADDR(p_Fd), DPAA_FD_GET_OFFSET(p_Fd));
+
+    DBG(TRACE, ("Hc Conf, SeqNum %d, FD@0x%x, fd offset 0x%x",
+                p_HcFrame->commandSequence, DPAA_FD_GET_ADDR(p_Fd), DPAA_FD_GET_OFFSET(p_Fd)));
+
+    if (!(p_FmHc->wait[p_HcFrame->commandSequence]))
+        REPORT_ERROR(MINOR, E_INVALID_FRAME, ("Not an Host-Command frame received!"));
+    else
+        p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+}
+
+t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err = E_OK;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_HcFrame                           *p_HcFrame;
+    t_DpaaFD                            fmFd;
+    uint32_t                            intFlags;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        return NULL;
+    }
+
+    if(!p_Scheme->modify)
+    {
+        /* check that schemeId is in range */
+        if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE))
+        {
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+
+        physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
+
+        memset(p_HcFrame, 0, sizeof(t_HcFrame));
+        p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+        p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        p_HcFrame->extraReg = 0xFFFFF800;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+
+        /* check if this scheme is already used */
+        if (FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+    }
+    else
+    {
+        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+        err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, TRUE);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        if (err)
+        {
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+    }
+
+    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs);
+    if(err)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return NULL;
+    }
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+    p_HcFrame->extraReg = 0xFFFFF800;
+    memcpy(&p_HcFrame->hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    if(!p_Scheme->schemeCounter.update)
+        memcpy((void*)&p_HcFrame->hcSpecificData.schemeRegs.kgse_dv0,
+               (void*)&schemeRegs.kgse_dv0,
+               4*sizeof(uint32_t));
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return NULL;
+    }
+
+    FmPcdKgValidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    XX_Free(p_HcFrame);
+
+    return UINT_TO_PTR((uint64_t)physicalSchemeId+1);
+}
+
+t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+    uint8_t     relativeSchemeId;
+    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    }
+
+    err = FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+    if (err)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    }
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    p_HcFrame->extraReg = 0xFFFFF800;
+    memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    FmPcdKgInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+    uint8_t     relativeSchemeId;
+    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    uint32_t    tmpReg32 = 0;
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Lock of the scheme FAILED"));
+
+    if(!FmPcdKgGetPointedOwners(p_FmHc->h_FmPcd, relativeSchemeId) ||
+       !(FmPcdKgGetRequiredAction(p_FmHc->h_FmPcd, relativeSchemeId) & requiredAction))
+    {
+
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        {
+            if((FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_DONE) && (FmPcdKgGetDoneAction(p_FmHc->h_FmPcd, relativeSchemeId) ==  e_FM_PCD_ENQ_FRAME))
+
+            {
+                p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+                if (!p_HcFrame)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+                memset(p_HcFrame, 0, sizeof(t_HcFrame));
+                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+                p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+                p_HcFrame->extraReg = 0xFFFFF800;
+                BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_Free(p_HcFrame);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                /* check if this scheme is already used */
+                if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_Free(p_HcFrame);
+                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+                }
+                tmpReg32 = GET_UINT32(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode);
+
+                ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+                WRITE_UINT32(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode, tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA);
+
+// was this memset really unnecessary?
+//                memset(p_HcFrame, 0, sizeof(t_HcFrame));
+                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+                p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+                p_HcFrame->extraReg = 0x80000000;
+
+                BUILD_FD(sizeof(t_HcFrame));
+
+                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_Free(p_HcFrame);
+                    REPORT_ERROR(MINOR, err, NO_MSG);
+                }
+
+                XX_Free(p_HcFrame);
+            }
+            else if (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_PLCR)
+            {
+
+                if((FmPcdKgIsDirectPlcr(p_FmHc->h_FmPcd, relativeSchemeId) == FALSE) ||
+                    (FmPcdKgIsDistrOnPlcrProfile(p_FmHc->h_FmPcd, relativeSchemeId) == TRUE))
+                 {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
+                 }
+                err = FmPcdPlcrCcGetSetParams(p_FmHc->h_FmPcd, FmPcdKgGetRelativeProfileId(p_FmHc->h_FmPcd, relativeSchemeId), requiredAction);
+                if(err)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+        }
+      }
+    }
+
+    FmPcdKgUpatePointedOwner(p_FmHc->h_FmPcd, relativeSchemeId,TRUE);
+    FmPcdKgUpdateRequiredAction(p_FmHc->h_FmPcd, relativeSchemeId,requiredAction);
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return E_OK;
+}
+
+uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+    uint32_t    retVal;
+    uint8_t     relativeSchemeId;
+    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+        return 0;
+    }
+
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, ("Scheme lock"));
+        return 0;
+    }
+
+    /* first read scheme and check that it is valid */
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        return 0;
+    }
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    p_HcFrame->extraReg = 0xFFFFF800;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return 0;
+    }
+
+    if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+        XX_Free(p_HcFrame);
+        return 0;
+    }
+
+    retVal = p_HcFrame->hcSpecificData.schemeRegs.kgse_spc;
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    XX_Free(p_HcFrame);
+
+    return retVal;
+}
+
+t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+    uint8_t     relativeSchemeId, physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /* first read scheme and check that it is valid */
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    p_HcFrame->extraReg = 0xFFFFF800;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* check that scheme is valid */
+    if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+    }
+
+    /* Write scheme back, with modified counter */
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    p_HcFrame->extraReg = 0xFFFFF800;
+    /* write counter */
+    p_HcFrame->hcSpecificData.schemeRegs.kgse_spc = value;
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    int                     i;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        memset(p_HcFrame, 0, sizeof(t_HcFrame));
+        p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+        p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+        p_HcFrame->extraReg = 0xFFFFF800;
+        memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void*)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(volatile uint32_t));
+
+        BUILD_FD(sizeof(t_HcFrame));
+
+        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+        {
+            XX_Free(p_HcFrame);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+    XX_Free(p_HcFrame);
+
+    return err;
+}
+
+
+t_Error FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t  grpId)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdKgInterModuleClsPlanSet      *p_clsPlanSet;
+
+    p_clsPlanSet = XX_Malloc(sizeof(*p_clsPlanSet));
+    if (!p_clsPlanSet)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_clsPlanSetd"));
+    /* clear clsPlan entries in memory */
+    p_clsPlanSet->baseEntry = FmPcdKgGetClsPlanGrpBase(p_FmHc->h_FmPcd, grpId);
+    p_clsPlanSet->numOfClsPlanEntries = FmPcdKgGetClsPlanGrpSize(p_FmHc->h_FmPcd, grpId);
+    ASSERT_COND(p_clsPlanSet->numOfClsPlanEntries <= FM_PCD_MAX_NUM_OF_CLS_PLANS);
+    memset(p_clsPlanSet->vectors, 0, p_clsPlanSet->numOfClsPlanEntries*sizeof(uint32_t));
+
+    FmHcPcdKgSetClsPlan(p_FmHc, p_clsPlanSet);
+
+    FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
+    XX_Free(p_clsPlanSet);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams )
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame                           *p_HcFrame;
+    uint32_t                            intFlags;
+    t_DpaaFD                            fmFd;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT);
+    memcpy(&p_HcFrame->hcSpecificData.ccCapwapReassmTimeout, p_CcCapwapReassmTimeoutParams, sizeof(t_FmPcdCcCapwapReassmTimeoutParams));
+    BUILD_FD(sizeof(t_HcFrame));
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    return E_OK;
+}
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+t_Error FmHcPcdCcIpFrag(t_Handle h_FmHc, t_FmPcdCcIpFragInitParams *p_CcIpFragInitialization)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame                           *p_HcFrame;
+    uint32_t                            intFlags;
+    t_DpaaFD                            fmFd;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION);
+    memcpy(&p_HcFrame->hcSpecificData.ccIpFragInitialization, p_CcIpFragInitialization, sizeof(t_FmPcdCcIpFragInitParams));
+    BUILD_FD(sizeof(t_HcFrame));
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    
+    return E_OK;
+}
+
+t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams )
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame                           *p_HcFrame;
+    uint32_t                            intFlags;
+    t_DpaaFD                            fmFd;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
+    memcpy(&p_HcFrame->hcSpecificData.ccIpReassmTimeout, p_CcIpReassmTimeoutParams, sizeof(t_FmPcdCcIpReassmTimeoutParams));
+    BUILD_FD(sizeof(t_HcFrame));
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    return E_OK;
+}
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction)
+{
+    t_FmHc              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame           *p_HcFrame;
+    t_DpaaFD            fmFd;
+    t_Error             err;
+    uint32_t            tmpReg32 = 0;
+    uint32_t            requiredActionTmp, pointedOwnersTmp;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
+        return ERROR_CODE(E_BUSY);
+
+
+    requiredActionTmp = FmPcdPlcrGetRequiredAction(p_FmHc->h_FmPcd, absoluteProfileId);
+    pointedOwnersTmp = FmPcdPlcrGetPointedOwners(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    if(!pointedOwnersTmp || !(requiredActionTmp & requiredAction))
+    {
+
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        {
+
+            p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+            if (!p_HcFrame)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+            /* first read scheme and check that it is valid */
+            memset(p_HcFrame, 0, sizeof(t_HcFrame));
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+            p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+            p_HcFrame->extraReg = 0x00008000;
+
+            BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            {
+                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            /* check that profile is valid */
+            if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
+            {
+                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+            }
+
+            tmpReg32 = GET_UINT32(p_HcFrame->hcSpecificData.profileRegs.fmpl_pegnia);
+            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            {
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+            }
+            tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+            p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+            p_HcFrame->actionReg |= FmPcdPlcrBuildNiaProfileReg(TRUE, FALSE, FALSE);
+            p_HcFrame->extraReg = 0x00008000;
+            p_HcFrame->hcSpecificData.singleRegForWrite = tmpReg32;
+
+            BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            {
+                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            tmpReg32 = GET_UINT32(p_HcFrame->hcSpecificData.profileRegs.fmpl_peynia);
+            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            {
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+            }
+            tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+            p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+            p_HcFrame->actionReg |= FmPcdPlcrBuildNiaProfileReg(FALSE, TRUE, FALSE);
+            p_HcFrame->extraReg = 0x00008000;
+            p_HcFrame->hcSpecificData.singleRegForWrite = tmpReg32;
+
+            BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            {
+                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            tmpReg32 = GET_UINT32(p_HcFrame->hcSpecificData.profileRegs.fmpl_pernia);
+            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            {
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+            }
+            tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+            p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+            p_HcFrame->actionReg |= FmPcdPlcrBuildNiaProfileReg(FALSE, FALSE, TRUE);
+            p_HcFrame->extraReg = 0x00008000;
+            p_HcFrame->hcSpecificData.singleRegForWrite = tmpReg32;
+
+            BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            {
+                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+                XX_Free(p_HcFrame);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+            XX_Free(p_HcFrame);
+        }
+    }
+
+    FmPcdPlcrUpatePointedOwner(p_FmHc->h_FmPcd, absoluteProfileId, TRUE);
+    FmPcdPlcrUpdateRequiredAction(p_FmHc->h_FmPcd, absoluteProfileId, requiredAction);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return E_OK;
+}
+
+t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
+    t_Error                             err = E_OK;
+    uint32_t                            intFlags;
+    uint16_t                            profileIndx;
+    t_HcFrame                           *p_HcFrame;
+    t_DpaaFD                            fmFd;
+
+    if (p_Profile->modify)
+    {
+        profileIndx = (uint16_t)(PTR_TO_UINT(p_Profile->id.h_Profile)-1);
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, FALSE))
+            return NULL;
+    }
+    else
+    {
+        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+        err = FmPcdPlcrGetAbsoluteProfileId(p_FmHc->h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &profileIndx);
+        if (err)
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        err = FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, TRUE);
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        if (err)
+            return NULL;
+    }
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        return NULL;
+    }
+
+    if(!p_Profile->modify)
+    {
+        memset(p_HcFrame, 0, sizeof(t_HcFrame));
+        p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+        p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
+        p_HcFrame->extraReg = 0x00008000;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+        {
+            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+
+        /* check if this scheme is already used */
+        if (FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
+        {
+            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+            XX_Free(p_HcFrame);
+            return NULL;
+        }
+    }
+
+    memset(&profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_Profile, &profileRegs);
+    if(err)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return NULL;
+    }
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+    p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    p_HcFrame->extraReg = 0x00008000;
+    memcpy(&p_HcFrame->hcSpecificData.profileRegs, &profileRegs, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return NULL;
+    }
+
+    FmPcdPlcrValidateProfileSw(p_FmHc->h_FmPcd, profileIndx);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+
+    XX_Free(p_HcFrame);
+
+    return UINT_TO_PTR((uint64_t)profileIndx+1);
+}
+
+t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
+        return ERROR_CODE(E_BUSY);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+    p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    p_HcFrame->actionReg  |= 0x00008000;
+    p_HcFrame->extraReg = 0x00008000;
+    memset(&p_HcFrame->hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
+        return ERROR_CODE(E_BUSY);
+
+    /* first read scheme and check that it is valid */
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+    p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    p_HcFrame->extraReg = 0x00008000;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+    }
+
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+    p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    p_HcFrame->actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
+    p_HcFrame->extraReg = 0x00008000;
+    p_HcFrame->hcSpecificData.singleRegForWrite = value;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_Error     err = E_OK;
+    t_HcFrame   *p_HcFrame;
+    t_DpaaFD    fmFd;
+    uint32_t    retVal;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
+        return 0;
+
+    /* first read scheme and check that it is valid */
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        return 0;
+    }
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
+    p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    p_HcFrame->extraReg = 0x00008000;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_HcFrame);
+        return 0;
+    }
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        XX_Free(p_HcFrame);
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("invalid Policer profile"));
+        return 0;
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            retVal = p_HcFrame->hcSpecificData.profileRegs.fmpl_pegpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = p_HcFrame->hcSpecificData.profileRegs.fmpl_peypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            retVal = p_HcFrame->hcSpecificData.profileRegs.fmpl_perpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = p_HcFrame->hcSpecificData.profileRegs.fmpl_perypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            retVal = p_HcFrame->hcSpecificData.profileRegs.fmpl_perrpc;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            retVal = 0;
+    }
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    XX_Free(p_HcFrame);
+
+    return retVal;
+}
+
+t_Error FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    uint32_t    intFlags;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Handle    h_Params;
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    err = FmPcdCcTreeTryLock(h_CcTree);
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+    if (err)
+        return err;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    err = FmPcdCcModifyNextEngineParamTree(p_FmHc->h_FmPcd, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams,
+            &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcTreeReleaseLock(h_CcTree);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcTreeReleaseLock(h_CcTree);
+
+    return err;
+}
+
+
+t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_Params;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Error     err = E_OK;
+    t_List      h_List;
+    uint32_t    intFlags;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, p_FmPcdCcNextEngineParams, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_Params;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Error     err = E_OK;
+    t_List      h_List;
+    uint32_t    intFlags;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+
+    err = FmPcdCcRemoveKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return err;
+
+}
+
+t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_Params;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Error     err = E_OK;
+    t_List      h_List;
+    uint32_t    intFlags;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+
+    err = FmPcdCcAddKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex,keySize, p_KeyParams, &h_OldPointersLst,&h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return err;
+}
+
+
+t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Error     err = E_OK;
+    t_List      h_List;
+    uint32_t    intFlags;
+    t_Handle    h_Params;
+
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    err = FmPcdCcModifyKey(p_FmHc->h_FmPcd, h_CcNode, keyIndex, keySize, p_Key, p_Mask, &h_OldPointersLst,&h_NewPointersLst,  &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return err;
+}
+
+t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_List      h_List;
+    uint32_t    intFlags;
+    t_Handle    h_Params;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    err = FmPcdCcModiyNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+    return err;
+}
+
+
+t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst, h_NewPointersLst;
+    t_Error     err = E_OK;
+    t_List      h_List;
+    uint32_t    intFlags;
+    t_Handle    h_Params;
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+        return err;
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmHc->h_FmPcd,h_CcNode,keyIndex,keySize, p_KeyParams, &h_OldPointersLst,&h_NewPointersLst, &h_Params);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+
+    return err;
+}
+
+
+t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    /* first read SP register */
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    p_HcFrame->extraReg = 0xFFFFF800;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* spReg is the first reg, so we can use it both for read and for write */
+    if(add)
+        p_HcFrame->hcSpecificData.portRegsForRead.spReg |= spReg;
+    else
+        p_HcFrame->hcSpecificData.portRegsForRead.spReg &= ~spReg;
+
+    p_HcFrame->actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    /* first read SP register */
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+    p_HcFrame->actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->hcSpecificData.singleRegForWrite = cppReg;
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+t_Error FmHcRmuDoorbellInitCmd(t_Handle h_FmHc, t_FmRmuDrblInitHcParams *p_DrblInitHcParams)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+    ASSERT_COND(p_DrblInitHcParams);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_DRBL_INIT);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    WRITE_UINT64(p_HcFrame->hcSpecificData.drblInitHcData.srioBaseAddr,          p_DrblInitHcParams->srioBaseAddr);
+    WRITE_UINT64(p_HcFrame->hcSpecificData.drblInitHcData.picBaseAddr,           p_DrblInitHcParams->picBaseAddr);
+    WRITE_UINT64(p_HcFrame->hcSpecificData.drblInitHcData.keyMask,               p_DrblInitHcParams->keyMask);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.drblInitHcData.inDrblClassTableBase,  p_DrblInitHcParams->inDrblClassTableBase);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.drblInitHcData.inDrblIntQueueBase,    p_DrblInitHcParams->inDrblIntQueueBase);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.drblInitHcData.inDrblParamsTableBase, p_DrblInitHcParams->inDrblParamsTableBase);
+    WRITE_UINT16(p_HcFrame->hcSpecificData.drblInitHcData.liodnOffset1,          p_DrblInitHcParams->liodnOffset1);
+    WRITE_UINT16(p_HcFrame->hcSpecificData.drblInitHcData.liodnOffset2,          p_DrblInitHcParams->liodnOffset2);
+    WRITE_UINT16(p_HcFrame->hcSpecificData.drblInitHcData.liodnOffset3,          p_DrblInitHcParams->liodnOffset3);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.drblInitHcData.portId,                p_DrblInitHcParams->portId);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.drblInitHcData.cevNum,                p_DrblInitHcParams->cevNum);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcRmuDoorbellSetCntsCmd(t_Handle h_FmHc, t_FmRmuDrblSetCntsHcParams *p_DrblSetCntsHcParams)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+    ASSERT_COND(p_DrblSetCntsHcParams);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_DRBL_SET_CNTS);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    WRITE_UINT32(p_HcFrame->hcSpecificData.drblSetCntsHcData.msgrNum,      p_DrblSetCntsHcParams->msgrNum);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.drblSetCntsHcData.inDrblCntPtr, p_DrblSetCntsHcParams->inDrblCntPtr);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcRmuDoorbellFreeCmd(t_Handle h_FmHc)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_DRBL_FREE);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcRmuMsgInitCmd(t_Handle h_FmHc, t_FmRmuMsgInitHcParams *p_MsgInitHcParams)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    uint8_t                 classInitMode = 0;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+    ASSERT_COND(p_MsgInitHcParams);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_MSG_INIT);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    classInitMode = FmHcRmuMsgInitBuildModeReg(p_MsgInitHcParams->cevNum, p_MsgInitHcParams->msgUnitId);
+
+    WRITE_BLOCK((void *)&(p_HcFrame->hcSpecificData.msgInitHcData), 0, sizeof(t_FmRmuMsgInitHcData));
+
+    COPY_BLOCK  ((void *)(p_HcFrame->hcSpecificData.msgInitHcData.keyMask),      (void *)(p_MsgInitHcParams->keyMask), FM_RMU_MSG_KEY_MASK_SIZE);
+    WRITE_UINT64(p_HcFrame->hcSpecificData.msgInitHcData.srioBaseAddr,           p_MsgInitHcParams->srioBaseAddr);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgInitHcData.keyMaskOffset,          p_MsgInitHcParams->keyMaskOffset);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgInitHcData.portId ,                p_MsgInitHcParams->portId);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgInitHcData.reserved,               0);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgInitHcData.modeReg,                classInitMode);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.msgInitHcData.inMsgClassTableBase,    p_MsgInitHcParams->inMsgClassTableBase);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.msgInitHcData.bufferProfileTableBase, p_MsgInitHcParams->bufferProfileTableBase);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.msgInitHcData.internalBufferBase,     p_MsgInitHcParams->internalBufferBase);
+    WRITE_UINT32(p_HcFrame->hcSpecificData.msgInitHcData.inMsgParamsTableBase,   p_MsgInitHcParams->inMsgParamsTableBase);
+    WRITE_UINT16(p_HcFrame->hcSpecificData.msgInitHcData.srioRegsLiodnOffest,    p_MsgInitHcParams->srioRegsLiodnOffest);
+    WRITE_UINT16(p_HcFrame->hcSpecificData.msgInitHcData.inMsgQueueLiodnOffset,  p_MsgInitHcParams->inMsgQueueLiodnOffset);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcRmuBufferProfileChange(t_Handle                              h_FmHc,
+                                   t_FmRmuBufferProfileChangeHcParams    *p_HcParams)
+{
+    t_FmHc          *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame       *p_HcFrame;
+    t_DpaaFD        fmFd;
+    uint64_t        bufferProfileEntryData;
+    uint8_t         bufferProfileEntryId, bufferProfileChangeMode;
+    t_Error         err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+    ASSERT_COND(p_HcParams);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_MSG_CHANGE_BUFFER_PROFILE_ENTRY);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    bufferProfileEntryData  = FmHcRmuMsgBuildBufferProfileEntry (p_HcParams->bufferPoolId,
+                                                                 p_HcParams->buffersSize,
+                                                                 p_HcParams->buffersOffset,
+                                                                 p_HcParams->bufferPoolliodnOffset);
+    bufferProfileEntryId    = p_HcParams->entryId;
+    bufferProfileChangeMode = p_HcParams->mailboxId;
+
+    WRITE_BLOCK((void *)&(p_HcFrame->hcSpecificData.bufferProfileChangeHcData), 0, sizeof(t_FmRmuBufferProfileChangeHcData));
+
+    WRITE_UINT64(p_HcFrame->hcSpecificData.bufferProfileChangeHcData.bufferProfileEntryData,  bufferProfileEntryData);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.bufferProfileChangeHcData.bufferProfileEntryId,    bufferProfileEntryId);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.bufferProfileChangeHcData.bufferProfileChangeMode, bufferProfileChangeMode);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error     FmHcRmuMsgClassChange(t_Handle h_FmHc, t_FmRmuMsgClassChangeHcParams *p_HcParams)
+{
+    t_FmHc          *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame       *p_HcFrame;
+    t_DpaaFD        fmFd;
+    uint32_t        classEntryData;
+    uint8_t         classEntryId, classEntryMode;
+    t_Error         err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+    ASSERT_COND(p_HcParams);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_MSG_CHANGE_CLASSIFICATION_ENTRY);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    classEntryData = FmHcRmuMsgBuildClassificationEntry(p_HcParams->validate, p_HcParams->bufferProfileId, p_HcParams->fqId);
+    classEntryId   = p_HcParams->entryId;
+    classEntryMode = FmHcRmuMsgClassificationBuildModeReg(p_HcParams->isErrQueueChange, p_HcParams->mailboxId);
+
+    WRITE_BLOCK((void *)&(p_HcFrame->hcSpecificData.msgClassChangeHcData), 0, sizeof(t_FmRmuMsgClassChangeHcData));
+
+    WRITE_UINT32(p_HcFrame->hcSpecificData.msgClassChangeHcData.classTableEntryData,  classEntryData);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgClassChangeHcData.classTableEntryId,    classEntryId);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgClassChangeHcData.classEntryChangeMode, classEntryMode);
+
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcRmuMsgFreeCmd(t_Handle h_FmHc, uint8_t mailboxId)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    uint8_t                 modeReg;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = (t_HcFrame *)XX_Malloc(sizeof(t_HcFrame));
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode    = (uint32_t)(HC_HCOR_OPCODE_RMU_MSG_FREE);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg  = 0;
+
+    //WRITE_BLOCK((void *)&(p_HcFrame->hcSpecificData.msgFreeHcData), 0, sizeof(t_FmRmuMsgFreeHcData));
+
+    modeReg = (mailboxId == 0 ? 0 : 1);
+    WRITE_UINT8 (p_HcFrame->hcSpecificData.msgFreeHcData.modeReg, modeReg);
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_Free(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    XX_Free(p_HcFrame);
+
+    return E_OK;
+}
+#endif /* FM_RMU_ASSIST_SUPPORT */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
new file mode 100644
index 0000000..3ff264d
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-MAC.o
+
+fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
new file mode 100644
index 0000000..2e1c84f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -0,0 +1,1928 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.c
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "fm_common.h"
+#include "dtsec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 1G MAC driver only supports 1G or lower speeds"));
+    if(p_Dtsec->macId >= FM_MAX_NUM_OF_1G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId can not be greater than the number of 1G MACs"));
+    if(p_Dtsec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC Must have a valid MAC Address"));
+    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
+        p_Dtsec->p_DtsecDriverParam->halfDuplex)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
+    if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
+#ifdef FM_NO_RX_PREAM_ERRATA_DTSECx1
+    if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
+#endif /* FM_NO_RX_PREAM_ERRATA_DTSECx1 */
+    if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
+    if((p_Dtsec->p_DtsecDriverParam)->fifoTxWatermarkH<((p_Dtsec->p_DtsecDriverParam)->fifoTxThr+8))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoTxWatermarkH has to be at least 8 larger than fifoTxThr"));
+    if((p_Dtsec->p_DtsecDriverParam)->halfDuplex &&
+       (p_Dtsec->p_DtsecDriverParam->txTimeStampEn || p_Dtsec->p_DtsecDriverParam->rxTimeStampEn))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dTSEC in half duplex mode has to be with 1588 timeStamping diable"));
+    if((p_Dtsec->p_DtsecDriverParam)->actOnRxPauseFrame && (p_Dtsec->p_DtsecDriverParam)->controlFrameAccept )
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Receive control frame are not passed to the system memory so it can not be accept "));
+    if((p_Dtsec->p_DtsecDriverParam)->packetAlignmentPadding  > MAX_PACKET_ALIGNMENT)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("packetAlignmentPadding can't be greater than %d ",MAX_PACKET_ALIGNMENT ));
+    if(((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg1  > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg2 > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->backToBackIpg > MAX_INTER_PACKET_GAP))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inter packet gap can't be greater than %d ",MAX_INTER_PACKET_GAP ));
+    if((p_Dtsec->p_DtsecDriverParam)->alternateBackoffVal > MAX_INTER_PALTERNATE_BEB)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("alternateBackoffVal can't be greater than %d ",MAX_INTER_PALTERNATE_BEB ));
+    if((p_Dtsec->p_DtsecDriverParam)->maxRetransmission > MAX_RETRANSMISSION)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("maxRetransmission can't be greater than %d ",MAX_RETRANSMISSION ));
+    if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
+
+    /*  If Auto negotiation process is disabled, need to */
+    /*  Set up the PHY using the MII Management Interface */
+    if (p_Dtsec->p_DtsecDriverParam->tbiPhyAddr > MAX_PHYS)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PHY address (should be 0-%d)", MAX_PHYS));
+    if(!p_Dtsec->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Exception"));
+    if(!p_Dtsec->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
+    return E_OK;
+}
+
+static uint8_t GetMiiDiv(int32_t refClk)
+{
+    uint32_t    div,tmpClk;
+    int         minRange;
+
+    div = 1;
+    minRange = (int)(refClk/40 - 1);
+
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 2;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 3;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/80 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 4;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/100 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 5;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/140 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 6;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/280 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 7;
+        minRange = (int)tmpClk;
+    }
+
+    return (uint8_t)div;
+}
+
+/* ........................................................................... */
+
+static void SetDefaultParam(t_DtsecDriverParam *p_DtsecDriverParam)
+{
+    p_DtsecDriverParam->errorDisabled       = DEFAULT_errorDisabled;
+
+    p_DtsecDriverParam->promiscuousEnable   = DEFAULT_promiscuousEnable;
+
+    p_DtsecDriverParam->pauseExtended       = DEFAULT_pauseExtended;
+    p_DtsecDriverParam->pauseTime           = DEFAULT_pauseTime;
+
+    p_DtsecDriverParam->halfDuplex              = DEFAULT_halfDuplex;
+    p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
+    p_DtsecDriverParam->txTimeStampEn           = DEFAULT_txTimeStampEn;
+    p_DtsecDriverParam->rxTimeStampEn           = DEFAULT_rxTimeStampEn;
+
+    p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
+    p_DtsecDriverParam->controlFrameAccept     = DEFAULT_controlFrameAccept;
+    p_DtsecDriverParam->groupHashExtend        = DEFAULT_groupHashExtend;
+    p_DtsecDriverParam->broadcReject           = DEFAULT_broadcReject;
+    p_DtsecDriverParam->rxShortFrame           = DEFAULT_rxShortFrame;
+    p_DtsecDriverParam->exactMatch             = DEFAULT_exactMatch;
+    p_DtsecDriverParam->debugMode              = DEFAULT_debugMode;
+
+    p_DtsecDriverParam->loopback               = DEFAULT_loopback;
+    p_DtsecDriverParam->tbiPhyAddr             = DEFAULT_tbiPhyAddr;
+    p_DtsecDriverParam->actOnRxPauseFrame      = DEFAULT_actOnRxPauseFrame;
+    p_DtsecDriverParam->actOnTxPauseFrame      = DEFAULT_actOnTxPauseFrame;
+
+    p_DtsecDriverParam->preambleLength         = DEFAULT_PreAmLength;
+    p_DtsecDriverParam->preambleRxEn           = DEFAULT_PreAmRxEn;
+    p_DtsecDriverParam->preambleTxEn           = DEFAULT_PreAmTxEn;
+    p_DtsecDriverParam->lengthCheckEnable      = DEFAULT_lengthCheckEnable;
+    p_DtsecDriverParam->padAndCrcEnable        = DEFAULT_padAndCrcEnable;
+    p_DtsecDriverParam->crcEnable              = DEFAULT_crcEnable;
+
+    p_DtsecDriverParam->nonBackToBackIpg1      = DEFAULT_nonBackToBackIpg1;
+    p_DtsecDriverParam->nonBackToBackIpg2      = DEFAULT_nonBackToBackIpg2;
+    p_DtsecDriverParam->minIfgEnforcement      = DEFAULT_minIfgEnforcement;
+    p_DtsecDriverParam->backToBackIpg          = DEFAULT_backToBackIpg;
+
+    p_DtsecDriverParam->alternateBackoffVal    = DEFAULT_altBackoffVal;
+    p_DtsecDriverParam->alternateBackoffEnable = DEFAULT_altBackoffEnable;
+    p_DtsecDriverParam->backPressureNoBackoff  = DEFAULT_backPressureNoBackoff;
+    p_DtsecDriverParam->noBackoff              = DEFAULT_noBackoff;
+    p_DtsecDriverParam->excessDefer            = DEFAULT_excessDefer;
+    p_DtsecDriverParam->maxRetransmission      = DEFAULT_maxRetransmission;
+    p_DtsecDriverParam->collisionWindow        = DEFAULT_collisionWindow;
+
+    p_DtsecDriverParam->maxFrameLength         = DEFAULT_maxFrameLength;
+
+    p_DtsecDriverParam->fifoTxThr              = DEFAULT_fifoTxThr;
+    p_DtsecDriverParam->fifoTxWatermarkH       = DEFAULT_fifoTxWatermarkH;
+
+    p_DtsecDriverParam->fifoRxWatermarkL       = DEFAULT_fifoRxWatermarkL;
+}
+
+static void DtsecException(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    event = GET_UINT32(p_DtsecMemMap->ievent);
+    /* handle only MDIO events */
+    event &= (IMASK_MMRDEN | IMASK_MMWREN);
+    if(event)
+    {
+        event &= GET_UINT32(p_DtsecMemMap->imask);
+
+        WRITE_UINT32(p_DtsecMemMap->ievent, event);
+
+        if(event & IMASK_MMRDEN)
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
+        if(event & IMASK_MMWREN)
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
+    }
+}
+
+static void UpdateStatistics(t_Dtsec *p_Dtsec)
+{
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        car1 =  GET_UINT32(p_DtsecMemMap->car1);
+    uint32_t        car2 =  GET_UINT32(p_DtsecMemMap->car2);
+
+    if(car1)
+    {
+        WRITE_UINT32(p_DtsecMemMap->car1, car1);
+        if(car1 & CAR1_TR64)
+            p_Dtsec->internalStatistics.tr64 += VAL22BIT;
+        if(car1 & CAR1_TR127)
+            p_Dtsec->internalStatistics.tr127 += VAL22BIT;
+        if(car1 & CAR1_TR255)
+            p_Dtsec->internalStatistics.tr255 += VAL22BIT;
+        if(car1 & CAR1_TR511)
+            p_Dtsec->internalStatistics.tr511 += VAL22BIT;
+        if(car1 & CAR1_TRK1)
+            p_Dtsec->internalStatistics.tr1k += VAL22BIT;
+        if(car1 & CAR1_TRMAX)
+            p_Dtsec->internalStatistics.trmax += VAL22BIT;
+        if(car1 & CAR1_TRMGV)
+            p_Dtsec->internalStatistics.trmgv += VAL22BIT;
+        if(car1 & CAR1_RBYT)
+            p_Dtsec->internalStatistics.rbyt += (uint64_t)VAL32BIT;
+        if(car1 & CAR1_RPKT)
+            p_Dtsec->internalStatistics.rpkt += VAL22BIT;
+        if(car1 & CAR1_RMCA)
+            p_Dtsec->internalStatistics.rmca += VAL22BIT;
+        if(car1 & CAR1_RBCA)
+            p_Dtsec->internalStatistics.rbca += VAL22BIT;
+        if(car1 & CAR1_RXPF)
+            p_Dtsec->internalStatistics.rxpf += VAL16BIT;
+        if(car1 & CAR1_RALN)
+            p_Dtsec->internalStatistics.raln += VAL16BIT;
+        if(car1 & CAR1_RFLR)
+            p_Dtsec->internalStatistics.rflr += VAL16BIT;
+        if(car1 & CAR1_RCDE)
+            p_Dtsec->internalStatistics.rcde += VAL16BIT;
+        if(car1 & CAR1_RCSE)
+            p_Dtsec->internalStatistics.rcse += VAL16BIT;
+        if(car1 & CAR1_RUND)
+            p_Dtsec->internalStatistics.rund += VAL16BIT;
+        if(car1 & CAR1_ROVR)
+            p_Dtsec->internalStatistics.rovr += VAL16BIT;
+        if(car1 & CAR1_RFRG)
+            p_Dtsec->internalStatistics.rfrg += VAL16BIT;
+        if(car1 & CAR1_RJBR)
+            p_Dtsec->internalStatistics.rjbr += VAL16BIT;
+        if(car1 & CAR1_RDRP)
+            p_Dtsec->internalStatistics.rdrp += VAL16BIT;
+    }
+    if(car2)
+    {
+        WRITE_UINT32(p_DtsecMemMap->car2, car2);
+        if(car2  & CAR2_TFCS)
+            p_Dtsec->internalStatistics.tfcs += VAL12BIT;
+        if(car2  & CAR2_TBYT)
+            p_Dtsec->internalStatistics.tbyt += (uint64_t)VAL32BIT;
+        if(car2  & CAR2_TPKT)
+            p_Dtsec->internalStatistics.tpkt += VAL22BIT;
+        if(car2  & CAR2_TMCA)
+            p_Dtsec->internalStatistics.tmca += VAL22BIT;
+        if(car2  & CAR2_TBCA)
+            p_Dtsec->internalStatistics.tbca += VAL22BIT;
+        if(car2  & CAR2_TXPF)
+            p_Dtsec->internalStatistics.txpf += VAL16BIT;
+        if(car2  & CAR2_TDRP)
+            p_Dtsec->internalStatistics.tdrp += VAL16BIT;
+    }
+}
+
+/* .............................................................................. */
+
+static uint16_t DtsecGetMaxFrameLength(t_Handle h_Dtsec)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_VALUE(p_Dtsec, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Dtsec->p_MemMap->maxfrm);
+}
+
+static void DtsecErrException(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    event = GET_UINT32(p_DtsecMemMap->ievent);
+    /* do not handle MDIO events */
+    event &= ~(IMASK_MMRDEN | IMASK_MMWREN);
+
+    event &= GET_UINT32(p_DtsecMemMap->imask);
+
+    WRITE_UINT32(p_DtsecMemMap->ievent, event);
+
+    if(event & IMASK_BREN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
+    if(event & IMASK_RXCEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_CTL);
+    if(event & IMASK_MSROEN)
+        UpdateStatistics(p_Dtsec);
+    if(event & IMASK_GTSCEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);
+    if(event & IMASK_BTEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_TX);
+    if(event & IMASK_TXCEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_CTL);
+    if(event & IMASK_TXEEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_ERR);
+    if(event & IMASK_LCEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_LATE_COL);
+    if(event & IMASK_CRLEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_COL_RET_LMT);
+    if(event & IMASK_XFUNEN)
+    {
+#ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
+        uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
+        /* a. Write 0x00E0_0C00 to DTSEC_ID */
+        /* This is a read only regidter */
+
+        /* b. Read and save the value of TPKT */
+        tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
+
+        /* c. Read the register at dTSEC address offset 0x32C */
+        tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+        /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
+        if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
+        {
+            /* If they are not equal, save the value of this register and wait for at least
+             * MAXFRM*16 ns */
+            XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
+        }
+
+        /* e. Read and save TPKT again and read the register at dTSEC address offset
+            0x32C again*/
+        tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
+        tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+        /* f. Compare the value of TPKT saved in step b to value read in step e. Also
+            compare bits [9:15] of the register at offset 0x32C saved in step d to the value
+            of bits [9:15] saved in step e. If the two registers values are unchanged, then
+            the transmit portion of the dTSEC controller is locked up and the user should
+            proceed to the recover sequence. */
+        if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
+        {
+            /* recover sequence */
+
+            /* a.Write a 1 to RCTRL[GRS]*/
+
+            WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
+
+            /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
+            for(i = 0 ; i < 100 ; i++ )
+            {
+                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                    break;
+                XX_UDelay(1);
+            }
+            if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
+            else
+                DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
+
+
+            /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
+            FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
+
+            /* d.Wait 4 Tx clocks (32 ns) */
+            XX_UDelay(1);
+
+            /* e.Write a 0 to bit n of FM_RSTC. */
+            /* cleared by FMAN */
+        }
+        else
+        {
+            /* If either value has changed, the dTSEC controller is not locked up and the
+               controller should be allowed to proceed normally by writing the reset value
+               of 0x0824_0101 to DTSEC_ID. */
+            /* Register is read only */
+        }
+#endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
+
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
+    }
+    if(event & IMASK_MAGEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_MAG_PCKT);
+    if(event & IMASK_GRSCEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);
+    if(event & IMASK_TDPEEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_DATA_ERR);
+    if(event & IMASK_RDPEEN)
+        p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_DATA_ERR);
+
+    /*  - masked interrupts */
+    ASSERT_COND(!(event & IMASK_ABRTEN));
+    ASSERT_COND(!(event & IMASK_IFERREN));
+}
+
+static void Dtsec1588Exception(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    if (p_Dtsec->ptpTsuEnabled)
+    {
+        event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
+        event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
+        if(event)
+        {
+            WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
+            ASSERT_COND(event & PEMASK_TSRE);
+            p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
+        }
+    }
+}
+
+/* ........................................................................... */
+
+static void FreeInitResources(t_Dtsec *p_Dtsec)
+{
+    if ((p_Dtsec->mdioIrq != 0) && (p_Dtsec->mdioIrq != NO_IRQ))
+    {
+        XX_DisableIntr(p_Dtsec->mdioIrq);
+        XX_FreeIntr(p_Dtsec->mdioIrq);
+    }
+    else if (p_Dtsec->mdioIrq == 0)
+        FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR);
+    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+
+    /* release the driver's group hash table */
+    FreeHashTable(p_Dtsec->p_MulticastAddrHash);
+    p_Dtsec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Dtsec->p_UnicastAddrHash);
+    p_Dtsec->p_UnicastAddrHash =     NULL;
+}
+
+/* ........................................................................... */
+
+static void HardwareClearAddrInPaddr(t_Dtsec *p_Dtsec, uint8_t paddrNum)
+{
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match1, 0x0);
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match2, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Dtsec *p_Dtsec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t        tmpReg32        = 0;
+    uint64_t        addr            = *p_Addr;
+    t_DtsecMemMap   *p_DtsecMemMap  = (t_DtsecMemMap*)p_Dtsec->p_MemMap;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match2, tmpReg32);
+}
+
+/* ........................................................................... */
+
+static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
+{
+    t_DtsecMemMap   *p_MemMap;
+
+    ASSERT_COND(p_Dtsec);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    ASSERT_COND(p_MemMap);
+
+    /* Assert the graceful transmit stop bit */
+    if (mode & e_COMM_MODE_RX)
+        WRITE_UINT32(p_MemMap->rctrl,
+                     GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+
+#ifdef FM_GRS_ERRATA_DTSEC_A002
+    XX_UDelay(100);
+#endif /* FM_GRS_ERRATA_DTSEC_A002 */
+
+#ifdef FM_GTS_ERRATA_DTSEC_A004
+    return E_OK;
+#endif /* FM_GTS_ERRATA_DTSEC_A004 */
+
+    if (mode & e_COMM_MODE_TX)
+        WRITE_UINT32(p_MemMap->tctrl,
+                     GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error GracefulRestart(t_Dtsec *p_Dtsec, e_CommMode mode)
+{
+    t_DtsecMemMap   *p_MemMap;
+
+    ASSERT_COND(p_Dtsec);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    ASSERT_COND(p_MemMap);
+
+    /* clear the graceful receive stop bit */
+    if(mode & e_COMM_MODE_TX)
+        WRITE_UINT32(p_MemMap->tctrl,
+                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
+
+    if(mode & e_COMM_MODE_RX)
+        WRITE_UINT32(p_MemMap->rctrl,
+                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      dTSEC Configs modification functions                 */
+/*****************************************************************************/
+
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigLoopback(t_Handle h_Dtsec, bool newVal)
+{
+
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->loopback = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigMaxFrameLength(t_Handle h_Dtsec, uint16_t newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigPadAndCrc(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->halfDuplex = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
+{
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+UNUSED(h_Dtsec);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+
+#else
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->lengthCheckEnable = newVal;
+
+    return E_OK;
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+}
+
+static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    {
+        GET_EXCEPTION_FLAG(bitMask, exception);
+        if(bitMask)
+        {
+            if (enable)
+                p_Dtsec->exceptions |= bitMask;
+            else
+                p_Dtsec->exceptions &= ~bitMask;
+        }
+        else
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+    }
+    else
+    {
+        if(!p_Dtsec->ptpTsuEnabled)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
+        switch(exception){
+        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if(enable)
+                p_Dtsec->enTsuErrExeption = TRUE;
+            else
+                p_Dtsec->enTsuErrExeption = FALSE;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+        }
+    }
+    return E_OK;
+}
+/*****************************************************************************/
+/*                      dTSEC Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+    if (mode & e_COMM_MODE_RX)
+        tmpReg32 |= MACCFG1_RX_EN;
+    if (mode & e_COMM_MODE_TX)
+        tmpReg32 |= MACCFG1_TX_EN;
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    GracefulRestart(p_Dtsec, mode);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    GracefulStop(p_Dtsec, mode);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+    if (mode & e_COMM_MODE_RX)
+        tmpReg32 &= ~MACCFG1_RX_EN;
+    if (mode & e_COMM_MODE_TX)
+        tmpReg32 &= ~MACCFG1_TX_EN;
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t        ptv = 0;
+    t_DtsecMemMap   *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    if (pauseTime)
+    {
+#ifdef FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
+        {
+            if (pauseTime <= 320)
+                RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                             ("This pause-time value of %d is illegal due to errata dTSEC-A003!"
+                              " value should be greater than 320."));
+        }
+#endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
+
+#ifdef FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                pauseTime += 2;
+        }
+#endif /* FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
+
+        ptv = GET_UINT32(p_MemMap->ptv);
+        ptv |= pauseTime;
+        WRITE_UINT32(p_MemMap->ptv, ptv);
+
+        /* trigger the transmission of a flow-control pause frame */
+        WRITE_UINT32(p_MemMap->maccfg1,
+                     GET_UINT32(p_MemMap->maccfg1) | MACCFG1_TX_FLOW);
+    }
+    else
+    {
+        WRITE_UINT32(p_MemMap->maccfg1,
+                     GET_UINT32(p_MemMap->maccfg1) & ~MACCFG1_TX_FLOW);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+    if (en)
+        tmpReg32 &= ~MACCFG1_RX_FLOW;
+    else
+        tmpReg32 |= MACCFG1_RX_FLOW;
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+#ifdef FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3
+    if((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("1588TimeStamp in 10/100 SGMII"));
+#endif /* FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3 */
+    p_Dtsec->ptpTsuEnabled = TRUE;
+    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) | RCTRL_RTSE);
+    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) | TCTRL_TTSE);
+
+    return E_OK;
+}
+
+static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->ptpTsuEnabled = FALSE;
+    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) & ~RCTRL_RTSE);
+    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) & ~TCTRL_TTSE);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statistics)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_DtsecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+
+    if (p_Dtsec->statisticsLevel == e_FM_MAC_NONE_STATISTICS)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Statistics disabled"));
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    memset(p_Statistics, 0xff, sizeof(t_FmMacStatistics));
+
+    if (p_Dtsec->statisticsLevel == e_FM_MAC_FULL_STATISTICS)
+    {
+        p_Statistics->eStatPkts64           = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr64))
+                                                + p_Dtsec->internalStatistics.tr64;      /**< r-10G tr-DT 64 byte frame counter */
+        p_Statistics->eStatPkts65to127      = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr127))
+                                                + p_Dtsec->internalStatistics.tr127;     /**< r-10G 65 to 127 byte frame counter */
+        p_Statistics->eStatPkts128to255     = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr255))
+                                                + p_Dtsec->internalStatistics.tr255;     /**< r-10G 128 to 255 byte frame counter */
+        p_Statistics->eStatPkts256to511     = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr511))
+                                                + p_Dtsec->internalStatistics.tr511;     /**< r-10G 256 to 511 byte frame counter */
+        p_Statistics->eStatPkts512to1023    = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr1k))
+                                                + p_Dtsec->internalStatistics.tr1k;      /**< r-10G 512 to 1023 byte frame counter */
+        p_Statistics->eStatPkts1024to1518   = (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmax))
+                                                + p_Dtsec->internalStatistics.trmax;     /**< r-10G 1024 to 1518 byte frame counter */
+        p_Statistics->eStatPkts1519to1522   = (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmgv))
+                                                + p_Dtsec->internalStatistics.trmgv;     /**< r-10G 1519 to 1522 byte good frame count */
+        /* MIB II */
+        p_Statistics->ifInOctets            = GET_UINT32(p_DtsecMemMap->rbyt)
+                                                + p_Dtsec->internalStatistics.rbyt;                  /**< Total number of byte received. */
+        p_Statistics->ifInPkts              = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rpkt))
+                                                + p_Dtsec->internalStatistics.rpkt;    /**< Total number of packets received.*/
+        p_Statistics->ifInMcastPkts         = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rmca))
+                                                + p_Dtsec->internalStatistics.rmca;    /**< Total number of multicast frame received*/
+        p_Statistics->ifInBcastPkts         = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rbca))
+                                                + p_Dtsec->internalStatistics.rbca;    /**< Total number of broadcast frame received */
+        p_Statistics->ifOutOctets           = GET_UINT32(p_DtsecMemMap->tbyt)
+                                                + p_Dtsec->internalStatistics.tbyt;                  /**< Total number of byte sent. */
+        p_Statistics->ifOutPkts             = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tpkt))
+                                                + p_Dtsec->internalStatistics.tpkt;    /**< Total number of packets sent .*/
+        p_Statistics->ifOutMcastPkts        = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tmca))
+                                                + p_Dtsec->internalStatistics.tmca;    /**< Total number of multicast frame sent */
+        p_Statistics->ifOutBcastPkts        = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tbca))
+                                                + p_Dtsec->internalStatistics.tbca;    /**< Total number of multicast frame sent */
+    }
+/* */
+    p_Statistics->eStatFragments        = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rfrg))
+                                            + p_Dtsec->internalStatistics.rfrg;      /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    p_Statistics->eStatJabbers          = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rjbr))
+                                            + p_Dtsec->internalStatistics.rjbr;      /**< Total number of packets longer than valid maximum length octets */
+
+    p_Statistics->eStatsDropEvents      = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rdrp))
+                                            + p_Dtsec->internalStatistics.rdrp;      /**< number of dropped packets due to internal errors of the MAC Client. */
+    p_Statistics->eStatCRCAlignErrors   = (MASK16BIT & GET_UINT32(p_DtsecMemMap->raln))
+                                            + p_Dtsec->internalStatistics.raln;      /**< Incremented when frames of correct length but with CRC error are received.*/
+
+    p_Statistics->eStatUndersizePkts    = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rund))
+                                            + p_Dtsec->internalStatistics.rund;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    p_Statistics->eStatOversizePkts     = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rovr))
+                                            + p_Dtsec->internalStatistics.rovr;      /**< T,B.D*/
+/* Pause */
+    p_Statistics->reStatPause           = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rxpf))
+                                            + p_Dtsec->internalStatistics.rxpf;      /**< Pause MAC Control received */
+    p_Statistics->teStatPause           = (MASK16BIT & GET_UINT32(p_DtsecMemMap->txpf))
+                                            + p_Dtsec->internalStatistics.txpf;      /**< Pause MAC Control sent */
+
+    p_Statistics->ifInDiscards          = p_Statistics->eStatsDropEvents;                    /**< Frames received, but discarded due to problems within the MAC RX. */
+
+    p_Statistics->ifInErrors            = p_Statistics->eStatsDropEvents
+                                        + p_Statistics->eStatCRCAlignErrors
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rflr))
+                                        + p_Dtsec->internalStatistics.rflr
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcde))
+                                        + p_Dtsec->internalStatistics.rcde
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcse))
+                                        + p_Dtsec->internalStatistics.rcse;
+
+    p_Statistics->ifOutDiscards         = (MASK16BIT & GET_UINT32(p_DtsecMemMap->tdrp))
+                                            + p_Dtsec->internalStatistics.tdrp;     /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    p_Statistics->ifOutErrors           = p_Statistics->ifOutDiscards                                           /**< Number of frames transmitted with error: */
+                                        + (MASK12BIT & GET_UINT32(p_DtsecMemMap->tfcs))
+                                        + p_Dtsec->internalStatistics.tfcs;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap;
+    uint32_t              tmpReg32 = 0;
+    uint64_t              addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    /* Initialize MAC Station Address registers (1 & 2)    */
+    /* Station address have to be swapped (big endian to little endian */
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Dtsec->addr = addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecResetCounters (t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    /* clear HW counters */
+    WRITE_UINT32(p_Dtsec->p_MemMap->ecntrl, GET_UINT32(p_Dtsec->p_MemMap->ecntrl) | ECNTRL_CLRCNT);
+
+    /* clear SW counters holding carries */
+    memset((char *)&p_Dtsec->internalStatistics, (char)0x0, sizeof(t_InternalStatistics));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Dtsec->indAddrRegUsed[paddrNum]) &&
+            (p_Dtsec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Dtsec, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (p_Dtsec->indAddrRegUsed[paddrNum])
+            if (p_Dtsec->paddr[paddrNum] == ethAddr)
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (!(p_Dtsec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Dtsec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Dtsec, &ethAddr, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg = (uint8_t)(crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in GADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->gaddr[reg]) | bitMask);
+    }
+    else
+    {
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in IADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->igaddr[reg]) | bitMask);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg =(uint8_t)( crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+        {
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->gaddr[reg]) & ~bitMask);
+    }
+    else
+    {
+        /* Individual Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+        {
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->igaddr[reg]) & ~bitMask);
+    }
+
+    /* address does not exist */
+    ASSERT_COND(p_HashEntry != NULL);
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->rctrl);
+
+    if (newVal)
+        tmpReg32 |= RCTRL_PROM;
+    else
+        tmpReg32 &= ~RCTRL_PROM;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetStatistics(t_Handle h_Dtsec, e_FmMacStatisticsLevel statisticsLevel)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    p_Dtsec->statisticsLevel = statisticsLevel;
+
+    switch (p_Dtsec->statisticsLevel)
+    {
+        case(e_FM_MAC_NONE_STATISTICS):
+            WRITE_UINT32(p_DtsecMemMap->cam1,0xffffffff);
+            WRITE_UINT32(p_DtsecMemMap->cam2,0xffffffff);
+            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) & ~ECNTRL_STEN);
+            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) & ~IMASK_MSROEN);
+            p_Dtsec->exceptions &= ~IMASK_MSROEN;
+            break;
+        case(e_FM_MAC_PARTIAL_STATISTICS):
+            WRITE_UINT32(p_DtsecMemMap->cam1, CAM1_ERRORS_ONLY);
+            WRITE_UINT32(p_DtsecMemMap->cam2, CAM2_ERRORS_ONLY);
+            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) | ECNTRL_STEN);
+            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) | IMASK_MSROEN);
+            p_Dtsec->exceptions |= IMASK_MSROEN;
+            break;
+        case(e_FM_MAC_FULL_STATISTICS):
+            WRITE_UINT32(p_DtsecMemMap->cam1,0);
+            WRITE_UINT32(p_DtsecMemMap->cam2,0);
+            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) | ECNTRL_STEN);
+            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) | IMASK_MSROEN);
+            p_Dtsec->exceptions |= IMASK_MSROEN;
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    if (!fullDuplex &&
+        ((speed >= e_ENET_SPEED_1000) ||
+         (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)))
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
+
+    p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
+    p_Dtsec->halfDuplex = !fullDuplex;
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
+    if(p_Dtsec->halfDuplex)
+        tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
+    else
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+
+    tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
+    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+    if (!(tmpReg32 & ECNTRL_CFG_RO))
+    {
+        if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= ECNTRL_R100M;
+        else
+            tmpReg32 &= ~ECNTRL_R100M;
+        WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+
+    *macId = p_Dtsec->macId;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    *macVersion = GET_UINT32(p_DtsecMemMap->tsec_id1);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetExcpetion(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            tmpReg, bitMask = 0;
+    t_DtsecMemMap       *p_DtsecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    {
+        GET_EXCEPTION_FLAG(bitMask, exception);
+        if(bitMask)
+        {
+            if (enable)
+                p_Dtsec->exceptions |= bitMask;
+            else
+                p_Dtsec->exceptions &= ~bitMask;
+       }
+        else
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+        tmpReg = GET_UINT32(p_DtsecMemMap->imask);
+        if(enable)
+            tmpReg |= bitMask;
+        else
+            tmpReg &= ~bitMask;
+        WRITE_UINT32(p_DtsecMemMap->imask, tmpReg);
+    }
+    else
+    {
+        if(!p_Dtsec->ptpTsuEnabled)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
+        tmpReg = GET_UINT32(p_DtsecMemMap->tmr_pemask);
+        switch(exception){
+        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if(enable)
+            {
+                p_Dtsec->enTsuErrExeption = TRUE;
+                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg | PEMASK_TSRE);
+            }
+            else
+            {
+                p_Dtsec->enTsuErrExeption = FALSE;
+                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg & ~PEMASK_TSRE);
+            }
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+        }
+    }
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    int i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_Dtsec->p_MemMap)
+    {
+
+        DUMP_TITLE(p_Dtsec->p_MemMap, ("MAC %d: ", p_Dtsec->macId));
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id1);
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ievent);
+        DUMP_VAR(p_Dtsec->p_MemMap, imask);
+        DUMP_VAR(p_Dtsec->p_MemMap, edis);
+        DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, ptv);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pevent);
+        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pemask);
+        DUMP_VAR(p_Dtsec->p_MemMap, tctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, rctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg1);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ipgifg);
+        DUMP_VAR(p_Dtsec->p_MemMap, hafdup);
+        DUMP_VAR(p_Dtsec->p_MemMap, maxfrm);
+
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr1);
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr2);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+        {
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
+        }
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecInit(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    t_DtsecMemMap       *p_DtsecMemMap;
+    int                 i;
+    uint32_t            tmpReg32;
+    uint64_t            addr;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    CHECK_INIT_PARAMETERS(p_Dtsec, CheckInitParameters);
+
+    p_DtsecDriverParam  = p_Dtsec->p_DtsecDriverParam;
+    p_Dtsec->halfDuplex = p_DtsecDriverParam->halfDuplex;
+    p_Dtsec->debugMode  = p_DtsecDriverParam->debugMode;
+    p_DtsecMemMap       = p_Dtsec->p_MemMap;
+
+    /*************dtsec_id2******************/
+    tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
+
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
+        if(tmpReg32 & ID2_INT_REDUCED_OFF)
+        {
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
+        }
+
+    if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)    ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_100))
+        if(tmpReg32 & ID2_INT_NORMAL_OFF)
+        {
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
+        }
+    /*************dtsec_id2******************/
+
+    /***************EDIS************************/
+    WRITE_UINT32(p_DtsecMemMap->edis, p_DtsecDriverParam->errorDisabled);
+    /***************EDIS************************/
+
+    /***************ECNTRL************************/
+    tmpReg32 = 0;
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+        tmpReg32 |= ECNTRL_GMIIM;
+    if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+        tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
+    if (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)
+        tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM | ECNTRL_QSGMIIM);
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
+        tmpReg32 |= ECNTRL_RPM;
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
+        tmpReg32 |= ECNTRL_R100M;
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RMII_10) || (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
+        tmpReg32 |= ECNTRL_RMM;
+    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    /***************ECNTRL************************/
+
+    /***************PTV************************/
+    tmpReg32 = 0;
+#ifdef FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            p_DtsecDriverParam->pauseTime += 2;
+    }
+#endif /* FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
+    if (p_DtsecDriverParam->pauseTime)
+        tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
+
+    if (p_DtsecDriverParam->pauseExtended)
+        tmpReg32 |= ((uint32_t)p_DtsecDriverParam->pauseExtended) << PTV_PTE_OFST;
+    WRITE_UINT32(p_DtsecMemMap->ptv, tmpReg32);
+    /***************PTV************************/
+
+    /***************TCTRL************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->halfDuplex)
+    {
+        if(p_DtsecDriverParam->halfDulexFlowControlEn)
+            tmpReg32 |= TCTRL_THDF;
+    }
+    else
+    {
+        if(p_DtsecDriverParam->txTimeStampEn)
+            tmpReg32 |= TCTRL_TTSE;
+    }
+    WRITE_UINT32(p_DtsecMemMap->tctrl, tmpReg32);
+    /***************TCTRL************************/
+
+    /***************RCTRL************************/
+    tmpReg32 = 0;
+    if (p_DtsecDriverParam->packetAlignmentPadding)
+        tmpReg32 |= ((uint32_t)(0x0000001f & p_DtsecDriverParam->packetAlignmentPadding)) << 16;
+    if (p_DtsecDriverParam->controlFrameAccept)
+        tmpReg32 |= RCTRL_CFA;
+    if (p_DtsecDriverParam->groupHashExtend)
+        tmpReg32 |= RCTRL_GHTX;
+    if(p_DtsecDriverParam->rxTimeStampEn)
+        tmpReg32 |= RCTRL_RTSE;
+    if (p_DtsecDriverParam->broadcReject)
+        tmpReg32 |= RCTRL_BC_REJ;
+    if (p_DtsecDriverParam->rxShortFrame)
+        tmpReg32 |= RCTRL_RSF;
+    if (p_DtsecDriverParam->promiscuousEnable)
+        tmpReg32 |= RCTRL_PROM;
+    if (p_DtsecDriverParam->exactMatch)
+        tmpReg32 |= RCTRL_EMEN;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+    /***************RCTRL************************/
+
+    /* Assign a Phy Address to the TBI (TBIPA).            */
+    /* Done also in case that TBI is not selected to avoid */
+    /* conflict with the external PHYs Physical address   */
+    WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
+
+    /* Reset the management interface */
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, MIIMCFG_RESET_MGMT);
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, ~MIIMCFG_RESET_MGMT);
+    /* Setup the MII Mgmt clock speed */
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
+                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
+
+    if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+    {
+        uint16_t            tmpReg16;
+
+        /* Configure the TBI PHY Control Register */
+        tmpReg16 = PHY_TBICON_SPEED2 | PHY_TBICON_SRESET;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+
+        tmpReg16 = PHY_TBICON_SPEED2;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+
+        if(!p_DtsecDriverParam->halfDuplex)
+            tmpReg16 |= PHY_CR_FULLDUPLEX | 0x8000 | PHY_CR_ANE;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+
+        tmpReg16 = 0x01a0;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
+
+        tmpReg16 = 0x1340;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+    }
+
+    /***************TMR_CTL************************/
+    WRITE_UINT32(p_DtsecMemMap->tmr_ctrl, 0);
+
+    if(p_Dtsec->ptpTsuEnabled)
+    {
+        tmpReg32 = 0;
+        if (p_Dtsec->enTsuErrExeption)
+            tmpReg32 |= PEMASK_TSRE;
+        WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg32);
+        WRITE_UINT32(p_DtsecMemMap->tmr_pevent, tmpReg32);
+    }
+
+    /***************DEBUG************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->debugMode)
+        WRITE_UINT32(p_DtsecMemMap->tsec_id1, TSEC_ID1_DEBUG);
+    /***************DEBUG************************/
+
+    /***************MACCFG1***********************/
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, MACCFG1_SOFT_RESET);
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, 0);
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->loopback)
+        tmpReg32 |= MACCFG1_LOOPBACK;
+    if(p_DtsecDriverParam->actOnRxPauseFrame)
+        tmpReg32 |= MACCFG1_RX_FLOW;
+    if(p_DtsecDriverParam->actOnTxPauseFrame)
+        tmpReg32 |= MACCFG1_TX_FLOW;
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, tmpReg32);
+    /***************MACCFG1***********************/
+
+    /***************MACCFG2***********************/
+    tmpReg32 = 0;
+    if( (p_Dtsec->enetMode == e_ENET_MODE_RMII_10)  ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)   ||
+        (p_Dtsec->enetMode == e_ENET_MODE_MII_100)  ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->preambleLength) & 0x0000000f)<< PREAMBLE_LENGTH_SHIFT;
+
+    if(p_DtsecDriverParam->preambleRxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Rx_EN;
+    if(p_DtsecDriverParam->preambleTxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Tx_EN;
+    if(p_DtsecDriverParam->lengthCheckEnable)
+        tmpReg32 |= MACCFG2_LENGTH_CHECK;
+    if(p_DtsecDriverParam->padAndCrcEnable)
+        tmpReg32 |=  MACCFG2_PAD_CRC_EN;
+    if(p_DtsecDriverParam->crcEnable)
+        tmpReg32 |= MACCFG2_CRC_EN;
+    if(!p_DtsecDriverParam->halfDuplex)
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+    /***************MACCFG2***********************/
+
+    /***************IPGIFG************************/
+    tmpReg32 = 0;
+    ASSERT_COND(p_DtsecDriverParam->nonBackToBackIpg1 <= p_DtsecDriverParam->nonBackToBackIpg2);
+    tmpReg32 = (uint32_t)((((uint32_t)p_DtsecDriverParam->nonBackToBackIpg1 <<
+               IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_1) |
+              (((uint32_t)p_DtsecDriverParam->nonBackToBackIpg2  <<
+                IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_2) |
+              (((uint32_t)p_DtsecDriverParam->minIfgEnforcement <<
+                IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT) & IPGIFG_MIN_IFG_ENFORCEMENT) |
+              ((uint32_t)p_DtsecDriverParam->backToBackIpg & IPGIFG_BACK_TO_BACK_IPG));
+    WRITE_UINT32(p_DtsecMemMap->ipgifg, tmpReg32);
+    /***************IPGIFG************************/
+
+    /***************HAFDUP************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->alternateBackoffEnable)
+    {
+        tmpReg32 = (uint32_t) (HAFDUP_ALT_BEB  | (((uint32_t)p_DtsecDriverParam->alternateBackoffVal & 0x0000000f) <<
+                                    HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT));
+    }
+
+    if(p_DtsecDriverParam->backPressureNoBackoff)
+        tmpReg32 |= HAFDUP_BP_NO_BACKOFF;
+    if(p_DtsecDriverParam->noBackoff)
+        tmpReg32 |= HAFDUP_NO_BACKOFF;
+    if(p_DtsecDriverParam->excessDefer)
+        tmpReg32 |= HAFDUP_EXCESS_DEFER;
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->maxRetransmission <<
+                HAFDUP_RETRANSMISSION_MAX_SHIFT )& HAFDUP_RETRANSMISSION_MAX);
+    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW);
+
+    WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
+    /***************HAFDUP************************/
+
+    /***************MAXFRM************************/
+    /* Initialize MAXFRM */
+    WRITE_UINT32(p_DtsecMemMap->maxfrm,
+                 p_DtsecDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId, p_DtsecDriverParam->maxFrameLength);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    /***************MAXFRM************************/
+
+    /***************CAM1************************/
+    WRITE_UINT32(p_DtsecMemMap->cam1,0xffffffff);
+    WRITE_UINT32(p_DtsecMemMap->cam2,0xffffffff);
+
+    /***************IMASK************************/
+    WRITE_UINT32(p_DtsecMemMap->imask, p_Dtsec->exceptions);
+    /***************IMASK************************/
+
+    /***************IEVENT************************/
+    WRITE_UINT32(p_DtsecMemMap->ievent, EVENTS_MASK);
+
+    /***************MACSTNADDR1/2*****************/
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+    addr = p_Dtsec->addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+    /***************MACSTNADDR1/2*****************/
+
+    /***************DEBUG*****************/
+    WRITE_UINT32(p_DtsecMemMap->tx_threshold,       (uint32_t)(p_DtsecDriverParam->fifoTxThr & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->tx_watermark_high,  (uint32_t)(p_DtsecDriverParam->fifoTxWatermarkH & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->rx_watermark_low,   (uint32_t)(p_DtsecDriverParam->fifoRxWatermarkL & 0x7f));
+    /***************DEBUG*****************/
+
+    /*****************HASH************************/
+    for(i=0 ; i<NUM_OF_HASH_REGS ; i++)
+    {
+        /* Initialize IADDRx */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[i], 0);
+        /* Initialize GADDRx */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[i], 0);
+    }
+
+    p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_MulticastAddrHash)
+    {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MC hash table is FAILED"));
+    }
+
+    p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("UC hash table is FAILED"));
+    }
+
+    /* register err intr handler for dtsec to FPM (err)*/
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR, DtsecErrException , p_Dtsec);
+    /* register 1588 intr handler for TMR to FPM (normal)*/
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, Dtsec1588Exception , p_Dtsec);
+    /* register normal intr handler for dtsec to main interrupt controller. */
+    if (p_Dtsec->mdioIrq != NO_IRQ)
+    {
+        XX_SetIntr(p_Dtsec->mdioIrq, DtsecException, p_Dtsec);
+        XX_EnableIntr(p_Dtsec->mdioIrq);
+    }
+
+    XX_Free(p_DtsecDriverParam);
+    p_Dtsec->p_DtsecDriverParam = NULL;
+
+    err = DtsecSetStatistics(p_Dtsec, e_FM_MAC_FULL_STATISTICS);
+    if(err)
+    {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+static t_Error DtsecFree(t_Handle h_Dtsec)
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    FreeInitResources(p_Dtsec);
+
+    if (p_Dtsec->p_DtsecDriverParam)
+    {
+        XX_Free(p_Dtsec->p_DtsecDriverParam);
+        p_Dtsec->p_DtsecDriverParam = NULL;
+    }
+    XX_Free (h_Dtsec);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = DtsecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = DtsecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetStatistics             = DtsecSetStatistics;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = DtsecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = DtsecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = NULL; /* Not supported on dTSEC */
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = DtsecConfigLengthCheck;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = DtsecSetExcpetion;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = DtsecRxIgnoreMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = DtsecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = DtsecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = DtsecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = DtsecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = DtsecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = DtsecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = DtsecGetMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = DTSEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = DTSEC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+
+/*****************************************************************************/
+/*                      dTSEC Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Dtsec             *p_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    uintptr_t           baseAddr;
+    uint8_t             *tmpEthAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    baseAddr = p_FmMacParam->baseAddr;
+    /* allocate memory for the UCC GETH data structure. */
+    p_Dtsec = (t_Dtsec *) XX_Malloc(sizeof(t_Dtsec));
+    if (!p_Dtsec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Dtsec */
+    memset(p_Dtsec, 0, sizeof(t_Dtsec));
+    InitFmMacControllerDriver(&p_Dtsec->fmMacControllerDriver);
+
+    /* allocate memory for the dTSEC driver parameters data structure. */
+    p_DtsecDriverParam = (t_DtsecDriverParam *) XX_Malloc(sizeof(t_DtsecDriverParam));
+    if (!p_DtsecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver parameters"));
+        DtsecFree(p_Dtsec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_DtsecDriverParam, 0, sizeof(t_DtsecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
+
+    SetDefaultParam(p_DtsecDriverParam);
+
+    tmpEthAddr = (uint8_t *)&p_Dtsec->addr;
+    memcpy(tmpEthAddr, p_FmMacParam->addr, sizeof(p_FmMacParam->addr));
+    p_Dtsec->addr             >>= 16;
+    p_Dtsec->p_MemMap           = (t_DtsecMemMap *)UINT_TO_PTR(baseAddr);
+    p_Dtsec->p_MiiMemMap        = (t_MiiAccessMemMap *)UINT_TO_PTR(baseAddr + DTSEC_TO_MII_OFFSET);
+    p_Dtsec->enetMode           = p_FmMacParam->enetMode;
+    p_Dtsec->macId              = p_FmMacParam->macId;
+    p_Dtsec->exceptions         = DEFAULT_exceptions;
+    p_Dtsec->mdioIrq            = p_FmMacParam->mdioIrq;
+    p_Dtsec->f_Exception        = p_FmMacParam->f_Exception;
+    p_Dtsec->f_Event            = p_FmMacParam->f_Event;
+    p_Dtsec->h_App              = p_FmMacParam->h_App;
+
+    return p_Dtsec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
new file mode 100644
index 0000000..3a53077
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -0,0 +1,634 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.h
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+#ifndef __DTSEC_H
+#define __DTSEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "dtsec_mii_acc.h"
+#include "fm_mac.h"
+
+
+#define PEMASK_TSRE                 0x00010000
+
+#define IMASK_BREN                  0x80000000
+#define IMASK_RXCEN                 0x40000000
+#define IMASK_MSROEN                0x04000000
+#define IMASK_GTSCEN                0x02000000
+#define IMASK_BTEN                  0x01000000
+#define IMASK_TXCEN                 0x00800000
+#define IMASK_TXEEN                 0x00400000
+#define IMASK_LCEN                  0x00040000
+#define IMASK_CRLEN                 0x00020000
+#define IMASK_XFUNEN                0x00010000
+#define IMASK_ABRTEN                0x00008000
+#define IMASK_IFERREN               0x00004000
+#define IMASK_MAGEN                 0x00000800
+#define IMASK_MMRDEN                0x00000400
+#define IMASK_MMWREN                0x00000200
+#define IMASK_GRSCEN                0x00000100
+#define IMASK_TDPEEN                0x00000002
+#define IMASK_RDPEEN                0x00000001
+
+#define EVENTS_MASK                 ((uint32_t)(IMASK_BREN    | \
+                                                IMASK_RXCEN   | \
+                                                IMASK_MSROEN  | \
+                                                IMASK_GTSCEN  | \
+                                                IMASK_BTEN    | \
+                                                IMASK_TXCEN   | \
+                                                IMASK_TXEEN   | \
+                                                IMASK_ABRTEN  | \
+                                                IMASK_LCEN    | \
+                                                IMASK_CRLEN   | \
+                                                IMASK_XFUNEN  | \
+                                                IMASK_IFERREN | \
+                                                IMASK_MAGEN   | \
+                                                IMASK_MMRDEN  | \
+                                                IMASK_MMWREN  | \
+                                                IMASK_GRSCEN  | \
+                                                IMASK_TDPEEN  | \
+                                                IMASK_RDPEEN))
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_MAC_EX_1G_BAB_RX:                                   \
+        bitMask = IMASK_BREN; break;                              \
+    case e_FM_MAC_EX_1G_RX_CTL:                                   \
+        bitMask = IMASK_RXCEN; break;                             \
+    case e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:                  \
+        bitMask = IMASK_GTSCEN ; break;                           \
+    case e_FM_MAC_EX_1G_BAB_TX:                                   \
+        bitMask = IMASK_BTEN   ; break;                           \
+    case e_FM_MAC_EX_1G_TX_CTL:                                   \
+        bitMask = IMASK_TXCEN  ; break;                           \
+    case e_FM_MAC_EX_1G_TX_ERR:                                   \
+        bitMask = IMASK_TXEEN  ; break;                           \
+    case e_FM_MAC_EX_1G_LATE_COL:                                 \
+        bitMask = IMASK_LCEN   ; break;                           \
+    case e_FM_MAC_EX_1G_COL_RET_LMT:                              \
+        bitMask = IMASK_CRLEN  ; break;                           \
+    case e_FM_MAC_EX_1G_TX_FIFO_UNDRN:                            \
+        bitMask = IMASK_XFUNEN ; break;                           \
+    case e_FM_MAC_EX_1G_MAG_PCKT:                                 \
+        bitMask = IMASK_MAGEN ; break;                            \
+    case e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET:                       \
+        bitMask = IMASK_MMRDEN; break;                            \
+    case e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET:                       \
+        bitMask = IMASK_MMWREN  ; break;                          \
+    case e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:                  \
+        bitMask = IMASK_GRSCEN; break;                            \
+    case e_FM_MAC_EX_1G_TX_DATA_ERR:                              \
+        bitMask = IMASK_TDPEEN; break;                            \
+    case e_FM_MAC_EX_1G_RX_DATA_ERR:                              \
+        bitMask = IMASK_RDPEEN ; break;                           \
+    default: bitMask = 0;break;}
+
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+/********************* From mac ext ******************************************/
+typedef  uint32_t t_ErrorDisable;
+
+#define ERROR_DISABLE_TRANSMIT              0x00400000
+#define ERROR_DISABLE_LATE_COLLISION        0x00040000
+#define ERROR_DISABLE_COLLISION_RETRY_LIMIT 0x00020000
+#define ERROR_DISABLE_TxFIFO_UNDERRUN       0x00010000
+#define ERROR_DISABLE_TxABORT               0x00008000
+#define ERROR_DISABLE_INTERFACE             0x00004000
+#define ERROR_DISABLE_TxDATA_PARITY         0x00000002
+#define ERROR_DISABLE_RxDATA_PARITY         0x00000001
+
+/*****************************************************************************/
+#define DTSEC_NUM_OF_PADDRS             15  /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS                   0x0000010000000000LL /* Group address bit indication */
+
+#define HASH_TABLE_SIZE                 256 /* Hash table size (= 32 bits * 8 regs) */
+
+#define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
+
+#define DEFAULT_errorDisabled           0
+#define DEFAULT_promiscuousEnable       FALSE
+#define DEFAULT_pauseExtended           0x0
+#define DEFAULT_pauseTime               0xf000
+#define DEFAULT_halfDuplex              FALSE
+#define DEFAULT_halfDulexFlowControlEn  FALSE
+#define DEFAULT_txTimeStampEn           FALSE
+#define DEFAULT_rxTimeStampEn           FALSE
+#define DEFAULT_packetAlignment         0
+#define DEFAULT_controlFrameAccept      FALSE
+#define DEFAULT_groupHashExtend         FALSE
+#define DEFAULT_broadcReject            FALSE
+#define DEFAULT_rxShortFrame            TRUE
+#define DEFAULT_exactMatch              FALSE
+#define DEFAULT_debugMode               FALSE
+#define DEFAULT_loopback                FALSE
+#define DEFAULT_actOnRxPauseFrame       TRUE
+#define DEFAULT_actOnTxPauseFrame       TRUE
+
+#define DEFAULT_PreAmLength             0x7
+#define DEFAULT_PreAmRxEn               FALSE
+#define DEFAULT_PreAmTxEn               FALSE
+#define DEFAULT_lengthCheckEnable       FALSE
+#define DEFAULT_padAndCrcEnable         TRUE
+#define DEFAULT_crcEnable               FALSE
+
+#define DEFAULT_nonBackToBackIpg1       0x40
+#define DEFAULT_nonBackToBackIpg2       0x60
+#define DEFAULT_minIfgEnforcement       0x50
+#define DEFAULT_backToBackIpg           0x60
+
+#define DEFAULT_altBackoffVal           0x0A
+#define DEFAULT_altBackoffEnable        FALSE
+#define DEFAULT_backPressureNoBackoff   FALSE
+#define DEFAULT_noBackoff               FALSE
+#define DEFAULT_excessDefer             TRUE
+#define DEFAULT_maxRetransmission       0x0F
+#define DEFAULT_collisionWindow         0x37
+
+#define DEFAULT_maxFrameLength          0x600
+
+#define DEFAULT_collisionWindow         0x37
+
+#define DEFAULT_fifoTxThr               0x10
+#define DEFAULT_fifoTxWatermarkH        0x7e
+#define DEFAULT_fifoRxWatermarkL        0x08
+#define DEFAULT_tbiPhyAddr              5
+
+#define DEFAULT_exceptions              ((uint32_t)(IMASK_BREN    | \
+                                                    IMASK_RXCEN   | \
+                                                    IMASK_BTEN    | \
+                                                    IMASK_TXCEN   | \
+                                                    IMASK_TXEEN   | \
+                                                    IMASK_ABRTEN  | \
+                                                    IMASK_LCEN    | \
+                                                    IMASK_CRLEN   | \
+                                                    IMASK_XFUNEN  | \
+                                                    IMASK_IFERREN | \
+                                                    IMASK_MAGEN   | \
+                                                    IMASK_TDPEEN  | \
+                                                    IMASK_RDPEEN))
+
+
+#define MAX_PHYS                    32 /* maximum number of phys */
+
+#define DTSEC_ID1_ID                0xffff0000
+#define DTSEC_ID1_REV_MJ            0x0000FF00
+#define DTSEC_ID1_REV_MN            0x000000ff
+
+#define ID2_INT_REDUCED_OFF         0x00010000
+#define ID2_INT_NORMAL_OFF          0x00020000
+
+#define ECNTRL_CLRCNT               0x00004000
+#define ECNTRL_AUTOZ                0x00002000
+#define ECNTRL_STEN                 0x00001000
+#define ECNTRL_CFG_RO               0x80000000
+#define ECNTRL_GMIIM                0x00000040
+#define ECNTRL_TBIM                 0x00000020
+#define ECNTRL_SGMIIM               0x00000002
+#define ECNTRL_RPM                  0x00000010
+#define ECNTRL_R100M                0x00000008
+#define ECNTRL_RMM                  0x00000004
+#define ECNTRL_QSGMIIM              0x00000001
+
+#define TCTRL_THDF                  0x00000800
+#define TCTRL_TTSE                  0x00000040
+#define TCTRL_GTS                   0x00000020
+#define TCTRL_TFC_PAUSE             0x00000010
+
+/* PTV offsets */
+#define PTV_PTE_OFST                16
+
+#define RCTRL_CFA                   0x00008000
+#define RCTRL_GHTX                  0x00000400
+#define RCTRL_RTSE                  0x00000040
+#define RCTRL_GRS                   0x00000020
+#define RCTRL_BC_REJ                0x00000010
+#define RCTRL_MPROM                 0x00000008
+#define RCTRL_RSF                   0x00000004
+#define RCTRL_EMEN                  0x00000002
+#define RCTRL_UPROM                 0x00000001
+#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
+
+#define TMR_CTL_ESFDP               0x00000800
+#define TMR_CTL_ESFDE               0x00000400
+
+#define TSEC_ID1_DEBUG              0x00e00c00
+#define DEBUG_ENABLE                0x80000000
+#define DPERROR_Tx_ERROR_ON_SEC     0x00400000
+#define DPERROR_Tx_ERROR_ON_WRITE   0x10000000
+#define DPERROR_Rx_ERROR_ON_SEC     0x00000040
+#define DPERROR_Rx_ERROR_ON_WRITE   0x00001000
+#define DPERROR_STT                 0x80000000
+#define DPERROR_STR                 0x00008000
+
+#define MACCFG1_SOFT_RESET          0x80000000
+#define MACCFG1_LOOPBACK            0x00000100
+#define MACCFG1_RX_FLOW             0x00000020
+#define MACCFG1_TX_FLOW             0x00000010
+#define MACCFG1_TX_EN               0x00000001
+#define MACCFG1_RX_EN               0x00000004
+#define MACCFG1_RESET_RxMC          0x00080000
+#define MACCFG1_RESET_TxMC          0x00040000
+#define MACCFG1_RESET_RxFUN         0x00020000
+#define MACCFG1_RESET_TxFUN         0x00010000
+
+#define MACCFG2_NIBBLE_MODE         0x00000100
+#define MACCFG2_BYTE_MODE           0x00000200
+#define MACCFG2_PRE_AM_Rx_EN        0x00000080
+#define MACCFG2_PRE_AM_Tx_EN        0x00000040
+#define MACCFG2_LENGTH_CHECK        0x00000010
+#define MACCFG2_MAGIC_PACKET_EN     0x00000008
+#define MACCFG2_PAD_CRC_EN          0x00000004
+#define MACCFG2_CRC_EN              0x00000002
+#define MACCFG2_FULL_DUPLEX         0x00000001
+
+#define PREAMBLE_LENGTH_SHIFT       12
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
+#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
+#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
+#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
+
+#define HAFDUP_ALT_BEB                   0x00080000
+#define HAFDUP_BP_NO_BACKOFF             0x00040000
+#define HAFDUP_NO_BACKOFF                0x00020000
+#define HAFDUP_EXCESS_DEFER              0x00010000
+#define HAFDUP_COLLISION_WINDOW          0x000003ff
+
+#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT    20
+#define HAFDUP_RETRANSMISSION_MAX_SHIFT          12
+#define HAFDUP_RETRANSMISSION_MAX       0x0000f000
+
+#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
+
+#define DEBUG_GET_FIFO_READ_INDEX       0x007f0000
+#define DEBUG_GET_FIFO_WRITE_INDEX      0x0000007f
+/* Pause Time Value Register  */
+#define PTV_PTE_SHIFT    16
+
+#define     MASK22BIT   0x003FFFFF
+#define     MASK16BIT   0x0000FFFF
+#define     MASK12BIT   0x00000FFF
+#define     MASK8BIT    0x000000FF
+
+#define     VAL32BIT    0x100000000LL
+#define     VAL22BIT    0x00400000
+#define     VAL16BIT    0x00010000
+#define     VAL12BIT    0x00001000
+
+/* PHY Control Register */
+#define PHY_CR_LOOPBACK     0x4000
+#define PHY_CR_SPEED0       0x2000
+#define PHY_CR_ANE          0x1000
+#define PHY_CR_FULLDUPLEX   0x0100
+#define PHY_CR_SPEED1       0x0040
+
+#define PHY_TBICON_SRESET   0x8000
+#define PHY_TBICON_SPEED2   0x0020
+
+/* CAR1/2 bits */
+#define CAR1_TR64   0x80000000
+#define CAR1_TR127  0x40000000
+#define CAR1_TR255  0x20000000
+#define CAR1_TR511  0x10000000
+#define CAR1_TRK1   0x08000000
+#define CAR1_TRMAX  0x04000000
+#define CAR1_TRMGV  0x02000000
+
+#define CAR1_RBYT   0x00010000
+#define CAR1_RPKT   0x00008000
+#define CAR1_RMCA   0x00002000
+#define CAR1_RBCA   0x00001000
+#define CAR1_RXPF   0x00000400
+#define CAR1_RALN   0x00000100
+#define CAR1_RFLR   0x00000080
+#define CAR1_RCDE   0x00000040
+#define CAR1_RCSE   0x00000020
+#define CAR1_RUND   0x00000010
+#define CAR1_ROVR   0x00000008
+#define CAR1_RFRG   0x00000004
+#define CAR1_RJBR   0x00000002
+#define CAR1_RDRP   0x00000001
+
+#define CAR2_TFCS   0x00040000
+#define CAR2_TBYT   0x00002000
+#define CAR2_TPKT   0x00001000
+#define CAR2_TMCA   0x00000800
+#define CAR2_TBCA   0x00000400
+#define CAR2_TXPF   0x00000200
+#define CAR2_TDRP   0x00000001
+
+#define CAM1_ERRORS_ONLY (CAR1_RXPF |   \
+                            CAR1_RALN | \
+                            CAR1_RFLR | \
+                            CAR1_RCDE | \
+                            CAR1_RCSE | \
+                            CAR1_RUND | \
+                            CAR1_ROVR | \
+                            CAR1_RFRG | \
+                            CAR1_RJBR | \
+                            CAR1_RDRP)
+
+#define CAM2_ERRORS_ONLY (CAR2_TFCS | CAR2_TXPF | CAR2_TDRP)
+
+typedef struct t_InternalStatistics
+{
+    uint64_t    tr64;
+    uint64_t    tr127;
+    uint64_t    tr255;
+    uint64_t    tr511;
+    uint64_t    tr1k;
+    uint64_t    trmax;
+    uint64_t    trmgv;
+    uint64_t    rfrg;
+    uint64_t    rjbr;
+    uint64_t    rdrp;
+    uint64_t    raln;
+    uint64_t    rund;
+    uint64_t    rovr;
+    uint64_t    rxpf;
+    uint64_t    txpf;
+    uint64_t    rbyt;
+    uint64_t    rpkt;
+    uint64_t    rmca;
+    uint64_t    rbca;
+    uint64_t    rflr;
+    uint64_t    rcde;
+    uint64_t    rcse;
+    uint64_t    tbyt;
+    uint64_t    tpkt;
+    uint64_t    tmca;
+    uint64_t    tbca;
+    uint64_t    tdrp;
+    uint64_t    tfcs;
+} t_InternalStatistics;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    uint32_t exact_match1; /* octets 1-4 */
+    uint32_t exact_match2; /* octets 5-6 */
+} _PackedType macRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t tsec_id1;             /* 0x000 ETSEC_ID register */
+    volatile uint32_t tsec_id2;             /* 0x004 ETSEC_ID2 register */
+    volatile uint32_t ievent;               /* 0x008 Interrupt event register */
+    volatile uint32_t imask;                /* 0x00C Interrupt mask register */
+    volatile uint32_t edis;                 /* 0x010 Error disabled register */
+    volatile uint32_t ecntrl;               /* 0x014 E control register */
+    volatile uint32_t ptv;                  /* 0x018 Pause time value register */
+    volatile uint32_t tbipa;                /* 0x01C TBI PHY address register */
+    volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
+    volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
+    volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
+    volatile uint32_t DTSEC_RESERVED2;      /* 0x02C */
+    volatile uint32_t iobistctl;            /* 0x030 IO BIST Control register */
+    volatile uint32_t DTSEC_RESERVED3[3];   /* 0x034 */
+
+    volatile uint32_t tctrl;                /* 0x040 Transmit control register */
+    volatile uint32_t DTSEC_RESERVED4[3];   /* 0x044-0x04C */
+    volatile uint32_t rctrl;                /* 0x050 Receive control register */
+    volatile uint32_t DTSEC_RESERVED5[11];  /* 0x054- 0x07C */
+
+    volatile uint32_t igaddr[8];            /* 0x080-0x09C Individual/group address registers 0-7 */
+    volatile uint32_t gaddr[8];             /* 0x0A0-0x0BC Group address registers 0-7 */
+    volatile uint32_t ETSEC_RESERVED6[16];  /* 0x0C0-0x0FC */
+
+    volatile uint32_t maccfg1;              /* 0x100 MAC configuration #1 */
+    volatile uint32_t maccfg2;              /* 0x104 MAC configuration #2 */
+    volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
+    volatile uint32_t hafdup;               /* 0x10C Half-duplex */
+    volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
+    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x114-0x11C register */
+    t_MiiAccessMemMap miiMemMap;
+    volatile uint32_t ifctrl;               /* 0x138 MII Mgmt:interface control */
+    volatile uint32_t ifstat;               /* 0x13C Interface status */
+    volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
+    volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
+    volatile macRegs  macaddr[DTSEC_NUM_OF_PADDRS]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
+    volatile uint32_t DTSEC_RESERVED8[16];  /* 0x1C0-0x1FC register */
+
+    /*  RMON MIB REGISTERS  */
+    /*  TRANSMIT and RECEIVE COUNTERS   */
+
+    volatile uint32_t tr64;            /* 0x200 transmit and receive 64 byte frame counter */
+    volatile uint32_t tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
+    volatile uint32_t tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
+    volatile uint32_t tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
+    volatile uint32_t tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
+    volatile uint32_t trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
+    volatile uint32_t trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
+
+    /* RECEIVE COUNTERS */
+    volatile uint32_t rbyt;            /* 0x21C receive byte counter */
+    volatile uint32_t rpkt;            /* 0x220 receive packet counter */
+    volatile uint32_t rfcs;            /* 0x224 receive FCS error counter */
+    volatile uint32_t rmca;            /* 0x228 RMCA receive multicast packet counter */
+    volatile uint32_t rbca;            /* 0x22C receive broadcast packet counter */
+    volatile uint32_t rxcf;            /* 0x230 receive control frame packet counter */
+    volatile uint32_t rxpf;            /* 0x234 receive PAUSE frame packet counter */
+    volatile uint32_t rxuo;            /* 0x238 receive unknown OP code counter */
+    volatile uint32_t raln;            /* 0x23C receive alignment error counter */
+    volatile uint32_t rflr;            /* 0x240 receive frame length error counter */
+    volatile uint32_t rcde;            /* 0x244 receive code error counter */
+    volatile uint32_t rcse;            /* 0x248 receive carrier sense error counter */
+    volatile uint32_t rund;            /* 0x24C receive undersize packet counter */
+    volatile uint32_t rovr;            /* 0x250 receive oversize packet counter */
+    volatile uint32_t rfrg;            /* 0x254 receive fragments counter */
+    volatile uint32_t rjbr;            /* 0x258 receive jabber counter */
+    volatile uint32_t rdrp;            /* 0x25C receive drop */
+
+    /* TRANSMIT COUNTERS */
+    volatile uint32_t tbyt;            /* 0x260 transmit byte counter */
+    volatile uint32_t tpkt;            /* 0x264 transmit packet counter */
+    volatile uint32_t tmca;            /* 0x268 transmit multicast packet counter */
+    volatile uint32_t tbca;            /* 0x26C transmit broadcast packet counter */
+    volatile uint32_t txpf;            /* 0x270 transmit PAUSE control frame counter */
+    volatile uint32_t tdfr;            /* 0x274 transmit deferral packet counter */
+    volatile uint32_t tedf;            /* 0x278 transmit excessive deferral packet counter */
+    volatile uint32_t tscl;            /* 0x27C transmit single collision packet counter */
+    volatile uint32_t tmcl;            /* 0x280 transmit multiple collision packet counter */
+    volatile uint32_t tlcl;            /* 0x284 transmit late collision packet counter */
+    volatile uint32_t txcl;            /* 0x288 transmit excessive collision packet counter */
+    volatile uint32_t tncl;            /* 0x28C transmit total collision counter */
+    volatile uint32_t DTSEC_RESERVED9; /* 0x290 */
+    volatile uint32_t tdrp;            /* 0x294 transmit drop frame counter */
+    volatile uint32_t tjbr;            /* 0x298 transmit jabber frame counter */
+    volatile uint32_t tfcs;            /* 0x29C transmit FCS error counter */
+    volatile uint32_t txcf;            /* 0x2A0 transmit control frame counter */
+    volatile uint32_t tovr;            /* 0x2A4 transmit oversize frame counter */
+    volatile uint32_t tund;            /* 0x2A8 transmit undersize frame counter */
+    volatile uint32_t tfrg;            /* 0x2AC transmit fragments frame counter */
+
+    /* GENERAL REGISTERS */
+    volatile uint32_t car1;            /* 0x2B0 carry register one register* */
+    volatile uint32_t car2;            /* 0x2B4 carry register two register* */
+    volatile uint32_t cam1;            /* 0x2B8 carry register one mask register */
+    volatile uint32_t cam2;            /* 0x2BC carry register two mask register */
+    volatile uint32_t DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
+
+    /* Debug and Factory Test Registers */
+    volatile uint32_t debug;            /* 0x300 DEBUG - Debug Register */
+    volatile uint32_t dperror;          /* 0x304 DPERROR - Parity Error Register */
+    volatile uint32_t hwassert;         /* 0x308 HWASSERT */
+    volatile uint32_t RESERVED11;       /* 0x30C Reserved */
+    volatile uint32_t rx_fifo_ptr;      /* 0x310 RXFIFOPTR - Rx FIFO R/W Pointer Register */
+    volatile uint32_t rx_fifo_dath;     /* 0x314 RXFIFODATH - Rx FIFO Data Register */
+    volatile uint32_t rx_fifo_datl;     /* 0x318 RXFIFODATL - Rx FIFO Data Register */
+    volatile uint32_t rx_fifo_stat;     /* 0x31C RXFIFOSTAT - Rx FIFO Status Register */
+    volatile uint32_t tx_fifo_ptr;      /* 0x320 TXFIFOPTR - Tx FIFO R/W Pointer Register */
+    volatile uint32_t tx_fifo_dath;     /* 0x324 TXFIFODATH - Rx FIFO Data Register */
+    volatile uint32_t tx_fifo_datl;     /* 0x328 TXFIFODATL - Rx FIFO Data Register */
+    volatile uint32_t tx_fifo_stat;     /* 0x32C TXFIFOSTAT - Tx FIFO Status Register */
+    volatile uint32_t pkt_rcv_cnt;      /* 0x330 PKTRCVCNT - Number of packets accepted and written to Rx FIFO */
+    volatile uint32_t RESERVED12[3];    /* 0x334-0x33C Reserved */
+    volatile uint32_t tx_threshold;     /* 0x340 Transmit threshold; Number of entries (4 bytes units) before starting to transmit to the MAC */
+    volatile uint32_t tx_watermark_high;/* 0x344 Transmit watermark high; Number of entries (4 byte units) before de-asserting Ready to packet Interface */
+    volatile uint32_t rx_watermark_low; /* 0x348 Receive watermark low; Number of entries (4 byte units) before unloading to packet Interface */
+} _PackedType t_DtsecMemMap;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct {
+    uint32_t    errorDisabled;
+    bool        halfDuplex;
+    uint16_t    pauseTime;
+    uint16_t    pauseExtended;
+    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr] */
+
+    bool        autoZeroCounters;
+    bool        promiscuousEnable;
+
+    bool        halfDulexFlowControlEn;
+    bool        txTimeStampEn;
+    bool        rxTimeStampEn;
+
+    uint8_t     packetAlignmentPadding;
+    bool        controlFrameAccept;
+    bool        groupHashExtend;
+    bool        broadcReject;
+    bool        rxShortFrame;
+    bool        exactMatch;
+
+    bool        debugMode;
+
+    bool        loopback;
+    bool        actOnRxPauseFrame;
+    bool        actOnTxPauseFrame;
+
+    uint8_t     nonBackToBackIpg1;
+    uint8_t     nonBackToBackIpg2;
+    uint8_t     minIfgEnforcement;
+    uint8_t     backToBackIpg;
+
+    uint8_t     preambleLength;
+    bool        preambleRxEn;
+    bool        preambleTxEn;
+    bool        lengthCheckEnable;
+    bool        magicPacketEnable;
+    bool        padAndCrcEnable;
+    bool        crcEnable;
+
+    bool        alternateBackoffEnable;
+    uint8_t     alternateBackoffVal;
+    bool        backPressureNoBackoff;
+    bool        noBackoff;
+    bool        excessDefer;
+    uint8_t     maxRetransmission;
+    uint16_t    collisionWindow;
+
+    uint16_t    maxFrameLength;
+
+    uint8_t     fifoTxThr;
+    uint8_t     fifoTxWatermarkH;
+    uint8_t     fifoRxWatermarkL;
+} t_DtsecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;
+    t_Handle                    h_App;            /**< Handle to the upper layer application              */
+    t_DtsecMemMap               *p_MemMap;        /**< pointer to dTSEC memory mapped registers.          */
+    t_MiiAccessMemMap           *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
+    uint64_t                    addr;             /**< MAC address of device;                             */
+    e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exception;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Event;
+    bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
+    bool                        debugMode;
+    bool                        halfDuplex;
+    t_InternalStatistics        internalStatistics;
+    t_EthHash                   *p_MulticastAddrHash;      /* pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;    /* pointer to driver's individual address hash table  */
+    uint8_t                     macId;
+    uint32_t                    exceptions;
+    bool                        ptpTsuEnabled;
+    bool                        enTsuErrExeption;
+    e_FmMacStatisticsLevel      statisticsLevel;
+
+    t_DtsecDriverParam          *p_DtsecDriverParam;
+} t_Dtsec;
+
+
+t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __DTSEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
new file mode 100644
index 0000000..be85fa2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -0,0 +1,120 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec_mii_acc.c
+
+ @Description   FM dtsec MII register access MAC ...
+*//***************************************************************************/
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "dtsec.h"
+
+
+/*****************************************************************************/
+t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
+                              uint8_t     phyAddr,
+                              uint8_t     reg,
+                              uint16_t    data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Stop the MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Setting up MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Setting up MII Management Control Register with data */
+    WRITE_UINT32(p_MiiAccess->miimcon, (uint32_t)data);
+    /* Dummy read to make sure MIIMCON is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcon);
+
+    /* Wait till MII management write is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
+                             uint8_t  phyAddr,
+                             uint8_t  reg,
+                             uint16_t *p_Data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Setting up the MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Perform an MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, MIIMCOM_READ_CYCLE);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Wait till MII management read is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    /* Read MII management status  */
+    *p_Data = (uint16_t)GET_UINT32(p_MiiAccess->miimstat);
+
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    if (*p_Data == 0xffff)
+        RETURN_ERROR(MINOR, E_NO_DEVICE,
+                     ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
+                      phyAddr, reg));
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
new file mode 100644
index 0000000..7c529c2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -0,0 +1,78 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DTSEC_MII_ACC_H
+#define __DTSEC_MII_ACC_H
+
+#include "std_ext.h"
+
+
+/* MII Management Configuration Register */
+#define MIIMCFG_RESET_MGMT          0x80000000
+#define MIIMCFG_MGMT_CLOCK_SELECT   0x00000007
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_CYCLE          0x00000001
+#define MIIMCOM_SCAN_CYCLE          0x00000002
+
+/* MII  Management Address Register */
+#define MIIMADD_PHY_ADDR_SHIFT      8
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_MiiAccessMemMap
+{
+    volatile uint32_t miimcfg;    /* MII Mgmt:configuration */
+    volatile uint32_t miimcom;    /* MII Mgmt:command       */
+    volatile uint32_t miimadd;    /* MII Mgmt:address       */
+    volatile uint32_t miimcon;    /* MII Mgmt:control 3     */
+    volatile uint32_t miimstat;   /* MII Mgmt:status        */
+    volatile uint32_t miimind;    /* MII Mgmt:indicators    */
+} _PackedType t_MiiAccessMemMap ;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+#endif /* __DTSEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
new file mode 100644
index 0000000..4eb3954
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -0,0 +1,560 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.c
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "error_ext.h"
+#include "fm_ext.h"
+
+#include "fm_common.h"
+#include "fm_mac.h"
+
+
+/* ........................................................................... */
+
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
+
+    if(ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
+        p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
+    else
+       p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+
+    if (!p_FmMacControllerDriver)
+        return NULL;
+
+    p_FmMacControllerDriver->h_Fm           = p_FmMacParam->h_Fm;
+    p_FmMacControllerDriver->enetMode       = p_FmMacParam->enetMode;
+    p_FmMacControllerDriver->macId          = p_FmMacParam->macId;
+    p_FmMacControllerDriver->resetOnInit    = DEFAULT_resetOnInit;
+
+    return (t_Handle)p_FmMacControllerDriver;
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Init (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->resetOnInit &&
+        (FmResetMac(p_FmMacControllerDriver->h_Fm,
+                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ? e_FM_MAC_10G : e_FM_MAC_1G),
+                     p_FmMacControllerDriver->macId) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
+
+    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Init)
+        return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Free (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Free)
+        return p_FmMacControllerDriver->f_FM_MAC_Free(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    p_FmMacControllerDriver->resetOnInit = enable;
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength(h_FmMac, newVal);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool flag)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigWan)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigWan(h_FmMac, flag);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex(h_FmMac,newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck(h_FmMac,newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigException (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigException)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigException(h_FmMac, ex, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+
+/*****************************************************************************/
+/* Run Time Control                                                          */
+/*****************************************************************************/
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Enable)
+        return p_FmMacControllerDriver->f_FM_MAC_Enable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Disable)
+        return p_FmMacControllerDriver->f_FM_MAC_Disable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Enable1588TimeStamp (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp)
+        return p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp)
+        return p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames(h_FmMac, pauseTime);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames(h_FmMac, en);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ResetCounters)
+        return p_FmMacControllerDriver->f_FM_MAC_ResetCounters(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetException)
+        return p_FmMacControllerDriver->f_FM_MAC_SetException(h_FmMac, ex, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_SetStatistics(h_FmMac, statisticsLevel);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_GetStatistics(h_FmMac, p_Statistics);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *macVresion)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetVersion)
+        return p_FmMacControllerDriver->f_FM_MAC_GetVersion(h_FmMac, macVresion);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *macId)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetId)
+        return p_FmMacControllerDriver->f_FM_MAC_GetId(h_FmMac, macId);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous)
+        return p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AdjustLink)
+        return p_FmMacControllerDriver->f_FM_MAC_AdjustLink(h_FmMac, speed, fullDuplex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg(h_FmMac, phyAddr, reg, data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg(h_FmMac, phyAddr, reg, p_Data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+uint16_t FM_MAC_GetMaxFrameLength(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacControllerDriver, E_INVALID_HANDLE, 0);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength)
+        return p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength(h_FmMac);
+
+    REPORT_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return 0;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/*****************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_DumpRegs)
+         return p_FmMacControllerDriver->f_FM_MAC_DumpRegs(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
new file mode 100644
index 0000000..9a64f14
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -0,0 +1,197 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_H
+#define __FM_MAC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_mac_ext.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_MAC
+
+
+#define DEFAULT_resetOnInit                 FALSE
+
+
+typedef struct {
+    uint64_t addr;      /* Ethernet Address  */
+    t_List   node;
+} t_EthHashEntry;
+#define ETH_HASH_ENTRY_OBJ(ptr) LIST_OBJECT(ptr, t_EthHashEntry, node)
+
+typedef struct {
+    uint16_t    size;
+    t_List      *p_Lsts;
+} t_EthHash;
+
+typedef struct {
+    t_Error (*f_FM_MAC_Init) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Free) (t_Handle h_FmMac);
+
+    t_Error (*f_FM_MAC_SetStatistics) (t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
+    t_Error (*f_FM_MAC_ConfigLoopback) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigMaxFrameLength) (t_Handle h_FmMac, uint16_t newVal);
+    t_Error (*f_FM_MAC_ConfigWan) (t_Handle h_FmMac, bool flag);
+    t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigLengthCheck) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    t_Error (*f_FM_MAC_ConfigSkipFman11Workaround) (t_Handle h_FmMac);
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+    t_Error (*f_FM_MAC_SetException) (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
+    t_Error (*f_FM_MAC_Enable)  (t_Handle h_FmMac,  e_CommMode mode);
+    t_Error (*f_FM_MAC_Disable) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Enable1588TimeStamp) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Disable1588TimeStamp) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
+
+    t_Error (*f_FM_MAC_SetTxAutoPauseFrames)   (t_Handle h_FmMac, uint16_t pauseTime);
+    t_Error (*f_FM_MAC_SetRxIgnorePauseFrames) (t_Handle h_FmMac, bool en);
+
+    t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_GetStatistics) (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+    t_Error (*f_FM_MAC_ModifyMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemoveHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemovelExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+    t_Error (*f_FM_MAC_SetPromiscuous) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_AdjustLink)     (t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+    t_Error (*f_FM_MAC_GetId) (t_Handle h_FmMac, uint32_t *macId);
+
+    t_Error (*f_FM_MAC_GetVersion) (t_Handle h_FmMac, uint32_t *macVersion);
+
+    uint16_t (*f_FM_MAC_GetMaxFrameLength) (t_Handle h_FmMac);
+
+    t_Error (*f_FM_MAC_MII_WritePhyReg)(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+    t_Error (*f_FM_MAC_MII_ReadPhyReg)(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_Error (*f_FM_MAC_DumpRegs) (t_Handle h_FmMac);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+    t_Handle        h_Fm;
+    e_EnetMode      enetMode;
+    uint8_t         macId;
+    bool            resetOnInit;
+    uint16_t        clkFreq;
+} t_FmMacControllerDriver;
+
+
+t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
+t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
+uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
+
+
+/* ........................................................................... */
+
+static __inline__ t_EthHashEntry *DequeueAddrFromHashEntry(t_List *p_AddrLst)
+{
+   t_EthHashEntry *p_HashEntry = NULL;
+    if (!LIST_IsEmpty(p_AddrLst))
+    {
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_AddrLst->p_Next);
+        LIST_DelAndInit(&p_HashEntry->node);
+    }
+    return p_HashEntry;
+}
+
+/* ........................................................................... */
+
+static __inline__ void FreeHashTable(t_EthHash *p_Hash)
+{
+    t_EthHashEntry  *p_HashEntry;
+    int             i = 0;
+
+    if (!p_Hash || !p_Hash->p_Lsts)
+        return;
+
+    for(i=0; i<p_Hash->size; i++)
+    {
+        p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        while (p_HashEntry)
+        {
+            XX_Free(p_HashEntry);
+            p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        }
+    }
+
+    XX_Free(p_Hash->p_Lsts);
+    XX_Free(p_Hash);
+}
+
+/* ........................................................................... */
+
+static __inline__ t_EthHash * AllocHashTable(uint16_t size)
+{
+    uint32_t    i;
+    t_EthHash *p_Hash;
+
+    /* Allocate address hash table */
+    p_Hash = (t_EthHash *)XX_Malloc(size*sizeof(t_EthHash *));
+    if (!p_Hash)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        return NULL;
+    }
+    p_Hash->size = size;
+
+    p_Hash->p_Lsts = (t_List *)XX_Malloc(p_Hash->size*sizeof(t_List));
+    if (!p_Hash->p_Lsts)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        XX_Free(p_Hash);
+        return NULL;
+    }
+
+    for(i=0 ; i<p_Hash->size; i++)
+        INIT_LIST(&p_Hash->p_Lsts[i]);
+
+    return p_Hash;
+}
+
+
+#endif /* __FM_MAC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
new file mode 100644
index 0000000..a83a530
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -0,0 +1,1267 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.c
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "fm_common.h"
+#include "tgec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Tgec->enetMode) < e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
+    if(p_Tgec->macId >= FM_MAX_NUM_OF_10G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10 G can not be greater than 0"));
+    if(p_Tgec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
+    if(!p_Tgec->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Exception"));
+    if(!p_Tgec->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
+{
+    p_TgecDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
+    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousModeEnable;
+    p_TgecDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
+    p_TgecDriverParam->pauseIgnore              = DEFAULT_pauseIgnore;
+    p_TgecDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
+
+    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopbackEnable;
+    p_TgecDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
+    p_TgecDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
+    p_TgecDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
+    p_TgecDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
+    p_TgecDriverParam->noLengthCheckEnable      = DEFAULT_noLengthCheckEnable;
+    p_TgecDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
+    p_TgecDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
+    p_TgecDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
+    p_TgecDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
+    p_TgecDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
+
+    p_TgecDriverParam->txIpgLength              = DEFAULT_txIpgLength;
+    p_TgecDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
+
+    p_TgecDriverParam->debugMode                = DEFAULT_debugMode;
+
+    p_TgecDriverParam->pauseTime                = DEFAULT_pauseTime;
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    p_TgecDriverParam->skipFman11Workaround     = DEFAULT_skipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+}
+
+/* ........................................................................... */
+
+static void TgecErrException(t_Handle h_Tgec)
+{
+    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t            event;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    event = GET_UINT32(p_TgecMemMap->ievent);
+    /* do not handle MDIO events */
+    event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+
+    event &= GET_UINT32(p_TgecMemMap->imask);
+
+    WRITE_UINT32(p_TgecMemMap->ievent, event);
+
+    if (event & IMASK_REM_FAULT)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
+    if (event & IMASK_LOC_FAULT)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
+    if (event & IMASK_1TX_ECC_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
+    if (event & IMASK_TX_FIFO_UNFL)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
+    if (event & IMASK_TX_FIFO_OVFL)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
+    if (event & IMASK_TX_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
+    if (event & IMASK_RX_FIFO_OVFL)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
+    if (event & IMASK_RX_ECC_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
+    if (event & IMASK_RX_JAB_FRM)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_JAB_FRM);
+    if (event & IMASK_RX_OVRSZ_FRM)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_OVRSZ_FRM);
+    if (event & IMASK_RX_RUNT_FRM)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_RUNT_FRM);
+    if (event & IMASK_RX_FRAG_FRM)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FRAG_FRM);
+    if (event & IMASK_RX_LEN_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_LEN_ER);
+    if (event & IMASK_RX_CRC_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_CRC_ER);
+    if (event & IMASK_RX_ALIGN_ER)
+        p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
+}
+
+static void TgecException(t_Handle h_Tgec)
+{
+     t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+     uint32_t            event;
+     t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+     event = GET_UINT32(p_TgecMemMap->ievent);
+     /* handle only MDIO events */
+     event &= (IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+     event &= GET_UINT32(p_TgecMemMap->imask);
+
+     WRITE_UINT32(p_TgecMemMap->ievent, event);
+
+     if(event & IMASK_MDIO_SCAN_EVENTMDIO)
+         p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
+     if(event & IMASK_MDIO_CMD_CMPL)
+         p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
+}
+
+static void FreeInitResources(t_Tgec *p_Tgec)
+{
+    if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
+    {
+        XX_DisableIntr(p_Tgec->mdioIrq);
+        XX_FreeIntr(p_Tgec->mdioIrq);
+    }
+    else if (p_Tgec->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));
+    FmUnregisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR);
+
+    /* release the driver's group hash table */
+    FreeHashTable(p_Tgec->p_MulticastAddrHash);
+    p_Tgec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Tgec->p_UnicastAddrHash);
+    p_Tgec->p_UnicastAddrHash =     NULL;
+}
+
+/* .............................................................................. */
+
+static void HardwareClearAddrInPaddr(t_Tgec   *p_Tgec, uint8_t paddrNum)
+{
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_2, 0x0);
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_3, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Tgec   *p_Tgec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t        tmpReg32 = 0;
+    uint64_t        addr = *p_Addr;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_2, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_TgecMemMap->mac_addr_3, tmpReg32);
+}
+
+/*****************************************************************************/
+/*                     10G MAC API routines                                  */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+    }
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    switch (mode)
+    {
+        case e_COMM_MODE_RX:
+            tmpReg32 &= ~CMD_CFG_RX_EN;
+            break;
+        case e_COMM_MODE_TX:
+            tmpReg32 &= ~CMD_CFG_TX_EN;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap *p_TgecMemMap;
+    uint32_t     tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+
+    tmpReg32 = GET_UINT32(p_TgecMemMap->cmd_conf_ctrl);
+
+    if (newVal)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    else
+        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Tgec Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+#ifdef FM_NO_TGEC_LOOPBACK
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("no loopback in this chip rev!"));
+    }
+#endif /* FM_NO_TGEC_LOOPBACK */
+
+    p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->wanModeEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
+{
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+UNUSED(h_Tgec);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+
+#else
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    UNUSED(newVal);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
+
+    return E_OK;
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if((revInfo.majorRev <=2) &&
+            enable &&
+            ((exception == e_FM_MAC_EX_10G_LOC_FAULT) || (exception == e_FM_MAC_EX_10G_REM_FAULT)))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT and e_FM_MAC_EX_10G_REM_FAULT !"));
+    }
+#endif   /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Tgec->exceptions |= bitMask;
+        else
+            p_Tgec->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+/* .............................................................................. */
+
+static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->skipFman11Workaround     = TRUE;
+
+    return E_OK;
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+
+/*****************************************************************************/
+/*                      Tgec Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t        ptv = 0;
+    t_TgecMemMap    *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    ptv = (uint32_t)pauseTime;
+
+    WRITE_UINT32(p_MemMap->pause_quant, ptv);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    if (en)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    else
+        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* .............................................................................. */
+
+static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+
+    p_Statistics->eStatPkts64           = GET_UINT64(p_TgecMemMap->R64);
+    p_Statistics->eStatPkts65to127      = GET_UINT64(p_TgecMemMap->R127);
+    p_Statistics->eStatPkts128to255     = GET_UINT64(p_TgecMemMap->R255);
+    p_Statistics->eStatPkts256to511     = GET_UINT64(p_TgecMemMap->R511);
+    p_Statistics->eStatPkts512to1023    = GET_UINT64(p_TgecMemMap->R1023);
+    p_Statistics->eStatPkts1024to1518   = GET_UINT64(p_TgecMemMap->R1518);
+    p_Statistics->eStatPkts1519to1522   = GET_UINT64(p_TgecMemMap->R1519X);
+/* */
+    p_Statistics->eStatFragments        = GET_UINT64(p_TgecMemMap->TRFRG);
+    p_Statistics->eStatJabbers          = GET_UINT64(p_TgecMemMap->TRJBR);
+
+    p_Statistics->eStatsDropEvents      = GET_UINT64(p_TgecMemMap->RDRP);
+    p_Statistics->eStatCRCAlignErrors   = GET_UINT64(p_TgecMemMap->RALN);
+
+    p_Statistics->eStatUndersizePkts    = GET_UINT64(p_TgecMemMap->TRUND);
+    p_Statistics->eStatOversizePkts     = GET_UINT64(p_TgecMemMap->TROVR);
+/* Pause */
+    p_Statistics->reStatPause           = GET_UINT64(p_TgecMemMap->RXPF);
+    p_Statistics->teStatPause           = GET_UINT64(p_TgecMemMap->TXPF);
+
+
+/* MIB II */
+    p_Statistics->ifInOctets            = GET_UINT64(p_TgecMemMap->ROCT);
+    p_Statistics->ifInMcastPkts         = GET_UINT64(p_TgecMemMap->RMCA);
+    p_Statistics->ifInBcastPkts         = GET_UINT64(p_TgecMemMap->RBCA);
+    p_Statistics->ifInPkts              = GET_UINT64(p_TgecMemMap->RUCA)
+                                        + p_Statistics->ifInMcastPkts
+                                        + p_Statistics->ifInBcastPkts;
+    p_Statistics->ifInDiscards          = 0;
+    p_Statistics->ifInErrors            = GET_UINT64(p_TgecMemMap->RERR);
+
+    p_Statistics->ifOutOctets           = GET_UINT64(p_TgecMemMap->TOCT);
+    p_Statistics->ifOutMcastPkts        = GET_UINT64(p_TgecMemMap->TMCA);
+    p_Statistics->ifOutBcastPkts        = GET_UINT64(p_TgecMemMap->TBCA);
+    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA);
+    p_Statistics->ifOutDiscards         = 0;
+    p_Statistics->ifOutErrors           = GET_UINT64(p_TgecMemMap->TERR);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) | CMD_CFG_EN_TIMESTAMP);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) & ~CMD_CFG_EN_TIMESTAMP);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+    uint32_t            tmpReg32 = 0;
+    uint64_t            addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Tgec->addr = addr;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)(addr & 0xFFFFFFFF);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_0, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t) (addr >> 32);
+
+    WRITE_UINT32(p_TgecMemMap->mac_addr_1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecResetCounters (t_Handle h_Tgec)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32, cmdConfCtrl;
+    int i;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    cmdConfCtrl = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    cmdConfCtrl |= CMD_CFG_STAT_CLR;
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    for (i=0; i<1000; i++)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+        if (!(tmpReg32 & CMD_CFG_STAT_CLR))
+            break;
+    }
+
+    cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Tgec->indAddrRegUsed[paddrNum]) &&
+            (p_Tgec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Tgec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Tgec, paddrNum);
+            p_Tgec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (p_Tgec->indAddrRegUsed[paddrNum])
+        {
+            if (p_Tgec->paddr[paddrNum] == ethAddr)
+            {
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+            }
+        }
+    }
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (!(p_Tgec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Tgec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Tgec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Tgec, &ethAddr, paddrNum);
+            p_Tgec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+    }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap;
+    t_EthHashEntry  *p_HashEntry;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (!(ethAddr & GROUP_ADDRESS))
+        /* Unicast addresses not supported in hash */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    LIST_AddToTail(&(p_HashEntry->node), &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]));
+    WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    LIST_FOR_EACH(p_Pos, &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+    {
+
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+        if(p_HashEntry->addr == ethAddr)
+        {
+            LIST_DelAndInit(&p_HashEntry->node);
+            XX_Free(p_HashEntry);
+            break;
+        }
+    }
+    if(LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+        WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
+
+    UNUSED(p_Tgec);
+    UNUSED(macId);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TgecGetId Not Supported"));
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+    *macVersion = GET_UINT32(p_TgecMemMap->tgec_id);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t            bitMask = 0, tmpReg;
+    t_TgecMemMap        *p_TgecMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+
+    p_TgecMemMap = p_Tgec->p_MemMap;
+#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if((revInfo.majorRev <=2) &&
+            enable &&
+            ((exception == e_FM_MAC_EX_10G_LOC_FAULT) || (exception == e_FM_MAC_EX_10G_REM_FAULT)))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT and e_FM_MAC_EX_10G_REM_FAULT !"));
+    }
+#endif   /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Tgec->exceptions |= bitMask;
+        else
+            p_Tgec->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    tmpReg = GET_UINT32(p_TgecMemMap->imask);
+    if(enable)
+        tmpReg |= bitMask;
+    else
+        tmpReg &= ~bitMask;
+    WRITE_UINT32(p_TgecMemMap->imask, tmpReg);
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_VALUE(p_Tgec, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Tgec->p_MemMap->maxfrm);
+}
+
+/* .............................................................................. */
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
+{
+    t_Error err;
+
+    XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
+    /* enable and set promiscuous */
+    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+    err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
+    /* disable */
+    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, 0);
+    if (err)
+        XX_Print("FAILED!\n");
+    else
+        XX_Print("done.\n");
+    TgecResetCounters (p_Tgec);
+
+    return err;
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+/* .............................................................................. */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error TgecDumpRegs(t_Handle h_Tgec)
+{
+    t_Tgec    *p_Tgec = (t_Tgec *)h_Tgec;
+
+    DECLARE_DUMP;
+
+    if (p_Tgec->p_MemMap)
+    {
+        DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
+        DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
+        DUMP_VAR(p_Tgec->p_MemMap, scratch);
+        DUMP_VAR(p_Tgec->p_MemMap, cmd_conf_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
+        DUMP_VAR(p_Tgec->p_MemMap, maxfrm);
+        DUMP_VAR(p_Tgec->p_MemMap, pause_quant);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_sections);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_sections);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_almost_f_e);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_almost_f_e);
+        DUMP_VAR(p_Tgec->p_MemMap, hashtable_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_cfg_status);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_command);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_data);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_regaddr);
+        DUMP_VAR(p_Tgec->p_MemMap, status);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_ipg_len);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_2);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_3);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_rd);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_wr);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_rd);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_wr);
+        DUMP_VAR(p_Tgec->p_MemMap, imask);
+        DUMP_VAR(p_Tgec->p_MemMap, ievent);
+        DUMP_VAR(p_Tgec->p_MemMap, udp_port);
+        DUMP_VAR(p_Tgec->p_MemMap, type_1588v2);
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecInit(t_Handle h_Tgec)
+{
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    t_TgecMemMap            *p_MemMap;
+    uint64_t                addr;
+    uint32_t                tmpReg32;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
+        ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
+#ifdef NCSW_LINUX
+    {
+        /* the workaround fails in simics, just report and continue initialization */
+        REPORT_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED, skipping workaround"));
+    }
+#else
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED"));
+    }
+#endif
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+    CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
+
+    p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
+    p_MemMap = p_Tgec->p_MemMap;
+
+    /* MAC Address */
+    addr = p_Tgec->addr;
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemMap->mac_addr_0, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemMap->mac_addr_1, tmpReg32);
+
+    /* Config */
+    tmpReg32 = 0;
+    if (p_TgecDriverParam->wanModeEnable)
+        tmpReg32 |= CMD_CFG_WAN_MODE;
+    if (p_TgecDriverParam->promiscuousModeEnable)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    if (p_TgecDriverParam->pauseForwardEnable)
+        tmpReg32 |= CMD_CFG_PAUSE_FWD;
+    if (p_TgecDriverParam->pauseIgnore)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    if (p_TgecDriverParam->txAddrInsEnable)
+        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+    if (p_TgecDriverParam->loopbackEnable)
+        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
+    if (p_TgecDriverParam->cmdFrameEnable)
+        tmpReg32 |= CMD_CFG_CMD_FRM_EN;
+    if (p_TgecDriverParam->rxErrorDiscard)
+        tmpReg32 |= CMD_CFG_RX_ER_DISC;
+    if (p_TgecDriverParam->phyTxenaOn)
+        tmpReg32 |= CMD_CFG_PHY_TX_EN;
+    if (p_TgecDriverParam->sendIdleEnable)
+        tmpReg32 |= CMD_CFG_SEND_IDLE;
+    if (p_TgecDriverParam->noLengthCheckEnable)
+        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+    if (p_TgecDriverParam->lgthCheckNostdr)
+        tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
+    if (p_TgecDriverParam->timeStampEnable)
+        tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
+    if (p_TgecDriverParam->rxSfdAny)
+        tmpReg32 |= RX_SFD_ANY;
+    if (p_TgecDriverParam->rxPblFwd)
+        tmpReg32 |= CMD_CFG_RX_PBL_FWD;
+    if (p_TgecDriverParam->txPblFwd)
+        tmpReg32 |= CMD_CFG_TX_PBL_FWD;
+    tmpReg32 |= 0x40;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    /* Max Frame Length */
+    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MAC_10G, p_Tgec->fmMacControllerDriver.macId, p_TgecDriverParam->maxFrameLength);
+    if(err)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    /* Pause Time */
+    WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
+
+#ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
+    WRITE_UINT32(p_Tgec->p_MemMap->tx_ipg_len,
+        (GET_UINT32(p_Tgec->p_MemMap->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
+#endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
+
+    /* Configure MII */
+    tmpReg32  = GET_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status);
+#ifdef FM_10G_MDIO_HOLD_ERRATA_XAUI3
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            tmpReg32 |= (MIIMCOM_MDIO_HOLD_4_REG_CLK << 2);
+    }
+#endif /* FM_10G_MDIO_HOLD_ERRATA_XAUI3 */
+    tmpReg32 &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    tmpReg32 |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status, tmpReg32);
+
+    p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_MulticastAddrHash)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Tgec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    /* interrupts */
+#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
+        if (revInfo.majorRev <=2)
+            p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
+    }
+#endif /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
+    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
+    WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
+
+    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR, TgecErrException , p_Tgec);
+    if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
+    {
+        XX_SetIntr(p_Tgec->mdioIrq, TgecException, p_Tgec);
+        XX_EnableIntr(p_Tgec->mdioIrq);
+    }
+    else if (p_Tgec->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));
+
+
+    XX_Free(p_TgecDriverParam);
+    p_Tgec->p_TgecDriverParam = NULL;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecFree(t_Handle h_Tgec)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    FreeInitResources(p_Tgec);
+
+    if (p_Tgec->p_TgecDriverParam)
+    {
+        XX_Free(p_Tgec->p_TgecDriverParam);
+        p_Tgec->p_TgecDriverParam = NULL;
+    }
+    XX_Free (p_Tgec);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = TgecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = TgecConfigWan;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = NULL; /* TGEC always works with pad+crc */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = TgecConfigLengthCheck;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = TgecConfigException;
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround= TgecConfigSkipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = TgecSetExcpetion;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = TgecEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = TgecDisable1588TimeStamp;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = TgecRxIgnoreMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = TgecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = TgecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = TgecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = TgecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = TgecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = TgecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = TgecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = TgecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = TgecGetVersion;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = TgecGetMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = TGEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = TGEC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = TgecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+
+/*****************************************************************************/
+/*                      Tgec Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Tgec                  *p_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    uintptr_t               baseAddr;
+    uint8_t                 *tmpEthAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    baseAddr = p_FmMacParam->baseAddr;
+    /* allocate memory for the UCC GETH data structure. */
+    p_Tgec = (t_Tgec *) XX_Malloc(sizeof(t_Tgec));
+    if (!p_Tgec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Tgec */
+    memset(p_Tgec, 0, sizeof(t_Tgec));
+    InitFmMacControllerDriver(&p_Tgec->fmMacControllerDriver);
+
+    /* allocate memory for the 10G MAC driver parameters data structure. */
+    p_TgecDriverParam = (t_TgecDriverParam *) XX_Malloc(sizeof(t_TgecDriverParam));
+    if (!p_TgecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
+        TgecFree(p_Tgec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_TgecDriverParam, 0, sizeof(t_TgecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Tgec->p_TgecDriverParam = p_TgecDriverParam;
+
+    SetDefaultParam(p_TgecDriverParam);
+
+    tmpEthAddr = (uint8_t *)&p_Tgec->addr;
+    memcpy(tmpEthAddr, p_FmMacParam->addr, sizeof(p_FmMacParam->addr));
+    p_Tgec->addr          >>= 16;
+    p_Tgec->p_MemMap        = (t_TgecMemMap *)UINT_TO_PTR(baseAddr);
+    p_Tgec->p_MiiMemMap     = (t_TgecMiiAccessMemMap *)UINT_TO_PTR(baseAddr + TGEC_TO_MII_OFFSET);
+    p_Tgec->enetMode        = p_FmMacParam->enetMode;
+    p_Tgec->macId           = p_FmMacParam->macId;
+    p_Tgec->exceptions      = DEFAULT_exceptions;
+    p_Tgec->mdioIrq         = p_FmMacParam->mdioIrq;
+    p_Tgec->f_Exception     = p_FmMacParam->f_Exception;
+    p_Tgec->f_Event         = p_FmMacParam->f_Event;
+    p_Tgec->h_App           = p_FmMacParam->h_App;
+
+    return p_Tgec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
new file mode 100644
index 0000000..db22ead
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -0,0 +1,482 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.h
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+#ifndef __TGEC_H
+#define __TGEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "tgec_mii_acc.h"
+#include "fm_mac.h"
+
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+
+#define EVENTS_MASK                 ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                                IMASK_MDIO_CMD_CMPL       |  \
+                                                IMASK_REM_FAULT           |  \
+                                                IMASK_LOC_FAULT           |  \
+                                                IMASK_1TX_ECC_ER          |  \
+                                                IMASK_TX_FIFO_UNFL        |  \
+                                                IMASK_TX_FIFO_OVFL        |  \
+                                                IMASK_TX_ER               |  \
+                                                IMASK_RX_FIFO_OVFL        |  \
+                                                IMASK_RX_ECC_ER           |  \
+                                                IMASK_RX_JAB_FRM          |  \
+                                                IMASK_RX_OVRSZ_FRM        |  \
+                                                IMASK_RX_RUNT_FRM         |  \
+                                                IMASK_RX_FRAG_FRM         |  \
+                                                IMASK_RX_LEN_ER           |  \
+                                                IMASK_RX_CRC_ER           |  \
+                                                IMASK_RX_ALIGN_ER))
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                                    \
+        bitMask = IMASK_MDIO_SCAN_EVENTMDIO; break;                              \
+    case e_FM_MAC_EX_10G_MDIO_CMD_CMPL:                                          \
+        bitMask = IMASK_MDIO_CMD_CMPL      ; break;                              \
+    case e_FM_MAC_EX_10G_REM_FAULT:                                              \
+        bitMask = IMASK_REM_FAULT          ; break;                              \
+    case e_FM_MAC_EX_10G_LOC_FAULT:                                              \
+        bitMask = IMASK_LOC_FAULT          ; break;                              \
+    case e_FM_MAC_EX_10G_1TX_ECC_ER:                                             \
+        bitMask = IMASK_1TX_ECC_ER         ; break;                              \
+    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                           \
+        bitMask = IMASK_TX_FIFO_UNFL       ; break;                              \
+    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                           \
+        bitMask = IMASK_TX_FIFO_OVFL       ; break;                              \
+    case e_FM_MAC_EX_10G_TX_ER:                                                  \
+        bitMask = IMASK_TX_ER              ; break;                              \
+    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                           \
+        bitMask = IMASK_RX_FIFO_OVFL       ; break;                              \
+    case e_FM_MAC_EX_10G_RX_ECC_ER:                                              \
+        bitMask = IMASK_RX_ECC_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_JAB_FRM:                                             \
+        bitMask = IMASK_RX_JAB_FRM         ; break;                              \
+    case e_FM_MAC_EX_10G_RX_OVRSZ_FRM:                                           \
+        bitMask = IMASK_RX_OVRSZ_FRM       ; break;                              \
+    case e_FM_MAC_EX_10G_RX_RUNT_FRM:                                            \
+        bitMask = IMASK_RX_RUNT_FRM        ; break;                              \
+    case e_FM_MAC_EX_10G_RX_FRAG_FRM:                                            \
+        bitMask = IMASK_RX_FRAG_FRM        ; break;                              \
+    case e_FM_MAC_EX_10G_RX_LEN_ER:                                              \
+        bitMask = IMASK_RX_LEN_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_CRC_ER:                                              \
+        bitMask = IMASK_RX_CRC_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_ALIGN_ER:                                            \
+        bitMask = IMASK_RX_ALIGN_ER        ; break;                              \
+    default: bitMask = 0;break;}
+
+
+/* Default Config Params */
+#define DEFAULT_wanModeEnable               FALSE
+#define DEFAULT_promiscuousModeEnable       FALSE
+
+
+#define DEFAULT_pauseForwardEnable          FALSE
+#define DEFAULT_pauseIgnore                 FALSE
+#define DEFAULT_txAddrInsEnable             FALSE
+
+#define DEFAULT_loopbackEnable              FALSE
+#define DEFAULT_cmdFrameEnable              FALSE
+#define DEFAULT_rxErrorDiscard              FALSE
+#define DEFAULT_phyTxenaOn                  FALSE
+#define DEFAULT_sendIdleEnable              FALSE
+#define DEFAULT_noLengthCheckEnable         TRUE
+#define DEFAULT_lgthCheckNostdr             FALSE
+#define DEFAULT_timeStampEnable             FALSE
+#define DEFAULT_rxSfdAny                    FALSE
+#define DEFAULT_rxPblFwd                    FALSE
+#define DEFAULT_txPblFwd                    FALSE
+#define DEFAULT_txIpgLength                 12
+
+#define DEFAULT_maxFrameLength              0x600
+
+#define DEFAULT_debugMode                   FALSE
+#define DEFAULT_pauseTime                   0xf000
+#define DEFAULT_imask                       0xf000
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define DEFAULT_skipFman11Workaround        FALSE
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+#define DEFAULT_exceptions          ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                                IMASK_REM_FAULT           |  \
+                                                IMASK_LOC_FAULT           |  \
+                                                IMASK_1TX_ECC_ER          |  \
+                                                IMASK_TX_FIFO_UNFL        |  \
+                                                IMASK_TX_FIFO_OVFL        |  \
+                                                IMASK_TX_ER               |  \
+                                                IMASK_RX_FIFO_OVFL        |  \
+                                                IMASK_RX_ECC_ER           |  \
+                                                IMASK_RX_JAB_FRM          |  \
+                                                IMASK_RX_OVRSZ_FRM        |  \
+                                                IMASK_RX_RUNT_FRM         |  \
+                                                IMASK_RX_FRAG_FRM         |  \
+                                                IMASK_RX_CRC_ER           |  \
+                                                IMASK_RX_ALIGN_ER))
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+#define TGEC_NUM_OF_PADDRS          1                   /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
+
+#define HASH_TABLE_SIZE             512                 /* Hash table size (= 32 bits * 8 regs) */
+
+#define TGEC_TO_MII_OFFSET          0x1030              /* Offset from the MEM map to the MDIO mem map */
+
+/* 10-gigabit Ethernet MAC Controller ID (10GEC_ID) */
+#define TGEC_ID_ID                  0xffff0000
+#define TGEC_ID_MAC_VERSION         0x0000FF00
+#define TGEC_ID_MAC_REV             0x000000ff
+
+/* Command and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_TX_PBL_FWD          0x00800000  /* 08 Transmit Preamble Forwarding (custom preamble).
+                                                 */
+#define CMD_CFG_RX_PBL_FWD          0x00400000  /* 09 Receive Preamble Forwarding (custom preamble).
+                                                 */
+#define RX_SFD_ANY                  0x00200000  /* 10 Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                                 */
+#define CMD_CFG_EN_TIMESTAMP        0x00100000  /* 11 EN_TIMESTAMP IEEE 1588 timeStamp functionality control.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000  /* 12 TX_ADDR_INS_SEL Transmit MAC address select
+                                                 * 0 insert using first MAC address
+                                                 * 1 insert using second MAC address
+                                                 */
+#define CMD_CFG_LEN_CHK_NOSTDR      0x00040000  /* 13 LEN_CHK_NOSTDR
+                                                 */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 NO_LEN_CHK Payload length check disable
+                                                 * 0 MAC compares the frame payload length with the frame length/type field.
+                                                 * 1 Payload length check is disabled.
+                                                 */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 SEND_IDLE Force idle generation
+                                                 * 0 Normal operation.
+                                                * 1 MAC permanently sends XGMII idle sequences even when faults are received.
+                                                 */
+#define CMD_CFG_PHY_TX_EN           0x00008000  /* 16 PHY_TX_EN PHY transmit enable
+                                                 * 0 PHY transmit is disabled.
+                                                 * 1 PHY transmit is enabled.
+                                                 */
+#define CMD_CFG_RX_ER_DISC          0x00004000  /* 17 RX_ER_DISC Receive error frame discard enable
+                                                 * 0 Received error frames are processed.
+                                                 * 1 Any frame received with an error is discarded.
+                                                 */
+#define CMD_CFG_CMD_FRM_EN          0x00002000  /* 18 CMD_FRM_EN Command frame reception enable
+                                                 * 0 Only Pause frames are accepted (all other command frames are rejected).
+                                                 * 1 All command frames are accepted.
+                                                 */
+#define CMD_CFG_STAT_CLR            0x00001000  /* 19 STAT_CLR Clear statistics
+                                                 * 0 Normal operations.
+                                                 * 1 All statistics counters are cleared.
+                                                 */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 LOOPBAC_EN PHY interface loopback enable
+                                                 * 0 Configure PHY for normal operation.
+                                                 * 1 Configure PHY for loopback mode.
+                                                 */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 TX_ADDR_INS Transmit source MAC address insertion
+                                                 * 0 MAC transmits the source MAC address unmodified.
+                                                 * 1 MAC overwrites the source MAC address with address specified by COMMAND_CONFIG[TX_ADDR_INS_SEL].
+                                                 */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 PAUSE_IGNORE Ignore Pause frame quanta
+                                                 * 0 MAC stops transmit process for the duration specified in the Pause frame quanta of a received Pause frame.
+                                                 * 1 MAC ignores received Pause frames.
+                                                 */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 PAUSE_FWD Terminate/forward received Pause frames
+                                                 * 0 MAC terminates and discards received Pause frames.
+                                                 * 1 MAC forwards Pause frames to the user application.
+                                                 */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 PROMIS_EN Promiscuous operation enable
+                                                 * 0 Unicast frames with a destination address not matching the core MAC address (defined by registers, MAC_ADDR_0 and MAC_ADDR_1) are rejected.
+                                                 * 1 All frames are received without any MAC address filtering.
+                                                 */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN_MODE WAN mode enable
+                                                 * 0 Configure MAC for LAN mode.
+                                                 * 1 Configure MAC for WAN mode.
+                                                 */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 RX_EN MAC receive path enable
+                                                 * 0 MAC receive path is disabled
+                                                 * 1 MAC receive path is enabled.
+                                                 */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 TX_EN MAC transmit path enable
+                                                 * 0 MAC transmit path is disabled
+                                                 * 1 MAC transmit path is enabled.
+                                                 */
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       23
+
+#define HASH_CTRL_MCAST_RD          0x00000400  /* 22 MCAST_READ Entry Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_CTRL_MCAST_EN          0x00000200  /* 22 MCAST_EN Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_ADDR_MASK              0x000001ff  /* 23-31 HASH_ADDR Hash table address code.
+                                                 */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x000003ff
+
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/*
+ * 10G memory map
+ */
+typedef _Packed struct {
+/* 10Ge General Control and Status */
+    volatile uint32_t   tgec_id;            /* 0x000 10GEC_ID - Controller ID register */
+    volatile uint32_t   scratch;            /* 0x004  */
+    volatile uint32_t   cmd_conf_ctrl;      /* 0x008 COMMAND_CONFIG - Control and configuration register */
+    volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0 - Lower 32 bits of the first 48-bit MAC address */
+    volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1 - Upper 16 bits of the first 48-bit MAC address */
+    volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
+    volatile uint32_t   pause_quant;        /* 0x018 PAUSE_QUANT - Pause quanta register */
+    volatile uint32_t   rx_fifo_sections;   /* 0x01c  */
+    volatile uint32_t   tx_fifo_sections;   /* 0x020  */
+    volatile uint32_t   rx_fifo_almost_f_e; /* 0x024  */
+    volatile uint32_t   tx_fifo_almost_f_e; /* 0x028  */
+    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+    volatile uint32_t   status;             /* 0x040  */
+    volatile uint32_t   tx_ipg_len;         /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
+    volatile uint32_t   mac_addr_2;         /* 0x048 MAC_ADDR_2 - Lower 32 bits of the second 48-bit MAC address */
+    volatile uint32_t   mac_addr_3;         /* 0x04C MAC_ADDR_3 - Upper 16 bits of the second 48-bit MAC address */
+    volatile uint32_t   rx_fifo_ptr_rd;     /* 0x050  */
+    volatile uint32_t   rx_fifo_ptr_wr;     /* 0x054  */
+    volatile uint32_t   tx_fifo_ptr_rd;     /* 0x058  */
+    volatile uint32_t   tx_fifo_ptr_wr;     /* 0x05c  */
+    volatile uint32_t   imask;              /* 0x060 IMASK - Interrupt mask register */
+    volatile uint32_t   ievent;             /* 0x064 IEVENT - Interrupt event register */
+    volatile uint32_t   udp_port;           /* 0x068 Defines a UDP Port number. When an UDP/IP frame is received with a matching UDP destination port, the receive status indication pin ff_rx_ts_frm will be asserted.*/
+    volatile uint32_t   type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames. IEEE1588 defines the type 0x88f7 for 1588 frames. */
+    volatile uint32_t   TENGEC_RESERVED4[4];
+/*10Ge Statistics Counter */
+    volatile uint64_t   TFRM;        /* 80 aFramesTransmittedOK */
+    volatile uint64_t   RFRM;        /* 88 aFramesReceivedOK */
+    volatile uint64_t   RFCS;        /* 90 aFrameCheckSequenceErrors */
+    volatile uint64_t   RALN;        /* 98 aAlignmentErrors */
+    volatile uint64_t   TXPF;        /* A0 aPAUSEMACCtrlFramesTransmitted */
+    volatile uint64_t   RXPF;        /* A8 aPAUSEMACCtrlFramesReceived */
+    volatile uint64_t   RLONG;       /* B0 aFrameTooLongErrors */
+    volatile uint64_t   RFLR;        /* B8 aInRangeLengthErrors */
+    volatile uint64_t   TVLAN;       /* C0 VLANTransmittedOK */
+    volatile uint64_t   RVLAN;       /* C8 VLANReceivedOK */
+    volatile uint64_t   TOCT;        /* D0 ifOutOctets */
+    volatile uint64_t   ROCT;        /* D8 ifInOctets */
+    volatile uint64_t   RUCA;        /* E0 ifInUcastPkts */
+    volatile uint64_t   RMCA;        /* E8 ifInMulticastPkts */
+    volatile uint64_t   RBCA;        /* F0 ifInBroadcastPkts */
+    volatile uint64_t   TERR;        /* F8 ifOutErrors */
+    volatile uint32_t   TENGEC_RESERVED6[2];
+    volatile uint64_t   TUCA;        /* 108 ifOutUcastPkts */
+    volatile uint64_t   TMCA;        /* 110 ifOutMulticastPkts */
+    volatile uint64_t   TBCA;        /* 118 ifOutBroadcastPkts */
+    volatile uint64_t   RDRP;        /* 120 etherStatsDropEvents */
+    volatile uint64_t   REOCT;       /* 128 etherStatsOctets */
+    volatile uint64_t   RPKT;        /* 130 etherStatsPkts */
+    volatile uint64_t   TRUND;       /* 138 etherStatsUndersizePkts */
+    volatile uint64_t   R64;         /* 140 etherStatsPkts64Octets */
+    volatile uint64_t   R127;        /* 148 etherStatsPkts65to127Octets */
+    volatile uint64_t   R255;        /* 150 etherStatsPkts128to255Octets */
+    volatile uint64_t   R511;        /* 158 etherStatsPkts256to511Octets */
+    volatile uint64_t   R1023;       /* 160 etherStatsPkts512to1023Octets */
+    volatile uint64_t   R1518;       /* 168 etherStatsPkts1024to1518Octets */
+    volatile uint64_t   R1519X;      /* 170 etherStatsPkts1519toX */
+    volatile uint64_t   TROVR;       /* 178 etherStatsOversizePkts */
+    volatile uint64_t   TRJBR;       /* 180 etherStatsJabbers */
+    volatile uint64_t   TRFRG;       /* 188 etherStatsFragments */
+    volatile uint64_t   RERR;        /* 190 ifInErrors */
+} _PackedType t_TgecMemMap;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct {
+    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
+    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
+    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
+    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
+    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
+                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
+                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
+    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
+    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
+    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
+    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
+    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
+    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
+    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
+    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
+                                        1: IEEE 1588 is enabled.
+                                        0: IEEE 1588 is disabled. */
+    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
+    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
+                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
+                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
+    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
+                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
+                                        If cleared (default) the MAC */
+    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
+                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
+                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+/*.. */
+    uint16_t    maxFrameLength;
+    bool        debugMode;
+    uint16_t    pauseTime;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    bool        skipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+} t_TgecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;              /**< Upper Mac control block */
+    t_Handle                    h_App;                              /**< Handle to the upper layer application  */
+    t_TgecMemMap                *p_MemMap;                          /**< pointer to 10G memory mapped registers. */
+    t_TgecMiiAccessMemMap       *p_MiiMemMap;                       /**< pointer to MII memory mapped registers.          */
+    uint64_t                    addr;                               /**< MAC address of device; */
+    e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exception;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Event;
+    bool                        indAddrRegUsed[TGEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[TGEC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs;                 /**< Number of individual addresses in registers for this station. */
+    t_EthHash                   *p_MulticastAddrHash;               /**< pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;                 /**< pointer to driver's individual address hash table  */
+    bool                        debugMode;
+    uint8_t                     macId;
+    uint32_t                    exceptions;
+    t_TgecDriverParam           *p_TgecDriverParam;
+} t_Tgec;
+
+
+t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __TGEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
new file mode 100644
index 0000000..c9753be
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -0,0 +1,121 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "tgec.h"
+#include "xx_ext.h"
+
+
+/*****************************************************************************/
+t_Error TGEC_MII_WritePhyReg(t_Handle   h_Tgec,
+                             uint8_t    phyAddr,
+                             uint8_t    reg,
+                             uint16_t   data)
+{
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
+                            uint8_t  phyAddr,
+                            uint8_t  reg,
+                            uint16_t *p_Data)
+{
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+    uint32_t                cfg_status;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, (uint32_t)(phyAddr | MIIMCOM_READ_CYCLE));
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    cfg_status  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+
+    if (cfg_status & MIIMIND_READ_ERROR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfg_status 0x%x",
+                      ((phyAddr & 0xe0)>>5), (phyAddr & 0x1f), reg, cfg_status));
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
new file mode 100644
index 0000000..81fd6ef
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TGEC_MII_ACC_H
+#define __TGEC_MII_ACC_H
+
+#include "std_ext.h"
+
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_POST_INCREMENT 0x00004000
+#define MIIMCOM_READ_CYCLE          0x00008000
+#define MIIMCOM_SCAN_CYCLE          0x00000800
+#define MIIMCOM_PREAMBLE_DISABLE    0x00000400
+
+#define MIIMCOM_MDIO_HOLD_1_REG_CLK 0
+#define MIIMCOM_MDIO_HOLD_2_REG_CLK 1
+#define MIIMCOM_MDIO_HOLD_3_REG_CLK 2
+#define MIIMCOM_MDIO_HOLD_4_REG_CLK 3
+
+#define MIIMCOM_DIV_MASK            0x0000ff00
+#define MIIMCOM_DIV_SHIFT           8
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+#define MIIMIND_READ_ERROR          0x00000002
+
+#define MIIDATA_BUSY                0x80000000
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_TgecMiiAccessMemMap
+{
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+} _PackedType t_TgecMiiAccessMemMap ;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+#endif /* __TGEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
new file mode 100644
index 0000000..a74b5fe
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
@@ -0,0 +1,21 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+
+obj-y		+= fsl-ncsw-PFM1.o
+
+fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o
+
+obj-y		+= MAC/
+obj-y		+= Pcd/
+obj-y		+= Port/
+obj-y		+= HC/
+obj-y		+= Rtc/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
new file mode 100644
index 0000000..6ca0268
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o fm_manip.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
new file mode 100644
index 0000000..9cd5e7c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -0,0 +1,3452 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_cc.c
+
+ @Description   FM CC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_cc.h"
+
+
+#if defined(FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_IPSEC) || defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+#define FM_PCD_CC_MANIP
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+
+t_Handle   FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree, uint8_t manipIndx)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    return p_FmPcdCcTree->fmPcdCcSavedManipParams[manipIndx];
+}
+
+void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams, uint8_t   manipIndx)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    p_FmPcdCcTree->fmPcdCcSavedManipParams[manipIndx] = h_SavedManipParams;
+}
+
+uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+    return p_FmPcdCcNode->parseCode;
+}
+
+uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+    return p_FmPcdCcNode->offset;
+}
+
+uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+    return p_FmPcdCcNode->numOfKeys;
+}
+static void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
+{
+    t_CcNodeInformation *p_CcInformation;
+    uint32_t            intFlags;
+
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+    if(!p_CcInformation)
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+    memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
+    memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
+    INIT_LIST(&p_CcInformation->node);
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_CcInformation->node, p_List);
+    XX_RestoreAllIntr(intFlags);
+}
+
+
+static t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info)
+{
+    t_CcNodeInformation *p_CcInformation;
+    t_List *p_Pos;
+    uint32_t            intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    {
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation->h_CcNode);
+        if(p_CcInformation->h_CcNode == h_Info)
+        {
+            XX_RestoreAllIntr(intFlags);
+            return p_CcInformation;
+        }
+    }
+    XX_RestoreAllIntr(intFlags);
+    return NULL;
+}
+
+static void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
+{
+    t_CcNodeInformation *p_CcInformation = NULL;
+    uint32_t            intFlags;
+    t_List              *p_Pos;
+
+    intFlags = XX_DisableAllIntr();
+    if (LIST_IsEmpty(p_List))
+    {
+        XX_RestoreAllIntr(intFlags);
+        return;
+    }
+
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    {
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation->h_CcNode);
+        if (p_CcInformation->h_CcNode == h_Info)
+            break;
+    }
+    if (p_CcInformation)
+        LIST_DelAndInit(&p_CcInformation->node);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredAction, t_FmPcdCcNextEngineAndRecuiredActionParams *p_CcNextEngineParamsTmp,
+                                        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
+{
+
+    t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
+    uint32_t            tmpReg32;
+    t_Error             err;
+    t_FmPcdCcNode       *p_FmPcdCcNode;
+    int                 i = 0;
+    uint16_t            tmp = 0;
+    uint16_t            profileId;
+    uint8_t             relativeSchemeId, physicalSchemeId;
+    t_CcNodeInformation ccNodeInfo;
+
+     for(i = 0; i < numOfEntries; i++)
+     {
+        if(i == 0)
+            h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
+        else
+            h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        if(p_CcNextEngineParamsTmp[i].shadowAction & requiredAction)
+            continue;
+        switch(p_CcNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        {
+            case(e_FM_PCD_CC):
+                if(requiredAction)
+                {
+                    p_FmPcdCcNode = p_CcNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
+                    ASSERT_COND(p_FmPcdCcNode);
+                    if(p_FmPcdCcNode->shadowAction == requiredAction)
+                        break;
+                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    {
+
+                        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) == 0);
+                        if(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
+                            p_FmPcdCcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
+                        memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                        ccNodeInfo.h_CcNode = h_Tree;
+                        EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNode->ccTreesLst, &ccNodeInfo);
+                        p_CcNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
+                    }
+                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    {
+                        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) == 1);
+                        if(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_TREE)
+                            p_FmPcdCcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
+                        DequeueNodeInfoFromRelevantLst(&p_FmPcdCcNode->ccTreesLst, h_Tree);
+                        p_CcNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
+                    }
+                    if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                        tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+                    else
+                        tmp = p_FmPcdCcNode->numOfKeys;
+                    err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_FmPcdCcNode->nextEngineAndRequiredAction, p_FmPcdCcNode->h_AdTable, tmp, h_Tree);
+                    if(err != E_OK)
+                        return err;
+                    p_FmPcdCcNode->shadowAction |= requiredAction;
+                }
+                break;
+
+            case(e_FM_PCD_KG):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                {
+                    physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme)-1);
+                    relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
+                    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+                    if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+                    if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
+                    err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction);
+                    if(err != E_OK)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                }
+                break;
+
+            case(e_FM_PCD_PLCR):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                {
+                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
+                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
+                    err =  FmPcdPlcrGetAbsoluteProfileId(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
+                    if(err!= E_OK)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                    err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
+                    if(err != E_OK)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                }
+                break;
+
+            case(e_FM_PCD_DONE):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                {
+                    tmpReg32 = GET_UINT32(p_AdTmp->nia);
+                    if((tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previosely assigned not as PCD_DONE"));
+                    tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                    WRITE_UINT32(p_AdTmp->nia, tmpReg32);
+                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                }
+                break;
+
+            default:
+                break;
+        }
+     }
+
+     return E_OK;
+}
+
+static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
+                             t_Handle                                   h_FmPort,
+                             t_FmPcdCcNextEngineAndRecuiredActionParams *p_CcNextEngineParams,
+                             uint16_t                                   numOfEntries,
+                             t_Handle                                   h_Ad,
+                             bool                                       validate,
+                             uint16_t                                   level,
+                             t_Handle                                   h_FmTree,
+                             bool                                       modify)
+{
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_FmPcdCcNode       *p_FmPcdCcNode;
+    t_Error             err;
+    uint16_t            tmp = 0;
+    int                 i = 0;
+
+    level++;
+
+    if(numOfEntries)
+    {
+        for(i = 0; i < numOfEntries; i++)
+        {
+            if(i == 0)
+                h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            else
+                h_Ad = PTR_MOVE(h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
+
+            if(p_CcNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                p_FmPcdCcNode = p_CcNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+                ASSERT_COND(p_FmPcdCcNode);
+                p_CcNodeInfo = FindNodeInfoInReleventLst(&p_FmPcdCcNode->ccTreesLst,h_FmTree);
+                ASSERT_COND(p_CcNodeInfo);
+                p_CcNodeInfo->index = level;
+#ifdef FM_PCD_CC_MANIP
+                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, p_CcNodeInfo->index, h_FmTree, modify);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+#endif /* FM_PCD_CC_MANIP */
+
+                if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+                else
+                    tmp = p_FmPcdCcNode->numOfKeys;
+
+                err = CcUpdateParam(h_FmPcd, h_FmPort, p_FmPcdCcNode->nextEngineAndRequiredAction, tmp, p_FmPcdCcNode->h_AdTable, validate,level, h_FmTree, modify);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+#ifdef FM_PCD_CC_MANIP
+            else
+            {
+                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level,h_FmTree, modify);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
+#endif /* FM_PCD_CC_MANIP */
+          }
+    }
+
+    return E_OK;
+}
+#ifndef NCSW_LINUX
+static void UpdateTreeWithModifiedState(t_Handle h_FmTree, bool modifiedState)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    p_FmPcdCcTree->modifiedState = modifiedState;
+}
+#endif
+static bool IsNodeInModifiedState(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->modifiedState;
+}
+
+static void UpdateNodeWithModifiedState(t_Handle h_CcNode, bool modifiedState)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_FmPcdCcNode);
+
+    p_FmPcdCcNode->modifiedState = modifiedState;
+}
+
+static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
+    {
+        case(e_FM_PCD_ACTION_EXACT_MATCH):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_KEY):
+                    return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
+                default:
+                    return CC_PRIVATE_INFO_NONE;
+            }
+        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
+                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                    return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
+                default:
+                  return  CC_PRIVATE_INFO_NONE;
+            }
+       default:
+           break;
+    }
+    return CC_PRIVATE_INFO_NONE;
+}
+
+static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+{
+    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_List->p_Next);
+        LIST_DelAndInit(&p_CcNodeInfo->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+    return p_CcNodeInfo;
+}
+
+static void ReleaseLst(t_List *p_List)
+{
+    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+
+    if(!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        while (p_CcNodeInfo)
+        {
+            XX_Free(p_CcNodeInfo);
+            p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        }
+    }
+    LIST_DelAndInit(p_List);
+}
+
+void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+{
+    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+}
+
+void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
+{
+    t_List              *p_Pos;
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_Handle            h_FmPcdCcTree;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
+        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+    }
+    ReleaseLst(p_List);
+}
+
+static void DeleteNode(t_FmPcdCcNode *p_FmPcdCcNode)
+{
+    if(p_FmPcdCcNode)
+    {
+        if(p_FmPcdCcNode->p_GlblMask)
+        {
+            XX_Free(p_FmPcdCcNode->p_GlblMask);
+            p_FmPcdCcNode->p_GlblMask = NULL;
+        }
+        if(p_FmPcdCcNode->h_KeysMatchTable)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_FmPcdCcNode->h_KeysMatchTable);
+            p_FmPcdCcNode->h_KeysMatchTable = NULL;
+        }
+        if(p_FmPcdCcNode->h_AdTable)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_FmPcdCcNode->h_AdTable);
+            p_FmPcdCcNode->h_AdTable = NULL;
+        }
+
+        ReleaseLst(&p_FmPcdCcNode->ccPrevNodesLst);
+        ReleaseLst(&p_FmPcdCcNode->ccTreeIdLst);
+        ReleaseLst(&p_FmPcdCcNode->ccTreesLst);
+
+        XX_Free(p_FmPcdCcNode);
+    }
+}
+
+static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
+{
+    if(p_FmPcdTree)
+    {
+        if(p_FmPcdTree->ccTreeBaseAddr)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
+            p_FmPcdTree->ccTreeBaseAddr = 0;
+        }
+
+        ReleaseLst(&p_FmPcdTree->fmPortsLst);
+
+        XX_Free(p_FmPcdTree);
+    }
+}
+
+static void  UpdateNodeOwner(t_FmPcdCcNode *p_FmPcdCcNode, bool add)
+{
+    ASSERT_COND(p_FmPcdCcNode);
+
+    if(add)
+        p_FmPcdCcNode->owners++;
+    else
+    {
+        ASSERT_COND(p_FmPcdCcNode->owners);
+        p_FmPcdCcNode->owners--;
+    }
+}
+
+static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
+{
+    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+        *parseCodeCcSize = 1;
+    else if(parseCodeRealSize == 2)
+        *parseCodeCcSize = 2;
+    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+        *parseCodeCcSize = 4;
+    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+        *parseCodeCcSize = 8;
+    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+        *parseCodeCcSize = 16;
+    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+        *parseCodeCcSize = 24;
+    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+        *parseCodeCcSize = 32;
+    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+        *parseCodeCcSize = 40;
+    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+        *parseCodeCcSize = 48;
+    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+        *parseCodeCcSize = 56;
+    else
+        *parseCodeCcSize = 0;
+}
+
+static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t *parseCodeRealSize)
+{
+    switch(hdr)
+    {
+        case (HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+               case(NET_HEADER_FIELD_VLAN_TCI):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported2"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported3"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 8;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    *parseCodeRealSize = 1;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported4"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_IPv6):
+            switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                   *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                   *parseCodeRealSize = 16;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                   *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported6"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                  *parseCodeRealSize = 4;
+                    break;
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                  *parseCodeRealSize = 8;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported7"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported8"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+        case (HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported9"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+       default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
+            *parseCodeRealSize = CC_SIZE_ILLEGAL;
+            break;
+    }
+}
+
+static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    uint16_t                    absoluteProfileId;
+    t_Error                     err = E_OK;
+    uint8_t                     relativeSchemeId;
+
+    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+         case(e_FM_PCD_INVALID):
+             err = E_NOT_SUPPORTED;
+             break;
+         case(e_FM_PCD_DONE):
+             if(p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+             {
+                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
+                         !p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+             }
+            break;
+        case(e_FM_PCD_KG):
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+            if(!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
+            if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
+            break;
+        case(e_FM_PCD_PLCR):
+            if(p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
+            {
+                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
+                {
+                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId, &absoluteProfileId);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
+                    if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
+                }
+                else
+                {
+                }
+                /* TODO - add check according to the revision of the chip.
+                if(!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
+                   (p_FmPcdCcNextEngineParams->params.plcrParams.newFqid & ~0x00FFFFFF))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("newFqid  must be between 1 and 2^24-1"));
+                */
+            }
+            break;
+        case(e_FM_PCD_CC):
+            if(!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
+    }
+    return err;
+}
+
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset, bool fromIc, ccPrivateInfo_t icCode)
+{
+    if(!fromIc)
+    {
+        switch(src)
+        {
+            case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+                if(glblMask)
+                    return CC_PC_GENERIC_WITH_MASK ;
+                else
+                  return CC_PC_GENERIC_WITHOUT_MASK;
+            case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+                if(offset)
+                    return CC_PR_OFFSET;
+                else
+                    return CC_PR_WITHOUT_OFFSET;
+            default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+                return CC_PC_ILLEGAL;
+        }
+    }
+    else
+    {
+        switch (icCode)
+        {
+            case(CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
+                 *parseArrayOffset = 0x50;
+                 return CC_PC_GENERIC_IC_GMASK;
+            case(CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
+               *parseArrayOffset = 0x48;
+               return CC_PC_GENERIC_IC_GMASK;
+            case(CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
+                *parseArrayOffset = 0x48;
+                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+            case(CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
+                *parseArrayOffset = 0x16;
+                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+            default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+                break;
+        }
+    }
+    return CC_PC_ILLEGAL;
+}
+
+static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+
+      switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+                return CC_PC_ILLEGAL;
+
+       case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_DA):
+                        return CC_PC_FF_MACDST;
+                    case(NET_HEADER_FIELD_ETH_SA):
+                         return CC_PC_FF_MACSRC;
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                         return CC_PC_FF_ETYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+                }
+
+         case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_TCI2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+                default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+            }
+
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return CC_PC_ILLEGAL;
+               default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+             }
+
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    return CC_PC_FF_IPV4TTL;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                    return CC_PC_FF_IPV6HOP_LIMIT;
+                 default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return CC_PC_FF_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return CC_PC_FF_MINENCAP_PTYPE;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPDST;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return CC_PC_FF_PPPPID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+         default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return CC_PC_ILLEGAL;
+    }
+}
+
+static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+{
+    bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr){
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+            return CC_PC_ILLEGAL;
+        case(HEADER_TYPE_ETH):
+            *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+            else
+                return CC_PC_PR_SHIM1;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+            else
+                return CC_PC_PR_SHIM2;
+            break;
+      case(HEADER_TYPE_LLC_SNAP):
+            *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+            break;
+        case(HEADER_TYPE_PPPoE):
+            *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+            break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                    return CC_PC_ILLEGAL;
+                }
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+              else
+              {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+                return CC_PC_ILLEGAL;
+
+              }
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
+                return CC_PC_ILLEGAL;
+     }
+
+        if(offsetRelevant)
+            return CC_PR_OFFSET;
+        else
+            return CC_PR_WITHOUT_OFFSET;
+}
+
+static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint32_t offset, uint8_t *parseArrayOffset, e_FmPcdHdrIndex hdrIndex)
+{
+    bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                    else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+        break;
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal header "));
+            return CC_PC_ILLEGAL;
+    }
+    if(offsetRelevant)
+        return CC_PR_OFFSET;
+    else
+        return CC_PR_WITHOUT_OFFSET;
+}
+
+static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+{
+    t_AdOfTypeResult                *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    uint32_t                        tmp = 0, tmpNia = 0;
+    uint16_t                        profileId;
+    t_Handle                        p_AdNewPtr = NULL;
+
+    p_AdNewPtr = p_AdResult;
+
+#ifdef FM_PCD_CC_MANIP
+    if (p_CcNextEngineParams->h_Manip)
+        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip, p_Ad, &p_AdNewPtr);
+#endif /* FM_PCD_CC_MANIP */
+
+    if(p_AdNewPtr)
+    {
+        switch(p_CcNextEngineParams->nextEngine)
+        {
+            case(e_FM_PCD_DONE):
+                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+                {
+                    if(p_CcNextEngineParams->params.enqueueParams.overrideFqid)
+                    {
+                       tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                       tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+                    }
+                    else
+                    {
+                       tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                       tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                    }
+                }
+            if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_DISCARD);
+            else
+                tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME);
+            if(p_CcNextEngineParams->params.enqueueParams.statisticsEn)
+                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+                break;
+            case(e_FM_PCD_KG):
+                if(p_CcNextEngineParams->params.kgParams.overrideFqid)
+                {
+                    tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                    tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
+                }
+                else
+                {
+                    tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                    tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                }
+                tmpNia = NIA_KG_DIRECT;
+                tmpNia |= NIA_ENG_KG;
+                tmpNia |= (uint8_t)(PTR_TO_UINT(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
+            if(p_CcNextEngineParams->params.kgParams.statisticsEn)
+                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+            break;
+            case(e_FM_PCD_PLCR):
+                tmp = 0;
+                if(p_CcNextEngineParams->params.plcrParams.overrideParams)
+                {
+                    tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+
+                    /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                    if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
+                    {
+                        tmpNia |= NIA_PLCR_ABSOLUTE;
+                        FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
+                    }
+                    else
+                        profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+
+                    tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
+                    WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
+                }
+                else
+                   tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+            if(p_CcNextEngineParams->params.kgParams.statisticsEn)
+                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+               break;
+            default:
+                return;
+        }
+        WRITE_UINT32(p_AdResult->fqid, tmp);
+
+#ifdef FM_PCD_CC_MANIP
+        if(p_CcNextEngineParams->h_Manip)
+        {
+            tmp = GET_UINT32(p_AdResult->plcrProfile);
+            tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr) - (p_FmPcd->physicalMuramBase)) >> 4;
+            WRITE_UINT32(p_AdResult->plcrProfile, tmp);
+
+            tmpNia |= FM_PCD_AD_RESULT_EXTENDED_MODE;
+            tmpNia |= FM_PCD_AD_RESULT_NADEN;
+        }
+#endif /* FM_PCD_CC_MANIP */
+
+        WRITE_UINT32(p_AdResult->nia, tmpNia);
+    }
+}
+
+static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode, t_Handle h_Manip)
+{
+    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_FmPcdCcNode;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                tmpReg32;
+    t_Handle                p_AdNewPtr = NULL;
+
+    p_AdNewPtr = p_AdContLookup;
+
+#ifdef FM_PCD_CC_MANIP
+    if (h_Manip)
+        FmPcdManipUpdateAdContLookupForCc(h_Manip, p_Ad, &p_AdNewPtr, (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase)));
+#else
+    UNUSED(h_Manip);
+#endif /* FM_PCD_CC_MANIP */
+
+    if(p_AdNewPtr)
+    {
+        tmpReg32 = 0;
+        tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
+        WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
+
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->numOfKeys << 24;
+        tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
+        tmpReg32 |= p_Node->h_KeysMatchTable ?
+                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
+        WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
+
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->prsArrayOffset << 24;
+        tmpReg32 |= p_Node->offset << 16;
+        tmpReg32 |= p_Node->parseCode;
+        WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+
+        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
+    }
+}
+
+static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+{
+    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_KG):
+        case(e_FM_PCD_PLCR):
+        case(e_FM_PCD_DONE):
+            FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            break;
+        case(e_FM_PCD_CC):
+            FillAdOfTypeContLookup(p_Ad,
+                                   p_FmPcd,
+                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+#ifdef FM_PCD_CC_MANIP
+                                   p_FmPcdCcNextEngineParams->h_Manip
+#else
+                                   NULL
+#endif /* FM_PCD_CC_MANIP */
+                                   );
+            UpdateNodeOwner (p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                            TRUE);
+            break;
+         default:
+             return;
+    }
+}
+
+
+static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    if(p_AdditionalInfo->p_AdTableNew)
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+    if(p_AdditionalInfo->p_KeysMatchTableNew)
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
+}
+
+static t_Error UpdateGblMask(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keySize, uint8_t *p_Mask)
+{
+    if (p_Mask &&
+        !p_FmPcdCcNode->glblMaskUpdated &&
+        (keySize <= 4) &&
+        !p_FmPcdCcNode->lclMask )
+    {
+        memcpy(p_FmPcdCcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
+        p_FmPcdCcNode->glblMaskUpdated = TRUE;
+        p_FmPcdCcNode->glblMaskSize = 4;
+    }
+    else if (p_Mask &&
+             (keySize <= 4) &&
+             !p_FmPcdCcNode->lclMask)
+    {
+        if (memcmp(p_FmPcdCcNode->p_GlblMask, p_Mask, keySize) != 0)
+        {
+            p_FmPcdCcNode->lclMask = TRUE;
+            p_FmPcdCcNode->glblMaskSize = 0;
+        }
+    }
+    else if (!p_Mask && (p_FmPcdCcNode->glblMaskUpdated) && (keySize <= 4))
+    {
+        uint32_t tmpMask = 0xffffffff;
+        if (memcmp(p_FmPcdCcNode->p_GlblMask, &tmpMask, 4) != 0)
+        {
+            p_FmPcdCcNode->lclMask = TRUE;
+            p_FmPcdCcNode->glblMaskSize = 0;
+        }
+    }
+    else if (p_Mask)
+    {
+        p_FmPcdCcNode->lclMask = TRUE;
+        p_FmPcdCcNode->glblMaskSize = 0;
+    }
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_FmPcdCcNode,
+                                      int                                   *size,
+                                      t_FmPcdModifyCcKeyAdditionalParams    *p_AdditionalInfo)
+{
+
+    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
+                                     (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_AdTableNew)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
+
+    IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    if(p_FmPcdCcNode->lclMask)
+        *size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    else
+        *size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+
+    p_AdditionalInfo->p_KeysMatchTableNew =
+        (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
+                                    (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
+                                    FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_KeysMatchTableNew)
+    {
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+        p_AdditionalInfo->p_AdTableNew = NULL;
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+    }
+    IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+
+    p_AdditionalInfo->p_AdTableOld          = p_FmPcdCcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld   = p_FmPcdCcNode->h_KeysMatchTable;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
+{
+    t_Error                 err = E_OK;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                requiredAction = 0;
+    bool                    prvLclMask;
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_List                  *p_Pos;
+
+    /*check that new NIA is legal*/
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    prvLclMask = p_FmPcdCcNode->lclMask;
+
+    /*check that new key is not require update of localMask*/
+    err = UpdateGblMask(p_FmPcdCcNode,
+                        p_FmPcdCcNode->ccKeySizeAccExtraction,
+                        p_KeyParams->p_Mask);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*update internal data structure for next engine per index (index - key)*/
+    memcpy(&p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].nextEngineParams,&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+
+    /*update numOfKeys*/
+    if(add)
+        p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+    else
+        p_AdditionalInfo->numOfKeys = (uint8_t)p_FmPcdCcNode->numOfKeys;
+    /*function which build in the memory new KeyTbl, AdTbl*/
+    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size, p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+#ifdef FM_PCD_CC_MANIP
+    /*check that manip is legal and what requiredAction is necessary for this manip*/
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction = requiredAction;
+
+    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+
+
+    /*update new Ad and new Key Table according to new requirement*/
+    i = 0;
+    for(j = 0; j < p_AdditionalInfo->numOfKeys; j++)
+    {
+        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+         {
+            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->userSizeOfExtraction);
+            if(p_FmPcdCcNode->lclMask)
+            {
+                if(p_KeyParams->p_Mask)
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->userSizeOfExtraction);
+                else if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                else
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->p_GlblMask, 4);
+            }
+            if(!add)
+                i++;
+         }
+         else
+         {
+            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+            p_KeysMatchTableNewTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i*size * sizeof(uint8_t));
+
+            if(p_FmPcdCcNode->lclMask)
+            {
+                if(prvLclMask)
+                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
+                               PTR_MOVE(p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
+                               p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                {
+                    p_KeysMatchTableOldTmp  = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+
+                    if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                    else
+                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_FmPcdCcNode->p_GlblMask, 4);
+                }
+            }
+            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+           i++;
+         }
+    }
+
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+    {
+        LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+        {
+            p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+            ASSERT_COND(p_CcNodeInformation->h_CcNode);
+            /*update the manipulation which has to be updated from parameters of the port*/
+            /*it's has to be updated with restrictions defined in the function*/
+                err = FmPcdCcSetRequiredAction(p_FmPcdCcNode->h_FmPcd,
+                                               p_FmPcdCcNode->shadowAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction,
+                                               &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
+                                               PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                               1,
+                                               p_CcNodeInformation->h_CcNode);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+                err = CcUpdateParam(p_FmPcdCcNode->h_FmPcd,
+                                    NULL,
+                                    &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
+                                    1,
+                                    PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                    TRUE,
+                                    p_CcNodeInformation->index,
+                                    p_CcNodeInformation->h_CcNode,
+                                    TRUE);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+   }
+
+    if(p_FmPcdCcNode->lclMask)
+        memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+
+
+    if(p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+
+    if(!add)
+    {
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+#ifdef FM_PCD_CC_MANIP
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
+#endif /* FM_PCD_CC_MANIP */
+    }
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    int         i = 0, j = 0;
+    t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
+    t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int         size;
+    t_Error     err = E_OK;
+
+    /*save new numOfKeys*/
+    p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
+
+    /*function which allocates in the memory new KeyTbl, AdTbl*/
+    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size, p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*update new Ad and new Key Table according to new requirement*/
+    for(i = 0, j = 0; j < p_FmPcdCcNode->numOfKeys; i++, j++)
+    {
+        if(j == keyIndex)
+        {
+            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
+            j++;
+        }
+        if(j == p_FmPcdCcNode->numOfKeys)
+            break;
+         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
+         IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+         p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j*size * sizeof(uint8_t));
+         p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i*size * sizeof(uint8_t));
+         IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
+    }
+
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+#ifdef FM_PCD_CC_MANIP
+    if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
+        p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
+#endif /* FM_PCD_CC_MANIP */
+
+   return E_OK;
+}
+
+static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err = E_OK;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+    bool                    prvLclMask;
+
+    p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode->numOfKeys;
+
+    prvLclMask = p_FmPcdCcNode->lclMask;
+
+    /*check that new key is not require update of localMask*/
+    err = UpdateGblMask(p_FmPcdCcNode,
+                        p_FmPcdCcNode->sizeOfExtraction,
+                        p_Mask);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*function which build in the memory new KeyTbl, AdTbl*/
+    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size,  p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*fill the New AdTable and New KeyTable*/
+    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    {
+        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+        {
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->userSizeOfExtraction);
+            if(p_FmPcdCcNode->lclMask)
+            {
+                if(p_Mask)
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->userSizeOfExtraction);
+                else if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                else
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->p_GlblMask, 4);
+            }
+        }
+        else
+        {
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*size * sizeof(uint8_t));
+            if (p_FmPcdCcNode->lclMask)
+            {
+                if(prvLclMask)
+                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
+                               PTR_MOVE(p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
+                               p_FmPcdCcNode->userSizeOfExtraction);
+                else
+                {
+                    p_KeysMatchTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*p_FmPcdCcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+
+                    if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                    else
+                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_FmPcdCcNode->p_GlblMask, 4);
+                }
+            }
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+        }
+    }
+
+    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,t_FmPcdCcNextEngineParams   *p_CcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+
+    t_Error      err = E_OK;
+    uint32_t     requiredAction = 0;
+    t_List       *p_Pos;
+    t_CcNodeInformation *p_CcNodeInformation, ccNodeInfo;
+    t_Handle     p_Ad;
+    t_FmPcdCcNode *p_FmPcdCcNode1 = NULL;
+    t_FmPcdCcTree *p_FmPcdCcTree = NULL;
+
+    ASSERT_COND(p_CcNextEngineParams);
+    /*check that new NIA is legal*/
+    err = ValidateNextEngineParams(h_FmPcd, p_CcNextEngineParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*update internal data structure for next engine per index (index - key)*/
+    memcpy(&p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].nextEngineParams,p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+
+#ifdef FM_PCD_CC_MANIP
+    /*check that manip is legal and what requiredAction is necessary for this manip*/
+    if(p_CcNextEngineParams->h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCcNextEgine(p_CcNextEngineParams,&requiredAction);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    if(!p_AdditionalInfo->tree)
+    {
+        p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
+        p_Ad = p_FmPcdCcNode1->h_AdTable;
+        if(p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+#ifdef FM_PCD_CC_MANIP
+        if(p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
+#endif /* FM_PCD_CC_MANIP */
+    }
+    else
+    {
+        p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
+        p_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+        if(p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+#ifdef FM_PCD_CC_MANIP
+        if(p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
+#endif /* FM_PCD_CC_MANIP */
+    }
+    ASSERT_COND(p_Ad);
+    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+    ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
+    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+
+    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+    p_Ad = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
+                                         FM_PCD_CC_AD_ENTRY_SIZE,
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_Ad)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32((uint8_t *)p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    if(p_CcNextEngineParams)
+        NextStepAd(p_Ad,p_CcNextEngineParams, h_FmPcd);
+    ccNodeInfo.h_CcNode = p_Ad;
+    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+
+    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction = requiredAction;
+
+    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+
+    if(!p_AdditionalInfo->tree)
+    {
+        ASSERT_COND(p_FmPcdCcNode1);
+        if(!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
+        {
+            LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode1->ccTreesLst)
+            {
+                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+                ASSERT_COND(p_CcNodeInformation->h_CcNode);
+                /*update the manipulation which has to be updated from parameters of the port*/
+                /*it's has to be updated with restrictions defined in the function*/
+                    err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd, p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
+                                                   p_Ad, 1, p_CcNodeInformation->h_CcNode);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, (NO_MSG));
+                     err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, (NO_MSG));
+            }
+        }
+    }
+    else
+    {
+       ASSERT_COND(p_FmPcdCcTree);
+       err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->requiredAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
+                                       p_Ad, 1, (t_Handle)p_FmPcdCcTree);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+         err = CcUpdateParam(h_FmPcd, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+
+    if(p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
+    return E_OK;
+}
+
+static t_Handle BuildNewAd(t_FmPcdModifyCcKeyAdditionalParams   *p_FmPcdModifyCcKeyAdditionalParams,
+                           t_FmPcdCcNode                        *p_FmPcdCcNode,
+                           t_FmPcdCcNextEngineParams            *p_FmPcdCcNextEngineParams)
+{
+
+    t_Handle        p_Ad;
+    t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
+
+    p_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_FmPcdCcNode->h_FmPcd))->h_FmMuram,
+                                         FM_PCD_CC_AD_ENTRY_SIZE,
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_Ad)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM for AD"));
+        return NULL;
+    }
+    IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_FmPcdCcNodeTmp)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
+        return NULL;
+    }
+    memset(p_FmPcdCcNodeTmp, 0, sizeof(t_FmPcdCcNode));
+
+    p_FmPcdCcNodeTmp->numOfKeys = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTmp->h_KeysMatchTable = p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+    p_FmPcdCcNodeTmp->h_AdTable = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+
+    p_FmPcdCcNodeTmp->lclMask = p_FmPcdCcNode->lclMask;
+    p_FmPcdCcNodeTmp->parseCode = p_FmPcdCcNode->parseCode;
+    p_FmPcdCcNodeTmp->offset = p_FmPcdCcNode->offset;
+    p_FmPcdCcNodeTmp->prsArrayOffset = p_FmPcdCcNode->prsArrayOffset;
+    p_FmPcdCcNodeTmp->ctrlFlow = p_FmPcdCcNode->ctrlFlow;
+    p_FmPcdCcNodeTmp->ccKeySizeAccExtraction = p_FmPcdCcNode->ccKeySizeAccExtraction;
+    p_FmPcdCcNodeTmp->sizeOfExtraction = p_FmPcdCcNode->sizeOfExtraction;
+    p_FmPcdCcNodeTmp->glblMaskSize = p_FmPcdCcNode->glblMaskSize;
+    p_FmPcdCcNodeTmp->p_GlblMask = p_FmPcdCcNode->p_GlblMask;
+
+    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
+        FillAdOfTypeContLookup(p_Ad,
+                               p_FmPcdCcNode->h_FmPcd,
+                               p_FmPcdCcNodeTmp,
+#ifdef FM_PCD_CC_MANIP
+                               p_FmPcdCcNextEngineParams->h_Manip
+#else
+                               NULL
+#endif /* FM_PCD_CC_MANIP */
+                               );
+
+    XX_Free(p_FmPcdCcNodeTmp);
+
+    return p_Ad;
+}
+
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode *p_CrntMdfNode ,t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams, t_List  *h_OldLst, t_List  *h_NewLst)
+{
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
+    t_List                  *p_Pos;
+    int                     i = 0;
+    t_Handle                p_AdTablePtOnCrntCurrentMdfNode, p_AdTableNewModified;
+    t_CcNodeInformation     ccNodeInfo;
+
+    LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccPrevNodesLst)
+    {
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        p_NodePtrOnCurrentMdfNode = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+        ASSERT_COND(p_NodePtrOnCurrentMdfNode);
+        /*search in the prev node which exact index points on this current modified node for getting AD */
+        for(i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
+        {
+            if(p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                if(p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                {
+                    p_AdTablePtOnCrntCurrentMdfNode = PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
+                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+
+                    p_AdTableNewModified = BuildNewAd(p_FmPcdModifyCcKeyAdditionalParams, p_CrntMdfNode, &p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams);
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTableNewModified;
+                    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+                }
+            }
+        }
+        ASSERT_COND(i != p_NodePtrOnCurrentMdfNode->numOfKeys);
+    }
+}
+
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode *p_CrntMdfNode ,t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams, t_List  *h_OldLst, t_List  *h_NewLst)
+{
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcTree           *p_TreePtrOnCurrentMdfNode = NULL;
+    t_List                  *p_Pos;
+    int                     i = 0;
+    t_Handle                p_AdTableTmp, p_AdTableTmp1;
+    t_CcNodeInformation     ccNodeInfo;
+
+    LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccTreeIdLst)
+    {
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        p_TreePtrOnCurrentMdfNode = (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
+
+        ASSERT_COND(p_TreePtrOnCurrentMdfNode);
+        /*search in the trees which exact index points on this current modified node for getting AD
+        */
+        for(i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
+        {
+            if(p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                if(p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                {
+                    p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTableTmp;
+                    EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
+
+                    p_AdTableTmp1 = BuildNewAd(p_FmPcdModifyCcKeyAdditionalParams, p_CrntMdfNode, &p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams);
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = p_AdTableTmp1;
+                    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+                }
+        }
+    }
+        ASSERT_COND(i == p_TreePtrOnCurrentMdfNode->numOfEntries);
+     }
+}
+
+static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyIndex, t_Handle *h_Params, e_ModifyState modifyState, bool check, bool tree)
+{
+    t_FmPcdModifyCcKeyAdditionalParams          *p_FmPcdModifyCcKeyAdditionalParams;
+    int                                         i = 0, j = 0;
+    bool                                        wasUpdate = FALSE;
+    t_FmPcdCcNode                               *p_FmPcdCcNode = NULL;
+    t_FmPcdCcTree                               *p_FmPcdCcTree;
+    uint16_t                                    numOfKeys;
+    t_FmPcdCcNextEngineAndRecuiredActionParams  *p_nextEngineAndRequiredAction = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNodeOrTree,E_INVALID_HANDLE);
+
+    p_nextEngineAndRequiredAction = XX_Malloc(FM_PCD_MAX_NUM_OF_KEYS * sizeof(*p_nextEngineAndRequiredAction));
+    if(!p_nextEngineAndRequiredAction) {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate memory for p_nextEngineAndRequiredAction"));
+    }
+    memset(p_nextEngineAndRequiredAction, 0, FM_PCD_MAX_NUM_OF_KEYS * sizeof(*p_nextEngineAndRequiredAction));
+
+    if(!tree)
+    {
+        p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
+        numOfKeys = p_FmPcdCcNode->numOfKeys;
+
+        /*node has to be pointed by another node or tree*/
+        if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
+            !LIST_NumOfObjs(&p_FmPcdCcNode->ccTreeIdLst)) {
+            XX_Free(p_nextEngineAndRequiredAction);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be pointed by node or tree"));
+        }
+
+        if(!LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) ||
+            (LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) != 1)) {
+            XX_Free(p_nextEngineAndRequiredAction);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be belonging to some tree and only to one tree"));
+        }
+
+        memcpy(p_nextEngineAndRequiredAction,
+               p_FmPcdCcNode->nextEngineAndRequiredAction,
+               FM_PCD_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams));
+
+        if(check)
+        {
+            if((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+               (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT) ||
+               (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)) {
+                XX_Free(p_nextEngineAndRequiredAction);
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
+            }
+        }
+    }
+    else
+    {
+        p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
+        numOfKeys = p_FmPcdCcTree->numOfEntries;
+        memcpy(p_nextEngineAndRequiredAction,
+               p_FmPcdCcTree->nextEngineAndRequiredAction,
+               FM_PCD_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams));
+    }
+
+    p_FmPcdModifyCcKeyAdditionalParams =
+        (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+    if(!p_FmPcdModifyCcKeyAdditionalParams) {
+        XX_Free(p_nextEngineAndRequiredAction);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
+    }
+    memset(p_FmPcdModifyCcKeyAdditionalParams, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+
+    p_FmPcdModifyCcKeyAdditionalParams->h_CurrentNode = h_FmPcdCcNodeOrTree;
+    p_FmPcdModifyCcKeyAdditionalParams->keyIndex = keyIndex;
+
+    while(i < numOfKeys)
+    {
+        if((j == keyIndex) && !wasUpdate)
+        {
+            if(modifyState == e_MODIFY_STATE_ADD)
+                j++;
+            else if(modifyState == e_MODIFY_STATE_REMOVE)
+                i++;
+            wasUpdate = TRUE;
+        }
+        else
+        {
+            memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j], &p_nextEngineAndRequiredAction[i], sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams));
+            i++;
+            j++;
+        }
+    }
+
+    if (keyIndex == numOfKeys)
+    {
+        if (modifyState == e_MODIFY_STATE_ADD)
+            j++;
+        else if(modifyState == e_MODIFY_STATE_REMOVE)
+            i++;
+    }
+
+    memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j], &p_nextEngineAndRequiredAction[numOfKeys], sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams));
+
+    XX_Free(p_nextEngineAndRequiredAction);
+    *h_Params = p_FmPcdModifyCcKeyAdditionalParams;
+
+    return E_OK;
+}
+
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_List *h_NewLst)
+{
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewLst);
+
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
+        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewLst);
+
+    return E_OK;
+}
+
+static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
+{
+    ASSERT_COND(p_FmPcdCcTree);
+
+    if(add)
+        p_FmPcdCcTree->owners++;
+    else
+    {
+        ASSERT_COND(p_FmPcdCcTree->owners);
+        p_FmPcdCcTree->owners--;
+    }
+}
+
+#ifdef FM_PCD_CC_MANIP
+static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_FmPcdCcNode)
+{
+    t_Error err = E_OK;
+    int     i = 0;
+
+    for(i = 0; i < p_FmPcdCcNode->numOfKeys; i++)
+    {
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
+        {
+            err = FmPcdManipCheckParamsWithCcNodeParams(p_FmPcdCcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, (t_Handle)p_FmPcdCcNode);
+            if(err)
+                return err;
+        }
+    }
+
+    return err;
+}
+#endif /* FM_PCD_CC_MANIP */
+
+static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
+                              t_Handle                         h_FmPort,
+                              t_Handle                         h_FmTree,
+                              bool                             validate)
+{
+    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+
+    return CcUpdateParam(h_FmPcd,
+                         h_FmPort,
+                         p_CcTree->nextEngineAndRequiredAction,
+                         p_CcTree->numOfEntries,
+                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr),
+                         validate,
+                         0,
+                         h_FmTree,
+                         FALSE);
+}
+
+static t_Error CheckParams(t_Handle             h_FmPcd,
+                           t_FmPcdCcNodeParams  *p_CcNodeParam,
+                           t_FmPcdCcNode        *p_FmPcdCcNode,
+                           bool                 *isKeyTblAlloc)
+{
+    int                     tmp = 0;
+    t_FmPcdCcKeyParams      *p_KeyParams;
+    t_Error                 err;
+    uint32_t                requiredAction = 0;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    if(err)
+        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+
+#ifdef FM_PCD_CC_MANIP
+    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+    p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].requiredAction = requiredAction;
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if(!p_KeyParams->p_Key)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
+
+
+       err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+        err = UpdateGblMask(p_FmPcdCcNode,
+                            p_CcNodeParam->keysParams.keySize,
+                            p_KeyParams->p_Mask);
+
+#ifdef FM_PCD_CC_MANIP
+        if(p_KeyParams->ccNextEngineParams.h_Manip)
+        {
+            err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            if(err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+#endif /* FM_PCD_CC_MANIP */
+
+        memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp],&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+    }
+
+    *isKeyTblAlloc = TRUE;
+    return E_OK;
+}
+
+static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(  t_Handle h_FmPcd,
+                                                    t_FmPcdCcNodeParams *p_CcNodeParam, t_FmPcdCcNode *p_FmPcdCcNode,
+                                                    bool *isKeyTblAlloc)
+{
+    int                 tmp = 0;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Error             err;
+    uint8_t             key = 0x01;
+    uint32_t            requiredAction = 0;
+
+    if(p_FmPcdCcNode->numOfKeys != 1 )
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    if(err)
+        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+
+#ifdef FM_PCD_CC_MANIP
+    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+    p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].requiredAction = requiredAction;
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if(p_KeyParams->p_Mask)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
+        if(memcmp(p_KeyParams->p_Key, &key, 1) != 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+#ifdef FM_PCD_CC_MANIP
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    {
+        err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+        if(err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+        memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams, &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+    }
+
+    *isKeyTblAlloc = FALSE;
+    return E_OK;
+}
+
+static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
+                                            t_FmPcdCcNodeParams *p_CcNodeParam,
+                                            t_FmPcdCcNode *p_FmPcdCcNode,
+                                            /*uint16_t *ccInfo,*/
+                                            /*t_List *ccNextDifferentNodesLst,*/
+                                            bool *isKeyTblAlloc)
+{
+    int                 tmp = 0, countOnes = 0;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Error             err;
+    uint16_t            glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
+    uint16_t            countMask = (uint16_t)(glblMask >> 4);
+#ifdef FM_PCD_CC_MANIP
+    uint32_t            requiredAction;
+#endif /* FM_PCD_CC_MANIP */
+
+    if (glblMask & 0x000f)
+       RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("icIndxMask has to be with last nibble 0"));
+
+    while (countMask)
+    {
+        countOnes++;
+        countMask=(uint16_t)(countMask>>1);
+    }
+
+    if (!POWER_OF_2(p_FmPcdCcNode->numOfKeys))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
+    if (p_FmPcdCcNode->numOfKeys != ((uint32_t)1<<countOnes ))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
+    if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+        RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
+
+        if((glblMask & (tmp * 16)) == (tmp * 16))
+        {
+            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+            if(err)
+                RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
+
+#ifdef FM_PCD_CC_MANIP
+            if(p_KeyParams->ccNextEngineParams.h_Manip)
+            {
+                err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+            }
+            p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+#endif /* FM_PCD_CC_MANIP */
+
+            memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams,&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        }
+        else
+        {
+            err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+            if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+                RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
+        }
+    }
+    *isKeyTblAlloc = FALSE;
+    memcpy(PTR_MOVE(p_FmPcdCcNode->p_GlblMask, 2), &glblMask, 2);
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error                             err = E_OK;
+    uint16_t                            keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
+    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+
+    err =  ModifyKeyCommonPart1(h_FmPcdCcTree, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    p_ModifyKeyParams->tree = TRUE;
+
+    err = BuildNewNodeModifyNextEngine (h_FmPcd, h_FmPcdCcTree, keyIndex,p_FmPcdCcNextEngineParams, h_OldLst, h_NewLst, p_ModifyKeyParams);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+
+}
+
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+{
+
+    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
+    t_Error                             err = E_OK;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("impossible to remove key when numOfKeys <= keyIndex"));
+
+    if(!p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_REMOVE, TRUE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    err = BuildNewNodeRemoveKey (p_FmPcdCcNode, keyIndex, p_ModifyKeyParams);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+
+}
+
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_List *h_NewLst,t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                             err = E_OK;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    if(keySize != p_FmPcdCcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
+
+    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+
+    err = BuildNewNodeModifyKey (p_FmPcdCcNode, keyIndex, p_Key, p_Mask, p_ModifyKeyParams);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+}
+
+
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err = E_OK;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, FALSE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+
+    err = BuildNewNodeModifyNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex,p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer, p_ModifyKeyParams);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err = E_OK;
+    uint16_t                         keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_VALUE);
+
+    keyIndex = p_FmPcdCcNode->numOfKeys;
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+
+    err = BuildNewNodeModifyNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex,p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer, p_ModifyKeyParams);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
+
+    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    if(keySize != p_FmPcdCcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_ADD, TRUE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_ModifyKeyParams, TRUE);
+    if(err)
+    {
+        XX_Free(p_ModifyKeyParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
+                if(err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+{
+    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
+
+    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    if(keySize != p_FmPcdCcNode->sizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_ModifyKeyParams, FALSE);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges, t_Handle *h_Params)
+{
+    t_FmPcdModifyCcKeyAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_Params;
+    t_List                          *p_Pos;
+    t_Error                         err = E_OK;
+    t_CcNodeInformation             ccNodeInfo, *p_CcNodeInformation;
+    t_Handle                        h_Muram;
+    t_FmPcdCcNode                   *p_FmPcdCcNextNode;
+    t_List                          *p_UpdateLst;
+
+    UNUSED(numOfGoodChanges);
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_CurrentNode,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_FmPcdOldPointersLst) == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
+
+    /*we don't update subtree of the new node with new tree because it was done in the previose stage*/
+    if(p_CcNewModifyAdditionalParams->h_NodeForAdd)
+    {
+        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_NodeForAdd;
+        if(!p_CcNewModifyAdditionalParams->tree)
+            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
+        else
+            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
+        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst, p_CcNewModifyAdditionalParams->h_CurrentNode);
+        if(p_CcNodeInformation)
+            p_CcNodeInformation->index++;
+        else
+        {
+            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+            ccNodeInfo.h_CcNode = (t_Handle)p_CcNewModifyAdditionalParams->h_CurrentNode;
+            ccNodeInfo.index = 1;
+            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo);
+        }
+    }
+
+     if(p_CcNewModifyAdditionalParams->h_NodeForRmv)
+    {
+
+        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_NodeForRmv;
+        if(!p_CcNewModifyAdditionalParams->tree)
+        {
+            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
+            LIST_FOR_EACH(p_Pos, &p_FmPcdCcNextNode->ccTreesLst)
+            {
+                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+                ASSERT_COND(p_CcNodeInformation->h_CcNode);
+                err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                               UPDATE_CC_WITH_DELETE_TREE,
+                                               &((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction[p_CcNewModifyAdditionalParams->keyIndex],
+                                               PTR_MOVE(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_AdTable, p_CcNewModifyAdditionalParams->keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                               1,
+                                               p_CcNodeInformation->h_CcNode);
+            }
+        }
+        else
+        {
+            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
+            err =  FmPcdCcSetRequiredAction(h_FmPcd,
+                                            UPDATE_CC_WITH_DELETE_TREE,
+                                            &((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction[p_CcNewModifyAdditionalParams->keyIndex],
+                                            UINT_TO_PTR(((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_CcNewModifyAdditionalParams->keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                            1,
+                                            p_CcNewModifyAdditionalParams->h_CurrentNode);
+        }
+        if(err)
+            return err;
+
+        /*we remove from the  subtree of the removed node tree because it wasn't done in the previose stage*/
+        /*update ccPrevNodesLst or ccTreeIdLst of the removed node*/
+        /*update of the nodeOwner*/
+        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst, p_CcNewModifyAdditionalParams->h_CurrentNode);
+        ASSERT_COND(p_CcNodeInformation);
+        ASSERT_COND(p_CcNodeInformation->index);
+        p_CcNodeInformation->index--;
+        if(p_CcNodeInformation->index == 0)
+           DequeueNodeInfoFromRelevantLst(p_UpdateLst,p_CcNewModifyAdditionalParams->h_CurrentNode);
+        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNextNode->ccTreesLst) == 1);
+        UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
+    }
+
+#ifdef FM_PCD_CC_MANIP
+    if(p_CcNewModifyAdditionalParams->h_ManipForRmv)
+        FmPcdManipUpdateOwner(p_CcNewModifyAdditionalParams->h_ManipForRmv, FALSE);
+#endif /* FM_PCD_CC_MANIP */
+
+    h_Muram = FmPcdGetMuramHandle(h_FmPcd);
+    ASSERT_COND(h_Muram);
+
+    /*we release new AD which was allocated and updated for copy from to actual AD*/
+    LIST_FOR_EACH(p_Pos, h_FmPcdNewPointersLst)
+    {
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcNodeInformation->h_CcNode);
+        FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+
+     }
+
+    /*free Old data structure if it has to be freed - new data structure was allocated*/
+    if(p_CcNewModifyAdditionalParams->p_AdTableOld)
+        FM_MURAM_FreeMem(h_Muram,p_CcNewModifyAdditionalParams->p_AdTableOld);
+    if(p_CcNewModifyAdditionalParams->p_KeysMatchTableOld)
+        FM_MURAM_FreeMem(h_Muram,p_CcNewModifyAdditionalParams->p_KeysMatchTableOld);
+
+    /*update current modified node with changed fields if it's required*/
+    if(!p_CcNewModifyAdditionalParams->tree)
+    {
+        if(p_CcNewModifyAdditionalParams->p_AdTableNew)
+            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_AdTable    = p_CcNewModifyAdditionalParams->p_AdTableNew;
+        if(p_CcNewModifyAdditionalParams->numOfKeys)
+            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfKeys    = p_CcNewModifyAdditionalParams->numOfKeys;
+        if(p_CcNewModifyAdditionalParams->p_KeysMatchTableNew)
+            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_KeysMatchTable    = p_CcNewModifyAdditionalParams->p_KeysMatchTableNew;
+        memcpy(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams) * (FM_PCD_MAX_NUM_OF_KEYS));
+    }
+    else
+        memcpy(&((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams) * (((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfEntries));
+
+    ReleaseLst(h_FmPcdOldPointersLst);
+    ReleaseLst(h_FmPcdNewPointersLst);
+    XX_Free(p_CcNewModifyAdditionalParams);
+
+    return E_OK;
+}
+
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInformation             *p_CcNodeInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+
+    p_CcNodeInfo = CC_NODE_F_OBJECT(h_Pointer);
+    return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode) - p_FmPcd->physicalMuramBase);
+}
+
+t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_STATE);
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+    *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
+    *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
+    return E_OK;
+}
+
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset, t_Handle h_FmPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error             err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
+
+    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, TRUE);
+
+    *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
+                           p_FmPcd->physicalMuramBase);
+
+    err = CcUpdateParams(h_FmPcd, h_FmPort, h_FmPcdCcTree, TRUE);
+
+    return err;
+}
+
+t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
+{
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
+    UNUSED(h_FmPcd);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_HANDLE);
+
+    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, FALSE);
+
+    return E_OK;
+}
+
+t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
+{
+    if (TRY_LOCK(NULL, &((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
+}
+
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+{
+    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List          *p_Pos;
+    t_CcNodeInformation    *p_CcNodeInfo, nodeInfo;
+    t_Error         err = E_OK;
+
+    UNUSED(h_FmPcd);
+
+    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcNodeInfo->h_CcNode);
+        err = FmPcdCcTreeTryLock(p_CcNodeInfo->h_CcNode);
+        if(err == E_OK)
+        {
+            memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
+            nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
+            EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
+        }
+        else
+            FmPcdCcNodeTreeReleaseLock(p_List);
+    }
+
+    return err;
+}
+
+t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Error                     err = E_OK;
+    int                         i = 0, j = 0, k = 0;
+    t_FmPcdCcTree               *p_FmPcdCcTree;
+    uint8_t                     numOfEntries;
+    t_Handle                    p_CcTreeTmp;
+    t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
+    t_FmPcdCcNextEngineAndRecuiredActionParams   params[16];
+    t_NetEnvParams              netEnvParams;
+    uint8_t                     lastOne = 0;
+    uint32_t                    requiredAction = 0;
+    t_FmPcdCcNode               *p_FmPcdCcNextNode;
+    t_CcNodeInformation         ccNodeInfo, *p_CcInformation;
+
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
+
+    memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
+
+    p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc (sizeof(t_FmPcdCcTree));
+    if(!p_FmPcdCcTree)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
+
+    INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
+
+    if(p_PcdGroupsParam->numOfGrps > 8)
+    {
+        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 8"));
+        return NULL;
+    }
+    numOfEntries = 0;
+    p_FmPcdCcTree->netEnvId = (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1);
+    for(i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
+    {
+        p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
+        p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
+        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+        if(numOfEntries > 16)
+        {
+            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries can not be larger than 16"));
+            return NULL;
+        }
+        if(lastOne)
+        {
+            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            {
+                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries per group in Tree has to  be from biggest to lower"));
+                return NULL;
+            }
+        }
+
+        lastOne = p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+
+        netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds, (sizeof(uint8_t)) * p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+        {
+            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            return NULL;
+        }
+
+        p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
+        for(j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        {
+            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j]);
+            if(err)
+            {
+                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                REPORT_ERROR(MAJOR, err, (NO_MSG));
+                return NULL;
+            }
+
+#ifdef FM_PCD_CC_MANIP
+            if(p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
+            {
+                err = FmPcdManipCheckParamsForCcNextEgine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
+                if(err)
+                {
+                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                    return NULL;
+                }
+           }
+#endif /* FM_PCD_CC_MANIP */
+
+           memcpy(&params[k].nextEngineParams, &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
+           requiredAction |= UPDATE_CC_WITH_TREE;
+           params[k].requiredAction = requiredAction;
+           k++;
+        }
+    }
+
+    p_FmPcdCcTree->numOfEntries = (uint8_t)k;
+    p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
+    p_FmPcdCcTree->ccTreeBaseAddr =
+        PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
+                                      (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
+                                      FM_PCD_CC_AD_TABLE_ALIGN));
+
+    if(!p_FmPcdCcTree->ccTreeBaseAddr)
+    {
+        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    IOMemSet32(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
+    j = 0;
+    for(i = 0; i < numOfEntries; i++)
+    {
+        NextStepAd(p_CcTreeTmp,&params[i].nextEngineParams,p_FmPcd);
+        p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        memcpy(&p_FmPcdCcTree->nextEngineAndRequiredAction[i], &params[i], sizeof(t_FmPcdCcNextEngineAndRecuiredActionParams));
+        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        {
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode;
+            if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            {
+                memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcTree;
+                ccNodeInfo.index = 1;
+                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccTreeIdLst, &ccNodeInfo);
+                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, TRUE);
+            }
+            else
+            {
+                p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,(t_Handle)p_FmPcdCcTree);
+                ASSERT_COND(p_CcInformation);
+                p_CcInformation->index++;
+            }
+        }
+    }
+
+    FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
+    p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
+    for(i = 0; i < p_FmPcdCcTree->numOfEntries ; i++)
+    {
+        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        {
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode;
+
+            if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
+        }
+    }
+
+    for(i = 0; i < numOfEntries; i++)
+    {
+        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].requiredAction)
+        {
+            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->nextEngineAndRequiredAction[i].requiredAction, &p_FmPcdCcTree->nextEngineAndRequiredAction[i], p_CcTreeTmp,1, p_FmPcdCcTree);
+            if(err)
+            {
+                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        }
+    }
+
+    return p_FmPcdCcTree;
+}
+
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcTree               *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    int                         i= 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+
+    FmPcdDecNetEnvOwners(h_FmPcd, p_CcTree->netEnvId);
+
+    if(p_CcTree->owners)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
+
+    for(i = 0; i <p_CcTree->numOfEntries; i++)
+    {
+        if(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            UpdateNodeOwner(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+    }
+
+#ifdef FM_PCD_CC_MANIP
+    for(i = 0; i < p_CcTree->numOfEntries; i++)
+    {
+        if(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
+            FmPcdManipUpdateOwner(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    DeleteTree(p_CcTree, p_FmPcd);
+    return E_OK;
+}
+
+t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
+    t_FmPcdCcNode       *p_FmPcdCcNode, *p_FmPcdCcNextNode;
+    t_Error             err = E_OK;
+    int                 tmp, size;
+    bool                glblMask = FALSE;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Handle            p_KeysMatchTblTmp;
+    t_Handle            p_AdTableTmp;
+    bool                fullField = FALSE;
+    ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
+    bool                isKeyTblAlloc, fromIc = FALSE;
+    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+
+    if (!p_CcNodeParam->keysParams.keySize ||
+        !p_CcNodeParam->keysParams.numOfKeys)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("At least one key of keySize > 0 must be defined."));
+        return NULL;
+    }
+
+    p_FmPcdCcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_FmPcdCcNode)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+
+    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    memset(p_FmPcdCcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+
+    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+
+    p_FmPcdCcNode->h_FmPcd = h_FmPcd;
+
+    INIT_LIST(&p_FmPcdCcNode->ccPrevNodesLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreeIdLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreesLst);
+
+    if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
+        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
+        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
+        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
+    {
+            err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, &isKeyTblAlloc);
+            glblMask = FALSE;
+
+    }
+    else if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
+        ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
+           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
+           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
+    {
+        if((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
+            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+            return NULL;
+        }
+
+        icCode = IcDefineCode(p_CcNodeParam);
+        fromIc = TRUE;
+        if(icCode == CC_PRIVATE_INFO_NONE)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+            return NULL;
+        }
+
+        if((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) || (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+        {
+            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, &isKeyTblAlloc);
+
+            glblMask = TRUE;
+        }
+        else
+        {
+            err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, &isKeyTblAlloc);
+            if(p_FmPcdCcNode->glblMaskSize)
+                glblMask = TRUE;
+        }
+    }
+    else
+    {
+        err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, &isKeyTblAlloc);
+        if(p_FmPcdCcNode->glblMaskSize)
+            glblMask = TRUE;
+    }
+
+    if(err)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    switch(p_CcNodeParam->extractCcParams.type)
+    {
+        case(e_FM_PCD_EXTRACT_BY_HDR):
+            switch(p_CcNodeParam->extractCcParams.extractByHdr.type)
+            {
+                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
+                    fullField = TRUE;
+                    if((p_FmPcdCcNode->parseCode != CC_PC_FF_TCI1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_TCI2) &&
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) &&
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
+                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
+                       glblMask)
+                    {
+                        glblMask = FALSE;
+                        p_FmPcdCcNode->glblMaskSize = 4;
+                        p_FmPcdCcNode->lclMask = TRUE;
+                    }
+                    break;
+                case(e_FM_PCD_EXTRACT_FROM_HDR):
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                                                p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
+                        break;
+                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
+                                                    p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
+                                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
+                        break;
+                default:
+                    REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    return NULL;
+            }
+            break;
+        case(e_FM_PCD_EXTRACT_NON_HDR):
+            /* get the field code for the generic extract */
+            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
+
+            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            {
+                if((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 64)
+                {
+                     DeleteNode(p_FmPcdCcNode);
+                     REPORT_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
+                     return NULL;
+                }
+            }
+            if((p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_GMASK) || (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            {
+                p_FmPcdCcNode->offset +=  p_FmPcdCcNode->prsArrayOffset;
+                p_FmPcdCcNode->prsArrayOffset = 0;
+            }
+                break;
+
+       default:
+            DeleteNode(p_FmPcdCcNode);
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return NULL;
+    }
+
+    if(p_FmPcdCcNode->parseCode == CC_PC_ILLEGAL)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("illeagl extraction type"));
+        return NULL;
+    }
+
+    if((p_FmPcdCcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
+        return NULL;
+    }
+
+    if(p_CcNodeParam->keysParams.keySize != p_FmPcdCcNode->sizeOfExtraction)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        return NULL;
+    }
+
+
+    p_FmPcdCcNode->userSizeOfExtraction = p_FmPcdCcNode->sizeOfExtraction;
+
+    if(!glblMask)
+        memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
+
+#ifdef FM_PCD_CC_MANIP
+    err = CheckAndSetManipParamsWithCcNodeParams(p_FmPcdCcNode);
+    if(err != E_OK)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        return NULL;
+    }
+#endif /* FM_PCD_CC_MANIP */
+
+    GetCcExtractKeySize(p_FmPcdCcNode->sizeOfExtraction, &p_FmPcdCcNode->ccKeySizeAccExtraction);
+
+    if(p_FmPcdCcNode->lclMask)
+        size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    else
+        size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+
+    if(isKeyTblAlloc)
+    {
+        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
+                                         (uint32_t)(size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1)),
+                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        if(!p_FmPcdCcNode->h_KeysMatchTable)
+        {
+            DeleteNode(p_FmPcdCcNode);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+            return NULL;
+        }
+        IOMemSet32((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
+    }
+
+    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
+                                     (uint32_t)( (p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_FmPcdCcNode->h_AdTable)
+    {
+        DeleteNode(p_FmPcdCcNode);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
+        return NULL;
+    }
+    IOMemSet32((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_KeysMatchTblTmp    = p_FmPcdCcNode->h_KeysMatchTable;
+    p_AdTableTmp         = p_FmPcdCcNode->h_AdTable;
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if(p_KeysMatchTblTmp)
+        {
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
+
+            if(p_FmPcdCcNode->lclMask && p_KeyParams->p_Mask)
+                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
+            else if(p_FmPcdCcNode->lclMask)
+                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->sizeOfExtraction);
+            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, size * sizeof(uint8_t));
+        }
+        NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+
+        p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    }
+    NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+
+    if(fullField == TRUE)
+        p_FmPcdCcNode->sizeOfExtraction = 0;
+
+
+    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys + 1; tmp++)
+    {
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        {
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.params.ccParams.h_CcNode;
+
+            if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            {
+                memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcNode;
+                ccNodeInfo.index = 1;
+                EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst, &ccNodeInfo);
+                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, TRUE);
+            }
+            else
+            {
+                p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,(t_Handle)p_FmPcdCcNode);
+                ASSERT_COND(p_CcInformation);
+                p_CcInformation->index++;
+            }
+        }
+
+    }
+
+    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys + 1; tmp++)
+    {
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        {
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.params.ccParams.h_CcNode;
+
+            if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+                UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
+        }
+    }
+
+    p_AdTableTmp   = p_FmPcdCcNode->h_AdTable;
+    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction)
+        {
+
+             err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+        }
+    }
+    if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction)
+        FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
+
+
+    return p_FmPcdCcNode;
+}
+
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
+{
+    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    int i = 0;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+
+    UNUSED(h_FmPcd);
+    if(!p_CcNode)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID is not initialized"));
+
+    if(p_CcNode->owners)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
+
+   for(i = 0; i < p_CcNode->numOfKeys; i++)
+   {
+        if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            UpdateNodeOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+
+    }
+    if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        UpdateNodeOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+
+#ifdef FM_PCD_CC_MANIP
+    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    {
+        if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
+            FmPcdManipUpdateOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
+    }
+    if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
+        FmPcdManipUpdateOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
+#endif /* FM_PCD_CC_MANIP */
+
+   DeleteNode(p_CcNode);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
+}
+
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
+}
+
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeMissNextEngine(p_FmPcd->h_Hc, h_CcNode, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_AdOfTypeResult    *p_AdResult = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_VALUE(h_CcNode, E_INVALID_HANDLE, 0);
+#ifdef DISABLE_SANITY_CHECKS
+UNUSED(h_FmPcd);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    if (keyIndex >= p_FmPcdCcNode->numOfKeys)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE,
+                     ("keyIndex > numOfKeys defined for this node"));
+        return 0;
+    }
+
+    p_AdResult = PTR_MOVE(p_FmPcdCcNode->h_AdTable, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE);
+    ASSERT_COND(p_AdResult);
+
+    if (p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE,
+                     ("statistics updated only for entries where next engine not CC"));
+        return 0;
+    }
+
+    if(((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_DONE) &&
+        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.enqueueParams.statisticsEn) ||
+        ((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_KG) &&
+        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.kgParams.statisticsEn) ||
+        ((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_PLCR) &&
+        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.plcrParams.statisticsEn))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE,
+                     ("statistics wasn't enable"));
+        return 0;
+    }
+
+    return  GET_UINT32(p_AdResult->res);
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
new file mode 100644
index 0000000..76e12dd
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -0,0 +1,319 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_cc.h
+
+ @Description   FM PCD CC ...
+*//***************************************************************************/
+#ifndef __FM_CC_H
+#define __FM_CC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_pcd.h"
+
+
+/***********************************************************************/
+/*          Coarse classification defines                              */
+/***********************************************************************/
+
+#define CC_PC_FF_MACDST                     0x00
+#define CC_PC_FF_MACSRC                     0x01
+#define CC_PC_FF_ETYPE                      0x02
+
+#define CC_PC_FF_TCI1                       0x03
+#define CC_PC_FF_TCI2                       0x04
+
+#define CC_PC_FF_MPLS1                      0x06
+#define CC_PC_FF_MPLS_LAST                  0x07
+
+#define CC_PC_FF_IPV4DST1                   0x08
+#define CC_PC_FF_IPV4DST2                   0x16
+#define CC_PC_FF_IPV4IPTOS_TC1              0x09
+#define CC_PC_FF_IPV4IPTOS_TC2              0x17
+#define CC_PC_FF_IPV4PTYPE1                 0x0A
+#define CC_PC_FF_IPV4PTYPE2                 0x18
+#define CC_PC_FF_IPV4SRC1                   0x0b
+#define CC_PC_FF_IPV4SRC2                   0x19
+#define CC_PC_FF_IPV4SRC1_IPV4DST1          0x0c
+#define CC_PC_FF_IPV4SRC2_IPV4DST2          0x1a
+#define CC_PC_FF_IPV4TTL                    0x29
+
+
+#define CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1    0x0d /*TODO - CLASS - what is it? TOS*/
+#define CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2    0x1b
+#define CC_PC_FF_IPV6PTYPE1                 0x0e
+#define CC_PC_FF_IPV6PTYPE2                 0x1c
+#define CC_PC_FF_IPV6DST1                   0x0f
+#define CC_PC_FF_IPV6DST2                   0x1d
+#define CC_PC_FF_IPV6SRC1                   0x10
+#define CC_PC_FF_IPV6SRC2                   0x1e
+#define CC_PC_FF_IPV6HOP_LIMIT              0x2a
+#define CC_PC_FF_GREPTYPE                   0x11
+
+#define CC_PC_FF_MINENCAP_PTYPE             0x12
+#define CC_PC_FF_MINENCAP_IPDST             0x13
+#define CC_PC_FF_MINENCAP_IPSRC             0x14
+#define CC_PC_FF_MINENCAP_IPSRC_IPDST       0x15
+
+#define CC_PC_FF_L4PSRC                     0x1f
+#define CC_PC_FF_L4PDST                     0x20
+#define CC_PC_FF_L4PSRC_L4PDST              0x21
+
+#define CC_PC_FF_PPPPID                     0x05
+
+#define CC_PC_PR_SHIM1                      0x22
+#define CC_PC_PR_SHIM2                      0x23
+
+#define CC_PC_GENERIC_WITHOUT_MASK          0x27
+#define CC_PC_GENERIC_WITH_MASK             0x28
+#define CC_PC_GENERIC_IC_GMASK              0x2B
+#define CC_PC_GENERIC_IC_HASH_INDEXED       0x2C
+
+#define CC_PR_OFFSET                        0x25
+#define CC_PR_WITHOUT_OFFSET                0x26
+
+#define CC_PC_PR_ETH_OFFSET                 19
+#define CC_PC_PR_USER_DEFINED_SHIM1_OFFSET  16
+#define CC_PC_PR_USER_DEFINED_SHIM2_OFFSET  17
+#define CC_PC_PR_USER_LLC_SNAP_OFFSET       20
+#define CC_PC_PR_VLAN1_OFFSET               21
+#define CC_PC_PR_VLAN2_OFFSET               22
+#define CC_PC_PR_PPPOE_OFFSET               24
+#define CC_PC_PR_MPLS1_OFFSET               25
+#define CC_PC_PR_MPLS_LAST_OFFSET           26
+#define CC_PC_PR_IP1_OFFSET                 27
+#define CC_PC_PR_IP_LAST_OFFSET             28
+#define CC_PC_PR_MINENC_OFFSET              28
+#define CC_PC_PR_L4_OFFSET                  30
+#define CC_PC_PR_GRE_OFFSET                 29
+#define CC_PC_PR_ETYPE_LAST_OFFSET          23
+#define CC_PC_PR_NEXT_HEADER_OFFSET         31
+
+#define CC_PC_ILLEGAL                       0xff
+#define CC_SIZE_ILLEGAL                     0
+
+#define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
+#define FM_PCD_CC_AD_TABLE_ALIGN            256
+#define FM_PCD_CC_AD_ENTRY_SIZE             16
+#define FM_PCD_CC_NUM_OF_KEYS               255
+
+#define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
+#define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
+#define FM_PCD_AD_RESULT_PLCR_DIS           0x20000000
+#define FM_PCD_AD_RESULT_EXTENDED_MODE      0x80000000
+#define FM_PCD_AD_RESULT_NADEN              0x20000000
+#define FM_PCD_AD_RESULT_STATISTICS_EN      0x40000000
+
+
+#define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
+#define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
+
+#define FM_PCD_AD_TYPE_MASK                 0xc0000000
+#define FM_PCD_AD_OPCODE_MASK               0x0000000f
+
+#define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+
+#define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
+#define CC_GLBL_MASK_SIZE                   4
+
+typedef uint32_t ccPrivateInfo_t; /**< private info of CC: */
+
+#define CC_PRIVATE_INFO_NONE                       0
+#define CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP       0x80000000
+#define CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH        0x40000000
+#define CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH         0x20000000
+#define CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP   0x10000000
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+typedef _Packed struct {
+    volatile uint32_t fqid;
+    volatile uint32_t plcrProfile;
+    volatile uint32_t nia;
+    volatile uint32_t  res;
+} _PackedType t_AdOfTypeResult;
+
+typedef _Packed struct {
+    volatile uint32_t ccAdBase;
+    volatile uint32_t matchTblPtr;
+    volatile uint32_t pcAndOffsets;
+    volatile uint32_t gmask;
+} _PackedType t_AdOfTypeContLookup;
+
+typedef _Packed union {
+    volatile t_AdOfTypeResult        adResult;
+    volatile t_AdOfTypeContLookup    adContLookup;
+} _PackedType t_Ad;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/***********************************************************************/
+/*  Driver's internal structures                                        */
+/***********************************************************************/
+
+typedef enum e_ModifyState {
+    e_MODIFY_STATE_ADD = 0,
+    e_MODIFY_STATE_REMOVE,
+    e_MODIFY_STATE_CHANGE
+} e_ModifyState;
+
+typedef struct {
+    t_FmPcdCcNextEngineParams   nextEngineParams;
+    uint32_t                    requiredAction;
+    uint32_t                    shadowAction;
+} t_FmPcdCcNextEngineAndRecuiredActionParams;
+
+typedef struct {
+    t_Handle         p_Ad;
+    e_FmPcdEngine    fmPcdEngine;
+    bool             adAllocated;
+    bool             isTree;
+
+    uint32_t    myInfo;
+    t_List      *h_CcNextNodesLst;
+    t_Handle    h_AdditionalInfo;
+    t_Handle    h_Node;
+} t_FmPcdModifyCcAdditionalParams;
+
+typedef struct {
+    t_Handle p_AdTableNew;
+    t_Handle p_KeysMatchTableNew;
+    t_Handle p_AdTableOld;
+    t_Handle p_KeysMatchTableOld;
+    uint16_t numOfKeys;
+    t_Handle h_CurrentNode;
+    uint16_t keyIndex;
+    t_Handle h_NodeForAdd;
+    t_Handle h_NodeForRmv;
+    t_Handle h_ManipForRmv;
+    bool     tree;
+
+    t_FmPcdCcNextEngineAndRecuiredActionParams nextEngineAndRequiredAction[256];
+} t_FmPcdModifyCcKeyAdditionalParams;
+
+typedef struct {
+    t_Handle h_Manip;
+    t_Handle h_CcNode;
+} t_CcNextEngineInfo;
+
+typedef struct {
+    uint16_t    numOfKeys;
+    bool        glblMaskUpdated;
+    t_Handle    p_GlblMask;
+    bool        lclMask;
+    uint8_t     parseCode;
+    uint8_t     offset;
+    uint8_t     prsArrayOffset;
+    bool        ctrlFlow;
+    //uint16_t    nodeId;
+    uint8_t     owners;
+
+    uint8_t     ccKeySizeAccExtraction;
+    uint8_t     sizeOfExtraction;
+    uint8_t     glblMaskSize;
+
+    t_Handle    h_KeysMatchTable;
+    t_Handle    h_AdTable;
+
+    /*t_List      ccNextNodesLst;*/
+    t_List      ccPrevNodesLst;
+
+    t_List      ccTreeIdLst;
+    t_List      ccTreesLst;
+
+    /*t_List      manipLst;*/
+    t_Handle    h_FmPcd;
+    uint32_t    shadowAction;
+    /*uint32_t    requiredAction;*/
+    bool        modifiedState;
+    uint8_t     userSizeOfExtraction;
+
+    t_FmPcdCcNextEngineAndRecuiredActionParams nextEngineAndRequiredAction[256];
+} t_FmPcdCcNode;
+
+typedef struct {
+    t_FmPcdCcNode       *p_FmPcdCcNode;
+    bool                occupied;
+    uint8_t             owners;
+    volatile bool       lock;
+} t_FmPcdCcNodeArray;
+
+typedef struct {
+    uint8_t             numOfEntriesInGroup;
+    uint32_t            totalBitsMask;
+    uint8_t             baseGroupEntry;
+} t_FmPcdCcGroupParam;
+
+typedef struct {
+    uint8_t             netEnvId;
+    uintptr_t           ccTreeBaseAddr;
+    uint8_t             numOfGrps;
+    t_FmPcdCcGroupParam fmPcdGroupParam[8];
+    //t_List              ccNextNodesLst;
+    //t_List              manipLst;
+    t_List              fmPortsLst;
+    //uint8_t             treeId;
+    volatile bool       lock;
+    uint8_t             numOfEntries;
+    uint8_t             owners;
+    t_Handle            *fmPcdCcSavedManipParams[256];
+    bool                modifiedState;
+    uint32_t            requiredAction;
+    t_FmPcdCcNextEngineAndRecuiredActionParams nextEngineAndRequiredAction[FM_PCD_MAX_NUM_OF_KEYS];
+} t_FmPcdCcTree;
+
+typedef struct {
+    t_FmPcdCcTree       *p_FmPcdCcTree;
+    bool                occupied;
+    uint8_t             owners;
+    volatile bool       lock;
+} t_FmPcdCcTreeArray;
+
+
+bool FmPcdManipIsManipNode(t_Handle h_Ad);
+
+
+#endif /* __FM_CC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
new file mode 100644
index 0000000..e0419e3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -0,0 +1,3252 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_kg.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_port_ext.h"
+
+#include "fm_common.h"
+#include "fm_pcd.h"
+#include "fm_hc.h"
+
+#include "fm_pcd_ipc.h"
+
+
+static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
+{
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
+    /* Wait for GO to be idle and read error */
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
+    if (kgar & FM_PCD_KG_KGAR_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
+    return E_OK;
+}
+
+static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDefaults[], uint8_t numOfSwDefaults, uint8_t code)
+{
+    int i;
+
+    switch(code)
+    {
+        case( KG_SCH_GEN_PARSE_RESULT_N_FQID):
+        case( KG_SCH_GEN_DEFAULT):
+        case( KG_SCH_GEN_NEXTHDR):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+            ASSERT_COND(FALSE);
+        case( KG_SCH_GEN_SHIM1):
+        case( KG_SCH_GEN_SHIM2):
+        case( KG_SCH_GEN_IP_PID_NO_V):
+        case( KG_SCH_GEN_ETH_NO_V):
+        case( KG_SCH_GEN_SNAP_NO_V):
+        case( KG_SCH_GEN_VLAN1_NO_V):
+        case( KG_SCH_GEN_VLAN2_NO_V):
+        case( KG_SCH_GEN_ETH_TYPE_NO_V):
+        case( KG_SCH_GEN_PPP_NO_V):
+        case( KG_SCH_GEN_MPLS1_NO_V):
+        case( KG_SCH_GEN_MPLS_LAST_NO_V):
+        case( KG_SCH_GEN_L3_NO_V):
+        case( KG_SCH_GEN_IP2_NO_V):
+        case( KG_SCH_GEN_GRE_NO_V):
+        case( KG_SCH_GEN_L4_NO_V):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+                    return swDefaults[i].dfltSelect;
+
+        case( KG_SCH_GEN_START_OF_FRM):
+        case( KG_SCH_GEN_ETH):
+        case( KG_SCH_GEN_SNAP):
+        case( KG_SCH_GEN_VLAN1):
+        case( KG_SCH_GEN_VLAN2):
+        case( KG_SCH_GEN_ETH_TYPE):
+        case( KG_SCH_GEN_PPP):
+        case( KG_SCH_GEN_MPLS1):
+        case( KG_SCH_GEN_MPLS2):
+        case( KG_SCH_GEN_MPLS3):
+        case( KG_SCH_GEN_MPLS_LAST):
+        case( KG_SCH_GEN_IPV4):
+        case( KG_SCH_GEN_IPV6):
+        case( KG_SCH_GEN_IPV4_TUNNELED):
+        case( KG_SCH_GEN_IPV6_TUNNELED):
+        case( KG_SCH_GEN_MIN_ENCAP):
+        case( KG_SCH_GEN_GRE):
+        case( KG_SCH_GEN_TCP):
+        case( KG_SCH_GEN_UDP):
+        case( KG_SCH_GEN_IPSEC_AH):
+        case( KG_SCH_GEN_SCTP):
+        case( KG_SCH_GEN_DCCP):
+        case( KG_SCH_GEN_IPSEC_ESP):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+        default:
+            return e_FM_PCD_KG_DFLT_ILLEGAL;
+    }
+}
+
+static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
+{
+    *p_Offset = 0;
+
+    switch(src)
+    {
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+            return KG_SCH_GEN_START_OF_FRM;
+        case(e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
+            return KG_SCH_GEN_DEFAULT;
+        case(e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
+            return KG_SCH_GEN_PARSE_RESULT_N_FQID;
+        case(e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
+            *p_Offset = 32;
+            return KG_SCH_GEN_PARSE_RESULT_N_FQID;
+        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+            return KG_SCH_GEN_NEXTHDR;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+            return 0;
+    }
+}
+
+static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
+{
+    if(!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP;
+            case(HEADER_TYPE_MPLS):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_MPLS2;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                    return KG_SCH_GEN_MPLS3;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV4;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV4_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
+                return 0;
+            case(HEADER_TYPE_IPv6):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV6;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV6_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
+                return 0;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE;
+            case(HEADER_TYPE_TCP):
+                return KG_SCH_GEN_TCP;
+            case(HEADER_TYPE_UDP):
+                return KG_SCH_GEN_UDP;
+            case(HEADER_TYPE_IPSEC_AH):
+                return KG_SCH_GEN_IPSEC_AH;
+            case(HEADER_TYPE_IPSEC_ESP):
+                return KG_SCH_GEN_IPSEC_ESP;
+            case(HEADER_TYPE_SCTP):
+                return KG_SCH_GEN_SCTP;
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_DCCP;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+    else
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH_NO_V;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP_NO_V;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP_NO_V;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST_NO_V;
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
+                else
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_L3_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IP2_NO_V;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+            case(HEADER_TYPE_MINENCAP):
+                return KG_SCH_GEN_IP2_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_L3):
+                return KG_SCH_GEN_L3_NO_V;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE_NO_V;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_L4_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                return KG_SCH_GEN_SHIM1;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                return KG_SCH_GEN_SHIM2;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+}
+static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
+{
+    if (!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                    case(NET_HEADER_FIELD_VLAN_TCI):
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            return KG_SCH_GEN_VLAN1;
+                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            return KG_SCH_GEN_VLAN2;
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                        return 0;
+                }
+            case(HEADER_TYPE_MPLS):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+            case(HEADER_TYPE_GRE):
+            case(HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_USER_DEFINED_L3):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_USER_DEFINED_L4):
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                return 0;
+        }
+        else
+            switch(hdr)
+            {
+                case(HEADER_TYPE_NONE):
+                    ASSERT_COND(FALSE);
+                case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE_NO_V;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+                case(HEADER_TYPE_VLAN):
+                    switch(field.vlan)
+                    {
+                        case(NET_HEADER_FIELD_VLAN_TCI) :
+                            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                                return KG_SCH_GEN_VLAN1_NO_V;
+                            if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                                return KG_SCH_GEN_VLAN2_NO_V;
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                            return 0;
+                    }
+                case(HEADER_TYPE_IPv4):
+                    switch(field.ipv4)
+                    {
+                        case(NET_HEADER_FIELD_IPv4_PROTO):
+                            return KG_SCH_GEN_IP_PID_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
+                    }
+                case(HEADER_TYPE_IPv6):
+                   switch(field.ipv6)
+                    {
+                        case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                            return KG_SCH_GEN_IP_PID_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
+                    }
+                case(HEADER_TYPE_MPLS):
+                case(HEADER_TYPE_LLC_SNAP):
+                case(HEADER_TYPE_PPPoE):
+                case(HEADER_TYPE_GRE):
+                case(HEADER_TYPE_MINENCAP):
+                case(HEADER_TYPE_USER_DEFINED_L3):
+                case(HEADER_TYPE_TCP):
+                case(HEADER_TYPE_UDP):
+                case(HEADER_TYPE_IPSEC_AH):
+                case(HEADER_TYPE_IPSEC_ESP):
+                case(HEADER_TYPE_SCTP):
+                case(HEADER_TYPE_DCCP):
+                case(HEADER_TYPE_USER_DEFINED_L4):
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                    return 0;
+            }
+}
+
+static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    return KG_SCH_KN_MACDST;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    return KG_SCH_KN_MACSRC;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_LLC_SNAP):
+            switch(field.llcSnap)
+            {
+                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_TCI2;
+                    else
+                    {
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                    }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_MPLS2;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return KG_SCH_KN_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return KG_SCH_KN_IPSRC2;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return KG_SCH_KN_IPDST2;
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return KG_SCH_KN_PTYPE2;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                case(NET_HEADER_FIELD_TCP_FLAGS):
+                    return KG_SCH_KN_TFLG;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_IPSEC_AH):
+            switch(field.ipsecAh)
+            {
+                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                case(NET_HEADER_FIELD_IPSEC_AH_NH):
+                    return KG_SCH_KN_IPSEC_NH;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_IPSEC_ESP):
+            switch(field.ipsecEsp)
+            {
+                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_SCTP):
+            switch(field.sctp)
+            {
+                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_SCTP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_DCCP):
+            switch(field.dccp)
+            {
+                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_DCCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return KG_SCH_KN_PPPID;
+                case(NET_HEADER_FIELD_PPPoE_SID):
+                    return KG_SCH_KN_PPPSID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return 0;
+    }
+}
+
+
+static uint8_t GetKnownFieldId(uint32_t bitMask)
+{
+    uint8_t cnt = 0;
+
+    while (bitMask)
+        if(bitMask & 0x80000000)
+            break;
+        else
+        {
+            cnt++;
+            bitMask <<= 1;
+        }
+    return cnt;
+
+}
+
+static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
+{
+    uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
+
+    /* bitOffset 1-7 --> mask 0x1-0x7F */
+    if(bitOffset<8)
+    {
+        mask = 0;
+        for(i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
+            mask |= walking1Mask;
+    }
+    else
+    {
+       mask = 0xFF;
+       numOfOnesToClear = 0;
+       if(fqid && bitOffset>24)
+           /* bitOffset 25-31 --> mask 0xFE-0x80 */
+           numOfOnesToClear = (uint8_t)(bitOffset-24);
+       else
+          /* bitOffset 9-15 --> mask 0xFE-0x80 */
+          if(!fqid && bitOffset>8)
+               numOfOnesToClear = (uint8_t)(bitOffset-8);
+       for(i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
+           mask &= ~walking1Mask;
+       /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
+    }
+    return mask;
+}
+
+
+t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err = E_OK;
+    uint32_t                        oredVectors = 0;
+    uint32_t                        intFlags;
+    int                             i, j;
+
+    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    /* find a new clsPlan group */
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if(i== FM_MAX_NUM_OF_PORTS)
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
+    }
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+    p_Grp->clsPlanGrpId = (uint8_t)i;
+
+    if(p_Grp->numOfOptions == 0)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+
+    if (!TRY_LOCK(NULL, &p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return ERROR_CODE(E_BUSY);
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
+    p_ClsPlanGrp->owners = 0;
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
+    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<p_Grp->numOfOptions);
+    /* a minimal group of 8 is required */
+    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        }
+
+    }
+    else
+    {
+        uint32_t                    replyLength;
+        t_FmPcdIpcMsg               *p_msg = NULL;
+        t_FmPcdIpcReply             *p_reply = NULL;
+
+        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+        memset(&kgAlloc, 0, sizeof(kgAlloc));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_ALLOC_KG_CLSPLAN;
+        memcpy(p_msg->msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) + sizeof(kgAlloc),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        if (err != E_OK)
+        {
+            XX_Free(p_reply);
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
+        {
+            XX_Free(p_reply);
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        }
+
+        err = (t_Error)p_reply->error;
+        if (err != E_OK)
+        {
+            XX_Free(p_reply);
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+
+        p_ClsPlanGrp->baseEntry = *(uint8_t*)(p_reply->replyBody);
+        XX_Free(p_reply);
+    }
+
+    /* build classification plan entries parameters */
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+
+    oredVectors = 0;
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+        oredVectors |= p_Grp->optVectors[i];
+        /* save an array of used options - the indexes represent the power of 2 index */
+        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+    }
+    /* set the classification plan relevant entries so that all bits
+     * relevant to the list of options is cleared
+     */
+    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        p_ClsPlanSet->vectors[j] = ~oredVectors;
+
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+       /* option i got the place 2^i in the clsPlan array. all entries that
+         * have bit i set, should have the vector bit cleared. So each option
+         * has one location that it is exclusive (1,2,4,8...) and represent the
+         * presence of that option only, and other locations that represent a
+         * combination of options.
+         * e.g:
+         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
+         * now represents a frame with ethernet-BC header - so the bit
+         * representing ethernet-BC should be set and all other option bits
+         * should be cleared.
+         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
+         * vector[1] set, but they also have other bits set:
+         * 3=1+2, options 0 and 1
+         * 6=2+4, options 1 and 2
+         * 7=1+2+4, options 0,1,and 2
+         * 10=2+8, options 1 and 3
+         * etc.
+         * */
+
+        /* now for each option (i), we set their bits in all entries (j)
+         * that contain bit 2^i.
+         */
+        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        {
+            if(j & (1<<i))
+                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+        }
+    }
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
+
+    return E_OK;
+}
+
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err;
+    uint32_t                        replyLength;
+    t_FmPcdIpcMsg                   *p_msg = NULL;
+    t_FmPcdIpcReply                 *p_reply = NULL;
+
+
+    /* check that no port is bound to this clsPlan */
+    if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+        return;
+    }
+
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+
+    /* free blocks */
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        err = KgFreeClsPlanEntries(h_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
+                                    p_FmPcd->guestId,
+                                    p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+        if(err)
+        {
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return;
+        }
+    }
+    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    {
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+            return;
+        }
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+            return;
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_FREE_KG_CLSPLAN;
+        memcpy(p_msg->msgBody, &kgAlloc, sizeof(kgAlloc));
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) + sizeof(kgAlloc),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        if (err != E_OK)
+        {
+            XX_Free(p_reply);
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
+        }
+
+        err = (t_Error)p_reply->error;
+        XX_Free(p_reply);
+
+        if (replyLength != sizeof(uint32_t))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return;
+        }
+        if(err != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
+            return;
+        }
+    }
+
+    if(grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+}
+
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint8_t                 swPortIndex = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+        if(add)
+        {
+            if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
+            if(p_Scheme->nextRelativePlcrProfile)
+            {
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
+            }
+            if(!p_BindPort->useClsPlan)
+            {
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if(tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+    }
+
+    *p_SpReg = schemesPerPortVector;
+
+    return E_OK;
+}
+
+void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        p_Scheme->owners++;
+    }
+}
+
+void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        ASSERT_COND(p_Scheme->owners);
+        p_Scheme->owners--;
+    }
+}
+
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
+    t_Error                 err = E_OK;
+
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    intFlags = FmPcdLock(p_FmPcd);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+
+    if(add)
+        tmpKgpeSp |= spReg;
+    else /* clear */
+        tmpKgpeSp &= ~spReg;
+
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    return E_OK;
+}
+
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg, intFlags;
+    t_Error                 err;
+
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    intFlags = FmPcdLock(p_FmPcd);
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+
+    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return err;
+}
+
+static void FmPcdKgUnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
+{
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+}
+
+static t_Error KgBindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    uint32_t                tmpKgpeCpp = 0;
+
+    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
+}
+
+t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err = E_OK;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
+}
+
+bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            intFlags;
+    uint8_t             i,j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
+        {
+            p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = guestId;
+            p_SchemesIds[j] = i;
+            j++;
+        }
+    }
+
+    if (j != numOfSchemes)
+    {
+        /* roll back */
+        for(j--; j; j--)
+        {
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].allocated = FALSE;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
+            p_SchemesIds[j] = 0;
+        }
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+
+t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            intFlags;
+    uint8_t             i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    for(i=0;i<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        {
+            FmPcdUnlock(p_FmPcd, intFlags);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+        }
+        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        {
+            FmPcdUnlock(p_FmPcd, intFlags);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
+    }
+
+    FmPcdUnlock(p_FmPcd, intFlags);
+    return E_OK;
+}
+
+t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    if(!numOfClsPlanEntries)
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return E_OK;
+    }
+
+    if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+    }
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
+    {
+        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        {
+            blocksFound++;
+            i++;
+            if(blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
+
+    if(blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
+        for(j = first; j<first + numOfBlocks; j++)
+        {
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
+        }
+        FmPcdUnlock(p_FmPcd, intFlags);
+
+        return E_OK;
+    }
+    else
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+    }
+}
+
+t_Error  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
+    uint8_t     numOfBlocks;
+    uint8_t     i, baseBlock;
+
+    UNUSED( guestId);
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
+
+    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
+    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+    return E_OK;
+}
+
+t_Error KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+
+    return E_OK;
+}
+
+t_Error KgDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+
+    return E_OK;
+}
+
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg=0, intFlags;
+    uint16_t                i, j;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+
+    intFlags = FmPcdLock(p_FmPcd);
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+
+        for(j=i;j<i+8;j++)
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+}
+
+static void PcdKgErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, schemeIndexes = 0,index = 0, mask = 0;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+
+    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
+    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
+
+    /* clear the forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, event & ~(event & mask));
+
+    event &= mask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+
+    if(event & FM_PCD_KG_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    {
+        if(schemeIndexes)
+        {
+            while(schemeIndexes)
+            {
+                if(schemeIndexes & 0x1)
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                schemeIndexes >>= 1;
+                index+=1;
+            }
+        }
+        else /* this should happen only when interrupt is forced. */
+            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
+    }
+}
+
+static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err = E_OK;
+    t_FmPcdIpcKgSchemesParams   kgAlloc;
+    uint32_t                    replyLength;
+    t_FmPcdIpcMsg               *p_msg = NULL;
+    t_FmPcdIpcReply             *p_reply = NULL;
+
+    ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
+
+    /* in GUEST_PARTITION, we use the IPC  */
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.guestId = p_FmPcd->guestId;
+
+    p_msg = XX_Malloc(sizeof(*p_msg));
+    if (!p_msg)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+    p_reply = XX_Malloc(sizeof(*p_reply));
+    if (!p_reply) {
+        XX_Free(p_msg);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+    }
+    memset(p_msg, 0, sizeof(*p_msg));
+    memset(p_reply, 0, sizeof(*p_reply));
+
+    p_msg->msgId = FM_PCD_ALLOC_KG_SCHEMES;
+    memcpy(p_msg->msgBody, &kgAlloc, sizeof(kgAlloc));
+    replyLength = sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t);
+
+    err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)p_msg,
+                                     sizeof(p_msg->msgId) + sizeof(kgAlloc),
+                                     (uint8_t*)p_reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL);
+    XX_Free(p_msg);
+    if (err != E_OK) {
+        XX_Free(p_reply);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t))) {
+        XX_Free(p_reply);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    }
+
+    memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(p_reply->replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
+
+    err = (t_Error)p_reply->error;
+    XX_Free(p_reply);
+
+    return err;
+}
+
+static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err = E_OK;
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    int                         i;
+    uint8_t                     hardwarePortId = 0;
+    uint32_t                    tmpReg;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+
+    /**********************KGEER******************/
+    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+    /**********************KGEER******************/
+
+    /**********************KGEEER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    {
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+    /**********************KGEEER******************/
+
+    /**********************KGFDOR******************/
+    WRITE_UINT32(p_Regs->kgfdor,0);
+    /**********************KGFDOR******************/
+
+    /**********************KGGDV0R******************/
+    WRITE_UINT32(p_Regs->kggdv0r,0);
+    /**********************KGGDV0R******************/
+
+    /**********************KGGDV1R******************/
+    WRITE_UINT32(p_Regs->kggdv1r,0);
+    /**********************KGGDV1R******************/
+
+    /**********************KGGCR******************/
+    WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    /**********************KGGCR******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+
+    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+
+        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* enable and enable all scheme interrupts */
+    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        err = FmPcdKgAllocSchemes(p_FmPcd,
+                                  p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                  p_FmPcd->guestId,
+                                  p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+
+/****************************************/
+/*  API routines                        */
+/****************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
+
+    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
+
+/* not needed
+    if(payloadOffset > 256)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
+*/
+
+    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
+
+    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
+
+    if(valueId == 0)
+        WRITE_UINT32(p_Regs->kggdv0r,value);
+    else
+        WRITE_UINT32(p_Regs->kggdv1r,value);
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0, j = 0;
+    uint8_t             hardwarePortId = 0;
+    uint32_t            tmpKgarReg, intFlags;
+    t_Error             err = E_OK;
+    t_FmPcdIpcMsg       *p_msg = NULL;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_KG_DUMP_REGS;
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)p_msg,
+                                 sizeof(p_msg->msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+        XX_Free(p_msg);
+        return err;
+    }
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+
+    DUMP_SUBTITLE(("\n"));
+    intFlags = FmPcdLock(p_FmPcd);
+    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    {
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+        }
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+    }
+    DUMP_SUBTITLE(("\n"));
+
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    {
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+
+        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdKg   *p_FmPcdKg;
+
+    UNUSED(p_FmPcd);
+    p_FmPcdKg = (t_FmPcdKg *) XX_Malloc(sizeof(t_FmPcdKg));
+    if (!p_FmPcdKg)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Keygen allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
+
+    if(FmIsMaster(p_FmPcd->h_Fm))
+    {
+        p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+    }
+
+    p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
+    if((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
+    {
+        p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+        DBG(INFO, ("numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"));
+    }
+
+    p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    return p_FmPcdKg;
+}
+
+t_Error KgInit(t_FmPcd *p_FmPcd)
+{
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+        return KgInitMaster(p_FmPcd);
+    else
+        return KgInitGuest(p_FmPcd);
+}
+
+t_Error KgFree(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdIpcKgSchemesParams       kgAlloc;
+    t_Error                         err = E_OK;
+    uint32_t                        replyLength;
+    t_FmPcdIpcMsg                   *p_msg = NULL;
+    t_FmPcdIpcReply                 *p_reply = NULL;
+
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
+
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+        return FmPcdKgFreeSchemes(p_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                    p_FmPcd->guestId,
+                                    p_FmPcd->p_FmPcdKg->schemesIds);
+
+    /* guest */
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.guestId = p_FmPcd->guestId;
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , (sizeof(uint8_t))*kgAlloc.numOfSchemes);
+
+    p_msg = XX_Malloc(sizeof(*p_msg));
+    if (!p_msg)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+    p_reply = XX_Malloc(sizeof(*p_reply));
+    if (!p_reply) {
+        XX_Free(p_msg);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+    }
+    memset(p_msg, 0, sizeof(*p_msg));
+    memset(p_reply, 0, sizeof(*p_reply));
+
+    p_msg->msgId = FM_PCD_FREE_KG_SCHEMES;
+    memcpy(p_msg->msgBody, &kgAlloc, sizeof(kgAlloc));
+    replyLength = sizeof(uint32_t);
+    err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)p_msg,
+                                     sizeof(p_msg->msgId) + sizeof(kgAlloc),
+                                     (uint8_t*)p_reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL);
+    XX_Free(p_msg);
+    if (err != E_OK) {
+        XX_Free(p_reply);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = (t_Error)p_reply->error;
+    XX_Free(p_reply);
+
+    if (replyLength != sizeof(uint32_t))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+    return err;
+}
+
+t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp)
+{
+    t_FmPcd                                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgInterModuleClsPlanGrpParams    grpParams, *p_GrpParams;
+    t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
+    t_FmPcdKgInterModuleClsPlanSet          *p_clsPlanSet;
+    t_Error                                 err;
+
+    memset(&grpParams, 0, sizeof(grpParams));
+    grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
+    p_GrpParams = &grpParams;
+
+    p_GrpParams->netEnvId = netEnvId;
+    err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
+    if(err)
+        RETURN_ERROR(MINOR,err,NO_MSG);
+    if(p_GrpParams->grpExists)
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+    else
+    {
+        p_clsPlanSet = XX_Malloc(sizeof(*p_clsPlanSet));
+        if (!p_clsPlanSet)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_clsPlanSet"));
+        err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_clsPlanSet);
+        if(err) {
+            XX_Free(p_clsPlanSet);
+            RETURN_ERROR(MINOR,err,NO_MSG);
+        }
+        *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+
+        if (p_FmPcd->h_Hc)
+        {
+            /* write clsPlan entries to memory */
+            err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_clsPlanSet);
+            if (err) {
+                XX_Free(p_clsPlanSet);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+        else
+            /* write clsPlan entries to memory */
+            KgSetClsPlan(p_FmPcd, p_clsPlanSet);
+            XX_Free(p_clsPlanSet);
+    }
+
+    /* mark if this is an empty classification group */
+    if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        *p_IsEmptyClsPlanGrp = TRUE;
+    else
+        *p_IsEmptyClsPlanGrp = FALSE;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
+
+    /* increment owners number */
+    p_ClsPlanGrp->owners++;
+
+    /* copy options array for port */
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
+
+    /* bind port to the new or existing group */
+    err = KgBindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+    t_FmPcdKgInterModuleClsPlanSet  *p_clsPlanSet;
+
+    FmPcdKgUnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
+
+    /* decrement owners number */
+    ASSERT_COND(p_ClsPlanGrp->owners);
+    p_ClsPlanGrp->owners--;
+
+    if(!p_ClsPlanGrp->owners)
+    {
+        if (p_FmPcd->h_Hc)
+            return FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
+        else
+        {
+            p_clsPlanSet = XX_Malloc(sizeof(*p_clsPlanSet));
+            if (!p_clsPlanSet)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_clsPlanSet"));
+            /* clear clsPlan entries in memory */
+            p_clsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
+            p_clsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
+            memset(p_clsPlanSet->vectors, 0, p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp*sizeof(uint32_t));
+            KgSetClsPlan(p_FmPcd, p_clsPlanSet);
+            XX_Free(p_clsPlanSet);
+
+            FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
+        }
+    }
+    return E_OK;
+}
+
+t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                            grpBits = 0;
+    uint8_t                             grpBase;
+    bool                                direct=TRUE, absolute=FALSE;
+    uint16_t                            profileId, numOfProfiles=0, relativeProfileId;
+    t_Error                             err = E_OK;
+    int                                 i = 0;
+    t_NetEnvParams                      netEnvParams;
+    uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
+    t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash = NULL;
+    uint8_t                             j, curr;
+    uint8_t                             id, shift=0, code=0, offset=0, size=0;
+    t_FmPcdExtractEntry                 *p_Extract = NULL;
+    t_FmPcdKgExtractedOrParams          *p_ExtractOr;
+    bool                                generic = FALSE;
+    t_KnownFieldsMasks                  bitMask;
+    e_FmPcdKgExtractDfltSelect          swDefault = (e_FmPcdKgExtractDfltSelect)0;
+    t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
+    uint8_t                             numOfSwDefaults = 0;
+    t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
+    uint8_t                             currGenId = 0, relativeSchemeId;
+
+    if(!p_Scheme->modify)
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+    else
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1));
+
+    memset(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId], 0, sizeof(t_FmPcdKgScheme));
+    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
+    memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+
+    /* by netEnv parameters, get match vector */
+    if(!p_Scheme->alwaysDirect)
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId =
+            (uint8_t)(PTR_TO_UINT(p_Scheme->netEnvParams.h_NetEnv)-1);
+        netEnvParams.netEnvId = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_Scheme->netEnvParams.numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, p_Scheme->netEnvParams.unitIds, (sizeof(uint8_t))*p_Scheme->netEnvParams.numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = netEnvParams.vector;
+    }
+    else
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = SCHEME_ALWAYS_DIRECT;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = ILLEGAL_NETENV;
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_INVALID)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
+
+    if(p_Scheme->bypassFqidGeneration)
+    {
+#ifdef FM_KG_NO_BYPASS_FQID_GEN
+        {
+            t_FmRevisionInfo    revInfo;
+
+            FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
+            if (revInfo.majorRev < 4)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
+        }
+#endif /* FM_KG_NO_BYPASS_FQID_GEN */
+        if(p_Scheme->baseFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
+    }
+    else
+        if(!p_Scheme->baseFqid)
+            DBG(WARNING, ("baseFqid is 0."));
+
+    if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
+    {
+        direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr = direct;
+        absolute = (bool)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
+        if(!direct && absolute)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
+
+        if(direct)
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+        }
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_CC)
+    {
+#ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
+        if((p_Scheme->kgNextEngineParams.cc.plcrNext) && (p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        {
+            t_FmRevisionInfo    revInfo;
+
+            FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
+            if (revInfo.majorRev < 4)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
+        }
+#endif /* FM_KG_NO_BYPASS_PLCR_PROFILE_GEN */
+
+        err = FmPcdCcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
+                             p_Scheme->kgNextEngineParams.cc.grpId,
+                             &grpBits,
+                             &grpBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].ccUnits = grpBits;
+
+        if((p_Scheme->kgNextEngineParams.cc.plcrNext) && (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        {
+                if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
+                absolute = FALSE;
+                direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
+                if(direct)
+                {
+                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                    numOfProfiles = 1;
+                }
+                else
+                {
+                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                    shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                    numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+                }
+        }
+    }
+
+    /* if policer is used directly after KG, or after CC */
+    if((p_Scheme->nextEngine == e_FM_PCD_PLCR)  ||
+       ((p_Scheme->nextEngine == e_FM_PCD_CC) &&
+                   (p_Scheme->kgNextEngineParams.cc.plcrNext) &&
+                   (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
+    {
+        /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
+        if(absolute)
+        {
+            /* for absolute direct policy only, */
+            relativeProfileId = profileId;
+            err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
+            if(err)
+                RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
+        }
+        else
+        {
+            /* save relative profile id's for later check */
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile = TRUE;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].numOfProfiles = numOfProfiles;
+        }
+    }
+    else
+    {
+        /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
+        is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
+        if(p_Scheme->bypassFqidGeneration && p_Scheme->numOfUsedExtractedOrs)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
+        if(p_Scheme->bypassFqidGeneration &&
+                p_Scheme->useHash &&
+                p_Scheme->keyExtractAndHashParams.hashDistributionNumOfFqids)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                    ("hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"));
+    }
+
+    /* configure all 21 scheme registers */
+    tmpReg =  KG_SCH_MODE_EN;
+    switch(p_Scheme->nextEngine)
+    {
+        case(e_FM_PCD_PLCR):
+            /* add to mode register - NIA */
+            tmpReg |= KG_SCH_MODE_NIA_PLCR;
+            tmpReg |= NIA_ENG_PLCR;
+            tmpReg |= (uint32_t)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
+            /* initialize policer profile command - */
+            /*  configure kgse_ppc  */
+            if(direct)
+            /* use profileId as base, other fields are 0 */
+                p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+            else
+            {
+                if(shift > MAX_PP_SHIFT)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+
+                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                ppcTmp |= (uint32_t)profileId;
+
+                p_SchemeRegs->kgse_ppc = ppcTmp;
+            }
+            break;
+        case(e_FM_PCD_CC):
+            /* mode reg - define NIA */
+            tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+
+            p_SchemeRegs->kgse_ccbs = grpBits;
+            tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
+
+            if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+            {
+                if(!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
+                {
+                    /* find out if absolute or relative */
+                    if(absolute)
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
+                    if(direct)
+                    {
+                        /* mask = 0, base = directProfileId */
+                        p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+                    }
+                    else
+                    {
+                        if(shift > MAX_PP_SHIFT)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+                        if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                        ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                        ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                        ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                        ppcTmp |= (uint32_t)profileId;
+
+                        p_SchemeRegs->kgse_ppc = ppcTmp;
+                    }
+                }
+                else
+                    ppcTmp = KG_SCH_PP_NO_GEN;
+            }
+            break;
+        case(e_FM_PCD_DONE):
+            if(p_Scheme->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+            else
+                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+            break;
+        default:
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
+    }
+    p_SchemeRegs->kgse_mode = tmpReg;
+
+    p_SchemeRegs->kgse_mv = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector;
+
+    if(p_Scheme->useHash)
+    {
+        p_KeyAndHash = &p_Scheme->keyExtractAndHashParams;
+
+        if (p_KeyAndHash->numOfUsedExtracts >= FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfUsedExtracts out of range"));
+
+        /*  configure kgse_dv0  */
+        p_SchemeRegs->kgse_dv0 = p_KeyAndHash->privateDflt0;
+
+        /*  configure kgse_dv1  */
+        p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
+
+        if(!p_Scheme->bypassFqidGeneration)
+        {
+            if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
+            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_Scheme->baseFqid)
+                DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
+        }
+
+        /*  configure kgse_ekdv  */
+        tmpReg = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
+        {
+            switch(p_KeyAndHash->dflts[i].type)
+            {
+                case(e_FM_PCD_KG_MAC_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_ENET_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_SESSION_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_MPLS_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PROTOCOL_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_TOS_TC):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPSEC_SPI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_L4_PORT):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCP_FLAG):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                   break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+        }
+        p_SchemeRegs->kgse_ekdv = tmpReg;
+
+        p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
+        if(!p_LocalExtractsArray)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+
+        /*  configure kgse_ekfc and  kgse_gec */
+        knownTmp = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            p_Extract = &p_KeyAndHash->extractArray[i];
+            switch(p_Extract->type)
+            {
+                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                    knownTmp |= KG_SCH_KN_PORT_ID;
+                    /* save in driver structure */
+                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
+                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                    break;
+                case(e_FM_PCD_EXTRACT_BY_HDR):
+                    switch(p_Extract->extractByHdr.hdr)
+                    {
+                        case(HEADER_TYPE_UDP_ENCAP_ESP):
+                            switch(p_Extract->extractByHdr.type)
+                            {
+                                case(e_FM_PCD_EXTRACT_FROM_HDR):
+                                    /* case where extraction from ESP only */
+                                    if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
+                                    {
+                                        p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                        p_Extract->extractByHdr.extractByHdrType.fromHdr.offset -= UDP_HEADER_SIZE;
+                                        p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                    }
+                                    else
+                                    {
+                                        p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                        p_Extract->extractByHdr.ignoreProtocolValidation = FALSE;
+                                    }
+                                    break;
+                                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                                    switch(p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
+                                    {
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                            break;
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                                            p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                    }
+                                    break;
+                                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                                    switch(p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
+                                    {
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                            p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
+                                            break;
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                            p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
+                                            p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SEQ_NUM_OFFSET;
+                                            p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
+                                            break;
+                                    }
+                                    break;
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+                    switch(p_Extract->extractByHdr.type)
+                    {
+                        case(e_FM_PCD_EXTRACT_FROM_HDR):
+                            generic = TRUE;
+                            /* get the header code for the generic extract */
+                            code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
+                            /* set generic register fields */
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                            generic = TRUE;
+                            /* get the field code for the generic extract */
+                            code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
+                                        p_Extract->extractByHdr.extractByHdrType.fromField.field, p_Extract->extractByHdr.ignoreProtocolValidation,p_Extract->extractByHdr.hdrIndex);
+                            offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
+                            size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if(!p_Extract->extractByHdr.ignoreProtocolValidation)
+                            {
+                                /* if we have a known field for it - use it, otherwise use generic */
+                                bitMask = GetKnownProtMask(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
+                                            p_Extract->extractByHdr.extractByHdrType.fullField);
+                                if(bitMask)
+                                {
+                                    knownTmp |= bitMask;
+                                    /* save in driver structure */
+                                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(bitMask);
+                                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                                }
+                                else
+                                    generic = TRUE;
+
+                            }
+                            else
+                                generic = TRUE;
+                            if(generic)
+                            {
+                                /* tmp - till we cover more headers under generic */
+                                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
+                            }
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                case(e_FM_PCD_EXTRACT_NON_HDR):
+                    /* use generic */
+                    generic = TRUE;
+                    offset = 0;
+                    /* get the field code for the generic extract */
+                    code = GetGenCode(p_Extract->extractNonHdr.src, &offset);
+                    offset += p_Extract->extractNonHdr.offset;
+                    size = p_Extract->extractNonHdr.size;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+
+            if(generic)
+            {
+                /* set generic register fields */
+                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                    RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                if(!code)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+
+                genTmp = KG_SCH_GEN_VALID;
+                genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+                genTmp |= offset;
+                if((size > MAX_KG_SCH_SIZE) || (size < 1))
+                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
+                swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
+                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                    DBG(WARNING, ("No sw default configured"));
+
+                genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
+                genTmp |= KG_SCH_GEN_MASK;
+                p_SchemeRegs->kgse_gec[currGenId] = genTmp;
+                /* save in driver structure */
+                p_LocalExtractsArray->extractsArray[i].id = currGenId++;
+                p_LocalExtractsArray->extractsArray[i].known = FALSE;
+                generic = FALSE;
+            }
+        }
+        p_SchemeRegs->kgse_ekfc = knownTmp;
+
+        selectTmp = 0;
+        maskTmp = 0xFFFFFFFF;
+        /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
+
+        if(p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
+        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        {
+            /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
+            id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
+            /* Get the shift of the select field (depending on i) */
+            GET_MASK_SEL_SHIFT(shift,i);
+            if (p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].known)
+                selectTmp |= id << shift;
+            else
+                selectTmp |= (id + MASK_FOR_GENERIC_BASE_ID) << shift;
+
+            /* Get the shift of the offset field (depending on i) - may
+               be in  kgse_bmch or in kgse_fqb (depending on i) */
+            GET_MASK_OFFSET_SHIFT(shift,i);
+            if (i<=1)
+                selectTmp |= p_KeyAndHash->masks[i].offset << shift;
+            else
+                fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
+
+            /* Get the shift of the mask field (depending on i) */
+            GET_MASK_SHIFT(shift,i);
+            /* pass all bits */
+            maskTmp |= KG_SCH_BITMASK_MASK << shift;
+            /* clear bits that need masking */
+            maskTmp &= ~(0xFF << shift) ;
+            /* set mask bits */
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
+        }
+        p_SchemeRegs->kgse_bmch = selectTmp;
+        p_SchemeRegs->kgse_bmcl = maskTmp;
+        /* kgse_fqb will be written t the end of the routine */
+
+        /*  configure kgse_hc  */
+        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+
+        tmpReg = 0;
+
+        tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
+        tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+
+        if(p_KeyAndHash->symmetricHash)
+        {
+            if((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
+                    (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
+            tmpReg |= KG_SCH_HASH_CONFIG_SYM;
+        }
+        p_SchemeRegs->kgse_hc = tmpReg;
+
+        /* build the return array describing the order of the extractions */
+
+        /* the last currGenId places of the array
+           are for generic extracts that are always last.
+           We now sort for the calculation of the order of the known
+           extractions we sort the known extracts between orderedArray[0] and
+           orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].
+           for the calculation of the order of the generic extractions we use:
+           num_of_generic - currGenId
+           num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
+           first_generic_index = num_of_known */
+        curr = 0;
+        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            if(p_LocalExtractsArray->extractsArray[i].known)
+            {
+                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
+                j = curr;
+                /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
+                index in the user's extractions array */
+                /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
+                location */
+                while(p_LocalExtractsArray->extractsArray[i].id <
+                      p_LocalExtractsArray->extractsArray[p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1]].id && j>0)
+                {
+                    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] =
+                        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1];
+                    j--;
+                }
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] = (uint8_t)i;
+                curr++;
+            }
+            else
+                /* index is first_generic_index + generic index (id) */
+                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id]= (uint8_t)i;
+
+        }
+        XX_Free(p_LocalExtractsArray);
+        p_LocalExtractsArray = NULL;
+
+    }
+    else
+    {
+        /* clear all unused registers: */
+        p_SchemeRegs->kgse_ekfc = 0;
+        p_SchemeRegs->kgse_ekdv = 0;
+        p_SchemeRegs->kgse_bmch = 0;
+        p_SchemeRegs->kgse_bmcl = 0;
+        p_SchemeRegs->kgse_hc = 0;
+        p_SchemeRegs->kgse_dv0 = 0;
+        p_SchemeRegs->kgse_dv1 = 0;
+    }
+
+    if(p_Scheme->bypassFqidGeneration)
+        p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
+
+    /*  configure kgse_spc  */
+    if( p_Scheme->schemeCounter.update)
+        p_SchemeRegs->kgse_spc = p_Scheme->schemeCounter.value;
+
+
+    /* check that are enough generic registers */
+    if(p_Scheme->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+
+    /* extracted OR mask on Qid */
+    for( i=0 ;i<p_Scheme->numOfUsedExtractedOrs ; i++)
+    {
+
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs = TRUE;
+        /*  configure kgse_gec[i]  */
+        p_ExtractOr = &p_Scheme->extractedOrs[i];
+        switch(p_ExtractOr->type)
+        {
+            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
+                offset = 0;
+                break;
+            case(e_FM_PCD_EXTRACT_BY_HDR):
+                /* get the header code for the generic extract */
+                code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
+                /* set generic register fields */
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            case(e_FM_PCD_EXTRACT_NON_HDR):
+                /* get the field code for the generic extract */
+                offset = 0;
+                code = GetGenCode(p_ExtractOr->src, &offset);
+                offset += p_ExtractOr->extractionOffset;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+        }
+
+        /* set generic register fields */
+        if(!code)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+        genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
+        genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+        genTmp |= offset;
+        if(!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
+
+        /************************************************************************************
+            bitOffsetInFqid and bitOffsetInPolicerProfile are translated to rotate parameter
+            in the following way:
+
+            Driver API and implementation:
+            ==============================
+            FQID: extracted OR byte may be shifted right 1-31 bits to effect parts of the FQID.
+            if shifted less than 8 bits, or more than 24 bits a mask is set on the bits that
+            are not overlapping FQID.
+                     ------------------------
+                    |      FQID (24)         |
+                     ------------------------
+            --------
+           |        |  extracted OR byte
+            --------
+
+            Policer Profile: extracted OR byte may be shifted right 1-15 bits to effect parts of the
+            PP id. Unless shifted exactly 8 bits to overlap the PP id, a mask is set on the bits that
+            are not overlapping PP id.
+
+                     --------
+                    | PP (8) |
+                     --------
+            --------
+           |        |  extracted OR byte
+            --------
+
+            HW implementation
+            =================
+            FQID and PP construct a 32 bit word in the way describe below. Extracted byte is located
+            as the highest byte of that word and may be rotated to effect any part os the FQID or
+            the PP.
+             ------------------------  --------
+            |      FQID (24)         || PP (8) |
+             ------------------------  --------
+             --------
+            |        |  extracted OR byte
+             --------
+
+        ************************************************************************************/
+
+        if(p_ExtractOr->bitOffsetInFqid)
+        {
+            if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
+            if(p_ExtractOr->bitOffsetInFqid<8)
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
+            else
+                genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInFqid, TRUE);
+        }
+        else /* effect policer profile */
+        {
+            if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
+            genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
+            p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInPlcrProfile, FALSE);
+        }
+
+        genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
+        /* clear bits that need masking */
+        genTmp &= ~KG_SCH_GEN_MASK ;
+        /* set mask bits */
+        genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
+        p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
+
+    }
+    /* clear all unused GEC registers */
+    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        p_SchemeRegs->kgse_gec[i] = 0;
+
+    /* add base Qid for this scheme */
+    /* add configuration for kgse_fqb */
+    if(p_Scheme->baseFqid & ~0x00FFFFFF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
+
+    fqbTmp |= p_Scheme->baseFqid;
+    p_SchemeRegs->kgse_fqb = fqbTmp;
+
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine = p_Scheme->nextEngine;
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction = p_Scheme->kgNextEngineParams.doneAction;
+    return E_OK;
+}
+
+void  FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
+        FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = TRUE;
+}
+
+void  FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
+        FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = FALSE;
+}
+
+uint32_t FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].requiredAction;
+}
+
+uint32_t FmPcdKgGetPointedOwners(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].pointedOwners;
+}
+
+bool FmPcdKgIsDirectPlcr(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].directPlcr;
+}
+
+
+uint16_t FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].relativeProfileId;
+}
+
+
+bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    if((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
+        p_FmPcd->p_FmPcdKg->schemes[schemeId].bitOffsetInPlcrProfile) ||
+        p_FmPcd->p_FmPcdKg->schemes[schemeId].nextRelativePlcrProfile)
+        return TRUE;
+    else
+        return FALSE;
+
+}
+void FmPcdKgUpatePointedOwner(t_Handle h_FmPcd, uint8_t schemeId, bool add)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    if(add)
+        p_FmPcd->p_FmPcdKg->schemes[schemeId].pointedOwners++;
+    else
+        p_FmPcd->p_FmPcdKg->schemes[schemeId].pointedOwners--;
+}
+
+e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].nextEngine;
+}
+
+e_FmPcdDoneAction FmPcdKgGetDoneAction(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].doneAction;
+}
+
+void FmPcdKgUpdateRequiredAction(t_Handle h_FmPcd, uint8_t schemeId, uint32_t requiredAction)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].requiredAction = requiredAction;
+}
+
+t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(schemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+   /* check that no port is bound to this scheme */
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
+    if(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
+    return E_OK;
+}
+
+uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    tmpKgpeCpp;
+
+    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
+    return tmpKgpeCpp;
+}
+
+bool    FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
+{
+
+    if(schemeModeReg & KG_SCH_MODE_EN)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
+{
+    return     (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_WRITE |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
+
+}
+
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
+{
+    return     (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_READ |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
+
+}
+
+
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t        FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+
+uint32_t        FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+uint32_t        FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
+}
+
+uint8_t FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].baseEntry;
+}
+
+uint16_t FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].sizeOfGrp;
+}
+
+uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i=0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeHwId)
+            return i;
+    ASSERT_COND(i!=p_FmPcd->p_FmPcdKg->numOfSchemes);
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+uint8_t FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->numOfSchemes;
+}
+
+uint8_t FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemesIds[relativeSchemeId];
+}
+
+uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+            return i;
+
+    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
+
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             relativeSchemeId, physicalSchemeId;
+    uint32_t            tmpKgarReg, tmpReg32 = 0, intFlags;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgCcGetSetParams(p_FmPcd->h_Hc,  h_Scheme,  requiredAction);
+
+    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+    if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    if (FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Lock of the scheme FAILED"));
+
+    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners ||
+       !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
+    {
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        {
+            switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
+            {
+                case(e_FM_PCD_DONE):
+                    if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
+                    {
+                        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+                        intFlags = FmPcdLock(p_FmPcd);
+                        WriteKgarWait(p_FmPcd, tmpKgarReg);
+                        if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+                        {
+                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+                        }
+                        tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+                        ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+                        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA);
+                        /* call indirect command for scheme write */
+                        tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+                        WriteKgarWait(p_FmPcd, tmpKgarReg);
+                        FmPcdUnlock(p_FmPcd, intFlags);
+                    }
+                break;
+                case(e_FM_PCD_PLCR):
+                    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
+                       (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs &&
+                        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
+                        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
+                        {
+                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
+                        }
+                        err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
+                        if(err)
+                        {
+                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                            RETURN_ERROR(MAJOR, err, NO_MSG);
+                        }
+               break;
+               default:
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,("in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"));
+            }
+        }
+    }
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners += 1;
+    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction |= requiredAction;
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+    return E_OK;
+}
+
+t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    bool        ans;
+
+    if (intr)
+        ans = TRY_LOCK(NULL, &p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
+    else
+        ans = TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
+    if (ans)
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
+}
+
+void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+}
+
+t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                            tmpReg;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
+    uint8_t                             i;
+    t_Error                             err = E_OK;
+    uint32_t                            tmpKgarReg;
+    uint32_t                            intFlags;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetScheme(p_FmPcd->h_Hc, p_Scheme);
+
+    /* if not called for modification, check first that this scheme is unused */
+    if(!p_Scheme->modify)
+    {
+        /* check that schemeId is in range */
+        if(p_Scheme->id.relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            return NULL;
+        }
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        if (FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE))
+            return NULL;
+
+        physicalSchemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+
+        /* read specified scheme into scheme registers */
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        intFlags = FmPcdLock(p_FmPcd);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+        tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+        FmPcdUnlock(p_FmPcd, intFlags);
+
+        if (tmpReg & KG_SCH_MODE_EN)
+        {
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
+                         ("Scheme %d(phys %d) is already used", relativeSchemeId, physicalSchemeId));
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            return NULL;
+        }
+
+    }
+    else
+    {
+        SANITY_CHECK_RETURN_VALUE(p_Scheme->id.h_Scheme, E_INVALID_HANDLE, NULL);
+
+        intFlags = FmPcdLock(p_FmPcd);
+        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+        /* check that schemeId is in range */
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            FmPcdUnlock(p_FmPcd, intFlags);
+            return NULL;
+        }
+
+        err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, TRUE);
+        FmPcdUnlock(p_FmPcd, intFlags);
+        if (err)
+            return NULL;
+    }
+
+    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        return NULL;
+    }
+
+    /* configure all 21 scheme registers */
+    p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
+    intFlags = FmPcdLock(p_FmPcd);
+    WRITE_UINT32(p_MemRegs->kgse_ppc, schemeRegs.kgse_ppc);
+    WRITE_UINT32(p_MemRegs->kgse_ccbs, schemeRegs.kgse_ccbs);
+    WRITE_UINT32(p_MemRegs->kgse_mode, schemeRegs.kgse_mode);
+    WRITE_UINT32(p_MemRegs->kgse_mv, schemeRegs.kgse_mv);
+    WRITE_UINT32(p_MemRegs->kgse_dv0, schemeRegs.kgse_dv0);
+    WRITE_UINT32(p_MemRegs->kgse_dv1, schemeRegs.kgse_dv1);
+    WRITE_UINT32(p_MemRegs->kgse_ekdv, schemeRegs.kgse_ekdv);
+    WRITE_UINT32(p_MemRegs->kgse_ekfc, schemeRegs.kgse_ekfc);
+    WRITE_UINT32(p_MemRegs->kgse_bmch, schemeRegs.kgse_bmch);
+    WRITE_UINT32(p_MemRegs->kgse_bmcl, schemeRegs.kgse_bmcl);
+    WRITE_UINT32(p_MemRegs->kgse_hc, schemeRegs.kgse_hc);
+    WRITE_UINT32(p_MemRegs->kgse_spc, schemeRegs.kgse_spc);
+    WRITE_UINT32(p_MemRegs->kgse_fqb, schemeRegs.kgse_fqb);
+    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    FmPcdKgValidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return UINT_TO_PTR((uint64_t)physicalSchemeId+1);
+}
+
+t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             physicalSchemeId;
+    uint32_t            tmpKgarReg, intFlags;
+    t_Error             err = E_OK;
+    uint8_t             relativeSchemeId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
+
+    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+    if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    if ((err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE)) != E_OK)
+       RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* check that no port is bound to this scheme */
+    err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+    if(err)
+       RETURN_ERROR(MINOR, err, NO_MSG);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    /* clear mode register, including enable bit */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, 0);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return E_OK;
+}
+
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            tmpKgarReg, spc, intFlags;
+    uint8_t             physicalSchemeId;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgGetSchemeCounter(p_FmPcd->h_Hc, h_Scheme);
+
+    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    intFlags = FmPcdLock(p_FmPcd);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+       REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+    spc = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return spc;
+}
+
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            tmpKgarReg, intFlags;
+    uint8_t             physicalSchemeId;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetSchemeCounter(p_FmPcd->h_Hc, h_Scheme, value);
+
+    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    /* check that schemeId is in range */
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    /* read specified scheme into scheme registers */
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    intFlags = FmPcdLock(p_FmPcd);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+    {
+       FmPcdUnlock(p_FmPcd, intFlags);
+       RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+    }
+
+    /* change counter value */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc, value);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
new file mode 100644
index 0000000..0d176e8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -0,0 +1,2637 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.c
+
+ @Description   FM PCD manip ...
+*//***************************************************************************/
+#ifdef CONFIG_FMAN_P1023
+#ifdef FM_CAPWAP_SUPPORT
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "memcpy_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_manip.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#undef WRITE_UINT16
+#undef GET_UINT16
+#undef WRITE_UINT8
+#undef GET_UINT8
+
+#define WRITE_UINT16(addr, val)  \
+    do{                             \
+            if((int)&(addr) % 4)    \
+                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
+                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
+            else                    \
+                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
+                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
+      }while(0);
+#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
+       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
+       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
+
+#define WRITE_UINT8(addr,val) WRITE_UINT8_ERRATA(&addr,val)
+#define GET_UINT8(addr) GET_UINT8_ERRATA(&addr)
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+static void WRITE_UINT8_ERRATA(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+         newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+static t_Error GetPrOffsetByNonHeader(uint8_t *parseArrayOffset)
+{
+    /*For now - the only field in the Parse Array from the NON_BY_TYPE can be e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE*/
+    /*Maybe extended in the future*/
+
+    *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+
+    return E_OK;
+}
+
+static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Handle      p_Ad;
+    uint32_t      tmpReg32 = 0;
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+            {
+                tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
+                tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
+                *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets = tmpReg32;
+                p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+                p_Manip->icOffset = icOffset;
+            }
+            else
+            {
+                if(p_Manip->icOffset != icOffset)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+            }
+            break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+                {
+                    p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+                    tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
+                    tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
+                    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
+                    p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+                    p_Manip->icOffset = icOffset;
+                }
+                else
+                {
+                    if(p_Manip->icOffset != icOffset)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+                }
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+    }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
+{
+
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+    uint32_t                tmpReg32;
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
+        fmPortGetSetCcParams.setCcParams.psoSize = 16;
+
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
+#endif
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+           (p_Manip->updateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
+        fmPortGetSetCcParams.setCcParams.psoSize = 16;
+
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+
+    }
+
+   if(p_Manip->updateParams & OFFSET_OF_PR)
+   {
+        tmpReg32 = 0;
+        tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
+        WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
+        p_Manip->updateParams &= ~OFFSET_OF_PR;
+        p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+   }
+   else if (validate)
+   {
+        tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
+        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
+   }
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate,t_Handle h_FmTree)
+{
+    t_AdOfTypeContLookup            *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPcdCcSavedManipParams       *p_SavedManipParams = NULL;
+    uint32_t                        tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        if(!p_SavedManipParams)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        p_Manip->fragParams.poolId = p_SavedManipParams->capwapParams.poolId;
+        p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
+
+        tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
+        tmpReg32 |= ((uint32_t)p_Manip->fragParams.poolId << 8);
+        tmpReg32 |= ((uint32_t)p_Manip->fragParams.dataOffset<< 16);
+        WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
+
+        p_Manip->updateParams &= ~OFFSET_OF_DATA;
+        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+    }
+   else if (validate)
+   {
+
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        if(!p_SavedManipParams)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        if((p_Manip->fragParams.poolId != p_SavedManipParams->capwapParams.poolId) ||
+           (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+   }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate, t_Handle h_FmTree)
+{
+    t_AdOfTypeContLookup        *p_Ad;
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    t_Error                     err;
+    uint32_t                    tmpReg32 = 0;
+    t_FmPcdCcSavedManipParams   *p_SavedManipParams;
+
+    UNUSED(h_Ad);
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+
+        p_SavedManipParams = (t_FmPcdCcSavedManipParams *)XX_Malloc(sizeof(t_FmPcdCcSavedManipParams));
+        p_SavedManipParams->capwapParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+        p_SavedManipParams->capwapParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND(!(p_SavedManipParams->capwapParams.dataOffset % 16));
+#endif
+
+        FmPcdCcTreeSetSavedManipParams(h_FmTree, (t_Handle)p_SavedManipParams, e_FM_MANIP_CAPWAP_INDX);
+    }
+    else if (validate)
+    {
+        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+            !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+            ((p_Manip->updateParams & OFFSET_OF_DATA) ||
+            (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.poolIdForManip << 8);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
+        WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
+
+        p_Manip->updateParams &= ~OFFSET_OF_DATA;
+        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+        p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+        p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+    }
+    else if (validate)
+    {
+        if((p_Manip->fragParams.poolId != fmPortGetSetCcParams.getCcParams.poolIdForManip) ||
+           (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+    }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
+                                     t_Handle                       h_FmPort,
+                                     t_FmPcdManip                   *p_Manip,
+                                     t_Handle                       h_Ad,
+                                     bool                           validate)
+{
+    t_CapwapReasmPram  *p_ReassmTbl;
+    t_Error             err;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    uint8_t             i = 0;
+    uint16_t            size;
+    uint32_t            tmpReg32;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcCapwapReassmTimeoutParams ccCapwapReassmTimeoutParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+
+    UNUSED(h_Ad);
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+    p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & NUM_OF_TASKS) && !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+        !(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & OFFSET_OF_PR) &&
+        !(p_Manip->updateParams & HW_PORT_ID)) ||
+           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR)
+           ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("buffser pool id  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND((fmPortGetSetCcParams.getCcParams.dataOffset % 16) == 0);
+#endif
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && (!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) &&
+         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) && (!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) &&
+         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
+           ((p_Manip->updateParams & NUM_OF_TASKS) ||
+           (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR)||
+            (p_Manip->updateParams & HW_PORT_ID)))
+
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool for header manipulation wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        if(p_Manip->updateParams & NUM_OF_TASKS)
+        {
+            size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess + fmPortGetSetCcParams.getCcParams.numOfTasks);
+            if(size  > 255)
+                RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
+
+            p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
+
+            /*p_ReassmFrmDescrIndxPoolTbl*/
+            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)(size + 1),
+                                              4);
+            if(!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
+
+            for( i = 0; i < size; i++)
+                WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
+
+            /*p_ReassmFrmDescrPoolTbl*/
+            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                                              4);
+
+           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
+
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescPoolTblPtr, tmpReg32);
+
+            /*p_TimeOutTbl*/
+
+            p_Manip->fragParams.p_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                                              4);
+
+            if(!p_Manip->fragParams.p_TimeOutTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+            WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
+
+
+            p_Manip->updateParams &= ~NUM_OF_TASKS;
+            p_Manip->shadowUpdateParams |= NUM_OF_TASKS;
+       }
+
+       if(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)
+       {
+
+            p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.poolId << 16;
+            WRITE_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes, tmpReg32);
+
+            p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+            p_Manip->shadowUpdateParams |= BUFFER_POOL_ID_FOR_MANIP;
+       }
+
+        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        {
+            p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= p_Manip->fragParams.dataOffset;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+            p_Manip->updateParams &= ~OFFSET_OF_DATA;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
+        }
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= FM_PCD_MANIP_CAPWAP_REASM_PR_COPY;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->intStatsTblPtr);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.prOffset << 24;
+            WRITE_UINT32(p_ReassmTbl->intStatsTblPtr, tmpReg32);
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+       }
+       else
+       {
+           p_Manip->fragParams.prOffset = 0xff;
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+
+       }
+
+        p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+
+        /*timeout hc */
+       ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->fragParams.fqidForTimeOutFrames;
+       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->fragParams.hwPortId << 24;
+       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
+       ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_Manip->fragParams.timeoutRoutineRequestTime)/2;
+       return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
+
+    }
+    else if(validate)
+    {
+        if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+        if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
+
+        if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
+
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        else
+        {
+            if(p_Manip->fragParams.prOffset != 0xff)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
+    }
+
+    return E_OK;
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+static t_Error UpdateInitIPSec(t_Handle h_FmPort, t_FmPcdManip *p_Manip)
+{
+    SANITY_CHECK_RETURN_ERROR(h_FmPort,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->type == HMAN_OC_IPSEC, E_INVALID_STATE);
+
+    /*
+    if(p_Manip->cnia)
+    {
+        p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+        WRITE_UINT32(p_Ad->ccAdBase, GET_UINT32(p_Ad->ccAdBase) | FM_PCD_MANIP_IPSEC_CNIA);
+    }
+*/
+    return E_OK;
+}
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))*/
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+static t_Error UpdateInitIpFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_Manip)
+{
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    t_Error                     err;
+    uint32_t                    tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->type == HMAN_OC_IP_FRAGMENTATION, E_INVALID_STATE);
+
+    fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+    fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+    err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+static t_Error CreateIpReassCommonParamTable(t_FmPcdManip *p_Manip,
+                                             t_FmPcd *p_FmPcd ,
+                                             t_IpReasmCommonTbl *p_IpReasmCommonPramTbl)
+{
+    uint32_t    tmpReg32 = 0, i;
+    uint64_t    tmpReg64, size;
+
+    p_Manip->ipReassmParams.h_IpReassCommonParamsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
+                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
+
+    if(!p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    p_IpReasmCommonPramTbl = (t_IpReasmCommonTbl *)(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+
+    IOMemSet32(p_IpReasmCommonPramTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
+
+    tmpReg32 = 0;
+    if(p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES; 
+
+    tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
+    WRITE_UINT32(p_IpReasmCommonPramTbl->timeoutModeAndFqid, tmpReg32);
+
+
+    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 129;
+
+    /*p_ReassmFrmDescrIndxPoolTbl */
+    p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                      (uint32_t)(size * 2),
+                                      256);
+    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size * 2));
+
+    for( i = 0; i < size - 1; i++)
+        WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
+
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+
+    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
+
+    /*p_ReassmFrmDescrPoolTbl*/
+    p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl = (t_Handle)XX_MallocSmart((uint32_t)(size * 32), p_Manip->ipReassmParams.dataMemId, 32);
+
+    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl, 0,  (uint32_t)(size * 32));
+
+    tmpReg64 = (uint64_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl));
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    WRITE_UINT32(p_IpReasmCommonPramTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
+
+    /*p_TimeOutTbl*/
+    p_Manip->ipReassmParams.h_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                           (uint32_t)(size  * 8),8);
+
+    if(!p_Manip->ipReassmParams.h_TimeOutTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_TimeOutTbl, 0,  (uint16_t)(size * 8));
+
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_IpReasmCommonPramTbl->timeOutTblPtr, tmpReg32);
+
+    /* Expiration Delay */
+    tmpReg32 = 0;
+    tmpReg32 |= p_Manip->ipReassmParams.timeoutThresholdForReassmProcess;
+    WRITE_UINT32(p_IpReasmCommonPramTbl->expirationDelay, tmpReg32);
+
+    /* Counts the number of TimeOut occurrences - Must be initialized to zero.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalTimeOutCounter, 0);
+    /* Counts the number of failed attempts to allocate a Reassembly Frame Descriptor - Must be initialized to zero.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalRfdPoolBusyCounter, 0);
+    /* Counts the number of times an internal buffer busy occured.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalInternalBufferBusy, 0);
+    /* Counts the number of times external buffer busy occured. */
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalExternalBufferBusy, 0);
+
+    return E_OK;
+}
+
+static t_Error CreateIpReassParamTable(t_FmPcdManip *p_Manip, t_Handle h_IpReassParamsTblPtr, bool ipv4)
+{
+    t_IpReasmPram           *p_Table;
+    t_AdOfTypeContLookup    *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
+    uint32_t                tmpReg32, autoLearnHashTblSize;
+    uint32_t                numOfWays, setSize, setSizeCode, tmpSetSize;
+    uint32_t                waySize, numOfSets, tmpNumOfSets, numOfEntries;
+    uint64_t                tmpReg64;
+    t_Handle                h_AutoLearnHashTbl, h_AutoLearnSetLockTblPtr;
+
+    /*Pointer to fragment ID*/
+    h_IpReassParamsTblPtr = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                        FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
+                                                        FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
+
+    if(!h_IpReassParamsTblPtr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(h_IpReassParamsTblPtr, 0, FM_PCD_MANIP_IP_REASM_TABLE_SIZE);
+
+    p_Table = (t_IpReasmPram *)h_IpReassParamsTblPtr;
+
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(((t_IpReasmPram *)h_IpReassParamsTblPtr)->ipReassCommonPrmTblPtr, tmpReg32);
+
+    /* waysNumAndSetSize calculation */
+    numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry;
+
+    /*It is recommended that the total number of entries in this table
+    (number of sets * number of ways) will be twice the number of frames that
+     are expected to be reassembled simultaneously.*/
+    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
+
+    /* sets number calculation - number of entries = number of sets * number of ways */
+    numOfSets = numOfEntries / numOfWays;
+
+    /*TODO - Handle way size*/
+    switch(p_Manip->ipReassmParams.hdr)
+    {
+        case(HEADER_TYPE_IPv6):
+            /* WaySize is rounded-up to next multiple of 8 */
+            waySize = ROUND_UP(((16 + 16 + 4 + 2) /* * numOfWays*/),8);
+            break;
+        case(HEADER_TYPE_IPv4):
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+    }
+    /* Set size is rounded-up to next power of 2 */
+    LOG2(numOfWays * waySize, tmpSetSize);
+    setSize =  (uint32_t)(1 << (tmpSetSize + (POWER_OF_2(numOfWays * waySize) ? 0 : 1)));
+
+    LOG2(setSize, setSizeCode);
+    WRITE_UINT16(((t_IpReasmPram *)p_Table)->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
+
+    LOG2(numOfSets, tmpNumOfSets);
+    numOfSets = (uint32_t)(1 << (tmpNumOfSets + (POWER_OF_2(numOfSets) ? 0 : 1)));
+
+    WRITE_UINT16(((t_IpReasmPram *)p_Table)->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
+
+    /*autoLearnHashTbl allocation
+    Table size = set size * number of sets
+    This tables base address should be aligned to SetSize.*/
+    autoLearnHashTblSize = numOfSets * setSize;
+
+    if (ipv4)
+        h_AutoLearnHashTbl = p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl;
+    else
+        h_AutoLearnHashTbl = p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl;
+
+    h_AutoLearnHashTbl = (t_Handle)XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSizeCode);
+
+    if(!h_AutoLearnHashTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+
+    IOMemSet32(h_AutoLearnHashTbl, 0,  autoLearnHashTblSize);
+
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 |= XX_VirtToPhys(h_AutoLearnHashTbl);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
+
+    /* AutoLearnSetLockTbl allocation - The size of this table is (number of sets in the IP
+    Reassembly Automatic Learning Hash table)*4 bytes. This table resides in external memory
+    and its base address should be 4-byte aligned */
+    if (ipv4)
+        h_AutoLearnSetLockTblPtr = p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr;
+    else
+        h_AutoLearnSetLockTblPtr = p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr;
+
+    h_AutoLearnSetLockTblPtr = (t_Handle)XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4);
+
+    if(!h_AutoLearnSetLockTblPtr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+
+    IOMemSet32(h_AutoLearnSetLockTblPtr, 0,  (numOfSets * 4));
+
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 |= XX_VirtToPhys(h_AutoLearnSetLockTblPtr);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
+
+    /* Setting the First/Middle fragment minimum size in Bytes */
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->minFragSize, p_Manip->ipReassmParams.minFragSize);
+
+    /* Zeroes all counters */
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalSuccessfullyReasmFramesCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalValidFragmentCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalProcessedFragCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalMalformdFragCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalSetBusyCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalDiscardedFragsCounter, 0);
+    WRITE_UINT32(((t_IpReasmPram *)p_Table)->totalMoreThan16FramesCounter, 0);
+
+    return E_OK;
+}
+
+static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
+                                 t_Handle       h_FmPort,
+                                 t_FmPcdManip   *p_Manip,
+                                 t_Handle       h_Ad,
+                                 bool           validate)
+{
+    t_AdOfTypeContLookup        *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    t_IpReasmCommonTbl          *p_ReassmCommonTbl = NULL;
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    uint8_t                     i = 0;
+    uint32_t                    tmpReg32;
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    UNUSED(h_Ad);
+
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & OFFSET_OF_PR) &&
+        !(p_Manip->updateParams & HW_PORT_ID)) ||
+           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR)
+           ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CLOSING_FRAG_CHECK;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) && (!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) &&
+         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
+           ((p_Manip->updateParams & NUM_OF_TASKS) ||
+           (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR)||
+            (p_Manip->updateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CLOSING_FRAG_CHECK;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        {
+            p_Manip->ipReassmParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
+            tmpReg32 |= p_Manip->ipReassmParams.dataOffset;
+            WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+
+            p_Manip->updateParams &= ~OFFSET_OF_DATA;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
+        }
+
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+    }
+    else
+    {
+        if(validate)
+        {
+            /* TODO - Handle validate..*/
+            /*if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+            if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
+
+            if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
+
+            if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+            {
+                if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            }
+            else
+            {
+                if(p_Manip->fragParams.prOffset != 0xff)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            }
+            if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));*/
+
+        }
+    }
+
+    return E_OK;
+}
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    if(p_Manip->h_Ad)
+    {
+        if(p_Manip->muramAllocate)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
+        else
+            XX_Free(p_Manip->h_Ad);
+        p_Manip->h_Ad = NULL;
+    }
+    if(p_Manip->p_Template)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
+        p_Manip->p_Template = NULL;
+    }
+    if(p_Manip->h_Frag)
+    {
+        if(p_Manip->fragParams.p_AutoLearnHashTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
+        if(p_Manip->fragParams.p_TimeOutTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
+
+    }
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    if (p_Manip->ipFragParams.h_Frag)
+    {
+        if(p_Manip->ipFragParams.h_FragId)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.h_FragId);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.h_Frag);
+    }
+    if (p_Manip->reassm)
+    {
+        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl);
+        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl);
+        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr);
+        if(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+        if(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl);
+        if(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
+            XX_Free(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl);
+    }
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    if(p_Manip->p_StatsTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
+}
+
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+{
+
+    if(p_ManipParams->rmv)
+    {
+        switch(p_ManipParams->rmvParams.type)
+        {
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION):
+                switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.type)
+                {
+                    case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                        switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.manipByHdr.hdr)
+                        {
+                            case(HEADER_TYPE_CAPWAP_DTLS) :
+
+                                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                                p_Manip->muramAllocate = TRUE;
+
+                                if(p_ManipParams->insrt)
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+
+                                if(p_ManipParams->fragOrReasm)
+                                {
+                                    if(!p_ManipParams->fragOrReasmParams.frag)
+                                    {
+                                        switch(p_ManipParams->fragOrReasmParams.hdr)
+                                        {
+                                            case(HEADER_TYPE_CAPWAP):
+                                                p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
+                                                break;
+                                            default:
+                                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                        }
+                                    }
+                                    else
+                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
+                                }
+                            break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+
+                        }
+                        break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid type of remove location"));
+
+                }
+            break;
+            case(e_FM_PCD_MANIP_RMV_INT_FRAME_HDR) :
+                if(p_ManipParams->insrt || p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For the type of remove e_FM_PCD_MANIP_RMV_INT_FRAME_HDR the only valid option rmv = TRUE, insrt = FALSE, fragOrReasm = FALSE"));
+                p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+                p_Manip->muramAllocate = FALSE;
+            break;
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION) :
+                if  (p_ManipParams->fragOrReasm ||
+                    ((p_ManipParams->insrt) && p_ManipParams->insrtParams.type != e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION the only allowed insertion type is e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+           break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+        }
+    }
+    else if(p_ManipParams->insrt)
+    {
+        switch(p_ManipParams->insrtParams.type)
+        {
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE) :
+
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+                p_Manip->muramAllocate = FALSE;
+
+                if(p_ManipParams->fragOrReasm)
+                {
+                    if(p_ManipParams->fragOrReasmParams.frag)
+                    {
+                           switch(p_ManipParams->fragOrReasmParams.hdr)
+                           {
+                                case(HEADER_TYPE_CAPWAP):
+                                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                                    break;
+                                break;
+                                default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
+                           }
+                    }
+                    else
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
+                }
+            break;
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR) :
+                if(p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of insert can not be fragOrReasm = TRUE"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+            break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+        }
+    }
+    else if(p_ManipParams->fragOrReasm)
+    {
+        if(p_ManipParams->fragOrReasmParams.frag)
+        {
+            switch(p_ManipParams->fragOrReasmParams.hdr)
+             {
+                 case(HEADER_TYPE_CAPWAP):
+                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                     p_Manip->muramAllocate = FALSE;
+                 break;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+                 case(HEADER_TYPE_IPv4):
+                     p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
+                     p_Manip->muramAllocate = TRUE;
+                 break;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+                 default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+             }
+        }
+        else
+        {
+            switch (p_ManipParams->fragOrReasmParams.hdr)
+            {
+                case(HEADER_TYPE_CAPWAP):
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+                case(HEADER_TYPE_IPv4):
+                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
+                    break;
+                case(HEADER_TYPE_IPv6):
+                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
+                    break;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+                default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+
+            }
+        }
+
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+
+    p_Manip->insrt = p_ManipParams->insrt;
+    p_Manip->rmv   = p_ManipParams->rmv;
+
+    return E_OK;
+}
+static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
+                                 t_Handle                       h_FmPort,
+                                 t_FmPcdManip                   *p_Manip)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup    *p_Ad;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("handler of PCD previously was initiated by different value"));
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+    if(!p_Manip->p_StatsTbl)
+    {
+
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
+
+        p_Manip->p_StatsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
+                                          4);
+        if(!p_Manip->p_StatsTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+        IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
+
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
+
+        if(p_Manip->cnia)
+            tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
+
+        tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
+        WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    }
+    else
+    {
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+}
+
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error      err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    UNUSED(h_FmPcd);
+    UNUSED(h_FmTree);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        if(level != 1)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For CAPWAP reassembly the manipulation has to be in the first level of the tree"));
+        err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
+        break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(!p_Manip->h_Frag)
+                break;
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            if(level != 2)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For CAPWAP fragmentation the manipulation has to be in the first level of the tree"));
+            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
+        break;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                if(level != 2)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For CAPWAP reassembly the manipulation has to be in the first level of the tree"));
+                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(HMAN_OC_IPSEC):
+            err = UpdateInitIPSec(h_FmPort, p_Manip);
+            if (err != E_OK)
+                RETURN_ERROR(MAJOR, err, ("UpdateInitIPSec failed"));
+            if(!p_Manip->h_Frag)
+                break;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        case(HMAN_OC_IP_FRAGMENTATION):
+            err = UpdateInitIpFragmentation(h_FmPort, p_Manip);
+            break;
+        case(HMAN_OC_IP_REASSEMBLY):
+            err = UpdateInitIpReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+            break;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))*/
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(level != 2)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For index statistics the manipulation has to be in the first level of the tree"));
+            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
+            break;
+        default:
+            return E_OK;
+    }
+    return err;
+}
+
+static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+{
+
+    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error         err = E_OK;
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+
+           if(p_Manip->h_Frag)
+           {
+               if(!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+               !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) && !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previousely in SetPcd function"));
+                if(level != 2)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For CAPWAP reassembly the manipulation has to be in the first level of the tree"));
+           }
+           break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(p_Manip->h_Frag)
+            {
+                if(level != 2)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For CAPWAP fragmentation the manipulation has to be in the first level of the tree"));
+                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+        default:
+            return E_OK;
+
+    }
+    return err;
+
+}
+
+static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipParams, uint8_t *parseArrayOffset)
+{
+    e_NetHeaderType hdr         = p_ManipParams->manipByHdr.hdr;
+    e_FmPcdHdrIndex hdrIndex    = p_ManipParams->manipByHdr.hdrIndex;
+    bool            byField     = p_ManipParams->manipByHdr.byField;
+    t_FmPcdFields   field;
+
+    if(byField)
+        field = p_ManipParams->manipByHdr.fullField;
+
+    if(byField)
+    {
+        switch(hdr)
+        {
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
+                }
+                break;
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                             *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                        break;
+                    default:
+                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type VLAN with this field not supported"));
+                }
+                break;
+           default:
+               RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header by field not supported"));
+        }
+    }
+    else
+    {
+        switch(hdr){
+             case(HEADER_TYPE_ETH):
+                 *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+                break;
+            /* TODO - to take care about SHIM3
+            case(HEADER_TYPE_USER_DEFINED_SHIM3):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
+                break;
+            */
+            case(HEADER_TYPE_LLC_SNAP):
+                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+                break;
+            case(HEADER_TYPE_PPPoE):
+                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+                break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
+     }
+    }
+    return E_OK;
+}
+
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    uint8_t                 prsArrayOffset = 0;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->rmv)
+    {
+        switch(p_ManipParams->rmvSpecificLocationParams.type)
+        {
+            case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                err = GetPrOffsetByHeaderOrField(&p_ManipParams->rmvSpecificLocationParams, &prsArrayOffset);
+                break;
+            case(e_FM_PCD_MANIP_LOC_NON_HDR) :
+                err = GetPrOffsetByNonHeader(&prsArrayOffset);
+                break;
+            default :
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid type of location header manipulation of type Remove"));
+        }
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 |= (uint32_t)prsArrayOffset << 24;
+        tmpReg32 |= HMAN_RMV_HDR;
+    }
+
+    if(p_Manip->insrt)
+        tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bool caamUsed)
+{
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_PR | INTERNAL_CONTEXT_OFFSET;
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpReg32;
+
+    /*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree
+    tmpReg32 = 0;
+    tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;
+    *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
+
+    tmpReg32 = 0;
+    tmpReg32 |= HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    if (caamUsed)
+        *(uint32_t *)&p_Ad->gmask = 0xf0000000;
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+
+
+    if(p_Manip->h_Frag)
+    {
+        p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+    }
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return err;
+}
+
+static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_Handle    p_Table;
+    uint32_t    tmpReg32 = 0;
+    int         i = 0;
+    uint8_t     log2Num;
+    uint8_t     numOfSets;
+    uint32_t    j = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    if(!p_FmPcd->h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
+    if (!POWER_OF_2(p_ManipParams->timeoutRoutineRequestTime))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
+    if(!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+    if(!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
+        DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 4) ||
+            (p_ManipParams->maxNumFramesInProcess > 512))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
+    }
+    else
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 8) ||
+            (p_ManipParams->maxNumFramesInProcess > 2048))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
+    }
+
+    p_Manip->updateParams |= (NUM_OF_TASKS | BUFFER_POOL_ID_FOR_MANIP | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
+
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+
+    p_Table         = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    p_Manip->fragParams.p_AutoLearnHashTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+
+    IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
+
+
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
+
+    tmpReg32 = 0;
+    if(p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    if(p_ManipParams->haltOnDuplicationFrag)
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
+    {
+        i = 8;
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
+    }
+    else
+        i = 4;
+
+    numOfSets = (uint8_t)((p_ManipParams->maxNumFramesInProcess * 2) / i);
+    LOG2(numOfSets, log2Num);
+    tmpReg32 |= (uint32_t)(log2Num - 1) << 24;
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
+
+    for(j = 0; j < p_ManipParams->maxNumFramesInProcess * 2; j++)
+    {
+        if(((j / i)  % 2)== 0)
+        {
+            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
+        }
+    }
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->bufferPoolIdAndRisc1SetIndexes, 0x00008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
+
+    p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
+
+    p_Manip->fragParams.poolIndx =  poolIndex;
+
+    p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
+    p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
+    /*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error
+     now we have problems with all calls to this fucntion*/
+    p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->expirationDelay, tmpReg32);
+
+    return E_OK;
+
+}
+
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP;
+
+    p_Manip->frag = TRUE;
+
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_CC_AD_ENTRY_SIZE,
+                                          FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
+
+    if(p_ManipParams->headerOptionsCompr)
+        tmpReg32 = FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+    p_Manip->fragParams.poolIndx = poolIndex;
+
+    return E_OK;
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+static t_Error IpFragmentation(t_IpFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Manip->ipFragParams.h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                           FM_PCD_CC_AD_ENTRY_SIZE,
+                                           FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if( !p_Manip->ipFragParams.h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32( p_Manip->ipFragParams.h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipFragParams.h_Frag;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_IP_FRAGMENTATION;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= (p_ManipParams->dontFragAction << 30);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    p_Manip->frag = TRUE;
+
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+    p_Manip->ipFragParams.poolIndx = poolIndex;
+
+    /*Pointer to fragment ID*/
+    p_Manip->ipFragParams.h_FragId= (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,4, 4);
+
+    if(!p_Manip->ipFragParams.h_FragId)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->ipFragParams.h_FragId, 0, 4);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.h_FragId) - (p_FmPcd->physicalMuramBase));
+    tmpReg32 |= p_ManipParams->scratchBpid << 24;
+    WRITE_UINT32(p_Ad->gmask, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool ipv4)
+{
+    t_AdOfTypeContLookup *p_Ad      = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPcd              *p_FmPcd   = (t_FmPcd *)p_Manip->h_FmPcd;
+    uint32_t             tmpReg32;
+    t_Error              err;
+    t_Handle             h_IpReassParamsTblPtr;
+
+    /* First Ad register */
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+
+    if (ipv4)
+        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr;
+    else
+        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr;
+
+    err = CreateIpReassParamTable(p_Manip, h_IpReassParamsTblPtr, ipv4);
+
+    if (err == E_OK)
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(h_IpReassParamsTblPtr) - (p_FmPcd->physicalMuramBase));
+    else
+        return err;
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    /* Second Ad register */
+    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.bpid << 8);
+    WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+
+    p_Manip->updateParams = OFFSET_OF_DATA;
+
+    /* Third Ad register */
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
+    tmpReg32 |= (uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT;
+    tmpReg32 |= (uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    p_Manip->reassm = TRUE;
+
+    return E_OK;
+}
+
+static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd; 
+
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_Manip->ipReassmParams.h_Ipv4Ad)
+        {
+           ReleaseManipHandler(p_Manip, p_FmPcd);
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        }
+
+        IOMemSet32(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+         p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
+         if(!p_Manip->ipReassmParams.h_Ipv4Ad)
+         {
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+         }
+
+        memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+
+    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv6Ad, TRUE);
+
+    return E_OK;
+}
+
+static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_Manip->ipReassmParams.h_Ipv6Ad)
+        {
+           ReleaseManipHandler(p_Manip, p_FmPcd);
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        }
+
+        IOMemSet32(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+         p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
+         if(!p_Manip->ipReassmParams.h_Ipv6Ad)
+         {
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+         }
+
+        memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+
+    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv6Ad, FALSE);
+
+    return E_OK;
+}
+
+
+static t_Error IpReassembly(t_FmPcdManipFragOrReasmParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    uint32_t                    tmpReg32 = 0, maxSetNumber = 10000;
+    t_IpReasmCommonTbl          *p_IpReasmCommonPramTbl = NULL;
+    t_IpReassemblyParams        reassmManipParams = p_ManipParams->ipReasmParams;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    if (!p_FmPcd->h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
+    if (!POWER_OF_2(reassmManipParams.maxNumFramesInProcess))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) && (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+
+    /*It is recommended that the total number of entries in this table (number of sets * number of ways) 
+    will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
+
+    p_Manip->ipReassmParams.maxNumFramesInProcess = reassmManipParams.maxNumFramesInProcess;
+    p_Manip->ipReassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->ipReassmParams.numOfFramesPerHashEntry = reassmManipParams.numOfFramesPerHashEntry;
+    p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->ipReassmParams.liodnOffset = reassmManipParams.liodnOffset;
+    p_Manip->ipReassmParams.minFragSize = reassmManipParams.minFragSize;
+    p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->ipReassmParams.bpid = p_ManipParams->extBufPoolIndx;
+
+    CreateIpReassCommonParamTable(p_Manip, p_FmPcd, p_IpReasmCommonPramTbl);
+
+    if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4_AND_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4))        
+        return SetIpv4ReassmManip(p_Manip);
+
+    if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4_AND_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6))        
+        return SetIpv6ReassmManip(p_Manip);
+
+    err = FM_PCD_RegisterReassmPort(p_FmPcd, p_IpReasmCommonPramTbl);
+    if (err != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_IpReasmCommonPramTbl);
+        RETURN_ERROR(MAJOR, err, ("port registration"));
+    }
+
+    return E_OK;
+}
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    UNUSED(p_FmPcd);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
+    if(p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+        tmpReg32 |= (uint32_t)0x16 << 16;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_FmPcdManipInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->insrtByTemplateParams;
+    uint8_t                             tmpReg8 = 0xff;
+    t_AdOfTypeContLookup                *p_Ad;
+    bool                                ipModify = FALSE;
+    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t                            tmpReg16 = 0;
+    t_Error                             err = E_OK;
+    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0;
+    uint8_t                             *p_Template = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->insrt)
+    {
+        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+             (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+
+         if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+
+         if(p_InsrtByTemplate->size > 128)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+
+         if(p_InsrtByTemplate->size)
+         {
+             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                p_InsrtByTemplate->size,
+                                                FM_PCD_CC_AD_TABLE_ALIGN);
+             if(!p_Manip->p_Template)
+                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
+             tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
+             *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
+         }
+
+         tmpReg32 = 0;
+
+        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if(!p_Template)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+
+        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+
+
+         if(p_InsrtByTemplate->modifyOuterIp)
+         {
+             ipModify = TRUE;
+
+             tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+
+             if((tmpReg8 & 0xf0) == 0x40)
+                 tmpReg8 = 4;
+             else if((tmpReg8 & 0xf0) == 0x60)
+                 tmpReg8 = 6;
+             else
+                 tmpReg8 = 0xff;
+
+             if(tmpReg8 == 4)
+             {
+                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
+
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                 {
+
+                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
+                     extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
+                     blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
+                     extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
+                     /*IP header template - IP totalLength -
+                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
+                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
+                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
+                 }
+                 if(blockSize)
+                 {
+                     if (!POWER_OF_2(blockSize))
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
+                     blockSize -= 1;
+                 }
+
+                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+
+
+                 /*IP header template - relevant only for ipv4 CheckSum = 0*/
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+
+
+                 /*UDP checksum has to be 0*/
+                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 {
+                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+
+                 }
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+
+                 tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
+             }
+             else
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
+         }
+
+         tmpReg32 = tmpReg16 = tmpReg8 = 0;
+         /*TODO - check it*/
+         if(p_InsrtByTemplate->modifyOuterVlan)
+         {
+             if(p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
+
+             memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
+             if((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
+
+             memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
+             tmpReg8 &= 0x1f;
+             tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
+
+             p_Template[14] = tmpReg8;
+         }
+
+        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+
+        XX_Free(p_Template);
+    }
+
+    tmpReg32 = 0;
+    if(p_Manip->h_Frag)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+          tmpReg32 = 0xffff0000;
+
+    if(ipModify)
+        tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
+    else
+        tmpReg32 |= (uint32_t)0x0000ff00;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+
+    return err;
+}
+
+#if defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC)
+static t_Error IPSecManip(t_FmPcdManipParams *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+
+    t_Error                     err = E_OK;
+    t_AdOfTypeContLookup        *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+
+    if(p_Manip->frag == TRUE)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32  |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+          tmpReg32 = 0xffff0000;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32  |= HMAN_OC_IPSEC;
+
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
+    WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
+
+/*
+    TODO - Fill the following:
+         - Over write OuterTos
+         - SaveInnerTos
+         - support in CNIA
+*/
+
+    return err;
+}
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+
+static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
+{
+
+    switch(p_StatsParams->type)
+    {
+        case(e_FM_PCD_STATS_PER_FLOWID):
+            p_Manip->type = HMAN_OC_CAPWAP_INDEXED_STATS;
+            p_Manip->muramAllocate = TRUE;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
+    }
+
+    return E_OK;
+}
+
+static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool stats)
+{
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
+    if(!p_Manip)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_Manip, 0, sizeof(t_FmPcdManip));
+
+    if(!stats)
+    {
+        err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
+    }
+    else
+    {
+        err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
+    }
+
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    if(p_Manip->type != HMAN_OC_IP_REASSEMBLY)
+    {
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+        p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    }
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    p_Manip->h_FmPcd = h_FmPcd;
+
+    return p_Manip;
+}
+
+
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify)
+{
+    t_Error err;
+
+    if(!modify)
+    {
+        err = FmPcdManipInitUpdate(h_FmPcd, h_FmPort, h_Manip, h_Ad, validate, level, h_FmTree);
+    }
+    else
+    {
+        err = FmPcdManipModifyUpdate(h_Manip, h_Ad, validate, level, h_FmTree);
+    }
+    return err;
+}
+
+uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(h_Manip);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            return UPDATE_NIA_ENQ_WITHOUT_DMA;
+        default:
+            return 0;
+    }
+}
+
+void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
+{
+
+    if(add)
+        ((t_FmPcdManip *)h_Manip)->owner++;
+    else
+    {
+        ASSERT_COND(((t_FmPcdManip *)h_Manip)->owner);
+        ((t_FmPcdManip *)h_Manip)->owner--;
+    }
+}
+
+t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
+{
+    t_FmPcdManip             *p_Manip;
+    t_Error                   err;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
+
+    p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
+    *requiredAction = 0;
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+               p_Manip->cnia = TRUE;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            p_Manip->ownerTmp++;
+        break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+            p_Manip->ownerTmp++;
+        break;
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
+               (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+            err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+        break;
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(HMAN_OC_IPSEC):
+
+            if((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
+               !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+               p_Manip->cnia = FALSE;
+            else
+               p_Manip->cnia = TRUE;
+            if(!p_Manip->h_Frag)
+            {
+                p_Manip->ownerTmp++;
+                break;
+            }
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        case(HMAN_OC_IP_FRAGMENTATION):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            p_Manip->ownerTmp++;
+        break;
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+            break;
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
+        break;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
+                err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+            break;
+        default:
+            break;
+    }
+    return err;
+}
+
+void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    FmPcdManipUpdateOwner(h_Manip, TRUE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(HMAN_OC_IP_FRAGMENTATION):
+        case(HMAN_OC_IP_REASSEMBLY):
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+            *p_AdNew = p_Manip->h_Ad;
+            break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+            *p_AdNew = NULL;
+            break;
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(HMAN_OC_IPSEC):
+            if (p_Manip->cnia)
+                *p_AdNew = p_Manip->h_Ad;
+            else
+            {
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+                *p_AdNew = NULL;
+            }
+            break;
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+        default:
+            break;
+    }
+}
+
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    FmPcdManipUpdateOwner(h_Manip, TRUE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
+            *p_AdNew = NULL;
+            break;
+        default:
+            break;
+    }
+}
+
+t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
+
+
+    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
+    if(!p_Manip)
+        return NULL;
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            /* HmanType1 */
+            err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->rmvParams, p_Manip);
+            break;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        case(HMAN_OC_IP_REASSEMBLY):
+            /* IpReassembly */
+            err = IpReassembly(&p_ManipParams->fragOrReasmParams, p_Manip, p_FmPcd);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            break;
+       case(HMAN_OC_IP_FRAGMENTATION):
+            /* IpFragmentation */
+            err = IpFragmentation(&p_ManipParams->fragOrReasmParams.ipFragParams ,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(HMAN_OC_IPSEC) :
+            err = IPSecManip(p_ManipParams, p_Manip, p_FmPcd);
+            break;
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            /* CapwapFragmentation */
+            err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.capwapFragParams ,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->insrt)
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
+            err = InsrtHdrByTempl(&p_ManipParams->insrtParams, p_Manip, p_FmPcd);
+            break;
+        case(HMAN_OC_CAPWAP_REASSEMBLY) :
+            /*CAPWAP Reassembly*/
+            err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.capwapReasmParams,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->rmv)
+                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
+            err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            /*Application Specific type 1*/
+            err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, (bool)(p_ManipParams->treatFdStatusFieldsAsErrors ? TRUE : FALSE));
+            break;
+       default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+    }
+    if(err)
+     {
+         REPORT_ERROR(MAJOR, err, NO_MSG);
+         ReleaseManipHandler(p_Manip, p_FmPcd);
+         XX_Free(p_Manip);
+         return NULL;
+     }
+     return p_Manip;
+}
+
+t_Error FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_ManipNode)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+
+    if(p_Manip->owner)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
+
+    ReleaseManipHandler(p_Manip,p_FmPcd);
+
+    XX_Free(h_ManipNode);
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsParams)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
+
+    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
+    if(!p_Manip)
+        return NULL;
+
+     switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            /* Indexed statistics */
+            err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
+            break;
+       default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+
+    }
+     if(err)
+     {
+         REPORT_ERROR(MAJOR, err, NO_MSG);
+         ReleaseManipHandler(p_Manip, p_FmPcd);
+         XX_Free(p_Manip);
+         return NULL;
+     }
+     return p_Manip;
+}
+
+#endif /* FM_CAPWAP_SUPPORT */
+#endif /* CONFIG_FMAN_P1023 */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
new file mode 100644
index 0000000..dbe9c1d
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -0,0 +1,310 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.h
+
+ @Description   FM PCD manip...
+*//***************************************************************************/
+#ifndef __FM_MANIP_H
+#define __FM_MANIP_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_cc.h"
+
+
+/***********************************************************************/
+/*          Header manipulations defines                              */
+/***********************************************************************/
+
+#define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
+#define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
+#define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#define HMAN_OC_IPSEC                                           0x34
+#define HMAN_OC_IP_FRAGMENTATION                                0x74
+#define HMAN_OC_IP_REASSEMBLY                                   0xB4
+#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
+#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
+#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
+
+#define HMAN_RMV_HDR                               0x80000000
+#define HMAN_INSRT_INT_FRM_HDR                     0x40000000
+
+#define UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP        6
+#define UDP_UDPCHECKSUM_FIELD_SIZE                  2
+
+#define IP_DSCECN_FIELD_OFFSET_FROM_IP              1
+#define IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP         2
+#define IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP         10
+#define VLAN_TAG_FIELD_OFFSET_FROM_ETH              12
+#define IP_ID_FIELD_OFFSET_FROM_IP                  4
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE               80
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN              8
+#define FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE                 32
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE 4
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE      8
+
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES          0x40000000
+#define FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG           0x10000000
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS    0x08000000
+#define FM_PCD_MANIP_CAPWAP_REASM_PR_COPY                          0x00800000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN             0x80000000
+
+#define FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE               4
+#define FM_PCD_MANIP_INDEXED_STATS_CNIA                     0x20000000
+#define FM_PCD_MANIP_INDEXED_STATS_DPD                      0x10000000
+
+#define FM_PCD_MANIP_IPSEC_CALC_UDP_LENGTH                  0x01000000
+#define FM_PCD_MANIP_IPSEC_CNIA                             0x20000000
+
+#define e_FM_MANIP_CAPWAP_INDX                              0
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define FM_PCD_MANIP_IP_REASM_TABLE_SIZE                    0x40
+#define FM_PCD_MANIP_IP_REASM_TABLE_ALIGN                   8
+
+#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
+#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
+#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES              0x80000000
+#define e_FM_MANIP_IP_INDX                                  1
+#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x000003F0
+#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
+#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x0000000F
+#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  44
+
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct {
+    volatile uint32_t mode;
+    volatile uint32_t autoLearnHashTblPtr;
+    volatile uint32_t intStatsTblPtr;
+    volatile uint32_t reasmFrmDescPoolTblPtr;
+    volatile uint32_t reasmFrmDescIndexPoolTblPtr;
+    volatile uint32_t timeOutTblPtr;
+    volatile uint32_t bufferPoolIdAndRisc1SetIndexes;
+    volatile uint32_t risc23SetIndexes;
+    volatile uint32_t risc4SetIndexesAndExtendedStatsTblPtr;
+    volatile uint32_t extendedStatsTblPtr;
+    volatile uint32_t expirationDelay;
+    volatile uint32_t totalProcessedFragCounter;
+    volatile uint32_t totalUnsuccessfulReasmFramesCounter;
+    volatile uint32_t totalDuplicatedFragCounter;
+    volatile uint32_t totalMalformdFragCounter;
+    volatile uint32_t totalTimeOutCounter;
+    volatile uint32_t totalSetBusyCounter;
+    volatile uint32_t totalRfdPoolBusyCounter;
+    volatile uint32_t totalDiscardedFragsCounter;
+    volatile uint32_t totalMoreThan16FramesCounter;
+    volatile uint32_t internalBufferBusy;
+    volatile uint32_t externalBufferBusy;
+    volatile uint8_t res[16];
+} _PackedType t_CapwapReasmPram;
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+typedef _Packed struct t_IpReasmPram{
+    volatile uint16_t waysNumAndSetSize;
+    volatile uint16_t autoLearnHashKeyMask;
+    volatile uint32_t ipReassCommonPrmTblPtr;
+    volatile uint32_t liodnAlAndAutoLearnHashTblPtrHi;
+    volatile uint32_t autoLearnHashTblPtrLow;
+    volatile uint32_t liodnSlAndAutoLearnSetLockTblPtrHi;
+    volatile uint32_t autoLearnSetLockTblPtrLow;
+    volatile uint16_t minFragSize;
+    volatile uint16_t reserved1;
+    volatile uint32_t totalSuccessfullyReasmFramesCounter;
+    volatile uint32_t totalValidFragmentCounter;
+    volatile uint32_t totalProcessedFragCounter;
+    volatile uint32_t totalMalformdFragCounter;
+    volatile uint32_t totalSetBusyCounter;
+    volatile uint32_t totalDiscardedFragsCounter;
+    volatile uint32_t totalMoreThan16FramesCounter;
+    volatile uint32_t reserved2[2];
+} _PackedType t_IpReasmPram;
+
+typedef _Packed struct t_IpReasmCommonTbl{
+    volatile uint32_t timeoutModeAndFqid;
+    volatile uint32_t reassFrmDescIndexPoolTblPtr;
+    volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
+    volatile uint32_t reassFrmDescPoolPtrLow;
+    volatile uint32_t timeOutTblPtr;
+    volatile uint32_t expirationDelay;
+    volatile uint32_t reseervd1;
+    volatile uint32_t reseervd2;
+    volatile uint32_t totalTimeOutCounter;
+    volatile uint32_t totalRfdPoolBusyCounter;
+    volatile uint32_t totalInternalBufferBusy;
+    volatile uint32_t totalExternalBufferBusy;
+    volatile uint32_t reserved3[4];
+} _PackedType t_IpReasmCommonTbl;
+
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/***********************************************************************/
+/*  Driver's internal structures                                       */
+/***********************************************************************/
+
+typedef struct
+{
+    t_Handle p_AutoLearnHashTbl;
+    t_Handle p_ReassmFrmDescrPoolTbl;
+    t_Handle p_ReassmFrmDescrIndxPoolTbl;
+    t_Handle p_TimeOutTbl;
+    uint8_t  maxNumFramesInProcess;
+    uint8_t  numOfTasks;
+    uint8_t  poolId;
+    uint8_t  prOffset;
+    uint16_t dataOffset;
+    uint8_t  poolIndx;
+    uint8_t  hwPortId;
+    uint32_t fqidForTimeOutFrames;
+    uint32_t timeoutRoutineRequestTime;
+    uint32_t bitFor1Micro;
+} t_FragParams;
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+typedef struct
+{
+    t_Handle h_Frag;
+    t_Handle h_FragId;
+    uint8_t  poolId;
+    uint16_t dataOffset;
+    uint8_t  poolIndx;
+}t_IpFragParams;
+
+typedef struct t_IpReassmParams
+{
+    t_Handle            h_Ipv4Ad;
+    t_Handle            h_Ipv6Ad;
+    e_NetHeaderType     hdr;                /**< Header selection */
+    uint32_t            fqidForTimeOutFrames;
+    uint16_t            dataOffset;
+    t_Handle            h_IpReassCommonParamsTbl;
+    t_Handle            h_Ipv4ReassParamsTblPtr;
+    t_Handle            h_Ipv6ReassParamsTblPtr;
+    t_Handle            h_Ipv4AutoLearnHashTbl;
+    t_Handle            h_Ipv6AutoLearnHashTbl;
+    t_Handle            h_Ipv4AutoLearnSetLockTblPtr;
+    t_Handle            h_Ipv6AutoLearnSetLockTblPtr;
+    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
+    t_Handle            h_ReassmFrmDescrPoolTbl;
+    t_Handle            h_TimeOutTbl;
+    uint32_t            maxNumFramesInProcess;
+    uint32_t            liodnOffset;
+    uint32_t            minFragSize;
+    uint8_t             dataMemId;              /**< Memory partition ID for data buffers */
+    uint32_t            bpid;
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+    uint32_t                        timeoutThresholdForReassmProcess;
+
+}t_IpReassmParams;
+
+typedef struct t_IpCommonReassmParams
+{
+    uint8_t             numOfTasks;
+    uint32_t            bitFor1Micro;
+    t_Handle            h_ReassmFrmDescrPoolTbl;
+    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
+    t_Handle            h_TimeOutTbl;
+}t_IpCommonReassmParams;
+
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+typedef struct{
+    bool                muramAllocate;
+    t_Handle            h_Ad;
+    uint32_t            type;
+    bool                rmv;
+    bool                insrt;
+    uint8_t             *p_Template;
+    t_Handle            h_Frag;
+    bool                frag;
+    bool                reassm;
+    uint16_t            sizeForFragmentation;
+    uint8_t             owner;
+    uint32_t            updateParams;
+    uint32_t            shadowUpdateParams;
+    t_FragParams        fragParams;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    t_IpReassmParams    ipReassmParams;
+    t_IpFragParams      ipFragParams;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    uint8_t             icOffset;
+    uint16_t            ownerTmp;
+    bool                cnia;
+    t_Handle            p_StatsTbl;
+    t_Handle            h_FmPcd;
+} t_FmPcdManip;
+
+typedef struct t_FmPcdCcSavedManipParams
+{
+    union
+    {
+        struct
+        {
+            uint16_t    dataOffset;
+            uint8_t     poolId;
+        }capwapParams;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        struct
+        {
+            uint16_t    dataOffset;
+            uint8_t     poolId;
+        }ipParams;
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+    };
+
+} t_FmPcdCcSavedManipParams;
+
+
+#endif /* __FM_MANIP_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
new file mode 100644
index 0000000..5f21db6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -0,0 +1,1825 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_common.h"
+#include "fm_pcd.h"
+#include "fm_pcd_ipc.h"
+#include "fm_hc.h"
+
+
+static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
+{
+    if(!p_FmPcd->h_Fm)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
+
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+        if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+        if(!p_FmPcd->f_Exception)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
+
+        if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
+
+        if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
+    }
+
+    return E_OK;
+}
+
+static volatile bool blockingFlag = FALSE;
+static void FmPcdIpcMsgCompletionCB(t_Handle   h_FmPcd,
+                                    uint8_t    *p_Msg,
+                                    uint8_t    *p_Reply,
+                                    uint32_t   replyLength,
+                                    t_Error    status)
+{
+    UNUSED(h_FmPcd);UNUSED(p_Msg);UNUSED(p_Reply);UNUSED(replyLength);UNUSED(status);
+    blockingFlag = FALSE;
+}
+
+static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
+                                   uint8_t   *p_Msg,
+                                   uint32_t  msgLength,
+                                   uint8_t   *p_Reply,
+                                   uint32_t  *p_ReplyLength)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+    t_FmPcdIpcMsg       *p_IpcMsg   = (t_FmPcdIpcMsg*)p_Msg;
+    t_FmPcdIpcReply     *p_IpcReply = (t_FmPcdIpcReply*)p_Reply;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength >= sizeof(uint32_t)), E_INVALID_VALUE);
+
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(msgLength);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    ASSERT_COND(p_Msg);
+
+    memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_PCD_MAX_REPLY_SIZE));
+    *p_ReplyLength = 0;
+
+    switch(p_IpcMsg->msgId)
+    {
+        case (FM_PCD_MASTER_IS_ALIVE):
+            *(uint8_t*)(p_IpcReply->replyBody) = 1;
+            p_IpcReply->error = E_OK;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        case (FM_PCD_MASTER_IS_ENABLED):
+            /* count partitions registrations */
+            if(p_FmPcd->enabled)
+                p_FmPcd->numOfEnabledGuestPartitionsPcds++;
+            *(uint8_t*)(p_IpcReply->replyBody)  = (uint8_t)p_FmPcd->enabled;
+            p_IpcReply->error = E_OK;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        case (FM_PCD_GUEST_DISABLE):
+            if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
+            {
+                p_FmPcd->numOfEnabledGuestPartitionsPcds--;
+                p_IpcReply->error = E_OK;
+            }
+            else
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE,("Trying to disable an unregistered partition"));
+                p_IpcReply->error = E_INVALID_STATE;
+            }
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        case(FM_PCD_GET_COUNTER):
+        {
+            e_FmPcdCounters inCounter;
+            uint32_t        outCounter;
+
+            memcpy((uint8_t*)&inCounter, p_IpcMsg->msgBody, sizeof(uint32_t));
+            outCounter = FM_PCD_GetCounter(h_FmPcd, inCounter);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&outCounter, sizeof(uint32_t));
+            p_IpcReply->error = E_OK;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case (FM_PCD_ALLOC_KG_SCHEMES):
+        {
+            t_FmPcdIpcKgSchemesParams   ipcSchemesParams;
+
+            memcpy((uint8_t*)&ipcSchemesParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcKgSchemesParams));
+            err = FmPcdKgAllocSchemes(h_FmPcd,
+                                      ipcSchemesParams.numOfSchemes,
+                                      ipcSchemesParams.guestId,
+                                      p_IpcReply->replyBody);
+            p_IpcReply->error = err;
+            *p_ReplyLength = sizeof(uint32_t) + ipcSchemesParams.numOfSchemes*sizeof(uint8_t);
+            break;
+        }
+        case (FM_PCD_FREE_KG_SCHEMES):
+        {
+            t_FmPcdIpcKgSchemesParams   ipcSchemesParams;
+
+            memcpy((uint8_t*)&ipcSchemesParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcKgSchemesParams));
+            err = FmPcdKgFreeSchemes(h_FmPcd,
+                                     ipcSchemesParams.numOfSchemes,
+                                     ipcSchemesParams.guestId,
+                                     ipcSchemesParams.schemesIds);
+            p_IpcReply->error = err;
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_PCD_ALLOC_KG_CLSPLAN):
+        {
+            t_FmPcdIpcKgClsPlanParams   ipcKgClsPlanParams;
+
+            memcpy((uint8_t*)&ipcKgClsPlanParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcKgClsPlanParams));
+            err = KgAllocClsPlanEntries(h_FmPcd,
+                                        ipcKgClsPlanParams.numOfClsPlanEntries,
+                                        ipcKgClsPlanParams.guestId,
+                                        p_IpcReply->replyBody);
+            p_IpcReply->error = err;
+            *p_ReplyLength =  sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        }
+        case (FM_PCD_FREE_KG_CLSPLAN):
+        {
+            t_FmPcdIpcKgClsPlanParams   ipcKgClsPlanParams;
+
+            memcpy((uint8_t*)&ipcKgClsPlanParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcKgClsPlanParams));
+            err = KgFreeClsPlanEntries(h_FmPcd,
+                                       ipcKgClsPlanParams.numOfClsPlanEntries,
+                                       ipcKgClsPlanParams.guestId,
+                                       ipcKgClsPlanParams.clsPlanBase);
+            p_IpcReply->error = err;
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_PCD_ALLOC_PROFILES):
+        {
+            t_FmPcdIpcPlcrAllocParams   ipcPlcrAllocParams;
+            uint16_t                    profilesBase;
+
+            memcpy((uint8_t*)&ipcPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcPlcrAllocParams));
+            err = PlcrAllocProfiles(h_FmPcd,
+                                    ipcPlcrAllocParams.hardwarePortId,
+                                    ipcPlcrAllocParams.num,
+                                    &profilesBase);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&profilesBase, sizeof(uint16_t));
+            p_IpcReply->error = err;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint16_t);
+            break;
+        }
+        case (FM_PCD_FREE_PROFILES):
+        {
+            t_FmPcdIpcPlcrAllocParams   ipcPlcrAllocParams;
+
+            memcpy((uint8_t*)&ipcPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcPlcrAllocParams));
+            err = PlcrFreeProfiles(h_FmPcd,
+                                   ipcPlcrAllocParams.hardwarePortId,
+                                   ipcPlcrAllocParams.num,
+                                   ipcPlcrAllocParams.plcrProfilesBase);
+            p_IpcReply->error = err;
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_PCD_ALLOC_SHARED_PROFILES):
+        {
+            uint16_t            numOfProfiles;
+            uint16_t            profilesIds[FM_PCD_PLCR_NUM_ENTRIES];
+
+            memcpy((uint8_t*)&numOfProfiles, p_IpcMsg->msgBody, sizeof(uint16_t));
+            err =  PlcrAllocSharedProfiles(h_FmPcd,
+                                           numOfProfiles,
+                                           profilesIds);
+            p_IpcReply->error = err;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&profilesIds, numOfProfiles * sizeof(uint16_t));
+            *p_ReplyLength = sizeof(uint32_t) + (numOfProfiles * sizeof(uint16_t)); /* num-of-shared-profiles */
+            break;
+        }
+        case (FM_PCD_FREE_SHARED_PROFILES):
+        {
+            t_FmPcdIpcSharedPlcrAllocParams   ipcSharedPlcrAllocParams;
+
+            memcpy((uint8_t*)&ipcSharedPlcrAllocParams, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcSharedPlcrAllocParams));
+            PlcrFreeSharedProfiles(h_FmPcd,
+                                   ipcSharedPlcrAllocParams.num,
+                                   ipcSharedPlcrAllocParams.profilesIds);
+            break;
+        }
+        case(FM_PCD_GET_SW_PRS_OFFSET):
+        {
+            t_FmPcdIpcSwPrsLable   ipcSwPrsLable;
+            uint32_t               swPrsOffset;
+
+            memcpy((uint8_t*)&ipcSwPrsLable, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcSwPrsLable));
+            swPrsOffset =
+                FmPcdGetSwPrsOffset(h_FmPcd,
+                                    (e_NetHeaderType)ipcSwPrsLable.enumHdr,
+                                    ipcSwPrsLable.indexPerHdr);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&swPrsOffset, sizeof(uint32_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case(FM_PCD_PRS_INC_PORT_STATS):
+        {
+            t_FmPcdIpcPrsIncludePort   ipcPrsIncludePort;
+
+            memcpy((uint8_t*)&ipcPrsIncludePort, p_IpcMsg->msgBody, sizeof(t_FmPcdIpcPrsIncludePort));
+            PrsIncludePortInStatistics(h_FmPcd,
+                                       ipcPrsIncludePort.hardwarePortId,
+                                       ipcPrsIncludePort.include);
+           break;
+        }
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+       case(FM_PCD_DUMP_REGS):
+            if((err = FM_PCD_DumpRegs(h_FmPcd)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+       case(FM_PCD_KG_DUMP_REGS):
+            if((err = FM_PCD_KgDumpRegs(h_FmPcd)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+       case(FM_PCD_PLCR_DUMP_REGS):
+            if((err = FM_PCD_PlcrDumpRegs(h_FmPcd)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+       case(FM_PCD_PLCR_PROFILE_DUMP_REGS):
+       {
+            t_Handle h_Profile;
+            memcpy((uint8_t*)&h_Profile, p_IpcMsg->msgBody, sizeof(t_Handle));
+            if((err = FM_PCD_PlcrProfileDumpRegs(h_FmPcd, h_Profile)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+
+       }
+       case(FM_PCD_PRS_DUMP_REGS):
+            if((err = FM_PCD_PrsDumpRegs(h_FmPcd)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+        default:
+            *p_ReplyLength = 0;
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+
+void FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId)
+{
+    p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = clsPlanGrpId;
+}
+
+t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_GrpParams)
+{
+    uint8_t netEnvId = p_GrpParams->netEnvId;
+    int     i, k, j;
+
+    if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
+    {
+        p_GrpParams->grpExists = TRUE;
+        p_GrpParams->clsPlanGrpId = p_FmPcd->netEnvs[netEnvId].clsPlanGrpId;
+        return E_OK;
+    }
+
+    for(i=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* if an option exists, add it to the opts list */
+            if(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+            {
+                /* check if this option already exists, add if it doesn't */
+                for(j = 0;j<p_GrpParams->numOfOptions;j++)
+                {
+                    if(p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                        break;
+                }
+                p_GrpParams->optVectors[j] |= p_FmPcd->netEnvs[netEnvId].unitsVectors[i];
+                if(j == p_GrpParams->numOfOptions)
+                {
+                    p_GrpParams->options[p_GrpParams->numOfOptions] = p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt;
+                    p_GrpParams->numOfOptions++;
+                }
+            }
+        }
+
+    if(p_GrpParams->numOfOptions == 0)
+    {
+        if(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
+        {
+            p_GrpParams->grpExists = TRUE;
+            p_GrpParams->clsPlanGrpId = p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
+        }
+    }
+
+    return E_OK;
+
+}
+
+t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector)
+{
+    uint8_t     j,k;
+
+    *p_Vector = 0;
+
+    for(j=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;j++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            if(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].opt == opt)
+                *p_Vector |= p_FmPcd->netEnvs[netEnvId].unitsVectors[j];
+        }
+
+    if (!*p_Vector)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested option was not defined for this Network Environment Characteristics module"));
+    else
+        return E_OK;
+}
+
+t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
+{
+    int                     i;
+
+    p_Params->vector = 0;
+    for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
+    {
+        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
+        ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
+        p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
+    }
+
+    return E_OK;
+}
+
+bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector)
+{
+    int     i=0, k;
+    /* check whether a given unit may be used by non-clsPlan users. */
+    /* first, recognize the unit by its vector */
+    while (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+    {
+        if (p_FmPcd->netEnvs[netEnvId].unitsVectors[i] == unitVector)
+        {
+            for (k=0;
+                 ((k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) &&
+                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
+                 k++)
+                /* check that no option exists */
+                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    return FALSE;
+            break;
+        }
+        i++;
+    }
+    /* assert that a unit was found to mach the vector */
+    ASSERT_COND(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE);
+
+    return TRUE;
+}
+bool  FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int         i, k;
+
+    ASSERT_COND(p_FmPcd);
+
+    for(i=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+            if (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr)
+                return TRUE;
+    for(i=0;(p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_PRIVATE_HDRS) ;i++)
+        if (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr)
+            return TRUE;
+
+    return FALSE;
+}
+
+e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr)
+{
+    int         i;
+
+    ASSERT_COND(p_FmPcd);
+
+    for(i=0;(p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_PRIVATE_HDRS) ;i++)
+        if (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr)
+            return p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].aliasHdr;
+
+    return HEADER_TYPE_NONE;
+}
+
+void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint16_t        swPortIndex = 0;
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort = h_FmPort;
+}
+
+uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
+}
+
+uint32_t FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->netEnvs[netEnvId].macsecVector;
+}
+
+void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners++;
+}
+
+void FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ASSERT_COND(((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners);
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners--;
+}
+
+uint32_t FmPcdLock(t_Handle h_FmPcd)
+{
+    return XX_LockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock);
+}
+
+void FmPcdUnlock(t_Handle h_FmPcd, uint32_t intFlags)
+{
+    XX_UnlockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock, intFlags);
+}
+
+t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
+{
+    ASSERT_COND(h_FmPcd);
+    SANITY_CHECK_RETURN_VALUE(((t_FmPcd*)h_FmPcd)->h_Hc, E_INVALID_HANDLE, NULL);
+    return ((t_FmPcd*)h_FmPcd)->h_Hc;
+}
+
+/**********************************************************************************************************/
+/*              API                                                                                       */
+/**********************************************************************************************************/
+
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcd             *p_FmPcd = NULL;
+    t_FmPhysAddr        physicalMuramBase;
+    uint8_t             i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdParams, E_INVALID_HANDLE,NULL);
+
+    p_FmPcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
+    if (!p_FmPcd)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd"));
+        return NULL;
+    }
+    memset(p_FmPcd, 0, sizeof(t_FmPcd));
+
+    p_FmPcd->p_FmPcdDriverParam = (t_FmPcdDriverParam *) XX_Malloc(sizeof(t_FmPcdDriverParam));
+    if (!p_FmPcd->p_FmPcdDriverParam)
+    {
+        XX_Free(p_FmPcd);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Driver Param"));
+        return NULL;
+    }
+    memset(p_FmPcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
+
+    p_FmPcd->h_Fm = p_FmPcdParams->h_Fm;
+    p_FmPcd->guestId = FmGetGuestId(p_FmPcd->h_Fm);
+    p_FmPcd->h_FmMuram = FmGetMuramHandle(p_FmPcd->h_Fm);
+    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
+    p_FmPcd->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+
+    for(i = 0; i<FM_MAX_NUM_OF_PORTS; i++)
+        p_FmPcd->netEnvs[i].clsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    if (p_FmPcdParams->useHostCommand)
+    {
+        t_FmHcParams    hcParams;
+
+        memset(&hcParams, 0, sizeof(hcParams));
+        hcParams.h_Fm = p_FmPcd->h_Fm;
+        hcParams.h_FmPcd = (t_Handle)p_FmPcd;
+        memcpy((uint8_t*)&hcParams.params, (uint8_t*)&p_FmPcdParams->hc, sizeof(t_FmPcdHcParams));
+        p_FmPcd->h_Hc = FmHcConfigAndInit(&hcParams);
+        if (!p_FmPcd->h_Hc)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd HC"));
+            FM_PCD_Free(p_FmPcd);
+            return NULL;
+        }
+    }
+    else if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No Host Command defined for a guest partition."));
+
+    if(p_FmPcdParams->kgSupport)
+    {
+        p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdKg)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Keygen"));
+            FM_PCD_Free(p_FmPcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->plcrSupport)
+    {
+        p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdPlcr)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Policer"));
+            FM_PCD_Free(p_FmPcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->prsSupport)
+    {
+        p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
+        if(!p_FmPcd->p_FmPcdPrs)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Parser"));
+            FM_PCD_Free(p_FmPcd);
+            return NULL;
+        }
+    }
+
+    p_FmPcd->h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPcd->h_Spinlock)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd spinlock"));
+        FM_PCD_Free(p_FmPcd);
+        return NULL;
+    }
+
+    p_FmPcd->numOfEnabledGuestPartitionsPcds = 0;
+
+    p_FmPcd->f_Exception                = p_FmPcdParams->f_Exception;
+    p_FmPcd->f_FmPcdIndexedException    = p_FmPcdParams->f_ExceptionId;
+    p_FmPcd->h_App                      = p_FmPcdParams->h_App;
+
+    return p_FmPcd;
+}
+
+t_Error FM_PCD_Init(t_Handle h_FmPcd)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error         err = E_OK;
+    t_FmPcdIpcMsg   *p_msg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        uint8_t                 isMasterAlive = 0;
+        uint32_t                replyLength;
+        t_FmPcdIpcReply         *p_reply = NULL;
+
+        memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+        if(Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm), p_FmPcd->guestId) != (p_FmPcd->guestId<10 ? 10:11))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+        p_FmPcd->h_IpcSession = XX_IpcInitSession(p_FmPcd->fmPcdIpcHandlerModuleName, p_FmPcd->fmPcdModuleName);
+        if (p_FmPcd->h_IpcSession == NULL)
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM PCD Guest %d IPC session", p_FmPcd->guestId));
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_MASTER_IS_ALIVE;
+        p_msg->msgBody[0] = p_FmPcd->guestId;
+        blockingFlag = TRUE;
+
+        do
+        {
+            replyLength = sizeof(uint32_t) + sizeof(isMasterAlive);
+            err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                                     (uint8_t*)p_msg,
+                                                     sizeof(p_msg->msgId)+sizeof(p_FmPcd->guestId),
+                                                     (uint8_t*)p_reply,
+                                                     &replyLength,
+                                                     FmPcdIpcMsgCompletionCB,
+                                                     h_FmPcd);
+            if (err != E_OK) {
+                XX_Free(p_msg);
+                XX_Free(p_reply);
+                REPORT_ERROR(MAJOR, err, NO_MSG);
+            }
+            while(blockingFlag) ;
+            if(replyLength != (sizeof(uint32_t) + sizeof(isMasterAlive))) {
+                XX_Free(p_msg);
+                XX_Free(p_reply);
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            }
+            isMasterAlive = *(uint8_t*)(p_reply->replyBody);
+        } while (!isMasterAlive);
+        XX_Free(p_msg);
+        XX_Free(p_reply);
+    }
+
+    CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
+
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+         /* register to inter-core messaging mechanism */
+        memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsgCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    XX_Free(p_FmPcd->p_FmPcdDriverParam);
+    p_FmPcd->p_FmPcdDriverParam = NULL;
+
+    FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_Free(t_Handle h_FmPcd)
+{
+    t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
+    t_Error                             err = E_OK;
+
+    if(p_FmPcd->enabled)
+        FM_PCD_Disable(p_FmPcd);
+
+    if (p_FmPcd->h_Spinlock)
+        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
+
+    if(p_FmPcd->p_FmPcdDriverParam)
+    {
+        XX_Free(p_FmPcd->p_FmPcdDriverParam);
+        p_FmPcd->p_FmPcdDriverParam = NULL;
+    }
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        if((err = KgFree(p_FmPcd)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_FmPcd->p_FmPcdKg);
+        p_FmPcd->p_FmPcdKg = NULL;
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        if((err = PlcrFree(p_FmPcd)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        XX_Free(p_FmPcd->p_FmPcdPlcr);
+        p_FmPcd->p_FmPcdPlcr = NULL;
+    }
+
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        if(p_FmPcd->guestId == NCSW_MASTER_ID)
+            PrsFree(p_FmPcd);
+        XX_Free(p_FmPcd->p_FmPcdPrs);
+        p_FmPcd->p_FmPcdPrs = NULL;
+    }
+
+    if (p_FmPcd->h_Hc)
+    {
+        FmHcFree(p_FmPcd->h_Hc);
+        p_FmPcd->h_Hc = NULL;
+    }
+
+    XX_IpcUnregisterMsgHandler(p_FmPcd->fmPcdModuleName);
+
+    FmUnregisterPcd(p_FmPcd->h_Fm);
+
+    XX_Free(p_FmPcd);
+    return E_OK;
+}
+
+t_Error FM_PCD_Enable(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        if(p_FmPcd->p_FmPcdKg)
+        {
+            err = KgEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        if(p_FmPcd->p_FmPcdPlcr)
+        {
+            err = PlcrEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        if(p_FmPcd->p_FmPcdPrs)
+        {
+            err = PrsEnable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        p_FmPcd->enabled = TRUE;
+    }
+    else
+    {
+        uint8_t         enabled;
+        uint32_t        replyLength;
+        t_FmPcdIpcMsg   *p_msg = NULL;
+        t_FmPcdIpcReply *p_reply = NULL;
+
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_MASTER_IS_ENABLED;
+        replyLength = sizeof(uint32_t) + sizeof(enabled);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        if (err != E_OK) {
+            XX_Free(p_reply);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        if (replyLength != sizeof(uint32_t) + sizeof(enabled)) {
+            XX_Free(p_reply);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        }
+
+        p_FmPcd->enabled = (bool)!!(*(uint8_t*)(p_reply->replyBody));
+        XX_Free(p_reply);
+
+        if (!p_FmPcd->enabled)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-PCD master should be enabled first!"));
+    }
+
+    return E_OK;
+}
+
+t_Error FM_PCD_Disable(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+    uint32_t            replyLength;
+    t_FmPcdIpcMsg       *p_msg = NULL;
+    t_FmPcdIpcReply     *p_reply = NULL;
+
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
+        if(p_FmPcd->p_FmPcdKg)
+        {
+            err = KgDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        if(p_FmPcd->p_FmPcdPlcr)
+        {
+            err = PlcrDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        if(p_FmPcd->p_FmPcdPrs)
+        {
+            err = PrsDisable(p_FmPcd);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        p_FmPcd->enabled = FALSE;
+
+        return E_OK;
+    }
+
+    p_msg = XX_Malloc(sizeof(*p_msg));
+    if (!p_msg)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+    p_reply = XX_Malloc(sizeof(*p_reply));
+    if (!p_reply) {
+        XX_Free(p_msg);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+    }
+    memset(p_msg, 0, sizeof(*p_msg));
+    memset(p_reply, 0, sizeof(*p_reply));
+
+    p_msg->msgId = FM_PCD_GUEST_DISABLE;
+    replyLength = sizeof(uint32_t);
+    err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)p_msg,
+                                     sizeof(p_msg->msgId),
+                                     (uint8_t*)p_reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL);
+    XX_Free(p_msg);
+    if (err != E_OK) {
+        XX_Free(p_reply);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = (t_Error)(p_reply->error);
+    XX_Free(p_reply);
+
+    if (replyLength != sizeof(uint32_t))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+    return err;
+}
+
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                intFlags, specialUnits = 0;
+    uint8_t                 bitId = 0;
+    uint8_t                 i, j, k;
+    uint8_t                 netEnvCurrId;
+    uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
+    bool                    ipsecAhExists = FALSE, ipsecEspExists = FALSE, shim1Selected = FALSE;
+    uint8_t                 hdrNum;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    /* find a new netEnv */
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->netEnvs[i].used)
+            break;
+
+    if(i== FM_MAX_NUM_OF_PORTS)
+    {
+        REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return NULL;
+    }
+
+    p_FmPcd->netEnvs[i].used = TRUE;
+
+    if (!TRY_LOCK(NULL, &p_FmPcd->netEnvs[i].lock))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return NULL;
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    netEnvCurrId = (uint8_t)i;
+
+    /* clear from previous use */
+    memset(&p_FmPcd->netEnvs[netEnvCurrId].units, 0, FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS * sizeof(t_FmPcdDistinctionUnit));
+    memset(&p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs, 0, FM_PCD_MAX_NUM_OF_PRIVATE_HDRS * sizeof(t_FmPcdNetEnvAliases));
+    memcpy(&p_FmPcd->netEnvs[netEnvCurrId].units, p_NetEnvParams->units, p_NetEnvParams->numOfDistinctionUnits*sizeof(t_FmPcdDistinctionUnit));
+    p_FmPcd->netEnvs[netEnvCurrId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* if an option exists, check that other headers are not the same header
+            without option */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
+            {
+                for(j=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE)
+                        && (j < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;j++)
+                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                        !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
+                    {
+                        REPORT_ERROR(MINOR, E_FULL, ("Illegal unit - header with opt may not be interchangable with the same header without opt"));
+                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        return NULL;
+                    }
+            }
+        }
+
+    /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* Some headers pairs may not be defined on different units as the parser
+            doesn't distinguish */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
+            {
+                if (ipsecEspExists && (ipsecEspUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                   return NULL;
+                }
+                else
+                {
+                    ipsecAhUnit = i;
+                    ipsecAhExists = TRUE;
+                }
+            }
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
+            {
+                if (ipsecAhExists && (ipsecAhUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                else
+                {
+                    ipsecEspUnit = i;
+                    ipsecEspExists = TRUE;
+                }
+            }
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
+            {
+                /* TODO - general coding. choose the free shim header */
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_ENCAP_ESP;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM1;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+            }
+       }
+
+    /* if private header (shim), check that no other headers specified */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+    {
+        if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
+            {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
+                RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                return NULL;
+            }
+    }
+
+    for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
+    {
+        if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
+            {
+                case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                    if (shim1Selected)
+                    {
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
+                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        return NULL;
+                    }
+                    shim1Selected = TRUE;
+                    p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
+                break;
+                case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                    p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Requested SHIM not supported"));
+            }
+        else
+        {
+            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
+
+            if(IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+                p_FmPcd->netEnvs[netEnvCurrId].macsecVector = p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
+        }
+    }
+
+    /* define a set of hardware parser LCV's according to the defined netenv */
+
+    /* set an array of LCV's for each header in the netEnv */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        /* private headers have no LCV in the hard parser */
+        if (!IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+        {
+            for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                    && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+            {
+                GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
+                if (hdrNum == ILLEGAL_HDR_NUM)
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
+            }
+        }
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+
+    return UINT_TO_PTR((uint64_t)netEnvCurrId+1);
+}
+
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     netEnvId = (uint8_t)(PTR_TO_UINT(h_NetEnv)-1);
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (!TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->netEnvs[netEnvId].lock))
+        return ERROR_CODE(E_BUSY);
+    /* check that no port is bound to this netEnv */
+    if(p_FmPcd->netEnvs[netEnvId].owners)
+    {
+       RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
+    }
+    p_FmPcd->netEnvs[netEnvId].used= FALSE;
+    p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    memset(p_FmPcd->netEnvs[netEnvId].units, 0, sizeof(t_FmPcdIntDistinctionUnit)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memset(p_FmPcd->netEnvs[netEnvId].unitsVectors, 0, sizeof(uint32_t)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memset(p_FmPcd->netEnvs[netEnvId].lcvs, 0, sizeof(uint32_t)*FM_PCD_PRS_NUM_OF_HDRS);
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
+
+    return E_OK;
+}
+
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_STATE);
+
+    FmHcTxConf(p_FmPcd->h_Hc, p_Fd);
+}
+
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                replyLength, outCounter = 0;
+    t_FmPcdIpcMsg           *p_msg = NULL;
+    t_FmPcdIpcReply         *p_reply = NULL;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_GET_COUNTER;
+        memcpy(p_msg->msgBody, (uint8_t *)&counter, sizeof(uint32_t));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) +sizeof(uint32_t),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+
+        memcpy((uint8_t*)&outCounter, p_reply->replyBody, sizeof(uint32_t));
+        XX_Free(p_reply);
+
+        if (err != E_OK) {
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t)) {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        }
+
+        return outCounter;
+    }
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            /* check that counters are enabled */
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
+
+        /*Policer statictics*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
+
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+    t_FmPcdIpcMsg       *p_msg = NULL;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_DUMP_REGS;
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)p_msg,
+                                 sizeof(p_msg->msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+        XX_Free(p_msg);
+        return err;
+    }
+    if (p_FmPcd->p_FmPcdKg)
+        return FM_PCD_KgDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPlcr)
+        return FM_PCD_PlcrDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPrs)
+        return FM_PCD_PrsDumpRegs(h_FmPcd);
+    return E_OK;
+}
+
+t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_STATE);
+
+    return FmHcDumpRegs(p_FmPcd->h_Hc);
+}
+
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0, tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetException - guest mode!"));
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+                if(!p_FmPcd->p_FmPcdKg)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if(!p_FmPcd->p_FmPcdPlcr)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                if(!p_FmPcd->p_FmPcdPrs)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+
+        }
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+                else
+                    tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_SINGLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+             default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+        }
+        /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
+           Driver may disable them automatically, depending on driver's status */
+        if(enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
+            FmEnableRamsEcc(p_FmPcd->h_Fm);
+        if(!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
+            FmDisableRamsEcc(p_FmPcd->h_Fm);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ForceIntr - guest mode!"));
+
+    switch(exception)
+    {
+        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+           if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
+
+    }
+    switch(exception)
+    {
+        case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
+            break;
+        case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+
+t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ModifyCounter - guest mode!"));
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - Policer is not working"));
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
+             break;
+       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
+             break;
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
+            break;
+
+        /*Policer counters*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+
+return E_OK;
+}
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+t_Error FM_PCD_RegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpReassmTimeoutParams ccIpReassmTimeoutParams = {0};
+    uint8_t  result;
+    uint32_t bitFor1Micro, tsbs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    tsbs = 31 - bitFor1Micro + 1;
+
+    ccIpReassmTimeoutParams.tsbsAndIprcpt =  (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.tsbsAndIprcpt |= (tsbs << 24);
+
+    FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams);
+
+    result = ccIpReassmTimeoutParams.result;
+
+    switch (result)
+    {
+        case (0):
+            return E_OK;
+        case (1):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
+        case (2):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
+        case (3):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, (""));
+    }
+    return E_OK;
+}
+
+t_Error FM_PCD_UnregisterReassmPort(t_Handle h_FmPcd)
+{
+    uint8_t result;
+
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpReassmTimeoutParams ccIpReassmTimeoutParams = {0};
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ccIpReassmTimeoutParams.subCmd = 1; /*Disable Timeout Task*/
+
+    return FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams);
+
+    switch (result)
+    {
+        case (0):
+            return E_OK;
+        case (1):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, (""));
+        case (2):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, (""));
+        case (3):
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Disable Timeout Task with invalid IPRCPT"));
+    }
+
+    return E_OK;
+}
+
+t_Error FM_PCD_FragmInitialization(t_Handle h_FmPcd, uint8_t scratchBpid)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpFragInitParams ccIpFragInitParams = {0};
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ccIpFragInitParams.numBuffers = 100; /*TODO - calc the value according to spec requirement */
+    ccIpFragInitParams.bufferPoolId = scratchBpid;
+
+    FmHcPcdCcIpFrag(p_FmPcd->h_Hc, &ccIpFragInitParams);
+
+    return E_OK;
+}
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
new file mode 100644
index 0000000..378a6a3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -0,0 +1,715 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_H
+#define __FM_PCD_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_pcd_ext.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_PCD
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+ @{
+*//***************************************************************************/
+
+/****************************/
+/* Network defines          */
+/****************************/
+#define UDP_HEADER_SIZE     8
+
+#define ESP_SPI_OFFSET      0
+#define ESP_SPI_SIZE        4
+#define ESP_SEQ_NUM_OFFSET  ESP_SPI_SIZE
+#define ESP_SEQ_NUM_SIZE    4
+
+/****************************/
+/* General defines          */
+/****************************/
+#define ILLEGAL_CLS_PLAN    0xff
+#define ILLEGAL_NETENV      0xff
+/****************************/
+/* Error defines           */
+/****************************/
+#define FM_PCD_EX_KG_DOUBLE_ECC                     0x80000000
+#define FM_PCD_EX_KG_KEYSIZE_OVERFLOW               0x40000000
+
+#define FM_PCD_EX_PLCR_DOUBLE_ECC                   0x20000000
+#define FM_PCD_EX_PLCR_INIT_ENTRY_ERROR             0x10000000
+#define FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE      0x08000000
+#define FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE       0x04000000
+
+#define FM_PCD_EX_PRS_DOUBLE_ECC                    0x02000000
+#define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
+
+#define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
+switch(exception){                                                  \
+    case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                          \
+        bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
+    case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                        \
+        bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
+    case e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW:                    \
+        bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
+    case e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR:                  \
+        bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
+    case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
+        bitMask = FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE; break;    \
+    case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:            \
+        bitMask = FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE; break;     \
+    case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_DOUBLE_ECC; break;                  \
+    case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
+    default: bitMask = 0;break;}
+
+/***********************************************************************/
+/*          SW parser L4 shells patch                                  */
+/***********************************************************************/
+#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
+#define SW_PRS_L4_PATCH                         \
+{   0x31,0x92,0x02,0x1f,0x00,0x32,0x00,0x78,    \
+    0x00,0x34,0x32,0xf0,0x00,0x50,0x00,0x0c,    \
+    0x28,0x5e,0x83,0x8e,0x29,0x32,0xaf,0x8e,    \
+    0x31,0xb2,0x9f,0xff,0x00,0x06,0xaf,0xbf,    \
+    0x00,0x06,0x29,0x36,0x00,0x01,0x1b,0xff,    \
+    0x32,0xf0,0x00,0x50,0x00,0x08,0x28,0x5e,    \
+    0x08,0x99,0x00,0x00,0x9f,0x8e,0x31,0xb2,    \
+    0x9f,0xff,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x00,0x00,0x00,0x00,0x00,0x00};
+
+#define SW_PRS_L4_PATCH_SIZE                120
+#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+
+/****************************/
+/* Parser defines           */
+/****************************/
+/* masks */
+#define PRS_ERR_CAP                         0x80000000
+#define PRS_ERR_TYPE_DOUBLE                 0x40000000
+#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
+#define PRS_ERR_ADDR_MASK                   0x000001FF
+#define FM_PCD_PRS_RPIMAC_EN                0x00000001
+#define FM_PCD_PRS_SINGLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
+#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
+#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
+
+/* others */
+#define PRS_MAX_CYCLE_LIMIT                 8191
+#define PRS_SW_DATA                         0x00000800
+#define PRS_REGS_OFFSET                     0x00000840
+
+#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
+    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
+
+#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
+    bitMask = 0x80000000>>prsPortId
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* Masks */
+#define FM_PCD_KG_KGGCR_EN                      0x80000000
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_ERR_CAP                              0x80000000
+#define KG_ERR_TYPE_DOUBLE                      0x40000000
+#define KG_ERR_ADDR_MASK                        0x00000FFF
+#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
+#define KG_SCH_MODE_EN                          0x80000000
+
+/* shifts */
+#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
+#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
+
+/* others */
+#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
+#define NO_VALIDATION                           0x70
+#define KG_ACTION_REG_TO                        1024
+#define KG_MAX_PROFILE                          255
+#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+
+typedef struct {
+    bool        known;
+    uint8_t     id;
+} t_FmPcdKgSchemesExtractsEntry;
+
+typedef struct {
+    t_FmPcdKgSchemesExtractsEntry extractsArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+} t_FmPcdKgSchemesExtracts;
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+
+/* masks */
+#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
+#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
+#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
+#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
+#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
+#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
+#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
+#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
+#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
+#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
+#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
+#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
+#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
+#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
+#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
+#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
+#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
+#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
+#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
+#define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
+#define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
+#define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
+
+#define FM_PCD_PLCR_NIA_VALID                 0x80000000
+
+#define FM_PCD_PLCR_GCR_EN                    0x80000000
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
+#define FM_PCD_PLCR_GCR_DAR                   0x20000000
+#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
+#define FM_PCD_PLCR_NIA_ABS                   0x00000100
+
+#define FM_PCD_PLCR_GSR_BSY                   0x80000000
+#define FM_PCD_PLCR_GSR_DQS                   0x60000000
+#define FM_PCD_PLCR_GSR_RPB                   0x20000000
+#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
+#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
+#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
+#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
+
+#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
+#define FM_PCD_PLCR_EVR_AAC                   0x40000000
+
+#define FM_PCD_PLCR_PAR_PSI                   0x20000000
+#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
+/* PWSEL Selctive select options */
+#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
+#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
+
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
+                                                           1-> 2^N specific locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
+                                                           2-> 2^(N-1) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
+                                                           4-> 2^(N-2) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
+                                                           8->2^(N-3) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
+                                                           16-> 2^(N-4) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
+                                                           32-> 2^(N-5) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
+                                                           64-> 2^(N-6) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
+                                                            128-> 2^(N-7) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
+                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
+
+#define FM_PCD_PLCR_PMR_V                     0x80000000
+#define PLCR_ERR_ECC_CAP                      0x80000000
+#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
+#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
+#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
+
+#define PLCR_ERR_UNINIT_CAP                   0x80000000
+#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
+#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
+#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
+
+/* shifts */
+#define PLCR_ERR_ECC_PNUM_SHIFT               4
+#define PLCR_ERR_UNINIT_PID_SHIFT             16
+
+#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
+
+/* others */
+#define WAIT_FOR_PLCR_EVR_AAC \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_evr);\
+        if (!( tmpReg32 & FM_PCD_PLCR_EVR_AAC)) break;\
+        count++;\
+    }\
+}
+
+#define WAIT_FOR_PLCR_PAR_GO \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_par);\
+        if (!( tmpReg32 & FM_PCD_PLCR_PAR_GO)) break;\
+        count++; \
+    }\
+}
+
+#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
+
+/****************************/
+/* Defaults                 */
+/****************************/
+#define DEFAULT_plcrAutoRefresh                 FALSE
+#define DEFAULT_prsMaxParseCycleLimit           0
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+#define DEFAULT_fmPcdPlcrExceptions             0
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
+
+#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
+#define DEFAULT_numOfUsedProfilesPerWindow      16
+#define DEFAULT_numOfSharedPlcrProfiles         4
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+typedef _Packed struct {
+   volatile uint32_t kgoe_sp;
+   volatile uint32_t kgoe_cpp;
+} _PackedType t_FmPcdKgPortConfigRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kgcpe[8];
+} _PackedType t_FmPcdKgClsPlanRegs;
+
+typedef _Packed union {
+    t_FmPcdKgInterModuleSchemeRegs  schemeRegs;
+    t_FmPcdKgPortConfigRegs         portRegs;
+    t_FmPcdKgClsPlanRegs            clsPlanRegs;
+} _PackedType u_FmPcdKgIndirectAccessRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kggcr;
+    volatile uint32_t res0;
+    volatile uint32_t res1;
+    volatile uint32_t kgeer;
+    volatile uint32_t kgeeer;
+    volatile uint32_t res2;
+    volatile uint32_t res3;
+    volatile uint32_t kgseer;
+    volatile uint32_t kgseeer;
+    volatile uint32_t kggsr;
+    volatile uint32_t kgtpc;
+    volatile uint32_t kgserc;
+    volatile uint32_t res4[4];
+    volatile uint32_t kgfdor;
+    volatile uint32_t kggdv0r;
+    volatile uint32_t kggdv1r;
+    volatile uint32_t res5[5];
+    volatile uint32_t kgfer;
+    volatile uint32_t kgfeer;
+    volatile uint32_t res6[38];
+    u_FmPcdKgIndirectAccessRegs   indirectAccessRegs;
+    volatile uint32_t res[42];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
+    volatile uint32_t kgar;
+} _PackedType t_FmPcdKgRegs;
+
+typedef _Packed struct {
+/* General Configuration and Status Registers */
+    volatile uint32_t fmpl_gcr;         /* 0x000 FMPL_GCR  - FM Policer General Configuration */
+    volatile uint32_t fmpl_gsr;         /* 0x004 FMPL_GSR  - FM Policer Global Status Register */
+    volatile uint32_t fmpl_evr;         /* 0x008 FMPL_EVR  - FM Policer Event Register */
+    volatile uint32_t fmpl_ier;         /* 0x00C FMPL_IER  - FM Policer Interrupt Enable Register */
+    volatile uint32_t fmpl_ifr;         /* 0x010 FMPL_IFR  - FM Policer Interrupt Force Register */
+    volatile uint32_t fmpl_eevr;        /* 0x014 FMPL_EEVR - FM Policer Error Event Register */
+    volatile uint32_t fmpl_eier;        /* 0x018 FMPL_EIER - FM Policer Error Interrupt Enable Register */
+    volatile uint32_t fmpl_eifr;        /* 0x01C FMPL_EIFR - FM Policer Error Interrupt Force Register */
+/* Global Statistic Counters */
+    volatile uint32_t fmpl_rpcnt;       /* 0x020 FMPL_RPC  - FM Policer RED Packets Counter */
+    volatile uint32_t fmpl_ypcnt;       /* 0x024 FMPL_YPC  - FM Policer YELLOW Packets Counter */
+    volatile uint32_t fmpl_rrpcnt;      /* 0x028 FMPL_RRPC - FM Policer Recolored RED Packet Counter */
+    volatile uint32_t fmpl_rypcnt;      /* 0x02C FMPL_RYPC - FM Policer Recolored YELLOW Packet Counter */
+    volatile uint32_t fmpl_tpcnt;       /* 0x030 FMPL_TPC  - FM Policer Total Packet Counter */
+    volatile uint32_t fmpl_flmcnt;      /* 0x034 FMPL_FLMC - FM Policer Frame Length Mismatch Counter */
+    volatile uint32_t fmpl_res0[21];    /* 0x038 - 0x08B Reserved */
+/* Profile RAM Access Registers */
+    volatile uint32_t fmpl_par;         /* 0x08C FMPL_PAR    - FM Policer Profile Action Register*/
+    t_FmPcdPlcrInterModuleProfileRegs profileRegs;
+/* Error Capture Registers */
+    volatile uint32_t fmpl_serc;        /* 0x100 FMPL_SERC - FM Policer Soft Error Capture */
+    volatile uint32_t fmpl_upcr;        /* 0x104 FMPL_UPCR - FM Policer Uninitialized Profile Capture Register */
+    volatile uint32_t fmpl_res2;        /* 0x108 Reserved */
+/* Debug Registers */
+    volatile uint32_t fmpl_res3[61];    /* 0x10C-0x200 Reserved Debug*/
+/* Profile Selection Mapping Registers Per Port-ID (n=1-11, 16) */
+    volatile uint32_t fmpl_dpmr;        /* 0x200 FMPL_DPMR - FM Policer Default Mapping Register */
+    volatile uint32_t fmpl_pmr[63];     /*+default 0x204-0x2FF FMPL_PMR1 - FMPL_PMR63, - FM Policer Profile Mapping Registers.
+                                           (for port-ID 1-11, only for supported Port-ID registers) */
+} _PackedType t_FmPcdPlcrRegs;
+
+typedef _Packed struct {
+    volatile uint32_t rpclim;
+    volatile uint32_t rpimac;
+    volatile uint32_t pmeec;
+    volatile uint32_t res1[5];
+    volatile uint32_t pevr;
+    volatile uint32_t pever;
+    volatile uint32_t pevfr;
+    volatile uint32_t perr;
+    volatile uint32_t perer;
+    volatile uint32_t perfr;
+    volatile uint32_t res2[0xA];
+    volatile uint32_t ppsc;
+    volatile uint32_t res3;
+    volatile uint32_t pds;
+    volatile uint32_t l2rrs;
+    volatile uint32_t l3rrs;
+    volatile uint32_t l4rrs;
+    volatile uint32_t srrs;
+    volatile uint32_t l2rres;
+    volatile uint32_t l3rres;
+    volatile uint32_t l4rres;
+    volatile uint32_t srres;
+    volatile uint32_t spcs;
+    volatile uint32_t spscs;
+    volatile uint32_t hxscs;
+    volatile uint32_t mrcs;
+    volatile uint32_t mwcs;
+    volatile uint32_t mrscs;
+    volatile uint32_t mwscs;
+    volatile uint32_t fcscs;
+} _PackedType t_FmPcdPrsRegs;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/***********************************************************************/
+/*  Driver's internal structures                                       */
+/***********************************************************************/
+
+typedef struct {
+    t_Handle        h_Manip;
+    bool            keepRes;
+    e_FmPcdEngine   nextEngine;
+    uint8_t         parseCode;
+} t_FmPcdInfoForManip;
+
+/**************************************************************************//**
+ @Description   A structure of parameters to communicate
+                between the port and PCD regarding the KG scheme.
+*//***************************************************************************/
+typedef struct {
+    uint8_t                     netEnvId;    /* in */
+    uint8_t                     numOfDistinctionUnits; /* in */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
+    uint32_t                    vector; /* out */
+} t_NetEnvParams;
+
+typedef struct {
+    volatile bool       lock;
+    bool                used;
+    uint8_t             owners;
+    uint8_t             netEnvId;
+    uint8_t             guestId;
+    uint8_t             baseEntry;
+    uint16_t            sizeOfGrp;
+    protocolOpt_t       optArray[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+} t_FmPcdKgClsPlanGrp;
+
+typedef struct {
+    volatile bool       lock;
+    bool                valid;
+    uint8_t             netEnvId;
+    uint8_t             owners;
+    uint32_t            matchVector;
+    uint32_t            ccUnits;
+    bool                nextRelativePlcrProfile;
+    uint16_t            relativeProfileId;
+    uint16_t            numOfProfiles;
+    t_FmPcdKgKeyOrder   orderedArray;
+    e_FmPcdEngine       nextEngine;
+    e_FmPcdDoneAction   doneAction;
+    uint8_t             pointedOwners;
+    uint32_t            requiredAction;
+    bool                extractedOrs;
+    uint8_t             bitOffsetInPlcrProfile;
+    bool                directPlcr;
+} t_FmPcdKgScheme;
+
+typedef struct {
+    bool    allocated;
+    uint8_t ownerId;    /* guestId for KG in multi-partition only,
+                           portId for PLCR in any environment */
+} t_FmPcdAllocMng;
+
+typedef struct {
+    t_FmPcdKgRegs                   *p_FmPcdKgRegs;
+    uint32_t                        schemeExceptionsBitMask;
+    uint8_t                         numOfSchemes;
+    uint8_t                         schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgScheme                 schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgClsPlanGrp             clsPlanGrps[FM_MAX_NUM_OF_PORTS];
+    uint8_t                         emptyClsPlanGrpId;
+    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES]; /* only for MASTER ! */
+    t_FmPcdAllocMng                 clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+} t_FmPcdKg;
+
+typedef struct {
+    uint16_t            profilesBase;
+    uint16_t            numOfProfiles;
+    t_Handle            h_FmPort;
+} t_FmPcdPlcrMapParam;
+
+typedef struct {
+    bool                valid;
+    volatile bool       lock;
+    t_FmPcdAllocMng     profilesMng;
+    uint8_t             pointedOwners;
+    uint32_t            requiredAction;
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
+
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Yellow next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Yellow next engine params */
+
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Red next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Red next engine params */
+} t_FmPcdPlcrProfile;
+
+typedef struct {
+    t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
+    t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
+    uint16_t                        numOfSharedProfiles;
+    uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
+    t_FmPcdPlcrMapParam             portsMapping[FM_MAX_NUM_OF_PORTS];
+} t_FmPcdPlcr;
+
+typedef struct {
+    uint32_t                        *p_SwPrsCode;
+    uint32_t                        *p_CurrSwPrs;
+    uint8_t                         currLabel;
+    t_FmPcdPrsRegs                  *p_FmPcdPrsRegs;
+    t_FmPcdPrsLabelParams           labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+    uint32_t                        fmPcdPrsPortIdStatistics;
+} t_FmPcdPrs;
+
+typedef struct {
+    struct {
+        e_NetHeaderType             hdr;
+        protocolOpt_t               opt; /* only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdIntDistinctionUnit;
+
+typedef struct {
+    e_NetHeaderType             hdr;
+    e_NetHeaderType             aliasHdr;
+} t_FmPcdNetEnvAliases;
+
+typedef struct {
+    volatile bool               lock;
+    bool                        used;
+    uint8_t                     owners;
+    uint8_t                     clsPlanGrpId;
+    t_FmPcdIntDistinctionUnit   units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    unitsVectors[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint32_t                    macsecVector;
+    t_FmPcdNetEnvAliases        aliasHdrs[FM_PCD_MAX_NUM_OF_PRIVATE_HDRS];
+} t_FmPcdNetEnv;
+
+typedef struct {
+    bool                        plcrAutoRefresh;
+
+    uint16_t                    prsMaxParseCycleLimit;
+} t_FmPcdDriverParam;
+
+typedef struct {
+    t_Handle                    h_Fm;
+    t_Handle                    h_FmMuram;
+    uint64_t                    physicalMuramBase;
+    volatile bool               lock;
+    t_Handle                    h_Spinlock;
+    t_Handle                    h_IpcSession; /* relevant for guest only */
+    bool                        enabled;
+    uint8_t                     guestId;            /**< Guest Partition Id */
+    uint8_t                     numOfEnabledGuestPartitionsPcds;
+    char                        fmPcdModuleName[MODULE_NAME_SIZE];
+    char                        fmPcdIpcHandlerModuleName[MODULE_NAME_SIZE]; /* relevant for guest only - this is the master's name */
+    t_FmPcdNetEnv               netEnvs[FM_MAX_NUM_OF_PORTS];
+    t_FmPcdKg                   *p_FmPcdKg;
+    t_FmPcdPlcr                 *p_FmPcdPlcr;
+    t_FmPcdPrs                  *p_FmPcdPrs;
+
+    t_Handle                    h_Hc;
+
+    uint32_t                    exceptions;
+    t_FmPcdExceptionCallback    *f_Exception;
+    t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
+    t_Handle                    h_App;
+
+    t_FmPcdDriverParam          *p_FmPcdDriverParam;
+} t_FmPcd;
+
+
+/***********************************************************************/
+/*  PCD internal routines                                              */
+/***********************************************************************/
+
+/**************************************************************************//**
+
+ @Group         FM_PCD_InterModule_grp FM PCD Inter-Module Unit
+
+ @Description   FM PCD Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules. This will be the case in a single core environment,
+                where instead of useing the XX messeging mechanism, the routines may be
+                called from other modules. In a multicore environment, the other modules may
+                be run by other cores and therefor these routines may not be called directly.
+
+ @{
+*//***************************************************************************/
+
+t_Error     PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector);
+t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
+bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector);
+t_Error     PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_GrpParams);
+void        FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId);
+e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
+
+t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     KgInit(t_FmPcd *p_FmPcd);
+t_Error     KgFree(t_FmPcd *p_FmPcd);
+void        KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set);
+bool        KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     KgEnable(t_FmPcd *p_FmPcd);
+t_Error     KgDisable(t_FmPcd *p_FmPcd);
+t_Error     KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First);
+t_Error     KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base);
+
+/* only for MULTI partittion */
+t_Error     FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds);
+t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds);
+/* only for SINGLE partittion */
+t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
+
+t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     PlcrInit(t_FmPcd *p_FmPcd);
+t_Error     PlcrFree(t_FmPcd *p_FmPcd);
+t_Error     PlcrEnable(t_FmPcd *p_FmPcd);
+t_Error     PlcrDisable(t_FmPcd *p_FmPcd);
+t_Error     PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num, uint16_t base);
+t_Error     PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base);
+t_Error     PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+void        PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+
+t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
+t_Error     PrsInit(t_FmPcd *p_FmPcd);
+t_Error     PrsEnable(t_FmPcd *p_FmPcd);
+t_Error     PrsDisable(t_FmPcd *p_FmPcd);
+void        PrsFree(t_FmPcd *p_FmPcd );
+t_Error     PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include);
+
+t_Handle    FmPcdCcConfig(t_Handle h_FmPcd, t_FmPcdParams *p_FmPcdParams);
+//void        FmPcdCcFree(t_Handle h_FmPcdCc);
+t_Error     FmPcdCcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
+uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
+uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
+uint16_t    FmPcdCcGetNumOfKeys(t_Handle h_CcNode);
+
+void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
+t_Error     FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_InfoForManip, uint32_t *requiredAction);
+void        FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew);
+void        FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset);
+uint32_t    FmPcdManipCheckNia(t_Handle h_FmPcd, t_Handle h_Ad);
+void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
+t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode);
+
+static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    ASSERT_COND(p_FmPcd);
+    return p_FmPcd->h_FmMuram;
+}
+
+static __inline__ uint64_t FmPcdGetMuramPhysBase(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    ASSERT_COND(p_FmPcd);
+    return p_FmPcd->physicalMuramBase;
+}
+
+
+#endif /* __FM_PCD_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
new file mode 100644
index 0000000..e0746bd
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -0,0 +1,325 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ipc.h
+
+ @Description   FM PCD Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PCD_IPC_H
+#define __FM_PCD_IPC_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   Structure for getting a sw parser address according to a label
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdIpcSwPrsLable
+{
+    uint32_t    enumHdr;                        /**< IN. The existance of this header will envoke
+                                                     the sw parser code. */
+    uint8_t     indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
+                                                     attachments for the same header, use this
+
+                                                   index to distinguish between them. */
+} _PackedType t_FmPcdIpcSwPrsLable;
+
+/**************************************************************************//**
+ @Description   Structure for port-PCD communication.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef  struct t_FmPcdIpcKgSchemesParams
+{
+    uint8_t     guestId;                                    /**< IN */
+    uint8_t     numOfSchemes;                               /**< IN */
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];       /**< OUT */
+} _PackedType t_FmPcdIpcKgSchemesParams;
+
+typedef  struct t_FmPcdIpcKgClsPlanParams
+{
+    uint8_t     guestId;                                    /**< IN */
+    uint16_t    numOfClsPlanEntries;                        /**< IN */
+    uint8_t     clsPlanBase;                                /**< IN in alloc only */
+} _PackedType t_FmPcdIpcKgClsPlanParams;
+
+typedef _Packed struct t_FmPcdIpcPlcrAllocParams
+{
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} _PackedType t_FmPcdIpcPlcrAllocParams;
+
+typedef _Packed struct t_FmPcdIpcSharedPlcrAllocParams
+{
+    uint16_t  num;                                    /**< IN */
+    uint16_t  profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
+} _PackedType t_FmPcdIpcSharedPlcrAllocParams;
+
+typedef _Packed struct t_FmPcdIpcPrsIncludePort
+{
+    uint8_t hardwarePortId;     /* IN */
+    bool    include;            /* IN */
+} _PackedType t_FmPcdIpcPrsIncludePort;
+
+
+#define FM_PCD_MAX_REPLY_SIZE           16
+#define FM_PCD_MAX_MSG_SIZE             1024
+#define FM_PCD_MAX_REPLY_BODY_SIZE      1024
+
+typedef _Packed struct
+{
+    uint32_t    msgId;
+    uint8_t     msgBody[FM_PCD_MAX_MSG_SIZE];
+} _PackedType t_FmPcdIpcMsg;
+
+typedef _Packed struct t_FmPcdIpcReply
+{
+    uint32_t    error;
+    uint8_t     replyBody[FM_PCD_MAX_REPLY_BODY_SIZE];
+} _PackedType t_FmPcdIpcReply;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_KG_SCHEMES
+
+ @Description   Used by FM PCD front-end in order to allocate KG resources
+
+ @Param[in/out] t_FmPcdIpcKgAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_KG_SCHEMES                 3
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_KG_SCHEMES
+
+ @Description   Used by FM PCD front-end in order to Free KG resources
+
+ @Param[in/out] t_FmPcdIpcKgSchemesParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_SCHEMES                  4
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_PROFILES
+
+ @Description   Used by FM PCD front-end in order to allocate Policer profiles
+
+ @Param[in/out] t_FmPcdIpcKgSchemesParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_PROFILES                   5
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_PROFILES
+
+ @Description   Used by FM PCD front-end in order to Free Policer profiles
+
+ @Param[in/out] t_FmPcdIpcPlcrAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_PROFILES                    6
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_PHYS_MURAM_BASE
+
+ @Description   Used by FM PCD front-end in order to get MURAM base address
+
+ @Param[in/out] t_FmPcdIcPhysAddr Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_PHYS_MURAM_BASE              7
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SW_PRS_OFFSET
+
+ @Description   Used by FM front-end to get the SW parser offset of the start of
+                code relevant to a given label.
+
+ @Param[in/out] t_FmPcdIpcSwPrsLable Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_SW_PRS_OFFSET                8
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_SHARED_PROFILES
+
+ @Description   Used by FM PCD front-end in order to allocate shared profiles
+
+ @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_SHARED_PROFILES            9
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_SHARED_PROFILES
+
+ @Description   Used by FM PCD front-end in order to free shared profiles
+
+ @Param[in/out] t_FmPcdIpcSharedPlcrAllocParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_SHARED_PROFILES             10
+
+/**************************************************************************//**
+ @Function      FM_PCD_MASTER_IS_ENABLED
+
+ @Description   Used by FM front-end in order to verify
+                PCD enablement.
+
+ @Param[in]     bool Pointer
+*//***************************************************************************/
+#define FM_PCD_MASTER_IS_ENABLED                15
+
+/**************************************************************************//**
+ @Function      FM_PCD_GUEST_DISABLE
+
+ @Description   Used by FM front-end to inform back-end when
+                front-end PCD is disabled
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_GUEST_DISABLE                    16
+
+/**************************************************************************//**
+ @Function      FM_PCD_DUMP_REGS
+
+ @Description   Used by FM front-end to dump all PCD registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_DUMP_REGS                        17
+
+/**************************************************************************//**
+ @Function      FM_PCD_KG_DUMP_REGS
+
+ @Description   Used by FM front-end to dump KG registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_KG_DUMP_REGS                     18
+
+/**************************************************************************//**
+ @Function      FM_PCD_PLCR_DUMP_REGS
+
+ @Description   Used by FM front-end to dump PLCR registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_PLCR_DUMP_REGS                   19
+
+/**************************************************************************//**
+ @Function      FM_PCD_PLCR_PROFILE_DUMP_REGS
+
+ @Description   Used by FM front-end to dump PLCR specified profile registers
+
+ @Param[in]     t_Handle Pointer
+*//***************************************************************************/
+#define FM_PCD_PLCR_PROFILE_DUMP_REGS           20
+
+/**************************************************************************//**
+ @Function      FM_PCD_PRS_DUMP_REGS
+
+ @Description   Used by FM front-end to dump PRS registers
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_PRS_DUMP_REGS                    21
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_KG_CLSPLAN
+
+ @Description   Used by FM PCD front-end in order to Free KG classification plan entries
+
+ @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_CLSPLAN                     22
+
+/**************************************************************************//**
+ @Function      FM_PCD_ALLOC_KG_CLSPLAN
+
+ @Description   Used by FM PCD front-end in order to allocate KG classification plan entries
+
+ @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
+*//***************************************************************************/
+#define FM_PCD_ALLOC_KG_CLSPLAN                    23
+
+/**************************************************************************//**
+ @Function      FM_PCD_MASTER_IS_ALIVE
+
+ @Description   Used by FM front-end to check that back-end exists
+
+ @Param[in]     None
+*//***************************************************************************/
+#define FM_PCD_MASTER_IS_ALIVE                  24
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_COUNTER
+
+ @Description   Used by FM front-end to read PCD counters
+
+ @Param[in/out] t_FmPcdIpcGetCounter Pointer
+*//***************************************************************************/
+#define FM_PCD_GET_COUNTER                      25
+
+/**************************************************************************//**
+ @Function      FM_PCD_PRS_INC_PORT_STATS
+
+ @Description   Used by FM front-end to set/clear statistics for port
+
+ @Param[in/out] t_FmPcdIpcPrsIncludePort Pointer
+*//***************************************************************************/
+#define FM_PCD_PRS_INC_PORT_STATS               26
+/** @} */ /* end of FM_PCD_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_PCD_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
new file mode 100644
index 0000000..11abf3c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -0,0 +1,1750 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_plcr.c
+
+ @Description   FM PCD POLICER...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+
+#include "fm_common.h"
+#include "fm_pcd.h"
+#include "fm_hc.h"
+#include "fm_pcd_ipc.h"
+
+
+static bool FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
+
+    for(i=0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
+        if(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] == absoluteProfileId)
+            return TRUE;
+    return FALSE;
+}
+
+static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcdPlcrNextEngineParams *p_NextEngineParams, uint32_t *nextAction)
+{
+    uint32_t    nia;
+    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_NextEngineParams->h_Profile)-1);
+    uint8_t     relativeSchemeId, physicatSchemeId;
+
+    nia = FM_PCD_PLCR_NIA_VALID;
+
+    switch (nextEngine)
+    {
+        case e_FM_PCD_DONE :
+            switch (p_NextEngineParams->action)
+            {
+                case e_FM_PCD_DROP_FRAME :
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+                    break;
+                case e_FM_PCD_ENQ_FRAME:
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+        case e_FM_PCD_KG:
+            physicatSchemeId = (uint8_t)(PTR_TO_UINT(p_NextEngineParams->h_DirectScheme)-1);
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicatSchemeId);
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            if (!FmPcdKgIsSchemeValidSw(p_FmPcd, relativeSchemeId))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
+            nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicatSchemeId;
+            break;
+        case e_FM_PCD_PLCR:
+             if(!FmPcdPlcrIsProfileShared(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
+             if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
+            nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    *nextAction =  nia;
+
+    return E_OK;
+}
+
+static uint32_t FPP_Function(uint32_t fpp)
+{
+    if(fpp > 15)
+        return 15 - (0x1f - fpp);
+    else
+        return 16 + fpp;
+}
+
+static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
+                                uint32_t rate,
+                                uint64_t tsuInTenthNano,
+                                uint32_t fppShift,
+                                uint64_t *p_Integer,
+                                uint64_t *p_Fraction)
+{
+    uint64_t tmp, div;
+
+    if(rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    {
+        /* now we calculate the initial integer for the bigger rate */
+        /* from Kbps to Bytes/TSU */
+        tmp = (uint64_t)rate;
+        tmp *= 1000; /* kb --> b */
+        tmp *= tsuInTenthNano; /* bps --> bpTsu(in 10nano) */
+
+        div = 1000000000;   /* nano */
+        div *= 10;          /* 10 nano */
+        div *= 8;           /* bit to byte */
+    }
+    else
+    {
+        /* now we calculate the initial integer for the bigger rate */
+        /* from Kbps to Bytes/TSU */
+        tmp = (uint64_t)rate;
+        tmp *= tsuInTenthNano; /* bps --> bpTsu(in 10nano) */
+
+        div = 1000000000;   /* nano */
+        div *= 10;          /* 10 nano */
+    }
+    *p_Integer = (tmp<<fppShift)/div;
+
+    /* for calculating the fraction, we will recalculate cir and deduct the integer.
+     * For precision, we will multiply by 2^16. we do not divid back, since we write
+     * this value as fraction - see spec.
+     */
+    *p_Fraction = (((tmp<<fppShift)<<16) - ((*p_Integer<<16)*div))/div;
+}
+
+/* .......... */
+
+static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_NonPassthroughAlgParam,
+                        uint32_t *cir, uint32_t *cbs, uint32_t *pir_eir, uint32_t *pbs_ebs, uint32_t *fpp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint64_t    integer, fraction;
+    uint32_t    temp, tsuInTenthNanos, bitFor1Micro;
+    uint8_t     fppShift=0;
+
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);  /* TimeStamp per nano seconds units */
+    /* we want the tsu to count 10 nano for better precision normally tsu is 3.9 nano, now we will get 39 */
+    tsuInTenthNanos = (uint32_t)(1000*10/(1<<bitFor1Micro));
+
+    /* we choose the faster rate to calibrate fpp */
+    if (p_NonPassthroughAlgParam->comittedInfoRate > p_NonPassthroughAlgParam->peakOrAccessiveInfoRate)
+        GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
+    else
+        GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
+
+
+    /* we shift integer, as in cir/pir it is represented by the MSB 16 bits, and
+     * the LSB bits are for the fraction */
+    temp = (uint32_t)((integer<<16) & 0x00000000FFFFFFFF);
+    /* temp is effected by the rate. For low rates it may be as low as 0, and then we'll
+     * take max fpp=31.
+     * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
+     * limited by the 10G physical port.
+     */
+    if(temp != 0)
+    {
+        /* count zeroes left of the higher used bit (in order to shift the value such that
+         * unused bits may be used for fraction).
+         */
+        while ((temp & 0x80000000) == 0)
+        {
+            temp = temp << 1;
+            fppShift++;
+        }
+        if(fppShift > 15)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
+            return;
+        }
+    }
+    else
+    {
+        temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
+        if(!temp)
+            /* integer and fraction are 0, we set fpp to its max val */
+            fppShift = 31;
+        else
+        {
+            /* integer was 0 but fraction is not. fpp is 16 for the integer,
+             * + all left zeroes of the fraction. */
+            fppShift=16;
+            /* count zeroes left of the higher used bit (in order to shift the value such that
+             * unused bits may be used for fraction).
+             */
+            while ((temp & 0x8000) == 0)
+            {
+                temp = temp << 1;
+                fppShift++;
+            }
+        }
+    }
+
+    /*
+     * This means that the FM TS register will now be used so that 'count' bits are for
+     * fraction and the rest for integer */
+    /* now we re-calculate cir */
+    GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
+    *cir = (uint32_t)(integer << 16 | (fraction & 0xFFFF));
+    GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
+    *pir_eir = (uint32_t)(integer << 16 | (fraction & 0xFFFF));
+
+    *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
+    *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
+
+    /* get fpp as it should be written to reg.*/
+    *fpp = FPP_Function(fppShift);
+
+}
+
+static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
+{
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
+
+    while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
+
+}
+
+/*********************************************/
+/*............Policer Exception..............*/
+/*********************************************/
+static void PcdPlcrException(t_Handle h_FmPcd)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t event, mask;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+
+    /* clear forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, event & ~(event & mask));
+    event &= mask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
+
+    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
+    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
+
+}
+
+/* ..... */
+
+static void PcdPlcrErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event, captureReg, mask;
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+
+    /* clear forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, event & ~(event & mask));
+
+    event &= mask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
+
+    if(event & FM_PCD_PLCR_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
+    {
+        captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
+        /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
+        p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
+        p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
+        p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
+        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
+    }
+}
+
+void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    if(add)
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
+    else
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
+}
+
+uint32_t FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners;
+}
+uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
+}
+
+t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+    t_Error                     err = E_OK;
+    uint16_t                    base;
+    uint16_t                    swPortIndex = 0;
+    uint32_t                    replyLength;
+    t_FmPcdIpcMsg               *p_msg = NULL;
+    t_FmPcdIpcReply             *p_reply = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if(!numOfProfiles)
+        return E_OK;
+
+    memset(&ipcPlcrParams, 0, sizeof(ipcPlcrParams));
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        /* Alloc resources using IPC messaging */
+        ipcPlcrParams.num = numOfProfiles;
+        ipcPlcrParams.hardwarePortId = hardwarePortId;
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_ALLOC_PROFILES;
+        memcpy(p_msg->msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint16_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) +sizeof(ipcPlcrParams),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        if (err != E_OK) {
+            XX_Free(p_reply);
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+        }
+
+        memcpy((uint8_t*)&base, p_reply->replyBody, sizeof(uint16_t));
+        err = (t_Error)p_reply->error;
+        XX_Free(p_reply);
+
+        if (replyLength != sizeof(uint32_t) + sizeof(uint16_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if(err != E_OK)
+            RETURN_ERROR(MAJOR, err, ("PLCR profiles allocation failed"));
+    }
+    else /* master */
+    {
+        err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
+
+    return E_OK;
+}
+
+t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+    t_Error                     err = E_OK;
+    uint16_t                    swPortIndex = 0;
+    uint32_t                    replyLength;
+    t_FmPcdIpcMsg               *p_msg = NULL;
+    t_FmPcdIpcReply             *p_reply = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        /* Alloc resources using IPC messaging */
+        ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
+        ipcPlcrParams.hardwarePortId = hardwarePortId;
+        ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_FREE_PROFILES;
+        memcpy(p_msg->msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
+        replyLength = sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) +sizeof(ipcPlcrParams),
+                                             (uint8_t*)p_reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        if (err != E_OK) {
+            XX_Free(p_reply);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        err = (t_Error)p_reply->error;
+        XX_Free(p_reply);
+
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, ("PLCR Free Profiles failed"));
+    }
+    else /* master */
+    {
+        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
+
+    return E_OK;
+}
+
+bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+
+    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+}
+
+t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        profilesFound, log2Num, tmpReg32;
+    uint32_t        intFlags;
+    uint16_t        first, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if(!numOfProfiles)
+        return E_OK;
+
+    ASSERT_COND(hardwarePortId);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    if (!POWER_OF_2(numOfProfiles))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
+    }
+
+    first = 0;
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfProfiles);
+        }
+    }
+    if(profilesFound == numOfProfiles)
+    {
+        for(i = first; i<first + numOfProfiles; i++)
+        {
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
+        }
+    }
+    else
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+
+    /**********************FMPL_PMRx******************/
+    LOG2((uint64_t)numOfProfiles, log2Num);
+    tmpReg32 = first;
+    tmpReg32 |= log2Num << 16;
+    tmpReg32 |= FM_PCD_PLCR_PMR_V;
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
+
+    *p_Base = first;
+
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+
+t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint32_t        profilesFound;
+    uint16_t        i, k=0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if(!numOfProfiles)
+        return E_OK;
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            profilesIds[k] = i;
+            k++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+    }
+    if(profilesFound != numOfProfiles)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
+    for(i = 0;i<k;i++)
+    {
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
+    }
+
+    return E_OK;
+}
+
+t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
+
+    for(i = base; i<base+numOfProfiles;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
+
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+    }
+
+    return E_OK;
+}
+
+void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    for(i=0;i<numOfProfiles; i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
+    }
+}
+
+t_Error PlcrEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+
+t_Error PlcrDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   uint32_t tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
+
+    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
+    if(enable)
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    else
+        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
+
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
+
+    return E_OK;
+}
+
+
+t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
+{
+
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_Error         err = E_OK;
+    uint32_t        pemode, gnia, ynia, rnia;
+
+/* Set G, Y, R Nia */
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnGreen,  &(p_Profile->paramsOnGreen), &gnia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnYellow, &(p_Profile->paramsOnYellow), &ynia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnRed,    &(p_Profile->paramsOnRed), &rnia);
+   if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+/* Mode fmpl_pemode */
+    pemode = FM_PCD_PLCR_PEMODE_PI;
+
+    switch (p_Profile->algSelection)
+    {
+        case    e_FM_PCD_PLCR_PASS_THROUGH:
+            p_PlcrRegs->fmpl_pecir         = 0;
+            p_PlcrRegs->fmpl_pecbs         = 0;
+            p_PlcrRegs->fmpl_pepepir_eir   = 0;
+            p_PlcrRegs->fmpl_pepbs_ebs     = 0;
+            p_PlcrRegs->fmpl_pelts         = 0;
+            p_PlcrRegs->fmpl_pects         = 0;
+            p_PlcrRegs->fmpl_pepts_ets     = 0;
+            pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    switch (p_Profile->color.dfltColor)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+
+        case    e_FM_PCD_PLCR_RFC_2698:
+            /* Select algorithm MODE[ALG] = "01" */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
+            if (p_Profile->nonPassthroughAlgParams.comittedInfoRate > p_Profile->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
+            goto cont_rfc;
+        case    e_FM_PCD_PLCR_RFC_4115:
+            /* Select algorithm MODE[ALG] = "10" */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
+cont_rfc:
+            /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    /*In color aware more select override color interpretation (MODE[OVCLR]) */
+                    switch (p_Profile->color.override)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_G_NC;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
+            switch (p_Profile->nonPassthroughAlgParams.rateMode)
+            {
+                case e_FM_PCD_PLCR_BYTE_MODE :
+                    pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
+                        {
+                            case e_FM_PCD_PLCR_L2_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
+                                break;
+                            case e_FM_PCD_PLCR_L3_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L3;
+                                break;
+                            case e_FM_PCD_PLCR_L4_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L4;
+                                break;
+                            case e_FM_PCD_PLCR_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_FULL;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
+                        {
+                            case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
+                                pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            case e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                    break;
+                case e_FM_PCD_PLCR_PACKET_MODE :
+                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
+               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
+               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
+
+            /* Configure Traffic Parameters*/
+            {
+                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
+
+                calcRates(h_FmPcd, &p_Profile->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+
+                /*  Set Committed Information Rate (CIR) */
+                p_PlcrRegs->fmpl_pecir = cir;
+                /*  Set Committed Burst Size (CBS). */
+                p_PlcrRegs->fmpl_pecbs =  cbs;
+                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
+                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
+                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
+                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
+
+                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
+                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
+                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
+                /* Committed Rate Token Bucket Size (CTS) */
+                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
+
+                /* Set the FPP based on calculation */
+                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
+            }
+            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    p_PlcrRegs->fmpl_pemode = pemode;
+
+    p_PlcrRegs->fmpl_pegnia = gnia;
+    p_PlcrRegs->fmpl_peynia = ynia;
+    p_PlcrRegs->fmpl_pernia = rnia;
+
+    /* Zero Counters */
+    p_PlcrRegs->fmpl_pegpc     = 0;
+    p_PlcrRegs->fmpl_peypc     = 0;
+    p_PlcrRegs->fmpl_perpc     = 0;
+    p_PlcrRegs->fmpl_perypc    = 0;
+    p_PlcrRegs->fmpl_perrpc    = 0;
+
+    return E_OK;
+}
+
+void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = TRUE;
+}
+
+void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = FALSE;
+}
+
+t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPlcr *p_FmPcdPlcr;
+    /*uint8_t i=0;*/
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
+    if (!p_FmPcdPlcr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        p_FmPcdPlcr->p_FmPcdPlcrRegs  = (t_FmPcdPlcrRegs *)UINT_TO_PTR(FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
+        p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
+    }
+
+    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
+
+    return p_FmPcdPlcr;
+}
+
+t_Error PlcrInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam              *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPlcr                     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    uint32_t                        tmpReg32 = 0;
+    t_Error                         err = E_OK;
+    t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t                        replyLength;
+    t_FmPcdIpcMsg                   *p_msg = NULL;
+    t_FmPcdIpcReply                 *p_reply = NULL;
+
+    if(p_FmPcdPlcr->numOfSharedProfiles)
+    {
+        if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        {
+            p_msg = XX_Malloc(sizeof(*p_msg));
+            if (!p_msg)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+            p_reply = XX_Malloc(sizeof(*p_reply));
+            if (!p_reply) {
+                XX_Free(p_msg);
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+            }
+            memset(p_msg, 0, sizeof(*p_msg));
+            memset(p_reply, 0, sizeof(*p_reply));
+
+            p_msg->msgId = FM_PCD_ALLOC_SHARED_PROFILES;
+            memcpy(p_msg->msgBody, (uint8_t *)&p_FmPcdPlcr->numOfSharedProfiles, sizeof(uint16_t));
+            replyLength = sizeof(uint32_t) + p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t);
+            err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                                     (uint8_t*)p_msg,
+                                                     sizeof(p_msg->msgId)+ sizeof(p_FmPcdPlcr->numOfSharedProfiles),
+                                                     (uint8_t*)p_reply,
+                                                     &replyLength,
+                                                     NULL,
+                                                     NULL);
+            XX_Free(p_msg);
+            if (err != E_OK) {
+                XX_Free(p_reply);
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+            }
+
+            if (replyLength != (sizeof(uint32_t) + p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t))) {
+                XX_Free(p_reply);
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            }
+ 
+            memcpy(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_reply->replyBody, p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+            err = (t_Error)p_reply->error;
+            XX_Free(p_reply);
+
+            return err;
+        }
+        else /* master */
+        {
+            err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+            if(err)
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+        }
+    }
+
+    /**********************FMPL_GCR******************/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    if(p_Param->plcrAutoRefresh)
+        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
+    tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
+    /**********************FMPL_GCR******************/
+
+    /**********************FMPL_EEVR******************/
+    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
+    /**********************FMPL_EEVR******************/
+    /**********************FMPL_EIER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+    {
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
+    /**********************FMPL_EIER******************/
+
+    /**********************FMPL_EVR******************/
+    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
+    /**********************FMPL_EVR******************/
+    /**********************FMPL_IER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
+    /**********************FMPL_IER******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, PcdPlcrErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, PcdPlcrException, p_FmPcd);
+
+    /* driver initializes one DFLT profile at the last entry*/
+    /**********************FMPL_DPMR******************/
+    tmpReg32 = 0;//FM_PCD_PLCR_NUM_ENTRIES-1;
+    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+    p_FmPcd->p_FmPcdPlcr->profiles[0].profilesMng.allocated = TRUE;
+
+    return E_OK;
+}
+
+t_Error PlcrFree(t_FmPcd *p_FmPcd)
+{
+    t_Error                             err;
+    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+    t_FmPcdIpcMsg                       *p_msg = NULL;
+
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
+
+    if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+    {
+        if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        {
+            /* Free resources using IPC messaging */
+            ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+            memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+            p_msg = XX_Malloc(sizeof(*p_msg));
+            if (!p_msg)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+            memset(p_msg, 0, sizeof(*p_msg));
+            p_msg->msgId = FM_PCD_FREE_SHARED_PROFILES;
+            memcpy(p_msg->msgBody, &ipcSharedPlcrParams, sizeof(ipcSharedPlcrParams));
+            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                         (uint8_t*)p_msg,
+                                         sizeof(p_msg->msgId)+sizeof(ipcSharedPlcrParams),
+                                         NULL,
+                                         NULL,
+                                         NULL,
+                                         NULL)) != E_OK) {
+                XX_Free(p_msg);
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+            }
+            XX_Free(p_msg);
+        }
+        else
+            PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+    }
+    return E_OK;
+}
+
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+                                          e_FmPcdProfileTypeSelection   profileType,
+                                          t_Handle                      h_FmPort,
+                                          uint16_t                      relativeProfile,
+                                          uint16_t                      *p_AbsoluteId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    uint8_t         i;
+
+    switch (profileType)
+    {
+        case e_FM_PCD_PLCR_PORT_PRIVATE:
+            /* get port PCD id from port handle */
+            for(i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+                    break;
+            if (i ==  FM_MAX_NUM_OF_PORTS)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
+
+            if(!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
+            if(relativeProfile >= p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[i].profilesBase + relativeProfile);
+            break;
+        case e_FM_PCD_PLCR_SHARED:
+            if(relativeProfile >= p_FmPcdPlcr->numOfSharedProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcdPlcr->sharedProfilesIds[relativeProfile]);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Invalid policer profile type"));
+    }
+    return E_OK;
+}
+
+uint16_t FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        swPortIndex = 0;
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
+}
+
+uint16_t FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        swPortIndex = 0;
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
+
+}
+uint32_t FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                      ((uint32_t)absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT));
+}
+
+uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                      ((uint32_t)absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                      FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
+{
+
+    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                      FM_PCD_PLCR_PAR_R |
+                      ((uint32_t)absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                      FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
+{
+    switch(counter)
+    {
+        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
+        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
+       default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+    }
+}
+
+uint32_t FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red)
+{
+
+    uint32_t tmpReg32 = 0;
+
+    if(green)
+        tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
+    if(yellow)
+        tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
+    if(red)
+        tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
+
+    return tmpReg32;
+}
+
+void FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId, uint32_t requiredAction)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction = requiredAction;
+}
+
+t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    bool            ans;
+    if (intr)
+        ans = TRY_LOCK(NULL, &p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
+    else
+        ans = TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
+    if (ans)
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
+}
+
+void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+}
+
+/**************************************************/
+/*............Policer API.........................*/
+/**************************************************/
+
+t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
+                               t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmPcd                             *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr                         *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
+    uint32_t                            intFlags;
+    uint16_t                            absoluteProfileId;
+    t_Error                             err = E_OK;
+    uint32_t                            tmpReg32;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
+
+    if (p_Profile->modify)
+    {
+        absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_Profile->id.h_Profile)-1);
+        if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+            return NULL;
+        }
+        if (FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, FALSE))
+            return NULL;
+    }
+    else
+    {
+        intFlags = FmPcdLock(p_FmPcd);
+        err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &absoluteProfileId);
+        if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+            return NULL;
+        }
+        if(err)
+        {
+            FmPcdUnlock(p_FmPcd, intFlags);
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        err = FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, TRUE);
+        FmPcdUnlock(p_FmPcd, intFlags);
+        if (err)
+            return NULL;
+    }
+
+    /* if no override, check first that this profile is unused */
+    if(!p_Profile->modify)
+    {
+        /* read specified profile into profile registers */
+        tmpReg32 = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+        intFlags = FmPcdLock(p_FmPcd);
+        WritePar(p_FmPcd, tmpReg32);
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode);
+        FmPcdUnlock(p_FmPcd, intFlags);
+        if (tmpReg32 & FM_PCD_PLCR_PEMODE_PI)
+        {
+            RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer Profile is already used"));
+            return NULL;
+        }
+    }
+
+    memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_Profile, &plcrProfileReg);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnGreen = p_Profile->nextEngineOnGreen;
+    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnGreen, &(p_Profile->paramsOnGreen), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnYellow = p_Profile->nextEngineOnYellow;
+    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnYellow, &(p_Profile->paramsOnYellow), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnRed = p_Profile->nextEngineOnRed;
+    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnRed, &(p_Profile->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    intFlags = FmPcdLock(p_FmPcd);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode , plcrProfileReg.fmpl_pemode);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia , plcrProfileReg.fmpl_pegnia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia , plcrProfileReg.fmpl_peynia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia , plcrProfileReg.fmpl_pernia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecir  , plcrProfileReg.fmpl_pecir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecbs  , plcrProfileReg.fmpl_pecbs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepepir_eir,plcrProfileReg.fmpl_pepepir_eir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepbs_ebs,plcrProfileReg.fmpl_pepbs_ebs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pelts  , plcrProfileReg.fmpl_pelts);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pects  , plcrProfileReg.fmpl_pects);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepts_ets,plcrProfileReg.fmpl_pepts_ets);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc  , plcrProfileReg.fmpl_pegpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc  , plcrProfileReg.fmpl_peypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc  , plcrProfileReg.fmpl_perpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc , plcrProfileReg.fmpl_perypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc , plcrProfileReg.fmpl_perrpc);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(absoluteProfileId);
+    WritePar(p_FmPcd, tmpReg32);
+
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    if (!p_Profile->modify)
+        FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+
+    return UINT_TO_PTR((uint64_t)absoluteProfileId+1);
+}
+
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint16_t        profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    uint32_t        tmpReg32, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((profileIndx < FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    WRITE_UINT32(p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs.fmpl_pemode, ~FM_PCD_PLCR_PEMODE_PI);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    WritePar(p_FmPcd, tmpReg32);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+
+/* ......... */
+/***************************************************/
+/*............Policer Profile Counter..............*/
+/***************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    uint16_t        profileIndx         = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        intFlags, counterVal = 0;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrGetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter);
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, 0);
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return 0;
+    }
+    intFlags = FmPcdLock(p_FmPcd);
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
+        FmPcdUnlock(p_FmPcd, intFlags);
+        return 0;
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            counterVal = (GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc));
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            counterVal = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            counterVal = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            counterVal = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            counterVal = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            break;
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return counterVal;
+}
+
+
+t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
+{
+    t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32, intFlags;
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrCcGetSetParams(p_FmPcd->h_Hc, profileIndx, requiredAction);
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
+
+    if (FmPcdPlcrProfileTryLock(p_FmPcd, profileIndx, FALSE))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,("Lock on PP FAILED"));
+
+    intFlags = FmPcdLock(p_FmPcd);
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
+    {
+        FmPcdUnlock(p_FmPcd, intFlags);
+        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].lock);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
+    }
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].valid);
+
+    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
+       !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
+    {
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        {
+            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
+               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
+               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
+            {
+                FmPcdUnlock(p_FmPcd, intFlags);
+                RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    FmPcdUnlock(p_FmPcd, intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
+                WritePar(p_FmPcd, tmpReg32);
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    FmPcdUnlock(p_FmPcd, intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
+                WritePar(p_FmPcd, tmpReg32);
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    FmPcdUnlock(p_FmPcd, intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
+                WritePar(p_FmPcd, tmpReg32);
+            }
+        }
+    }
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners += 1;
+    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction |= requiredAction;
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].lock);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    uint16_t        profileIndx         = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter, value);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc ,value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
+             break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    /*  Activate the atomic write action by writing FMPL_PAR with: GO=1, RW=1, PSI=0, PNUM =
+     *  Profile Number, PWSEL=0xFFFF (select all words).
+     */
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+    tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
+    WritePar(p_FmPcd, tmpReg32);
+    FmPcdUnlock(p_FmPcd, intFlags);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles = numOfSharedPlcrProfiles;
+
+    return E_OK;
+}
+
+
+/* ... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0;
+    t_Error             err;
+    t_FmPcdIpcMsg       *p_msg = NULL;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_PLCR_DUMP_REGS;
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)p_msg,
+                                 sizeof(p_msg->msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+        XX_Free(p_msg);
+        return err;
+    }
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+        DUMP_SUBSTRUCT_ARRAY(i, 63)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
+        }
+
+        return E_OK;
+    }
+}
+
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    uint32_t                            tmpReg, intFlags;
+    uint16_t                            profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    t_Error                             err;
+    t_FmPcdIpcMsg                       *p_msg = NULL;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_PLCR_PROFILE_DUMP_REGS;
+        memcpy(p_msg->msgBody, (uint8_t *)&h_Profile, sizeof(uint32_t));
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)p_msg,
+                                 sizeof(p_msg->msgId) + sizeof(uint32_t),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+        XX_Free(p_msg);
+        return err;
+    }
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+
+        p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
+        intFlags = FmPcdLock(p_FmPcd);
+        WritePar(p_FmPcd, tmpReg);
+
+        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
+
+        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+        FmPcdUnlock(p_FmPcd, intFlags);
+
+        return E_OK;
+    }
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
new file mode 100644
index 0000000..3ce6e25
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -0,0 +1,543 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+
+#include "fm_common.h"
+#include "fm_pcd.h"
+#include "fm_pcd_ipc.h"
+
+
+t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPrs  *p_FmPcdPrs;
+    uintptr_t   baseAddr;
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPrs = (t_FmPcdPrs *) XX_Malloc(sizeof(t_FmPcdPrs));
+    if (!p_FmPcdPrs)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Parser structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
+
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
+        p_FmPcdPrs->p_SwPrsCode  = (uint32_t *)UINT_TO_PTR(baseAddr);
+        p_FmPcdPrs->p_FmPcdPrsRegs  = (t_FmPcdPrsRegs *)UINT_TO_PTR(baseAddr + PRS_REGS_OFFSET);
+    }
+
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
+
+    return p_FmPcdPrs;
+}
+
+static void PcdPrsErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, mask;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+
+    /* clear the forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr,  event & ~(event & mask));
+
+    event &= mask;
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
+
+    DBG(TRACE, ("parser error - 0x%08x\n",event));
+
+    if(event & FM_PCD_PRS_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+}
+
+static void PcdPrsException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+
+    ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
+
+    DBG(TRACE, ("parser event - 0x%08x\n",event));
+
+    if(GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, ~event);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
+
+    p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+}
+
+static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t  indexPerHdr)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                     i;
+    t_FmPcdPrsLabelParams   *p_Label;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
+
+    p_Label = p_FmPcd->p_FmPcdPrs->labelsTable;
+    for(i=0;i<p_FmPcd->p_FmPcdPrs->currLabel;i++, p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i])
+    {
+        if((hdr == p_Label->hdr) && (indexPerHdr == p_Label->indexPerHdr))
+            return p_Label->instructionOffset;
+    }
+
+    REPORT_ERROR(MINOR, E_NOT_FOUND, ("Sw Parser attachment Not found"));
+    return (uint32_t)ILLEGAL_BASE;
+}
+
+t_Error PrsInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+    uint32_t            tmpReg;
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        return E_OK;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+
+#ifdef FM_PRS_MEM_ERRATA_FMAN_SW003
+    {
+        uint32_t            i;
+        uint32_t            regsToGlobalOffset = 0x840;
+        uint32_t            firstPortToGlobalOffset = 0x45800;
+        uint64_t            globalAddr = PTR_TO_UINT(p_Regs) - regsToGlobalOffset;
+        uint32_t            firstPortAddr = (uint32_t)(globalAddr - (uint64_t)firstPortToGlobalOffset);
+        uint32_t            portSize = 0x1000;
+        t_FmRevisionInfo    revInfo;
+
+        FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            /* clear all parser memory */
+            IOMemSet32(UINT_TO_PTR(globalAddr), 0x00000000, 0x800);
+            for(i = 0;i<16;i++)
+                IOMemSet32(UINT_TO_PTR(firstPortAddr+i*portSize), (uint8_t)0x00000000, (uint32_t)0x80);
+        }
+    }
+#endif /* FM_PRS_MEM_ERRATA_FMAN_SW003 */
+
+    /**********************RPCLIM******************/
+    WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
+    /**********************FMPL_RPCLIM******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR, PcdPrsErrorException, p_FmPcd);
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL, PcdPrsException, p_FmPcd);
+
+    /**********************PEVR******************/
+    WRITE_UINT32(p_Regs->pevr, (FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS) );
+    /**********************PEVR******************/
+
+    /**********************PEVER******************/
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
+    {
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
+    }
+    else
+        WRITE_UINT32(p_Regs->pever, 0);
+    /**********************PEVER******************/
+
+    /**********************PERR******************/
+    WRITE_UINT32(p_Regs->perr, FM_PCD_PRS_DOUBLE_ECC);
+
+    /**********************PERR******************/
+
+    /**********************PERER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
+    {
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+    }
+    WRITE_UINT32(p_Regs->perer, tmpReg);
+    /**********************PERER******************/
+
+    /**********************PPCS******************/
+    WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+    /**********************PPCS******************/
+
+#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
+    {
+        uint32_t            i, j;
+        t_FmRevisionInfo    revInfo;
+        uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
+
+        FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            /* load sw parser L4 patch */
+            for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+            {
+               tmpReg = 0;
+               for(j =0;j<4;j++)
+               {
+                  tmpReg <<= 8;
+                  tmpReg |= swPrsL4Patch[i*4+j];
+
+               }
+                WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ FM_PCD_PRS_SW_OFFSET/4 + i), tmpReg);
+            }
+            p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = FM_PCD_PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
+        }
+    }
+#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+
+    return E_OK;
+}
+
+void PrsFree(t_FmPcd *p_FmPcd )
+{
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR);
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL);
+}
+
+t_Error PrsEnable(t_FmPcd *p_FmPcd )
+{
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
+
+    return E_OK;
+}
+
+t_Error PrsDisable(t_FmPcd *p_FmPcd )
+{
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) & ~FM_PCD_PRS_RPIMAC_EN);
+
+    return E_OK;
+}
+
+t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include)
+{
+    uint32_t    bitMask = 0;
+    uint8_t     prsPortId;
+
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
+    GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId);
+
+    if(include)
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
+    else
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+
+    return E_OK;
+}
+
+t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
+    t_FmPcdIpcMsg               *p_msg = NULL;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        prsIncludePortParams.hardwarePortId = hardwarePortId;
+        prsIncludePortParams.include = include;
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_PRS_INC_PORT_STATS;
+        memcpy(p_msg->msgBody, &prsIncludePortParams, sizeof(prsIncludePortParams));
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)p_msg,
+                                     sizeof(p_msg->msgId) +sizeof(prsIncludePortParams),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        XX_Free(p_msg);
+        return E_OK;
+    }
+    return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
+}
+
+uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Error                 err = E_OK;
+    t_FmPcdIpcSwPrsLable    labelParams;
+    uint32_t                replyLength;
+    t_FmPcdIpcMsg           *p_msg = NULL;
+    t_FmPcdIpcReply         *p_reply = NULL;
+    uint32_t                *p_ReplyLength = NULL, prsOffset = 0;
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        labelParams.enumHdr = (uint32_t)hdr;
+        labelParams.indexPerHdr = indexPerHdr;
+
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        p_reply = XX_Malloc(sizeof(*p_reply));
+        if (!p_reply) {
+            XX_Free(p_msg);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_reply"));
+        }
+        memset(p_msg, 0, sizeof(*p_msg));
+        memset(p_reply, 0, sizeof(*p_reply));
+
+        p_msg->msgId = FM_PCD_GET_SW_PRS_OFFSET;
+        memcpy(p_msg->msgBody, &labelParams, sizeof(labelParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)p_msg,
+                                             sizeof(p_msg->msgId) +sizeof(labelParams),
+                                             (uint8_t*)p_reply,
+                                             p_ReplyLength,
+                                             NULL,
+                                             NULL);
+        XX_Free(p_msg);
+        memcpy((uint8_t*)&prsOffset, p_reply->replyBody, sizeof(uint32_t));
+        XX_Free(p_reply);
+
+        if (err != E_OK) {
+            XX_Free(p_reply);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        if(*p_ReplyLength != sizeof(uint32_t) + sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        return prsOffset;
+    }
+
+    return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
+}
+
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
+        return;
+    }
+    if(enable)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
+    else
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
+
+}
+
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                *p_LoadTarget, tmpReg;
+    int                     i, j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_PrsLoadSw - guest mode!"));
+
+    if(!p_SwPrs->override)
+    {
+        if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
+    }
+    if(p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
+    if(p_SwPrs->size % 4)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size must be divisible by 4"));
+
+    /* save sw parser lables */
+    if(p_SwPrs->override)
+        p_FmPcd->p_FmPcdPrs->currLabel = 0;
+    if(p_FmPcd->p_FmPcdPrs->currLabel+ p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
+    memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel], p_SwPrs->labelsTable, p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
+    p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
+    /* load sw parser code */
+    p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;//+ FM_PCD_PRS_SW_OFFSET/4 + sizeof(swPrsL4Patch)/4;
+    for(i=0;i<p_SwPrs->size/4;i++)
+    {
+        tmpReg = 0;
+        for(j =0;j<4;j++)
+        {
+            tmpReg <<= 8;
+            tmpReg |= *(p_SwPrs->p_Code+i*4+j);
+        }
+        WRITE_UINT32(*(p_LoadTarget + i), tmpReg);
+    }
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + p_SwPrs->size/4;
+
+    /* copy data parameters */
+    for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
+        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
+
+
+    /* Clear last 4 bytes */
+    WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-FM_PCD_PRS_SW_TAIL_SIZE)/4), 0);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPrsMaxCycleLimit - guest mode!"));
+
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
+
+    return E_OK;
+}
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err = E_OK;
+    t_FmPcdIpcMsg       *p_msg = NULL;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        p_msg = XX_Malloc(sizeof(*p_msg));
+        if (!p_msg)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_msg"));
+        memset(p_msg, 0, sizeof(*p_msg));
+        p_msg->msgId = FM_PCD_PRS_DUMP_REGS;
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                    (uint8_t*)p_msg,
+                                    sizeof(p_msg->msgId),
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    NULL);
+        XX_Free(p_msg);
+        return err;
+    }
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
new file mode 100644
index 0000000..8799431
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_port.o fm_port_im.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
new file mode 100644
index 0000000..7a8434c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -0,0 +1,5102 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_port.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static t_Error CheckInitParameters(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    t_Error             ans = E_OK;
+    uint32_t            unusedMask;
+    uint8_t             i;
+    uint8_t             j;
+    bool                found;
+
+    if (p_FmPort->imEn)
+    {
+        if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
+            return ERROR_CODE(ans);
+    }
+    else
+    {
+        /****************************************/
+        /*   Rx only                            */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        {
+            /* external buffer pools */
+            if(!p_Params->extBufPools.numOfPoolsUsed)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+
+            if(p_Params->extBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+            for(i=0;i<p_Params->extBufPools.numOfPoolsUsed;i++)
+            {
+                if(p_Params->extBufPools.extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].id can't be larger than %d", i, BM_MAX_NUM_OF_POOLS));
+                if(!p_Params->extBufPools.extBufPool[i].size)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].size is 0", i));
+            }
+
+            /* backup BM pools indication is valid only for some chip deriviatives
+               (limited by the config routine) */
+            if(p_Params->p_BackupBmPools)
+            {
+                if(p_Params->p_BackupBmPools->numOfBackupPools >= p_Params->extBufPools.numOfPoolsUsed)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"));
+                found = FALSE;
+                for(i = 0;i<p_Params->p_BackupBmPools->numOfBackupPools;i++)
+                    for(j=0;j<p_Params->extBufPools.numOfPoolsUsed;j++)
+                        if(p_Params->p_BackupBmPools->poolIds[i] == p_Params->extBufPools.extBufPool[j].id)
+                            found = TRUE;
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
+            }
+
+            /* up to extBufPools.numOfPoolsUsed pools may be defined */
+            if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
+            {
+                if((p_Params->bufPoolDepletion.numOfPools > p_Params->extBufPools.numOfPoolsUsed))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+                if(!p_Params->bufPoolDepletion.numOfPools)
+                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+            }
+            /* Check that part of IC that needs copying is small enough to enter start margin */
+            if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
+
+            if(p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
+#ifdef FM_PARTITION_ARRAY
+            {
+                t_FmRevisionInfo revInfo;
+                FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                {
+                    if(p_Params->liodnOffset >= MAX_LIODN_OFFSET)
+                    {
+                        p_Params->liodnOffset = (uint16_t)(p_Params->liodnOffset & (MAX_LIODN_OFFSET-1));
+                        DBG(WARNING, ("liodnOffset number is out of rev1 range - MSB bits cleard."));
+                    }
+                }
+            }
+#endif /* FM_PARTITION_ARRAY */
+        }
+
+        /****************************************/
+        /*   Non Rx ports                       */
+        /****************************************/
+        else
+        {
+            if(p_Params->deqSubPortal >= MAX_QMI_DEQ_SUBPORTAL)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", MAX_QMI_DEQ_SUBPORTAL));
+
+            /* to protect HW internal-context from overwrite */
+            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+        }
+
+        /****************************************/
+        /*   Rx Or Offline Parsing              */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        {
+
+            if(!p_Params->dfltFqid)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+#if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
+#endif
+        }
+
+        /****************************************/
+        /*   All ports                          */
+        /****************************************/
+        /* common BMI registers values */
+        /* Check that Queue Id is not larger than 2^24, and is not 0 */
+        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
+        if(p_Params->dfltFqid & ~0x00FFFFFF)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+    }
+
+    /****************************************/
+    /*   Rx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 16 */
+        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+
+        /* Check the margin definition */
+        if(p_Params->bufMargins.startMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+        if(p_Params->bufMargins.endMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
+
+        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
+           !p_Params->bufPoolDepletion.numOfPools)
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+#ifdef FM_CSI_CFED_LIMIT
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+
+            if (revInfo.majorRev == 4)
+            {
+                /* Check that not larger than 16 */
+                if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+            }
+        }
+#endif /* FM_CSI_CFED_LIMIT */
+
+    }
+
+    /****************************************/
+    /*   Non Rx ports                       */
+    /****************************************/
+    else
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_FmPort->fifoBufs.extra)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+
+    /****************************************/
+    /*   Rx & Tx                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that not larger than 16 */
+        if(p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+    }
+
+    /****************************************/
+    /*   Tx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 8 */
+        if((!p_FmPort->txFifoDeqPipelineDepth) ||( p_FmPort->txFifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if(p_FmPort->txFifoDeqPipelineDepth > 2)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth for !G can't be larger than 2"));
+    }
+    else
+    /****************************************/
+    /*   Non Tx Ports                       */
+    /****************************************/
+    {
+        /* If discard override was selected , no frames may be discarded. */
+        if(p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
+            RETURN_ERROR(MAJOR, E_CONFLICT, ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
+    }
+
+    /****************************************/
+    /*   Rx and Offline parsing             */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+        || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            unusedMask = BMI_STATUS_OP_MASK_UNUSED;
+        else
+            unusedMask = BMI_STATUS_RX_MASK_UNUSED;
+
+        /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
+        if(p_Params->errorsToDiscard & unusedMask)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
+    }
+
+    /****************************************/
+    /*   All ports                          */
+    /****************************************/
+
+   /* Check that divisible by 16 and not larger than 240 */
+    if(p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
+    if(p_Params->intContext.intContextOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
+
+    /* check that ic size+ic internal offset, does not exceed ic block size */
+    if(p_Params->intContext.size + p_Params->intContext.intContextOffset > MAX_IC_SIZE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size + intContext.intContextOffset has to be smaller than %d", MAX_IC_SIZE));
+    /* Check that divisible by 16 and not larger than 256 */
+    if(p_Params->intContext.size % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size  has to be divisible by %d", OFFSET_UNITS));
+
+    /* Check that divisible by 16 and not larger than 4K */
+    if(p_Params->intContext.extBufOffset > MAX_EXT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset can't be larger than %d", MAX_EXT_OFFSET));
+    if(p_Params->intContext.extBufOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset  has to be divisible by %d", OFFSET_UNITS));
+
+    /* common BMI registers values */
+    if((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if(p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+    if((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if(p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    if(!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(p_FmPort->fifoBufs.num % BMI_FIFO_UNITS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
+
+    return E_OK;
+}
+
+static void FmPortDriverParamFree(t_FmPort *p_FmPort)
+{
+    if(p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        p_FmPort->p_FmPortDriverParam = NULL;
+    }
+}
+
+static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
+{
+    t_FmPortExtPools            *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
+    t_FmPortBufPoolDepletion    *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
+    volatile uint32_t           *p_ExtBufRegs;
+    volatile uint32_t           *p_BufPoolDepletionReg;
+    bool                        rxPort;
+    bool                        found;
+    uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
+    uint8_t                     count = 0;
+    uint8_t                     numOfPools;
+    uint16_t                    bufSize = 0, largestBufSize = 0;
+    int                         i=0, j=0, k=0;
+    uint32_t                    tmpReg, vector, minFifoSizeRequired=0;
+
+    memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
+    memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmPortExtPools));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
+            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_mpd;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
+            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
+            rxPort = FALSE;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for port type"));
+    }
+
+    /* First we copy the external buffers pools information to an ordered local array */
+    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    {
+        /* get pool size */
+        bufSize = p_ExtBufPools->extBufPool[i].size;
+
+        /* keep sizes in an array according to poolId for direct access */
+        sizesArray[p_ExtBufPools->extBufPool[i].id] =  bufSize;
+
+        /* save poolId in an ordered array according to size */
+        for (j=0;j<=i;j++)
+        {
+            /* this is the next free place in the array */
+            if (j==i)
+                orderedArray[i] = p_ExtBufPools->extBufPool[i].id;
+            else
+            {
+                /* find the right place for this poolId */
+                if(bufSize < sizesArray[orderedArray[j]])
+                {
+                    /* move the poolIds one place ahead to make room for this poolId */
+                    for(k=i;k>j;k--)
+                       orderedArray[k] = orderedArray[k-1];
+
+                    /* now k==j, this is the place for the new size */
+                    orderedArray[k] = p_ExtBufPools->extBufPool[i].id;
+                    break;
+                }
+            }
+        }
+    }
+
+    /* build the register value */
+
+    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    {
+        tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
+        tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
+        tmpReg |= sizesArray[orderedArray[i]];
+        /* functionality available only for some deriviatives (limited by config) */
+        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+                if(orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+                {
+                    tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
+                    break;
+                }
+        WRITE_UINT32(*(p_ExtBufRegs+i), tmpReg);
+    }
+
+    if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
+
+   numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
+
+    /* clear unused pools */
+    for(i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
+        WRITE_UINT32(*(p_ExtBufRegs+i), 0);
+
+    p_FmPort->rxPoolsParams.largestBufSize = largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+#ifdef FM_FIFO_ALLOCATION_OLD_ALG
+        t_FmRevisionInfo        revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+
+        if(revInfo.majorRev < 4)
+        {
+            minFifoSizeRequired = (uint32_t)(((largestBufSize % BMI_FIFO_UNITS) ?
+                                    ((largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    largestBufSize) +
+                                    (7*BMI_FIFO_UNITS));
+        }
+        else
+#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
+        {
+            p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
+            if(p_ExtBufPools->numOfPoolsUsed == 1)
+                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
+            else
+            {
+                uint16_t secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
+                p_FmPort->rxPoolsParams.secondLargestBufSize = secondLargestBufSize;
+                minFifoSizeRequired = (uint32_t)(((secondLargestBufSize % BMI_FIFO_UNITS) ?
+                                    ((secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    secondLargestBufSize) +
+                                    (7*BMI_FIFO_UNITS));
+            }
+        }
+        if(p_FmPort->fifoBufs.num < minFifoSizeRequired)
+        {
+            p_FmPort->fifoBufs.num = minFifoSizeRequired;
+            DBG(INFO, ("FIFO size for Rx port enlarged to %d",minFifoSizeRequired));
+        }
+    }
+
+    /* check if pool size is not too big */
+    if (largestBufSize > p_FmPort->fifoBufs.num)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Pool %d size %u is bigger than ports %u type %u commited fifo size %u",
+                     p_ExtBufPools->extBufPool[i].id, largestBufSize, p_FmPort->portId, p_FmPort->portType, p_FmPort->fifoBufs.num));
+
+    /* pool depletion */
+    tmpReg = 0;
+    if(p_BufPoolDepletion->numberOfPoolsModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        found = FALSE;
+        vector = 0;
+        count = 0;
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        {
+            if(p_BufPoolDepletion->poolsToConsider[i])
+            {
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                {
+                    if (i == orderedArray[j])
+                    {
+                        vector |= 0x80000000 >> j;
+                        found = TRUE;
+                        count++;
+                        break;
+                    }
+                }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
+            }
+        }
+        if (count < p_BufPoolDepletion->numOfPools)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
+
+        /* configure num of pools and vector for number of pools mode */
+        tmpReg |= (((uint32_t)p_BufPoolDepletion->numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
+        tmpReg |= vector;
+    }
+
+    if(p_BufPoolDepletion->singlePoolModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        found = FALSE;
+        vector = 0;
+        count = 0;
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        {
+            if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
+            {
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                {
+                    if (i == orderedArray[j])
+                     {
+                        vector |= 0x00000080 >> j;
+                        found = TRUE;
+                        count++;
+                        break;
+                    }
+                }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
+            }
+        }
+        if (!count)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
+
+        /* configure num of pools and vector for number of pools mode */
+        tmpReg |= vector;
+    }
+
+    WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
+
+    return E_OK;
+}
+
+static t_Error ClearPerfCnts(t_FmPort *p_FmPort)
+{
+    FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL, 0);
+    FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL, 0);
+    FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL, 0);
+    FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL, 0);
+    return E_OK;
+}
+
+static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    uint32_t                tmpReg;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t                errorsToEnq = 0;
+    t_FmPortPerformanceCnt  performanceContersParams;
+    t_Error                 err;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                      ("Port(%d,%d) is already enabled",p_FmPort->portType, p_FmPort->portId));
+
+    /* Set Config register */
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+    /* No discard - all error frames go to error queue */
+    else if (p_Params->frmDiscardOverride)
+        tmpReg |= BMI_PORT_CFG_FDOVR;
+
+    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_rda, tmpReg);
+
+    /* Configure Rx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->rxFifoPriElevationLevel/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_PRI_ELEVATION_SHIFT);
+    tmpReg |= ((p_Params->rxFifoThreshold/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_THRESHOLD_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_RX_FRAME_END_CS_IGNORE_SHIFT);
+    tmpReg |= ((uint32_t)p_Params->cutBytesFromEnd<< BMI_RX_FRAME_END_CUT_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
+
+    /* IC parameters */
+    tmpReg = 0;
+    tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_ricp, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* check if the largest external buffer pool is large enough */
+        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins > p_FmPort->rxPoolsParams.largestBufSize)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
+                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, p_FmPort->rxPoolsParams.largestBufSize));
+
+        /* buffer margins */
+        tmpReg = 0;
+        tmpReg |= (((uint32_t)p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
+        tmpReg |= (((uint32_t)p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
+    }
+
+
+    if(p_FmPort->internalBufferOffset)
+    {
+        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+        WRITE_UINT32(p_Regs->fmbm_rim, tmpReg << BMI_IM_FOF_SHIFT);
+    }
+
+    /* NIA */
+    if (p_FmPort->imEn)
+        WRITE_UINT32(p_Regs->fmbm_rfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_RX);
+    else
+    {
+        tmpReg = 0;
+        if (p_Params->forwardReuseIntContext)
+            tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
+        /* L3/L4 checksum verify is enabled by default. */
+        /*tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;*/
+        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    }
+    WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    tmpReg = BMI_CMD_RX_MR_DEF;
+    if (!p_FmPort->imEn)
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC;
+        tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_rfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_rfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_refqid, p_Params->errFqid);
+    }
+
+    /* set counters */
+    WRITE_UINT32(p_Regs->fmbm_rstc, BMI_COUNTERS_EN);
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
+    performanceContersParams.queueCompVal   = 1;
+    performanceContersParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+    if((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
+
+    /* error/status mask  - check that if discard OV is set, no
+       discard is required for specific errors.*/
+    WRITE_UINT32(p_Regs->fmbm_rfsdm, p_Params->errorsToDiscard);
+
+    errorsToEnq = (RX_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+    WRITE_UINT32(p_Regs->fmbm_rfsem, errorsToEnq);
+
+#ifdef FM_BMI_TO_RISC_ENQ_ERRATA_FMANc
+    if((GET_UINT32(p_Regs->fmbm_rfene) && NIA_ENG_MASK)== NIA_ENG_FM_CTL)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("NIA not supported at this stage"));
+#endif /* FM_BMI_TO_RISC_ENQ_ERRATA_FMANc */
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+    uint32_t            tmpReg;
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    /*uint32_t            rateCountUnit;*/
+    t_FmPortPerformanceCnt  performanceContersParams;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_tcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+
+    WRITE_UINT32(p_Regs->fmbm_tcfg, tmpReg);
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+
+    WRITE_UINT32(p_Regs->fmbm_tda, tmpReg);
+
+    /* Configure Tx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->txFifoMinFillLevel/BMI_FIFO_UNITS) << BMI_TX_FIFO_MIN_FILL_SHIFT);
+    tmpReg |= (((uint32_t)p_FmPort->txFifoDeqPipelineDepth - 1) << BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT);
+    tmpReg |= ((p_Params->txFifoLowComfLevel/BMI_FIFO_UNITS - 1) << BMI_TX_LOW_COMF_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_TX_FRAME_END_CS_IGNORE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfed, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* IC parameters */
+        tmpReg = 0;
+        tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+        tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+        tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_ticp, tmpReg);
+    }
+
+    /* NIA */
+    if (p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+    }
+    else
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_QMI_DEQ);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        /* The line bellow is a trick so the FM will not release the buffer
+           to BM nor will try to enq the frame to QM */
+        if(!p_Params->dfltFqid && p_Params->dontReleaseBuf)
+            WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+    }
+
+    /* command attribute */
+    tmpReg = BMI_CMD_TX_MR_DEF;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_CMD_MR_DEAS;
+    else
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        /* if we set syncReq, we may get stuck when HC command is running */
+        /*if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC;*/
+        tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_tfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tcfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
+    }
+
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
+    performanceContersParams.queueCompVal   = 1;
+    performanceContersParams.dmaCompVal     = (uint8_t)p_FmPort->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
+
+    WRITE_UINT32(p_Regs->fmbm_tpc, BMI_COUNTERS_EN);
+
+    return E_OK;
+}
+
+static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortOhBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+    uint32_t                tmpReg, errorsToEnq = 0;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
+    t_FmPortPerformanceCnt  performanceContersParams;
+    t_Error                 err;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= (uint32_t)p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
+
+    /* IC parameters */
+    tmpReg = 0;
+    tmpReg |= (((uint32_t)p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= (((uint32_t)p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= (((uint32_t)p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_oicp, tmpReg);
+
+    /* NIA */
+    WRITE_UINT32(p_Regs->fmbm_ofdne, NIA_ENG_QMI_DEQ);
+
+    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ);
+    else
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    if (p_FmPort->portType==e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        tmpReg =  BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+    else
+        tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+
+    if(p_Params->syncReq)
+        tmpReg |= BMI_CMD_ATTR_SYNC;
+    tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
+
+    /* No discard - all error frames go to error queue */
+    if (p_Params->frmDiscardOverride)
+        tmpReg = BMI_PORT_CFG_FDOVR;
+    else
+        tmpReg = 0;
+    WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
+
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    {
+        WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
+
+        errorsToEnq = (OP_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+        WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
+
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+        {
+#ifdef FM_NO_OP_OBSERVED_POOLS
+            t_FmRevisionInfo        revInfo;
+
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev >= 4) && (p_Params->enBufPoolDepletion))
+#endif /* FM_NO_OP_OBSERVED_POOLS */
+            {
+
+                /* define external buffer pools */
+                err = SetExtBufferPools(p_FmPort);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+    }
+    else
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_HC);
+
+    /* default queues */
+    WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
+    WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
+
+    if(p_FmPort->internalBufferOffset)
+    {
+        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+        WRITE_UINT32(p_Regs->fmbm_oim, tmpReg << BMI_IM_FOF_SHIFT);
+    }
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
+
+    performanceContersParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
+    performanceContersParams.queueCompVal   = 0;
+    performanceContersParams.dmaCompVal     = (uint8_t)p_FmPort->openDmas.num;
+    performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+    FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
+
+    WRITE_UINT32(p_Regs->fmbm_opc, BMI_COUNTERS_EN);
+
+    return E_OK;
+}
+
+static t_Error QmiInit(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam             *p_Params = NULL;
+    uint32_t                        tmpReg;
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* check that port is not busy */
+    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
+       (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* enable & clear counters */
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
+
+    /* The following is  done for non-Rx ports only */
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    {
+        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+                        (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        {
+            /* define dequeue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+        }
+        else  /* for HC & OP */
+        {
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        }
+
+        /* configure dequeue */
+        tmpReg = 0;
+        if(p_Params->deqHighPriority)
+            tmpReg |= QMI_DEQ_CFG_PRI;
+
+        switch(p_Params->deqType)
+        {
+            case(e_FM_PORT_DEQ_TYPE1):
+                tmpReg |= QMI_DEQ_CFG_TYPE1;
+                break;
+            case(e_FM_PORT_DEQ_TYPE2):
+                tmpReg |= QMI_DEQ_CFG_TYPE2;
+                break;
+            case(e_FM_PORT_DEQ_TYPE3):
+                tmpReg |= QMI_DEQ_CFG_TYPE3;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue type"));
+        }
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+
+        switch(p_Params->deqPrefetchOption)
+        {
+            case(e_FM_PORT_DEQ_NO_PREFETCH):
+                /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
+                break;
+            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            case(e_FM_PORT_DEQ_FULL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
+        }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+        tmpReg |= p_Params->deqByteCnt;
+        tmpReg |= (uint32_t)p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
+
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndc, tmpReg);
+    }
+    else /* rx port */
+        /* define enqueue NIA */
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+
+    return E_OK;
+}
+
+static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            /* performance counters - may be read when disabled */
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+         default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+            *p_Ptr = &p_BmiRegs->fmbm_rccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rtuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rrquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            *p_Ptr = &p_BmiRegs->fmbm_rpac;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfcd;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfbc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rlfc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rffc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+#ifdef FM_PORT_COUNTERS_ERRATA_FMANg
+            {
+                t_FmRevisionInfo revInfo;
+                FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available in rev1"));
+            }
+#endif /* FM_PORT_COUNTERS_ERRATA_FMANg */
+            *p_Ptr = &p_BmiRegs->fmbm_rfldec;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+            *p_Ptr = &p_BmiRegs->fmbm_rodc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_rbdc;
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+    }
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            /* performance counters - may be read when disabled */
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_tccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ttuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_tfledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_tbdc;
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+    }
+
+    return E_OK;
+}
+
+static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+
+    /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            /* performance counters - may be read when disabled */
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+            if(p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Host Command ports"));
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_occn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_otuc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_oduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ofuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofdc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_offc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+#ifdef FM_PORT_COUNTERS_ERRATA_FMANg
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available in rev1"));
+        }
+#endif /* FM_PORT_COUNTERS_ERRATA_FMANg */
+          *p_Ptr = &p_BmiRegs->fmbm_ofldec;
+            break;
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+           *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_ofledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_obdc;
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+    }
+
+    return E_OK;
+}
+
+static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+{
+    uint8_t                     hdrNum, Ipv4HdrNum;
+    u_FmPcdHdrPrsOpts           *p_prsOpts;
+    uint32_t                    tmpReg = 0, tmpPrsOffset;
+
+    if(IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
+
+    if(p_HdrParams->errDisable)
+        tmpReg |= PRS_HDR_ERROR_DIS;
+
+    /* Set parser options */
+    if(p_HdrParams->usePrsOpts)
+    {
+        p_prsOpts = &p_HdrParams->prsOpts;
+        switch(p_HdrParams->hdr)
+        {
+            case(HEADER_TYPE_MPLS):
+                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+                    tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
+                GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
+                if(hdrNum == ILLEGAL_HDR_NUM)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+                GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
+                if(hdrNum < Ipv4HdrNum)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                        ("Header must be equal or higher than IPv4"));
+                tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+                break;
+            case(HEADER_TYPE_PPPoE):
+                if(p_prsOpts->pppoePrsOptions.enableMTUCheck)
+                {
+#ifdef FM_PPPOE_NO_MTU_CHECK
+                    t_FmRevisionInfo revInfo;
+                    FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Invalid parser option"));
+                    else
+#endif /* FM_PPPOE_NO_MTU_CHECK */
+                        tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
+                }
+                break;
+            case(HEADER_TYPE_IPv6):
+                if(p_prsOpts->ipv6PrsOptions.routingHdrDisable)
+                    tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_DIS;
+                break;
+            case(HEADER_TYPE_TCP):
+                if(p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                break;
+            case(HEADER_TYPE_UDP):
+                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
+        }
+    }
+
+    /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
+    if(p_HdrParams->swPrsEnable)
+    {
+        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
+        if(tmpPrsOffset == ILLEGAL_BASE)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+        tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
+    }
+    *p_SoftSeqAttachReg = tmpReg;
+
+    return E_OK;
+}
+
+static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                    walking1Mask = 0x80000000, tmp;
+    uint8_t                     idx = 0;
+
+    p_SchemeBind->netEnvId = p_FmPort->netEnvId;
+    p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
+    p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
+    p_SchemeBind->numOfSchemes = 0;
+    tmp = p_FmPort->schemesPerPortVector;
+    if(tmp)
+    {
+        while (tmp)
+        {
+            if(tmp & walking1Mask)
+            {
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->numOfSchemes++;
+                tmp &= ~walking1Mask;
+            }
+            walking1Mask >>= 1;
+            idx++;
+        }
+    }
+
+    return tmp;
+}
+
+static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
+{
+    uint32_t                        tmp;
+
+    ASSERT_COND(p_FmPort);
+
+    /* Align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =
+        (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1)) ?
+            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) & ~(uint16_t)(OFFSET_UNITS-1)) :
+             p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
+
+    /* Translate margin and intContext params to FM parameters */
+#ifdef FM_INCORRECT_CS_ERRATA_FMAN18
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            uint8_t mod = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign % 256;
+            if(mod)
+            {
+                p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign += (256-mod);
+                DBG(WARNING,("dataAlign modified to next 256 to conform with FMAN18 errata\n"));
+            }
+        }
+    }
+#endif /* FM_INCORRECT_CS_ERRATA_FMAN18 */
+
+    /* Initialize with illegal value. Later we'll set legal values. */
+    p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.hashResultOffset= (uint32_t)ILLEGAL_BASE;
+    p_FmPort->bufferOffsets.pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
+#ifdef DEBUG
+    p_FmPort->bufferOffsets.debugOffset     = (uint32_t)ILLEGAL_BASE;
+#endif /* DEBUG */
+
+    /* Internally the driver supports 4 options
+       1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
+          relate to it as 1).
+       2. All IC context (from AD) except debug.
+       3. Debug information only.
+       4. All IC context (from AD) including debug.
+       Note, that if user asks for prsResult/timestamp/hashResult and Debug, we give them (4) */
+
+    /* This 'if' covers options  2 & 4. We copy from beginning of context with or without debug. */
+    /* If passAllOtherPCDInfo explicitly requested, or passDebugInfo+prs/ts --> we also take passAllOtherPCDInfo */
+    if ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
+#ifdef DEBUG
+        || (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo &&
+         (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ||
+          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
+          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult))
+#endif /* DEBUG */
+       )
+    {
+#ifdef DEBUG
+        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
+        {
+            p_FmPort->p_FmPortDriverParam->intContext.size = 240;
+            p_FmPort->bufferOffsets.debugOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 128);
+        }
+        else
+#endif /* DEBUG */
+            p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
+        /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
+        p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 16;
+
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
+            p_FmPort->bufferOffsets.pcdInfoOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
+            p_FmPort->bufferOffsets.prsResultOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 16);
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
+            p_FmPort->bufferOffsets.timeStampOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 48);
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
+            p_FmPort->bufferOffsets.hashResultOffset =
+                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 56);
+    }
+    else
+    {
+#ifdef DEBUG
+        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
+        {
+            /* This case covers option 3 */
+            p_FmPort->p_FmPortDriverParam->intContext.size = 112;
+            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 144;
+            p_FmPort->bufferOffsets.debugOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        }
+        else
+#endif /* DEBUG */
+        {
+            /* This case covers the options under 1 */
+            /* Copy size must be in 16-byte granularity. */
+            p_FmPort->p_FmPortDriverParam->intContext.size =
+                (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 : 0) +
+                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
+                          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 16 : 0));
+
+            /* Align start of internal context data to 16 byte */
+            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset =
+                (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 :
+                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp  ||
+                           p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 64 : 0));
+
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
+                p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
+                p_FmPort->bufferOffsets.timeStampOffset =  p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                            (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
+                                            p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
+                /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
+                p_FmPort->bufferOffsets.hashResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                              (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult) + 8) :
+                                              p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 8;
+        }
+    }
+
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins =
+        (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
+                   p_FmPort->p_FmPortDriverParam->intContext.size);
+#ifdef FM_CAPWAP_SUPPORT
+    /* save extra space for manip in both external and internal buffers */
+    if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace)
+    {
+        p_FmPort->bufferOffsets.manipOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
+        p_FmPort->p_FmPortDriverParam->internalBufferOffset =
+            (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
+    }
+#endif /* FM_CAPWAP_SUPPORT */
+
+    /* align data start */
+    tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins %
+                     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign);
+    if (tmp)
+        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-tmp);
+    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+    p_FmPort->internalBufferOffset = p_FmPort->p_FmPortDriverParam->internalBufferOffset;
+
+    return E_OK;
+}
+
+static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    uint32_t                            tmpReg;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t                   *p_BmiPrsNia=NULL;
+    volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
+    volatile uint32_t                   *p_BmiInitPrsResult=NULL;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    uint8_t                             hdrNum, L3HdrNum, greHdrNum;
+    int                                 i;
+    bool                                isEmptyClsPlanGrp;
+    uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint16_t                            absoluteProfileId;
+    uint8_t                             physicalSchemeId;
+    uint32_t                            ccTreePhysOffset;
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->netEnvId = (uint8_t)(PTR_TO_UINT(p_PcdParams->h_NetEnv)-1);
+
+    p_FmPort->pcdEngines = 0;
+
+    /* initialize p_FmPort->pcdEngines field in port's structure */
+    switch(p_PcdParams->pcdSupport)
+    {
+        case(e_FM_PORT_PCD_SUPPORT_NONE):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
+        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            break;
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+
+#ifdef FM_CAPWAP_SUPPORT
+        case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
+            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
+    }
+
+    if((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
+
+    /* check that parameters exist for each and only each defined engine */
+    if((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistant with pcdSupport"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+
+        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at lease one scheme must be bound. "));
+        /* for each scheme */
+        for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        {
+            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+            /* build vector */
+            p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
+        }
+
+        err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
+                                            p_FmPort->hardwarePortId,
+                                            p_FmPort->netEnvId,
+                                            p_FmPort->optArray,
+                                            &p_FmPort->clsPlanGrpId,
+                                            &isEmptyClsPlanGrp);
+         if(err)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
+
+         p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
+    }
+
+    /* set PCD port parameter */
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+    }
+
+    /***************************/
+    /* configure NIA after BMI */
+    /***************************/
+    if (!CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+        /* rfne may contain FDCS bits, so first we read them. */
+        p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+
+    /* If policer is used directly after BMI or PRS */
+    if((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
+        ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
+                (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+    {
+        absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_PcdParams->p_PlcrParams->h_Profile)-1);
+
+        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
+
+        tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
+
+        if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+        {
+            /* update BMI HPNIA */
+            WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
+        }
+        else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+            /* update BMI NIA */
+            p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
+    }
+
+#ifdef FM_CAPWAP_SUPPORT
+    /* if CC is used directly after BMI */
+    if((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
+        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG) ||
+        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR))
+    {
+        if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
+        p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+         /* check that prs start offset == RIM[FOF] */
+    }
+#endif /* FM_CAPWAP_SUPPORT */
+
+    if (p_FmPort->pcdEngines & FM_PCD_PRS)
+    {
+        /* if PRS is used it is always first */
+        GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
+        if (hdrNum == ILLEGAL_HDR_NUM)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+        if (!CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
+            p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
+        ASSERT_COND(p_PcdParams->p_PrsParams);
+        /* set after parser NIA */
+        tmpReg = 0;
+        switch(p_PcdParams->pcdSupport)
+        {
+            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                break;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+                tmpReg = NIA_KG_CC_EN;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+                if(p_PcdParams->p_KgParams->directScheme)
+                {
+                    physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_DirectScheme)-1);
+                    /* check that this scheme was bound to this port */
+                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                            break;
+                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
+                    tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
+                }
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
+                break;
+#if (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || defined(UNDER_CONSTRUCTION_IPSEC))
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+                WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                break;
+#endif /* (defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY) || ... */
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
+        }
+
+        /* set start parsing offset */
+        WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
+
+        /************************************/
+        /* Parser port parameters           */
+        /************************************/
+        /* stop before configuring */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+
+        /* set soft seq attachment register */
+        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+
+        /* set protocol options */
+        for(i=0;p_FmPort->optArray[i];i++)
+            switch(p_FmPort->optArray[i])
+            {
+                case(ETH_BROADCAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                    break;
+                case(ETH_MULTICAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                    break;
+                case(VLAN_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                    tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                    break;
+                case(MPLS_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                    break;
+                case(IPV4_BROADCAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                    break;
+                case(IPV4_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_BROADCAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                    break;
+                case(IPV6_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                    break;
+            }
+
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP))
+        {
+            p_PcdParams->p_PrsParams->additionalParams
+                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr = HEADER_TYPE_UDP;
+            p_PcdParams->p_PrsParams->additionalParams
+                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable = TRUE;
+            p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams++;
+        }
+
+        /* set MPLS default next header - HW reset workaround  */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+        tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
+        GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
+        tmpHxs[hdrNum] |= (uint32_t)L3HdrNum  << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+
+        /* for GRE, disable errors */
+        GET_PRS_HDR_NUM(greHdrNum, HEADER_TYPE_GRE);
+        tmpHxs[greHdrNum] |= PRS_HDR_ERROR_DIS;
+
+        /* config additional params for specific headers */
+        for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
+        {
+            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            if(hdrNum== ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+            if(hdrNum==NO_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
+
+            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpReg);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+            tmpHxs[hdrNum] |= tmpReg;
+        }
+#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            {
+               /* link to sw parser code for L4 shells - only if no other code is applied. */
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
+                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
+            }
+        }
+#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+
+        for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+        {
+            /* For all header set LCV as taken from netEnv*/
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            /* set HXS register according to default+Additional params+protocol options */
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+        }
+
+        /* set tpid. */
+        tmpReg = PRS_TPID_DFLT;
+        if(p_PcdParams->p_PrsParams->setVlanTpid1)
+        {
+            tmpReg &= PRS_TPID2_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
+        }
+        if(p_PcdParams->p_PrsParams->setVlanTpid2)
+        {
+            tmpReg &= PRS_TPID1_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
+        }
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
+
+        /* enable parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
+
+        if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+            p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+
+    } /* end parser */
+    else
+        p_FmPort->privateInfo = 0;
+
+    WRITE_UINT32(*p_BmiPrsStartOffset, GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
+
+    /* set initial parser result - used for all engines */
+    for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
+    {
+        if (!i)
+            WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
+                                                            | BMI_PRS_RESULT_HIGH));
+        else
+            if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
+            else
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
+    }
+
+    return E_OK;
+}
+
+static t_Error DeletePcd(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    if(!p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    /* "cut" PCD out of the port's flow - go to BMI */
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+    if(p_FmPort->pcdEngines | FM_PCD_PRS)
+    {
+        /* stop parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        p_FmPort->useClsPlan = FALSE;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        /* unbind - we need to get the treeId too */
+        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    p_FmPort->pcdEngines = 0;
+
+    return E_OK;
+}
+
+
+/********************************************/
+/*  Inter-module API                        */
+/********************************************/
+void FmPortSetMacsecLcv(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    uint32_t                    macsecEn = BMI_PORT_CFG_EN_MACSEC;
+    uint32_t                    lcv, walking1Mask = 0x80000000;
+    uint8_t                     cnt = 0;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
+        return;
+    }
+
+    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+    /* get LCV for MACSEC */
+    if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
+    {
+        while(!(lcv & walking1Mask))
+        {
+            cnt++;
+            walking1Mask >>= 1;
+        }
+
+        macsecEn |= (uint32_t)cnt << BMI_PORT_CFG_MS_SEL_SHIFT;
+     }
+
+     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
+}
+
+void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    uint32_t                    tmpReg;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Tx ports only"));
+        return;
+    }
+
+    p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfca;
+    tmpReg = GET_UINT32(*p_BmiCfgReg) & ~BMI_CMD_ATTR_MACCMD_MASK;
+    tmpReg |= BMI_CMD_ATTR_MACCMD_SECURED;
+    tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT) & BMI_CMD_ATTR_MACCMD_SC_MASK);
+
+    WRITE_UINT32(*p_BmiCfgReg, tmpReg);
+}
+
+uint8_t FmPortGetNetEnvId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->netEnvId;
+}
+
+uint8_t FmPortGetHardwarePortId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->hardwarePortId;
+}
+
+uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->pcdEngines;
+}
+
+t_Error FmPortAttachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
+pndn, pnen ... maybe were changed because of the Tree requirement*/
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    if(p_FmPort->requiredAction  & UPDATE_NIA_PNEN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
+
+    if(p_FmPort->requiredAction  & UPDATE_NIA_PNDN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    if(p_FmPort->requiredAction  & UPDATE_NIA_RFENE)
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiRfene);
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    return E_OK;
+}
+
+t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    int                 tmpInt;
+    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+
+    /* this function called from Cc for pass and receive parameters port params between CC and PORT*/
+
+    if((p_CcParams->getCcParams.type & OFFSET_OF_PR) && (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
+    {
+        p_CcParams->getCcParams.prOffset = (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
+        p_CcParams->getCcParams.type &= ~OFFSET_OF_PR;
+    }
+    if(p_CcParams->getCcParams.type & HW_PORT_ID)
+    {
+        p_CcParams->getCcParams.hardwarePortId = (uint8_t)p_FmPort->hardwarePortId;
+        p_CcParams->getCcParams.type &= ~HW_PORT_ID;
+    }
+    if((p_CcParams->getCcParams.type & OFFSET_OF_DATA) && (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
+    {
+        p_CcParams->getCcParams.dataOffset = (uint16_t)p_FmPort->bufferOffsets.dataOffset;
+        p_CcParams->getCcParams.type &= ~OFFSET_OF_DATA;
+    }
+    if(p_CcParams->getCcParams.type & NUM_OF_TASKS)
+    {
+        p_CcParams->getCcParams.numOfTasks = p_FmPort->numOfTasks;
+        p_CcParams->getCcParams.type &= ~NUM_OF_TASKS;
+    }
+    if(p_CcParams->getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+    {
+        if(p_CcParams->getCcParams.poolIndex < p_FmPort->extBufPools.numOfPoolsUsed)
+        {
+            p_CcParams->getCcParams.poolIdForManip = p_FmPort->extBufPools.extBufPool[p_CcParams->getCcParams.poolIndex].id;
+            p_CcParams->getCcParams.type &= ~BUFFER_POOL_ID_FOR_MANIP;
+        }
+    }
+
+    if((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) && !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
+    {
+        p_FmPort->requiredAction |= UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+    }
+
+    if((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) && !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
+    {
+        p_FmPort->savedQmiPnen = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_PNEN;
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
+    {
+       if(p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pnen was defined previously different"));
+    }
+
+    if((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN) && !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
+    {
+        p_FmPort->savedNonRxQmiRegsPndn = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_PNDN;
+    }
+    else if(p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+    {
+        if(p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pndn was defined previously different"));
+    }
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    if((p_CcParams->setCcParams.type & UPDATE_NIA_RFENE) && !(p_FmPort->requiredAction & UPDATE_NIA_RFENE))
+    {
+        p_FmPort->savedBmiRfene = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_RFENE;
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_RFENE)
+    {
+       if(p_FmPort->savedBmiRfene != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("rfene was defined previously different"));
+    }
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+    if((p_CcParams->setCcParams.type & UPDATE_PSO) && !(p_FmPort->requiredAction & UPDATE_PSO))
+    {
+        /* get PCD registers pointers */
+         switch(p_FmPort->portType)
+         {
+             case(e_FM_PORT_TYPE_RX_10G):
+             case(e_FM_PORT_TYPE_RX):
+                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+                 break;
+             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                 p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+                 break;
+             default:
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+         }
+        /* set start parsing offset */
+        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
+        if(tmpInt>0)
+            WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
+
+        p_FmPort->requiredAction |= UPDATE_PSO;
+        p_FmPort->savedPrsStartOffset = p_CcParams->setCcParams.psoSize;
+
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_PSO)
+    {
+        if(p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
+    }
+    return E_OK;
+}
+/**********************************         End of inter-module routines ********************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
+{
+    t_FmPort    *p_FmPort;
+    uintptr_t   baseAddr = p_FmPortParams->baseAddr;
+
+    /* Allocate FM structure */
+    p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
+    if (!p_FmPort)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver structure"));
+        return NULL;
+    }
+    memset(p_FmPort, 0, sizeof(t_FmPort));
+
+    /* Allocate the FM driver's parameters structure */
+    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(sizeof(t_FmPortDriverParam));
+    if (!p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver parameters"));
+        return NULL;
+    }
+    memset(p_FmPort->p_FmPortDriverParam, 0, sizeof(t_FmPortDriverParam));
+
+    /* Initialize FM port parameters which will be kept by the driver */
+    p_FmPort->portType      = p_FmPortParams->portType;
+    p_FmPort->portId        = p_FmPortParams->portId;
+    p_FmPort->pcdEngines    = FM_PCD_NONE;
+    p_FmPort->f_Exception   = p_FmPortParams->f_Exception;
+    p_FmPort->h_App         = p_FmPortParams->h_App;
+    p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
+
+    /* calculate global portId number */
+    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+
+    /* Initialize FM port parameters for initialization phase only */
+    p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
+                                                                    = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+#ifdef DEBUG
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo= DEFAULT_PORT_bufferPrefixContent_debugInfo;
+#endif /* DEBUG */
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
+    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
+
+    /* resource distribution. */
+    p_FmPort->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
+    p_FmPort->fifoBufs.extra                   = DEFAULT_PORT_extraSizeOfFifo(p_FmPort->portType);
+    p_FmPort->openDmas.num                     = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+    p_FmPort->openDmas.extra                   = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+    p_FmPort->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+    p_FmPort->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+    p_FmPort->numOfTasks = (uint8_t)p_FmPort->tasks.num;
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            p_FmPort->fifoBufs.extra           = 0;
+            p_FmPort->openDmas.extra           = 0;
+            p_FmPort->tasks.extra              = 0;
+        }
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
+
+    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
+#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+                p_FmPort->p_FmPortDriverParam->color              = e_FM_PORT_COLOR_OVERRIDE;
+    }
+#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
+
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        p_FmPort->p_FmPortDriverParam->syncReq          = DEFAULT_PORT_syncReqForHc;
+    else
+        p_FmPort->p_FmPortDriverParam->syncReq          = DEFAULT_PORT_syncReq;
+
+#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+                p_FmPort->p_FmPortDriverParam->syncReq              = FALSE;
+    }
+#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
+
+    /* Port type specific initialization: */
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+
+    switch(p_FmPort->portType)
+    {
+    case(e_FM_PORT_TYPE_RX):
+    case(e_FM_PORT_TYPE_RX_10G):
+        /* Initialize FM port parameters for initialization phase only */
+        p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
+        p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
+        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
+        p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
+        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+        break;
+
+    case(e_FM_PORT_TYPE_TX):
+        p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
+    p_FmPort->p_FmPortDriverParam->dontReleaseBuf                   = FALSE;
+    case(e_FM_PORT_TYPE_TX_10G):
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
+        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
+        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
+
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        {
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
+        }
+        break;
+
+    default:
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        return NULL;
+    }
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        p_FmPort->txFifoDeqPipelineDepth                            = OH_PIPELINE_DEPTH;
+
+    p_FmPort->imEn = p_FmPortParams->independentModeEnable;
+
+    if (p_FmPort->imEn)
+    {
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+            (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+            p_FmPort->txFifoDeqPipelineDepth = DEFAULT_PORT_txFifoDeqPipelineDepth_IM;
+        FmPortConfigIM(p_FmPort, p_FmPortParams);
+    }
+    else
+    {
+        switch(p_FmPort->portType)
+        {
+        case(e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+            /* Initialize FM port parameters for initialization phase only */
+            memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
+                   &p_FmPortParams->specificParams.rxParams.extBufPools,
+                   sizeof(t_FmPortExtPools));
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
+            p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+#ifdef FM_OP_PARTITION_ERRATA_FMANx8
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                p_FmPort->p_FmPortDriverParam->liodnOffset              = p_FmPortParams->specificParams.nonRxParams.opLiodnOffset;
+        }
+#endif /* FM_OP_PARTITION_ERRATA_FMANx8 */
+        case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
+                (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
+            break;
+        default:
+            XX_Free(p_FmPort->p_FmPortDriverParam);
+            XX_Free(p_FmPort);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            return NULL;
+        }
+    }
+
+    memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+    if(Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
+               FmGetId(p_FmPort->h_Fm),
+               ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
+                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
+                "OH" : (p_FmPort->portType == e_FM_PORT_TYPE_RX ?
+                        "1g-RX" : (p_FmPort->portType == e_FM_PORT_TYPE_TX ?
+                                   "1g-TX" : (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G ?
+                                              "10g-RX" : "10g-TX")))),
+               p_FmPort->portId) == 0)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
+    p_FmPort->h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPort->h_Spinlock)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
+    return p_FmPort;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortDriverParam             *p_Params;
+    t_Error                         err = E_OK;
+    t_FmInterModulePortInitParams   fmParams;
+    uint32_t                        minFifoSizeRequired = 0;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if ((err = BuildBufferStructure(p_FmPort)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* set memory map pointers */
+    p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(p_Params->baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
+
+    /* For O/H ports, check fifo size and update if necessary */
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    {
+        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
+        if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
+        {
+            p_FmPort->fifoBufs.num = minFifoSizeRequired;
+            DBG(WARNING, ("FIFO size enlarged to %d due to txFifoDeqPipelineDepth size", minFifoSizeRequired));
+        }
+    }
+
+    /* For Rx Ports, call the external Buffer routine which also checks fifo
+       size and updates it if necessary */
+    if(((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        && !p_FmPort->imEn)
+    {
+        /* define external buffer pools and pool depletion*/
+        err = SetExtBufferPools(p_FmPort);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    /************************************************************/
+    /* Call FM module routine for communicating parameters      */
+    /************************************************************/
+    memset(&fmParams, 0, sizeof(fmParams));
+    fmParams.hardwarePortId     = p_FmPort->hardwarePortId;
+    fmParams.portType           = (e_FmPortType)p_FmPort->portType;
+    fmParams.numOfTasks         = (uint8_t)p_FmPort->tasks.num;
+    fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
+    fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
+    fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
+    fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
+    fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
+    fmParams.independentMode    = p_FmPort->imEn;
+    fmParams.liodnOffset        = p_Params->liodnOffset;
+    fmParams.liodnBase          = p_Params->liodnBase;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_FmPort->tasks.num        = fmParams.numOfTasks;
+    p_FmPort->tasks.extra      = fmParams.numOfExtraTasks;
+    p_FmPort->openDmas.num     = fmParams.numOfOpenDmas;
+    p_FmPort->openDmas.extra   = fmParams.numOfExtraOpenDmas;
+    p_FmPort->fifoBufs.num     = fmParams.sizeOfFifo;
+    p_FmPort->fifoBufs.extra   = fmParams.extraSizeOfFifo;
+
+    /* get params for use in init */
+    p_Params->fmMuramPhysBaseAddr =
+        (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
+                   ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            err = BmiRxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            err = BmiTxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            err = BmiOhPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+    if (!p_FmPort->imEn && ((err = QmiInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPortDriverParamFree(p_FmPort);
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmInterModulePortFreeParams       fmParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if(p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
+
+    if (p_FmPort->enabled)
+    {
+        /* Force the disable if the port still enabled */
+        p_FmPort->enabled = 1;
+        FM_PORT_Disable(p_FmPort);
+    }
+
+    if (p_FmPort->h_Spinlock)
+        XX_FreeSpinlock(p_FmPort->h_Spinlock);
+
+    FmPortDriverParamFree(p_FmPort);
+
+    if (p_FmPort->imEn)
+        FmPortImFree(p_FmPort);
+
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+    FmFreePortParams(p_FmPort->h_Fm, &fmParams);
+
+    XX_Free(p_FmPort);
+
+    return E_OK;
+}
+
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqType = deqType;
+
+    return E_OK;
+}
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
+    return E_OK;
+}
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_BackupBmPools)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+#ifdef FM_NO_BACKUP_POOLS
+    {
+    t_FmRevisionInfo    revInfo;
+
+    FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+    if (revInfo.majorRev < 4)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigBackupPools"));
+    }
+#endif /* FM_NO_BACKUP_POOLS */
+
+    p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmPortBackupBmPools *)XX_Malloc(sizeof(t_FmPortBackupBmPools));
+    if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
+    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmPortBackupBmPools));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmPortBufferPrefixContent, sizeof(t_FmPortBufferPrefixContent));
+    /* if dataAlign was not initialized by user, we return to driver's deafult */
+    if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
+        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx & Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmPortBufPoolDepletion));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+
+    p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, &p_FmPortObservedBufPoolDepletion->poolDepletionParams, sizeof(t_FmPortBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, &p_FmPortObservedBufPoolDepletion->poolsParams, sizeof(t_FmPortExtPools));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmPortExtPools, sizeof(t_FmPortExtPools));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
+
+    p_FmPort->txFifoDeqPipelineDepth = deqPipelineDepth;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDfltColor!"));
+    }
+#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
+    p_FmPort->p_FmPortDriverParam->color = color;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+#ifdef FM_PORT_SYNC_ERRATA_FMAN6
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("port-sync!"));
+    }
+#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
+
+    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+
+    return E_OK;
+}
+
+
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
+
+    return E_OK;
+}
+
+
+/****************************************************/
+/*       PCD Advaced config API                     */
+/****************************************************/
+
+/****************************************************/
+/*       API Run-time Control unit functions        */
+/****************************************************/
+
+t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_NumOfOpenDmas->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
+
+    if((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if(p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfOpenDmas->num, (uint8_t)p_NumOfOpenDmas->extra, FALSE);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    memcpy(&p_FmPort->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
+
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_NumOfTasks->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
+
+    if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if(p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+
+    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t)p_NumOfTasks->num, (uint8_t)p_NumOfTasks->extra, FALSE);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* update driver's struct */
+    memcpy(&p_FmPort->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
+    return E_OK;
+}
+
+t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err;
+    t_FmInterModulePortRxPoolsParams    rxPoolsParams;
+    uint32_t                            minFifoSizeRequired;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
+            (p_SizeOfFifo->extra))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
+    }
+#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
+    if(!p_SizeOfFifo->num || (p_SizeOfFifo->num > BMI_MAX_FIFO_SIZE))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(p_SizeOfFifo->num % BMI_FIFO_UNITS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* extra FIFO size (allowed only to Rx ports) */
+         if(p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
+    }
+    else
+        if(p_SizeOfFifo->extra)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
+
+    /* For O/H ports, check fifo size and update if necessary */
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    {
+        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
+        if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
+        {
+            p_FmPort->fifoBufs.num = minFifoSizeRequired;
+            DBG(INFO, ("FIFO size enlarged to %d", minFifoSizeRequired));
+        }
+    }
+    memcpy(&rxPoolsParams, &p_FmPort->rxPoolsParams, sizeof(rxPoolsParams));
+    err = FmSetSizeOfFifo(p_FmPort->h_Fm,
+                            p_FmPort->hardwarePortId,
+                            p_FmPort->portType,
+                            p_FmPort->imEn,
+                            &p_SizeOfFifo->num,
+                            p_SizeOfFifo->extra,
+                            p_FmPort->txFifoDeqPipelineDepth,
+                            &rxPoolsParams,
+                            FALSE);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* update driver's structure AFTER the FM routine, as it may change by the FM. */
+    memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    return p_FmPort->bufferOffsets.dataOffset;
+}
+
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.pcdInfoOffset);
+}
+
+#ifdef DEBUG
+uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPort->bufferOffsets.debugOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.debugOffset);
+}
+#endif /* DEBUG */
+
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (t_FmPrsResult *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.prsResultOffset);
+}
+
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint64_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.timeStampOffset);
+}
+
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    if(p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.hashResultOffset);
+}
+
+t_Error FM_PORT_Disable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    volatile uint32_t           *p_BmiStatusReg = NULL;
+    uint32_t                    intFlags;
+    bool                        rxPort = FALSE;
+    int                         tries;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    p_FmPort->enabled--;
+    /* If the port is enabled and we're not in the first time, just decrement the counter and skip */
+    if (p_FmPort->enabled > 0)
+    {
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+        return E_OK;
+    }
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+    SANITY_CHECK_RETURN_ERROR((p_FmPort->enabled == 0), E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    /* Disable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & ~QMI_PORT_CFG_EN);
+        /* wait for QMI to finish Handling dequeue tnums */
+        tries=1000;
+        while ((GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) &&
+                --tries)
+            XX_UDelay(1);
+        if (!tries)
+            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+    }
+
+    /* Disable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
+
+
+    if (p_FmPort->imEn)
+        FmPortImDisable(p_FmPort);
+
+    tries=5000;
+    while ((GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) &&
+            --tries)
+        XX_UDelay(1);
+
+    if (!tries)
+        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_Enable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    bool                        rxPort = FALSE;
+    uint32_t                    intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    /* If the port already enabled just increment the counter and skip */
+    if (p_FmPort->enabled > 0)
+    {
+        p_FmPort->enabled++;
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+        return E_OK;
+    }
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, intFlags);
+
+    if (p_FmPort->imEn)
+        FmPortImEnable(p_FmPort);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    /* Enable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
+
+    /* Enable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+
+    p_FmPort->enabled = 1;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t            tmpRateLimit, tmpRateLimitScale;
+    volatile uint32_t   *p_RateLimitReg, *p_RateLimitScaleReg;
+    uint8_t             factor, countUnitBit;
+    uint16_t            baseGran;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
+            baseGran = 16000;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
+            baseGran = 10000;
+           break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);  /* TimeStamp per nano seconds units */
+    /* normally, we use 1 usec as the reference count */
+    factor = 1;
+    /* if ratelimit is too small for a 1usec factor, multiply the factor */
+    while (p_RateLimit->rateLimit < baseGran/factor)
+    {
+        if (countUnitBit==31)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
+
+        countUnitBit++;
+        factor <<= 1;
+    }
+    /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
+    if (p_RateLimit->rateLimit > ((uint32_t)baseGran * (1<<10) * (uint32_t)factor))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
+
+    tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
+
+    if(!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
+
+    tmpRateLimitScale = ((31 - (uint32_t)countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
+
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+    else
+    {
+#ifndef FM_NO_ADVANCED_RATE_LIMITER
+        t_FmRevisionInfo    revInfo;
+
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if (revInfo.majorRev >= 4)
+        {
+            switch(p_RateLimit->rateLimitDivider)
+            {
+                case(e_FM_PORT_DUAL_RATE_LIMITER_NONE):
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
+                    break;
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
+                    tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
+                    break;
+                default:
+                    break;
+            }
+            tmpRateLimit |= BMI_RATE_LIMIT_BURST_SIZE_GRAN;
+        }
+        else
+#endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
+        {
+            if(p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
+
+            if(p_RateLimit->maxBurstSize % 1000)
+            {
+                p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
+                DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
+            }
+            else
+                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize/1000);
+        }
+        tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+
+    }
+    WRITE_UINT32(*p_RateLimitScaleReg, tmpRateLimitScale);
+    WRITE_UINT32(*p_RateLimitReg, tmpRateLimit);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t   *p_RateLimitReg, *p_RateLimitScaleReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
+            p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
+           break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    WRITE_UINT32(*p_RateLimitScaleReg, 0);
+    WRITE_UINT32(*p_RateLimitReg, 0);
+
+    return E_OK;
+}
+
+
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
+    if(enable)
+        tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
+    else
+        tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
+
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_BmiPcReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    if(enable)
+        WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
+    else
+        WRITE_UINT32(*p_BmiPcReg, 0);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiPcpReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    /* check parameters */
+    if (!p_FmPortPerformanceCnt->taskCompVal ||
+        (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("performanceCnt.taskCompVal has to be in the range of 1 - %d (current value)!",
+                      p_FmPort->tasks.num));
+    if (!p_FmPortPerformanceCnt->dmaCompVal ||
+        (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("performanceCnt.dmaCompVal has to be in the range of 1 - %d (current value)!",
+                      p_FmPort->openDmas.num));
+    if (!p_FmPortPerformanceCnt->fifoCompVal ||
+        (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("performanceCnt.fifoCompVal has to be in the range of 256 - %d (current value)!",
+                      p_FmPort->fifoBufs.num));
+    if (p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("performanceCnt.fifoCompVal has to be divisible by %d",
+                      BMI_FIFO_UNITS));
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            if (!p_FmPortPerformanceCnt->queueCompVal ||
+                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
+                              MAX_PERFORMANCE_RX_QUEUE_COMP));
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            if (!p_FmPortPerformanceCnt->queueCompVal ||
+                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
+                              MAX_PERFORMANCE_TX_QUEUE_COMP));
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            if (p_FmPortPerformanceCnt->queueCompVal)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    tmpReg = 0;
+    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
+    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
+    tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        tmpReg |= ((uint32_t)(p_FmPortPerformanceCnt->taskCompVal - 1) << BMI_PERFORMANCE_TASK_COMP_SHIFT);
+
+    WRITE_UINT32(*p_BmiPcpReg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortPerformanceCnt  currParams, savedParams;
+    t_Error                 err;
+    bool                    underTest, failed = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    XX_Print("Analyzing Performance parameters for port (type %d, id%d)\n",
+             p_FmPort->portType, p_FmPort->portId);
+
+    currParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        currParams.queueCompVal   = 0;
+    else
+        currParams.queueCompVal   = 1;
+    currParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
+    currParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+
+    FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
+    ClearPerfCnts(p_FmPort);
+    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
+    XX_UDelay(1000000);
+    FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
+    if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
+    {
+        XX_Print ("Max num of defined port tasks (%d) utilized - Please enlarge\n",p_FmPort->tasks.num);
+        failed = TRUE;
+    }
+    if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
+    {
+        XX_Print ("Max num of defined port openDmas (%d) utilized - Please enlarge\n",p_FmPort->openDmas.num);
+        failed = TRUE;
+    }
+    if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
+    {
+        XX_Print ("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num*BMI_FIFO_UNITS);
+        failed = TRUE;
+    }
+    if (failed)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+
+    memset(&savedParams, 0, sizeof(savedParams));
+    while (TRUE)
+    {
+        underTest = FALSE;
+        if ((currParams.taskCompVal != 1) && !savedParams.taskCompVal)
+        {
+            currParams.taskCompVal--;
+            underTest = TRUE;
+        }
+        if ((currParams.dmaCompVal != 1) && !savedParams.dmaCompVal)
+        {
+            currParams.dmaCompVal--;
+            underTest = TRUE;
+        }
+        if ((currParams.fifoCompVal != BMI_FIFO_UNITS) && !savedParams.fifoCompVal)
+        {
+            currParams.fifoCompVal -= BMI_FIFO_UNITS;
+            underTest = TRUE;
+        }
+        if (!underTest)
+            break;
+
+        ClearPerfCnts(p_FmPort);
+        if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
+        XX_UDelay(1000000);
+        FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
+
+        if (!savedParams.taskCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
+            savedParams.taskCompVal = (uint8_t)(currParams.taskCompVal+2);
+        if (!savedParams.dmaCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
+            savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal+2);
+        if (!savedParams.fifoCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
+            savedParams.fifoCompVal = currParams.fifoCompVal+2;
+    }
+
+    XX_Print("best vals: tasks %d, dmas %d, fifos %d\n",
+             savedParams.taskCompVal, savedParams.dmaCompVal, savedParams.fifoCompVal);
+    return E_OK;
+}
+
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiStcReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+    }
+
+    tmpReg = GET_UINT32(*p_BmiStcReg);
+
+    if(enable)
+        tmpReg |= BMI_COUNTERS_EN;
+    else
+        tmpReg &= ~BMI_COUNTERS_EN;
+
+    WRITE_UINT32(*p_BmiStcReg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if (GET_UINT32(*p_ErrDiscard) & errs)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Selectd Errors that were configured to cause frame discard."));
+
+    WRITE_UINT32(*p_ErrQReg, errs);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    int                     i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
+    {
+        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
+        {
+            if(enable)
+                tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
+            else
+                tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], tmpReg);
+            break;
+        }
+    }
+    if (i == FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                return 0;
+            }
+            bmiCounter = FALSE;
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+            break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+                return 0;
+        }
+        return GET_UINT32(*p_Reg);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        {
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            return 0;
+        }
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                return 0;
+        }
+    }
+
+    return 0;
+}
+
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+            break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                 break;
+            default:
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+        }
+        WRITE_UINT32(*p_Reg, value);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
+                break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
+                break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
+                break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+        }
+    }
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        return 0;
+    }
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                    return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
+                else
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+                    return 0;
+                }
+            }
+        }
+    }
+    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    return 0;
+}
+
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+{
+    t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                {
+                    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
+                    return E_OK;
+                }
+                else
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+            }
+        }
+    }
+    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+}
+
+bool FM_PORT_IsStalled(t_Handle h_FmPort)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error     err;
+    bool        isStalled;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
+
+    err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
+    if(err != E_OK)
+    {
+        REPORT_ERROR(MINOR, err, NO_MSG);
+        return TRUE;
+    }
+    return isStalled;
+}
+
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    return FmResumeStalledPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+}
+
+t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);
+    if (l4Checksum)
+        tmpReg &= ~BMI_PORT_RFNE_FRWD_DCL4C;
+    else
+        tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, tmpReg);
+
+    return E_OK;
+}
+
+
+/*       API Run-time PCD Control unit functions        */
+
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err = E_OK;
+
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    if(numOfProfiles)
+    {
+        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err = E_OK;
+
+    err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_BmiHpnia = NULL;
+    uint32_t                tmpReg;
+    uint8_t                 relativeSchemeId;
+    uint8_t                 physicalSchemeId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    /* if we want to change to direct scheme, we need to check that this scheme is valid */
+    if(p_FmPcdKgScheme->direct)
+    {
+        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_FmPcdKgScheme->h_DirectScheme)-1);
+        /* check that this scheme is bound to this port */
+        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
+        }
+
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
+        }
+
+        if(!FmPcdKgIsSchemeValidSw(p_FmPort->h_FmPcd, relativeSchemeId))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
+        }
+
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
+    }
+    else /* change to indirect scheme */
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t               *p_BmiNia;
+    volatile uint32_t               *p_BmiHpnia;
+    uint32_t                        tmpReg;
+    uint16_t                        absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
+
+    /* check relevancy of this routine  - only when policer is used
+    directly after BMI or Parser */
+    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            tmpReg = 0;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
+    }
+
+    tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
+
+    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    {
+        /* update BMI HPNIA */
+        WRITE_UINT32(*p_BmiHpnia, tmpReg);
+    }
+    else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+    {
+        /* rfne may contain FDCS bits, so first we read them. */
+        tmpReg |= (GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK);
+        /* update BMI NIA */
+        WRITE_UINT32(*p_BmiNia, tmpReg);
+    }
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+
+t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    uint32_t                            ccTreePhysOffset;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+/*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
+         it has to be returned to the default state - initially*/
+
+    p_FmPort->requiredAction = 0;
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+                break;
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        }
+
+        if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+            return ERROR_CODE(E_BUSY);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset, h_FmPort);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+
+        p_FmPort->ccTreeId = h_CcTree;
+        RELEASE_LOCK(p_FmPort->lock);
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse CLassification not defined for this port."));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
+{
+
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* TODO - may add here checks for:
+        SP (or in sw: schemes)
+        CPP (or in sw clsPlan)
+        Parser enabled and configured(?)
+        Tree(?)
+        Profile - only if direct.
+        Scheme - only if direct
+    */
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    err = FmPortAttachPCD(h_FmPort);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+/*TODO - not atomic - it seems that port has to be disabled*/
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_RX):
+            case(e_FM_PORT_TYPE_RX_10G):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+                break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
+    {
+        /*TODO - check!!*/
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+    uint8_t                                 i;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    err = SetPcd( h_FmPort, p_PcdParams);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        schemeBind.netEnvId = p_FmPort->netEnvId;
+        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
+        schemeBind.useClsPlan = p_FmPort->useClsPlan;
+        for(i = 0;i<schemeBind.numOfSchemes;i++)
+            schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+
+        err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+        {
+            DeletePcd(p_FmPort);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+
+    FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    err = FmPortAttachPCD(h_FmPort);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        /* unbind all schemes */
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
+
+        err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    /* we do it anyway, instead of checking if included */
+    if (FmIsMaster(p_FmPort->h_Fm) &&
+        (p_FmPort->pcdEngines & FM_PCD_PRS))
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+
+    FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    err = DeletePcd( h_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+    uint32_t                                tmpScmVec=0;
+    int                                     i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    schemeBind.useClsPlan = p_FmPort->useClsPlan;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
+        schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
+    }
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector |= tmpScmVec;
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
+    uint32_t                                tmpScmVec=0;
+    int                                     i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
+        schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
+    }
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector &= ~tmpScmVec;
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t   *p_BmiNia = NULL;
+    uint32_t            tmpReg;
+    uint8_t             hdrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            tmpReg = 0;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+        return ERROR_CODE(E_BUSY);
+    /* set the first header */
+    GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
+    if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+    }
+    WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
+
+    /* set start parsing offset */
+    WRITE_UINT32(*p_BmiPrsStartOffset, p_FmPcdPrsStart->parsingOffset);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error             err = E_OK;
+    char                arr[30];
+    uint8_t             flag;
+    int                 i=0;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
+
+    switch (p_FmPort->portType)
+    {
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            strcpy(arr, "PORT_TYPE_OFFLINE_PARSING");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            strcpy(arr, "PORT_TYPE_HOST_COMMAND");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_RX):
+            strcpy(arr, "PORT_TYPE_RX");
+            flag = 1;
+            break;
+        case (e_FM_PORT_TYPE_RX_10G):
+            strcpy(arr, "PORT_TYPE_RX_10G");
+            flag = 1;
+            break;
+        case (e_FM_PORT_TYPE_TX):
+            strcpy(arr, "PORT_TYPE_TX");
+            flag = 2;
+            break;
+        case (e_FM_PORT_TYPE_TX_10G):
+            strcpy(arr, "PORT_TYPE_TX_10G");
+            flag = 2;
+            break;
+        default:
+            return ERROR_CODE(E_INVALID_VALUE);
+    }
+
+    DUMP_TITLE(UINT_TO_PTR(p_FmPort->hardwarePortId), ("PortId for %s %d", arr, p_FmPort->portId ));
+    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
+
+    err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch(flag)
+    {
+        case(0):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
+
+        {
+#ifndef FM_NO_OP_OBSERVED_POOLS
+            t_FmRevisionInfo    revInfo;
+
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if (revInfo.majorRev >= 4)
+#endif /* !FM_NO_OP_OBSERVED_POOLS */
+            {
+                DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
+
+                DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS)
+                {
+                    DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi[i], sizeof(uint32_t));
+                }
+                DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
+            }
+        }
+
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
+        break;
+    case(1):
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm, ("fmbm_cgm"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[i], sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_mpd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdbg);
+        break;
+    case(2):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
+        break;
+
+   default:
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
+    }
+
+    DUMP_TITLE(p_FmPort->p_FmPortQmiRegs, ("Qmi Port Regs"));
+
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnc);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pns);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnts);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
+
+    if(flag !=1)
+    {
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndtfc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndcc);
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS], opPort;
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    {
+#ifdef FM_NO_OP_OBSERVED_CGS
+        t_FmRevisionInfo    revInfo;
+
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if (revInfo.majorRev <4)
+        {
+            if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+        }
+        else
+#endif /* FM_NO_OP_OBSERVED_CGS */
+        if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    }
+
+    opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
+                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg |=  (0x00000001 << (uint32_t)mod);
+
+        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+        {
+            if(opPort)
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
+            else
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32], tmpReg);
+        }
+    }
+
+    return  E_OK;
+}
+
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS], opPort;
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    {
+#ifdef FM_NO_OP_OBSERVED_CGS
+        t_FmRevisionInfo    revInfo;
+
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if (revInfo.majorRev <4)
+        {
+            if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+        }
+        else
+#endif /* FM_NO_OP_OBSERVED_CGS */
+        if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    }
+
+    opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
+                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg &=  ~(0x00000001 << (uint32_t)mod);
+
+        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+        {
+            if(opPort)
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
+            else
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32], tmpReg);
+        }
+    }
+
+    return  E_OK;
+}
+
+#ifdef UNDER_CONSTRUCTION_IPSEC
+t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+#ifdef FM_DISABLE_SEC_ERRORS
+    if (workarounds & FM_OP_PORT_WA_SEC_ERR)
+    {
+        t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_NO_PCD);
+
+        memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_FETCH | NIA_ENG_FM_CTL);
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+#endif /* FM_DISABLE_SEC_ERRORS */
+#ifdef SEC_IPV6_UDP_CHECKSUM_UPDATE
+    if (workarounds & FM_OP_PORT_WA_DISABLE_UDP_CKSM)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* SEC_IPV6_UDP_CHECKSUM_UPDATE */
+#ifdef FM_ETH_TYPE_FIX
+    if (workarounds & FM_OP_PORT_WA_ETH_TYPE)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* FM_ETH_TYPE_FIX */
+#ifdef FM_NO_COPY_CTXA_CTXB_ERRATA_FMAN_SW001
+    if (workarounds & FM_OP_PORT_WA_COPY_CTXB)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* FM_NO_COPY_CTXA_CTXB_ERRATA_FMAN_SW001 */
+#ifdef SEC_UDP_LENGTH_UPDATE
+    if (workarounds & FM_OP_PORT_WA_UPDATE_UDP_LEN)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN);
+    }
+#endif /* SEC_UDP_LENGTH_UPDATE */
+
+    return E_OK;
+}
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
new file mode 100644
index 0000000..d0e81a6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -0,0 +1,893 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.h
+
+ @Description   FM Port internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PORT_H
+#define __FM_PORT_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_port_ext.h"
+
+#include "fm_common.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_PORT
+
+
+#define MIN_EXT_BUF_SIZE                                64
+#define DATA_ALIGNMENT                                  64
+#define MAX_LIODN_OFFSET                                64
+
+/**************************************************************************//**
+ @Description       Memory Map defines
+*//***************************************************************************/
+#define BMI_PORT_REGS_OFFSET                            0
+#define QMI_PORT_REGS_OFFSET                            0x400
+#define PRS_PORT_REGS_OFFSET                            0x800
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_PORT_deqHighPriority                    TRUE
+#define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+#define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_FULL_PREFETCH
+#define DEFAULT_PORT_deqPrefetchOption_HC               e_FM_PORT_DEQ_NO_PREFETCH
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+#define DEFAULT_PORT_deqByteCnt                         2000
+#define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
+#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  FALSE
+#define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
+#define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo    FALSE
+#ifdef DEBUG
+#define DEFAULT_PORT_bufferPrefixContent_debugInfo      FALSE
+#endif /* DEBUG */
+#define DEFAULT_PORT_bufferPrefixContent_dataAlign      DATA_ALIGNMENT
+#define DEFAULT_PORT_cheksumLastBytesIgnore             0
+#define DEFAULT_PORT_cutBytesFromEnd                    4
+#define DEFAULT_PORT_txFifoMinFillLevel                 0
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          2
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          2
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         8
+#define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
+#define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
+#define DEFAULT_PORT_frmDiscardOverride                 FALSE
+#define DEFAULT_PORT_dmaSwapData                        e_FM_PORT_DMA_NO_SWP
+#define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaHeaderCacheAttr                 e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaScatterGatherCacheAttr          e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaWriteOptimize                   TRUE
+#define DEFAULT_PORT_forwardIntContextReuse             FALSE
+#define DEFAULT_PORT_BufMargins_startMargins            32
+#define DEFAULT_PORT_BufMargins_endMargins              0
+#define DEFAULT_PORT_syncReq                            TRUE
+#define DEFAULT_PORT_syncReqForHc                       FALSE
+#define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
+#define DEFAULT_PORT_errorsToDiscard                    FM_PORT_FRM_ERR_CLS_DISCARD
+#define DEFAULT_dualRateLimitScaleDown                  e_FM_PORT_DUAL_RATE_LIMITER_NONE
+#define DEFAULT_rateLimitBurstSizeHighGranularity       FALSE
+#define DEFAULT_exception                               IM_EV_BSY
+
+/* Host command port MUST NOT be changed to more than 1 !!! */
+#define DEFAULT_PORT_numOfTasks(type)                       \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 16 :   \
+               ((((type) == e_FM_PORT_TYPE_RX) ||           \
+                 ((type) == e_FM_PORT_TYPE_TX) ||           \
+                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 3 : 1))
+
+#define DEFAULT_PORT_extraNumOfTasks(type)                  \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
+               ((((type) == e_FM_PORT_TYPE_RX) ||           \
+                 ((type) == e_FM_PORT_TYPE_TX) ||           \
+                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
+
+#define DEFAULT_PORT_numOfOpenDmas(type)                \
+    (uint32_t)(((type) == e_FM_PORT_TYPE_TX_10G) ? 8 :  \
+               (((type) == e_FM_PORT_TYPE_RX_10G) ? 4 : 1))
+
+#define DEFAULT_PORT_extraNumOfOpenDmas(type)               \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
+               ((((type) == e_FM_PORT_TYPE_RX) ||           \
+                 ((type) == e_FM_PORT_TYPE_TX) ||           \
+                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 1 : 0))
+
+#ifdef CONFIG_FMAN_P1023
+#define DEFAULT_PORT_sizeOfFifo(type)                               \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||                  \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :  \
+               ((type == e_FM_PORT_TYPE_RX) ? (10*KILOBYTE) : \
+                ((type == e_FM_PORT_TYPE_TX) ? (10*KILOBYTE + KILOBYTE*3/4) : \
+                 ((type == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? (1536) : 1536 /* HC */))))
+#else
+#define DEFAULT_PORT_sizeOfFifo(type)                                   \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||                    \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :    \
+               ((((type) == e_FM_PORT_TYPE_RX) ||                       \
+                 ((type) == e_FM_PORT_TYPE_TX) ||                       \
+                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1536)))
+#endif
+
+#define DEFAULT_PORT_extraSizeOfFifo(type)                          \
+    (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G) ? (8*KILOBYTE) :   \
+               (((type) == e_FM_PORT_TYPE_RX) ? (4*KILOBYTE) : (0)))
+
+#define DEFAULT_PORT_txBdRingLength                 16
+#define DEFAULT_PORT_rxBdRingLength                 128
+#define DEFAULT_PORT_ImfwExtStructsMemId            0
+#define DEFAULT_PORT_ImfwExtStructsMemAttr          MEMORY_ATTR_CACHEABLE
+
+#define OH_PIPELINE_DEPTH                           2
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS   8
+#define FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS 256
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
+    volatile uint32_t   fmbm_rst;       /**< Rx Status */
+    volatile uint32_t   fmbm_rda;       /**< Rx DMA attributes*/
+    volatile uint32_t   fmbm_rfp;       /**< Rx FIFO Parameters*/
+    volatile uint32_t   fmbm_rfed;      /**< Rx Frame End Data*/
+    volatile uint32_t   fmbm_ricp;      /**< Rx Internal Context Parameters*/
+    volatile uint32_t   fmbm_rim;       /**< Rx Internal Buffer Margins*/
+    volatile uint32_t   fmbm_rebm;      /**< Rx External Buffer Margins*/
+    volatile uint32_t   fmbm_rfne;      /**< Rx Frame Next Engine*/
+    volatile uint32_t   fmbm_rfca;      /**< Rx Frame Command Attributes.*/
+    volatile uint32_t   fmbm_rfpne;     /**< Rx Frame Parser Next Engine*/
+    volatile uint32_t   fmbm_rpso;      /**< Rx Parse Start Offset*/
+    volatile uint32_t   fmbm_rpp;       /**< Rx Policer Profile  */
+    volatile uint32_t   fmbm_rccb;      /**< Rx Coarse Classification Base */
+    volatile uint32_t   reserved1[2];   /**< (0x038 0x03F) */
+    volatile uint32_t   fmbm_rprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
+                                        /**< Rx Parse Results Array Initialization*/
+    volatile uint32_t   fmbm_rfqid;     /**< Rx Frame Queue ID*/
+    volatile uint32_t   fmbm_refqid;    /**< Rx Error Frame Queue ID*/
+    volatile uint32_t   fmbm_rfsdm;     /**< Rx Frame Status Discard Mask*/
+    volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
+    volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
+    volatile uint32_t   reserved2[0x23];/**< (0x074 0x0FF)  */
+    volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
+                                        /**< Buffer Manager pool Information-*/
+    volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
+                                        /**< Allocate Counter-*/
+    volatile uint32_t   reserved3[8];
+                                        /**< 0x130/0x140 - 0x15F reserved -*/
+    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
+                                        /**< Congestion Group Map*/
+    volatile uint32_t   fmbm_mpd;       /**< BM Pool Depletion  */
+    volatile uint32_t   reserved4[0x1F];/**< (0x184 0x1FF) */
+    volatile uint32_t   fmbm_rstc;      /**< Rx Statistics Counters*/
+    volatile uint32_t   fmbm_rfrc;      /**< Rx Frame Counter*/
+    volatile uint32_t   fmbm_rfbc;      /**< Rx Bad Frames Counter*/
+    volatile uint32_t   fmbm_rlfc;      /**< Rx Large Frames Counter*/
+    volatile uint32_t   fmbm_rffc;      /**< Rx Filter Frames Counter*/
+    volatile uint32_t   fmbm_rfcd;      /**< Rx Frame Discard Counter*/
+    volatile uint32_t   fmbm_rfldec;    /**< Rx Frames List DMA Error Counter*/
+    volatile uint32_t   fmbm_rodc;      /**< Rx Out of Buffers Discard Counter-*/
+    volatile uint32_t   fmbm_rbdc;      /**< Rx Buffers Deallocate Counter-*/
+    volatile uint32_t   reserved5[0x17];/**< (0x224 0x27F) */
+    volatile uint32_t   fmbm_rpc;       /**< Rx Performance Counters*/
+    volatile uint32_t   fmbm_rpcp;      /**< Rx Performance Count Parameters*/
+    volatile uint32_t   fmbm_rccn;      /**< Rx Cycle Counter*/
+    volatile uint32_t   fmbm_rtuc;      /**< Rx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_rrquc;     /**< Rx Receive Queue Utilization Counter*/
+    volatile uint32_t   fmbm_rduc;      /**< Rx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_rfuc;      /**< Rx FIFO Utilization Counter*/
+    volatile uint32_t   fmbm_rpac;      /**< Rx Pause Activation Counter*/
+    volatile uint32_t   reserved6[0x18];/**< (0x2A0 0x2FF) */
+    volatile uint32_t   fmbm_rdbg;      /**< Rx Debug-*/
+} _PackedType t_FmPortRxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_tcfg;      /**< Tx Configuration */
+    volatile uint32_t   fmbm_tst;       /**< Tx Status */
+    volatile uint32_t   fmbm_tda;       /**< Tx DMA attributes */
+    volatile uint32_t   fmbm_tfp;       /**< Tx FIFO Parameters */
+    volatile uint32_t   fmbm_tfed;      /**< Tx Frame End Data */
+    volatile uint32_t   fmbm_ticp;      /**< Tx Internal Context Parameters */
+    volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine. */
+    volatile uint32_t   fmbm_tfca;      /**< Tx Frame Command attribute. */
+    volatile uint32_t   fmbm_tcfqid;    /**< Tx Confirmation Frame Queue ID. */
+    volatile uint32_t   fmbm_tfeqid;    /**< Tx Frame Error Queue ID */
+    volatile uint32_t   fmbm_tfene;     /**< Tx Frame Enqueue Next Engine */
+    volatile uint32_t   fmbm_trlmts;    /**< Tx Rate Limiter Scale */
+    volatile uint32_t   fmbm_trlmt;     /**< Tx Rate Limiter */
+    volatile uint32_t   reserved0[0x73];/**< (0x038-0x200) */
+    volatile uint32_t   fmbm_tstc;      /**< Tx Statistics Counters */
+    volatile uint32_t   fmbm_tfrc;      /**< Tx Frame Counter */
+    volatile uint32_t   fmbm_tfdc;      /**< Tx Frames Discard Counter */
+    volatile uint32_t   fmbm_tfledc;    /**< Tx Frame Length error discard counter */
+    volatile uint32_t   fmbm_tfufdc;    /**< Tx Frame unsupported format discard Counter */
+    volatile uint32_t   fmbm_tbdc;      /**< Tx Buffers Deallocate Counter */
+    volatile uint32_t   reserved1[0x1A];/**< (0x218-0x280) */
+    volatile uint32_t   fmbm_tpc;       /**< Tx Performance Counters*/
+    volatile uint32_t   fmbm_tpcp;      /**< Tx Performance Count Parameters*/
+    volatile uint32_t   fmbm_tccn;      /**< Tx Cycle Counter*/
+    volatile uint32_t   fmbm_ttuc;      /**< Tx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_ttcquc;    /**< Tx Transmit Confirm Queue Utilization Counter*/
+    volatile uint32_t   fmbm_tduc;      /**< Tx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_tfuc;      /**< Tx FIFO Utilization Counter*/
+} _PackedType t_FmPortTxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_ocfg;      /**< O/H Configuration  */
+    volatile uint32_t   fmbm_ost;       /**< O/H Status */
+    volatile uint32_t   fmbm_oda;       /**< O/H DMA attributes  */
+    volatile uint32_t   fmbm_oicp;      /**< O/H Internal Context Parameters  */
+    volatile uint32_t   fmbm_ofdne;     /**< O/H Frame Dequeue Next Engine  */
+    volatile uint32_t   fmbm_ofne;      /**< O/H Frame Next Engine  */
+    volatile uint32_t   fmbm_ofca;      /**< O/H Frame Command Attributes.  */
+    volatile uint32_t   fmbm_ofpne;     /**< O/H Frame Parser Next Engine  */
+    volatile uint32_t   fmbm_opso;      /**< O/H Parse Start Offset  */
+    volatile uint32_t   fmbm_opp;       /**< O/H Policer Profile */
+    volatile uint32_t   fmbm_occb;      /**< O/H Coarse Classification base */
+    volatile uint32_t   fmbm_oim;       /**< O/H Internal margins*/
+    volatile uint32_t   reserved0[4];   /**< (0x030 - 0x03F) */
+    volatile uint32_t   fmbm_oprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
+                                        /**< O/H Parse Results Array Initialization  */
+    volatile uint32_t   fmbm_ofqid;     /**< O/H Frame Queue ID  */
+    volatile uint32_t   fmbm_oefqid;    /**< O/H Error Frame Queue ID  */
+    volatile uint32_t   fmbm_ofsdm;     /**< O/H Frame Status Discard Mask  */
+    volatile uint32_t   fmbm_ofsem;     /**< O/H Frame Status Error Mask  */
+    volatile uint32_t   fmbm_ofene;     /**< O/H Frame Enqueue Next Engine  */
+    volatile uint32_t   fmbm_orlmts;    /**< O/H Rate Limiter Scale  */
+    volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
+    volatile uint32_t   reserved0a[0x21];
+                                        /**< 0x07C - 0x0FF Reserved */
+    union
+    {
+        volatile uint32_t   fmbm_oebmpi[FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS];
+                                        /**< Buffer Manager Observed Pool Information */
+        volatile uint32_t   reserved0b[0x18];
+    };                                  /**< 0x100 - 0x15F Reserved */
+    volatile uint32_t   fmbm_ocgm;      /**< Observed Congestion Group Map */
+    volatile uint32_t   reserved0c[0x7];/**< 0x164 - 0x17F Reserved */
+    volatile uint32_t   fmbm_ompd;      /**< Observed BMan Pool Depletion */
+    volatile uint32_t   reserved0d[0x1F];
+                                        /**< 0x184 - 0x1FF Reserved */
+    volatile uint32_t   fmbm_ostc;      /**< O/H Statistics Counters  */
+    volatile uint32_t   fmbm_ofrc;      /**< O/H Frame Counter  */
+    volatile uint32_t   fmbm_ofdc;      /**< O/H Frames Discard Counter  */
+    volatile uint32_t   fmbm_ofledc;    /**< O/H Frames Length Error Discard Counter  */
+    volatile uint32_t   fmbm_ofufdc;    /**< O/H Frames Unsupported Format Discard Counter  */
+    volatile uint32_t   fmbm_offc;      /**< O/H Filter Frames Counter  */
+    volatile uint32_t   fmbm_ofwdc;     /**< - Rx Frames WRED Discard Counter  */
+    volatile uint32_t   fmbm_ofldec;    /**< O/H Frames List DMA Error Counter */
+    volatile uint32_t   fmbm_obdc;      /**< O/H Buffers Deallocate Counter */
+    volatile uint32_t   reserved2[0x17];/**< (0x218 - 0x27F) */
+    volatile uint32_t   fmbm_opc;       /**< O/H Performance Counters  */
+    volatile uint32_t   fmbm_opcp;      /**< O/H Performance Count Parameters  */
+    volatile uint32_t   fmbm_occn;      /**< O/H Cycle Counter  */
+    volatile uint32_t   fmbm_otuc;      /**< O/H Tasks Utilization Counter  */
+    volatile uint32_t   fmbm_oduc;      /**< O/H DMA Utilization Counter */
+    volatile uint32_t   fmbm_ofuc;      /**< O/H FIFO Utilization Counter */
+} _PackedType t_FmPortOhBmiRegs;
+
+typedef _Packed union
+{
+    t_FmPortRxBmiRegs rxPortBmiRegs;
+    t_FmPortTxBmiRegs txPortBmiRegs;
+    t_FmPortOhBmiRegs ohPortBmiRegs;
+} _PackedType u_FmPortBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   reserved1[2];   /**<   0xn024 - 0x02B */
+    volatile uint32_t   fmqm_pndn;      /**<   PortID n Dequeue NIA Register */
+    volatile uint32_t   fmqm_pndc;      /**<   PortID n Dequeue Config Register */
+    volatile uint32_t   fmqm_pndtfc;    /**<   PortID n Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_pndfdc;    /**<   PortID n Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_pndcc;     /**<   PortID n Dequeue Confirm Counter */
+} _PackedType t_FmPortNonRxQmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_pnc;       /**<   PortID n Configuration Register */
+    volatile uint32_t   fmqm_pns;       /**<   PortID n Status Register */
+    volatile uint32_t   fmqm_pnts;      /**<   PortID n Task Status Register */
+    volatile uint32_t   reserved0[4];   /**<   0xn00C - 0xn01B */
+    volatile uint32_t   fmqm_pnen;      /**<   PortID n Enqueue NIA Register */
+    volatile uint32_t   fmqm_pnetfc;    /**<   PortID n Enqueue Total Frame Counter */
+    t_FmPortNonRxQmiRegs    nonRxQmiRegs;  /**<   Registers for Tx Hc & Op ports */
+} _PackedType t_FmPortQmiRegs;
+
+typedef _Packed struct
+{
+    _Packed struct
+    {
+        volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
+        volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
+    } _PackedType hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    volatile uint8_t    reserved0[0x378];
+    volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
+    volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
+} _PackedType t_FmPortPrsRegs;
+
+/**************************************************************************//*
+ @Description   Basic buffer descriptor (BD) structure
+*//***************************************************************************/
+typedef _Packed struct
+{
+    volatile uint16_t       status;
+    volatile uint16_t       length;
+    volatile uint8_t        reserved0[0x6];
+    volatile uint8_t        reserved1[0x1];
+    volatile t_FmPhysAddr   buff;
+} _PackedType t_FmImBd;
+
+typedef _Packed struct
+{
+    volatile uint16_t       gen;                /**< tbd */
+    volatile uint8_t        reserved0[0x1];
+    volatile t_FmPhysAddr   bdRingBase;         /**< tbd */
+    volatile uint16_t       bdRingSize;         /**< tbd */
+    volatile uint16_t       offsetIn;           /**< tbd */
+    volatile uint16_t       offsetOut;          /**< tbd */
+    volatile uint8_t        reserved1[0x12];    /**< 0x0e - 0x1f */
+} _PackedType t_FmPortImQd;
+
+typedef _Packed struct
+{
+    volatile uint32_t   mode;               /**< Mode register */
+    volatile uint32_t   rxQdPtr;            /**< tbd */
+    volatile uint32_t   txQdPtr;            /**< tbd */
+    volatile uint16_t   mrblr;              /**< tbd */
+    volatile uint16_t   rxQdBsyCnt;         /**< tbd */
+    volatile uint8_t    reserved0[0x10];    /**< 0x10 - 0x1f */
+    t_FmPortImQd        rxQd;
+    t_FmPortImQd        txQd;
+    volatile uint8_t    reserved1[0xa0];    /**< 0x60 - 0xff */
+} _PackedType t_FmPortImPram;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description       Registers bit fields
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+#define BMI_PORT_CFG_EN                         0x80000000
+#define BMI_PORT_CFG_EN_MACSEC                  0x00800000
+#define BMI_PORT_CFG_FDOVR                      0x02000000
+#define BMI_PORT_CFG_IM                         0x01000000
+#define BMI_PORT_STATUS_BSY                     0x80000000
+#define BMI_COUNTERS_EN                         0x80000000
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
+#define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
+#define BMI_RFNE_FDCS_MASK                      0xFF000000
+
+#define BMI_CMD_MR_LEAC                         0x00200000
+#define BMI_CMD_MR_SLEAC                        0x00100000
+#define BMI_CMD_MR_MA                           0x00080000
+#define BMI_CMD_MR_DEAS                         0x00040000
+#define BMI_CMD_TX_MR_DEF                       (0)
+#define BMI_CMD_RX_MR_DEF                       (BMI_CMD_MR_LEAC | \
+                                                 BMI_CMD_MR_SLEAC | \
+                                                 BMI_CMD_MR_MA | \
+                                                 BMI_CMD_MR_DEAS)
+#define BMI_CMD_ATTR_ORDER                      0x80000000
+#define BMI_CMD_ATTR_SYNC                       0x02000000
+#define BMI_CMD_ATTR_MACCMD_MASK                0x0000ff00
+#define BMI_CMD_ATTR_MACCMD_OVERRIDE            0x00008000
+#define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
+#define BMI_CMD_ATTR_MACCMD_SC_MASK             0x00000f00
+
+#define BMI_EXT_BUF_POOL_VALID                  0x80000000
+#define BMI_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define BMI_EXT_BUF_POOL_BACKUP                 0x20000000
+#define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
+#define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA                    | \
+                                                             FM_PORT_FRM_ERR_PHYSICAL               | \
+                                                             FM_PORT_FRM_ERR_SIZE                   | \
+                                                             FM_PORT_FRM_ERR_CLS_DISCARD            | \
+                                                             FM_PORT_FRM_ERR_EXTRACTION             | \
+                                                             FM_PORT_FRM_ERR_NO_SCHEME              | \
+                                                             FM_PORT_FRM_ERR_COLOR_RED              | \
+                                                             FM_PORT_FRM_ERR_COLOR_YELLOW           | \
+                                                             FM_PORT_FRM_ERR_ILL_PLCR               | \
+                                                             FM_PORT_FRM_ERR_PLCR_FRAME_LEN         | \
+                                                             FM_PORT_FRM_ERR_PRS_TIMEOUT            | \
+                                                             FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
+                                                             FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
+                                                             FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
+                                                             FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
+                                                             FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW))
+
+#define BMI_STATUS_OP_MASK_UNUSED               (uint32_t)(BMI_STATUS_RX_MASK_UNUSED &                \
+                                                           ~(FM_PORT_FRM_ERR_LENGTH                 | \
+                                                             FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT))
+
+#define BMI_RATE_LIMIT_EN                       0x80000000
+#define BMI_RATE_LIMIT_BURST_SIZE_GRAN          0x80000000
+#define BMI_RATE_LIMIT_SCALE_BY_2               0x00000001
+#define BMI_RATE_LIMIT_SCALE_BY_4               0x00000002
+#define BMI_RATE_LIMIT_SCALE_BY_8               0x00000003
+
+#define BMI_PRS_RESULT_HIGH                     0x00000000
+#define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
+
+#define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA                    | \
+                                                 FM_PORT_FRM_ERR_PHYSICAL               | \
+                                                 FM_PORT_FRM_ERR_SIZE                   | \
+                                                 FM_PORT_FRM_ERR_EXTRACTION             | \
+                                                 FM_PORT_FRM_ERR_NO_SCHEME              | \
+                                                 FM_PORT_FRM_ERR_ILL_PLCR               | \
+                                                 FM_PORT_FRM_ERR_PLCR_FRAME_LEN         | \
+                                                 FM_PORT_FRM_ERR_PRS_TIMEOUT            | \
+                                                 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
+                                                 FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
+                                                 FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
+                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
+                                                 FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
+
+#ifdef FM_CAPWAP_SUPPORT
+#define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
+                                                 FM_PORT_FRM_ERR_LENGTH                 | \
+                                                 FM_PORT_FRM_ERR_NON_FM                 | \
+                                                 FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
+
+#else
+#define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
+                                                 FM_PORT_FRM_ERR_LENGTH                 | \
+                                                 FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
+#endif /* FM_CAPWAP_SUPPORT */
+
+/* shifts */
+#define BMI_PORT_CFG_MS_SEL_SHIFT               16
+#define BMI_DMA_ATTR_SWP_SHIFT                  30
+#define BMI_DMA_ATTR_IC_CACHE_SHIFT             28
+#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            26
+#define BMI_DMA_ATTR_SG_CACHE_SHIFT             24
+
+#define BMI_IM_FOF_SHIFT                        28
+#define BMI_PR_PORTID_SHIFT                     24
+
+#define BMI_RX_FIFO_PRI_ELEVATION_SHIFT         16
+#define BMI_RX_FIFO_THRESHOLD_SHIFT             0
+
+#define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
+#define BMI_RX_FRAME_END_CUT_SHIFT              16
+
+#define BMI_IC_TO_EXT_SHIFT                     16
+#define BMI_IC_FROM_INT_SHIFT                   8
+#define BMI_IC_SIZE_SHIFT                       0
+
+#define BMI_INT_BUF_MARG_SHIFT                  28
+
+#define BMI_EXT_BUF_MARG_START_SHIFT            16
+#define BMI_EXT_BUF_MARG_END_SHIFT              0
+
+#define BMI_CMD_ATTR_COLOR_SHIFT                26
+#define BMI_CMD_ATTR_COM_MODE_SHIFT             16
+#define BMI_CMD_ATTR_MACCMD_SHIFT               8
+#define BMI_CMD_ATTR_MACCMD_OVERRIDE_SHIFT      15
+#define BMI_CMD_ATTR_MACCMD_SECURED_SHIFT       12
+#define BMI_CMD_ATTR_MACCMD_SC_SHIFT            8
+
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
+
+#define BMI_EXT_BUF_POOL_ID_SHIFT               16
+
+#define BMI_TX_FIFO_MIN_FILL_SHIFT              16
+#define BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT        12
+#define BMI_TX_LOW_COMF_SHIFT                   0
+
+#define BMI_TX_FRAME_END_CS_IGNORE_SHIFT        24
+
+#define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
+#define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
+#define BMI_PERFORMANCE_DMA_COMP_SHIFT          12
+#define BMI_PERFORMANCE_FIFO_COMP_SHIFT         0
+
+#define BMI_MAX_BURST_SHIFT                     16
+#define BMI_COUNT_RATE_UNIT_SHIFT               16
+
+/* sizes */
+#define FRAME_END_DATA_SIZE                     16
+#define OFFSET_UNITS                            16
+#define FRAME_OFFSET_UNITS                      16
+#define MAX_EXT_OFFSET                          496
+#define MAX_EXT_BUFFER_OFFSET                   511
+#define MAX_INT_OFFSET                          240
+#define MIN_TX_INT_OFFSET                       16
+#define MAX_IC_SIZE                             256
+#define MAX_FRAME_OFFSET                        64
+#define MAX_FIFO_PIPELINE_DEPTH                 8
+#define MAX_PERFORMANCE_TASK_COMP               64
+#define MAX_PERFORMANCE_TX_QUEUE_COMP           8
+#define MAX_PERFORMANCE_RX_QUEUE_COMP           64
+#define MAX_PERFORMANCE_DMA_COMP                16
+#define MAX_NUM_OF_TASKS                        64
+#define MAX_NUM_OF_EXTRA_TASKS                  8
+#define MAX_NUM_OF_DMAS                         16
+#define MAX_NUM_OF_EXTRA_DMAS                   8
+#define MAX_BURST_SIZE                          1024
+#define FRAG_EXTRA_SPACE                        32
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_PORT_CFG_EN                         0x80000000
+#define QMI_PORT_CFG_EN_COUNTERS                0x10000000
+#define QMI_PORT_STATUS_DEQ_TNUM_BSY            0x80000000
+#define QMI_PORT_STATUS_DEQ_FD_BSY              0x20000000
+
+#define QMI_DEQ_CFG_PREFETCH_NO_TNUM            0x02000000
+#define QMI_DEQ_CFG_PREFETCH_WAITING_TNUM       0
+#define QMI_DEQ_CFG_PREFETCH_1_FRAME            0
+#define QMI_DEQ_CFG_PREFETCH_3_FRAMES           0x01000000
+
+#define QMI_DEQ_CFG_PRI                         0x80000000
+#define QMI_DEQ_CFG_TYPE1                       0x10000000
+#define QMI_DEQ_CFG_TYPE2                       0x20000000
+#define QMI_DEQ_CFG_TYPE3                       0x30000000
+
+#define QMI_DEQ_CFG_SUBPORTAL_MASK              0x1f
+#define QMI_DEQ_CFG_SUBPORTAL_SHIFT             20
+
+/**************************************************************************//**
+ @Description       PARSER defines
+*//***************************************************************************/
+/* masks */
+#define PRS_HDR_ERROR_DIS                       0x00000800
+#define PRS_HDR_SW_PRS_EN                       0x00000400
+#define PRS_CP_OFFSET_MASK                      0x0000000F
+#define PRS_TPID1_MASK                          0xFFFF0000
+#define PRS_TPID2_MASK                          0x0000FFFF
+#define PRS_TPID_DFLT                           0x91009100
+
+#define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
+#define PRS_HDR_IPV6_ROUTE_HDR_DIS              0x00008000
+#define PRS_HDR_PPPOE_MTU_CHECK_EN              0x80000000
+#define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
+#define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
+#define PRS_CAC_STOP                            0x00000001
+#define PRS_CAC_ACTIVE                          0x00000100
+
+/* shifts */
+#define PRS_PCTPID_SHIFT                        16
+#define PRS_HDR_MPLS_NEXT_HDR_SHIFT             22
+#define PRS_HDR_ETH_BC_SHIFT                    28
+#define PRS_HDR_ETH_MC_SHIFT                    24
+#define PRS_HDR_VLAN_STACKED_SHIFT              16
+#define PRS_HDR_MPLS_STACKED_SHIFT              16
+#define PRS_HDR_IPV4_1_BC_SHIFT                 28
+#define PRS_HDR_IPV4_1_MC_SHIFT                 24
+#define PRS_HDR_IPV4_2_UC_SHIFT                 20
+#define PRS_HDR_IPV4_2_MC_BC_SHIFT              16
+#define PRS_HDR_IPV6_1_MC_SHIFT                 24
+#define PRS_HDR_IPV6_2_UC_SHIFT                 20
+#define PRS_HDR_IPV6_2_MC_SHIFT                 16
+
+#define PRS_HDR_ETH_BC_MASK                     0x0fffffff
+#define PRS_HDR_ETH_MC_MASK                     0xf0ffffff
+#define PRS_HDR_VLAN_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_MPLS_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_IPV4_1_BC_MASK                  0x0fffffff
+#define PRS_HDR_IPV4_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV4_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV4_2_MC_BC_MASK               0xfff0ffff
+#define PRS_HDR_IPV6_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV6_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV6_2_MC_MASK                  0xfff0ffff
+
+/* others */
+#define PRS_HDR_ENTRY_SIZE                      8
+#define DEFAULT_CLS_PLAN_VECTOR                 0xFFFFFFFF
+
+#define IPSEC_SW_PATCH_START                    0x20
+#define SCTP_SW_PATCH_START                     0x4D
+#define DCCP_SW_PATCH_START                     0x41
+
+/**************************************************************************//**
+ @Description       IM defines
+*//***************************************************************************/
+#define BD_R_E                                  0x80000000
+#define BD_L                                    0x08000000
+
+#define BD_RX_CRE                               0x00080000
+#define BD_RX_FTL                               0x00040000
+#define BD_RX_FTS                               0x00020000
+#define BD_RX_OV                                0x00010000
+
+#define BD_RX_ERRORS                            (BD_RX_CRE | BD_RX_FTL | BD_RX_FTS | BD_RX_OV)
+#define BD_ERROR_PASS_FRAME                     BD_RX_ERRORS
+
+#define FM_IM_SIZEOF_BD                         sizeof(t_FmImBd)
+
+#define BD_STATUS_MASK                          0xffff0000
+#define BD_LENGTH_MASK                          0x0000ffff
+
+#define BD_STATUS_AND_LENGTH_SET(bd, val)       WRITE_UINT32(*(volatile uint32_t*)(bd), (val))
+
+#define BD_STATUS_AND_LENGTH(bd)                GET_UINT32(*(volatile uint32_t*)(bd))
+
+#define BD_GET(id)                              &p_FmPort->im.p_BdRing[id]
+
+#define IM_ILEGAL_BD_ID                         0xffff
+
+/* others */
+#define IM_PRAM_ALIGN                           0x100
+
+/* masks */
+#define IM_MODE_GBL                             0x20000000
+#define IM_MODE_BO_MASK                         0x18000000
+#define IM_MODE_BO_SHIFT                        3
+#define IM_MODE_GRC_STP                         0x00800000
+
+#define IM_MODE_SET_BO(val)                     (uint32_t)((val << (31-IM_MODE_BO_SHIFT)) & IM_MODE_BO_MASK)
+
+#define IM_RXQD_BSYINTM                         0x0008
+#define IM_RXQD_RXFINTM                         0x0010
+#define IM_RXQD_FPMEVT_SEL_MASK                 0x0003
+
+#define IM_EV_BSY                               0x40000000
+#define IM_EV_RX                                0x80000000
+
+typedef struct {
+    t_Handle                    h_FmMuram;
+    t_FmPortImPram              *p_FmPortImPram;
+    uint8_t                     fwExtStructsMemId;
+    uint32_t                    fwExtStructsMemAttr;
+    uint16_t                    bdRingSize;
+    t_FmImBd                    *p_BdRing;
+    t_Handle                    *p_BdShadow;
+    uint16_t                    currBdId;
+    uint16_t                    firstBdOfFrameId;
+
+    /* Rx port parameters */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPool;
+    uint16_t                    mrblr;
+    uint16_t                    rxFrameAccumLength;
+    t_FmPortImRxStoreCallback   *f_RxStore;
+
+    /* Tx port parameters */
+    uint32_t                    txFirstBdStatus;
+    t_FmPortImTxConfCallback    *f_TxConf;
+} t_FmMacIm;
+
+/**************************************************************************//**
+ @Description   structure for defining internal context copying
+*//***************************************************************************/
+typedef struct
+{
+    uint16_t    extBufOffset;       /**< Offset in External buffer to which internal
+                                         context is copied to (Rx) or taken from (Tx, Op). */
+    uint8_t     intContextOffset;   /**< Offset within internal context to copy from
+                                         (Rx) or to copy to (Tx, Op). */
+    uint16_t    size;               /**< Internal offset size to be copied */
+} t_FmPortIntContextDataCopy;
+
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct {
+    uint16_t    startMargins;           /**< Number of bytes to be left at the beginning
+                                             of the external buffer (must be divisible by 16) */
+    uint16_t    endMargins;             /**< number of bytes to be left at the end
+                                             of the external buffer(must be divisible by 16) */
+} t_FmPortBufMargins;
+
+typedef struct {
+    uint32_t      dataOffset;
+    uint32_t      prsResultOffset;
+    uint32_t      timeStampOffset;
+    uint32_t      hashResultOffset;
+    uint32_t      pcdInfoOffset;
+    uint32_t      manipOffset;
+#ifdef DEBUG
+    uint32_t      debugOffset;
+#endif /* DEBUG */
+} t_FmPortBufferOffsets;
+
+typedef struct {
+    uint32_t                            dfltFqid;
+    uint32_t                            confFqid;
+    uint32_t                            errFqid;
+    uintptr_t                           baseAddr;
+    uint8_t                             deqSubPortal;
+    bool                                deqHighPriority;
+    e_FmPortDeqType                     deqType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    e_FmPortDeqPrefetchOption           deqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+    uint16_t                            deqByteCnt;
+    uint8_t                             cheksumLastBytesIgnore;
+    uint8_t                             cutBytesFromEnd;
+    t_FmPortBufPoolDepletion            bufPoolDepletion;
+    uint8_t                             pipelineDepth;
+    uint16_t                            fifoLowComfLevel;
+    bool                                frmDiscardOverride;
+    bool                                enRateLimit;
+    t_FmPortRateLimit                   rateLimit;
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;
+    bool                                enBufPoolDepletion;
+    uint16_t                            liodnOffset;
+    uint16_t                            liodnBase;
+    t_FmPortExtPools                    extBufPools;
+    e_FmPortDmaSwap                     dmaSwapData;
+    e_FmPortDmaCache                    dmaIntContextCacheAttr;
+    e_FmPortDmaCache                    dmaHeaderCacheAttr;
+    e_FmPortDmaCache                    dmaScatterGatherCacheAttr;
+    bool                                dmaReadOptimize;
+    bool                                dmaWriteOptimize;
+    uint32_t                            txFifoMinFillLevel;
+    uint32_t                            txFifoLowComfLevel;
+    uint32_t                            rxFifoPriElevationLevel;
+    uint32_t                            rxFifoThreshold;
+    t_FmPortBufMargins                  bufMargins;
+    t_FmPortIntContextDataCopy          intContext;
+    bool                                syncReq;
+    e_FmPortColor                       color;
+    fmPortFrameErrSelect_t              errorsToDiscard;
+    fmPortFrameErrSelect_t              errorsToEnq;
+    uint64_t                            fmMuramPhysBaseAddr;
+    bool                                forwardReuseIntContext;
+    t_FmPortBufferPrefixContent         bufferPrefixContent;
+    uint8_t                             internalBufferOffset;
+    t_FmPortBackupBmPools               *p_BackupBmPools;
+    bool                                dontReleaseBuf;
+} t_FmPortDriverParam;
+
+typedef struct {
+    t_Handle                    h_Fm;
+    t_Handle                    h_FmPcd;
+    uint8_t                     portId;
+    e_FmPortType                portType;
+    int                         enabled;
+    char                        name[MODULE_NAME_SIZE];
+    uint8_t                     hardwarePortId;
+    uint16_t                    fmClkFreq;
+    t_FmPortQmiRegs             *p_FmPortQmiRegs;
+    u_FmPortBmiRegs             *p_FmPortBmiRegs;
+    t_FmPortPrsRegs             *p_FmPortPrsRegs;
+    fmPcdEngines_t              pcdEngines;
+    uint32_t                    savedBmiNia;
+    uint8_t                     netEnvId;
+    uint32_t                    optArray[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint8_t                     privateInfo;
+    uint32_t                    schemesPerPortVector;
+    bool                        useClsPlan;
+    uint8_t                     clsPlanGrpId;
+    t_Handle                    ccTreeId;
+    t_Handle                    completeArg;
+    void                        (*f_Complete)(t_Handle arg);
+    t_FmPortBufferOffsets       bufferOffsets;
+    /* Independent-Mode parameters support */
+    bool                        imEn;
+    t_FmMacIm                   im;
+    uint8_t                     txFifoDeqPipelineDepth;
+    volatile bool               lock;
+    t_Handle                    h_Spinlock;
+    t_FmPortExceptionCallback   *f_Exception;
+    t_Handle                    h_App;
+    uint8_t                     internalBufferOffset;
+    uint8_t                     fmanCtrlEventId;
+    uint32_t                    exceptions;
+    bool                        polling;
+    uint8_t                     numOfTasks;
+    t_FmPortExtPools            extBufPools;
+    uint32_t                    requiredAction;
+    uint32_t                    savedQmiPnen;
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    uint32_t                    savedBmiRfene;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    uint32_t                    savedNonRxQmiRegsPndn;
+    int                         savedPrsStartOffset;
+    t_FmPortRsrc                openDmas;
+    t_FmPortRsrc                tasks;
+    t_FmPortRsrc                fifoBufs;
+    t_FmInterModulePortRxPoolsParams rxPoolsParams;
+    t_FmPortDriverParam         *p_FmPortDriverParam;
+} t_FmPort;
+
+#define CHECK_FM_CTL_AC_POST_FETCH_PCD(savedBmiNia) \
+    ((((savedBmiNia) & NIA_ENG_MASK) == NIA_ENG_FM_CTL) && \
+     ((((savedBmiNia) & NIA_FM_CTL_AC_MASK) == NIA_FM_CTL_AC_POST_FETCH_PCD) || \
+      (((savedBmiNia) & NIA_FM_CTL_AC_MASK) == NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN)))
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
+
+t_Error FmPortImInit(t_FmPort *p_FmPort);
+void    FmPortImFree(t_FmPort *p_FmPort);
+
+t_Error FmPortImEnable  (t_FmPort *p_FmPort);
+t_Error FmPortImDisable (t_FmPort *p_FmPort);
+t_Error FmPortImRx      (t_FmPort *p_FmPort);
+
+void    FmPortSetMacsecLcv(t_Handle h_FmPort);
+void    FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci);
+
+
+static __inline__ uint8_t * BdBufferGet (t_PhysToVirt *f_PhysToVirt, t_FmImBd *p_Bd)
+{
+    uint64_t    physAddr = (uint64_t)((uint64_t)GET_UINT8(p_Bd->buff.high) << 32);
+    physAddr |= GET_UINT32(p_Bd->buff.low);
+
+    return (uint8_t *)f_PhysToVirt((physAddress_t)(physAddr));
+}
+
+static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t value)
+{
+    WRITE_UINT8(fmPhysAddr->high,(uint8_t)((value & 0x000000ff00000000LL) >> 32));
+    WRITE_UINT32(fmPhysAddr->low,(uint32_t)value);
+}
+
+static __inline__ void BdBufferSet(t_VirtToPhys *f_VirtToPhys, t_FmImBd *p_Bd, uint8_t *p_Buffer)
+{
+    uint64_t    physAddr = (uint64_t)(f_VirtToPhys(p_Buffer));
+    SET_ADDR(&p_Bd->buff, physAddr);
+}
+
+static __inline__ uint16_t GetNextBdId(t_FmPort *p_FmPort, uint16_t id)
+{
+    if (id < p_FmPort->im.bdRingSize-1)
+        return (uint16_t)(id+1);
+    else
+        return 0;
+}
+
+
+#endif /* __FM_PORT_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
new file mode 100644
index 0000000..7ddf3a2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -0,0 +1,791 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_im.c
+
+ @Description   FM Port Independent-Mode ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "fm_muram_ext.h"
+
+#include "fm_port.h"
+
+
+#define TX_CONF_STATUS_UNSENT 0x1
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#undef WRITE_UINT16
+#undef GET_UINT16
+
+#define WRITE_UINT16(addr, val)  \
+    do{                             \
+            if((int)&(addr) % 4)    \
+                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
+                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
+            else                    \
+                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
+                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
+      }while(0);
+
+#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
+       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
+       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+typedef enum e_TxConfType
+{
+     e_TX_CONF_TYPE_CHECK      = 0  /**< check if all the buffers were touched by the muxator, no confirmation callback */
+    ,e_TX_CONF_TYPE_CALLBACK   = 1  /**< confirm to user all the available sent buffers */
+    ,e_TX_CONF_TYPE_FLUSH      = 3  /**< confirm all buffers plus the unsent one with an appropriate status */
+} e_TxConfType;
+
+
+static void ImException(t_Handle h_FmPort, uint32_t event)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    ASSERT_COND(((event & IM_EV_RX) && FmIsMaster(p_FmPort->h_Fm)) ||
+                !FmIsMaster(p_FmPort->h_Fm));
+
+    if (event & IM_EV_RX)
+        FmPortImRx(p_FmPort);
+    if ((event & IM_EV_BSY) && p_FmPort->f_Exception)
+        p_FmPort->f_Exception(p_FmPort->h_App, e_FM_PORT_EXCEPTION_IM_BUSY);
+}
+
+
+static t_Error TxConf(t_FmPort *p_FmPort, e_TxConfType confType)
+{
+    t_Error             retVal = E_BUSY;
+    uint32_t            bdStatus;
+    uint16_t            savedStartBdId, confBdId;
+
+    ASSERT_COND(p_FmPort);
+
+    /*
+    if (confType==e_TX_CONF_TYPE_CHECK)
+        return (WfqEntryIsQueueEmpty(p_FmPort->im.h_WfqEntry) ? E_OK : E_BUSY);
+    */
+
+    confBdId = savedStartBdId = p_FmPort->im.currBdId;
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(confBdId));
+
+    /* If R bit is set, we don't enter, or we break.
+       we run till we get to R, or complete the loop */
+    while ((!(bdStatus & BD_R_E) || (confType == e_TX_CONF_TYPE_FLUSH)) && (retVal != E_OK))
+    {
+        if (confType & e_TX_CONF_TYPE_CALLBACK) /* if it is confirmation with user callbacks */
+            BD_STATUS_AND_LENGTH_SET(BD_GET(confBdId), 0);
+
+        /* case 1: R bit is 0 and Length is set -> confirm! */
+        if ((confType & e_TX_CONF_TYPE_CALLBACK) && (bdStatus & BD_LENGTH_MASK))
+        {
+            if (p_FmPort->im.f_TxConf)
+            {
+                if ((confType == e_TX_CONF_TYPE_FLUSH) && (bdStatus & BD_R_E))
+                    p_FmPort->im.f_TxConf(p_FmPort->h_App,
+                                          BdBufferGet(XX_PhysToVirt, BD_GET(confBdId)),
+                                          TX_CONF_STATUS_UNSENT,
+                                          p_FmPort->im.p_BdShadow[confBdId]);
+                else
+                    p_FmPort->im.f_TxConf(p_FmPort->h_App,
+                                          BdBufferGet(XX_PhysToVirt, BD_GET(confBdId)),
+                                          0,
+                                          p_FmPort->im.p_BdShadow[confBdId]);
+            }
+        }
+        /* case 2: R bit is 0 and Length is 0 -> not used yet, nop! */
+
+        confBdId = GetNextBdId(p_FmPort, confBdId);
+        if (confBdId == savedStartBdId)
+            retVal = E_OK;
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(confBdId));
+    }
+
+    return retVal;
+}
+
+t_Error FmPortImEnable(t_FmPort *p_FmPort)
+{
+    uint32_t    tmpReg = GET_UINT32(p_FmPort->im.p_FmPortImPram->mode);
+    WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, (uint32_t)(tmpReg & ~IM_MODE_GRC_STP));
+    return E_OK;
+}
+
+t_Error FmPortImDisable(t_FmPort *p_FmPort)
+{
+    uint32_t    tmpReg = GET_UINT32(p_FmPort->im.p_FmPortImPram->mode);
+    WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, (uint32_t)(tmpReg | IM_MODE_GRC_STP));
+    return E_OK;
+}
+
+t_Error FmPortImRx(t_FmPort *p_FmPort)
+{
+    t_Handle                h_CurrUserPriv, h_NewUserPriv;
+    uint32_t                bdStatus;
+    volatile uint8_t        buffPos;
+    uint16_t                length;
+    uint16_t                errors/*, reportErrors*/;
+    uint8_t                 *p_CurData, *p_Data;
+    uint32_t                flags;
+
+    ASSERT_COND(p_FmPort);
+
+    flags = XX_LockIntrSpinlock(p_FmPort->h_Spinlock);
+    if (p_FmPort->lock)
+    {
+        XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, flags);
+        return E_OK;
+    }
+    p_FmPort->lock = TRUE;
+    XX_UnlockIntrSpinlock(p_FmPort->h_Spinlock, flags);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+    while (!(bdStatus & BD_R_E)) /* while there is data in the Rx BD */
+    {
+        if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_NewUserPriv)) == NULL)
+        {
+            p_FmPort->lock = FALSE;
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+        }
+
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+            p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+
+        errors = 0;
+        p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
+        h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
+        length = (uint16_t)((bdStatus & BD_L) ?
+                            ((bdStatus & BD_LENGTH_MASK) - p_FmPort->im.rxFrameAccumLength):
+                            (bdStatus & BD_LENGTH_MASK));
+        p_FmPort->im.rxFrameAccumLength += length;
+
+        /* determine whether buffer is first, last, first and last (single  */
+        /* buffer frame) or middle (not first and not last)                 */
+        buffPos = (uint8_t)((p_FmPort->im.currBdId == p_FmPort->im.firstBdOfFrameId) ?
+                            ((bdStatus & BD_L) ? SINGLE_BUF : FIRST_BUF) :
+                            ((bdStatus & BD_L) ? LAST_BUF : MIDDLE_BUF));
+
+        if (bdStatus & BD_L)
+        {
+            p_FmPort->im.rxFrameAccumLength = 0;
+            p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+        }
+
+        BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, BD_GET(p_FmPort->im.currBdId), p_Data);
+
+        BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
+
+        errors = (uint16_t)((bdStatus & BD_RX_ERRORS) >> 16);
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
+        /* Pass the buffer if one of the conditions is true:
+        - There are no errors
+        - This is a part of a larger frame ( the application has already received some buffers )
+        - There is an error, but it was defined to be passed anyway. */
+        if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
+        {
+            if (p_FmPort->im.f_RxStore(p_FmPort->h_App,
+                                       p_CurData,
+                                       length,
+                                       errors,
+                                       buffPos,
+                                       h_CurrUserPriv) == e_RX_STORE_RESPONSE_PAUSE)
+                break;
+        }
+        else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                              p_CurData,
+                                              h_CurrUserPriv))
+        {
+            p_FmPort->lock = FALSE;
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Failed freeing data buffer"));
+        }
+
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    }
+    p_FmPort->lock = FALSE;
+    return E_OK;
+}
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
+{
+    ASSERT_COND(p_FmPort);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.h_FmMuram                      = p_FmPortParams->specificParams.imRxTxParams.h_FmMuram;
+    p_FmPort->p_FmPortDriverParam->liodnOffset  = p_FmPortParams->specificParams.imRxTxParams.liodnOffset;
+    p_FmPort->im.dataMemId                      = p_FmPortParams->specificParams.imRxTxParams.dataMemId;
+    p_FmPort->im.dataMemAttributes              = p_FmPortParams->specificParams.imRxTxParams.dataMemAttributes;
+
+    p_FmPort->im.fwExtStructsMemId              = DEFAULT_PORT_ImfwExtStructsMemId;
+    p_FmPort->im.fwExtStructsMemAttr            = DEFAULT_PORT_ImfwExtStructsMemAttr;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.rxPool.h_BufferPool    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.h_BufferPool;
+        p_FmPort->im.rxPool.f_GetBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_GetBuf;
+        p_FmPort->im.rxPool.f_PutBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PutBuf;
+        p_FmPort->im.rxPool.bufferSize      = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.bufferSize;
+        p_FmPort->im.rxPool.f_PhysToVirt    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PhysToVirt;
+        if (!p_FmPort->im.rxPool.f_PhysToVirt)
+            p_FmPort->im.rxPool.f_PhysToVirt = XX_PhysToVirt;
+        p_FmPort->im.rxPool.f_VirtToPhys    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_VirtToPhys;
+        if (!p_FmPort->im.rxPool.f_VirtToPhys)
+            p_FmPort->im.rxPool.f_VirtToPhys = XX_VirtToPhys;
+        p_FmPort->im.f_RxStore              = p_FmPortParams->specificParams.imRxTxParams.f_RxStore;
+
+        p_FmPort->im.mrblr                  = 0x8000;
+        while (p_FmPort->im.mrblr)
+        {
+            if (p_FmPort->im.rxPool.bufferSize & p_FmPort->im.mrblr)
+                break;
+            p_FmPort->im.mrblr >>= 1;
+        }
+        if (p_FmPort->im.mrblr != p_FmPort->im.rxPool.bufferSize)
+            DBG(WARNING, ("Max-Rx-Buffer-Length set to %d", p_FmPort->im.mrblr));
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
+        p_FmPort->exceptions                = DEFAULT_exception;
+        if (FmIsMaster(p_FmPort->h_Fm))
+            p_FmPort->polling               = FALSE;
+        else
+            p_FmPort->polling               = TRUE;
+        p_FmPort->fmanCtrlEventId           = (uint8_t)NO_IRQ;
+    }
+    else
+    {
+        p_FmPort->im.f_TxConf               = p_FmPortParams->specificParams.imRxTxParams.f_TxConf;
+
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_txBdRingLength;
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
+{
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if (!POWER_OF_2(p_FmPort->im.mrblr))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must be power of 2!!!"));
+        if (p_FmPort->im.mrblr < 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
+        if(p_FmPort->p_FmPortDriverParam->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
+#ifdef FM_PARTITION_ARRAY
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            {
+                if(p_FmPort->p_FmPortDriverParam->liodnOffset >= MAX_LIODN_OFFSET)
+                {
+                    p_FmPort->p_FmPortDriverParam->liodnOffset =
+                        (uint16_t)(p_FmPort->p_FmPortDriverParam->liodnOffset & (MAX_LIODN_OFFSET-1));
+                    DBG(WARNING, ("liodnOffset number is out of rev1 range - MSB bits cleard."));
+                }
+            }
+        }
+#endif /* FM_PARTITION_ARRAY */
+/* TODO - add checks */
+    }
+    else
+    {
+/* TODO - add checks */
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImInit(t_FmPort *p_FmPort)
+{
+    t_FmImBd    *p_Bd=NULL;
+    t_Handle    h_BufContext;
+    uint64_t    tmpPhysBase;
+    uint16_t    log2Num;
+    uint8_t     *p_Data/*, *p_Tmp*/;
+    int         i;
+    t_Error     err;
+    uint16_t    tmpReg16;
+    uint32_t    tmpReg32;
+
+    ASSERT_COND(p_FmPort);
+
+    p_FmPort->im.p_FmPortImPram =
+        (t_FmPortImPram *)FM_MURAM_AllocMem(p_FmPort->im.h_FmMuram, sizeof(t_FmPortImPram), IM_PRAM_ALIGN);
+    if (!p_FmPort->im.p_FmPortImPram)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Parameter-RAM!!!"));
+    WRITE_BLOCK(p_FmPort->im.p_FmPortImPram, 0, sizeof(t_FmPortImPram));
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD ring!!!"));
+        IOMemSet32(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+
+        /* Initialize the Rx-BD ring */
+        for (i=0; i<p_FmPort->im.bdRingSize; i++)
+        {
+            p_Bd = BD_GET(i);
+            BD_STATUS_AND_LENGTH_SET (p_Bd, BD_R_E);
+
+            if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_BufContext)) == NULL)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+            BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, p_Bd, p_Data);
+            p_FmPort->im.p_BdShadow[i] = h_BufContext;
+        }
+
+        if ((p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE) ||
+            (p_FmPort->im.fwExtStructsMemAttr & MEMORY_ATTR_CACHEABLE))
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL | IM_MODE_SET_BO(2));
+        else
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_SET_BO(2));
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->rxQdPtr,
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
+
+        LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
+
+        /* Initialize Rx QD */
+        tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->rxQd.bdRingBase, tmpPhysBase);
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+        if (!p_FmPort->polling || p_FmPort->exceptions)
+        {
+            /* Allocate, configure and register interrupts */
+            err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
+            tmpReg16 = (uint16_t)(p_FmPort->fmanCtrlEventId & IM_RXQD_FPMEVT_SEL_MASK);
+            tmpReg32 = 0;
+
+            if(p_FmPort->exceptions & IM_EV_BSY)
+            {
+                tmpReg16 |= IM_RXQD_BSYINTM;
+                tmpReg32 |= IM_EV_BSY;
+            }
+            if(!p_FmPort->polling)
+            {
+                tmpReg16 |= IM_RXQD_RXFINTM;
+                tmpReg32 |= IM_EV_RX;
+            }
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+
+            FmRegisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, ImException , (t_Handle)p_FmPort);
+
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+        }
+        else
+            p_FmPort->fmanCtrlEventId = (uint8_t)NO_IRQ;
+    }
+    else
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Tx BD ring!!!"));
+        IOMemSet32(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+
+        if ((p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE) ||
+            (p_FmPort->im.fwExtStructsMemAttr & MEMORY_ATTR_CACHEABLE))
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL | IM_MODE_SET_BO(2));
+        else
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_SET_BO(2));
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->txQdPtr,
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x40));
+
+        /* Initialize Tx QD */
+        tmpPhysBase = (uint64_t)(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->txQd.bdRingBase, tmpPhysBase);
+        WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
+                     (uint32_t)((uint64_t)(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+    }
+
+
+    return E_OK;
+}
+
+void FmPortImFree(t_FmPort *p_FmPort)
+{
+    uint32_t    bdStatus;
+    uint8_t     *p_CurData;
+
+    ASSERT_COND(p_FmPort);
+
+    if (p_FmPort->im.p_FmPortImPram)
+        FM_MURAM_FreeMem(p_FmPort->im.h_FmMuram, p_FmPort->im.p_FmPortImPram);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if (!p_FmPort->polling || p_FmPort->exceptions)
+        {
+            /* De-Allocate and unregister interrupts */
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, 0);
+
+            FmFreeFmanCtrlEventReg(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, 0);
+
+            FmUnregisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+        }
+        /* Try first clean what has received */
+        FmPortImRx(p_FmPort);
+
+        /* Now, get rid of the the empty buffer! */
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+        while (bdStatus & BD_R_E) /* while there is data in the Rx BD */
+        {
+            p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
+
+            BdBufferSet(p_FmPort->im.rxPool.f_VirtToPhys, BD_GET(p_FmPort->im.currBdId), NULL);
+            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+
+            p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                         p_CurData,
+                                         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+            p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+            bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        }
+    }
+    else
+        TxConf(p_FmPort, e_TX_CONF_TYPE_FLUSH);
+
+    if (p_FmPort->im.p_BdShadow)
+        XX_Free(p_FmPort->im.p_BdShadow);
+
+    if (p_FmPort->im.p_BdRing)
+        XX_FreeSmart(p_FmPort->im.p_BdRing);
+}
+
+
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.mrblr = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
+                                                       uint8_t  memId,
+                                                       uint32_t memAttributes)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.fwExtStructsMemId              = memId;
+    p_FmPort->im.fwExtStructsMemAttr            = memAttributes;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    if (!FmIsMaster(p_FmPort->h_Fm))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available on master-partition only;"
+                                                  "in guest-partiotions, IM is always in polling!"));
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->polling = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error     err;
+    uint16_t    tmpReg16;
+    uint32_t    tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if(exception == e_FM_PORT_EXCEPTION_IM_BUSY)
+    {
+        if(enable)
+        {
+            p_FmPort->exceptions |= IM_EV_BSY;
+            if(p_FmPort->fmanCtrlEventId == (uint8_t)NO_IRQ)
+            {
+                /* Allocate, configure and register interrupts */
+                err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
+
+                FmRegisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, ImException, (t_Handle)p_FmPort);
+                tmpReg16 = (uint16_t)((p_FmPort->fmanCtrlEventId & IM_RXQD_FPMEVT_SEL_MASK) | IM_RXQD_BSYINTM);
+                tmpReg32 = IM_EV_BSY;
+            }
+            else
+            {
+                tmpReg16 = (uint16_t)(GET_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen) | IM_RXQD_BSYINTM);
+                tmpReg32 = FmGetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId) | IM_EV_BSY;
+            }
+
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+            FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+        }
+        else
+        {
+            p_FmPort->exceptions &= ~IM_EV_BSY;
+            if (!p_FmPort->exceptions && p_FmPort->polling)
+            {
+                FmFreeFmanCtrlEventReg(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+                FmUnregisterFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId);
+                FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, 0);
+                WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, 0);
+                p_FmPort->fmanCtrlEventId = (uint8_t)NO_IRQ;
+            }
+            else
+            {
+                tmpReg16 = (uint16_t)(GET_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen) & ~IM_RXQD_BSYINTM);
+                WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.gen, tmpReg16);
+                tmpReg32 = FmGetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId) & ~IM_EV_BSY;
+                FmSetFmanCtrlIntr(p_FmPort->h_Fm, p_FmPort->fmanCtrlEventId, tmpReg32);
+            }
+        }
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Invalid exception."));
+
+    return E_OK;
+}
+
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_BufContext)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint16_t            nextBdId;
+    uint32_t            bdStatus, nextBdStatus;
+    bool                firstBuffer;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    nextBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+    nextBdStatus = BD_STATUS_AND_LENGTH(BD_GET(nextBdId));
+
+    if (!(bdStatus & BD_R_E) && !(nextBdStatus & BD_R_E))
+    {
+        /* Confirm the current BD - BD is available */
+        if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConf))
+            p_FmPort->im.f_TxConf (p_FmPort->h_App,
+                                   BdBufferGet(XX_PhysToVirt, BD_GET(p_FmPort->im.currBdId)),
+                                   0,
+                                   p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+        bdStatus = length;
+
+        /* if this is the first BD of a frame */
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+        {
+            firstBuffer = TRUE;
+            p_FmPort->im.txFirstBdStatus = (bdStatus | BD_R_E);
+
+            if (!lastBuffer)
+                p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+        }
+        else
+            firstBuffer = FALSE;
+
+        BdBufferSet(XX_VirtToPhys, BD_GET(p_FmPort->im.currBdId), p_Data);
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_BufContext;
+
+        /* deal with last */
+        if (lastBuffer)
+        {
+            /* if single buffer frame */
+            if (firstBuffer)
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), p_FmPort->im.txFirstBdStatus | BD_L);
+            else
+            {
+                /* Set the last BD of the frame */
+                BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), (bdStatus | BD_R_E | BD_L));
+                /* Set the first BD of the frame */
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.firstBdOfFrameId), p_FmPort->im.txFirstBdStatus);
+                p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+            }
+            WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(GetNextBdId(p_FmPort, p_FmPort->im.currBdId)<<4));
+        }
+        else if (!firstBuffer) /* mid frame buffer */
+            BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), bdStatus | BD_R_E);
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+    }
+    else
+    {
+        /* Discard current frame. Return error.   */
+        if (p_FmPort->im.firstBdOfFrameId != IM_ILEGAL_BD_ID)
+        {
+            /* Error:    No free BD */
+            /* Response: Discard current frame. Return error.   */
+            uint16_t   cleanBdId = p_FmPort->im.firstBdOfFrameId;
+
+            ASSERT_COND(p_FmPort->im.firstBdOfFrameId != p_FmPort->im.currBdId);
+
+            /* Since firstInFrame is not NULL, one buffer at least has already been
+               inserted into the BD ring. Using do-while covers the situation of a
+               frame spanned throughout the whole Tx BD ring (p_CleanBd is incremented
+               prior to testing whether or not it's equal to TxBd). */
+            do
+            {
+                BD_STATUS_AND_LENGTH_SET(BD_GET(cleanBdId), 0);
+                /* Advance BD pointer */
+                cleanBdId = GetNextBdId(p_FmPort, cleanBdId);
+            } while (cleanBdId != p_FmPort->im.currBdId);
+
+            p_FmPort->im.currBdId = cleanBdId;
+            p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+        }
+
+        return ERROR_CODE(E_FULL);
+    }
+
+    return E_OK;
+}
+
+void FM_PORT_ImTxConf(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    TxConf(p_FmPort, e_TX_CONF_TYPE_CALLBACK);
+}
+
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    return FmPortImRx(p_FmPort);
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
new file mode 100644
index 0000000..dbe51ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-RTC.o
+
+fsl-ncsw-RTC-objs	:=   fm_rtc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
new file mode 100644
index 0000000..c970570
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -0,0 +1,859 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_rtc.c
+
+ @Description   FM RTC driver implementation.
+
+ @Cautions      None
+*//***************************************************************************/
+
+#include "error_ext.h"
+#include "debug_ext.h"
+#include "string_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+#include "ncsw_ext.h"
+
+#include "fm_rtc.h"
+#include "fm_common.h"
+
+
+/*****************************************************************************/
+static void SetDefaultParam(t_FmRtc *p_Rtc)
+{
+    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    int                 i;
+
+    p_Rtc->outputClockDivisor = DEFAULT_outputClockDivisor;
+    p_Rtc->p_RtcDriverParam->bypass = DEFAULT_bypass;
+    p_RtcDriverParam->srcClk = DEFAULT_srcClock;
+    p_RtcDriverParam->invertInputClkPhase = DEFAULT_invertInputClkPhase;
+    p_RtcDriverParam->invertOutputClkPhase = DEFAULT_invertOutputClkPhase;
+    p_RtcDriverParam->pulseRealign = DEFAULT_pulseRealign;
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        p_RtcDriverParam->alarmPolarity[i] = DEFAULT_alarmPolarity;
+    }
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+    {
+        p_RtcDriverParam->triggerPolarity[i] = DEFAULT_triggerPolarity;
+    }
+    p_Rtc->clockPeriodNanoSec = DEFAULT_clockPeriod; /* 1 usec */
+}
+
+/*****************************************************************************/
+static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
+{
+    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    int                 i;
+
+    if ((p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_EXTERNAL) &&
+        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM) &&
+        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_OSCILATOR))
+        RETURN_ERROR(MAJOR, E_INVALID_CLOCK, ("Source clock undefined"));
+
+    if (p_Rtc->outputClockDivisor == 0)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("Divisor for output clock (should be positive)"));
+    }
+
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        if ((p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW) &&
+            (p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH))
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm %d signal polarity", i));
+        }
+    }
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+    {
+        if ((p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_FALLING_EDGE) &&
+            (p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_RISING_EDGE))
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Trigger %d signal polarity", i));
+        }
+    }
+
+#ifdef FM_1588_SRC_CLK_ERRATA_FMAN1
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Rtc->h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0)&&
+           ((p_RtcDriverParam->srcClk==e_FM_RTC_SOURCE_CLOCK_SYSTEM) && p_RtcDriverParam->invertInputClkPhase))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Can not use invertInputClkPhase when source clock is e_FM_RTC_SOURCE_CLOCK_SYSTEM"));
+    }
+#endif /* FM_1588_SRC_CLK_ERRATA_FMAN1 */
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+static void RtcExceptions(t_Handle h_FmRtc)
+{
+    t_FmRtc          *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap    *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    register uint32_t   events;
+
+    ASSERT_COND(p_Rtc);
+
+    /* Get valid events */
+    events =  GET_UINT32(p_MemMap->tmr_tevent);
+    events &= GET_UINT32(p_MemMap->tmr_temask);
+
+    /* Clear event bits */
+    WRITE_UINT32(p_MemMap->tmr_tevent, events);
+
+    if (events & TMR_TEVENT_ALM1)
+    {
+        if(p_Rtc->alarmParams[0].clearOnExpiration)
+        {
+            WRITE_UINT32(p_MemMap->tmr_alarm[0].tmr_alarm_l, 0);
+            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM1);
+        }
+        ASSERT_COND(p_Rtc->alarmParams[0].f_AlarmCallback);
+        p_Rtc->alarmParams[0].f_AlarmCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_ALM2)
+    {
+        if(p_Rtc->alarmParams[1].clearOnExpiration)
+        {
+            WRITE_UINT32(p_MemMap->tmr_alarm[1].tmr_alarm_l, 0);
+            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM2);
+        }
+        ASSERT_COND(p_Rtc->alarmParams[1].f_AlarmCallback);
+        p_Rtc->alarmParams[1].f_AlarmCallback(p_Rtc->h_App, 1);
+    }
+    if (events & TMR_TEVENT_PP1)
+    {
+        ASSERT_COND(p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback);
+        p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_PP2)
+    {
+        ASSERT_COND(p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback);
+        p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback(p_Rtc->h_App, 1);
+    }
+    if (events & TMR_TEVENT_ETS1)
+    {
+        ASSERT_COND(p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback);
+        p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback(p_Rtc->h_App, 0);
+    }
+    if (events & TMR_TEVENT_ETS2)
+    {
+        ASSERT_COND(p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback);
+        p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback(p_Rtc->h_App, 1);
+    }
+}
+
+
+/*****************************************************************************/
+t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam)
+{
+    t_FmRtc *p_Rtc;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmRtcParam, E_NULL_POINTER, NULL);
+
+    /* Allocate memory for the FM RTC driver parameters */
+    p_Rtc = (t_FmRtc *)XX_Malloc(sizeof(t_FmRtc));
+    if (!p_Rtc)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM RTC driver structure"));
+        return NULL;
+    }
+
+    memset(p_Rtc, 0, sizeof(t_FmRtc));
+
+    /* Allocate memory for the FM RTC driver parameters */
+    p_Rtc->p_RtcDriverParam = (t_FmRtcDriverParam *)XX_Malloc(sizeof(t_FmRtcDriverParam));
+    if (!p_Rtc->p_RtcDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM RTC driver parameters"));
+        XX_Free(p_Rtc);
+        return NULL;
+    }
+
+    memset(p_Rtc->p_RtcDriverParam, 0, sizeof(t_FmRtcDriverParam));
+
+    /* Store RTC configuration parameters */
+    p_Rtc->h_Fm = p_FmRtcParam->h_Fm;
+
+    /* Set default RTC configuration parameters */
+    SetDefaultParam(p_Rtc);
+
+    /* Store RTC parameters in the RTC control structure */
+    p_Rtc->p_MemMap = (t_FmRtcMemMap *)UINT_TO_PTR(p_FmRtcParam->baseAddress);
+    p_Rtc->h_App    = p_FmRtcParam->h_App;
+
+    return p_Rtc;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Init(t_Handle h_FmRtc)
+{
+    t_FmRtc             *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcDriverParam  *p_RtcDriverParam;
+    t_FmRtcMemMap       *p_MemMap;
+    uint32_t            freqCompensation;
+    uint32_t            tmrCtrl;
+    int                 i;
+    uint64_t            tmpDouble;
+
+    p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    p_MemMap = p_Rtc->p_MemMap;
+
+    if(CheckInitParameters(p_Rtc)!=E_OK)
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+                     ("Init Parameters are not Valid"));
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    WRITE_UINT32(p_MemMap->tmr_ctrl, TMR_CTRL_TMSR);
+    XX_UDelay(10);
+    WRITE_UINT32(p_MemMap->tmr_ctrl, 0);
+
+    /* Set the source clock */
+    switch (p_RtcDriverParam->srcClk)
+    {
+        case e_FM_RTC_SOURCE_CLOCK_SYSTEM:
+            tmrCtrl = TMR_CTRL_CKSEL_MAC_CLK;
+            break;
+        case e_FM_RTC_SOURCE_CLOCK_OSCILATOR:
+            tmrCtrl = TMR_CTRL_CKSEL_OSC_CLK;
+            break;
+        default:
+            /* Use a clock from the External TMR reference clock.*/
+            tmrCtrl = TMR_CTRL_CKSEL_EXT_CLK;
+            break;
+    }
+
+    /* whatever period the user picked, the timestamp will advance in '1' every time
+     * the period passed. */
+    tmrCtrl |= ((1 << TMR_CTRL_TCLK_PERIOD_SHIFT) & TMR_CTRL_TCLK_PERIOD_MASK);
+
+    if (p_RtcDriverParam->invertInputClkPhase)
+        tmrCtrl |= TMR_CTRL_CIPH;
+    if (p_RtcDriverParam->invertOutputClkPhase)
+        tmrCtrl |= TMR_CTRL_COPH;
+
+    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        if (p_RtcDriverParam->alarmPolarity[i] == e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW)
+            tmrCtrl |= (TMR_CTRL_ALMP1 >> i);
+    }
+
+    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
+        if (p_RtcDriverParam->triggerPolarity[i] == e_FM_RTC_TRIGGER_ON_FALLING_EDGE)
+            tmrCtrl |= (TMR_CTRL_ETEP1 << i);
+
+    if (!p_RtcDriverParam->timerSlaveMode && p_Rtc->p_RtcDriverParam->bypass)
+        tmrCtrl |= TMR_CTRL_BYP;
+
+    WRITE_UINT32(p_MemMap->tmr_ctrl, tmrCtrl);
+
+     for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
+    {
+        /* Clear TMR_ALARM registers */
+        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_l, 0xFFFFFFFF);
+        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_h, 0xFFFFFFFF);
+    }
+
+    /* Clear TMR_TEVENT */
+    WRITE_UINT32(p_MemMap->tmr_tevent, TMR_TEVENT_ALL);
+
+    /* Initialize TMR_TEMASK */
+    WRITE_UINT32(p_MemMap->tmr_temask, 0);
+
+
+    /* find source clock frequency in Mhz */
+    if (p_Rtc->p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
+         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->extSrcClkFreq;
+    else
+        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetClockFreq(p_Rtc->h_Fm)/2);
+
+    /* if timer in Master mode Initialize TMR_CTRL */
+    /* We want the counter (TMR_CNT) to count in nano-seconds */
+    if (!p_RtcDriverParam->timerSlaveMode && p_Rtc->p_RtcDriverParam->bypass)
+    {
+        p_Rtc->clockPeriodNanoSec = (1000 / p_Rtc->srcClkFreqMhz);
+    }
+    else
+    {
+        /* Initialize TMR_ADD with the initial frequency compensation value:
+           freqCompensation = (2^32 / frequency ratio) */
+        /* frequency ratio = sorce clock/rtc clock =
+         * (p_Rtc->srcClkFreqMhz*1000000))/ 1/(p_Rtc->clockPeriodNanoSec * 1000000000) */
+        freqCompensation = DIV_CEIL(ACCUMULATOR_OVERFLOW * 1000, p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz);
+        WRITE_UINT32(p_MemMap->tmr_add, freqCompensation);
+    }
+    /* check the legality of the relation between source and destination clocks */
+    /* should be larger than 1.0001 */
+    tmpDouble = 10000 * (uint64_t)p_Rtc->clockPeriodNanoSec * (uint64_t)p_Rtc->srcClkFreqMhz;
+    if((tmpDouble) <= 10001)
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+              ("Invalid relation between source and destination clocks. Should be larger than 1.0001"));
+
+
+    for (i=0; i < 2; i++)
+        /* Clear TMR_FIPER registers */
+        WRITE_UINT32(p_MemMap->tmr_fiper[i], 0xFFFFFFFF);
+
+    /* Initialize TMR_PRSC */
+    WRITE_UINT32(p_MemMap->tmr_prsc, p_Rtc->outputClockDivisor);
+
+    /* Clear TMR_OFF */
+    WRITE_UINT32(p_MemMap->tmr_off_l, 0);
+    WRITE_UINT32(p_MemMap->tmr_off_h, 0);
+
+    /* Register the FM RTC interrupt */
+    FmRegisterIntr(p_Rtc->h_Fm, e_FM_MOD_TMR, 0, e_FM_INTR_TYPE_NORMAL, RtcExceptions , p_Rtc);
+
+    /* Free parameters structures */
+    XX_Free(p_Rtc->p_RtcDriverParam);
+    p_Rtc->p_RtcDriverParam = NULL;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Free(t_Handle h_FmRtc)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+
+    if (p_Rtc->p_RtcDriverParam)
+    {
+        XX_Free(p_Rtc->p_RtcDriverParam);
+    }
+    else
+    {
+        FM_RTC_Disable(h_FmRtc);
+    }
+
+    /* Unregister FM RTC interrupt */
+    FmUnregisterIntr(p_Rtc->h_Fm, e_FM_MOD_TMR, 0, e_FM_INTR_TYPE_NORMAL);
+    XX_Free(p_Rtc);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigSourceClock(t_Handle         h_FmRtc,
+                                    e_FmSrcClk    srcClk,
+                                    uint32_t      freqInMhz)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->srcClk = srcClk;
+    if(srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
+        p_Rtc->p_RtcDriverParam->extSrcClkFreq = freqInMhz;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigPeriod(t_Handle h_FmRtc, uint32_t period)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->clockPeriodNanoSec = period;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigFrequencyBypass(t_Handle h_FmRtc, bool enabled)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->bypass = enabled;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->invertInputClkPhase = inverted;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->invertOutputClkPhase = inverted;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigOutputClockDivisor(t_Handle h_FmRtc, uint16_t divisor)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->outputClockDivisor = divisor;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    p_Rtc->p_RtcDriverParam->pulseRealign = enable;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
+                                   uint8_t              alarmId,
+                                   e_FmRtcAlarmPolarity alarmPolarity)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (alarmId >= FM_RTC_NUM_OF_ALARMS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
+    }
+
+    p_Rtc->p_RtcDriverParam->alarmPolarity[alarmId] = alarmPolarity;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
+                                             uint8_t                triggerId,
+                                             e_FmRtcTriggerPolarity triggerPolarity)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (triggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
+    }
+
+    p_Rtc->p_RtcDriverParam->triggerPolarity[triggerId] = triggerPolarity;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = p_Rtc->p_MemMap;
+    uint32_t        tmrCtrl;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    tmrCtrl = GET_UINT32(p_MemMap->tmr_ctrl);
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    if (resetClock)
+    {
+        WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TMSR));
+
+        XX_UDelay(10);
+        /* Clear TMR_OFF */
+        WRITE_UINT32(p_MemMap->tmr_off_l, 0);
+        WRITE_UINT32(p_MemMap->tmr_off_h, 0);
+    }
+
+    WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TE));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_Disable(t_Handle h_FmRtc)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmrCtrl;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TODO A check must be added here, that no timestamping MAC's
+     * are working in this stage. */
+    tmrCtrl = GET_UINT32(p_MemMap->tmr_ctrl);
+    WRITE_UINT32(p_MemMap->tmr_ctrl, (tmrCtrl & ~(TMR_CTRL_TE)));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset)
+{
+    t_FmRtc *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TMR_OFF_L must be written first */
+    WRITE_UINT32(p_MemMap->tmr_off_l, (uint32_t)offset);
+    WRITE_UINT32(p_MemMap->tmr_off_h, (uint32_t)(offset >> 32));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+    uint64_t        tmpAlarm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcAlarmParams->alarmId >= FM_RTC_NUM_OF_ALARMS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
+    }
+
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Alarm when RTC is enabled."));
+    if(p_FmRtcAlarmParams->alarmTime < p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    if(p_FmRtcAlarmParams->alarmTime % (uint64_t)p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    tmpAlarm = p_FmRtcAlarmParams->alarmTime/(uint64_t)p_Rtc->clockPeriodNanoSec;
+
+    /* TMR_ALARM_L must be written first */
+    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_l, (uint32_t)tmpAlarm);
+    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_h,
+                 (uint32_t)(tmpAlarm >> 32));
+
+    p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].f_AlarmCallback = p_FmRtcAlarmParams->f_AlarmCallback;
+    p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].clearOnExpiration = p_FmRtcAlarmParams->clearOnExpiration;
+
+    if(p_FmRtcAlarmParams->alarmId == 0)
+        tmpReg = TMR_TEVENT_ALM1;
+    else
+        tmpReg = TMR_TEVENT_ALM2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_FmRtcPeriodicPulseParams)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmpReg;
+    uint64_t    tmpFiper;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcPeriodicPulseParams->periodicPulseId >= FM_RTC_NUM_OF_PERIODIC_PULSES)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
+    }
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Periodic pulse when RTC is enabled."));
+    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod % (uint64_t)p_Rtc->clockPeriodNanoSec)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
+    tmpFiper = p_FmRtcPeriodicPulseParams->periodicPulsePeriod/(uint64_t)p_Rtc->clockPeriodNanoSec;
+    if(tmpFiper & 0xffffffff00000000LL)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse/RTC Period must be smaller than 4294967296", p_Rtc->clockPeriodNanoSec));
+
+    WRITE_UINT32(p_MemMap->tmr_fiper[p_FmRtcPeriodicPulseParams->periodicPulseId], (uint32_t)tmpFiper);
+
+    p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
+                                                            p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
+
+    if(p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
+        tmpReg = TMR_TEVENT_PP1;
+    else
+        tmpReg = TMR_TEVENT_PP2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (periodicPulseId >= FM_RTC_NUM_OF_PERIODIC_PULSES)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
+    }
+
+    p_Rtc->periodicPulseParams[periodicPulseId].f_PeriodicPulseCallback = NULL;
+
+    if(periodicPulseId == 0)
+        tmpReg = TMR_TEVENT_PP1;
+    else
+        tmpReg = TMR_TEVENT_PP2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~tmpReg);
+
+    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_FS)
+        WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) & ~TMR_CTRL_FS);
+
+    WRITE_UINT32(p_MemMap->tmr_fiper[periodicPulseId], 0xFFFFFFFF);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams *p_FmRtcExternalTriggerParams)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (p_FmRtcExternalTriggerParams->externalTriggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External Trigger ID"));
+    }
+
+    p_Rtc->externalTriggerParams[p_FmRtcExternalTriggerParams->externalTriggerId].f_ExternalTriggerCallback = p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback;
+    if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+        tmpReg = TMR_TEVENT_ETS1;
+    else
+        tmpReg = TMR_TEVENT_ETS2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+
+    if(p_FmRtcExternalTriggerParams->usePulseAsInput)
+    {
+        if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+            tmpReg = TMR_CTRL_PP1L;
+        else
+            tmpReg = TMR_CTRL_PP2L;
+    }
+    WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) | tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t externalTriggerId)
+{
+    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap   *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (externalTriggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External Trigger ID"));
+
+    p_Rtc->externalTriggerParams[externalTriggerId].f_ExternalTriggerCallback = NULL;
+
+    if(externalTriggerId == 0)
+        tmpReg = TMR_TEVENT_ETS1;
+    else
+        tmpReg = TMR_TEVENT_ETS2;
+    WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~tmpReg);
+
+    if(externalTriggerId == 0)
+        tmpReg = TMR_CTRL_PP1L;
+    else
+        tmpReg = TMR_CTRL_PP2L;
+
+    if (GET_UINT32(p_MemMap->tmr_ctrl) & tmpReg)
+        WRITE_UINT32(p_MemMap->tmr_ctrl, GET_UINT32(p_MemMap->tmr_ctrl) & ~tmpReg);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
+                                              uint8_t           triggerId,
+                                              uint64_t          *p_TimeStamp)
+{
+    t_FmRtc  *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint64_t    timeStamp;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    if (triggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
+    }
+
+    timeStamp = (uint64_t)GET_UINT32(p_MemMap->tmr_etts[triggerId].tmr_etts_l);
+    timeStamp |= ((uint64_t)GET_UINT32(p_MemMap->tmr_etts[triggerId].tmr_etts_h) << 32);
+
+    timeStamp = timeStamp*p_Rtc->clockPeriodNanoSec;
+    *p_TimeStamp = timeStamp;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    uint64_t    time;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    /* TMR_CNT_L must be read first to get an accurate value */
+    time = (uint64_t)GET_UINT32(p_MemMap->tmr_cnt_l);
+    time |= ((uint64_t)GET_UINT32(p_MemMap->tmr_cnt_h) << 32);
+
+    time = time*p_Rtc->clockPeriodNanoSec;
+
+    *p_Ts = time;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
+
+    ts = ts/p_Rtc->clockPeriodNanoSec;
+    /* TMR_CNT_L must be written first to get an accurate value */
+    WRITE_UINT32(p_MemMap->tmr_cnt_l, (uint32_t)ts);
+    WRITE_UINT32(p_MemMap->tmr_cnt_h, (uint32_t)(ts >> 32));
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc)
+{
+    t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
+    t_FmRtcMemMap *p_MemMap = (t_FmRtcMemMap *)p_Rtc->p_MemMap;
+    int i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_MemMap)
+    {
+
+        DUMP_TITLE(p_MemMap, ("RTC:"));
+        DUMP_VAR(p_MemMap, tmr_id);
+        DUMP_VAR(p_MemMap, tmr_id2);
+        DUMP_VAR(p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_MemMap, tmr_tevent);
+        DUMP_VAR(p_MemMap, tmr_temask);
+        DUMP_VAR(p_MemMap, tmr_cnt_h);
+        DUMP_VAR(p_MemMap, tmr_cnt_l);
+        DUMP_VAR(p_MemMap, tmr_ctrl);
+        DUMP_VAR(p_MemMap, tmr_add);
+        DUMP_VAR(p_MemMap, tmr_acc);
+        DUMP_VAR(p_MemMap, tmr_prsc);
+        DUMP_VAR(p_MemMap, tmr_off_h);
+        DUMP_VAR(p_MemMap, tmr_off_l);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_h);
+            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_l);
+        }
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_fiper[i]);
+            DUMP_VAR(p_MemMap, tmr_fiper[i]);
+        }
+        DUMP_SUBSTRUCT_ARRAY(i, 2)
+        {
+            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
+            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
+        }
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
new file mode 100644
index 0000000..eb8046c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -0,0 +1,217 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_rtc.h
+
+ @Description   Memory map and internal definitions for FM RTC IEEE1588 Timer driver.
+
+ @Cautions      None
+*//***************************************************************************/
+
+#ifndef __FM_RTC_H__
+#define __FM_RTC_H__
+
+#include "std_ext.h"
+#include "fm_rtc_ext.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_RTC
+
+/* General definitions */
+
+#define NANOSEC_PER_ONE_HZ_TICK         1000000000
+#define MIN_RTC_CLK_FREQ_HZ             1000
+#define MHz                             1000000
+
+#define ACCUMULATOR_OVERFLOW            ((uint64_t)(1LL << 32))
+
+/* RTC default values */
+#define DEFAULT_srcClock                e_FM_RTC_SOURCE_CLOCK_SYSTEM
+#define DEFAULT_bypass      FALSE
+#define DEFAULT_invertInputClkPhase     FALSE
+#define DEFAULT_invertOutputClkPhase    FALSE
+#define DEFAULT_outputClockDivisor      0x00000002
+#define DEFAULT_alarmPolarity           e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH
+#define DEFAULT_triggerPolarity         e_FM_RTC_TRIGGER_ON_FALLING_EDGE
+#define DEFAULT_pulseRealign            FALSE
+#define DEFAULT_clockPeriod             1000
+
+/* FM RTC Registers definitions */
+#define TMR_CTRL_ALMP1                  0x80000000
+#define TMR_CTRL_ALMP2                  0x40000000
+#define TMR_CTRL_FS                     0x10000000
+#define TMR_CTRL_PP1L                   0x08000000
+#define TMR_CTRL_PP2L                   0x04000000
+#define TMR_CTRL_TCLK_PERIOD_MASK       0x03FF0000
+#define TMR_CTRL_FRD                    0x00004000
+#define TMR_CTRL_SLV                    0x00002000
+#define TMR_CTRL_ETEP1                  0x00000100
+#define TMR_CTRL_COPH                   0x00000080
+#define TMR_CTRL_CIPH                   0x00000040
+#define TMR_CTRL_TMSR                   0x00000020
+#define TMR_CTRL_DBG                    0x00000010
+#define TMR_CTRL_BYP                    0x00000008
+#define TMR_CTRL_TE                     0x00000004
+#define TMR_CTRL_CKSEL_OSC_CLK          0x00000003
+#define TMR_CTRL_CKSEL_MAC_CLK          0x00000001
+#define TMR_CTRL_CKSEL_EXT_CLK          0x00000000
+#define TMR_CTRL_TCLK_PERIOD_SHIFT      16
+
+#define TMR_TEVENT_ETS2                 0x02000000
+#define TMR_TEVENT_ETS1                 0x01000000
+#define TMR_TEVENT_ALM2                 0x00020000
+#define TMR_TEVENT_ALM1                 0x00010000
+#define TMR_TEVENT_PP1                  0x00000080
+#define TMR_TEVENT_PP2                  0x00000040
+#define TMR_TEVENT_PP3                  0x00000020
+#define TMR_TEVENT_ALL                  (TMR_TEVENT_ETS2 | TMR_TEVENT_ETS1 | \
+                                         TMR_TEVENT_ALM2 | TMR_TEVENT_ALM1 | \
+                                         TMR_TEVENT_PP1 | TMR_TEVENT_PP2 | TMR_TEVENT_PP3)
+
+#define TMR_PRSC_OCK_MASK               0x0000FFFF
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description FM RTC timer alarm
+*//***************************************************************************/
+typedef _Packed struct t_TmrAlaram
+{
+    volatile uint32_t   tmr_alarm_h;    /**<  */
+    volatile uint32_t   tmr_alarm_l;    /**<  */
+} _PackedType t_TmrAlaram;
+
+/**************************************************************************//**
+ @Description FM RTC timer Ex trigger
+*//***************************************************************************/
+typedef _Packed struct t_TmrExtTrigger
+{
+    volatile uint32_t   tmr_etts_l;     /**<  */
+    volatile uint32_t   tmr_etts_h;     /**<  */
+} _PackedType t_TmrExtTrigger;
+
+typedef _Packed struct
+{
+    volatile uint32_t tmr_id;      /* Module ID and version register */
+    volatile uint32_t tmr_id2;     /* Module ID and configuration register */
+    volatile uint32_t PTP_RESERVED1[30];
+    volatile uint32_t tmr_ctrl;    /* timer control register */
+    volatile uint32_t tmr_tevent;  /* timer event register */
+    volatile uint32_t tmr_temask;  /* timer event mask register */
+    volatile uint32_t PTP_RESERVED2[3];
+    volatile uint32_t tmr_cnt_h;   /* timer counter high register */
+    volatile uint32_t tmr_cnt_l;   /* timer counter low register */
+    volatile uint32_t tmr_add;     /* timer drift compensation addend register */
+    volatile uint32_t tmr_acc;     /* timer accumulator register */
+    volatile uint32_t tmr_prsc;    /* timer prescale */
+    volatile uint32_t PTP_RESERVED3;
+    volatile uint32_t tmr_off_h;    /* timer offset high */
+    volatile uint32_t tmr_off_l;    /* timer offset low  */
+    volatile t_TmrAlaram tmr_alarm[FM_RTC_NUM_OF_ALARMS]; /* timer alarm */
+    volatile uint32_t PTP_RESERVED4[2];
+    volatile uint32_t tmr_fiper[FM_RTC_NUM_OF_PERIODIC_PULSES]; /* timer fixed period interval */
+    volatile uint32_t PTP_RESERVED5[2];
+    volatile t_TmrExtTrigger tmr_etts[FM_RTC_NUM_OF_EXT_TRIGGERS]; /*time stamp general purpose external */
+    volatile uint32_t PTP_RESERVED6[3];
+} _PackedType t_FmRtcMemMap;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description   RTC FM driver parameters structure.
+*//***************************************************************************/
+typedef struct t_FmRtcDriverParam
+{
+    t_Handle                h_Fm;                   /**<  */
+    e_FmSrcClk              srcClk;               /**<  */
+    uint32_t                extSrcClkFreq;         /**<  */
+    uint32_t                rtcFreqHz;              /**<  */
+    bool                    timerSlaveMode;         /*Slave/Master Mode*/
+    bool                    invertInputClkPhase;
+    bool                    invertOutputClkPhase;
+    uint32_t                eventsMask;
+    bool                    bypass; /**< Indicates if frequency compensation is bypassed */
+    bool                    pulseRealign;
+    e_FmRtcAlarmPolarity    alarmPolarity[FM_RTC_NUM_OF_ALARMS];
+    e_FmRtcTriggerPolarity  triggerPolarity[FM_RTC_NUM_OF_EXT_TRIGGERS];
+} t_FmRtcDriverParam;
+
+typedef struct t_FmRtcAlarm
+{
+    t_FmRtcExceptionsCallback   *f_AlarmCallback;
+    bool                        clearOnExpiration;
+} t_FmRtcAlarm;
+
+typedef struct t_FmRtcPeriodicPulse
+{
+    t_FmRtcExceptionsCallback   *f_PeriodicPulseCallback;
+} t_FmRtcPeriodicPulse;
+
+typedef struct t_FmRtcExternalTrigger
+{
+    t_FmRtcExceptionsCallback   *f_ExternalTriggerCallback;
+} t_FmRtcExternalTrigger;
+
+
+/**************************************************************************//**
+ @Description RTC FM driver control structure.
+*//***************************************************************************/
+typedef struct t_FmRtc
+{
+    t_Part                  *p_Part;            /**< Pointer to the integration device              */
+    t_Handle                h_Fm;
+    t_Handle                h_App;              /**< Application handle */
+    t_FmRtcMemMap           *p_MemMap;          /**< Pointer to RTC memory map */
+    uint32_t                clockPeriodNanoSec; /**< RTC clock period in nano-seconds (for FS mode) */
+    uint32_t                srcClkFreqMhz;
+    uint16_t                outputClockDivisor; /**< Output clock divisor (for FS mode) */
+    t_FmRtcAlarm            alarmParams[FM_RTC_NUM_OF_ALARMS];
+    t_FmRtcPeriodicPulse    periodicPulseParams[FM_RTC_NUM_OF_PERIODIC_PULSES];
+    t_FmRtcExternalTrigger  externalTriggerParams[FM_RTC_NUM_OF_EXT_TRIGGERS];
+    t_FmRtcDriverParam      *p_RtcDriverParam;  /**< RTC Driver parameters (for Init phase) */
+} t_FmRtc;
+
+
+#endif /* __FM_RTC_H__ */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
new file mode 100644
index 0000000..64ea1d0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -0,0 +1,4615 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_muram_ext.h"
+
+#include "fm_common.h"
+#include "fm_ipc.h"
+#include "fm.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static volatile bool blockingFlag = FALSE;
+static void IpcMsgCompletionCB(t_Handle   h_Fm,
+                               uint8_t    *p_Msg,
+                               uint8_t    *p_Reply,
+                               uint32_t   replyLength,
+                               t_Error    status)
+{
+    UNUSED(h_Fm);UNUSED(p_Msg);UNUSED(p_Reply);UNUSED(replyLength);UNUSED(status);
+    blockingFlag = FALSE;
+}
+
+static bool IsFmanCtrlCodeLoaded(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram;
+
+    ASSERT_COND(p_Fm);
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+
+    return (bool)!!(GET_UINT32(p_Iram->iready) & IRAM_READY);
+}
+
+static t_Error CheckFmParameters(t_Fm *p_Fm)
+{
+    if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FMan CTRL code is already loaded; FM must be reset!"));
+    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
+    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
+    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
+
+    if(!p_Fm->p_FmStateStruct->fmClkFreq)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
+    if (USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq) > DMA_MAX_WATCHDOG)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
+
+#ifdef FM_PARTITION_ARRAY
+    {
+        t_FmRevisionInfo revInfo;
+        uint8_t     i;
+
+        FM_GetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            for (i=0; i<FM_SIZE_OF_LIODN_TABLE; i++)
+                if (p_Fm->p_FmDriverParam->liodnBasePerPort[i] & ~FM_LIODN_BASE_MASK)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
+    }
+#endif /* FM_PARTITION_ARRAY */
+
+    if(p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
+    if(!p_Fm->p_FmStateStruct->totalFifoSize || (p_Fm->p_FmStateStruct->totalFifoSize > BMI_MAX_FIFO_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(!p_Fm->p_FmStateStruct->totalNumOfTasks || (p_Fm->p_FmStateStruct->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
+    if(!p_Fm->p_FmStateStruct->maxNumOfOpenDmas || (p_Fm->p_FmStateStruct->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
+
+    if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
+
+    if(!p_Fm->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+    if(!p_Fm->f_BusError)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    return E_OK;
+}
+
+static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
+{
+    t_Error     err;
+    t_FmIpcIsr  fmIpcIsr;
+    t_FmIpcMsg  msg;
+
+    ASSERT_COND(p_Fm->guestId == NCSW_MASTER_ID);
+    ASSERT_COND(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId]);
+    if (p_Fm->intrMng[macEvent].guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_GUEST_ISR;
+        fmIpcIsr.pendingReg = pendingReg;
+        fmIpcIsr.boolErr = FALSE;
+        memcpy(msg.msgBody, &fmIpcIsr, sizeof(fmIpcIsr));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(fmIpcIsr),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+        return;
+    }
+    else
+        p_Fm->intrMng[macEvent].f_Isr(p_Fm->intrMng[macEvent].h_SrcHandle);
+}
+
+static void    BmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
+    mask = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr)& event)
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, event & ~(event & mask));
+
+    event &= mask;
+
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
+
+    if(event & BMI_ERR_INTR_EN_PIPELINE_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
+    if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
+    if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
+    if(event & BMI_ERR_INTR_EN_DISPATCH_RAM_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_DISPATCH_RAM_ECC);
+}
+
+static void    QmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif)& event)
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, event & ~(event & mask));
+
+    event &= mask;
+
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
+
+    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
+    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID);
+}
+
+static void    DmaErrEvent(t_Fm *p_Fm)
+{
+    uint64_t            addr=0;
+    uint32_t            status, mask, tmpReg=0;
+    uint8_t             tnum;
+    uint8_t             hardwarePortId;
+    uint8_t             relativePortId;
+    uint16_t            liodn;
+
+    status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+    mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+
+    /* get bus error regs befor clearing BER */
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        addr = (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtal);
+        addr |= ((uint64_t)(GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtah)) << 32);
+
+        /* get information about the owner of that bus error */
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtcid);
+    }
+
+    /* clear set events */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, status);
+
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        hardwarePortId = (uint8_t)(((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
+        tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
+        liodn = (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK);
+        ASSERT_COND(p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
+        p_Fm->f_BusError(p_Fm->h_App, p_Fm->p_FmStateStruct->portsTypes[hardwarePortId], relativePortId, addr, tnum, liodn);
+    }
+    if(mask & DMA_MODE_ECC)
+    {
+        if (status & DMA_STATUS_READ_ECC)
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_READ_ECC);
+        if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC);
+        if (status & DMA_STATUS_FM_WRITE_ECC)
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC);
+    }
+}
+
+static void    FpmErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+
+    /* clear the all occured events */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
+
+    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
+    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
+    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
+}
+
+static void    MuramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+
+    /* clear MURAM event bit */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
+
+    ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
+    ASSERT_COND(event & FPM_RAM_CTL_RAMS_ECC_EN);
+
+    if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
+        p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_MURAM_ECC);
+}
+
+static void IramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+    /* clear the acknowledged events (do not clear IRAM event) */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
+
+    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
+    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
+
+    if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
+        p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_IRAM_ECC);
+}
+
+static void QmiEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if)& event)
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if,  event & ~(event & mask));
+
+    event &= mask;
+
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
+
+    if(event & QMI_INTR_EN_SINGLE_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
+}
+
+static void UnimplementedIsr(t_Handle h_Arg)
+{
+    UNUSED(h_Arg);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
+static void UnimplementedFmanCtrlIsr(t_Handle h_Arg, uint32_t event)
+{
+    UNUSED(h_Arg); UNUSED(event);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
+}
+
+static void FmEnableTimeStamp(t_Fm *p_Fm)
+{
+    uint32_t                tmpReg;
+    uint64_t                fraction;
+    uint32_t                integer;
+    uint8_t                 count1MicroBit = 8;
+    uint32_t                tsFrequency = (uint32_t)(1<<count1MicroBit); /* in Mhz */
+
+    /* configure timestamp so that bit 8 will count 1 microsecond */
+    /* Find effective count rate at TIMESTAMP least significant bits:
+       Effective_Count_Rate = 1MHz x 2^8 = 256MHz
+       Find frequency ratio between effective count rate and the clock:
+       Effective_Count_Rate / CLK e.g. for 600 MHz clock:
+       256/600 = 0.4266666... */
+    integer = tsFrequency/p_Fm->p_FmStateStruct->fmClkFreq;
+    /* we multiply by 2^16 to keep the fraction of the division */
+    /* we do not divid back, since we write this value as fraction - see spec */
+    fraction = ((tsFrequency << 16) - (integer << 16)*p_Fm->p_FmStateStruct->fmClkFreq)/p_Fm->p_FmStateStruct->fmClkFreq;
+    /* we check remainder of the division in order to round up if not integer */
+    if(((tsFrequency << 16) - (integer << 16)*p_Fm->p_FmStateStruct->fmClkFreq) % p_Fm->p_FmStateStruct->fmClkFreq)
+        fraction++;
+
+    tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
+
+    /* enable timestamp with original clock */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, FPM_TS_CTL_EN);
+
+    p_Fm->p_FmStateStruct->count1MicroBit = count1MicroBit;
+    p_Fm->p_FmStateStruct->enabledTimeStamp = TRUE;
+}
+
+static void FreeInitResources(t_Fm *p_Fm)
+{
+    if (p_Fm->camBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
+    if (p_Fm->fifoBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->fifoBaseAddr));
+    if (p_Fm->resAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->resAddr));
+}
+
+static t_Error ClearIRam(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram;
+    int             i;
+
+    ASSERT_COND(p_Fm);
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+
+    /* Enable the auto-increment */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < (FM_IRAM_SIZE/4); i++)
+        WRITE_UINT32(p_Iram->idata, 0xffffffff);
+
+    WRITE_UINT32(p_Iram->iadd, FM_IRAM_SIZE - 4);
+    CORE_MemoryBarrier();
+    while (GET_UINT32(p_Iram->idata) != 0xffffffff) ;
+
+    return E_OK;
+}
+
+static t_Error ReadFmanCtrlCode(t_Handle h_Fm, uint32_t *p_buff, uint32_t size)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_FMIramRegs    *p_Iram;
+    int             i;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_buff);
+    ASSERT_COND(size);
+
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+
+    /* Enable the auto-increment */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < ((size + 3) / 4); i++)
+        p_buff[i] = GET_UINT32(p_Iram->idata);
+
+    return E_OK;
+}
+
+static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram;
+    int             i;
+    uint32_t        tmp;
+    uint8_t         compTo16;
+
+    ASSERT_COND(p_Fm);
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+
+    /* Enable the auto-increment */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+        WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
+
+    compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
+    if(compTo16)
+        for (i=0; i < ((16-compTo16) / 4); i++)
+            WRITE_UINT32(p_Iram->idata, 0xffffffff);
+
+    WRITE_UINT32(p_Iram->iadd,p_Fm->p_FmDriverParam->firmware.size-4);
+    while(GET_UINT32(p_Iram->iadd) != (p_Fm->p_FmDriverParam->firmware.size-4)) ;
+
+    /* verify that writing has completed */
+    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[(p_Fm->p_FmDriverParam->firmware.size / 4)-1]) ;
+
+    if (p_Fm->p_FmDriverParam->fwVerify)
+    {
+        WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+        while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+        for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+            if ((tmp=GET_UINT32(p_Iram->idata)) != p_Fm->p_FmDriverParam->firmware.p_Code[i])
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED,
+                             ("UCode write error : write 0x%x, read 0x%x",
+                              p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
+        WRITE_UINT32(p_Iram->iadd, 0x0);
+    }
+
+    /* Enable patch from IRAM */
+    WRITE_UINT32(p_Iram->iready, IRAM_READY);
+    XX_UDelay(1000);
+
+    DBG(INFO, ("FMan-Controller code (ver %d.%d) loaded to IRAM.",
+               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[5],
+               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[7]));
+
+    return E_OK;
+}
+
+
+/****************************************/
+/*       Inter-Module functions         */
+/****************************************/
+static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
+                                     uint8_t   *p_Msg,
+                                     uint32_t  msgLength,
+                                     uint8_t   *p_Reply,
+                                     uint32_t  *p_ReplyLength)
+{
+    t_FmIpcMsg      *p_IpcMsg   = (t_FmIpcMsg*)p_Msg;
+
+    UNUSED(p_Reply);
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength > sizeof(uint32_t)), E_INVALID_VALUE);
+
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(msgLength);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    ASSERT_COND(p_Msg);
+
+    *p_ReplyLength = 0;
+
+    switch(p_IpcMsg->msgId)
+    {
+        case (FM_GUEST_ISR):
+        {
+            t_FmIpcIsr ipcIsr;
+
+            memcpy((uint8_t*)&ipcIsr, p_IpcMsg->msgBody, sizeof(t_FmIpcIsr));
+            if(ipcIsr.boolErr)
+                FM_GuestErrorIsr(h_Fm, ipcIsr.pendingReg);
+            else
+                FM_GuestEventIsr(h_Fm, ipcIsr.pendingReg);
+            break;
+        }
+        default:
+            *p_ReplyLength = 0;
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+
+static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
+                                uint8_t   *p_Msg,
+                                uint32_t  msgLength,
+                                uint8_t   *p_Reply,
+                                uint32_t  *p_ReplyLength)
+{
+    t_Fm            *p_Fm       = (t_Fm*)h_Fm;
+    t_FmIpcMsg      *p_IpcMsg   = (t_FmIpcMsg*)p_Msg;
+    t_FmIpcReply    *p_IpcReply = (t_FmIpcReply*)p_Reply;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((msgLength >= sizeof(uint32_t)), E_INVALID_VALUE);
+
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(msgLength);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    ASSERT_COND(p_IpcMsg);
+
+    memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_IPC_MAX_REPLY_SIZE));
+    *p_ReplyLength = 0;
+
+    switch(p_IpcMsg->msgId)
+    {
+        case (FM_GET_SET_PORT_PARAMS):
+        {
+            t_FmIpcPortInInitParams         ipcInitParams;
+            t_FmInterModulePortInitParams   initParams;
+            t_FmIpcPhysAddr                 ipcPhysAddr;
+
+            memcpy((uint8_t*)&ipcInitParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortInInitParams));
+            initParams.hardwarePortId = ipcInitParams.hardwarePortId;
+            initParams.portType = (e_FmPortType)ipcInitParams.enumPortType;
+            initParams.independentMode = (bool)(ipcInitParams.boolIndependentMode);
+            initParams.liodnOffset = ipcInitParams.liodnOffset;
+            initParams.numOfTasks = ipcInitParams.numOfTasks;
+            initParams.numOfExtraTasks = ipcInitParams.numOfExtraTasks;
+            initParams.numOfOpenDmas = ipcInitParams.numOfOpenDmas;
+            initParams.numOfExtraOpenDmas = ipcInitParams.numOfExtraOpenDmas;
+            initParams.sizeOfFifo = ipcInitParams.sizeOfFifo;
+            initParams.extraSizeOfFifo = ipcInitParams.extraSizeOfFifo;
+            initParams.deqPipelineDepth = ipcInitParams.deqPipelineDepth;
+            initParams.liodnBase = ipcInitParams.liodnBase;
+#ifdef FM_RMU_ASSIST_SUPPORT
+            initParams.isRmuDoorbell = (bool)(ipcInitParams.boolIsRmuDoorbell);
+            initParams.isRmuMailbox0 = (bool)(ipcInitParams.boolIsRmuMailbox0);
+            initParams.isRmuMailbox1 = (bool)(ipcInitParams.boolIsRmuMailbox1);
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+            p_IpcReply->error = (uint32_t)FmGetSetPortParams(h_Fm, &initParams);
+            ipcPhysAddr.high = initParams.fmMuramPhysBaseAddr.high;
+            ipcPhysAddr.low = initParams.fmMuramPhysBaseAddr.low;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcPhysAddr, sizeof(t_FmIpcPhysAddr));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcPhysAddr);
+            break;
+        }
+        case (FM_SET_SIZE_OF_FIFO):
+        {
+            t_FmIpcPortFifoParams               ipcPortFifoParams;
+            t_FmInterModulePortRxPoolsParams    rxPoolsParams;
+
+            memcpy((uint8_t*)&ipcPortFifoParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortFifoParams));
+            rxPoolsParams.numOfPools = ipcPortFifoParams.numOfPools;
+            rxPoolsParams.secondLargestBufSize = ipcPortFifoParams.secondLargestBufSize;
+            rxPoolsParams.largestBufSize = ipcPortFifoParams.largestBufSize;
+
+            p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm, ipcPortFifoParams.rsrcParams.hardwarePortId,
+                                                (e_FmPortType)ipcPortFifoParams.enumPortType,
+                                                (bool)ipcPortFifoParams.boolIndependentMode,
+                                                &ipcPortFifoParams.rsrcParams.val,
+                                                ipcPortFifoParams.rsrcParams.extra,
+                                                ipcPortFifoParams.deqPipelineDepth,
+                                                &rxPoolsParams,
+                                                (bool)ipcPortFifoParams.boolInitialConfig);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcPortFifoParams.rsrcParams.val, sizeof(uint32_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case (FM_SET_NUM_OF_TASKS):
+        {
+            t_FmIpcPortRsrcParams   ipcPortRsrcParams;
+
+            memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
+            p_IpcReply->error = (uint32_t)FmSetNumOfTasks(h_Fm, ipcPortRsrcParams.hardwarePortId,
+                                                          (uint8_t)ipcPortRsrcParams.val,
+                                                          (uint8_t)ipcPortRsrcParams.extra,
+                                                          (bool)ipcPortRsrcParams.boolInitialConfig);
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_SET_NUM_OF_OPEN_DMAS):
+        {
+            t_FmIpcPortRsrcParams   ipcPortRsrcParams;
+
+            memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
+            p_IpcReply->error = (uint32_t)FmSetNumOfOpenDmas(h_Fm, ipcPortRsrcParams.hardwarePortId,
+                                                               (uint8_t)ipcPortRsrcParams.val,
+                                                               (uint8_t)ipcPortRsrcParams.extra,
+                                                               (bool)ipcPortRsrcParams.boolInitialConfig);
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_RESUME_STALLED_PORT):
+            *p_ReplyLength = sizeof(uint32_t);
+            p_IpcReply->error = (uint32_t)FmResumeStalledPort(h_Fm, p_IpcMsg->msgBody[0]);
+            break;
+        case (FM_MASTER_IS_ALIVE):
+        {
+            uint8_t guestId = p_IpcMsg->msgBody[0];
+            /* build the FM master partition IPC address */
+            memset(p_Fm->fmIpcHandlerModuleName[guestId], 0, (sizeof(char)) * MODULE_NAME_SIZE);
+            if(Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+            p_Fm->h_IpcSessions[guestId] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[guestId], p_Fm->fmModuleName);
+            if (p_Fm->h_IpcSessions[guestId] == NULL)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM Master IPC session for guest %d", guestId));
+            *(uint8_t*)(p_IpcReply->replyBody) = 1;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        }
+        case (FM_IS_PORT_STALLED):
+        {
+            bool tmp;
+
+            p_IpcReply->error = (uint32_t)FmIsPortStalled(h_Fm, p_IpcMsg->msgBody[0], &tmp);
+            *(uint8_t*)(p_IpcReply->replyBody) = (uint8_t)tmp;
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        }
+        case (FM_RESET_MAC):
+        {
+            t_FmIpcMacParams    ipcMacParams;
+
+            memcpy((uint8_t*)&ipcMacParams, p_IpcMsg->msgBody, sizeof(t_FmIpcMacParams));
+            p_IpcReply->error = (uint32_t)FmResetMac(p_Fm,
+                                                     (e_FmMacType)(ipcMacParams.enumType),
+                                                     ipcMacParams.id);
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+        }
+        case (FM_SET_MAC_MAX_FRAME):
+        {
+            t_Error                     err;
+            t_FmIpcMacMaxFrameParams    ipcMacMaxFrameParams;
+
+            memcpy((uint8_t*)&ipcMacMaxFrameParams, p_IpcMsg->msgBody, sizeof(t_FmIpcMacMaxFrameParams));
+            if ((err = FmSetMacMaxFrame(p_Fm,
+                                        (e_FmMacType)(ipcMacMaxFrameParams.macParams.enumType),
+                                        ipcMacMaxFrameParams.macParams.id,
+                                        ipcMacMaxFrameParams.maxFrameLength)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+        case (FM_GET_CLK_FREQ):
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&p_Fm->p_FmStateStruct->fmClkFreq, sizeof(uint16_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint16_t);
+            break;
+        case (FM_FREE_PORT):
+        {
+            t_FmInterModulePortFreeParams   portParams;
+            t_FmIpcPortFreeParams           ipcPortParams;
+
+            memcpy((uint8_t*)&ipcPortParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortFreeParams));
+            portParams.hardwarePortId = ipcPortParams.hardwarePortId;
+            portParams.portType = (e_FmPortType)(ipcPortParams.enumPortType);
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+            portParams.deqPipelineDepth = ipcPortParams.deqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+            FmFreePortParams(h_Fm, &portParams);
+            break;
+        }
+        case (FM_REGISTER_INTR):
+        {
+            t_FmIpcRegisterIntr ipcRegIntr;
+
+            memcpy((uint8_t*)&ipcRegIntr, p_IpcMsg->msgBody, sizeof(ipcRegIntr));
+            p_Fm->intrMng[ipcRegIntr.event].guestId = ipcRegIntr.guestId;
+            break;
+        }
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        case (FM_DUMP_REGS):
+        {
+            t_Error     err;
+            if ((err = FM_DumpRegs(h_Fm)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+        case (FM_DUMP_PORT_REGS):
+        {
+            t_Error     err;
+
+            if ((err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0])) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+#endif /* (defined(DEBUG_ERRORS) && ... */
+        case (FM_GET_REV):
+        {
+            t_FmRevisionInfo    revInfo;
+            t_FmIpcRevisionInfo ipcRevInfo;
+
+            p_IpcReply->error = (uint32_t)FM_GetRevision(h_Fm, &revInfo);
+            ipcRevInfo.majorRev = revInfo.majorRev;
+            ipcRevInfo.minorRev = revInfo.minorRev;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcRevInfo, sizeof(t_FmIpcRevisionInfo));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcRevisionInfo);
+            break;
+        }
+        case (FM_DMA_STAT):
+        {
+            t_FmDmaStatus       dmaStatus;
+            t_FmIpcDmaStatus    ipcDmaStatus;
+
+            FM_GetDmaStatus(h_Fm, &dmaStatus);
+            ipcDmaStatus.boolCmqNotEmpty = (uint8_t)dmaStatus.cmqNotEmpty;
+            ipcDmaStatus.boolBusError = (uint8_t)dmaStatus.busError;
+            ipcDmaStatus.boolReadBufEccError = (uint8_t)dmaStatus.readBufEccError;
+            ipcDmaStatus.boolWriteBufEccSysError = (uint8_t)dmaStatus.writeBufEccSysError;
+            ipcDmaStatus.boolWriteBufEccFmError = (uint8_t)dmaStatus.writeBufEccFmError;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcDmaStatus, sizeof(t_FmIpcDmaStatus));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus);
+            break;
+        }
+        case (FM_ALLOC_FMAN_CTRL_EVENT_REG):
+            p_IpcReply->error = (uint32_t)FmAllocFmanCtrlEventReg(h_Fm, (uint8_t*)p_IpcReply->replyBody);
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        case (FM_FREE_FMAN_CTRL_EVENT_REG):
+            FmFreeFmanCtrlEventReg(h_Fm, p_IpcMsg->msgBody[0]);
+            break;
+        case (FM_GET_TIMESTAMP_SCALE):
+        {
+            uint32_t    timeStamp = FmGetTimeStampScale(h_Fm);
+
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&timeStamp, sizeof(uint32_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case (FM_GET_COUNTER):
+        {
+            e_FmCounters    inCounter;
+            uint32_t        outCounter;
+
+            memcpy((uint8_t*)&inCounter, p_IpcMsg->msgBody, sizeof(uint32_t));
+            outCounter = FM_GetCounter(h_Fm, inCounter);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&outCounter, sizeof(uint32_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case (FM_SET_FMAN_CTRL_EVENTS_ENABLE):
+        {
+            t_FmIpcFmanEvents ipcFmanEvents;
+
+            memcpy((uint8_t*)&ipcFmanEvents, p_IpcMsg->msgBody, sizeof(t_FmIpcFmanEvents));
+            FmSetFmanCtrlIntr(h_Fm,
+                              ipcFmanEvents.eventRegId,
+                              ipcFmanEvents.enableEvents);
+            break;
+        }
+        case (FM_GET_FMAN_CTRL_EVENTS_ENABLE):
+        {
+            uint32_t    tmp = FmGetFmanCtrlIntr(h_Fm, p_IpcMsg->msgBody[0]);
+
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&tmp, sizeof(uint32_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
+            break;
+        }
+        case (FM_GET_PHYS_MURAM_BASE):
+        {
+            t_FmPhysAddr        physAddr;
+            t_FmIpcPhysAddr     ipcPhysAddr;
+
+            p_IpcReply->error = (uint32_t)FmGetPhysicalMuramBase(h_Fm, &physAddr);
+            ipcPhysAddr.high    = physAddr.high;
+            ipcPhysAddr.low     = physAddr.low;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcPhysAddr, sizeof(t_FmIpcPhysAddr));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcPhysAddr);
+            break;
+        }
+        case (FM_ENABLE_RAM_ECC):
+        {
+            t_Error 	err;
+
+            if (((err = FM_EnableRamsEcc(h_Fm)) != E_OK) ||
+				((err = FM_SetException(h_Fm, e_FM_EX_IRAM_ECC, TRUE)) != E_OK) ||
+        		((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, TRUE)) != E_OK))
+		        REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+        case (FM_DISABLE_RAM_ECC):
+        {
+        	t_Error 	err;
+
+        	if (((err = FM_SetException(h_Fm, e_FM_EX_IRAM_ECC, FALSE)) != E_OK) ||
+        		((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, FALSE)) != E_OK) ||
+        		((err = FM_DisableRamsEcc(h_Fm)) != E_OK))
+		        REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+        case (FM_SET_NUM_OF_FMAN_CTRL):
+        {
+            t_Error                     err;
+            t_FmIpcPortNumOfFmanCtrls   ipcPortNumOfFmanCtrls;
+
+            memcpy((uint8_t*)&ipcPortNumOfFmanCtrls, p_IpcMsg->msgBody, sizeof(t_FmIpcPortNumOfFmanCtrls));
+            if ((err = FmSetNumOfRiscsPerPort(h_Fm,
+                                              ipcPortNumOfFmanCtrls.hardwarePortId,
+                                              ipcPortNumOfFmanCtrls.numOfFmanCtrls)) != E_OK)
+		        REPORT_ERROR(MINOR, err, NO_MSG);
+            break;
+        }
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+        case (FM_10G_TX_ECC_WA):
+            p_IpcReply->error = (uint32_t)Fm10GTxEccWorkaround(h_Fm, p_IpcMsg->msgBody[0]);
+            *p_ReplyLength = sizeof(uint32_t);
+            break;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+        default:
+            *p_ReplyLength = 0;
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    int             timeout = 1000;
+    t_Error         err = E_OK;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_10G_TX_ECC_WA;
+        msg.msgBody[0] = macId;
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(macId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+
+    SANITY_CHECK_RETURN_ERROR((macId == 0), E_NOT_SUPPORTED);
+    SANITY_CHECK_RETURN_ERROR(IsFmanCtrlCodeLoaded(p_Fm), E_INVALID_STATE);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmextc, 0x40000000);
+    CORE_MemoryBarrier();
+    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fpmextc) & 0x40000000) &&
+           --timeout) ;
+    if (!timeout)
+        return ERROR_CODE(E_TIMEOUT);
+    return E_OK;
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+uintptr_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+
+    return (p_Fm->baseAddr + FM_MM_PRS);
+}
+
+uintptr_t FmGetPcdKgBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+
+    return (p_Fm->baseAddr + FM_MM_KG);
+}
+
+uintptr_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+
+    return (p_Fm->baseAddr + FM_MM_PLCR);
+}
+
+t_Handle FmGetMuramHandle(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, NULL);
+
+    return (p_Fm->h_FmMuram);
+}
+
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_Error         err;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength;
+    t_FmIpcPhysAddr ipcPhysAddr;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_PHYS_MURAM_BASE;
+        replyLength = sizeof(uint32_t) + sizeof(t_FmPhysAddr);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmPhysAddr)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&ipcPhysAddr, reply.replyBody, sizeof(t_FmIpcPhysAddr));
+        p_FmPhysAddr->high = ipcPhysAddr.high;
+        p_FmPhysAddr->low  = ipcPhysAddr.low;
+        return (t_Error)(reply.error);
+    }
+
+    /* General FM driver initialization */
+    p_FmPhysAddr->low = (uint32_t)p_Fm->fmMuramPhysBaseAddr;
+    p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
+
+    return E_OK;
+}
+
+t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint8_t         i;
+    t_Error         err;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_ALLOC_FMAN_CTRL_EVENT_REG;
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        *p_EventId = *(uint8_t*)(reply.replyBody);
+
+        return (t_Error)(reply.error);
+    }
+
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        if (!p_Fm->usedEventRegs[i])
+        {
+            p_Fm->usedEventRegs[i] = TRUE;
+            *p_EventId = i;
+            break;
+        }
+
+    if (i==FM_NUM_OF_FMAN_CTRL_EVENT_REGS)
+        RETURN_ERROR(MAJOR, E_BUSY, ("No resource - Fman controller event register."));
+
+    return E_OK;
+}
+
+void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    t_Error     err;
+    t_FmIpcMsg  msg;
+
+    if(((t_Fm *)h_Fm)->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_FREE_FMAN_CTRL_EVENT_REG;
+        msg.msgBody[0] = eventId;
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(eventId),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+        return;
+    }
+
+    ((t_Fm*)h_Fm)->usedEventRegs[eventId] = FALSE;
+}
+
+void FmRegisterIntr(t_Handle h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType,
+                        void (*f_Isr) (t_Handle h_Arg),
+                        t_Handle    h_Arg)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint8_t             event= 0;
+    t_FmIpcRegisterIntr fmIpcRegisterIntr;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+
+    ASSERT_COND(h_Fm);
+
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+
+    /* register in local FM structure */
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    p_Fm->intrMng[event].f_Isr = f_Isr;
+    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        if(p_Fm->h_IpcSessions[0])
+        {
+            /* register in Master FM structure */
+            fmIpcRegisterIntr.event = event;
+            fmIpcRegisterIntr.guestId = p_Fm->guestId;
+            memset(&msg, 0, sizeof(msg));
+            msg.msgId = FM_REGISTER_INTR;
+            memcpy(msg.msgBody, &fmIpcRegisterIntr, sizeof(fmIpcRegisterIntr));
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                         (uint8_t*)&msg,
+                                         sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
+                                         NULL,
+                                         NULL,
+                                         NULL,
+                                         NULL)) != E_OK)
+                REPORT_ERROR(MINOR, err, NO_MSG);
+        }
+        else
+            DBG(WARNING,("'Register interrupt' - unavailable - No IPC"));
+    }
+
+}
+
+void FmUnregisterIntr(t_Handle h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+    uint8_t     event= 0;
+
+    ASSERT_COND(h_Fm);
+
+    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
+    p_Fm->intrMng[event].h_SrcHandle = NULL;
+}
+
+void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvents)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    t_FmIpcFmanEvents   fmanCtrl;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        fmanCtrl.eventRegId = eventRegId;
+        fmanCtrl.enableEvents = enableEvents;
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_SET_FMAN_CTRL_EVENTS_ENABLE;
+        memcpy(msg.msgBody, &fmanCtrl, sizeof(fmanCtrl));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(fmanCtrl),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+        return;
+    }
+
+    ASSERT_COND(eventRegId < FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId], enableEvents);
+}
+
+uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_Error         err;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength, ctrlIntr;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_FMAN_CTRL_EVENTS_ENABLE;
+        msg.msgBody[0] = eventRegId;
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(eventRegId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&ctrlIntr, reply.replyBody, sizeof(uint32_t));
+        return ctrlIntr;
+    }
+
+    return GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[eventRegId]);
+}
+
+void  FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Arg, uint32_t event), t_Handle    h_Arg)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        ASSERT_COND(0);
+        /* TODO */
+    }
+
+    p_Fm->fmanCtrlIntr[eventRegId].f_Isr = f_Isr;
+    p_Fm->fmanCtrlIntr[eventRegId].h_SrcHandle = h_Arg;
+}
+
+void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        ASSERT_COND(0);
+        /* TODO */
+    }
+
+    p_Fm->fmanCtrlIntr[eventRegId].f_Isr = UnimplementedFmanCtrlIsr;
+    p_Fm->fmanCtrlIntr[eventRegId].h_SrcHandle = NULL;
+}
+
+void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
+
+    p_Fm->h_Pcd = h_FmPcd;
+
+}
+
+void  FmUnregisterPcd(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(!p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("No PCD"));
+
+    p_Fm->h_Pcd = NULL;
+
+}
+
+t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->h_Pcd;
+}
+
+uint8_t FmGetId(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0xff);
+
+    return p_Fm->p_FmStateStruct->fmId;
+}
+
+t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls)
+{
+
+    t_Fm                        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                    tmpReg = 0;
+    t_Error                     err;
+    t_FmIpcPortNumOfFmanCtrls   params;
+    t_FmIpcMsg                  msg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        params.hardwarePortId = hardwarePortId;
+        params.numOfFmanCtrls = numOfFmanCtrls;
+        msg.msgId = FM_SET_NUM_OF_FMAN_CTRL;
+        memcpy(msg.msgBody, &params, sizeof(params));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(params),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        return E_OK;
+    }
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+
+    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
+
+    /*TODO - maybe to put CTL# according to another criteria*/
+
+    if(numOfFmanCtrls == 2)
+        tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
+
+    /* order restoration */
+    if(hardwarePortId%2)
+        tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL1;
+    else
+        tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL2;
+
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    return E_OK;
+}
+
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                tmpReg;
+    uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
+    t_FmIpcPortInInitParams portInParams;
+    t_FmIpcPhysAddr         ipcPhysAddr;
+    t_Error                 err;
+    t_FmIpcMsg              msg;
+    t_FmIpcReply            reply;
+    uint32_t                replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        portInParams.hardwarePortId = p_PortParams->hardwarePortId;
+        portInParams.enumPortType = (uint32_t)p_PortParams->portType;
+        portInParams.boolIndependentMode = (uint8_t)p_PortParams->independentMode;
+        portInParams.liodnOffset = p_PortParams->liodnOffset;
+        portInParams.numOfTasks = p_PortParams->numOfTasks;
+        portInParams.numOfExtraTasks = p_PortParams->numOfExtraTasks;
+        portInParams.numOfOpenDmas = p_PortParams->numOfOpenDmas;
+        portInParams.numOfExtraOpenDmas = p_PortParams->numOfExtraOpenDmas;
+        portInParams.sizeOfFifo = p_PortParams->sizeOfFifo;
+        portInParams.extraSizeOfFifo = p_PortParams->extraSizeOfFifo;
+        portInParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
+        portInParams.liodnBase = p_PortParams->liodnBase;
+#ifdef FM_RMU_ASSIST_SUPPORT
+        portInParams.boolIsRmuDoorbell = p_PortParams->isRmuDoorbell;
+        portInParams.boolIsRmuMailbox0 = p_PortParams->isRmuMailbox0;
+        portInParams.boolIsRmuMailbox1 = p_PortParams->isRmuMailbox1;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_SET_PORT_PARAMS;
+        memcpy(msg.msgBody, &portInParams, sizeof(portInParams));
+        replyLength = (sizeof(uint32_t) + sizeof(p_PortParams->fmMuramPhysBaseAddr));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(portInParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(p_PortParams->fmMuramPhysBaseAddr)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&ipcPhysAddr, reply.replyBody, sizeof(t_FmIpcPhysAddr));
+        p_PortParams->fmMuramPhysBaseAddr.high = ipcPhysAddr.high;
+        p_PortParams->fmMuramPhysBaseAddr.low  = ipcPhysAddr.low;
+
+        return (t_Error)(reply.error);
+    }
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+
+    if(p_PortParams->independentMode)
+    {
+        /* set port parameters */
+        p_Fm->independentMode = p_PortParams->independentMode;
+        /* disable dispatch limit */
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, 0);
+    }
+#ifdef FM_RMU_ASSIST_SUPPORT
+    if(p_PortParams->isRmuDoorbell)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte, GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte) | FPM_EXTE_RMU_DRBL_INTR);
+    if(p_PortParams->isRmuMailbox0)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte, GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte) | FPM_EXTE_RMU_MAILBOX0_INTR);
+    if(p_PortParams->isRmuMailbox1)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte, GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_exte) | FPM_EXTE_RMU_MAILBOX1_INTR);
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    {
+        if(p_Fm->hcPortInitialized)
+        {
+            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
+        }
+        else
+            p_Fm->hcPortInitialized = TRUE;
+    }
+    p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
+
+    err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
+    if(err)
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        uint8_t     enqTh;
+        uint8_t     deqTh;
+        bool        update = FALSE;
+
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums += p_PortParams->deqPipelineDepth;
+        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
+        enqTh = (uint8_t)(tmpReg>>8);
+        /* if enqTh is too big, we reduce it to the max value that is still OK */
+        if(enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums))
+        {
+            enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums - 1);
+            tmpReg &= ~QMI_CFG_ENQ_MASK;
+            tmpReg |= ((uint32_t)enqTh << 8);
+            update = TRUE;
+        }
+
+        deqTh = (uint8_t)tmpReg;
+        /* if deqTh is too small, we enlarge it to the min value that is still OK.
+         deqTh may not be larger than 63 (QMI_MAX_NUM_OF_TNUMS-1). */
+        if((deqTh <= p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
+        {
+            deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
+            tmpReg &= ~QMI_CFG_DEQ_MASK;
+            tmpReg |= (uint32_t)deqTh;
+            update = TRUE;
+        }
+        if(update)
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+#ifdef FM_LOW_END_RESTRICTION
+    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+    {
+        if(p_Fm->p_FmStateStruct->lowEndRestriction)
+        {
+            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
+        }
+        else
+            p_Fm->p_FmStateStruct->lowEndRestriction = TRUE;
+    }
+#endif /* FM_LOW_END_RESTRICTION */
+
+    err = FmSetSizeOfFifo(p_Fm,
+                            p_PortParams->hardwarePortId,
+                            p_PortParams->portType,
+                            p_PortParams->independentMode,
+                            &p_PortParams->sizeOfFifo,
+                            p_PortParams->extraSizeOfFifo,
+                            p_PortParams->deqPipelineDepth,
+                            NULL,
+                            TRUE);
+    if(err)
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = FmSetNumOfOpenDmas(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfOpenDmas, p_PortParams->numOfExtraOpenDmas, TRUE);
+    if(err)
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], (uint32_t)p_PortParams->liodnOffset);
+
+    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
+    if(p_PortParams->independentMode)
+    {
+        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
+    }
+    else
+    {
+        tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
+
+        /* order restoration */
+        if(hardwarePortId%2)
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    {
+#ifdef FM_PARTITION_ARRAY
+        t_FmRevisionInfo revInfo;
+
+        FM_GetRevision(p_Fm, &revInfo);
+        if (revInfo.majorRev >= 2)
+#endif /* FM_PARTITION_ARRAY */
+        {
+            /* set LIODN base for this port */
+            tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
+            if(hardwarePortId%2)
+            {
+                tmpReg &= ~FM_LIODN_BASE_MASK;
+                tmpReg |= (uint32_t)p_PortParams->liodnBase;
+            }
+            else
+            {
+                tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
+                tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
+            }
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+        }
+    }
+
+    FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    return E_OK;
+}
+
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                tmpReg;
+    uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t                 numOfTasks;
+    t_Error                 err;
+    t_FmIpcPortFreeParams   portParams;
+    t_FmIpcMsg              msg;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        portParams.hardwarePortId = p_PortParams->hardwarePortId;
+        portParams.enumPortType = (uint32_t)p_PortParams->portType;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+        portParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_FREE_PORT;
+        memcpy(msg.msgBody, &portParams, sizeof(portParams));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(portParams),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+        return;
+    }
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    {
+        ASSERT_COND(p_Fm->hcPortInitialized);
+        p_Fm->hcPortInitialized = FALSE;
+    }
+
+    p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = e_FM_PORT_TYPE_DUMMY;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+    /* free numOfTasks */
+    numOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= numOfTasks);
+    p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= numOfTasks;
+
+    /* free numOfOpenDmas */
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+    p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= (((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+
+    /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+    tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+
+    /* free sizeOfFifo */
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >=
+                (((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS));
+    p_Fm->p_FmStateStruct->accumulatedFifoSize -=
+        (((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
+
+    /* clear registers */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], 0);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
+    //WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0);
+
+#ifdef FM_PORT_DISABLED_ERRATA_FMANx9
+    /* this errata means that when a port is taken down, other port may not use its
+     * resources for a while as it may still be using it (in case of reject).
+     */
+        {
+            t_FmRevisionInfo revInfo;
+            FM_GetRevision(p_Fm, &revInfo);
+            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                XX_UDelay(100000);
+        }
+#endif /* FM_PORT_DISABLED_ERRATA_FMANx9 */
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        uint8_t     enqTh;
+        uint8_t     deqTh;
+
+        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
+
+        /* p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums is now smaller,
+           so we can enlarge enqTh */
+        enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums - 1);
+        tmpReg &= ~QMI_CFG_ENQ_MASK;
+        tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
+
+         /* p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums is now smaller,
+           so we can reduce deqTh */
+        deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
+        tmpReg &= ~QMI_CFG_DEQ_MASK;
+        tmpReg |= (uint32_t)deqTh;
+
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+#ifdef FM_LOW_END_RESTRICTION
+    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+        p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
+#endif /* FM_LOW_END_RESTRICTION */
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+}
+
+t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+    t_Error         err;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_IS_PORT_STALLED;
+        msg.msgBody[0] = hardwarePortId;
+        replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(hardwarePortId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        *p_IsStalled = (bool)!!(*(uint8_t*)(reply.replyBody));
+
+        return (t_Error)(reply.error);
+    }
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
+    *p_IsStalled = (bool)!!(tmpReg & FPM_PS_STALLED);
+
+    return E_OK;
+}
+
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+    t_Error         err;
+    bool            isStalled;
+    t_FmIpcMsg      msg;
+    t_FmIpcReply    reply;
+    uint32_t        replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_RESUME_STALLED_PORT;
+        msg.msgBody[0] = hardwarePortId;
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(hardwarePortId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+        	RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+
+    /* Get port status */
+    err = FmIsPortStalled(h_Fm, hardwarePortId, &isStalled);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't get port status"));
+    if (!isStalled)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is not stalled"));
+
+    tmpReg = (uint32_t)((hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT) | FPM_PRC_REALSE_STALLED);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint32_t            bitMask, timeout = 1000;
+    t_FmIpcMacParams    macParams;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+    t_FmIpcReply        reply;
+    uint32_t            replyLength;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        if(p_Fm->h_IpcSessions[0])
+        {
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            macParams.id = macId;
+            macParams.enumType = (uint32_t)type;
+            msg.msgId = FM_RESET_MAC;
+            memcpy(msg.msgBody,  &macParams, sizeof(macParams));
+            replyLength = sizeof(uint32_t);
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                         (uint8_t*)&msg,
+                                         sizeof(msg.msgId)+sizeof(macParams),
+                                         (uint8_t*)&reply,
+                                         &replyLength,
+                                         NULL,
+                                         NULL)) != E_OK)
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            if (replyLength != sizeof(uint32_t))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return (t_Error)(reply.error);
+        }
+        else
+            if(!p_Fm->p_FmFpmRegs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("No IPC and no registers address"));
+    }
+
+    /* Get the relevant bit mask */
+    if (type == e_FM_MAC_10G)
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_10G0_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+        }
+    }
+    else
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_1G0_RESET;
+                break;
+            case(1):
+                bitMask = FPM_RSTC_1G1_RESET;
+                break;
+            case(2):
+                bitMask = FPM_RSTC_1G2_RESET;
+                break;
+            case(3):
+                bitMask = FPM_RSTC_1G3_RESET;
+                break;
+            case(4):
+                bitMask = FPM_RSTC_1G4_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+        }
+    }
+
+    /* reset */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, bitMask);
+    while ((GET_UINT32(p_Fm->p_FmFpmRegs->fmrstc) & bitMask) &&
+           --timeout) ;
+    if (!timeout)
+        return ERROR_CODE(E_TIMEOUT);
+    return E_OK;
+}
+
+t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu)
+{
+    t_Fm                        *p_Fm = (t_Fm*)h_Fm;
+    t_FmIpcMacMaxFrameParams    macMaxFrameLengthParams;
+    t_Error                     err;
+    t_FmIpcMsg                  msg;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        macMaxFrameLengthParams.macParams.id = macId;
+        macMaxFrameLengthParams.macParams.enumType = (uint32_t)type;
+        macMaxFrameLengthParams.maxFrameLength = (uint16_t)mtu;
+        msg.msgId = FM_SET_MAC_MAX_FRAME;
+        memcpy(msg.msgBody,  &macMaxFrameLengthParams, sizeof(macMaxFrameLengthParams));
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId)+sizeof(macMaxFrameLengthParams),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
+    }
+
+#if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
+    if (type == e_FM_MAC_10G)
+        p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId] = mtu;
+    else
+#else
+    UNUSED(type);
+#endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+        p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId] = mtu;
+
+    return E_OK;
+}
+
+uint16_t FmGetClockFreq(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    /* for MC environment: this depends on the
+     * fact that fmClkFreq was properly initialized at "init". */
+    return p_Fm->p_FmStateStruct->fmClkFreq;
+}
+
+uint32_t FmGetTimeStampScale(t_Handle h_Fm)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+    t_FmIpcReply        reply;
+    uint32_t            replyLength, timeStamp;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_TIMESTAMP_SCALE;
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        memcpy((uint8_t*)&timeStamp, reply.replyBody, sizeof(uint32_t));
+        return timeStamp;
+    }
+
+    if(!p_Fm->p_FmStateStruct->enabledTimeStamp)
+        FmEnableTimeStamp(p_Fm);
+
+    return p_Fm->p_FmStateStruct->count1MicroBit;
+}
+
+bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+t_Error FmEnableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    p_Fm->p_FmStateStruct->ramsEccOwners++;
+    p_Fm->p_FmStateStruct->internalCall = TRUE;
+
+    return FM_EnableRamsEcc(p_Fm);
+}
+
+t_Error FmDisableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    ASSERT_COND(p_Fm->p_FmStateStruct->ramsEccOwners);
+    p_Fm->p_FmStateStruct->ramsEccOwners--;
+
+    if(p_Fm->p_FmStateStruct->ramsEccOwners==0)
+    {
+        p_Fm->p_FmStateStruct->internalCall = TRUE;
+        return FM_DisableRamsEcc(p_Fm);
+    }
+    return E_OK;
+}
+
+uint8_t FmGetGuestId(t_Handle h_Fm)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->guestId;
+}
+
+bool FmIsMaster(t_Handle h_Fm)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    return (p_Fm->guestId == NCSW_MASTER_ID);
+}
+
+t_Error FmSetSizeOfFifo(t_Handle                            h_Fm,
+                        uint8_t                             hardwarePortId,
+                        e_FmPortType                        portType,
+                        bool                                independentMode,
+                        uint32_t                            *p_SizeOfFifo,
+                        uint32_t                            extraSizeOfFifo,
+                        uint8_t                             deqPipelineDepth,
+                        t_FmInterModulePortRxPoolsParams    *p_RxPoolsParams,
+                        bool                                initialConfig)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint8_t                 relativePortId;
+    uint16_t                macMaxFrameLength = 0, oldVal;
+    uint32_t                minFifoSizeRequired = 0, sizeOfFifo, tmpReg = 0;
+    t_FmIpcPortFifoParams   fifoParams;
+    t_Error                 err;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        memset(&fifoParams, 0, sizeof(fifoParams));
+        fifoParams.rsrcParams.hardwarePortId = hardwarePortId;
+        fifoParams.rsrcParams.val = *p_SizeOfFifo;
+        fifoParams.rsrcParams.extra = extraSizeOfFifo;
+        fifoParams.enumPortType = (uint32_t)portType;
+        fifoParams.boolIndependentMode = (uint8_t)independentMode;
+        fifoParams.deqPipelineDepth = deqPipelineDepth;
+        fifoParams.numOfPools = p_RxPoolsParams->numOfPools;
+        fifoParams.secondLargestBufSize = p_RxPoolsParams->secondLargestBufSize;
+        fifoParams.largestBufSize = p_RxPoolsParams->largestBufSize;
+        fifoParams.boolInitialConfig = (uint8_t)initialConfig;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_SIZE_OF_FIFO;
+        memcpy(msg.msgBody, &fifoParams, sizeof(fifoParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(fifoParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)p_SizeOfFifo, reply.replyBody, sizeof(uint32_t));
+
+        return (t_Error)(reply.error);
+    }
+    sizeOfFifo = *p_SizeOfFifo;
+    /* if neseccary (cases where frame length is relevant), update sizeOfFifo field. */
+    if((portType == e_FM_PORT_TYPE_TX) || ((portType == e_FM_PORT_TYPE_RX) && independentMode))
+    {
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
+        macMaxFrameLength = p_Fm->p_FmStateStruct->macMaxFrameLengths1G[relativePortId];
+    }
+
+#if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
+    if((portType == e_FM_PORT_TYPE_TX_10G) || ((portType == e_FM_PORT_TYPE_RX_10G)  && independentMode))
+    {
+        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
+        macMaxFrameLength = p_Fm->p_FmStateStruct->macMaxFrameLengths10G[relativePortId];
+    }
+#endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
+
+    if (!p_Fm->h_IpcSessions[0])
+        /* dont check MAC */;
+
+    /*************************/
+    /*    TX PORTS           */
+    /*************************/
+    if((portType == e_FM_PORT_TYPE_TX) || (portType == e_FM_PORT_TYPE_TX_10G))
+    {
+        if(independentMode)
+            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
+                                (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                macMaxFrameLength) +
+                                (3*BMI_FIFO_UNITS));
+        else
+            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
+                                   (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                   macMaxFrameLength) +
+                                   (deqPipelineDepth+3)*BMI_FIFO_UNITS);
+    }
+    else
+        if(((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G)) && independentMode)
+            /*************************/
+            /*    RX IM PORTS        */
+            /*************************/
+            minFifoSizeRequired = (uint32_t)(((macMaxFrameLength % BMI_FIFO_UNITS) ?
+                                             ((macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                             macMaxFrameLength) +
+                                             (4*BMI_FIFO_UNITS));
+
+    /* for Rx (non-Im) ports or OP, buffer pools are relevant for fifo size.
+       If this routine is called as part of the "GetSet" routine, initialConfig is TRUE
+       and these checks where done in the port routine.
+       If it is called by an explicit user request ("SetSizeOfFifo"), than these parameters
+       should be checked/updated */
+    if(!initialConfig &&
+      ((portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+      (((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G)) && !independentMode)))
+    {
+        if((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G))
+        {
+            /*************************/
+            /*    RX non-IM PORTS    */
+            /*************************/
+#ifdef FM_FIFO_ALLOCATION_OLD_ALG
+            t_FmRevisionInfo revInfo;
+
+            FM_GetRevision(p_Fm, &revInfo);
+            if(revInfo.majorRev < 4)
+                minFifoSizeRequired = (uint32_t)(((p_RxPoolsParams->largestBufSize % BMI_FIFO_UNITS) ?
+                                        ((p_RxPoolsParams->largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                        p_RxPoolsParams->largestBufSize) +
+                                        (7*BMI_FIFO_UNITS));
+            else
+#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
+            {
+                if(p_RxPoolsParams->numOfPools == 1)
+                    minFifoSizeRequired = 8*BMI_FIFO_UNITS;
+                else
+                {
+                    minFifoSizeRequired = (uint32_t)(((p_RxPoolsParams->secondLargestBufSize % BMI_FIFO_UNITS) ?
+                                        ((p_RxPoolsParams->secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                        p_RxPoolsParams->secondLargestBufSize) +
+                                        (7*BMI_FIFO_UNITS));
+                    if((sizeOfFifo < minFifoSizeRequired))
+                    {
+                        DBG(WARNING, ("User set FIFO size for Rx port is not optimized. (not modified by driver)"));
+                        minFifoSizeRequired = 8*BMI_FIFO_UNITS;
+                    }
+                }
+            }
+        }
+        else
+        {
+            /*************************/
+            /*    OP PORTS           */
+            /*************************/
+            /* check if pool size is not too big */
+            if(p_RxPoolsParams->largestBufSize > sizeOfFifo )
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Largest pool size is bigger than ports commited fifo size"));
+        }
+    }
+
+
+    if (minFifoSizeRequired && (sizeOfFifo < minFifoSizeRequired))
+    {
+        sizeOfFifo = minFifoSizeRequired;
+        DBG(INFO, ("FIFO size enlarged to %d for port %#x", minFifoSizeRequired, hardwarePortId));
+    }
+
+    if(initialConfig)
+        oldVal = 0;
+    else
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+        /* read into oldVal the current extra fifo size */
+        oldVal = (uint16_t)((((tmpReg & BMI_EXTRA_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS) >> BMI_EXTRA_FIFO_SIZE_SHIFT);
+    }
+
+    if(extraSizeOfFifo > oldVal)
+        p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
+
+    if(!initialConfig)
+        /* read into oldVal the current num of tasks */
+        oldVal = (uint16_t)(((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS);
+
+    /* check that there are enough uncommitted fifo size */
+    if((p_Fm->p_FmStateStruct->accumulatedFifoSize - oldVal + sizeOfFifo) >
+       (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
+    else
+    {
+        /* update acummulated */
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= oldVal);
+        p_Fm->p_FmStateStruct->accumulatedFifoSize -= oldVal;
+        p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
+        /* calculate reg */
+        tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
+                            ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+    }
+    *p_SizeOfFifo = sizeOfFifo;
+
+    return E_OK;
+}
+
+t_Error FmSetNumOfTasks(t_Handle    h_Fm,
+                        uint8_t     hardwarePortId,
+                        uint8_t     numOfTasks,
+                        uint8_t     numOfExtraTasks,
+                        bool        initialConfig)
+{
+    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
+    uint8_t                 oldVal;
+    uint32_t                tmpReg = 0;
+    t_FmIpcPortRsrcParams   rsrcParams;
+    t_Error                 err;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = numOfTasks;
+        rsrcParams.extra = numOfExtraTasks;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_NUM_OF_TASKS;
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+        	RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+
+    if(initialConfig)
+        oldVal = 0;
+    else
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+        /* read into oldVal the current extra tasks */
+        oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_TASKS_MASK) >> BMI_EXTRA_NUM_OF_TASKS_SHIFT);
+    }
+
+    if(numOfExtraTasks > oldVal)
+        p_Fm->p_FmStateStruct->extraTasksPoolSize = (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+
+    if(!initialConfig)
+        /* read into oldVal the current num of tasks */
+        oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+
+    /* check that there are enough uncommitted tasks */
+    if((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - oldVal + numOfTasks) >
+       (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfTasks and extra tasks pool exceed total numOfTasks."));
+    else
+    {
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= oldVal);
+        /* update acummulated */
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= oldVal;
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
+        /* calculate reg */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
+        tmpReg |= (uint32_t)(((numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                    (numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+    }
+
+    return E_OK;
+}
+
+t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
+                            uint8_t hardwarePortId,
+                            uint8_t numOfOpenDmas,
+                            uint8_t numOfExtraOpenDmas,
+                            bool    initialConfig)
+
+{
+    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
+    uint8_t                 oldVal;
+    uint32_t                tmpReg = 0;
+    t_FmIpcPortRsrcParams   rsrcParams;
+    t_Error                 err;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = numOfOpenDmas;
+        rsrcParams.extra = numOfExtraOpenDmas;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_SET_NUM_OF_OPEN_DMAS;
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+        	RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        return (t_Error)(reply.error);
+    }
+
+    if(initialConfig)
+        oldVal = 0;
+    else
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+        /* read into oldVal the current extra tasks */
+        oldVal = (uint8_t)((tmpReg & BMI_NUM_OF_EXTRA_DMAS_MASK) >> BMI_EXTRA_NUM_OF_DMAS_SHIFT);
+    }
+
+    if(numOfExtraOpenDmas > oldVal)
+        p_Fm->p_FmStateStruct->extraOpenDmasPoolSize = (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
+
+    if(!initialConfig)
+        /* read into oldVal the current num of tasks */
+        oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+
+    /* check that there are enough uncommited open DMA's */
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= oldVal);
+    if((p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas) >
+       p_Fm->p_FmStateStruct->maxNumOfOpenDmas)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfOpenDmas."));
+    else
+    {
+        /* update acummulated */
+        p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= oldVal;
+        p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += numOfOpenDmas;
+        /* calculate reg */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
+        tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                    (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
+
+        /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+        tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+    }
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+{
+    t_Fm        	*p_Fm = (t_Fm *)h_Fm;
+    t_FmIpcMsg  	msg;
+    t_Error			err;
+
+    DECLARE_DUMP;
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_DUMP_PORT_REGS;
+        msg.msgBody[0] = hardwarePortId;
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                    (uint8_t*)&msg,
+                                    sizeof(msg.msgId)+sizeof(hardwarePortId),
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    NULL)) != E_OK)
+        	RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
+    }
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], ("fmbm_pp for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %u", (hardwarePortId )));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], ("bm_ppid for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], sizeof(uint32_t));
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+
+/*****************************************************************************/
+/*                      API Init unit functions                              */
+/*****************************************************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm        *p_Fm;
+    uint8_t     i;
+    uintptr_t	baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
+    SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
+                               (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
+                              E_INVALID_VALUE, NULL);
+
+    baseAddr = p_FmParam->baseAddr;
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    p_Fm->p_FmStateStruct = (t_FmStateStruct *) XX_Malloc(sizeof(t_FmStateStruct));
+    if (!p_Fm->p_FmStateStruct)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Status structure"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmStateStruct, 0, sizeof(t_FmStateStruct));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->p_FmStateStruct->fmId = p_FmParam->fmId;
+    p_Fm->guestId               = p_FmParam->guestId;
+
+    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
+        p_Fm->p_FmStateStruct->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+
+    /* Allocate the FM driver's parameters structure */
+    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
+    if (!p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm->p_FmStateStruct);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->p_FmStateStruct->fmId              = p_FmParam->fmId;
+    p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
+    p_Fm->h_App             = p_FmParam->h_App;
+    p_Fm->p_FmStateStruct->fmClkFreq         = p_FmParam->fmClkFreq;
+    p_Fm->f_Exception       = p_FmParam->f_Exception;
+    p_Fm->f_BusError        = p_FmParam->f_BusError;
+    p_Fm->p_FmFpmRegs       = (t_FmFpmRegs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
+    p_Fm->p_FmBmiRegs       = (t_FmBmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
+    p_Fm->p_FmQmiRegs       = (t_FmQmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
+    p_Fm->p_FmDmaRegs       = (t_FmDmaRegs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
+    p_Fm->baseAddr          = baseAddr;
+    p_Fm->p_FmStateStruct->irq               = p_FmParam->irq;
+    p_Fm->p_FmStateStruct->errIrq            = p_FmParam->errIrq;
+    p_Fm->hcPortInitialized = FALSE;
+    p_Fm->independentMode   = FALSE;
+    p_Fm->p_FmStateStruct->ramsEccEnable     = FALSE;
+    p_Fm->p_FmStateStruct->totalNumOfTasks   = DEFAULT_totalNumOfTasks;
+    p_Fm->p_FmStateStruct->totalFifoSize     = DEFAULT_totalFifoSize;
+    p_Fm->p_FmStateStruct->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
+    p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+    p_Fm->p_FmStateStruct->exceptions        = DEFAULT_exceptions;
+    for(i = 0;i<FM_MAX_NUM_OF_1G_MACS;i++)
+        p_Fm->p_FmStateStruct->macMaxFrameLengths1G[i] = DEFAULT_mtu;
+#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    for(i = 0;i<FM_MAX_NUM_OF_10G_MACS;i++)
+        p_Fm->p_FmStateStruct->macMaxFrameLengths10G[i] = DEFAULT_mtu;
+#endif /*defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)*/
+
+    p_Fm->h_Spinlock = XX_InitSpinlock();
+    if (!p_Fm->h_Spinlock)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm->p_FmStateStruct);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("cant allocate spinlock!"));
+        return NULL;
+    }
+
+#ifdef FM_PARTITION_ARRAY
+    /* Initialize FM driver parameters parameters (for initialization phase only) */
+    memcpy(p_Fm->p_FmDriverParam->liodnBasePerPort, p_FmParam->liodnBasePerPort, FM_SIZE_OF_LIODN_TABLE*sizeof(uint16_t));
+#endif /* FM_PARTITION_ARRAY */
+
+    /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
+    p_Fm->p_FmDriverParam->enCounters                           = FALSE;
+
+    p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
+
+    p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
+    p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
+    p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
+    p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
+    p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
+    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
+    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
+    p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
+
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaSosEmergency                          = DEFAULT_dmaSosEmergency;
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
+    p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
+    p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
+    p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError          = DEFAULT_haltOnUnrecoverableEccError;
+    p_Fm->p_FmDriverParam->enIramTestMode                       = FALSE;
+    p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
+    p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
+
+    p_Fm->p_FmDriverParam->fwVerify                             = DEFAULT_VerifyUcode;
+    p_Fm->p_FmDriverParam->firmware.size                        = p_FmParam->firmware.size;
+    if (p_Fm->p_FmDriverParam->firmware.size)
+    {
+        p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+        if (!p_Fm->p_FmDriverParam->firmware.p_Code)
+        {
+            XX_Free(p_Fm->p_FmDriverParam);
+            XX_Free(p_Fm->p_FmStateStruct);
+            XX_Free(p_Fm);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
+            return NULL;
+        }
+        memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code, p_Fm->p_FmDriverParam->firmware.size);
+    }
+    else
+    {
+        /* Read the Microcode from the IRAM and reuse it later */
+        p_Fm->p_FmDriverParam->firmware.size = FM_IRAM_SIZE;
+        p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+
+        if (!p_Fm->p_FmDriverParam->firmware.p_Code ||
+                ReadFmanCtrlCode(p_Fm, p_Fm->p_FmDriverParam->firmware.p_Code, FM_IRAM_SIZE) != E_OK)
+        {
+            if (!p_Fm->p_FmDriverParam->firmware.p_Code)
+                XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+            XX_Free(p_Fm->p_FmDriverParam);
+            XX_Free(p_Fm->p_FmStateStruct);
+            XX_Free(p_Fm);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
+            return NULL;
+        }
+    }
+
+    return p_Fm;
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_FmDriverParam         *p_FmDriverParam = NULL;
+    t_Error                 err = E_OK;
+    uint32_t                tmpReg, cfgReg = 0;
+    int                     i;
+    uint16_t                periodInFmClocks;
+    uint8_t                 remainder;
+    t_FmRevisionInfo        revInfo;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        uint8_t             isMasterAlive;
+        t_FmIpcMsg          msg;
+        t_FmIpcReply        reply;
+        uint32_t            replyLength;
+
+        /* build the FM guest partition IPC address */
+        if(Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, p_Fm->guestId) != (p_Fm->guestId<10 ? 6:7))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+        /* build the FM master partition IPC address */
+        memset(p_Fm->fmIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
+        if(Sprint (p_Fm->fmIpcHandlerModuleName[0], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+        for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+            p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+
+        p_Fm->h_IpcSessions[0] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[0], p_Fm->fmModuleName);
+        if (p_Fm->h_IpcSessions[0])
+        {
+            err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmGuestHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            msg.msgId = FM_MASTER_IS_ALIVE;
+            msg.msgBody[0] = p_Fm->guestId;
+            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            do
+            {
+                blockingFlag = TRUE;
+                if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                             (uint8_t*)&msg,
+                                             sizeof(msg.msgId)+sizeof(p_Fm->guestId),
+                                             (uint8_t*)&reply,
+                                             &replyLength,
+                                             IpcMsgCompletionCB,
+                                             h_Fm)) != E_OK)
+                    REPORT_ERROR(MINOR, err, NO_MSG);
+                while(blockingFlag) ;
+                if(replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+                    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+                isMasterAlive = *(uint8_t*)(reply.replyBody);
+            } while (!isMasterAlive);
+
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            msg.msgId = FM_GET_CLK_FREQ;
+            replyLength = sizeof(uint32_t) + sizeof(p_Fm->p_FmStateStruct->fmClkFreq);
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                         (uint8_t*)&msg,
+                                         sizeof(msg.msgId),
+                                         (uint8_t*)&reply,
+                                         &replyLength,
+                                         NULL,
+                                         NULL)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            if(replyLength != (sizeof(uint32_t) + sizeof(p_Fm->p_FmStateStruct->fmClkFreq)))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            memcpy((uint8_t*)&p_Fm->p_FmStateStruct->fmClkFreq, reply.replyBody, sizeof(uint16_t));
+        }
+        else
+        {
+            DBG(WARNING, ("FM Guest mode - without IPC"));
+            if(!p_Fm->p_FmStateStruct->fmClkFreq )
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No fmClkFreq configured for guest without IPC"));
+            if(!p_Fm->baseAddr)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
+        }
+
+        XX_Free(p_Fm->p_FmDriverParam);
+        p_Fm->p_FmDriverParam = NULL;
+
+        if ((p_Fm->guestId == NCSW_MASTER_ID) ||
+            (p_Fm->h_IpcSessions[0]))
+        {
+            FM_DisableRamsEcc(p_Fm);
+            FmMuramClear(p_Fm->h_FmMuram);
+            FM_EnableRamsEcc(p_Fm);
+        }
+
+        return E_OK;
+    }
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    FM_GetRevision(p_Fm, &revInfo);
+
+#ifdef FM_NO_DISPATCH_RAM_ECC
+    if (revInfo.majorRev < 4)
+        p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
+#endif /* FM_NO_DISPATCH_RAM_ECC */
+
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        p_Fm->p_FmStateStruct->exceptions  &= ~FM_EX_BMI_LIST_RAM_ECC;
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
+
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        p_Fm->p_FmStateStruct->exceptions  &= ~FM_EX_BMI_PIPELINE_ECC;
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
+
+#ifdef FM_QMI_NO_ECC_EXCEPTIONS
+    if (revInfo.majorRev == 4)
+        p_Fm->p_FmStateStruct->exceptions  &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
+#endif /* FM_QMI_NO_ECC_EXCEPTIONS */
+
+    CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
+
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
+
+    FmMuramClear(p_Fm->h_FmMuram);
+
+#ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+    if (p_FmDriverParam->resetOnInit)
+    {
+        t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+        uint32_t        debug_reg;
+
+        /* write to IRAM first location the debug instruction */
+        WRITE_UINT32(p_Iram->iadd, 0);
+        while (GET_UINT32(p_Iram->iadd) != 0) ;
+        WRITE_UINT32(p_Iram->idata, FM_UCODE_DEBUG_INSTRUCTION);
+
+        WRITE_UINT32(p_Iram->iadd, 0);
+        while (GET_UINT32(p_Iram->iadd) != 0) ;
+        while (GET_UINT32(p_Iram->idata) != FM_UCODE_DEBUG_INSTRUCTION) ;
+
+        /* Enable patch from IRAM */
+        WRITE_UINT32(p_Iram->iready, IRAM_READY);
+        XX_UDelay(100);
+
+        /* reset FMAN */
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        XX_UDelay(100);
+
+        /* verify breakpoint debug status register */
+        debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
+#ifndef NCSW_LINUX
+        if(!debug_reg)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
+#else
+        if(!debug_reg)
+            DBG(INFO,("Invalid debug status register value = 0"));
+#endif
+        /*************************************/
+        /* Load FMan-Controller code to Iram */
+        /*************************************/
+        if (ClearIRam(p_Fm) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+            (LoadFmanCtrlCode(p_Fm) != E_OK))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+         XX_UDelay(100);
+
+        /* reset FMAN again to start the microcode */
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        XX_UDelay(1000);
+    }
+    else
+    {
+#endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
+    if(p_FmDriverParam->resetOnInit)
+    {
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+        XX_UDelay(100);
+    }
+
+    /*************************************/
+    /* Load FMan-Controller code to Iram */
+    /*************************************/
+    if (ClearIRam(p_Fm) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+        (LoadFmanCtrlCode(p_Fm) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+#ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+    }
+#endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
+
+#ifdef FM_CAPWAP_SUPPORT
+    /* save first 256 byte in MURAM */
+    p_Fm->resAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram, 256, 0));
+    if (!p_Fm->resAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for reserved Area failed"));
+
+    WRITE_BLOCK(UINT_TO_PTR(p_Fm->resAddr), 0, 256);
+#endif /* FM_CAPWAP_SUPPORT */
+
+    /* General FM driver initialization */
+    p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
+    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+        p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        p_Fm->fmanCtrlIntr[i].f_Isr = UnimplementedFmanCtrlIsr;
+
+    /**********************/
+    /* Init DMA Registers */
+    /**********************/
+    /* clear status reg events */
+    tmpReg = (DMA_STATUS_BUS_ERR | DMA_STATUS_READ_ECC | DMA_STATUS_SYSTEM_WRITE_ECC | DMA_STATUS_FM_WRITE_ECC);
+    /*tmpReg |= (DMA_STATUS_SYSTEM_DPEXT_ECC | DMA_STATUS_FM_DPEXT_ECC | DMA_STATUS_SYSTEM_DPDAT_ECC | DMA_STATUS_FM_DPDAT_ECC | DMA_STATUS_FM_SPDAT_ECC);*/
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
+
+    /* configure mode register */
+    tmpReg = 0;
+    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
+    if(p_FmDriverParam->dmaAidOverride)
+        tmpReg |= DMA_MODE_AID_OR;
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
+        tmpReg |= DMA_MODE_BER;
+    if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+        tmpReg |= DMA_MODE_ECC;
+    if(p_FmDriverParam->dmaStopOnBusError)
+        tmpReg |= DMA_MODE_SBER;
+    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
+    if (p_FmDriverParam->dmaEnEmergency)
+    {
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
+        if(p_FmDriverParam->dmaEnEmergencySmoother)
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
+     }
+    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
+
+    tmpReg |= DMA_MODE_SECURE_PROT;
+    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
+
+#ifdef FM_PEDANTIC_DMA
+    tmpReg |= DMA_MODE_EMERGENCY_READ;
+#endif /* FM_PEDANTIC_DMA */
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+
+    /* configure thresholds register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
+
+    /* configure hysteresis register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
+
+    /* configure emergency threshold */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
+
+    /* configure Watchdog */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->p_FmStateStruct->fmClkFreq));
+
+    /* Allocate MURAM for CAM */
+    p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                      (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
+                                                      DMA_CAM_ALIGN));
+    if (!p_Fm->camBaseAddr )
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+    WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+
+    /* VirtToPhys */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
+                 (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
+
+#ifdef FM_PARTITION_ARRAY
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(p_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            /* liodn-partitions */
+            for (i=0 ; i<FM_SIZE_OF_LIODN_TABLE ; i+=2)
+            {
+                tmpReg = (((uint32_t)p_FmDriverParam->liodnBasePerPort[i] << DMA_LIODN_SHIFT) |
+                            (uint32_t)p_FmDriverParam->liodnBasePerPort[i+1]);
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
+            }
+    }
+#endif /* FM_PARTITION_ARRAY */
+
+    /**********************/
+    /* Init FPM Registers */
+    /**********************/
+    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis1, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis2, tmpReg);
+
+    /* define exceptions and error behavior */
+    tmpReg = 0;
+    /* Clear events */
+    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
+    /* enable interrupts */
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_STALL_ON_TASKS)
+        tmpReg |= FPM_EV_MASK_STALL_EN;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_SINGLE_ECC)
+        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_FPM_DOUBLE_ECC)
+        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
+    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
+    if(!p_Fm->p_FmDriverParam->haltOnExternalActivation)
+        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
+    if(!p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
+        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+
+    /* clear all fmCtls event registers */
+    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
+
+    /* RAM ECC -  enable and clear events*/
+    /* first we need to clear all parser memory, as it is uninitialized and
+    may cause ECC errors */
+    tmpReg = 0;
+    /* event bits */
+    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
+    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
+    if(p_Fm->p_FmDriverParam->externalEccRamsEnable)
+        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
+
+    /* enable test mode */
+    if(p_FmDriverParam->enMuramTestMode)
+        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
+    if(p_FmDriverParam->enIramTestMode)
+        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
+
+    tmpReg = 0;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_IRAM_ECC)
+    {
+        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_NURAM_ECC)
+    {
+        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+        FmEnableRamsEcc(p_Fm);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+
+    /* define common resources */
+    /* allocate MURAM for FIFO according to total size */
+    p_Fm->fifoBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                       p_Fm->p_FmStateStruct->totalFifoSize,
+                                                       BMI_FIFO_ALIGN));
+    if (!p_Fm->fifoBaseAddr)
+    {
+        FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
+    }
+
+    tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = tmpReg / BMI_FIFO_ALIGN;
+
+    tmpReg |= ((p_Fm->p_FmStateStruct->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
+
+    tmpReg =  ((uint32_t)(p_Fm->p_FmStateStruct->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT );
+    /* num of DMA's will be dynamically updated when each port is set */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+
+    /* define unmaskable exceptions, enable and clear events */
+    tmpReg = 0;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
+                                                BMI_ERR_INTR_EN_PIPELINE_ECC |
+                                                BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
+                                                BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_PIPELINE_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+     /* Clear error interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
+    tmpReg = 0;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
+        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
+        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+
+    if(p_Fm->p_FmDriverParam->tnumAgingPeriod)
+    {
+        /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
+        periodInFmClocks = (uint16_t)(p_Fm->p_FmDriverParam->tnumAgingPeriod*p_Fm->p_FmStateStruct->fmClkFreq);
+        /* periodInFmClocks must be a 64 multiply */
+        remainder = (uint8_t)(periodInFmClocks % 64);
+        if (remainder > 64)
+            tmpReg = (uint32_t)((periodInFmClocks/64) + 1);
+        else
+        {
+            tmpReg = (uint32_t)(periodInFmClocks/64);
+            if(!tmpReg)
+                tmpReg = 1;
+        }
+        tmpReg <<= QMI_TAPC_TAP;
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_tapc, tmpReg);
+
+    }
+    tmpReg = 0;
+    /* Clear interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
+        tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+
+    /* clear & enable global counters  - calculate reg and save for later,
+       because it's the same reg for QMI enable */
+    if(p_Fm->p_FmDriverParam->enCounters)
+        cfgReg = QMI_CFG_EN_COUNTERS;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+    if (p_Fm->p_FmStateStruct->irq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->p_FmStateStruct->irq, FM_EventIsr, p_Fm);
+        XX_EnableIntr(p_Fm->p_FmStateStruct->irq);
+    }
+
+    if (p_Fm->p_FmStateStruct->errIrq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->p_FmStateStruct->errIrq, FM_ErrorIsr, p_Fm);
+        XX_EnableIntr(p_Fm->p_FmStateStruct->errIrq);
+    }
+
+    /* build the FM master partition IPC address */
+    if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+
+    err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /**********************/
+    /* Enable all modules */
+    /**********************/
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, BMI_INIT_START);
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, cfgReg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN);
+
+    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+    {
+        XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+        p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
+    }
+
+    XX_Free(p_Fm->p_FmDriverParam);
+    p_Fm->p_FmDriverParam = NULL;
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
+
+        if(!p_Fm->recoveryMode)
+            XX_Free(p_Fm->p_FmStateStruct);
+
+        XX_Free(p_Fm);
+
+        return E_OK;
+    }
+
+    /* disable BMI and QMI */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, 0);
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, 0);
+
+    /* release BMI resources */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, 0);
+
+    /* disable ECC */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, 0);
+
+    if ((p_Fm->guestId == NCSW_MASTER_ID) &&
+        (p_Fm->fmModuleName[0] != 0))
+        XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
+
+    if (p_Fm->p_FmStateStruct->irq != NO_IRQ)
+    {
+        XX_DisableIntr(p_Fm->p_FmStateStruct->irq);
+        XX_FreeIntr(p_Fm->p_FmStateStruct->irq);
+    }
+
+    if (p_Fm->p_FmStateStruct->errIrq != NO_IRQ)
+    {
+        XX_DisableIntr(p_Fm->p_FmStateStruct->errIrq);
+        XX_FreeIntr(p_Fm->p_FmStateStruct->errIrq);
+    }
+
+    if (p_Fm->h_Spinlock)
+        XX_FreeSpinlock(p_Fm->h_Spinlock);
+
+    if(p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        p_Fm->p_FmDriverParam = NULL;
+    }
+
+    FreeInitResources(p_Fm);
+
+    if(!p_Fm->recoveryMode)
+        XX_FreeSmart(p_Fm->p_FmStateStruct);
+
+    XX_Free(p_Fm);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
+{
+
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->resetOnInit = enable;
+
+    return E_OK;
+}
+
+
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmStateStruct->totalNumOfTasks = totalNumOfTasks;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmStateStruct->totalFifoSize = totalFifoSize;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmStateStruct->maxNumOfOpenDmas = maxNumOfOpenDmas;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride = cacheOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidOverride = aidOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidMode = aidMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries = numOfEntries;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+#ifdef FM_NO_WATCHDOG
+    {
+        t_FmRevisionInfo    revInfo;
+        FM_GetRevision(h_Fm, &revInfo);
+        if (revInfo.majorRev < 4)
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("watchdog!"));
+    }
+#endif /* FM_NO_WATCHDOG */
+
+    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
+    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
+
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
+    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enCounters = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaErr = dmaErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->catastrophicErr = catastrophicErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+#ifdef FM_HALT_SIG_ERRATA_GEN12
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(h_Fm, &revInfo);
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnExternalActivation!"));
+    }
+#endif /* FM_HALT_SIG_ERRATA_GEN12 */
+
+    p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+#ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
+#endif /* FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
+
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint32_t            bitMask = 0;
+    t_FmRevisionInfo    revInfo;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    FM_GetRevision(p_Fm, &revInfo);
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+    if((exception == e_FM_EX_BMI_PIPELINE_ECC) && (enable))
+    {
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECC!"));
+            return E_OK;
+        }
+    }
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+    if((exception == e_FM_EX_BMI_LIST_RAM_ECC) && (enable))
+    {
+        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        {
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
+            return E_OK;
+        }
+    }
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
+#ifdef FM_QMI_NO_ECC_EXCEPTIONS
+    if(((exception == e_FM_EX_QMI_SINGLE_ECC) || (exception == e_FM_EX_QMI_DOUBLE_ECC)) &&
+            enable)
+    {
+        if (revInfo.majorRev == 4)
+        {
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("QMI ECC exception!"));
+            return E_OK;
+        }
+    }
+#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
+#ifdef FM_NO_DISPATCH_RAM_ECC
+    if((exception == e_FM_EX_BMI_DISPATCH_RAM_ECC) && (enable))
+    {
+        if (revInfo.majorRev < 4)
+        {
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
+            return E_OK;
+        }
+    }
+#endif   /* FM_NO_DISPATCH_RAM_ECC */
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->p_FmStateStruct->exceptions |= bitMask;
+        else
+            p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->externalEccRamsEnable = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+#ifdef FM_NO_TNUM_AGING
+    {
+        t_FmRevisionInfo revInfo;
+        FM_GetRevision(h_Fm, &revInfo);
+        if (revInfo.majorRev < 4)
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigTnumAgingPeriod!"));
+    }
+#endif /* FM_NO_TNUM_AGING */
+    p_Fm->p_FmDriverParam->tnumAgingPeriod = tnumAgingPeriod;
+
+    return E_OK;
+
+}
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!((t_Fm*)h_Fm)->p_FmDriverParam, E_INVALID_STATE, NULL);
+
+    return ((t_Fm*)h_Fm)->h_Pcd;
+}
+
+void FM_EventIsr(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending, event;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* normal interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
+    ASSERT_COND(pending);
+    if(pending & INTR_EN_BMI)
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
+    if(pending & INTR_EN_QMI)
+        QmiEvent(p_Fm);
+    if(pending & INTR_EN_PRS)
+        p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
+    if(pending & INTR_EN_PLCR)
+        p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
+    if(pending & INTR_EN_KG)
+        p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
+    if(pending & INTR_EN_TMR)
+            p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+
+    /* MAC events may belong to different partitions */
+    if(pending & INTR_EN_1G_MAC0_TMR)
+    {
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC0_TMR, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC1_TMR)
+    {
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC1_TMR, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC2_TMR)
+    {
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC2_TMR, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC3_TMR)
+    {
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC3_TMR, pending);
+        else
+           p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+    }
+    /* IM port events may belong to different partitions */
+    if(pending & INTR_EN_REV0)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[0]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[0]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[0], event);
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_0].guestId)
+            /*TODO IPC ISR For Fman Ctrl */
+            ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_0, pending);
+        else
+            p_Fm->fmanCtrlIntr[0].f_Isr(p_Fm->fmanCtrlIntr[0].h_SrcHandle, event);
+
+    }
+    if(pending & INTR_EN_REV1)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[1]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[1]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[1], event);
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_1].guestId)
+            /*TODO IPC ISR For Fman Ctrl */
+            ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_1, pending);
+        else
+            p_Fm->fmanCtrlIntr[1].f_Isr(p_Fm->fmanCtrlIntr[1].h_SrcHandle, event);
+
+    }
+    if(pending & INTR_EN_REV2)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[2]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[2]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[2], event);
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_2].guestId)
+            /*TODO IPC ISR For Fman Ctrl */
+            ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_2, pending);
+        else
+           p_Fm->fmanCtrlIntr[2].f_Isr(p_Fm->fmanCtrlIntr[2].h_SrcHandle, event);
+    }
+    if(pending & INTR_EN_REV3)
+    {
+        event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcev[3]) & GET_UINT32(p_Fm->p_FmFpmRegs->fmfpfcee[3]);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[3], event);
+        if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_FMAN_CTRL_3].guestId)
+            /*TODO IPC ISR For Fman Ctrl */
+            ASSERT_COND(0);
+            //SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_2, pendin3);
+        else
+            p_Fm->fmanCtrlIntr[3].f_Isr(p_Fm->fmanCtrlIntr[3].h_SrcHandle, event);
+    }
+}
+
+void FM_ErrorIsr(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* error interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmepi);
+    if (!pending)
+        return;
+
+    if(pending & ERR_INTR_EN_BMI)
+        BmiErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_QMI)
+        QmiErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_FPM)
+        FpmErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_DMA)
+        DmaErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_IRAM)
+        IramErrIntr(p_Fm);
+    if(pending & ERR_INTR_EN_MURAM)
+        MuramErrIntr(p_Fm);
+    if(pending & ERR_INTR_EN_PRS)
+        p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
+    if(pending & ERR_INTR_EN_PLCR)
+        p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
+    if(pending & ERR_INTR_EN_KG)
+        p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
+
+    /* MAC events may belong to different partitions */
+    if(pending & ERR_INTR_EN_1G_MAC0)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC0, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
+    }
+    if(pending & ERR_INTR_EN_1G_MAC1)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC1, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
+    }
+    if(pending & ERR_INTR_EN_1G_MAC2)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC2, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
+    }
+    if(pending & ERR_INTR_EN_1G_MAC3)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC3, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
+    }
+    if(pending & ERR_INTR_EN_10G_MAC0)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_10G_MAC0, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
+    }
+}
+
+void FM_GuestErrorIsr(t_Handle h_Fm, uint32_t pending)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* error interrupts */
+    if(pending & ERR_INTR_EN_1G_MAC0)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC1)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC2)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC3)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
+    if(pending & ERR_INTR_EN_10G_MAC0)
+        p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
+}
+
+void FM_GuestEventIsr(t_Handle h_Fm, uint32_t pending)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    if(pending & INTR_EN_1G_MAC0_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC1_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC2_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC3_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+    if(pending & INTR_EN_TMR)
+        p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+}
+
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    int         i;
+    uint8_t     sum;
+    uint8_t     hardwarePortId=0;
+    uint32_t    tmpRegs[8] = {0,0,0,0,0,0,0,0};
+    uint8_t     relativePortId, shift, weight, maxPercent = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* check that all ports add up to 100% */
+    sum = 0;
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+        sum +=p_PortsBandwidth->portsBandwidths[i].bandwidth;
+    if (sum != 100)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
+
+    /* find highest precent */
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    {
+        if (p_PortsBandwidth->portsBandwidths[i].bandwidth > maxPercent)
+            maxPercent = p_PortsBandwidth->portsBandwidths[i].bandwidth;
+    }
+
+    /* calculate weight for each port */
+    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    {
+        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT )/maxPercent);
+        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exect division
+           is not reached, we round up so that:
+           0 until maxPercent/PORT_MAX_WEIGHT get "1"
+           maxPercent/PORT_MAX_WEIGHT+1 until (maxPercent/PORT_MAX_WEIGHT)*2 get "2"
+           ...
+           maxPercent - maxPercent/PORT_MAX_WEIGHT until maxPercent get "PORT_MAX_WEIGHT: */
+        if((uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT ) % maxPercent))
+            weight++;
+
+        /* find the location of this port within the register */
+        SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, p_PortsBandwidth->portsBandwidths[i].type,p_PortsBandwidth->portsBandwidths[i].relativePortId);
+        relativePortId = (uint8_t)(hardwarePortId % 8);
+        shift = (uint8_t)(32-4*(relativePortId+1));
+
+
+        if(weight > 1)
+            /* Add this port to tmpReg */
+            /* (each 8 ports result in one register)*/
+            tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
+    }
+
+    for(i=0;i<8;i++)
+        if(tmpRegs[i])
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i], tmpRegs[i]);
+
+    return E_OK;
+}
+
+t_Error FM_EnableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        t_FmIpcMsg      msg;
+        t_Error         err;
+
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_ENABLE_RAM_ECC;
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
+    }
+
+    if(!p_Fm->p_FmStateStruct->internalCall)
+        p_Fm->p_FmStateStruct->explicitEnable = TRUE;
+    p_Fm->p_FmStateStruct->internalCall = FALSE;
+
+    if(p_Fm->p_FmStateStruct->ramsEccEnable)
+        return E_OK;
+    else
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        {
+            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
+        }
+        else
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->p_FmStateStruct->ramsEccEnable = TRUE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_DisableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+    bool        explicitDisable = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        t_Error             err;
+        t_FmIpcMsg          msg;
+
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_DISABLE_RAM_ECC;
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     NULL,
+                                     NULL,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
+    }
+
+    if(!p_Fm->p_FmStateStruct->internalCall)
+        explicitDisable = TRUE;
+    p_Fm->p_FmStateStruct->internalCall = FALSE;
+
+    /* if rams are already disabled, or if rams were explicitly enabled and are
+       currently called indirectly (not explicitly), ignore this call. */
+    if(!p_Fm->p_FmStateStruct->ramsEccEnable || (p_Fm->p_FmStateStruct->explicitEnable && !explicitDisable))
+        return E_OK;
+    else
+    {
+        if(p_Fm->p_FmStateStruct->explicitEnable)
+            /* This is the case were both explicit are TRUE.
+               Turn off this flag for cases were following ramsEnable
+               routines are called */
+            p_Fm->p_FmStateStruct->explicitEnable = FALSE;
+
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+        if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        {
+            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~FPM_RAM_CTL_IRAM_ECC_EN);
+        }
+        else
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->p_FmStateStruct->ramsEccEnable = FALSE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask = 0;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->p_FmStateStruct->exceptions |= bitMask;
+        else
+            p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+             case(e_FM_EX_DMA_BUS_ERROR):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_BER;
+                else
+                    tmpReg &= ~DMA_MODE_BER;
+                /* disable bus error */
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_DMA_READ_ECC):
+             case(e_FM_EX_DMA_SYSTEM_WRITE_ECC):
+             case(e_FM_EX_DMA_FM_WRITE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_ECC;
+                else
+                    tmpReg &= ~DMA_MODE_ECC;
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_FPM_STALL_ON_TASKS):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_STALL_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_STALL_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+             case(e_FM_EX_FPM_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_FPM_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_QMI_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+                if(enable)
+                {
+#ifdef FM_QMI_NO_ECC_EXCEPTIONS
+                    t_FmRevisionInfo revInfo;
+                    FM_GetRevision(p_Fm, &revInfo);
+                    if (revInfo.majorRev == 4)
+                    {
+                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
+                       return E_OK;
+                    }
+#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
+                    tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+                }
+                else
+                    tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                {
+#ifdef FM_QMI_NO_ECC_EXCEPTIONS
+                    t_FmRevisionInfo revInfo;
+                    FM_GetRevision(p_Fm, &revInfo);
+                    if (revInfo.majorRev == 4)
+                    {
+                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_DOUBLE_ECC"));
+                       return E_OK;
+                    }
+#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
+                    tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+                }
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                    tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_BMI_LIST_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                {
+#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+                    t_FmRevisionInfo revInfo;
+                    FM_GetRevision(p_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    {
+                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC"));
+                       return E_OK;
+                    }
+#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
+                    tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                }
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+             case(e_FM_EX_BMI_PIPELINE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                {
+#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+                    t_FmRevisionInfo revInfo;
+                    FM_GetRevision(p_Fm, &revInfo);
+                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+                    {
+                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECCBMI_LIST_RAM_ECC"));
+                       return E_OK;
+                    }
+#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
+                    tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+                }
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+             case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+             case(e_FM_EX_BMI_DISPATCH_RAM_ECC):
+               tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+               if(enable)
+               {
+#ifdef FM_NO_DISPATCH_RAM_ECC
+                   t_FmRevisionInfo     revInfo;
+                   FM_GetRevision(p_Fm, &revInfo);
+                   if (revInfo.majorRev < 4)
+                   {
+                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC"));
+                       return E_OK;
+                   }
+#endif /* FM_NO_DISPATCH_RAM_ECC */
+                   tmpReg |= BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+               }
+               else
+                   tmpReg &= ~BMI_ERR_INTR_EN_DISPATCH_RAM_ECC;
+               WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+               break;
+             case(e_FM_EX_IRAM_ECC):
+                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    FmEnableRamsEcc(p_Fm);
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+                }
+                else
+                {
+                    /* ECC mechanism may be disabled, depending on driver status  */
+                    FmDisableRamsEcc(p_Fm);
+                    tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
+                }
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+                break;
+
+             case(e_FM_EX_MURAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    FmEnableRamsEcc(p_Fm);
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+                }
+                else
+                {
+                    /* ECC mechanism may be disabled, depending on driver status  */
+                    FmDisableRamsEcc(p_Fm);
+                    tmpReg &= ~FPM_MURAM_ECC_ERR_EX_EN;
+                }
+
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrie, tmpReg);
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+        }
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint32_t            tmpReg;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+    t_FmIpcReply        reply;
+    uint32_t            replyLength;
+    t_FmIpcRevisionInfo ipcRevInfo;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_REV;
+        replyLength = sizeof(uint32_t) + sizeof(t_FmRevisionInfo);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmRevisionInfo)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&ipcRevInfo, reply.replyBody, sizeof(t_FmRevisionInfo));
+        p_FmRevisionInfo->majorRev = ipcRevInfo.majorRev;
+        p_FmRevisionInfo->minorRev = ipcRevInfo.minorRev;
+        return (t_Error)(reply.error);
+    }
+
+    /* read revision register 1 */
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+    p_FmRevisionInfo->majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+    p_FmRevisionInfo->minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+
+    return E_OK;
+}
+
+uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    t_Error             err;
+    uint32_t            counterValue;
+    t_FmIpcMsg          msg;
+    t_FmIpcReply        reply;
+    uint32_t            replyLength, outCounter;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_GET_COUNTER;
+        memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(counterValue),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
+
+        return outCounter;
+     }
+
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
+        case(e_FM_COUNTERS_DEQ_0):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0);
+        case(e_FM_COUNTERS_DEQ_1):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1);
+        case(e_FM_COUNTERS_DEQ_2):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2);
+        case(e_FM_COUNTERS_DEQ_3):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3);
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc);
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc);
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc);
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc);
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc);
+        default:
+            break;
+    }
+    /* should never get here */
+    ASSERT_COND(FALSE);
+
+    return 0;
+}
+
+t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+   SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+   SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* When applicable (when there is an 'enable counters' bit,
+    check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_0):
+        case(e_FM_COUNTERS_DEQ_1):
+        case(e_FM_COUNTERS_DEQ_2):
+        case(e_FM_COUNTERS_DEQ_3):
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_0):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_1):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_2):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_3):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc, val);
+            break;
+        default:
+            break;
+    }
+
+    return E_OK;
+}
+
+void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
+
+    if(enable)
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
+    else /* disable */
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
+
+    return;
+}
+
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | ((uint32_t)pri << DMA_MODE_BUS_PRI_SHIFT) );
+
+    return;
+}
+
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint32_t            tmpReg;
+    t_Error             err;
+    t_FmIpcMsg          msg;
+    t_FmIpcReply        reply;
+    uint32_t            replyLength;
+    t_FmIpcDmaStatus    ipcDmaStatus;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_DMA_STAT;
+        replyLength = sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus);
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+        {
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
+        }
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus)))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return;
+        }
+        memcpy((uint8_t*)&ipcDmaStatus, reply.replyBody, sizeof(t_FmIpcDmaStatus));
+
+        p_FmDmaStatus->cmqNotEmpty = (bool)ipcDmaStatus.boolCmqNotEmpty;            /**< Command queue is not empty */
+        p_FmDmaStatus->busError = (bool)ipcDmaStatus.boolBusError;                  /**< Bus error occured */
+        p_FmDmaStatus->readBufEccError = (bool)ipcDmaStatus.boolReadBufEccError;        /**< Double ECC error on buffer Read */
+        p_FmDmaStatus->writeBufEccSysError =(bool)ipcDmaStatus.boolWriteBufEccSysError;    /**< Double ECC error on buffer write from system side */
+        p_FmDmaStatus->writeBufEccFmError = (bool)ipcDmaStatus.boolWriteBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+        return;
+    }
+
+    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+
+    p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
+    p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
+    p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
+    p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
+    p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+    return;
+}
+
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+            break;
+        case e_FM_EX_QMI_SINGLE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            break;
+        case e_FM_EX_QMI_DOUBLE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            break;
+        case e_FM_EX_BMI_LIST_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_PIPELINE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_PIPELINE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_PIPELINE_ECC);
+            break;
+        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+void FM_Resume(t_Handle h_Fm)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        /* TODO */
+        ASSERT_COND(0);
+        return;
+    }
+
+    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    /* clear tmpReg event bits in order not to clear standing events */
+    tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_DumpRegs(t_Handle h_Fm)
+{
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+    uint8_t         i = 0;
+    t_Error			err;
+    t_FmIpcMsg      msg;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+
+    if(p_Fm->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_DUMP_REGS;
+        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                    (uint8_t*)&msg,
+                                    sizeof(msg.msgId),
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    NULL)) != E_OK)
+        	RETURN_ERROR(MINOR, err, NO_MSG);
+        return E_OK;
+    }
+
+
+    DUMP_SUBTITLE(("\n"));
+
+    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FmFpmRegs Regs"));
+
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtnc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmpr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,brkc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmflc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmepi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrie);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcev, ("fmfpfcev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfpfcee, ("fmfpfcee"));
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfpfcee[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsp);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsf);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrcr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmextc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext2);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmdrd, ("fpmdrd"));
+    DUMP_SUBSTRUCT_ARRAY(i, 16)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmdrd[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdra);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrstc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmcld);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmnpi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmem);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmcev, ("fpmcev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 4)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmcev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps, ("fmfp_ps"));
+    DUMP_SUBSTRUCT_ARRAY(i, 64)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("p_FmDmaRegs Regs"));
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmhy);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsetr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtah);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtal);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtcid);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmra);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmrd);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmwcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmebcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqdr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr1);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr2);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr3);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr4);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr5);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsefrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsqfrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmssrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmdcr);
+
+    DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr, ("fmdmplr"));
+
+    DUMP_SUBSTRUCT_ARRAY(i, FM_SIZE_OF_LIODN_TABLE/2)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("p_FmBmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_init);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg1);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg2);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ievr);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ier);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_arb, ("fmbm_arb"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_arb[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("p_FmQmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eif);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ts);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
new file mode 100644
index 0000000..ccc950c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -0,0 +1,717 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_H
+#define __FM_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_ext.h"
+#include "fm_ipc.h"
+
+
+#define __ERR_MODULE__  MODULE_FM
+
+#define FM_MAX_NUM_OF_HW_PORT_IDS           64
+#define FM_MAX_NUM_OF_GUESTS                100
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+#define FM_EX_DMA_BUS_ERROR                 0x80000000      /**< DMA bus error. */
+#define FM_EX_DMA_READ_ECC                  0x40000000
+#define FM_EX_DMA_SYSTEM_WRITE_ECC          0x20000000
+#define FM_EX_DMA_FM_WRITE_ECC              0x10000000
+#define FM_EX_FPM_STALL_ON_TASKS            0x08000000      /**< Stall of tasks on FPM */
+#define FM_EX_FPM_SINGLE_ECC                0x04000000      /**< Single ECC on FPM */
+#define FM_EX_FPM_DOUBLE_ECC                0x02000000
+#define FM_EX_QMI_SINGLE_ECC                0x01000000      /**< Single ECC on FPM */
+#define FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID   0x00800000      /**< Dequeu from default queue id */
+#define FM_EX_QMI_DOUBLE_ECC                0x00400000
+#define FM_EX_BMI_LIST_RAM_ECC              0x00200000
+#define FM_EX_BMI_PIPELINE_ECC              0x00100000
+#define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
+#define FM_EX_IRAM_ECC                      0x00040000
+#define FM_EX_NURAM_ECC                     0x00020000
+#define FM_EX_BMI_DISPATCH_RAM_ECC          0x00010000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_EX_DMA_BUS_ERROR:                                         \
+        bitMask = FM_EX_DMA_BUS_ERROR; break;                           \
+    case e_FM_EX_DMA_READ_ECC:                                          \
+        bitMask = FM_EX_DMA_READ_ECC; break;                            \
+    case e_FM_EX_DMA_SYSTEM_WRITE_ECC:                                  \
+        bitMask = FM_EX_DMA_SYSTEM_WRITE_ECC; break;                    \
+    case e_FM_EX_DMA_FM_WRITE_ECC:                                      \
+        bitMask = FM_EX_DMA_FM_WRITE_ECC; break;                        \
+    case e_FM_EX_FPM_STALL_ON_TASKS:                                    \
+        bitMask = FM_EX_FPM_STALL_ON_TASKS; break;                      \
+    case e_FM_EX_FPM_SINGLE_ECC:                                        \
+        bitMask = FM_EX_FPM_SINGLE_ECC; break;                          \
+    case e_FM_EX_FPM_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_FPM_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_SINGLE_ECC:                                        \
+        bitMask = FM_EX_QMI_SINGLE_ECC; break;                          \
+    case e_FM_EX_QMI_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_QMI_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:                           \
+        bitMask = FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break;             \
+    case e_FM_EX_BMI_LIST_RAM_ECC:                                      \
+        bitMask = FM_EX_BMI_LIST_RAM_ECC; break;                        \
+    case e_FM_EX_BMI_PIPELINE_ECC:                                      \
+        bitMask = FM_EX_BMI_PIPELINE_ECC; break;                        \
+    case e_FM_EX_BMI_STATISTICS_RAM_ECC:                                \
+        bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;                  \
+    case e_FM_EX_BMI_DISPATCH_RAM_ECC:                                  \
+        bitMask = FM_EX_BMI_DISPATCH_RAM_ECC; break;                    \
+    case e_FM_EX_IRAM_ECC:                                              \
+        bitMask = FM_EX_IRAM_ECC; break;                                \
+    case e_FM_EX_MURAM_ECC:                                             \
+        bitMask = FM_EX_NURAM_ECC; break;                               \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_exceptions                  (FM_EX_DMA_BUS_ERROR            |\
+                                            FM_EX_DMA_READ_ECC              |\
+                                            FM_EX_DMA_SYSTEM_WRITE_ECC      |\
+                                            FM_EX_DMA_FM_WRITE_ECC          |\
+                                            FM_EX_FPM_STALL_ON_TASKS        |\
+                                            FM_EX_FPM_SINGLE_ECC            |\
+                                            FM_EX_FPM_DOUBLE_ECC            |\
+                                            FM_EX_QMI_SINGLE_ECC            |\
+                                            FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID|\
+                                            FM_EX_QMI_DOUBLE_ECC            |\
+                                            FM_EX_BMI_LIST_RAM_ECC          |\
+                                            FM_EX_BMI_PIPELINE_ECC          |\
+                                            FM_EX_BMI_STATISTICS_RAM_ECC    |\
+                                            FM_EX_BMI_DISPATCH_RAM_ECC      |\
+                                            FM_EX_IRAM_ECC                  |\
+                                            FM_EX_NURAM_ECC                 )
+#define DEFAULT_totalNumOfTasks             (BMI_MAX_NUM_OF_TASKS*3/4)
+#define DEFAULT_totalFifoSize               (BMI_MAX_FIFO_SIZE*3/4)
+#define DEFAULT_maxNumOfOpenDmas            (BMI_MAX_NUM_OF_DMAS*3/4)
+#define DEFAULT_eccEnable                   FALSE
+#define DEFAULT_dispLimit                   16
+#define DEFAULT_prsDispTh                   16
+#define DEFAULT_plcrDispTh                  16
+#define DEFAULT_kgDispTh                    16
+#define DEFAULT_bmiDispTh                   16
+#define DEFAULT_qmiEnqDispTh                16
+#define DEFAULT_qmiDeqDispTh                16
+#define DEFAULT_fmCtl1DispTh                16
+#define DEFAULT_fmCtl2DispTh                16
+#define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
+#ifdef FM_PEDANTIC_DMA
+#define DEFAULT_aidOverride                 TRUE
+#else
+#define DEFAULT_aidOverride                 FALSE
+#endif /* FM_PEDANTIC_DMA */
+#define DEFAULT_aidMode                     e_FM_DMA_AID_OUT_TNUM
+#define DEFAULT_dmaStopOnBusError           FALSE
+#define DEFAULT_stopAtBusError              FALSE
+#define DEFAULT_axiDbgNumOfBeats            1
+#define DEFAULT_dmaCamNumOfEntries          32
+#define DEFAULT_dmaCommQLow                 ((DMA_THRESH_MAX_COMMQ+1)/2)
+#define DEFAULT_dmaCommQHigh                ((DMA_THRESH_MAX_COMMQ+1)*3/4)
+#define DEFAULT_dmaReadIntBufLow            ((DMA_THRESH_MAX_BUF+1)/2)
+#define DEFAULT_dmaReadIntBufHigh           ((DMA_THRESH_MAX_BUF+1)*3/4)
+#define DEFAULT_dmaWriteIntBufLow           ((DMA_THRESH_MAX_BUF+1)/2)
+#define DEFAULT_dmaWriteIntBufHigh          ((DMA_THRESH_MAX_BUF+1)*3/4)
+#define DEFAULT_dmaSosEmergency             0
+#define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
+#define DEFAULT_dmaErr                      e_FM_DMA_ERR_CATASTROPHIC
+#define DEFAULT_resetOnInit                 FALSE
+#define DEFAULT_haltOnExternalActivation    FALSE   /* do not change! if changed, must be disabled for rev1 ! */
+#define DEFAULT_haltOnUnrecoverableEccError FALSE   /* do not change! if changed, must be disabled for rev1 ! */
+#define DEFAULT_externalEccRamsEnable       FALSE
+#define DEFAULT_VerifyUcode                 FALSE
+#define DEFAULT_tnumAgingPeriod             0
+#define DEFAULT_dmaWatchdog                 0 /* disabled */
+#define DEFAULT_mtu                         9600
+
+/**************************************************************************//**
+ @Description       Modules registers offsets
+*//***************************************************************************/
+#define FM_MM_MURAM             0x00000000
+#define FM_MM_BMI               0x00080000
+#define FM_MM_QMI               0x00080400
+#define FM_MM_PRS               0x000c7000
+#define FM_MM_KG                0x000C1000
+#define FM_MM_DMA               0x000C2000
+#define FM_MM_FPM               0x000C3000
+#define FM_MM_PLCR              0x000C0000
+#define FM_MM_IMEM              0x000C4000
+
+/**************************************************************************//**
+ @Description       Interrupt Enable/Mask
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    volatile uint32_t   fpmtnc;         /**< FPM TNUM Control */
+    volatile uint32_t   fpmpr;          /**< FPM Port_ID FmCtl Association */
+    volatile uint32_t   brkc;           /**< FPM Breakpoint Control */
+    volatile uint32_t   fpmflc;         /**< FPM Flush Control */
+    volatile uint32_t   fpmdis1;        /**< FPM Dispatch Thresholds1 */
+    volatile uint32_t   fpmdis2;        /**< FPM Dispatch Thresholds2  */
+    volatile uint32_t   fmepi;          /**< FM Error Pending Interrupts */
+    volatile uint32_t   fmrie;          /**< FM Error Interrupt Enable */
+    volatile uint32_t   fmfpfcev[4];    /**< FPM FMan-Controller Event 1-4 */
+    volatile uint8_t    res1[16];       /**< reserved */
+    volatile uint32_t   fmfpfcee[4];    /**< PM FMan-Controller Event 1-4 */
+    volatile uint8_t    res2[16];       /**< reserved */
+    volatile uint32_t   fpmtsc1;        /**< FPM TimeStamp Control1 */
+    volatile uint32_t   fpmtsc2;        /**< FPM TimeStamp Control2 */
+    volatile uint32_t   fpmtsp;         /**< FPM Time Stamp */
+    volatile uint32_t   fpmtsf;         /**< FPM Time Stamp Fraction */
+    volatile uint32_t   fmrcr;          /**< FM Rams Control */
+    volatile uint32_t   fpmextc;        /**< FPM External Requests Control */
+    volatile uint32_t   fpmext1;        /**< FPM External Requests Config1 */
+    volatile uint32_t   fpmext2;        /**< FPM External Requests Config2 */
+    volatile uint32_t   fpmdrd[16];     /**< FPM Data_Ram Data 0-15 */
+    volatile uint32_t   fpmdra;         /**< FPM Data Ram Access */
+    volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
+    volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
+    volatile uint32_t   fmrstc;         /**< FM Reset Command */
+    volatile uint32_t   fmcld;          /**< FM Classifier Debug */
+    volatile uint32_t   fmnpi;          /**< FM Normal Pending Interrupts  */
+    volatile uint32_t   fmfp_exte;      /**< FPM External Requests Enable */
+    volatile uint32_t   fpmem;          /**< FPM Event & Mask */
+    volatile uint32_t   fpmcev[4];      /**< FPM CPU Event 1-4 */
+    volatile uint8_t    res4[16];       /**< reserved */
+    volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
+    volatile uint8_t    reserved1[0x260];
+    volatile uint32_t   fpmts[128];     /**< 0x400: FPM Task Status */
+} _PackedType t_FmFpmRegs;
+
+#define NUM_OF_DBG_TRAPS    3
+
+typedef _Packed struct
+{
+   volatile uint32_t   fmbm_init;       /**< BMI Initialization */
+   volatile uint32_t   fmbm_cfg1;       /**< BMI Configuration 1 */
+   volatile uint32_t   fmbm_cfg2;       /**< BMI Configuration 2 */
+   volatile uint32_t   reserved[5];
+   volatile uint32_t   fmbm_ievr;       /**< Interrupt Event Register */
+   volatile uint32_t   fmbm_ier;        /**< Interrupt Enable Register */
+   volatile uint32_t   fmbm_ifr;        /**< Interrupt Force Register */
+   volatile uint32_t   reserved1[5];
+   volatile uint32_t   fmbm_arb[8];     /**< BMI Arbitration */
+   volatile uint32_t   reserved2[12];
+   volatile uint32_t   fmbm_dtc[NUM_OF_DBG_TRAPS];      /**< BMI Debug Trap Counter */
+   volatile uint32_t   reserved3;
+   volatile uint32_t   fmbm_dcv[NUM_OF_DBG_TRAPS][4];   /**< BMI Debug Compare Value */
+   volatile uint32_t   fmbm_dcm[NUM_OF_DBG_TRAPS][4];   /**< BMI Debug Compare Mask */
+   volatile uint32_t   fmbm_gde;        /**< BMI Global Debug Enable */
+   volatile uint32_t   fmbm_pp[63];     /**< BMI Port Parameters */
+   volatile uint32_t   reserved4;
+   volatile uint32_t   fmbm_pfs[63];    /**< BMI Port FIFO Size */
+   volatile uint32_t   reserved5;
+   volatile uint32_t   fmbm_ppid[63];   /**< Port Partition ID */
+} _PackedType t_FmBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_gc;        /**<  General Configuration Register */
+    volatile uint32_t   Reserved0;
+    volatile uint32_t   fmqm_eie;       /**<  Error Interrupt Event Register */
+    volatile uint32_t   fmqm_eien;      /**<  Error Interrupt Enable Register */
+    volatile uint32_t   fmqm_eif;       /**<  Error Interrupt Force Register */
+    volatile uint32_t   fmqm_ie;        /**<  Interrupt Event Register */
+    volatile uint32_t   fmqm_ien;       /**<  Interrupt Enable Register */
+    volatile uint32_t   fmqm_if;        /**<  Interrupt Force Register */
+    volatile uint32_t   fmqm_gs;        /**<  Global Status Register */
+    volatile uint32_t   fmqm_ts;        /**<  Task Status Register */
+    volatile uint32_t   fmqm_etfc;      /**<  Enqueue Total Frame Counter */
+    volatile uint32_t   fmqm_dtfc;      /**<  Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_dc0;       /**<  Dequeue Counter 0 */
+    volatile uint32_t   fmqm_dc1;       /**<  Dequeue Counter 1 */
+    volatile uint32_t   fmqm_dc2;       /**<  Dequeue Counter 2 */
+    volatile uint32_t   fmqm_dc3;       /**<  Dequeue Counter 3 */
+    volatile uint32_t   fmqm_dfdc;      /**<  Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
+    volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
+    volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
+    volatile uint32_t   Reserved1a[7];
+    volatile uint32_t   fmqm_tapc;      /**<  Tnum Aging Period Control */
+    volatile uint32_t   fmqm_dmcvc;     /**<  Dequeue MAC Command Valid Counter */
+    volatile uint32_t   fmqm_difdcc;    /**<  Dequeue Invalid FD Command Counter */
+    volatile uint32_t   fmqm_da1v;      /**<  Dequeue A1 Valid Counter */
+    volatile uint32_t   Reserved1b;
+    volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
+    volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
+    volatile uint32_t   Reserved3[2];
+    _Packed struct {
+        volatile uint32_t   fmqm_dtcfg1;    /**<  0x0090 Debug Trap Configuration 1 Register */
+        volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value 1 Register */
+        volatile uint32_t   fmqm_dtm1;      /**<  Debug Trap Mask 1 Register */
+        volatile uint32_t   fmqm_dtc1;      /**<  Debug Trap Counter 1 Register */
+        volatile uint32_t   fmqm_dtcfg2;    /**<  Debug Trap Configuration 2 Register */
+        volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value 2 Register */
+        volatile uint32_t   fmqm_dtm2;      /**<  Debug Trap Mask 2 Register */
+        volatile uint32_t   Reserved1;
+    } _PackedType dbgTraps[NUM_OF_DBG_TRAPS];
+} _PackedType t_FmQmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmdmsr;         /**<    FM DMA status register 0x04 */
+    volatile uint32_t   fmdmmr;         /**<    FM DMA mode register 0x08 */
+    volatile uint32_t   fmdmtr;         /**<    FM DMA bus threshold register 0x0c */
+    volatile uint32_t   fmdmhy;         /**<    FM DMA bus hysteresis register 0x10 */
+    volatile uint32_t   fmdmsetr;       /**<    FM DMA SOS emergency Threshold Register 0x14 */
+    volatile uint32_t   fmdmtah;        /**<    FM DMA transfer bus address high register 0x18  */
+    volatile uint32_t   fmdmtal;        /**<    FM DMA transfer bus address low register 0x1C  */
+    volatile uint32_t   fmdmtcid;       /**<    FM DMA transfer bus communication ID register 0x20  */
+    volatile uint32_t   fmdmra;         /**<    FM DMA bus internal ram address register 0x24  */
+    volatile uint32_t   fmdmrd;         /**<    FM DMA bus internal ram data register 0x28  */
+    volatile uint32_t   fmdmwcr;        /**<    FM DMA CAM watchdog counter value 0x2C  */
+    volatile uint32_t   fmdmebcr;       /**<    FM DMA CAM base in MURAM register 0x30  */
+    volatile uint32_t   fmdmccqdr;      /**<    FM DMA CAM and CMD Queue Debug register 0x34  */
+    volatile uint32_t   fmdmccqvr1;     /**<    FM DMA CAM and CMD Queue Value register #1 0x38  */
+    volatile uint32_t   fmdmccqvr2;     /**<    FM DMA CAM and CMD Queue Value register #2 0x3C  */
+    volatile uint32_t   fmdmcqvr3;      /**<    FM DMA CMD Queue Value register #3 0x40  */
+    volatile uint32_t   fmdmcqvr4;      /**<    FM DMA CMD Queue Value register #4 0x44  */
+    volatile uint32_t   fmdmcqvr5;      /**<    FM DMA CMD Queue Value register #5 0x48  */
+    volatile uint32_t   fmdmsefrc;      /**<    FM DMA Semaphore Entry Full Reject Counter 0x50  */
+    volatile uint32_t   fmdmsqfrc;      /**<    FM DMA Semaphore Queue Full Reject Counter 0x54  */
+    volatile uint32_t   fmdmssrc;       /**<    FM DMA Semaphore SYNC Reject Counter 0x54  */
+    volatile uint32_t   fmdmdcr;        /**<    FM DMA Debug Counter */
+    volatile uint32_t   fmdmemsr;       /**<    FM DMA Emrgency Smoother Register */
+    volatile uint32_t   reserved;
+    volatile uint32_t   fmdmplr[FM_SIZE_OF_LIODN_TABLE/2];
+                                        /**<    FM DMA PID-LIODN # register  */
+} _PackedType t_FmDmaRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   iadd;           /**<    FM IRAM instruction address register */
+    volatile uint32_t   idata;          /**<    FM IRAM instruction data register */
+    volatile uint32_t   itcfg;          /**<    FM IRAM timing config register */
+    volatile uint32_t   iready;         /**<    FM IRAM ready register */
+    volatile uint8_t    res[0x80000-0x10];
+} _PackedType t_FMIramRegs;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define FM_DEBUG_STATUS_REGISTER_OFFSET     0x000d1084UL
+#define FM_UCODE_DEBUG_INSTRUCTION          0x6ffff805UL
+
+
+/**************************************************************************//**
+ @Description       DMA definitions
+*//***************************************************************************/
+
+/* masks */
+#define DMA_MODE_AID_OR                     0x20000000
+#define DMA_MODE_SBER                       0x10000000
+#define DMA_MODE_BER                        0x00200000
+#define DMA_MODE_ECC                        0x00000020
+#define DMA_MODE_PRIVILEGE_PROT             0x00001000
+#define DMA_MODE_SECURE_PROT                0x00000800
+#define DMA_MODE_EMERGENCY_READ             0x00080000
+#define DMA_MODE_EMERGENCY_WRITE            0x00040000
+
+#define DMA_TRANSFER_PORTID_MASK            0xFF000000
+#define DMA_TRANSFER_TNUM_MASK              0x00FF0000
+#define DMA_TRANSFER_LIODN_MASK             0x00000FFF
+
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+
+#define DMA_STATUS_CMD_QUEUE_NOT_EMPTY      0x10000000
+#define DMA_STATUS_BUS_ERR                  0x08000000
+#define DMA_STATUS_READ_ECC                 0x04000000
+#define DMA_STATUS_SYSTEM_WRITE_ECC         0x02000000
+#define DMA_STATUS_FM_WRITE_ECC             0x01000000
+#define DMA_STATUS_SYSTEM_DPEXT_ECC         0x00800000
+#define DMA_STATUS_FM_DPEXT_ECC             0x00400000
+#define DMA_STATUS_SYSTEM_DPDAT_ECC         0x00200000
+#define DMA_STATUS_FM_DPDAT_ECC             0x00100000
+#define DMA_STATUS_FM_SPDAT_ECC             0x00080000
+
+#define FM_LIODN_BASE_MASK                  0x00000FFF
+
+/* shifts */
+#define DMA_MODE_CACHE_OR_SHIFT             30
+#define DMA_MODE_BUS_PRI_SHIFT              16
+#define DMA_MODE_AXI_DBG_SHIFT              24
+#define DMA_MODE_CEN_SHIFT                  13
+#define DMA_MODE_BUS_PROT_SHIFT             10
+#define DMA_MODE_DBG_SHIFT                  7
+#define DMA_MODE_EMERGENCY_LEVEL_SHIFT      6
+#define DMA_MODE_AID_MODE_SHIFT             4
+#define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS   16
+#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     32
+
+#define DMA_THRESH_COMMQ_SHIFT              24
+#define DMA_THRESH_READ_INT_BUF_SHIFT       16
+
+#define DMA_LIODN_SHIFT                     16
+
+#define DMA_TRANSFER_PORTID_SHIFT           24
+#define DMA_TRANSFER_TNUM_SHIFT             16
+
+/* sizes */
+#define DMA_MAX_WATCHDOG                    0xffffffff
+
+/* others */
+#define DMA_CAM_SIZEOF_ENTRY                0x40
+#define DMA_CAM_ALIGN                       0x1000
+#define DMA_CAM_UNITS                       8
+
+
+/**************************************************************************//**
+ @Description       FPM defines
+*//***************************************************************************/
+
+/* masks */
+#define FPM_EV_MASK_DOUBLE_ECC          0x80000000
+#define FPM_EV_MASK_STALL               0x40000000
+#define FPM_EV_MASK_SINGLE_ECC          0x20000000
+#define FPM_EV_MASK_RELEASE_FM          0x00010000
+#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
+#define FPM_EV_MASK_STALL_EN            0x00004000
+#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
+#define FPM_EV_MASK_EXTERNAL_HALT       0x00000008
+#define FPM_EV_MASK_ECC_ERR_HALT        0x00000004
+
+#define FPM_RAM_CTL_RAMS_ECC_EN         0x80000000
+#define FPM_RAM_CTL_IRAM_ECC_EN         0x40000000
+#define FPM_RAM_CTL_MURAM_ECC           0x00008000
+#define FPM_RAM_CTL_IRAM_ECC            0x00004000
+#define FPM_RAM_CTL_MURAM_TEST_ECC      0x20000000
+#define FPM_RAM_CTL_IRAM_TEST_ECC       0x10000000
+#define FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL 0x08000000
+
+#define FPM_IRAM_ECC_ERR_EX_EN          0x00020000
+#define FPM_MURAM_ECC_ERR_EX_EN         0x00040000
+
+#define FPM_REV1_MAJOR_MASK             0x0000FF00
+#define FPM_REV1_MINOR_MASK             0x000000FF
+
+#define FPM_REV2_INTEG_MASK             0x00FF0000
+#define FPM_REV2_ERR_MASK               0x0000FF00
+#define FPM_REV2_CFG_MASK               0x000000FF
+
+#define FPM_TS_FRACTION_MASK            0x0000FFFF
+#define FPM_TS_CTL_EN                   0x80000000
+
+#define FPM_PORT_FM_CTL1                0x00000001
+#define FPM_PORT_FM_CTL2                0x00000002
+#define FPM_PRC_REALSE_STALLED          0x00800000
+
+#define FPM_PS_STALLED                  0x00800000
+#define FPM_PS_FM_CTL1_SEL              0x80000000
+#define FPM_PS_FM_CTL2_SEL              0x40000000
+#define FPM_PS_FM_CTL_SEL_MASK          (FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
+
+#define FPM_RSTC_FM_RESET               0x80000000
+#define FPM_RSTC_10G0_RESET             0x04000000
+#define FPM_RSTC_1G0_RESET              0x40000000
+#define FPM_RSTC_1G1_RESET              0x20000000
+#define FPM_RSTC_1G2_RESET              0x10000000
+#define FPM_RSTC_1G3_RESET              0x08000000
+#define FPM_RSTC_1G4_RESET              0x02000000
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+#define FPM_EXTE_RMU_DRBL_INTR          0x10000000
+#define FPM_EXTE_RMU_MAILBOX0_INTR      0x04000000
+#define FPM_EXTE_RMU_MAILBOX1_INTR      0x01000000
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+/* shifts */
+#define FPM_DISP_LIMIT_SHIFT            24
+
+#define FPM_THR1_PRS_SHIFT              24
+#define FPM_THR1_KG_SHIFT               16
+#define FPM_THR1_PLCR_SHIFT             8
+#define FPM_THR1_BMI_SHIFT              0
+
+#define FPM_THR2_QMI_ENQ_SHIFT          24
+#define FPM_THR2_QMI_DEQ_SHIFT          0
+#define FPM_THR2_FM_CTL1_SHIFT          16
+#define FPM_THR2_FM_CTL2_SHIFT          8
+
+#define FPM_EV_MASK_CAT_ERR_SHIFT       1
+#define FPM_EV_MASK_DMA_ERR_SHIFT       0
+
+#define FPM_REV1_MAJOR_SHIFT            8
+#define FPM_REV1_MINOR_SHIFT            0
+
+#define FPM_REV2_INTEG_SHIFT            16
+#define FPM_REV2_ERR_SHIFT              8
+#define FPM_REV2_CFG_SHIFT              0
+
+#define FPM_TS_INT_SHIFT                16
+
+#define FPM_PORT_FM_CTL_PORTID_SHIFT      24
+
+#define FPM_PS_FM_CTL_SEL_SHIFT           30
+#define FPM_PRC_ORA_FM_CTL_SEL_SHIFT      16
+
+/* Interrupts defines */
+#define FPM_EVENT_FM_CTL_0                0x00008000
+#define FPM_EVENT_FM_CTL                  0x0000FF00
+#define FPM_EVENT_FM_CTL_BRK              0x00000080
+
+/* others */
+#define FPM_MAX_DISP_LIMIT              31
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+/* masks */
+#define BMI_INIT_START                      0x80000000
+#define BMI_ERR_INTR_EN_PIPELINE_ECC        0x80000000
+#define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
+#define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
+#define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC    0x10000000
+#define BMI_NUM_OF_TASKS_MASK               0x3F000000
+#define BMI_NUM_OF_EXTRA_TASKS_MASK         0x000F0000
+#define BMI_NUM_OF_DMAS_MASK                0x00000F00
+#define BMI_NUM_OF_EXTRA_DMAS_MASK          0x0000000F
+#define BMI_FIFO_SIZE_MASK                  0x000003FF
+#define BMI_EXTRA_FIFO_SIZE_MASK            0x03FF0000
+#define BMI_CFG2_DMAS_MASK                  0x0000003F
+
+/* shifts */
+#define BMI_CFG2_TASKS_SHIFT            16
+#define BMI_CFG2_DMAS_SHIFT             0
+#define BMI_CFG1_FIFO_SIZE_SHIFT        16
+#define BMI_FIFO_SIZE_SHIFT             0
+#define BMI_EXTRA_FIFO_SIZE_SHIFT       16
+#define BMI_NUM_OF_TASKS_SHIFT          24
+#define BMI_EXTRA_NUM_OF_TASKS_SHIFT    16
+#define BMI_NUM_OF_DMAS_SHIFT           8
+#define BMI_EXTRA_NUM_OF_DMAS_SHIFT     0
+
+/* others */
+#define BMI_FIFO_ALIGN                  0x100
+
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_CFG_ENQ_EN                  0x80000000
+#define QMI_CFG_DEQ_EN                  0x40000000
+#define QMI_CFG_EN_COUNTERS             0x10000000
+#define QMI_CFG_SOFT_RESET              0x01000000
+#define QMI_CFG_DEQ_MASK                0x0000003F
+#define QMI_CFG_ENQ_MASK                0x00003F00
+
+#define QMI_ERR_INTR_EN_DOUBLE_ECC      0x80000000
+#define QMI_ERR_INTR_EN_DEQ_FROM_DEF    0x40000000
+#define QMI_INTR_EN_SINGLE_ECC          0x80000000
+
+/* shifts */
+#define QMI_CFG_ENQ_SHIFT               8
+#define QMI_TAPC_TAP                    22
+
+
+/**************************************************************************//**
+ @Description       IRAM defines
+*//***************************************************************************/
+/* masks */
+#define IRAM_IADD_AIE                   0x80000000
+#define IRAM_READY                      0x80000000
+
+typedef struct {
+    void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
+    t_Handle    h_SrcHandle;
+} t_FmanCtrlIntrSrc;
+
+
+typedef struct
+{
+ /*   uint8_t                     numOfPartitions; */
+    bool                        resetOnInit;
+#ifdef FM_PARTITION_ARRAY
+    uint16_t                    liodnBasePerPort[FM_SIZE_OF_LIODN_TABLE];
+#endif
+    bool                        enCounters;
+    t_FmThresholds              thresholds;
+    e_FmDmaCacheOverride        dmaCacheOverride;
+    e_FmDmaAidMode              dmaAidMode;
+    bool                        dmaAidOverride;
+    uint8_t                     dmaAxiDbgNumOfBeats;
+    uint8_t                     dmaCamNumOfEntries;
+    uint32_t                    dmaWatchdog;
+    t_FmDmaThresholds           dmaCommQThresholds;
+    t_FmDmaThresholds           dmaWriteBufThresholds;
+    t_FmDmaThresholds           dmaReadBufThresholds;
+    uint32_t                    dmaSosEmergency;
+    e_FmDmaDbgCntMode           dmaDbgCntMode;
+    bool                        dmaStopOnBusError;
+    bool                        dmaEnEmergency;
+    t_FmDmaEmergency            dmaEmergency;
+    bool                        dmaEnEmergencySmoother;
+    uint32_t                    dmaEmergencySwitchCounter;
+    bool                        haltOnExternalActivation;
+    bool                        haltOnUnrecoverableEccError;
+    e_FmCatastrophicErr         catastrophicErr;
+    e_FmDmaErr                  dmaErr;
+    bool                        enMuramTestMode;
+    bool                        enIramTestMode;
+    bool                        externalEccRamsEnable;
+    uint16_t                    tnumAgingPeriod;
+    t_FmPcdFirmwareParams       firmware;
+    bool                        fwVerify;
+} t_FmDriverParam;
+
+typedef void (t_FmanCtrlIsr)( t_Handle h_Fm, uint32_t event);
+
+typedef struct
+{
+/***************************/
+/* Master/Guest parameters */
+/***************************/
+    uint8_t                     fmId;
+    e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
+    uint16_t                    fmClkFreq;
+/**************************/
+/* Master Only parameters */
+/**************************/
+    bool                        enabledTimeStamp;
+    uint8_t                     count1MicroBit;
+    uint8_t                     totalNumOfTasks;
+    uint32_t                    totalFifoSize;
+    uint8_t                     maxNumOfOpenDmas;
+    uint8_t                     accumulatedNumOfTasks;
+    uint32_t                    accumulatedFifoSize;
+    uint8_t                     accumulatedNumOfOpenDmas;
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    uint8_t                     accumulatedNumOfDeqTnums;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+#ifdef FM_LOW_END_RESTRICTION
+    bool                        lowEndRestriction;
+#endif /* FM_LOW_END_RESTRICTION */
+    uint32_t                    exceptions;
+    int                         irq;
+    int                         errIrq;
+    bool                        ramsEccEnable;
+    bool                        explicitEnable;
+    bool                        internalCall;
+    uint8_t                     ramsEccOwners;
+    uint32_t                    extraFifoPoolSize;
+    uint8_t                     extraTasksPoolSize;
+    uint8_t                     extraOpenDmasPoolSize;
+#if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
+    uint16_t                    macMaxFrameLengths10G[FM_MAX_NUM_OF_10G_MACS];
+#endif /* defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS) */
+    uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
+} t_FmStateStruct;
+
+typedef struct
+{
+/***************************/
+/* Master/Guest parameters */
+/***************************/
+/* locals for recovery */
+    uintptr_t                   baseAddr;
+
+/* un-needed for recovery */
+    t_Handle                    h_Pcd;
+    char                        fmModuleName[MODULE_NAME_SIZE];
+    char                        fmIpcHandlerModuleName[FM_MAX_NUM_OF_GUESTS][MODULE_NAME_SIZE];
+    t_Handle                    h_IpcSessions[FM_MAX_NUM_OF_GUESTS];
+    t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
+    uint8_t                     guestId;
+/**************************/
+/* Master Only parameters */
+/**************************/
+/* locals for recovery */
+    t_FmFpmRegs                 *p_FmFpmRegs;
+    t_FmBmiRegs                 *p_FmBmiRegs;
+    t_FmQmiRegs                 *p_FmQmiRegs;
+    t_FmDmaRegs                 *p_FmDmaRegs;
+    t_FmExceptionsCallback      *f_Exception;
+    t_FmBusErrorCallback        *f_BusError;
+    t_Handle                    h_App;                          /* Application handle */
+    t_Handle                    h_Spinlock;
+    bool                        recoveryMode;
+    t_FmStateStruct             *p_FmStateStruct;
+
+/* un-needed for recovery */
+    t_FmDriverParam             *p_FmDriverParam;
+    t_Handle                    h_FmMuram;
+    uint64_t                    fmMuramPhysBaseAddr;
+    bool                        independentMode;
+    bool                        hcPortInitialized;
+    uintptr_t                   camBaseAddr;                    /* save for freeing */
+    uintptr_t                   resAddr;
+    uintptr_t                   fifoBaseAddr;                   /* save for freeing */
+    t_FmanCtrlIntrSrc           fmanCtrlIntr[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];    /* FM exceptions user callback */
+    bool                        usedEventRegs[FM_NUM_OF_FMAN_CTRL_EVENT_REGS];
+} t_Fm;
+
+
+/**************************************************************************//**
+ @Function      FM_Isr
+
+ @Description   FM interrupt-service-routine.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_GuestErrorIsr(t_Handle h_Fm, uint32_t pending);
+void FM_GuestEventIsr(t_Handle h_Fm, uint32_t pending);
+
+
+#endif /* __FM_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
new file mode 100644
index 0000000..886f6a0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -0,0 +1,35 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
new file mode 100644
index 0000000..824a49e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -0,0 +1,454 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ipc.h
+
+ @Description   FM Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_IPC_H
+#define __FM_IPC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_IPC_grp FM Inter-Partition messaging Unit
+
+ @Description   FM Inter-Partition messaging unit API definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef _Packed struct
+{
+    uint8_t         id;
+    uint32_t        enumType;
+} _PackedType t_FmIpcMacParams;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef _Packed struct
+{
+    t_FmIpcMacParams    macParams;
+    uint16_t            maxFrameLength;
+} _PackedType t_FmIpcMacMaxFrameParams;
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPhysAddr
+{
+    volatile uint8_t    high;
+    volatile uint32_t   low;
+} _PackedType t_FmIpcPhysAddr;
+
+/**************************************************************************//**
+ @Description   Structure for IPC communication during FM_PORT_Init.
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortInInitParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    uint32_t            enumPortType;       /**< IN. Port type */
+    uint8_t             boolIndependentMode;/**< IN. TRUE if FM Port operates in independent mode */
+    uint16_t            liodnOffset;        /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
+                                                 LIODN base for this port, to be
+                                                 used together with LIODN offset. */
+#ifdef FM_RMU_ASSIST_SUPPORT
+    uint8_t             boolIsRmuDoorbell;  /**< IN. TRUE if this is RMU port with doorbells support */
+    uint8_t             boolIsRmuMailbox0;  /**< IN. TRUE if this is RMU port with mailbox 0 support */
+	uint8_t             boolIsRmuMailbox1;  /**< IN. TRUE if this is RMU port with mailbox 1 support */
+#endif /* FM_RMU_ASSIST_SUPPORT */
+} _PackedType t_FmIpcPortInInitParams;
+
+
+/**************************************************************************//**
+ @Description   Structure for IPC communication between port and FM
+                regarding tasks and open DMA resources management.
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortRsrcParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    uint32_t            val;                /**< IN. Port's requested resource */
+    uint32_t            extra;              /**< IN. Port's requested resource */
+    uint8_t             boolInitialConfig;
+} _PackedType t_FmIpcPortRsrcParams;
+
+
+/**************************************************************************//**
+ @Description   Structure for IPC communication between port and FM
+                regarding tasks and open DMA resources management.
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortFifoParams {
+    t_FmIpcPortRsrcParams   rsrcParams;
+    uint32_t                enumPortType;
+    uint8_t                 boolIndependentMode;
+    uint8_t                 deqPipelineDepth;
+    uint8_t                 numOfPools;
+    uint16_t                secondLargestBufSize;
+    uint16_t                largestBufSize;
+    uint8_t                 boolInitialConfig;
+} _PackedType t_FmIpcPortFifoParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortFreeParams {
+    uint8_t             hardwarePortId;         /**< IN. port Id */
+    uint32_t            enumPortType;           /**< IN. Port type */
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+} _PackedType t_FmIpcPortFreeParams;
+
+/**************************************************************************//**
+ @Description   Structure for defining DMA status
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcDmaStatus {
+    uint8_t    boolCmqNotEmpty;            /**< Command queue is not empty */
+    uint8_t    boolBusError;               /**< Bus error occured */
+    uint8_t    boolReadBufEccError;        /**< Double ECC error on buffer Read */
+    uint8_t    boolWriteBufEccSysError;    /**< Double ECC error on buffer write from system side */
+    uint8_t    boolWriteBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+} _PackedType t_FmIpcDmaStatus;
+
+typedef _Packed struct t_FmIpcRegisterIntr
+{
+    uint8_t         guestId;        /* IN */
+    uint32_t        event;          /* IN */
+} _PackedType t_FmIpcRegisterIntr;
+
+typedef _Packed struct t_FmIpcIsr
+{
+    uint8_t         boolErr;        /* IN */
+    uint32_t        pendingReg;     /* IN */
+} _PackedType t_FmIpcIsr;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcRevisionInfo {
+    uint8_t         majorRev;               /**< OUT: Major revision */
+    uint8_t         minorRev;               /**< OUT: Minor revision */
+} _PackedType t_FmIpcRevisionInfo;
+
+/**************************************************************************//**
+ @Description   Structure for defining Fm number of Fman controlers
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPortNumOfFmanCtrls {
+    uint8_t             hardwarePortId;         /**< IN. port Id */
+    uint8_t             numOfFmanCtrls;         /**< IN. Port type */
+} t_FmIpcPortNumOfFmanCtrls;
+
+/**************************************************************************//**
+ @Description   structure for setting Fman contriller events
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcFmanEvents {
+    uint8_t         eventRegId;               /**< IN: Fman controller event register id */
+    uint32_t        enableEvents;             /**< IN/OUT: required enabled events mask */
+} _PackedType t_FmIpcFmanEvents;
+
+#define FM_IPC_MAX_REPLY_BODY_SIZE  16
+#define FM_IPC_MAX_REPLY_SIZE       (FM_IPC_MAX_REPLY_BODY_SIZE + sizeof(uint32_t))
+#define FM_IPC_MAX_MSG_SIZE         30
+typedef _Packed struct t_FmIpcMsg
+{
+    uint32_t    msgId;
+    uint8_t     msgBody[FM_IPC_MAX_MSG_SIZE];
+} _PackedType t_FmIpcMsg;
+
+typedef _Packed struct t_FmIpcReply
+{
+    uint32_t    error;
+    uint8_t     replyBody[FM_IPC_MAX_REPLY_BODY_SIZE];
+} _PackedType t_FmIpcReply;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/***************************************************************************/
+/************************ FRONT-END-TO-BACK-END*****************************/
+/***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_GET_TIMESTAMP_SCALE
+
+ @Description   Used by FM front-end.
+
+ @Param[out]    uint32_t Pointer
+*//***************************************************************************/
+#define FM_GET_TIMESTAMP_SCALE      1
+
+/**************************************************************************//**
+ @Function      FM_GET_COUNTER
+
+ @Description   Used by FM front-end.
+
+ @Param[in/out] t_FmIpcGetCounter Pointer
+*//***************************************************************************/
+#define FM_GET_COUNTER              2
+
+/**************************************************************************//**
+ @Function      FM_DUMP_REGS
+
+ @Description   Used by FM front-end for the PORT module in order to set and get
+                parameters in/from master FM module on FM PORT initialization time.
+
+ @Param         None
+*//***************************************************************************/
+#define FM_DUMP_REGS                3
+
+/**************************************************************************//**
+ @Function      FM_GET_SET_PORT_PARAMS
+
+ @Description   Used by FM front-end for the PORT module in order to set and get
+                parameters in/from master FM module on FM PORT initialization time.
+
+ @Param[in/out] t_FmIcPortInitParams Pointer
+*//***************************************************************************/
+#define FM_GET_SET_PORT_PARAMS      4
+
+/**************************************************************************//**
+ @Function      FM_FREE_PORT
+
+ @Description   Used by FM front-end for the PORT module when a port is freed
+                to free all FM PORT resources.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_FREE_PORT                5
+
+/**************************************************************************//**
+ @Function      FM_RESET_MAC
+
+ @Description   Used by front-end for the MAC module to reset the MAC registers
+
+ @Param[in]     t_FmIpcMacParams Pointer .
+*//***************************************************************************/
+#define FM_RESET_MAC                6
+
+/**************************************************************************//**
+ @Function      FM_RESUME_STALLED_PORT
+
+ @Description   Used by FM front-end for the PORT module in order to
+                release a stalled FM Port.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_RESUME_STALLED_PORT      7
+
+/**************************************************************************//**
+ @Function      FM_IS_PORT_STALLED
+
+ @Description   Used by FM front-end for the PORT module in order to check whether
+                an FM port is stalled.
+
+ @Param[in/out] t_FmIcPortIsStalled Pointer
+*//***************************************************************************/
+#define FM_IS_PORT_STALLED          8
+
+/**************************************************************************//**
+ @Function      FM_DUMP_PORT_REGS
+
+ @Description   Used by FM front-end for the PORT module in order to dump
+                all port registers.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_DUMP_PORT_REGS           9
+
+/**************************************************************************//**
+ @Function      FM_GET_REV
+
+ @Description   Used by FM front-end for the PORT module in order to dump
+                all port registers.
+
+ @Param[in]     uint8_t Pointer
+*//***************************************************************************/
+#define FM_GET_REV                  10
+
+/**************************************************************************//**
+ @Function      FM_REGISTER_INTR
+
+ @Description   Used by FM front-end to register an interrupt handler to
+                be called upon interrupt for guest.
+
+ @Param[out]    t_FmIpcRegisterIntr Pointer
+*//***************************************************************************/
+#define FM_REGISTER_INTR            11
+
+/**************************************************************************//**
+ @Function      FM_GET_CLK_FREQ
+
+ @Description   Used by FM Front-end to read the FM clock frequency.
+
+ @Param[out]    uint32_t Pointer
+*//***************************************************************************/
+#define FM_GET_CLK_FREQ             12
+
+/**************************************************************************//**
+ @Function      FM_DMA_STAT
+
+ @Description   Used by FM front-end to read the FM DMA status.
+
+ @Param[out]    t_FmIpcDmaStatus Pointer
+*//***************************************************************************/
+#define FM_DMA_STAT                 13
+
+/**************************************************************************//**
+ @Function      FM_ALLOC_FMAN_CTRL_EVENT_REG
+
+ @Description   Used by FM front-end to allocate event register.
+
+ @Param[out]    Event register id Pointer
+*//***************************************************************************/
+#define FM_ALLOC_FMAN_CTRL_EVENT_REG 14
+
+/**************************************************************************//**
+ @Function      FM_FREE_FMAN_CTRL_EVENT_REG
+
+ @Description   Used by FM front-end to free locate event register.
+
+ @Param[in]    uint8_t Pointer - Event register id
+*//***************************************************************************/
+#define FM_FREE_FMAN_CTRL_EVENT_REG 15
+
+/**************************************************************************//**
+ @Function      FM_SET_FMAN_CTRL_EVENTS_ENABLE
+
+ @Description   Used by FM front-end to enable events in the FPM
+                Fman controller event register.
+
+ @Param[in]    t_FmIpcFmanEvents Pointer
+*//***************************************************************************/
+#define FM_SET_FMAN_CTRL_EVENTS_ENABLE 16
+
+/**************************************************************************//**
+ @Function      FM_SET_FMAN_CTRL_EVENTS_ENABLE
+
+ @Description   Used by FM front-end to enable events in the FPM
+                Fman controller event register.
+
+ @Param[in/out] t_FmIpcFmanEvents Pointer
+*//***************************************************************************/
+#define FM_GET_FMAN_CTRL_EVENTS_ENABLE 17
+
+/**************************************************************************//**
+ @Function      FM_SET_MAC_MAX_FRAME
+
+ @Description   Used by FM front-end to set MAC's MTU/RTU's in
+                back-end.
+
+ @Param[in/out] t_FmIpcMacMaxFrameParams Pointer
+*//***************************************************************************/
+#define FM_SET_MAC_MAX_FRAME 18
+
+/**************************************************************************//**
+ @Function      FM_GET_PHYS_MURAM_BASE
+
+ @Description   Used by FM front-end in order to get MURAM base address
+
+ @Param[in/out] t_FmIpcPhysAddr Pointer
+*//***************************************************************************/
+#define FM_GET_PHYS_MURAM_BASE  19
+
+/**************************************************************************//**
+ @Function      FM_MASTER_IS_ALIVE
+
+ @Description   Used by FM front-end in order to verify Master is up
+
+ @Param[in/out] bool
+*//***************************************************************************/
+#define FM_MASTER_IS_ALIVE          20
+
+#define FM_ENABLE_RAM_ECC           21
+#define FM_DISABLE_RAM_ECC          22
+#define FM_SET_NUM_OF_FMAN_CTRL     23
+#define FM_SET_SIZE_OF_FIFO         24
+#define FM_SET_NUM_OF_TASKS         25
+#define FM_SET_NUM_OF_OPEN_DMAS     26
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define FM_10G_TX_ECC_WA            100
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+/***************************************************************************/
+/************************ BACK-END-TO-FRONT-END*****************************/
+/***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_GUEST_ISR
+
+ @Description   Used by FM back-end to report an interrupt to the front-end.
+
+ @Param[out]    t_FmIpcIsr Pointer
+*//***************************************************************************/
+#define FM_GUEST_ISR                1
+
+
+
+/** @} */ /* end of FM_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
new file mode 100644
index 0000000..a89a832
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -0,0 +1,145 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          FM_muram.c
+
+ @Description   FM MURAM ...
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mm_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+
+typedef struct
+{
+    t_Handle    h_Mem;
+    uintptr_t   baseAddr;
+    uint32_t    size;
+} t_FmMuram;
+
+#define __ERR_MODULE__  MODULE_FM_MURAM
+
+
+t_Handle FM_MURAM_ConfigAndInit(uintptr_t baseAddress, uint32_t size)
+{
+    t_Handle    h_Mem;
+    t_FmMuram   *p_FmMuram;
+
+    if(!baseAddress)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress 0 is not supported"));
+        return NULL;
+    }
+
+    if(baseAddress%4)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress not 4 bytes aligned!"));
+        return NULL;
+    }
+
+    /* Allocate FM MURAM structure */
+    p_FmMuram = (t_FmMuram *) XX_Malloc(sizeof(t_FmMuram));
+    if (!p_FmMuram)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MURAM driver structure"));
+        return NULL;
+    }
+    memset(p_FmMuram, 0, sizeof(t_FmMuram));
+
+
+    if ((MM_Init(&h_Mem, baseAddress, size) != E_OK) || (!h_Mem))
+    {
+        XX_Free(p_FmMuram);
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM partition!!!"));
+        return NULL;
+    }
+
+    /* Initialize FM MURAM parameters which will be kept by the driver */
+    p_FmMuram->baseAddr = baseAddress;
+    p_FmMuram->size = size;
+    p_FmMuram->h_Mem = h_Mem;
+
+    return p_FmMuram;
+}
+
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram)
+{
+    t_FmMuram   *p_FmMuram = ( t_FmMuram *)h_FmMuram;
+
+    if (p_FmMuram->h_Mem)
+        MM_Free(p_FmMuram->h_Mem);
+
+    XX_Free(h_FmMuram);
+
+    return E_OK;
+}
+
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align)
+{
+    t_FmMuram   *p_FmMuram = ( t_FmMuram *)h_FmMuram;
+    uintptr_t   addr;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmMuram, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmMuram->h_Mem, E_INVALID_HANDLE, NULL);
+
+    addr = (uintptr_t)MM_Get(p_FmMuram->h_Mem, size, align ,"FM MURAM");
+
+    if(addr == ILLEGAL_BASE)
+        return NULL;
+
+    return UINT_TO_PTR(addr);
+}
+
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr)
+{
+    t_FmMuram   *p_FmMuram = ( t_FmMuram *)h_FmMuram;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmMuram, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMuram->h_Mem, E_INVALID_HANDLE);
+
+    if (MM_Put(p_FmMuram->h_Mem, PTR_TO_UINT(ptr)) == 0)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, ("memory pointer!!!"));
+
+    return E_OK;
+}
+
+void FmMuramClear(t_Handle h_FmMuram)
+{
+    t_FmMuram   *p_FmMuram = ( t_FmMuram *)h_FmMuram;
+
+    SANITY_CHECK_RETURN(h_FmMuram, E_INVALID_HANDLE);
+    IOMemSet32(UINT_TO_PTR(p_FmMuram->baseAddr), 0, p_FmMuram->size);
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
new file mode 100644
index 0000000..0f19681
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -0,0 +1,1322 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_common.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_COMMON_H
+#define __FM_COMMON_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#ifdef FM_RMU_ASSIST_SUPPORT
+#include "fm_rmu_port_ext.h"
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+#define CLS_PLAN_NUM_PER_GRP                        8
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
+    volatile uint32_t fmpl_pemode;      /* 0x090 FMPL_PEMODE - FM Policer Profile Entry Mode*/
+    volatile uint32_t fmpl_pegnia;      /* 0x094 FMPL_PEGNIA - FM Policer Profile Entry GREEN Next Invoked Action*/
+    volatile uint32_t fmpl_peynia;      /* 0x098 FMPL_PEYNIA - FM Policer Profile Entry YELLOW Next Invoked Action*/
+    volatile uint32_t fmpl_pernia;      /* 0x09C FMPL_PERNIA - FM Policer Profile Entry RED Next Invoked Action*/
+    volatile uint32_t fmpl_pecir;       /* 0x0A0 FMPL_PECIR  - FM Policer Profile Entry Committed Information Rate*/
+    volatile uint32_t fmpl_pecbs;       /* 0x0A4 FMPL_PECBS  - FM Policer Profile Entry Committed Burst Size*/
+    volatile uint32_t fmpl_pepepir_eir; /* 0x0A8 FMPL_PEPIR_EIR - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pepbs_ebs;   /* 0x0AC FMPL_PEPBS_EBS - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pelts;       /* 0x0B0 FMPL_PELTS  - FM Policer Profile Entry Last TimeStamp*/
+    volatile uint32_t fmpl_pects;       /* 0x0B4 FMPL_PECTS  - FM Policer Profile Entry Committed Token Status*/
+    volatile uint32_t fmpl_pepts_ets;   /* 0x0B8 FMPL_PEPTS_ETS - FM Policer Profile Entry Peak/Excess Token Status*/
+    volatile uint32_t fmpl_pegpc;       /* 0x0BC FMPL_PEGPC  - FM Policer Profile Entry GREEN Packet Counter*/
+    volatile uint32_t fmpl_peypc;       /* 0x0C0 FMPL_PEYPC  - FM Policer Profile Entry YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perpc;       /* 0x0C4 FMPL_PERPC  - FM Policer Profile Entry RED Packet Counter */
+    volatile uint32_t fmpl_perypc;      /* 0x0C8 FMPL_PERYPC - FM Policer Profile Entry Recolored YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perrpc;      /* 0x0CC FMPL_PERRPC - FM Policer Profile Entry Recolored RED Packet Counter*/
+    volatile uint32_t fmpl_res1[12];    /* 0x0D0-0x0FF Reserved */
+} _PackedType t_FmPcdPlcrInterModuleProfileRegs;
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
+    volatile uint32_t kgse_mode;    /**< MODE */
+    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
+    volatile uint32_t kgse_hc;      /**< Hash Command */
+    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
+    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                   /**< Generic Extract Command */
+    volatile uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
+    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgInterModuleSchemeRegs;
+
+typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
+    volatile uint32_t                       portIdAndCapwapReassmTbl;
+    volatile uint32_t                       fqidForTimeOutFrames;
+    volatile uint32_t                       timeoutRequestTime;
+}_PackedType t_FmPcdCcCapwapReassmTimeoutParams;
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+typedef _Packed struct t_FmPcdCcIpReassmTimeoutParams {
+    volatile uint8_t                        subCmd;
+    volatile uint8_t                        result;
+    volatile uint8_t                        resereved1;
+    volatile uint8_t                        resereved2;
+    volatile uint32_t                       tsbsAndIprcpt;
+}_PackedType t_FmPcdCcIpReassmTimeoutParams;
+
+typedef _Packed struct t_FmPcdCcIpFragInitParams {
+    volatile uint8_t                        numBuffers;
+    volatile uint8_t                        resereved1;
+    volatile uint8_t                        resereved2;
+    volatile uint8_t                        resereved3;
+    volatile uint8_t                        bufferPoolId;
+}_PackedType t_FmPcdCcIpFragInitParams;
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+/**************************************************************************//**
+ @Description   RMU inbound doorbell initialization host command data
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuDrblInitHcData {
+    volatile    uint64_t    srioBaseAddr;
+    volatile    uint64_t    picBaseAddr;
+    volatile    uint64_t    keyMask;
+    volatile    uint32_t    inDrblClassTableBase;
+    volatile    uint32_t    inDrblIntQueueBase;
+    volatile    uint32_t    inDrblParamsTableBase;
+    volatile    uint16_t    liodnOffset1;
+    volatile    uint16_t    liodnOffset2;
+    volatile    uint16_t    liodnOffset3;
+    volatile    uint8_t     portId;
+    volatile    uint8_t     cevNum;
+    volatile    uint8_t     reserved[4];
+} _PackedType t_FmRmuDrblInitHcData;
+
+/**************************************************************************//**
+ @Description   RMU inbound doorbell set-counters (per-core) host command parameters
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuDrblSetCntsHcData {
+    volatile    uint32_t    msgrNum;
+    volatile    uint32_t    inDrblCntPtr;
+} _PackedType t_FmRmuDrblSetCntsHcData;
+
+/**************************************************************************//**
+ @Description   RMU inbound message initialization host command data
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuMsgInitHcData {
+    volatile    uint64_t    srioBaseAddr;
+    volatile    uint8_t     keyMask[FM_RMU_MSG_KEY_MASK_SIZE];
+    volatile    uint8_t     keyMaskOffset;
+    volatile    uint8_t     portId;
+    volatile    uint8_t     reserved;
+    volatile    uint8_t     modeReg;
+    volatile    uint32_t    inMsgClassTableBase;
+    volatile    uint32_t    bufferProfileTableBase;
+    volatile    uint32_t    internalBufferBase;
+    volatile    uint32_t    inMsgParamsTableBase;
+    volatile    uint16_t    srioRegsLiodnOffest;
+    volatile    uint16_t    inMsgQueueLiodnOffset;
+} _PackedType t_FmRmuMsgInitHcData;
+
+
+/**************************************************************************//**
+ @Description   RMU inbound message classification entry change command data
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuMsgClassChangeHcData {
+    volatile    uint32_t    classTableEntryData;
+    volatile    uint8_t     classTableEntryId;
+    volatile    uint8_t     classEntryChangeMode;
+    volatile    uint8_t     reserved[2];
+} _PackedType t_FmRmuMsgClassChangeHcData;
+
+
+/**************************************************************************//**
+ @Description   RMU inbound message buffer profile entry change command data
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuBufferProfileChangeHcData {
+    volatile    uint64_t    bufferProfileEntryData;
+    volatile    uint8_t     bufferProfileEntryId;
+    volatile    uint8_t     bufferProfileChangeMode;
+    volatile    uint8_t     reserved[6];
+} _PackedType t_FmRmuBufferProfileChangeHcData;
+
+/**************************************************************************//**
+ @Description   RMU inbound message free command data
+*//***************************************************************************/
+typedef _Packed struct t_FmRmuMsgFreeHcData {
+    volatile    uint8_t     modeReg;
+    volatile    uint8_t     reserved[3];
+} _PackedType t_FmRmuMsgFreeHcData;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+/**************************************************************************//**
+ @Description   RMU inbound doorbell initialization host command parameters
+*//***************************************************************************/
+typedef struct t_FmRmuDrblInitHcParams {
+    uint64_t    srioBaseAddr;
+    uint64_t    picBaseAddr;
+    uint64_t    keyMask;
+    uint32_t    inDrblClassTableBase;
+    uint32_t    inDrblIntQueueBase;
+    uint32_t    inDrblParamsTableBase;
+    uint16_t    liodnOffset1;
+    uint16_t    liodnOffset2;
+    uint16_t    liodnOffset3;
+    uint8_t     portId;
+    uint8_t     cevNum;
+
+} t_FmRmuDrblInitHcParams;
+
+
+/*******************************************************************************//**
+ @Description   RMU inbound doorbell set-counters (per-core) host command parameters
+*//********************************************************************************/
+typedef struct t_FmRmuDrblSetCntsHcParams {
+    uint8_t     msgrNum;
+    uint32_t    inDrblCntPtr;
+
+} t_FmRmuDrblSetCntsHcParams;
+
+
+/**************************************************************************//**
+ @Description   RMU inbound message initialization host command parameters
+*//***************************************************************************/
+typedef struct t_FmRmuMsgInitHcParams {
+    uint64_t    srioBaseAddr;
+    uint8_t     keyMask[FM_RMU_MSG_KEY_MASK_SIZE];
+    uint8_t     keyMaskOffset;
+    uint8_t     portId;
+    uint8_t     cevNum;
+    uint8_t     msgUnitId;
+    uint32_t    inMsgClassTableBase;
+    uint32_t    bufferProfileTableBase;
+    uint32_t    internalBufferBase;
+    uint32_t    inMsgParamsTableBase;
+    uint16_t    srioRegsLiodnOffest;
+    uint16_t    inMsgQueueLiodnOffset;
+
+} t_FmRmuMsgInitHcParams;
+
+
+/****************************************************************************//**
+ @Description   RMU inbound message classification entry change host command data
+*//*****************************************************************************/
+typedef struct t_FmRmuMsgClassChangeHcParams {
+    uint8_t     entryId;
+    bool        validate;
+    uint8_t     bufferProfileId;
+    uint32_t    fqId;
+    bool        isErrQueueChange;
+    uint8_t     mailboxId;
+
+} t_FmRmuMsgClassChangeHcParams;
+
+
+/****************************************************************************//**
+ @Description   RMU inbound message buffer profile entry change host command data
+*//*****************************************************************************/
+typedef struct t_FmRmuBufferProfileChangeHcParams {
+    uint8_t     entryId;
+    uint8_t     bufferPoolId;
+    uint32_t    buffersSize;
+    uint16_t    buffersOffset;
+    uint16_t    bufferPoolliodnOffset;
+    uint8_t     mailboxId;
+
+} t_FmRmuBufferProfileChangeHcParams;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+typedef struct {
+    uint8_t             baseEntry;
+    uint16_t            numOfClsPlanEntries;
+    uint32_t            vectors[FM_PCD_MAX_NUM_OF_CLS_PLANS];
+} t_FmPcdKgInterModuleClsPlanSet;
+
+/**************************************************************************//**
+ @Description   Structure for binding a port to keygen schemes.
+*//***************************************************************************/
+typedef struct t_FmPcdKgInterModuleBindPortToSchemes {
+    uint8_t     hardwarePortId;
+    uint8_t     netEnvId;
+    bool        useClsPlan;                 /**< TRUE if this port uses the clsPlan mechanism */
+    uint8_t     numOfSchemes;
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+} t_FmPcdKgInterModuleBindPortToSchemes;
+
+typedef struct {
+    uint32_t nextCcNodeInfo;
+    t_List   node;
+} t_CcNodeInfo;
+
+typedef struct
+{
+    t_Handle    h_CcNode;
+    uint16_t    index;
+    t_List      node;
+}t_CcNodeInformation;
+#define CC_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInformation, node)
+
+typedef struct
+{
+    t_Handle h_Manip;
+    t_List   node;
+}t_ManipInfo;
+#define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, node)
+
+typedef struct {
+    uint32_t    type;
+    uint8_t     prOffset;
+
+    uint16_t    dataOffset;
+    uint8_t     poolIndex;
+
+    uint8_t     poolIdForManip;
+    uint8_t     numOfTasks;
+
+    uint8_t     hardwarePortId;
+
+} t_GetCcParams;
+
+typedef struct {
+    uint32_t type;
+    int      psoSize;
+    uint32_t nia;
+
+} t_SetCcParams;
+
+typedef struct {
+    t_GetCcParams getCcParams;
+    t_SetCcParams setCcParams;
+} t_FmPortGetSetCcParams;
+
+
+static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
+{
+    uint32_t intFlags;
+    if (h_Spinlock)
+        intFlags = XX_LockIntrSpinlock(h_Spinlock);
+    else
+        intFlags = XX_DisableAllIntr();
+    if (*p_Flag)
+    {
+        if (h_Spinlock)
+            XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+        else
+            XX_RestoreAllIntr(intFlags);
+        return FALSE;
+    }
+    *p_Flag = TRUE;
+    if (h_Spinlock)
+        XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
+    else
+        XX_RestoreAllIntr(intFlags);
+    return TRUE;
+}
+
+#define RELEASE_LOCK(_flag) _flag = FALSE;
+
+/**************************************************************************//**
+ @Collection   Defines used for manipulation CC and BMI
+ @{
+*//***************************************************************************/
+#define INTERNAL_CONTEXT_OFFSET                 0x80000000
+#define OFFSET_OF_PR                            0x40000000
+#define BUFFER_POOL_ID_FOR_MANIP                0x20000000
+#define NUM_OF_TASKS                            0x10000000
+#define OFFSET_OF_DATA                          0x08000000
+#define HW_PORT_ID                              0x04000000
+
+
+#define UPDATE_NIA_PNEN                         0x80000000
+#define UPDATE_PSO                              0x40000000
+#define UPDATE_NIA_PNDN                         0x20000000
+#define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define UPDATE_NIA_RFENE                        0x04000000
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   Defines used for manipulation CC and CC
+ @{
+*//***************************************************************************/
+
+#define UPDATE_NIA_ENQ_WITHOUT_DMA              0x80000000
+#define UPDATE_CC_WITH_TREE                     0x40000000
+#define UPDATE_CC_WITH_DELETE_TREE              0x20000000
+//#define UPDATE_NIA_ENQ_WITH_DMA                 0x40000000
+/* @} */
+
+/**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+ @{
+*//***************************************************************************/
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000
+#define ERR_INTR_EN_FPM         0x80000000
+#define ERR_INTR_EN_BMI         0x00800000
+#define ERR_INTR_EN_QMI         0x00400000
+#define ERR_INTR_EN_PRS         0x00200000
+#define ERR_INTR_EN_KG          0x00100000
+#define ERR_INTR_EN_PLCR        0x00080000
+#define ERR_INTR_EN_MURAM       0x00040000
+#define ERR_INTR_EN_IRAM        0x00020000
+#define ERR_INTR_EN_10G_MAC0    0x00008000
+#define ERR_INTR_EN_1G_MAC0     0x00004000
+#define ERR_INTR_EN_1G_MAC1     0x00002000
+#define ERR_INTR_EN_1G_MAC2     0x00001000
+#define ERR_INTR_EN_1G_MAC3     0x00000800
+#define ERR_INTR_EN_MACSEC_MAC0 0x00000200
+
+
+typedef uint32_t t_FmBlockIntrEnable;
+
+#define INTR_EN_BMI             0x80000000
+#define INTR_EN_QMI             0x40000000
+#define INTR_EN_PRS             0x20000000
+#define INTR_EN_KG              0x10000000
+#define INTR_EN_PLCR            0x08000000
+#define INTR_EN_REV0            0x00008000
+#define INTR_EN_REV1            0x00004000
+#define INTR_EN_REV2            0x00002000
+#define INTR_EN_REV3            0x00001000
+#define INTR_EN_BRK             0x00000080
+#define INTR_EN_TMR             0x01000000
+#define INTR_EN_1G_MAC0_TMR     0x00080000
+#define INTR_EN_1G_MAC1_TMR     0x00040000
+#define INTR_EN_1G_MAC2_TMR     0x00020000
+#define INTR_EN_1G_MAC3_TMR     0x00010000
+#define INTR_EN_MACSEC_MAC0     0x00000001
+/* @} */
+
+#define FM_MAX_NUM_OF_PORTS         (FM_MAX_NUM_OF_OH_PORTS +       \
+                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
+                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)
+
+#define MODULE_NAME_SIZE            30
+#define DUMMY_PORT_ID               0
+
+#define FM_LIODN_OFFSET_MASK        0x3FF
+
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+
+#define NIA_ORDER_RESTOR            0x00800000
+#define NIA_ENG_FM_CTL              0x00000000
+#define NIA_ENG_PRS                 0x00440000
+#define NIA_ENG_KG                  0x00480000
+#define NIA_ENG_PLCR                0x004C0000
+#define NIA_ENG_BMI                 0x00500000
+#define NIA_ENG_QMI_ENQ             0x00540000
+#define NIA_ENG_QMI_DEQ             0x00580000
+#define NIA_ENG_MASK                0x007C0000
+
+#define NIA_FM_CTL_AC_CC                        0x00000006
+#define NIA_FM_CTL_AC_HC                        0x0000000C
+#define NIA_FM_CTL_AC_IND_MODE_TX               0x00000008
+#define NIA_FM_CTL_AC_IND_MODE_RX               0x0000000A
+#define NIA_FM_CTL_AC_FRAG                      0x0000000e
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define NIA_FM_CTL_AC_CLOSING_FRAG_CHECK        0x00800014
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+#define NIA_FM_CTL_AC_PRE_FETCH                 0x00000010
+#define NIA_FM_CTL_AC_POST_FETCH_PCD            0x00000012
+#define NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN    0x00000018
+#define NIA_FM_CTL_AC_POST_FETCH_NO_PCD         0x00000012
+#define NIA_FM_CTL_AC_FRAG_CHECK                0x00000014
+#define NIA_FM_CTL_AC_MASK                      0x0000001f
+
+#define NIA_BMI_AC_ENQ_FRAME        0x00000002
+#define NIA_BMI_AC_TX_RELEASE       0x000002C0
+#define NIA_BMI_AC_RELEASE          0x000000C0
+#define NIA_BMI_AC_DISCARD          0x000000C1
+#define NIA_BMI_AC_TX               0x00000274
+#define NIA_BMI_AC_FETCH            0x00000208
+#define NIA_BMI_AC_MASK             0x000003FF
+
+#define NIA_KG_DIRECT               0x00000100
+#define NIA_KG_CC_EN                0x00000200
+#define NIA_PLCR_ABSOLUTE           0x00008000
+
+#define NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA    0x00000202
+
+/**************************************************************************//**
+ @Description       Port Id defines
+*//***************************************************************************/
+#define BASE_OH_PORTID              1
+#define BASE_1G_RX_PORTID           8
+#define BASE_10G_RX_PORTID          0x10
+#define BASE_1G_TX_PORTID           0x28
+#define BASE_10G_TX_PORTID          0x30
+
+#define FM_PCD_PORT_OH_BASE_INDX        0
+#define FM_PCD_PORT_1G_RX_BASE_INDX     (FM_PCD_PORT_OH_BASE_INDX+FM_MAX_NUM_OF_OH_PORTS)
+#define FM_PCD_PORT_10G_RX_BASE_INDX    (FM_PCD_PORT_1G_RX_BASE_INDX+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_PCD_PORT_1G_TX_BASE_INDX     (FM_PCD_PORT_10G_RX_BASE_INDX+FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_PCD_PORT_10G_TX_BASE_INDX    (FM_PCD_PORT_1G_TX_BASE_INDX+FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define SW_PORT_ID_TO_HW_PORT_ID(port, type, relativePortId)            \
+switch(type){                                                           \
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                            \
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):                               \
+        if ((relativePortId) >= FM_MAX_NUM_OF_OH_PORTS)                 \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id"));  \
+        port = (uint8_t)(BASE_OH_PORTID + (relativePortId));            \
+        break;                                                          \
+    case(e_FM_PORT_TYPE_RX):                                            \
+        if ((relativePortId) >= FM_MAX_NUM_OF_1G_RX_PORTS)              \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id"));  \
+        port = (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));         \
+        break;                                                          \
+    case(e_FM_PORT_TYPE_RX_10G):                                        \
+        if ((relativePortId) >= FM_MAX_NUM_OF_10G_RX_PORTS)             \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id"));  \
+        port = (uint8_t)(BASE_10G_RX_PORTID + (relativePortId));        \
+        break;                                                          \
+    case(e_FM_PORT_TYPE_TX):                                            \
+        if ((relativePortId) >= FM_MAX_NUM_OF_1G_TX_PORTS)              \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id"));  \
+        port = (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));         \
+        break;                                                          \
+    case(e_FM_PORT_TYPE_TX_10G):                                        \
+        if ((relativePortId) >= FM_MAX_NUM_OF_10G_TX_PORTS)             \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id"));  \
+        port = (uint8_t)(BASE_10G_TX_PORTID + (relativePortId));        \
+        break;                                                          \
+    default:                                                            \
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));    \
+        break;                                                          \
+}
+
+#define HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId)                                                                \
+{   if (((hardwarePortId) >= BASE_OH_PORTID) && ((hardwarePortId) < BASE_OH_PORTID+FM_MAX_NUM_OF_OH_PORTS))                     \
+        relativePortId = (uint8_t)((hardwarePortId)-BASE_OH_PORTID);                                                            \
+    else if (((hardwarePortId) >= BASE_10G_TX_PORTID) && ((hardwarePortId) < BASE_10G_TX_PORTID+FM_MAX_NUM_OF_10G_TX_PORTS))    \
+        relativePortId = (uint8_t)((hardwarePortId)-BASE_10G_TX_PORTID);                                                        \
+    else if (((hardwarePortId) >= BASE_1G_TX_PORTID) && ((hardwarePortId) < BASE_1G_TX_PORTID+FM_MAX_NUM_OF_1G_TX_PORTS))       \
+        relativePortId = (uint8_t)((hardwarePortId)-BASE_1G_TX_PORTID);                                                         \
+    else if (((hardwarePortId) >= BASE_10G_RX_PORTID) && ((hardwarePortId) < BASE_10G_RX_PORTID+FM_MAX_NUM_OF_10G_RX_PORTS))    \
+        relativePortId = (uint8_t)((hardwarePortId)-BASE_10G_RX_PORTID);                                                        \
+    else if (((hardwarePortId) >= BASE_1G_RX_PORTID) && ((hardwarePortId) < BASE_1G_RX_PORTID+FM_MAX_NUM_OF_1G_RX_PORTS))       \
+        relativePortId = (uint8_t)((hardwarePortId)-BASE_1G_RX_PORTID);                                                         \
+    else {                                                                                                                      \
+        relativePortId = (uint8_t)DUMMY_PORT_ID;                                                                                \
+        ASSERT_COND(TRUE);                                                                                                      \
+    }                                                                                                                           \
+}
+
+#define HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId)                                             \
+do {                                                                                                        \
+    if (((hardwarePortId) >= BASE_OH_PORTID) && ((hardwarePortId) < BASE_OH_PORTID+FM_MAX_NUM_OF_OH_PORTS)) \
+        swPortIndex = (uint8_t)((hardwarePortId)-BASE_OH_PORTID+FM_PCD_PORT_OH_BASE_INDX);                  \
+    else if (((hardwarePortId) >= BASE_1G_RX_PORTID) &&                                                     \
+             ((hardwarePortId) < BASE_1G_RX_PORTID+FM_MAX_NUM_OF_1G_RX_PORTS))                              \
+        swPortIndex = (uint8_t)((hardwarePortId)-BASE_1G_RX_PORTID+FM_PCD_PORT_1G_RX_BASE_INDX);            \
+    else if (((hardwarePortId) >= BASE_10G_RX_PORTID) &&                                                    \
+             ((hardwarePortId) < BASE_10G_RX_PORTID+FM_MAX_NUM_OF_10G_RX_PORTS))                            \
+        swPortIndex = (uint8_t)((hardwarePortId)-BASE_10G_RX_PORTID+FM_PCD_PORT_10G_RX_BASE_INDX);          \
+    else if (((hardwarePortId) >= BASE_1G_TX_PORTID) &&                                                     \
+             ((hardwarePortId) < BASE_1G_TX_PORTID+FM_MAX_NUM_OF_1G_TX_PORTS))                              \
+        swPortIndex = (uint8_t)((hardwarePortId)-BASE_1G_TX_PORTID+FM_PCD_PORT_1G_TX_BASE_INDX);            \
+    else if (((hardwarePortId) >= BASE_10G_TX_PORTID) &&                                                    \
+             ((hardwarePortId) < BASE_10G_TX_PORTID+FM_MAX_NUM_OF_10G_TX_PORTS))                            \
+        swPortIndex = (uint8_t)((hardwarePortId)-BASE_10G_TX_PORTID+FM_PCD_PORT_10G_TX_BASE_INDX);          \
+    else ASSERT_COND(FALSE);                                                                                \
+} while (0)
+
+#define SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, swPortIndex)                                                 \
+do {                                                                                                            \
+    if (((swPortIndex) >= FM_PCD_PORT_OH_BASE_INDX) && ((swPortIndex) < FM_PCD_PORT_1G_RX_BASE_INDX))           \
+        hardwarePortId = (uint8_t)((swPortIndex)-FM_PCD_PORT_OH_BASE_INDX+BASE_OH_PORTID);                      \
+    else if (((swPortIndex) >= FM_PCD_PORT_1G_RX_BASE_INDX) && ((swPortIndex) < FM_PCD_PORT_10G_RX_BASE_INDX))  \
+        hardwarePortId = (uint8_t)((swPortIndex)-FM_PCD_PORT_1G_RX_BASE_INDX+BASE_1G_RX_PORTID);                \
+    else if (((swPortIndex) >= FM_PCD_PORT_10G_RX_BASE_INDX) && ((swPortIndex) < FM_MAX_NUM_OF_PORTS))          \
+        hardwarePortId = (uint8_t)((swPortIndex)-FM_PCD_PORT_10G_RX_BASE_INDX+BASE_10G_RX_PORTID);              \
+    else if (((swPortIndex) >= FM_PCD_PORT_1G_TX_BASE_INDX) && ((swPortIndex) < FM_PCD_PORT_10G_TX_BASE_INDX))  \
+        hardwarePortId = (uint8_t)((swPortIndex)-FM_PCD_PORT_1G_TX_BASE_INDX+BASE_1G_TX_PORTID);                \
+    else if (((swPortIndex) >= FM_PCD_PORT_10G_TX_BASE_INDX) && ((swPortIndex) < FM_MAX_NUM_OF_PORTS))          \
+        hardwarePortId = (uint8_t)((swPortIndex)-FM_PCD_PORT_10G_TX_BASE_INDX+BASE_10G_TX_PORTID);              \
+    else ASSERT_COND(FALSE);                                                                                    \
+} while (0)
+
+#define BMI_FIFO_UNITS                      0x100
+
+typedef struct {
+    void        (*f_Isr) (t_Handle h_Arg);
+    t_Handle    h_SrcHandle;
+    uint8_t     guestId;
+} t_FmIntrSrc;
+
+#define ILLEGAL_HDR_NUM                     0xFF
+#define NO_HDR_NUM                          FM_PCD_PRS_NUM_OF_HDRS
+
+#define IS_PRIVATE_HEADER(hdr)              (((hdr) == HEADER_TYPE_USER_DEFINED_SHIM1) ||   \
+                                             ((hdr) == HEADER_TYPE_USER_DEFINED_SHIM2))
+#define IS_SPECIAL_HEADER(hdr)              ((hdr) == HEADER_TYPE_MACSEC)
+
+#define GET_PRS_HDR_NUM(num, hdr)                           \
+switch(hdr)                                                 \
+{   case(HEADER_TYPE_ETH):              num = 0;  break;    \
+    case(HEADER_TYPE_LLC_SNAP):         num = 1;  break;    \
+    case(HEADER_TYPE_VLAN):             num = 2;  break;    \
+    case(HEADER_TYPE_PPPoE):            num = 3;  break;    \
+    case(HEADER_TYPE_MPLS):             num = 4;  break;    \
+    case(HEADER_TYPE_IPv4):             num = 5;  break;    \
+    case(HEADER_TYPE_IPv6):             num = 6;  break;    \
+    case(HEADER_TYPE_GRE):              num = 7;  break;    \
+    case(HEADER_TYPE_MINENCAP):         num = 8;  break;    \
+    case(HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;    \
+    case(HEADER_TYPE_TCP):              num = 10; break;    \
+    case(HEADER_TYPE_UDP):              num = 11; break;    \
+    case(HEADER_TYPE_IPSEC_AH):                             \
+    case(HEADER_TYPE_IPSEC_ESP):        num = 12; break;    \
+    case(HEADER_TYPE_SCTP):             num = 13; break;    \
+    case(HEADER_TYPE_DCCP):             num = 14; break;    \
+    case(HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;    \
+    case(HEADER_TYPE_USER_DEFINED_SHIM1):                   \
+    case(HEADER_TYPE_USER_DEFINED_SHIM2):                   \
+    case(HEADER_TYPE_MACSEC):                               \
+        num = NO_HDR_NUM; break;                            \
+    default:                                                \
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
+        num = ILLEGAL_HDR_NUM; break;                       \
+}
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+#define FM_PCD_PLCR_PAR_GO                    0x80000000
+#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
+#define FM_PCD_PLCR_PAR_R                     0x40000000
+
+/* shifts */
+#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* maskes */
+#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_NO_GEN                        0x10000000
+#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
+#define KG_SCH_MODE_NIA_PLCR                    0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_SCH_BITMASK_MASK                     0x000000FF
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_MASK                         0x00FF0000
+#define FM_PCD_KG_KGAR_ERR                      0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
+#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
+
+#define FM_PCD_KG_KGAR_GO                       0x80000000
+#define FM_PCD_KG_KGAR_READ                     0x40000000
+#define FM_PCD_KG_KGAR_WRITE                    0x00000000
+#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
+#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
+
+
+typedef uint32_t t_KnownFieldsMasks;
+
+#define KG_SCH_KN_PORT_ID                   0x80000000
+#define KG_SCH_KN_MACDST                    0x40000000
+#define KG_SCH_KN_MACSRC                    0x20000000
+#define KG_SCH_KN_TCI1                      0x10000000
+#define KG_SCH_KN_TCI2                      0x08000000
+#define KG_SCH_KN_ETYPE                     0x04000000
+#define KG_SCH_KN_PPPSID                    0x02000000
+#define KG_SCH_KN_PPPID                     0x01000000
+#define KG_SCH_KN_MPLS1                     0x00800000
+#define KG_SCH_KN_MPLS2                     0x00400000
+#define KG_SCH_KN_MPLS_LAST                 0x00200000
+#define KG_SCH_KN_IPSRC1                    0x00100000
+#define KG_SCH_KN_IPDST1                    0x00080000
+#define KG_SCH_KN_PTYPE1                    0x00040000
+#define KG_SCH_KN_IPTOS_TC1                 0x00020000
+#define KG_SCH_KN_IPV6FL1                   0x00010000
+#define KG_SCH_KN_IPSRC2                    0x00008000
+#define KG_SCH_KN_IPDST2                    0x00004000
+#define KG_SCH_KN_PTYPE2                    0x00002000
+#define KG_SCH_KN_IPTOS_TC2                 0x00001000
+#define KG_SCH_KN_IPV6FL2                   0x00000800
+#define KG_SCH_KN_GREPTYPE                  0x00000400
+#define KG_SCH_KN_IPSEC_SPI                 0x00000200
+#define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_L4PSRC                    0x00000004
+#define KG_SCH_KN_L4PDST                    0x00000002
+#define KG_SCH_KN_TFLG                      0x00000001
+
+typedef uint8_t t_GenericCodes;
+
+#define KG_SCH_GEN_SHIM1                       0x70
+#define KG_SCH_GEN_DEFAULT                     0x10
+#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
+#define KG_SCH_GEN_START_OF_FRM                0x40
+#define KG_SCH_GEN_SHIM2                       0x71
+#define KG_SCH_GEN_IP_PID_NO_V                 0x72
+#define KG_SCH_GEN_ETH                         0x03
+#define KG_SCH_GEN_ETH_NO_V                    0x73
+#define KG_SCH_GEN_SNAP                        0x04
+#define KG_SCH_GEN_SNAP_NO_V                   0x74
+#define KG_SCH_GEN_VLAN1                       0x05
+#define KG_SCH_GEN_VLAN1_NO_V                  0x75
+#define KG_SCH_GEN_VLAN2                       0x06
+#define KG_SCH_GEN_VLAN2_NO_V                  0x76
+#define KG_SCH_GEN_ETH_TYPE                    0x07
+#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
+#define KG_SCH_GEN_PPP                         0x08
+#define KG_SCH_GEN_PPP_NO_V                    0x78
+#define KG_SCH_GEN_MPLS1                       0x09
+#define KG_SCH_GEN_MPLS2                       0x19
+#define KG_SCH_GEN_MPLS3                       0x29
+#define KG_SCH_GEN_MPLS1_NO_V                  0x79
+#define KG_SCH_GEN_MPLS_LAST                   0x0a
+#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
+#define KG_SCH_GEN_IPV4                        0x0b
+#define KG_SCH_GEN_IPV6                        0x1b
+#define KG_SCH_GEN_L3_NO_V                     0x7b
+#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
+#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
+#define KG_SCH_GEN_MIN_ENCAP                   0x2c
+#define KG_SCH_GEN_IP2_NO_V                    0x7c
+#define KG_SCH_GEN_GRE                         0x0d
+#define KG_SCH_GEN_GRE_NO_V                    0x7d
+#define KG_SCH_GEN_TCP                         0x0e
+#define KG_SCH_GEN_UDP                         0x1e
+#define KG_SCH_GEN_IPSEC_AH                    0x2e
+#define KG_SCH_GEN_SCTP                        0x3e
+#define KG_SCH_GEN_DCCP                        0x4e
+#define KG_SCH_GEN_IPSEC_ESP                   0x6e
+#define KG_SCH_GEN_L4_NO_V                     0x7e
+#define KG_SCH_GEN_NEXTHDR                     0x7f
+
+/* shifts */
+#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
+#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
+#define KG_SCH_PP_MASK_SHIFT                16
+#define KG_SCH_MODE_CCOBASE_SHIFT           24
+#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
+#define KG_SCH_DEF_TCI_SHIFT                28
+#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
+#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
+#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
+#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
+#define KG_SCH_DEF_IP_ADDR_SHIFT            18
+#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
+#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
+#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
+#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
+#define KG_SCH_DEF_L4_PORT_SHIFT            8
+#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
+#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
+#define KG_SCH_GEN_MASK_SHIFT               16
+#define KG_SCH_GEN_HT_SHIFT                 8
+#define KG_SCH_GEN_SIZE_SHIFT               24
+#define KG_SCH_GEN_DEF_SHIFT                29
+#define FM_PCD_KG_KGAR_NUM_SHIFT            16
+
+
+/* others */
+#define NUM_OF_SW_DEFAULTS                  3
+#define MAX_PP_SHIFT                        15
+#define MAX_KG_SCH_SIZE                     16
+#define MASK_FOR_GENERIC_BASE_ID            0x20
+#define MAX_HASH_SHIFT                      40
+#define MAX_KG_SCH_FQID_BIT_OFFSET          31
+#define MAX_KG_SCH_PP_BIT_OFFSET            15
+#define MAX_DIST_FQID_SHIFT                 23
+
+#define GET_MASK_SEL_SHIFT(shift,i)             \
+switch(i) {                                     \
+    case(0):shift = 26;break;                   \
+    case(1):shift = 20;break;                   \
+    case(2):shift = 10;break;                   \
+    case(3):shift = 4;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_OFFSET_SHIFT(shift,i)          \
+switch(i) {                                     \
+    case(0):shift = 16;break;                   \
+    case(1):shift = 0;break;                    \
+    case(2):shift = 28;break;                   \
+    case(3):shift = 24;break;                   \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_SHIFT(shift,i)                 \
+switch(i) {                                     \
+    case(0):shift = 24;break;                   \
+    case(1):shift = 16;break;                   \
+    case(2):shift = 8;break;                    \
+    case(3):shift = 0;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
+
+typedef struct {
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} t_FmPortPcdInterModulePlcrParams;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct t_FmPcdKgInterModuleClsPlanGrpParams {
+    uint8_t         netEnvId;   /* IN */
+    bool            grpExists;  /* OUT (unused in FmPcdKgBuildClsPlanGrp)*/
+    uint8_t         clsPlanGrpId;  /* OUT */
+    bool            emptyClsPlanGrp; /* OUT */
+    uint8_t         numOfOptions;   /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+    protocolOpt_t   options[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+                                    /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+    uint32_t        optVectors[FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)];
+                               /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
+} t_FmPcdKgInterModuleClsPlanGrpParams;
+
+typedef struct t_FmInterModulePortRxPoolsParams
+{
+    uint8_t     numOfPools;
+    uint16_t    secondLargestBufSize;
+    uint16_t    largestBufSize;
+} t_FmInterModulePortRxPoolsParams;
+
+
+typedef t_Error (t_FmPortGetSetCcParamsCallback) (t_Handle                  h_FmPort,
+                                                  t_FmPortGetSetCcParams    *p_FmPortGetSetCcParams);
+
+
+t_Handle    FmPcdGetHcHandle(t_Handle h_FmPcd);
+uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
+uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
+uint32_t    FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId);
+void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
+uint32_t    FmPcdLock(t_Handle h_FmPcd);
+void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
+bool        FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
+
+t_Error     FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges, t_Handle *h_Params);
+uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_Params);
+t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
+uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
+t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
+void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
+void        FmPcdCcNodeTreeReleaseLock(t_List *p_List);
+t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree, uint8_t   manipIndx);
+void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams, uint8_t   manipIndx);
+
+bool        FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
+t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
+uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
+void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
+void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+bool        FmPcdKgIsDriverClsPlan(t_Handle h_FmPcd);
+bool        FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg);
+uint32_t    FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter);
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId);
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
+uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
+t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr);
+void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgUpatePointedOwner(t_Handle h_FmPcd, uint8_t schemeId, bool add);
+
+t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
+t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
+uint32_t    FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId);
+uint32_t    FmPcdKgGetPointedOwners(t_Handle h_FmPcd, uint8_t schemeId);
+e_FmPcdDoneAction FmPcdKgGetDoneAction(t_Handle h_FmPcd, uint8_t schemeId);
+e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgUpdateRequiredAction(t_Handle h_FmPcd, uint8_t schemeId, uint32_t requiredAction);
+bool        FmPcdKgIsDirectPlcr(t_Handle h_FmPcd, uint8_t schemeId);
+bool        FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId);
+uint16_t    FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId);
+
+/* FM-PCD parser API routines */
+t_Error     FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
+
+/* FM-PCD policer API routines */
+t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
+t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+bool        FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+uint16_t    FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint16_t    FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint32_t    FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
+uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
+t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+                                          e_FmPcdProfileTypeSelection   profileType,
+                                          t_Handle                      h_FmPort,
+                                          uint16_t                      relativeProfile,
+                                          uint16_t                      *p_AbsoluteId);
+void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
+t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
+void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);
+uint32_t    FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+void        FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add);
+uint32_t    FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red);
+void        FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId, uint32_t requiredAction);
+
+/* FM-PCD Coarse-Classification API routines */
+uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
+uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
+
+t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
+t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
+uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
+t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
+t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
+t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction);
+
+uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
+uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
+uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
+void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
+t_Error     FmPortAttachPCD(t_Handle h_FmPort);
+t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
+t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+uint8_t     FmHcRmuMsgInitBuildModeReg(uint8_t cevNum, uint8_t msgUnitId);
+uint8_t     FmHcRmuMsgClassificationBuildModeReg (bool isErrQueueChange, uint8_t msgUnitId);
+uint32_t    FmHcRmuMsgBuildClassificationEntry (bool validate, uint8_t bufferProfileId, uint32_t fqId);
+uint64_t    FmHcRmuMsgBuildBufferProfileEntry (uint8_t bpId, uint32_t bufferSize, uint16_t bufferOffset, uint16_t liodnOffset);
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+/**************************************************************************//**
+ @Function      FmRegisterIntr
+
+ @Description   Used to register an inter-module event handler to be processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     mod             The module that causes the event
+ @Param[in]     modId           Module id - if more than 1 instansiation of this
+                                mode exists,0 otherwise.
+ @Param[in]     intrType        Interrupt type (error/normal) selection.
+ @Param[in]     f_Isr           The interrupt service routine.
+ @Param[in]     h_Arg           Argument to be passed to f_Isr.
+
+ @Return        None.
+*//***************************************************************************/
+void FmRegisterIntr(t_Handle                h_Fm,
+                    e_FmEventModules       mod,
+                    uint8_t                modId,
+                    e_FmIntrType           intrType,
+                    void                   (*f_Isr) (t_Handle h_Arg),
+                    t_Handle               h_Arg);
+
+/**************************************************************************//**
+ @Function      FmUnregisterIntr
+
+ @Description   Used to un-register an inter-module event handler that was processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     mod             The module that causes the event
+ @Param[in]     modId           Module id - if more than 1 instansiation of this
+                                mode exists,0 otherwise.
+ @Param[in]     intrType        Interrupt type (error/normal) selection.
+
+ @Return        None.
+*//***************************************************************************/
+void FmUnregisterIntr(t_Handle          h_Fm,
+                      e_FmEventModules  mod,
+                      uint8_t           modId,
+                      e_FmIntrType      intrType);
+
+/**************************************************************************//**
+ @Function      FmRegisterFmCtlIntr
+
+ @Description   Used to register to one of the fmCtl events in the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     eventRegId      FmCtl event id (0-7).
+ @Param[in]     f_Isr           The interrupt service routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum e_FmMacType {
+    e_FM_MAC_10G = 0,               /**< 10G MAC */
+    e_FM_MAC_1G                     /**< 1G MAC */
+} e_FmMacType;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortInitParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint16_t            liodnOffset;        /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    uint16_t            liodnBase;          /**< IN. Irrelevant for P4080 rev 1.
+                                                 LIODN base for this port, to be
+                                                 used together with LIODN offset. */
+#ifdef FM_RMU_ASSIST_SUPPORT
+    bool                isRmuDoorbell;
+    bool                isRmuMailbox0;
+    bool                isRmuMailbox1;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+    t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmInterModulePortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortFreeParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+#ifdef FM_RMU_ASSIST_SUPPORT
+    bool                isRmuDoorbell;
+    bool                isRmuMailbox0;
+    bool                isRmuMailbox1;
+#endif /* FM_RMU_ASSIST_SUPPORT */
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+} t_FmInterModulePortFreeParams;
+
+/**************************************************************************//**
+ @Function      FmGetPcdPrsBaseAddr
+
+ @Description   Get the base address of the Parser from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uintptr_t FmGetPcdPrsBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdKgBaseAddr
+
+ @Description   Get the base address of the Keygen from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uintptr_t FmGetPcdKgBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdPlcrBaseAddr
+
+ @Description   Get the base address of the Policer from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uintptr_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetMuramHandle
+
+ @Description   Get the handle of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        MURAM module handle.
+*//***************************************************************************/
+t_Handle FmGetMuramHandle(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPhysicalMuramBase
+
+ @Description   Get the physical base address of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     fmPhysAddr      Physical MURAM base
+
+ @Return        Physical base address.
+*//***************************************************************************/
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
+
+/**************************************************************************//**
+ @Function      FmGetTimeStampScale
+
+ @Description   Used internally by other modules in order to get the timeStamp
+                period as requested by the application.
+
+ @Param[in]     h_Fm                    A handle to an FM Module.
+
+ @Return        TimeStamp period in nanoseconds.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t    FmGetTimeStampScale(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmResumeStalledPort
+
+ @Description   Used internally by FM port to release a stalled port.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmIsPortStalled
+
+ @Description   Used internally by FM port to read the port's status.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                  HW port id.
+ @Param[in]     p_IsStalled                     A pointer to the boolean port stalled state
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled);
+
+/**************************************************************************//**
+ @Function      FmResetMac
+
+ @Description   Used by MAC driver to reset the MAC registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     type            MAC type.
+ @Param[in]     macId           MAC id - according to type.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
+
+/**************************************************************************//**
+ @Function      FmGetClockFreq
+
+ @Description   Used by MAC driver to get the FM clock frequency
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        clock-freq on success; 0 otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint16_t FmGetClockFreq(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetId
+
+ @Description   Used by PCD driver to read rhe FM id
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint8_t FmGetId(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetSetPortParams
+
+ @Description   Used by FM-PORT driver to pass and receive parameters between
+                PORT and FM modules.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams);
+
+/**************************************************************************//**
+ @Function      FmFreePortParams
+
+ @Description   Used by FM-PORT driver to free port's resources within the FM.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
+
+/**************************************************************************//**
+ @Function      FmSetPortToWorkWithOneRiscOnly
+
+ @Description   Used by FM-PORT driver to pass parameter between
+                PORT and FM modules for working with number of RISC..
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls);
+
+
+void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
+void        FmUnregisterPcd(t_Handle h_Fm);
+t_Handle    FmGetPcdHandle(t_Handle h_Fm);
+bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
+t_Error     FmEnableRamsEcc(t_Handle h_Fm);
+t_Error     FmDisableRamsEcc(t_Handle h_Fm);
+void        FmGetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+t_Error     FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId);
+void        FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId);
+void        FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvents);
+uint32_t    FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId);
+void        FmRegisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event), t_Handle    h_Arg);
+void        FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId);
+t_Error     FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu);
+bool        FmIsMaster(t_Handle h_Fm);
+uint8_t     FmGetGuestId(t_Handle h_Fm);
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+t_Error     Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId);
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+void        FmMuramClear(t_Handle h_FmMuram);
+t_Error     FmSetNumOfOpenDmas(t_Handle h_Fm,
+                                uint8_t hardwarePortId,
+                                uint8_t numOfOpenDmas,
+                                uint8_t numOfExtraOpenDmas,
+                                bool    initialConfig);
+t_Error     FmSetNumOfTasks(t_Handle    h_Fm,
+                                uint8_t     hardwarePortId,
+                                uint8_t     numOfTasks,
+                                uint8_t     numOfExtraTasks,
+                                bool        initialConfig);
+t_Error     FmSetSizeOfFifo(t_Handle            h_Fm,
+                            uint8_t             hardwarePortId,
+                            e_FmPortType        portType,
+                            bool                independentMode,
+                            uint32_t            *p_SizeOfFifo,
+                            uint32_t            extraSizeOfFifo,
+                            uint8_t             deqPipelineDepth,
+                            t_FmInterModulePortRxPoolsParams    *p_RxPoolsParams,
+                            bool                initialConfig);
+
+
+#endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
new file mode 100644
index 0000000..c846b69
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_HC_H
+#define __FM_HC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_PCD
+
+
+typedef struct t_FmHcParams {
+    t_Handle        h_Fm;
+    t_Handle        h_FmPcd;
+    t_FmPcdHcParams params;
+} t_FmHcParams;
+
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
+void        FmHcFree(t_Handle h_FmHc);
+t_Error     FmHcDumpRegs(t_Handle h_FmHc);
+
+void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
+
+t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
+t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+t_Error     FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams );
+t_Error     FmHcPcdCcIpFrag(t_Handle h_FmHc, t_FmPcdCcIpFragInitParams *p_CcIpFragInitialization);
+#endif /*UNDER_CONSTRUCTION_FRAG_REASSEMBLY*/
+t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
+//t_Handle    FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp);
+t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
+
+t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value);
+uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
+
+t_Error     FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex);
+t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+t_Handle    FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile);
+t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
+
+t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+uint32_t    FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+t_Error     FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add);
+t_Error     FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg);
+
+t_Error     FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction);
+t_Error     FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction);
+
+#ifdef FM_RMU_ASSIST_SUPPORT
+t_Error     FmHcRmuDoorbellInitCmd(t_Handle h_FmHc, t_FmRmuDrblInitHcParams *p_DrblInitHcParams);
+t_Error     FmHcRmuDoorbellSetCntsCmd(t_Handle h_FmHc, t_FmRmuDrblSetCntsHcParams *p_DrblSetCntsHcParams);
+t_Error     FmHcRmuDoorbellFreeCmd(t_Handle h_FmHc);
+
+t_Error     FmHcRmuMsgInitCmd(t_Handle h_FmHc, t_FmRmuMsgInitHcParams *p_MsgInitHcParams);
+t_Error     FmHcRmuBufferProfileChange(t_Handle h_FmHc, t_FmRmuBufferProfileChangeHcParams *p_HcParams);
+t_Error     FmHcRmuMsgClassChange(t_Handle h_FmHc, t_FmRmuMsgClassChangeHcParams *p_HcParams);
+t_Error     FmHcRmuMsgFreeCmd(t_Handle h_FmHc, uint8_t  mailboxId);
+#endif /* FM_RMU_ASSIST_SUPPORT */
+
+#endif /* __FM_HC_H */
diff --git a/drivers/net/dpa/NetCommSw/etc/Makefile b/drivers/net/dpa/NetCommSw/etc/Makefile
new file mode 100644
index 0000000..ed10553
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-etc.o
+
+fsl-ncsw-etc-objs	:= mm.o memcpy.o sprint.o list.o error.o
diff --git a/drivers/net/dpa/NetCommSw/etc/error.c b/drivers/net/dpa/NetCommSw/etc/error.c
new file mode 100644
index 0000000..896722f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/error.c
@@ -0,0 +1,118 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+
+ @File          error.c
+
+ @Description   General errors and events reporting utilities.
+*//***************************************************************************/
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+const char *dbgLevelStrings[] =
+{
+     "CRITICAL"
+    ,"MAJOR"
+    ,"MINOR"
+    ,"WARNING"
+    ,"INFO"
+    ,"TRACE"
+};
+
+const char *errTypeStrings[] =
+{
+     "Invalid State"                        /* E_INVALID_STATE */
+    ,"Invalid Operation"                    /* E_INVALID_OPERATION */
+    ,"Unsupported Operation"                /* E_NOT_SUPPORTED */
+    ,"No Device"                            /* E_NO_DEVICE */
+    ,"Invalid Handle"                       /* E_INVALID_HANDLE */
+    ,"Invalid ID"                           /* E_INVALID_ID */
+    ,"Unexpected NULL Pointer"              /* E_NULL_POINTER */
+    ,"Invalid Value"                        /* E_INVALID_VALUE */
+    ,"Invalid Selection"                    /* E_INVALID_SELECTION */
+    ,"Invalid Communication Mode"           /* E_INVALID_COMM_MODE */
+    ,"Invalid Byte Order"                   /* E_INVALID_BYTE_ORDER */
+    ,"Invalid Memory Type"                  /* E_INVALID_MEMORY_TYPE */
+    ,"Invalid Interrupt Queue"              /* E_INVALID_INTR_QUEUE */
+    ,"Invalid Priority"                     /* E_INVALID_PRIORITY */
+    ,"Invalid Clock"                        /* E_INVALID_CLOCK */
+    ,"Invalid Rate"                         /* E_INVALID_RATE */
+    ,"Invalid Address"                      /* E_INVALID_ADDRESS */
+    ,"Invalid Bus"                          /* E_INVALID_BUS */
+    ,"Conflict In Bus Selection"            /* E_BUS_CONFLICT */
+    ,"Conflict In Settings"                 /* E_CONFLICT */
+    ,"Incorrect Alignment"                  /* E_NOT_ALIGNED */
+    ,"Value Out Of Range"                   /* E_NOT_IN_RANGE */
+    ,"Invalid Frame"                        /* E_INVALID_FRAME */
+    ,"Frame Is Empty"                       /* E_EMPTY_FRAME */
+    ,"Buffer Is Empty"                      /* E_EMPTY_BUFFER */
+    ,"Memory Allocation Failed"             /* E_NO_MEMORY */
+    ,"Resource Not Found"                   /* E_NOT_FOUND */
+    ,"Resource Is Unavailable"              /* E_NOT_AVAILABLE */
+    ,"Resource Already Exists"              /* E_ALREADY_EXISTS */
+    ,"Resource Is Full"                     /* E_FULL */
+    ,"Resource Is Empty"                    /* E_EMPTY */
+    ,"Resource Is Busy"                     /* E_BUSY */
+    ,"Resource Already Free"                /* E_ALREADY_FREE */
+    ,"Read Access Failed"                   /* E_READ_FAILED */
+    ,"Write Access Failed"                  /* E_WRITE_FAILED */
+    ,"Send Operation Failed"                /* E_SEND_FAILED */
+    ,"Receive Operation Failed"             /* E_RECEIVE_FAILED */
+    ,"Operation Timed Out"                  /* E_TIMEOUT */
+};
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+
+const char *eventStrings[] =
+{
+     "Rx Discard"                           /* EV_RX_DISCARD */
+    ,"Rx Error"                             /* EV_RX_ERROR */
+    ,"Tx Error"                             /* EV_TX_ERROR */
+    ,"No Buffer Objects"                    /* EV_NO_BUFFERS */
+    ,"No MB-Frame Objects"                  /* EV_NO_MB_FRAMES */
+    ,"No SB-Frame Objects"                  /* EV_NO_SB_FRAMES */
+    ,"Tx Queue Is Full"                     /* EV_TX_QUEUE_FULL */
+    ,"Rx Queue Is Full"                     /* EV_RX_QUEUE_FULL */
+    ,"Interrupts Queue Is Full"             /* EV_INTR_QUEUE_FULL */
+    ,"Data Buffer Is Unavailable"           /* EV_NO_DATA_BUFFER */
+    ,"Objects Pool Is Empty"                /* EV_OBJ_POOL_EMPTY */
+    ,"Illegal bus access"                   /* EV_BUS_ERROR */
+    ,"PTP Tx Timestamps Queue Is Full"      /* EV_PTP_TXTS_QUEUE_FULL */
+    ,"PTP Rx Timestamps Queue Is Full"      /* EV_PTP_RXTS_QUEUE_FULL */
+};
+
+#endif /* (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0)) */
+
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
diff --git a/drivers/net/dpa/NetCommSw/etc/list.c b/drivers/net/dpa/NetCommSw/etc/list.c
new file mode 100644
index 0000000..fd51a18
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/list.c
@@ -0,0 +1,70 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list.c
+
+ @Description   Implementation of list.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "list_ext.h"
+
+
+void LIST_Append(t_List *p_NewList, t_List *p_Head)
+{
+    t_List *p_First = LIST_FIRST(p_NewList);
+
+    if (p_First != p_NewList)
+    {
+        t_List *p_Last  = LIST_LAST(p_NewList);
+        t_List *p_Cur   = LIST_NEXT(p_Head);
+
+        LIST_PREV(p_First) = p_Head;
+        LIST_FIRST(p_Head) = p_First;
+        LIST_NEXT(p_Last)  = p_Cur;
+        LIST_LAST(p_Cur)   = p_Last;
+    }
+}
+
+
+int LIST_NumOfObjs(t_List *p_List)
+{
+    t_List *p_Tmp;
+    int    numOfObjs = 0;
+
+    if (!LIST_IsEmpty(p_List))
+        LIST_FOR_EACH(p_Tmp, p_List)
+            numOfObjs++;
+
+    return numOfObjs;
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/memcpy.c b/drivers/net/dpa/NetCommSw/etc/memcpy.c
new file mode 100644
index 0000000..1ed8dae
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/memcpy.c
@@ -0,0 +1,665 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+         newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t MY_MY_GET_UINT8(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
+#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
+#else
+#define MY_WRITE_UINT8 WRITE_UINT8
+#define MY_GET_UINT8   GET_UINT8
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (uint32_t)((PTR_TO_UINT(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32++ = *p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;
+            p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (uint32_t)((PTR_TO_UINT(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, GET_UINT32(*p_Src32));
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (uint32_t)((PTR_TO_UINT(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            WRITE_UINT32(*p_Dst32, *p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = *p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = *p_Src32;
+            WRITE_UINT32(*p_Dst32, (lastWord << leftAlign) | (currWord >> rightAlign));
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint32_t lastWord;
+    uint32_t currWord;
+    uint32_t *p_Src32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessary to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (uint32_t)((PTR_TO_UINT(p_Src8) & 3) << 3); /* leftAlign = (pSrc mod 4)*8 */
+    rightAlign = 32 - leftAlign;
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        p_Src32 = (uint32_t*)(p_Src8);
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        while (size >> 2) /* size >= 4 */
+        {
+            *p_Dst32 = GET_UINT32(*p_Src32);
+            p_Dst32++;p_Src32++;
+            size -= 4;
+        }
+        p_Src8 = (uint8_t*)(p_Src32);
+        p_Dst8 = (uint8_t*)(p_Dst32);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        p_Src32 = (uint32_t*)(p_Src8 - (leftAlign >> 3));
+        p_Dst32 = (uint32_t*)(p_Dst8);
+        lastWord = GET_UINT32(*p_Src32);
+        p_Src32++;
+        while(size >> 3) /* size >= 8 */
+        {
+            currWord = GET_UINT32(*p_Src32);
+            *p_Dst32 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            p_Src32++;p_Dst32++;
+            size -= 4;
+        }
+        p_Dst8 = (uint8_t*)(p_Dst32);
+        p_Src8 = (uint8_t*)(p_Src32) - 4 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+    {
+        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        p_Dst8++;p_Src8++;
+    }
+
+    return pDst;
+}
+
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size)
+{
+    uint32_t leftAlign;
+    uint32_t rightAlign;
+    uint64_t lastWord;
+    uint64_t currWord;
+    uint64_t *pSrc64;
+    uint64_t *pDst64;
+    uint8_t  *p_Src8;
+    uint8_t  *p_Dst8;
+
+    p_Src8 = (uint8_t*)(pSrc);
+    p_Dst8 = (uint8_t*)(pDst);
+    /* first copy byte by byte till the source first alignment
+     * this step is necessarily to ensure we do not even try to access
+     * data which is before the source buffer, hence it is not ours.
+     */
+    while((PTR_TO_UINT(p_Src8) & 7) && size) /* (pSrc mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* align destination (possibly disaligning source)*/
+    while((PTR_TO_UINT(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = *p_Src8++;
+        size--;
+    }
+
+    /* dest is aligned and source is not necessarily aligned */
+    leftAlign = (uint32_t)((PTR_TO_UINT(p_Src8) & 7) << 3); /* leftAlign = (pSrc mod 8)*8 */
+    rightAlign = 64 - leftAlign;
+
+
+    if (leftAlign == 0)
+    {
+        /* source is also aligned */
+        pSrc64 = (uint64_t*)(p_Src8);
+        pDst64 = (uint64_t*)(p_Dst8);
+        while (size >> 3) /* size >= 8 */
+        {
+            *pDst64++ = *pSrc64++;
+            size -= 8;
+        }
+        p_Src8 = (uint8_t*)(pSrc64);
+        p_Dst8 = (uint8_t*)(pDst64);
+    }
+    else
+    {
+        /* source is not aligned (destination is aligned)*/
+        pSrc64 = (uint64_t*)(p_Src8 - (leftAlign >> 3));
+        pDst64 = (uint64_t*)(p_Dst8);
+        lastWord = *pSrc64++;
+        while(size >> 4) /* size >= 16 */
+        {
+            currWord = *pSrc64;
+            *pDst64 = (lastWord << leftAlign) | (currWord >> rightAlign);
+            lastWord = currWord;
+            pSrc64++;
+            pDst64++;
+            size -= 8;
+        }
+        p_Dst8 = (uint8_t*)(pDst64);
+        p_Src8 = (uint8_t*)(pSrc64) - 8 + (leftAlign >> 3);
+    }
+
+    /* complete the left overs */
+    while (size--)
+        *p_Dst8++ = *p_Src8++;
+
+    return pDst;
+}
+
+void * MemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        *p_Dst32++ = val32;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size)
+{
+    uint32_t val32;
+    uint32_t *p_Dst32;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val32  = (uint32_t) val;
+    val32 |= (val32 <<  8);
+    val32 |= (val32 << 16);
+
+    /* align destination to 32 */
+    while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+        size--;
+    }
+
+    /* 32-bit chunks */
+    p_Dst32 = (uint32_t*)(p_Dst8);
+    while (size >> 2) /* size >= 4 */
+    {
+        WRITE_UINT32(*p_Dst32, val32);
+        p_Dst32++;
+        size -= 4;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(p_Dst32);
+    while (size--)
+    {
+        MY_WRITE_UINT8(*p_Dst8, val);
+        p_Dst8++;
+    }
+
+    return pDst;
+}
+
+void * MemSet64(void* pDst, uint8_t val, uint32_t size)
+{
+    uint64_t val64;
+    uint64_t *pDst64;
+    uint8_t  *p_Dst8;
+
+    p_Dst8 = (uint8_t*)(pDst);
+
+    /* generate four 8-bit val's in 32-bit container */
+    val64  = (uint64_t) val;
+    val64 |= (val64 <<  8);
+    val64 |= (val64 << 16);
+    val64 |= (val64 << 24);
+    val64 |= (val64 << 32);
+
+    /* align destination to 64 */
+    while((PTR_TO_UINT(p_Dst8) & 7) && size) /* (pDst mod 8) > 0 and size > 0 */
+    {
+        *p_Dst8++ = val;
+        size--;
+    }
+
+    /* 64-bit chunks */
+    pDst64 = (uint64_t*)(p_Dst8);
+    while (size >> 4) /* size >= 8 */
+    {
+        *pDst64++ = val64;
+        size -= 8;
+    }
+
+    /* complete the leftovers */
+    p_Dst8 = (uint8_t*)(pDst64);
+    while (size--)
+        *p_Dst8++ = val;
+
+    return pDst;
+}
+
+void MemDisp(uint8_t *p, int size)
+{
+    uint32_t    space = (uint32_t)(PTR_TO_UINT(p) & 0x3);
+    uint8_t     *p_Limit;
+
+    if (space)
+    {
+        p_Limit = (p - space + 4);
+
+        XX_Print("0x%08X: ", (p - space));
+
+        while (space--)
+        {
+            XX_Print("--");
+        }
+        while (size  && (p < p_Limit))
+        {
+            XX_Print("%02x", *(uint8_t*)p);
+            size--;
+            p++;
+        }
+
+        XX_Print(" ");
+        p_Limit += 12;
+
+        while ((size > 3) && (p < p_Limit))
+        {
+            XX_Print("%08x ", *(uint32_t*)p);
+            size -= 4;
+            p += 4;
+        }
+        XX_Print("\r\n");
+    }
+
+    while (size > 15)
+    {
+        XX_Print("0x%08X: %08x %08x %08x %08x\r\n",
+                 p, *(uint32_t *)p, *(uint32_t *)(p + 4),
+                 *(uint32_t *)(p + 8), *(uint32_t *)(p + 12));
+        size -= 16;
+        p += 16;
+    }
+
+    if (size)
+    {
+        XX_Print("0x%08X: ", p);
+
+        while (size > 3)
+        {
+            XX_Print("%08x ", *(uint32_t *)p);
+            size -= 4;
+            p += 4;
+        }
+        while (size)
+        {
+            XX_Print("%02x", *(uint8_t *)p);
+            size--;
+            p++;
+        }
+
+        XX_Print("\r\n");
+    }
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.c b/drivers/net/dpa/NetCommSw/etc/mm.c
new file mode 100644
index 0000000..2d4fe45
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.c
@@ -0,0 +1,1128 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "string_ext.h"
+#include "error_ext.h"
+#include "std_ext.h"
+#include "sprint_ext.h"
+#include "part_ext.h"
+#include "xx_ext.h"
+
+#include "mm.h"
+
+
+
+
+/**********************************************************************
+ *                     MM internal routines set                       *
+ **********************************************************************/
+
+/****************************************************************
+ *  Routine:   InitBusyBlock
+ *
+ *  Description:
+ *      Initializes a new busy block of "size" bytes and started
+ *      rom "base" address. Each busy block has a name that
+ *      specified the purpose of the memory allocation.
+ *
+ *  Arguments:
+ *      busyBlock - handle to the busyBlock object
+ *      base      - base address of the busy block
+ *      size      - size of the busy block
+ *      name      - name that specified the busy block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for busy block.
+ ****************************************************************/
+static t_Error InitBusyBlock(t_Handle *busyBlock, uint64_t base, uint64_t size, char *name)
+{
+    t_BusyBlock *p_BusyBlock;
+    int         n, nameLen;
+
+    p_BusyBlock = (t_BusyBlock *)XX_Malloc(sizeof(t_BusyBlock));
+    if ( !p_BusyBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_BusyBlock->base = base;
+    p_BusyBlock->end = base + size;
+    nameLen = (int)strlen(name);
+    n = (nameLen > MM_MAX_NAME_LEN - 1) ? MM_MAX_NAME_LEN-1 : nameLen;
+    strncpy(p_BusyBlock->name, name, (uint32_t)n);
+    p_BusyBlock->name[n] = '\0';
+    p_BusyBlock->p_Next = 0;
+
+    *busyBlock = p_BusyBlock;
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:   InitNewBlock
+ *
+ *  Description:
+ *      Initializes a new memory block of "size" bytes and started
+ *      from "base" address.
+ *
+ *  Arguments:
+ *      memBlock- handle to the memBlock object
+ *      base    - base address of the memory block
+ *      size    - size of the memory block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for memBlock object.
+ ****************************************************************/
+static t_Error InitNewBlock(t_Handle *memBlock, uint64_t base, uint64_t size)
+{
+    t_MemBlock *p_MemBlock;
+
+    p_MemBlock = (t_MemBlock *)XX_Malloc(sizeof(t_MemBlock));
+    if ( !p_MemBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_MemBlock->base = base;
+    p_MemBlock->end = base+size;
+    p_MemBlock->p_Next = 0;
+
+    *memBlock = p_MemBlock;
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:   InitFreeBlock
+ *
+ *  Description:
+ *      Initializes a new free block of of "size" bytes and
+ *      started from "base" address.
+ *
+ *  Arguments:
+ *      freeBlock - handle to the freeBlock object
+ *      base      - base address of the free block
+ *      size      - size of the free block
+ *
+ *  Return value:
+ *      E_OK is returned on success. E_NOMEMORY is returned
+ *      if can't allocate memory for a free block.
+ ****************************************************************/
+static t_Error InitFreeBlock(t_Handle *freeBlock, uint64_t base, uint64_t size)
+{
+    t_FreeBlock *p_FreeBlock;
+
+    p_FreeBlock = (t_FreeBlock *)XX_Malloc(sizeof(t_FreeBlock));
+    if ( !p_FreeBlock )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_FreeBlock->base = base;
+    p_FreeBlock->end = base + size;
+    p_FreeBlock->p_Next = 0;
+
+    *freeBlock = p_FreeBlock;
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:    AddFree
+ *
+ *  Description:
+ *      Adds a new free block to the free lists. It updates each
+ *      free list to include a new free block.
+ *      Note, that all free block in each free list are ordered
+ *      by their base address.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given free block
+ *      end   - end address of a given free block
+ *
+ *  Return value:
+ *
+ *
+ ****************************************************************/
+static t_Error AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint64_t    alignment;
+    uint64_t    alignBase;
+    int         i;
+
+    /* Updates free lists to include  a just released block */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint64_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(base, alignment);
+
+        /* Goes to the next free list if there is no block to free */
+        if (alignBase >= end)
+            continue;
+
+        /* Looks for a free block that should be updated */
+        while ( p_CurrB )
+        {
+            if ( alignBase <= p_CurrB->end )
+            {
+                if ( end > p_CurrB->end )
+                {
+                    t_FreeBlock *p_NextB;
+                    while ( p_CurrB->p_Next && end > p_CurrB->p_Next->end )
+                    {
+                        p_NextB = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                        XX_Free(p_NextB);
+                    }
+
+                    p_NextB = p_CurrB->p_Next;
+                    if ( !p_NextB || (p_NextB && end < p_NextB->base) )
+                    {
+                        p_CurrB->end = end;
+                    }
+                    else
+                    {
+                        p_CurrB->end = p_NextB->end;
+                        p_CurrB->p_Next = p_NextB->p_Next;
+                        XX_Free(p_NextB);
+                    }
+                }
+                else if ( (end < p_CurrB->base) && ((end-alignBase) >= alignment) )
+                {
+                    if ( InitFreeBlock((t_Handle *)&p_NewB,
+                                        alignBase,
+                                        end-alignBase) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB;
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_NewB;
+                    else
+                        p_MM->freeBlocks[i] = p_NewB;
+                    break;
+                }
+
+                if ((alignBase < p_CurrB->base) && (end >= p_CurrB->base))
+                {
+                    p_CurrB->base = alignBase;
+                }
+
+                /* if size of the free block is less then alignment
+                 * deletes that free block from the free list. */
+                if ( (p_CurrB->end - p_CurrB->base) < alignment)
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+
+        /* If no free block found to be updated, insert a new free block
+         * to the end of the free list.
+         */
+        if ( !p_CurrB && ((((uint64_t)(end-base)) & ((uint64_t)(alignment-1))) == 0) )
+        {
+            if ( InitFreeBlock((t_Handle *)&p_NewB, alignBase, end-base) != E_OK )
+            {
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+            }
+            if (p_PrevB)
+                p_PrevB->p_Next = p_NewB;
+            else
+                p_MM->freeBlocks[i] = p_NewB;
+        }
+
+        /* Update boundaries of the new free block */
+        if ((alignment == 1) && !p_NewB)
+        {
+            if ( p_CurrB && base > p_CurrB->base )
+                base = p_CurrB->base;
+            if ( p_CurrB && end < p_CurrB->end )
+                end = p_CurrB->end;
+        }
+    }
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:      CutFree
+ *
+ *  Description:
+ *      Cuts a free block from holdBase to holdEnd from the free lists.
+ *      That is, it updates all free lists of the MM object do
+ *      not include a block of memory from holdBase to holdEnd.
+ *      For each free lists it seek for a free block that holds
+ *      either holdBase or holdEnd. If such block is found it updates it.
+ *
+ *  Arguments:
+ *      p_MM            - pointer to the MM object
+ *      holdBase        - base address of the allocated block
+ *      holdEnd         - end address of the allocated block
+ *
+ *  Return value:
+ *      E_OK is returned on success,
+ *      otherwise returns an error code.
+ *
+ ****************************************************************/
+static t_Error CutFree(t_MM *p_MM, uint64_t holdBase, uint64_t holdEnd)
+{
+    t_FreeBlock *p_PrevB, *p_CurrB, *p_NewB;
+    uint64_t    alignBase, base, end;
+    uint64_t    alignment;
+    int         i;
+
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_PrevB = p_NewB = 0;
+        p_CurrB = p_MM->freeBlocks[i];
+
+        alignment = (uint64_t)(0x1 << i);
+        alignBase = MAKE_ALIGNED(holdEnd, alignment);
+
+        while ( p_CurrB )
+        {
+            base = p_CurrB->base;
+            end = p_CurrB->end;
+
+            if ( (holdBase <= base) && (holdEnd <= end) && (holdEnd > base) )
+            {
+                if ( alignBase >= end ||
+                     (alignBase < end && ((end-alignBase) < alignment)) )
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                else
+                {
+                    p_CurrB->base = alignBase;
+                }
+                break;
+            }
+            else if ( (holdBase > base) && (holdEnd <= end) )
+            {
+                if ( (holdBase-base) >= alignment )
+                {
+                    if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                    {
+                        if ( InitFreeBlock( (t_Handle *)&p_NewB,
+                                             alignBase,
+                                             (end-alignBase)) != E_OK )
+                        {
+                            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                        }
+                        p_NewB->p_Next = p_CurrB->p_Next;
+                        p_CurrB->p_Next = p_NewB;
+                    }
+                    p_CurrB->end = holdBase;
+                }
+                else if ( (alignBase < end) && ((end-alignBase) >= alignment) )
+                {
+                    p_CurrB->base = alignBase;
+                }
+                else
+                {
+                    if (p_PrevB)
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->freeBlocks[i] = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+                break;
+            }
+            else
+            {
+                p_PrevB = p_CurrB;
+                p_CurrB = p_CurrB->p_Next;
+            }
+        }
+    }
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:     AddBusy
+ *
+ *  Description:
+ *      Adds a new busy block to the list of busy blocks. Note,
+ *      that all busy blocks are ordered by their base address in
+ *      the busy list.
+ *
+ *  Arguments:
+ *      MM              - handler to the MM object
+ *      p_NewBusyB      - pointer to the a busy block
+ *
+ *  Return value:
+ *      None.
+ *
+ ****************************************************************/
+static void AddBusy(t_MM *p_MM, t_BusyBlock *p_NewBusyB)
+{
+    t_BusyBlock *p_CurrBusyB, *p_PrevBusyB;
+
+    /* finds a place of a new busy block in the list of busy blocks */
+    p_PrevBusyB = 0;
+    p_CurrBusyB = p_MM->busyBlocks;
+
+    while ( p_CurrBusyB && p_NewBusyB->base > p_CurrBusyB->base )
+    {
+        p_PrevBusyB = p_CurrBusyB;
+        p_CurrBusyB = p_CurrBusyB->p_Next;
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    if ( p_CurrBusyB )
+        p_NewBusyB->p_Next = p_CurrBusyB;
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_NewBusyB;
+    else
+        p_MM->busyBlocks = p_NewBusyB;
+}
+
+/****************************************************************
+ *  Routine:    CutBusy
+ *
+ *  Description:
+ *      Cuts a block from base to end from the list of busy blocks.
+ *      This is done by updating the list of busy blocks do not
+ *      include a given block, that block is going to be free. If a
+ *      given block is a part of some other busy block, so that
+ *      busy block is updated. If there are number of busy blocks
+ *      included in the given block, so all that blocks are removed
+ *      from the busy list and the end blocks are updated.
+ *      If the given block devides some block into two parts, a new
+ *      busy block is added to the busy list.
+ *
+ *  Arguments:
+ *      p_MM  - pointer to the MM object
+ *      base  - base address of a given busy block
+ *      end   - end address of a given busy block
+ *
+ *  Return value:
+ *      E_OK on success, E_NOMEMORY otherwise.
+ *
+ ****************************************************************/
+static t_Error CutBusy(t_MM *p_MM, uint64_t base, uint64_t end)
+{
+    t_BusyBlock  *p_CurrB, *p_PrevB, *p_NewB;
+
+    p_CurrB = p_MM->busyBlocks;
+    p_PrevB = p_NewB = 0;
+
+    while ( p_CurrB )
+    {
+        if ( base < p_CurrB->end )
+        {
+            if ( end > p_CurrB->end )
+            {
+                t_BusyBlock *p_NextB;
+                while ( p_CurrB->p_Next && end >= p_CurrB->p_Next->end )
+                {
+                    p_NextB = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_CurrB->p_Next->p_Next;
+                    XX_Free(p_NextB);
+                }
+
+                p_NextB = p_CurrB->p_Next;
+                if ( p_NextB && end > p_NextB->base )
+                {
+                    p_NextB->base = end;
+                }
+            }
+
+            if ( base <= p_CurrB->base )
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    p_CurrB->base = end;
+                }
+                else if ( end >= p_CurrB->end )
+                {
+                    if ( p_PrevB )
+                        p_PrevB->p_Next = p_CurrB->p_Next;
+                    else
+                        p_MM->busyBlocks = p_CurrB->p_Next;
+                    XX_Free(p_CurrB);
+                }
+            }
+            else
+            {
+                if ( end < p_CurrB->end && end > p_CurrB->base )
+                {
+                    if ( InitBusyBlock((t_Handle *)&p_NewB,
+                                        end,
+                                        p_CurrB->end-end,
+                                        p_CurrB->name ) != E_OK )
+                    {
+                        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+                    }
+                    p_NewB->p_Next = p_CurrB->p_Next;
+                    p_CurrB->p_Next = p_NewB;
+                }
+                p_CurrB->end = base;
+            }
+            break;
+        }
+        else
+        {
+            p_PrevB = p_CurrB;
+            p_CurrB = p_CurrB->p_Next;
+        }
+    }
+
+    return (E_OK);
+}
+
+/****************************************************************
+ *  Routine:     MmGetGreaterAlignment
+ *
+ *  Description:
+ *      Allocates a block of memory according to the given size
+ *      and the alignment. That routine is called from the MM_Get
+ *      routine if the required alignment is greater then MM_MAX_ALIGNMENT.
+ *      In that case, it goes over free blocks of 64 byte align list
+ *      and checks if it has the required size of bytes of the required
+ *      alignment. If no blocks found returns ILLEGAL_BASE.
+ *      After the block is found and data is allocated, it calls
+ *      the internal CutFree routine to update all free lists
+ *      do not include a just allocated block. Of course, each
+ *      free list contains a free blocks with the same alignment.
+ *      It is also creates a busy block that holds
+ *      information about an allocated block.
+ *
+ *  Arguments:
+ *      MM              - handle to the MM object
+ *      size            - size of the MM
+ *      alignment       - index as a power of two defines
+ *                        a required alignment that is greater then 64.
+ *      name            - the name that specifies an allocated block.
+ *
+ *  Return value:
+ *      base address of an allocated block.
+ *      ILLEGAL_BASE if can't allocate a block
+ *
+ ****************************************************************/
+static uint64_t MmGetGreaterAlignment(t_MM *p_MM, uint64_t size, uint64_t alignment, char* name)
+{
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd, alignBase = 0;
+
+    /* goes over free blocks of the 64 byte alignment list
+       and look for a block of the suitable size and
+       base address according to the alignment. */
+    p_FreeB = p_MM->freeBlocks[MM_MAX_ALIGNMENT];
+
+    while ( p_FreeB )
+    {
+        alignBase = MAKE_ALIGNED(p_FreeB->base, alignment);
+
+        /* the block is found if the aligned base inside the block
+         * and has the anough size. */
+        if ( alignBase >= p_FreeB->base &&
+             alignBase < p_FreeB->end &&
+             size <= (p_FreeB->end - alignBase) )
+            break;
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    /* If such block isn't found */
+    if ( !p_FreeB )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    holdBase = alignBase;
+    holdEnd = alignBase + size;
+
+    /* init a new busy block */
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+        return (uint64_t)(ILLEGAL_BASE);
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy ( p_MM, p_NewBusyB );
+
+    return (holdBase);
+}
+
+
+/**********************************************************************
+ *                     MM API routines set                            *
+ **********************************************************************/
+
+/*****************************************************************************/
+t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM;
+    uint64_t    newBase, newSize;
+    int         i;
+
+    if (!size)
+    {
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size (should be positive)"));
+    }
+
+    /* Initializes a new MM object */
+    p_MM = (t_MM *)XX_Malloc(sizeof(t_MM));
+    if (!p_MM)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    p_MM->h_Spinlock = XX_InitSpinlock();
+    if (!p_MM->h_Spinlock)
+    {
+        XX_Free(p_MM);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MM spinlock!"));
+    }
+
+    /* initializes a new memory block */
+    if ( InitNewBlock((t_Handle *)&p_MM->memBlocks, base, size) != E_OK )
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
+    /*Initializes a new free block for each free list*/
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        newBase = MAKE_ALIGNED( base, (0x1 << i) );
+        newSize = size - (newBase - base);
+
+        if ( InitFreeBlock((t_Handle *)&p_MM->freeBlocks[i], newBase, newSize ) != E_OK)
+        {
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
+    }
+
+    *h_MM = p_MM;
+
+    return (E_OK);
+}
+
+/*****************************************************************************/
+void MM_Free(t_Handle h_MM)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemBlock;
+    t_BusyBlock *p_BusyBlock;
+    t_FreeBlock *p_FreeBlock;
+    void        *p_Block;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    /* release memory allocated for busy blocks */
+    p_BusyBlock = p_MM->busyBlocks;
+    while ( p_BusyBlock )
+    {
+        p_Block = p_BusyBlock;
+        p_BusyBlock = p_BusyBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    /* release memory allocated for free blocks */
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        p_FreeBlock = p_MM->freeBlocks[i];
+        while ( p_FreeBlock )
+        {
+            p_Block = p_FreeBlock;
+            p_FreeBlock = p_FreeBlock->p_Next;
+            XX_Free(p_Block);
+        }
+    }
+
+    /* release memory allocated for memory blocks */
+    p_MemBlock = p_MM->memBlocks;
+    while ( p_MemBlock )
+    {
+        p_Block = p_MemBlock;
+        p_MemBlock = p_MemBlock->p_Next;
+        XX_Free(p_Block);
+    }
+
+    if (p_MM->h_Spinlock)
+        XX_FreeSpinlock(p_MM->h_Spinlock);
+
+    /* release memory allocated for MM object itself */
+    XX_Free(p_MM);
+}
+
+/*****************************************************************************/
+uint64_t MM_Get(t_Handle h_MM, uint64_t size, uint64_t alignment, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd, j, i = 0;
+    uint32_t    intFlags;
+
+    SANITY_CHECK_RETURN_VALUE(p_MM, E_INVALID_HANDLE, (uint64_t)ILLEGAL_BASE);
+
+    /* checks that alignment value is greater then zero */
+    if (alignment == 0)
+    {
+        alignment = 1;
+    }
+
+    j = alignment;
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    /* if the given alignment isn't power of two, returns an error */
+    if (j != 1)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("alignment (should be power of 2)"));
+        return (uint64_t)ILLEGAL_BASE;
+    }
+
+    if (i > MM_MAX_ALIGNMENT)
+    {
+        return (MmGetGreaterAlignment(p_MM, size, alignment, name));
+    }
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    /* look for a block of the size greater or equal to the required size. */
+    p_FreeB = p_MM->freeBlocks[i];
+    while ( p_FreeB && (p_FreeB->end - p_FreeB->base) < size )
+        p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    holdBase = p_FreeB->base;
+    holdEnd = holdBase + size;
+
+    /* init a new busy block */
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, holdBase, size, name ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy ( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (holdBase);
+}
+
+/*****************************************************************************/
+uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint32_t    intFlags;
+    bool        blockIsFree = FALSE;
+
+    ASSERT_COND(p_MM);
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_FreeB = p_MM->freeBlocks[0]; /* The biggest free blocks are in the
+                                      free list with alignment 1 */
+
+    while ( p_FreeB )
+    {
+        if ( base >= p_FreeB->base && (base+size) <= p_FreeB->end )
+        {
+            blockIsFree = TRUE;
+            break;
+        }
+        else
+            p_FreeB = p_FreeB->p_Next;
+    }
+
+    if ( !blockIsFree )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* init a new busy block */
+    if ( InitBusyBlock ( (t_Handle *)&p_NewBusyB, base, size, name ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree ( p_MM, base, base+size ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy ( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (base);
+}
+
+/*****************************************************************************/
+uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64_t min, char* name)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_NewBusyB;
+    uint64_t    holdBase, holdEnd, j = alignment, i=0;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    /* checks if alignment is a power of two, if it correct and if the
+       required size is multiple of the given alignment. */
+    while ((j & 0x1) == 0)
+    {
+        i++;
+        j = j >> 1;
+    }
+
+    if ( (j != 1) || (i > MM_MAX_ALIGNMENT) )
+    {
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_FreeB = p_MM->freeBlocks[i];
+
+    /* look for the first block that contains the minimum
+       base address. If the whole required size may be fit
+       into it, use that block, otherwise look for the next
+       block of size greater or equal to the required size. */
+    while ( p_FreeB && (min >= p_FreeB->end))
+            p_FreeB = p_FreeB->p_Next;
+
+    /* If such block is found */
+    if ( !p_FreeB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* if this block is large enough, use this block */
+    holdBase = ( min <= p_FreeB->base ) ? p_FreeB->base : min;
+    if ((holdBase + size) <= p_FreeB->end )
+    {
+        holdEnd = holdBase + size;
+    }
+    else
+    {
+        p_FreeB = p_FreeB->p_Next;
+        while ( p_FreeB && ((p_FreeB->end - p_FreeB->base) < size) )
+            p_FreeB = p_FreeB->p_Next;
+
+        /* If such block is found */
+        if ( !p_FreeB )
+        {
+            XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+            return (uint64_t)(ILLEGAL_BASE);
+        }
+
+        holdBase = p_FreeB->base;
+        holdEnd = holdBase + size;
+    }
+
+    /* init a new busy block */
+    if ( InitBusyBlock((t_Handle *)&p_NewBusyB, holdBase, size, name) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* calls Update routine to update a lists of free blocks */
+    if ( CutFree( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(ILLEGAL_BASE);
+    }
+
+    /* insert the new busy block into the list of busy blocks */
+    AddBusy( p_MM, p_NewBusyB );
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (holdBase);
+}
+
+/*****************************************************************************/
+uint64_t MM_Put(t_Handle h_MM, uint64_t base)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_BusyBlock *p_BusyB, *p_PrevBusyB;
+    uint64_t    size;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    /* Look for a busy block that have the given base value.
+     * That block will be returned back to the memory.
+     */
+    p_PrevBusyB = 0;
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_BusyB = p_MM->busyBlocks;
+    while ( p_BusyB && base != p_BusyB->base )
+    {
+        p_PrevBusyB = p_BusyB;
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    if ( !p_BusyB )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    if ( AddFree( p_MM, p_BusyB->base, p_BusyB->end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    /* removes a busy block form the list of busy blocks */
+    if ( p_PrevBusyB )
+        p_PrevBusyB->p_Next = p_BusyB->p_Next;
+    else
+        p_MM->busyBlocks = p_BusyB->p_Next;
+
+    size = p_BusyB->end - p_BusyB->base;
+
+    XX_Free(p_BusyB);
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (size);
+}
+
+/*****************************************************************************/
+uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    uint64_t    end = base + size;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    if ( CutBusy( p_MM, base, end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+
+    if ( AddFree ( p_MM, base, end ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        return (uint64_t)(0);
+    }
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (size);
+}
+
+/*****************************************************************************/
+t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_MemBlock  *p_MemB, *p_NewMemB;
+    t_Error     errCode;
+    uint32_t    intFlags;
+
+    ASSERT_COND(p_MM);
+
+    /* find a last block in the list of memory blocks to insert a new
+     * memory block
+     */
+    intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+    p_MemB = p_MM->memBlocks;
+    while ( p_MemB->p_Next )
+    {
+        if ( base >= p_MemB->base && base < p_MemB->end )
+        {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+        }
+        p_MemB = p_MemB->p_Next;
+    }
+    /* check for a last memory block */
+    if ( base >= p_MemB->base && base < p_MemB->end )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+    }
+
+    /* create a new memory block */
+    if ( InitNewBlock( (t_Handle *)&p_NewMemB, base, size ) != E_OK )
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    }
+
+    /* append a new memory block to the end of the list of memory blocks */
+    p_MemB->p_Next = p_NewMemB;
+
+    /* add a new free block to the free lists */
+    errCode = AddFree(p_MM, base, base+size);
+    if (errCode)
+    {
+        XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        p_MemB->p_Next = 0;
+        XX_Free(p_NewMemB);
+        return ((t_Error)errCode);
+    }
+    XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+
+    return (E_OK);
+}
+
+/*****************************************************************************/
+uint64_t MM_GetMemBlock(t_Handle h_MM, int index)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+    int         i;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    for (i=0; i < index; i++)
+        p_MemBlock = p_MemBlock->p_Next;
+
+    if ( p_MemBlock )
+        return (p_MemBlock->base);
+    else
+        return (uint64_t)ILLEGAL_BASE;
+}
+
+/*****************************************************************************/
+uint64_t MM_GetBase(t_Handle h_MM)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+    return  p_MemBlock->base;
+}
+
+/*****************************************************************************/
+bool MM_InRange(t_Handle h_MM, uint64_t addr)
+{
+    t_MM       *p_MM = (t_MM*)h_MM;
+    t_MemBlock *p_MemBlock;
+
+    ASSERT_COND(p_MM);
+
+    p_MemBlock = p_MM->memBlocks;
+
+    if ((addr >= p_MemBlock->base) && (addr < p_MemBlock->end))
+        return TRUE;
+    else
+        return FALSE;
+}
+
+/*****************************************************************************/
+void MM_Dump(t_Handle h_MM, void *buff)
+{
+    t_MM        *p_MM = (t_MM *)h_MM;
+    t_FreeBlock *p_FreeB;
+    t_BusyBlock *p_BusyB;
+    int          i;
+
+    p_BusyB = p_MM->busyBlocks;
+    Sprint(buff, "List of busy blocks:\n");
+    while (p_BusyB)
+    {
+        Sprint(buff, "\t0x%p: (%s: b=0x%lx, e=0x%lx)\n",
+               p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
+        p_BusyB = p_BusyB->p_Next;
+    }
+
+    Sprint(buff, "\nLists of free blocks according to alignment:\n");
+    for (i=0; i <= MM_MAX_ALIGNMENT; i++)
+    {
+        Sprint(buff, "%d alignment:\n", (0x1 << i));
+        p_FreeB = p_MM->freeBlocks[i];
+        while (p_FreeB)
+        {
+            Sprint(buff, "\t0x%p: (b=0x%lx, e=0x%lx)\n",
+                   p_FreeB, p_FreeB->base, p_FreeB->end);
+            p_FreeB = p_FreeB->p_Next;
+        }
+        Sprint(buff, "\n");
+    }
+}
diff --git a/drivers/net/dpa/NetCommSw/etc/mm.h b/drivers/net/dpa/NetCommSw/etc/mm.h
new file mode 100644
index 0000000..2bb8cc4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/mm.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/****************************************************************
+ *
+ * File:  mm.h
+ *
+ *
+ * Description:
+ *  MM (Memory Management) object definitions.
+ *  It also includes definitions of the Free Block, Busy Block
+ *  and Memory Block structures used by the MM object.
+ *
+ ****************************************************************/
+
+#ifndef __MM_H
+#define __MM_H
+
+
+#include "mm_ext.h"
+
+#define __ERR_MODULE__  MODULE_MM
+
+
+#define MAKE_ALIGNED(addr, align)    \
+    (((uint64_t)(addr) + ((align) - 1)) & (~(((uint64_t)align) - 1)))
+
+
+/* t_MemBlock data stucutre defines parameters of the Memory Block */
+typedef struct t_MemBlock
+{
+    struct t_MemBlock *p_Next;    /* Pointer to the next memory block */
+
+    uint64_t  base;             /* Base address of the memory block */
+    uint64_t  end;              /* End address of the memory block */
+} t_MemBlock;
+
+
+/* t_FreeBlock data stucutre defines parameters of the Free Block */
+typedef struct t_FreeBlock
+{
+    struct t_FreeBlock *p_Next;   /* Pointer to the next free block */
+
+    uint64_t  base;             /* Base address of the block */
+    uint64_t  end;              /* End address of the block */
+} t_FreeBlock;
+
+
+/* t_BusyBlock data stucutre defines parameters of the Busy Block  */
+typedef struct t_BusyBlock
+{
+    struct t_BusyBlock *p_Next;       /* Pointer to the next free block */
+
+    uint64_t  base;                 /* Base address of the block */
+    uint64_t  end;                  /* End address of the block */
+    char  name[MM_MAX_NAME_LEN];    /* That block of memory was allocated for
+                                       something specified by the Name */
+} t_BusyBlock;
+
+
+/* t_MM data structure defines parameters of the MM object */
+typedef struct t_MM
+{
+    t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
+    t_BusyBlock     *busyBlocks;    /* List of busy blocks (Busy list) */
+    t_FreeBlock     *freeBlocks[MM_MAX_ALIGNMENT + 1];
+                                    /* Alignment lists of free blocks (Free lists) */
+    t_Handle        h_Spinlock;
+} t_MM;
+
+
+#endif /* __MM_H */
diff --git a/drivers/net/dpa/NetCommSw/etc/sprint.c b/drivers/net/dpa/NetCommSw/etc/sprint.c
new file mode 100644
index 0000000..1b0facc
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/etc/sprint.c
@@ -0,0 +1,86 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: sprint.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Debug routines (externals)                        */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "string_ext.h"
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+#include "stdarg_ext.h"
+#include "sprint_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+int Sprint(char * buf, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsprintf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Snprint(char * buf, uint32_t size, const char *fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args, fmt);
+    i=vsnprintf(buf,size,fmt,args);
+    va_end(args);
+    return i;
+}
+
+
+int Sscan(const char * buf, const char * fmt, ...)
+{
+    va_list args;
+    int i;
+
+    va_start(args,fmt);
+    i = vsscanf(buf,fmt,args);
+    va_end(args);
+    return i;
+}
diff --git a/drivers/net/dpa/NetCommSw/events_mapping.h b/drivers/net/dpa/NetCommSw/events_mapping.h
new file mode 100644
index 0000000..5c9c0a0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/events_mapping.h
@@ -0,0 +1,51 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __EVENTS_MAPPING_H
+#define __EVENTS_MAPPING_H
+
+
+#define EV_RX_DISCARD_LEVEL         REPORT_LEVEL_MINOR
+#define EV_RX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_TX_ERROR_LEVEL           REPORT_LEVEL_MINOR
+#define EV_NO_BUFFERS_LEVEL         REPORT_LEVEL_MAJOR
+#define EV_NO_MB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_NO_SB_FRAMES_LEVEL       REPORT_LEVEL_MAJOR
+#define EV_TX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MINOR
+#define EV_RX_QUEUE_FULL_LEVEL      REPORT_LEVEL_MAJOR
+#define EV_INTR_QUEUE_FULL_LEVEL    REPORT_LEVEL_MINOR
+#define EV_NO_DATA_BUFFER_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_OBJ_POOL_EMPTY_LEVEL     REPORT_LEVEL_MAJOR
+#define EV_BUS_ERROR_LEVEL          REPORT_LEVEL_CRITICAL
+
+
+#endif /* __EVENTS_MAPPING_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
new file mode 100644
index 0000000..5990f71
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -0,0 +1,363 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: crc_mac_addr_ext.h                             */
+/*                                                      */
+/* Description:                                         */
+/*    Define a macro that calculate the crc value of    */
+/*    an Ethernet MAC address (48 bitd address          */
+/*------------------------------------------------------*/
+
+#ifndef __crc_mac_addr_ext_h
+#define __crc_mac_addr_ext_h
+
+#include "std_ext.h"
+
+
+static uint32_t crc_table[256] =
+{
+    0x00000000,
+    0x77073096,
+    0xee0e612c,
+    0x990951ba,
+    0x076dc419,
+    0x706af48f,
+    0xe963a535,
+    0x9e6495a3,
+    0x0edb8832,
+    0x79dcb8a4,
+    0xe0d5e91e,
+    0x97d2d988,
+    0x09b64c2b,
+    0x7eb17cbd,
+    0xe7b82d07,
+    0x90bf1d91,
+    0x1db71064,
+    0x6ab020f2,
+    0xf3b97148,
+    0x84be41de,
+    0x1adad47d,
+    0x6ddde4eb,
+    0xf4d4b551,
+    0x83d385c7,
+    0x136c9856,
+    0x646ba8c0,
+    0xfd62f97a,
+    0x8a65c9ec,
+    0x14015c4f,
+    0x63066cd9,
+    0xfa0f3d63,
+    0x8d080df5,
+    0x3b6e20c8,
+    0x4c69105e,
+    0xd56041e4,
+    0xa2677172,
+    0x3c03e4d1,
+    0x4b04d447,
+    0xd20d85fd,
+    0xa50ab56b,
+    0x35b5a8fa,
+    0x42b2986c,
+    0xdbbbc9d6,
+    0xacbcf940,
+    0x32d86ce3,
+    0x45df5c75,
+    0xdcd60dcf,
+    0xabd13d59,
+    0x26d930ac,
+    0x51de003a,
+    0xc8d75180,
+    0xbfd06116,
+    0x21b4f4b5,
+    0x56b3c423,
+    0xcfba9599,
+    0xb8bda50f,
+    0x2802b89e,
+    0x5f058808,
+    0xc60cd9b2,
+    0xb10be924,
+    0x2f6f7c87,
+    0x58684c11,
+    0xc1611dab,
+    0xb6662d3d,
+    0x76dc4190,
+    0x01db7106,
+    0x98d220bc,
+    0xefd5102a,
+    0x71b18589,
+    0x06b6b51f,
+    0x9fbfe4a5,
+    0xe8b8d433,
+    0x7807c9a2,
+    0x0f00f934,
+    0x9609a88e,
+    0xe10e9818,
+    0x7f6a0dbb,
+    0x086d3d2d,
+    0x91646c97,
+    0xe6635c01,
+    0x6b6b51f4,
+    0x1c6c6162,
+    0x856530d8,
+    0xf262004e,
+    0x6c0695ed,
+    0x1b01a57b,
+    0x8208f4c1,
+    0xf50fc457,
+    0x65b0d9c6,
+    0x12b7e950,
+    0x8bbeb8ea,
+    0xfcb9887c,
+    0x62dd1ddf,
+    0x15da2d49,
+    0x8cd37cf3,
+    0xfbd44c65,
+    0x4db26158,
+    0x3ab551ce,
+    0xa3bc0074,
+    0xd4bb30e2,
+    0x4adfa541,
+    0x3dd895d7,
+    0xa4d1c46d,
+    0xd3d6f4fb,
+    0x4369e96a,
+    0x346ed9fc,
+    0xad678846,
+    0xda60b8d0,
+    0x44042d73,
+    0x33031de5,
+    0xaa0a4c5f,
+    0xdd0d7cc9,
+    0x5005713c,
+    0x270241aa,
+    0xbe0b1010,
+    0xc90c2086,
+    0x5768b525,
+    0x206f85b3,
+    0xb966d409,
+    0xce61e49f,
+    0x5edef90e,
+    0x29d9c998,
+    0xb0d09822,
+    0xc7d7a8b4,
+    0x59b33d17,
+    0x2eb40d81,
+    0xb7bd5c3b,
+    0xc0ba6cad,
+    0xedb88320,
+    0x9abfb3b6,
+    0x03b6e20c,
+    0x74b1d29a,
+    0xead54739,
+    0x9dd277af,
+    0x04db2615,
+    0x73dc1683,
+    0xe3630b12,
+    0x94643b84,
+    0x0d6d6a3e,
+    0x7a6a5aa8,
+    0xe40ecf0b,
+    0x9309ff9d,
+    0x0a00ae27,
+    0x7d079eb1,
+    0xf00f9344,
+    0x8708a3d2,
+    0x1e01f268,
+    0x6906c2fe,
+    0xf762575d,
+    0x806567cb,
+    0x196c3671,
+    0x6e6b06e7,
+    0xfed41b76,
+    0x89d32be0,
+    0x10da7a5a,
+    0x67dd4acc,
+    0xf9b9df6f,
+    0x8ebeeff9,
+    0x17b7be43,
+    0x60b08ed5,
+    0xd6d6a3e8,
+    0xa1d1937e,
+    0x38d8c2c4,
+    0x4fdff252,
+    0xd1bb67f1,
+    0xa6bc5767,
+    0x3fb506dd,
+    0x48b2364b,
+    0xd80d2bda,
+    0xaf0a1b4c,
+    0x36034af6,
+    0x41047a60,
+    0xdf60efc3,
+    0xa867df55,
+    0x316e8eef,
+    0x4669be79,
+    0xcb61b38c,
+    0xbc66831a,
+    0x256fd2a0,
+    0x5268e236,
+    0xcc0c7795,
+    0xbb0b4703,
+    0x220216b9,
+    0x5505262f,
+    0xc5ba3bbe,
+    0xb2bd0b28,
+    0x2bb45a92,
+    0x5cb36a04,
+    0xc2d7ffa7,
+    0xb5d0cf31,
+    0x2cd99e8b,
+    0x5bdeae1d,
+    0x9b64c2b0,
+    0xec63f226,
+    0x756aa39c,
+    0x026d930a,
+    0x9c0906a9,
+    0xeb0e363f,
+    0x72076785,
+    0x05005713,
+    0x95bf4a82,
+    0xe2b87a14,
+    0x7bb12bae,
+    0x0cb61b38,
+    0x92d28e9b,
+    0xe5d5be0d,
+    0x7cdcefb7,
+    0x0bdbdf21,
+    0x86d3d2d4,
+    0xf1d4e242,
+    0x68ddb3f8,
+    0x1fda836e,
+    0x81be16cd,
+    0xf6b9265b,
+    0x6fb077e1,
+    0x18b74777,
+    0x88085ae6,
+    0xff0f6a70,
+    0x66063bca,
+    0x11010b5c,
+    0x8f659eff,
+    0xf862ae69,
+    0x616bffd3,
+    0x166ccf45,
+    0xa00ae278,
+    0xd70dd2ee,
+    0x4e048354,
+    0x3903b3c2,
+    0xa7672661,
+    0xd06016f7,
+    0x4969474d,
+    0x3e6e77db,
+    0xaed16a4a,
+    0xd9d65adc,
+    0x40df0b66,
+    0x37d83bf0,
+    0xa9bcae53,
+    0xdebb9ec5,
+    0x47b2cf7f,
+    0x30b5ffe9,
+    0xbdbdf21c,
+    0xcabac28a,
+    0x53b39330,
+    0x24b4a3a6,
+    0xbad03605,
+    0xcdd70693,
+    0x54de5729,
+    0x23d967bf,
+    0xb3667a2e,
+    0xc4614ab8,
+    0x5d681b02,
+    0x2a6f2b94,
+    0xb40bbe37,
+    0xc30c8ea1,
+    0x5a05df1b,
+    0x2d02ef8d
+};
+
+
+#define GET_MAC_ADDR_CRC(addr, crc)             \
+{                                               \
+    uint32_t    i;                              \
+    uint8_t     data;                           \
+                                                \
+    /* CRC calculation */                       \
+    crc = 0xffffffff;                           \
+    for (i=0; i < 6; i++)                       \
+    {                                           \
+        data = (uint8_t)(addr >> ((5-i)*8));    \
+        crc = crc^data;                         \
+        crc = crc_table[crc&0xff] ^ (crc>>8);   \
+    }                                           \
+}                                               \
+
+/*    Define a macro for getting the mirrored value of      */
+/*    a byte size number. (0x11010011 --> 0x11001011)       */
+/*    Sometimes the mirrored value of the CRC is required   */
+static __inline__ uint8_t GetMirror(uint8_t n)
+{
+    uint8_t mirror[16] =
+        {
+            0x00,
+            0x08,
+            0x04,
+            0x0c,
+            0x02,
+            0x0a,
+            0x06,
+            0x0e,
+            0x01,
+            0x09,
+            0x05,
+            0x0d,
+            0x03,
+            0x0b,
+            0x07,
+            0x0f
+        };
+    return ((uint8_t)(((mirror[n & 0x0f] << 4) | (mirror[n >> 4]))));
+}
+
+static __inline__ uint32_t GetMirror32(uint32_t n)
+{
+    return (((uint32_t)GetMirror((uint8_t)(n))<<24) |
+            ((uint32_t)GetMirror((uint8_t)(n>>8))<<16) |
+            ((uint32_t)GetMirror((uint8_t)(n>>16))<<8) |
+            ((uint32_t)GetMirror((uint8_t)(n>>24))));
+}
+
+#define MIRROR      GetMirror
+#define MIRROR_32   GetMirror32
+
+
+#endif /* __crc_mac_addr_ext_h */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
new file mode 100644
index 0000000..6e7b421
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -0,0 +1,206 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dpaa_ext.h
+
+ @Description   DPAA Application Programming Interface.
+*//***************************************************************************/
+#ifndef __DPAA_EXT_H
+#define __DPAA_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+/**************************************************************************//**
+ @Group         DPAA_grp Data Path Acceleration Architecture API
+
+ @Description   DPAA API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   Frame descriptor
+*//***************************************************************************/
+typedef _Packed struct t_DpaaFD {
+    volatile uint32_t    id;                /**< FD id */
+    volatile uint32_t    addrl;             /**< Data Address */
+    volatile uint32_t    length;            /**< Frame length */
+    volatile uint32_t    status;            /**< FD status */
+} _PackedType t_DpaaFD;
+
+/**************************************************************************//**
+ @Description   enum for defining frame format
+*//***************************************************************************/
+typedef enum e_DpaaFDFormatType {
+    e_DPAA_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
+                                                    small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
+                                                    (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
+                                                    and small length (9b OFFSET, 20b LENGTH) */
+    e_DPAA_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
+                                                    big length (29b LENGTH ,No OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
+                                                    No LENGTH or OFFSET) */
+    e_DPAA_FD_FORMAT_TYPE_DUMMY
+} e_DpaaFDFormatType;
+
+/**************************************************************************//**
+ @Collection   Frame descriptor macros
+*//***************************************************************************/
+#define DPAA_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
+#define DPAA_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define DPAA_FD_ELIODN_MASK   0x0000f000           /**< FD ELIODN field mask */
+#define DPAA_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
+#define DPAA_FD_ADDRH_MASK    0x000000ff           /**< FD ADDRH field mask */
+#define DPAA_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
+#define DPAA_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
+#define DPAA_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
+#define DPAA_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
+
+#define DPAA_FD_GET_DD(fd)            ((((t_DpaaFD *)fd)->id & DPAA_FD_DD_MASK) >> (31-1))              /**< Macro to get FD DD field */
+#define DPAA_FD_GET_PID(fd)           (((((t_DpaaFD *)fd)->id & DPAA_FD_PID_MASK) >> (31-7)) | \
+                                        ((((t_DpaaFD *)fd)->id & DPAA_FD_ELIODN_MASK) >> (31-19-6)))    /**< Macro to get FD PID field */
+#define DPAA_FD_GET_BPID(fd)          ((((t_DpaaFD *)fd)->id & DPAA_FD_BPID_MASK) >> (31-15))           /**< Macro to get FD BPID field */
+#define DPAA_FD_GET_ADDRH(fd)         (((t_DpaaFD *)fd)->id & DPAA_FD_ADDRH_MASK)                       /**< Macro to get FD ADDRH field */
+#define DPAA_FD_GET_ADDRL(fd)         ((t_DpaaFD *)fd)->addrl                                           /**< Macro to get FD ADDRL field */
+#define DPAA_FD_GET_PHYS_ADDR(fd)     ((physAddress_t)(((uint64_t)DPAA_FD_GET_ADDRH(fd) << 32) | (uint64_t)DPAA_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define DPAA_FD_GET_FORMAT(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_FORMAT_MASK) >> (31-2))      /**< Macro to get FD FORMAT field */
+#define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))     /**< Macro to get FD OFFSET field */
+#define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                  /**< Macro to get FD LENGTH field */
+#define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                          /**< Macro to get FD STATUS field */
+#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))
+
+#define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | (((val) << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
+                                                                                                        /**< Macro to set FD PID field or LIODN offset*/
+#define DPAA_FD_SET_PID(fd,val)       (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~(DPAA_FD_PID_MASK|DPAA_FD_ELIODN_MASK)) | ((((val) << (31-7)) & DPAA_FD_PID_MASK) | ((((val)>>6) << (31-19)) & DPAA_FD_ELIODN_MASK))))
+#define DPAA_FD_SET_BPID(fd,val)      (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_BPID_MASK) | (((val)  << (31-15)) & DPAA_FD_BPID_MASK))) /**< Macro to set FD BPID field */
+#define DPAA_FD_SET_ADDRH(fd,val)     (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_ADDRH_MASK) | ((val) & DPAA_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
+#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = (val)                                     /**< Macro to set FD ADDRL field */
+#define DPAA_FD_SET_ADDR(fd,val)                            \
+do {                                                        \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
+    DPAA_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));    \
+    DPAA_FD_SET_ADDRL(fd, (uint32_t)physAddr);              \
+} while (0)                                                                                             /**< Macro to set FD ADDR field */
+#define DPAA_FD_SET_FORMAT(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_FORMAT_MASK) | (((val)  << (31-2))& DPAA_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
+#define DPAA_FD_SET_OFFSET(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_OFFSET_MASK) | (((val) << (31-11))& DPAA_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
+#define DPAA_FD_SET_LENGTH(fd,val)    (((t_DpaaFD *)fd)->length = (((t_DpaaFD *)fd)->length & ~DPAA_FD_LENGTH_MASK) | ((val) & DPAA_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
+#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = (val)                                    /**< Macro to set FD STATUS field */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table Entry
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGTE {
+    volatile uint32_t    addrh;        /**< Buffer Address high */
+    volatile uint32_t    addrl;        /**< Buffer Address low */
+    volatile uint32_t    length;       /**< Buffer length */
+    volatile uint32_t    offset;       /**< SGTE offset */
+} _PackedType t_DpaaSGTE;
+
+#define DPAA_NUM_OF_SG_TABLE_ENTRY 16
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table
+*//***************************************************************************/
+typedef _Packed struct t_DpaaSGT {
+    t_DpaaSGTE    tableEntry[DPAA_NUM_OF_SG_TABLE_ENTRY];
+                                    /**< structure that hold the information about
+                                         a single S/G entry. */
+} _PackedType t_DpaaSGT;
+
+/**************************************************************************//**
+ @Description   Compound Frame Table
+*//***************************************************************************/
+typedef _Packed struct t_DpaaCompTbl {
+    t_DpaaSGTE    inputBuffInfo;    /**< structure that hold the information about
+                                         the compound-frame input buffer;
+                                         NOTE: this may point to a S/G table */
+    t_DpaaSGTE    outputBuffInfo;   /**< structure that hold the information about
+                                         the compound-frame output buffer;
+                                         NOTE: this may point to a S/G table */
+} _PackedType t_DpaaCompTbl;
+
+/**************************************************************************//**
+ @Collection   Frame Scatter/Gather Table Entry macros
+*//***************************************************************************/
+#define DPAA_SGTE_ADDRH_MASK    0x000000ff           /**< SGTE ADDRH field mask */
+#define DPAA_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
+#define DPAA_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
+#define DPAA_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
+#define DPAA_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
+#define DPAA_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
+#define DPAA_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
+
+#define DPAA_SGTE_GET_ADDRH(sgte)         (((t_DpaaSGTE *)sgte)->addrh & DPAA_SGTE_ADDRH_MASK)              /**< Macro to get SGTE ADDRH field */
+#define DPAA_SGTE_GET_ADDRL(sgte)         ((t_DpaaSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
+#define DPAA_SGTE_GET_PHYS_ADDR(sgte)     ((physAddress_t)(((uint64_t)DPAA_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)DPAA_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
+#define DPAA_SGTE_GET_EXTENSION(sgte)     ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_E_MASK) >> (31-0))     /**< Macro to get SGTE EXTENSION field */
+#define DPAA_SGTE_GET_FINAL(sgte)         ((((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_F_MASK) >> (31-1))     /**< Macro to get SGTE FINAL field */
+#define DPAA_SGTE_GET_LENGTH(sgte)        (((t_DpaaSGTE *)sgte)->length & DPAA_SGTE_LENGTH_MASK)            /**< Macro to get SGTE LENGTH field */
+#define DPAA_SGTE_GET_BPID(sgte)          ((((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_BPID_MASK) >> (31-15)) /**< Macro to get SGTE BPID field */
+#define DPAA_SGTE_GET_OFFSET(sgte)        (((t_DpaaSGTE *)sgte)->offset & DPAA_SGTE_OFFSET_MASK)            /**< Macro to get SGTE OFFSET field */
+#define DPAA_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(DPAA_SGTE_GET_PHYS_ADDR(sgte))
+
+#define DPAA_SGTE_SET_ADDRH(sgte,val)     (((t_DpaaSGTE *)sgte)->addrh = ((((t_DpaaSGTE *)sgte)->addrh & ~DPAA_SGTE_ADDRH_MASK) | ((val) & DPAA_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
+#define DPAA_SGTE_SET_ADDRL(sgte,val)     ((t_DpaaSGTE *)sgte)->addrl = (val)                                 /**< Macro to set SGTE ADDRL field */
+#define DPAA_SGTE_SET_ADDR(sgte,val)                            \
+do {                                                            \
+    uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));         \
+    DPAA_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));    \
+    DPAA_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);              \
+} while (0)                                                                                                 /**< Macro to set SGTE ADDR field */
+#define DPAA_SGTE_SET_EXTENSION(sgte,val) (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_E_MASK) | (((val)  << (31-0))& DPAA_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
+#define DPAA_SGTE_SET_FINAL(sgte,val)     (((t_DpaaSGTE *)sgte)->length = ((((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_F_MASK) | (((val)  << (31-1))& DPAA_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
+#define DPAA_SGTE_SET_LENGTH(sgte,val)    (((t_DpaaSGTE *)sgte)->length = (((t_DpaaSGTE *)sgte)->length & ~DPAA_SGTE_LENGTH_MASK) | ((val) & DPAA_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
+#define DPAA_SGTE_SET_BPID(sgte,val)      (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_BPID_MASK) | (((val)  << (31-15))& DPAA_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
+#define DPAA_SGTE_SET_OFFSET(sgte,val)    (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_OFFSET_MASK) | (((val) << (31-31))& DPAA_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
+/* @} */
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+/** @} */ /* end of DPAA_grp group */
+
+
+#endif /* __DPAA_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
new file mode 100644
index 0000000..037827e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -0,0 +1,1374 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ext.h
+
+ @Description   FM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_EXT
+#define __FM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "dpaa_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "singletone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmPortType {
+    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port (id's: 0-6, share id's with
+                                                 host command, so must have exclusive id) */
+    e_FM_PORT_TYPE_OH_HOST_COMMAND,         /**< Host command port (id's: 0-6, share id's with
+                                                 offline parsing ports, so must have exclusive id) */
+    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port (id's: 0-3) */
+    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port (id's: 0) */
+    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port (id's: 0-3) */
+    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_DUMMY
+} e_FmPortType;
+
+/**************************************************************************//**
+ @Collection    General FM defines
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_PARTITIONS    64      /**< Maximim number of partitions */
+#define FM_PHYS_ADDRESS_SIZE        6       /**< FM Physical address size */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
+
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non Frame-Manager error; probably come from SEC that
+                                                                         was chained to FM */
+#endif /* FM_CAPWAP_SUPPORT */
+#define FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                         Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< Keysize Overflow */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< Frame color is yellow */
+#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< Frame color is red */
+#define FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Policer frame length error */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPM Frame Processing Timeout Exceeded */
+/* @} */
+
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmPhysAddr {
+    volatile uint8_t    high;         /**< High part of the physical address */
+    volatile uint32_t   low;          /**< Low part of the physical address */
+} _PackedType t_FmPhysAddr;
+
+/**************************************************************************//**
+ @Description   Parse results memory layout
+*//***************************************************************************/
+typedef _Packed struct t_FmPrsResult {
+    volatile uint8_t     lpid;               /**< Logical port id */
+    volatile uint8_t     shimr;              /**< Shim header result  */
+    volatile uint16_t    l2r;                /**< Layer 2 result */
+    volatile uint16_t    l3r;                /**< Layer 3 result */
+    volatile uint8_t     l4r;                /**< Layer 4 result */
+    volatile uint8_t     cplan;              /**< Classification plan id */
+    volatile uint16_t    nxthdr;             /**< Next Header  */
+    volatile uint16_t    cksum;              /**< Checksum */
+    volatile uint32_t    lcv;                /**< LCV */
+    volatile uint8_t     shim_off[3];        /**< Shim offset */
+    volatile uint8_t     eth_off;            /**< ETH offset */
+    volatile uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
+    volatile uint8_t     vlan_off[2];        /**< VLAN offset */
+    volatile uint8_t     etype_off;          /**< ETYPE offset */
+    volatile uint8_t     pppoe_off;          /**< PPP offset */
+    volatile uint8_t     mpls_off[2];        /**< MPLS offset */
+    volatile uint8_t     ip_off[2];          /**< IP offset */
+    volatile uint8_t     gre_off;            /**< GRE offset */
+    volatile uint8_t     l4_off;             /**< Layer 4 offset */
+    volatile uint8_t     nxthdr_off;         /**< Parser end point */
+} _PackedType t_FmPrsResult;
+
+/**************************************************************************//**
+ @Description   Parse results
+*//***************************************************************************/
+#define FM_PR_L2_VLAN_STACK         0x00000100  /**< Parse Result: VLAN stack */
+#define FM_PR_L2_ETHERNET           0x00008000  /**< Parse Result: Ethernet*/
+#define FM_PR_L2_VLAN               0x00004000  /**< Parse Result: VLAN */
+#define FM_PR_L2_LLC_SNAP           0x00002000  /**< Parse Result: LLC_SNAP */
+#define FM_PR_L2_MPLS               0x00001000  /**< Parse Result: MPLS */
+#define FM_PR_L2_PPPoE              0x00000800  /**< Parse Result: PPPoE */
+
+/**************************************************************************//**
+ @Collection   FM Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_CMD_FCO               0x80000000  /**< Frame queue Context Override */
+#define FM_FD_CMD_RPD               0x40000000  /**< Read Prepended Data */
+#define FM_FD_CMD_UPD               0x20000000  /**< Update Prepended Data */
+#define FM_FD_CMD_DTC               0x10000000  /**< Do L4 Checksum */
+#define FM_FD_CMD_DCL4C             0x10000000  /**< Didn't calculate L4 Checksum */
+#define FM_FD_CMD_CFQ               0x00ffffff  /**< Confirmation Frame Queue */
+
+#define FM_FD_TX_STATUS_ERR_MASK    0x07000000  /**< TX Error FD bits */
+#define FM_FD_RX_STATUS_ERR_MASK    0x070ee3f8  /**< RX Error FD bits */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Context A
+*//***************************************************************************/
+typedef _Packed struct t_FmContextA {
+    volatile uint32_t    command;   /**< ContextA Command */
+    volatile uint8_t     res0[4];   /**< ContextA Reserved bits */
+} _PackedType t_FmContextA;
+
+/**************************************************************************//**
+ @Description   Context B
+*//***************************************************************************/
+typedef uint32_t t_FmContextB;
+
+/**************************************************************************//**
+ @Collection   Context A macros
+*//***************************************************************************/
+#define FM_CONTEXTA_OVERRIDE_MASK       0x80000000
+#define FM_CONTEXTA_ICMD_MASK           0x40000000
+#define FM_CONTEXTA_A1_VALID_MASK       0x20000000
+#define FM_CONTEXTA_MACCMD_MASK         0x00ff0000
+#define FM_CONTEXTA_MACCMD_VALID_MASK   0x00800000
+#define FM_CONTEXTA_MACCMD_SECURED_MASK 0x00100000
+#define FM_CONTEXTA_MACCMD_SC_MASK      0x000f0000
+#define FM_CONTEXTA_A1_MASK             0x0000ffff
+
+#define FM_CONTEXTA_GET_OVERRIDE(contextA)                 ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_OVERRIDE_MASK) >> (31-0))
+#define FM_CONTEXTA_GET_ICMD(contextA)                     ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_ICMD_MASK) >> (31-1))
+#define FM_CONTEXTA_GET_A1_VALID(contextA)                 ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_A1_VALID_MASK) >> (31-2))
+#define FM_CONTEXTA_GET_A1(contextA)                       ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_A1_MASK) >> (31-31))
+#define FM_CONTEXTA_GET_MACCMD(contextA)                   ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_MASK) >> (31-15))
+#define FM_CONTEXTA_GET_MACCMD_VALID(contextA)             ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_VALID_MASK) >> (31-8))
+#define FM_CONTEXTA_GET_MACCMD_SECURED(contextA)           ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_SECURED_MASK) >> (31-11))
+#define FM_CONTEXTA_GET_MACCMD_SECURE_CHANNEL(contextA)    ((((t_FmContextA *)contextA)->command & FM_CONTEXTA_MACCMD_SC_MASK) >> (31-15))
+
+#define FM_CONTEXTA_SET_OVERRIDE(contextA,val)              (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_OVERRIDE_MASK) | (((uint32_t)(val) << (31-0)) & FM_CONTEXTA_OVERRIDE_MASK) ))
+#define FM_CONTEXTA_SET_ICMD(contextA,val)                  (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_ICMD_MASK) | (((val) << (31-1)) & FM_CONTEXTA_ICMD_MASK) ))
+#define FM_CONTEXTA_SET_A1_VALID(contextA,val)              (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_A1_VALID_MASK) | (((val) << (31-2)) & FM_CONTEXTA_A1_VALID_MASK) ))
+#define FM_CONTEXTA_SET_A1(contextA,val)                    (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_A1_MASK) | (((val) << (31-31)) & FM_CONTEXTA_A1_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD(contextA,val)                (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_MASK) | (((val) << (31-15)) & FM_CONTEXTA_MACCMD_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_VALID(contextA,val)          (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_VALID_MASK) | (((val) << (31-8)) & FM_CONTEXTA_MACCMD_VALID_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_SECURED(contextA,val)        (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_SECURED_MASK) | (((val) << (31-11)) & FM_CONTEXTA_MACCMD_SECURED_MASK) ))
+#define FM_CONTEXTA_SET_MACCMD_SECURE_CHANNEL(contextA,val) (((t_FmContextA *)contextA)->command = (uint32_t)((((t_FmContextA *)contextA)->command & ~FM_CONTEXTA_MACCMD_SC_MASK) | (((val) << (31-15)) & FM_CONTEXTA_MACCMD_SC_MASK) ))
+/* @} */
+
+/**************************************************************************//**
+ @Collection   Context B macros
+*//***************************************************************************/
+#define FM_CONTEXTB_FQID_MASK               0x00ffffff
+
+#define FM_CONTEXTB_GET_FQID(contextB)      (*((t_FmContextB *)contextB) & FM_CONTEXTB_FQID_MASK)
+#define FM_CONTEXTB_SET_FQID(contextB,val)  (*((t_FmContextB *)contextB) = ((*((t_FmContextB *)contextB) & ~FM_CONTEXTB_FQID_MASK) | ((val) & FM_CONTEXTB_FQID_MASK)))
+/* @} */
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum e_FmExceptions {
+    e_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_FM_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
+    e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
+    e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} e_FmExceptions;
+
+/**************************************************************************//**
+ @Group         FM_init_grp FM Initialization Unit
+
+ @Description   FM Initialization Unit
+
+                Initialization Flow
+                Initialization of the FM Module will be carried out by the application
+                according to the following sequence:
+                a.  Calling the configuration routine with basic parameters.
+                b.  Calling the advance initialization routines to change driver's defaults.
+                c.  Calling the initialization routine.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+*//***************************************************************************/
+typedef void (t_FmExceptionsCallback) (t_Handle              h_App,
+                                       e_FmExceptions        exception);
+
+/**************************************************************************//**
+ @Function      t_FmBusErrorCallback
+
+ @Description   Bus error user callback routine, will be called upon a
+                bus error, passing parameters describing the errors and the owner.
+
+ @Param[in]     h_App       - User's application descriptor.
+ @Param[in]     portType    - Port type (e_FmPortType)
+ @Param[in]     portId      - Port id - relative to type.
+ @Param[in]     addr        - Address that caused the error
+ @Param[in]     tnum        - Owner of error
+ @Param[in]     liodn       - Logical IO device number
+*//***************************************************************************/
+typedef void (t_FmBusErrorCallback) (t_Handle        h_App,
+                                     e_FmPortType    portType,
+                                     uint8_t         portId,
+                                     uint64_t        addr,
+                                     uint8_t         tnum,
+                                     uint16_t        liodn);
+
+/**************************************************************************//**
+ @Description   structure for defining Ucode patch for loading.
+*//***************************************************************************/
+typedef struct t_FmPcdFirmwareParams {
+    uint32_t                size;                   /**< Size of uCode */
+    uint32_t                *p_Code;                /**< A pointer to the uCode */
+} t_FmPcdFirmwareParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+#define FM_SIZE_OF_LIODN_TABLE  64
+typedef struct t_FmParams {
+    uint8_t                 fmId;                   /**< Index of the FM */
+
+    uint8_t                 guestId;                /**< FM Partition Id */
+
+    uintptr_t               baseAddr;               /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         A pointer to base of memory mapped FM registers (virtual);
+                                                         NOTE that this should include ALL common regs of the FM including
+                                                         the PCD regs area. */
+    t_Handle                h_FmMuram;              /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         A handle of an initialized MURAM object,
+                                                         to be used by the FM */
+    uint16_t                fmClkFreq;              /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         In Mhz */
+#ifdef FM_PARTITION_ARRAY
+    uint16_t                liodnBasePerPort[FM_SIZE_OF_LIODN_TABLE];
+                                                    /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         For each partition, LIODN should be configured here. */
+#endif /* FM_PARTITION_ARRAY */
+    t_FmExceptionsCallback  *f_Exception;           /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         An application callback routine to
+                                                         handle exceptions.*/
+    t_FmBusErrorCallback    *f_BusError;            /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         An application callback routine to
+                                                         handle exceptions.*/
+    t_Handle                h_App;                  /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+    int                     irq;                    /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         FM interrupt source for normal events */
+    int                     errIrq;                 /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         FM interrupt source for errors */
+    t_FmPcdFirmwareParams   firmware;               /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         Ucode */
+} t_FmParams;
+
+
+/**************************************************************************//**
+ @Function      FM_Config
+
+ @Description   Creates descriptor for the FM module.
+
+                The routine returns a handle (descriptor) to the FM object.
+                This descriptor must be passed as first parameter to all other
+                FM function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmParams  - A pointer to data structure of parameters
+
+ @Return        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_Config(t_FmParams *p_FmParams);
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm);
+
+
+/**************************************************************************//**
+ @Group         FM_advanced_init_grp    FM Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values;
+                Note: Advanced init routines are not available for guest partition.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   DMA debug mode
+*//***************************************************************************/
+typedef enum e_FmDmaDbgCntMode {
+    e_FM_DMA_DBG_NO_CNT             = 0,    /**< No counting */
+    e_FM_DMA_DBG_CNT_DONE,                  /**< Count DONE commands */
+    e_FM_DMA_DBG_CNT_COMM_Q_EM,             /**< count command queue emergency signals */
+    e_FM_DMA_DBG_CNT_INT_READ_EM,           /**< Count Internal Read buffer emergency signal */
+    e_FM_DMA_DBG_CNT_INT_WRITE_EM,          /**< Count Internal Write buffer emergency signal */
+    e_FM_DMA_DBG_CNT_FPM_WAIT,              /**< Count FPM WAIT signal */
+    e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC,         /**< Single bit ECC errors. */
+    e_FM_DMA_DBG_CNT_RAW_WAR_PROT           /**< Number of times there was a need for RAW & WAR protection. */
+} e_FmDmaDbgCntMode;
+
+/**************************************************************************//**
+ @Description   DMA Cache Override
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOverride {
+    e_FM_DMA_NO_CACHE_OR = 0,               /**< No override of the Cache field */
+    e_FM_DMA_NO_STASH_DATA,                 /**< Data should not be stashed in system level cache */
+    e_FM_DMA_MAY_STASH_DATA,                /**< Data may be stashed in system level cache */
+    e_FM_DMA_STASH_DATA                     /**< Data should be stashed in system level cache */
+} e_FmDmaCacheOverride;
+
+/**************************************************************************//**
+ @Description   DMA External Bus Priority
+*//***************************************************************************/
+typedef enum e_FmDmaExtBusPri {
+    e_FM_DMA_EXT_BUS_NORMAL = 0,            /**< Normal priority */
+    e_FM_DMA_EXT_BUS_EBS,                   /**< AXI extended bus service priority */
+    e_FM_DMA_EXT_BUS_SOS,                   /**< AXI sos priority */
+    e_FM_DMA_EXT_BUS_EBS_AND_SOS            /**< AXI ebs + sos priority */
+} e_FmDmaExtBusPri;
+
+/**************************************************************************//**
+ @Description   enum for choosing the field that will be output on AID
+*//***************************************************************************/
+typedef enum e_FmDmaAidMode {
+    e_FM_DMA_AID_OUT_PORT_ID = 0,           /**< 4 LSB of PORT_ID */
+    e_FM_DMA_AID_OUT_TNUM                   /**< 4 LSB of TNUM */
+} e_FmDmaAidMode;
+
+/**************************************************************************//**
+ @Description   FPM Catasrophic error behaviour
+*//***************************************************************************/
+typedef enum e_FmCatastrophicErr {
+    e_FM_CATASTROPHIC_ERR_STALL_PORT = 0,   /**< Port_ID is stalled (only reset can release it) */
+    e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only errornous task is stalled */
+} e_FmCatastrophicErr;
+
+/**************************************************************************//**
+ @Description   FPM DMA error behaviour
+*//***************************************************************************/
+typedef enum e_FmDmaErr {
+    e_FM_DMA_ERR_CATASTROPHIC = 0,          /**< Dma error is treated as a catastrophic error */
+    e_FM_DMA_ERR_REPORT                     /**< Dma error is just reported */
+} e_FmDmaErr;
+
+/**************************************************************************//**
+ @Description   DMA Emergency level by BMI emergency signal
+*//***************************************************************************/
+typedef enum e_FmDmaEmergencyLevel {
+    e_FM_DMA_EM_EBS = 0,                    /**< EBS emergency */
+    e_FM_DMA_EM_SOS                         /**< SOS emergency */
+} e_FmDmaEmergencyLevel;
+
+/**************************************************************************//**
+ @Collection   DMA emergency options
+*//***************************************************************************/
+typedef uint32_t fmEmergencyBus_t;          /**< DMA emergency options */
+
+#define  FM_DMA_MURAM_READ_EMERGENCY        0x00800000    /**< Enable emergency for MURAM1 */
+#define  FM_DMA_MURAM_WRITE_EMERGENCY       0x00400000    /**< Enable emergency for MURAM2 */
+#define  FM_DMA_EXT_BUS_EMERGENCY           0x00100000    /**< Enable emergency for external bus */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A structure for defining DMA emergency level
+*//***************************************************************************/
+typedef struct t_FmDmaEmergency {
+    fmEmergencyBus_t        emergencyBusSelect;             /**< An OR of the busses where emergency
+                                                                 should be enabled */
+    e_FmDmaEmergencyLevel   emergencyLevel;                 /**< EBS/SOS */
+} t_FmDmaEmergency;
+
+/**************************************************************************//**
+ @Description   structure for defining FM threshold
+*//***************************************************************************/
+typedef struct t_FmThresholds {
+    uint8_t                 dispLimit;                      /**< The number of times a frames may
+                                                                 be passed in the FM before assumed to
+                                                                 be looping. */
+    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the parser dispatch queue*/
+    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
+                                                                 queued in the policer dispatch queue*/
+    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
+                                                                 queued in the keygen dispatch queue*/
+    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the BMI dispatch queue*/
+    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI enqueue dispatch queue*/
+    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI dequeue dispatch queue*/
+    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl1 dispatch queue*/
+    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl2 dispatch queue*/
+} t_FmThresholds;
+
+
+/**************************************************************************//**
+ @Description   structure for defining DMA thresholds
+*//***************************************************************************/
+typedef struct t_FmDmaThresholds {
+    uint8_t                     assertEmergency;            /**< When this value is reached,
+                                                                 assert emergency (Threshold)*/
+    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
+                                                                 until this value is reached (Hystheresis) */
+} t_FmDmaThresholds;
+
+
+/**************************************************************************//**
+ @Function      FM_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM before initialization or
+                not. It changes the default configuration [FALSE].
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     enable              When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalNumOfTasks
+
+ @Description   Change the total number of tasks from its default
+                configuration [BMI_MAX_NUM_OF_TASKS]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalNumOfTasks     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalFifoSize
+
+ @Description   Change the total Fifo size from its default
+                configuration [BMI_MAX_FIFO_SIZE]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalFifoSize       The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
+
+/**************************************************************************//**
+ @Function      FM_ConfigMaxNumOfOpenDmas
+
+ @Description   Change the maximum allowed open DMA's for this FM from its default
+                configuration [BMI_MAX_NUM_OF_DMAS]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     maxNumOfOpenDmas    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_ConfigThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration:
+                                          dispLimit:    [16]
+                                          prsDispTh:    [16]
+                                          plcrDispTh:   [16]
+                                          kgDispTh:     [16]
+                                          bmiDispTh:    [16]
+                                          qmiEnqDispTh: [16]
+                                          qmiDeqDispTh: [16]
+                                          fmCtl1DispTh:  [16]
+                                          fmCtl2DispTh:  [16]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     p_FmThresholds  A structure of threshold parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCacheOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of cache override mode [e_FM_DMA_NO_CACHE_OR]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     cacheOverride   The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid override mode [TRUE]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidOverride     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid mode [e_FM_DMA_AID_OUT_TNUM]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidMode         The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAxiDbgNumOfBeats
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of axi debug [1]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     axiDbgNumOfBeats    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaCamNumOfEntries
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of number of CAM entries [32]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     numOfEntries    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWatchdog
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default watchdog configuration, which is disabled
+                [0].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     watchDogValue   The selected new value - in microseconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWriteBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA write buffer threshold
+                assertEmergency: [DMA_THRESH_MAX_BUF]
+                clearEmergency:  [DMA_THRESH_MAX_BUF]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCommQThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA command queue threshold
+                assertEmergency: [DMA_THRESH_MAX_COMMQ]
+                clearEmergency:  [DMA_THRESH_MAX_COMMQ]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaReadBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA read buffer threshold
+                assertEmergency: [DMA_THRESH_MAX_BUF]
+                clearEmergency:  [DMA_THRESH_MAX_BUF]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaSosEmergencyThreshold
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default dma SOS emergency configuration [0]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     dmaSosEmergency     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableCounters
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default counters configuration where counters are disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaDbgCounter
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA debug counters configuration [e_FM_DMA_DBG_NO_CNT]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     fmDmaDbgCntMode     An enum selecting the debug counter mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaStopOnBusErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of bus error behavior [FALSE]
+
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     stop    TRUE to stop on bus error, FALSE to continue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                Only if bus error is enabled.
+*//***************************************************************************/
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergency
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of DMA emergency where's it's disabled.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     p_Emergency An OR mask of all required options.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergencySmoother
+
+ @Description   sets the minimum amount of DATA beats transferred on the AXI
+                READ and WRITE ports before lowering the emergency level.
+                By default smother is disabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     emergencyCnt    emergency switching counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA error treatment [e_FM_DMA_ERR_CATASTROPHIC]
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     dmaErr  The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigCatastrophicErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default behavior on catastrophic error [e_FM_CATASTROPHIC_ERR_STALL_PORT]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     catastrophicErr     The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableMuramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableIramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnExternalActivation
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on external halt
+                activation [FALSE].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on external halt
+                                activation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnUnrecoverableEccError
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on unrecoverable
+                Ecc error [FALSE].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on unrecoverable Ecc error
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigExternalEccRamsEnable
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default [FALSE].
+                When this option is enabled Rams ECC enable is not effected
+                by the FPM RCR bit, but by a JTAG.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable this option.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTnumAgingPeriod
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration for aging of dequeue TNUM's
+                in the QMI.[0]
+                Note that this functionality is not available in all chips.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     tnumAgingPeriod     Tnum Aging Period in microseconds.
+                                    Note that period is recalculated in units of
+                                    64 FM clocks. Driver will pick the closest
+                                    possible period.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
+
+/** @} */ /* end of FM_advanced_init_grp group */
+/** @} */ /* end of FM_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_VALID_PORTS   (FM_MAX_NUM_OF_OH_PORTS +       \
+                                     FM_MAX_NUM_OF_1G_RX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_RX_PORTS +   \
+                                     FM_MAX_NUM_OF_1G_TX_PORTS +    \
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)
+/* @} */
+
+/**************************************************************************//**
+ @Description   Structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+*//***************************************************************************/
+typedef struct t_FmPortBandwidth {
+    e_FmPortType        type;           /**< FM port type */
+    uint8_t             relativePortId; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} t_FmPortBandwidth;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
+*//***************************************************************************/
+typedef struct t_FmPortsBandwidthParams {
+    uint8_t             numOfPorts;         /**< num of ports listed in the array below */
+    t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
+                                            /**< for each port, it's bandwidth (all port's
+                                                 bandwidths must add up to 100.*/
+} t_FmPortsBandwidthParams;
+
+/**************************************************************************//**
+ @Description   DMA Emergency control on MURAM
+*//***************************************************************************/
+typedef enum e_FmDmaMuramPort {
+    e_FM_DMA_MURAM_PORT_WRITE,              /**< MURAM write port */
+    e_FM_DMA_MURAM_PORT_READ                /**< MURAM read port */
+} e_FmDmaMuramPort;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmCounters {
+    e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,              /**< QMI total enqueued frames counter */
+    e_FM_COUNTERS_DEQ_TOTAL_FRAME,                  /**< QMI total dequeued frames counter */
+    e_FM_COUNTERS_DEQ_0,                            /**< QMI 0 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_1,                            /**< QMI 1 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_2,                            /**< QMI 2 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_3,                            /**< QMI 3 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_FROM_DEFAULT,                 /**< QMI dequeue from default queue counter */
+    e_FM_COUNTERS_DEQ_FROM_CONTEXT,                 /**< QMI dequeue from FQ context counter */
+    e_FM_COUNTERS_DEQ_FROM_FD,                      /**< QMI dequeue from FD command field counter */
+    e_FM_COUNTERS_DEQ_CONFIRM,                      /**< QMI dequeue confirm counter */
+    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,       /**< DMA semaphor reject due to full entry counter */
+    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,       /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT              /**< DMA semaphor reject due to sync counter */
+} e_FmCounters;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct t_FmRevisionInfo {
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmRevisionInfo;
+
+/**************************************************************************//**
+ @Description   struct for defining DMA status
+*//***************************************************************************/
+typedef struct t_FmDmaStatus {
+    bool    cmqNotEmpty;            /**< Command queue is not empty */
+    bool    busError;               /**< Bus error occured */
+    bool    readBufEccError;        /**< Double ECC error on buffer Read */
+    bool    writeBufEccSysError;    /**< Double ECC error on buffer write from system side */
+    bool    writeBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+} t_FmDmaStatus;
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_DumpRegs
+
+ @Description   Dumps all FM registers
+
+ @Param[in]     h_Fm      A handle to an FM Module.
+
+ @Return        E_OK on success;
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FM_DumpRegs(t_Handle h_Fm);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
+
+/**************************************************************************//**
+ @Function      FM_EnableRamsEcc
+
+ @Description   Enables ECC mechanism for all the different FM RAM's; E.g. IRAM,
+                MURAM, Parser, Keygen, Policer, etc.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                This routine is also called by the driver if an ECC exception is
+                enabled.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_EnableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_DisableRamsEcc
+
+ @Description   Disables ECC mechanism for all the different FM RAM's; E.g. IRAM,
+                MURAM, Parser, Keygen, Policer, etc.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                In opposed to FM_EnableRamsEcc, this routine must be called
+                explicitly to disable all Rams ECC.
+                Note: Not available for guest partition.
+
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_DisableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_GetRevision
+
+ @Description   Returns the FM revision
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_FmRevisionInfo    A structure of revision information parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+/**************************************************************************//**
+ @Function      FM_GetCounter
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     val         The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+
+/**************************************************************************//**
+ @Function      FM_Resume
+
+ @Description   Release FM after halt FM command or after unrecoverable ECC error.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+void FM_Resume(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_SetDmaEmergency
+
+ @Description   Manual emergency set
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     muramPort   MURAM direction select.
+ @Param[in]     enable      TRUE to manualy enable emergency, FALSE to disable.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetDmaExtBusPri
+
+ @Description   Manual emergency set
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     pri     External bus priority select
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
+
+/**************************************************************************//**
+ @Function      FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_GetDmaStatus
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_FmDmaStatus      A structure of DMA status parameters.
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
+
+/**************************************************************************//**
+ @Function      FM_GetPcdHandle
+
+ @Description   Used by FMC in order to get PCD handle
+
+ @Param[in]     h_Fm     A handle to an FM Module.
+
+ @Return        A handle to the PCD module, NULL if uninitialized.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ErrorIsr
+                Note: Not available for guest partition.
+
+ @Description   FM interrupt-service-routine for errors.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+void FM_ErrorIsr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_EventIsr
+                Note: Not available for guest partition.
+
+ @Description   FM interrupt-service-routine for normal events.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+void FM_EventIsr(t_Handle h_Fm);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FmDumpPortRegs
+
+ @Description   Dumps FM port registers which are part of FM common registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     hardwarePortId    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/** @} */ /* end of FM_runtime_control_grp group */
+/** @} */ /* end of FM_lib_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
new file mode 100644
index 0000000..9046308
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -0,0 +1,708 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_mac_ext.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_EXT_H
+#define __FM_MAC_EXT_H
+
+#include "std_ext.h"
+#include "enet_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_mac_grp FM MAC
+
+ @Description   FM MAC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   FM MAC Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacExceptions {
+    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO
+   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL
+   ,e_FM_MAC_EX_10G_REM_FAULT
+   ,e_FM_MAC_EX_10G_LOC_FAULT
+   ,e_FM_MAC_EX_10G_1TX_ECC_ER
+   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL
+   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL
+   ,e_FM_MAC_EX_10G_TX_ER
+   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL
+   ,e_FM_MAC_EX_10G_RX_ECC_ER
+   ,e_FM_MAC_EX_10G_RX_JAB_FRM
+   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM
+   ,e_FM_MAC_EX_10G_RX_RUNT_FRM
+   ,e_FM_MAC_EX_10G_RX_FRAG_FRM
+   ,e_FM_MAC_EX_10G_RX_LEN_ER
+   ,e_FM_MAC_EX_10G_RX_CRC_ER
+   ,e_FM_MAC_EX_10G_RX_ALIGN_ER
+   ,e_FM_MAC_EX_1G_BAB_RX
+   ,e_FM_MAC_EX_1G_RX_CTL
+   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET
+   ,e_FM_MAC_EX_1G_BAB_TX
+   ,e_FM_MAC_EX_1G_TX_CTL
+   ,e_FM_MAC_EX_1G_TX_ERR
+   ,e_FM_MAC_EX_1G_LATE_COL
+   ,e_FM_MAC_EX_1G_COL_RET_LMT
+   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN
+   ,e_FM_MAC_EX_1G_MAG_PCKT
+   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET
+   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET
+   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET
+   ,e_FM_MAC_EX_1G_TX_DATA_ERR
+   ,e_FM_MAC_EX_1G_RX_DATA_ERR
+   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR
+} e_FmMacExceptions;
+
+/**************************************************************************//**
+ @Description   TM MAC statistics level
+*//***************************************************************************/
+typedef enum e_FmMacStatisticsLevel {
+    e_FM_MAC_NONE_STATISTICS = 0,       /**< No statistics */
+    e_FM_MAC_PARTIAL_STATISTICS,        /**< Only error counters are available. Optimized for performance */
+    e_FM_MAC_FULL_STATISTICS            /**< All counters available. Not optimized for performance */
+} e_FmMacStatisticsLevel;
+
+
+/**************************************************************************//**
+ @Function      t_FmMacExceptionCallback
+
+ @Description   Fm Mac Exception Callback from FM MAC to the user
+
+ @Param[in]     h_App             - Handle to the upper layer handler
+
+ @Param[in]     exceptions        - The exception that occured
+
+
+ @Return        void.
+*//***************************************************************************/
+typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions);
+
+
+/**************************************************************************//**
+ @Description   TM MAC statistics rfc3635
+*//***************************************************************************/
+typedef struct t_FmMacStatistics {
+/* RMON */
+    uint64_t  eStatPkts64;             /**< r-10G tr-DT 64 byte frame counter */
+    uint64_t  eStatPkts65to127;        /**< r-10G 65 to 127 byte frame counter */
+    uint64_t  eStatPkts128to255;       /**< r-10G 128 to 255 byte frame counter */
+    uint64_t  eStatPkts256to511;       /**< r-10G 256 to 511 byte frame counter */
+    uint64_t  eStatPkts512to1023;      /**< r-10G 512 to 1023 byte frame counter */
+    uint64_t  eStatPkts1024to1518;     /**< r-10G 1024 to 1518 byte frame counter */
+    uint64_t  eStatPkts1519to1522;     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client. */
+    uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
+    uint64_t  eStatUndersizePkts;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    uint64_t  eStatOversizePkts;       /**< T,B.D*/
+/* Pause */
+    uint64_t  teStatPause;             /**< Pause MAC Control received */
+    uint64_t  reStatPause;             /**< Pause MAC Control sent */
+
+/* MIB II */
+    uint64_t  ifInOctets;              /**< Total number of byte received. */
+    uint64_t  ifInPkts;                /**< Total number of packets received.*/
+    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received*/
+    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
+    uint64_t  ifInErrors;              /**< Number of frames received with error:
+                                               - FIFO Overflow Error
+                                               - CRC Error
+                                               - Frame Too Long Error
+                                               - Alignment Error
+                                               - The dedicated Error Code (0xfe, not a code error) was received */
+    uint64_t  ifOutOctets;             /**< Total number of byte sent. */
+    uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
+    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
+                                               - FIFO Overflow Error
+                                               - FIFO Underflow Error
+                                               - Other */
+} t_FmMacStatistics;
+
+
+/**************************************************************************//**
+ @Group         FM_mac_init_grp Initialization Unit
+
+ @Description   FM MAC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM MAC config input
+*//***************************************************************************/
+typedef struct t_FmMacParams {
+    uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
+    t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
+    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G 0>         */
+    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
+                                                         MACs; MUST be set to 'NO_IRQ' for MACs that don't have
+                                                         mdio-irq, or for polling */
+    t_FmMacExceptionCallback    *f_Event;           /**< MDIO Events Callback Routine         */
+    t_FmMacExceptionCallback    *f_Exception;       /**< Exception Callback Routine         */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmMacParams;
+
+
+/**************************************************************************//**
+ @Function      FM_MAC_Config
+
+ @Description   Creates descriptor for the FM MAC module.
+
+                The routine returns a handle (descriptor) to the FM MAC object.
+                This descriptor must be passed as first parameter to all other
+                FM MAC function calls.
+
+                No actual initialization or configuration of FM MAC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacParam   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM MAC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Init
+
+ @Description   Initializes the FM MAC module
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Init (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM MAC module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Free (t_Handle h_FmMac);
+
+
+/**************************************************************************//**
+ @Group         FM_mac_advanced_init_grp    Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM MAC before initialization or
+                not. It changes the default configuration [DEFAULT_resetOnInit].
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLoopback
+
+ @Description   Enable/Disable internal loopback mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigMaxFrameLength
+
+ @Description   Setup maximum Frame Length
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     MAX Frame length
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigWan
+
+ @Description   ENABLE WAN mode in 10G MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigPadAndCrc
+
+ @Description   Config PAD and CRC mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHalfDuplex
+
+ @Description   Config Half Duplex Mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLengthCheck
+
+ @Description   Configure thef frame length checking.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigException
+
+ @Description   Change Excption selection from default
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired excpetions
+ @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac);
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+/** @} */ /* end of FM_mac_advanced_init_grp group */
+/** @} */ /* end of FM_mac_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_mac_runtime_control_grp Runtime Control Unit
+
+ @Description   FM MAC Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable
+
+ @Description   Enable the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Mode of operation (RX, TX, Both)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable
+
+ @Description   DISABLE the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Define what part to Disable (RX,  TX or BOTH)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable1588TimeStamp
+
+ @Description   Enables the TSU operation.
+
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable1588TimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable1588TimeStamp
+
+ @Description   Disables the TSU operation.
+
+ @Param[in]     h_Fm   - Handle to the PTP as returned from the FM_MAC_PtpConfig.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetTxAutoPauseFrames
+
+ @Description   Enable/Disable transmition of Pause-Frames.
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     pauseTime   Pause quanta value used with transmitted pause frames.
+                            Each quanta represents a 512 bit-times; Note that '0'
+                            as an input here will be used as disabling the
+                            transmission of the pause-frames.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetRxIgnorePauseFrames
+
+ @Description   Enable/Disable ignoring of Pause-Frames.
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     en          boolean indicates whether to ignore the incoming pause
+                            frames or not.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ResetCounters
+
+ @Description   reset all statistics counters
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetException
+
+ @Description   Enable/Disable a sspecific Excption
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired excpetions
+ @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetStatistics
+
+ @Description   Define Statistics level.
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     statisticsLevel Full statistics level provides all standard counters but may
+                                reduce performance. Partial statistics provides only special
+                                event counters (errors etc.). If selected, regular counters (such as
+                                byte/packet) will be invalid and will return -1.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     p_Statistics    Staructure with statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ModifyMacAddr
+
+ @Description   Replace the main MAC Address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filterd out in upper FM blocks.
+*//***************************************************************************/
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddExactMatchMacAddr
+
+ @Description   Add a unicast or multicast mac address (8 on dTSEC, 1 on 10G).
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to ADD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemovelExactMatchMacAddr
+
+ @Description   Remove a uni cast or multi cast mac address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to remove
+
+ @Return        E_OK on success; Error code otherwise..
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetPromiscuous
+
+ @Description   Enable/Disable MAC Promiscuous mode for ALL mac addresses.
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     enable     - TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AdjustLink
+
+ @Description   Adjusts the Ethernet link with new speed/duplex setup.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+ @Param[in]     speed       - Ethernet speed.
+ @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
+                              FALSE for Half-Duplex mode.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetId
+
+ @Description   Return the MAC ID
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[out]    p_MacId     -   MAC ID of device
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *p_MacId);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetVesrion
+
+ @Description   Return Mac HW chip version
+
+ @Param[in]     h_FmMac      -   A handle to a FM Module.
+ @Param[out]    p_MacVresion -   Mac version as defined by the chip
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *p_MacVresion);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_WritePhyReg
+
+ @Description   Write data into Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[in]     data        -   Data to write.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_ReadPhyReg
+
+ @Description   Read data from Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[out]    p_Data      -   Data from PHY.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_MAC_DumpRegs
+
+ @Description   Dump internal registers
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of FM_mac_runtime_control_grp group */
+/** @} */ /* end of FM_mac_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+
+#endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
new file mode 100644
index 0000000..8bc4a88
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -0,0 +1,144 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_muram_ext.h
+
+ @Description   FM MURAM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_MURAM_EXT
+#define __FM_MURAM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_grp FM MURAM
+
+ @Description   FM MURAM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_init_grp FM MURAM Initialization
+
+ @Description   FM MURAM initialization API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_ConfigAndInit
+
+ @Description   Creates partition in the MURAM.
+
+                The routine returns a handle (descriptor) to the MURAM partition.
+                This descriptor must be passed as first parameter to all other
+                FM-MURAM function calls.
+
+                No actual initialization or configuration of FM_MURAM hardware is
+                done by this routine.
+
+ @Param[in]     baseAddress - Pointer to base of memory mapped FM-MURAM.
+ @Param[in]     size        - Size of the FM-MURAM partition.
+
+ @Return        Handle to FM-MURAM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MURAM_ConfigAndInit(uintptr_t baseAddress, uint32_t size);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_Free
+
+ @Description   Frees all resources that were assigned to FM-MURAM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram);
+
+/** @} */ /* end of FM_muram_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_muram_ctrl_grp FM MURAM Control
+
+ @Description   FM MURAM control API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_AllocMem
+
+ @Description   Allocate some memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     size      - size of the memory to be allocated.
+ @Param[in]     align     - Alignment of the memory.
+
+ @Return        address of the allocated memory; NULL otherwise.
+*//***************************************************************************/
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_FreeMem
+
+ @Description   Free an allocated memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     ptr       - A pointer to an allocated memory.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr);
+
+/** @} */ /* end of FM_muram_ctrl_grp group */
+/** @} */ /* end of FM_muram_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+
+#endif /* __FM_MURAM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
new file mode 100644
index 0000000..ccb5c70
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -0,0 +1,2341 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ext.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_EXT
+#define __FM_PCD_EXT
+
+#include "std_ext.h"
+#include "net_ext.h"
+#include "list_ext.h"
+#include "fm_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
+
+#define FM_PCD_NONE                                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_PRS                                  0x80000000          /**< Parser indicated */
+#define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
+#define FM_PCD_MANIP                                0x08000000          /**< Manipulation indicated */
+
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
+
+#define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                        /**< number of distinction units is limited by
+                                                                             register size (32), - reserved bits for
+                                                                             private headers. */
+
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                             For reason of HW implemetation, in most
+                                                                             cases less than this will be allowed. The
+                                                                             driver will return error in initialization
+                                                                             time if resource is overused. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of sw parser area */
+#define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+#define FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+#define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_OFFSET-FM_PCD_PRS_SW_TAIL_SIZE)
+                                                                        /**< Max possible size of SW parser code */
+
+#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Max possible size of insertion template for
+                                                                             insert manipulation*/
+/* @} */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   FM PCD Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum e_FmPcdCounters {
+    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} e_FmPcdCounters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum e_FmPcdExceptions {
+    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Self init complete */
+    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Atomic action complete */
+    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser ECC error */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single ECC */
+} e_FmPcdExceptions;
+
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPcdExceptionCallback) (t_Handle h_App, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an exception
+                passing the exception identification.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     exception       - The exception.
+ @Param[in]     index           - id of the relevant source (may be scheme or profile id).
+ *//***************************************************************************/
+typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
+                                            e_FmPcdExceptions  exception,
+                                            uint16_t           index);
+
+/**************************************************************************//**
+ @Description   A callback for enquing frame onto a QM queue.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     p_Fd            - Frame descriptor for the frame.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
+
+/**************************************************************************//**
+ @Description   A structure for Host-Command
+                When using Host command for PCD functionalities, a dedicated port
+                must be used. If this routine is called for a PCD in a single partition
+                environment, or it is the Master partition in a Multi partition
+                environment, The port will be initialized by the PCD driver
+                initialization routine.
+ *//***************************************************************************/
+typedef struct t_FmPcdHcParams {
+    uintptr_t                   portBaseAddr;       /**< Host-Command Port Virtual Address of
+                                                         memory mapped registers.*/
+    uint8_t                     portId;             /**< Host-Command Port Id (0-6 relative
+                                                         to Host-Command/Offline parsing ports) */
+    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
+                                                         used together with LIODN offset. */
+    uint32_t                    errFqid;            /**< Host-Command Port Error Queue Id. */
+    uint32_t                    confFqid;           /**< Host-Command Port Confirmation queue Id. */
+    uint32_t                    qmChannel;          /**< Host-Command port - QM-channel dedicated to
+                                                         this port will be used by the FM for dequeue. */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Call back routine for enquing a frame to the QM */
+    t_Handle                    h_QmArg;            /**< A handle of the QM module */
+} t_FmPcdHcParams;
+
+/**************************************************************************//**
+ @Description   The main structure for PCD initialization
+ *//***************************************************************************/
+typedef struct t_FmPcdParams {
+    bool                        prsSupport;             /**< TRUE if Parser will be used for any
+                                                             of the FM ports */
+    bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
+                                                             of the FM ports */
+    bool                        kgSupport;              /**< TRUE if Keygen will be used for any
+                                                             of the FM ports */
+    bool                        plcrSupport;            /**< TRUE if Policer will be used for any
+                                                             of the FM ports */
+    t_Handle                    h_Fm;                   /**< A handle to the FM module */
+    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
+    bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
+    t_FmPcdHcParams             hc;                     /**< Relevant only if useHostCommand=TRUE.
+                                                             Host Command parameters. */
+
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Relevant for master (or single) partition only: Callback routine
+                                                             to be called of PCD exception */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Relevant for master (or single) partition only: Callback routine
+                                                             to be used for a single scheme and
+                                                             profile exceptions */
+    t_Handle                    h_App;                  /**< Relevant for master (or single) partition only: A handle to an
+                                                             application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks */
+} t_FmPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Config
+
+ @Description   Basic configuration of the PCD module.
+                Creates descriptor for the FM PCD module.
+
+ @Param[in]     p_FmPcdParams    A structure of parameters for the initialization of PCD.
+
+ @Return        A handle to the initialized module.
+*//***************************************************************************/
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Init
+
+ @Description   Initialization of the PCD module.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Init(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Free(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Group         FM_PCD_advanced_init_grp    FM PCD Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                [DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]     h_FmPcd                     FM PCD module descriptor.
+ @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
+                                            be shared between ports on this partition
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrAutoRefreshMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default autorefresh is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     enable          TRUE to enable, FALSE to disable
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPrsMaxCycleLimit
+
+ @Description   Calling this routine changes the internal data structure for
+                the maximum parsing time from its default value
+                [DEFAULT_prsMaxParseCycleLimit].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     value           0 to disable the mechanism, or new
+                                maximum parsing time.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
+
+/** @} */ /* end of FM_PCD_advanced_init_grp group */
+/** @} */ /* end of FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1 or 2). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsLabelParams {
+    uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    e_NetHeaderType         hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} t_FmPcdPrsLabelParams;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsSwParams {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patches.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                 *p_Code;                    /**< SW parser code */
+    uint32_t                swPrsDataParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 numOfLabels;                /**< Number of labels for SW parser. */
+    t_FmPcdPrsLabelParams   labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing
+                                                             numOfLabels entries */
+} t_FmPcdPrsSwParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_Enable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+t_Error FM_PCD_Disable(t_Handle h_FmPcd);
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
+
+/**************************************************************************//**
+@Function      FM_PCD_PrsLoadSw
+
+@Description   This routine may be called in order to load software parsing code.
+
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+@Param[in]     p_SwPrs         A pointer to a structure of software
+                               parser parameters, including the software
+                               parser image.
+
+@Return        E_OK on success; Error code otherwise.
+
+@Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+               Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     valueId         0,1 - one of 2 global default values.
+ @Param[in]     value           The requested default value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finishing point.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     payloadOffset   the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     value       The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPlcrStatistics
+
+ @Description   This routine may be used to enable/disable policer statistics
+                counter. By default the statistics is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor
+ @Param[in]     enable          TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPrsStatistics
+
+ @Description   Defines whether to gather parser statistics including all ports.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        None
+
+ @Cautions      Allowed only following PCD_Init().
+                Not available for guest partition.
+*//***************************************************************************/
+void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+                Not available for guest partition.
+*//***************************************************************************/
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcTxConf
+
+ @Description   This routine should be called to confirm frames that were
+                 recieved on the HC confirmation queue.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_Fd            Frame descriptor of the received frame.
+
+ @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
+                option was selected in the initialization.
+*//***************************************************************************/
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PCD_DumpRegs
+
+ @Description   Dumps all PCD registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDumpRegs
+
+ @Description   Dumps all PCD KG registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Plcr registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileDumpRegs
+
+ @Description   Dumps all PCD Plcr registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to a profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsDumpRegs
+
+ @Description   Dumps all PCD Prs registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcDumpRegs
+
+ @Description   Dumps HC Port registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+#ifdef VERIFICATION_SUPPORT
+/********************* VERIFICATION ONLY ********************************/
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorSet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+ @Param[out]    value               Value to write.
+
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorGet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+
+ @Return        Value read
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t     FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset);
+#endif /*VERIFICATION_SUPPORT*/
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_tree_buildgrp FM PCD Tree building Unit
+
+ @Description   FM PCD Runtime Unit
+
+                This group contains routines for setting, deleting and modifying
+                PCD resources, for defining the total PCD tree.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define FM_PCD_MAX_NUM_OF_CC_NODES          255
+#define FM_PCD_MAX_NUM_OF_CC_TREES          8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS         16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS          4
+#define FM_PCD_MAX_NUM_OF_KEYS              256
+#define FM_PCD_MAX_SIZE_OF_KEY              56
+#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP 16
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t        protocolOpt_t;          /**< A general type to define a protocol option. */
+
+typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options. */
+#define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
+#define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
+
+typedef protocolOpt_t   vlanProtocolOpt_t;      /**< Vlan protocol options. */
+#define VLAN_STACKED                0x20000000  /**< Vlan Stacked. */
+
+typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
+#define MPLS_STACKED                0x10000000  /**< MPLS Stacked. */
+
+typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
+#define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
+#define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
+#define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
+#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define IPV4_FRAG_1                 0x00000008  /**< TODO */
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
+#define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
+#define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
+#define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+#define IPV6_FRAG_1                 0x00000004  /**< TODO */
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum e_FmPcdEngine {
+    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_FM_PCD_KG,            /**< Keygen indicated */
+    e_FM_PCD_CC,            /**< Coarse classification indicated */
+    e_FM_PCD_PLCR,          /**< Policer indicated */
+    e_FM_PCD_PRS            /**< Parser indicated */
+} e_FmPcdEngine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum e_FmPcdExtractByHdrType {
+    e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} e_FmPcdExtractByHdrType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum e_FmPcdExtractFrom {
+    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} e_FmPcdExtractFrom;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum e_FmPcdExtractType {
+    e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} e_FmPcdExtractType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum e_FmPcdKgExtractDfltSelect {
+    e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} e_FmPcdKgExtractDfltSelect;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum e_FmPcdKgKnownFieldsDfltTypes {
+    e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                             any data extraction that is not the full
+                                             field described above  */
+    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                             any data extraction without validation */
+    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                             extraction from parser result or
+                                             direct use of default value  */
+} e_FmPcdKgKnownFieldsDfltTypes;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum e_FmPcdHdrIndex {
+    e_FM_PCD_HDR_INDEX_NONE = 0,        /**< used when multiple headers not used, also
+                                             to specify regular IP (not tunneled). */
+    e_FM_PCD_HDR_INDEX_1,               /**< may be used for VLAN, MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_2,               /**< may be used for MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_3,               /**< may be used for MPLS */
+    e_FM_PCD_HDR_INDEX_LAST = 0xFF      /**< may be used for VLAN, MPLS */
+} e_FmPcdHdrIndex;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum e_FmPcdProfileTypeSelection {
+    e_FM_PCD_PLCR_PORT_PRIVATE,         /**< Port dedicated profile */
+    e_FM_PCD_PLCR_SHARED                /**< Shared profile (shared within partition) */
+} e_FmPcdProfileTypeSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrAlgorithmSelection {
+    e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
+    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorythm RFC 2698 */
+    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorythm RFC 4115 */
+} e_FmPcdPlcrAlgorithmSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColorMode {
+    e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
+    e_FM_PCD_PLCR_COLOR_AWARE           /**< Color aware */
+} e_FmPcdPlcrColorMode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColor {
+    e_FM_PCD_PLCR_GREEN,                /**< Green */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
+    e_FM_PCD_PLCR_RED,                  /**< Red */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
+} e_FmPcdPlcrColor;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrFrameLengthSelect {
+  e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
+  e_FM_PCD_PLCR_L3_FRM_LEN,             /**< L3 frame length */
+  e_FM_PCD_PLCR_L4_FRM_LEN,             /**< L4 frame length */
+  e_FM_PCD_PLCR_FULL_FRM_LEN            /**< Full frame length */
+} e_FmPcdPlcrFrameLengthSelect;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRollBackFrameSelect {
+  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} e_FmPcdPlcrRollBackFrameSelect;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRateMode {
+    e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
+    e_FM_PCD_PLCR_PACKET_MODE           /**< Packet mode */
+} e_FmPcdPlcrRateMode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum e_FmPcdDoneAction {
+    e_FM_PCD_ENQ_FRAME = 0,        /**< Enqueue frame */
+    e_FM_PCD_DROP_FRAME            /**< Drop frame */
+} e_FmPcdDoneAction;
+
+/**************************************************************************//**
+ @Description   A structure for selecting the policer counter
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrProfileCounters {
+    e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} e_FmPcdPlcrProfileCounters;
+
+/**************************************************************************//**
+ @Description   A structure for selecting action
+*//***************************************************************************/
+typedef enum e_FmPcdAction {
+    e_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} e_FmPcdAction;
+
+#if defined(FM_CAPWAP_SUPPORT) || \
+    defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+/**************************************************************************//**
+ @Description   An enum for selecting type of insert manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipInsrtType {
+    e_FM_PCD_MANIP_INSRT_NONE = 0,                          /**< No insertion */
+    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR,   /**< Insert internal frame header to start of frame */
+    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE         /**< Insert template to start of frame*/
+} e_FmPcdManipInsrtType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of remove manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipRmvParamsType {
+    e_FM_PCD_MANIP_RMV_NONE = 0,                                        /**< No remove */
+    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION,      /**< Remove from start of frame till (excluding) specified indication */
+    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,   /**< Remove from start of frame till (including) specified indication */
+    e_FM_PCD_MANIP_RMV_INT_FRAME_HDR                                    /**< Remove internal frame header to start of frame */
+} e_FmPcdManipRmvParamsType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of location
+*//***************************************************************************/
+typedef enum e_FmPcdManipLocateType {
+    e_FM_PCD_MANIP_LOC_BY_HDR = 0,            /**< Locate according to header */
+    e_FM_PCD_MANIP_LOC_NON_HDR                /**< Locate from data that is not the header */
+} e_FmPcdManipLocateType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of Timeout mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemTimeOutMode {
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< limits the time of the reassm process from the first frag to the last */
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< limits the time of receiving the fragment */
+} e_FmPcdManipReassemTimeOutMode;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of WaysNumber mode
+*//***************************************************************************/
+typedef enum e_FmPcdManipReassemWaysNumber {
+    e_FM_PCD_MANIP_ONE_WAYS_HASH = 1,  /**< four ways hash */
+    e_FM_PCD_MANIP_TOW_WAYS_HASH,  /**< eight ways hash*/
+    e_FM_PCD_MANIP_THREE_WAYS_HASH,  /**< four ways hash */
+    e_FM_PCD_MANIP_FOUR_WAYS_HASH,  /**< eight ways hash*/
+    e_FM_PCD_MANIP_FIVE_WAYS_HASH,  /**< four ways hash */
+    e_FM_PCD_MANIP_SIX_WAYS_HASH,  /**< eight ways hash*/
+    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,  /**< four ways hash */
+    e_FM_PCD_MANIP_EIGHT_WAYS_HASH  /**< eight ways hash*/
+} e_FmPcdManipReassemWaysNumber;
+
+/**************************************************************************//**
+ @Description   An enum for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum e_FmPcdStatsType {
+    e_FM_PCD_STATS_PER_FLOWID = 0   /**< type where flowId used as index for getting statistics */
+} e_FmPcdStatsType;
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+/**************************************************************************//**
+ @Description   An enum for Dont Fragment Action. If an IP packet is larger
+                than MTU and its DF bit is set, then this enum determine
+                the action to be taken.
+*//***************************************************************************/
+typedef enum e_FmPcdManipDontFragAction {
+    e_FM_PCD_MANIP_DISCARD_PACKET = 0,      /**< Discard packet */
+    e_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
+} e_FmPcdManipDontFragAction;
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+#endif /* FM_CAPWAP_SUPPORT */
+
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union u_FmPcdHdrProtocolOpt {
+    ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
+    vlanProtocolOpt_t   vlanOpt;    /**< Vlan options */
+    mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
+    ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
+    ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+} u_FmPcdHdrProtocolOpt;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union t_FmPcdFields {
+    headerFieldEth_t            eth;            /**< eth      */
+    headerFieldVlan_t           vlan;           /**< vlan     */
+    headerFieldLlcSnap_t        llcSnap;        /**< llcSnap  */
+    headerFieldPppoe_t          pppoe;          /**< pppoe    */
+    headerFieldMpls_t           mpls;           /**< mpls     */
+    headerFieldIpv4_t           ipv4;           /**< ipv4     */
+    headerFieldIpv6_t           ipv6;           /**< ipv6     */
+    headerFieldUdp_t            udp;            /**< udp      */
+    headerFieldTcp_t            tcp;            /**< tcp      */
+    headerFieldSctp_t           sctp;           /**< sctp     */
+    headerFieldDccp_t           dccp;           /**< dccp     */
+    headerFieldGre_t            gre;            /**< gre      */
+    headerFieldMinencap_t       minencap;       /**< minencap */
+    headerFieldIpsecAh_t        ipsecAh;        /**< ipsecAh  */
+    headerFieldIpsecEsp_t       ipsecEsp;       /**< ipsecEsp */
+    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< udpEncapEsp */
+} t_FmPcdFields;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromHdr {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromHdr;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromField {
+    t_FmPcdFields       field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromField;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdDistinctionUnit {
+    struct {
+        e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
+        u_FmPcdHdrProtocolOpt   opt;        /**< only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdDistinctionUnit;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdNetEnvParams {
+    uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
+    t_FmPcdDistinctionUnit  units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /**< An array of numOfDistinctionUnits of the
+                                                                             different units to be identified */
+} t_FmPcdNetEnvParams;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct t_FmPcdExtractEntry {
+    e_FmPcdExtractType                  type;           /**< Extraction type select */
+    union {
+        struct {
+            e_NetHeaderType             hdr;            /**< Header selection */
+            bool                        ignoreProtocolValidation;
+                                                        /**< Ignore protocol validation */
+            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
+            union {
+                t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
+                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters*/
+                t_FmPcdFields           fullField;      /**< Extract full filed parameters*/
+            } extractByHdrType;
+        } extractByHdr;                                 /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+        struct {
+            e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
+            e_FmPcdAction               action;         /**< Relevant for CC Only */
+            uint16_t                    icIndxMask;     /**< Relevant only for CC where
+                                                             action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
+            uint8_t                     offset;         /**< Byte offset */
+            uint8_t                     size;           /**< Size in byte */
+        } extractNonHdr;                                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    };
+} t_FmPcdExtractEntry;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractMask {
+    uint8_t                             extractArrayIndex;       /**< Index in the extraction array, as initialized by user */
+    uint8_t                             offset;                  /**< Byte offset */
+    uint8_t                             mask;                    /**< A byte mask (selected bits will be used) */
+} t_FmPcdKgExtractMask;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractDflt {
+    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select*/
+    e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
+} t_FmPcdKgExtractDflt;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct t_FmPcdKgKeyExtractAndHashParams {
+    uint32_t                    privateDflt0;                /**< Scheme default register 0 */
+    uint32_t                    privateDflt1;                /**< Scheme default register 1 */
+    uint8_t                     numOfUsedExtracts;           /**< defines the valid size of the following array */
+    t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
+    uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+                                                             /**< For each extraction used in this scheme, specify the required
+                                                                  default register to be used when header is not found.
+                                                                  types not specified in this array will get undefined value. */
+    uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                     hashShift;                   /**< hash result right shift. Select the 24 bits out of the 64 hash
+                                                                  result. 0 means using the 24 LSB's, otherwise use the
+                                                                  24 LSB's after shifting right.*/
+    uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
+                                                                  of queues for the key and hash functionality */
+    uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                        symmetricHash;               /**< TRUE to generate the same hash for frames with swapped source and
+                                                                  destination fields on all layers; If TRUE, driver will check that for
+                                                                  all layers, if SRC extraction is selected, DST extraction must also be
+                                                                  selected, and vice versa. */
+} t_FmPcdKgKeyExtractAndHashParams;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Fqid mask (extracted OR).
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractedOrParams {
+    e_FmPcdExtractType              type;               /**< Extraction type select */
+    union {
+        struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType         hdr;
+            e_FmPcdHdrIndex         hdrIndex;           /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            bool                    ignoreProtocolValidation;
+                                                        /**< continue extraction even if protocol is not recognized */
+        } extractByHdr;
+        e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    } ;
+    uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
+    e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
+                                                             field not found */
+    uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
+    uint8_t                         bitOffsetInFqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bitOffsetInPlcrProfile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+} t_FmPcdKgExtractedOrParams;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeCounter {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} t_FmPcdKgSchemeCounter;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct t_FmPcdKgPlcrProfile {
+    bool                sharedProfile;              /**< TRUE if this profile is shared between ports
+                                                         (i.e. managed by master partition) May not be TRUE
+                                                         if profile is after Coarse Classification*/
+    bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
+                                                         id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters, to define a range of profiles from
+                                                         which the keygen result will determine the
+                                                         destination policer profile.  */
+    union {
+        uint16_t        directRelativeProfileId;         /**< Used if 'direct' is TRUE, to select policer profile.
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< shift of KG results without the qid base */
+            uint8_t     fqidOffsetRelativeProfileIdBase;/**< OR of KG results without the qid base
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles window or SHARED window depends on sharedProfile */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
+        } indirectProfile;
+    } profileSelect;
+} t_FmPcdKgPlcrProfile;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct t_FmPcdKgCc {
+    t_Handle                h_CcTree;           /**< A handle to a CC Tree */
+    uint8_t                 grpId;              /**< CC group id within the CC tree */
+    bool                    plcrNext;           /**< TRUE if after CC, in case of data frame,
+                                                     policing is required. */
+    bool                    bypassPlcrProfileGeneration;
+                                                /**< TRUE to bypass keygen policer profile
+                                                     generation (profile selected is the one selected at
+                                                     port initialization). */
+    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE and bypassPlcrProfileGeneration=FALSE */
+} t_FmPcdKgCc;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeParams {
+    bool                                modify;                 /**< TRUE to change an existing scheme */
+    union
+    {
+        uint8_t                         relativeSchemeId;       /**< if modify=FALSE:Partition relative scheme id */
+        t_Handle                        h_Scheme;               /**< if modify=TRUE: a handle of the existing scheme */
+    }id;
+    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+                                                                     it when matching   */
+    struct {                                                    /**< HL Relevant only if alwaysDirect = FALSE */
+        t_Handle                        h_NetEnv;               /**< A handle to the Network environment as returned
+                                                                     by FM_PCD_SetNetEnvCharacteristics() */
+        uint8_t                         numOfDistinctionUnits;  /**< Number of netenv units listed in unitIds array */
+        uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                useHash;                /**< use the KG Hash functionality  */
+    t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
+                                                                /**< used only if useHash = TRUE */
+    bool                                bypassFqidGeneration;   /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                                     In such a case FQID after KG will be the default FQID
+                                                                     defined for the relevant port, or the FQID defined by CC
+                                                                     in cases where CC was the previous engine. */
+    uint32_t                            baseFqid;               /**< Base FQID; Relevant only if bypassFqidGeneration = FALSE;
+                                                                     If hash is used and an even distribution is expected
+                                                                     according to hashDistributionNumOfFqids, baseFqid must be aligned to
+                                                                     hashDistributionNumOfFqids.  */
+    uint8_t                             numOfUsedExtractedOrs;  /**< Number of Fqid masks listed in extractedOrs array*/
+    t_FmPcdKgExtractedOrParams          extractedOrs[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                                /**< IN: FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                                     registers are shared between qidMasks
+                                                                     functionality and some of the extraction
+                                                                     actions; Normally only some will be used
+                                                                     for qidMask. Driver will return error if
+                                                                     resource is full at initialization time. */
+    e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
+    union {                                                     /**< depends on nextEngine */
+        e_FmPcdDoneAction               doneAction;             /**< Used when next engine is BMI (done) */
+        t_FmPcdKgPlcrProfile            plcrProfile;            /**< Used when next engine is PLCR */
+        t_FmPcdKgCc                     cc;                     /**< Used when next engine is CC */
+    } kgNextEngineParams;
+    t_FmPcdKgSchemeCounter              schemeCounter;          /**< A structure of parameters for updating
+                                                                     the scheme counter */
+} t_FmPcdKgSchemeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextCcParams {
+    t_Handle    h_CcNode;               /**< A handle of the next CC node */
+} t_FmPcdCcNextCcParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextPlcrParams {
+    bool        overrideParams;         /**< TRUE if CC override previously decided parameters*/
+    bool        sharedProfile;          /**< Relevant only if overrideParams=TRUE:
+                                             TRUE if this profile is shared between ports */
+    uint16_t    newRelativeProfileId;   /**< Relevant only if overrideParams=TRUE:
+                                             (otherwise profile id is taken from keygen);
+                                             This parameter should indicate the policer
+                                             profile offset within the port's
+                                             policer profiles or from SHARED window.*/
+    uint32_t    newFqid;                /**< Relevant only if overrideParams=TRUE:
+                                             FQID for enqueing the frame;
+                                             In earlier chips  if policer next engine is KEYGEN,
+                                             this parameter can be 0, because the KEYGEN
+                                             always decides the enqueue FQID.*/
+    bool        statisticsEn;           /**< In the case of TRUE Statistic counter is
+                                             incremented for each received frame passed through
+                                             this Coarse Classification entry.*/
+} t_FmPcdCcNextPlcrParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEnqueueParams {
+
+    e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME */
+    uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueing the frame
+                                             (otherwise FQID is taken from keygen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME*/
+    bool                 statisticsEn;  /**< In the case of TRUE Statistic counter is
+                                             incremented for each received frame passed through
+                                             this Coarse Classification entry.*/
+} t_FmPcdCcNextEnqueueParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextKgParams {
+    bool        overrideFqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
+                                             Note - this parameters irrelevant for earlier chips*/
+    uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueing the frame
+                                             (otherwise FQID is taken from keygen),
+                                             Note - this parameters irrelevant for earlier chips*/
+    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
+    bool        statisticsEn;           /**< In the case of TRUE Statistic counter is
+                                             incremented for each received frame passed through
+                                             this Coarse Classification entry.*/
+} t_FmPcdCcNextKgParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEngineParams {
+    e_FmPcdEngine                       nextEngine;    /**< User has to initialize parameters
+                                                            according to nextEngine definition */
+    union {
+        t_FmPcdCcNextCcParams           ccParams;      /**< Parameters in case next engine is CC */
+        t_FmPcdCcNextPlcrParams         plcrParams;    /**< Parameters in case next engine is PLCR */
+        t_FmPcdCcNextEnqueueParams      enqueueParams; /**< Parameters in case next engine is BMI */
+        t_FmPcdCcNextKgParams           kgParams;      /**< Parameters in case next engine is KG */
+    } params;
+#if defined(FM_CAPWAP_SUPPORT) || \
+    defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+    t_Handle                            h_Manip;       /**< Handler to headerManip.
+                                                            Relevant if next engine of the type result
+                                                            (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+} t_FmPcdCcNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyParams {
+    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize*/
+    uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
+                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                 of the same size defined in the keySize */
+    t_FmPcdCcNextEngineParams   ccNextEngineParams;
+                                            /**< parameters for the next for the defined Key in
+                                                 the p_Key */
+} t_FmPcdCcKeyParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct t_KeysParams {
+    uint8_t                     numOfKeys;      /**< Number Of relevant Keys  */
+    uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
+                                                     the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                     key. In the another type of extraction keySize has to be as size of extraction.
+                                                     In the case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP the size of keySize has to be 2*/
+    t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
+                                                /**< it's array with numOfKeys entries each entry in
+                                                     the array of the type t_FmPcdCcKeyParams */
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
+                                                /**< parameters for the next step of
+                                                     unfound (or undefined) key . Not relevant in the case
+                                                     of action = e_FM_PCD_ACTION_INDEXED_LOOKUP*/
+} t_KeysParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct t_FmPcdCcNodeParams {
+    t_FmPcdExtractEntry         extractCcParams;    /**< params which defines extraction parameters */
+    t_KeysParams                keysParams;         /**< params which defines Keys parameters of the
+                                                         extraction defined in extractCcParams */
+} t_FmPcdCcNodeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unitIds list must be in order from lower to higher indexes.
+
+                t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                numOfDistinctionUnits = 2
+                unitIds = {1,3}
+                p_NextEnginePerEntriesInGrp[0] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[1] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - found;
+                p_NextEnginePerEntriesInGrp[2] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[3] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct t_FmPcdCcGrpParams {
+    uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                /**< Indexes of the units as defined in
+                                                                     FM_PCD_SetNetEnvCharacteristics() */
+    t_FmPcdCcNextEngineParams   nextEnginePerEntriesInGrp[FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                /**< Max size is 16 - if only one group used */
+} t_FmPcdCcGrpParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct t_FmPcdCcTreeParams {
+    t_Handle                h_NetEnv;                                   /**< A handle to the Network environment as returned
+                                                                             by FM_PCD_SetNetEnvCharacteristics() */
+    uint8_t                 numOfGrps;                                  /**< Number of CC groups within the CC tree */
+    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];   /**< Parameters for each group. */
+} t_FmPcdCcTreeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrByteRateModeParams {
+    e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
+    e_FmPcdPlcrRollBackFrameSelect  rollBackFrameSelection; /**< relevant option only e_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                 e_FM_PCD_PLCR_FULL_FRM_LEN */
+} t_FmPcdPlcrByteRateModeParams;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC-2698 or
+                RFC-4115 parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
+    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
+    t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
+    uint32_t                         comittedInfoRate;               /**< KBits/Sec or Packets/Sec */
+    uint32_t                         comittedBurstSize;              /**< Bytes/Packets */
+    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Sec or Packets/Sec */
+    uint32_t                         peakOrAccessiveBurstSize;       /**< Bytes/Packets */
+} t_FmPcdPlcrNonPassthroughAlgParams;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union u_FmPcdPlcrNextEngineParams {
+        e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
+        t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
+                                                                 is PLCR, must be a SHARED profile */
+        t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is Keygen */
+} u_FmPcdPlcrNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for selecting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrProfileParams {
+    bool                                modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
+            t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
+            uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
+        } newParams;                                                /**< use it when modify=FALSE */
+        t_Handle                        h_Profile;                  /**< A handle to a profile - use it when modify=TRUE */
+    } id;
+    e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
+    e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                         any incoming packet with the default value. */
+        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes. The profile response to a
+                                                                         pre-color value of 2'b11. */
+    } color;
+
+    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 params */
+
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
+
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Yellow next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Yellow next engine params */
+
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Red next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Red next engine params */
+
+    bool                                trapProfileOnFlowA;         /**< Trap on flow A */
+    bool                                trapProfileOnFlowB;         /**< Trap on flow B */
+    bool                                trapProfileOnFlowC;         /**< Trap on flow C */
+} t_FmPcdPlcrProfileParams;
+
+#if defined(FM_CAPWAP_SUPPORT) || \
+    defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+/**************************************************************************//**
+ @Description   A structure for selecting the location of manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipLocationParams {
+    e_FmPcdManipLocateType              type;           /**< location of manipulation type select */
+    struct {                                            /**< used when type = e_FM_PCD_MANIP_BY_HDR */
+        e_NetHeaderType                 hdr;            /**< Header selection */
+        e_FmPcdHdrIndex                 hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared. */
+        bool                            byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
+        t_FmPcdFields                   fullField;      /**< Relevant only when byField = TRUE: Extract field */
+    } manipByHdr;
+} t_FmPcdManipLocationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining insert manipulation
+                of the type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+*//***************************************************************************/
+typedef struct t_FmPcdManipInsrtByTemplateParams {
+    uint8_t         size;                               /**< size of insert template to the start of the frame. */
+    uint8_t         hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
+                                                        /**< array of the insertion template. */
+
+    bool            modifyOuterIp;                      /**< TRUE if user want to modify some fields in outer IP. */
+    struct {
+        uint16_t    ipOuterOffset;                      /**< offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint16_t    dscpEcn;                            /**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
+                                                             in IPV4 dscpEsn only byte - it has to be adjusted to the right*/
+        bool        udpPresent;                         /**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint8_t     udpOffset;                          /**< offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
+        uint8_t     ipIdentGenId;                       /**< Used by FMan-CTRL to calculate IP-identification field,relevant if modifyOuterIp = TRUE.*/
+        bool        recalculateLength;                  /**< TRUE if recalculate length has to be performed due to the engines in the path which can change the frame later, relevant if modifyOuterIp = TRUE.*/
+        struct {
+            uint8_t blockSize;                          /**< The CAAM block-size; Used by FMan-CTRL to calculate the IP-total-len field.*/
+            uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP-total-len field and UDP length*/
+            uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP-total-len field and UDP length.*/
+        } recalculateLengthParams;                      /**< recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
+    } modifyOuterIpParams;                              /**< Outer IP modification parameters - ignored if modifyOuterIp is FALSE */
+
+    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify vpri field in the outer VLAN header*/
+    struct {
+        uint8_t     vpri;                               /**< value of vpri, relevant if modifyOuterVlan = TRUE
+                                                             vpri only 3 bits, it has to be adjusted to the right*/
+    } modifyOuterVlanParams;
+} t_FmPcdManipInsrtByTemplateParams;
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+#ifdef UNDER_CONSTRUCTION_IPSEC
+/**************************************************************************//**
+ @Description   structure for defining insert manipulation
+                of the type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractedAndParams
+{
+    uint8_t                     numOfOrExtracts;         /**< Number of OR extracts */
+    t_FmPcdManipLocationParams  extractOrArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+                                                         /**< An array of numOfOrExtracts extraction definitions */
+} t_FmPcdKgExtractedAndParams;
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef struct t_FmPcdManipInsrtIntFrameHdrParams {
+    uint8_t                     numOfAndExtracts;       /**< TODO */
+    t_FmPcdKgExtractedAndParams extractAndArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+                                                        /**< TODO */
+    bool                        passPrsResult;          /**< TRUE to pass the parse result to/from the FM */
+} t_FmPcdManipInsrtIntFrameHdrParams;
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP fragmentation
+*//***************************************************************************/
+typedef struct t_CapwapFragmentationParams {
+    uint16_t         sizeForFragmentation;              /**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
+    bool             headerOptionsCompr;                /**< TRUE - first fragment include the CAPWAP header options field,
+                                                             and all other fragments exclude the CAPWAP options field,
+                                                             FALSE - all fragments include CAPWAP header options field. */
+} t_CapwapFragmentationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP Re-assembly
+*//***************************************************************************/
+typedef struct t_CapwapReassemblyParams {
+    uint8_t                         maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
+                                                                 It has to be power of 2.
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+    bool                            haltOnDuplicationFrag;  /**< In the case of TRUE, Reassembly process halted due to duplicated fragment,
+                                                                 and all processed fragments passed for enqueue with error indication.
+                                                                 In the case of FALSE, only duplicated fragment passed for enqueue with error indication */
+
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< Fqid in which time out frames will enqueue during Time Out Process  */
+    uint32_t                        timeoutRoutineRequestTime;
+                                                            /**< Represents the time interval in microseconds between consecutive
+                                                                 timeout routine requests It has to be power of 2. */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry needed for reassembly process */
+} t_CapwapReassemblyParams;
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+
+typedef enum e_FmPcdManipDontFrag {
+    e_FM_PCD_MANIP_DF_ACTION_DISCARD    =  0, /**< Send packet to an error queue or discard it, as configured in the BMI */
+    e_FM_PCD_MANIP_DF_ACTION_FRAG       =  1, /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_DF_ACTION_DONT_FRAG  =  2  /**< Continue normal processing without fragmenting the packet*/
+} e_FmPcdManipDontFrag;
+
+
+/**************************************************************************//**
+ @Description   structure for defining IP fragmentation
+*//***************************************************************************/
+typedef struct t_IpFragmentationParams {
+    uint16_t                    sizeForFragmentation;   /**< if length of the frame is greater than this value,
+                                                             IP fragmentation will be executed.*/
+    uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
+    e_FmPcdManipDontFrag        dontFragAction;         /**< Dont Fragment Action - If an IP packet is larger than MTU and its DF bit is set, then this field will determine
+                                                             the action to be taken.*/
+} t_IpFragmentationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining IP Re-assembly
+*//***************************************************************************/
+typedef struct t_IpReassemblyParams {
+    uint8_t                         relativeSchemeId;       /**< Partition relative scheme id */
+    uint16_t                        liodnOffset;            /**< TODO - LIODN offset. */
+    uint8_t                         dataMemId;              /**< Memory partition ID for data buffers */
+    uint16_t                        minFragSize;            /**< TODO */
+
+    uint8_t                         maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
+                                                                 It has to be power of 2.
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< Fqid in which time out frames will enqueue during Time Out Process  */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry; /**< Number of frames per hash entry needed for reassembly process */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+
+} t_IpReassemblyParams;
+
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+#if defined(FM_CAPWAP_SUPPORT) || \
+    defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+/**************************************************************************//**
+ @Description   structure for defining fragmentation/reassembly
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragOrReasmParams {
+    bool                                frag;               /**< TRUE if using the structure for fragmentation,
+                                                                 otherwise this structure is used for reassembly */
+    uint8_t                             extBufPoolIndx;     /**< Index of the buffer pool ID which was configured for port
+                                                                 and can be used for manipulation;
+                                                                 NOTE: This field is relevant only for CAPWAP fragmentation
+                                                                 and reassembly */
+    e_NetHeaderType                     hdr;                /**< Header selection */
+    union {
+#ifdef FM_CAPWAP_SUPPORT
+        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_CAPWAP */
+        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_CAPWAP */
+#endif /* FM_CAPWAP_SUPPORT */
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+        t_IpFragmentationParams         ipFragParams;       /**< Structure for IP-fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+        t_IpReassemblyParams            ipReasmParams;      /**< Structure for IP-reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    };
+} t_FmPcdManipFragOrReasmParams;
+
+/**************************************************************************//**
+ @Description   structure for defining insert manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipInsrtParams {
+    e_FmPcdManipInsrtType                       type;       /**< Type of insert manipulation */
+    union {
+        t_FmPcdManipInsrtByTemplateParams       insrtByTemplateParams;
+                                                            /**< parameters for insert manipulation, relevant if
+                                                                 type = e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE */
+#ifdef UNDER_CONSTRUCTION_IPSEC
+        t_FmPcdManipInsrtIntFrameHdrParams      insrtIntFrameHdrParams;
+                                                            /**< TODO */
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+    };
+} t_FmPcdManipInsrtParams;
+
+/**************************************************************************//**
+ @Description   structure for defining remove manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipRmvParams {
+    e_FmPcdManipRmvParamsType                   type;   /**< Type of remove manipulation */
+    t_FmPcdManipLocationParams                  rmvSpecificLocationParams;
+                                                        /**< Specified location of remove manipulation;
+                                                              This params should be initialized in cases:
+                                                              - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION
+                                                              - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION */
+} t_FmPcdManipRmvParams;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipParams {
+    bool                                        rmv;                /**< TRUE, if defined remove manipulation */
+    t_FmPcdManipRmvParams                       rmvParams;          /**< Parameters for remove manipulation, relevant if rmv = TRUE */
+
+    bool                                        insrt;              /**< TRUE, if defined insert manipulation */
+    t_FmPcdManipInsrtParams                     insrtParams;        /**< Parameters for insert manipulation, relevant if insrt = TRUE */
+
+    bool                                        fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
+    t_FmPcdManipFragOrReasmParams               fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation, relevant if fragOrReasm = TRUE */
+
+    /**< General parameters */
+    bool                                        treatFdStatusFieldsAsErrors;
+                                                                    /**< Set to TRUE when the port that is using this manip is chained
+                                                                         to SEC (i.e. the traffic was forwarded from SEC) */
+} t_FmPcdManipParams;
+
+/**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    e_FmPcdStatsType        type; /**< type of statistics node */
+} t_FmPcdStatsParams;
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetNetEnvCharacteristics
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_NetEnvParams  A structure of parameters for the initialization of
+                                the network environment.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_DeleteNetEnvCharacteristics
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_NetEnv        A handle to the Network environment.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetScheme
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in,out] p_Scheme        A structure of parameters for defining the scheme
+
+ @Return        A handle to the initialized scheme on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSetScheme (t_Handle                h_FmPcd,
+                             t_FmPcdKgSchemeParams   *p_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteScheme
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme
+
+ @Return        E_OK on success; Error code otherwise.
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error     FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgGetSchemeCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetSchemeCounter
+
+ @Description   Writes scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+ @Param[in]     value           New scheme counter value - typically '0' for
+                                resetting the counter.
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcBuildTree
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in]     h_FmPcd                 FM PCD module descriptor.
+ @Param[in]     p_FmPcdCcTreeParams     A structure of parameters to define the tree.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_CcBuildTree (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_FmPcdCcTreeParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteTree
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcTree        A handle to a CC tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcSetNode
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_CcNodeParam       A structure of parameters defining the CC node
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_CcSetNode(t_Handle             h_FmPcd,
+                            t_FmPcdCcNodeParams  *p_CcNodeParam);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcNode        A handle to a CC node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeGetKeyStatistics
+
+ @Description   return statistics of the frames passed throught defined node
+                specific entry of defined node.
+
+ @Param[in]     h_CcNode        A handle to a CC node.
+ @Param[in]     keyIndex        An index of the entry
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+
+uint32_t FM_PCD_CcNodeGetKeyStatistics(t_Handle h_CcNode, uint8_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcTreeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcTree                    A handle to the tree
+ @Param[in]     grpId                       A Group index in the tree
+ @Param[in]     index                       Entry index in the group defined by grpId
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for Next Engine Params modifications
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeRemoveKey
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for removing
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeAddKey
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes new key with Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_Key                       A pointer to the new key
+ @Param[in]     p_Mask                      A pointer to the new mask if relevnt, otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeGetKeyCounter
+
+ @Description   This routine may be used to get a counter of specific key in a CC
+                Node; This counter reflects how many frames passed that were matched
+                this key.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+
+ @Return        The specific key counter.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfile
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd           A handle to an FM PCD Module.
+ @Param[in]     p_Profile         A structure of parameters for defining a
+                                  policer profile entry.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_PlcrSetProfile(t_Handle                  h_FmPcd,
+                               t_FmPcdPlcrProfileParams  *p_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDeleteProfile
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrGetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd             A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter             Counter selector.
+
+ @Return        specific counter value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+ @Param[in]     value           value to set counter with.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+
+#if defined(FM_CAPWAP_SUPPORT) || \
+    defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+/**************************************************************************//**
+ @Function      FM_PCD_ManipSetNode
+
+ @Description   This routine should be called for defining a manipulation
+                node. A manipulation node must be defined before the CC node
+                that precedes it.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdManipParams  A structure of parameters defining the manipulation
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipDeleteNode
+
+ @Description   Delete an existing manip node.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_HdrManipNode  A handle to a Manip node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error  FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode);
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+/**************************************************************************//**
+ @Function      FM_RegisterReassmPort
+                Note: Not available for guest partition.
+
+ @Description   Registers reassembly port.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     portNum         reassembly hardware port ID.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_RegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
+
+/**************************************************************************//**
+ @Function      FM_UnregisterReassmPort
+                Note: Not available for guest partition.
+
+ @Description   Unregisters reassembly port.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     portNum         reassembly hardware port ID.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_UnregisterReassmPort(t_Handle h_Fm);
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Function      FM_PCD_StatisticsSetNode
+
+ @Description   This routine should be called for defining a statistics
+                node.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_FmPcdstatsParams  A structure of parameters defining the statistics
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcdstatsParams);
+#endif /* FM_CAPWAP_SUPPORT */
+
+/** @} */ /* end of FM_PCD_Runtime_tree_buildgrp group */
+/** @} */ /* end of FM_PCD_Runtime_grp group */
+/** @} */ /* end of FM_PCD_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+
+#endif /* __FM_PCD_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
new file mode 100644
index 0000000..643c7ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -0,0 +1,2194 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_port_ext.h
+
+ @Description   FM-Port Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_PORT_EXT
+#define __FM_PORT_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+*//***************************************************************************/
+typedef enum e_FmPortPcdSupport {
+    e_FM_PORT_PCD_SUPPORT_NONE = 0,             /**< BMI to BMI, PCD is not used */
+    e_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR,
+                                                /**< Use all PCD engines */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR,  /**< Use Parser, Keygen and Policer */
+#if defined(UNDER_CONSTRUCTION_IPSEC) || \
+    defined(UNDER_CONSTRUCTION_FRAG_REASSEMBLY)
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_CC,           /**< Use Parser and Coarse Classification */
+#endif /* defined(UNDER_CONSTRUCTION_IPSEC) || ... */
+#ifdef FM_CAPWAP_SUPPORT
+    e_FM_PORT_PCD_SUPPORT_CC_ONLY,              /**< Use only Coarse Classification */
+    e_FM_PORT_PCD_SUPPORT_CC_AND_KG,            /**< Use Coarse Classification,and Keygen */
+    e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR    /**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPortPcdSupport;
+
+/**************************************************************************//**
+ @Description   Port interrupts
+*//***************************************************************************/
+typedef enum e_FmPortExceptions {
+    e_FM_PORT_EXCEPTION_IM_BUSY                 /**< Independent-Mode Rx-BSUY */
+} e_FmPortExceptions;
+
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define FM_PORT_PRS_RESULT_NUM_OF_WORDS     8   /**< Number of 4 bytes words in parser result */
+/* @} */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_init_grp FM Port Initialization Unit
+
+ @Description   FM Port Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPortExceptionCallback) (t_Handle h_App, e_FmPortExceptions exception);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with recieve data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     length          length of received data
+ @Param[in]     status          receive status and errors
+ @Param[in]     position        position of buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+*//***************************************************************************/
+typedef e_RxStoreResponse (t_FmPortImRxStoreCallback) (t_Handle h_App,
+                                                       uint8_t  *p_Data,
+                                                       uint16_t length,
+                                                       uint16_t status,
+                                                       uint8_t  position,
+                                                       t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     status          transmit status and errors
+ @Param[in]     lastBuffer      is last buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
+                                         uint8_t    *p_Data,
+                                         uint16_t   status,
+                                         t_Handle   h_BufContext);
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+typedef struct t_FmPortExtPoolParams {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+} t_FmPortExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by this port.
+*//***************************************************************************/
+typedef struct t_FmPortExtPools {
+    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
+    t_FmPortExtPoolParams   extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} t_FmPortExtPools;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< Default Queue Id.  */
+    uint16_t                liodnOffset;        /**< Port's LIODN offset. */
+    t_FmPortExtPools        extBufPools;        /**< Which external buffer pools are used
+                                                     (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
+} t_FmPortRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortNonRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
+                                                     by the FM for dequeue. */
+#ifdef FM_OP_PARTITION_ERRATA_FMANx8
+    uint16_t                opLiodnOffset;      /**< For Offline Parsing ports only. Port's LIODN offset. */
+#endif  /* FM_OP_PARTITION_ERRATA_FMANx8 */
+} t_FmPortNonRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortImRxTxParams {
+    t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
+    uint16_t                    liodnOffset;        /**< For Rx ports only. Port's LIODN Offset. */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
+    t_FmPortImRxStoreCallback   *f_RxStore;         /**< For Rx ports only. */
+    t_FmPortImTxConfCallback    *f_TxConf;          /**< For Tx ports only. */
+} t_FmPortImRxTxParams;
+
+/**************************************************************************//**
+ @Description   Union for additional parameters depending on port type
+*//***************************************************************************/
+typedef union u_FmPortSpecificParams {
+    t_FmPortImRxTxParams        imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
+    t_FmPortRxParams            rxParams;           /**< Rx port parameters structure */
+    t_FmPortNonRxParams         nonRxParams;        /**< Non-Rx port parameters structure */
+} u_FmPortSpecificParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmPortParams {
+    uintptr_t                   baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    e_FmPortType                portType;           /**< Port type */
+    uint8_t                     portId;             /**< Port Id - relative to type */
+    bool                        independentModeEnable;
+                                                    /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
+                                                         used together with LIODN offset. */
+    u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
+                                                         type. */
+
+    t_FmPortExceptionCallback   *f_Exception;       /**< Callback routine to be called of PCD exception */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmPortParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Config
+
+ @Description   Creates descriptor for the FM PORT module.
+
+                The routine returns a handle (descriptor) to the FM PORT object.
+                This descriptor must be passed as first parameter to all other
+                FM PORT function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmPortParams   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM PORT module
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM PORT module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort);
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_advanced_init_grp    FM Port Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqType {
+   e_FM_PORT_DEQ_TYPE1,             /**< Dequeue from the SP channel - with priority precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE2,             /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE3              /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and override Intra-Class Scheduling */
+} e_FmPortDeqType;
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqPrefetchOption {
+   e_FM_PORT_DEQ_NO_PREFETCH,       /**< QMI preforms a dequeue action for a single frame
+                                         only when a dedicated portID Tnum is waiting. */
+   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
+                                         one dedicated portId tnum is waiting. */
+   e_FM_PORT_DEQ_FULL_PREFETCH      /**< QMI preforms a dequeue action for 3 frames when
+                                         no dedicated portId tnums are waiting. */
+
+} e_FmPortDeqPrefetchOption;
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmPortDmaSwap {
+    e_FM_PORT_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+    e_FM_PORT_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+                                         in PowerPc Little Endian mode. */
+    e_FM_PORT_DMA_SWP_BE            /**< The transferred data should be swapped
+                                         in Big Endian mode */
+} e_FmPortDmaSwap;
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmPortDmaCache {
+    e_FM_PORT_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_PORT_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
+} e_FmPortDmaCache;
+
+/**************************************************************************//**
+ @Description   enum for defining port default color
+*//***************************************************************************/
+typedef enum e_FmPortColor {
+    e_FM_PORT_COLOR_GREEN,          /**< Default port color is green */
+    e_FM_PORT_COLOR_YELLOW,         /**< Default port color is yellow */
+    e_FM_PORT_COLOR_RED,            /**< Default port color is red */
+    e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
+} e_FmPortColor;
+
+/**************************************************************************//**
+ @Description   struct for defining Dual Tx rate limiting scale
+*//***************************************************************************/
+typedef enum e_FmPortDualRateLimiterScaleDown {
+    e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} e_FmPortDualRateLimiterScaleDown;
+
+
+/**************************************************************************//**
+ @Description   struct for defining FM port resources
+*//***************************************************************************/
+typedef struct t_FmPortRsrc {
+    uint32_t    num;                /**< Commited required resource */
+    uint32_t    extra;              /**< Extra (not commited) required resource */
+} t_FmPortRsrc;
+
+/**************************************************************************//**
+ @Description   struct for defining pool depletion criteria
+*//***************************************************************************/
+typedef struct t_FmPortBufPoolDepletion {
+    bool        numberOfPoolsModeEnable;            /**< select mode in which pause frames will be sent after
+                                                         a number of pools are depleted */
+    uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
+                                                         invoke pause frames transmission. */
+    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
+                                                         a single of pools are depleted */
+    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+} t_FmPortBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   struct for defining observed pool depletion
+*//***************************************************************************/
+typedef struct t_FmPortObservedBufPoolDepletion {
+    t_FmPortBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
+    t_FmPortExtPools            poolsParams;        /**< Which external buffer pools are observed
+                                                         (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
+                                                         and their sizes. */
+} t_FmPortObservedBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   struct for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct t_FmPortRateLimit {
+    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} t_FmPortRateLimit;
+
+/**************************************************************************//**
+ @Description   struct for defining define the parameters of
+                the Rx port performance counters
+*//***************************************************************************/
+typedef struct t_FmPortPerformanceCnt {
+    uint8_t     taskCompVal;            /**< Task compare value */
+    uint8_t     queueCompVal;           /**< Rx queue/Tx confirm queue compare
+                                             value (unused for H/O) */
+    uint8_t     dmaCompVal;             /**< Dma compare value */
+    uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
+} t_FmPortPerformanceCnt;
+
+/**************************************************************************//**
+ @Description   struct for defining buffer content.
+*//***************************************************************************/
+typedef struct t_FmPortBufferPrefixContent {
+    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer */
+    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM */
+    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM */
+    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM */
+    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
+                                         for selecting a data alignment (must be a
+                                         power of 2) */
+#ifdef DEBUG
+    bool        passDebugInfo;      /**< Debug-information */
+#endif /* DEBUG */
+#ifdef FM_CAPWAP_SUPPORT
+    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size) */
+#endif /* FM_CAPWAP_SUPPORT */
+} t_FmPortBufferPrefixContent;
+
+/**************************************************************************//**
+ @Description   struct for defining backup Bm Pools.
+*//***************************************************************************/
+typedef struct t_FmPortBackupBmPools {
+    uint8_t     numOfBackupPools;        /**< Number of BM backup pools -
+                                             must be smaller than the total number of
+                                             pools defined for the specified port.*/
+    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< numOfBackupPools pool id's, specifying which
+                                             pools should be used only as backup. Pool
+                                             id's specified here must be a subset of the
+                                             pools used by the specified port.*/
+} t_FmPortBackupBmPools;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqHighPriority
+
+ @Description   Calling this routine changes the dequeue priority in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqHighPriority]
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     highPri     TRUE to select high priority, FALSE for normal operation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqType
+
+ @Description   Calling this routine changes the dequeue type parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqType].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     deqType     According to QM definition.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
+
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqPrefetchOption
+
+ @Description   Calling this routine changes the dequeue prefetch option parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqPrefetchOption]
+                Note: Available for some chips only
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPrefetchOption   New option
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqByteCnt
+
+ @Description   Calling this routine changes the dequeue byte count parameter in
+                the internal driver data base from its default configuration [DEFAULT_PORT_deqByteCnt].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     deqByteCnt      New byte count
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+                fill level parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     minFillLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+                pipeline depth parameter in the internal driver data base
+
+                from its default configuration: 1G ports: [DEFAULT_PORT_txFifoDeqPipelineDepth_1G],
+                10G port: [DEFAULT_PORT_txFifoDeqPipelineDepth_10G]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPipelineDepth    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+                parameter in internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoLowComfLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoLowComfLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+                fill level parameter in the internal driver data base
+                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
+
+                If the total number of buffers which are
+                currently in use and associated with the
+                specific RX port exceed this threshold, the
+                BMI will signal the MAC to send a pause frame
+                over the link.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoThreshold       New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxFifoPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+                parameter in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
+
+                If the total number of buffers which are currently in use and 
+                associated with the specific RX port exceed the amount specified 
+                in priElevationLevel, BMI will signal the main FM's DMA to 
+                elevate the FM priority on the system bus.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     priElevationLevel   New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort                        A handle to a FM Port module.
+ @Param[in,out] p_FmPortBufferPrefixContent     A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent);
+
+#ifdef VERIFICATION_SUPPORT
+t_Error FM_PORT_ConfigIntContent (t_Handle  h_FmPort,
+                                  uint8_t   intContextIntOffset,
+                                  uint16_t  intContextExtOffset,
+                                  uint16_t  intContextSize,
+                                  uint16_t  startMargins,
+                                  uint16_t  endMargins);
+#endif /* VERIFICATION_SUPPORT */
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCheksumLastBytesIgnore
+
+ @Description   Calling this routine changes the number of checksum bytes to ignore
+                parameter in the internal driver data base from its default configuration
+                [DEFAULT_PORT_cheksumLastBytesIgnore]
+
+                May be used by Tx & Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     cheksumLastBytesIgnore    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCutBytesFromEnd
+
+ @Description   Calling this routine changes the number of bytes to cut from a
+                frame's end parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_cutBytesFromEnd]
+                Note that if the result of (frame length before chop - cutBytesFromEnd) is
+                less than 14 bytes, the chop operation is not executed.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     cutBytesFromEnd     New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigObservedPoolDepletion
+
+ @Description   Calling this routine enables a mechanism to stop port enqueue
+                depending on the depletion status of selected BM pools.
+                It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                Note: Available for some chips only
+
+                May be used for Offline Parsing ports only
+
+ @Param[in]     h_FmPort                            A handle to a FM Port module.
+ @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigExtBufPools
+
+ @Description   This routine should be called for offline parsing ports
+                that internally use BM buffer pools. In such cases, e.g. for fragmentation and
+                re-assembly, the FM needs new BM buffers. By calling this routine the user
+                specifies the BM buffer pools that should be used.
+
+                Note: Available for some chips only
+
+                May be used for Offline Parsing ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPortExtPools    A structure of parameters for the external pools.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+                defined for this port as backup pools.
+                A pool configured to be a backup pool will be used only if all other
+                enabled non-backup pools are depleted.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortBackupBmPools   An array of pool id's. All pools specified here will
+                                        be defined as backup pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_FmPortBackupBmPools);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigFrmDiscardOverride
+
+ @Description   Calling this routine changes the error frames destination parameter
+                in the internal driver data base from its default configuration:
+                override = [DEFAULT_PORT_frmDiscardOverride]
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     override    TRUE to override dicarding of error frames and
+                            enqueueing them to error queue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigErrorsToDiscard
+
+ @Description   Calling this routine changes the behaviour on error parameter
+                in the internal driver data base from its default configuration:
+                [DEFAULT_PORT_errorsToDiscard].
+                If a requested error was previously defined as "ErrorsToEnqueue" it's
+                definition will change and the frame will be discarded.
+                Errors that were not defined either as "ErrorsToEnqueue" nor as
+                "ErrorsToDiscard", will be forwarded to CPU.
+
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to discard
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data aparameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_dmaSwapData]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort               A handle to a FM Port module.
+ @Param[in]     intContextCacheAttr    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration:  optimize = [DEFAULT_PORT_dmaWriteOptimize]
+
+                May be used for non-Tx port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDfltColor
+
+ @Description   Calling this routine changes the internal default color parameter
+                in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_color]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     color           New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSyncReq
+
+ @Description   Calling this routine changes the synchronization attribute parameter
+                in the internal driver data base from its default configuration:
+                syncReq = [DEFAULT_PORT_syncReq]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     syncReq         TRUE to request synchronization, FALSE otherwize.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigForwardReuseIntContext
+
+ @Description   This routine is relevant for Rx ports that are routed to offline
+                parsing. It changes the internal context reuse option
+                in the internal driver data base from its default configuration:
+                reuse = [DEFAULT_PORT_forwardIntContextReuse]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     reuse           TRUE to reuse internal context on frames
+                                forwarded to offline parsing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDontReleaseTxBufToBM
+
+ @Description   This routine should be called if no Tx confirmation
+                is done, and yet buffers should not be released to the BM.
+                Normally, buffers are returned using the Tx confirmation
+                process. When Tx confirmation is not used (defFqid=0),
+                buffers are typically released to the BM. This routine
+                may be called to avoid this behavior and not release the
+                buffers.
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMMaxRxBufLength
+
+ @Description   Changes the maximum receive buffer length from its default
+                configuration: Closest rounded down power of 2 value of the
+                data buffer size.
+
+                The maximum receive buffer length directly affects the structure
+                of received frames (single- or multi-buffered) and the performance
+                of both the FM and the driver.
+
+                The selection between single- or multi-buffered frames should be
+                done according to the characteristics of the specific application.
+                The recommended mode is to use a single data buffer per packet,
+                as this mode provides the best performance. However, the user can
+                select to use multiple data buffers per packet.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          Maximum receive buffer length (in bytes).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMRxBdRingLength
+
+ @Description   Changes the receive BD ring length from its default
+                configuration:[DEFAULT_PORT_rxBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMTxBdRingLength
+
+ @Description   Changes the transmit BD ring length from its default
+                configuration:[DEFAULT_PORT_txBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMFmanCtrlExternalStructsMemory
+
+ @Description   Configures memory partition and attributes for FMan-Controller
+                data structures (e.g. BD rings).
+                Calling this routine changes the internal driver data base
+                from its default configuration
+                [DEFAULT_PORT_ImfwExtStructsMemId , DEFAULT_PORT_ImfwExtStructsMemAttr].
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     memId           Memory partition ID.
+ @Param[in]     memAttributes   Memory attributes mask (a combination of MEMORY_ATTR_x flags).
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
+                                                       uint8_t  memId,
+                                                       uint32_t memAttributes);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMPolling
+
+ @Description   Changes the Rx flow from interrupt driven (default) to polling.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_advanced_init_grp group */
+/** @} */ /* end of FM_PORT_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum e_FmPortCounters {
+    e_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} e_FmPortCounters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct t_FmPortCongestionGrps {
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of 'numOfCongestionGrpsToConsider'
+                                                             describing the groups */
+} t_FmPortCongestionGrps;
+
+#ifdef UNDER_CONSTRUCTION_IPSEC
+/**************************************************************************//**
+ @Collection   FM OP PORT Workarounds
+*//***************************************************************************/
+typedef uint32_t    fmOpPortWorkaroundsSelect_t;                    /**< TODO */
+
+#define FM_OP_PORT_WA_SEC_ERR                           0x80000000  /**< TODO */
+#define FM_OP_PORT_WA_DISABLE_UDP_CKSM                  0x40000000  /**< TODO */
+#define FM_OP_PORT_WA_ETH_TYPE                          0x20000000  /**< TODO */
+#define FM_OP_PORT_WA_COPY_CTXB                         0x10000000  /**< TODO */
+#define FM_OP_PORT_WA_UPDATE_UDP_LEN                    0x08000000  /**< TODO */
+/* @} */
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PORT_DumpRegs
+
+ @Description   Dump all regs.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDataOffset
+
+ @Description   Returns the data offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        data offset.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferICInfo
+
+ @Description   Returns the Internal Context offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
+
+#ifdef DEBUG
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDebugInfo
+
+ @Description   Returns the debug info offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Debug info pointer on success, NULL if 'passDebugInfo' was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data);
+#endif /* DEBUG */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_PORT_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+t_Error FM_PORT_Disable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_Enable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded DOWN to the nearest 16M.
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_RateLimit     A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeleteRateLimit
+
+ @Description   Calling this routine disables and clears rate limit 
+                initialization.
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetStatisticsCounters
+
+ @Description   Calling this routine enables/disables port's statistics counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetFrameQueueCounters
+
+ @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
+                By default, counters are enabled.
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     enable                  TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine defines port's performance
+                counters parameters.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A pointer to a structure of performance
+                                        counters parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AnalyzePerformanceParams
+
+ @Description   User may call this routine to so the driver will analyze if the
+                basic performance parameters are correct and also the driver may
+                suggest of improvments; The basic parameters are FIFO sizes, number
+                of DMAs and number of TNUMs for the port.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetNumOfOpenDmas
+
+ @Description   Calling this routine updates the number of open DMA requested for
+                this port.
+
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfOpenDmas     A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetNumOfTasks
+
+ @Description   Calling this routine updates the number of tasks requested for
+                this port.
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfTasks        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetSizeOfFifo
+
+ @Description   Calling this routine updates the Fifo size resource requested for
+                this port.
+
+                May be used for all port types - note that only Rx has 'extra'
+                fifo size. For other ports 'extra' field must be disabled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_SizeOfFifo        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Calling this routine enables/disables BM pool allocate
+                buffer counters.
+                By default, counters are enabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     poolId      BM pool id.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetCounter
+
+ @Description   Reads one of the FM PORT counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetAllocBufCounter
+
+ @Description   Reads one of the FM PORT buffer counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ModifyAllocBufCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or  RX+OP ports only (depending on chip)
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx, or RX+OP ports only (depending on chip)
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_IsStalled
+
+ @Description   A routine for checking whether the specified port is stalled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+bool FM_PORT_IsStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ReleaseStalled
+
+ @Description   This routine may be called in case the port was stalled and may
+                now be released.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetRxL4ChecksumVerify
+
+ @Description   This routine is relevant for Rx ports (1G and 10G). The routine
+                set/clear the L3/L4 checksum verification (on RX side).
+                Note that this takes affect only if hw-parser is enabled!
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     l4Checksum      boolean indicates whether to do L3/L4 checksum
+                                on frames or not.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetIMExceptions
+
+ @Description   Calling this routine enables/disables FM PORT interrupts.
+                Note: Not available for guest partition.
+
+ @Param[in]     h_FmPort        FM PORT module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
+
+#ifdef UNDER_CONSTRUCTION_IPSEC
+t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds);
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A stracture defining the KG scheme after the parser.
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeSelect {
+    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV.*/
+    t_Handle    h_DirectScheme;         /**< Relevant for 'direct'=TRUE only. scheme handle,
+                                             Selects the scheme after parser. */
+} t_FmPcdKgSchemeSelect;
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPortSchemesParams {
+    uint8_t     numOfSchemes;                           /**< Number of schemes for port to be bound to. */
+    t_Handle    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];    /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+} t_FmPcdPortSchemesParams;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union u_FmPcdHdrPrsOpts {
+    /* MPLS */
+    struct {
+        bool            labelInterpretationEnable;  /**< When this bit is set, the last MPLS label will be
+                                                         interpreted as described in HW spec table. When the bit
+                                                         is cleared, the parser will advance to MPLS next parse */
+        e_NetHeaderType nextParse;                  /**< must be equal or higher than IPv4 */
+    } mplsPrsOptions;
+    /* VLAN */
+    struct {
+        uint16_t        tagProtocolId1;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlanPrsOptions;
+    /* PPP */
+    struct{
+        bool            enableMTUCheck;             /**< Check validity of MTU according to RFC2516 */
+    } pppoePrsOptions;
+
+    /* IPV6 */
+    struct{
+        bool            routingHdrDisable;          /**< Disable routing header */
+    } ipv6PrsOptions;
+
+    /* UDP */
+    struct{
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } udpPrsOptions;
+
+    /* TCP */
+    struct {
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } tcpPrsOptions;
+} u_FmPcdHdrPrsOpts;
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct t_FmPcdPrsAdditionalHdrParams {
+    e_NetHeaderType         hdr;            /**< Selected header */
+    bool                    errDisable;     /**< TRUE to disable error indication */
+    bool                    swPrsEnable;    /**< Enable jump to SW parser when this
+                                                 header is recognized by the HW parser. */
+    uint8_t                 indexPerHdr;    /**< Normally 0, if more than one sw parser
+                                                 attachments exists for the same header,
+                                                 (in the main sw parser code) use this
+                                                 index to distinguish between them. */
+    bool                    usePrsOpts;     /**< TRUE to use parser options. */
+    u_FmPcdHdrPrsOpts       prsOpts;        /**< A unuion according to header type,
+                                                 defining the parser options selected.*/
+} t_FmPcdPrsAdditionalHdrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPrsParams {
+    uint8_t                         prsResultPrivateInfo;           /**< The private info provides a method of inserting
+                                                                         port information into the parser result. This information
+                                                                         may be extracted by Keygen and be used for frames
+                                                                         distribution when a per-port distinction is required,
+                                                                         it may also be used as a port logical id for analyzing
+                                                                         incoming frames. */
+    uint8_t                         parsingOffset;                  /**< Number of bytes from beginning of packet to start parsing */
+    e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header expected at 'parsingOffset' */
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
+                                                                         NOTE: this field is not valid when the FN is in "guest" mode. */
+    uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
+                                                                         special parameters */
+    t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                                    /**< 'numOfHdrsWithAdditionalParams'  structures
+                                                                         of additional parameters
+                                                                         for each header that requires them */
+    bool                            setVlanTpid1;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid1;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                            setVlanTpid2;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid2;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+} t_FmPortPcdPrsParams;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdCcParams {
+    t_Handle            h_CcTree;                       /**< A handle to a CC tree */
+} t_FmPortPcdCcParams;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdKgParams {
+    uint8_t             numOfSchemes;                   /**< Number of schemes for port to be bound to. */
+    t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes handles for the
+                                                             port to be bound to */
+    bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
+                                                             as returned by FM_PCD_KgSetScheme */
+} t_FmPortPcdKgParams;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPlcrParams {
+    t_Handle                h_Profile;          /**< Selected profile handle; Relevant for one of
+                                                     following cases:
+                                                     e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR were selected,
+                                                     or if any flow uses a KG scheme were policer
+                                                     profile is not generated
+                                                     (bypassPlcrProfileGeneration selected) */
+} t_FmPortPcdPlcrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdParams {
+    e_FmPortPcdSupport      pcdSupport;         /**< Relevant for Rx and offline ports only.
+                                                     Describes the active PCD engines for this port. */
+    t_Handle                h_NetEnv;           /**< HL Unused in PLCR only mode */
+    t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
+    t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
+    t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
+    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
+} t_FmPortPcdParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct t_FmPcdPrsStart {
+    uint8_t             parsingOffset;  /**< Number of bytes from begining of packet to
+                                             start parsing */
+    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} t_FmPcdPrsStart;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
+                                configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_AttachPCD().
+*//***************************************************************************/
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     numOfProfiles       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPcdKgScheme     A structure of parameters for defining whether
+                                    a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows
+                e_FM_PORT_PCD_SUPPORT_PLCR_ONLY or e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR
+                only, to change the initial Policer profile frame should be
+                routed to. The change may be of a profile and/or absolute/direct
+                mode selection.
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     h_Profile               Policer profile handle
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called for ports that use coarse classification tree
+                if the user wishes to replace the tree. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     h_CcTree            A CC tree that was already built. The tree id as returned from
+                                    the BuildTree routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not added,
+                just this specific port starts using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not removed or invalidated,
+                just this specific port stops using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPrsModifyStartOffset
+
+ @Description   Runtime change of the parser start offset within the header.
+                The routine may not be called while port
+                receives packets using the PCD functionalities, therefore port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
+                                start point for the parser.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetatchPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
+
+/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of FM_PORT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
+
+ @Description   FM Port Runtime data unit API functions, definitions and enums.
+                This API is valid only if working in Independent-Mode.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTx
+
+ @Description   Tx function, called to transmit a data buffer on the port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Data      A pointer to an LCP data buffer.
+ @Param[in]     length      Size of data for transmission.
+ @Param[in]     lastBuffer  Buffer poistion - TRUE for the last buffer
+                            of a frame, including a single buffer frame
+ @Param[in]     h_BufContext  A handle of the user acossiated with this buffer
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_BufContext);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTxConf
+
+ @Description   Tx port confirmation routine, optional, may be called to verify
+                transmission of all frames. The procedure performed by this
+                routine will be performed automatically on next buffer transmission,
+                but if desired, calling this routine will invoke this action on
+                demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+void FM_PORT_ImTxConf(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImRx
+
+ @Description   Rx function, may be called to poll for received buffers.
+                Normally, Rx process is invoked by the driver on Rx interrupt.
+                Alternatively, this routine may be called on demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_runtime_data_grp group */
+/** @} */ /* end of FM_PORT_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#ifdef VERIFICATION_SUPPORT
+void            FM_PORT_BackdoorSet (t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+uint32_t        FM_PORT_BackdoorGet(t_Handle h_FmPort, e_ModuleId moduleId, uint32_t offset);
+#endif /*VERIFICATION_SUPPORT*/
+
+
+#endif /* __FM_PORT_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
new file mode 100644
index 0000000..8590184
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -0,0 +1,564 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_rtc_ext.h
+
+ @Description   External definitions and API for FM RTC IEEE1588 Timer Module.
+
+ @Cautions      None.
+*//***************************************************************************/
+
+#ifndef __FM_RTC_EXT_H__
+#define __FM_RTC_EXT_H__
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         fm_rtc_grp FM RTC
+
+ @Description   FM RTC functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         fm_rtc_init_grp FM RTC Initialization Unit
+
+ @Description   FM RTC initialization API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM RTC Alarm Polarity Options.
+*//***************************************************************************/
+typedef enum e_FmRtcAlarmPolarity
+{
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH,    /**< Active-high output polarity */
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW      /**< Active-low output polarity */
+} e_FmRtcAlarmPolarity;
+
+/**************************************************************************//**
+ @Description   FM RTC Trigger Polarity Options.
+*//***************************************************************************/
+typedef enum e_FmRtcTriggerPolarity
+{
+    e_FM_RTC_TRIGGER_ON_RISING_EDGE,    /**< Trigger on rising edge */
+    e_FM_RTC_TRIGGER_ON_FALLING_EDGE    /**< Trigger on falling edge */
+} e_FmRtcTriggerPolarity;
+
+/**************************************************************************//**
+ @Description   IEEE1588 Timer Module FM RTC Optional Clock Sources.
+*//***************************************************************************/
+typedef enum e_FmSrcClock
+{
+    e_FM_RTC_SOURCE_CLOCK_EXTERNAL,  /**< external high precision timer reference clock */
+    e_FM_RTC_SOURCE_CLOCK_SYSTEM,    /**< MAC system clock */
+    e_FM_RTC_SOURCE_CLOCK_OSCILATOR  /**< RTC clock oscilator */
+}e_FmSrcClk;
+
+/**************************************************************************//**
+ @Description   FM RTC configuration parameters structure.
+
+                This structure should be passed to FM_RTC_Config().
+*//***************************************************************************/
+typedef struct t_FmRtcParams
+{
+    t_Handle                 h_Fm;               /**< FM Handle*/
+    uintptr_t                baseAddress;        /**< Base address of FM RTC registers */
+    t_Handle                 h_App;              /**< A handle to an application layer object; This handle will
+                                                      be passed by the driver upon calling the above callbacks */
+} t_FmRtcParams;
+
+
+/**************************************************************************//**
+ @Function      FM_RTC_Config
+
+ @Description   Configures the FM RTC module according to user's parameters.
+
+                The driver assigns default values to some FM RTC parameters.
+                These parameters can be overwritten using the advanced
+                configuration routines.
+
+ @Param[in]     p_FmRtcParam    - FM RTC configuration parameters.
+
+ @Return        Handle to the new FM RTC object; NULL pointer on failure.
+
+ @Cautions      None
+*//***************************************************************************/
+t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Init
+
+ @Description   Initializes the FM RTC driver and hardware.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_Init(t_Handle h_FmRtc);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Free
+
+ @Description   Frees the FM RTC object and all allocated resources.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_Free(t_Handle h_FmRtc);
+
+
+/**************************************************************************//**
+ @Group         fm_rtc_adv_config_grp  FM RTC Advanced Configuration Unit
+
+ @Description   FM RTC advanced configuration functions.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigPeriod
+
+ @Description   Configures the period of the timestamp if different than
+                default [DEFAULT_clockPeriod].
+
+ @Param[in]     h_FmRtc         - Handle to FM RTC object.
+ @Param[in]     period          - Period in nano-seconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigPeriod(t_Handle h_FmRtc, uint32_t period);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigSourceClock
+
+ @Description   Configures the source clock of the RTC.
+
+ @Param[in]     h_FmRtc         - Handle to FM RTC object.
+ @Param[in]     srcClk          - Source clock selection.
+ @Param[in]     freqInMhz       - the source-clock frequency (in MHz).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigSourceClock(t_Handle      h_FmRtc,
+                                 e_FmSrcClk    srcClk,
+                                 uint32_t      freqInMhz);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigPulseRealignment
+
+ @Description   Configures the RTC to automatic FIPER pulse realignment in
+                response to timer adjustments [DEFAULT_pulseRealign]
+
+                In this mode, the RTC clock is identical to the source clock.
+                This feature can be useful when the system contains an external
+                RTC with inherent frequency compensation.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     enable      - TRUE to enable automatic realignment.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigFrequencyBypass
+
+ @Description   Configures the RTC to bypass the frequency compensation
+                mechanism. [DEFAULT_bypass]
+
+                In this mode, the RTC clock is identical to the source clock.
+                This feature can be useful when the system contains an external
+                RTC with inherent frequency compensation.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     enabled     - TRUE to bypass frequency compensation;
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigFrequencyBypass(t_Handle h_FmRtc, bool enabled);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigInvertedInputClockPhase
+
+ @Description   Configures the RTC to invert the source clock phase on input.
+                [DEFAULT_invertInputClkPhase]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     inverted    - TRUE to invert the source clock phase on input.
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigInvertedOutputClockPhase
+
+ @Description   Configures the RTC to invert the output clock phase.
+                [DEFAULT_invertOutputClkPhase]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     inverted    - TRUE to invert the output clock phase.
+                              FALSE otherwise.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigOutputClockDivisor
+
+ @Description   Configures the divisor for generating the output clock from
+                the RTC clock. [DEFAULT_outputClockDivisor]
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     divisor     - Divisor for generation of the output clock.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigOutputClockDivisor(t_Handle h_FmRtc, uint16_t divisor);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigAlarmPolarity
+
+ @Description   Configures the polarity (active-high/active-low) of a specific
+                alarm signal. [DEFAULT_alarmPolarity]
+
+ @Param[in]     h_FmRtc      - Handle to FM RTC object.
+ @Param[in]     alarmId         - Alarm ID.
+ @Param[in]     alarmPolarity   - Alarm polarity.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
+                                   uint8_t              alarmId,
+                                   e_FmRtcAlarmPolarity alarmPolarity);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ConfigExternalTriggerPolarity
+
+ @Description   Configures the polarity (rising/falling edge) of a specific
+                external trigger signal. [DEFAULT_triggerPolarity]
+
+ @Param[in]     h_FmRtc      - Handle to FM RTC object.
+ @Param[in]     triggerId       - Trigger ID.
+ @Param[in]     triggerPolarity - Trigger polarity.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously created using FM_RTC_Config().
+*//***************************************************************************/
+t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
+                                             uint8_t                triggerId,
+                                             e_FmRtcTriggerPolarity triggerPolarity);
+
+/** @} */ /* end of fm_rtc_adv_config_grp */
+/** @} */ /* end of fm_rtc_init_grp */
+
+
+/**************************************************************************//**
+ @Group         fm_rtc_control_grp FM RTC Control Unit
+
+ @Description   FM RTC runtime control API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmRtcExceptionsCallback
+
+ @Description   Exceptions user callback routine, used for RTC different mechanisms.
+
+ @Param[in]     h_App       - User's application descriptor.
+ @Param[in]     id          - source id.
+*//***************************************************************************/
+typedef void (t_FmRtcExceptionsCallback) ( t_Handle  h_App, uint8_t id);
+
+/**************************************************************************//**
+ @Description   FM RTC alarm parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcAlarmParams {
+    uint8_t                     alarmId;            /**< 0 or 1 */
+    uint64_t                    alarmTime;          /**< In nanoseconds, the time when the alarm
+                                                         should go off - must be a multiple of
+                                                         the RTC period */
+    t_FmRtcExceptionsCallback   *f_AlarmCallback;   /**< This routine will be called when RTC
+                                                         reaches alarmTime */
+    bool                        clearOnExpiration;  /**< TRUE to turn off the alarm once expired. */
+} t_FmRtcAlarmParams;
+
+/**************************************************************************//**
+ @Description   FM RTC Periodic Pulse parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcPeriodicPulseParams {
+    uint8_t                     periodicPulseId;            /**< 0 or 1 */
+    uint64_t                    periodicPulsePeriod;        /**< In Nanoseconds. Must be
+                                                                 a multiple of the RTC period */
+    t_FmRtcExceptionsCallback   *f_PeriodicPulseCallback;   /**< This routine will be called every
+                                                                 periodicPulsePeriod. */
+} t_FmRtcPeriodicPulseParams;
+
+/**************************************************************************//**
+ @Description   FM RTC Periodic Pulse parameters.
+*//***************************************************************************/
+typedef struct t_FmRtcExternalTriggerParams {
+    uint8_t                     externalTriggerId;              /**< 0 or 1 */
+    bool                        usePulseAsInput;                /**< Use the pulse interrupt instead of
+                                                                     an external signal */
+    t_FmRtcExceptionsCallback   *f_ExternalTriggerCallback;     /**< This routine will be called every
+                                                                     periodicPulsePeriod. */
+} t_FmRtcExternalTriggerParams;
+
+
+/**************************************************************************//**
+ @Function      FM_RTC_Enable
+
+ @Description   Enable the RTC (time count is started).
+
+                The user can select to resume the time count from previous
+                point, or to restart the time count.
+
+ @Param[in]     h_FmRtc     - Handle to FM RTC object.
+ @Param[in]     resetClock  - Restart the time count from zero.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock);
+
+/**************************************************************************//**
+ @Function      FM_RTC_Disable
+
+ @Description   Disables the RTC (time count is stopped).
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_Disable(t_Handle h_FmRtc);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetClockOffset
+
+ @Description   Sets the clock offset (usually relative to another clock).
+
+                The user can pass a negative offset value.
+
+ @Param[in]     h_FmRtc  - Handle to FM RTC object.
+ @Param[in]     offset   - New clock offset (in nanoseconds).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetAlarm
+
+ @Description   Schedules an alarm event to a given RTC time.
+
+ @Param[in]     h_FmRtc             - Handle to FM RTC object.
+ @Param[in]     p_FmRtcAlarmParams  - Alarm parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+                Must be called only prior to FM_RTC_Enable().
+*//***************************************************************************/
+t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetPeriodicPulse
+
+ @Description   Sets a periodic pulse.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     p_FmRtcPeriodicPulseParams      - Periodic pulse parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+                Must be called only prior to FM_RTC_Enable().
+*//***************************************************************************/
+t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_FmRtcPeriodicPulseParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ClearPeriodicPulse
+
+ @Description   Clears a periodic pulse.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     periodicPulseId                 - Periodic pulse id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetExternalTrigger
+
+ @Description   Sets an external trigger indication and define a callback
+                routine to be called on such event.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     p_FmRtcExternalTriggerParams    - External Trigger parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams *p_FmRtcExternalTriggerParams);
+
+/**************************************************************************//**
+ @Function      FM_RTC_ClearExternalTrigger
+
+ @Description   Clears external trigger indication.
+
+ @Param[in]     h_FmRtc                         - Handle to FM RTC object.
+ @Param[in]     id                              - External Trigger id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t id);
+
+/**************************************************************************//**
+ @Function      FM_RTC_GetExternalTriggerTimeStamp
+
+ @Description   Reads the External Trigger TimeStamp.
+
+ @Param[in]     h_FmRtc                 - Handle to FM RTC object.
+ @Param[in]     triggerId               - External Trigger id.
+ @Param[out]    p_TimeStamp             - External Trigger timestamp (in nanoseconds).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
+                                           uint8_t              triggerId,
+                                           uint64_t             *p_TimeStamp);
+
+/**************************************************************************//**
+ @Function      FM_RTC_GetCurrentTime
+
+ @Description   Returns the current RTC time.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+ @Param[out]    p_Ts - returned time stamp (in nanoseconds).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts);
+
+/**************************************************************************//**
+ @Function      FM_RTC_SetCurrentTime
+
+ @Description   Sets the current RTC time.
+
+ @Param[in]     h_FmRtc - Handle to FM RTC object.
+ @Param[in]     ts - The new time stamp (in nanoseconds).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
+*//***************************************************************************/
+t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_RTC_DumpRegs
+
+ @Description   Dumps all FM registers
+
+ @Param[in]     h_FmRtc      A handle to an FM RTC Module.
+
+ @Return        E_OK on success;
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of fm_rtc_control_grp */
+/** @} */ /* end of fm_rtc_grp */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_RTC_EXT_H__ */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
new file mode 100644
index 0000000..5291866
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -0,0 +1,75 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __MII_ACC_EXT_H
+#define __MII_ACC_EXT_H
+
+
+/**************************************************************************//**
+ @Function      MII_ReadPhyReg
+
+ @Description   This routine is called to read a specified PHY
+                register value.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to read
+ @Param[out]    p_Data      - Gets the register value.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_ReadPhyReg(t_Handle h_MiiAccess,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data);
+
+/**************************************************************************//**
+ @Function      MII_WritePhyReg
+
+ @Description   This routine is called to write data to a specified PHY
+                   register.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to write
+ @Param[in]     data        - Data to write in register.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_WritePhyReg(t_Handle    h_MiiAccess,
+                    uint8_t     phyAddr,
+                    uint8_t     reg,
+                    uint16_t    data);
+
+
+#endif /* __MII_ACC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/core_ext.h b/drivers/net/dpa/NetCommSw/inc/core_ext.h
new file mode 100644
index 0000000..022de2b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/core_ext.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          core_ext.h
+
+ @Description   Generic interface to basic core operations.
+
+                The system integrator must ensure that this interface is
+                mapped to a specific core implementation, by including the
+                appropriate header file.
+*//***************************************************************************/
+#ifndef __CORE_EXT_H
+#define __CORE_EXT_H
+
+
+#ifdef NCSW_PPC_CORE
+#include "ppc_ext.h"
+#elif defined(NCSW_VXWORKS)
+#include "core_vxw_ext.h"
+#else
+#error "Core is not defined!"
+#endif /* NCSW_CORE */
+
+#if (!defined(CORE_IS_LITTLE_ENDIAN) && !defined(CORE_IS_BIG_ENDIAN))
+#error "Must define core as little-endian or big-endian!"
+#endif /* (!defined(CORE_IS_LITTLE_ENDIAN) && ... */
+
+
+/**************************************************************************//**
+ @Function      CORE_GetId
+
+ @Description   Returns the core ID in the system.
+
+ @Return        Core ID.
+*//***************************************************************************/
+uint32_t CORE_GetId(void);
+
+/**************************************************************************//**
+ @Function      CORE_MemoryBarrier
+
+ @Description   This routine will cause the core to stop executing any commands
+                until all previous memory read/write commands are completely out
+                of the core's pipeline.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_MemoryBarrier(void);
+
+
+#endif /* __CORE_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
new file mode 100644
index 0000000..e1a0132
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -0,0 +1,402 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          e500v2_ext.h
+
+ @Description   E500 external definitions prototypes
+                This file is not included by the E500
+                source file as it is an assembly file. It is used
+                only for prototypes exposure, for inclusion
+                by user and other modules.
+*//***************************************************************************/
+
+#ifndef __E500V2_EXT_H
+#define __E500V2_EXT_H
+
+#include "std_ext.h"
+
+
+/* Layer 1 Cache Manipulations
+ *==============================
+ * Should not be called directly by the user.
+ */
+void        L1DCache_Invalidate (void);
+void        L1ICache_Invalidate(void);
+void        L1DCache_Enable(void);
+void        L1ICache_Enable(void);
+void        L1DCache_Disable(void);
+void        L1ICache_Disable(void);
+void        L1DCache_Flush(void);
+void        L1ICache_Flush(void);
+/*
+ *
+ */
+uint32_t    L1DCache_LineLock(uint32_t addr);
+uint32_t    L1ICache_LineLock(uint32_t addr);
+void        L1Cache_BroadCastEnable(void);
+void        L1Cache_BroadCastDisable(void);
+
+
+#define CORE_DCacheEnable       E500_DCacheEnable
+#define CORE_ICacheEnable       E500_ICacheEnable
+#define CORE_DCacheDisable      E500_DCacheDisable
+#define CORE_ICacheDisable      E500_ICacheDisable
+#define CORE_GetId              E500_GetId
+#define CORE_TestAndSet         E500_TestAndSet
+#define CORE_MemoryBarrier      E500_MemoryBarrier
+#define CORE_InstructionSync    E500_InstructionSync
+
+#define CORE_SetDozeMode        E500_SetDozeMode
+#define CORE_SetNapMode         E500_SetNapMode
+#define CORE_SetSleepMode       E500_SetSleepMode
+#define CORE_SetJogMode         E500_SetJogMode
+#define CORE_SetDeepSleepMode   E500_SetDeepSleepMode
+
+#define CORE_RecoverDozeMode    E500_RecoverDozeMode
+#define CORE_RecoverNapMode     E500_RecoverNapMode
+#define CORE_RecoverSleepMode   E500_RecoverSleepMode
+#define CORE_RecoverJogMode     E500_RecoverJogMode
+
+void E500_SetDozeMode(void);
+void E500_SetNapMode(void);
+void E500_SetSleepMode(void);
+void E500_SetJogMode(void);
+t_Error E500_SetDeepSleepMode(uint32_t bptrAddress);
+
+void E500_RecoverDozeMode(void);
+void E500_RecoverNapMode(void);
+void E500_RecoverSleepMode(void);
+void E500_RecoverJogMode(void);
+
+
+/**************************************************************************//**
+ @Group         E500_id E500 Application Programming Interface
+
+ @Description   E500 API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         E500_init_grp E500 Initialization Unit
+
+ @Description   E500 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Function      E500_DCacheEnable
+
+ @Description   Enables the data cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheEnable
+
+ @Description   Enables the instruction cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_DCacheDisable
+
+ @Description   Disables the data cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheDisable
+
+ @Description   Disables the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_DCacheFlush
+
+ @Description   Flushes the data cache
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheFlush(void);
+
+/**************************************************************************//**
+ @Function      E500_ICacheFlush
+
+ @Description   Flushes the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_ICacheFlush(void);
+
+/**************************************************************************//**
+ @Function      E500_DCacheSetStashId
+
+ @Description   Set Stash Id for data cache
+
+ @Param[in]     stashId     the stash id to be set.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_DCacheSetStashId(uint8_t stashId);
+
+/**************************************************************************//**
+ @Description   E500mc L2 Cache Operation Mode
+*//***************************************************************************/
+typedef enum e_E500mcL2CacheMode
+{
+    e_L2_CACHE_MODE_DATA_ONLY      = 0x00000001,   /**< Cache data only */
+    e_L2_CACHE_MODE_INST_ONLY      = 0x00000002,   /**< Cache instructions only */
+    e_L2_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache data and instructions */
+} e_E500mcL2CacheMode;
+
+/**************************************************************************//**
+ @Function      E500_L2CacheEnable
+
+ @Description   Enables the cache for memory pages that are not cache inhibited.
+
+ @param[in]     mode - L2 cache mode: data only, instruction only or instruction and data.
+
+ @Return        None.
+
+ @Cautions      This routine must be call only ONCE for both caches. I.e. it is
+                not possible to call this routine for i-cache and than to call
+                again for d-cache; The second call will override the first one.
+*//***************************************************************************/
+void E500_L2CacheEnable(e_E500mcL2CacheMode mode);
+
+/**************************************************************************//**
+ @Function      E500_L2CacheDisable
+
+ @Description   Disables the cache (data instruction or both).
+
+ @Return        None.
+
+*//***************************************************************************/
+void E500_L2CacheDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_L2CacheFlush
+
+ @Description   Flushes the cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_L2CacheFlush(void);
+
+/**************************************************************************//**
+ @Function      E500_L2SetStashId
+
+ @Description   Set Stash Id
+
+ @Param[in]     stashId     the stash id to be set.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_L2SetStashId(uint8_t stashId);
+
+/**************************************************************************//**
+ @Function      E500_AddressBusStreamingEnable
+
+ @Description   Enables address bus streaming on the CCB.
+
+                This setting, along with the ECM streaming configuration
+                parameters, enables address bus streaming on the CCB.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBusStreamingEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBusStreamingDisable
+
+ @Description   Disables address bus streaming on the CCB.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBusStreamingDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBroadcastEnable
+
+ @Description   Enables address broadcast.
+
+                The e500 broadcasts cache management instructions (dcbst, dcblc
+                (CT = 1), icblc (CT = 1), dcbf, dcbi, mbar, msync, tlbsync, icbi)
+                based on ABE. ABE must be set to allow management of external
+                L2 caches.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBroadcastEnable(void);
+
+/**************************************************************************//**
+ @Function      E500_AddressBroadcastDisable
+
+ @Description   Disables address broadcast.
+
+                The e500 broadcasts cache management instructions (dcbst, dcblc
+                (CT = 1), icblc (CT = 1), dcbf, dcbi, mbar, msync, tlbsync, icbi)
+                based on ABE. ABE must be set to allow management of external
+                L2 caches.
+
+ @Return        None.
+*//***************************************************************************/
+void E500_AddressBroadcastDisable(void);
+
+/**************************************************************************//**
+ @Function      E500_IsTaskletSupported
+
+ @Description   Checks if tasklets are supported by the e500 interrupt handler.
+
+ @Retval        TRUE    - Tasklets are supported.
+ @Retval        FALSE   - Tasklets are not supported.
+*//***************************************************************************/
+bool E500_IsTaskletSupported(void);
+
+void E500_EnableTimeBase(void);
+void E500_DisableTimeBase(void);
+
+uint64_t E500_GetTimeBaseTime(void);
+
+void E500_GenericIntrInit(void);
+
+t_Error E500_SetIntr(int        ppcIntrSrc,
+                     void       (* Isr)(t_Handle handle),
+                     t_Handle   handle);
+
+t_Error E500_ClearIntr(int ppcIntrSrc);
+
+/**************************************************************************//**
+ @Function      E500_GenericIntrHandler
+
+ @Description   This is the general e500 interrupt handler.
+
+                It is called by the main assembly interrupt handler
+                when an exception occures and no other function has been
+                assigned to this exception.
+
+ @Param         intrEntry   - (In) The exception interrupt vector entry.
+*//***************************************************************************/
+void E500_GenericIntrHandler(uint32_t intrEntry);
+
+#ifndef QE_CRITICAL_INTR
+/**************************************************************************//**
+ @Function      CriticalIntr
+
+ @Description   This is the specific critical e500 interrupt handler.
+
+                It is called by the main assembly interrupt handler
+                when an critical interrupt.
+
+ @Param         intrEntry   - (In) The exception interrupt vector entry.
+*//***************************************************************************/
+void CriticalIntr(uint32_t intrEntry);
+#endif /* not QE_CRITICAL_INTR */
+
+
+/**************************************************************************//**
+ @Function      E500_GetId
+
+ @Description   Returns the core ID in the system.
+
+ @Return        Core ID.
+*//***************************************************************************/
+uint32_t E500_GetId(void);
+
+/**************************************************************************//**
+ @Function      E500_TestAndSet
+
+ @Description   This routine tries to atomically test-and-set an integer
+                in memory to a non-zero value.
+
+                The memory will be set only if it is tested as zero, in which
+                case the routine retunrs the new non-zero value; otherwise the
+                routine returns zero.
+
+ @Param[in]     p - pointer to a volatile int in memory, on which test-and-set
+                    operation should be made.
+
+ @Retval        Zero        - Operation failed - memory was already set.
+ @Retval        Non-zero    - Operation succeeded - memory has been set.
+*//***************************************************************************/
+int E500_TestAndSet(volatile int *p);
+
+/**************************************************************************//**
+ @Function      E500_MemoryBarrier
+
+ @Description   This routine will cause the core to stop executing any commands
+                until all previous memory read/write commands are completely out
+                of the core's pipeline.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void E500_MemoryBarrier(void)
+{
+    __asm__ ("mbar 1");
+}
+
+/**************************************************************************//**
+ @Function      E500_InstructionSync
+
+ @Description   This routine will cause the core to wait for previous instructions
+                (including any interrupts they generate) to complete before the
+                synchronization command executes, which purges all instructions
+                from the processor's pipeline and refetches the next instruction.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void E500_InstructionSync(void)
+{
+    __asm__ ("isync");
+}
+
+
+/** @} */ /* end of E500_init_grp group */
+/** @} */ /* end of E500_grp group */
+
+
+#endif /* __E500V2_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
new file mode 100644
index 0000000..ed4f212
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -0,0 +1,130 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ppc_ext.h
+
+ @Description   Core API for PowerPC cores
+
+                These routines must be implemented by each specific PowerPC
+                core driver.
+*//***************************************************************************/
+#ifndef __PPC_EXT_H
+#define __PPC_EXT_H
+
+#include "part_ext.h"
+
+
+#define CORE_IS_BIG_ENDIAN
+
+
+/**************************************************************************//**
+ @Function      CORE_TestAndSet
+
+ @Description   This routine tries to atomically test-and-set an integer
+                in memory to a non-zero value.
+
+                The memory will be set only if it is tested as zero, in which
+                case the routine retunrs the new non-zero value; otherwise the
+                routine returns zero.
+
+ @Param[in]     p - pointer to a volatile int in memory, on which test-and-set
+                    operation should be made.
+
+ @Retval        Zero        - Operation failed - memory was already set.
+ @Retval        Non-zero    - Operation succeeded - memory has been set.
+*//***************************************************************************/
+int CORE_TestAndSet(volatile int *p);
+
+/**************************************************************************//**
+ @Function      CORE_InstructionSync
+
+ @Description   This routine will cause the core to wait for previous instructions
+                (including any interrupts they generate) to complete before the
+                synchronization command executes, which purges all instructions
+                from the processor's pipeline and refetches the next instruction.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_InstructionSync(void);
+
+/**************************************************************************//**
+ @Function      CORE_DCacheEnable
+
+ @Description   Enables the data cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_DCacheEnable(void);
+
+/**************************************************************************//**
+ @Function      CORE_ICacheEnable
+
+ @Description   Enables the instruction cache for memory pages that are
+                not cache inhibited.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_ICacheEnable(void);
+
+/**************************************************************************//**
+ @Function      CORE_DCacheDisable
+
+ @Description   Disables the data cache.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_DCacheDisable(void);
+
+/**************************************************************************//**
+ @Function      CORE_ICacheDisable
+
+ @Description   Disables the instruction cache.
+
+ @Return        None.
+*//***************************************************************************/
+void CORE_ICacheDisable(void);
+
+
+
+
+#if defined(CORE_E300)
+#include "e300_ext.h"
+#elif defined(CORE_E500V2) || defined(CORE_E500MC)
+#include "e500v2_ext.h"
+#else
+#error "Core not defined!"
+#endif
+
+
+#endif /* __PPC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
new file mode 100644
index 0000000..7910905
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CTYPE_EXT_H
+#define __CTYPE_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+/*
+ * NOTE! This ctype does not handle EOF like the standard C
+ * library is required to.
+ */
+
+#define _U    0x01    /* upper */
+#define _L    0x02    /* lower */
+#define _D    0x04    /* digit */
+#define _C    0x08    /* cntrl */
+#define _P    0x10    /* punct */
+#define _S    0x20    /* white space (space/lf/tab) */
+#define _X    0x40    /* hex digit */
+#define _SP   0x80    /* hard space (0x20) */
+
+extern unsigned char _ctype[];
+
+#define __ismask(x) (_ctype[(int)(unsigned char)(x)])
+
+#define isalnum(c)    ((__ismask(c)&(_U|_L|_D)) != 0)
+#define isalpha(c)    ((__ismask(c)&(_U|_L)) != 0)
+#define iscntrl(c)    ((__ismask(c)&(_C)) != 0)
+#define isdigit(c)    ((__ismask(c)&(_D)) != 0)
+#define isgraph(c)    ((__ismask(c)&(_P|_U|_L|_D)) != 0)
+#define islower(c)    ((__ismask(c)&(_L)) != 0)
+#define isprint(c)    ((__ismask(c)&(_P|_U|_L|_D|_SP)) != 0)
+#define ispunct(c)    ((__ismask(c)&(_P)) != 0)
+#define isspace(c)    ((__ismask(c)&(_S)) != 0)
+#define isupper(c)    ((__ismask(c)&(_U)) != 0)
+#define isxdigit(c)   ((__ismask(c)&(_D|_X)) != 0)
+
+#define isascii(c) (((unsigned char)(c))<=0x7f)
+#define toascii(c) (((unsigned char)(c))&0x7f)
+
+static __inline__ unsigned char __tolower(unsigned char c)
+{
+    if (isupper(c))
+        c -= 'A'-'a';
+    return c;
+}
+
+static __inline__ unsigned char __toupper(unsigned char c)
+{
+    if (islower(c))
+        c -= 'a'-'A';
+    return c;
+}
+
+#define tolower(c) __tolower(c)
+#define toupper(c) __toupper(c)
+
+#elif defined(MWI_VXWORKS)
+#include "ctype.h"
+
+#else
+#include <ctype.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __CTYPE_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
new file mode 100644
index 0000000..d6decf5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
@@ -0,0 +1,259 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          debug_ext.h
+
+ @Description   Debug mode definitions.
+*//***************************************************************************/
+
+#ifndef __DEBUG_EXT_H
+#define __DEBUG_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+#if (DEBUG_ERRORS > 0)
+#include "sprint_ext.h"
+#include "string_ext.h"
+#endif /* DEBUG_ERRORS > 0 */
+
+
+#if (DEBUG_ERRORS > 0)
+
+/* Internally used macros */
+
+#define DUMP_Print          XX_Print
+#define DUMP_MAX_LEVELS     6
+#define DUMP_MAX_STR        64
+
+
+#define _CREATE_DUMP_SUBSTR(phrase) \
+    dumpTmpLevel = 0; dumpSubStr[0] = '\0'; \
+    sprintf(dumpTmpStr, "%s", #phrase); \
+    p_DumpToken = strtok(dumpTmpStr, (dumpIsArr[0] ? "[" : ".")); \
+    while (p_DumpToken != NULL) \
+    { \
+        strcat(dumpSubStr, p_DumpToken); \
+        if (dumpIsArr[dumpTmpLevel]) \
+        { \
+            strcat(dumpSubStr, dumpIdxStr[dumpTmpLevel]); \
+            p_DumpToken = strtok(NULL, "."); \
+        } \
+        if ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != 0) \
+            strcat(dumpSubStr, "."); \
+    }\
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         dump_id  Memory and Registers Dump Mechanism
+
+ @Description   Macros for dumping memory mapped structures.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Declaration of dump mechanism variables.
+
+                This macro must be declared at the beginning of each routine
+                which uses the dump mechanism macros, before the routine's code
+                starts.
+*//***************************************************************************/
+#define DECLARE_DUMP \
+    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][6] = { "", }; \
+    char    dumpSubStr[DUMP_MAX_STR] = ""; \
+    char    dumpTmpStr[DUMP_MAX_STR] = ""; \
+    char    *p_DumpToken = NULL; \
+    int     dumpArrIdx = 0, dumpArrSize = 0, dumpVarSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
+    uint8_t dumpIsArr[DUMP_MAX_LEVELS + 1] = { 0 }; \
+    /* Prevent warnings if not all used */ \
+    UNUSED(dumpIdxStr[0][0]); \
+    UNUSED(dumpSubStr[0]); \
+    UNUSED(dumpTmpStr[0]); \
+    UNUSED(p_DumpToken); \
+    UNUSED(dumpArrIdx); \
+    UNUSED(dumpArrSize); \
+    UNUSED(dumpVarSize); \
+    UNUSED(dumpLevel); \
+    UNUSED(dumpTmpLevel); \
+    UNUSED(dumpIsArr[0]);
+
+
+/**************************************************************************//**
+ @Description   Prints a title for a subsequent dumped structure or memory.
+
+                The inputs for this macro are the structure/memory title and
+                its base addresss.
+*//***************************************************************************/
+#define DUMP_TITLE(addr, msg)  \
+    DUMP_Print("\r\n"); DUMP_Print msg; \
+    DUMP_Print(" (0x%p)\r\n" \
+               "---------------------------------------------------------\r\n", \
+               (addr))
+
+/**************************************************************************//**
+ @Description   Prints a subtitle for a subsequent dumped sub-structure (optional).
+
+                The inputs for this macro are the sub-structure subtitle.
+                A separating line with this subtitle will be printed.
+*//***************************************************************************/
+#define DUMP_SUBTITLE(subtitle)  \
+    DUMP_Print("----------- "); DUMP_Print subtitle; DUMP_Print("\r\n")
+
+
+/**************************************************************************//**
+ @Description   Dumps a memory region in 4-bytes aligned format.
+
+                The inputs for this macro are the base addresss and size
+                (in bytes) of the memory region.
+*//***************************************************************************/
+#define DUMP_MEMORY(addr, size)  \
+    MemDisp((uint8_t *)(addr), (int)(size))
+
+
+/**************************************************************************//**
+ @Description   Declares a dump loop, for dumping a sub-structure array.
+
+                The inputs for this macro are:
+                - idx: an index variable, for indexing the sub-structure items
+                       inside the loop. This variable must be declared separately
+                       in the beginning of the routine.
+                - cnt: the number of times to repeat the loop. This number should
+                       equal the number of items in the sub-structures array.
+
+                Note, that the body of the loop must be written inside brackets.
+*//***************************************************************************/
+#define DUMP_SUBSTRUCT_ARRAY(idx, cnt) \
+    for (idx=0, dumpIsArr[dumpLevel++] = 1; \
+         (idx < cnt) && sprintf(dumpIdxStr[dumpLevel-1], "[%d]", idx); \
+         idx++, ((idx < cnt) || ((dumpIsArr[--dumpLevel] = 0) == 0)))
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's member variable.
+
+                The input for this macro is the full reference for the member
+                variable, where the structure is referenced using a pointer.
+
+                Note, that a members array must be dumped using DUMP_ARR macro,
+                rather than using this macro.
+
+                If the member variable is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->member
+                            p_Struct->sub.member
+                            p_Struct->sub[i].member
+*//***************************************************************************/
+#define DUMP_VAR(st, phrase) \
+    do { \
+        void *addr = (void *)&((st)->phrase); \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpVarSize = sizeof((st)->phrase); \
+        switch (dumpVarSize) \
+        { \
+            case 1:  DUMP_Print("0x%08X: 0x%02x%14s\t%s\r\n", \
+                                addr, GET_UINT8(*(uint8_t*)addr), "", dumpSubStr); break; \
+            case 2:  DUMP_Print("0x%08X: 0x%04x%12s\t%s\r\n", \
+                                addr, GET_UINT16(*(uint16_t*)addr), "", dumpSubStr); break; \
+            case 4:  DUMP_Print("0x%08X: 0x%08x%8s\t%s\r\n", \
+                                addr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); break; \
+            case 8:  DUMP_Print("0x%08X: 0x%016llx\t%s\r\n", \
+                                addr, GET_UINT64(*(uint64_t*)addr), dumpSubStr); break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's members array.
+
+                The input for this macro is the full reference for the members
+                array, where the structure is referenced using a pointer.
+
+                If the members array is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->array
+                            p_Struct->sub.array
+                            p_Struct->sub[i].array
+*//***************************************************************************/
+#define DUMP_ARR(st, phrase) \
+    do { \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpArrSize = ARRAY_SIZE((st)->phrase); \
+        dumpVarSize = sizeof((st)->phrase[0]); \
+        switch (dumpVarSize) \
+        { \
+            case 1: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%02x%14s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 2: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%04x%12s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 4: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%08x%8s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 8: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%016llx\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
+                } break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+#endif /* DEBUG_ERRORS > 0 */
+
+
+/** @} */ /* end of dump_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __DEBUG_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
new file mode 100644
index 0000000..7084e82
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
@@ -0,0 +1,446 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          endian_ext.h
+
+ @Description   Big/little endian swapping routines.
+*//***************************************************************************/
+
+#ifndef __ENDIAN_EXT_H
+#define __ENDIAN_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   General usage API. This API is intended for usage by both the
+                internal modules and the user's application.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         endian_id Big/Little-Endian Conversion
+
+ @Description   Routines and macros for Big/Little-Endian conversion and
+                general byte swapping.
+
+                All routines and macros are expecting unsigned values as
+                parameters, but will generate the correct result also for
+                signed values. Therefore, signed/unsigned casting is allowed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Macros
+
+                Macros for swapping byte order.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the byte-swap routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint16() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT16(val) \
+    ((uint16_t)((((val) & 0x00FF) << 8) | (((val) & 0xFF00) >> 8)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint32() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT32(val) \
+    ((uint32_t)((((val) & 0x000000FF) << 24) | \
+                (((val) & 0x0000FF00) <<  8) | \
+                (((val) & 0x00FF0000) >>  8) | \
+                (((val) & 0xFF000000) >> 24)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint64() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT64(val) \
+    ((uint64_t)((((val) & 0x00000000000000FFULL) << 56) | \
+                (((val) & 0x000000000000FF00ULL) << 40) | \
+                (((val) & 0x0000000000FF0000ULL) << 24) | \
+                (((val) & 0x00000000FF000000ULL) <<  8) | \
+                (((val) & 0x000000FF00000000ULL) >>  8) | \
+                (((val) & 0x0000FF0000000000ULL) >> 24) | \
+                (((val) & 0x00FF000000000000ULL) >> 40) | \
+                (((val) & 0xFF00000000000000ULL) >> 56)))
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Routines
+
+                Routines for swapping the byte order of a given parameter and
+                returning the swapped value.
+
+                These inline routines are safer than the byte-swap macros,
+                because they evaluate the parameter expression only once.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16
+
+ @Description   Returns the byte-swapped value of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint16_t SwapUint16(uint16_t val)
+{
+    return (uint16_t)(((val & 0x00FF) << 8) |
+                      ((val & 0xFF00) >> 8));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32
+
+ @Description   Returns the byte-swapped value of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint32_t SwapUint32(uint32_t val)
+{
+    return (uint32_t)(((val & 0x000000FF) << 24) |
+                      ((val & 0x0000FF00) <<  8) |
+                      ((val & 0x00FF0000) >>  8) |
+                      ((val & 0xFF000000) >> 24));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64
+
+ @Description   Returns the byte-swapped value of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint64_t SwapUint64(uint64_t val)
+{
+    return (uint64_t)(((val & 0x00000000000000FFULL) << 56) |
+                      ((val & 0x000000000000FF00ULL) << 40) |
+                      ((val & 0x0000000000FF0000ULL) << 24) |
+                      ((val & 0x00000000FF000000ULL) <<  8) |
+                      ((val & 0x000000FF00000000ULL) >>  8) |
+                      ((val & 0x0000FF0000000000ULL) >> 24) |
+                      ((val & 0x00FF000000000000ULL) >> 40) |
+                      ((val & 0xFF00000000000000ULL) >> 56));
+}
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    In-place Byte-Swap-And-Set Routines
+
+                Routines for swapping the byte order of a given variable and
+                setting the swapped value back to the same variable.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16P
+
+ @Description   Swaps the byte order of a given 16-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 16-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint16P(uint16_t *p_Val)
+{
+    *p_Val = SwapUint16(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32P
+
+ @Description   Swaps the byte order of a given 32-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 32-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint32P(uint32_t *p_Val)
+{
+    *p_Val = SwapUint32(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64P
+
+ @Description   Swaps the byte order of a given 64-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 64-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint64P(uint64_t *p_Val)
+{
+    *p_Val = SwapUint64(*p_Val);
+}
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Collection    Little-Endian Conversion Macros
+
+                These macros convert given parameters to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian value in memory, without a-priori knowing the CPU
+                byte order.
+
+                These macros use the byte-swap routines. For conversion of
+                constants in initialization structures, you may use the CONST
+                versions of these macros (see below), which are using the
+                byte-swap macros instead.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE16(val)        SwapUint16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE32(val)        SwapUint32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE64(val)        SwapUint64(val)
+
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE16_TO_CPU(val)        CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE32_TO_CPU(val)        CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE64_TO_CPU(val)        CPU_TO_LE64(val)
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Little-Endian Constant Conversion Macros
+
+                These macros convert given constants to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian constant in memory, without a-priori knowing the
+                CPU byte order.
+
+                These macros use the byte-swap macros, therefore can be used for
+                conversion of constants in initialization structures.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For non-constant expressions, use the non-CONST macro versions.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE16(val)  SWAP_UINT16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE32(val)  SWAP_UINT32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE64(val)  SWAP_UINT64(val)
+
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE16_TO_CPU(val)  CONST_CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE32_TO_CPU(val)  CONST_CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE64_TO_CPU(val)  CONST_CPU_TO_LE64(val)
+
+/* @} */
+
+
+/** @} */ /* end of endian_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __ENDIAN_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
new file mode 100644
index 0000000..14f7760
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
@@ -0,0 +1,154 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          enet_ext.h
+
+ @Description   Ethernet generic definitions and enums.
+*//***************************************************************************/
+
+#ifndef __ENET_EXT_H
+#define __ENET_EXT_H
+
+
+#define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
+#define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
+
+
+/**************************************************************************//**
+ @Description   Ethernet Address
+*//***************************************************************************/
+typedef uint8_t t_EnetAddr[ENET_NUM_OCTETS_PER_ADDRESS];
+
+/**************************************************************************//**
+ @Description   Ethernet Address Type.
+*//***************************************************************************/
+typedef enum e_EnetAddrType
+{
+    e_ENET_ADDR_TYPE_INDIVIDUAL,    /**< Individual (unicast) address */
+    e_ENET_ADDR_TYPE_GROUP,         /**< Group (multicast) address */
+    e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
+} e_EnetAddrType;
+
+
+/**************************************************************************//**
+ @Description   Ethernet MAC-PHY Interface
+*//***************************************************************************/
+typedef enum e_EnetInterface
+{
+    e_ENET_IF_MII   = 0x00010000,   /**< MII interface */
+    e_ENET_IF_RMII  = 0x00020000,   /**< RMII interface */
+    e_ENET_IF_SMII  = 0x00030000,   /**< SMII interface */
+    e_ENET_IF_GMII  = 0x00040000,   /**< GMII interface */
+    e_ENET_IF_RGMII = 0x00050000,   /**< RGMII interface */
+    e_ENET_IF_TBI   = 0x00060000,   /**< TBI interface */
+    e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
+    e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
+    e_ENET_IF_XGMII = 0x00090000,   /**< XGMII interface */
+    e_ENET_IF_QSGMII= 0x000a0000    /**< QSGMII interface */
+} e_EnetInterface;
+
+/**************************************************************************//**
+ @Description   Ethernet Duplex Mode
+*//***************************************************************************/
+typedef enum e_EnetDuplexMode
+{
+    e_ENET_HALF_DUPLEX,             /**< Half-Duplex mode */
+    e_ENET_FULL_DUPLEX              /**< Full-Duplex mode */
+} e_EnetDuplexMode;
+
+/**************************************************************************//**
+ @Description   Ethernet Speed (nominal data rate)
+*//***************************************************************************/
+typedef enum e_EnetSpeed
+{
+    e_ENET_SPEED_10     = 10,       /**< 10 Mbps */
+    e_ENET_SPEED_100    = 100,      /**< 100 Mbps */
+    e_ENET_SPEED_1000   = 1000,     /**< 1000 Mbps = 1 Gbps */
+    e_ENET_SPEED_10000  = 10000     /**< 10000 Mbps = 10 Gbps */
+} e_EnetSpeed;
+
+/**************************************************************************//**
+ @Description   Ethernet mode (combination of MAC-PHY interface and speed)
+*//***************************************************************************/
+typedef enum e_EnetMode
+{
+    e_ENET_MODE_INVALID     = 0,                                        /**< Invalid Ethernet mode */
+    e_ENET_MODE_MII_10      = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
+    e_ENET_MODE_MII_100     = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
+    e_ENET_MODE_RMII_10     = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
+    e_ENET_MODE_RMII_100    = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
+    e_ENET_MODE_SMII_10     = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
+    e_ENET_MODE_SMII_100    = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
+    e_ENET_MODE_GMII_1000   = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
+    e_ENET_MODE_RGMII_10    = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
+    e_ENET_MODE_RGMII_100   = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
+    e_ENET_MODE_RGMII_1000  = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
+    e_ENET_MODE_TBI_1000    = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
+    e_ENET_MODE_RTBI_1000   = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
+    e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
+    e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
+    e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
+    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),    /**< 10000 Mbps XGMII */
+    e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000)    /**<  1000 Mbps QSGMII */
+} e_EnetMode;
+
+
+#define IS_ENET_MODE_VALID(mode) \
+        (((mode) == e_ENET_MODE_MII_10     ) || \
+         ((mode) == e_ENET_MODE_MII_100    ) || \
+         ((mode) == e_ENET_MODE_RMII_10    ) || \
+         ((mode) == e_ENET_MODE_RMII_100   ) || \
+         ((mode) == e_ENET_MODE_SMII_10    ) || \
+         ((mode) == e_ENET_MODE_SMII_100   ) || \
+         ((mode) == e_ENET_MODE_GMII_1000  ) || \
+         ((mode) == e_ENET_MODE_RGMII_10   ) || \
+         ((mode) == e_ENET_MODE_RGMII_100  ) || \
+         ((mode) == e_ENET_MODE_RGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_TBI_1000   ) || \
+         ((mode) == e_ENET_MODE_RTBI_1000  ) || \
+         ((mode) == e_ENET_MODE_SGMII_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_XGMII_10000) || \
+         ((mode) == e_ENET_MODE_QSGMII_1000))
+
+
+#define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
+
+#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0xFFFF0000)
+#define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
+
+
+
+#endif /* __ENET_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/error_ext.h b/drivers/net/dpa/NetCommSw/inc/error_ext.h
new file mode 100644
index 0000000..778ba30
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/error_ext.h
@@ -0,0 +1,553 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @File          error_ext.h
+
+ @Description   Error definitions.
+*//***************************************************************************/
+
+#ifndef __ERROR_EXT_H
+#define __ERROR_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "core_ext.h"
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         gen_error_id  Errors, Events and Debug
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/******************************************************************************
+The scheme below provides the bits description for error codes:
+
+ 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
+|       Reserved (should be zero)      |              Module ID               |
+
+ 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
+|                               Error Type                                    |
+******************************************************************************/
+
+#define ERROR_CODE(_err)            ((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
+
+#define GET_ERROR_TYPE(_errcode)    ((_errcode) & 0x0000FFFF)
+                                /**< Extract module code from error code (#t_Error) */
+
+#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
+                                /**< Extract error type (#e_ErrorType) from
+                                     error code (#t_Error) */
+
+
+/**************************************************************************//**
+ @Description    Error Type Enumeration
+*//***************************************************************************/
+typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
+{                           /* ------------------------------------------------------------ */
+    E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
+
+    /* Invalid Function Calls */
+    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
+                            /*   String: none.                                              */
+    ,E_INVALID_OPERATION    /**< The operation/command is invalid (unrecognized).           */
+                            /*   String: none.                                              */
+    ,E_NOT_SUPPORTED        /**< The function is not supported or not implemented.          */
+                            /*   String: none.                                              */
+    ,E_NO_DEVICE            /**< The associated device is not initialized.                  */
+                            /*   String: none.                                              */
+
+    /* Invalid Parameters */
+    ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
+                            /*   String: none, unless the function takes in more than one
+                                 handle (in this case add the handle description)           */
+    ,E_INVALID_ID           /**< Invalid module ID (usually enumeration or index).          */
+                            /*   String: none, unless the function takes in more than one
+                                 ID (in this case add the ID description)                   */
+    ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
+                            /*   String: pointer description.                               */
+    ,E_INVALID_VALUE        /**< Invalid value.                                             */
+                            /*   Use for non-enumeration parameters, and
+                                 only when other error types are not suitable.
+                                 String: parameter description + "(should be <attribute>)",
+                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
+                                      "Channel number (should be even)".                    */
+    ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
+                            /*   Use for enumeration values, only when other error types
+                                 are not suitable.
+                                 String: parameter description.                             */
+    ,E_INVALID_COMM_MODE    /**< Invalid communication mode.                                */
+                            /*   String: none, unless the function takes in more than one
+                                 communication mode indications (in this case add
+                                 parameter description).                                    */
+    ,E_INVALID_BYTE_ORDER   /**< Invalid byte order.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 byte order indications (in this case add parameter
+                                 description).                                              */
+    ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
+                            /*   String: none, unless the function takes in more than one
+                                 memory types (in this case add memory description,
+                                 e.g: "Data memory", "Buffer descriptors memory").          */
+    ,E_INVALID_INTR_QUEUE   /**< Invalid interrupt queue.                                   */
+                            /*   String: none, unless the function takes in more than one
+                                 interrupt queues (in this case add queue description,
+                                 e.g: "Rx interrupt queue", "Tx interrupt queue").          */
+    ,E_INVALID_PRIORITY     /**< Invalid priority.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 priority (in this case add priority description).          */
+    ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
+                            /*   String: none, unless the function takes in more than one
+                                 clocks (in this case add clock description,
+                                 e.g: "Rx clock", "Tx clock").                              */
+    ,E_INVALID_RATE         /**< Invalid rate value.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 rate values (in this case add rate description).           */
+    ,E_INVALID_ADDRESS      /**< Invalid address.                                           */
+                            /*   String: description of the specific violation.             */
+    ,E_INVALID_BUS          /**< Invalid bus type.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 bus parameters (in this case add bus description).         */
+    ,E_BUS_CONFLICT         /**< Bus (or memory) type conflicts with another setting.       */
+                            /*   String: description of the conflicting buses/memories.     */
+    ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
+                            /*   String: description of the conflicting settings.           */
+    ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
+                            /*   String: parameter description + "(should be %d-bytes aligned)",
+                                 e.g: "Rx data buffer (should be 32-bytes aligned)".        */
+    ,E_NOT_IN_RANGE         /**< Parameter value is out of range.                           */
+                            /*   Don't use this error for enumeration parameters.
+                                 String: parameter description + "(should be %d-%d)",
+                                 e.g: "Number of pad characters (should be 0-15)".          */
+
+    /* Frame/Buffer Errors */
+    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
+                            /*   String: none.                                              */
+    ,E_EMPTY_FRAME          /**< Frame object is empty (has no buffers).                    */
+                            /*   String: none.                                              */
+    ,E_EMPTY_BUFFER         /**< Buffer object is empty (no data, or zero data length).     */
+                            /*   String: none.                                              */
+
+    /* Resource Errors */
+    ,E_NO_MEMORY            /**< External memory allocation failed.                         */
+                            /*   String: description of item for which allocation failed.   */
+    ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
+                            /*   Use only when the resource/item is uniquely identified.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_NOT_AVAILABLE        /**< Resource is unavailable.                                   */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_EXISTS       /**< Requested resource or item already exists.                 */
+                            /*   Use when resource duplication or sharing are not allowed.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_FULL                 /**< Resource is full.                                          */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_EMPTY                /**< Resource is empty.                                         */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_BUSY                 /**< Resource or module is busy.                                */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+
+    /* Read/Write Access Errors */
+    ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
+                            /*   String: none, or device name.                              */
+    ,E_WRITE_FAILED         /**< Write access failed on memory/device.                      */
+                            /*   String: none, or device name.                              */
+
+    /* Send/Receive Failures */
+    ,E_SEND_FAILED          /**< Send operation failed on device.                           */
+                            /*   String: none, or device name.                              */
+    ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
+                            /*   String: none, or device name.                              */
+
+    /* Operation time-out */
+    ,E_TIMEOUT              /**< The operation timed out.                                   */
+                            /*   String: none.                                              */
+
+    ,E_DUMMY_LAST           /* NEVER USED */
+
+} e_ErrorType;
+
+
+/**************************************************************************//**
+ @Description    Event Type Enumeration
+*//***************************************************************************/
+typedef enum e_Event        /*   Comments / Associated Flags and Message Strings            */
+{                           /* ------------------------------------------------------------ */
+    EV_NO_EVENT = 0         /**< No event; Never used.                                      */
+
+    ,EV_RX_DISCARD          /**< Received packet discarded (by the driver, and only for
+                                 complete packets);
+                                 Flags: error flags in case of error, zero otherwise.       */
+                            /*   String: reason for discard, e.g: "Error in frame",
+                                 "Disordered frame", "Incomplete frame", "No frame object". */
+    ,EV_RX_ERROR            /**< Receive error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_TX_ERROR            /**< Transmit error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_NO_BUFFERS          /**< System ran out of buffer objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_MB_FRAMES        /**< System ran out of multi-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_SB_FRAMES        /**< System ran out of single-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_TX_QUEUE_FULL       /**< Transmit queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_RX_QUEUE_FULL       /**< Receive queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_INTR_QUEUE_FULL     /**< Interrupt queue overflow;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_DATA_BUFFER      /**< Data buffer allocation (from higher layer) failed;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_OBJ_POOL_EMPTY      /**< Objects pool is empty;
+                                 Flags: zero.                                               */
+                            /*   String: object description (name).                         */
+    ,EV_BUS_ERROR           /**< Illegal access on bus;
+                                 Flags: the address (if available) or bus identifier        */
+                            /*   String: bus/address/module description.                    */
+    ,EV_PTP_TXTS_QUEUE_FULL /**< PTP Tx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_PTP_RXTS_QUEUE_FULL /**< PTP Rx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_DUMMY_LAST
+
+} e_Event;
+
+
+/**************************************************************************//**
+ @Collection    Debug Levels for Errors and Events
+
+                The level description refers to errors only.
+                For events, classification is done by the user.
+
+                The TRACE, INFO and WARNING levels are allowed only when using
+                the DBG macro, and are not allowed when using the error macros
+                (RETURN_ERROR or REPORT_ERROR).
+ @{
+*//***************************************************************************/
+#define REPORT_LEVEL_CRITICAL   1       /**< Crasher: Incorrect flow, NULL pointers/handles. */
+#define REPORT_LEVEL_MAJOR      2       /**< Cannot proceed: Invalid operation, parameters or
+                                             configuration. */
+#define REPORT_LEVEL_MINOR      3       /**< Recoverable problem: a repeating call with the same
+                                             parameters may be successful. */
+#define REPORT_LEVEL_WARNING    4       /**< Something is not exactly right, yet it is not an error. */
+#define REPORT_LEVEL_INFO       5       /**< Messages which may be of interest to user/programmer. */
+#define REPORT_LEVEL_TRACE      6       /**< Program flow messages. */
+
+#define EVENT_DISABLED          0xFF    /**< Disabled event (not reported at all) */
+
+/* @} */
+
+
+
+#define NO_MSG      ("")
+
+#ifndef DEBUG_GLOBAL_LEVEL
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* DEBUG_GLOBAL_LEVEL */
+
+#ifndef ERROR_GLOBAL_LEVEL
+#define ERROR_GLOBAL_LEVEL  DEBUG_GLOBAL_LEVEL
+#endif /* ERROR_GLOBAL_LEVEL */
+
+#ifndef EVENT_GLOBAL_LEVEL
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+#endif /* EVENT_GLOBAL_LEVEL */
+
+#ifdef EVENT_LOCAL_LEVEL
+#define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
+#else
+#define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
+#endif /* EVENT_LOCAL_LEVEL */
+
+
+#ifndef DEBUG_DYNAMIC_LEVEL
+#define DEBUG_USING_STATIC_LEVEL
+
+#ifdef DEBUG_STATIC_LEVEL
+#define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
+#else
+#define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
+#endif /* DEBUG_STATIC_LEVEL */
+
+#else /* DEBUG_DYNAMIC_LEVEL */
+#ifdef DEBUG_STATIC_LEVEL
+#error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
+#else
+int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
+#endif /* DEBUG_STATIC_LEVEL */
+#endif /* !DEBUG_DYNAMIC_LEVEL */
+
+
+#ifndef ERROR_DYNAMIC_LEVEL
+
+#ifdef ERROR_STATIC_LEVEL
+#define ERROR_DYNAMIC_LEVEL ERROR_STATIC_LEVEL
+#else
+#define ERROR_DYNAMIC_LEVEL ERROR_GLOBAL_LEVEL
+#endif /* ERROR_STATIC_LEVEL */
+
+#else /* ERROR_DYNAMIC_LEVEL */
+#ifdef ERROR_STATIC_LEVEL
+#error "Please use either ERROR_STATIC_LEVEL or ERROR_DYNAMIC_LEVEL (not both)"
+#else
+int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
+#endif /* ERROR_STATIC_LEVEL */
+#endif /* !ERROR_DYNAMIC_LEVEL */
+
+#define PRINT_FORMAT        "[CPU%02d, %s:%d %s]"
+#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
+
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+/* No debug/error/event messages at all */
+#define DBG(_level, _vmsg)
+
+#define REPORT_ERROR(_level, _err, _vmsg)
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+        return ERROR_CODE(_err)
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#else /* DEBUG_ERRORS > 0 */
+
+extern const char *dbgLevelStrings[];
+extern const char *errTypeStrings[];
+extern const char *moduleStrings[];
+#if (REPORT_EVENTS > 0)
+extern const char *eventStrings[];
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
+/* No need for DBG macro - debug level is higher anyway */
+#define DBG(_level, _vmsg)
+#else
+#define DBG(_level, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("> %s (%s) " PRINT_FORMAT ": ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+#endif /* (defined(DEBUG_USING_STATIC_LEVEL) && (DEBUG_DYNAMIC_LEVEL < WARNING)) */
+
+
+#define REPORT_ERROR(_level, _err, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= ERROR_DYNAMIC_LEVEL) { \
+            XX_Print("! %s %s Error " PRINT_FORMAT ": %s; ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS, \
+                     errTypeStrings[(GET_ERROR_TYPE(_err) - E_OK - 1)]); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+    do { \
+        REPORT_ERROR(_level, (_err), _vmsg); \
+        return ERROR_CODE(_err); \
+    } while (0)
+
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
+                     dbgLevelStrings[_ev##_LEVEL - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS, \
+                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
+                     (uint16_t)(_flg)); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else /* not REPORT_EVENTS */
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+#endif /* (DEBUG_ERRORS > 0) */
+
+
+/**************************************************************************//**
+ @Function      ASSERT_COND
+
+ @Description   Assertion macro.
+
+ @Param[in]     _cond - The condition being checked, in positive form;
+                        Failure of the condition triggers the assert.
+*//***************************************************************************/
+#ifdef DISABLE_ASSERTIONS
+#define ASSERT_COND(_cond)
+#else
+#define ASSERT_COND(_cond) \
+    do { \
+        if (!(_cond)) { \
+            XX_Print("*** ASSERT_COND failed " PRINT_FORMAT "\r\n", \
+                    PRINT_FMT_PARAMS); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+#endif /* DISABLE_ASSERTIONS */
+
+
+#ifdef DISABLE_INIT_PARAMETERS_CHECK
+
+#define CHECK_INIT_PARAMETERS(handle, f_check)
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval)
+
+#else
+
+#define CHECK_INIT_PARAMETERS(handle, f_check) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            RETURN_ERROR(MAJOR, err, NO_MSG); \
+        } \
+    } while (0)
+
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            REPORT_ERROR(MAJOR, err, NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_INIT_PARAMETERS_CHECK */
+
+#ifdef DISABLE_SANITY_CHECKS
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err)
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval)
+#define SANITY_CHECK_RETURN(_cond, _err)
+#define SANITY_CHECK_EXIT(_cond, _err)
+
+#else /* DISABLE_SANITY_CHECKS */
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            RETURN_ERROR(CRITICAL, (_err), NO_MSG); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return; \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_EXIT(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_SANITY_CHECKS */
+
+/** @} */ /* end of Debug/error Utils group */
+
+/** @} */ /* end of General Utils group */
+
+#endif /* __ERROR_EXT_H */
+
+
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
new file mode 100644
index 0000000..4418c80
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
@@ -0,0 +1,357 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list_ext.h
+
+ @Description   External prototypes for list.c
+*//***************************************************************************/
+
+#ifndef __LIST_EXT_H
+#define __LIST_EXT_H
+
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         list_id List
+
+ @Description   List module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   List structure.
+*//***************************************************************************/
+typedef struct List
+{
+    struct List *p_Next;  /**< A pointer to the next list object     */
+    struct List *p_Prev;  /**< A pointer to the previous list object */
+} t_List;
+
+
+/**************************************************************************//**
+ @Function      LIST_FIRST/LIST_LAST/LIST_NEXT/LIST_PREV
+
+ @Description   Macro to get first/last/next/previous entry in a list.
+
+ @Param[in]     p_List - A pointer to a list.
+*//***************************************************************************/
+#define LIST_FIRST(p_List) (p_List)->p_Next
+#define LIST_LAST(p_List)  (p_List)->p_Prev
+#define LIST_NEXT          LIST_FIRST
+#define LIST_PREV          LIST_LAST
+
+
+/**************************************************************************//**
+ @Function      LIST_INIT
+
+ @Description   Macro for initialization of a list struct.
+
+ @Param[in]     lst - The t_List object to initialize.
+*//***************************************************************************/
+#define LIST_INIT(lst) {&(lst), &(lst)}
+
+
+/**************************************************************************//**
+ @Function      LIST
+
+ @Description   Macro to declare of a list.
+
+ @Param[in]     listName - The list object name.
+*//***************************************************************************/
+#define LIST(listName) t_List listName = LIST_INIT(listName)
+
+
+/**************************************************************************//**
+ @Function      INIT_LIST
+
+ @Description   Macro to initialize a list pointer.
+
+ @Param[in]     p_List - The list pointer.
+*//***************************************************************************/
+#define INIT_LIST(p_List)   LIST_FIRST(p_List) = LIST_LAST(p_List) = (p_List)
+
+
+/**************************************************************************//**
+ @Function      LIST_OBJECT
+
+ @Description   Macro to get the struct (object) for this entry.
+
+ @Param[in]     type   - The type of the struct (object) this list is embedded in.
+ @Param[in]     member - The name of the t_List object within the struct.
+
+ @Return        The structure pointer for this entry.
+*//***************************************************************************/
+#define MEMBER_OFFSET(type, member) (PTR_TO_UINT(&((type *)0)->member))
+#define LIST_OBJECT(p_List, type, member) \
+    ((type *)((char *)(p_List)-MEMBER_OFFSET(type, member)))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH
+
+ @Description   Macro to iterate over a list.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH(p_Pos, p_Head) \
+    for (p_Pos = LIST_FIRST(p_Head); p_Pos != (p_Head); p_Pos = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_SAFE
+
+ @Description   Macro to iterate over a list safe against removal of list entry.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+*//***************************************************************************/
+#define LIST_FOR_EACH_SAFE(p_Pos, p_Tmp, p_Head)                \
+    for (p_Pos = LIST_FIRST(p_Head), p_Tmp = LIST_FIRST(p_Pos); \
+         p_Pos != (p_Head);                                     \
+         p_Pos = p_Tmp, p_Tmp = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT_SAFE
+
+ @Description   Macro to iterate over list of given type safely.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT_SAFE(p_Pos, p_Tmp, p_Head, type, member)      \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member),            \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member);    \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = p_Tmp,                                                    \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member))
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT
+
+ @Description   Macro to iterate over list of given type.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT(p_Pos, type, p_Head, member)                  \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member);            \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = LIST_OBJECT(LIST_FIRST(&(p_Pos->member)), type, member))
+
+
+/**************************************************************************//**
+ @Function      LIST_Add
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry after the specified head.
+                This is good for implementing stacks.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Add(t_List *p_New, t_List *p_Head)
+{
+    LIST_PREV(LIST_NEXT(p_Head)) = p_New;
+    LIST_NEXT(p_New)             = LIST_NEXT(p_Head);
+    LIST_PREV(p_New)             = p_Head;
+    LIST_NEXT(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_AddToTail
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry before the specified head.
+                This is useful for implementing queues.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_AddToTail(t_List *p_New, t_List *p_Head)
+{
+    LIST_NEXT(LIST_PREV(p_Head)) = p_New;
+    LIST_PREV(p_New)             = LIST_PREV(p_Head);
+    LIST_NEXT(p_New)             = p_Head;
+    LIST_PREV(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Del
+
+ @Description   Deletes entry from a list.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+
+ @Cautions      LIST_IsEmpty() on entry does not return true after this,
+                the entry is in an undefined state.
+*//***************************************************************************/
+static __inline__ void LIST_Del(t_List *p_Entry)
+{
+    LIST_PREV(LIST_NEXT(p_Entry)) = LIST_PREV(p_Entry);
+    LIST_NEXT(LIST_PREV(p_Entry)) = LIST_NEXT(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_DelAndInit
+
+ @Description   Deletes entry from list and reinitialize it.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_DelAndInit(t_List *p_Entry)
+{
+    LIST_Del(p_Entry);
+    INIT_LIST(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Move
+
+ @Description   Delete from one list and add as another's head.
+
+ @Param[in]     p_Entry - A pointer to the list entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will precede our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Move(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_Add(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_MoveToTail
+
+ @Description   Delete from one list and add as another's tail.
+
+ @Param[in]     p_Entry - A pointer to the entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will follow our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_MoveToTail(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_AddToTail(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_IsEmpty
+
+ @Description   Tests whether a list is empty.
+
+ @Param[in]     p_List - A pointer to the list to test.
+
+ @Return        1 if the list is empty, 0 otherwise.
+*//***************************************************************************/
+static __inline__ int LIST_IsEmpty(t_List *p_List)
+{
+    return (LIST_FIRST(p_List) == p_List);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Append
+
+ @Description   Join two lists.
+
+ @Param[in]     p_NewList - A pointer to the new list to add.
+ @Param[in]     p_Head    - A pointer to the place to add it in the first list.
+
+ @Return        none.
+*//***************************************************************************/
+void LIST_Append(t_List *p_NewList, t_List *p_Head);
+
+
+/**************************************************************************//**
+ @Function      LIST_NumOfObjs
+
+ @Description   Counts number of objects in the list
+
+ @Param[in]     p_List - A pointer to the list which objects are to be counted.
+
+ @Return        Number of objects in the list.
+*//***************************************************************************/
+int LIST_NumOfObjs(t_List *p_List);
+
+/** @} */ /* end of list_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __LIST_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
new file mode 100644
index 0000000..16592d5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -0,0 +1,317 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          mem_ext.h
+
+ @Description   External prototypes for the memory manager object
+*//***************************************************************************/
+
+#ifndef __MEM_EXT_H
+#define __MEM_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_id   Slab Memory Manager
+
+ @Description   Slab Memory Manager module functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/* Each block is of the following structure:
+ *
+ *
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  | Alignment |  Prefix  | Data                      | Postfix   | Alignment |
+ *  |  field    |   field  |  field                    |   field   | Padding   |
+ *  |           |          |                           |           |           |
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  and at the beginning of all bytes, an additional optional padding might reside
+ *  to ensure that the first blocks data field is aligned as requested.
+ */
+
+
+#define MEM_MAX_NAME_LENGTH     8
+
+/**************************************************************************//*
+ @Description   Memory Segment structure
+*//***************************************************************************/
+
+typedef struct
+{
+    char        name[MEM_MAX_NAME_LENGTH];
+                                    /* The segment's name */
+    uint8_t     **p_Bases;          /* Base addresses of the segments */
+    uint8_t     **p_BlocksStack;    /* Array of pointers to blocks */
+    t_Handle    h_Spinlock;
+    uint16_t    dataSize;           /* Size of each data block */
+    uint16_t    prefixSize;         /* How many bytes to reserve before the data */
+    uint16_t    postfixSize;        /* How many bytes to reserve after the data */
+    uint16_t    alignment;          /* Requested alignment for the data field */
+    int         allocOwner;         /* Memory allocation owner */
+    uint32_t    getFailures;        /* Number of times get failed */
+    uint32_t    num;                /* Number of blocks in segment */
+    uint32_t    current;            /* Current block */
+    bool        consecutiveMem;     /* Allocate consecutive data blocks memory */
+#ifdef DEBUG_MEM_LEAKS
+    void        *p_MemDbg;          /* MEM debug database (MEM leaks detection) */
+    uint32_t    blockOffset;
+    uint32_t    blockSize;
+#endif /* DEBUG_MEM_LEAKS */
+} t_MemorySegment;
+
+
+
+/**************************************************************************//**
+ @Function      MEM_Init
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field (in bytes).
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_Init(char     name[],
+                 t_Handle *p_Handle,
+                 uint32_t num,
+                 uint16_t dataSize,
+                 uint16_t prefixSize,
+                 uint16_t postfixSize,
+                 uint16_t alignment);
+
+/**************************************************************************//**
+ @Function      MEM_InitSmart
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name            - Name of memory partition.
+ @Param[in]     p_Handle        - Handle to new segment is returned through here.
+ @Param[in]     num             - Number of blocks in new segment.
+ @Param[in]     dataSize        - Size of blocks in segment.
+ @Param[in]     prefixSize      - How many bytes to allocate before the data.
+ @Param[in]     postfixSize     - How many bytes to allocate after the data.
+ @Param[in]     alignment       - Requested alignment for data field (in bytes).
+ @Param[in]     memPartitionId  - Memory partition ID for allocation.
+ @Param[in]     consecutiveMem  - Whether to allocate the memory blocks
+                                  continuously or not.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_InitSmart(char      name[],
+                      t_Handle  *p_Handle,
+                      uint32_t  num,
+                      uint16_t  dataSize,
+                      uint16_t  prefixSize,
+                      uint16_t  postfixSize,
+                      uint16_t  alignment,
+                      uint8_t   memPartitionId,
+                      bool      consecutiveMem);
+
+/**************************************************************************//**
+ @Function      MEM_InitByAddress
+
+ @Description   Create a new memory segment with a specified base address.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field (in bytes).
+ @Param[in]     address     - The required base address.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+ *//***************************************************************************/
+t_Error MEM_InitByAddress(char        name[],
+                          t_Handle    *p_Handle,
+                          uint32_t    num,
+                          uint16_t    dataSize,
+                          uint16_t    prefixSize,
+                          uint16_t    postfixSize,
+                          uint16_t    alignment,
+                          uint8_t     *address);
+
+/**************************************************************************//**
+ @Function      MEM_Free
+
+ @Description   Free a specific memory segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_Free(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_Get
+
+ @Description   Get a block of memory from a segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+void * MEM_Get(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_GetN
+
+ @Description   Get up to N blocks of memory from a segment.
+
+                The blocks are assumed to be of a fixed size (one size per segment).
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     num     - Number of blocks to allocate.
+ @Param[out]    array   - Array of at least num pointers to which the addresses
+                          of the allocated blocks are written.
+
+ @Return        The number of blocks actually allocated.
+
+ @Cautions      Interrupts are disabled for all of the allocation loop.
+                Although this loop is very short for each block (several machine
+                instructions), you should not allocate a very large number
+                of blocks via this routine.
+*//***************************************************************************/
+uint16_t MEM_GetN(t_Handle h_Mem, uint32_t num, void *array[]);
+
+/**************************************************************************//**
+ @Function      MEM_Put
+
+ @Description   Put a block of memory back to a segment.
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     p_Block - The block to return.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+t_Error MEM_Put(t_Handle h_Mem, void *p_Block);
+
+/**************************************************************************//**
+ @Function      MEM_ComputePartitionSize
+
+ @Description   calculate a tight upper boundary of the size of a partition with
+                given attributes.
+
+                The returned value is suitable if one wants to use MEM_InitByAddress().
+
+ @Param[in]     num         - The number of blocks in the segment.
+ @Param[in]     dataSize    - Size of block to get.
+ @Param[in]     prefixSize  - The prefix size
+ @Param         postfixSize - The postfix size
+ @Param[in]     alignment   - The requested alignment value (in bytes)
+
+ @Return        The memory block size a segment with the given attributes needs.
+*//***************************************************************************/
+uint32_t MEM_ComputePartitionSize(uint32_t num,
+                                  uint16_t dataSize,
+                                  uint16_t prefixSize,
+                                  uint16_t postfixSize,
+                                  uint16_t alignment);
+
+#ifdef DEBUG_MEM_LEAKS
+#if !(defined(__MWERKS__) && (__dest_os == __ppc_eabi))
+#error  "Memory-Leaks-Debug option is supported only for freescale CodeWarrior"
+#endif /* !(defined(__MWERKS__) && ... */
+
+/**************************************************************************//**
+ @Function      MEM_CheckLeaks
+
+ @Description   Report MEM object leaks.
+
+                This routine is automatically called by the MEM_Free() routine,
+                but it can also be invoked while the MEM object is alive.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_CheckLeaks(t_Handle h_Mem);
+
+#else  /* not DEBUG_MEM_LEAKS */
+#define MEM_CheckLeaks(h_Mem)
+#endif /* not DEBUG_MEM_LEAKS */
+
+/**************************************************************************//**
+ @Description   Get base of MEM
+*//***************************************************************************/
+#define MEM_GetBase(h_Mem)             ((t_MemorySegment *)(h_Mem))->p_Bases[0]
+
+/**************************************************************************//**
+ @Description   Get size of MEM block
+*//***************************************************************************/
+#define MEM_GetSize(h_Mem)             ((t_MemorySegment *)(h_Mem))->dataSize
+
+/**************************************************************************//**
+ @Description   Get prefix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPrefixSize(h_Mem)       ((t_MemorySegment *)(h_Mem))->prefixSize
+
+/**************************************************************************//**
+ @Description   Get postfix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPostfixSize(h_Mem)      ((t_MemorySegment *)(h_Mem))->postfixSize
+
+/**************************************************************************//**
+ @Description   Get alignment of MEM block (in bytes)
+*//***************************************************************************/
+#define MEM_GetAlignment(h_Mem)        ((t_MemorySegment *)(h_Mem))->alignment
+
+/**************************************************************************//**
+ @Description   Get the number of blocks in the segment
+*//***************************************************************************/
+#define MEM_GetNumOfBlocks(h_Mem)             ((t_MemorySegment *)(h_Mem))->num
+
+/** @} */ /* end of MEM group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
new file mode 100644
index 0000000..750cfe7
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -0,0 +1,173 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          memcpy_ext.h
+
+ @Description   Efficient functions for copying and setting blocks of memory.
+*//***************************************************************************/
+
+#ifndef __MEMCPY_EXT_H
+#define __MEMCPY_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_cpy Memory Copy
+
+ @Description   Memory Copy module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      MemCpy32
+
+ @Description   Copies one memory buffer into another one in 4-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 4 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non-null parameters as source & destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemCpy64
+
+ @Description   Copies one memory buffer into another one in 8-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 8 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+                Some testing suggests that MemCpy32() preforms better than
+                MemCpy64() over small buffers. On average they break even at
+                100 byte buffers. For buffers larger than that MemCpy64 is
+                superior.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameters as source & destination and size
+                that actually fits into their buffer.
+
+                Do not use under Linux.
+*//***************************************************************************/
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet32
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                4-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet32(void* pDst, uint8_t val, uint32_t size);
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet64
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                8-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet64(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemDisp
+
+ @Description   Displays a block of memory in chunks of 32 bits.
+
+ @Param[in]     addr    - The address of the memory to dysplay.
+ @Param[in]     size    - The number of bytes that will be displayed.
+
+ @Return        None.
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void MemDisp(uint8_t *addr, int size);
+
+/** @} */ /* end of mem_cpy group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEMCPY_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
new file mode 100644
index 0000000..61fd2ae
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -0,0 +1,300 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          mm_ext.h
+
+ @Description   Memory Manager Application Programming Interface
+*//***************************************************************************/
+#ifndef __MM_EXT
+#define __MM_EXT
+
+#include "std_ext.h"
+
+#define MM_MAX_ALIGNMENT    20  /* Alignments from 2 to 128 are available
+                                   where maximum alignment defined as
+                                   MM_MAX_ALIGNMENT power of 2 */
+
+#define MM_MAX_NAME_LEN     50
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mm_grp Flexible Memory Manager
+
+ @Description   Flexible Memory Manager module functions,definitions and enums.
+                (All of the following functions,definitions and enums can be found in mm_ext.h)
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Function      MM_Init
+
+ @Description   Initializes a new MM object.
+
+                It initializes a new memory block consisting of base address
+                and size of the available memory by calling to MemBlock_Init
+                routine. It is also initializes a new free block for each
+                by calling FreeBlock_Init routine, which is pointed to
+                the almost all memory started from the required alignment
+                from the base address and to the end of the memory.
+                The handle to the new MM object is returned via "MM"
+                argument (passed by reference).
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+
+ @Return        E_OK is returned on success. E_NOMEMORY is returned if the new MM object or a new free block can not be initialized.
+*//***************************************************************************/
+t_Error     MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Get
+
+ @Description   Allocates a block of memory according to the given size and the alignment.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The routine passes through the specific free list of free
+                blocks and seeks for a first block that have anough memory
+                that  is required (best fit).
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment (in bytes); Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     name        - The name that specifies an allocated block.
+
+ @Return        base address of an allocated block ILLEGAL_BASE if can't allocate a block
+*//***************************************************************************/
+uint64_t    MM_Get(t_Handle h_MM, uint64_t size, uint64_t alignment, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetBase
+
+ @Description   Gets the base address of the required MM objects.
+
+ @Param[in]     h_MM - Handle to the MM object.
+
+ @Return        base address of the block.
+*//***************************************************************************/
+uint64_t    MM_GetBase(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetForce
+
+ @Description   Force memory allocation.
+
+                It means to allocate a block of memory of the given
+                size from the given base address.
+                The routine checks if the required block can be allocated
+                (that is it is free) and then, calls the internal MM_CutFree
+                routine to update all free lists do not include that block.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+ @Param[in]     name    - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block, ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetForceMin
+
+ @Description   Allocates a block of memory according to the given size, the alignment and minimum base address.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The minimum baser address forces the location of the block
+                to be from a given address onward.
+                The routine passes through the specific free list of free
+                blocks and seeks for the first base address equal or smaller
+                than the required minimum address and end address larger than
+                than the required base + its size - i.e. that may contain
+                the required block.
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment (in bytes); Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     min         - The minimum base address of the block.
+ @Param[in]     name        - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block,ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForceMin(t_Handle h_MM,
+                           uint64_t size,
+                           uint64_t alignment,
+                           uint64_t min,
+                           char     *name);
+
+/**************************************************************************//**
+ @Function      MM_Put
+
+ @Description   Puts a block of memory of the given base address back to the memory.
+
+                It checks if there is a busy block with the
+                given base address. If not, it returns 0, that
+                means can't free a block. Otherwise, it gets parameters of
+                the busy block and after it updates lists of free blocks,
+                removes that busy block from the list by calling to MM_CutBusy
+                routine.
+                After that it calls to MM_AddFree routine to add a new free
+                block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+
+ @Return         The size of bytes released, 0 if failed.
+*//***************************************************************************/
+uint64_t    MM_Put(t_Handle h_MM, uint64_t base);
+
+/**************************************************************************//**
+ @Function      MM_PutForce
+
+ @Description   Releases a block of memory of the required size from the required base address.
+
+                First, it calls to MM_CutBusy routine
+                to cut a free block from the busy list. And then, calls to
+                MM_AddFree routine to add the free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of of a block to free.
+ @Param[in]     size    - Size of a block to free.
+
+ @Return        The number of bytes released, 0 on failure.
+*//***************************************************************************/
+uint64_t    MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Add
+
+ @Description   Adds a new memory block for memory allocation.
+
+                When a new memory block is initialized and added to the
+                memory list, it calls to MM_AddFree routine to add the
+                new free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the memory block.
+ @Param[in]     size    - Size of the memory block.
+
+ @Return        E_OK on success, otherwise returns an error code.
+*//***************************************************************************/
+t_Error     MM_Add(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Dump
+
+ @Description   Prints results of free and busy lists into the file.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     buff        - A pointer to a buffer
+*//***************************************************************************/
+void        MM_Dump(t_Handle h_MM, void *buff);
+
+/**************************************************************************//**
+ @Function      MM_Free
+
+ @Description   Releases memory allocated for MM object.
+
+ @Param[in]     h_MM - Handle of the MM object.
+*//***************************************************************************/
+void        MM_Free(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetMemBlock
+
+ @Description   Returns base address of the memory block specified by the index.
+
+                If index is 0, returns base address
+                of the first memory block, 1 - returns base address
+                of the second memory block, etc.
+                Note, those memory blocks are allocated by the
+                application before MM_Init or MM_Add and have to
+                be released by the application before or after invoking
+                the MM_Free routine.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     index   - Index of the memory block.
+
+ @Return        valid base address or ILLEGAL_BASE if no memory block specified by the index.
+*//***************************************************************************/
+uint64_t    MM_GetMemBlock(t_Handle h_MM, int index);
+
+/**************************************************************************//**
+ @Function      MM_InRange
+
+ @Description   Checks if a specific address is in the memory range of the passed MM object.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     addr    - The address to be checked.
+
+ @Return        TRUE if the addres is in the address range of the block,FALSE otherwise.
+*//***************************************************************************/
+bool        MM_InRange(t_Handle h_MM, uint64_t addr);
+
+
+/** @} */ /* end of mm_grp group */
+/** @} */ /* end of etc_id group */
+
+#endif /* __MM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
new file mode 100644
index 0000000..2fc5d63
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -0,0 +1,125 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          sprint_ext.h
+
+ @Description   Debug routines (externals).
+
+*//***************************************************************************/
+
+#ifndef __SPRINT_EXT_H
+#define __SPRINT_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+
+#elif defined(NCSW_LINUX_USD)
+#include <stdio.h>
+#include "stdarg_ext.h"
+#include "std_ext.h"
+
+extern int vsscanf(const char *, const char *, va_list);
+
+#elif defined(NCSW_VXWORKS)
+#include "private/stdioP.h"
+
+#else
+#include <stdio.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         sprint_id Sprint
+
+ @Description   Sprint & Sscan module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      Sprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buff - The buffer to place the result into.
+ @Param[in]     str  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Sprint(char *buff, const char *str, ...);
+
+/**************************************************************************//**
+ @Function      Snprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buf  - The buffer to place the result into.
+ @Param[in]     size - The size of the buffer, including the trailing null space.
+ @Param[in]     fmt  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Snprint(char * buf, uint32_t size, const char *fmt, ...);
+
+/**************************************************************************//**
+ @Function      Sscan
+
+ @Description   Unformat a buffer into a list of arguments.
+
+ @Param[in]     buf  - input buffer.
+ @Param[in]     fmt  - formatting of buffer.
+ @Param[out]    ...  - resulting arguments.
+
+ @Return        Number of bytes unformatted.
+*//***************************************************************************/
+int Sscan(const char * buf, const char * fmt, ...);
+
+/** @} */ /* end of sprint_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __SPRINT_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
new file mode 100644
index 0000000..fa2910f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -0,0 +1,333 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   P1023 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+typedef enum e_DpaaSwPortal {
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2
+} e_DpaaSwPortal;
+
+typedef enum {
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL3
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS  3
+#define DPAA_MAX_NUM_OF_DC_PORTALS  3
+
+/*****************************************************************************
+ QMAN INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS 3
+#define QM_MAX_NUM_OF_WQ            8
+#define QM_MAX_NUM_OF_SWP_AS        2
+#define QM_MAX_NUM_OF_CGS           64
+#define QM_MAX_NUM_OF_FQIDS           (16*MEGABYTE)
+
+typedef enum {
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x21,
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+
+#ifdef SC1023
+    e_QM_FQ_CHANNEL_CISCO_SP0 = 0x60,
+    e_QM_FQ_CHANNEL_CISCO_SP1,
+    e_QM_FQ_CHANNEL_CISCO_SP2,
+#endif /* SC1023 */
+
+    e_QM_FQ_CHANNEL_CAAM = 0x80
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMAN INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         8
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          1
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_RX_PORTS   2
+#define FM_MAX_NUM_OF_10G_RX_PORTS  0
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   2
+#define FM_MAX_NUM_OF_10G_TX_PORTS  0
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OH_PORTS      5
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_MACSECS       1
+
+#if 0
+#define FM_MACSEC_SUPPORT
+#define FM_CAPWAP_SUPPORT
+#endif
+
+#define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   2           /**< Number of Offline parsing port external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          32          /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               7
+
+/* Rams defines */
+#define FM_MURAM_SIZE               (64*KILOBYTE)
+#define FM_IRAM_SIZE                (32*KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         32                  /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        16                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     128                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   2
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            15
+#define MAX_QMI_DEQ_SUBPORTAL           7
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            15
+#define DMA_THRESH_MAX_BUF              7
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            64
+#define BMI_MAX_NUM_OF_DMAS             16
+#define BMI_MAX_FIFO_SIZE              (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 4
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
+    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
+    e_FM_MOD_MACSEC,
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+} e_FmIntrType;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_ERR_MACSEC_MAC0,        /**< MACSEC MAC 0 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_MACSEC_MAC0,            /**< MACSEC MAC 0 event */
+    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
+    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
+    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
+    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                                  \
+    switch(mod){                                                                                    \
+        case e_FM_MOD_PRS:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_DUMMY_LAST; break;    \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_DUMMY_LAST; break;    \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_DUMMY_LAST; break;    \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC_TMR:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_MACSEC:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
+            else switch(id){                                                                        \
+                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
+                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
+                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
+                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
+                 }                                                                                  \
+            break;                                                                                  \
+        default:event = e_FM_EV_DUMMY_LAST;                                                         \
+        break;}
+
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+
+typedef enum e_FmMacsecEventModules{
+    e_FM_MACSEC_MOD_SC_TX,
+    e_FM_MACSEC_MOD_DUMMY_LAST
+} e_FmMacsecEventModules;
+
+typedef enum e_FmMacsecInterModuleEvent {
+    e_FM_MACSEC_EV_SC_TX,
+    e_FM_MACSEC_EV_ERR_SC_TX,
+    e_FM_MACSEC_EV_DUMMY_LAST
+} e_FmMacsecInterModuleEvent;
+
+#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
+
+#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
+    switch(mod){                                          \
+        case e_FM_MACSEC_MOD_SC_TX:                       \
+             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
+                        e_FM_MACSEC_EV_ERR_SC_TX:         \
+                        e_FM_MACSEC_EV_SC_TX;             \
+             event += (uint8_t)(2 * id);break;            \
+            break;                                        \
+        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
+        break;}
+
+
+/* 1023 unique features */
+#define FM_QMI_NO_ECC_EXCEPTIONS
+#define FM_CSI_CFED_LIMIT
+#define FM_PEDANTIC_DMA
+
+/* FM erratas */
+#define FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001                 FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2      /* No implementation, Out of LLD scope */
+
+#define FM_IM_TX_SYNC_SKIP_TNUM_ERRATA_FMAN_A001        /* Implemented by ucode */
+#define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003            /* Implemented by ucode */
+#define FM_IM_TX_SHARED_TNUM_ERRATA_FMAN4               /* Implemented by ucode */
+#define FM_IM_GS_DEADLOCK_ERRATA_FMAN5                  /* Implemented by ucode */
+#define FM_IM_DEQ_PIPELINE_DEPTH_ERRATA_FMAN10          /* Implemented by ucode */
+#define FM_CC_GEN6_MISSMATCH_ERRATA_FMAN12              /* Implemented by ucode */
+#define FM_CC_CHANGE_SHARED_TNUM_ERRATA_FMAN13          /* Implemented by ucode */
+#define FM_IM_LARGE_MRBLR_ERRATA_FMAN15                 /* Implemented by ucode */
+
+#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+
+/* ??? */
+#define FM_GRS_ERRATA_DTSEC_A002
+#define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
+#define FM_GTS_ERRATA_DTSEC_A004
+#define FM_TX_LOCKUP_ERRATA_DTSEC6
+
+#define FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+
+#endif /* __FM_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
new file mode 100644
index 0000000..bb8b054
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+
+#if !(defined(MPC8306) || \
+      defined(MPC8309) || \
+      defined(MPC834x) || \
+      defined(MPC836x) || \
+      defined(MPC832x) || \
+      defined(MPC837x) || \
+      defined(MPC8568) || \
+      defined(MPC8569) || \
+      defined(P1020)   || \
+      defined(P1021)   || \
+      defined(P1022)   || \
+      defined(P1023)   || \
+      defined(P2020)   || \
+      defined(P3041)   || \
+      defined(P4080)   || \
+      defined(P5020)   || \
+      defined(MSC814x))
+#error "unable to proceed without chip-definition"
+#endif
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uint64_t    (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uint64_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
new file mode 100644
index 0000000..40a7c28
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -0,0 +1,689 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   P1023 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+#ifndef NCSW_LINUX
+#include "ddr_std_ext.h"
+#endif
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         1023_chip_id P1023 Application Programming Interface
+
+ @Description   P1023 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define INTG_MAX_NUM_OF_CORES   1
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_LAW,            /**< Local Access module                     */
+    e_MODULE_ID_ECM,            /**< e500 Coherency Module                   */
+    e_MODULE_ID_DDR,            /**< DDR memory controller                   */
+    e_MODULE_ID_I2C_1,          /**< I2C 1                                   */
+    e_MODULE_ID_I2C_2,          /**< I2C 1                                   */
+    e_MODULE_ID_DUART_1,        /**< DUART module 1                          */
+    e_MODULE_ID_DUART_2,        /**< DUART module 2                          */
+    e_MODULE_ID_LBC,            /**< Local bus memory controller module      */
+    e_MODULE_ID_PCIE_1,         /**< PCI Express 1 controller module         */
+    e_MODULE_ID_PCIE_ATMU_1,    /**< PCI 1 ATMU Window                       */
+    e_MODULE_ID_PCIE_2,         /**< PCI Express 2 controller module         */
+    e_MODULE_ID_PCIE_ATMU_2,    /**< PCI 2 ATMU Window                       */
+    e_MODULE_ID_PCIE_3,         /**< PCI Express 3 controller module         */
+    e_MODULE_ID_PCIE_ATMU_3,    /**< PCI 3 ATMU Window                       */
+    e_MODULE_ID_MSI,            /**< MSI registers                           */
+    e_MODULE_ID_L2_SRAM,        /**< L2/SRAM Memory-Mapped controller module */
+    e_MODULE_ID_DMA_1,          /**< DMA controller 1                        */
+    e_MODULE_ID_DMA_2,          /**< DMA controller 2                        */
+    e_MODULE_ID_EPIC,           /**< Programmable interrupt controller       */
+    e_MODULE_ID_ESPI,           /**< ESPI module                             */
+    e_MODULE_ID_GPIO,           /**< General Purpose I/O                     */
+    e_MODULE_ID_SEC_GEN,        /**< SEC 4.0 General registers               */
+    e_MODULE_ID_SEC_QI,         /**< SEC 4.0 QI registers                    */
+    e_MODULE_ID_SEC_JQ0,        /**< SEC 4.0 JQ-0 registers                  */
+    e_MODULE_ID_SEC_JQ1,        /**< SEC 4.0 JQ-1 registers                  */
+    e_MODULE_ID_SEC_JQ2,        /**< SEC 4.0 JQ-2 registers                  */
+    e_MODULE_ID_SEC_JQ3,        /**< SEC 4.0 JQ-3 registers                  */
+    e_MODULE_ID_SEC_RTIC,       /**< SEC 4.0 RTIC registers                  */
+    e_MODULE_ID_SEC_DECO0_CCB0, /**< SEC 4.0 DECO-0/CCB-0 registers          */
+    e_MODULE_ID_SEC_DECO1_CCB1, /**< SEC 4.0 DECO-1/CCB-1 registers          */
+    e_MODULE_ID_SEC_DECO2_CCB2, /**< SEC 4.0 DECO-2/CCB-2 registers          */
+    e_MODULE_ID_SEC_DECO3_CCB3, /**< SEC 4.0 DECO-3/CCB-3 registers          */
+    e_MODULE_ID_SEC_DECO4_CCB4, /**< SEC 4.0 DECO-4/CCB-4 registers          */
+    e_MODULE_ID_USB_DR_1,       /**< USB 2.0 module 1                        */
+    e_MODULE_ID_USB_DR_2,       /**< USB 2.0 module 2                        */
+    e_MODULE_ID_ETSEC_MII_MNG,  /**< MII MNG registers                       */
+    e_MODULE_ID_ETSEC_1,        /**< ETSEC module 1                             */
+    e_MODULE_ID_ETSEC_2,        /**< ETSEC module 2                             */
+    e_MODULE_ID_GUTS,           /**< Serial DMA                              */
+    e_MODULE_ID_PM,             /**< Performance Monitor module              */
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL,
+    e_MODULE_ID_QM_CI_PORTAL,
+    e_MODULE_ID_BM_CE_PORTAL,
+    e_MODULE_ID_BM_CI_PORTAL,
+    e_MODULE_ID_FM,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_MACSEC,         /**< FM MACSEC */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+
+#define P1023_OFFSET_LAW                    0x00000C08
+#define P1023_OFFSET_ECM                    0x00001000
+#define P1023_OFFSET_DDR                    0x00002000
+#define P1023_OFFSET_I2C1                   0x00003000
+#define P1023_OFFSET_I2C2                   0x00003100
+#define P1023_OFFSET_DUART1                 0x00004500
+#define P1023_OFFSET_DUART2                 0x00004600
+#define P1023_OFFSET_LBC                    0x00005000
+#define P1023_OFFSET_ESPI                   0x00007000
+#define P1023_OFFSET_PCIE2                  0x00009000
+#define P1023_OFFSET_PCIE2_ATMU             0x00009C00
+#define P1023_OFFSET_PCIE1                  0x0000A000
+#define P1023_OFFSET_PCIE1_ATMU             0x0000AC00
+#define P1023_OFFSET_PCIE3                  0x0000B000
+#define P1023_OFFSET_PCIE3_ATMU             0x0000BC00
+#define P1023_OFFSET_DMA2                   0x0000C100
+#define P1023_OFFSET_GPIO                   0x0000F000
+#define P1023_OFFSET_L2_SRAM                0x00020000
+#define P1023_OFFSET_DMA1                   0x00021100
+#define P1023_OFFSET_USB1                   0x00022000
+#define P1023_OFFSET_SEC_GEN                0x00030000
+#define P1023_OFFSET_SEC_JQ0                0x00031000
+#define P1023_OFFSET_SEC_JQ1                0x00032000
+#define P1023_OFFSET_SEC_JQ2                0x00033000
+#define P1023_OFFSET_SEC_JQ3                0x00034000
+#define P1023_OFFSET_SEC_RTIC               0x00036000
+#define P1023_OFFSET_SEC_QI                 0x00037000
+#define P1023_OFFSET_SEC_DECO0_CCB0         0x00038000
+#define P1023_OFFSET_SEC_DECO1_CCB1         0x00039000
+#define P1023_OFFSET_SEC_DECO2_CCB2         0x0003a000
+#define P1023_OFFSET_SEC_DECO3_CCB3         0x0003b000
+#define P1023_OFFSET_SEC_DECO4_CCB4         0x0003c000
+#define P1023_OFFSET_PIC                    0x00040000
+#define P1023_OFFSET_MSI                    0x00041600
+#define P1023_OFFSET_AXI                    0x00081000
+#define P1023_OFFSET_QM                     0x00088000
+#define P1023_OFFSET_BM                     0x0008A000
+#define P1022_OFFSET_PM                     0x000E1000
+
+#ifdef RSC1023
+#define P1023_OFFSET_DTSEC0_MII_MNG         0x00024520
+#define P1023_OFFSET_DTSEC0                 0x000B0000
+#define P1023_OFFSET_DTSEC1                 0x000B2000
+#endif /* RSC1023 */
+#define P1023_OFFSET_GUTIL                  0x000E0000
+#define P1023_OFFSET_PM                     0x000E1000
+#define P1023_OFFSET_DEBUG                  0x000E2000
+#define P1023_OFFSET_SERDES                 0x000E3000
+#define P1023_OFFSET_ROM                    0x000F0000
+#define P1023_OFFSET_FM                     0x00100000
+
+#define P1023_OFFSET_FM_MURAM               (P1023_OFFSET_FM + 0x00000000)
+#define P1023_OFFSET_FM_BMI                 (P1023_OFFSET_FM + 0x00080000)
+#define P1023_OFFSET_FM_QMI                 (P1023_OFFSET_FM + 0x00080400)
+#define P1023_OFFSET_FM_PRS                 (P1023_OFFSET_FM + 0x00080800)
+#define P1023_OFFSET_FM_PORT_HO0            (P1023_OFFSET_FM + 0x00081000)
+#define P1023_OFFSET_FM_PORT_HO1            (P1023_OFFSET_FM + 0x00082000)
+#define P1023_OFFSET_FM_PORT_HO2            (P1023_OFFSET_FM + 0x00083000)
+#define P1023_OFFSET_FM_PORT_HO3            (P1023_OFFSET_FM + 0x00084000)
+#define P1023_OFFSET_FM_PORT_HO4            (P1023_OFFSET_FM + 0x00085000)
+#define P1023_OFFSET_FM_PORT_1GRX0          (P1023_OFFSET_FM + 0x00088000)
+#define P1023_OFFSET_FM_PORT_1GRX1          (P1023_OFFSET_FM + 0x00089000)
+#define P1023_OFFSET_FM_PORT_1GTX0          (P1023_OFFSET_FM + 0x000A8000)
+#define P1023_OFFSET_FM_PORT_1GTX1          (P1023_OFFSET_FM + 0x000A9000)
+#define P1023_OFFSET_FM_PLCR                (P1023_OFFSET_FM + 0x000C0000)
+#define P1023_OFFSET_FM_KG                  (P1023_OFFSET_FM + 0x000C1000)
+#define P1023_OFFSET_FM_DMA                 (P1023_OFFSET_FM + 0x000C2000)
+#define P1023_OFFSET_FM_FPM                 (P1023_OFFSET_FM + 0x000C3000)
+#define P1023_OFFSET_FM_IRAM                (P1023_OFFSET_FM + 0x000C4000)
+#define P1023_OFFSET_FM_PRS_IRAM            (P1023_OFFSET_FM + 0x000C7000)
+#define P1023_OFFSET_FM_RISC0               (P1023_OFFSET_FM + 0x000D0000)
+#define P1023_OFFSET_FM_RISC1               (P1023_OFFSET_FM + 0x000D0400)
+#define P1023_OFFSET_FM_MACSEC              (P1023_OFFSET_FM + 0x000D8000)
+#define P1023_OFFSET_FM_1GMAC0              (P1023_OFFSET_FM + 0x000E0000)
+#define P1023_OFFSET_FM_1GMDIO0             (P1023_OFFSET_FM + 0x000E1120)
+#define P1023_OFFSET_FM_1GMAC1              (P1023_OFFSET_FM + 0x000E2000)
+#define P1023_OFFSET_FM_1GMDIO1             (P1023_OFFSET_FM + 0x000E3000)
+#define P1023_OFFSET_FM_RTC                 (P1023_OFFSET_FM + 0x000FE000)
+
+/* Offsets relative to QM or BM portals base */
+#define P1023_OFFSET_PORTALS_CE_AREA        0x00000000        /* cache enabled area */
+#define P1023_OFFSET_PORTALS_CI_AREA        0x00100000        /* cache inhibited area */
+
+#define P1023_OFFSET_PORTALS_CE(portal)     (P1023_OFFSET_PORTALS_CE_AREA + 0x4000 * (portal))
+#define P1023_OFFSET_PORTALS_CI(portal)     (P1023_OFFSET_PORTALS_CI_AREA + 0x1000 * (portal))
+
+/**************************************************************************//**
+ @Description   Transaction source ID (for memory conrollers error reporting).
+*//***************************************************************************/
+typedef enum e_TransSrc
+{
+    e_TRANS_SRC_PCIE_2          = 0x01, /**< PCIe port 2                    */
+    e_TRANS_SRC_PCIE_1          = 0x02, /**< PCIe port 1                    */
+    e_TRANS_SRC_PCIE_3          = 0x03, /**< PCIe port 3                    */
+    e_TRANS_SRC_LBC             = 0x04, /**< Enhanced local bus             */
+    e_TRANS_SRC_DPAA_SW_PORTALS = 0x0E, /**< DPAA software portals or SRAM  */
+    e_TRANS_SRC_DDR             = 0x0F, /**< DDR controller                 */
+    e_TRANS_SRC_CORE_INS_FETCH  = 0x10, /**< Processor (instruction)        */
+    e_TRANS_SRC_CORE_DATA       = 0x11, /**< Processor (data)               */
+    e_TRANS_SRC_DMA             = 0x15  /**< DMA                            */
+} e_TransSrc;
+
+/**************************************************************************//**
+ @Description   Local Access Window Target interface ID
+*//***************************************************************************/
+typedef enum e_P1023LawTargetId
+{
+    e_P1023_LAW_TARGET_PCIE_2       = 0x01, /**< PCI Express 2 target interface */
+    e_P1023_LAW_TARGET_PCIE_1       = 0x02, /**< PCI Express 1 target interface */
+    e_P1023_LAW_TARGET_PCIE_3       = 0x03, /**< PCI Express 3 target interface */
+    e_P1023_LAW_TARGET_LBC          = 0x04, /**< Local bus target interface */
+    e_P1023_LAW_TARGET_QM_PORTALS   = 0x0E, /**< Queue Manager Portals */
+    e_P1023_LAW_TARGET_BM_PORTALS   = 0x0E, /**< Buffer Manager Portals */
+    e_P1023_LAW_TARGET_SRAM         = 0x0E, /**< SRAM scratchpad */
+    e_P1023_LAW_TARGET_DDR          = 0x0F, /**< DDR target interface */
+    e_P1023_LAW_TARGET_NONE         = 0xFF  /**< Invalid target interface */
+} e_P1023LawTargetId;
+
+
+/**************************************************************************//**
+ @Group         1023_init_grp P1023 Initialization Unit
+
+ @Description   P1023 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Part ID and revision number
+*//***************************************************************************/
+typedef enum e_P1023DeviceName
+{
+    e_P1023_REV_INVALID = 0x00000000, /**< Invalid revision */
+#ifdef RSC1023
+    e_RSC1023_REV_1_0   = 0x80EC0010, /**< RSC1023 rev 1.0  */
+#endif
+    e_P1023_REV_1_0     = 0x80FC0010  /**< P1023 rev 1.0    */
+} e_P1023DeviceName;
+
+/**************************************************************************//**
+ @Description   structure representing P1023 initialization parameters
+*//***************************************************************************/
+typedef struct t_P1023Params
+{
+    uintptr_t   ccsrBaseAddress;        /**< CCSR base address (virtual) */
+    uintptr_t   bmPortalsBaseAddress;   /**< Portals base address (virtual) */
+    uintptr_t   qmPortalsBaseAddress;   /**< Portals base address (virtual) */
+} t_P1023Params;
+
+/**************************************************************************//**
+ @Function      P1023_ConfigAndInit
+
+ @Description   General initiation of the chip registers.
+
+ @Param[in]     p_P1023Params  - A pointer to data structure of parameters
+
+ @Return        A handle to the P1023 data structure.
+*//***************************************************************************/
+t_Handle P1023_ConfigAndInit(t_P1023Params *p_P1023Params);
+
+/**************************************************************************//**
+ @Function      P1023_Free
+
+ @Description   Free all resources.
+
+ @Param         h_P1023 - (In) The handle of the initialized P1023 object.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P1023_Free(t_Handle h_P1023);
+
+/**************************************************************************//**
+ @Function      P1023_GetRevInfo
+
+ @Description   This routine enables access to chip and revision information.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+
+ @Return        Part ID and revision.
+*//***************************************************************************/
+e_P1023DeviceName P1023_GetRevInfo(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetE500Factor
+
+ @Description   Returns E500 core clock multiplication factor.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param[in]     coreId          - Id of the requested core.
+ @Param[out]    p_E500MulFactor - Returns E500 to CCB multification factor.
+ @Param[out]    p_E500DivFactor - Returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*
+*//***************************************************************************/
+t_Error P1023_GetE500Factor(uintptr_t    gutilBase,
+                            uint32_t    coreId,
+                            uint32_t    *p_E500MulFactor,
+                            uint32_t    *p_E500DivFactor);
+
+/**************************************************************************//**
+ @Function      P1023_GetFmFactor
+
+ @Description   returns FM multiplication factors. (This value is returned using
+                two parameters to avoid using float parameter).
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param[out]    p_FmMulFactor   - returns E500 to CCB multification factor.
+ @Param[out]    p_FmDivFactor   - returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error  P1023_GetFmFactor(uintptr_t gutilBase, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
+
+/**************************************************************************//**
+ @Function      P1023_GetCcbFactor
+
+ @Description   returns system multiplication factor.
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+
+ @Return        System multiplication factor.
+*//***************************************************************************/
+uint32_t P1023_GetCcbFactor(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetDdrFactor
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock .
+                Note: assumes the ddr_in_clk is identical to the sys_in_clk
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param         p_DdrMulFactor  - returns DDR in clk multification factor.
+ @Param         p_DdrDivFactor  - returns DDR division factor.
+
+ @Return        E_OK on success; Other value otherwise..
+*//***************************************************************************/
+t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
+                            uint32_t    *p_DdrMulFactor,
+                            uint32_t    *p_DdrDivFactor);
+
+
+/**************************************************************************//**
+ @Function      P1023_GetDdrType
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock .
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param         p_DdrType   - (Out) returns DDR type DDR1/DDR2/DDR3.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+#ifndef NCSW_LINUX
+t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
+#endif
+
+
+/** @} */ /* end of 1023_init_grp group */
+/** @} */ /* end of 1023_grp group */
+
+#define CORE_E500V2
+
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_P1023            0x00040000
+#define MODULE_MII              0x00050000
+#define MODULE_PM               0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_PIC              0x00080000
+#define MODULE_L2_CACHE         0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_FM               0x00100000
+#define MODULE_FM_MURAM         0x00110000
+#define MODULE_FM_PCD           0x00120000
+#define MODULE_FM_RTC           0x00130000
+#define MODULE_FM_MAC           0x00140000
+#define MODULE_FM_PORT          0x00150000
+#define MODULE_FM_MACSEC        0x00160000
+#define MODULE_FM_MACSEC_SECY   0x00170000
+#define MODULE_ECM              0x00180000
+#define MODULE_DMA              0x00190000
+#define MODULE_DDR              0x001a0000
+#define MODULE_LAW              0x001b0000
+#define MODULE_LBC              0x001c0000
+#define MODULE_I2C              0x001d0000
+#define MODULE_ESPI             0x001e0000
+#define MODULE_PCI              0x001f0000
+#define MODULE_DPA              0x00200000
+#define MODULE_USB              0x00210000
+#ifdef RSC1023
+#define MODULE_ETSEC            0x00220000
+#endif /* RSC1023 */
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_NUM_OF_BANKS            2
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL
+#define LBC_ATOMIC_OPERATION_SUPPORT
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_SHIFT_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_ARCH_CCB
+#define LAW_NUM_OF_WINDOWS      12
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
+#define LAW_MAX_WINDOW_SIZE     0x0000001000000000LL    /**< 32GB */
+
+
+/*****************************************************************************
+ SPI INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SPI_NUM_OF_CONTROLLERS      1
+
+/*****************************************************************************
+ PCI/PCIe INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+
+#define PCI_MAX_INBOUND_WINDOWS_NUM     4
+#define PCI_MAX_OUTBOUND_WINDOWS_NUM    5
+
+/**************************************************************************//**
+ @Description   Target interface of an inbound window
+*//***************************************************************************/
+typedef enum e_PciTargetInterface
+{
+    e_PCI_TARGET_PCIE_2         = 0x1,  /**<  PCI Express target interface 2 */
+    e_PCI_TARGET_PCIE_1         = 0x2,  /**<  PCI Express target interface 1 */
+    e_PCI_TARGET_PCIE_3         = 0x3,  /**<  PCI Express target interface 3 */
+    e_PCI_TARGET_LOCAL_MEMORY   = 0xF   /**<  Local Memory (DDR SDRAM, Local Bus, SRAM) target interface */
+
+} e_PciTargetInterface;
+
+/*****************************************************************************
+ DDR INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_DDR_CTRLS  1
+#define DDR_NUM_OF_VALID_CS     2
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_ERRATA_STAT_REGS_UNUSABLE
+
+/*****************************************************************************
+ DMA INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define DMA_NUM_OF_CONTROLLERS  1
+
+/*****************************************************************************
+ I2c NUMBER OF DEVICES
+******************************************************************************/
+#define I2C_NUM_OF_DEVS 		4
+
+#ifdef RSC1023
+/*****************************************************************************
+ ETSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define ETSEC_NUM_OF_PORTS  2
+
+#define ETSEC_INTERFACES_MAP            \
+{                                       \
+    { e_ENET_IF_RGMII,  { 1, 1} },   \
+    { e_ENET_IF_SGMII,  { 1, 1} },   \
+}
+
+#define ETSEC_REV2
+#define ETSEC_PTP_SUPPORT
+
+#endif /* RSC1023 */
+
+
+/*****************************************************************************
+ 1588 INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PTP_V2
+
+/**************************************************************************//**
+ @Function      P1023_GetMuxControlReg
+
+ @Description   Returns the value of PMUXCR (Alternate Function Signal Multiplex 
+                Control Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        Value of PMUXCR
+*//***************************************************************************/
+uint32_t P1023_GetMuxControlReg(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_SetMuxControlReg
+
+ @Description   Sets the value of PMUXCR (Alternate Function Signal Multiplex 
+                Control Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+ @Param[in]     val         - the new value for PMUXCR.
+
+ @Return        None
+*//***************************************************************************/
+void P1023_SetMuxControlReg(uintptr_t gutilBase, uint32_t val);
+
+/**************************************************************************//**
+ @Function      P1023_GetPowerMngClkDisableReg
+
+ @Description   Returns the value of PMCDR (Power Management Clock Disable Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        Value of PMCDR
+*//***************************************************************************/
+uint32_t P1023_GetPowerMngClkDisableReg(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_SetPowerMngClkDisableReg
+
+ @Description   Sets the value of PMCDR ((Power Management Clock Disable Register))
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+ @Param[in]     val         - the new value for PMCDR.
+
+ @Return        None
+*//***************************************************************************/
+void P1023_SetPowerMngClkDisableReg(uintptr_t gutilBase, uint32_t val);
+
+/**************************************************************************//**
+ @Function      P1023_GetDeviceDisableStatusRegister
+
+ @Description   Returns the value of DEVDISR (Device Disable Register)
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        Value of DEVDISR
+*//***************************************************************************/
+uint32_t P1023_GetDeviceDisableStatusRegister(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetPorDeviceStatusRegister
+
+ @Description   Returns the value of POR Device Status Register
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        POR Device Status Register
+*//***************************************************************************/
+uint32_t P1023_GetPorDeviceStatusRegister(uintptr_t gutilBase);
+
+/**************************************************************************//**
+ @Function      P1023_GetPorBootModeStatusRegister
+
+ @Description   Returns the value of POR Boot Mode Status Register
+
+ @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
+
+ @Return        POR Boot Mode Status Register value
+*//***************************************************************************/
+uint32_t P1023_GetPorBootModeStatusRegister(uintptr_t gutilBase);
+
+
+#define PORDEVSR_SGMII1_DIS     0x10000000
+#define PORDEVSR_SGMII2_DIS     0x08000000
+#define PORDEVSR_ECP1           0x02000000
+#define PORDEVSR_IO_SEL         0x00780000
+#define PORDEVSR_IO_SEL_SHIFT   19
+#define PORBMSR_HA              0x00070000
+#define PORBMSR_HA_SHIFT        16
+
+#define DEVDISR_QM_BM           0x80000000
+#define DEVDISR_FM              0x40000000
+#define DEVDISR_PCIE1           0x20000000
+#define DEVDISR_MAC_SEC         0x10000000
+#define DEVDISR_ELBC            0x08000000
+#define DEVDISR_PCIE2           0x04000000
+#define DEVDISR_PCIE3           0x02000000
+#define DEVDISR_CAAM            0x01000000
+#define DEVDISR_USB0            0x00800000
+#define DEVDISR_1588            0x00020000
+#define DEVDISR_CORE0           0x00008000
+#define DEVDISR_TB0             0x00004000
+#define DEVDISR_CORE1           0x00002000
+#define DEVDISR_TB1             0x00001000
+#define DEVDISR_DMA1            0x00000400
+#define DEVDISR_DMA2            0x00000200
+#ifdef SC1023
+#define DEVDISR_CISCOIP         0x00000100
+#endif /* SC1023 */
+#define DEVDISR_DDR             0x00000010
+#define DEVDISR_TSEC1           0x00000080
+#define DEVDISR_TSEC2           0x00000040
+#define DEVDISR_SPI             0x00000008
+#define DEVDISR_I2C             0x00000004
+#define DEVDISR_DUART           0x00000002
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
new file mode 100644
index 0000000..7d280e8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -0,0 +1,450 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   P4080 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+typedef enum {
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+typedef enum {
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL3,
+    e_DPAA_DCPORTAL4,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QMAN_PM_DCP_COUNTERS_ERRATA_QMAN1
+#define QMAN_FQD_AVOID_BLK_ERRATA_QMAN2
+#define QMAN_DBG_TRC_EV_ERRATA_QMAN3
+#define QMAN_WQ_CS_CFG_ERRATA_QMAN4
+#define QMAN_SFDR_LEAK_ERRATA_QMAN5
+#define QMAN_FQ_TD_THRESH_ERRATA_QMAN6
+#define QMAN_FQ_INIT_ON_PARKED_ERRATA_QMAN7
+#define QMAN_NESN_ORR_ERRATA_QMAN8
+#define QMAN_ERN_REJ_CODE6_ERRATA_QMAN9
+#define QMAN_ERN_MOULTI_CORE_ERRATA_QMAN10
+#define QMAN_PERFMON_FOR_DCP_FQD_ERRATA_QMAN11
+
+#define QM_MAX_NUM_OF_POOL_CHANNELS 15
+#define QM_MAX_NUM_OF_WQ            8
+#define QM_MAX_NUM_OF_SWP_AS        4
+#define QM_MAX_NUM_OF_CGS           256
+#define QM_MAX_NUM_OF_FQIDS           (16*MEGABYTE)
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0,              /**< Dedicated channels serviced by software portals 0 to 9 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x21,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x40,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                     connected to FMan 0; assigned in incrementing order to
+                                                     each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+
+    e_QM_FQ_CHANNEL_FMAN1_SP0 = 0x60,
+    e_QM_FQ_CHANNEL_FMAN1_SP1,
+    e_QM_FQ_CHANNEL_FMAN1_SP2,
+    e_QM_FQ_CHANNEL_FMAN1_SP3,
+    e_QM_FQ_CHANNEL_FMAN1_SP4,
+    e_QM_FQ_CHANNEL_FMAN1_SP5,
+    e_QM_FQ_CHANNEL_FMAN1_SP6,
+    e_QM_FQ_CHANNEL_FMAN1_SP7,
+    e_QM_FQ_CHANNEL_FMAN1_SP8,
+    e_QM_FQ_CHANNEL_FMAN1_SP9,
+    e_QM_FQ_CHANNEL_FMAN1_SP10,
+    e_QM_FQ_CHANNEL_FMAN1_SP11,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x80,                /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                     connected to SEC 4.x */
+
+    e_QM_FQ_CHANNEL_PME = 0xA0,                 /**< Dedicated channel serviced by Direct Connect Portal 3:
+                                                     connected to PME */
+} e_QmFQChannel;
+
+/* p4080-rev1 unique features */
+#define QM_CGS_NO_FRAME_MODE
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/* SEC erratas */
+#ifdef UNDER_CONSTRUCTION_IPSEC
+#define SEC_IPV6_UDP_CHECKSUM_UPDATE
+#define SEC_UDP_LENGTH_UPDATE
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_RX_PORTS   5
+#define FM_MAX_NUM_OF_10G_RX_PORTS  1
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   5
+#define FM_MAX_NUM_OF_10G_TX_PORTS  1
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OH_PORTS      7
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            8           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               12
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (160 * KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   2                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define MAX_QMI_DEQ_SUBPORTAL           12
+#define QMI_DEF_TNUMS_THRESH            48
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            31
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             32
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+/* Reassembly defines */
+#define FM_MAX_NUM_OF_REASSEMBLY_PORTS  4
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC error event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC error event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC timer event */
+    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller timer event */
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+} e_FmIntrType;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_ERR_1G_MAC4,            /**< 1G MAC 4 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC4,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_1G_MAC4_TMR,            /**< 1G MAC 4 Timer event */
+    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
+    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
+    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
+    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                               \
+    switch(mod){                                                                                    \
+        case e_FM_MOD_PRS:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS : e_FM_EV_PRS;          \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG : e_FM_EV_DUMMY_LAST;    \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR : e_FM_EV_PLCR;        \
+            break;                                                                                  \
+        case e_FM_MOD_10G_MAC:                                                                      \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_10G_MAC0 : e_FM_EV_DUMMY_LAST;\
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0 : e_FM_EV_DUMMY_LAST; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1 : e_FM_EV_DUMMY_LAST; break; \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2 : e_FM_EV_DUMMY_LAST; break; \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3 : e_FM_EV_DUMMY_LAST; break; \
+                 case(4): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC4 : e_FM_EV_DUMMY_LAST; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_TMR;       \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC_TMR:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC0_TMR; break;\
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC1_TMR; break;\
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC2_TMR; break;\
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC3_TMR; break;\
+                 case(4): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC4_TMR; break;\
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
+            else switch(id){                                                                        \
+                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
+                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
+                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
+                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
+                 }                                                                                  \
+            break;                                                                                  \
+        default: event = e_FM_EV_DUMMY_LAST;                                                        \
+        break;}
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* p4080-rev1 unique features */
+#define FM_PARTITION_ARRAY
+#define FM_PPPOE_NO_MTU_CHECK
+
+/* p4080 unique features */
+#ifdef UNDER_CONSTRUCTION_IPSEC
+#define FM_ETH_TYPE_FIX
+#define FM_DISABLE_SEC_ERRORS
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+#define FM_QMI_DEQ_OPTIONS_SUPPORT
+#define FM_NO_DISPATCH_RAM_ECC
+#define FM_FIFO_ALLOCATION_OLD_ALG
+#define FM_NO_WATCHDOG
+#define FM_NO_TNUM_AGING
+#define FM_NO_TGEC_LOOPBACK
+#define FM_KG_NO_BYPASS_FQID_GEN
+#define FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
+#define FM_NO_BACKUP_POOLS
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_NO_ADVANCED_RATE_LIMITER
+#define FM_NO_OP_OBSERVED_CGS
+
+/* FM erratas */
+#define FM_SINGLE_MDIO_ERRATA_GEN8                      /* implemented in platform */
+#define FM_HALT_SIG_ERRATA_GEN12
+
+#define FM_10G_MDIO_HOLD_ERRATA_XAUI3                   /* implemented in platform */
+#define FM_10G_PCS_ALIGNMENT_ERRATA_XAUI4               /* implemented in platform */
+
+#define FM_IEEE_BAD_TS_ERRATA_IEEE1588_A001             /* No implementation, Out of LLD scope */
+
+#define FM_FALSE_RDRP_ERRATA_10GMAC_A001                /* No implementation, Out of LLD scope */
+#define FM_RX_EXTRA_BYTES_ERRATA_10GMAC_A002            /* No implementation, Out of LLD scope */
+#define FM_TX_PAUSE_ON_ENABLE_ERRATA_10GMAC_A003        /* No implementation, Out of LLD scope */
+#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
+#define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
+#define FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+
+#define FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001                 FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_GRS_ERRATA_DTSEC_A002
+#define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
+#define FM_GTS_ERRATA_DTSEC_A004
+#define FM_PAUSE_BLOCK_ERRATA_DTSEC_A006                        /* do nothing */
+#define FM_RESERVED_ACCESS_TO_DISABLED_DEV_ERRATA_DTSEC_A0011   /* do nothing */
+#define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012       FM_GTS_ERRATA_DTSEC_A004
+
+#define FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2          /* No implementation, Out of LLD scope */
+#define FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3
+#define FM_TX_LOCKUP_ERRATA_DTSEC6
+
+#define FM_IM_TX_SYNC_SKIP_TNUM_ERRATA_FMAN_A001            /* Implemented by ucode */
+#define FM_RX_PIPELINE_OF_DATA_CORRUPTION_ERRATA_FMAN_A002  /* No implementation, Out of LLD scope */
+#define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003                /* Implemented by ucode */
+
+#define FM_1588_SRC_CLK_ERRATA_FMAN1
+#define FM_NO_RUNNING_SUM_FOR_DBG_N_SWPRS_ERRATA_FMAN2      /* No implementation, Out of LLD scope */
+#define FM_IM_TX_SHARED_TNUM_ERRATA_FMAN4                   /* Implemented by ucode */
+#define FM_IM_GS_DEADLOCK_ERRATA_FMAN5                      /* Implemented by ucode */
+#define FM_PORT_SYNC_ERRATA_FMAN6
+#define FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
+#define FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
+#define FM_IM_DEQ_PIPELINE_DEPTH_ERRATA_FMAN10              /* Implemented by ucode */
+#define FM_CC_GEN6_MISSMATCH_ERRATA_FMAN12                  /* Implemented by ucode */
+#define FM_CC_CHANGE_SHARED_TNUM_ERRATA_FMAN13              /* Implemented by ucode */
+#define FM_IM_LARGE_MRBLR_ERRATA_FMAN15                     /* Implemented by ucode */
+#define FM_RESET_ERRATA_FMAN16                              /* No implementation, Out of LLD scope */
+#define FM_IPV4_HDRLEN0_ERRATA_FMAN17                       /* No implementation, Out of LLD scope */
+#define FM_INCORRECT_CS_ERRATA_FMAN18
+#define FM_ILLEGAL_FRM_LEN_ERRATA_FMAN20                    /* No implementation, Out of LLD scope */
+#define FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
+
+#define FM_PRS_L4_SHELL_ERRATA_FMANb
+#define FM_BMI_TO_RISC_ENQ_ERRATA_FMANc
+#define FM_INVALID_SWPRS_DATA_ERRATA_FMANd                  /* No implementation, Out of LLD scope */
+//#define FM_PRS_L4_NO_CLEAR_ERRATA_FMANe                     /* No implementation, No patch yet */
+//#define FM_PRS_MPLS_ERROR_ERRATA_FMANf                      /* No implementation, No patch yet */
+#define FM_PORT_COUNTERS_ERRATA_FMANg
+#define FM_BAD_RX_FD_ERRATA_FMANh                           /* No implementation, Out of LLD scope */
+//#define FM_PRS_MPLS_SSA_ERRATA_FMANj                        /* No implementation, No patch yet */
+//#define FM_PRS_INITIAL_PLANID_ERRATA_FMANk                  /* No implementation, No patch yet */
+
+
+#define FM_OP_PARTITION_ERRATA_FMANx8
+#define FM_PORT_DISABLED_ERRATA_FMANx9
+#define FM_TX_PORT_IM_OR_ERRATA_FMANx11                     /* Implemented by ucode */
+#define FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+#define FM_PORT_OTF_CHANGES_ERRATA_FMANx12                  FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
+#define FM_SOFT_RESET_ERRATA_FMANx15                        /* No implementation, Out of LLD scope */
+
+#define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
+
+#define FM_PRS_MEM_ERRATA_FMAN_SW003
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+#define FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
+
+#ifdef UNDER_CONSTRUCTION_IPSEC
+#define FM_NO_COPY_CTXA_CTXB_ERRATA_FMAN_SW001
+#endif /* UNDER_CONSTRUCTION_IPSEC */
+
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
new file mode 100644
index 0000000..21d07df
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
@@ -0,0 +1,83 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+
+#if !(defined(MPC8306) || \
+      defined(MPC8309) || \
+      defined(MPC834x) || \
+      defined(MPC836x) || \
+      defined(MPC832x) || \
+      defined(MPC837x) || \
+      defined(MPC8568) || \
+      defined(MPC8569) || \
+      defined(P1020)   || \
+      defined(P1021)   || \
+      defined(P1022)   || \
+      defined(P1023)   || \
+      defined(P2020)   || \
+      defined(P2040)   || \
+      defined(P3041)   || \
+      defined(P4080)   || \
+      defined(SC4080)  || \
+      defined(P5020)   || \
+      defined(MSC814x))
+#error "unable to proceed without chip-definition"
+#endif /* !(defined(MPC834x) || ... */
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
new file mode 100644
index 0000000..a265f35
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
@@ -0,0 +1,331 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   P3040/P4080/P5020 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         P3040/P4080/P5020_chip_id P5020 Application Programming Interface
+
+ @Description   P3040/P4080/P5020 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E500MC
+
+#define INTG_MAX_NUM_OF_CORES   1
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_LBC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM1,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM1_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM1_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM1_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx4,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx4,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM1_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM1_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM1_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM1_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM1_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM1_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM1_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM1_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM1_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_FM2,                /**< Frame manager #2 module */
+    e_MODULE_ID_FM2_RTC,            /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM2_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM2_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM2_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM2_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM2_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM2_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM2_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM2_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM2_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM2_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_MPIC,               /**< MPIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,     	/**< RapidIO controller */
+    e_MODULE_ID_SRIO_MU,        	/**< RapidIO messaging unit module */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_CHIP             0x00040000
+#define MODULE_PLTFRM           0x00050000
+#define MODULE_PM               0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_PIC              0x00080000
+#define MODULE_CPC              0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_LAW              0x00100000
+#define MODULE_LBC              0x00110000
+#define MODULE_PAMU             0x00120000
+#define MODULE_FM               0x00130000
+#define MODULE_FM_MURAM         0x00140000
+#define MODULE_FM_PCD           0x00150000
+#define MODULE_FM_RTC           0x00160000
+#define MODULE_FM_MAC           0x00170000
+#define MODULE_FM_PORT          0x00180000
+#define MODULE_DPA              0x00190000
+#define MODULE_SRIO             0x00200000
+#define MODULE_DMA              0x00100000
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  5
+
+#define PAMU_PICS_AVICS_ERRATA_PAMU3
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_NUM_OF_WINDOWS      32
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4KB */
+#define LAW_MAX_WINDOW_SIZE     0x0000002000000000LL    /**< 64GB */
+
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_ATOMIC_WRITE    0x00800000  /**< Atomic write error */
+#define LBC_ERR_ATOMIC_READ     0x00400000  /**< Atomic read error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_ATOMIC_WRITE | \
+                                 LBC_ERR_ATOMIC_READ | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL
+#define LBC_ATOMIC_OPERATION_SUPPORT
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_NUM_OF_PORTS   1   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 i/O pins. */
+
+#define GPIO_VALID_PIN_MASKS  \
+    { /* Port A */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS \
+    { /* Port A */ 0xFFFFFFFF }
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/math_ext.h b/drivers/net/dpa/NetCommSw/inc/math_ext.h
new file mode 100644
index 0000000..95b9560
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/math_ext.h
@@ -0,0 +1,98 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MATH_EXT_H
+#define __MATH_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/math.h>
+
+#elif defined(__MWERKS__)
+#define LOW(x) ( sizeof(x)==8 ? *(1+(int32_t*)&x) : (*(int32_t*)&x))
+#define HIGH(x) (*(int32_t*)&x)
+#define ULOW(x) ( sizeof(x)==8 ? *(1+(uint32_t*)&x) : (*(uint32_t*)&x))
+#define UHIGH(x) (*(uint32_t*)&x)
+
+static const double big = 1.0e300;
+
+/* Macro for checking if a number is a power of 2 */
+static __inline__ double ceil(double x)
+{
+    int32_t i0,i1,j0; /*- cc 020130 -*/
+    uint32_t i,j; /*- cc 020130 -*/
+    i0 =  HIGH(x);
+    i1 =  LOW(x);
+    j0 = ((i0>>20)&0x7ff)-0x3ff;
+    if(j0<20) {
+        if(j0<0) {     /* raise inexact if x != 0 */
+        if(big+x>0.0) {/* return 0*sign(x) if |x|<1 */
+            if(i0<0) {i0=0x80000000;i1=0;}
+            else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
+        }
+        } else {
+        i = (uint32_t)(0x000fffff)>>j0;
+        if(((i0&i)|i1)==0) return x; /* x is integral */
+        if(big+x>0.0) {    /* raise inexact flag */
+            if(i0>0) i0 += (0x00100000)>>j0;
+            i0 &= (~i); i1=0;
+        }
+        }
+    } else if (j0>51) {
+        if(j0==0x400) return x+x;    /* inf or NaN */
+        else return x;        /* x is integral */
+    } else {
+        i = ((uint32_t)(0xffffffff))>>(j0-20); /*- cc 020130 -*/
+        if((i1&i)==0) return x;    /* x is integral */
+        if(big+x>0.0) {         /* raise inexact flag */
+        if(i0>0) {
+            if(j0==20) i0+=1;
+            else {
+            j = (uint32_t)(i1 + (1<<(52-j0)));
+            if(j<i1) i0+=1;    /* got a carry */
+            i1 = (int32_t)j;
+            }
+        }
+        i1 &= (~i);
+        }
+    }
+    HIGH(x) = i0;
+    LOW(x) = i1;
+    return x;
+}
+
+#else
+#include <math.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __MATH_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
new file mode 100644
index 0000000..ccb84f5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -0,0 +1,413 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          ncsw_ext.h
+
+ @Description   General NetCommSw Standard Definitions
+*//***************************************************************************/
+
+#ifndef __NCSW_EXT_H
+#define __NCSW_EXT_H
+
+#include "memcpy_ext.h"
+
+
+#define WRITE_BLOCK                 IOMemSet32
+#define COPY_BLOCK                  Mem2IOCpy32
+
+#define PTR_TO_UINT(_ptr)           ((uintptr_t)(_ptr))
+#define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
+
+#define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
+
+
+#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+
+/* Little-Endian access macros */
+
+#define WRITE_UINT16_LE(arg, data) \
+        WRITE_UINT16((arg), SwapUint16(data))
+
+#define WRITE_UINT32_LE(arg, data) \
+        WRITE_UINT32((arg), SwapUint32(data))
+
+#define WRITE_UINT64_LE(arg, data) \
+        WRITE_UINT64((arg), SwapUint64(data))
+
+#define GET_UINT16_LE(arg) \
+        SwapUint16(GET_UINT16(arg))
+
+#define GET_UINT32_LE(arg) \
+        SwapUint32(GET_UINT32(arg))
+
+#define GET_UINT64_LE(arg) \
+        SwapUint64(GET_UINT64(arg))
+
+/* Write and Read again macros */
+#define WRITE_UINT_SYNC(size, arg, data)    \
+    do {                                    \
+        WRITE_UINT##size((arg), (data));    \
+        CORE_MemoryBarrier();               \
+    } while (0)
+
+#define WRITE_UINT8_SYNC(arg, data)     WRITE_UINT_SYNC(8, (arg), (data))
+
+#define WRITE_UINT16_SYNC(arg, data)    WRITE_UINT_SYNC(16, (arg), (data))
+#define WRITE_UINT32_SYNC(arg, data)    WRITE_UINT_SYNC(32, (arg), (data))
+
+#define MAKE_UINT64(high32, low32)      (((uint64_t)high32 << 32) | (low32))
+
+
+/*----------------------*/
+/* Miscellaneous macros */
+/*----------------------*/
+
+#define UNUSED(X) (X=X)
+
+#define KILOBYTE            0x400                   /* 1024 */
+#define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
+#define GIGABYTE            (KILOBYTE * MEGABYTE)   /* 1024*1024*1024 */
+
+#undef  NO_IRQ
+#define NO_IRQ              (-1)
+#define NCSW_MASTER_ID      (0)
+
+/* Macro for checking if a number is a power of 2 */
+#define POWER_OF_2(n)   (!((n) & ((n)-1)))
+
+/* Macro for calculating log of base 2 */
+#define LOG2(num, log2Num)      \
+    do                          \
+    {                           \
+        uint64_t tmp = (num);   \
+        log2Num = 0;            \
+        while (tmp > 1)         \
+        {                       \
+            log2Num++;          \
+            tmp >>= 1;          \
+        }                       \
+    } while (0)
+
+/* Ceiling division - not the fastest way, but safer in terms of overflow */
+#define DIV_CEIL(x,y)   ((uint32_t)((x)/(y)) + (((((uint32_t)((x)/(y)))*(y)) == (x)) ? 0 : 1))
+
+/* Round up a number to be a multiple of a second number */
+#define ROUND_UP(x,y)   ((((x) + (y) - 1) / (y)) * (y))
+
+/* Timing macro for converting usec units to number of ticks.   */
+/* (number of usec *  clock_Hz) / 1,000,000) - since            */
+/* clk is in MHz units, no division needed.                     */
+#define USEC_TO_CLK(usec,clk)       ((usec) * (clk))
+#define CYCLES_TO_USEC(cycles,clk)  ((cycles) / (clk))
+
+/* Timing macros for converting between nsec units and number of clocks. */
+#define NSEC_TO_CLK(nsec,clk)       DIV_CEIL(((nsec) * (clk)), 1000)
+#define CYCLES_TO_NSEC(cycles,clk)  (((cycles) * 1000) / (clk))
+
+/* Timing macros for converting between psec units and number of clocks. */
+#define PSEC_TO_CLK(psec,clk)       DIV_CEIL(((psec) * (clk)), 1000000)
+#define CYCLES_TO_PSEC(cycles,clk)  (((cycles) * 1000000) / (clk))
+
+/* Min, Max macros */
+#define MIN(a,b)    ((a) < (b) ? (a) : (b))
+#define MAX(a,b)    ((a) > (b) ? (a) : (b))
+#define IN_RANGE(min,val,max) ((min)<=(val) && (val)<=(max))
+
+#define ABS(a)  ((a<0)?(a*-1):a)
+
+#if !(defined(ARRAY_SIZE))
+#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]))
+#endif /* !defined(ARRAY_SIZE) */
+
+
+/* possible alignments */
+#define HALF_WORD_ALIGNMENT     2
+#define WORD_ALIGNMENT          4
+#define DOUBLE_WORD_ALIGNMENT   8
+#define BURST_ALIGNMENT         32
+
+#define HALF_WORD_ALIGNED       0x00000001
+#define WORD_ALIGNED            0x00000003
+#define DOUBLE_WORD_ALIGNED     0x00000007
+#define BURST_ALIGNED           0x0000001f
+#ifndef IS_ALIGNED
+#define IS_ALIGNED(n,align)     (!((uint32_t)(n) & (align - 1)))
+#endif /* IS_ALIGNED */
+
+
+#define LAST_BUF        1
+#define FIRST_BUF       2
+#define SINGLE_BUF      (LAST_BUF | FIRST_BUF)
+#define MIDDLE_BUF      4
+
+#define ARRAY_END       -1
+
+#define ILLEGAL_BASE    (~0)
+
+#define BUF_POSITION(first, last)   state[(!!(last))<<1 | !!(first)]
+#define DECLARE_POSITION static uint8_t state[4] = { (uint8_t)MIDDLE_BUF, (uint8_t)FIRST_BUF, (uint8_t)LAST_BUF, (uint8_t)SINGLE_BUF };
+
+
+/**************************************************************************//**
+ @Description   Timers operation mode
+*//***************************************************************************/
+typedef enum e_TimerMode
+{
+    e_TIMER_MODE_INVALID = 0,
+    e_TIMER_MODE_FREE_RUN,    /**< Free run - counter continues to increase
+                                   after reaching the reference value. */
+    e_TIMER_MODE_PERIODIC,    /**< Periodic - counter restarts counting from 0
+                                   after reaching the reference value. */
+    e_TIMER_MODE_SINGLE       /**< Single (one-shot) - counter stops counting
+                                   after reaching the reference value. */
+} e_TimerMode;
+
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum e_CommMode
+{
+    e_COMM_MODE_NONE        = 0,    /**< No transmit/receive communication */
+    e_COMM_MODE_RX          = 1,    /**< Only receive communication */
+    e_COMM_MODE_TX          = 2,    /**< Only transmit communication */
+    e_COMM_MODE_RX_AND_TX   = 3     /**< Both transmit and receive communication */
+} e_CommMode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum e_DiagMode
+{
+    e_DIAG_MODE_NONE = 0,       /**< Normal operation; no diagnostic mode */
+    e_DIAG_MODE_CTRL_LOOPBACK,  /**< Loopback in the controller */
+    e_DIAG_MODE_CHIP_LOOPBACK,  /**< Loopback in the chip but not in the
+                                     controller; e.g. IO-pins, SerDes, etc. */
+    e_DIAG_MODE_PHY_LOOPBACK,   /**< Loopback in the external PHY */
+    e_DIAG_MODE_EXT_LOOPBACK,   /**< Loopback in the external line (beyond the PHY) */
+    e_DIAG_MODE_CTRL_ECHO,      /**< Echo incoming data by the controller */
+    e_DIAG_MODE_PHY_ECHO        /**< Echo incoming data by the PHY */
+} e_DiagMode;
+
+/**************************************************************************//**
+ @Description   Possible RxStore callback responses.
+*//***************************************************************************/
+typedef enum e_RxStoreResponse
+{
+      e_RX_STORE_RESPONSE_PAUSE     /**< Pause invoking callback with received data;
+                                         in polling mode, start again invoking callback
+                                         only next time user invokes the receive routine;
+                                         in interrupt mode, start again invoking callback
+                                         only next time a receive event triggers an interrupt;
+                                         in all cases, received data that are pending are not
+                                         lost, rather, their processing is temporarily deferred;
+                                         in all cases, received data are processed in the order
+                                         in which they were received. */
+    , e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
+} e_RxStoreResponse;
+
+
+/**************************************************************************//**
+ @Description   General Handle
+*//***************************************************************************/
+typedef void *      t_Handle;   /**< handle, used as object's descriptor */
+
+/**************************************************************************//**
+ @Description   MUTEX type
+*//***************************************************************************/
+typedef uint32_t    t_Mutex;
+
+/**************************************************************************//**
+ @Description   Error Code.
+
+                The high word of the error code is the code of the software
+                module (driver). The low word is the error type (e_ErrorType).
+                To get the values from the error code, use GET_ERROR_TYPE()
+                and GET_ERROR_MODULE().
+*//***************************************************************************/
+typedef uint32_t    t_Error;
+
+/**************************************************************************//**
+ @Description   General prototype of interrupt service routine (ISR).
+
+ @Param[in]     handle - Optional handle of the module handling the interrupt.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void (t_Isr)(t_Handle handle);
+
+/**************************************************************************//**
+ @Anchor        mem_attr
+
+ @Collection    Memory Attributes
+
+                Various attributes of memory partitions. These values may be
+                or'ed together to create a mask of all memory attributes.
+ @{
+*//***************************************************************************/
+#define MEMORY_ATTR_CACHEABLE           0x00000001
+                                        /**< Memory is cacheable */
+#define MEMORY_ATTR_QE_2ND_BUS_ACCESS   0x00000002
+                                        /**< Memory can be accessed by QUICC Engine
+                                             through its secondary bus interface */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Function      t_GetBufFunction
+
+ @Description   User callback function called by driver to get data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool        - A handle to buffer pool manager
+ @Param[out]    p_BufContextHandle  - Returns the user's private context that
+                                      should be associated with the buffer
+
+ @Return        Pointer to data buffer, NULL if error
+ *//***************************************************************************/
+typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
+                                     t_Handle   *p_BufContextHandle);
+
+/**************************************************************************//**
+ @Function      t_PutBufFunction
+
+ @Description   User callback function called by driver to return data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool    - A handle to buffer pool manager
+ @Param[in]     p_Buffer        - A pointer to buffer to return
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the returned buffer
+
+ @Return        E_OK on success; Error code otherwise
+ *//***************************************************************************/
+typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
+                                   uint8_t  *p_Buffer,
+                                   t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Function      t_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+typedef void * t_PhysToVirt(physAddress_t addr);
+
+/**************************************************************************//**
+ @Function      t_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+typedef physAddress_t t_VirtToPhys(void *addr);
+
+/**************************************************************************//**
+ @Description   Buffer Pool Information Structure.
+*//***************************************************************************/
+typedef struct t_BufferPoolInfo
+{
+    t_Handle            h_BufferPool;   /**< A handle to the buffer pool manager */
+    t_GetBufFunction    *f_GetBuf;      /**< User callback to get a free buffer */
+    t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
+    uint16_t            bufferSize;     /**< Buffer size (in bytes) */
+
+    t_PhysToVirt        *f_PhysToVirt;  /**< User callback to translate pool buffers
+                                             physical addresses to virtual addresses  */
+    t_VirtToPhys        *f_VirtToPhys;  /**< User callback to translate pool buffers
+                                             virtual addresses to physical addresses */
+} t_BufferPoolInfo;
+
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Transmit queue ID
+ @Param[in]     p_Data          - Pointer to the data buffer
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     status          - Transmit status and errors
+ @Param[in]     flags           - Driver-dependent information
+ *//***************************************************************************/
+typedef void (t_TxConfFunction)(t_Handle    h_App,
+                                uint32_t    queueId,
+                                uint8_t     *p_Data,
+                                t_Handle    h_BufContext,
+                                uint16_t    status,
+                                uint32_t    flags);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with receive data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Receive queue ID
+ @Param[in]     p_Data          - Pointer to the buffer with received data
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     length          - Length of received data
+ @Param[in]     status          - Receive status and errors
+ @Param[in]     position        - Position of buffer in frame
+ @Param[in]     flags           - Driver-dependent information
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+ *//***************************************************************************/
+typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
+                                              uint32_t  queueId,
+                                              uint8_t   *p_Data,
+                                              t_Handle  h_BufContext,
+                                              uint32_t  length,
+                                              uint16_t  status,
+                                              uint8_t   position,
+                                              uint32_t  flags);
+
+
+#endif /* __NCSW_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
new file mode 100644
index 0000000..2db5b86
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -0,0 +1,391 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ext.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_EXT_H
+#define __NET_EXT_H
+
+#include "std_ext.h"
+
+
+typedef uint8_t headerFieldPpp_t;
+
+#define NET_HEADER_FIELD_PPP_PID                        (1)
+#define NET_HEADER_FIELD_PPP_COMPRESSED                 (NET_HEADER_FIELD_PPP_PID << 1)
+#define NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t headerFieldPppoe_t;
+
+#define NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define NET_HEADER_FIELD_PPPoE_TYPE                     (NET_HEADER_FIELD_PPPoE_VER << 1)
+#define NET_HEADER_FIELD_PPPoE_CODE                     (NET_HEADER_FIELD_PPPoE_VER << 2)
+#define NET_HEADER_FIELD_PPPoE_SID                      (NET_HEADER_FIELD_PPPoE_VER << 3)
+#define NET_HEADER_FIELD_PPPoE_LEN                      (NET_HEADER_FIELD_PPPoE_VER << 4)
+#define NET_HEADER_FIELD_PPPoE_SESSION                  (NET_HEADER_FIELD_PPPoE_VER << 5)
+#define NET_HEADER_FIELD_PPPoE_PID                      (NET_HEADER_FIELD_PPPoE_VER << 6)
+#define NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define NET_HEADER_FIELD_PPPMUX_CKSUM                   (NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define NET_HEADER_FIELD_PPPMUX_COMPRESSED              (NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t headerFieldEth_t;
+
+#define NET_HEADER_FIELD_ETH_DA                         (1)
+#define NET_HEADER_FIELD_ETH_SA                         (NET_HEADER_FIELD_ETH_DA << 1)
+#define NET_HEADER_FIELD_ETH_LENGTH                     (NET_HEADER_FIELD_ETH_DA << 2)
+#define NET_HEADER_FIELD_ETH_TYPE                       (NET_HEADER_FIELD_ETH_DA << 3)
+#define NET_HEADER_FIELD_ETH_FINAL_CKSUM                (NET_HEADER_FIELD_ETH_DA << 4)
+#define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
+#define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t headerFieldIpv4_t;
+
+#define NET_HEADER_FIELD_IPv4_VER                       (1)
+#define NET_HEADER_FIELD_IPv4_HDR_LEN                   (NET_HEADER_FIELD_IPv4_VER << 1)
+#define NET_HEADER_FIELD_IPv4_TOS                       (NET_HEADER_FIELD_IPv4_VER << 2)
+#define NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (NET_HEADER_FIELD_IPv4_VER << 3)
+#define NET_HEADER_FIELD_IPv4_ID                        (NET_HEADER_FIELD_IPv4_VER << 4)
+#define NET_HEADER_FIELD_IPv4_FLAG_D                    (NET_HEADER_FIELD_IPv4_VER << 5)
+#define NET_HEADER_FIELD_IPv4_FLAG_M                    (NET_HEADER_FIELD_IPv4_VER << 6)
+#define NET_HEADER_FIELD_IPv4_OFFSET                    (NET_HEADER_FIELD_IPv4_VER << 7)
+#define NET_HEADER_FIELD_IPv4_TTL                       (NET_HEADER_FIELD_IPv4_VER << 8)
+#define NET_HEADER_FIELD_IPv4_PROTO                     (NET_HEADER_FIELD_IPv4_VER << 9)
+#define NET_HEADER_FIELD_IPv4_CKSUM                     (NET_HEADER_FIELD_IPv4_VER << 10)
+#define NET_HEADER_FIELD_IPv4_SRC_IP                    (NET_HEADER_FIELD_IPv4_VER << 11)
+#define NET_HEADER_FIELD_IPv4_DST_IP                    (NET_HEADER_FIELD_IPv4_VER << 12)
+#define NET_HEADER_FIELD_IPv4_OPTS                      (NET_HEADER_FIELD_IPv4_VER << 13)
+#define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
+#define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t headerFieldIpv6_t;
+
+#define NET_HEADER_FIELD_IPv6_VER                       (1)
+#define NET_HEADER_FIELD_IPv6_TC                        (NET_HEADER_FIELD_IPv6_VER << 1)
+#define NET_HEADER_FIELD_IPv6_SRC_IP                    (NET_HEADER_FIELD_IPv6_VER << 2)
+#define NET_HEADER_FIELD_IPv6_DST_IP                    (NET_HEADER_FIELD_IPv6_VER << 3)
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR                  (NET_HEADER_FIELD_IPv6_VER << 4)
+#define NET_HEADER_FIELD_IPv6_FL                        (NET_HEADER_FIELD_IPv6_VER << 5)
+#define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
+#define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define NET_HEADER_FIELD_ICMP_ID                        (NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define NET_HEADER_FIELD_IGMP_DATA                      (NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t headerFieldTcp_t;
+
+#define NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_TCP_PORT_DST                   (NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_TCP_SEQ                        (NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_TCP_ACK                        (NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_TCP_OFFSET                     (NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_TCP_FLAGS                      (NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_TCP_WINDOW                     (NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define NET_HEADER_FIELD_TCP_CKSUM                      (NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define NET_HEADER_FIELD_TCP_URGPTR                     (NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define NET_HEADER_FIELD_TCP_OPTS                       (NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t headerFieldSctp_t;
+
+#define NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_SCTP_PORT_DST                  (NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_SCTP_VER_TAG                   (NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t headerFieldDccp_t;
+
+#define NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t headerFieldUdp_t;
+
+#define NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_UDP_PORT_DST                   (NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LEN                        (NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+typedef uint8_t headerFieldUdpEncapEsp_t;
+
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define NET_HEADER_FIELD_IPHC_CID                       (1)
+#define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
+#define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
+#define NET_HEADER_FIELD_IPHC_GEN                       (NET_HEADER_FIELD_IPHC_CID << 3)
+#define NET_HEADER_FIELD_IPHC_D_BIT                     (NET_HEADER_FIELD_IPHC_CID << 4)
+#define NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv2_VERSION                 (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv2_LEN                     (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv2_SESSION_ID              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv2_NS                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define NET_HEADER_FIELD_L2TPv2_NR                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ID                 (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t headerFieldVlan_t;
+
+#define NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define NET_HEADER_FIELD_VLAN_CFI                       (NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI | \
+                                                         NET_HEADER_FIELD_VLAN_CFI | \
+                                                         NET_HEADER_FIELD_VLAN_VID)
+
+
+typedef uint8_t headerFieldLlc_t;
+
+#define NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define NET_HEADER_FIELD_LLC_SSAP                       (NET_HEADER_FIELD_LLC_DSAP << 1)
+#define NET_HEADER_FIELD_LLC_CTRL                       (NET_HEADER_FIELD_LLC_DSAP << 2)
+#define NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t headerFieldSnap_t;
+
+#define NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define NET_HEADER_FIELD_SNAP_PID                       (NET_HEADER_FIELD_SNAP_OUI << 1)
+#define NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t headerFieldLlcSnap_t;
+
+#define NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define NET_HEADER_FIELD_ARP_PTYPE                      (NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define NET_HEADER_FIELD_ARP_HLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define NET_HEADER_FIELD_ARP_PLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define NET_HEADER_FIELD_ARP_OPER                       (NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define NET_HEADER_FIELD_ARP_SHA                        (NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define NET_HEADER_FIELD_ARP_SPA                        (NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define NET_HEADER_FIELD_ARP_THA                        (NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define NET_HEADER_FIELD_ARP_TPA                        (NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define NET_HEADER_FIELD_RFC2684_NLPID                  (NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define NET_HEADER_FIELD_RFC2684_OUI                    (NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define NET_HEADER_FIELD_RFC2684_PID                    (NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define NET_HEADER_FIELD_RFC2684_VPN_OUI                (NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define NET_HEADER_FIELD_RFC2684_VPN_IDX                (NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define NET_HEADER_FIELD_USER_DEFINED_PCDID             (NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define NET_HEADER_FIELD_PAYLOAD_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define NET_HEADER_FIELD_MAX_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define NET_HEADER_FIELD_MIN_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define NET_HEADER_FIELD_PAYLOAD_TYPE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define NET_HEADER_FIELD_FRAME_SIZE                     (NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t headerFieldGre_t;
+
+#define NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t headerFieldMinencap_t;
+
+#define NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define NET_HEADER_FIELD_MINENCAP_DST_IP                (NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define NET_HEADER_FIELD_MINENCAP_TYPE                  (NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t headerFieldIpsecAh_t;
+
+#define NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define NET_HEADER_FIELD_IPSEC_AH_NH                    (NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t headerFieldIpsecEsp_t;
+
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+
+typedef uint8_t headerFieldMpls_t;
+
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t headerFieldMacsec_t;
+
+#define NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+
+typedef enum {
+    HEADER_TYPE_NONE = 0,
+    HEADER_TYPE_PAYLOAD,
+    HEADER_TYPE_ETH,
+    HEADER_TYPE_VLAN,
+    HEADER_TYPE_IPv4,
+    HEADER_TYPE_IPv6,
+#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
+    HEADER_TYPE_IPv4_AND_IPv6,
+#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
+    HEADER_TYPE_TCP,
+    HEADER_TYPE_UDP,
+    HEADER_TYPE_IPHC,
+    HEADER_TYPE_SCTP,
+    HEADER_TYPE_SCTP_CHUNK_DATA,
+    HEADER_TYPE_PPPoE,
+    HEADER_TYPE_PPP,
+    HEADER_TYPE_PPPMUX,
+    HEADER_TYPE_PPPMUX_SUBFRAME,
+    HEADER_TYPE_L2TPv2,
+    HEADER_TYPE_L2TPv3_CTRL,
+    HEADER_TYPE_L2TPv3_SESS,
+    HEADER_TYPE_LLC,
+    HEADER_TYPE_LLC_SNAP,
+    HEADER_TYPE_NLPID,
+    HEADER_TYPE_SNAP,
+    HEADER_TYPE_MPLS,
+    HEADER_TYPE_IPSEC_AH,
+    HEADER_TYPE_IPSEC_ESP,
+    HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+    HEADER_TYPE_MACSEC,
+    HEADER_TYPE_GRE,
+    HEADER_TYPE_MINENCAP,
+    HEADER_TYPE_DCCP,
+    HEADER_TYPE_ICMP,
+    HEADER_TYPE_IGMP,
+    HEADER_TYPE_ARP,
+    HEADER_TYPE_CAPWAP,
+    HEADER_TYPE_CAPWAP_DTLS,
+    HEADER_TYPE_RFC2684,
+    HEADER_TYPE_USER_DEFINED_L2,
+    HEADER_TYPE_USER_DEFINED_L3,
+    HEADER_TYPE_USER_DEFINED_L4,
+    HEADER_TYPE_USER_DEFINED_SHIM1,
+    HEADER_TYPE_USER_DEFINED_SHIM2,
+    MAX_HEADER_TYPE_COUNT
+} e_NetHeaderType;
+
+
+#endif /* __NET_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/std_ext.h b/drivers/net/dpa/NetCommSw/inc/std_ext.h
new file mode 100644
index 0000000..4d2ba44
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/std_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          std_ext.h
+
+ @Description   General Standard Definitions
+*//***************************************************************************/
+
+#ifndef __STD_EXT_H
+#define __STD_EXT_H
+
+
+#include "types_ext.h"
+#include "ncsw_ext.h"
+
+
+#endif /* __STD_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
new file mode 100644
index 0000000..e2b2191
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STDARG_EXT_H
+#define __STDARG_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <stdarg.h>
+
+#else
+#include <stdarg.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDARG_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
new file mode 100644
index 0000000..f8dbaea
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
@@ -0,0 +1,161 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __STDLIB_EXT_H
+#define __STDLIB_EXT_H
+
+
+#if (defined(NCSW_LINUX)) && defined(__KERNEL__)
+#include "stdarg_ext.h"
+#include "std_ext.h"
+
+
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoll - convert a string to a int64 long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base);
+
+/**
+ * atoi - convert a character to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s);
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count);
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s);
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct);
+
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count);
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src);
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:    input buffer
+ * @fmt:    format of buffer
+ * @args:    arguments
+ */
+int vsscanf(const char * buf, const char * fmt, va_list args);
+
+/**
+ * vsnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want snprintf instead.
+ */
+int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args);
+
+#else
+#include <stdlib.h>
+#include <stdio.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDLIB_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/string_ext.h b/drivers/net/dpa/NetCommSw/inc/string_ext.h
new file mode 100644
index 0000000..f598c92
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/string_ext.h
@@ -0,0 +1,55 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STRING_EXT_H
+#define __STRING_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+#include <linux/string.h>
+extern char * strtok ( char * str, const char * delimiters );
+
+#elif defined(__KERNEL__)
+#include "linux/types.h"
+#include "linux/posix_types.h"
+#include "linux/string.h"
+
+#else
+#include <string.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STRING_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/types_ext.h b/drivers/net/dpa/NetCommSw/inc/types_ext.h
new file mode 100644
index 0000000..2ee73e3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/types_ext.h
@@ -0,0 +1,111 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          types_ext.h
+
+ @Description   General types Standard Definitions
+*//***************************************************************************/
+
+#ifndef __TYPES_EXT_H
+#define __TYPES_EXT_H
+
+
+#if defined(NCSW_LINUX)
+#include "types_linux.h"
+
+#elif defined (NCSW_LINUX_USD)
+#include "types_linux_usd.h"
+
+#elif defined (NCSW_VXWORKS)
+#include "types_vxworks.h"
+
+#elif defined (__MWERKS__) && defined (__GNUC__) && defined (__cplusplus)
+#include "types_bb_gpp.h"
+
+#elif defined (__MWERKS__) && defined (__GNUC__)
+#include "types_bb_gcc.h"
+
+#elif defined(__ghs__)
+#include "types_ghs.h"
+
+#else
+#include "types_dflt.h"
+#endif /* defined (__ROCOO__) */
+
+
+static __inline__ void TypesChecker(void)
+{
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+#define MEM_MAP_START
+     _Packed struct strct {
+        __volatile__ int vi;
+    } _PackedType;
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+    size_t          size = 0;
+    bool            tr = TRUE, fls = FALSE;
+    struct strct    *p_Strct = NULL;
+    physAddress_t   addr = 0x100;
+
+    tr      = fls;
+    p_Strct = p_Strct;
+    size++;
+    if (tr) size++;
+
+    WRITE_UINT8(*((uint8_t*)((size_t)(addr))),
+                 GET_UINT8(*((uint8_t*)((size_t)(addr)))));
+
+    WRITE_UINT8(*((uint8_t*)((size_t)(UINT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(UINT8_MAX)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(UINT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(UINT16_MAX)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(UINT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(UINT32_MAX)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(UINT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(UINT64_MAX)))));
+    WRITE_UINT8(*((uint8_t*)((size_t)(INT8_MAX))),
+                 GET_UINT8(*((uint8_t*)((size_t)(INT8_MIN)))));
+    WRITE_UINT16(*((uint16_t*)((size_t)(INT16_MAX))),
+                 GET_UINT16(*((uint16_t*)((size_t)(INT16_MIN)))));
+    WRITE_UINT32(*((uint32_t*)((size_t)(INT32_MAX))),
+                 GET_UINT32(*((uint32_t*)((size_t)(INT32_MIN)))));
+    WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
+                 GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
+}
+
+
+#endif /* __TYPES_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
new file mode 100644
index 0000000..ec92e2a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
@@ -0,0 +1,880 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_ext.h
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+*//***************************************************************************/
+
+#ifndef __XX_EXT_H
+#define __XX_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+#if defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)
+#include "xx_integration_ext.h"
+#endif /* defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED) */
+
+
+/**************************************************************************//**
+ @Group         xx_id  XX Interface (System call hooks)
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+
+ @{
+*//***************************************************************************/
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+/**************************************************************************//**
+ @Function      XX_EventById
+
+ @Description   Event reporting routine - executed only when REPORT_EVENTS=1.
+
+ @Param[in]     event - Event code (e_Event).
+ @Param[in]     appId - Application identifier.
+ @Param[in]     flags - Event flags.
+ @Param[in]     msg   - Event message.
+
+ @Return        None
+*//***************************************************************************/
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg);
+
+#else  /* not REPORT_EVENTS */
+#define XX_EventById(event, appId, flags, msg)
+#endif /* REPORT_EVENTS */
+
+
+
+#ifdef DEBUG_XX_MALLOC
+void * XX_MallocDebug(uint32_t size, char *fname, int line);
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t alignment,
+                           char     *fname,
+                           int      line);
+
+#define XX_Malloc(sz) \
+    XX_MallocDebug((sz), __FILE__, __LINE__)
+
+#define XX_MallocSmart(sz, memt, al) \
+    XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
+
+#else /* not DEBUG_XX_MALLOC */
+/**************************************************************************//**
+ @Function      XX_Malloc
+
+ @Description   allocates contiguous block of memory.
+
+ @Param[in]     size - Number of bytes to allocate.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_Malloc(uint32_t size);
+
+/**************************************************************************//**
+ @Function      XX_MallocSmart
+
+ @Description   Allocates contiguous block of memory in a specified
+                alignment and from the specified segment.
+
+ @Param[in]     size            - Number of bytes to allocate.
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+ @Param[in]     alignment       - Required memory alignment (in bytes).
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
+#endif /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_FreeSmart
+
+ @Description   Frees the memory block pointed to by "p".
+                Only for memory allocated by XX_MallocSmart
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSmart(void *p_Memory);
+
+/**************************************************************************//**
+ @Function      XX_Free
+
+ @Description   frees the memory block pointed to by "p".
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Free(void *p_Memory);
+
+
+/**************************************************************************//**
+ @Function      XX_GetMemPartitionBase
+
+ @Description   This routine gets the address of a memory segment according to
+                the memory type.
+
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+
+ @Return        The address of the required memory type.
+*//***************************************************************************/
+void * XX_GetMemPartitionBase(int memPartitionId);
+
+/**************************************************************************//**
+ @Function      XX_Print
+
+ @Description   print a string.
+
+ @Param[in]     str - string to print.
+
+ @Return        None.
+*//***************************************************************************/
+void    XX_Print(char *str, ...);
+
+/**************************************************************************//**
+ @Function      XX_GetChar
+
+ @Description   Get character from console.
+
+ @Return        Character is returned on success. Zero is returned otherwise.
+*//***************************************************************************/
+char    XX_GetChar(void);
+
+/**************************************************************************//**
+ @Function      XX_SetIntr
+
+ @Description   Set an interupt service routine for a specific interrupt source.
+
+ @Param[in]     irq     - Interrupt ID (system-specific number).
+ @Param[in]     f_Isr   - Callback routine that will be called when the interupt occurs.
+ @Param[in]     handle  - The argument for the user callback routine.
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle);
+
+/**************************************************************************//**
+ @Function      XX_FreeIntr
+
+ @Description   Free a specific interrupt and a specific callback routine.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_FreeIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_EnableIntr
+
+ @Description   Enable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_EnableIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_DisableIntr
+
+ @Description   Disable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_DisableIntr(int irq);
+
+#if !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED))
+/**************************************************************************//**
+ @Function      XX_DisableAllIntr
+
+ @Description   Disable all interrupts by masking them at the CPU.
+
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_RestoreAllIntr() call.
+*//***************************************************************************/
+uint32_t XX_DisableAllIntr(void);
+
+/**************************************************************************//**
+ @Function      XX_RestoreAllIntr
+
+ @Description   Restore previous state of interrupts level at the CPU.
+
+ @Param[in]     flags - A value that represents the interrupts state to restore,
+                        as returned by the matching call for XX_DisableAllIntr().
+
+ @Return        None.
+*//***************************************************************************/
+void XX_RestoreAllIntr(uint32_t flags);
+#endif /* !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)) */
+
+/**************************************************************************//**
+ @Function      XX_Call
+
+ @Description   Call a service in another task.
+
+                Activate the routine "f" via the queue identified by "IntrManagerId". The
+                parameter to "f" is Id - the handle of the destination object
+
+ @Param[in]     intrManagerId   - Queue ID.
+ @Param[in]     f               - routine pointer.
+ @Param[in]     Id              - the parameter to be passed to f().
+ @Param[in]     h_App           - Application handle.
+ @Param[in]     flags           - Unused,
+
+ @Return        E_OK is returned on success. E_FAIL is returned otherwise (usually an operating system level failure).
+*//***************************************************************************/
+t_Error XX_Call( uint32_t intrManagerId,
+                 t_Error (* f)(t_Handle),
+                 t_Handle Id,
+                 t_Handle h_App,
+                 uint16_t flags );
+
+/**************************************************************************//**
+ @Function      XX_Exit
+
+ @Description   Stop execution and report status (where it is applicable)
+
+ @Param[in]     status - exit status
+*//***************************************************************************/
+void    XX_Exit(int status);
+
+/*****************************************************************************/
+/*                        Tasklet Service Routines                           */
+/*****************************************************************************/
+typedef t_Handle t_TaskletHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitTasklet
+
+ @Description   Create and initialize a tasklet object.
+
+ @Param[in]     routine - A routine to be ran as a tasklet.
+ @Param[in]     data    - An argument to pass to the tasklet.
+
+ @Return        Tasklet handle is returned on success. NULL is returned otherwise.
+*//***************************************************************************/
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data);
+
+/**************************************************************************//**
+ @Function      XX_FreeTasklet
+
+ @Description   Free a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be free.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_ScheduleTask
+
+ @Description   Schedule a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     immediate - Indicate whether to schedule this tasklet on
+                            the immediate queue or on the delayed one.
+
+ @Return        0 - on success. Error code - otherwise.
+*//***************************************************************************/
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate);
+
+/**************************************************************************//**
+ @Function      XX_FlushScheduledTasks
+
+ @Description   Flush all tasks there are in the scheduled tasks queue.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FlushScheduledTasks(void);
+
+/**************************************************************************//**
+ @Function      XX_TaskletIsQueued
+
+ @Description   Check if task is queued.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        1 - task is queued. 0 - otherwise.
+*//***************************************************************************/
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_SetTaskletData
+
+ @Description   Set data to a scheduleded task. Used to change data of allready
+                scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     data      - Data to be set.
+*//***************************************************************************/
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data);
+
+/**************************************************************************//**
+ @Function      XX_GetTaskletData
+
+ @Description   Get the data of scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        handle to the data of the task.
+*//***************************************************************************/
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_BottomHalf
+
+ @Description   Bottom half implementation, invoked by the interrupt handler.
+
+                This routine handles all bottom-half tasklets with interrupts
+                enabled.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_BottomHalf(void);
+
+
+/*****************************************************************************/
+/*                        Spinlock Service Routines                          */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_InitSpinlock
+
+ @Description   Creates a spinlock.
+
+ @Return        Spinlock handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_Handle XX_InitSpinlock(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeSpinlock
+
+ @Description   Frees the memory allocated for the spinlock creation.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSpinlock(t_Handle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_LockSpinlock
+
+ @Description   Locks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_LockSpinlock(t_Handle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_UnlockSpinlock
+
+ @Description   Unlocks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_UnlockSpinlock(t_Handle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_LockIntrSpinlock
+
+ @Description   Locks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        A value that represents the interrupts state before the
+                operation, and should be passed to the matching
+                XX_UnlockIntrSpinlock() call.
+*//***************************************************************************/
+uint32_t XX_LockIntrSpinlock(t_Handle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_UnlockIntrSpinlock
+
+ @Description   Unlocks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock  - A handle to a spinlock.
+ @Param[in]     intrFlags   - A value that represents the interrupts state to
+                              restore, as returned by the matching call for
+                              XX_LockIntrSpinlock().
+
+ @Return        None.
+*//***************************************************************************/
+void XX_UnlockIntrSpinlock(t_Handle h_Spinlock, uint32_t intrFlags);
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_CurrentTime
+
+ @Description   Returns current system time.
+
+ @Return        Current system time (in milliseconds).
+*//***************************************************************************/
+uint32_t XX_CurrentTime(void);
+
+/**************************************************************************//**
+ @Function      XX_CreateTimer
+
+ @Description   Creates a timer.
+
+ @Return        Timer handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_Handle XX_CreateTimer(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTimer(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_StartTimer
+
+ @Description   Starts a timer.
+
+                The user can select to start the timer as periodic timer or as
+                one-shot timer. The user should provide a callback routine that
+                will be called when the timer expires.
+
+ @Param[in]     h_Timer         - A handle to a timer.
+ @Param[in]     msecs           - Timer expiration period (in milliseconds).
+ @Param[in]     periodic        - TRUE for a periodic timer;
+                                  FALSE for a one-shot timer..
+ @Param[in]     f_TimerExpired  - A callback routine to be called when the
+                                  timer expires.
+ @Param[in]     h_Arg           - The argument to pass in the timer-expired
+                                  callback routine.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle h_Arg),
+                   t_Handle h_Arg);
+
+/**************************************************************************//**
+ @Function      XX_StopTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StopTimer(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_GetExpirationTime
+
+ @Description   Returns the time (in milliseconds) remaining until the
+                expiration of a timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        The time left until the timer expires.
+*//***************************************************************************/
+uint32_t XX_GetExpirationTime(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_ModTimer
+
+ @Description   Updates the expiration time of a timer.
+
+                This routine adds the given time to the current system time,
+                and sets this value as the new expiration time of the timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+ @Param[in]     msecs   - The new interval until timer expiration
+                          (in milliseconds).
+
+ @Return        None.
+*//***************************************************************************/
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_TimerIsActive
+
+ @Description   Checks whether a timer is active (pending) or not.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        0 - the timer is inactive; Non-zero value - the timer is active;
+*//***************************************************************************/
+int XX_TimerIsActive(t_Handle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_Sleep
+
+ @Description   Non-busy wait until the desired time (in milliseconds) has passed.
+
+ @Param[in]     msecs - The requested sleep time (in milliseconds).
+
+ @Return        None.
+
+ @Cautions      This routine enables interrupts during its wait time.
+*//***************************************************************************/
+uint32_t XX_Sleep(uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_UDelay
+
+ @Description   Busy-wait until the desired time (in microseconds) has passed.
+
+ @Param[in]     usecs - The requested delay time (in microseconds).
+
+ @Return        None.
+
+ @Cautions      It is highly unrecommended to call this routine during interrupt
+                time, because the system time may not be updated properly during
+                the delay loop. The behavior of this routine during interrupt
+                time is unexpected.
+*//***************************************************************************/
+void XX_UDelay(uint32_t usecs);
+
+
+/*****************************************************************************/
+/*                         Other Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+void * XX_PhysToVirt(physAddress_t addr);
+
+/**************************************************************************//**
+ @Function      XX_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+physAddress_t XX_VirtToPhys(void *addr);
+
+
+/**************************************************************************//**
+ @Group         xx_ipc  XX Inter-Partition-Communication API
+
+ @Description   The following API is to be used when working with multiple
+                partitions configuration.
+
+ @{
+*//***************************************************************************/
+
+#define XX_IPC_MAX_ADDR_NAME_LENGTH 16         /**< Maximum length of an endpoint name string;
+                                                    The IPC service can use this constant to limit
+                                                    the storage space for IPC endpoint names. */
+
+
+/**************************************************************************//**
+ @Function      t_IpcMsgCompletion
+
+ @Description   Callback function used upon IPC non-blocking transaction completion
+                to return message buffer to the caller and to forward reply if available.
+
+                This callback function may be attached by the source endpoint to any outgoing
+                IPC message to indicate a non-blocking send (see also XX_IpcSendMessage() routine).
+                Upon completion of an IPC transaction (consisting of a message and an optional reply),
+                the IPC service invokes this callback routine to return the message buffer to the sender
+                and to provide the received reply, if requested.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_Module        - Abstract handle to the sending module -  the same handle as was passed
+                                  in the XX_IpcSendMessage() function; This handle is typically used to point
+                                  to the internal data structure of the source endpoint.
+ @Param[in]     p_Msg           - Pointer to original (sent) message buffer;
+                                  The source endpoint can free (or reuse) this buffer when message
+                                  completion callback is called.
+ @Param[in]     p_Reply         - Pointer to (received) reply buffer;
+                                  This pointer is the same as was provided by the source endpoint in
+                                  XX_IpcSendMessage().
+ @Param[in]     replyLength     - Length (in bytes) of actual data in the reply buffer.
+ @Param[in]     status          - Completion status - E_OK or failure indication, e.g. IPC transaction completion
+                                  timeout.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void    (t_IpcMsgCompletion)(t_Handle   h_Module,
+                                     uint8_t    *p_Msg,
+                                     uint8_t    *p_Reply,
+                                     uint32_t   replyLength,
+                                     t_Error    status);
+
+/**************************************************************************//**
+ @Function      t_IpcMsgHandler
+
+ @Description   Callback function used as IPC message handler.
+
+                The IPC service invokes message handlers for each IPC message received.
+                The actual function pointer should be registered by each destination endpoint
+                via the XX_IpcRegisterMsgHandler() routine.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_Module        - Abstract handle to the message handling module -  the same handle as
+                                  was passed in the XX_IpcRegisterMsgHandler() function; this handle is
+                                  typically used to point to the internal data structure of the destination
+                                  endpoint.
+ @Param[in]     p_Msg           - Pointer to message buffer with data received from peer.
+ @Param[in]     msgLength       - Length (in bytes) of message data.
+ @Param[in]     p_Reply         - Pointer to reply buffer, to be filled by the message handler and then sent
+                                  by the IPC service;
+                                  The reply buffer is allocated by the IPC service with size equals to the
+                                  replyLength parameter provided in message handler registration (see
+                                  XX_IpcRegisterMsgHandler() function);
+                                  If replyLength was initially specified as zero during message handler registration,
+                                  the IPC service may set this pointer to NULL and assume that a reply is not needed;
+                                  The IPC service is also responsible for freeing the reply buffer after the
+                                  reply has been sent or dismissed.
+ @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
+                                  [In] equals the replyLength parameter provided in message handler
+                                  registration (see XX_IpcRegisterMsgHandler() function), and
+                                  [Out] should be updated by message handler to the actual reply length; if
+                                  this value is set to zero, the IPC service must assume that a reply should
+                                  not be sent;
+                                  Note: If p_Reply is not NULL, p_ReplyLength must not be NULL as well.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_IpcMsgHandler)(t_Handle  h_Module,
+                                  uint8_t   *p_Msg,
+                                  uint32_t  msgLength,
+                                  uint8_t   *p_Reply,
+                                  uint32_t  *p_ReplyLength);
+
+/**************************************************************************//**
+ @Function      XX_IpcRegisterMsgHandler
+
+ @Description   IPC mailbox registration.
+
+                This function is used for registering an IPC message handler in the IPC service.
+                This function is called by each destination endpoint to indicate that it is ready
+                to handle incoming messages. The IPC service invokes the message handler upon receiving
+                a message addressed to the specified destination endpoint.
+
+ @Param[in]     addr                - The address name string associated with the destination endpoint;
+                                      This address must be unique across the IPC service domain to ensure
+                                      correct message routing.
+ @Param[in]     f_MsgHandler        - Pointer to the message handler callback for processing incoming
+                                      message; invoked by the IPC service upon receiving a message
+                                      addressed to the destination endpoint specified by the addr
+                                      parameter.
+ @Param[in]     h_Module            - Abstract handle to the message handling module, passed unchanged
+                                      to f_MsgHandler callback function.
+ @Param[in]     replyLength         - The maximal data length (in bytes) of any reply that the specified message handler
+                                      may generate; the IPC service provides the message handler with buffer
+                                      for reply according to the length specified here (refer also to the description
+                                      of #t_IpcMsgHandler callback function type);
+                                      This size shall be zero if the message handler never generates replies.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcRegisterMsgHandler(char                   addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandler        *f_MsgHandler,
+                                 t_Handle               h_Module,
+                                 uint32_t               replyLength);
+
+/**************************************************************************//**
+ @Function      XX_IpcUnregisterMsgHandler
+
+ @Description   Release IPC mailbox routine.
+
+                 This function is used for unregistering an IPC message handler from the IPC service.
+                 This function is called by each destination endpoint to indicate that it is no longer
+                 capable of handling incoming messages.
+
+ @Param[in]     addr          - The address name string associated with the destination endpoint;
+                                This address is the same as was used when the message handler was
+                                registered via XX_IpcRegisterMsgHandler().
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
+
+/**************************************************************************//**
+ @Function      XX_IpcInitSession
+
+ @Description   This function is used for creating an IPC session between the source endpoint
+                and the destination endpoint.
+
+                The actual implementation and representation of a session is left for the IPC service.
+                The function returns an abstract handle to the created session. This handle shall be used
+                by the source endpoint in subsequent calls to XX_IpcSendMessage().
+                The IPC service assumes that before this function is called, no messages are sent from
+                the specified source endpoint to the specified destination endpoint.
+
+                The IPC service may use a connection-oriented approach or a connectionless approach (or both)
+                as described below.
+
+                @par Connection-Oriented Approach
+
+                The IPC service may implement a session in a connection-oriented approach -  when this function is called,
+                the IPC service should take the necessary steps to bring up a source-to-destination channel for messages
+                and a destination-to-source channel for replies. The returned handle should represent the internal
+                representation of these channels.
+
+                @par Connectionless Approach
+
+                The IPC service may implement a session in a connectionless approach -  when this function is called, the
+                IPC service should not perform any particular steps, but it must store the pair of source and destination
+                addresses in some session representation and return it as a handle. When XX_IpcSendMessage() shall be
+                called, the IPC service may use this handle to provide the necessary identifiers for routing the messages
+                through the connectionless medium.
+
+ @Param[in]     destAddr      - The address name string associated with the destination endpoint.
+ @Param[in]     srcAddr       - The address name string associated with the source endpoint.
+
+ @Return        Abstract handle to the initialized session, or NULL on error.
+*//***************************************************************************/
+t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH]);
+
+/**************************************************************************//**
+ @Function      XX_IpcFreeSession
+
+ @Description   This function is used for terminating an existing IPC session between a source endpoint
+                and a destination endpoint.
+
+                The IPC service assumes that after this function is called, no messages shall be sent from
+                the associated source endpoint to the associated destination endpoint.
+
+ @Param[in]     h_Session      - Abstract handle to the IPC session -  the same handle as was originally
+                                 returned by the XX_IpcInitSession() function.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcFreeSession(t_Handle h_Session);
+
+/**************************************************************************//**
+ @Function      XX_IpcSendMessage
+
+ @Description   IPC message send routine.
+
+                This function may be used by a source endpoint to send an IPC message to a destination
+                endpoint. The source endpoint cannot send a message to the destination endpoint without
+                first initiating a session with that destination endpoint via XX_IpcInitSession() routine.
+
+                The source endpoint must provide the buffer pointer and length of the outgoing message.
+                Optionally, it may also provide a buffer for an expected reply. In the latter case, the
+                transaction is not considered complete by the IPC service until the reply has been received.
+                If the source endpoint does not provide a reply buffer, the transaction is considered
+                complete after the message has been sent. The source endpoint must keep the message (and
+                optional reply) buffers valid until the transaction is complete.
+
+                @par Non-blocking mode
+
+                The source endpoint may request a non-blocking send by providing a non-NULL pointer to a message
+                completion callback function (f_Completion). Upon completion of the IPC transaction (consisting of a
+                message and an optional reply), the IPC service invokes this callback routine to return the message
+                buffer to the sender and to provide the received reply, if requested.
+
+                @par Blocking mode
+
+                The source endpoint may request a blocking send by setting f_Completion to NULL. The function is
+                expected to block until the IPC transaction is complete -  either the reply has been received or (if no reply
+                was requested) the message has been sent.
+
+ @Param[in]     h_Session       - Abstract handle to the IPC session -  the same handle as was originally
+                                  returned by the XX_IpcInitSession() function.
+ @Param[in]     p_Msg           - Pointer to message buffer to send.
+ @Param[in]     msgLength       - Length (in bytes) of actual data in the message buffer.
+ @Param[in]     p_Reply         - Pointer to reply buffer -  if this buffer is not NULL, the IPC service
+                                  fills this buffer with the received reply data;
+                                  In blocking mode, the reply data must be valid when the function returns;
+                                  In non-blocking mode, the reply data is valid when f_Completion is called;
+                                  If this pointer is NULL, no reply is expected.
+ @Param[in,out] p_ReplyLength   - Pointer to reply length, which has a dual role in this function:
+                                  [In] specifies the maximal length (in bytes) of the reply buffer pointed by
+                                  p_Reply, and
+                                  [Out] in non-blocking mode this value is updated by the IPC service to the
+                                  actual reply length (in bytes).
+ @Param[in]     f_Completion    - Pointer to a completion callback to be used in non-blocking send mode;
+                                  The completion callback is invoked by the IPC service upon
+                                  completion of the IPC transaction (consisting of a message and an optional
+                                  reply);
+                                  If this pointer is NULL, the function is expected to block until the IPC
+                                  transaction is complete.
+ @Param[in]     h_Arg           - Abstract handle to the sending module; passed unchanged to the f_Completion
+                                  callback function as the first argument.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error XX_IpcSendMessage(t_Handle           h_Session,
+                          uint8_t            *p_Msg,
+                          uint32_t           msgLength,
+                          uint8_t            *p_Reply,
+                          uint32_t           *p_ReplyLength,
+                          t_IpcMsgCompletion *f_Completion,
+                          t_Handle           h_Arg);
+
+
+/** @} */ /* end of xx_ipc group */
+/** @} */ /* end of xx_id group */
+
+
+#endif /* __XX_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/integrations/P1023/Makefile b/drivers/net/dpa/NetCommSw/integrations/P1023/Makefile
new file mode 100644
index 0000000..6241a44
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P1023/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= module_strings.o
diff --git a/drivers/net/dpa/NetCommSw/integrations/P1023/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P1023/module_strings.c
new file mode 100644
index 0000000..98d3a79
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P1023/module_strings.c
@@ -0,0 +1,74 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/* Module names for debug messages */
+const char *moduleStrings[] =
+{
+     ""                         /* MODULE_UNKNOWN */
+    ,"MEM"                      /* MODULE_ */
+    ,"MM"                       /* MODULE_MM */
+    ,"CORE"                     /* MODULE_CORE */
+    ,"P1023"                    /* MODULE_P1023 */
+    ,"MII"                      /* MODULE_MII */
+    ,"PM"                       /* MODULE_PM */
+    ,"MMU"                      /* MODULE_MMU */
+    ,"PIC"                      /* MODULE_PIC */
+    ,"L2 cache"                 /* MODULE_L2_CACHE */
+    ,"DUART"                    /* MODULE_DUART */
+    ,"SerDes"                   /* MODULE_SERDES */
+    ,"PIO"                      /* MODULE_PIO */
+    ,"QM"                       /* MODULE_QM */
+    ,"BM"                       /* MODULE_BM */
+    ,"SEC"                      /* MODULE_SEC */
+    ,"FM"                       /* MODULE_FM */
+    ,"FM-MURAM"                 /* MODULE_FM_MURAM */
+    ,"FM-PCD"                   /* MODULE_FM_PCD */
+    ,"FM-RTC"                   /* MODULE_FM_RTC */
+    ,"FM-MAC"                   /* MODULE_FM_MAC */
+    ,"FM-Port"                  /* MODULE_FM_PORT */
+    ,"FM-MACSEC"                /* MODULE_FM_MACSEC */
+    ,"FM-MACSEC-SecY"           /* MODULE_FM_MACSEC_SECY */
+    ,"ECM"                      /* MODULE_ECM */
+    ,"DMA"                      /* MODULE_DMA */
+    ,"DDR"                      /* MODULE_DDR */
+    ,"LAW"                      /* MODULE_LAW */
+    ,"LBC"                      /* MODULE_LBC */
+    ,"I2C"                      /* MODULE_I2C */
+    ,"ESPI"                     /* MODULE_ESPI */
+    ,"PCI"                      /* MODULE_PCI */
+    ,"DPA"                      /* MODULE_DPA */
+    ,"USB"                      /* MODULE_USB */
+#ifdef RSC1023
+    ,"eTSEC"                    /* MODULE_ETSEC */
+#endif /* RSC1023 */
+};
diff --git a/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/Makefile b/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/Makefile
new file mode 100644
index 0000000..6241a44
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= module_strings.o
diff --git a/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
new file mode 100644
index 0000000..36a4250
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
@@ -0,0 +1,62 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Module names for debug messages */
+const char *moduleStrings[] =
+{
+     "???"                      /* MODULE_UNKNOWN */
+    ,"MEM"                      /* MODULE_ */
+    ,"MM"                       /* MODULE_MM */
+    ,"CORE"                     /* MODULE_CORE */
+    ,"P4080"                    /* MODULE_P4080 */
+    ,"P4080-Platform"           /* MODULE_P4080_PLTFRM */
+    ,"PM"                       /* MODULE_PM */
+    ,"MMU"                      /* MODULE_MMU */
+    ,"PIC"                      /* MODULE_PIC */
+    ,"L3 cache (CPC)"           /* MODULE_CPC */
+    ,"DUART"                    /* MODULE_DUART */
+    ,"SerDes"                   /* MODULE_SERDES */
+    ,"PIO"                      /* MODULE_PIO */
+    ,"QM"                       /* MODULE_QM */
+    ,"BM"                       /* MODULE_BM */
+    ,"SEC"                      /* MODULE_SEC */
+    ,"LAW"                      /* MODULE_LAW */
+    ,"LBC"                      /* MODULE_LBC */
+    ,"PAMU"                     /* MODULE_PAMU */
+    ,"FM"                       /* MODULE_FM */
+    ,"FM-MURAM"                 /* MODULE_FM_MURAM */
+    ,"FM-PCD"                   /* MODULE_FM_PCD */
+    ,"FM-RTC"                   /* MODULE_FM_RTC */
+    ,"FM-MAC"                   /* MODULE_FM_MAC */
+    ,"FM-Port"                  /* MODULE_FM_PORT */
+    ,"DPA"                      /* MODULE_DPA */
+};
diff --git a/drivers/net/dpa/NetCommSw/ncsw_config.mk b/drivers/net/dpa/NetCommSw/ncsw_config.mk
new file mode 100644
index 0000000..e54a13b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/ncsw_config.mk
@@ -0,0 +1,33 @@
+#
+# Makefile config for the Freescale NetcommSW
+#
+NET_DPA     = $(srctree)/drivers/net
+DRV_DPA     = $(srctree)/drivers/net/dpa
+NCSW        = $(srctree)/drivers/net/dpa/NetCommSw
+
+ifdef CONFIG_FMAN_P3040_P4080_P5020
+EXTRA_CFLAGS +=-include $(NCSW)/p3040_4080_5020_dflags.h
+endif
+ifdef CONFIG_FMAN_P1023
+EXTRA_CFLAGS +=-include $(NCSW)/p1023_dflags.h
+endif
+
+EXTRA_CFLAGS += -I$(DRV_DPA)/
+EXTRA_CFLAGS += -I$(NCSW)/inc
+EXTRA_CFLAGS += -I$(NCSW)/inc/cores
+EXTRA_CFLAGS += -I$(NCSW)/inc/etc
+EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
+
+ifdef CONFIG_FMAN_P3040_P4080_P5020
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P3040_P4080_P5020
+endif
+ifdef CONFIG_FMAN_P1023
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P1023
+endif
+
+EXTRA_CFLAGS += -I$(NCSW)/src/inc
+EXTRA_CFLAGS += -I$(NCSW)/src/inc/system
+EXTRA_CFLAGS += -I$(NCSW)/src/inc/wrappers/Peripherals
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/Peripherals
+EXTRA_CFLAGS += -I$(srctree)/include/linux/fmd/integrations
diff --git a/drivers/net/dpa/NetCommSw/p1023_dflags.h b/drivers/net/dpa/NetCommSw/p1023_dflags.h
new file mode 100644
index 0000000..5f28610
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/p1023_dflags.h
@@ -0,0 +1,67 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+#include "events_mapping.h"
+
+
+#define NCSW_LINUX
+#if 0
+#define DEBUG
+#endif
+
+#define P1023
+#define NCSW_PPC_CORE
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#ifdef CONFIG_P4080_SIM
+#error "Do not define CONFIG_P4080_SIM..."
+#endif 
+
+
+#endif /* __dflags_h */
diff --git a/drivers/net/dpa/NetCommSw/p3040_4080_5020_dflags.h b/drivers/net/dpa/NetCommSw/p3040_4080_5020_dflags.h
new file mode 100644
index 0000000..12482f9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/p3040_4080_5020_dflags.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+#include "events_mapping.h"
+
+
+#define NCSW_LINUX
+
+#define P4080
+#define NCSW_PPC_CORE
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#ifdef CONFIG_P4080_SIM
+#define SIMULATOR
+#endif /* CONFIG_P4080_SIM */
+
+
+#endif /* __dflags_h */
diff --git a/drivers/net/dpa/NetCommSw/src/Makefile b/drivers/net/dpa/NetCommSw/src/Makefile
new file mode 100644
index 0000000..902fe6e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= modules/integrations/P4080/FM/
+obj-y		+= system/
+obj-y		+= util/
+obj-y		+= wrappers/Peripherals/FM/
+obj-y		+= xx/
diff --git a/drivers/net/dpa/NetCommSw/src/inc/procbuff_ext.h b/drivers/net/dpa/NetCommSw/src/inc/procbuff_ext.h
new file mode 100644
index 0000000..2787495
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/procbuff_ext.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          procbuff_ext.h
+
+ @Author        Eran Liberty
+
+ @Description   TODO
+*//***************************************************************************/
+#ifndef __PROCBUFF_EXT_H
+#define __PROCBUFF_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#define MAX_LINE_SIZE       1024
+
+
+t_Handle    ProcBuff_Init (char *buffer,char **start,int offset,int length, int *eof);
+void        ProcBuff_Free (t_Handle h_ProcBuff);
+
+void        ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...);
+int         ProcBuff_GetNumOfWrittenChars (t_Handle h_ProcBuff);
+void        ProcBuff_Done  (t_Handle h_ProcBuff);
+
+
+#endif /* __PROCBUFF_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/system/platform_ext.h b/drivers/net/dpa/NetCommSw/src/inc/system/platform_ext.h
new file mode 100644
index 0000000..696c12b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/system/platform_ext.h
@@ -0,0 +1,209 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_EXT_H
+#define __PLATFORM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @Description   Generic Platform API, that must be implemented by each
+                specific platform.
+
+ @{
+*//***************************************************************************/
+
+#define MAX_CHIP_NAME_LEN   9   /* (including null character) */
+
+#define PLATFORM_IO_MODE_ANY    (-1)    /**< Unspecified I/O mode */
+
+/**************************************************************************//**
+ @Description   Cache Operation Mode
+*//***************************************************************************/
+typedef enum e_CacheMode
+{
+    e_CACHE_MODE_DISABLED       = 0x00000000,   /**< Cache is disabled */
+    e_CACHE_MODE_DATA_ONLY      = 0x00000001,   /**< Cache is enabled for data only */
+    e_CACHE_MODE_INST_ONLY      = 0x00000002,   /**< Cache is enabled for instructions only */
+    e_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache is enabled for data and instructions */
+
+} e_CacheMode;
+
+/**************************************************************************//**
+ @Description   Memory Partition Identifiers
+
+                Note that not all memory partitions are supported by all
+                platforms. Every platform may select which memory partitions
+                to support.
+*//***************************************************************************/
+typedef enum e_MemoryPartitionId
+{
+    e_MEM_1ST_DDR_CACHEABLE     = 1, /**< Primary DDR cacheable memory partition */
+    e_MEM_1ST_DDR_NON_CACHEABLE = 2, /**< Primary DDR non-cacheable memory partition */
+    e_MEM_2ND_DDR_CACHEABLE     = 3, /**< Secondary DDR cacheable memory partition */
+    e_MEM_2ND_DDR_NON_CACHEABLE = 4, /**< Secondary DDR non-cacheable memory partition */
+    e_MEM_SDRAM                 = 5, /**< SDRAM non-cacheable memory partition */
+    e_MEM_L2_SRAM               = 6, /**< L2 SRAM cacheable memory partition */
+    e_MEM_MURAM_LOW             = 7, /**< Low-range MURAM partition */
+    e_MEM_MURAM                 = 8  /**< Full-range MURAM partition */
+
+} e_MemoryPartitionId;
+
+/**************************************************************************//**
+ @Description   Chip Type and Revision Information Structure
+*//***************************************************************************/
+typedef struct t_ChipRevInfo
+{
+    char            chipName[MAX_CHIP_NAME_LEN];
+                    /**< Chip name (e.g. "P4080") */
+    uint16_t        revMajor;
+                    /**< Major chip revision */
+    uint16_t        revMinor;
+                    /**< Minor chip revision */
+} t_ChipRevInfo;
+
+/**************************************************************************//**
+ @Description   Platform Events
+*//***************************************************************************/
+typedef enum e_PlatformEvent
+{
+    e_PLATFORM_EVENT_LINK_DOWN, /**< Link-up event */
+    e_PLATFORM_EVENT_LINK_UP    /**< Link-down event */
+
+} e_PlatformEvent;
+
+/**************************************************************************//**
+ @Description   Callback Function Prototype for Link Events
+*//***************************************************************************/
+typedef void (t_PlatformLinkEventsCb)(t_Handle          h_Controller,
+                                      uint8_t           linkId,
+                                      e_PlatformEvent   event);
+
+
+
+/**************************************************************************//**
+ @Description   Interrupt Source Types
+*//***************************************************************************/
+typedef enum e_InterruptType
+{
+    e_INTR_TYPE_GENERAL,
+    e_INTR_TYPE_IRQ,
+    e_INTR_TYPE_ERR,
+    e_INTR_TYPE_GTIMERS_TIMER,
+    e_INTR_TYPE_RTC_COUNT,
+    e_INTR_TYPE_RTC_ALARM,
+    e_INTR_TYPE_PCI_IRQ,
+    e_INTR_TYPE_PCI_PME,
+    e_INTR_TYPE_PCI_MSI,
+    e_INTR_TYPE_ETSEC_TX,
+    e_INTR_TYPE_ETSEC_RX,
+    e_INTR_TYPE_ETSEC_ERROR,
+    e_INTR_TYPE_RIO_PW,
+    e_INTR_TYPE_RIO_DB_OUT,
+    e_INTR_TYPE_RIO_DB_IN,
+    e_INTR_TYPE_RIO_MSG_OUT,
+    e_INTR_TYPE_RIO_MSG_IN,
+    e_INTR_TYPE_QE_LOW,
+    e_INTR_TYPE_QE_HIGH,
+    e_INTR_TYPE_QE_IO_PORTS,
+    e_INTR_TYPE_QE_IRAM_ERR,
+    e_INTR_TYPE_QE_MURAM_ERR,
+    e_INTR_TYPE_QE_RTT,
+    e_INTR_TYPE_QE_SDMA,
+    e_INTR_TYPE_QE_VT,
+    e_INTR_TYPE_QE_EXT_REQ
+} e_InterruptType;
+
+/**************************************************************************//**
+ @Description   Descriptor of Board Connections
+*//***************************************************************************/
+typedef struct t_BoardConnectorDesc
+{
+    struct
+    {
+        e_SysModule module;
+        uint32_t    id;
+    } source;
+
+    struct
+    {
+        e_SysModule module;
+        uint32_t    id;
+    } dest;
+
+} t_BoardConnectorDesc;
+
+/**************************************************************************//**
+ @Description   Platform configuration parameters structure.
+
+                This structure must be specifically defined by each platform.
+*//***************************************************************************/
+struct t_PlatformParam;
+
+
+t_Handle PLATFORM_Init(struct t_PlatformParam *p_PlatformParam);
+
+t_Error  PLATFORM_Free(t_Handle h_Platform);
+
+t_Error  PLATFORM_ConnectExternalRequest(t_Handle h_Platform, e_SysModule module,uint8_t extReqNum);
+
+t_Error  PLATFORM_GetChipRevInfo(t_Handle h_Platform, t_ChipRevInfo *p_ChipRevInfo);
+
+uint32_t PLATFORM_GetMemoryMappedModuleBase(t_Handle    h_Platform,
+                                            e_SysModule module,
+                                            uint32_t    id);
+
+int PLATFORM_GetInterruptId(t_Handle        h_Platform,
+                            e_SysModule     module,
+                            uint32_t        id,
+                            e_InterruptType intrType,
+                            uint32_t        intrRelatedId);
+
+uint32_t PLATFORM_GetCoreClk(t_Handle h_Platform);
+
+uint32_t PLATFORM_GetSystemBusClk(t_Handle h_Platform);
+
+uint32_t PLATFORM_GetControllerClk(t_Handle     h_Platform,
+                                   e_SysModule  module,
+                                   uint32_t     id);
+/** @} */ /* end of platform_grp */
+
+#endif /* __PLATFORM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/system/platform_p4080_ds_ext.h b/drivers/net/dpa/NetCommSw/src/inc/system/platform_p4080_ds_ext.h
new file mode 100644
index 0000000..d35a11c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/system/platform_p4080_ds_ext.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          platform_p4080_ds_ext.h
+
+ @Description   Prototypes, externals and typedefs for platform routines
+****************************************************************************/
+#ifndef __PLATFORM_P4080_DS_EXT_H
+#define __PLATFORM_P4080_DS_EXT_H
+
+#include "std_ext.h"
+#include "platform_ext.h"
+
+
+/**************************************************************************//**
+ @Group         platform_grp PLATFORM Application Programming Interface
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   P4080-DS Platform configuration parameters structure
+*//***************************************************************************/
+typedef struct t_PlatformParam
+{
+    e_CacheMode             l1CacheMode;
+    e_CacheMode             l2CacheMode;
+} t_PlatformParam;
+
+/** @} */ /* end of platform_grp */
+
+
+#endif /* __PLATFORM_P4080_DS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/src/inc/system/sys_ext.h
new file mode 100644
index 0000000..33d0b3b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/system/sys_ext.h
@@ -0,0 +1,928 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_EXT_H
+#define __SYS_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         sys_grp     System Interfaces
+
+ @Description   Linux system programming interfaces.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         sys_gen_grp     System General Interface
+
+ @Description   General definitions, structures and routines of the linux
+                system programming interface.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   System Modules and Sub-Modules Enumeration
+
+                This enumeration type is expected by most system routines in
+                order to identify the type of the referenced module or sub-module.
+                The lower values of this enumeration type are modules, and the
+                higher values are sub-modules.
+*//***************************************************************************/
+typedef enum e_SysModule
+{
+    e_SYS_MODULE_NONE = 0,
+
+    /* ----------- Modules ----------- */
+    e_SYS_MODULE_PLATFORM,
+    e_SYS_MODULE_DEV_MNG,
+    e_SYS_MODULE_DATA_POOL_MNG,
+    e_SYS_MODULE_TRAFFIC_MNG,
+    e_SYS_MODULE_APP,
+    /* Stacks */
+    e_SYS_MODULE_PCI_STACK,
+    e_SYS_MODULE_ESDHC_STACK,
+    e_SYS_MODULE_RIO_STACK,
+    e_SYS_MODULE_I2C_STACK,
+    e_SYS_MODULE_SPI_STACK,
+    e_SYS_MODULE_USB_STACK,
+    e_SYS_MODULE_IMA_STACK,
+    /* Wrappers */
+    e_SYS_MODULE_WRP_ECM,
+    e_SYS_MODULE_WRP_ARBITER,
+    e_SYS_MODULE_WRP_DUART,
+    e_SYS_MODULE_WRP_UART,
+    e_SYS_MODULE_WRP_QE,
+    e_SYS_MODULE_WRP_UPC,
+    e_SYS_MODULE_WRP_UCC_ATM,
+    e_SYS_MODULE_WRP_UCC_POS,
+    e_SYS_MODULE_WRP_UCC_GETH,
+    e_SYS_MODULE_WRP_UCC_HDLC,
+    e_SYS_MODULE_WRP_UCC_TRNS,
+    e_SYS_MODULE_WRP_UCC_UART,
+    e_SYS_MODULE_WRP_QMC,
+    e_SYS_MODULE_WRP_QMC_HDLC,
+    e_SYS_MODULE_WRP_QMC_TRANS,
+    e_SYS_MODULE_WRP_L2_SWITCH,
+    e_SYS_MODULE_WRP_SI,
+    e_SYS_MODULE_WRP_TDM,
+    e_SYS_MODULE_WRP_MCC,
+    e_SYS_MODULE_WRP_MCC_HDLC,
+    e_SYS_MODULE_WRP_MCC_TRANS,
+    e_SYS_MODULE_WRP_MCC_SS7,
+    e_SYS_MODULE_WRP_PPPOHT,
+    e_SYS_MODULE_WRP_IW_PPPOHT,
+    e_SYS_MODULE_WRP_PCI,
+    e_SYS_MODULE_WRP_ESDHC,
+    e_SYS_MODULE_WRP_RIO,
+    e_SYS_MODULE_WRP_I2C,
+    e_SYS_MODULE_WRP_SPI,
+    e_SYS_MODULE_WRP_ETSEC,
+    e_SYS_MODULE_WRP_SRIO,
+    e_SYS_MODULE_WRP_IMA,
+    e_SYS_MODULE_WRP_MTC,
+    e_SYS_MODULE_WRP_QE_IW,
+    e_SYS_MODULE_WRP_QE_FILTERING,
+    e_SYS_MODULE_WRP_QE_RTC,
+    e_SYS_MODULE_WRP_VP,
+    e_SYS_MODULE_WRP_GTIMERS,
+    e_SYS_MODULE_WRP_DMA,
+    e_SYS_MODULE_WRP_PTP,
+
+    /* Bus Device Drivers */
+    e_SYS_MODULE_MPC8568_RIO_DEV,
+    e_SYS_MODULE_MPC8568_PCI_DEV,
+    e_SYS_MODULE_MPC836X_PCI_DEV,
+    e_SYS_MODULE_MPC837x_PCI_DEV,
+    e_SYS_MODULE_MPC832X_PCI_DEV,
+    e_SYS_MODULE_MPC8568_PCIE_DEV,
+    e_SYS_MODULE_MPC8569_PCIE_DEV,
+    e_SYS_MODULE_MPC837x_PCIE_DEV,
+    e_SYS_MODULE_MPC8568_SPI_FLASH_DEV,
+    e_SYS_MODULE_MPC8568_SPI_LB_DEV,
+    e_SYS_MODULE_SD_DEV,
+    e_SYS_MODULE_SPD_I2C_DEV,
+    e_SYS_MODULE_DS1374_I2C_DEV,
+    e_SYS_MODULE_PCA9555_I2C_DEV,
+    e_SYS_MODULE_M24256_I2C_DEV,
+    e_SYS_MODULE_AT24C01A_I2C_DEV,
+
+    /* Must close the modules list and open the sub-modules list */
+    e_SYS_SUBMODULE_DUMMY_FIRST,
+
+    /* --------- Sub-modules --------- */
+    e_SYS_SUBMODULE_DATA_POOL,
+    e_SYS_SUBMODULE_PG,
+    e_SYS_SUBMODULE_TG,
+    e_SYS_SUBMODULE_TA,
+    e_SYS_SUBMODULE_DEC,
+    e_SYS_SUBMODULE_PART,
+    e_SYS_SUBMODULE_IPIC,
+    e_SYS_SUBMODULE_EPIC,
+    e_SYS_SUBMODULE_QE_IC,
+    e_SYS_SUBMODULE_LAW,
+    e_SYS_SUBMODULE_DDR,
+    e_SYS_SUBMODULE_LBC,
+    e_SYS_SUBMODULE_ECM,
+    e_SYS_SUBMODULE_ARBITER,
+    e_SYS_SUBMODULE_L2,
+    e_SYS_SUBMODULE_QE,
+    e_SYS_SUBMODULE_QE_TIMERS,
+    e_SYS_SUBMODULE_GTIMERS,
+    e_SYS_SUBMODULE_PAR_IO,
+    e_SYS_SUBMODULE_GPIO,
+    e_SYS_SUBMODULE_SI,
+    e_SYS_SUBMODULE_TDM,
+    e_SYS_SUBMODULE_TDM_RX_FRAME,
+    e_SYS_SUBMODULE_TDM_TX_FRAME,
+    e_SYS_SUBMODULE_MCC,
+    e_SYS_SUBMODULE_MCC_HDLC_CH,
+    e_SYS_SUBMODULE_MCC_TRANS_CH,
+    e_SYS_SUBMODULE_MCC_SS7_CH,
+    e_SYS_SUBMODULE_UPC,
+    e_SYS_SUBMODULE_DUART,
+    e_SYS_SUBMODULE_I2C_CTRL,
+    e_SYS_SUBMODULE_DMA,
+    e_SYS_SUBMODULE_DMA_CH,
+    e_SYS_SUBMODULE_PM,
+    e_SYS_SUBMODULE_RTC,
+    e_SYS_SUBMODULE_TLU,
+    e_SYS_SUBMODULE_SEC,
+    e_SYS_SUBMODULE_PCI_CTRL,
+    e_SYS_SUBMODULE_PCIE_CTRL,
+    e_SYS_SUBMODULE_ESDHC,
+    e_SYS_SUBMODULE_SRIO_PORT,
+    e_SYS_SUBMODULE_SRIO_MU,
+    e_SYS_SUBMODULE_SPI_CTRL,
+    e_SYS_SUBMODULE_ETSEC,
+    e_SYS_SUBMODULE_USB_CTRL,
+    e_SYS_SUBMODULE_UCC_GETH,
+    e_SYS_SUBMODULE_UCC_ATM_COMMON,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_COMMON,
+    e_SYS_SUBMODULE_UCC_ATM_CTRL,
+    e_SYS_SUBMODULE_UCC_POS_COMMON,
+    e_SYS_SUBMODULE_UCC_POS_CTRL,
+    e_SYS_SUBMODULE_EOS_LINK,
+    e_SYS_SUBMODULE_PPPOS_LINK,
+    e_SYS_SUBMODULE_UTOPIA_PORT,
+    e_SYS_SUBMODULE_UCC_ATM_POLICER,
+    e_SYS_SUBMODULE_UCC_ATM_AAL0,
+    e_SYS_SUBMODULE_UCC_ATM_AAL5,
+    e_SYS_SUBMODULE_UCC_ATM_AAL1,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_TQD,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_CID,
+    e_SYS_SUBMODULE_UCC_HDLC,
+    e_SYS_SUBMODULE_UCC_TRNS,
+    e_SYS_SUBMODULE_UCC_UART,
+    e_SYS_SUBMODULE_QMC,
+    e_SYS_SUBMODULE_QMC_HDLC_CH,
+    e_SYS_SUBMODULE_QMC_TRANS_CH,
+    e_SYS_SUBMODULE_L2_SWITCH,
+    e_SYS_SUBMODULE_L2_SWITCH_PORT,
+    e_SYS_SUBMODULE_PPPOHT,
+    e_SYS_SUBMODULE_PPPOHT_BUNDLE,
+    e_SYS_SUBMODULE_PPPOHT_LINK,
+    e_SYS_SUBMODULE_PPPOHT_RX_FBP,
+    e_SYS_SUBMODULE_PPPOHT_TX_FBPS,
+    e_SYS_SUBMODULE_IW_PPPOHT,
+    e_SYS_SUBMODULE_IW_PPPOHT_BUNDLE,
+    e_SYS_SUBMODULE_IW_PPPOHT_LINK,
+    e_SYS_SUBMODULE_IMA,
+    e_SYS_SUBMODULE_IMA_GROUP_PORT,
+    e_SYS_SUBMODULE_IMA_GROUP,
+    e_SYS_SUBMODULE_IMA_LINK,
+    e_SYS_SUBMODULE_MTC_COMMON,
+    e_SYS_SUBMODULE_MTC,
+    e_SYS_SUBMODULE_MTC_UCC,
+    e_SYS_SUBMODULE_MTC_MCC,
+    e_SYS_SUBMODULE_MTC_MCC_COMMON,
+    e_SYS_SUBMODULE_IW_COMMON,
+    e_SYS_SUBMODULE_IW_DEV,
+    e_SYS_SUBMODULE_IW_CONN,
+    e_SYS_SUBMODULE_IW_CDESC,
+    e_SYS_SUBMODULE_IW_MCAST_GROUP,
+    e_SYS_SUBMODULE_IW_IP_REASS,
+    e_SYS_SUBMODULE_IW_PLCR,
+    e_SYS_SUBMODULE_IW_QM,
+    e_SYS_SUBMODULE_IW_IPSEC,
+    e_SYS_SUBMODULE_QE_FILTER,
+    e_SYS_SUBMODULE_QE_TABLE,
+    e_SYS_SUBMODULE_QE_RTC,
+    e_SYS_SUBMODULE_VP_DEV,
+    e_SYS_SUBMODULE_VP_PORT,
+    e_SYS_SUBMODULE_MII_MNG,
+    e_SYS_SUBMODULE_PTP,
+    e_SYS_SUBMODULE_SATA,
+    e_SYS_SUBMODULE_SERDES,
+    e_SYS_SUBMODULE_BM,
+    e_SYS_SUBMODULE_BM_PORTAL,
+    e_SYS_SUBMODULE_BM_CE_PORTAL,
+    e_SYS_SUBMODULE_BM_CI_PORTAL,
+    e_SYS_SUBMODULE_QM,
+    e_SYS_SUBMODULE_QM_PORTAL,
+    e_SYS_SUBMODULE_QM_CE_PORTAL,
+    e_SYS_SUBMODULE_QM_CI_PORTAL,
+    e_SYS_SUBMODULE_FM,
+    e_SYS_SUBMODULE_FM_MURAM,
+    e_SYS_SUBMODULE_FM_PORT_HO,
+    e_SYS_SUBMODULE_FM_PORT_10GRx,
+    e_SYS_SUBMODULE_FM_PORT_1GRx,
+    e_SYS_SUBMODULE_FM_PORT_10GTx,
+    e_SYS_SUBMODULE_FM_PORT_1GTx,
+    e_SYS_SUBMODULE_FM_PORT_10GMAC,
+    e_SYS_SUBMODULE_FM_PORT_1GMAC,
+    e_SYS_SUBMODULE_IW_IPHC_HC,
+    e_SYS_SUBMODULE_IW_IPHC_HDEC,
+    /* Must close the sub-modules list */
+    e_SYS_SUBMODULE_DUMMY_LAST
+
+} e_SysModule;
+
+/**************************************************************************//**
+ @Description   System Object Descriptor
+
+                This is the generic object descriptor for the system layout.
+                It contains only the module enumeration type, according to
+                which the system can decide whether this is a module descriptor
+                or a sub-module descriptor.
+*//***************************************************************************/
+typedef struct t_SysObjectDescriptor
+{
+    e_SysModule module; /**< Module/sub-module type */
+
+} t_SysObjectDescriptor;
+
+/**************************************************************************//**
+ @Description   Module initialization function (with no parameters)
+*//***************************************************************************/
+typedef t_Handle (t_SysModuleInitFuncNoParams)(void);
+
+/**************************************************************************//**
+ @Description   Module initialization function (with pointer to parameters)
+*//***************************************************************************/
+typedef t_Handle (t_SysModuleInitFuncWithParams)(void *p_ModuleParams);
+
+/**************************************************************************//**
+ @Description   System Module Descriptor
+
+                This structure should be used in the use case layout to request
+                initialization of a module object.
+
+                A module is by definition a singleton object, therefore no ID
+                is required in this structure.
+*//***************************************************************************/
+typedef struct t_SysModuleDescriptor
+{
+    e_SysModule module;                     /**< Module type */
+    void        *p_Settings;                /**< Pointer to the module's settings */
+
+    struct
+    {
+        union
+        {
+            t_SysModuleInitFuncNoParams     *f_InitNoParams;
+                                            /**< Module initialization routine (with no parameters) */
+            t_SysModuleInitFuncWithParams   *f_InitWithParams;
+                                            /**< Module initialization routine (with parameters) */
+        } cbs;
+        t_Error                             (*f_Free)(t_Handle h_Module);
+                                            /**< Module free routine */
+    } moduleInterface;
+
+} t_SysModuleDescriptor;
+
+
+/**************************************************************************//**
+ @Description   System Sub-Module Descriptor
+
+                This structure should be used in the use case layout to request
+                initialization of a sub-module object.
+
+                There may be multiple objects of the same sub-module type,
+                therefore the ID variable must be unique for each instance of
+                the same type.
+
+                The f_UpdateSettings callback routine and the idIncrement value
+                may be used to clone multiple objects of the same type. If the
+                callback is not NULL, the system shall call this routine to
+                generate a new settings structure for the next object, and then
+                initialize the object. The system will continue to invoke the
+                callback routine until a NULL pointer is returned. The callback
+                routine is responsible for allocating and freeing the cloned
+                settings structure. The original settings must not be modified.
+*//***************************************************************************/
+typedef struct t_SysSubModuleDescriptor
+{
+    e_SysModule module;             /**< Sub-module type */
+    uint64_t    id;                 /**< The sub-module ID */
+    void        *p_Settings;        /**< Pointer to the sub-module's settings */
+    void *      (*f_UpdateSettings)(uint64_t newId, void *p_OrigSettings, void *p_PrevSettings);
+                                    /**< Callback routine for cloning objects */
+    uint16_t    idIncrement;        /**< Amount by which to increment the
+                                         Sub-module ID when cloning objects */
+} t_SysSubModuleDescriptor;
+
+
+/**************************************************************************//**
+ @Collection    Object Identifier Macros
+ @{
+*//***************************************************************************/
+#define SYS_NULL_OBJECT_ID          0xFFFFFFFF
+                                    /**< Object ID representing no object */
+
+#define CAST_ID_TO_HANDLE(_id)      ((t_Handle)((uintptr_t)_id))
+                                    /**< Macro for casting an object ID to a handle */
+#define CAST_HANDLE_TO_ID(_h)       ((uintptr_t)(_h))
+                                    /**< Macro for casting a handle to an object ID */
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Macros for Advanced Configuration Requests
+ @{
+*//***************************************************************************/
+#define SYS_MAX_ADV_CONFIG_ARGS     4
+                                    /**< Maximum number of arguments in
+                                         an advanced confiuration entry */
+
+#define ADV_CONFIG_DONE             NULL, { 0 }
+                                    /**< Marks the end of an advanced
+                                         configuration requests array \hideinitializer */
+#define ADV_CONFIG_NONE             (t_SysObjectAdvConfigEntry[]){ {ADV_CONFIG_DONE} }
+                                    /**< Marks an empty advanced
+                                         configuration requests array \hideinitializer */
+/* @} */
+
+/**************************************************************************//**
+ @Description   System Object Advanced Configuration Entry
+
+                This structure represents a single request for an advanced
+                configuration call on the initialized object. An array of such
+                requests may be contained in the settings structure of the
+                corresponding object.
+
+                The maximum number of arguments is limited to #SYS_MAX_ADV_CONFIG_ARGS.
+*//***************************************************************************/
+typedef struct t_SysObjectAdvConfigEntry
+{
+    void        *p_Function;    /**< Pointer to advanced configuration routine */
+#if 0
+     /*@@@@ cannot use uint64_t (CW bug?) */
+#endif
+    uintptr_t    args[SYS_MAX_ADV_CONFIG_ARGS];
+                                /**< Array of arguments for the specified routine;
+                                     All arguments should be casted to uint32_t. */
+} t_SysObjectAdvConfigEntry;
+
+
+/** @} */ /* end of sys_gen_grp */
+
+/**************************************************************************//**
+ @Group         sys_app_grp     System Interface for Applications
+
+ @Description   Linux system programming interface for applications and
+                use cases.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Test Descriptor Text Length Limits
+ @{
+*//***************************************************************************/
+#define SYS_MAX_TEST_MODULE_NAME_LENGTH     32  /**< Maximum test module name length */
+#define SYS_MAX_TEST_GROUP_NAME_LENGTH      64  /**< Maximum test group name length */
+#define SYS_MAX_TEST_DESCRIPTION_LENGTH     128 /**< Maximum test description length */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Test Descriptor
+
+                This structure should be used in the use case layout to request
+                execution of a specific test.
+*//***************************************************************************/
+typedef struct t_SysTestDescriptor
+{
+    char        testModule[SYS_MAX_TEST_MODULE_NAME_LENGTH];
+                /**< Test module name */
+    char        testGroup[SYS_MAX_TEST_GROUP_NAME_LENGTH];
+                /**< Test group name */
+    uint16_t    testId;
+                /**< Test identifier */
+    char        description[SYS_MAX_TEST_DESCRIPTION_LENGTH];
+                /**< Test description */
+    t_Error     (*f_RunTest)(void *p_TestParam);
+                /**< Test routine */
+    void        (*f_KillTest)(void);
+                /**< Test termination routine */
+    void        *p_TestParam;
+                /**< Pointer to the test parameters structure */
+
+} t_SysTestDescriptor;
+
+
+/**************************************************************************//**
+ @Description   Runtime Layout Structure
+
+                This structure describes a requested runtime layout, and
+                contains both logical object descriptors and test descriptors.
+*//***************************************************************************/
+typedef struct t_SysRuntimeLayout
+{
+    t_SysObjectDescriptor   **p_LogicalObjects;     /**< Logical-layer object descriptors */
+    t_SysTestDescriptor     **p_TestDescriptors;    /**< Test descriptors */
+
+} t_SysRuntimeLayout;
+
+/**************************************************************************//**
+ @Description   Peripheral Layout Structure
+
+                This structure describes a peripheral layout, and contains both
+                peripheral object descriptors and an array of runtime layouts
+*//***************************************************************************/
+typedef struct t_SysPeripheralLayout
+{
+    t_SysObjectDescriptor   **p_PeripheralObjects;  /**< Peripheral-layer object descriptors */
+    t_SysRuntimeLayout      *p_RuntimeLayouts;      /**< An array of runtime layouts */
+
+} t_SysPeripheralLayout;
+
+/**************************************************************************//**
+ @Description   System Layout Structure
+
+                This structure describes a system layout, and contains both
+                system object descriptors and an array of peripheral layouts
+*//***************************************************************************/
+typedef struct t_SysSystemLayout
+{
+    t_SysObjectDescriptor   **p_SystemObjects;      /**< System-layer object descriptors */
+    t_SysPeripheralLayout   *p_PeripheralLayouts;   /**< An array of peripheral layouts */
+
+} t_SysSystemLayout;
+
+/**************************************************************************//**
+ @Description   Use Case Layout Structure
+
+                This structure describes a use case runtime layout, and
+                contains a pointer to the platform settings as well as an
+                array of system layouts.
+*//***************************************************************************/
+typedef struct t_SysUseCaseLayout
+{
+    t_SysObjectDescriptor   *p_PlatformObject;      /**< Platform object descriptor */
+    t_SysSystemLayout       *p_SystemLayouts;       /**< An array of system layouts */
+
+} t_SysUseCaseLayout;
+
+
+/**************************************************************************//**
+ @Collection    Macros for Building the Use Case Layout
+ @{
+*//***************************************************************************/
+#define SYS_SYSTEM_OBJECTS(...)     (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of system object descriptors \hideinitializer */
+#define SYS_PERIPHERAL_OBJECTS(...) (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of peripheral object descriptors \hideinitializer */
+#define SYS_LOGICAL_OBJECTS(...)    (t_SysObjectDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of logical object descriptors \hideinitializer */
+#define SYS_TEST_DESCRIPTORS(...)   (t_SysTestDescriptor*[]){ __VA_ARGS__, NULL }
+                                    /**< Defines an array of test descriptors \hideinitializer */
+
+#define SYS_BEGIN_SYSTEM_LAYOUTS \
+        (t_SysSystemLayout[]){      /**< Starts an array of system layout structures \hideinitializer */
+#define SYS_END_SYSTEM_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of system layout structures \hideinitializer */
+
+#define SYS_BEGIN_PERIPHERAL_LAYOUTS \
+        (t_SysPeripheralLayout[]){  /**< Starts an array of peripheral layout structures \hideinitializer */
+#define SYS_END_PERIPHERAL_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of peripheral layout structures \hideinitializer */
+
+#define SYS_BEGIN_RUNTIME_LAYOUTS \
+        (t_SysRuntimeLayout[]){     /**< Starts an array of runtime layout structures \hideinitializer */
+#define SYS_END_RUNTIME_LAYOUTS \
+        , { NULL, NULL } }          /**< Ends an array of runtime layout structures \hideinitializer */
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Macros for Defining a Module Interface
+ @{
+*//***************************************************************************/
+#define MODULE_INTERFACE_VOID_PARAM(_initFunc, _freeFunc) \
+    { .cbs.f_InitNoParams = (_initFunc), .f_Free = (_freeFunc) }
+                    /**< Defines a module interface (with no initialization parameters) \hideinitializer */
+
+#define MODULE_INTERFACE_WITH_PARAM(_initFunc, _freeFunc) \
+    { .cbs.f_InitWithParams = (t_SysModuleInitFuncWithParams *)(_initFunc), .f_Free = (_freeFunc) }
+                    /**< Defines a module interface (with initialization parameters) \hideinitializer */
+/* @} */
+
+typedef t_Error (t_UpdateSettingsFunc)(uint64_t id, void *p_SubmoduleSettings);
+
+
+/**************************************************************************//**
+ @Function      SYS_Init
+
+ @Description   System initialization routine.
+
+                This routine calls the SYS_InternalInit() routine to initialize
+                the internal system structures and services, such as memory
+                management, objects repository and more.
+
+ @Return        None.
+*//***************************************************************************/
+void SYS_Init(void);
+
+/**************************************************************************//**
+ @Function      SYS_Free
+
+ @Description   System termination routine.
+
+                This routine releases all internal structures that were
+                initialized by the SYS_Init() routine.
+
+ @Return        None.
+*//***************************************************************************/
+void SYS_Free(void);
+
+/**************************************************************************//**
+ @Function      SYS_RunLayout
+
+ @Description   Executes a given use case layout.
+
+                This routine may be called to process and execute a use case
+                layout structure. The user should pass a pointer to a valid
+                use case layout structure, and the system would initialize
+                the requested objects and execute the requested test routines.
+
+ @Param[in]     p_UcLayout - Pointer to use case layout structure.
+
+ @Return        Zero for success; Non-zero value on error.
+*//***************************************************************************/
+int SYS_RunLayout(t_SysUseCaseLayout *p_UcLayout);
+
+/**************************************************************************//**
+ @Function      SYS_GetHandle
+
+ @Description   Returns a specific object handle.
+
+                This routine may be used to get the handle of any module or
+                sub-module in the system.
+
+                For singleton objects, it is recommended to use the
+                SYS_GetUniqueHandle() routine.
+
+ @Param[in]     module  - Module/sub-module type.
+ @Param[in]     id      - For sub-modules, this is the unique object ID;
+                          For modules, this value must always be zero.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+t_Handle SYS_GetHandle(e_SysModule module, uint64_t id);
+
+/**************************************************************************//**
+ @Function      SYS_GetUniqueHandle
+
+ @Description   Returns a specific object handle (for singleton objects).
+
+                This routine may be used to get the handle of any singleton
+                module or sub-module in the system.
+
+                This routine simply calls the SYS_GetHandle() routine with
+                the \c id parameter set to zero.
+
+ @Param[in]     module - Module/sub-module type.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+static __inline__ t_Handle SYS_GetUniqueHandle(e_SysModule module)
+{
+    return SYS_GetHandle(module, 0);
+}
+
+/**************************************************************************//**
+ @Function      SYS_CreateObject
+
+ @Description   Initializes a module or sub-module using the information
+                provided in the object descriptor.
+
+ @Param[in]     p_ObjectDesc - Object descriptor.
+
+ @Return        E_OK in case of success; error code otherwise.
+*//***************************************************************************/
+t_Error SYS_CreateObject(t_SysObjectDescriptor *p_ObjectDesc);
+
+/**************************************************************************//**
+ @Function      SYS_FreeObject
+
+ @Description   Frees a module or sub-module.
+
+ @Param[in]     module  - Module/sub-module type.
+ @Param[in]     id      - For sub-modules, this is the unique object ID;
+                          For modules, this value must always be zero.
+
+ @Return        E_OK in case of success; error code otherwise.
+*//***************************************************************************/
+t_Error SYS_FreeObject(e_SysModule module, uint64_t id);
+
+/**************************************************************************//**
+ @Function      USER_BuildLayout
+
+ @Description   User-implemented routine for building the use case layout.
+
+                Any memory allocations in this routine must be released in the
+                USER_FreeLayout() routine.
+
+ @Return        Pointer to the use case layout; NULL on failure.
+*//***************************************************************************/
+t_SysUseCaseLayout * USER_BuildLayout(void);
+
+/**************************************************************************//**
+ @Function      USER_FreeLayout
+
+ @Description   User-implemented routine for freeing the use case layout.
+
+                This routine is called by the main routine in order to free
+                the use case layout before terminating the program.
+
+ @Param[in]     p_UseCaseLayout - Pointer to the use case layout to free.
+
+ @Return        None.
+*//***************************************************************************/
+void USER_FreeLayout(t_SysUseCaseLayout *p_UseCaseLayout);
+
+
+/**************************************************************************//**
+ @Function      USER_ModuleInit
+
+ @Description   User-implemented routine for system initialization. It calls
+                the necessary routines to build and run the use case layout.
+
+                This must be called from the kernel module's init routine.
+
+ @Return        0 on sucess, negative error code otherwise.
+*//***************************************************************************/
+int USER_ModuleInit(void);
+
+/**************************************************************************//**
+ @Function      USER_ModuleExit
+
+ @Description   User-implemented routine for freeing system resources. out.
+
+                This must be called from the kernel module's exit routine.
+
+ @Return        None.
+*//***************************************************************************/
+void USER_ModuleExit(void);
+
+/** @} */ /* end of sys_app_grp */
+
+/**************************************************************************//**
+ @Group         sys_mod_grp     System Interface for Modules
+
+ @Description   Linux system programming interface for modules (such as
+                wrappers and others).
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Sub-Modules Registration Parameters.
+
+                This structure provides registration parameters for a set of
+                sub-modules. Each module should register its own sub-modules
+                in the system using the SYS_RegisterSubModules() routine.
+*//***************************************************************************/
+typedef struct t_SysSubModuleRegisterParam
+{
+    e_SysModule owner;              /**< The type of the owner module */
+    uint8_t     numOfSubModules;    /**< Number of sub-modules in the \c p_SubModules array */
+    e_SysModule *p_SubModules;      /**< An array of sub-module types, of size \c numOfSubModules */
+    t_Error     (*f_InitSubModule)(t_Handle h_Module, t_SysSubModuleDescriptor *p_SubModuleDesc);
+                                    /**< Sub-modules initialization routine */
+    t_Error     (*f_FreeSubModule)(t_Handle h_Module, e_SysModule subModule, uint64_t id);
+                                    /**< Sub-modules free routine */
+    t_Handle    (*f_GetSubModule)(t_Handle h_Module, e_SysModule subModule, uint64_t id);
+                                    /**< Routine for retrieving sub-module handles */
+} t_SysSubModuleRegisterParam;
+
+/**************************************************************************//**
+ @Description   Sub-Modules Deregistration Parameters.
+
+                This structure provides deregistration parameters for a set of
+                sub-modules. Each module should deregister its own sub-modules
+                from the system during its termination and cleanup phase, using
+                the SYS_UnregisterSubModules() routine.
+*//***************************************************************************/
+typedef struct t_SysSubModuleUnregisterParam
+{
+    e_SysModule owner;              /**< The type of the owner module */
+    uint8_t     numOfSubModules;    /**< Number of sub-modules in the \c p_SubModules array */
+    e_SysModule *p_SubModules;      /**< An array of sub-module types, of size \c numOfSubModules */
+
+} t_SysSubModuleUnregisterParam;
+
+/**************************************************************************//**
+ @Function      SYS_RegisterSubModules
+
+ @Description   Registers a set of sub-modules as being owned by a given module.
+
+                This routine should be called by every system module in order
+                to register its sub-modules in the system. Without registration,
+                sub-modules cannot be initialized through the use case layout.
+
+ @Param[in]     p_RegParam - Pointer to registration parameters structure.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error SYS_RegisterSubModules(t_SysSubModuleRegisterParam *p_RegParam);
+
+/**************************************************************************//**
+ @Function      SYS_UnregisterSubModules
+
+ @Description   Unregisters a set of sub-modules from their owner module.
+
+                This routine should be called by every system module during
+                its termination and cleanup phase, in order to deregister its
+                sub-modules.
+
+ @Param[in]     p_UnregParam - Pointer to de-registration parameters structure.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error SYS_UnregisterSubModules(t_SysSubModuleUnregisterParam *p_UnregParam);
+
+/**************************************************************************//**
+ @Function      SYS_ForceHandle
+
+ @Description   Forces a handle for a specific object in the system.
+
+                This routine allows forcing an object handle into the system
+                and thus bypassing the normal initialization flow.
+
+                The forced handle must be removed as soon as it is not valid
+                anymore, using the SYS_RemoveForcedHandle() routine.
+
+ @Param[in]     module      - The object (module/sub-module) type.
+ @Param[in]     id          - Unique object ID;
+ @Param[in]     h_Module    - The object handle;
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine must not be used in normal flow - it serves only
+                rare and special cases in platform initialization.
+*//***************************************************************************/
+t_Error SYS_ForceHandle(e_SysModule module, uint64_t id, t_Handle h_Module);
+
+/**************************************************************************//**
+ @Function      SYS_RemoveForcedHandle
+
+ @Description   Removes a previously forced handle of a specific object.
+
+                This routine must be called to remove object handles that
+                were previously forced using the SYS_ForceHandle() routine.
+
+ @Param[in]     module      - The object (module/sub-module) type.
+ @Param[in]     id          - Unique object ID;
+
+ @Return        None.
+
+ @Cautions      This routine must not be used in normal flow - it serves only
+                rare and special cases in platform initialization.
+*//***************************************************************************/
+void SYS_RemoveForcedHandle(e_SysModule module, uint64_t id);
+
+/** @} */ /* end of sys_mod_grp */
+/** @} */ /* end of sys_grp */
+
+
+#define PARAMS(_num, _params)   ADV_CONFIG_PARAMS_##_num _params
+#define NO_PARAMS
+
+#define ADV_CONFIG_PARAMS_1(_type) \
+    , (_type)p_Entry->args[0]
+
+#define ADV_CONFIG_PARAMS_2(_type0, _type1) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1]
+
+#define ADV_CONFIG_PARAMS_3(_type0, _type1, _type2) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2]
+
+#define ADV_CONFIG_PARAMS_4(_type0, _type1, _type2, _type3) \
+    , (_type0)p_Entry->args[0], (_type1)p_Entry->args[1], (_type2)p_Entry->args[2], (_type3)p_Entry->args[3]
+
+
+#define SET_ADV_CONFIG_ARGS_1(_arg0)        \
+    p_Entry->args[0] = (uintptr_t )(_arg0);   \
+
+#define SET_ADV_CONFIG_ARGS_2(_arg0, _arg1) \
+    p_Entry->args[0] = (uintptr_t )(_arg0);   \
+    p_Entry->args[1] = (uintptr_t )(_arg1);   \
+
+#define SET_ADV_CONFIG_ARGS_3(_arg0, _arg1, _arg2)  \
+    p_Entry->args[0] = (uintptr_t )(_arg0);           \
+    p_Entry->args[1] = (uintptr_t )(_arg1);           \
+    p_Entry->args[2] = (uintptr_t )(_arg2);           \
+
+#define SET_ADV_CONFIG_ARGS_4(_arg0, _arg1, _arg2, _arg3)   \
+    p_Entry->args[0] = (uintptr_t )(_arg0);                   \
+    p_Entry->args[1] = (uintptr_t )(_arg1);                   \
+    p_Entry->args[2] = (uintptr_t )(_arg2);                   \
+    p_Entry->args[3] = (uintptr_t )(_arg3);                   \
+
+#define ARGS(_num, _params) SET_ADV_CONFIG_ARGS_##_num _params
+#define NO_ARGS
+
+#define ADD_ADV_CONFIG(_func, _param)       \
+    do {                                    \
+        if (i<max){                         \
+            p_Entry = &p_Entrys[i];         \
+            p_Entry->p_Function = _func;    \
+            _param                          \
+            i++;                            \
+        }                                   \
+        else                                \
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, \
+                         ("Number of advanced-configuration entries exceeded")); \
+    } while (0)
+
+#define ADD_ADV_CONFIG_FIND_LOCATION(_func)                                     \
+    for (i=0; TRUE; i++) {                                                      \
+        if (i == max)                                                           \
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,                                \
+                         ("Number of advanced-configuration entries exceeded"));\
+        p_Entry = &p_Entrys[i];                                             \
+        if (!p_Entry->p_Function || (p_Entry->p_Function == _func))         \
+            break;                                                          \
+    }                                                                       \
+
+#define ADD_ADV_CONFIG_START(_p_Entries, _maxEntries)           \
+    {                                                           \
+        t_SysObjectAdvConfigEntry   *p_Entry;                   \
+        t_SysObjectAdvConfigEntry   *p_Entrys = (_p_Entries);   \
+        int                         i=0, max = (_maxEntries);   \
+
+#define ADD_ADV_CONFIG_END \
+    }
+
+#define ADV_CONFIG_CHECK_START(_p_Entry)                        \
+    {                                                           \
+        t_SysObjectAdvConfigEntry   *p_Entry = _p_Entry;        \
+        t_Error                     errCode;                    \
+
+#define ADV_CONFIG_CHECK(_handle, _func, _params)               \
+        if (p_Entry->p_Function == _func)                       \
+        {                                                       \
+            errCode = _func(_handle _params);                   \
+        } else
+
+#define ADV_CONFIG_CHECK_END                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+            return NULL;                                        \
+        }                                                       \
+        if (errCode != E_OK)                                    \
+        {                                                       \
+            REPORT_ERROR(MAJOR, errCode, NO_MSG);               \
+            return NULL;                                        \
+        }                                                       \
+    }
+
+
+#endif /* __SYS_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/system/sys_io_ext.h b/drivers/net/dpa/NetCommSw/src/inc/system/sys_io_ext.h
new file mode 100644
index 0000000..3d9ce88
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/system/sys_io_ext.h
@@ -0,0 +1,46 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_IO_EXT_H
+#define __SYS_IO_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+t_Error  SYS_RegisterIoMap   (uint64_t virtAddr, uint64_t physAddr, uint32_t size);
+t_Error  SYS_UnregisterIoMap (uint64_t virtAddr);
+uint64_t SYS_PhysToVirt      (uint64_t addr);
+uint64_t SYS_VirtToPhys      (uint64_t addr);
+
+
+#endif /* __SYS_IO_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/types_linux.h b/drivers/net/dpa/NetCommSw/src/inc/types_linux.h
new file mode 100644
index 0000000..471a919
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/types_linux.h
@@ -0,0 +1,200 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TYPES_LINUX_H__
+#define __TYPES_LINUX_H__
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/io.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+    #error "This kernel is probably not supported!!!"
+#elif   (!((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,27)) || \
+           (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,30))))
+    #warning "This kernel is probably not supported!!! You may need to add some fixes."
+#endif    /* LINUX_VERSION_CODE */
+
+
+typedef float               float_t;    /* Single precision floating point  */
+typedef double              double_t;   /* Double precision floating point  */
+
+
+#define _Packed
+#define _PackedType __attribute__ ((packed))
+
+typedef  phys_addr_t physAddress_t;
+
+#define UINT8_MAX   0xFF
+#define UINT8_MIN   0
+#define UINT16_MAX  0xFFFF
+#define UINT16_MIN  0
+#define UINT32_MAX  0xFFFFFFFF
+#define UINT32_MIN  0
+#define UINT64_MAX  0xFFFFFFFFFFFFFFFFLL
+#define UINT64_MIN  0
+#define INT8_MAX    0x7F
+#define INT8_MIN    0x80
+#define INT16_MAX   0x7FFF
+#define INT16_MIN   0x8000
+#define INT32_MAX   0x7FFFFFFF
+#define INT32_MIN   0x80000000
+#define INT64_MAX   0x7FFFFFFFFFFFFFFFLL
+#define INT64_MIN   0x8000000000000000LL
+
+#define ON          1
+#define OFF         0
+
+#define FALSE       false
+#define TRUE        true
+
+
+/************************/
+/* memory access macros */
+/************************/
+#define GET_UINT8(arg)              *(volatile uint8_t *)(&(arg))
+#define GET_UINT16(arg)             in_be16(&(arg))//*(volatile uint16_t*)(&(arg))
+#define GET_UINT32(arg)             in_be32(&(arg))//*(volatile uint32_t*)(&(arg))
+#define GET_UINT64(arg)             *(volatile uint64_t*)(&(arg))
+
+#ifdef VERBOSE_WRITE
+void    XX_Print(char *str, ...);
+#define WRITE_UINT8(arg, data)  \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%02x\r\n",    (uint32_t)&(arg), (data)); *(volatile uint8_t *)(&(arg)) = (data); } while (0)
+#define WRITE_UINT16(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%04x\r\n",    (uint32_t)&(arg), (data)); out_be16(&(arg), data); /* *(volatile uint16_t*)(&(arg)) = (data);*/ } while (0)
+#define WRITE_UINT32(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%08x\r\n",    (uint32_t)&(arg), (data)); out_be32(&(arg), data); /* *(volatile uint32_t*)(&(arg)) = (data);*/ } while (0)
+#define WRITE_UINT64(arg, data) \
+    do { XX_Print("ADDR: 0x%08x, VAL: 0x%016llx\r\n", (uint32_t)&(arg), (data)); *(volatile uint64_t*)(&(arg)) = (data); } while (0)
+
+#else  /* not VERBOSE_WRITE */
+#define WRITE_UINT8(arg, data)      *(volatile uint8_t *)(&(arg)) = (data)
+#define WRITE_UINT16(arg, data)     out_be16(&(arg), data)//*(volatile uint16_t*)(&(arg)) = (data)
+#define WRITE_UINT32(arg, data)     out_be32(&(arg), data)//*(volatile unsigned int *)(&(arg)) = (data)
+#define WRITE_UINT64(arg, data)     *(volatile uint64_t*)(&(arg)) = (data)
+#endif /* not VERBOSE_WRITE */
+
+
+/*****************************************************************************/
+/*                      General stuff                                        */
+/*****************************************************************************/
+#ifdef ARRAY_SIZE
+#undef ARRAY_SIZE
+#endif /* ARRAY_SIZE */
+
+#ifdef MAJOR
+#undef MAJOR
+#endif /* MAJOR */
+
+#ifdef MINOR
+#undef MINOR
+#endif /* MINOR */
+
+#ifdef QE_SIZEOF_BD
+#undef QE_SIZEOF_BD
+#endif /* QE_SIZEOF_BD */
+
+#ifdef BD_BUFFER_CLEAR
+#undef BD_BUFFER_CLEAR
+#endif /* BD_BUFFER_CLEAR */
+
+#ifdef BD_BUFFER
+#undef BD_BUFFER
+#endif /* BD_BUFFER */
+
+#ifdef BD_STATUS_AND_LENGTH_SET
+#undef BD_STATUS_AND_LENGTH_SET
+#endif /* BD_STATUS_AND_LENGTH_SET */
+
+#ifdef BD_STATUS_AND_LENGTH
+#undef BD_STATUS_AND_LENGTH
+#endif /* BD_STATUS_AND_LENGTH */
+
+#ifdef BD_BUFFER_ARG
+#undef BD_BUFFER_ARG
+#endif /* BD_BUFFER_ARG */
+
+#ifdef BD_GET_NEXT
+#undef BD_GET_NEXT
+#endif /* BD_GET_NEXT */
+
+#ifdef QE_SDEBCR_BA_MASK
+#undef QE_SDEBCR_BA_MASK
+#endif /* QE_SDEBCR_BA_MASK */
+
+#ifdef BD_BUFFER_SET
+#undef BD_BUFFER_SET
+#endif /* BD_BUFFER_SET */
+
+#ifdef UPGCR_PROTOCOL
+#undef UPGCR_PROTOCOL
+#endif /* UPGCR_PROTOCOL */
+
+#ifdef UPGCR_TMS
+#undef UPGCR_TMS
+#endif /* UPGCR_TMS */
+
+#ifdef UPGCR_RMS
+#undef UPGCR_RMS
+#endif /* UPGCR_RMS */
+
+#ifdef UPGCR_ADDR
+#undef UPGCR_ADDR
+#endif /* UPGCR_ADDR */
+
+#ifdef UPGCR_DIAG
+#undef UPGCR_DIAG
+#endif /* UPGCR_DIAG */
+
+#ifdef PARAMS
+#undef PARAMS
+#endif /* PARAMS */
+
+#ifdef NO_IRQ
+#undef NO_IRQ
+#endif /* NO_IRQ */
+
+#define PRINT_LINE   XX_Print("%s:\n %s [%d]\n",__FILE__,__FUNCTION__,__LINE__);
+
+
+#endif /* __TYPES_LINUX_H__ */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman.h b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman.h
new file mode 100644
index 0000000..bd86e64
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman.h
@@ -0,0 +1,272 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman.h
+
+ @Description   Linux internal kernel API
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_H
+#define __FSL_FMAN_H
+
+#include <linux/types.h>
+#include <linux/device.h>   /* struct device */
+#include <linux/fsl_qman.h> /* struct qman_fq */
+#include "dpaa_integration_ext.h"
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                Internal Kernel Control Unit API
+ @{
+*//***************************************************************************/
+
+/*****************************************************************************/
+/*                  Internal Linux kernel routines                           */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm;
+
+/**************************************************************************//**
+ @Description   A structure ..,
+*//***************************************************************************/
+struct fm_port;
+
+typedef int (*alloc_pcd_fqids)(struct device    *dev,
+                               uint32_t         num,
+                               uint8_t          alignment,
+                               uint32_t         *base_fqid);
+
+struct fm_port_pcd_param {
+    alloc_pcd_fqids         cb;
+    struct device           *dev;
+};
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+struct fm_port_pool_param {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+struct fm_port_rx_params {
+    uint32_t                    errq;               /**< Error Queue Id. */
+    uint32_t                    defq;               /**< Default Queue Id.  */
+    uint8_t                     num_pools;          /**< Number of pools use by this port */
+    struct fm_port_pool_param   pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                    /**< Parameters for each pool */
+    uint16_t                    priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                        parse_results;      /**< Whether to have the parser-results in the Received buffer */
+    bool                        hash_results;       /**< Whether to have the hash-results in the Received buffer */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+struct fm_port_non_rx_params {
+    uint32_t                errq;               /**< Error Queue Id. */
+    uint32_t                defq;               /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint16_t                priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    bool                    parse_results;      /**< Whether to put the parser-results in the Transmitted buffer */
+    bool                    hash_results;       /**< Whether to have the hash-results in the Received buffer */
+};
+
+
+/**************************************************************************//**
+ @Function      fm_bind
+
+ @Description   Bind to a specific FM device.
+
+ @Param[in]     fm_dev  - the OF handle of the FM device.
+
+ @Return        A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm * fm_bind (struct device *fm_dev);
+
+/**************************************************************************//**
+ @Function      fm_unbind
+
+ @Description   Un-bind from a specific FM device.
+
+ @Param[in]     fm      - A handle of the FM device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_unbind(struct fm *fm);
+
+void * fm_get_handle(struct fm *fm);
+struct resource * fm_get_mem_region(struct fm *fm);
+
+/**************************************************************************//**
+ @Function      fm_port_bind
+
+ @Description   Bind to a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     fm_port_dev - the OF handle of the FM port device.
+
+ @Return        A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+struct fm_port * fm_port_bind (struct device *fm_port_dev);
+
+/**************************************************************************//**
+ @Function      fm_port_unbind
+
+ @Description   Un-bind from a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only after the port was created.
+*//***************************************************************************/
+void fm_port_unbind(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_rx_port_params
+
+ @Description   Configure parameters for a specific Rx FM-port device.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Rx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_pcd_bind
+
+ @Description   Bind as a listener on a port PCD.
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - PCD port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
+
+/**************************************************************************//**
+ @Function      fm_get_tx_port_channel
+
+ @Description   Get qman-channel number for this Tx port.
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Return        qman-channel number for this Tx port.
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+int fm_get_tx_port_channel(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_set_tx_port_params
+
+ @Description   Configure parameters for a specific Tx FM-port device
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[in]     params      - Tx port parameters
+
+ @Cautions      Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params);
+
+/**************************************************************************//**
+ @Function      fm_port_enable
+
+ @Description   Enable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+int fm_port_enable (struct fm_port *port);
+
+/**************************************************************************//**
+ @Function      fm_port_disable
+
+ @Description   Disable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]     port        - A handle of the FM port device.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+void fm_port_disable(struct fm_port *port);
+
+void * fm_port_get_handle(struct fm_port *port);
+
+/**************************************************************************//**
+ @Description   Get base address of this port. Useful for accessing
+                port-specific registers (i.e., not common ones).
+
+ @Param[in]     port        - A handle of the FM port device.
+ @Param[out]    base_addr   - The port's base addr (virtual address).
+*//***************************************************************************/
+void fm_port_get_base_addr(const struct fm_port *port, uint64_t *base_addr);
+
+/**************************************************************************//**
+ @Description   Lock function required before any FMD/LLD call.
+*//***************************************************************************/
+void fm_mutex_lock(void);
+
+/**************************************************************************//**
+ @Description   Unlock function required after any FMD/LLD call.
+*//***************************************************************************/
+void fm_mutex_unlock(void);
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __FSL_FMAN_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman_test.h b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman_test.h
new file mode 100644
index 0000000..67a76b1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/fsl_fman_test.h
@@ -0,0 +1,83 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fsl_fman_test.h
+
+ @Description
+*//***************************************************************************/
+
+#ifndef __FSL_FMAN_TEST_H
+#define __FSL_FMAN_TEST_H
+
+#include <linux/types.h>
+
+
+#define FMT_RX_ERR_Q    0xffffffff
+#define FMT_RX_DFLT_Q   0xfffffffe
+#define FMT_TX_ERR_Q    0xfffffffd
+#define FMT_TX_CONF_Q   0xfffffffc
+
+
+/**************************************************************************//**
+ @Function      is_fman_test
+
+ @Description   Check if arriving frame belong to the test
+
+ @Param[in]     mac_dev - TODO
+ @Param[in]     queueId - TODO
+ @Param[in]     buffer  - A pointer to the buffer to check.
+ @Param[in]     size    - size of the given buffer.
+
+ @Return        true if this buffer belongs to FMan test application; false otherwise.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size);
+
+/**************************************************************************//**
+ @Function      fman_test_ip_manip
+
+ @Description   IP header manipulation
+
+ @Param[in]     mac_dev - TODO
+ @Param[in]     data    - A pointer to the data (payload) to manipulate.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+void fman_test_ip_manip (void *mac_dev, uint8_t *data);
+
+
+#endif /* __FSL_FMAN_TEST_H */
diff --git a/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
new file mode 100644
index 0000000..4967561
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -0,0 +1,162 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          lnxwrp_fm_ext.h
+
+ @Description   TODO
+*//***************************************************************************/
+
+#ifndef __LNXWRP_FM_EXT_H
+#define __LNXWRP_FM_EXT_H
+
+#include "std_ext.h"
+#include "sys_ext.h"
+#include "fm_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#include "fm_mac_ext.h"
+#include "fm_rtc_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description   FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_init_grp Initialization Unit
+
+ @Description   Initialization Unit
+
+                Initialization Flow:
+                Initialization of the FM Module will be carried out by the Linux
+                kernel according to the following sequence:
+                a. Calling the initialization routine with no parameters.
+                b. The driver will register to the Device-Tree.
+                c. The Linux Device-Tree will initiate a call to the driver for
+                   initialization.
+                d. The driver will read the appropriate information from the Device-Tree
+                e. [Optional] Calling the advance initialization routines to change
+                   driver's defaults.
+                f. Initialization of the device will be automatically upon using it.
+
+ @{
+*//***************************************************************************/
+
+typedef struct t_WrpFmDevSettings
+{
+    t_FmParams                  param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmDevSettings;
+
+typedef struct t_WrpFmPcdDevSettings
+{
+    t_FmPcdParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPcdDevSettings;
+
+typedef struct t_WrpFmPortDevSettings
+{
+    t_FmPortParams              param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmPortDevSettings;
+
+typedef struct t_WrpFmMacDevSettings
+{
+    t_FmMacParams               param;
+    t_SysObjectAdvConfigEntry   *advConfig;
+} t_WrpFmMacDevSettings;
+
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Init
+
+ @Description   Initialize the FM linux wrapper.
+
+ @Return        A handle (descriptor) of the newly created FM Linux wrapper
+                structure.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_Init(void);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_Free
+
+ @Description   Free the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  LNXWRP_FM_Free(t_Handle h_LnxWrpFm);
+
+/**************************************************************************//**
+ @Function      LNXWRP_FM_GetMacHandle
+
+ @Description   Get the FM-MAC LLD handle from the FM linux wrapper.
+
+ @Param[in]     h_LnxWrpFm   - A handle to the FM linux wrapper.
+ @Param[in]     fmId         - Index of the FM device to get the MAC handle from.
+ @Param[in]     macId        - Index of the mac handle.
+
+ @Return        A handle of the LLD compressor.
+*//***************************************************************************/
+t_Handle LNXWRP_FM_GetMacHandle(t_Handle h_LnxWrpFm, uint8_t fmId, uint8_t macId);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+t_Handle LNXWRP_FM_TEST_Init(void);
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+/** @} */ /* end of FM_LnxKern_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_LnxKern_ctrl_grp Control Unit
+
+ @Description   Control Unit
+
+                TODO
+ @{
+*//***************************************************************************/
+
+#include "fsl_fman.h"
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __LNXWRP_FM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/Makefile b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/Makefile
new file mode 100644
index 0000000..07f8c41
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fmm.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/fmm.c b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/fmm.c
new file mode 100644
index 0000000..a62a5ee
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/fmm.c
@@ -0,0 +1,205 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fmm.c
+
+ @Description   FM module
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+#include <linux/uts.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <asm/pgtable.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "sys_ext.h"
+#include "platform_p4080_ds_ext.h"
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_P4080
+
+
+#define DRIVER_AUTHOR   "Shlomi Gridish"
+#define DRIVER_DESC     "Frame Manager module"
+#define DRIVER_INFO     DRIVER_DESC
+
+
+MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_LICENSE ("Dual BSD/GPL");
+
+
+typedef struct {
+    t_Handle                    h_Pltfrm;
+    t_Handle                    h_FmLnxWrp;
+#ifdef CONFIG_FSL_FMAN_TEST
+    t_Handle                    h_FmTestLnxWrp;
+#endif /* CONFIG_FSL_FMAN_TEST */
+} t_NcswModule;
+
+
+#ifdef MODULE
+extern int  __init __cold port_wrapper_load(void);
+extern void __exit __cold port_wrapper_unload(void);
+extern int  __init __cold mac_load(void);
+extern void __exit __cold mac_unload(void);
+extern int  __init __cold dpa_load(void);
+extern void __exit __cold dpa_unload(void);
+#endif /* MODULE */
+
+
+static t_NcswModule mod;
+
+
+#if 0
+static t_Handle ModGetObject (t_Handle h_App, e_SysModule mod, ...)
+{
+    t_NcswModule    *p_Mod = (t_NcswModule *)h_App;
+    t_Handle        obj = NULL;
+    va_list         args;
+    int             index;
+
+    va_start(args, mod);
+    index = va_arg(args, int);
+
+    switch (mod)
+    {
+        case e_SYS_MODULE_PLATFORM:
+            if (index == 0)
+                obj = p_Mod->sys.p_Descriptors[e_DESC_INTEG];
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("device-type!!!"));
+            break;
+    }
+    va_end(args);
+
+    if (!obj)
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, ("device [%d,%d]!!!", mod,index));
+    return obj;
+}
+#endif /* 0 */
+
+static void FreeInitResources(t_NcswModule *p_Mod)
+{
+#ifdef CONFIG_FSL_FMAN_TEST
+    if (p_Mod->h_FmTestLnxWrp)
+        LNXWRP_FM_TEST_Free(p_Mod->h_FmTestLnxWrp);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    if (p_Mod->h_FmLnxWrp)
+        LNXWRP_FM_Free(p_Mod->h_FmLnxWrp);
+
+    PLATFORM_Free(&p_Mod->h_Pltfrm);
+}
+
+/*-------------------------------------------------------------------------*/
+static int __init __cold fm_load (void)
+{
+    t_PlatformParam     platformParam;
+
+    memset(&platformParam, 0, sizeof(platformParam));
+    if ((mod.h_Pltfrm = PLATFORM_Init(&platformParam)) == NULL)
+    {
+        printk("Failed to init general modules!\n");
+        return -ENODEV;
+    }
+
+    if ((mod.h_FmLnxWrp = LNXWRP_FM_Init()) == NULL)
+    {
+        printk("Failed to init FM wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+
+#ifdef MODULE
+    if (port_wrapper_load() || mac_load() || dpa_load())
+    {
+        printk("Failed to init port-wrapper or MAC or DPA driver!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* MODULE */
+
+#ifdef CONFIG_FSL_FMAN_TEST
+    if ((mod.h_FmTestLnxWrp = LNXWRP_FM_TEST_Init()) == NULL)
+    {
+        printk("Failed to init FM-test wrapper!\n");
+        FreeInitResources(&mod);
+        return -ENODEV;
+    }
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    printk (KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")\n");
+
+    return 0;
+}
+
+static void __exit __cold fm_unload (void)
+{
+#ifdef MODULE
+    dpa_unload();
+    mac_unload();
+    port_wrapper_unload();
+#endif /* MODULE */
+
+    FreeInitResources(&mod);
+}
+
+module_init (fm_load);
+module_exit (fm_unload);
diff --git a/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/mod_config.h b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/mod_config.h
new file mode 100644
index 0000000..4715ac6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/modules/integrations/P4080/FM/mod_config.h
@@ -0,0 +1,41 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __SYS_CONFIG_H
+#define __SYS_CONFIG_H
+
+
+/* System & Platform Modules */
+#define SYS_CFG_FM          ON
+
+
+#endif /* __SYS_CONFIG_H */
diff --git a/drivers/net/dpa/NetCommSw/src/system/Makefile b/drivers/net/dpa/NetCommSw/src/system/Makefile
new file mode 100644
index 0000000..441eda1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/system/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+
+obj-y		+= sys_io.o
+
+
+obj-y		+= platform/P4080/
diff --git a/drivers/net/dpa/NetCommSw/src/system/platform/P4080/Makefile b/drivers/net/dpa/NetCommSw/src/system/platform/P4080/Makefile
new file mode 100644
index 0000000..5605157
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/system/platform/P4080/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= platform_p4080_ds.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/system/platform/P4080/platform_p4080_ds.c b/drivers/net/dpa/NetCommSw/src/system/platform/P4080/platform_p4080_ds.c
new file mode 100644
index 0000000..5037441
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/system/platform/P4080/platform_p4080_ds.c
@@ -0,0 +1,122 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <sysdev/fsl_soc.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "part_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sys_io_ext.h"
+#include "platform_p4080_ds_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct t_Platform
+{
+    /* Platform-owned module handles */
+    t_Handle                h_Part;
+    /* Clocks-related variables */
+    uint32_t                clockInFreqHz;
+    uint32_t                localBusFreqHz;
+} t_Platform;
+
+#if 0
+uint64_t ram_virt_addr;
+uint64_t ram_phys_addr;
+uint64_t ram_size;
+#endif
+
+t_Handle PLATFORM_Init(t_PlatformParam *p_PlatformParam)
+{
+    t_Platform *p_Platform = NULL;
+
+    SANITY_CHECK_RETURN_VALUE(p_PlatformParam, E_NULL_POINTER, NULL);
+
+    /* Allocate the platform's control structure */
+    p_Platform = XX_Malloc(sizeof(t_Platform));
+    if (!p_Platform)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Platform structure"));
+        return NULL;
+    }
+    memset(p_Platform, 0, sizeof(t_Platform));
+
+    /* Are these ok for all platforms? For ram, let's base on the system mapping. */
+#if 0
+    ram_virt_addr = (uintptr_t)phys_to_virt(0);
+    ram_phys_addr = 0x0;
+    ram_size      = 0x20000000;
+    if (SYS_RegisterIoMap((uint64_t)ram_virt_addr, (uint64_t)ram_phys_addr, ram_size) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("RAM memory map"));
+        return NULL;
+    }
+#endif
+    return p_Platform;
+}
+
+t_Error PLATFORM_Free(t_Handle h_Platform)
+{
+    t_Platform *p_Platform = (t_Platform *)h_Platform;
+
+    if (!p_Platform)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+#if 0
+    SYS_UnregisterIoMap((uint64_t)ram_virt_addr);
+#endif
+    XX_Free(p_Platform);
+
+    return E_OK;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/src/system/sys_io.c b/drivers/net/dpa/NetCommSw/src/system/sys_io.c
new file mode 100644
index 0000000..a97371b
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/system/sys_io.c
@@ -0,0 +1,189 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "list_ext.h"
+#include "sys_io_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+
+typedef struct {
+    uint64_t    virtAddr;
+    uint64_t    physAddr;
+    uint32_t    size;
+    t_List      node;
+} t_IoMap;
+#define IOMAP_OBJECT(ptr)  LIST_OBJECT(ptr, t_IoMap, node)
+
+LIST(mapsList);
+
+
+static void EnqueueIoMap(t_IoMap *p_IoMap)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_IoMap->node, &mapsList);
+    XX_RestoreAllIntr(intFlags);
+}
+
+#if 0
+static t_IoMap * DequeueIoMap(void)
+{
+    t_IoMap     *p_IoMap = NULL;
+    uint32_t    intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&mapsList))
+    {
+        p_IoMap = IOMAP_OBJECT(mapsList.p_Next);
+        LIST_DelAndInit(&p_IoMap->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_IoMap;
+}
+#endif /* 0 */
+
+static t_IoMap * FindIoMapByVirtAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->virtAddr) && (addr < p_IoMap->virtAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+static t_IoMap * FindIoMapByPhysAddr(uint64_t addr)
+{
+    t_IoMap     *p_IoMap;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &mapsList)
+    {
+        p_IoMap = IOMAP_OBJECT(p_Pos);
+        if ((addr >= p_IoMap->physAddr) && (addr < p_IoMap->physAddr+p_IoMap->size))
+            return p_IoMap;
+    }
+
+    return NULL;
+}
+
+t_Error SYS_RegisterIoMap (uint64_t virtAddr, uint64_t physAddr, uint32_t size)
+{
+    t_IoMap *p_IoMap;
+
+    p_IoMap = (t_IoMap*)XX_Malloc(sizeof(t_IoMap));
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_IoMap, 0, sizeof(t_IoMap));
+
+    p_IoMap->virtAddr = virtAddr;
+    p_IoMap->physAddr = physAddr;
+    p_IoMap->size     = size;
+
+    INIT_LIST(&p_IoMap->node);
+    EnqueueIoMap(p_IoMap);
+
+    return E_OK;
+}
+
+t_Error SYS_UnregisterIoMap  (uint64_t virtAddr)
+{
+    t_IoMap *p_IoMap = FindIoMapByVirtAddr(virtAddr);
+    if (!p_IoMap)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_IoMap->node);
+    XX_Free(p_IoMap);
+
+    return E_OK;
+}
+
+uint64_t SYS_PhysToVirt(uint64_t addr)
+{
+    t_IoMap *p_IoMap = FindIoMapByPhysAddr(addr);
+    if (p_IoMap)
+    {
+        /* This is optimization - put the latest in the list-head - like a cache */
+        if (mapsList.p_Next != &p_IoMap->node)
+        {
+            uint32_t intFlags = XX_DisableAllIntr();
+            LIST_DelAndInit(&p_IoMap->node);
+            LIST_Add(&p_IoMap->node, &mapsList);
+            XX_RestoreAllIntr(intFlags);
+        }
+        return (uint64_t)(addr - p_IoMap->physAddr + p_IoMap->virtAddr);
+    }
+    return PTR_TO_UINT(phys_to_virt((unsigned long)addr));
+}
+
+uint64_t SYS_VirtToPhys(uint64_t addr)
+{
+    t_IoMap *p_IoMap;
+
+    if (addr == 0)
+        return 0;
+
+    p_IoMap = FindIoMapByVirtAddr(addr);
+    if (p_IoMap)
+        return (uint64_t)(addr - p_IoMap->virtAddr + p_IoMap->physAddr);
+    return (uint64_t)virt_to_phys(UINT_TO_PTR(addr));
+}
diff --git a/drivers/net/dpa/NetCommSw/src/util/Makefile b/drivers/net/dpa/NetCommSw/src/util/Makefile
new file mode 100644
index 0000000..7edbea6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/util/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= procbuff.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/util/procbuff.c b/drivers/net/dpa/NetCommSw/src/util/procbuff.c
new file mode 100644
index 0000000..f79f144
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/util/procbuff.c
@@ -0,0 +1,121 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "stdarg_ext.h"
+#include "xx_ext.h"
+
+#include "procbuff.h"
+
+
+t_Handle    ProcBuff_Init(char *buffer,char **start,int offset,int length, int *eof)
+{
+    t_ProcBuff  * p_ProcBuff = XX_Malloc(sizeof(t_ProcBuff));
+
+    if (p_ProcBuff)
+    {
+        p_ProcBuff->num_of_written_chars = 0;
+        p_ProcBuff->buffer = buffer;
+        p_ProcBuff->offset = offset;
+        p_ProcBuff->length = length;
+        p_ProcBuff->eof = eof;
+
+        if(start)
+            *start = buffer;
+        *(p_ProcBuff->eof) = 0;
+    }
+
+    return (t_Handle)(p_ProcBuff);
+}
+
+void        ProcBuff_Free (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    XX_Free(p_ProcBuff);
+}
+
+void         ProcBuff_Write (t_Handle h_ProcBuff,const char *fmt, ...)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+    int         len;
+    va_list     args;
+    char        *str = NULL;
+
+    str = XX_Malloc(MAX_LINE_SIZE);
+    if (!str) {
+        return;
+    }
+    va_start(args, fmt);
+    len=vsnprintf(str,MAX_LINE_SIZE,fmt,args);
+    va_end(args);
+
+    if (len == -1 || len >= MAX_LINE_SIZE)
+    {
+        /* formated string truncated, it is to big to fit into the MAX_LINE_SIZE */
+        len = MAX_LINE_SIZE - 1;
+        str[len] = 0;
+    }
+
+    if (len <= p_ProcBuff->offset)
+        p_ProcBuff->offset -= len;
+    else
+    {
+        len -= p_ProcBuff->offset;
+        if (len > p_ProcBuff->length)
+            len = p_ProcBuff->length;
+        strncpy(p_ProcBuff->buffer,str + p_ProcBuff->offset,(unsigned int)(len));
+
+        p_ProcBuff->buffer += len;
+        p_ProcBuff->length -= len;
+        if (p_ProcBuff->offset)
+            p_ProcBuff->offset = 0;
+        p_ProcBuff->num_of_written_chars += len;
+    }
+    XX_Free(str);
+}
+
+int          ProcBuff_GetNumOfWrittenChars(t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    return p_ProcBuff->num_of_written_chars;
+}
+
+void         ProcBuff_Done (t_Handle h_ProcBuff)
+{
+    t_ProcBuff  * p_ProcBuff = (t_ProcBuff *)(h_ProcBuff);
+
+    if (p_ProcBuff->length)
+        *(p_ProcBuff->eof) = 1;
+}
diff --git a/drivers/net/dpa/NetCommSw/src/util/procbuff.h b/drivers/net/dpa/NetCommSw/src/util/procbuff.h
new file mode 100644
index 0000000..6a3608e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/util/procbuff.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PROCBUFF_H
+#define __PROCBUFF_H
+
+#include "procbuff_ext.h"
+
+
+typedef struct t_ProcBuff {
+    int     num_of_written_chars;
+    char    *buffer;
+    int     length;
+    int     *eof;
+    int     offset;
+} t_ProcBuff;
+
+
+#endif /* __PROCBUFF_H */
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/Makefile
new file mode 100644
index 0000000..4cbf247
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+EXTRA_CFLAGS += -I$(NET_DPA)
+
+obj-y		+= fsl-ncsw-PFM.o
+obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
+
+fsl-ncsw-PFM-objs	:=   lnxwrp_fm.o lnxwrp_fm_ioctls.o
+obj-$(CONFIG_COMPAT)     +=   lnxwrp_fm_compat_ioctls.o
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fm_compat_ioctls.h b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fm_compat_ioctls.h
new file mode 100644
index 0000000..842ef33
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fm_compat_ioctls.h
@@ -0,0 +1,377 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_compat_ioctls.h
+
+ @Description   FM PCD compat structures definition.
+*//***************************************************************************/
+#ifndef __FM_COMPAT_IOCTLS_H
+#define __FM_COMPAT_IOCTLS_H
+
+#include <linux/compat.h>
+
+#define COMPAT_K_TO_US 0 /* copy from Kernel to User */
+#define COMPAT_US_TO_K 1 /* copy from User to Kernel */
+
+#define COMPAT_COPY_K2US(dest, src, type)	compat_copy_##type(src, dest, 0)
+#define COMPAT_COPY_US2K(dest, src, type)	compat_copy_##type(dest, src, 1)
+
+/* maping kernel pointers w/ UserSpace id's { */
+/* Because compat_ptr(ptr_to_compat(X)) != X, this way we cannot exchange pointers
+   back and forth (US - KS). compat_ptr is a cast and pointers are broken. */
+#define COMPAT_PTR2ID_ARRAY_MAX (256+1) /* first location is not used */
+#define COMPAT_PTR2ID_WATERMARK 0xface0000
+#define COMPAT_PTR2ID_WM_MASK   0xffff0000
+
+void compat_del_ptr2id(void *p);
+compat_uptr_t compat_add_ptr2id(void *p);
+compat_uptr_t compat_get_ptr2id(void *p);
+void *compat_get_id2ptr(compat_uptr_t comp);
+/* } maping kernel pointers w/ UserSpace id's  */
+
+/* pcd compat structures { */
+typedef struct ioc_compat_fm_pcd_cc_node_remove_key_params_t {
+    compat_uptr_t                       id;
+    uint8_t                             key_indx;
+} ioc_compat_fm_pcd_cc_node_remove_key_params_t;
+
+typedef union ioc_compat_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_done_action     action;
+        compat_uptr_t              p_profile;
+        compat_uptr_t              p_direct_scheme;
+} ioc_compat_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct ioc_compat_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;
+            compat_uptr_t                       p_port;
+            uint16_t                            relative_profile_id;
+        } new_params;
+        compat_uptr_t                           p_profile;
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;
+    ioc_fm_pcd_plcr_color_mode                  color_mode;
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;
+        ioc_fm_pcd_plcr_color                   override;
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;
+
+    ioc_fm_pcd_engine                           next_engine_on_green;
+    ioc_compat_fm_pcd_plcr_next_engine_params_u params_on_green;
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;
+    ioc_compat_fm_pcd_plcr_next_engine_params_u params_on_yellow;
+
+    ioc_fm_pcd_engine                           next_engine_on_red;
+    ioc_compat_fm_pcd_plcr_next_engine_params_u params_on_red;
+
+    bool                                        trap_profile_on_flow_A;
+    bool                                        trap_profile_on_flow_B;
+    bool                                        trap_profile_on_flow_C;
+    compat_uptr_t                               id;
+} ioc_compat_fm_pcd_plcr_profile_params_t;
+
+typedef struct ioc_compat_fm_obj_t {
+    compat_uptr_t obj;
+} ioc_compat_fm_obj_t;
+
+typedef struct ioc_compat_fm_pcd_kg_scheme_select_t {
+    bool          direct;
+    compat_uptr_t scheme_id;
+} ioc_compat_fm_pcd_kg_scheme_select_t;
+
+typedef struct ioc_compat_fm_pcd_port_schemes_params_t {
+    uint8_t        num_of_schemes;
+    compat_uptr_t  schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+} ioc_compat_fm_pcd_port_schemes_params_t;
+
+typedef struct ioc_compat_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* same structure*/
+    compat_uptr_t                   id;
+} ioc_compat_fm_pcd_net_env_params_t;
+
+typedef struct ioc_compat_fm_pcd_prs_sw_params_t {
+    bool                            override;
+    uint32_t                        size;
+    uint16_t                        base;
+    compat_uptr_t                   p_code;
+    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+    uint8_t                         num_of_labels;
+    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+} ioc_compat_fm_pcd_prs_sw_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_next_kg_params_t {
+    bool          override_fqid;
+    uint32_t      new_fqid;
+    compat_uptr_t p_direct_scheme;
+} ioc_compat_fm_pcd_cc_next_kg_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_next_cc_params_t {
+    compat_uptr_t        cc_node_id;
+} ioc_compat_fm_pcd_cc_next_cc_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                                  next_engine;
+    union {
+            ioc_compat_fm_pcd_cc_next_cc_params_t      cc_params;      /**< compat structure*/
+            ioc_fm_pcd_cc_next_plcr_params_t           plcr_params;    /**< same structure*/
+            ioc_fm_pcd_cc_next_enqueue_params_t        enqueue_params; /**< same structure*/
+            ioc_compat_fm_pcd_cc_next_kg_params_t      kg_params;      /**< compat structure*/
+    } params;
+#ifdef FM_PCD_CC_MANIP
+    compat_uptr_t                                      p_manip;
+#endif
+} ioc_compat_fm_pcd_cc_next_engine_params_t;
+
+
+typedef struct ioc_compat_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics */
+    ioc_compat_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                    /**< Max size is 16 - if only one group used */
+} ioc_compat_fm_pcd_cc_grp_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_tree_params_t {
+    compat_uptr_t                   net_env_id;
+    uint8_t                         num_of_groups;
+    ioc_compat_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+    compat_uptr_t                   id;
+} ioc_compat_fm_pcd_cc_tree_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t {
+    compat_uptr_t                       id;
+    uint8_t                             grp_indx;
+    uint8_t                             indx;
+    ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+} ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_key_params_t {
+    compat_uptr_t                              p_key;
+    compat_uptr_t                              p_mask;
+    ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params; /**< compat structure*/
+} ioc_compat_fm_pcd_cc_key_params_t;
+
+typedef struct ioc_compat_keys_params_t {
+    uint8_t                                    num_of_keys;
+    uint8_t                                    key_size;
+    ioc_compat_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS]; /**< compat structure*/
+    ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;         /**< compat structure*/
+} ioc_compat_keys_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t                 extract_cc_params;  /**< same structure*/
+    ioc_compat_keys_params_t                   keys_params;        /**< compat structure*/
+    compat_uptr_t                              id;
+} ioc_compat_fm_pcd_cc_node_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_node_modify_key_params_t {
+    compat_uptr_t                       id;
+    uint8_t                             key_indx;
+    uint8_t                             key_size;
+    compat_uptr_t                       p_key;
+    compat_uptr_t                       p_mask;
+} ioc_compat_fm_pcd_cc_node_modify_key_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    compat_uptr_t                       id;
+    uint8_t                             key_indx;
+    uint8_t                             key_size;
+    ioc_compat_fm_pcd_cc_key_params_t   key_params;
+} ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+typedef struct ioc_compat_fm_port_pcd_plcr_params_t {
+    compat_uptr_t                plcr_profile_id;
+} ioc_compat_fm_port_pcd_plcr_params_t;
+
+typedef struct ioc_compat_fm_port_pcd_cc_params_t {
+    compat_uptr_t                cc_tree_id;
+} ioc_compat_fm_port_pcd_cc_params_t;
+
+typedef struct ioc_compat_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;
+    compat_uptr_t       schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+    bool                direct_scheme;
+    compat_uptr_t       direct_scheme_id;
+} ioc_compat_fm_port_pcd_kg_params_t;
+
+typedef struct ioc_compat_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support          pcd_support;
+    compat_uptr_t                    net_env_id;
+    compat_uptr_t                    p_prs_params;
+    compat_uptr_t                    p_cc_params;
+    compat_uptr_t                    p_kg_params;
+    compat_uptr_t                    p_plcr_params;
+} ioc_compat_fm_port_pcd_params_t;
+
+typedef struct ioc_compat_fm_pcd_kg_cc_t {
+    compat_uptr_t                   tree_id;
+    uint8_t                         grp_id;
+    bool                            plcr_next;
+    bool                            bypass_plcr_profile_generation;
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;
+} ioc_compat_fm_pcd_kg_cc_t;
+
+typedef struct ioc_compat_fm_pcd_kg_scheme_params_t {
+    bool                                modify;
+    union
+    {
+        uint8_t                         relative_scheme_id;
+        compat_uptr_t                   scheme_id;
+    } scm_id;
+    bool                                always_direct;
+    struct
+    {
+        compat_uptr_t                   net_env_id;
+        uint8_t                         num_of_distinction_units;
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    } netEnvParams;
+    bool                                use_hash;
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+    bool                                bypass_fqid_generation;
+    uint32_t                            base_fqid;
+    uint8_t                             numOfUsedExtractedOrs;
+    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+    ioc_fm_pcd_engine                   next_engine;
+    union{
+        ioc_fm_pcd_done_action          done_action;
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;
+        ioc_compat_fm_pcd_kg_cc_t       cc;
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;
+    compat_uptr_t                       id;
+} ioc_compat_fm_pcd_kg_scheme_params_t;
+
+typedef struct ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t {
+    compat_uptr_t                       id;
+    uint8_t                             key_indx;
+    uint8_t                             key_size;
+    ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+} ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t;
+/* } pcd compat structures */
+
+/* pcd compat functions { */
+void compat_copy_fm_pcd_plcr_profile(
+        ioc_compat_fm_pcd_plcr_profile_params_t *compat_param,
+        ioc_fm_pcd_plcr_profile_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_key(
+        ioc_compat_fm_pcd_cc_key_params_t *compat_param,
+        ioc_fm_pcd_cc_key_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(
+        ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *compat_param,
+        ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_node_modify_next_engine(
+        ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *compat_param,
+        ioc_fm_pcd_cc_node_modify_next_engine_params_t *param,
+        uint8_t compat);
+
+void compat_fm_pcd_cc_tree_modify_next_engine(
+        ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *compat_param,
+        ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_grp(
+        ioc_compat_fm_pcd_cc_grp_params_t *compat_param,
+        ioc_fm_pcd_cc_grp_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_tree(
+        ioc_compat_fm_pcd_cc_tree_params_t *compat_param,
+        ioc_fm_pcd_cc_tree_params_t *param,
+        uint8_t compat);
+
+void compat_fm_pcd_prs_sw(
+        ioc_compat_fm_pcd_prs_sw_params_t *compat_param,
+        ioc_fm_pcd_prs_sw_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_kg_scheme(
+        ioc_compat_fm_pcd_kg_scheme_params_t *compat_param,
+        ioc_fm_pcd_kg_scheme_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_kg_scheme_select(
+        ioc_compat_fm_pcd_kg_scheme_select_t *compat_param,
+        ioc_fm_pcd_kg_scheme_select_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_kg_schemes_params(
+        ioc_compat_fm_pcd_port_schemes_params_t *compat_param,
+        ioc_fm_pcd_port_schemes_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_port_pcd_kg(
+        ioc_compat_fm_port_pcd_kg_params_t *compat_param,
+        ioc_fm_port_pcd_kg_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_port_pcd(
+        ioc_compat_fm_port_pcd_params_t *compat_param,
+        ioc_fm_port_pcd_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_net_env(
+        ioc_compat_fm_pcd_net_env_params_t *compat_param,
+        ioc_fm_pcd_net_env_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_node_modify_key(
+        ioc_compat_fm_pcd_cc_node_modify_key_params_t *compat_param,
+        ioc_fm_pcd_cc_node_modify_key_params_t *param,
+        uint8_t compat);
+
+void compat_copy_keys(
+        ioc_compat_keys_params_t *compat_param,
+        ioc_keys_params_t *param,
+        uint8_t compat);
+
+void compat_copy_fm_pcd_cc_node(
+        ioc_compat_fm_pcd_cc_node_params_t *compat_param,
+        ioc_fm_pcd_cc_node_params_t *param,
+        uint8_t compat);
+
+/* } pcd compat functions */
+#endif
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fman_test.c
new file mode 100644
index 0000000..d140bef
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/fman_test.c
@@ -0,0 +1,1029 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fman_test.c
+
+ @Author        Moti Bar
+
+ @Description   FM Linux test
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/fsl_qman.h>     /*struct qman_fq */
+#include <linux/of_platform.h>
+#include <linux/ip.h>
+#include <linux/compat.h>	/*for mixed environment */
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "debug_ext.h"
+#include "list_ext.h"
+#include "fm_ext.h"
+
+#include "fm_test_ioctls.h"
+#include "fsl_fman.h"
+#include "fsl_fman_test.h"
+#include "fm_port_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+#define FMT_FRM_WATERMARK   0xdeadbeefdeadbeeaLL
+
+typedef struct {
+    ioc_fmt_buff_desc_t     buff;
+    t_List                  node;
+} t_FmTestFrame;
+
+#define FMT_FRAME_OBJECT(ptr)  LIST_OBJECT(ptr, t_FmTestFrame, node)
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    struct list_head    list;
+    void                *port;
+    bool                init;
+} t_FmTestFq;
+
+typedef struct {
+    bool                valid;
+    uint8_t             id;
+    ioc_fmt_port_type   portType;
+    ioc_diag_mode       diag;
+    bool                echo;
+    bool                ip_header_manip;
+    struct fm_port      *p_TxPort;
+    t_Handle            h_TxFmPortDev;
+    struct fm_port      *p_RxPort;
+    t_Handle            h_RxFmPortDev;
+    t_Handle            h_Mac;
+    uint64_t            fmPhysBaseAddr;
+    t_List              rxFrmsQ;
+
+    int                 numOfTxQs;
+    struct qman_fq      *p_TxFqs[8];
+} t_FmTestPort;
+
+typedef struct {
+    int major;
+    t_FmTestPort ports[IOC_FMT_MAX_NUM_OF_PORTS];
+    struct class *fm_test_class;
+} t_FmTest;
+
+
+static t_FmTest fmTest;
+
+
+static t_Error Set1GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+#define FM_1GMAC0_OFFSET                0x000e0000
+#define FM_1GMAC_CMD_CONF_CTRL_OFFSET   0x100
+#define MACCFG1_LOOPBACK                0x00000100
+
+    uint64_t    baseAddr, regAddr;
+    uint32_t    tmpVal;
+
+    baseAddr = p_FmTestPort->fmPhysBaseAddr + (FM_1GMAC0_OFFSET + (p_FmTestPort->id*0x2000));
+
+    baseAddr = PTR_TO_UINT(ioremap(baseAddr, 0x1000));
+
+    regAddr = baseAddr + FM_1GMAC_CMD_CONF_CTRL_OFFSET;
+    tmpVal = GET_UINT32(*((uint32_t *)UINT_TO_PTR(regAddr)));
+    if (en)
+        tmpVal |= MACCFG1_LOOPBACK;
+    else
+        tmpVal &= ~MACCFG1_LOOPBACK;
+    WRITE_UINT32(*((uint32_t *)UINT_TO_PTR(regAddr)), tmpVal);
+
+    iounmap(UINT_TO_PTR(baseAddr));
+
+    return E_OK;
+}
+
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
+static t_Error Set10GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+#define FM_10GMAC0_OFFSET               0x000f0000
+#define FM_10GMAC_CMD_CONF_CTRL_OFFSET  0x8
+#define CMD_CFG_LOOPBACK_EN             0x00000400
+
+    uint64_t    baseAddr, regAddr;
+    uint32_t    tmpVal;
+
+    baseAddr = p_FmTestPort->fmPhysBaseAddr + (FM_10GMAC0_OFFSET + ((p_FmTestPort->id-FM_MAX_NUM_OF_1G_RX_PORTS)*0x2000));
+
+    baseAddr = PTR_TO_UINT(ioremap(baseAddr, 0x1000));
+
+    regAddr = baseAddr + FM_10GMAC_CMD_CONF_CTRL_OFFSET;
+    tmpVal = GET_UINT32(*((uint32_t *)UINT_TO_PTR(regAddr)));
+    if (en)
+        tmpVal |= CMD_CFG_LOOPBACK_EN;
+    else
+        tmpVal &= ~CMD_CFG_LOOPBACK_EN;
+    WRITE_UINT32(*((uint32_t *)UINT_TO_PTR(regAddr)), tmpVal);
+
+    iounmap(UINT_TO_PTR(baseAddr));
+
+    return E_OK;
+}
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
+
+static t_Error SetMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+
+    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
+    {
+        if (p_FmTestPort->id < FM_MAX_NUM_OF_1G_RX_PORTS)
+            return Set1GMacIntLoopback(p_FmTestPort, en);
+        else if ((p_FmTestPort->id >= FM_MAX_NUM_OF_1G_RX_PORTS) && (p_FmTestPort->id < FM_MAX_NUM_OF_1G_RX_PORTS + FM_MAX_NUM_OF_10G_RX_PORTS))
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
+            return Set10GMacIntLoopback(p_FmTestPort, en);
+#else
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TGEC don't have internal-loopback"));
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
+    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+}
+
+static void EnqueueFrameToRxQ(t_FmTestPort *p_FmTestPort, t_FmTestFrame *p_FmTestFrame)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_FmTestFrame->node, &p_FmTestPort->rxFrmsQ);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static t_FmTestFrame * DequeueFrameFromRxQ(t_FmTestPort *p_FmTestPort)
+{
+    t_FmTestFrame   *p_FmTestFrame = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&p_FmTestPort->rxFrmsQ))
+    {
+        p_FmTestFrame = FMT_FRAME_OBJECT(p_FmTestPort->rxFrmsQ.p_Next);
+        LIST_DelAndInit(&p_FmTestFrame->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_FmTestFrame;
+}
+
+static enum qman_cb_dqrr_result egress_dqrr(struct qman_portal          *portal,
+                                            struct qman_fq              *fq,
+                                            const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void egress_ern(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_FmTestPort    *p_FmTestPort,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = egress_dqrr;
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = egress_ern;
+    p_FmtFq->port = (void *)p_FmTestPort;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    p_FmtFq->init    = !(flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",fqid,flags,channel,wq));
+
+    _errno = qman_create_fq(fqid, flags, &p_FmtFq->fq_base);
+    if (unlikely(_errno)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (p_FmtFq->init) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    return fq;
+}
+
+static t_Error PortInit (t_FmTestPort *p_FmTestPort, ioc_fmt_port_param_t *p_Params)
+{
+    struct of_device_id name;
+    struct device_node  *fm_node, *fm_port_node;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+    uint32_t            i;
+
+    INIT_LIST(&p_FmTestPort->rxFrmsQ);
+    p_FmTestPort->numOfTxQs         = p_Params->num_tx_queues;
+    p_FmTestPort->id                = p_Params->fm_port_id;
+    p_FmTestPort->portType          = p_Params->fm_port_type;
+    p_FmTestPort->diag              = e_IOC_DIAG_MODE_NONE;
+    p_FmTestPort->ip_header_manip   = FALSE;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        if (*uint32_prop == p_Params->fm_id) {
+            struct resource     res;
+            /* Get the FM address */
+            _errno = of_address_to_resource(fm_node, 0, &res);
+            if (unlikely(_errno < 0))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+
+            p_FmTestPort->fmPhysBaseAddr = res.start;
+
+            for_each_child_of_node(fm_node, fm_port_node) {
+                struct of_device    *of_dev;
+                uint32_prop = (uint32_t *)of_get_property(fm_port_node, "cell-index", &lenp);
+                if (uint32_prop == NULL)
+                    continue;
+
+                if (of_device_is_compatible(fm_port_node, "fsl,fman-port-oh") &&
+                    (p_FmTestPort->portType  == e_IOC_FMT_PORT_T_OP)) {
+                    if (*uint32_prop == p_FmTestPort->id)
+                    {
+                        of_dev = of_find_device_by_node(fm_port_node);
+                        if (unlikely(of_dev == NULL))
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                        p_FmTestPort->h_RxFmPortDev = p_FmTestPort->h_TxFmPortDev;
+                        p_FmTestPort->h_Mac = NULL;
+                        break;
+                    }
+                }
+                else if ((*uint32_prop == p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-1g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-1g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_TxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+                else if (((*uint32_prop + FM_MAX_NUM_OF_1G_RX_PORTS )== p_FmTestPort->id) &&
+                          p_FmTestPort->portType  == e_IOC_FMT_PORT_T_RXTX) {
+                    of_dev = of_find_device_by_node(fm_port_node);
+                    if (unlikely(of_dev == NULL))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+                    if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-tx"))
+                    {
+                        p_FmTestPort->p_TxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_TxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_TxPort);
+                    }
+                    else if(of_device_is_compatible(fm_port_node, "fsl,fman-port-10g-rx"))
+                    {
+                        p_FmTestPort->p_RxPort = fm_port_bind(&of_dev->dev);
+                        p_FmTestPort->h_RxFmPortDev = (t_Handle)fm_port_get_handle(p_FmTestPort->p_RxPort);
+                    }
+                    else if (of_device_is_compatible(fm_port_node, "fsl,fman-10g-mac"))
+                        p_FmTestPort->h_Mac = (typeof(p_FmTestPort->h_Mac))dev_get_drvdata(&of_dev->dev);
+                    else
+                        continue;
+                    if(p_FmTestPort->h_TxFmPortDev && p_FmTestPort->h_RxFmPortDev && p_FmTestPort->h_Mac)
+                        break;
+                }
+            } //for_each_child
+        }
+    } //for each matching node
+
+    DBG(TRACE, ("h_TxFmPortDev - 0x%08x, h_RxFmPortDev - 0x%08x, h_Mac - 0x%08x\n",
+        p_FmTestPort->h_TxFmPortDev,p_FmTestPort->h_RxFmPortDev,p_FmTestPort->h_Mac));
+
+    if(p_FmTestPort->h_TxFmPortDev == 0 || p_FmTestPort->h_RxFmPortDev == 0)
+        RETURN_ERROR(MINOR, E_INVALID_ADDRESS, ("Bad pointers!"));
+
+    //init Queues
+    for (i=0; i<p_FmTestPort->numOfTxQs; i++) {
+        p_FmTestPort->p_TxFqs[i] =
+            FqAlloc(p_FmTestPort,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    fm_get_tx_port_channel(p_FmTestPort->p_TxPort),
+                    i);
+        if (IS_ERR(p_FmTestPort->p_TxFqs[i]))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Tx FQs!"));
+    }
+
+    p_FmTestPort->valid     = TRUE;
+
+    return E_OK;
+}
+
+
+bool is_fman_test (void     *mac_dev,
+                   uint32_t queueId,
+                   uint8_t  *buffer,
+                   uint32_t size)
+{
+    t_FmTest                *p_FmTest = &fmTest;
+    t_FmTestPort            *p_FmTestPort=NULL;
+    t_FmTestFrame           *p_FmTestFrame;
+    uint32_t                count=size-7;
+    uint64_t                temp;
+    uint8_t                 *temp_buf=buffer, i;
+    bool                    fman_test_flag = false;
+    uint32_t                dataOffset;
+    struct fm_port          *fm_port = (struct fm_port *) mac_dev;
+
+#if 0
+    if ((queueId == FMT_TX_CONF_Q) || (queueId == FMT_TX_ERR_Q))
+    {
+        /* Check for the FM-test-port object existence, otherwise we make wrong frees all the time */
+        for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+            if (mac_dev == p_FmTest->ports[i].h_Mac)
+                p_FmTestPort = &p_FmTest->ports[i];
+        if (!p_FmTestPort)
+            return false;
+
+        if (buffer != NULL)
+            XX_Free(buffer);
+        return true;
+    }
+#endif
+
+    /* Get the FM-test-port object */
+    for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+        if ((p_FmTest->ports[i].h_Mac && mac_dev == p_FmTest->ports[i].h_Mac) ||
+                fm_port == p_FmTest->ports[i].p_TxPort)
+        {
+            p_FmTestPort = &p_FmTest->ports[i];
+            break;
+        }
+    if (!p_FmTestPort)
+        return false;
+
+    /* Check according to watermark if this frame is for FM-test */
+    while(count--)
+    {
+        temp = *(uint64_t *)temp_buf;
+        if (temp == FMT_FRM_WATERMARK)
+        {
+            fman_test_flag = true;
+            break;
+        }
+        temp_buf++;
+    }
+
+    if (fman_test_flag /*|| p_FmTestPort->echo*/)
+    {
+        if ((queueId == FMT_TX_CONF_Q) || (queueId == FMT_TX_ERR_Q))
+        {
+            if (buffer != NULL)
+                XX_Free(buffer);
+            return true;
+        }
+
+        DBG(TRACE, ("Port %d got FMUC frame\n", p_FmTestPort->id));
+        dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_RxFmPortDev);
+
+        p_FmTestFrame = (t_FmTestFrame *)XX_Malloc(sizeof(t_FmTestFrame));
+        /* dump frame... no more space left on device */
+        if(p_FmTestFrame == NULL)
+            return false;
+
+        memset(p_FmTestFrame, 0, sizeof(t_FmTestFrame));
+        INIT_LIST(&p_FmTestFrame->node);
+
+        p_FmTestFrame->buff.p_data = (uint8_t *)XX_Malloc(size * sizeof(uint8_t));
+        /* No more space left on device*/
+        if(p_FmTestFrame->buff.p_data == NULL){
+            XX_Free(p_FmTestFrame);
+            return false;
+        }
+
+        p_FmTestFrame->buff.size = size-dataOffset;
+        p_FmTestFrame->buff.qid = queueId;
+
+        memcpy(p_FmTestFrame->buff.p_data,
+               (uint8_t *)PTR_MOVE(buffer, dataOffset),
+               p_FmTestFrame->buff.size);
+
+        memcpy(p_FmTestFrame->buff.buff_context.fm_prs_res,
+               FM_PORT_GetBufferPrsResult(p_FmTestPort->h_RxFmPortDev, (char*)buffer),
+               32);
+
+        EnqueueFrameToRxQ(p_FmTestPort, p_FmTestFrame);
+        return true;
+    }
+
+    return false;
+}
+
+void fman_test_ip_manip (void *mac_dev, uint8_t *data)
+{
+    t_FmTest                *p_FmTest = &fmTest;
+    t_FmTestPort            *p_FmTestPort=NULL;
+    struct iphdr            *iph;
+    uint32_t                *p_Data = (uint32_t *)data;
+    uint32_t                net;
+    uint32_t                saddr, daddr;
+    uint8_t                 i;
+
+    /* Get the FM-test-port object */
+    for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+        if (mac_dev == p_FmTest->ports[i].h_Mac)
+            p_FmTestPort = &p_FmTest->ports[i];
+    if (!p_FmTestPort || !p_FmTestPort->ip_header_manip)
+        return;
+
+    iph = (struct iphdr *)p_Data;
+    saddr = iph->saddr;
+    daddr = iph->daddr;
+
+    /* If it is ARP packet ... */
+    if (*p_Data == 0x00010800)
+    {
+        saddr = *((uint32_t *)PTR_MOVE(p_Data, 14));
+        daddr = *((uint32_t *)PTR_MOVE(p_Data, 24));
+    }
+
+    DBG(TRACE,
+        ("\nSrc  IP before header-manipulation: %d.%d.%d.%d"
+         "\nDest IP before header-manipulation: %d.%d.%d.%d",
+         (int)((saddr & 0xff000000) >> 24),
+         (int)((saddr & 0x00ff0000) >> 16),
+         (int)((saddr & 0x0000ff00) >> 8),
+         (int)((saddr & 0x000000ff) >> 0),
+         (int)((daddr & 0xff000000) >> 24),
+         (int)((daddr & 0x00ff0000) >> 16),
+         (int)((daddr & 0x0000ff00) >> 8),
+         (int)((daddr & 0x000000ff) >> 0)));
+
+    if ((p_FmTestPort->diag == e_IOC_DIAG_MODE_CTRL_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_CHIP_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_PHY_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_LINE_LOOPBACK))
+    {
+        net   = saddr;
+        saddr = daddr;
+        daddr = net;
+    }
+    else
+    {
+        /* We allow only up to 10 eth ports */
+        net   = ((daddr & 0x000000ff) % 10);
+        saddr = (uint32_t)((saddr & ~0x0000ff00) | (net << 8));
+        daddr = (uint32_t)((daddr & ~0x0000ff00) | (net << 8));
+    }
+
+    /* If not ARP ... */
+    if (*p_Data != 0x00010800)
+    {
+        iph->check = 0;
+
+        iph->saddr = saddr;
+        iph->daddr = daddr;
+        iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+    }
+    else /* The packet is ARP */
+    {
+        *((uint32_t *)PTR_MOVE(p_Data, 14)) = saddr;
+        *((uint32_t *)PTR_MOVE(p_Data, 24)) = daddr;
+    }
+
+    DBG(TRACE,
+        ("\nSrc  IP after  header-manipulation: %d.%d.%d.%d"
+         "\nDest IP after  header-manipulation: %d.%d.%d.%d",
+         (int)((saddr & 0xff000000) >> 24),
+         (int)((saddr & 0x00ff0000) >> 16),
+         (int)((saddr & 0x0000ff00) >> 8),
+         (int)((saddr & 0x000000ff) >> 0),
+         (int)((daddr & 0xff000000) >> 24),
+         (int)((daddr & 0x00ff0000) >> 16),
+         (int)((daddr & 0x0000ff00) >> 8),
+         (int)((daddr & 0x000000ff) >> 0)));
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_test_open(struct inode *inode, struct file *file)
+{
+    t_FmTest            *p_FmTest = &fmTest;
+    //unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+    if ((minor >= DEV_FM_TEST_PORTS_MINOR_BASE) &&
+        (minor < DEV_FM_TEST_MAX_MINORS))
+        file->private_data = &p_FmTest->ports[minor];
+    else
+        return -ENXIO;
+
+    return 0;
+}
+
+static int fm_test_close(struct inode *inode, struct file *file)
+{
+    t_FmTestPort        *p_FmTestPort;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    p_FmTestPort->valid = FALSE;
+
+    /* Complete!!! */
+    return err;
+}
+
+static int fm_test_ioctls(unsigned int minor, struct file *file, unsigned int cmd, unsigned long arg, bool compat)
+{
+    t_FmTestPort        *p_FmTestPort;
+
+    DBG(TRACE, ("IOCTL minor - %d, cmd - 0x%08x, arg - 0x%08x", minor, cmd, arg));
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort)
+        return -ENODEV;
+
+    switch (cmd)
+    {
+        case FMT_PORT_IOC_INIT:
+        {
+            ioc_fmt_port_param_t  param;
+
+            if (p_FmTestPort->valid) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("port is already initialized!!!"));
+                return -EFAULT;
+            }
+#if defined(CONFIG_COMPAT)
+            if (compat){
+                if (copy_from_user(&param, (ioc_fmt_port_param_t *)compat_ptr(arg), sizeof(ioc_fmt_port_param_t))) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+#endif
+            else{
+                if (copy_from_user(&param, (ioc_fmt_port_param_t *) arg, sizeof(ioc_fmt_port_param_t))) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+
+            return PortInit(p_FmTestPort, &param);
+        }
+
+        case FMT_PORT_IOC_SET_DIAG_MODE:
+        {
+            if (get_user(p_FmTestPort->diag, (ioc_diag_mode *)arg)) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+
+            if (p_FmTestPort->diag == e_IOC_DIAG_MODE_CTRL_LOOPBACK)
+                return SetMacIntLoopback(p_FmTestPort, TRUE);
+            else
+                return SetMacIntLoopback(p_FmTestPort, FALSE);
+            break;
+        }
+
+        case FMT_PORT_IOC_SET_DPAECHO_MODE:
+        {
+#if defined(CONFIG_COMPAT)
+            if (compat){
+                if (get_user(p_FmTestPort->echo, (int *)compat_ptr(arg))) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+            else
+#endif
+            {
+                if (get_user(p_FmTestPort->echo, (int *)arg)) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+            break;
+        }
+
+        case FMT_PORT_IOC_SET_IP_HEADER_MANIP:
+        {
+#if defined(CONFIG_COMPAT)
+            if (compat){
+                if (get_user(p_FmTestPort->ip_header_manip, (int *)compat_ptr(arg))) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+            else
+#endif
+            {
+                if (get_user(p_FmTestPort->ip_header_manip, (int *)arg)) {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return -EFAULT;
+                }
+            }
+            break;
+        }
+
+        default:
+            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("IOCTL"));
+            return -EFAULT;
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long fm_test_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int minor = iminor(file->f_path.dentry->d_inode);
+
+    return fm_test_ioctls(minor, file, cmd, arg, true);
+}
+#endif
+
+static int fm_test_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int        minor = iminor(inode);
+
+    return fm_test_ioctls(minor, file, cmd, arg, false);
+}
+
+#ifdef CONFIG_COMPAT
+void copy_compat_test_frame_buffer(ioc_fmt_buff_desc_t *buff, ioc_fmt_compat_buff_desc_t *compat_buff)
+{
+    compat_buff->qid = buff->qid;
+    compat_buff->p_data = ptr_to_compat(buff->p_data);
+    compat_buff->size = buff->size;
+    compat_buff->status = buff->status;
+
+    compat_buff->buff_context.p_user_priv = ptr_to_compat(buff->buff_context.p_user_priv);
+    memcpy(compat_buff->buff_context.fm_prs_res,buff->buff_context.fm_prs_res,FM_PRS_MAX * sizeof(uint8_t));
+    memcpy(compat_buff->buff_context.fm_time_stamp,buff->buff_context.fm_time_stamp,FM_TIME_STAMP_MAX * sizeof(uint8_t));
+}
+#endif
+
+ssize_t fm_test_read (struct file *file, char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+    t_FmTestFrame       *p_FmTestFrame;
+    ssize_t             cnt = 0;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid)
+        return -ENODEV;
+
+    p_FmTestFrame = DequeueFrameFromRxQ(p_FmTestPort);
+    if (!p_FmTestFrame)
+        return 0;
+
+    if (!p_FmTestPort->echo) {
+#ifdef CONFIG_COMPAT
+        cnt = sizeof(ioc_fmt_compat_buff_desc_t);
+#else
+        cnt = sizeof(ioc_fmt_buff_desc_t);
+#endif
+        if (size<cnt) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+            return 0;
+        }
+
+        /* Copy structure */
+#ifdef CONFIG_COMPAT
+        {
+            ioc_fmt_compat_buff_desc_t compat_buff;
+            copy_compat_test_frame_buffer(&p_FmTestFrame->buff, &compat_buff);
+            
+            if (copy_to_user(buf, &compat_buff, cnt)) {
+                XX_Free(p_FmTestFrame->buff.p_data);
+                XX_Free(p_FmTestFrame);
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return 0;
+            }
+        }
+
+       ((ioc_fmt_compat_buff_desc_t *)buf)->p_data = ptr_to_compat(buf+sizeof(ioc_fmt_compat_buff_desc_t));
+        cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
+#else
+        if (copy_to_user(buf, &p_FmTestFrame->buff, cnt)) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return 0;
+        }
+
+        ((ioc_fmt_buff_desc_t *)buf)->p_data = buf+sizeof(ioc_fmt_buff_desc_t);
+        cnt += MIN(p_FmTestFrame->buff.size, size-cnt);
+#endif
+
+        if (size<cnt) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_NO_MEMORY, ("Illegal buffer-size!"));
+            return 0;
+        }
+
+        /* copy frame */
+#ifdef CONFIG_COMPAT
+        if (copy_to_user(buf+sizeof(ioc_fmt_compat_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return 0;
+        }
+#else
+        if (copy_to_user(buf+sizeof(ioc_fmt_buff_desc_t), p_FmTestFrame->buff.p_data, cnt)) {
+            XX_Free(p_FmTestFrame->buff.p_data);
+            XX_Free(p_FmTestFrame);
+            REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+            return 0;
+        }
+#endif
+
+        XX_Free(p_FmTestFrame->buff.p_data);
+        XX_Free(p_FmTestFrame);
+    }
+    else {
+        uint8_t  *p_Data = NULL;
+        uint32_t frameSize =0;
+        t_DpaaFD fd;
+        int      _errno = 0;
+
+        p_Data = (uint8_t *)p_FmTestFrame->buff.p_data;
+        frameSize = p_FmTestFrame->buff.size;
+
+        /* paranoia ...*/
+        if(!p_Data){
+            XX_Free(p_FmTestFrame);
+            return 0;
+        }
+
+        /* Set frame descriptor... */
+        memset(&fd, 0, sizeof(fd));
+        DPAA_FD_SET_ADDR(&fd, p_Data);
+        DPAA_FD_SET_OFFSET(&fd, 0);
+        DPAA_FD_SET_LENGTH(&fd, frameSize);
+
+        /* Enqueue frame... */
+        _errno = qman_enqueue(p_FmTestPort->p_TxFqs[0], (struct qm_fd*)&fd, 0);
+        if (_errno) {
+            XX_Free(p_FmTestFrame);
+            XX_Free(p_Data);
+            return 0;
+        }
+
+        XX_Free(p_FmTestFrame);
+    }
+
+    return cnt;
+}
+
+ssize_t fm_test_write (struct file *file, const char __user *buf, size_t size, loff_t *ppos)
+{
+    t_FmTestPort        *p_FmTestPort;
+
+    ioc_fmt_buff_desc_t buffDesc;
+#ifdef CONFIG_COMPAT
+    ioc_fmt_compat_buff_desc_t compatBuffDesc;
+#endif
+    t_DpaaFD            fd;
+    uint8_t             *p_Data;
+    uint32_t            dataOffset;
+    int                 _errno;
+
+    p_FmTestPort = file->private_data;
+    if (!p_FmTestPort || !p_FmTestPort->valid) {
+        REPORT_ERROR(MINOR, E_INVALID_HANDLE, NO_MSG);
+        return -1;
+    }
+
+    /* If Compat (32B UserSpace - 64B KernelSpace)  */
+#ifdef CONFIG_COMPAT
+    if (copy_from_user(&compatBuffDesc, buf, sizeof(ioc_fmt_compat_buff_desc_t))) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return -1;
+    }
+
+    buffDesc.qid = compatBuffDesc.qid;
+    buffDesc.p_data = compat_ptr(compatBuffDesc.p_data);
+    buffDesc.size = compatBuffDesc.size;
+    buffDesc.status = compatBuffDesc.status;
+
+    buffDesc.buff_context.p_user_priv = compat_ptr(compatBuffDesc.buff_context.p_user_priv);
+    memcpy(buffDesc.buff_context.fm_prs_res, compatBuffDesc.buff_context.fm_prs_res, FM_PRS_MAX * sizeof(uint8_t));
+    memcpy(buffDesc.buff_context.fm_time_stamp, compatBuffDesc.buff_context.fm_time_stamp, FM_TIME_STAMP_MAX * sizeof(uint8_t));
+#else
+    if (copy_from_user(&buffDesc, (ioc_fmt_buff_desc_t *)buf, sizeof(ioc_fmt_buff_desc_t))) {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return -1;
+    }
+#endif
+
+    dataOffset = FM_PORT_GetBufferDataOffset(p_FmTestPort->h_TxFmPortDev);
+    p_Data = (uint8_t*)XX_Malloc(buffDesc.size+dataOffset);
+    if (!p_Data) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        return -1;
+    }
+
+    /* If Compat (32UserSpace - 64KernelSpace) the buffDesc.p_data is ok */
+    if (copy_from_user ((uint8_t *)PTR_MOVE(p_Data, dataOffset),
+                        buffDesc.p_data,
+                        buffDesc.size)) {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("data buff!"));
+        XX_Free(p_Data);
+        return -1;
+    }
+
+    memset(&fd, 0, sizeof(fd));
+    DPAA_FD_SET_ADDR(&fd, p_Data);
+    DPAA_FD_SET_OFFSET(&fd, dataOffset);
+    DPAA_FD_SET_LENGTH(&fd, buffDesc.size);
+
+    DBG(TRACE, ("buffDesc qId %d, fqid %d, frame len %d, fq 0x%8x\n",
+                buffDesc.qid, qman_fq_fqid(p_FmTestPort->p_TxFqs[buffDesc.qid]), buffDesc.size, p_FmTestPort->p_TxFqs[buffDesc.qid]));
+
+    _errno = qman_enqueue(p_FmTestPort->p_TxFqs[buffDesc.qid], (struct qm_fd*)&fd, 0);
+    if (_errno) {
+        buffDesc.status = (uint32_t)_errno;
+        if (copy_to_user((ioc_fmt_buff_desc_t*)buf, &buffDesc, sizeof(ioc_fmt_buff_desc_t))) {
+            REPORT_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            XX_Free(p_Data);
+            return -1;
+        }
+    }
+    return buffDesc.size;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_test_fops =
+{
+    owner:      THIS_MODULE,
+#ifdef CONFIG_COMPAT
+    compat_ioctl:fm_test_compat_ioctl,
+#endif
+    ioctl:      fm_test_ioctl,
+    open:       fm_test_open,
+    release:    fm_test_close,
+    read:       fm_test_read,
+    write:      fm_test_write,
+};
+
+t_Handle LNXWRP_FM_TEST_Init(void)
+{
+    t_FmTest    *p_FmTest = &fmTest;
+    int id;
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_FmTest->major = register_chrdev(0, DEV_FM_TEST_NAME, &fm_test_fops)) <= 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_TEST_NAME));
+        return NULL;
+    }
+
+    /* Creating class for FMan_test */
+    DBG(TRACE ,("class_create fm_test_class"));
+    p_FmTest->fm_test_class = class_create(THIS_MODULE, DEV_FM_TEST_NAME);
+    if (IS_ERR(p_FmTest->fm_test_class)) {
+        unregister_chrdev(p_FmTest->major, DEV_FM_TEST_NAME);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("class_create error fm_test_class"));
+        return NULL;
+    }
+
+    for (id = 0; id < IOC_FMT_MAX_NUM_OF_PORTS; id++)
+        if(NULL == device_create(p_FmTest->fm_test_class, NULL, MKDEV(p_FmTest->major, DEV_FM_TEST_PORTS_MINOR_BASE + id), NULL,
+                DEV_FM_TEST_NAME "%d", id))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Error creating device.\n"));
+            return NULL;
+        }
+
+    return p_FmTest;
+}
+
+t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp)
+{
+    t_FmTest    *p_FmTest = (t_FmTest*)h_FmTestLnxWrp;
+    int id;
+
+    DBG(TRACE, ("destroy fm_test_class"));
+    for (id = 0; id < IOC_FMT_MAX_NUM_OF_PORTS; id++)
+        device_destroy(p_FmTest->fm_test_class, MKDEV(p_FmTest->major, DEV_FM_TEST_PORTS_MINOR_BASE + id));
+    class_destroy(p_FmTest->fm_test_class);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.c
new file mode 100644
index 0000000..87e887f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -0,0 +1,3050 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/of_platform.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <asm/qe.h>        /* For struct qe_firmware */
+#include <sysdev/fsl_soc.h>
+#include <linux/stat.h>	   /* For file access mask */
+
+/* NetCommSw Headers --------------- */
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "sys_io_ext.h"
+#include "procbuff_ext.h"
+
+#include "fm_ioctls.h"
+
+#include "lnxwrp_fm.h"
+#include "fm_port_ext.h"
+
+#define PROC_PRINT(args...) offset += sprintf(buf+offset,args)
+
+#define ADD_ADV_CONFIG_NO_RET(_func, _param)    \
+    do {                                        \
+        if (i<max){                             \
+            p_Entry = &p_Entrys[i];             \
+            p_Entry->p_Function = _func;        \
+            _param                              \
+            i++;                                \
+        }                                       \
+        else                                    \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,\
+                         ("Number of advanced-configuration entries exceeded"));\
+    } while (0)
+
+
+static t_LnxWrpFm   lnxWrpFm;
+
+typedef enum e_FmDmaMatchStatistics {
+    e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+    e_FM_DMA_COUNTERS_BUS_ERROR,
+    e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+    e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+    e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR
+}e_FmDmaMatchStatistics;
+
+/* FM PORT STATISTICS */
+typedef struct{
+    const char *statisticName;
+    uint8_t statisticCounter;
+}t_SysfsStats;
+
+static const t_SysfsStats fmSysfsStats[] = {
+    /* FM statistics */
+    {
+        .statisticName = "enq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "deq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_DEQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "deq_0",
+        .statisticCounter = e_FM_COUNTERS_DEQ_0,
+    },
+    {
+        .statisticName = "deq_1",
+        .statisticCounter = e_FM_COUNTERS_DEQ_1,
+    },
+    {
+        .statisticName = "deq_2",
+        .statisticCounter = e_FM_COUNTERS_DEQ_2,
+    },
+    {
+        .statisticName = "deq_from_default",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_DEFAULT,
+    },
+    {
+        .statisticName = "deq_from_context",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_CONTEXT,
+    },
+    {
+        .statisticName = "deq_from_fd",
+        .statisticCounter = e_FM_COUNTERS_DEQ_FROM_FD,
+    },
+    {
+        .statisticName = "deq_confirm",
+        .statisticCounter = e_FM_COUNTERS_DEQ_CONFIRM,
+    },
+    /* FM:DMA  statistics */
+    {
+        .statisticName = "cmq_not_empty",
+        .statisticCounter = e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY,
+    },
+    {
+        .statisticName = "bus_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_BUS_ERROR,
+    },
+    {
+        .statisticName = "read_buf_ecc_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR,
+    },
+    {
+        .statisticName = "write_buf_ecc_sys_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR,
+    },
+    {
+        .statisticName = "write_buf_ecc_fm_error",
+        .statisticCounter = e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR,
+    },
+    /* FM:PCD  statistics */
+    {
+        .statisticName = "pcd_enq_total_frame",
+        .statisticCounter = e_FM_COUNTERS_ENQ_TOTAL_FRAME,
+    },
+    {
+        .statisticName = "pcd_kg_total",
+        .statisticCounter = e_FM_PCD_KG_COUNTERS_TOTAL,
+    },
+    {
+        .statisticName = "pcd_plcr_yellow",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_YELLOW,
+    },
+    {
+        .statisticName = "pcd_plcr_red",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RED,
+    },
+    {
+        .statisticName = "pcd_plcr_recolored_to_red",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,
+    },
+    {
+        .statisticName = "pcd_plcr_recolored_to_yellow",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,
+    },
+    {
+        .statisticName = "pcd_plcr_total",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_TOTAL,
+    },
+    {
+        .statisticName = "pcd_plcr_length_mismatch",
+        .statisticCounter = e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,
+    },
+    {
+        .statisticName = "pcd_prs_parse_dispatch",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,
+    },
+    {
+        .statisticName = "pcd_prs_l2_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l3_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l4_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_shim_parse_result_returned",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,
+    },
+    {
+        .statisticName = "pcd_prs_l2_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_l3_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_l4_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_shim_parse_result_returned_with_err",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,
+    },
+    {
+        .statisticName = "pcd_prs_soft_prs_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_soft_prs_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_hard_prs_cycle_incl_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_read_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_read_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_write_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_muram_write_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,
+    },
+    {
+        .statisticName = "pcd_prs_fpm_command_stall_cycles",
+        .statisticCounter = e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES,
+    },
+    {}
+};
+
+static const t_SysfsStats portSysfsStats[] = {
+    /* RX/TX/OH common statistics */
+    {
+        .statisticName = "port_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_FRAME,
+    },
+    {
+        .statisticName = "port_discard_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_DISCARD_FRAME,
+    },
+    {
+        .statisticName = "port_dealloc_buf",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEALLOC_BUF,
+    },
+    {
+        .statisticName = "port_enq_total",
+        .statisticCounter = e_FM_PORT_COUNTERS_ENQ_TOTAL,
+    },
+    /* TX/OH */
+    {
+        .statisticName = "port_length_err",
+        .statisticCounter = e_FM_PORT_COUNTERS_LENGTH_ERR,
+    },
+    {
+        .statisticName = "port_unsupprted_format",
+        .statisticCounter = e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,
+    },
+    {
+        .statisticName = "port_deq_total",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_TOTAL,
+    },
+    {
+        .statisticName = "port_deq_from_default",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,
+    },
+    {
+        .statisticName = "port_deq_confirm",
+        .statisticCounter = e_FM_PORT_COUNTERS_DEQ_CONFIRM,
+    },
+    /* RX/OH */
+    {
+        .statisticName = "port_rx_bad_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_BAD_FRAME,
+    },
+    {
+        .statisticName = "port_rx_large_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_LARGE_FRAME ,
+    },
+    {
+        .statisticName = "port_rx_out_of_buffers_discard",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,
+    },
+    {
+        .statisticName = "port_rx_filter_frame",
+        .statisticCounter = e_FM_PORT_COUNTERS_RX_FILTER_FRAME,
+    },
+    /* TODO: Particular statistics for OH ports */
+    {}
+};
+
+static uint8_t find_fm_statistic_counter_by_name(const char *attr_name, t_SysfsStats *sysfs_stats, uint8_t *offset)
+{
+    int i = 0;
+
+    while(sysfs_stats[i].statisticName != NULL)
+    {
+        if(strcmp(sysfs_stats[i].statisticName, attr_name) == 0){
+            if(offset != NULL)
+                *offset = i;
+            return sysfs_stats[i].statisticCounter;
+        }
+
+        i++;
+    }
+    /* Should never get here! */
+    BUG();
+    return 0;
+}
+
+static ssize_t show_fm_port_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    t_LnxWrpFmDev               *p_LnxWrpFmDev     = NULL;
+    unsigned long               flags;
+    int                         n = 0;
+    uint8_t                     counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    if (p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    if (p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    if (!p_LnxWrpFmPortDev->h_Dev)
+    {
+        n = snprintf( buf, PAGE_SIZE,
+            "\tFM Port not configured... \n");
+        return n;
+    }
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&portSysfsStats[0], NULL);
+
+    if(counter == e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR){
+        uint32_t fmRev = 0;
+        fmRev = (uint32_t)(*((volatile uint32_t *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+0x000c30c4))& 0xffff);
+        local_irq_save(flags);
+
+        if (fmRev == 0x0100)
+            n = snprintf( buf, PAGE_SIZE, "counter not available for revision 1\n");
+
+        local_irq_restore(flags);
+        return n;
+    }
+
+    local_irq_save(flags);
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d Port %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            p_LnxWrpFmPortDev->id,
+            FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, (e_FmPortCounters)counter));
+    local_irq_restore(flags);
+
+    return n;
+}
+
+/* FM PORT RX/TX/OH statistics */
+static DEVICE_ATTR(port_frame                       , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_discard_frame               , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_dealloc_buf                 , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_enq_total                   , S_IRUGO, show_fm_port_stats, NULL);
+/* FM PORT TX/OH statistics */
+static DEVICE_ATTR(port_length_err                  , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_unsupprted_format           , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_total                   , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_from_default            , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_deq_confirm                 , S_IRUGO, show_fm_port_stats, NULL);
+/* FM PORT RX/OH statistics */
+static DEVICE_ATTR(port_rx_bad_frame                , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_large_frame              , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_out_of_buffers_discard   , S_IRUGO, show_fm_port_stats, NULL);
+static DEVICE_ATTR(port_rx_filter_frame             , S_IRUGO, show_fm_port_stats, NULL);
+
+/* FM PORT TX statistics */
+static struct attribute *fm_tx_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    &dev_attr_port_length_err.attr,
+    &dev_attr_port_unsupprted_format.attr,
+    &dev_attr_port_deq_total.attr,
+    &dev_attr_port_deq_from_default.attr,
+    &dev_attr_port_deq_confirm.attr,
+    NULL
+};
+
+static const struct attribute_group fm_tx_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_tx_port_dev_stats_attributes
+};
+
+/* FM PORT RX statistics */
+static struct attribute *fm_rx_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    &dev_attr_port_rx_bad_frame.attr,
+    &dev_attr_port_rx_large_frame.attr,
+    &dev_attr_port_rx_out_of_buffers_discard.attr,
+    &dev_attr_port_rx_filter_frame.attr,
+    NULL
+};
+
+static const struct attribute_group fm_rx_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_rx_port_dev_stats_attributes
+};
+
+/* TODO: add particular OH ports statistics */
+static struct attribute *fm_oh_port_dev_stats_attributes[] = {
+    &dev_attr_port_frame.attr,
+    &dev_attr_port_discard_frame.attr,
+    &dev_attr_port_dealloc_buf.attr,
+    &dev_attr_port_enq_total.attr,
+    /*TX*/
+    &dev_attr_port_length_err.attr,
+    &dev_attr_port_unsupprted_format.attr,
+    &dev_attr_port_deq_total.attr,
+    &dev_attr_port_deq_from_default.attr,
+    &dev_attr_port_deq_confirm.attr,
+    /*RX*/
+    &dev_attr_port_rx_bad_frame.attr,
+    &dev_attr_port_rx_large_frame.attr,
+    &dev_attr_port_rx_out_of_buffers_discard.attr,
+    /*&dev_attr_port_rx_filter_frame.attr,*/
+    NULL
+};
+
+static const struct attribute_group fm_oh_port_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_oh_port_dev_stats_attributes
+};
+
+static ssize_t show_fm_port_regs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+#endif
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    local_irq_save(flags);
+
+    if (!p_LnxWrpFmPortDev->h_Dev){
+        n = snprintf( buf, PAGE_SIZE,
+            "\tFM Port not configured... \n");
+        return n;
+    }
+    else{
+        n = snprintf(buf, PAGE_SIZE, "FM port driver registers dump.\n");
+        FM_PORT_DumpRegs(p_LnxWrpFmPortDev->h_Dev);
+    }
+
+    local_irq_restore(flags);
+
+    return n;
+#else
+
+    local_irq_save(flags);
+    n = snprintf(buf, PAGE_SIZE, "Debug level is too low to dump registers!!!\n");
+    local_irq_restore(flags);
+
+    return n;
+#endif
+}
+
+static DEVICE_ATTR(fm_port_regs,0x644,show_fm_port_regs,NULL);
+
+static int fm_port_sysfs_create(struct device *dev)
+{
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = NULL;
+
+    if(dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    /* store to remove them when module si disabled */
+    p_LnxWrpFmPortDev->dev_attr_regs = &dev_attr_fm_port_regs;
+
+    /* Registers dump entry - in future will be moved to debugfs */
+    if(device_create_file(dev,&dev_attr_fm_port_regs) !=0 )
+         return -EIO;
+
+    /* FM Ports statistics */
+    switch(p_LnxWrpFmPortDev->settings.param.portType){
+        case e_FM_PORT_TYPE_TX:
+        case e_FM_PORT_TYPE_TX_10G:
+            if (sysfs_create_group(&dev->kobj, &fm_tx_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_RX:
+        case e_FM_PORT_TYPE_RX_10G :
+            if (sysfs_create_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING :
+        case e_FM_PORT_TYPE_OH_HOST_COMMAND :
+            if (sysfs_create_group(&dev->kobj, &fm_oh_port_dev_stats_attr_grp) !=0)
+                return -EIO;
+        break;
+        case e_FM_PORT_TYPE_DUMMY:
+        default:
+            BUG();
+        break;
+    };
+
+    return 0;
+}
+
+static void fm_port_sysfs_destroy(struct device *dev)
+{
+    t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = NULL;
+
+    /* this function has never been tested !!! */
+
+    if(dev == NULL)
+        BUG();
+
+    p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmPortDev == NULL)
+        BUG();
+
+    /* The name attribute will be freed also by these 2 functions? Hell knows... */
+    switch(p_LnxWrpFmPortDev->settings.param.portType){
+        case e_FM_PORT_TYPE_TX:
+        case e_FM_PORT_TYPE_TX_10G:
+            sysfs_remove_group(&dev->kobj, &fm_tx_port_dev_stats_attr_grp);
+        break;
+        case e_FM_PORT_TYPE_RX:
+        case e_FM_PORT_TYPE_RX_10G :
+            sysfs_remove_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp);
+        break;
+        case e_FM_PORT_TYPE_OH_OFFLINE_PARSING :
+        case e_FM_PORT_TYPE_OH_HOST_COMMAND :
+            /* Not supported yet... */
+            printk( KERN_WARNING "Statistics for port type not supported... \n");
+        break;
+        case e_FM_PORT_TYPE_DUMMY :
+        default :
+            BUG();
+        break;
+    };
+
+    device_remove_file(dev, p_LnxWrpFmPortDev->dev_attr_regs);
+}
+
+/* Fm stats and regs dumps via sysfs */
+static ssize_t show_fm_dma_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    t_FmDmaStatus  fmDmaStatus;
+    unsigned long  flags = 0;
+    unsigned n = 0;
+    uint8_t counter_value = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
+
+    local_irq_save(flags);
+
+    memset(&fmDmaStatus, 0, sizeof(fmDmaStatus));
+    FM_GetDmaStatus(p_LnxWrpFmDev->h_Dev, &fmDmaStatus);
+
+    switch(counter){
+        case e_FM_DMA_COUNTERS_CMQ_NOT_EMPTY:
+            counter_value = fmDmaStatus.cmqNotEmpty;
+        break;
+        case e_FM_DMA_COUNTERS_BUS_ERROR:
+            counter_value = fmDmaStatus.busError;
+        break;
+        case e_FM_DMA_COUNTERS_READ_BUF_ECC_ERROR:
+            counter_value = fmDmaStatus.readBufEccError;
+        break;
+        case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_SYS_ERROR:
+            counter_value = fmDmaStatus.writeBufEccSysError;
+        break;
+        case e_FM_DMA_COUNTERS_WRITE_BUF_ECC_FM_ERROR:
+            counter_value = fmDmaStatus.writeBufEccFmError;
+        break;
+        default:
+            BUG();
+        break;
+    };
+
+    n = snprintf( buf, PAGE_SIZE, "\tFM %u counter: %c\n",
+            p_LnxWrpFmDev->id,
+            counter_value?'T':'F' );
+
+    local_irq_restore(flags);
+
+    return n;
+}
+
+static ssize_t show_fm_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    unsigned long  flags = 0;
+    unsigned n = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
+
+    local_irq_save(flags);
+
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            FM_GetCounter(p_LnxWrpFmDev->h_Dev, (e_FmCounters)counter));
+
+    local_irq_restore(flags);
+
+    return n;
+}
+
+static ssize_t show_fm_pcd_stats(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+    unsigned long  flags = 0;
+    unsigned n = 0, counter = 0;
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+
+    counter = find_fm_statistic_counter_by_name(attr->attr.name, (t_SysfsStats *)&fmSysfsStats[0], NULL);
+
+    local_irq_save(flags);
+
+    n = snprintf( buf, PAGE_SIZE, "\tFM %d counter: %d\n",
+            p_LnxWrpFmDev->id,
+            FM_PCD_GetCounter(p_LnxWrpFmDev->h_PcdDev, (e_FmPcdCounters)counter));
+
+    local_irq_restore(flags);
+
+    return n;
+}
+
+/* FM */
+static DEVICE_ATTR(enq_total_frame              , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_total_frame              , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_0                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_1                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_2                        , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_default             , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_context             , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_from_fd                  , S_IRUGO, show_fm_stats, NULL);
+static DEVICE_ATTR(deq_confirm                  , S_IRUGO, show_fm_stats, NULL);
+/* FM:DMA */
+static DEVICE_ATTR(cmq_not_empty            , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(bus_error                , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(read_buf_ecc_error       , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(write_buf_ecc_sys_error  , S_IRUGO, show_fm_dma_stats, NULL);
+static DEVICE_ATTR(write_buf_ecc_fm_error   , S_IRUGO, show_fm_dma_stats, NULL);
+/* FM:PCD */
+static DEVICE_ATTR(pcd_enq_total_frame                          , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_kg_total                                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_yellow                              , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_red                                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_recolored_to_red                    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_recolored_to_yellow                 , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_total                               , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_plcr_length_mismatch                     , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_parse_dispatch                       , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l2_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l3_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l4_parse_result_returned             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_shim_parse_result_returned           , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l2_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l3_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_l4_parse_result_returned_with_err    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_shim_parse_result_returned_with_err  , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_soft_prs_cycles                      , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_soft_prs_stall_cycles                , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_hard_prs_cycle_incl_stall_cycles     , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_read_cycles                    , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_read_stall_cycles              , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_write_cycles                   , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_muram_write_stall_cycles             , S_IRUGO, show_fm_pcd_stats, NULL);
+static DEVICE_ATTR(pcd_prs_fpm_command_stall_cycles             , S_IRUGO, show_fm_pcd_stats, NULL);
+
+static struct attribute *fm_dev_stats_attributes[] = {
+    &dev_attr_enq_total_frame.attr,
+    &dev_attr_deq_total_frame.attr,
+    &dev_attr_deq_0.attr,
+    &dev_attr_deq_1.attr,
+    &dev_attr_deq_2.attr,
+    &dev_attr_deq_from_default.attr,
+    &dev_attr_deq_from_context.attr,
+    &dev_attr_deq_from_fd.attr,
+    &dev_attr_deq_confirm.attr,
+    &dev_attr_cmq_not_empty.attr,
+    &dev_attr_bus_error.attr,
+    &dev_attr_read_buf_ecc_error.attr,
+    &dev_attr_write_buf_ecc_sys_error.attr,
+    &dev_attr_write_buf_ecc_fm_error.attr,
+    &dev_attr_pcd_enq_total_frame.attr,
+    &dev_attr_pcd_kg_total.attr,
+    &dev_attr_pcd_plcr_yellow.attr,
+    &dev_attr_pcd_plcr_red.attr,
+    &dev_attr_pcd_plcr_recolored_to_red.attr,
+    &dev_attr_pcd_plcr_recolored_to_yellow.attr,
+    &dev_attr_pcd_plcr_total.attr,
+    &dev_attr_pcd_plcr_length_mismatch.attr,
+    &dev_attr_pcd_prs_parse_dispatch.attr,
+    &dev_attr_pcd_prs_l2_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l3_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l4_parse_result_returned.attr,
+    &dev_attr_pcd_prs_shim_parse_result_returned.attr,
+    &dev_attr_pcd_prs_l2_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_l3_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_l4_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_shim_parse_result_returned_with_err.attr,
+    &dev_attr_pcd_prs_soft_prs_cycles.attr,
+    &dev_attr_pcd_prs_soft_prs_stall_cycles.attr,
+    &dev_attr_pcd_prs_hard_prs_cycle_incl_stall_cycles.attr,
+    &dev_attr_pcd_prs_muram_read_cycles.attr,
+    &dev_attr_pcd_prs_muram_read_stall_cycles.attr,
+    &dev_attr_pcd_prs_muram_write_cycles.attr,
+    &dev_attr_pcd_prs_muram_write_stall_cycles.attr,
+    &dev_attr_pcd_prs_fpm_command_stall_cycles.attr,
+    NULL
+};
+
+static const struct attribute_group fm_dev_stats_attr_grp = {
+    .name = "statistics",
+    .attrs = fm_dev_stats_attributes
+};
+
+static ssize_t show_fm_regs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = NULL;
+#endif
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    local_irq_save(flags);
+
+    n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+        return -EIO;
+    else
+        FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
+
+    local_irq_restore(flags);
+#else
+
+    local_irq_save(flags);
+    n = snprintf(buf, PAGE_SIZE, "Debug level is too low to dump registers!!!\n");
+    local_irq_restore(flags);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+    return n;
+}
+
+static ssize_t show_pcd_regs(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    unsigned long   flags;
+    unsigned n = 0;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = NULL;
+#endif
+
+    if (attr == NULL || buf == NULL || dev == NULL)
+        return -EINVAL;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    local_irq_save(flags);
+    n = snprintf(buf, PAGE_SIZE, "FM driver registers dump.\n");
+
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_PcdDev)
+        return -EIO;
+    else
+        FM_PCD_DumpRegs(p_LnxWrpFmDev->h_PcdDev);
+
+    local_irq_restore(flags);
+#else
+
+    local_irq_save(flags);
+    n = snprintf(buf, PAGE_SIZE,  "Debug level is too low to dump registers!!!\n");
+    local_irq_restore(flags);
+
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+    return n;
+}
+
+static DEVICE_ATTR(fm_regs, S_IRUGO, show_fm_regs, NULL);
+static DEVICE_ATTR(fm_pcd_regs, S_IRUGO, show_pcd_regs, NULL);
+
+static int fm_sysfs_create(struct device *dev)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+
+    if(dev == NULL)
+        return -EIO;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+
+    /* store to remove them when module si disabled */
+    p_LnxWrpFmDev->dev_attr_regs = &dev_attr_fm_regs;
+    p_LnxWrpFmDev->dev_pcd_attr_regs = &dev_attr_fm_pcd_regs;
+
+    /* Create sysfs statistics group for FM module */
+    if (sysfs_create_group(&dev->kobj, &fm_dev_stats_attr_grp) !=0)
+        return -EIO;
+
+    /* Registers dump entry - in future will be moved to debugfs */
+    if (device_create_file(dev,&dev_attr_fm_regs) != 0 ||
+        device_create_file(dev,&dev_attr_fm_pcd_regs) != 0)
+        return -EIO;
+
+    return 0;
+}
+
+static void fm_sysfs_distroy(struct device *dev)
+{
+    t_LnxWrpFmDev *p_LnxWrpFmDev = NULL;
+
+    if(dev == NULL)
+        BUG();
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev*)dev_get_drvdata(dev);
+    if(p_LnxWrpFmDev == NULL)
+        BUG();
+
+    /* this function has never been tested !!! */
+    sysfs_remove_group(&dev->kobj, &fm_dev_stats_attr_grp);
+    device_remove_file(dev,p_LnxWrpFmDev->dev_attr_regs);
+}
+
+static irqreturn_t fm_irq(int irq, void *_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+
+    if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
+        return IRQ_NONE;
+
+    FM_EventIsr(p_LnxWrpFmDev->h_Dev);
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t fm_err_irq(int irq, void *_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+
+    if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
+        return IRQ_NONE;
+
+    FM_ErrorIsr(p_LnxWrpFmDev->h_Dev);
+
+    return IRQ_HANDLED;
+}
+
+static volatile int   hcFrmRcv = 0;
+static spinlock_t     lock;
+/* used to protect FMD/LLD from concurent calls in functions fm_mutex_lock / fm_mutex_unlock */
+static struct mutex   lnxwrp_mutex;
+
+static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
+                                                   struct qman_fq              *fq,
+                                                   const struct qm_dqrr_entry  *dq)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = ((t_FmTestFq *)fq)->h_Arg;
+    unsigned long flags;
+
+    FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_DpaaFD *)&dq->fd);
+    spin_lock_irqsave(&lock, flags);
+    hcFrmRcv--;
+    spin_unlock_irqrestore(&lock, flags);
+
+    return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result qm_tx_dqrr_cb(struct qman_portal          *portal,
+                                              struct qman_fq              *fq,
+                                              const struct qm_dqrr_entry  *dq)
+{
+    BUG();
+    return qman_cb_dqrr_consume;
+}
+
+static void qm_err_cb(struct qman_portal       *portal,
+                       struct qman_fq           *fq,
+                       const struct qm_mr_entry *msg)
+{
+    BUG();
+}
+
+static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
+                                uint32_t        fqid,
+                                uint32_t        flags,
+                                uint16_t        channel,
+                                uint8_t         wq)
+{
+    int                     _errno;
+    struct qman_fq          *fq = NULL;
+    t_FmTestFq              *p_FmtFq;
+    struct qm_mcc_initfq    initfq;
+
+    p_FmtFq = (t_FmTestFq *)XX_Malloc(sizeof(t_FmTestFq));
+    if (!p_FmtFq) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj!!!"));
+        return NULL;
+    }
+
+    p_FmtFq->fq_base.cb.dqrr = (QMAN_FQ_FLAG_NO_ENQUEUE ? qm_tx_conf_dqrr_cb : qm_tx_dqrr_cb);
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = qm_err_cb;
+    p_FmtFq->h_Arg = (t_Handle)p_LnxWrpFmDev;
+    if (fqid == 0) {
+        flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+        flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+    } else {
+        flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+    }
+
+    if (qman_create_fq(fqid, flags, &p_FmtFq->fq_base)) {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_new_fq!!!"));
+        XX_Free(p_FmtFq);
+        return NULL;
+    }
+    fq = &p_FmtFq->fq_base;
+
+    if (!(flags & QMAN_FQ_FLAG_NO_MODIFY)) {
+        initfq.we_mask            = QM_INITFQ_WE_DESTWQ;
+        initfq.fqd.dest.channel   = channel;
+        initfq.fqd.dest.wq        = wq;
+
+        _errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+        if (unlikely(_errno < 0)) {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FQ obj - qman_init_fq!!!"));
+            qman_destroy_fq(fq, 0);
+            XX_Free(p_FmtFq);
+            return NULL;
+        }
+    }
+
+    DBG(TRACE, ("fqid %d, flags 0x%08x, channel %d, wq %d",qman_fq_fqid(fq),flags,channel,wq));
+
+    return fq;
+}
+
+static t_Error QmEnqueueCB (t_Handle h_Arg, void *p_Fd)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
+    int             _errno, timeout=1000000;
+    unsigned long flags;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    spin_lock_irqsave(&lock, flags);
+    hcFrmRcv++;
+    spin_unlock_irqrestore(&lock, flags);
+//MemDisp((uint8_t*)p_Fd,sizeof(t_DpaaFD));
+    _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
+    if (_errno)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("qman_enqueue() failed"));
+
+    while (hcFrmRcv && --timeout)
+    {
+        udelay(1);
+        cpu_relax();
+    }
+    if(timeout == 0)
+    {
+        dump_stack();
+        RETURN_ERROR(MINOR, E_WRITE_FAILED, ("timeout waiting for Tx confirmation"));
+        return E_WRITE_FAILED;
+    }
+
+    return E_OK;
+}
+
+static t_LnxWrpFmDev * CreateFmDev(uint8_t  id)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    int             j;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)XX_Malloc(sizeof(t_LnxWrpFmDev));
+    if (!p_LnxWrpFmDev)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        return NULL;
+    }
+
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+    p_LnxWrpFmDev->fmDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->fmPcdDevSettings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->fmPcdDevSettings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    p_LnxWrpFmDev->hcPort.settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+    memset(p_LnxWrpFmDev->hcPort.settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->rxPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->rxPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+    {
+        p_LnxWrpFmDev->txPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->txPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+    for (j=0; j<FM_MAX_NUM_OF_OH_PORTS-1; j++)
+    {
+        p_LnxWrpFmDev->opPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
+        memset(p_LnxWrpFmDev->opPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
+    }
+
+    return p_LnxWrpFmDev;
+}
+
+static void DistroyFmDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+    int             j;
+
+    for (j=0; j<FM_MAX_NUM_OF_OH_PORTS-1; j++)
+        if (p_LnxWrpFmDev->opPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->opPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
+        if (p_LnxWrpFmDev->txPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->txPorts[j].settings.advConfig);
+    for (j=0; j<FM_MAX_NUM_OF_RX_PORTS; j++)
+        if (p_LnxWrpFmDev->rxPorts[j].settings.advConfig)
+            XX_Free(p_LnxWrpFmDev->rxPorts[j].settings.advConfig);
+    if (p_LnxWrpFmDev->hcPort.settings.advConfig)
+        XX_Free(p_LnxWrpFmDev->hcPort.settings.advConfig);
+    if (p_LnxWrpFmDev->fmPcdDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmPcdDevSettings.advConfig);
+    if (p_LnxWrpFmDev->fmDevSettings.advConfig)
+        XX_Free(p_LnxWrpFmDev->fmDevSettings.advConfig);
+
+#ifdef NO_OF_SUPPORT
+    memset(p_LnxWrpFmDev, 0, sizeof(t_LnxWrpFmDev));
+#else
+    XX_Free(p_LnxWrpFmDev);
+#endif /* NO_OF_SUPPORT */
+}
+
+static t_Error FillRestFmInfo(t_LnxWrpFmDev *p_LnxWrpFmDev)
+{
+#define FM_BMI_PPIDS_OFFSET                 0x00080304
+#define FM_DMA_PLR_OFFSET                   0x000c2060
+#define FM_FPM_IP_REV_1_OFFSET              0x000c30c4
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+#define DMA_LIODN_SHIFT                     16
+
+typedef _Packed struct {
+    uint32_t    plr[32];
+} _PackedType t_Plr;
+
+typedef _Packed struct {
+   volatile uint32_t   fmbm_ppid[63];
+} _PackedType t_Ppids;
+
+    t_Plr       *p_Plr;
+    t_Ppids     *p_Ppids;
+    int         i,j;
+    uint32_t    fmRev;
+
+    static const uint8_t     phys1GRxPortId[] = {0x8,0x9,0xa,0xb,0xc};
+    static const uint8_t     phys10GRxPortId[] = {0x10};
+    static const uint8_t     physOhPortId[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
+    static const uint8_t     phys1GTxPortId[] = {0x28,0x29,0x2a,0x2b,0x2c};
+    static const uint8_t     phys10GTxPortId[] = {0x30};
+
+    fmRev = (uint32_t)(*((volatile uint32_t *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+FM_FPM_IP_REV_1_OFFSET)));
+    fmRev &= 0xffff;
+
+    p_Plr = (t_Plr *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+FM_DMA_PLR_OFFSET);
+#ifdef MODULE
+    for (i=0;i<FM_MAX_NUM_OF_PARTITIONS/2;i++)
+        p_Plr->plr[i] = 0;
+#endif /* MODULE */
+
+    for (i=0; i<FM_MAX_NUM_OF_PARTITIONS; i++)
+    {
+        uint16_t liodnBase = (uint16_t)((i%2) ?
+                       (p_Plr->plr[i/2] & DMA_LOW_LIODN_MASK) :
+                       ((p_Plr->plr[i/2] & DMA_HIGH_LIODN_MASK) >> DMA_LIODN_SHIFT));
+#ifdef FM_PARTITION_ARRAY
+        /* TODO: this was .liodnPerPartition[i] = liodnBase; is the index meaning the same? */
+        p_LnxWrpFmDev->fmDevSettings.param.liodnBasePerPort[i] = liodnBase;
+#endif /* FM_PARTITION_ARRAY */
+
+        if ((i >= phys1GRxPortId[0]) &&
+             (i <= phys1GRxPortId[FM_MAX_NUM_OF_1G_RX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys1GRxPortId); j++)
+                if (phys1GRxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys1GRxPortId));
+            p_LnxWrpFmDev->rxPorts[j].settings.param.liodnBase = liodnBase;
+        }
+        else if (FM_MAX_NUM_OF_10G_RX_PORTS &&
+                 (i >= phys10GRxPortId[0]) &&
+                 (i <= phys10GRxPortId[FM_MAX_NUM_OF_10G_RX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys10GRxPortId); j++)
+                if (phys10GRxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys10GRxPortId));
+            p_LnxWrpFmDev->rxPorts[FM_MAX_NUM_OF_1G_RX_PORTS+j].settings.param.liodnBase = liodnBase;
+        }
+        else if ((i >= physOhPortId[0]) &&
+                 (i <= physOhPortId[FM_MAX_NUM_OF_OH_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(physOhPortId); j++)
+                if (physOhPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(physOhPortId));
+            if (j == 0)
+                p_LnxWrpFmDev->hcPort.settings.param.liodnBase = liodnBase;
+            else
+                p_LnxWrpFmDev->opPorts[j - 1].settings.param.liodnBase = liodnBase;
+        }
+        else if ((i >= phys1GTxPortId[0]) &&
+                  (i <= phys1GTxPortId[FM_MAX_NUM_OF_1G_TX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys1GTxPortId); j++)
+                if (phys1GTxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys1GTxPortId));
+            p_LnxWrpFmDev->txPorts[j].settings.param.liodnBase = liodnBase;
+        }
+        else if (FM_MAX_NUM_OF_10G_TX_PORTS &&
+                 (i >= phys10GTxPortId[0]) &&
+                 (i <= phys10GTxPortId[FM_MAX_NUM_OF_10G_TX_PORTS-1]))
+        {
+            for (j=0; j<ARRAY_SIZE(phys10GTxPortId); j++)
+                if (phys10GTxPortId[j] == i)
+                    break;
+            ASSERT_COND(j<ARRAY_SIZE(phys10GTxPortId));
+            p_LnxWrpFmDev->txPorts[FM_MAX_NUM_OF_1G_TX_PORTS+j].settings.param.liodnBase = liodnBase;
+        }
+    }
+
+    p_Ppids = (t_Ppids *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET);
+
+    for (i=0; i<FM_MAX_NUM_OF_1G_RX_PORTS; i++)
+        /* TODO: this was .rxPartitionId = ; liodnOffset seems to have the same meaning */
+        p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.liodnOffset =
+                p_Ppids->fmbm_ppid[phys1GRxPortId[i]-1];
+
+    for (i=0; i<FM_MAX_NUM_OF_10G_RX_PORTS; i++)
+            p_LnxWrpFmDev->rxPorts[FM_MAX_NUM_OF_1G_RX_PORTS+i].settings.param.specificParams.rxParams.liodnOffset =
+                p_Ppids->fmbm_ppid[phys10GRxPortId[i]-1];
+
+#ifdef FM_OP_PARTITION_ERRATA_FMANx8
+    for (i=0; i<FM_MAX_NUM_OF_OH_PORTS; i++)
+    {
+        /* OH port #0 is host-command, don't need this workaround */
+        if (i == 0)
+            continue;
+        if (fmRev == 0x0100)
+            /* TODO: this was opPartitionId = ; opLiodnOffset seems to have the same meaning */
+            p_LnxWrpFmDev->opPorts[i-1].settings.param.specificParams.nonRxParams.opLiodnOffset =
+                p_Ppids->fmbm_ppid[physOhPortId[i]-1];
+    }
+#endif  /* FM_OP_PARTITION_ERRATA_FMANx8 */
+
+    return E_OK;
+}
+
+#ifndef NO_OF_SUPPORT
+/* The default address for the Fman microcode in flash. Having a default
+ * allows older systems to continue functioning.  0xEF000000 is the address
+ * where the firmware is normally on a P4080DS.
+ */
+#ifdef CONFIG_PHYS_64BIT
+static phys_addr_t P4080_UCAddr = 0xfef000000ull;
+#else
+static phys_addr_t P4080_UCAddr = 0xef000000;
+#endif
+
+
+/**
+ * FmanUcodeAddrParam - process the fman_ucode kernel command-line parameter
+ *
+ * This function is called when the kernel encounters a fman_ucode command-
+ * line parameter.  This parameter contains the address of the Fman microcode
+ * in flash.
+ */
+static int FmanUcodeAddrParam(char *str)
+{
+    unsigned long long l;
+    int ret;
+
+    ret = strict_strtoull(str, 0, &l);
+    if (!ret)
+        P4080_UCAddr = (phys_addr_t) l;
+
+    return ret;
+}
+__setup("fman_ucode=", FmanUcodeAddrParam);
+
+/**
+ * FindFmanMicrocode - find the Fman micrcode in memory
+ *
+ * This function returns a pointer to the QE Firmware blob that holds
+ * the Fman microcode.  We use the QE Firmware structure because Fman microcode
+ * is similar to QE microcode, so there's no point in defining a new layout.
+ *
+ * Current versions of U-Boot embed the Fman firmware into the device tree,
+ * so we check for that first.  Each Fman node in the device tree contains a
+ * node or a pointer to node that holds the firmware.  Technically, we should
+ * be fetching the firmware node for the current Fman, but we don't have that
+ * information any more, so we assume that there is only one firmware node in
+ * the device tree, and that all Fmen use the same firmware.
+ *
+ * If we have an older U-Boot, then we assume that the firmware is located in
+ * flash at physical address 'P4080_UCAddr'
+ */
+static const struct qe_firmware *FindFmanMicrocode(void)
+{
+    static const struct qe_firmware *P4080_UCPatch;
+    struct device_node *np;
+#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
+    unsigned long P4080_UCSize;
+    const struct qe_header *hdr;
+#endif
+
+    if (P4080_UCPatch)
+	    return P4080_UCPatch;
+
+    /* The firmware should be inside the device tree. */
+    np = of_find_compatible_node(NULL, NULL, "fsl,fman-firmware");
+    if (np) {
+	    P4080_UCPatch = of_get_property(np, "fsl,firmware", NULL);
+	    if (P4080_UCPatch)
+		    return P4080_UCPatch;
+	    else
+		    REPORT_ERROR(WARNING, E_NOT_FOUND, ("firmware node is incomplete"));
+    }
+
+#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
+    /* If not, then we have a legacy U-Boot.  The firmware is in flash. */
+    /* Only map enough to the get the core structure */
+    P4080_UCPatch = ioremap(P4080_UCAddr, sizeof(struct qe_firmware));
+    if (!P4080_UCPatch) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+        return NULL;
+    }
+    /* Make sure it really is a QE Firmware blob */
+    hdr = &P4080_UCPatch->header;
+    if (!hdr ||
+        (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+        (hdr->magic[2] != 'F')) {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
+        return NULL;
+    }
+
+    /* Now we call ioremap again, this time to pick up the whole blob. We never
+     * iounmap() the memory because we might reset the Fman at any time.
+     */
+    /* TODO: ionumap() should be performed when unloading the driver */
+    P4080_UCSize = sizeof(u32) * P4080_UCPatch->microcode[0].count;
+    iounmap((void *)P4080_UCPatch);
+    P4080_UCPatch = ioremap(P4080_UCAddr, P4080_UCSize);
+    if (!P4080_UCPatch) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, ("ioremap(%llx) returned NULL", (u64) P4080_UCAddr));
+        return NULL;
+    }
+#else
+    /* Returning NULL here forces the reuse of the IRAM content */
+    P4080_UCPatch = NULL;
+#endif /* FMAN_READ_MICROCODE_FROM_NOR_FLASH */
+    return P4080_UCPatch;
+}
+
+static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    struct device_node  *fm_node, *dev_node, *dpa_node;
+    struct of_device_id name;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+
+    fm_node = of_dev->node;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (*uint32_prop > INTG_MAX_NUM_OF_FM) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+        return NULL;
+    }
+    p_LnxWrpFmDev = CreateFmDev(*uint32_prop);
+    if (!p_LnxWrpFmDev) {
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        return NULL;
+    }
+    p_LnxWrpFmDev->dev = &of_dev->dev;
+    p_LnxWrpFmDev->id = *uint32_prop;
+
+    /* Get the FM interrupt */
+    p_LnxWrpFmDev->irq = of_irq_to_resource(fm_node, 0, NULL);
+    if (unlikely(p_LnxWrpFmDev->irq == /*NO_IRQ*/0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
+        return NULL;
+    }
+
+    /* Get the FM error interrupt */
+    p_LnxWrpFmDev->err_irq = of_irq_to_resource(fm_node, 1, NULL);
+    /* TODO - un-comment it once there will be err_irq in the DTS */
+#if 0
+    if (unlikely(p_LnxWrpFmDev->err_irq == /*NO_IRQ*/0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
+        return NULL;
+    }
+#endif /* 0 */
+
+    /* Get the FM address */
+    _errno = of_address_to_resource(fm_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev->fmBaseAddr = res.start;
+    p_LnxWrpFmDev->fmMemSize = res.end + 1 - res.start;
+
+    uint32_prop = (uint32_t *)of_get_property(fm_node, "clock-frequency", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, clock-frequency) failed", fm_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    p_LnxWrpFmDev->fmDevSettings.param.fmClkFreq = (*uint32_prop + 500000)/1000000; /* In MHz, rounded */
+
+    /* Get the MURAM base address and size */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("muram") >= sizeof(name.name));
+    strcpy(name.name, "muram");
+    BUG_ON(strlen("fsl,fman-muram") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-muram");
+    for_each_child_of_node(fm_node, dev_node) {
+        if (likely(of_match_node(&name, dev_node) != NULL)) {
+            _errno = of_address_to_resource(dev_node, 0, &res);
+            if (unlikely(_errno < 0)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+                return NULL;
+            }
+
+            p_LnxWrpFmDev->fmMuramBaseAddr = res.start;
+            p_LnxWrpFmDev->fmMuramMemSize = res.end + 1 - res.start;
+        }
+    }
+
+    /* Get the RTC base address and size */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("rtc") >= sizeof(name.name));
+    strcpy(name.name, "rtc");
+    BUG_ON(strlen("fsl,fman-rtc") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-rtc");
+    for_each_child_of_node(fm_node, dev_node) {
+        if (likely(of_match_node(&name, dev_node) != NULL)) {
+            _errno = of_address_to_resource(dev_node, 0, &res);
+            if (unlikely(_errno < 0)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+                return NULL;
+            }
+
+            p_LnxWrpFmDev->fmRtcBaseAddr = res.start;
+            p_LnxWrpFmDev->fmRtcMemSize = res.end + 1 - res.start;
+        }
+    }
+
+    /* Get all PCD nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("parser") >= sizeof(name.name));
+    strcpy(name.name, "parser");
+    BUG_ON(strlen("fsl,fman-parser") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-parser");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->prsActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("keygen") >= sizeof(name.name));
+    strcpy(name.name, "keygen");
+    BUG_ON(strlen("fsl,fman-keygen") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-keygen");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->kgActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("cc") >= sizeof(name.name));
+    strcpy(name.name, "cc");
+    BUG_ON(strlen("fsl,fman-cc") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-cc");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->ccActive = TRUE;
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("policer") >= sizeof(name.name));
+    strcpy(name.name, "policer");
+    BUG_ON(strlen("fsl,fman-policer") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman-policer");
+    for_each_child_of_node(fm_node, dev_node)
+        if (likely(of_match_node(&name, dev_node) != NULL))
+            p_LnxWrpFmDev->plcrActive = TRUE;
+
+    if (p_LnxWrpFmDev->prsActive || p_LnxWrpFmDev->kgActive ||
+        p_LnxWrpFmDev->ccActive || p_LnxWrpFmDev->plcrActive)
+        p_LnxWrpFmDev->pcdActive = TRUE;
+
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        const char *str_prop = (char *)of_get_property(fm_node, "fsl,default-pcd", &lenp);
+        if (str_prop) {
+            if (strncmp(str_prop, "3-tuple", strlen("3-tuple")) == 0)
+                p_LnxWrpFmDev->defPcd = e_FM_PCD_3_TUPLE;
+        }
+        else
+            p_LnxWrpFmDev->defPcd = e_NO_PCD;
+    }
+
+    of_node_put(fm_node);
+
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,dpa-ethernet") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,dpa-ethernet");
+    for_each_matching_node(dpa_node, &name) {
+        struct device_node  *mac_node;
+        const phandle       *phandle_prop;
+
+        phandle_prop = (typeof(phandle_prop))of_get_property(dpa_node, "fsl,fman-mac", &lenp);
+        if (phandle_prop == NULL)
+            continue;
+
+        BUG_ON(lenp != sizeof(phandle));
+
+        mac_node = of_find_node_by_phandle(*phandle_prop);
+        if (unlikely(mac_node == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_find_node_by_phandle() failed"));
+            return NULL;
+        }
+
+        fm_node = of_get_parent(mac_node);
+        if (unlikely(fm_node == NULL)) {
+            REPORT_ERROR(MAJOR, E_NO_DEVICE, ("of_get_parent() = %d", _errno));
+            return NULL;
+        }
+        of_node_put(mac_node);
+
+        uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
+        if (unlikely(uint32_prop == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        of_node_put(fm_node);
+
+        if (*uint32_prop == p_LnxWrpFmDev->id) {
+            phandle_prop = (typeof(phandle_prop))of_get_property(dpa_node, "fsl,qman-channel", &lenp);
+            if (unlikely(phandle_prop == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, fsl,qman-channel) failed", dpa_node->full_name));
+                return NULL;
+            }
+            BUG_ON(lenp != sizeof(phandle));
+
+            dev_node = of_find_node_by_phandle(*phandle_prop);
+            if (unlikely(dev_node == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_find_node_by_phandle() failed"));
+                return NULL;
+            }
+
+            uint32_prop = (typeof(uint32_prop))of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
+            if (unlikely(uint32_prop == NULL)) {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, fsl,qman-channel-id) failed", dev_node->full_name));
+                of_node_put(dev_node);
+                return NULL;
+            }
+            of_node_put(dev_node);
+            BUG_ON(lenp != sizeof(uint32_t));
+            p_LnxWrpFmDev->hcCh = *uint32_prop;
+            break;
+        }
+    }
+
+    p_LnxWrpFmDev->active = TRUE;
+
+    return p_LnxWrpFmDev;
+}
+
+static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    struct device_node  *fm_node, *port_node;
+    struct resource     res;
+    const uint32_t      *uint32_prop;
+    int                 _errno=0, lenp;
+#ifdef CONFIG_FMAN_P1023
+    static unsigned char have_oh_port = 0;
+#endif
+
+    port_node = of_dev->node;
+
+    /* Get the FM node */
+    fm_node = of_get_parent(port_node);
+    if (unlikely(fm_node == NULL)) {
+        REPORT_ERROR(MAJOR, E_NO_DEVICE, ("of_get_parent() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmDev = dev_get_drvdata(&of_find_device_by_node(fm_node)->dev);
+    of_node_put(fm_node);
+
+    /* if fm_probe() failed, no point in going further with port probing */
+    if (p_LnxWrpFmDev == NULL)
+        return NULL;
+
+    uint32_prop = (uint32_t *)of_get_property(port_node, "cell-index", &lenp);
+    if (unlikely(uint32_prop == NULL)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+        return NULL;
+    }
+    BUG_ON(lenp != sizeof(uint32_t));
+    if (of_device_is_compatible(port_node, "fsl,fman-port-oh")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OH_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+
+#ifdef CONFIG_FMAN_P1023
+        /* Beware, this can be done when there is only one FMan to be initialized */
+        if (!have_oh_port) {
+            have_oh_port = 1; /* first OP/HC port is used for host command */
+#else
+        /* Here it is hardcoded the use of the OH port 1 (with cell-index 0) */
+        if (*uint32_prop == 0) {
+#endif
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+            p_LnxWrpFmPortDev->id = 0;
+            //p_LnxWrpFmPortDev->id = *uint32_prop-1;
+            //p_LnxWrpFmPortDev->id = *uint32_prop;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OH_HOST_COMMAND;
+        }
+        else {
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[*uint32_prop-1];
+            p_LnxWrpFmPortDev->id = *uint32_prop-1;
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_OH_OFFLINE_PARSING;
+        }
+        p_LnxWrpFmPortDev->settings.param.portId = *uint32_prop;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+//            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            XX_Print("FM warning: missing fsl,qman-channel-id for OH port.\n");
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.qmChannel = p_LnxWrpFmPortDev->txCh;
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_TX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop+FM_MAX_NUM_OF_1G_TX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX;
+
+        uint32_prop = (uint32_t *)of_get_property(port_node, "fsl,qman-channel-id", &lenp);
+        if (uint32_prop == NULL) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("missing fsl,qman-channel-id"));
+            return NULL;
+        }
+        BUG_ON(lenp != sizeof(uint32_t));
+        p_LnxWrpFmPortDev->txCh = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.qmChannel = p_LnxWrpFmPortDev->txCh;
+    }
+    else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx") ||
+             of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_RX_PORTS)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
+            return NULL;
+        }
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop+FM_MAX_NUM_OF_1G_RX_PORTS];
+        else
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+
+        p_LnxWrpFmPortDev->id = *uint32_prop;
+        p_LnxWrpFmPortDev->settings.param.portId = p_LnxWrpFmPortDev->id;
+        if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx"))
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX_10G;
+        else
+            p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX;
+
+        if (p_LnxWrpFmDev->pcdActive)
+            p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
+    }
+    else {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
+        return NULL;
+    }
+
+    _errno = of_address_to_resource(port_node, 0, &res);
+    if (unlikely(_errno < 0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_address_to_resource() = %d", _errno));
+        return NULL;
+    }
+
+    p_LnxWrpFmPortDev->dev = &of_dev->dev;
+    p_LnxWrpFmPortDev->baseAddr = res.start;
+    p_LnxWrpFmPortDev->memSize = res.end + 1 - res.start;
+    p_LnxWrpFmPortDev->settings.param.h_Fm = p_LnxWrpFmDev->h_Dev;
+    p_LnxWrpFmPortDev->h_LnxWrpFmDev = (t_Handle)p_LnxWrpFmDev;
+
+    of_node_put(port_node);
+
+    p_LnxWrpFmPortDev->active = TRUE;
+
+    return p_LnxWrpFmPortDev;
+}
+#endif /* !NO_OF_SUPPORT */
+
+static void LnxwrpFmDevExceptionsCb(t_Handle h_App, e_FmExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmDevBusErrorCb(t_Handle        h_App,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint64_t        addr,
+                                  uint8_t         tnum,
+                                  uint16_t        liodn)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    /* do nothing */
+    UNUSED(portType);UNUSED(portId);UNUSED(addr);UNUSED(tnum);UNUSED(liodn);
+}
+
+static void LnxwrpFmPcdDevExceptionsCb( t_Handle h_App, e_FmPcdExceptions exception)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd exception %d", exception));
+
+    /* do nothing */
+    UNUSED(exception);
+}
+
+static void LnxwrpFmPcdDevIndexedExceptionsCb(t_Handle          h_App,
+                                              e_FmPcdExceptions exception,
+                                              uint16_t          index)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)h_App;
+
+    ASSERT_COND(p_LnxWrpFmDev);
+
+    DBG(INFO, ("got fm-pcd-indexed exception %d, indx %d", exception, index));
+
+    /* do nothing */
+    UNUSED(exception);UNUSED(index);
+}
+
+static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    struct resource     *dev_res;
+    int                 _errno;
+    uint64_t            fmPhysAddr, muramPhysAddr;
+
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    _errno = can_request_irq(p_LnxWrpFmDev->irq, 0);
+    if (unlikely(_errno < 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("can_request_irq() = %d", _errno));
+    _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->irq, fm_irq, 0, "fman", p_LnxWrpFmDev);
+    if (unlikely(_errno < 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->irq, _errno));
+
+    if (p_LnxWrpFmDev->err_irq != 0) {
+        _errno = can_request_irq(p_LnxWrpFmDev->err_irq, 0);
+        if (unlikely(_errno < 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("can_request_irq() = %d", _errno));
+        _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->err_irq, fm_err_irq, IRQF_SHARED, "fman-err", p_LnxWrpFmDev);
+        if (unlikely(_errno < 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->err_irq, _errno));
+    }
+
+    fmPhysAddr = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->res = devm_request_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize, "fman");
+    if (unlikely(p_LnxWrpFmDev->res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_mem_region() failed"));
+
+    p_LnxWrpFmDev->fmBaseAddr = PTR_TO_UINT(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize));
+    if (unlikely(p_LnxWrpFmDev->fmBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    muramPhysAddr = p_LnxWrpFmDev->fmMuramBaseAddr;
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize, "fman-muram");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+
+    p_LnxWrpFmDev->fmMuramBaseAddr = PTR_TO_UINT(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize));
+    if (unlikely(p_LnxWrpFmDev->fmMuramBaseAddr == 0))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmMuramBaseAddr, (uint64_t)muramPhysAddr, p_LnxWrpFmDev->fmMuramMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM MURAM memory map"));
+
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        uint64_t rtcPhysAddr = p_LnxWrpFmDev->fmRtcBaseAddr;
+        dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize, "fman-rtc");
+        if (unlikely(dev_res == NULL))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+
+        p_LnxWrpFmDev->fmRtcBaseAddr = PTR_TO_UINT(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize));
+        if (unlikely(p_LnxWrpFmDev->fmRtcBaseAddr == 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+        if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmRtcBaseAddr, (uint64_t)rtcPhysAddr, p_LnxWrpFmDev->fmRtcMemSize) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC memory map"));
+    }
+
+    if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr, (uint64_t)fmPhysAddr, p_LnxWrpFmDev->fmMemSize) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM memory map"));
+
+    p_LnxWrpFmDev->fmDevSettings.param.baseAddr     = p_LnxWrpFmDev->fmBaseAddr;
+    p_LnxWrpFmDev->fmDevSettings.param.fmId         = p_LnxWrpFmDev->id;
+    p_LnxWrpFmDev->fmDevSettings.param.irq          = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.errIrq       = NO_IRQ;
+    p_LnxWrpFmDev->fmDevSettings.param.f_Exception  = LnxwrpFmDevExceptionsCb;
+    p_LnxWrpFmDev->fmDevSettings.param.f_BusError   = LnxwrpFmDevBusErrorCb;
+    p_LnxWrpFmDev->fmDevSettings.param.h_App        = p_LnxWrpFmDev;
+
+    return FillRestFmInfo(p_LnxWrpFmDev);
+}
+
+static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    struct resource     *dev_res;
+
+    if (!p_LnxWrpFmPortDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM port not configured!!!"));
+
+    dev_res = __devm_request_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize, "fman-port-hc");
+    if (unlikely(dev_res == NULL))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("__devm_request_region() failed"));
+    p_LnxWrpFmPortDev->baseAddr = PTR_TO_UINT(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize));
+    if (unlikely(p_LnxWrpFmPortDev->baseAddr == 0))
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
+
+    p_LnxWrpFmPortDev->settings.param.baseAddr = p_LnxWrpFmPortDev->baseAddr;
+
+    return E_OK;
+}
+
+static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (p_LnxWrpFmDev->pcdActive)
+    {
+        t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        t_FmPcdParams       fmPcdParams;
+        t_Error             err;
+
+        memset(&fmPcdParams, 0, sizeof(fmPcdParams));
+        fmPcdParams.h_Fm        = p_LnxWrpFmDev->h_Dev;
+        fmPcdParams.prsSupport  = p_LnxWrpFmDev->prsActive;
+        fmPcdParams.kgSupport   = p_LnxWrpFmDev->kgActive;
+        fmPcdParams.plcrSupport = p_LnxWrpFmDev->plcrActive;
+        fmPcdParams.ccSupport   = p_LnxWrpFmDev->ccActive;
+        fmPcdParams.numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+
+#ifndef CONFIG_GUEST_PARTITION
+        fmPcdParams.f_Exception   = LnxwrpFmPcdDevExceptionsCb;
+        if (fmPcdParams.kgSupport)
+            fmPcdParams.f_ExceptionId  = LnxwrpFmPcdDevIndexedExceptionsCb;
+        fmPcdParams.h_App              = p_LnxWrpFmDev;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        fmPcdParams.numOfSchemes = 0;
+        fmPcdParams.numOfClsPlanEntries = 0;
+        fmPcdParams.partitionId = 0;
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+        fmPcdParams.useHostCommand = TRUE;
+
+        p_LnxWrpFmDev->hc_tx_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_TO_DCPORTAL,
+                    p_LnxWrpFmPortDev->txCh,
+                    0);
+        if(!p_LnxWrpFmDev->hc_tx_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
+
+        p_LnxWrpFmDev->hc_tx_conf_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    p_LnxWrpFmDev->hcCh,
+                    7);
+        if(!p_LnxWrpFmDev->hc_tx_conf_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
+
+        p_LnxWrpFmDev->hc_tx_err_fq  =
+            FqAlloc(p_LnxWrpFmDev,
+                    0,
+                    QMAN_FQ_FLAG_NO_ENQUEUE,
+                    p_LnxWrpFmDev->hcCh,
+                    7);
+        if(!p_LnxWrpFmDev->hc_tx_err_fq)
+            RETURN_ERROR(MAJOR, E_NULL_POINTER, ("Frame queue allocation failed..."));
+
+        fmPcdParams.hc.portBaseAddr = p_LnxWrpFmPortDev->baseAddr;
+        fmPcdParams.hc.portId = p_LnxWrpFmPortDev->settings.param.portId;
+        fmPcdParams.hc.liodnBase = p_LnxWrpFmPortDev->settings.param.liodnBase;
+        fmPcdParams.hc.errFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_err_fq);
+        fmPcdParams.hc.confFqid = qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
+        fmPcdParams.hc.qmChannel = p_LnxWrpFmPortDev->txCh;
+        fmPcdParams.hc.f_QmEnqueue = QmEnqueueCB;
+        fmPcdParams.hc.h_QmArg = (t_Handle)p_LnxWrpFmDev;
+
+        p_LnxWrpFmDev->h_PcdDev = FM_PCD_Config(&fmPcdParams);
+        if(!p_LnxWrpFmDev->h_PcdDev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+        if((err = FM_PCD_ConfigPlcrNumOfSharedProfiles(p_LnxWrpFmDev->h_PcdDev,
+                                                       LNXWRP_FM_NUM_OF_SHARED_PROFILES))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if (p_LnxWrpFmDev->err_irq == 0) {
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,FALSE);
+        }
+    }
+
+    return E_OK;
+}
+
+static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    const struct qe_firmware *fw;
+
+    if (!p_LnxWrpFmDev->active)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
+
+    if ((p_LnxWrpFmDev->h_MuramDev = FM_MURAM_ConfigAndInit(p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM!"));
+
+    /* Loading the fman-controller code */
+    fw = FindFmanMicrocode();
+
+    if (!fw) {
+#ifdef FMAN_READ_MICROCODE_FROM_NOR_FLASH
+        /* We already reported an error, so just return NULL*/
+        return ERROR_CODE(E_NULL_POINTER);
+#else
+        /* this forces the reuse of the current IRAM content */
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.size = 0;
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code = NULL;
+#endif
+    } else {
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.p_Code =
+            (void *) fw + fw->microcode[0].code_offset;
+        p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
+            sizeof(u32) * fw->microcode[0].count;
+        DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
+                   fw->microcode[0].major,
+                   fw->microcode[0].minor,
+                   fw->microcode[0].revision));
+    }
+
+    p_LnxWrpFmDev->fmDevSettings.param.h_FmMuram = p_LnxWrpFmDev->h_MuramDev;
+
+    if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
+
+    if (FM_ConfigMaxNumOfOpenDmas(p_LnxWrpFmDev->h_Dev,BMI_MAX_NUM_OF_DMAS) != E_OK)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+    if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+#ifdef CONFIG_FMAN_P1023
+    if (FM_ConfigDmaAidOverride(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+#endif
+
+    if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+
+    if (p_LnxWrpFmDev->err_irq == 0) {
+        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_DMA_BUS_ERROR,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_READ_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_SYSTEM_WRITE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_FM_WRITE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_STALL_ON_TASKS , FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_DOUBLE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
+        /* TODO: FmDisableRamsEcc assert for ramsEccOwners.
+         * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DOUBLE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_LIST_RAM_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_PIPELINE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STATISTICS_RAM_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_SINGLE_ECC, FALSE);
+    }
+
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        t_FmRtcParams   fmRtcParam;
+
+        memset(&fmRtcParam, 0, sizeof(fmRtcParam));
+        fmRtcParam.h_App = p_LnxWrpFmDev;
+        fmRtcParam.h_Fm = p_LnxWrpFmDev->h_Dev;
+        fmRtcParam.baseAddress = p_LnxWrpFmDev->fmRtcBaseAddr;
+
+        if(!(p_LnxWrpFmDev->h_RtcDev = FM_RTC_Config(&fmRtcParam)))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-RTC"));
+
+        if (FM_RTC_Init(p_LnxWrpFmDev->h_RtcDev) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-RTC"));
+    }
+
+//    return InitFmPcdDev(p_LnxWrpFmDev);
+    return E_OK;
+}
+
+static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev                       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    t_FmPcdNetEnvParams                 *p_netEnvParam = NULL;
+    t_FmPcdKgSchemeParams               *p_schemeParam = NULL;
+    t_FmPortPcdParams                   pcdParam;
+    t_FmPortPcdPrsParams                prsParam;
+    t_FmPortPcdKgParams                 kgParam;
+    uint8_t                             i, j;
+
+    if (!p_LnxWrpFmDev->kgActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keygen must be enabled for 3-tuple PCD!"));
+
+    if (!p_LnxWrpFmDev->prsActive)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser must be enabled for 3-tuple PCD!"));
+
+    if (p_LnxWrpFmPortDev->pcdNumOfQs < 9)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Need to save at least 18 queues for 3-tuple PCD!!!"));
+
+    p_LnxWrpFmPortDev->totalNumOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed = 2;
+
+    if (AllocSchemesForPort(p_LnxWrpFmDev, p_LnxWrpFmPortDev->totalNumOfSchemes, &p_LnxWrpFmPortDev->schemesBase) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No schemes for Rx or OP port for 3-tuple PCD!!!"));
+
+    p_netEnvParam = kzalloc(sizeof(*p_netEnvParam), GFP_KERNEL);
+    if (!p_netEnvParam) {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Failed to allocate p_netEnvParam"));
+    }
+    /* set netEnv */
+    p_netEnvParam->numOfDistinctionUnits = 2;
+    p_netEnvParam->units[0].hdrs[0].hdr = HEADER_TYPE_IPv4; /* no special options */
+    p_netEnvParam->units[1].hdrs[0].hdr = HEADER_TYPE_ETH;
+    p_LnxWrpFmPortDev->h_DefNetEnv = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, p_netEnvParam);
+    kfree(p_netEnvParam);
+    if(!p_LnxWrpFmPortDev->h_DefNetEnv)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
+
+    p_schemeParam = kmalloc(sizeof(*p_schemeParam), GFP_KERNEL);
+    if (!p_schemeParam) {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Failed to allocate p_schemeParam"));
+    }
+    for(i=0; i<p_LnxWrpFmPortDev->numOfSchemesUsed; i++)
+    {
+        memset(p_schemeParam, 0, sizeof(*p_schemeParam));
+        p_schemeParam->modify = FALSE;
+        p_schemeParam->id.relativeSchemeId = i+p_LnxWrpFmPortDev->schemesBase;
+        p_schemeParam->alwaysDirect = FALSE;
+        p_schemeParam->netEnvParams.h_NetEnv = p_LnxWrpFmPortDev->h_DefNetEnv;
+        p_schemeParam->schemeCounter.update = TRUE;
+        p_schemeParam->schemeCounter.value = 0;
+
+        switch (i)
+        {
+            case (0): /* catch IPv4 */
+                p_schemeParam->netEnvParams.numOfDistinctionUnits = 1;
+                p_schemeParam->netEnvParams.unitIds[0] = 0;
+                p_schemeParam->baseFqid = p_LnxWrpFmPortDev->pcdBaseQ;
+                p_schemeParam->nextEngine = e_FM_PCD_DONE;
+                p_schemeParam->numOfUsedExtractedOrs = 0;
+                p_schemeParam->useHash = TRUE;
+                p_schemeParam->keyExtractAndHashParams.numOfUsedExtracts = 3;
+                for(j=0; j<p_schemeParam->keyExtractAndHashParams.numOfUsedExtracts; j++)
+                {
+                    p_schemeParam->keyExtractAndHashParams.extractArray[j].type = e_FM_PCD_EXTRACT_BY_HDR;
+                    p_schemeParam->keyExtractAndHashParams.extractArray[j].extractByHdr.hdr = HEADER_TYPE_IPv4;
+                    p_schemeParam->keyExtractAndHashParams.extractArray[j].extractByHdr.ignoreProtocolValidation = FALSE;
+                    p_schemeParam->keyExtractAndHashParams.extractArray[j].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+                }
+                p_schemeParam->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+                p_schemeParam->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+                p_schemeParam->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+
+                if(p_schemeParam->useHash)
+                {
+                    p_schemeParam->keyExtractAndHashParams.privateDflt0 = 0x01020304;
+                    p_schemeParam->keyExtractAndHashParams.privateDflt1 = 0x11121314;
+                    p_schemeParam->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+                    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+                    {
+                        p_schemeParam->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+                        p_schemeParam->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+                    }
+                    p_schemeParam->keyExtractAndHashParams.numOfUsedMasks = 0;
+                    p_schemeParam->keyExtractAndHashParams.hashShift = 0;
+                    p_schemeParam->keyExtractAndHashParams.hashDistributionNumOfFqids = 8;
+                }
+                break;
+
+            case (1): /* Garbage collector */
+                p_schemeParam->netEnvParams.numOfDistinctionUnits = 0;
+                p_schemeParam->baseFqid = p_LnxWrpFmPortDev->pcdBaseQ+8;
+                break;
+
+            default:
+                break;
+        }
+
+        p_LnxWrpFmPortDev->h_Schemes[i] = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, p_schemeParam);
+        if(!p_LnxWrpFmPortDev->h_Schemes[i]) {
+            kfree(p_schemeParam);
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_KgSetScheme failed"));
+        }
+    }
+    kfree(p_schemeParam);
+
+    /* initialize PCD parameters */
+    memset(&pcdParam, 0, sizeof( t_FmPortPcdParams));
+    pcdParam.h_NetEnv   = p_LnxWrpFmPortDev->h_DefNetEnv;
+    pcdParam.pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG;
+
+    /* initialize Keygen parameters */
+    memset(&prsParam, 0, sizeof( t_FmPortPcdPrsParams));
+
+    prsParam.parsingOffset = 0;
+    prsParam.firstPrsHdr = HEADER_TYPE_ETH;
+    pcdParam.p_PrsParams = &prsParam;
+
+    /* initialize Parser parameters */
+    memset(&kgParam, 0, sizeof( t_FmPortPcdKgParams));
+    kgParam.numOfSchemes = p_LnxWrpFmPortDev->numOfSchemesUsed;
+    for(i=0;i<kgParam.numOfSchemes;i++)
+        kgParam.h_Schemes[i] = p_LnxWrpFmPortDev->h_Schemes[i];
+
+    pcdParam.p_KgParams = &kgParam;
+
+    return FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, &pcdParam);
+}
+
+static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+#define MY_ADV_CONFIG_CHECK_END                                 \
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION,            \
+                         ("Advanced configuration routine"));   \
+        if (errCode != E_OK)                                    \
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);               \
+    }
+
+    int                 i = 0;
+
+    if (!p_LnxWrpFmPortDev->active || p_LnxWrpFmPortDev->h_Dev)
+        return E_INVALID_STATE;
+
+    if ((p_LnxWrpFmPortDev->h_Dev = FM_PORT_Config(&p_LnxWrpFmPortDev->settings.param)) == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
+
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX))
+    {
+        t_Error errCode = E_OK;
+        if ((errCode = FM_PORT_ConfigDeqHighPriority(p_LnxWrpFmPortDev->h_Dev, TRUE)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+        if ((errCode = FM_PORT_ConfigDeqPrefetchOption(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_DEQ_FULL_PREFETCH)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+    }
+
+    /* Call the driver's advanced configuration routines, if requested:
+       Compare the function pointer of each entry to the available routines,
+       and invoke the matching routine with proper casting of arguments. */
+    while (p_LnxWrpFmPortDev->settings.advConfig[i].p_Function && (i < FM_MAX_NUM_OF_ADV_SETTINGS))
+    {
+        ADV_CONFIG_CHECK_START(&(p_LnxWrpFmPortDev->settings.advConfig[i]))
+
+        ADV_CONFIG_CHECK(p_LnxWrpFmPortDev->h_Dev, FM_PORT_ConfigBufferPrefixContent,   PARAMS(1, (t_FmPortBufferPrefixContent*)))
+
+        MY_ADV_CONFIG_CHECK_END
+
+        /* Advance to next advanced configuration entry */
+        i++;
+    }
+
+    if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    /* Set for 10G ports for performance purposes... */
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        t_Error      errCode = E_OK;
+        t_FmPortRsrc numOfOpenDmas;
+        numOfOpenDmas.num = FM_PORT_10G_NUM_OF_OPEN_DMA;
+        numOfOpenDmas.extra = 0;
+        if ((errCode = FM_PORT_SetNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev, &numOfOpenDmas)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+    }
+
+    /*Do we still need this one?*/
+#if 0
+    {
+        t_FmPortRsrc    portRsrc;
+        t_Error         errCode;
+
+        if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
+//              portRsrc.num = (6 + 3 + 7) * 256; /* on P4080, and for MAXFRM=1522 */
+            portRsrc.num = 21*1024;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+//              portRsrc.num = (7 + 7) * 256; /* on P4080, for bpool size=1588 */
+            portRsrc.num = 22*1024 + 512;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)
+//              portRsrc.num = (6 + 3 + 1) * 256; /* on both P4080 and P1023, for MAXFRM=1522 */
+            portRsrc.num = 10*1024 + 768;
+        else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)
+//              portRsrc.num = (7 + 7) * 256; /* on P4080, for bpool size=1588 */
+            portRsrc.num = 10*1024;
+        else
+//              portRsrc.num = (2 + 4) * 256; /* on P4080 (>> ?BMI brings only the frame header? <<) */
+            portRsrc.num = 1536; /* OH ports */
+
+       /* Using the following formulae (*), under a set of simplifying assumptions (.):
+        *  . all ports are configured in Normal Mode (rather than Independent Mode)
+        *  . the DPAA Eth driver allocates buffers of size:
+        *      . MAXFRM + NET_IP_ALIGN + DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + DPA_HASH_RESULTS_SIZE, i.e.:
+        *        MAXFRM + 2 + 16 + sizeof(t_FmPrsResult) + 16, i.e.:
+        *        MAXFRM + 66
+        *  . excessive buffer pools not accounted for
+        *
+        *  * for Rx ports on P4080:
+        *      . IFSZ = ceil(max(FMBM_EBMPI[PBS]) / 256) * 256 + 7 * 256
+        *      . no internal frame offset (FMBM_RIM[FOF] == 0) - otherwise, add up to 256 to the above
+        *
+        *  * for Rx ports on P1023:
+        *      . IFSZ = ceil(second_largest(FMBM_EBMPI[PBS] / 256)) * 256 + 7 * 256, if at least 2 bpools are configured
+        *      . IFSZ = 8 * 256, if only a single bpool is configured
+        *
+        *  * for Tx ports:
+        *      . IFSZ = ceil(frame_size / 256) * 256 + 3 * 256 + FMBM_TFP[DPDE] * 256, i.e.:
+        *        IFSZ = ceil(MAXFRM / 256) * 256 + 3 x 256 + FMBM_TFP[DPDE] * 256
+        *
+        *  * for OH ports on P4080:
+        *      . IFSZ = ceil(frame_size / 256) * 256 + 1 * 256 + FMBM_PP[MXT] * 256
+        *  * for OH ports on P1023:
+        *      . IFSZ = ceil(frame_size / 256) * 256 + 3 * 256 + FMBM_TFP[DPDE] * 256
+        *  * for both P4080 and P1023:
+        *      . (conservative decisions, assuming that BMI must bring the entire frame, not only the frame header)
+        *      . no internal frame offset (FMBM_OIM[FOF] == 0) - otherwise, add up to 256 to the above
+        *
+        *  . for P4080/P5020/P3041/P2040, DPDE is:
+        *              > 0 or 1, for 1Gb ports, HW default: 0
+        *              > 2..7 (recommended: 3..7) for 10Gb ports, HW default: 3
+        *  . for P1023, DPDE should be 1
+        *
+        *  . for P1023, MXT is in range (0..31)
+        *  . for P4080, MXT is in range (0..63)
+        *
+        */
+
+        portRsrc.extra = 0;
+        if ((errCode = FM_PORT_SetSizeOfFifo(p_LnxWrpFmPortDev->h_Dev, &portRsrc)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+    }
+#endif
+/* TODO: Implement f_FM_MAC_SetException...
+    if (((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev)->err_irq == 0) {
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_CMD_CMPL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_REM_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_LOC_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_1TX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_UNFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_JAB_FRM,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_OVRSZ_FRM,FALSE);
+    }
+*/
+
+    if ((p_LnxWrpFmPortDev->defPcd != e_NO_PCD) &&
+        (InitFmPort3TupleDefPcd(p_LnxWrpFmPortDev) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    return E_OK;
+}
+
+static void FreeFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
+{
+    if (!p_LnxWrpFmDev->active)
+        return;
+
+    if (p_LnxWrpFmDev->h_PcdDev)
+        FM_PCD_Free(p_LnxWrpFmDev->h_PcdDev);
+
+    if (p_LnxWrpFmDev->h_Dev)
+        FM_Free(p_LnxWrpFmDev->h_Dev);
+
+    if (p_LnxWrpFmDev->h_MuramDev)
+        FM_MURAM_Free(p_LnxWrpFmDev->h_MuramDev);
+
+    if (p_LnxWrpFmDev->fmRtcBaseAddr)
+    {
+        SYS_UnregisterIoMap(p_LnxWrpFmDev->fmRtcBaseAddr);
+        devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmDev->fmRtcBaseAddr));
+        __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmRtcBaseAddr, p_LnxWrpFmDev->fmRtcMemSize);
+    }
+    SYS_UnregisterIoMap(p_LnxWrpFmDev->fmMuramBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmDev->fmMuramBaseAddr));
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize);
+    SYS_UnregisterIoMap(p_LnxWrpFmDev->fmBaseAddr);
+    devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr));
+    release_mem_region(p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+//    devm_release_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize);
+}
+
+static void FreeFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+
+    if (!p_LnxWrpFmPortDev->active)
+        return;
+
+    if (p_LnxWrpFmPortDev->h_Dev)
+        FM_PORT_Free(p_LnxWrpFmPortDev->h_Dev);
+    devm_iounmap(p_LnxWrpFmDev->dev, UINT_TO_PTR(p_LnxWrpFmPortDev->baseAddr));
+    __devm_release_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->res, p_LnxWrpFmPortDev->baseAddr, p_LnxWrpFmPortDev->memSize);
+}
+
+
+/*****************************************************************************/
+/*               API routines for the FM Linux Device                        */
+/*****************************************************************************/
+
+static int fm_open(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = NULL;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = NULL;
+    unsigned int        major = imajor(inode);
+    unsigned int        minor = iminor(inode);
+
+    DBG(TRACE, ("Opening minor - %d - ", minor));
+
+    if (file->private_data != NULL)
+        return 0;
+
+#ifdef NO_OF_SUPPORT
+{
+    int                 i;
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+        if (lnxWrpFm.p_FmDevs[i]->major == major)
+            p_LnxWrpFmDev = lnxWrpFm.p_FmDevs[i];
+}
+#else
+{
+    struct of_device_id name;
+    struct device_node  *fm_node;
+
+    /* Get all the FM nodes */
+    memset(&name, 0, sizeof(struct of_device_id));
+    BUG_ON(strlen("fsl,fman") >= sizeof(name.compatible));
+    strcpy(name.compatible, "fsl,fman");
+    for_each_matching_node(fm_node, &name) {
+        struct of_device    *of_dev;
+
+        of_dev = of_find_device_by_node(fm_node);
+        if (unlikely(of_dev == NULL)) {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fm id!"));
+            return -ENXIO;
+        }
+
+        p_LnxWrpFmDev = (t_LnxWrpFmDev *)fm_bind(&of_dev->dev);
+        if (p_LnxWrpFmDev->major == major)
+            break;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+        p_LnxWrpFmDev = NULL;
+    }
+}
+#endif /* NO_OF_SUPPORT */
+
+    if (!p_LnxWrpFmDev)
+        return -ENODEV;
+
+    if (minor == DEV_FM_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else if (minor == DEV_FM_PCD_MINOR_BASE)
+        file->private_data = p_LnxWrpFmDev;
+    else {
+        if (minor == DEV_FM_OH_PORTS_MINOR_BASE)
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
+        else if ((minor > DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[minor-DEV_FM_OH_PORTS_MINOR_BASE-1];
+        else if ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[minor-DEV_FM_RX_PORTS_MINOR_BASE];
+        else if ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[minor-DEV_FM_TX_PORTS_MINOR_BASE];
+        else
+            return -EINVAL;
+
+        /* if trying to open port, check if it initialized */
+        if (!p_LnxWrpFmPortDev->h_Dev)
+            return -ENODEV;
+
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)fm_port_bind(p_LnxWrpFmPortDev->dev);
+        file->private_data = p_LnxWrpFmPortDev;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+
+    if (file->private_data == NULL)
+         return -ENXIO;
+
+    return 0;
+}
+
+static int fm_close(struct inode *inode, struct file *file)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    unsigned int        minor = iminor(inode);
+    int                 err = 0;
+
+    DBG(TRACE, ("Closing minor - %d - ", minor));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        p_LnxWrpFmDev = (t_LnxWrpFmDev*)file->private_data;
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        fm_unbind((struct fm *)p_LnxWrpFmDev);
+    }
+    else if (((minor >= DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)file->private_data;
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        fm_port_unbind((struct fm_port *)p_LnxWrpFmPortDev);
+    }
+
+    return err;
+}
+
+static int fm_ioctls(unsigned int minor, struct file *file, unsigned int cmd, unsigned long arg, bool compat)
+{
+    DBG(TRACE, ("IOCTL minor - %u, cmd - 0x%08x, arg - 0x%08lx \n", minor, cmd, arg));
+
+    if ((minor == DEV_FM_MINOR_BASE) ||
+        (minor == DEV_FM_PCD_MINOR_BASE))
+    {
+        t_LnxWrpFmDev *p_LnxWrpFmDev = ((t_LnxWrpFmDev*)file->private_data);
+        if (!p_LnxWrpFmDev)
+            return -ENODEV;
+        if (LnxwrpFmIOCTL(p_LnxWrpFmDev, cmd, arg, compat))
+            return -EFAULT;
+    }
+    else if (((minor >= DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
+             ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
+    {
+        t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = ((t_LnxWrpFmPortDev*)file->private_data);
+        if (!p_LnxWrpFmPortDev)
+            return -ENODEV;
+        if (LnxwrpFmPortIOCTL(p_LnxWrpFmPortDev, cmd, arg, compat))
+            return -EFAULT;
+    }
+    else
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("minor"));
+        return -ENODEV;
+    }
+
+    return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long fm_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int minor = iminor(file->f_path.dentry->d_inode);
+    long res;
+
+    fm_mutex_lock();
+    res = fm_ioctls(minor, file, cmd, arg, true);
+    fm_mutex_unlock();
+
+    return res;
+}
+#endif
+
+static long fm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    unsigned int minor = iminor(file->f_path.dentry->d_inode);
+    long res;
+
+    fm_mutex_lock();
+    res = fm_ioctls(minor, file, cmd, arg, false);
+    fm_mutex_unlock();
+
+    return res;
+}
+
+/* Globals for FM character device */
+static struct file_operations fm_fops =
+{
+    .owner =            THIS_MODULE,
+    .unlocked_ioctl =   fm_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl =     fm_compat_ioctl,
+#endif
+    .open =             fm_open,
+    .release =          fm_close,
+};
+
+#ifndef NO_OF_SUPPORT
+static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+
+    if ((p_LnxWrpFmDev = ReadFmDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+    if (ConfigureFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+    if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+        return -EIO;
+
+    Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+
+    /* Register to the /dev for IOCTL API */
+    /* Register dynamically a new major number for the character device: */
+    if ((p_LnxWrpFmDev->major = register_chrdev(0, p_LnxWrpFmDev->name, &fm_fops)) <= 0) {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", p_LnxWrpFmDev->name));
+        return -EIO;
+    }
+
+    /* Creating classes for FM */
+    DBG(TRACE ,("class_create fm_class"));
+    p_LnxWrpFmDev->fm_class = class_create(THIS_MODULE, p_LnxWrpFmDev->name);
+    if (IS_ERR(p_LnxWrpFmDev->fm_class)) {
+        unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("class_create error fm_class"));
+        return -EIO;
+    }
+
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, DEV_FM_MINOR_BASE), NULL,
+                  "fm%d", p_LnxWrpFmDev->id);
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, DEV_FM_PCD_MINOR_BASE), NULL,
+                  "fm%d-pcd", p_LnxWrpFmDev->id);
+    dev_set_drvdata(p_LnxWrpFmDev->dev, p_LnxWrpFmDev);
+
+   /* create sysfs entries for stats and regs */
+    if ( fm_sysfs_create(p_LnxWrpFmDev->dev) !=0 )
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to sysfs entry - fm!!!"));
+        return -EIO;
+    }
+
+    DBG(TRACE, ("FM%d probed", p_LnxWrpFmDev->id));
+
+    return 0;
+}
+
+static int __devexit fm_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    struct device   *dev;
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmDev = dev_get_drvdata(dev);
+
+    fm_sysfs_distroy(dev);
+
+    DBG(TRACE, ("destroy fm_class"));
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, DEV_FM_MINOR_BASE));
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, DEV_FM_PCD_MINOR_BASE));
+    class_destroy(p_LnxWrpFmDev->fm_class);
+
+    /* Destroy chardev */
+    unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
+
+    FreeFmDev(p_LnxWrpFmDev);
+
+    DistroyFmDev(p_LnxWrpFmDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_driver = {
+    .name           = "fsl-fman",
+    .match_table    = fm_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_probe,
+    .remove         = __devexit_p(fm_remove)
+};
+
+static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+
+    if ((p_LnxWrpFmPortDev = ReadFmPortDevTreeNode(of_dev)) == NULL)
+        return -EIO;
+    if (ConfigureFmPortDev(p_LnxWrpFmPortDev) != E_OK)
+        return -EIO;
+
+#if 0
+    if ((p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_RX) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX_10G) &&
+        (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_TX) &&
+        (InitFmPortDev(p_LnxWrpFmPortDev) != E_OK))
+        return -EIO;
+#endif /* 0 */
+
+    dev_set_drvdata(dev, p_LnxWrpFmPortDev);
+
+    if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
+        (InitFmPcdDev((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev) != E_OK))
+        return -EIO;
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+
+    if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-rx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_RX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-rx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+FM_MAX_NUM_OF_1G_RX_PORTS);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_RX_PORTS + DEV_FM_RX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-tx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_TX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-tx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+FM_MAX_NUM_OF_1G_TX_PORTS);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS + DEV_FM_TX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_OH_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+1);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + 1 + DEV_FM_OH_PORTS_MINOR_BASE;
+    }
+
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor), NULL, p_LnxWrpFmPortDev->name);
+
+    /* create sysfs entries for stats and regs */
+
+    if (fm_port_sysfs_create(dev) !=0 )
+    {
+        FreeFmDev(p_LnxWrpFmDev);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to sys entry - fm port!!!"));
+        return -EIO;
+    }
+
+    DBG(TRACE, ("%s probed", p_LnxWrpFmPortDev->name));
+
+    return 0;
+}
+
+static int __devexit fm_port_remove(struct of_device *of_dev)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    struct device       *dev;
+
+    dev = &of_dev->dev;
+    p_LnxWrpFmPortDev = dev_get_drvdata(dev);
+
+    fm_port_sysfs_destroy(dev);
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor));
+
+    FreeFmPortDev(p_LnxWrpFmPortDev);
+
+    dev_set_drvdata(dev, NULL);
+
+    return 0;
+}
+
+static const struct of_device_id fm_port_match[] __devinitconst = {
+    {
+        .compatible    = "fsl,fman-port-oh"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-rx"
+    },
+    {
+        .compatible    = "fsl,fman-port-1g-tx"
+    },
+    {
+        .compatible    = "fsl,fman-port-10g-tx"
+    },
+    {}
+};
+#ifndef MODULE
+MODULE_DEVICE_TABLE(of, fm_port_match);
+#endif /* !MODULE */
+
+static struct of_platform_driver fm_port_driver = {
+    .name           = "fsl-fman-port",
+    .match_table    = fm_port_match,
+    .owner          = THIS_MODULE,
+    .probe          = fm_port_probe,
+    .remove         = __devexit_p(fm_port_remove)
+};
+#endif /* !NO_OF_SUPPORT */
+
+
+t_Handle LNXWRP_FM_Init(void)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFmDev   *p_LnxWrpFmDev;
+    int             i, j;
+#endif /* NO_OF_SUPPORT */
+
+    memset(&lnxWrpFm, 0, sizeof(lnxWrpFm));
+    spin_lock_init(&lock);
+    mutex_init(&lnxwrp_mutex);
+
+#ifdef NO_OF_SUPPORT
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = CreateFmDev(i);
+        if (!p_LnxWrpFmDev)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM dev obj!"));
+            return NULL;
+        }
+        lnxWrpFm.p_FmDevs[i] = p_LnxWrpFmDev;
+
+        if (i==1)
+        {
+            ConfigureFmDev(p_LnxWrpFmDev);
+            if (InitFmDev(p_LnxWrpFmDev) != E_OK)
+                return NULL;
+
+            Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+
+            /* Register to the /dev for IOCTL API */
+            /* Register dynamically a new major number for the character device: */
+            if ((p_LnxWrpFmDev->major = register_chrdev(0, p_LnxWrpFmDev->name, &fm_fops)) <= 0)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", p_LnxWrpFmDev->name));
+                return NULL;
+            }
+
+            /* Register to the /proc for debug and statistics API */
+            if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(p_LnxWrpFmDev->name, NULL)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
+                ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
+                return NULL;
+            }
+        }
+
+//        lnxWrpFm.h_Mod = p_TdmLnxWrpParam->h_Mod;
+//        lnxWrpFm.f_GetObject = p_TdmLnxWrpParam->f_GetObject;
+    }
+
+#else
+    /* Register to the DTB for basic FM API */
+    of_register_platform_driver(&fm_driver);
+    /* Register to the DTB for basic FM port API */
+    of_register_platform_driver(&fm_port_driver);
+#endif /* !NO_OF_SUPPORT */
+
+#ifdef CONFIG_FSL_FMAN_TEST
+    /* Seed the QMan allocator so we'll have enough queues to run PCD with
+       dinamically fqid-range allocation */
+    qman_release_fqid_range(0x100, 0x400);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+    return &lnxWrpFm;
+}
+
+t_Error LNXWRP_FM_Free(t_Handle h_LnxWrpFm)
+{
+#ifdef NO_OF_SUPPORT
+    t_LnxWrpFm          *p_LnxWrpFm = (t_LnxWrpFm *)h_LnxWrpFm;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
+    int                 i, j;
+
+    for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
+    {
+        p_LnxWrpFmDev = p_LnxWrpFm->p_FmDevs[i];
+
+        remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
+        remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
+        remove_proc_entry(p_LnxWrpFmDev->name, NULL);
+
+        /* Destroy chardev */
+        unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
+
+        FreeFmDev(p_LnxWrpFmDev);
+
+        DistroyFmDev(p_LnxWrpFmDev);
+    }
+
+#else
+        of_unregister_platform_driver(&fm_port_driver);
+        of_unregister_platform_driver(&fm_driver);
+#endif /* NO_OF_SUPPORT */
+    mutex_destroy(&lnxwrp_mutex);
+
+    return E_OK;
+}
+
+
+struct fm * fm_bind (struct device *fm_dev)
+{
+    return (struct fm *)(dev_get_drvdata(get_device(fm_dev)));
+}
+EXPORT_SYMBOL(fm_bind);
+
+void fm_unbind(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    put_device(p_LnxWrpFmDev->dev);
+}
+EXPORT_SYMBOL(fm_unbind);
+
+struct resource * fm_get_mem_region(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return p_LnxWrpFmDev->res;
+}
+EXPORT_SYMBOL(fm_get_mem_region);
+
+void * fm_get_handle(struct fm *fm)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev*)fm;
+
+    return (void *)p_LnxWrpFmDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_get_handle);
+
+struct fm_port * fm_port_bind (struct device *fm_port_dev)
+{
+    return (struct fm_port *)(dev_get_drvdata(get_device(fm_port_dev)));
+}
+EXPORT_SYMBOL(fm_port_bind);
+
+void fm_port_unbind(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    put_device(p_LnxWrpFmPortDev->dev);
+}
+EXPORT_SYMBOL(fm_port_unbind);
+
+void * fm_port_get_handle(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return (void *)p_LnxWrpFmPortDev->h_Dev;
+}
+EXPORT_SYMBOL(fm_port_get_handle);
+
+void fm_port_get_base_addr(const struct fm_port *port, uint64_t *base_addr)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)port;
+
+    *base_addr = p_LnxWrpFmPortDev->settings.param.baseAddr;
+}
+EXPORT_SYMBOL(fm_port_get_base_addr);
+
+void fm_set_rx_port_params(struct fm_port *port, struct fm_port_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+    int                 i;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.dfltFqid = params->defq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.numOfPoolsUsed = params->num_pools;
+    for (i=0; i<params->num_pools; i++)
+    {
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.extBufPool[i].id =
+            params->pool_param[i].id;
+        p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools.extBufPool[i].size =
+            params->pool_param[i].size;
+    }
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+    p_LnxWrpFmPortDev->buffPrefixContent.passHashResult   = params->hash_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_rx_port_params);
+
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->pcd_owner_params.cb      = params->cb;
+    p_LnxWrpFmPortDev->pcd_owner_params.dev     = params->dev;
+}
+EXPORT_SYMBOL(fm_port_pcd_bind);
+
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_non_rx_params *params)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.errFqid  = params->errq;
+    p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.dfltFqid = params->defq;
+
+    p_LnxWrpFmPortDev->buffPrefixContent.privDataSize     = params->priv_data_size;
+    p_LnxWrpFmPortDev->buffPrefixContent.passPrsResult    = params->parse_results;
+    p_LnxWrpFmPortDev->buffPrefixContent.passHashResult   = params->hash_results;
+
+    ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig, FM_MAX_NUM_OF_ADV_SETTINGS)
+
+    ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,   ARGS(1, (&p_LnxWrpFmPortDev->buffPrefixContent)));
+
+    ADD_ADV_CONFIG_END
+
+    InitFmPortDev(p_LnxWrpFmPortDev);
+}
+EXPORT_SYMBOL(fm_set_tx_port_params);
+
+int fm_get_tx_port_channel(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    return p_LnxWrpFmPortDev->txCh;
+}
+EXPORT_SYMBOL(fm_get_tx_port_channel);
+
+int fm_port_enable (struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+
+    return 0;
+}
+EXPORT_SYMBOL(fm_port_enable);
+
+void fm_port_disable(struct fm_port *port)
+{
+    t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
+
+    FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+}
+EXPORT_SYMBOL(fm_port_disable);
+
+void fm_mutex_lock(void)
+{
+    mutex_lock(&lnxwrp_mutex);
+}
+EXPORT_SYMBOL(fm_mutex_lock);
+
+void fm_mutex_unlock(void)
+{
+    mutex_unlock(&lnxwrp_mutex);
+}
+EXPORT_SYMBOL(fm_mutex_unlock);
+
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.h
new file mode 100644
index 0000000..86e3bce
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -0,0 +1,201 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.h
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+#ifndef __LNXWRP_FM_H__
+#define __LNXWRP_FM_H__
+
+#include <linux/fsl_qman.h>    /* struct qman_fq */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "procbuff_ext.h"
+
+#include "lnxwrp_fm_ext.h"
+
+
+#define __ERR_MODULE__      MODULE_FM
+
+
+#define FM_MAX_NUM_OF_ADV_SETTINGS          10
+
+#define LNXWRP_FM_NUM_OF_SHARED_PROFILES    16
+
+#define FM_PORT_10G_NUM_OF_OPEN_DMA             12   /* Use only for 10G ports - RX and TX */
+
+typedef enum {
+    e_NO_PCD = 0,
+    e_FM_PCD_3_TUPLE
+} e_LnxWrpFmPortPcdDefUseCase;
+
+
+typedef struct t_FmTestFq {
+    struct qman_fq      fq_base;
+    t_Handle            h_Arg;
+} t_FmTestFq;
+
+typedef struct {
+    uint8_t                     id; /* sw port id, see SW_PORT_ID_TO_HW_PORT_ID() in fm_common.h */
+    int                         minor;
+    char                        name[20];
+    bool                        active;
+    uint64_t                    baseAddr;               /* Port's *virtual* address */
+    uint32_t                    memSize;
+    t_WrpFmPortDevSettings      settings;
+    uint8_t                     totalNumOfSchemes;
+    uint8_t                     schemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint32_t                    pcdBaseQ;
+    uint16_t                    pcdNumOfQs;
+    struct fm_port_pcd_param    pcd_owner_params;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    t_Handle                    h_DefNetEnv;
+    t_Handle                    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPortBufferPrefixContent buffPrefixContent;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+    uint16_t                    txCh;
+    struct device               *dev;
+    struct device_attribute     *dev_attr_stats;
+    struct device_attribute     *dev_attr_regs;
+} t_LnxWrpFmPortDev;
+
+typedef struct {
+    uint8_t                     id;
+    bool                        active;
+    uint64_t                    baseAddr;
+    uint32_t                    memSize;
+    t_WrpFmMacDevSettings       settings;
+    t_Handle                    h_Dev;
+    t_Handle                    h_LnxWrpFmDev;
+} t_LnxWrpFmMacDev;
+
+typedef struct {
+    uint8_t                     id;
+    char                        name[10];
+    bool                        active;
+    bool                        pcdActive;
+    bool                        prsActive;
+    bool                        kgActive;
+    bool                        ccActive;
+    bool                        plcrActive;
+    e_LnxWrpFmPortPcdDefUseCase defPcd;
+    uint32_t                    usedSchemes;
+    uint8_t                     totalNumOfSharedSchemes;
+    uint8_t                     sharedSchemesBase;
+    uint8_t                     numOfSchemesUsed;
+    uint8_t                     defNetEnvId;
+    uint64_t                    fmBaseAddr;
+    uint32_t                    fmMemSize;
+    uint64_t                    fmMuramBaseAddr;
+    uint32_t                    fmMuramMemSize;
+    uint64_t                    fmRtcBaseAddr;
+    uint32_t                    fmRtcMemSize;
+    int                         irq;
+    int                         err_irq;
+    t_WrpFmDevSettings          fmDevSettings;
+    t_WrpFmPcdDevSettings       fmPcdDevSettings;
+    t_Handle                    h_Dev;
+    uint16_t                    hcCh;
+
+    t_Handle                    h_MuramDev;
+    t_Handle                    h_PcdDev;
+    t_Handle                    h_RtcDev;
+
+    t_LnxWrpFmPortDev           hcPort;
+    t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OH_PORTS-1];
+    t_LnxWrpFmPortDev           rxPorts[FM_MAX_NUM_OF_RX_PORTS];
+    t_LnxWrpFmPortDev           txPorts[FM_MAX_NUM_OF_TX_PORTS];
+    t_LnxWrpFmMacDev            macs[FM_MAX_NUM_OF_MACS];
+
+    struct device               *dev;
+    struct resource             *res;
+    int                         major;
+    struct class                *fm_class;
+    struct device_attribute     *dev_attr_stats;
+    struct device_attribute     *dev_attr_regs;
+
+    struct device_attribute     *dev_pcd_attr_stats;
+    struct device_attribute     *dev_pcd_attr_regs;
+
+    struct qman_fq              *hc_tx_conf_fq, *hc_tx_err_fq, *hc_tx_fq;
+} t_LnxWrpFmDev;
+
+typedef struct {
+//    t_Handle h_Mod;
+//    t_Handle (*f_GetObject) (t_Handle h_Mod, e_SysModule devType, ...);
+
+    t_LnxWrpFmDev   *p_FmDevs[INTG_MAX_NUM_OF_FM];
+} t_LnxWrpFm;
+#define LNXWRP_FM_OBJECT(ptr)   LIST_OBJECT(ptr, t_LnxWrpFm, fms[((t_LnxWrpFmDev *)ptr)->id])
+
+
+t_Error  LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg, bool compat);
+t_Error  LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg, bool compat);
+
+
+static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint8_t numSchemes, uint8_t *p_BaseSchemeNum)
+{
+    uint32_t    schemeMask;
+    uint8_t     i;
+
+    if (!numSchemes)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+    schemeMask = 0x80000000;
+    *p_BaseSchemeNum = 0xff;
+
+    for (i=0; schemeMask && numSchemes; schemeMask>>=1, i++)
+        if ((p_LnxWrpFmDev->usedSchemes & schemeMask) == 0)
+        {
+            p_LnxWrpFmDev->usedSchemes |= schemeMask;
+            numSchemes--;
+            if (*p_BaseSchemeNum==0xff)
+                *p_BaseSchemeNum = i;
+        }
+        else if (*p_BaseSchemeNum!=0xff)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Fragmentation on schemes array!!!"));
+
+    if (numSchemes)
+        RETURN_ERROR(MINOR, E_FULL, ("schemes!!!"));
+    return E_OK;
+}
+
+
+#endif /* __LNXWRP_FM_H__ */
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_compat_ioctls.c b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_compat_ioctls.c
new file mode 100644
index 0000000..8ad13ca
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_compat_ioctls.c
@@ -0,0 +1,789 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          lnxwrp_fm_compat_ioctls.c
+
+ @Description   FM PCD compat functions
+*//***************************************************************************/
+
+#if !defined(CONFIG_COMPAT)
+#error "missing COMPAT layer..."
+#endif
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <sysdev/fsl_soc.h>
+
+#include "part_ext.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+#include "fm_compat_ioctls.h"
+
+/* debug dump */
+#if 0
+static void hex_dump(void * p_addr, unsigned int size)
+{
+   int i;
+
+   for(i=0; i<size; i+=16)
+   {
+       printk("%p: 0x%08x 0x%08x 0x%08x 0x%08x\n", p_addr + i,
+           *(unsigned int *)(p_addr + i),
+           *(unsigned int *)(p_addr + i + 4),
+           *(unsigned int *)(p_addr + i + 8),
+           *(unsigned int *)(p_addr + i +12)
+           );
+   }
+}
+#endif
+
+/* maping kernel pointers w/ UserSpace id's { */
+static void *compat_ptr2id_array[COMPAT_PTR2ID_ARRAY_MAX] = {0};
+/*  szbs001: we may need one set of these per FM device
+    to avoid using expensive synchronization! */
+
+void compat_del_ptr2id(void *p)
+{
+    compat_uptr_t k;
+
+    /*printk("\ncompat_del_ptr2id(%p)\n", p);*/
+
+    for(k=1; k < COMPAT_PTR2ID_ARRAY_MAX; k++)
+        if(compat_ptr2id_array[k] == p)
+            compat_ptr2id_array[k] = NULL;
+}
+
+compat_uptr_t compat_add_ptr2id(void *p)
+{
+    compat_uptr_t k;
+
+    /*printk("\ncompat_add_ptr2id(%p) -> ", p);*/
+
+    if(!p)
+        return 0;
+
+    for(k=1; k < COMPAT_PTR2ID_ARRAY_MAX; k++)
+        if(compat_ptr2id_array[k] == NULL)
+        {
+            compat_ptr2id_array[k] = p;
+            /*printk("0x%08x\n", k | COMPAT_PTR2ID_WATERMARK);*/
+            return k | COMPAT_PTR2ID_WATERMARK;
+        }
+
+    return 0;
+}
+
+compat_uptr_t compat_get_ptr2id(void *p)
+{
+    compat_uptr_t k;
+
+    /*printk("\ncompat_get_ptr2id(%p) -> ", p);*/
+
+    for(k=1; k < COMPAT_PTR2ID_ARRAY_MAX; k++)
+        if(compat_ptr2id_array[k] == p) {
+            /*printk("0x%08x\n", k | COMPAT_PTR2ID_WATERMARK);*/
+            return k | COMPAT_PTR2ID_WATERMARK;
+        }
+
+    return 0;
+}
+
+void *compat_get_id2ptr(compat_uptr_t comp)
+{
+
+    /*printk("\ncompat_get_id2ptr(0x%08x) -> ", comp);*/
+
+    if((COMPAT_PTR2ID_WM_MASK & comp) != COMPAT_PTR2ID_WATERMARK) {
+        /*printk("Error, invalid watermark!\n\n");
+        dump_stack();*/
+        return compat_ptr(comp);
+    }
+
+    comp &= ~COMPAT_PTR2ID_WM_MASK;
+
+    if((0 < comp) && (comp < COMPAT_PTR2ID_ARRAY_MAX) && (compat_ptr2id_array[comp] != NULL)) {
+        /*printk("%p\n", compat_ptr2id_array[comp]);*/
+        return compat_ptr2id_array[comp];
+    }
+    return NULL;
+}
+/* } maping kernel pointers w/ UserSpace id's  */
+
+static inline void compat_copy_fm_pcd_plcr_next_engine(
+        ioc_compat_fm_pcd_plcr_next_engine_params_u *compat_param,
+        ioc_fm_pcd_plcr_next_engine_params_u        *param,
+        ioc_fm_pcd_engine                           next_engine,
+        uint8_t                                     compat)
+{
+    switch (next_engine)
+    {
+        case e_IOC_FM_PCD_PLCR:
+            if (compat)
+                param->p_profile = compat_ptr(compat_param->p_profile);
+            else
+                compat_param->p_profile = ptr_to_compat(param->p_profile);
+            break;
+
+        case e_IOC_FM_PCD_KG:
+            if (compat)
+                param->p_direct_scheme = compat_ptr(compat_param->p_direct_scheme);
+            else
+                compat_param->p_direct_scheme = ptr_to_compat(param->p_direct_scheme);
+            break;
+
+        default:
+            if (compat)
+                param->action = compat_param->action;
+            else
+                compat_param->action = param->action;
+    }
+}
+
+void compat_copy_fm_pcd_plcr_profile(
+        ioc_compat_fm_pcd_plcr_profile_params_t *compat_param,
+        ioc_fm_pcd_plcr_profile_params_t        *param,
+        uint8_t                                 compat)
+{
+    if (compat)
+    {
+        param->modify = compat_param->modify;
+
+        /* profile_select */
+        if (!compat_param->modify)
+        {
+            param->profile_select.new_params.profile_type =
+                compat_param->profile_select.new_params.profile_type;
+            param->profile_select.new_params.p_port =
+                compat_ptr(compat_param->profile_select.new_params.p_port);
+            param->profile_select.new_params.relative_profile_id =
+                compat_param->profile_select.new_params.relative_profile_id;
+        }
+        else
+            param->profile_select.p_profile =
+                compat_ptr(compat_param->profile_select.p_profile);
+
+        param->alg_selection    = compat_param->alg_selection;
+        param->color_mode       = compat_param->color_mode;
+
+        /* both parameters in the union has the same size, so memcpy works */
+        memcpy(&param->color, &compat_param->color, sizeof(param->color));
+
+        memcpy(&param->non_passthrough_alg_param, &compat_param->non_passthrough_alg_param, sizeof(ioc_fm_pcd_plcr_non_passthrough_alg_param_t));
+
+        param->next_engine_on_green = compat_param->next_engine_on_green;
+        param->next_engine_on_yellow = compat_param->next_engine_on_yellow;
+        param->next_engine_on_red = compat_param->next_engine_on_red;
+
+        param->trap_profile_on_flow_A = compat_param->trap_profile_on_flow_A;
+        param->trap_profile_on_flow_B = compat_param->trap_profile_on_flow_B;
+        param->trap_profile_on_flow_C = compat_param->trap_profile_on_flow_C;
+
+        param->id = compat_ptr(compat_param->id);
+    }
+    else
+    {
+        compat_param->modify = param->modify;
+
+        /* profile_select */
+        if(!param->modify){
+            compat_param->profile_select.new_params.profile_type =
+                param->profile_select.new_params.profile_type;
+            compat_param->profile_select.new_params.p_port =
+                ptr_to_compat(param->profile_select.new_params.p_port);
+            compat_param->profile_select.new_params.relative_profile_id =
+                param->profile_select.new_params.relative_profile_id;
+        }
+        else
+            compat_param->profile_select.p_profile =
+                ptr_to_compat(param->profile_select.p_profile);
+
+        compat_param->alg_selection = param->alg_selection;
+        compat_param->color_mode    = param->color_mode;
+
+        /* both parameters in the union has the same size, so memcpy works */
+        memcpy(&compat_param->color, &param->color, sizeof(compat_param->color));
+
+        memcpy(&compat_param->non_passthrough_alg_param, &param->non_passthrough_alg_param, sizeof(ioc_fm_pcd_plcr_non_passthrough_alg_param_t));
+
+        compat_param->next_engine_on_green = param->next_engine_on_green;
+        compat_param->next_engine_on_yellow = param->next_engine_on_yellow;
+        compat_param->next_engine_on_red = param->next_engine_on_red;
+
+        compat_param->trap_profile_on_flow_A = param->trap_profile_on_flow_A;
+        compat_param->trap_profile_on_flow_B = param->trap_profile_on_flow_B;
+        compat_param->trap_profile_on_flow_C = param->trap_profile_on_flow_C;
+
+        compat_param->id = ptr_to_compat(param->id);
+    }
+
+    compat_copy_fm_pcd_plcr_next_engine(&compat_param->params_on_green,
+            &param->params_on_green, param->next_engine_on_green, compat);
+
+    compat_copy_fm_pcd_plcr_next_engine(&compat_param->params_on_yellow,
+            &param->params_on_yellow, param->next_engine_on_yellow, compat);
+
+    compat_copy_fm_pcd_plcr_next_engine(&compat_param->params_on_red,
+            &param->params_on_red, param->next_engine_on_red, compat);
+}
+
+static inline void compat_copy_fm_pcd_cc_next_kg(
+        ioc_compat_fm_pcd_cc_next_kg_params_t   *compat_param,
+        ioc_fm_pcd_cc_next_kg_params_t          *param,
+        uint8_t                                 compat)
+{
+    if (compat)
+    {
+        param->new_fqid         = compat_param->new_fqid;
+        param->override_fqid    = compat_param->override_fqid;
+        param->p_direct_scheme  = compat_ptr(compat_param->p_direct_scheme);
+    }
+    else
+    {
+        compat_param->new_fqid          = param->new_fqid;
+        compat_param->override_fqid     = param->override_fqid;
+        compat_param->p_direct_scheme   = ptr_to_compat(param->p_direct_scheme);
+    }
+}
+
+static inline void compat_copy_fm_pcd_cc_next_cc(
+        ioc_compat_fm_pcd_cc_next_cc_params_t   *compat_param,
+        ioc_fm_pcd_cc_next_cc_params_t          *param,
+        uint8_t                                 compat)
+{
+    if (compat)
+        param->cc_node_id = compat_get_id2ptr(compat_param->cc_node_id);
+    else
+        compat_param->cc_node_id = compat_get_ptr2id(param->cc_node_id);
+}
+
+static inline void compat_copy_fm_pcd_cc_next_engine(
+        ioc_compat_fm_pcd_cc_next_engine_params_t   *compat_param,
+        ioc_fm_pcd_cc_next_engine_params_t          *param,
+        uint8_t                                     compat)
+{
+    if (compat)
+    {
+        param->next_engine = compat_param->next_engine;
+
+        switch (compat_param->next_engine)
+        {
+            case e_IOC_FM_PCD_KG:
+                compat_copy_fm_pcd_cc_next_kg(&compat_param->params.kg_params, &param->params.kg_params, compat);
+                break;
+            case e_IOC_FM_PCD_CC:
+                compat_copy_fm_pcd_cc_next_cc(&compat_param->params.cc_params, &param->params.cc_params, compat);
+                break;
+            default:
+                memcpy(&param->params, &compat_param->params, sizeof(param->params));
+            break;
+        }
+#ifdef FM_PCD_CC_MANIP
+        param->p_manip = compat_ptr(compat_param->p_manip);
+#endif
+    }
+    else
+    {
+        compat_param->next_engine = param->next_engine;
+
+        switch (compat_param->next_engine)
+        {
+            case e_IOC_FM_PCD_KG:
+                compat_copy_fm_pcd_cc_next_kg(&compat_param->params.kg_params, &param->params.kg_params, compat);
+                break;
+            case e_IOC_FM_PCD_CC:
+                compat_copy_fm_pcd_cc_next_cc(&compat_param->params.cc_params, &param->params.cc_params, compat);
+                break;
+            default:
+                memcpy(&compat_param->params, &param->params, sizeof(compat_param->params));
+            break;
+        }
+
+#ifdef FM_PCD_CC_MANIP
+        compat_param->p_manip = ptr_to_compat(param->p_manip);
+#endif
+    }
+}
+
+void compat_copy_fm_pcd_cc_key(
+        ioc_compat_fm_pcd_cc_key_params_t   *compat_param,
+        ioc_fm_pcd_cc_key_params_t          *param,
+        uint8_t                             compat)
+{
+    if (compat)
+    {
+        param->p_key = compat_ptr(compat_param->p_key);
+        param->p_mask = compat_ptr(compat_param->p_mask);
+    }
+    else
+    {
+        compat_param->p_key = ptr_to_compat(param->p_key);
+        compat_param->p_mask = ptr_to_compat(param->p_mask);
+    }
+
+    compat_copy_fm_pcd_cc_next_engine(
+            &compat_param->cc_next_engine_params,
+            &param->cc_next_engine_params,
+            compat);
+}
+
+void compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(
+        ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t   *compat_param,
+        ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t          *param,
+        uint8_t                                                         compat)
+{
+    if (compat)
+    {
+        param->id       = compat_ptr(compat_param->id);
+        param->key_indx = compat_param->key_indx;
+        param->key_size = compat_param->key_indx;
+        compat_copy_fm_pcd_cc_key(
+            &compat_param->key_params,
+            &param->key_params,
+            compat);
+    }
+    else
+    {
+        compat_param->id       = ptr_to_compat(param->id);
+        compat_param->key_indx = param->key_indx;
+        compat_param->key_size = param->key_indx;
+        compat_copy_fm_pcd_cc_key(
+            &compat_param->key_params,
+            &param->key_params,
+            compat);
+    }
+}
+
+void compat_copy_fm_pcd_cc_node_modify_next_engine(
+        ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t   *compat_param,
+        ioc_fm_pcd_cc_node_modify_next_engine_params_t          *param,
+        uint8_t                                                 compat)
+{
+    if (compat)
+    {
+        param->id = compat_ptr(compat_param->id);
+        param->key_indx = compat_param->key_indx;
+        param->key_size = compat_param->key_size;
+    }
+    else
+    {
+        compat_param->id = ptr_to_compat(param->id);
+        compat_param->key_indx = param->key_indx;
+        compat_param->key_size = param->key_size;
+    }
+
+    compat_copy_fm_pcd_cc_next_engine(
+            &compat_param->cc_next_engine_params,
+            &param->cc_next_engine_params,
+            compat);
+}
+
+void compat_fm_pcd_cc_tree_modify_next_engine(
+        ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t   *compat_param,
+        ioc_fm_pcd_cc_tree_modify_next_engine_params_t          *param,
+        uint8_t                                                 compat)
+{
+    if (compat)
+    {
+        param->id       = compat_ptr(compat_param->id);
+        param->grp_indx = compat_param->grp_indx;
+        param->indx     = compat_param->indx;
+    }
+    else
+    {
+        compat_param->id       = ptr_to_compat(param->id);
+        compat_param->grp_indx = param->grp_indx;
+        compat_param->indx     = param->indx;
+    }
+
+    compat_copy_fm_pcd_cc_next_engine(
+            &compat_param->cc_next_engine_params,
+            &param->cc_next_engine_params,
+            compat);
+}
+
+void compat_copy_fm_pcd_cc_grp(
+        ioc_compat_fm_pcd_cc_grp_params_t *compat_param,
+        ioc_fm_pcd_cc_grp_params_t *param,
+        uint8_t compat)
+{
+    int k;
+
+    if (compat)
+    {
+        param->num_of_distinction_units = compat_param->num_of_distinction_units;
+        memcpy(param->unit_ids, compat_param->unit_ids, IOC_FM_PCD_MAX_NUM_OF_CC_UNITS);
+    }
+    else
+    {
+        compat_param->num_of_distinction_units = param->num_of_distinction_units;
+        memcpy(compat_param->unit_ids, param->unit_ids, IOC_FM_PCD_MAX_NUM_OF_CC_UNITS);
+    }
+
+    for (k=0; k < IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP; k++)
+        compat_copy_fm_pcd_cc_next_engine(
+                &compat_param->next_engine_per_entries_in_grp[k],
+                &param->next_engine_per_entries_in_grp[k],
+                compat);
+}
+
+void compat_copy_fm_pcd_cc_tree(
+        ioc_compat_fm_pcd_cc_tree_params_t *compat_param,
+        ioc_fm_pcd_cc_tree_params_t *param,
+        uint8_t compat)
+{
+    int k;
+
+    if (compat)
+    {
+        param->net_env_id = compat_ptr(compat_param->net_env_id);
+        param->num_of_groups = compat_param->num_of_groups;
+
+        for (k=0; k < IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS; k++)
+            compat_copy_fm_pcd_cc_grp(
+                    &compat_param->fm_pcd_cc_group_params[k],
+                    &param->fm_pcd_cc_group_params[k],
+                    compat);
+        param->id = compat_ptr(compat_param->id);
+    }
+    else
+    {
+        compat_param->net_env_id = ptr_to_compat(param->net_env_id);
+        compat_param->num_of_groups = param->num_of_groups;
+        for (k=0; k < IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS; k++)
+            compat_copy_fm_pcd_cc_grp(
+                    &compat_param->fm_pcd_cc_group_params[k],
+                    &param->fm_pcd_cc_group_params[k],
+                    compat);
+        compat_param->id = ptr_to_compat(param->id);
+    }
+}
+
+void compat_fm_pcd_prs_sw(
+        ioc_compat_fm_pcd_prs_sw_params_t *compat_param,
+        ioc_fm_pcd_prs_sw_params_t *param,
+        uint8_t compat)
+{
+    if (compat)
+    {
+        param->override = compat_param->override;
+        param->size = compat_param->size;
+        param->base = compat_param->base;
+        param->p_code = compat_ptr(compat_param->p_code);
+        memcpy(param->sw_prs_data_params,compat_param->sw_prs_data_params,IOC_FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+        param->num_of_labels = compat_param->num_of_labels;
+        memcpy(param->labels_table,compat_param->labels_table,IOC_FM_PCD_PRS_NUM_OF_LABELS*sizeof(ioc_fm_pcd_prs_label_params_t));
+        return;
+    }
+
+    printk(" %s:%u feature not implemented... \n", __func__, __LINE__);
+    BUG();
+}
+
+void compat_copy_fm_pcd_kg_scheme(
+        ioc_compat_fm_pcd_kg_scheme_params_t    *compat_param,
+        ioc_fm_pcd_kg_scheme_params_t           *param,
+        uint8_t                                 compat)
+{
+    if (compat)
+    {
+        param->modify = compat_param->modify;
+
+        /* scm_id */
+        if(compat_param->modify)
+            param->scm_id.scheme_id = compat_ptr(compat_param->scm_id.scheme_id);
+        else
+            param->scm_id.relative_scheme_id = compat_param->scm_id.relative_scheme_id;
+
+        param->always_direct = compat_param->always_direct;
+        /* netEnvParams */
+        param->netEnvParams.net_env_id = compat_ptr(compat_param->netEnvParams.net_env_id);
+        param->netEnvParams.num_of_distinction_units = compat_param->netEnvParams.num_of_distinction_units;
+        memcpy(param->netEnvParams.unit_ids,
+               compat_param->netEnvParams.unit_ids,
+               IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+
+        param->use_hash = compat_param->use_hash;
+        memcpy(&param->key_extract_and_hash_params,
+               &compat_param->key_extract_and_hash_params,
+               sizeof(ioc_fm_pcd_kg_key_extract_and_hash_params_t));
+        param->bypass_fqid_generation = compat_param->bypass_fqid_generation;
+        param->base_fqid = compat_param->base_fqid;
+        param->numOfUsedExtractedOrs = compat_param->numOfUsedExtractedOrs;
+		memcpy(param->extracted_ors, compat_param->extracted_ors, IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS * sizeof(ioc_fm_pcd_kg_extracted_or_params_t));
+        param->next_engine = compat_param->next_engine;
+
+    	/* kg_next_engine_params */
+        if(param->next_engine == e_IOC_FM_PCD_CC){
+            param->kg_next_engine_params.cc.tree_id = compat_get_id2ptr(compat_param->kg_next_engine_params.cc.tree_id);
+            param->kg_next_engine_params.cc.grp_id = compat_param->kg_next_engine_params.cc.grp_id;
+            param->kg_next_engine_params.cc.plcr_next = compat_param->kg_next_engine_params.cc.plcr_next;
+            param->kg_next_engine_params.cc.bypass_plcr_profile_generation = compat_param->kg_next_engine_params.cc.bypass_plcr_profile_generation;
+            memcpy(&param->kg_next_engine_params.cc.plcr_profile,
+                   &compat_param->kg_next_engine_params.cc.plcr_profile,
+                   sizeof(ioc_fm_pcd_kg_plcr_profile_t));
+        }
+        else
+			memcpy(&param->kg_next_engine_params,
+                   &compat_param->kg_next_engine_params,
+                   sizeof(param->kg_next_engine_params));
+
+        memcpy(&param->scheme_counter, &compat_param->scheme_counter, sizeof(ioc_fm_pcd_kg_scheme_counter_t));
+        param->id = compat_ptr(compat_param->id);
+    }
+    else
+    {
+        compat_param->modify = param->modify;
+
+        /* scm_id */
+        if(param->modify)
+            compat_param->scm_id.scheme_id = ptr_to_compat(param->scm_id.scheme_id);
+        else
+            compat_param->scm_id.relative_scheme_id = param->scm_id.relative_scheme_id;
+
+        compat_param->always_direct = param->always_direct;
+
+        /* netEnvParams */
+        compat_param->netEnvParams.net_env_id = ptr_to_compat(param->netEnvParams.net_env_id);
+        compat_param->netEnvParams.num_of_distinction_units = param->netEnvParams.num_of_distinction_units;
+        memcpy(compat_param->netEnvParams.unit_ids, param->netEnvParams.unit_ids, IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+
+        compat_param->use_hash = param->use_hash;
+        memcpy(&compat_param->key_extract_and_hash_params, &param->key_extract_and_hash_params, sizeof(ioc_fm_pcd_kg_key_extract_and_hash_params_t));
+        compat_param->bypass_fqid_generation = param->bypass_fqid_generation;
+        compat_param->base_fqid = param->base_fqid;
+        compat_param->numOfUsedExtractedOrs = param->numOfUsedExtractedOrs;
+		memcpy(compat_param->extracted_ors, param->extracted_ors, IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS * sizeof(ioc_fm_pcd_kg_extracted_or_params_t));
+        compat_param->next_engine = param->next_engine;
+
+        /* kg_next_engine_params */
+        if(compat_param->next_engine == e_IOC_FM_PCD_CC){
+            compat_param->kg_next_engine_params.cc.tree_id = compat_get_ptr2id(param->kg_next_engine_params.cc.tree_id);
+            compat_param->kg_next_engine_params.cc.grp_id = param->kg_next_engine_params.cc.grp_id;
+            compat_param->kg_next_engine_params.cc.plcr_next = param->kg_next_engine_params.cc.plcr_next;
+            compat_param->kg_next_engine_params.cc.bypass_plcr_profile_generation = param->kg_next_engine_params.cc.bypass_plcr_profile_generation;
+            memcpy(&compat_param->kg_next_engine_params.cc.plcr_profile, &param->kg_next_engine_params.cc.plcr_profile, sizeof(ioc_fm_pcd_kg_plcr_profile_t));
+        }
+        else
+            memcpy(&param->kg_next_engine_params, &compat_param->kg_next_engine_params, sizeof(compat_param->kg_next_engine_params));
+
+        memcpy(&compat_param->scheme_counter, &param->scheme_counter, sizeof(ioc_fm_pcd_kg_scheme_counter_t));
+        compat_param->id = ptr_to_compat(param->id);
+    }
+}
+
+void compat_copy_fm_pcd_kg_scheme_select(
+        ioc_compat_fm_pcd_kg_scheme_select_t *compat_param,
+        ioc_fm_pcd_kg_scheme_select_t *param,
+        uint8_t compat)
+{
+    if (compat){
+        param->direct = compat_param->direct;
+        param->scheme_id = compat_ptr(compat_param->direct);
+    }
+    else {
+        printk(" %s:%u feature not implemented... \n", __func__, __LINE__);
+    }
+}
+
+void compat_copy_fm_pcd_kg_schemes_params(
+        ioc_compat_fm_pcd_port_schemes_params_t *compat_param,
+        ioc_fm_pcd_port_schemes_params_t *param,
+        uint8_t compat)
+{
+    int k;
+
+    if (compat) {
+        param->num_of_schemes = compat_param->num_of_schemes;
+        for(k=0; k < IOC_FM_PCD_KG_NUM_OF_SCHEMES; k++)
+            param->schemes_ids[k] = compat_ptr(compat_param->schemes_ids[k]);
+    }
+    else {
+        printk(" %s:%u feature not implemented... \n", __func__, __LINE__);
+    }
+}
+
+void compat_copy_fm_port_pcd_kg(
+        ioc_compat_fm_port_pcd_kg_params_t *compat_param,
+        ioc_fm_port_pcd_kg_params_t *param,
+        uint8_t compat)
+{
+    if (compat){
+        uint8_t k;
+        param->num_of_schemes = compat_param->num_of_schemes;
+        for(k=0;k<IOC_FM_PCD_KG_NUM_OF_SCHEMES;k++)
+            param->schemes_ids[k] = compat_ptr(compat_param->schemes_ids[k]);
+        param->direct_scheme = compat_param->direct_scheme;
+        param->direct_scheme_id = compat_ptr(compat_param->direct_scheme_id);
+    }
+    else {
+        printk(" %s:%u feature not implemented... \n", __func__, __LINE__);;
+    }
+}
+
+void compat_copy_fm_port_pcd(
+        ioc_compat_fm_port_pcd_params_t *compat_param,
+        ioc_fm_port_pcd_params_t *param,
+        uint8_t compat)
+{
+    if (compat){
+        param->pcd_support = compat_param->pcd_support;
+        param->net_env_id = compat_ptr(compat_param->net_env_id);
+        param->p_prs_params = compat_ptr(compat_param->p_prs_params); /* same structure */
+        param->p_cc_params = compat_ptr(compat_param->p_cc_params);
+        param->p_kg_params = compat_ptr(compat_param->p_kg_params);
+        param->p_plcr_params = compat_ptr(compat_param->p_plcr_params);
+    }
+    else {
+        compat_param->pcd_support = param->pcd_support;
+        compat_param->net_env_id = ptr_to_compat(param->net_env_id);
+        compat_param->p_prs_params = ptr_to_compat(param->p_prs_params); /* same structure */
+        compat_param->p_cc_params = ptr_to_compat(param->p_cc_params);
+        compat_param->p_kg_params = ptr_to_compat(param->p_kg_params);
+        compat_param->p_plcr_params = ptr_to_compat(param->p_plcr_params);
+    }
+}
+
+void compat_copy_fm_pcd_net_env(
+        ioc_compat_fm_pcd_net_env_params_t *compat_param,
+        ioc_fm_pcd_net_env_params_t *param,
+        uint8_t compat)
+{
+    if (compat)
+    {
+        param->num_of_distinction_units = compat_param->num_of_distinction_units;
+        memcpy(param->units, compat_param->units, sizeof(ioc_fm_pcd_distinction_unit_t)*IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+        param->id = compat_ptr(compat_param->id);
+    }
+    else
+    {
+        compat_param->num_of_distinction_units = param->num_of_distinction_units;
+        memcpy(compat_param->units, param->units, sizeof(ioc_fm_pcd_distinction_unit_t)*IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+        compat_param->id = ptr_to_compat(param->id);
+    }
+}
+
+void compat_copy_fm_pcd_cc_node_modify_key(
+        ioc_compat_fm_pcd_cc_node_modify_key_params_t   *compat_param,
+        ioc_fm_pcd_cc_node_modify_key_params_t          *param,
+        uint8_t                                         compat)
+{
+    if (compat)
+    {
+        param->id       = compat_ptr(compat_param->id);
+        param->key_indx = compat_param->key_indx;
+        param->key_size = compat_param->key_size;
+        param->p_key    = (uint8_t *)compat_ptr(compat_param->p_key);
+        param->p_mask   = (uint8_t *)compat_ptr(compat_param->p_mask);
+    }
+    else
+    {
+        compat_param->id        = ptr_to_compat(param->id);
+        compat_param->key_indx  = param->key_indx;
+        compat_param->key_size  = param->key_size;
+        compat_param->p_key     = ptr_to_compat((void *)param->p_key);
+        compat_param->p_mask    = ptr_to_compat((void *)param->p_mask);
+    }
+}
+
+void compat_copy_keys(
+        ioc_compat_keys_params_t *compat_param,
+        ioc_keys_params_t *param,
+        uint8_t compat)
+{
+    int k = 0;
+    if (compat){
+        param->num_of_keys = compat_param->num_of_keys;
+        param->key_size = compat_param->key_size;
+
+        for(k=0;k<IOC_FM_PCD_MAX_NUM_OF_KEYS;k++)
+            compat_copy_fm_pcd_cc_key(
+                &compat_param->key_params[k],
+                &param->key_params[k],
+                compat);
+
+    }
+    else {
+
+        compat_param->num_of_keys = param->num_of_keys;
+        compat_param->key_size = param->key_size;
+
+        for(k=0;k<IOC_FM_PCD_MAX_NUM_OF_KEYS;k++)
+            compat_copy_fm_pcd_cc_key(
+                &compat_param->key_params[k],
+                &param->key_params[k],
+                compat);
+    }
+
+    compat_copy_fm_pcd_cc_next_engine(
+            &compat_param->cc_next_engine_params_for_miss,
+            &param->cc_next_engine_params_for_miss,
+            compat);
+
+}
+
+void compat_copy_fm_pcd_cc_node(
+        ioc_compat_fm_pcd_cc_node_params_t  *compat_param,
+        ioc_fm_pcd_cc_node_params_t         *param,
+        uint8_t                             compat)
+{
+    if (compat)
+    {
+        /* no pointer inside, so sizeof US and KS are the same - memcpy is ok */
+        memcpy(&param->extract_cc_params, &compat_param->extract_cc_params, sizeof(ioc_fm_pcd_extract_entry_t));
+
+        compat_copy_keys(&compat_param->keys_params, &param->keys_params, compat);
+
+        param->id = compat_get_id2ptr(compat_param->id);
+    }
+    else
+    {
+        /* no pointer inside, so sizeof US and KS are the same - memcpy is ok */
+        memcpy(&compat_param->extract_cc_params, &param->extract_cc_params, sizeof(ioc_fm_pcd_extract_entry_t));
+
+        compat_copy_keys(&compat_param->keys_params, &param->keys_params, compat);
+
+        compat_param->id = ptr_to_compat(param->id);
+    }
+}
+
diff --git a/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
new file mode 100644
index 0000000..53448f4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -0,0 +1,2444 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          lnxwrp_fm.c
+
+ @Author        Shlomi Gridish
+
+ @Description   FM Linux wrapper functions.
+*//***************************************************************************/
+
+/* Linux Headers ------------------- */
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+#include <sysdev/fsl_soc.h>
+
+#if defined(CONFIG_COMPAT)
+#include <linux/compat.h>
+#endif
+
+#include "part_ext.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+#include "fm_port_ioctls.h"
+
+#if defined(CONFIG_COMPAT)
+#include "fm_compat_ioctls.h"
+#endif
+
+#include "lnxwrp_fm.h"
+
+#define CMP_IOC_DEFINE(def) (IOC_##def != def)
+
+/* fm_pcd_ioctls.h === fm_pcd_ext.h assertions */
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_PRS_NUM_OF_HDRS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_SCHEMES)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+/* please check for this one in fm_common.h: */
+#define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
+#if (IOC_FM_PCD_MAX_NUM_OF_OPTIONS != FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+#error Error: please synchronize IOC_ defines!
+#endif
+#undef FM_PCD_MAX_NUM_OF_OPTIONS
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_GENERIC_REGS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CLS_PLANS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_DEFAULT_GROUPS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_PRS_NUM_OF_LABELS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_NODES)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_TREES)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_GROUPS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_UNITS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_KEYS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_SIZE_OF_KEY)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+/* net_ioctls.h === net_ext.h assertions */
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPPoE_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPPMUX_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_ETH_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IPv4_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IPv6_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_ICMP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IGMP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_TCP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_SCTP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_DCCP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_UDP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IPHC_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_L2TPv2_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_VLAN_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_LLC_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_NLPID_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_SNAP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS)
+#warning Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_ARP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_RFC2684_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_GRE_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_MINENCAP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_MACSEC_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+/* fm_ioctls.h === fm_ext.h assertions */
+#if CMP_IOC_DEFINE(FM_MAX_NUM_OF_VALID_PORTS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+/* fm_port_ioctls.h === dpaa_integrations_ext.h assertions */
+#if CMP_IOC_DEFINE(FM_PORT_NUM_OF_CONGESTION_GRPS)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#define ASSERT_IOC_NET_ENUM(def) ASSERT_COND((unsigned long)e_IOC_NET_##def == (unsigned long)def)
+
+static void LnxwrpAssertions(void)
+{
+    /* sampling checks */
+    ASSERT_IOC_NET_ENUM(HEADER_TYPE_MACSEC);
+    ASSERT_IOC_NET_ENUM(HEADER_TYPE_PPP);
+    ASSERT_IOC_NET_ENUM(MAX_HEADER_TYPE_COUNT);
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_TYPE_DUMMY == (unsigned long)e_FM_PORT_TYPE_DUMMY);
+    ASSERT_COND((unsigned long)e_IOC_FM_EX_MURAM_ECC == (unsigned long)e_FM_EX_MURAM_ECC);
+    ASSERT_COND((unsigned long)e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT == (unsigned long)e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES == (unsigned long)e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC == (unsigned long)e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS == (unsigned long)e_FM_PCD_PRS);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_EXTRACT_FULL_FIELD == (unsigned long)e_FM_PCD_EXTRACT_FULL_FIELD);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID == (unsigned long)e_FM_PCD_EXTRACT_FROM_FLOW_ID);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO == (unsigned long)e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_DFLT_ILLEGAL == (unsigned long)e_FM_PCD_KG_DFLT_ILLEGAL);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA == (unsigned long)e_FM_PCD_KG_GENERIC_NOT_FROM_DATA);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_HDR_INDEX_3 == (unsigned long)e_FM_PCD_HDR_INDEX_3);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_SHARED == (unsigned long)e_FM_PCD_PLCR_SHARED);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_RFC_4115 == (unsigned long)e_FM_PCD_PLCR_RFC_4115);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_COLOR_AWARE == (unsigned long)e_FM_PCD_PLCR_COLOR_AWARE);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_OVERRIDE == (unsigned long)e_FM_PCD_PLCR_OVERRIDE);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_FULL_FRM_LEN == (unsigned long)e_FM_PCD_PLCR_FULL_FRM_LEN);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN == (unsigned long)e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_PACKET_MODE == (unsigned long)e_FM_PCD_PLCR_PACKET_MODE);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_DROP_FRAME == (unsigned long)e_FM_PCD_DROP_FRAME);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER == (unsigned long)e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP == (unsigned long)e_FM_PCD_ACTION_INDEXED_LOOKUP);
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR == (unsigned long)e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR);
+#ifdef FM_CAPWAP_SUPPORT
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR == (unsigned long)e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR);
+#endif
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM == (unsigned long)e_FM_PORT_COUNTERS_DEQ_CONFIRM);
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8 == (unsigned long)e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8);
+}
+
+static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg, bool compat)
+{
+    t_Error err = E_READ_FAILED;
+
+    /* can be moved from here */
+    LnxwrpAssertions();
+
+    switch (cmd)
+    {
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_PRS_LOAD_SW_COMPAT:
+#endif
+        case FM_PCD_IOC_PRS_LOAD_SW:
+        {
+            ioc_fm_pcd_prs_sw_params_t *param;
+            uint8_t                    *p_code;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
+
+            param = (ioc_fm_pcd_prs_sw_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_prs_sw_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_prs_sw_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_prs_sw_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_prs_sw_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_prs_sw_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_prs_sw_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_fm_pcd_prs_sw(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_prs_sw_params_t *)arg,
+                            sizeof(ioc_fm_pcd_prs_sw_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            p_code = (uint8_t *) XX_Malloc(param->size);
+            if (!p_code)
+            {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (copy_from_user(p_code, param->p_code, param->size)) {
+                XX_Free(p_code);
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->p_code = p_code;
+
+            err = FM_PCD_PrsLoadSw(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPrsSwParams*)param);
+            XX_Free(p_code);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_ENABLE:
+            return FM_PCD_Enable(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_DISABLE:
+            return FM_PCD_Disable(p_LnxWrpFmDev->h_PcdDev);
+
+        case FM_PCD_IOC_FORCE_INTR:
+        {
+            int exception;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (get_user(exception, (int *) compat_ptr(arg)))
+                    break;
+            }
+            else
+#endif
+            {
+               if (get_user(exception, (int *)arg))
+                   break;
+            }
+
+            return FM_PCD_ForceIntr(p_LnxWrpFmDev->h_PcdDev, (e_FmPcdExceptions)exception);
+        }
+
+        case FM_PCD_IOC_SET_EXCEPTION:
+        {
+            ioc_fm_pcd_exception_params_t *param;
+
+            param = (ioc_fm_pcd_exception_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_exception_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_exception_params_t *)compat_ptr(arg),
+                                    sizeof(ioc_fm_pcd_exception_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_exception_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_exception_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev, param->exception, param->enable);
+            XX_Free(param);
+            break;
+        }
+
+        case FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING:
+        {
+            uint8_t payloadOffset;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (get_user(payloadOffset, (uint8_t*) compat_ptr(arg)))
+                    break;
+            }
+            else
+#endif
+            {
+                if (get_user(payloadOffset, (uint8_t*) arg))
+                    break;
+            }
+
+            return FM_PCD_KgSetAdditionalDataAfterParsing(p_LnxWrpFmDev->h_PcdDev, payloadOffset);
+        }
+
+        case FM_PCD_IOC_KG_SET_DFLT_VALUE:
+        {
+            ioc_fm_pcd_kg_dflt_value_params_t *param;
+
+            param = (ioc_fm_pcd_kg_dflt_value_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_kg_dflt_value_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_kg_dflt_value_params_t *)compat_ptr(arg),
+                                    sizeof(ioc_fm_pcd_kg_dflt_value_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_kg_dflt_value_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_kg_dflt_value_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_KgSetDfltValue(p_LnxWrpFmDev->h_PcdDev, param->valueId, param->value);
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT:
+#endif
+        case FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_pcd_net_env_params_t  *param;
+
+            param = (ioc_fm_pcd_net_env_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_net_env_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_net_env_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_net_env_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_net_env_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
+                                    sizeof(ioc_compat_fm_pcd_net_env_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_net_env(compat_param, param, COMPAT_US_TO_K);
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_net_env_params_t *) arg,
+                            sizeof(ioc_fm_pcd_net_env_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            param->id = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_net_env_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_net_env_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_net_env_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                compat_copy_fm_pcd_net_env(compat_param, param, COMPAT_K_TO_US);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_net_env_params_t)))
+                    err = E_OK;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_net_env_params_t *)arg, param, sizeof(ioc_fm_pcd_net_env_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT:
+#endif
+        case FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_DeleteNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_KG_SET_SCHEME_COMPAT:
+#endif
+        case FM_PCD_IOC_KG_SET_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_params_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdKgSchemeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_kg_scheme_params_t));
+            param = (ioc_fm_pcd_kg_scheme_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_kg_scheme_params_t *compat_param = NULL;
+
+                compat_param = (ioc_compat_fm_pcd_kg_scheme_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_kg_scheme_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_kg_scheme_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_kg_scheme(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_params_t *)arg,
+                            sizeof(ioc_fm_pcd_kg_scheme_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            param->id = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_kg_scheme_params_t *compat_param = NULL;
+
+                compat_param = (ioc_compat_fm_pcd_kg_scheme_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                compat_copy_fm_pcd_kg_scheme(compat_param, param, COMPAT_K_TO_US);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_kg_scheme_params_t *)compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_kg_scheme_params_t)))
+                    err = E_OK;
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_kg_scheme_params_t *)arg,
+                            param,
+                            sizeof(ioc_fm_pcd_kg_scheme_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_KG_DEL_SCHEME_COMPAT:
+#endif
+        case FM_PCD_IOC_KG_DEL_SCHEME:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_KgDeleteScheme(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_SET_NODE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_SET_NODE:
+        {
+            ioc_fm_pcd_cc_node_params_t *param;
+            uint8_t                     *keys;
+            uint8_t                     *masks;
+            int                         i,k;
+
+            ASSERT_COND(sizeof(t_FmPcdCcNodeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_node_params_t));
+
+            param = (ioc_fm_pcd_cc_node_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_params_t) +
+                    2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_params_t) +
+                    2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            keys = (uint8_t *) (param + 1);
+            masks = keys + IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY;
+            memset(keys, 0, 2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_params_t) +
+                        2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_params_t) +
+                        2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_node_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_node_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_params_t *)arg, sizeof(ioc_fm_pcd_cc_node_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+            ASSERT_COND(param->keys_params.num_of_keys <= IOC_FM_PCD_MAX_NUM_OF_KEYS);
+            ASSERT_COND(param->keys_params.key_size <= IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+            /* support for indexed lookup */
+            if( !(param->extract_cc_params.type == e_IOC_FM_PCD_EXTRACT_NON_HDR &&
+                  param->extract_cc_params.extract_params.extract_non_hdr.src == e_IOC_FM_PCD_EXTRACT_FROM_HASH &&
+                  param->extract_cc_params.extract_params.extract_non_hdr.action == e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP))
+            {
+                for (i=0, k=0;
+                     i < param->keys_params.num_of_keys;
+                     i++, k += IOC_FM_PCD_MAX_SIZE_OF_KEY)
+                {
+                    if (copy_from_user(&keys[k],
+                                param->keys_params.key_params[i].p_key,
+                                param->keys_params.key_size))
+                    {
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, err, NO_MSG);
+                    }
+
+                    param->keys_params.key_params[i].p_key = &keys[k];
+
+                    if (param->keys_params.key_params[i].p_mask)
+                    {
+                        if (copy_from_user(&masks[k],
+                                    param->keys_params.key_params[i].p_mask,
+                                    param->keys_params.key_size))
+                        {
+                            XX_Free(param);
+                            RETURN_ERROR(MINOR, err, NO_MSG);
+                        }
+                        param->keys_params.key_params[i].p_mask = &masks[k];
+                    }
+                }
+            }
+
+            param->id = FM_PCD_CcSetNode(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_params_t *compat_param;
+                compat_param = (ioc_compat_fm_pcd_cc_node_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_params_t) +
+                        2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_params_t) +
+                        2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                /* setup user space structure */
+                compat_copy_fm_pcd_cc_node(compat_param, param, COMPAT_K_TO_US);
+
+                compat_param->id = compat_add_ptr2id(param->id);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_node_params_t *)compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_cc_node_params_t)))
+                    err = E_OK;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_cc_node_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_node_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_DELETE_NODE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_DELETE_NODE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_get_id2ptr(compat_id.obj);
+                compat_del_ptr2id(id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_CcDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_BUILD_TREE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_BUILD_TREE:
+        {
+            ioc_fm_pcd_cc_tree_params_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdCcTreeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_tree_params_t));
+
+            param = (ioc_fm_pcd_cc_tree_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_tree_params_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tree_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tree_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_tree(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_tree_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tree_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            param->id = FM_PCD_CcBuildTree(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tree_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tree_params_t *) XX_Malloc(sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
+
+                compat_add_ptr2id(param->id);
+                param->id = (void *)(uint64_t)compat_get_ptr2id(param->id);
+
+                compat_copy_fm_pcd_cc_tree(compat_param, param, COMPAT_K_TO_US);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
+                                                compat_param,
+                                                sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
+                    err = E_OK;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_cc_tree_params_t *)arg, param, sizeof(ioc_fm_pcd_cc_tree_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_DELETE_TREE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_DELETE_TREE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_get_id2ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_CcDeleteTree(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT:
+#endif
+        case FM_PCD_IOC_PLCR_SET_PROFILE:
+        {
+            ioc_fm_pcd_plcr_profile_params_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *) == sizeof(ioc_fm_pcd_plcr_profile_params_t));
+
+            param = (ioc_fm_pcd_plcr_profile_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_plcr_profile_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_plcr_profile_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_plcr_profile_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_plcr_profile_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_plcr_profile_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_plcr_profile_params_t))) {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_plcr_profile(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_plcr_profile_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_plcr_profile_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            if (!param->modify &&
+                (((t_FmPcdPlcrProfileParams*)param)->id.newParams.profileType != e_FM_PCD_PLCR_SHARED))
+            {
+                t_Handle h_Port;
+                fm_pcd_port_params_t *port_params;
+
+                port_params = (fm_pcd_port_params_t*) XX_Malloc(sizeof(fm_pcd_port_params_t)); 
+                if (!port_params)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(port_params, (fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort,
+                            sizeof(fm_pcd_port_params_t)))
+                {
+                    XX_Free(port_params);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                switch(port_params->port_type)
+                {
+                    case (e_IOC_FM_PORT_TYPE_RX):
+                        h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_RX_10G):
+                        h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                        break;
+                    case (e_IOC_FM_PORT_TYPE_OFFLINE_PARSING):
+                        if (port_params->port_id)
+                        {
+                            h_Port = p_LnxWrpFmDev->opPorts[port_params->port_id - 1].h_Dev;
+                            break;
+                        }
+                    default:
+                        XX_Free(port_params);
+                        XX_Free(param);
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+                }
+
+                ((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort = h_Port;
+                XX_Free(port_params);
+            }
+
+            param->id = FM_PCD_PlcrSetProfile(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_plcr_profile_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_plcr_profile_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_plcr_profile_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                compat_copy_fm_pcd_plcr_profile(compat_param, param, COMPAT_K_TO_US);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_plcr_profile_params_t *) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_plcr_profile_params_t)))
+                    err = E_OK;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_plcr_profile_params_t *)arg, param, sizeof(ioc_fm_pcd_plcr_profile_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT:
+#endif
+        case FM_PCD_IOC_PLCR_DEL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_PlcrDeleteProfile(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
+
+            param = (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_fm_pcd_cc_tree_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcTreeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                    param->id,
+                    param->grp_indx,
+                    param->indx,
+                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcNodeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                    param->id,
+                    param->key_indx,
+                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
+
+            param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
+                                    sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node_modify_next_engine(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_next_engine_params_t *) arg,
+                                    sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcNodeModifyMissNextEngine(p_LnxWrpFmDev->h_PcdDev, param->id,
+                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_REMOVE_KEY:
+        {
+            ioc_fm_pcd_cc_node_remove_key_params_t *param;
+
+            param = (ioc_fm_pcd_cc_node_remove_key_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_remove_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_remove_key_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_remove_key_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_remove_key_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_node_remove_key_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_node_remove_key_params_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                param->id = compat_ptr(compat_param->id);
+                param->key_indx = compat_param->key_indx;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_remove_key_params_t *) arg,
+                            sizeof(ioc_fm_pcd_cc_node_remove_key_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcNodeRemoveKey(p_LnxWrpFmDev->h_PcdDev, param->id, param->key_indx);
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_ADD_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcNodeAddKey(p_LnxWrpFmDev->h_PcdDev,
+                    param->id,
+                    param->key_indx,
+                    param->key_size,
+                    (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE:
+        {
+            ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
+
+            ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
+
+            param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node_modify_key_and_next_engine(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            err = FM_PCD_CcNodeModifyKeyAndNextEngine(p_LnxWrpFmDev->h_PcdDev,
+                    param->id,
+                    param->key_indx,
+                    param->key_size,
+                    (t_FmPcdCcKeyParams*)(&param->key_params));
+            XX_Free(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT:
+#endif
+        case FM_PCD_IOC_CC_NODE_MODIFY_KEY:
+        {
+            ioc_fm_pcd_cc_node_modify_key_params_t  *param = NULL;
+            uint8_t                                 *key = NULL;
+            uint8_t                                 *mask = NULL;
+
+            param = (ioc_fm_pcd_cc_node_modify_key_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_cc_node_modify_key_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_node_modify_key_params_t  *compat_param = NULL;
+                compat_param = (ioc_compat_fm_pcd_cc_node_modify_key_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_node_modify_key_params_t));
+                if (!param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_key_params_t *)compat_ptr(arg),
+                                    sizeof(ioc_compat_fm_pcd_cc_node_modify_key_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_node_modify_key(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_cc_node_modify_key_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_cc_node_modify_key_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            if (param->p_key)
+            {
+                key = (uint8_t *) XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!key)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD key"));
+                }
+                memset(key, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(key, param->p_key, param->key_size))
+                {
+                    XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_key = key;
+            }
+
+            if (param->p_mask)
+            {
+                mask = (uint8_t *) XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                if (!mask)
+                {
+                    if (key)
+                        XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD mask"));
+                }
+                memset(mask, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+
+                if (copy_from_user(mask, param->p_mask, param->key_size))
+                {
+                    if (mask)
+                        XX_Free(mask);
+                    if (key)
+                        XX_Free(key);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+                param->p_mask = mask;
+            }
+
+            err = FM_PCD_CcNodeModifyKey(p_LnxWrpFmDev->h_PcdDev,
+                    param->id,
+                    param->key_indx,
+                    param->key_size,
+                    param->p_key,
+                    param->p_mask);
+            if (mask)
+                XX_Free(mask);
+            if (key)
+                XX_Free(key);
+            XX_Free(param);
+            break;
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
+            break;
+    }
+
+    return err;
+}
+
+t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg, bool compat)
+{
+    t_Error err = E_READ_FAILED;
+
+    DBG(TRACE, ("p_LnxWrpFmDev - 0x%08lx, cmd - 0x%08x, arg - 0x%08lx \n", (uintptr_t)p_LnxWrpFmDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_IOC_SET_PORTS_BANDWIDTH:
+        {
+            ioc_fm_port_bandwidth_params *param;
+
+            ASSERT_COND(sizeof(t_FmPortsBandwidthParams) == sizeof(ioc_fm_port_bandwidth_params));
+
+            param = (ioc_fm_port_bandwidth_params*) XX_Malloc(sizeof(ioc_fm_port_bandwidth_params));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_port_bandwidth_params*)compat_ptr(arg), sizeof(ioc_fm_port_bandwidth_params)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_port_bandwidth_params*)arg, sizeof(ioc_fm_port_bandwidth_params)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+
+            err =  FM_SetPortsBandwidth(p_LnxWrpFmDev->h_Dev, (t_FmPortsBandwidthParams*) param);
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_REVISION:
+        {
+            ioc_fm_revision_info_t *param;
+
+            ASSERT_COND(sizeof(t_FmRevisionInfo) == sizeof(ioc_fm_revision_info_t));
+
+            param = (ioc_fm_revision_info_t *) XX_Malloc(sizeof(ioc_fm_revision_info_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            FM_GetRevision(p_LnxWrpFmDev->h_Dev, (t_FmRevisionInfo*)param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_to_user((ioc_fm_revision_info_t *)compat_ptr(arg),
+                            param,
+                            sizeof(ioc_fm_revision_info_t)))
+                    err = E_WRITE_FAILED;
+                else
+                    err = E_OK;
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_revision_info_t *)arg,
+                            param,
+                            sizeof(ioc_fm_revision_info_t)))
+                    err = E_WRITE_FAILED;
+                else
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_SET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *) XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_counters_params_t *)compat_ptr(arg), sizeof(ioc_fm_counters_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+
+            err = FM_ModifyCounter(p_LnxWrpFmDev->h_Dev, param->cnt, param->val);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_GET_COUNTER:
+        {
+            ioc_fm_counters_params_t *param;
+
+            param = (ioc_fm_counters_params_t *) XX_Malloc(sizeof(ioc_fm_counters_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_counters_params_t *)compat_ptr(arg), sizeof(ioc_fm_counters_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_counters_params_t *)arg, sizeof(ioc_fm_counters_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+
+            param->val = FM_GetCounter(p_LnxWrpFmDev->h_Dev, param->cnt);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_to_user((ioc_fm_counters_params_t *)compat_ptr(arg), param, sizeof(ioc_fm_counters_params_t)))
+                    err = E_WRITE_FAILED;
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_counters_params_t *)arg, param, sizeof(ioc_fm_counters_params_t)))
+                    err = E_WRITE_FAILED;
+            }
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_IOC_FORCE_INTR:
+        {
+            ioc_fm_exceptions param;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (get_user(param, (ioc_fm_exceptions*) compat_ptr(arg)))
+                    break;
+            }
+            else
+#endif
+            {
+                if (get_user(param, (ioc_fm_exceptions*)arg))
+                    break;
+            }
+
+            return FM_ForceIntr(p_LnxWrpFmDev->h_Dev, (e_FmExceptions)param);
+        }
+
+        default:
+            return LnxwrpFmPcdIOCTL(p_LnxWrpFmDev, cmd, arg, compat);
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL FM"));
+}
+
+t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg, bool compat)
+{
+    t_Error err = E_READ_FAILED;
+    DBG(TRACE, ("p_LnxWrpFmPortDev - 0x%08lx, cmd - 0x%08x, arg - 0x%08lx", (uintptr_t)p_LnxWrpFmPortDev, cmd, arg));
+
+    switch (cmd)
+    {
+        case FM_PORT_IOC_DISABLE:
+            FM_PORT_Disable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+
+        case FM_PORT_IOC_ENABLE:
+            FM_PORT_Enable(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+
+        case FM_PORT_IOC_SET_ERRORS_ROUTE:
+        {
+            ioc_fm_port_frame_err_select_t errs;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (get_user(errs, (ioc_fm_port_frame_err_select_t*)compat_ptr(arg)))
+                    break;
+            }
+            else
+#endif
+            {
+                if (get_user(errs, (ioc_fm_port_frame_err_select_t*)arg))
+                    break;
+            }
+
+            return FM_PORT_SetErrorsRoute(p_LnxWrpFmPortDev->h_Dev, (fmPortFrameErrSelect_t)errs);
+        }
+
+        case FM_PORT_IOC_SET_RATE_LIMIT:
+        {
+            ioc_fm_port_rate_limit_t *param;
+
+            ASSERT_COND(sizeof(t_FmPortRateLimit) == sizeof(ioc_fm_port_rate_limit_t));
+
+            param = (ioc_fm_port_rate_limit_t *) XX_Malloc(sizeof(ioc_fm_port_rate_limit_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_port_rate_limit_t *)compat_ptr(arg), sizeof(ioc_fm_port_rate_limit_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_port_rate_limit_t *)arg, sizeof(ioc_fm_port_rate_limit_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+                }
+            }
+
+            err =  FM_PORT_SetRateLimit(p_LnxWrpFmPortDev->h_Dev, (t_FmPortRateLimit *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_REMOVE_RATE_LIMIT:
+            FM_PORT_DeleteRateLimit(p_LnxWrpFmPortDev->h_Dev);
+            return E_OK;
+        
+        case FM_PORT_IOC_ALLOC_PCD_FQIDS:
+        {
+            ioc_fm_port_pcd_fqids_params_t *param;
+
+            param = (ioc_fm_port_pcd_fqids_params_t *) XX_Malloc(sizeof(ioc_fm_port_pcd_fqids_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_port_pcd_fqids_params_t *)compat_ptr(arg),
+                                    sizeof(ioc_fm_port_pcd_fqids_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_port_pcd_fqids_params_t *)arg,
+                                    sizeof(ioc_fm_port_pcd_fqids_params_t)))
+                {
+                    XX_Free(param);
+                    return err;
+                }
+            }
+
+            if (!p_LnxWrpFmPortDev->pcd_owner_params.cb)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("No one to listen on this PCD!!!"));
+
+            if (p_LnxWrpFmPortDev->pcd_owner_params.cb (p_LnxWrpFmPortDev->pcd_owner_params.dev,
+                                                        param->num_fqids,
+                                                        param->alignment,
+                                                        &param->base_fqid))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("can't allocate fqids for PCD!!!"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_to_user((ioc_fm_port_pcd_fqids_params_t *)compat_ptr(arg),
+                                  param, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_port_pcd_fqids_params_t *)arg,
+                                  param, sizeof(ioc_fm_port_pcd_fqids_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+            XX_Free(param);
+            return E_OK;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_SET_PCD_COMPAT:
+#endif
+        case FM_PORT_IOC_SET_PCD:
+        {
+            ioc_fm_port_pcd_params_t      *port_pcd_params;
+            ioc_fm_port_pcd_prs_params_t  *port_pcd_prs_params;
+            ioc_fm_port_pcd_cc_params_t   *port_pcd_cc_params;
+            ioc_fm_port_pcd_kg_params_t   *port_pcd_kg_params;
+            ioc_fm_port_pcd_plcr_params_t *port_pcd_plcr_params;
+
+            long copy_fail = 0;
+
+            ASSERT_COND(sizeof(t_FmPortPcdParams) == sizeof(ioc_fm_port_pcd_params_t));
+
+            port_pcd_params = (ioc_fm_port_pcd_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_port_pcd_params_t) +
+                    sizeof(ioc_fm_port_pcd_prs_params_t) +
+                    sizeof(ioc_fm_port_pcd_cc_params_t) +
+                    sizeof(ioc_fm_port_pcd_kg_params_t) +
+                    sizeof(ioc_fm_port_pcd_plcr_params_t));
+            if (!port_pcd_params)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            port_pcd_prs_params  = (ioc_fm_port_pcd_prs_params_t *)  (port_pcd_params + 1);
+            port_pcd_cc_params   = (ioc_fm_port_pcd_cc_params_t *)   (port_pcd_prs_params + 1);
+            port_pcd_kg_params   = (ioc_fm_port_pcd_kg_params_t *)   (port_pcd_cc_params + 1);
+            port_pcd_plcr_params = (ioc_fm_port_pcd_plcr_params_t *) (port_pcd_kg_params + 1);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_port_pcd_params_t      *compat_port_pcd_params;
+                ioc_fm_port_pcd_prs_params_t         *same_port_pcd_prs_params;
+                ioc_compat_fm_port_pcd_cc_params_t   *compat_port_pcd_cc_params;
+                ioc_compat_fm_port_pcd_kg_params_t   *compat_port_pcd_kg_params;
+                ioc_compat_fm_port_pcd_plcr_params_t *compat_port_pcd_plcr_params;
+
+                compat_port_pcd_params = (ioc_compat_fm_port_pcd_params_t *) XX_Malloc(
+                                sizeof(ioc_compat_fm_port_pcd_params_t) +
+                                sizeof(ioc_fm_port_pcd_prs_params_t) +
+                                sizeof(ioc_compat_fm_port_pcd_cc_params_t) +
+                                sizeof(ioc_compat_fm_port_pcd_kg_params_t) +
+                                sizeof(ioc_compat_fm_port_pcd_plcr_params_t));
+                if (!compat_port_pcd_params)
+                {
+                    XX_Free(port_pcd_params);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                }
+
+                same_port_pcd_prs_params    = (ioc_fm_port_pcd_prs_params_t *) (compat_port_pcd_params + 1);
+                compat_port_pcd_cc_params   = (ioc_compat_fm_port_pcd_cc_params_t *) (same_port_pcd_prs_params + 1);
+                compat_port_pcd_kg_params   = (ioc_compat_fm_port_pcd_kg_params_t *) (compat_port_pcd_cc_params + 1);
+                compat_port_pcd_plcr_params = (ioc_compat_fm_port_pcd_plcr_params_t *) (compat_port_pcd_kg_params + 1);
+
+                /* Pseudo-while */
+                while (!(copy_fail = copy_from_user(compat_port_pcd_params,
+                                        (ioc_compat_fm_port_pcd_params_t *)compat_ptr(arg),
+                                        sizeof(ioc_compat_fm_port_pcd_params_t))))
+                {
+                    compat_copy_fm_port_pcd(compat_port_pcd_params, port_pcd_params, COMPAT_US_TO_K);
+
+                    /* the prs member is the same, no compat structure...memcpy only */
+                    if (port_pcd_params->p_prs_params && !copy_fail)
+                    {
+                        if(!(copy_fail = copy_from_user(same_port_pcd_prs_params,
+                                port_pcd_params->p_prs_params,
+                                sizeof(ioc_fm_port_pcd_prs_params_t))))
+                        {
+                            memcpy(port_pcd_prs_params, same_port_pcd_prs_params, sizeof(ioc_fm_port_pcd_prs_params_t));
+                            port_pcd_params->p_prs_params = port_pcd_prs_params;
+                        }
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_cc_params && !copy_fail)
+                    {
+                        if(!(copy_fail = copy_from_user(compat_port_pcd_cc_params,
+                                port_pcd_params->p_cc_params,
+                                sizeof(ioc_compat_fm_port_pcd_cc_params_t))))
+                        {
+                            port_pcd_params->p_cc_params = port_pcd_cc_params;
+                            port_pcd_params->p_cc_params->cc_tree_id = compat_get_id2ptr(compat_port_pcd_cc_params->cc_tree_id);
+                        }
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_kg_params && !copy_fail)
+                    {
+                        if(!(copy_fail = copy_from_user(compat_port_pcd_kg_params,
+                                port_pcd_params->p_kg_params,
+                                sizeof(ioc_compat_fm_port_pcd_kg_params_t))))
+                        {
+                            compat_copy_fm_port_pcd_kg(compat_port_pcd_kg_params, port_pcd_kg_params, COMPAT_US_TO_K);
+                            port_pcd_params->p_kg_params = port_pcd_kg_params;
+                        }
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_plcr_params && !copy_fail)
+                    {
+                        if(!(copy_fail = copy_from_user(compat_port_pcd_plcr_params,
+                                port_pcd_params->p_plcr_params,
+                                sizeof(ioc_compat_fm_port_pcd_plcr_params_t))))
+                        {
+                            port_pcd_params->p_plcr_params = port_pcd_plcr_params;
+                            port_pcd_params->p_plcr_params->plcr_profile_id = compat_ptr(compat_port_pcd_plcr_params->plcr_profile_id);
+                        }
+                    }
+
+                    /* always run once! */
+                    break;
+                }
+
+                XX_Free(compat_port_pcd_params);
+            }
+            else
+#endif
+            {
+                /* Pseudo-while */
+                while (!(copy_fail = copy_from_user(port_pcd_params,
+                                        (ioc_fm_port_pcd_params_t *)arg,
+                                        sizeof(ioc_fm_port_pcd_params_t))))
+                {
+                    if (port_pcd_params->p_prs_params && !copy_fail)
+                    {
+                        if (!(copy_fail = copy_from_user(port_pcd_prs_params,
+                                port_pcd_params->p_prs_params,
+                                sizeof(ioc_fm_port_pcd_prs_params_t))))
+                            port_pcd_params->p_prs_params = port_pcd_prs_params;
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_cc_params &&  !copy_fail)
+                    {
+                        if (!(copy_fail = copy_from_user(port_pcd_cc_params,
+                                port_pcd_params->p_cc_params,
+                                sizeof(ioc_fm_port_pcd_cc_params_t))))
+                            port_pcd_params->p_cc_params = port_pcd_cc_params;
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_kg_params && !copy_fail)
+                    {
+                        if (!(copy_fail = copy_from_user(port_pcd_kg_params,
+                                port_pcd_params->p_kg_params,
+                                sizeof(ioc_fm_port_pcd_kg_params_t))))
+                            port_pcd_params->p_kg_params = port_pcd_kg_params;
+                        else
+                            break;
+                    }
+
+                    if (port_pcd_params->p_plcr_params && !copy_fail)
+                    {
+                        if (!(copy_fail = copy_from_user(port_pcd_plcr_params,
+                                port_pcd_params->p_plcr_params,
+                                sizeof(ioc_fm_port_pcd_plcr_params_t))))
+                            port_pcd_params->p_plcr_params = port_pcd_plcr_params;
+                    }
+
+                    /* always run once! */
+                    break;
+                }
+            }
+
+            if (!copy_fail)
+                err = FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, (t_FmPortPcdParams*) port_pcd_params);
+            else
+                err = E_READ_FAILED;
+
+            XX_Free(port_pcd_params);
+
+            return err;
+        }
+
+        case FM_PORT_IOC_DELETE_PCD:
+            return FM_PORT_DeletePCD(p_LnxWrpFmPortDev->h_Dev);
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT:
+#endif
+        case FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME:
+        {
+            ioc_fm_pcd_kg_scheme_select_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdKgSchemeSelect) == sizeof(ioc_fm_pcd_kg_scheme_select_t));
+
+            param = (ioc_fm_pcd_kg_scheme_select_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_kg_scheme_select_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_kg_scheme_select_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_kg_scheme_select_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_kg_scheme_select_t));
+                if (!compat_param){
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+                }
+
+                if (copy_from_user(compat_param,
+                                   (ioc_compat_fm_pcd_kg_scheme_select_t *) compat_ptr(arg),
+                                   sizeof(ioc_compat_fm_pcd_kg_scheme_select_t)))
+                {
+                    XX_Free(param);
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_kg_scheme_select(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_kg_scheme_select_t *)arg,
+                                   sizeof(ioc_fm_pcd_kg_scheme_select_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_READ_FAILED, NO_MSG);
+                }
+            }
+
+            err =  FM_PORT_PcdKgModifyInitialScheme(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdKgSchemeSelect *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT:
+#endif
+        case FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+#if defined(CONFIG_COMPAT)
+            if (compat) {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PORT_PcdPlcrModifyInitialProfile(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT:
+#endif
+        case FM_PORT_IOC_PCD_KG_BIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
+
+            param = (ioc_fm_pcd_port_schemes_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            memset(&param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_port_schemes_params_t compat_param;
+
+                if (copy_from_user(&compat_param,
+                            (ioc_compat_fm_pcd_port_schemes_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_port_schemes_params_t)))
+                    break;
+
+                compat_copy_fm_pcd_kg_schemes_params(&compat_param, param, COMPAT_US_TO_K);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *) arg,
+                            sizeof(ioc_fm_pcd_port_schemes_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+
+            err = FM_PORT_PcdKgBindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT:
+#endif
+        case FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES:
+        {
+            ioc_fm_pcd_port_schemes_params_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
+
+            param = (ioc_fm_pcd_port_schemes_params_t *) XX_Malloc(
+                    sizeof(ioc_fm_pcd_port_schemes_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+            memset(&param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_port_schemes_params_t compat_param;
+
+                if (copy_from_user(&compat_param,
+                            (ioc_compat_fm_pcd_port_schemes_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_port_schemes_params_t)))
+                    break;
+
+                compat_copy_fm_pcd_kg_schemes_params(&compat_param, param, COMPAT_US_TO_K);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_port_schemes_params_t *) arg,
+                        sizeof(ioc_fm_pcd_port_schemes_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+
+            err =  FM_PORT_PcdKgUnbindSchemes(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPortSchemesParams *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET:
+        {
+            ioc_fm_pcd_prs_start_t *param;
+
+            ASSERT_COND(sizeof(t_FmPcdPrsStart) == sizeof(ioc_fm_pcd_prs_start_t));
+
+            param = (ioc_fm_pcd_prs_start_t *) XX_Malloc(sizeof(ioc_fm_pcd_prs_start_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_prs_start_t *)compat_ptr(arg),
+                                   sizeof(ioc_fm_pcd_prs_start_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_prs_start_t *)arg,
+                                   sizeof(ioc_fm_pcd_prs_start_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
+                }
+            }
+            err = FM_PORT_PcdPrsModifyStartOffset(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPrsStart *)param);
+
+            XX_Free(param);
+            return err;
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES:
+        {
+            uint16_t num;
+            if (get_user(num, (uint16_t*) arg))
+                break;
+            return FM_PORT_PcdPlcrAllocProfiles(p_LnxWrpFmPortDev->h_Dev, num);
+        }
+
+        case FM_PORT_IOC_PCD_PLCR_FREE_PROFILES:
+            return FM_PORT_PcdPlcrFreeProfiles(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_DETACH_PCD:
+            return FM_PORT_DetachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+        case FM_PORT_IOC_ATTACH_PCD:
+            return FM_PORT_AttachPCD(p_LnxWrpFmPortDev->h_Dev);
+
+#if defined(CONFIG_COMPAT)
+        case FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT:
+#endif
+        case FM_PORT_IOC_PCD_CC_MODIFY_TREE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_get_id2ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PORT_PcdCcModifyTree(p_LnxWrpFmPortDev->h_Dev, id.obj);
+        }
+
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
+    }
+
+    RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL port"));
+}
diff --git a/drivers/net/dpa/NetCommSw/src/xx/Makefile b/drivers/net/dpa/NetCommSw/src/xx/Makefile
new file mode 100644
index 0000000..96cd972
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/Makefile
@@ -0,0 +1,17 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+obj-y		+= fsl-ncsw-xx.o
+
+fsl-ncsw-xx-objs	:=   xx_linux.o udivdi3.o stdlib.o
+# ctype.o
+
+obj-y		+= integrations/
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/xx/ctype.c b/drivers/net/dpa/NetCommSw/src/xx/ctype.c
new file mode 100644
index 0000000..1fd4840
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/ctype.c
@@ -0,0 +1,67 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ctype.c
+
+ @Description   ...
+*//***************************************************************************/
+#include "stdlib_ext.h"
+#include "ctype_ext.h"
+
+
+unsigned char _ctype[] = {
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 0-7     */
+    _C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,     /* 8-15    */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 16-23   */
+    _C,_C,_C,_C,_C,_C,_C,_C,                    /* 24-31   */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,                /* 32-39   */
+    _P,_P,_P,_P,_P,_P,_P,_P,                    /* 40-47   */
+    _D,_D,_D,_D,_D,_D,_D,_D,                    /* 48-55   */
+    _D,_D,_P,_P,_P,_P,_P,_P,                    /* 56-63   */
+    _P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,  /* 64-71   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 72-79   */
+    _U,_U,_U,_U,_U,_U,_U,_U,                    /* 80-87   */
+    _U,_U,_U,_P,_P,_P,_P,_P,                    /* 88-95   */
+    _P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,  /* 96-103  */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 104-111 */
+    _L,_L,_L,_L,_L,_L,_L,_L,                    /* 112-119 */
+    _L,_L,_L,_P,_P,_P,_P,_C,                    /* 120-127 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 128-143 */
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,            /* 144-159 */
+    _S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,    /* 160-175 */
+    _P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,        /* 176-191 */
+    _U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,        /* 192-207 */
+    _U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,        /* 208-223 */
+    _L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,        /* 224-239 */
+    _L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L         /* 240-255 */
+};
diff --git a/drivers/net/dpa/NetCommSw/src/xx/integrations/Makefile b/drivers/net/dpa/NetCommSw/src/xx/integrations/Makefile
new file mode 100644
index 0000000..e961908
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/integrations/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+#
+obj-y		+= P4080/
diff --git a/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/Makefile b/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/Makefile
new file mode 100644
index 0000000..d7aebc9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/Makefile
@@ -0,0 +1,13 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NCSW)/src/xx
+
+obj-y		+= xx_integration.o
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/xx_integration.c b/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/xx_integration.c
new file mode 100644
index 0000000..aeab856
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/integrations/P4080/xx_integration.c
@@ -0,0 +1,202 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_integration.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+//#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "sys_io_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+/*Forced to introduce due to PRINT_FMT_PARAMS define*/
+uint32_t E500_GetId(void)
+{
+    return smp_processor_id();
+}
+
+void * XX_GetMemPartitionBase(int memPartitionId)
+{
+    switch(memPartitionId)
+    {
+        case(0):
+        case(e_MEM_1ST_DDR_CACHEABLE):
+            return phys_to_virt(0);
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Memory type!"));
+            return UINT_TO_PTR(ILLEGAL_BASE);
+    }
+    return UINT_TO_PTR(ILLEGAL_BASE);
+}
+
+char * GetDeviceName(int irq)
+{
+    switch (irq)
+    {
+//        case e_DUART1_INTR:
+//            return "NCSW_DUART1";
+        default:
+            return NULL;
+    }
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+int GetDeviceIrqNum(int irq)
+{
+    struct device_node  *iPar;
+    struct irq_host     *irqHost;
+    uint32_t            hwIrq;
+
+    /* Get the interrupt controller */
+    iPar = of_find_node_by_name(NULL, "mpic");
+    hwIrq = 0;
+
+    ASSERT_COND(iPar != NULL);
+    /* Get the irq host */
+    irqHost = irq_find_host(iPar);
+    of_node_put(iPar);
+
+    /* Create irq mapping */
+    return irq_create_mapping(irqHost, hwIrq);
+}
+#else
+#error "kernel not supported!!!"
+#endif    /* LINUX_VERSION_CODE */
+
+
+void * XX_PhysToVirt(physAddress_t addr)
+{
+    return UINT_TO_PTR(SYS_PhysToVirt((uint64_t)addr));
+}
+
+physAddress_t XX_VirtToPhys(void * addr)
+{
+    return (physAddress_t)SYS_VirtToPhys(PTR_TO_UINT(addr));
+}
+
+/*****************************************************************************/
+void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    void        *returnCode;
+    uint32_t    tmp;
+
+    switch(memPartitionId) {
+       case(0):
+       case(e_MEM_1ST_DDR_CACHEABLE):
+            if (alignment < 4)
+                alignment = 4;
+            tmp = (uintptr_t)(xx_Malloc((uint32_t)(size + alignment)));
+            if (tmp == 0)
+                return NULL;
+            returnCode = (void*)((uintptr_t)((tmp + alignment) & ~(alignment - 1)));
+            *(uint32_t*)((uintptr_t)returnCode - 4) = tmp;
+            break;
+        default:
+            XX_Print("XX_MallocSmart:Mem type not supported\r\n");
+            return NULL;
+    }
+    return returnCode;
+}
+
+void xx_FreeSmart(void *p)
+{
+    xx_Free((void *)((uintptr_t)(*(uint32_t *)((uintptr_t)(p)-4))));
+}
+
+
diff --git a/drivers/net/dpa/NetCommSw/src/xx/stdlib.c b/drivers/net/dpa/NetCommSw/src/xx/stdlib.c
new file mode 100644
index 0000000..321e13f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/stdlib.c
@@ -0,0 +1,264 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: stdlib.c                                       */
+/*                                                      */
+/* Description:                                         */
+/*    Standard library routines (externals)             */
+/*                                                      */
+/* Modifications:                                       */
+/* ==============                                       */
+/*                                                      */
+/*------------------------------------------------------*/
+#include "stdlib_ext.h"
+#include "stdarg_ext.h"
+#include "ctype_ext.h"
+#include "string_ext.h"
+#include "std_ext.h"
+#include "xx_ext.h"
+
+
+#ifdef MODULE
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base)
+{
+    uint32_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) &&
+           (value = (uint32_t)(isdigit(*cp) ? *cp-'0' : toupper((uint8_t)(*cp))-'A'+10)) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long)(-strtoul(cp+1,endp,base));
+    return (long)strtoul(cp,endp,base);
+}
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base)
+{
+    uint64_t result = 0,value;
+
+    if (!base) {
+        base = 10;
+        if (*cp == '0') {
+            base = 8;
+            cp++;
+            if ((*cp == 'x') && isxdigit(cp[1])) {
+                cp++;
+                base = 16;
+            }
+        }
+    }
+    while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+        ? toupper((uint8_t)(*cp)) : *cp)-'A'+10) < base) {
+        result = result*base + value;
+        cp++;
+    }
+    if (endp)
+        *endp = (char *)cp;
+    return result;
+}
+
+/**
+ * strtoll - convert a string to a int64
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base)
+{
+    if(*cp=='-')
+        return (long long)(-strtoull(cp+1,endp,base));
+    return (long long)(strtoull(cp,endp,base));
+}
+
+/**
+ * atoi - convert a string to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s)
+{
+    int i=0;
+    const char **tmp_s = &s;
+
+    while (isdigit(**tmp_s))
+        i = i*10 + *((*tmp_s)++) - '0';
+    return i;
+}
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+    const char *sc;
+
+    for (sc = s; *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+    const char *sc;
+
+    for (sc = s; count-- && *sc != '\0'; ++sc)
+        /* nothing */;
+
+    return sc - s;
+}
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+    char *tmp = dest;
+
+    while ((*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+#endif /* MODULE */
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char *___strtok;
+
+char * strtok(char * s,const char * ct)
+{
+    char *sbegin, *send;
+
+    sbegin  = s ? s : ___strtok;
+    if (!sbegin) {
+        return NULL;
+    }
+    sbegin += strspn(sbegin,ct);
+    if (*sbegin == '\0') {
+        ___strtok = NULL;
+        return( NULL );
+    }
+    send = strpbrk( sbegin, ct);
+    if (send && *send != '\0')
+        *send++ = '\0';
+    ___strtok = send;
+    return (sbegin);
+}
+
+
+#ifdef MODULE
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+    char *tmp = dest;
+
+    while (count-- && (*dest++ = *src++) != '\0')
+        /* nothing */;
+
+    return tmp;
+}
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+    return vsnprintf(buf, INT32_MAX, fmt, args);
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/src/xx/udivdi3.c b/drivers/net/dpa/NetCommSw/src/xx/udivdi3.c
new file mode 100644
index 0000000..9272d2a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/udivdi3.c
@@ -0,0 +1,132 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#include <config/modversions.h>
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/div64.h>
+
+
+#define BITS_PER_UNIT  8
+#define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)
+
+
+typedef unsigned int UQItype    __attribute__ ((mode (QI)));
+typedef          int SItype     __attribute__ ((mode (SI)));
+typedef unsigned int USItype    __attribute__ ((mode (SI)));
+typedef          int DItype     __attribute__ ((mode (DI)));
+typedef          int word_type  __attribute__ ((mode (__word__)));
+typedef unsigned int UDItype    __attribute__ ((mode (DI)));
+
+struct DIstruct {SItype low, high;};
+
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+
+/* bit divisor, dividend and result. dynamic precision */
+static __inline__ uint64_t _div64_64(uint64_t dividend, uint64_t divisor)
+{
+    uint32_t d = divisor;
+
+    if (divisor > 0xffffffffULL)
+    {
+        unsigned int shift = fls(divisor >> 32);
+
+        d = divisor >> shift;
+        dividend >>= shift;
+    }
+
+    /* avoid 64 bit division if possible */
+    if (dividend >> 32)
+        do_div(dividend, d);
+    else
+        dividend = (uint32_t) dividend / d;
+
+    return dividend;
+}
+
+UDItype __udivdi3 (UDItype n, UDItype d)
+{
+  return _div64_64(n, d);
+}
+
+DItype __divdi3 (DItype n, DItype d)
+{
+  DItype sign = 1;
+  if (n<0)
+  {
+    sign *= -1;
+    n *= -1;
+  }
+  if (d<0)
+  {
+    sign *= -1;
+    d *= -1;
+  }
+  return sign*_div64_64((UDItype)n, (UDItype)d);
+}
+
+UDItype __umoddi3 (UDItype n, UDItype d)
+{
+  return n-(_div64_64(n, d)*d);
+}
+
+#ifdef MODULE
+word_type __ucmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((USItype) au.s.high < (USItype) bu.s.high)
+    return 0;
+  else if ((USItype) au.s.high > (USItype) bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+#endif /* MODULE */
diff --git a/drivers/net/dpa/NetCommSw/src/xx/xx.h b/drivers/net/dpa/NetCommSw/src/xx/xx.h
new file mode 100644
index 0000000..5687bfa
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/xx.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __XX_H
+#define __XX_H
+
+#include "xx_ext.h"
+
+void * xx_Malloc(uint32_t n);
+void xx_Free(void *p);
+
+void *xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t align);
+void xx_FreeSmart(void *p);
+
+char  * GetDeviceName(int irq);
+int     GetDeviceIrqNum(int irq);
+
+
+#endif /* __XX_H */
diff --git a/drivers/net/dpa/NetCommSw/src/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/src/xx/xx_linux.c
new file mode 100644
index 0000000..5f51336
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/src/xx/xx_linux.c
@@ -0,0 +1,929 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_linux.c
+
+ @Description   XX routines implementation for Linux.
+*//***************************************************************************/
+#include <linux/version.h>
+
+#if defined(CONFIG_MODVERSIONS) && !defined(MODVERSIONS)
+#define MODVERSIONS
+#endif
+#ifdef MODVERSIONS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/modversions.h>
+#else
+#include <config/modversions.h>
+#endif    /* LINUX_VERSION_CODE */
+#endif /* MODVERSIONS */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif    /* LINUX_VERSION_CODE */
+
+#ifdef BIGPHYSAREA_ENABLE
+#include <linux/bigphysarea.h>
+#endif /* BIGPHYSAREA_ENABLE */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+#include <asm/of_device.h>
+#include <sysdev/fsl_soc.h>
+#endif    /* LINUX_VERSION_CODE */
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+#include <asm/string.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#include "error_ext.h"
+#include "std_ext.h"
+//#include "mem_ext.h"
+#include "list_ext.h"
+#include "mm_ext.h"
+#include "platform_ext.h"
+
+#include "xx.h"
+
+
+#define __ERR_MODULE__      MODULE_UNKNOWN
+
+#ifdef BIGPHYSAREA_ENABLE
+#define MAX_ALLOCATION_SIZE     128 * 1024 /* Maximum size allocated with kmalloc is 128K */
+
+
+/* TODO: large allocations => use big phys area */
+/******************************************************************************
+ * routine:     get_nr_pages
+ *
+ * description:
+ *     calculates the number of memory pages for a given size (in bytes)
+ *
+ * arguments:
+ *     size       - the number of bytes
+ *
+ * return code:
+ *     The number of pages
+ *
+ *****************************************************************************/
+static __inline__ uint32_t get_nr_pages (uint32_t size)
+{
+    return (uint32_t)((size >> PAGE_SHIFT) + (size & PAGE_SHIFT ? 1 : 0));
+}
+
+static bool in_big_phys_area (uint32_t addr)
+{
+    uint32_t base, size;
+
+    bigphysarea_get_details (&base, &size);
+    return ((addr >= base) && (addr < base + size));
+}
+#endif /* BIGPHYSAREA_ENABLE */
+
+void * xx_Malloc(uint32_t n)
+{
+    void        *a;
+    uint32_t    flags;
+
+    flags = XX_DisableAllIntr();
+#ifdef BIGPHYSAREA_ENABLE
+    if (n >= MAX_ALLOCATION_SIZE)
+        a = (void*)bigphysarea_alloc_pages(get_nr_pages(n), 0, GFP_ATOMIC);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    a = (void *)kmalloc((uint32_t)n, GFP_ATOMIC);
+    if (!a)
+        XX_Print("No memory for XX_Malloc\n");
+    XX_RestoreAllIntr(flags);
+
+    return a;
+}
+
+void xx_Free(void *p)
+{
+#ifdef BIGPHYSAREA_ENABLE
+    if (in_big_phys_area ((uint32_t)p))
+        bigphysarea_free_pages(p);
+    else
+#endif /* BIGPHYSAREA_ENABLE */
+    kfree(p);
+}
+
+void XX_Exit(int status)
+{
+    XX_Print("NetCommSw driver can't go on!!!\r\n");
+    BUG();
+}
+
+#define BUF_SIZE    512
+void XX_Print(char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+void XX_Fprint(void *file, char *str, ...)
+{
+    va_list args;
+#ifdef CONFIG_SMP
+    char buf[BUF_SIZE];
+#endif /* CONFIG_SMP */
+
+    va_start(args, str);
+#ifdef CONFIG_SMP
+    if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
+        printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
+#else
+    vprintk(str, args);
+#endif /* CONFIG_SMP */
+    va_end(args);
+}
+
+#ifdef DEBUG_XX_MALLOC
+typedef void (*t_ffn)(void *);
+typedef struct {
+    t_ffn       f_free;
+    void        *mem;
+    char        *fname;
+    int         fline;
+    uint32_t    size;
+    t_List      node;
+} t_MemDebug;
+#define MEMDBG_OBJECT(p_List) LIST_OBJECT(p_List, t_MemDebug, node)
+
+LIST(memDbgLst);
+
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)xx_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_Malloc(size);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_Free;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line)
+{
+    void       *mem;
+    t_MemDebug *p_MemDbg;
+
+    p_MemDbg = (t_MemDebug *)XX_Malloc(sizeof(t_MemDebug));
+    if (p_MemDbg == NULL)
+        return NULL;
+
+    mem = xx_MallocSmart((uint32_t)size, memPartitionId, align);
+    if (mem == NULL)
+    {
+        XX_Free(p_MemDbg);
+        return NULL;
+    }
+
+    INIT_LIST(&p_MemDbg->node);
+    p_MemDbg->f_free = xx_FreeSmart;
+    p_MemDbg->mem    = mem;
+    p_MemDbg->fname  = fname;
+    p_MemDbg->fline  = line;
+    p_MemDbg->size   = size+sizeof(t_MemDebug);
+    LIST_AddToTail(&p_MemDbg->node, &memDbgLst);
+
+    return mem;
+}
+
+static void debug_free(void *mem)
+{
+    t_List      *p_MemDbgLh = NULL;
+    t_MemDebug  *p_MemDbg;
+    bool        found = FALSE;
+
+    if (LIST_IsEmpty(&memDbgLst))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_FREE, ("Unbalanced free (0x%08x)", mem));
+        return;
+    }
+
+    LIST_FOR_EACH(p_MemDbgLh, &memDbgLst)
+    {
+        p_MemDbg = MEMDBG_OBJECT(p_MemDbgLh);
+        if (p_MemDbg->mem == mem)
+        {
+            found = TRUE;
+            break;
+        }
+    }
+
+    if (!found)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND,
+                     ("Attempt to free unallocated address (0x%08x)",mem));
+        dump_stack();
+        return;
+    }
+
+    LIST_Del(p_MemDbgLh);
+    p_MemDbg->f_free(mem);
+    p_MemDbg->f_free(p_MemDbg);
+}
+
+void XX_FreeSmart(void *p)
+{
+    debug_free(p);
+}
+
+
+void XX_Free(void *p)
+{
+    debug_free(p);
+}
+
+#else /* not DEBUG_XX_MALLOC */
+void * XX_Malloc(uint32_t size)
+{
+    return xx_Malloc(size);
+}
+
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    return xx_MallocSmart(size,memPartitionId, alignment);
+}
+
+void XX_FreeSmart(void *p)
+{
+    xx_FreeSmart(p);
+}
+
+
+void XX_Free(void *p)
+{
+    xx_Free(p);
+}
+#endif /* not DEBUG_XX_MALLOC */
+
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg)
+{
+    e_Event eventCode = (e_Event)event;
+
+    UNUSED(eventCode);
+    UNUSED(appId);
+    UNUSED(flags);
+    UNUSED(msg);
+}
+#endif /* (defined(REPORT_EVENTS) && ... */
+
+
+uint32_t XX_DisableAllIntr(void)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    return (uint32_t)flags;
+}
+
+void XX_RestoreAllIntr(uint32_t flags)
+{
+    local_irq_restore((unsigned long)flags);
+}
+
+t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
+{
+    UNUSED(qid);
+    UNUSED(appId);
+    UNUSED(flags);
+
+    return f(id);
+}
+
+int XX_IsICacheEnable(void)
+{
+    return TRUE;
+}
+
+int XX_IsDCacheEnable(void)
+{
+    return TRUE;
+}
+
+
+typedef struct {
+    t_Isr       *f_Isr;
+    t_Handle    handle;
+} t_InterruptHandler;
+
+
+t_Handle interruptHandlers[0x00010000];
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static int LinuxInterruptHandler(int irq, void * dev_id, struct pt_regs * regs)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#else
+static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
+{
+    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
+    p_IntrHndl->f_Isr(p_IntrHndl->handle);
+    return IRQ_HANDLED;
+}
+#endif    /* LINUX_VERSION_CODE */
+
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
+{
+    const char *device;
+    t_InterruptHandler *p_IntrHndl;
+
+    device = GetDeviceName(irq);
+    if (device == NULL)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
+
+    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
+    if (p_IntrHndl == NULL)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    p_IntrHndl->f_Isr = f_Isr;
+    p_IntrHndl->handle = handle;
+    interruptHandlers[irq] = p_IntrHndl;
+
+    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
+        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
+    disable_irq(GetDeviceIrqNum(irq));
+
+    return E_OK;
+}
+
+t_Error XX_FreeIntr(int irq)
+{
+    t_InterruptHandler *p_IntrHndl = interruptHandlers[irq];
+    free_irq(GetDeviceIrqNum(irq), p_IntrHndl);
+    XX_Free(p_IntrHndl);
+    interruptHandlers[irq] = 0;
+    return E_OK;
+}
+
+t_Error XX_EnableIntr(int irq)
+{
+    enable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+t_Error XX_DisableIntr(int irq)
+{
+    disable_irq(GetDeviceIrqNum(irq));
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                       Tasklet Service Routines                            */
+/*****************************************************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+typedef struct
+{
+    t_Handle            h_Data;
+    void                (*f_Callback) (void *);
+    struct delayed_work dwork;
+} t_Tasklet;
+
+static void GenericTaskletCallback(struct work_struct *p_Work)
+{
+    t_Tasklet *p_Task = container_of(p_Work, t_Tasklet, dwork.work);
+
+    p_Task->f_Callback(p_Task->h_Data);
+}
+#endif    /* LINUX_VERSION_CODE */
+
+
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    struct tq_struct *p_Task;
+    p_Task = (struct tq_struct *)XX_Malloc(sizeof(struct tq_struct));
+    INIT_TQUEUE(p_Task, routine, data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    struct work_struct *p_Task;
+    p_Task = (struct work_struct *)XX_Malloc(sizeof(struct work_struct));
+    INIT_WORK(p_Task, routine, data);
+#else
+    t_Tasklet *p_Task = (t_Tasklet *)XX_Malloc(sizeof(t_Tasklet));
+    p_Task->h_Data = data;
+    p_Task->f_Callback = routine;
+    INIT_DELAYED_WORK(&p_Task->dwork, GenericTaskletCallback);
+#endif    /* LINUX_VERSION_CODE */
+
+    return (t_TaskletHandle)p_Task;
+}
+
+
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet)
+{
+    if (h_Tasklet)
+        XX_Free(h_Tasklet);
+}
+
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate)
+{
+    int ans;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    UNUSED(immediate);
+    ans = queue_task(h_Tasklet, &tq_immediate);
+    mark_bh(IMMEDIATE_BH);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    if (immediate)
+        ans = schedule_work(h_Tasklet);
+    else
+        ans = schedule_delayed_work(h_Tasklet, 1);
+#else
+    if (immediate)
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, 0);
+    else
+        ans = schedule_delayed_work(&((t_Tasklet *)h_Tasklet)->dwork, HZ);
+#endif /* LINUX_VERSION_CODE */
+
+    return ans;
+}
+
+void XX_FlushScheduledTasks(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    flush_scheduled_tasks();
+#else
+    flush_scheduled_work();
+#endif    /* LINUX_VERSION_CODE */
+}
+
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (int)(((struct tq_struct *)h_Tasklet)->sync);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (int)(((struct work_struct *)h_Tasklet)->pending);
+#else
+    return (int)delayed_work_pending(&((t_Tasklet *)h_Tasklet)->dwork);
+#endif    /* LINUX_VERSION_CODE */
+}
+
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    ((struct tq_struct *)h_Tasklet)->data = data;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    ((struct work_struct *)h_Tasklet)->data = data;
+#else
+    ((t_Tasklet *)h_Tasklet)->h_Data = data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+    return (t_Handle)(((struct tq_struct *)h_Tasklet)->data);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+    return (t_Handle)(((struct work_struct *)h_Tasklet)->data);
+#else
+    return ((t_Tasklet *)h_Tasklet)->h_Data;
+#endif    /* LINUX_VERSION_CODE */
+}
+
+
+#if 0
+/*****************************************************************************/
+/*                       Semaphore Service Routines                          */
+/*****************************************************************************/
+t_SemaphoreHandle XX_InitSemaphore(int val)
+{
+    struct semaphore *p_Semaphore = (struct semaphore *)XX_Malloc(sizeof(struct semaphore));
+    if (p_Semaphore)
+        sema_init (p_Semaphore, val);
+    return (t_SemaphoreHandle)p_Semaphore;
+}
+
+void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore)
+{
+    if (h_Semaphore)
+        XX_Free(h_Semaphore);
+}
+
+t_MutexHandle XX_InitMutex(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(1);
+}
+
+
+t_MutexHandle XX_InitMutexLocked(void)
+{
+    return (t_MutexHandle)XX_InitSemaphore(0);
+}
+
+void XX_FreeMutex(t_MutexHandle h_Mutex)
+{
+    XX_FreeSemaphore(h_Mutex);
+}
+
+void XX_Lock(t_MutexHandle h_Mutex)
+{
+    down((struct semaphore *)h_Mutex);
+}
+
+void XX_Unlock(t_MutexHandle h_Mutex)
+{
+    up((struct semaphore *)h_Mutex);
+}
+
+#endif /* 0 */
+/*****************************************************************************/
+/*                         Spinlock Service Routines                         */
+/*****************************************************************************/
+
+t_Handle XX_InitSpinlock(void)
+{
+    spinlock_t *p_Spinlock = (spinlock_t *)XX_Malloc(sizeof(spinlock_t));
+    if (!p_Spinlock)
+        return NULL;
+
+    spin_lock_init(p_Spinlock);
+
+    return (t_Handle)p_Spinlock;
+}
+
+void XX_FreeSpinlock(t_Handle h_Spinlock)
+{
+    if (h_Spinlock)
+        XX_Free(h_Spinlock);
+}
+
+void XX_LockSpinlock(t_Handle h_Spinlock)
+{
+    spin_lock((spinlock_t *)h_Spinlock);
+}
+
+void XX_UnlockSpinlock(t_Handle h_Spinlock)
+{
+    spin_unlock((spinlock_t *)h_Spinlock);
+}
+
+uint32_t XX_LockIntrSpinlock(t_Handle h_Spinlock)
+{
+    unsigned long intrFlags;
+    spin_lock_irqsave((spinlock_t *)h_Spinlock, intrFlags);
+    return intrFlags;
+}
+
+void XX_UnlockIntrSpinlock(t_Handle h_Spinlock, uint32_t intrFlags)
+{
+     spin_unlock_irqrestore((spinlock_t *)h_Spinlock, (unsigned long)intrFlags);
+}
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+/* The time now is in mili sec. resolution */
+uint32_t XX_CurrentTime(void)
+{
+    return (jiffies*1000)/HZ;
+}
+
+
+t_Handle XX_CreateTimer(void)
+{
+    struct timer_list *p_Timer = (struct timer_list *)XX_Malloc(sizeof(struct timer_list));
+    if (p_Timer)
+    {
+        memset(p_Timer, 0, sizeof(struct timer_list));
+        init_timer(p_Timer);
+    }
+    return (t_Handle)p_Timer;
+}
+
+void XX_FreeTimer(t_Handle h_Timer)
+{
+    if (h_Timer)
+        XX_Free(h_Timer);
+}
+
+void XX_StartTimer(t_Handle h_Timer,
+                   uint32_t msecs,
+                   bool     periodic,
+                   void     (*f_TimerExpired)(t_Handle),
+                   t_Handle h_Arg)
+{
+    int                 tmp_jiffies = (msecs*HZ)/1000;
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    SANITY_CHECK_RETURN((periodic == FALSE), E_NOT_SUPPORTED);
+
+    p_Timer->function = (void (*)(unsigned long))f_TimerExpired;
+    p_Timer->data = (unsigned long)h_Arg;
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    p_Timer->expires = (jiffies + tmp_jiffies);
+
+    add_timer((struct timer_list *)h_Timer);
+}
+
+void XX_SetTimerData(t_Handle h_Timer, t_Handle data)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    p_Timer->data = (unsigned long)data;
+}
+
+t_Handle XX_GetTimerData(t_Handle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (t_Handle)p_Timer->data;
+}
+
+uint32_t   XX_GetExpirationTime(t_Handle h_Timer)
+{
+    struct timer_list   *p_Timer = (struct timer_list *)h_Timer;
+
+    return (uint32_t)p_Timer->expires;
+}
+
+void XX_StopTimer(t_Handle h_Timer)
+{
+    del_timer((struct timer_list *)h_Timer);
+}
+
+void XX_ModTimer(t_Handle h_Timer, uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    mod_timer((struct timer_list *)h_Timer, jiffies + tmp_jiffies);
+}
+
+int XX_TimerIsActive(t_Handle h_Timer)
+{
+  return timer_pending((struct timer_list *)h_Timer);
+}
+
+uint32_t XX_Sleep(uint32_t msecs)
+{
+    int tmp_jiffies = (msecs*HZ)/1000;
+
+    if ((msecs*HZ)%1000)
+        tmp_jiffies++;
+    return schedule_timeout(tmp_jiffies);
+}
+
+/*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
+void XX_UDelay(uint32_t usecs)
+{
+    udelay(usecs);
+}
+
+/* TODO: verify that these are correct */
+#define MSG_BODY_SIZE       512
+typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg);
+
+typedef struct {
+    char            *p_Addr;
+    t_MsgHandler    *f_MsgHandlerCB;
+    t_Handle        h_Mod;
+    t_List          node;
+} t_MsgHndlr;
+#define MSG_HNDLR_OBJECT(ptr)  LIST_OBJECT(ptr, t_MsgHndlr, node)
+
+LIST(msgHndlrList);
+
+static void EnqueueMsgHndlr(t_MsgHndlr *p_MsgHndlr)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_MsgHndlr->node, &msgHndlrList);
+    XX_RestoreAllIntr(intFlags);
+}
+/* TODO: add this for multi-platform support
+static t_MsgHndlr * DequeueMsgHndlr(void)
+{
+    t_MsgHndlr *p_MsgHndlr = NULL;
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(&msgHndlrList))
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(msgHndlrList.p_Next);
+        LIST_DelAndInit(&p_MsgHndlr->node);
+    }
+    XX_RestoreAllIntr(intFlags);
+
+    return p_MsgHndlr;
+}
+*/
+static t_MsgHndlr * FindMsgHndlr(char *p_Addr)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, &msgHndlrList)
+    {
+        p_MsgHndlr = MSG_HNDLR_OBJECT(p_Pos);
+        if (strstr(p_MsgHndlr->p_Addr, p_Addr))
+            return p_MsgHndlr;
+    }
+
+    return NULL;
+}
+
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod)
+{
+    t_MsgHndlr  *p_MsgHndlr;
+    uint32_t    len;
+
+    p_MsgHndlr = (t_MsgHndlr*)XX_Malloc(sizeof(t_MsgHndlr));
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("message handler object!!!"));
+    memset(p_MsgHndlr, 0, sizeof(t_MsgHndlr));
+
+    len = strlen(p_Addr);
+    p_MsgHndlr->p_Addr = (char*)XX_Malloc(len+1);
+    strncpy(p_MsgHndlr->p_Addr,p_Addr, (uint32_t)(len+1));
+
+    p_MsgHndlr->f_MsgHandlerCB = f_MsgHandlerCB;
+    p_MsgHndlr->h_Mod = h_Mod;
+    INIT_LIST(&p_MsgHndlr->node);
+    EnqueueMsgHndlr(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_UnregisterMessageHandler (char *p_Addr)
+{
+    t_MsgHndlr *p_MsgHndlr = FindMsgHndlr(p_Addr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    LIST_Del(&p_MsgHndlr->node);
+    XX_Free(p_MsgHndlr->p_Addr);
+    XX_Free(p_MsgHndlr);
+
+    return E_OK;
+}
+
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg)
+{
+    t_Error     ans;
+    t_MsgHndlr  *p_MsgHndlr = FindMsgHndlr(p_DestAddr);
+    if (!p_MsgHndlr)
+        RETURN_ERROR(MINOR, E_NO_DEVICE, ("message handler not found in list!!!"));
+
+    ans = p_MsgHndlr->f_MsgHandlerCB(p_MsgHndlr->h_Mod, msgId, msgBody);
+
+    if (f_CompletionCB)
+        f_CompletionCB(h_CBArg, msgBody);
+
+    return ans;
+}
+
+t_Error XX_IpcRegisterMsgHandler(char                   addr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                                 t_IpcMsgHandler        *f_MsgHandler,
+                                 t_Handle               h_Module,
+                                 uint32_t               replyLength)
+{
+    UNUSED(addr);UNUSED(f_MsgHandler);UNUSED(h_Module);UNUSED(replyLength);
+    return E_OK;
+}
+
+t_Error XX_IpcUnregisterMsgHandler(char addr[XX_IPC_MAX_ADDR_NAME_LENGTH])
+{
+    UNUSED(addr);
+    return E_OK;
+}
+
+
+t_Error XX_IpcSendMessage(t_Handle           h_Session,
+                          uint8_t            *p_Msg,
+                          uint32_t           msgLength,
+                          uint8_t            *p_Reply,
+                          uint32_t           *p_ReplyLength,
+                          t_IpcMsgCompletion *f_Completion,
+                          t_Handle           h_Arg)
+{
+    UNUSED(h_Session); UNUSED(p_Msg); UNUSED(msgLength); UNUSED(p_Reply);
+    UNUSED(p_ReplyLength); UNUSED(f_Completion); UNUSED(h_Arg);
+    return E_OK;
+}
+
+t_Handle XX_IpcInitSession(char destAddr[XX_IPC_MAX_ADDR_NAME_LENGTH],
+                           char srcAddr[XX_IPC_MAX_ADDR_NAME_LENGTH])
+{
+    UNUSED(destAddr); UNUSED(srcAddr);
+    return E_OK;
+}
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index 5853d65..3213143 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -15,6 +15,7 @@ header-y += netfilter_bridge/
 header-y += netfilter_ipv4/
 header-y += netfilter_ipv6/
 header-y += usb/
+header-y += fmd/
 
 header-y += affs_hardblocks.h
 header-y += aio_abi.h
diff --git a/include/linux/fmd/Kbuild b/include/linux/fmd/Kbuild
new file mode 100644
index 0000000..56a2040
--- /dev/null
+++ b/include/linux/fmd/Kbuild
@@ -0,0 +1,5 @@
+header-y += integrations/
+header-y += Peripherals/
+
+header-y += ioctls.h
+header-y += net_ioctls.h
diff --git a/include/linux/fmd/Peripherals/Kbuild b/include/linux/fmd/Peripherals/Kbuild
new file mode 100644
index 0000000..43883ef
--- /dev/null
+++ b/include/linux/fmd/Peripherals/Kbuild
@@ -0,0 +1,4 @@
+header-y += fm_ioctls.h
+header-y += fm_port_ioctls.h
+header-y += fm_pcd_ioctls.h
+header-y += fm_test_ioctls.h
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
new file mode 100644
index 0000000..5686917
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -0,0 +1,324 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_IOCTLS_H
+#define __FM_IOCTLS_H
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    FM IOCTL device ('/dev') definitions
+*//***************************************************************************/
+#define DEV_FM_NAME                 "fm" /**< Name of the FM chardev */
+
+#define DEV_FM_MINOR_BASE           0
+#define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)                                 /*/dev/fmx-pcd */
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)                             /*/dev/fmx-port-ohy */
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + FM_MAX_NUM_OF_OH_PORTS)   /*/dev/fmx-port-rxy */
+#define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_RX_PORTS)   /*/dev/fmx-port-txy */
+#define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + FM_MAX_NUM_OF_TX_PORTS)
+
+
+#define FM_IOC_NUM(n)       n
+#define FM_PCD_IOC_NUM(n)   (n+20)
+#define FM_PORT_IOC_NUM(n)  (n+50)
+/* @} */
+
+#define IOC_FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typedef for defining Frame Descriptor errors */
+
+#define IOC_FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+#define IOC_FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define IOC_FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#ifdef FM_CAPWAP_SUPPORT
+#define IOC_FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non FMan error; probably come from SEC chained to FM */
+#endif /* FM_CAPWAP_SUPPORT */
+#define IOC_FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                         Sequence error, PHY error control character detected. */
+#define IOC_FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define IOC_FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define IOC_FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define IOC_FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define IOC_FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< */
+#define IOC_FM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< */
+#define IOC_FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define IOC_FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define IOC_FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define IOC_FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define IOC_FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED            0x00000008  /**< Frame parsed beyind 256 first bytes */
+#define IOC_FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+                (must match enum e_FmPortType defined in fm_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_port_type {
+    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_DUMMY
+} ioc_fm_port_type;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "single-tone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum ioc_fm_exceptions {
+    e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_IOC_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
+    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} ioc_fm_exceptions;
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+ *//***************************************************************************/
+#define IOC_FM_MAX_NUM_OF_VALID_PORTS (FM_MAX_NUM_OF_OH_PORTS + \
+        FM_MAX_NUM_OF_1G_RX_PORTS +  \
+        FM_MAX_NUM_OF_10G_RX_PORTS + \
+        FM_MAX_NUM_OF_1G_TX_PORTS +  \
+        FM_MAX_NUM_OF_10G_TX_PORTS)
+/* @} */
+
+/**************************************************************************//**
+ @Description   Structure for Port bandwidth requirement. Port is identified
+                by type and relative id.
+                (must be identical to t_FmPortBandwidth defined in fm_ext.h --
+                great piece of SW design!!!)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_t {
+    ioc_fm_port_type    type;           /**< FM port type */
+    uint8_t             relativePortId; /**< Type relative port id */
+    uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
+} ioc_fm_port_bandwidth_t;
+
+/**************************************************************************//**
+ @Description   A Structure containing an array of Port bandwidth requirements.
+                The user should state the ports requiring bandwidth in terms of
+                percentage - i.e. all port's bandwidths in the array must add
+                up to 100.
+                (must be identical to t_FmPortsBandwidthParams defined in
+                fm_ext.h -- great piece of SW design!!!)
+*//***************************************************************************/
+typedef struct ioc_fm_port_bandwidth_params {
+    uint8_t                     numOfPorts;
+                                /**< num of ports listed in the array below */
+/*TODO:Andy64 BUG*/
+    ioc_fm_port_bandwidth_t     portsBandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
+                                /**< for each port, it's bandwidth (all port's
+                                  bandwidths must add up to 100.*/
+} ioc_fm_port_bandwidth_params;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum ioc_fm_counters {
+    e_IOC_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_IOC_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} ioc_fm_counters;
+
+typedef struct ioc_fm_obj_t {
+    void            *obj;
+} ioc_fm_obj_t;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct ioc_fm_revision_info_t {
+    uint8_t         major;               /**< Major revision */
+    uint8_t         minor;               /**< Minor revision */
+} ioc_fm_revision_info_t;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_counters_params_t {
+    ioc_fm_counters cnt;                /**< The requested counter */
+    uint32_t        val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_counters_params_t;
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_PORTS_BANDWIDTH
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     ioc_fm_port_bandwidth_params    Port bandwidth percentages,
+ their sum must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_PORTS_BANDWIDTH                             _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(2), ioc_fm_port_bandwidth_params)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_REVISION
+
+ @Description   Returns the FM revision
+
+ @Param[out]    ioc_fm_revision_info_t  A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_GET_REVISION                                    _IOR(FM_IOC_TYPE_BASE, FM_IOC_NUM(3), ioc_fm_revision_info_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in,out] ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_IOC_GET_COUNTER                                    _IOWR(FM_IOC_TYPE_BASE, FM_IOC_NUM(4), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_SET_COUNTER                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(5), ioc_fm_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_exceptions   An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)
+
+/** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp */
+
+
+#endif /* __FM_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
new file mode 100644
index 0000000..ef50022
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -0,0 +1,1534 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd_ioctls.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_IOCTLS_H
+#define __FM_PCD_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
+
+#define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+
+#ifdef CONFIG_FMAN_P1023
+#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    16                  /**< Total number of KG schemes */
+#else
+#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
+#endif
+#define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                            /**< Maximum number of netenv distinction units */
+#ifdef CONFIG_FMAN_P1023
+#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   7                   /**< Maximum number of netenv distinction units options */
+#else
+#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
+#endif
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                                 For reason of HW implemetation, in most
+                                                                                 cases less than this will be allowed. The
+                                                                                 driver will return error in initialization
+                                                                                 time if resource is overused. */
+#ifdef CONFIG_FMAN_P1023
+#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 128                 /**< Number of classification plan entries. */
+#else
+#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
+#endif
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_counters {
+    e_IOC_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_IOC_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} ioc_fm_pcd_counters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+                (must match enum e_FmPcdExceptions defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_exceptions {
+    e_IOC_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_IOC_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_IOC_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_IOC_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                       /**< Parser single ECC */
+} ioc_fm_pcd_exceptions;
+
+/**************************************************************************//**
+ @Description   structure for FM counters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_counters_params_t {
+    ioc_fm_pcd_counters cnt;                /**< The requested counter */
+    uint32_t            val;                /**< The requested value to get/set from/into the counter */
+} ioc_fm_pcd_counters_params_t;
+
+/**************************************************************************//**
+ @Description   structure for FM exception definitios
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_exception_params_t {
+    ioc_fm_pcd_exceptions exception;        /**< The requested exception */
+    bool                  enable;           /**< TRUE to enable interrupt, FALSE to mask it. */
+} ioc_fm_pcd_exception_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+                (must be identical to struct t_FmPcdPrsLabelParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_label_params_t {
+    uint32_t                instruction_offset;             /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    ioc_net_header_type     hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 index_per_hdr;                  /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} ioc_fm_pcd_prs_label_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+                (must be identical to struct t_FmPcdPrsSwParams defined in fm_pcd_ext.h)
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_sw_params_t {
+    bool                            override;           /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                        size;               /**< SW parser code size */
+    uint16_t                        base;               /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                         *p_code;            /**< SW parser code */
+    uint32_t                        sw_prs_data_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                         num_of_labels;      /**< Number of labels for SW parser. */
+    ioc_fm_pcd_prs_label_params_t   labels_table[IOC_FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} ioc_fm_pcd_prs_sw_params_t;
+
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
+    uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
+    uint32_t                        value;                  /**< The requested default value */
+} ioc_fm_pcd_kg_dflt_value_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_ENABLE
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_ENABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DISABLE
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_DISABLE  _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(2))
+
+ /**************************************************************************//**
+ @Function      FM_PCD_IOC_PRS_LOAD_SW
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases it is recommended in order to save resources.
+                The driver automatically saves 8 classification plans for
+                ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be called.
+
+ @Param[in]     ioc_fm_pcd_prs_sw_params_t  A pointer to the image of the software parser code.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PRS_LOAD_SW_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_compat_fm_pcd_prs_sw_params_t)
+#endif
+#define FM_PCD_IOC_PRS_LOAD_SW  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(3), ioc_fm_pcd_prs_sw_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_DFLT_VALUE
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_DFLT_VALUE  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(6), ioc_fm_pcd_kg_dflt_value_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finishing point.
+
+ @Param[in]     uint8_t   payload-offset; the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+#define FM_PCD_IOC_KG_SET_ADDITIONAL_DATA_AFTER_PARSING  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(7), uint8_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_EXCEPTION
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     ioc_fm_pcd_exception_params_t     The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_EXCEPTION _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(8), ioc_fm_pcd_exception_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_GET_COUNTER
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in,out] ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+#define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_COUNTER
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     ioc_fm_pcd_counters_params_t The requested counter parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_FORCE_INTR
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     ioc_fm_pcd_exceptions    An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#define FM_PCD_IOC_FORCE_INTR _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(11), ioc_fm_pcd_exceptions)
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define IOC_FM_PCD_MAX_NUM_OF_CC_NODES          255
+#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES            8
+#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS          16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS            4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS              256
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY               56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP  16
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t            ioc_protocol_opt_t;      /**< A general type to define a protocol option. */
+
+typedef ioc_protocol_opt_t  ioc_eth_protocol_opt_t;  /**< Ethernet protocol options. */
+#define IOC_ETH_BROADCAST               0x80000000   /**< Ethernet Broadcast. */
+#define IOC_ETH_MULTICAST               0x40000000   /**< Ethernet Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_vlan_protocol_opt_t; /**< Vlan protocol options. */
+#define IOC_VLAN_STACKED                0x20000000   /**< Vlan Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_mpls_protocol_opt_t; /**< MPLS protocol options. */
+#define IOC_MPLS_STACKED                0x10000000   /**< MPLS Stacked. */
+
+typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options. */
+#define IOC_IPV4_BROADCAST_1            0x08000000   /**< IPv4 Broadcast. */
+#define IOC_IPV4_MULTICAST_1            0x04000000   /**< IPv4 Multicast. */
+#define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
+#define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
+#define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
+#define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
+#define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_engine {
+    e_IOC_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_IOC_FM_PCD_DONE,          /**< No PCD Engine indicated */
+    e_IOC_FM_PCD_KG,            /**< Keygen indicated */
+    e_IOC_FM_PCD_CC,            /**< Coarse classification indicated */
+    e_IOC_FM_PCD_PLCR,          /**< Policer indicated */
+    e_IOC_FM_PCD_PRS            /**< Parser indicated */
+} ioc_fm_pcd_engine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_by_hdr_type {
+    e_IOC_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_IOC_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_IOC_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} ioc_fm_pcd_extract_by_hdr_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_from {
+    e_IOC_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< KG & CC: Extract from beginning of frame */
+    e_IOC_FM_PCD_EXTRACT_FROM_DFLT_VALUE,           /**< KG only: Extract from a default value */
+    e_IOC_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE,    /**< KG only: Extract from the point where parsing had finished */
+    e_IOC_FM_PCD_EXTRACT_FROM_KEY,                  /**< CC only: Field where saved KEY */
+    e_IOC_FM_PCD_EXTRACT_FROM_HASH,                 /**< CC only: Field where saved HASH */
+    e_IOC_FM_PCD_EXTRACT_FROM_PARSE_RESULT,         /**< KG & CC: Extract from the parser result */
+    e_IOC_FM_PCD_EXTRACT_FROM_ENQ_FQID,             /**< KG & CC: Extract from enqueue FQID */
+    e_IOC_FM_PCD_EXTRACT_FROM_FLOW_ID               /**< CC only: Field where saved Dequeue FQID */
+} ioc_fm_pcd_extract_from;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_extract_type {
+    e_IOC_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_IOC_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} ioc_fm_pcd_extract_type;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_extract_dflt_select {
+    e_IOC_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_IOC_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_IOC_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_IOC_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} ioc_fm_pcd_kg_extract_dflt_select;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_kg_known_fields_dflt_types {
+    e_IOC_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_IOC_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_IOC_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_IOC_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_IOC_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_IOC_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_IOC_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_IOC_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_IOC_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_IOC_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_IOC_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_IOC_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_IOC_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                                 any data extraction that is not the full
+                                                 field described above  */
+    e_IOC_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                                 any data extraction without validation */
+    e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                                 extraction from parser result or
+                                                 direct use of default value  */
+} ioc_fm_pcd_kg_known_fields_dflt_types;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_hdr_index {
+    e_IOC_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                     to specify regular IP (not tunneled). */
+    e_IOC_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_IOC_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_IOC_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} ioc_fm_pcd_hdr_index;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_profile_type_selection {
+    e_IOC_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_IOC_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} ioc_fm_pcd_profile_type_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_algorithm_selection {
+    e_IOC_FM_PCD_PLCR_PASS_THROUGH, /**< Policer pass through */
+    e_IOC_FM_PCD_PLCR_RFC_2698,     /**< Policer algorythm RFC 2698 */
+    e_IOC_FM_PCD_PLCR_RFC_4115      /**< Policer algorythm RFC 4115 */
+} ioc_fm_pcd_plcr_algorithm_selection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color_mode {
+    e_IOC_FM_PCD_PLCR_COLOR_BLIND,  /**< Color blind */
+    e_IOC_FM_PCD_PLCR_COLOR_AWARE   /**< Color aware */
+} ioc_fm_pcd_plcr_color_mode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_color {
+    e_IOC_FM_PCD_PLCR_GREEN,    /**< Green */
+    e_IOC_FM_PCD_PLCR_YELLOW,   /**< Yellow */
+    e_IOC_FM_PCD_PLCR_RED,      /**< Red */
+    e_IOC_FM_PCD_PLCR_OVERRIDE  /**< Color override */
+} ioc_fm_pcd_plcr_color;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_frame_length_select {
+  e_IOC_FM_PCD_PLCR_L2_FRM_LEN,     /**< L2 frame length */
+  e_IOC_FM_PCD_PLCR_L3_FRM_LEN,     /**< L3 frame length */
+  e_IOC_FM_PCD_PLCR_L4_FRM_LEN,     /**< L4 frame length */
+  e_IOC_FM_PCD_PLCR_FULL_FRM_LEN    /**< Full frame length */
+} ioc_fm_pcd_plcr_frame_length_select;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_roll_back_frame_select {
+  e_IOC_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_IOC_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} ioc_fm_pcd_plcr_roll_back_frame_select;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_rate_mode {
+    e_IOC_FM_PCD_PLCR_BYTE_MODE,    /**< Byte mode */
+    e_IOC_FM_PCD_PLCR_PACKET_MODE   /**< Packet mode */
+} ioc_fm_pcd_plcr_rate_mode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_done_action {
+    e_IOC_FM_PCD_ENQ_FRAME = 0,    /**< Enqueue frame */
+    e_IOC_FM_PCD_DROP_FRAME    /**< Drop frame */
+} ioc_fm_pcd_done_action;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_plcr_profile_counters {
+    e_IOC_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} ioc_fm_pcd_plcr_profile_counters;
+
+/**************************************************************************//**
+ @Description   A structure for selecting action
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_action {
+    e_IOC_FM_PCD_ACTION_NONE,                           /**< NONE  */
+    e_IOC_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
+    e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+} ioc_fm_pcd_action;
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_protocol_opt_u {
+    ioc_eth_protocol_opt_t    eth_opt;     /**< Ethernet options */
+    ioc_vlan_protocol_opt_t   vlan_opt;    /**< Vlan options */
+    ioc_mpls_protocol_opt_t   mpls_opt;    /**< MPLS options */
+    ioc_ipv4_protocol_opt_t   ipv4_opt;    /**< IPv4 options */
+    ioc_ipv6_protocol_opt_t   ipv6_opt;    /**< IPv6 options */
+} ioc_fm_pcd_hdr_protocol_opt_u;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union ioc_fm_pcd_fields_u {
+    ioc_header_field_eth_t        eth;        /**< eth      */
+    ioc_header_field_vlan_t       vlan;       /**< vlan     */
+    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
+    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
+    ioc_header_field_mpls_t       mpls;       /**< mpls     */
+    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
+    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
+    ioc_header_field_udp_t        udp;        /**< udp      */
+    ioc_header_field_tcp_t        tcp;        /**< tcp      */
+    ioc_header_field_sctp_t       sctp;       /**< sctp     */
+    ioc_header_field_dccp_t       dccp;       /**< dccp     */
+    ioc_header_field_gre_t        gre;        /**< gre      */
+    ioc_header_field_minencap_t   minencap;   /**< minencap */
+    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
+    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
+} ioc_fm_pcd_fields_u;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_hdr_t {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_hdr_t;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_from_field_t {
+    ioc_fm_pcd_fields_u field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} ioc_fm_pcd_from_field_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_distinction_unit_t {
+    struct {
+        ioc_net_header_type             hdr;            /**< One of the headers supported by the FM */
+        ioc_fm_pcd_hdr_protocol_opt_u   opt;            /**< only one option !! */
+    } hdrs[IOC_FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} ioc_fm_pcd_distinction_unit_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engines to distinguish between flows.
+                (must match struct t_FmPcdNetEnvParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_net_env_params_t {
+    uint8_t                         num_of_distinction_units;   /**< Number of different units to be identified */
+    ioc_fm_pcd_distinction_unit_t   units[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                                /**< An array of numOfDistinctionUnits of the
+                                                                     different units to be identified */
+    void                            *id;                        /**< output parameter; Returns the net-env Id to be used */
+} ioc_fm_pcd_net_env_params_t;
+
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_extract_entry_t {
+    ioc_fm_pcd_extract_type                 type;           /**< Extraction type select */
+    union {
+        struct {                            /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;            /**< Header selection */
+            bool                            ignore_protocol_validation; /**< Ignore protocol validation */
+            ioc_fm_pcd_hdr_index            hdr_index;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                                  IP. Otherwise should be cleared.*/
+            ioc_fm_pcd_extract_by_hdr_type  type;            /**< Header extraction type select */
+            union {
+                ioc_fm_pcd_from_hdr_t       from_hdr;        /**< Extract bytes from header parameters */
+                ioc_fm_pcd_from_field_t     from_field;      /**< Extract bytes from field parameters*/
+                ioc_fm_pcd_fields_u         full_field;      /**< Extract full filed parameters*/
+            } extract_by_hdr_type;
+        } extract_by_hdr;
+        struct{                       /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+            ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
+            ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
+            uint16_t                        ic_indx_mask;   /**< Relevant only for CC where
+                                                                 action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
+            uint8_t                         offset;         /**< Byte offset */
+            uint8_t                         size;           /**< Size in byte */
+        } extract_non_hdr;
+    } extract_params;
+} ioc_fm_pcd_extract_entry_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_mask_t {
+    uint8_t                extract_array_index;         /**< Index in the extraction array, as initialized by user */
+    uint8_t                offset;                      /**< Byte offset */
+    uint8_t                mask;                        /**< A byte mask (selected bits will be ignored) */
+} ioc_fm_pcd_kg_extract_mask_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extract_dflt_t {
+    ioc_fm_pcd_kg_known_fields_dflt_types    type;          /**< Default type select*/
+    ioc_fm_pcd_kg_extract_dflt_select        dflt_select;   /**< Default register select */
+} ioc_fm_pcd_kg_extract_dflt_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_key_extract_and_hash_params_t {
+    uint32_t                            private_dflt0;               /**< Scheme default register 0 */
+    uint32_t                            private_dflt1;               /**< Scheme default register 1 */
+    uint8_t                             num_of_used_extracts;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_extract_entry_t          extract_array [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+    uint8_t                             num_of_used_dflt;           /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_dflt_t        dflts[IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                             num_of_used_masks;              /**< defines the valid size of the following array */
+    ioc_fm_pcd_kg_extract_mask_t        masks[IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                             hash_shift;                     /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                            hash_distribution_num_of_fqids; /**< must be > 1 and a power of 2. Represents the range
+                                                                             of queues for the key and hash functionality */
+    uint8_t                             hash_distribution_fqids_shift;  /**< selects the FQID bits that will be effected by the hash */
+    bool                                symmetric_hash;                 /**< TRUE to generate the same hash for frames with swapped source and
+                                                                  destination fields on all layers; If TRUE, driver will check that for
+                                                                  all layers, if SRC extraction is selected, DST extraction must also be
+                                                                  selected, and vice versa. */
+} ioc_fm_pcd_kg_key_extract_and_hash_params_t;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Qid mask (extracted OR).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
+    ioc_fm_pcd_extract_type                 type;               /**< Extraction type select */
+    union{
+        struct{                                                 /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_BY_HDR */
+            ioc_net_header_type             hdr;
+            ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
+                                                                     IP. Otherwise should be cleared.*/
+            bool                            ignore_protocol_validation;
+        } extract_by_hdr;
+        ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extract_params;
+    uint8_t                                 extraction_offset;  /**< Offset for extraction */
+    ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
+                                                                     field not found */
+    uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
+    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
+} ioc_fm_pcd_kg_extracted_or_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_counter_t {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} ioc_fm_pcd_kg_scheme_counter_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_plcr_profile_t {
+    bool                shared_profile;                 /**< TRUE if this profile is shared between ports
+                                                             (i.e. managed by master partition) May not be TRUE
+                                                             if profile is after Coarse Classification*/
+    bool                direct;                         /**< if TRUE, directRelativeProfileId only selects the profile
+                                                             id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                             together with fqidOffsetShift and numOfProfiles
+                                                             parameters, to define a range of profiles from
+                                                             which the keygen result will determine the
+                                                             destination policer profile.  */
+    union{
+        uint16_t        direct_relative_profile_id;     /**< Used if 'direct' is TRUE, to select policer profile.
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqid_offset_shift;              /**< shift of KG results without the qid base */
+            uint8_t     fqid_offset_relative_profile_id_base;/**< OR of KG results without the qid base
+                                                             This parameter should
+                                                             indicate the policer profile offset within the port's
+                                                             policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     num_of_profiles;                /**< Range of profiles starting at base */
+        } indirect_profile_id;
+    } profile_select;
+} ioc_fm_pcd_kg_plcr_profile_t;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_cc_t {
+    void                            *tree_id;           /**< CC Tree id */
+    uint8_t                         grp_id;             /**< CC group id within the CC tree */
+    bool                            plcr_next;          /**< TRUE if after CC, in case of data frame,
+                                                             policing is required. */
+    bool                            bypass_plcr_profile_generation;
+                                                        /**< TRUE to bypass keygen policer profile
+                                                             generation (profile selected is the one selected at
+                                                             port initialization). */
+    ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;       /**< only if plcrNext=TRUE */
+} ioc_fm_pcd_kg_cc_t;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+                (must match struct t_FmPcdKgSchemeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_params_t {
+    bool                                modify;         /**< enables changing an existing scheme */
+    union
+    {
+        uint8_t                         relative_scheme_id;
+                                                         /**< if modify=FALSE:Partition relative scheme id */
+        void                            *scheme_id;      /**< if modify=TRUE: a handle of the existing scheme */
+    } scm_id;
+    bool                                always_direct;   /**< This scheme is reached only directly, i.e.
+                                                              no need for match vector. Keygen will ignore
+                                                              it when matching   */
+    struct                                               /**< HL Relevant only if alwaysDirect = FALSE */
+    {
+        void                            *net_env_id;     /**< Network environment id  */
+        uint8_t                         num_of_distinction_units;
+                                                         /**< Number of netenv units listed in unit_ids array */
+        uint8_t                         unit_ids[IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+                                                         /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                use_hash;        /**< use the KG Hash functionality */
+    ioc_fm_pcd_kg_key_extract_and_hash_params_t key_extract_and_hash_params;
+                                                         /**< used only if useHash = TRUE */
+    bool                                bypass_fqid_generation;
+                                                         /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
+                                                              In such a case FQID after KG will be the default FQID
+                                                              defined for the relevant port, or the FQID defined by CC
+                                                              in cases where CC was the previous engine. */
+    uint32_t                            base_fqid;       /**< Base FQID */
+    uint8_t                             numOfUsedExtractedOrs;
+                                                         /**< Number of Fqid masks listed in extractedOrs array*/
+    ioc_fm_pcd_kg_extracted_or_params_t extracted_ors[IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                         /**< IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                              registers are shared between qidMasks
+                                                              functionality and some of the extraction
+                                                              actions; Normally only some will be used
+                                                              for qidMask. Driver will return error if
+                                                              resource is full at initialization time. */
+    ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
+    union{                                               /**< depends on nextEngine */
+        ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
+        ioc_fm_pcd_kg_plcr_profile_t    plcr_profile;    /**< Used when next engine is PLCR */
+        ioc_fm_pcd_kg_cc_t              cc;              /**< Used when next engine is CC */
+    } kg_next_engine_params;
+    ioc_fm_pcd_kg_scheme_counter_t      scheme_counter;  /**< A structure of parameters for updating
+                                                              the scheme counter */
+    void                                *id;             /**< Returns the scheme Id to be used */
+} ioc_fm_pcd_kg_scheme_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_cc_params_t {
+    void        *cc_node_id;                             /**< Id of the next CC node */
+} ioc_fm_pcd_cc_next_cc_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
+    bool        override_params;            /**< TRUE if CC override previously decided parameters*/
+    bool        shared_profile;             /**< Relevant only if overrideParams=TRUE:
+                                                TRUE if this profile is shared between ports */
+    uint16_t    new_relative_profileId;     /**< Relevant only if overrideParams=TRUE:
+                                                (otherwise profile id
+                                                is taken from keygen);
+                                                This parameter should
+                                                indicate the policer profile offset within the port's
+                                                policer profiles or from SHARED window.*/
+    uint32_t    new_fqid;                   /**< Relevant only if overrideParams=TRUE:
+                                                FQID for enquing the frame;
+                                                In earlier chips  if policer next engine is KEYGEN,
+                                                this parameter can be 0, because the KEYGEN always decides
+                                                the enqueue FQID.*/
+    bool        statistics_en;               /**< In the case of TRUE Statistic counter is
+                                                incremented for each received frame passed through
+                                                this Coarse Classification entry.*/
+} ioc_fm_pcd_cc_next_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
+    ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
+    bool                    override_fqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
+                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+    uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                                 (otherwise FQID is taken from keygen),
+                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+    bool                    statistics_en;   /**< In the case of TRUE Statistic counter is
+                                                 incremented for each received frame passed through
+                                                 this Coarse Classification entry.*/
+} ioc_fm_pcd_cc_next_enqueue_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_kg_params_t {
+    bool       override_fqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
+                                          Note - this parameters unrelevant for earlier chips*/
+    uint32_t   new_fqid;                 /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
+                                         (otherwise FQID is taken from keygen),
+                                          Note - this parameters unrelevant for earlier chips*/
+    void       *p_direct_scheme;        /**< Direct scheme handle to go to. */
+    bool       statistics_en;           /**< In the case of TRUE Statistic counter is
+                                             incremented for each received frame passed through
+                                             this Coarse Classification entry.*/
+} ioc_fm_pcd_cc_next_kg_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+                (must match struct t_FmPcdCcNextEngineParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_next_engine_params_t {
+    ioc_fm_pcd_engine                           next_engine;    /**< user has to init parameters according
+                                                                     to nextEngine definition */
+    union {
+            ioc_fm_pcd_cc_next_cc_params_t      cc_params;      /**< Parameters in case next engine is CC */
+            ioc_fm_pcd_cc_next_plcr_params_t    plcr_params;    /**< Parameters in case next engine is PLCR */
+            ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
+            ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
+    } params;
+#if defined(FM_CAPWAP_SUPPORT)
+    void                                        *p_manip;       /**< Handler to headerManip.
+                                                                     Relevant if next engine of the type result
+                                                                     (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+#endif /* defined(FM_CAPWAP_SUPPORT) */
+} ioc_fm_pcd_cc_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_key_params_t {
+    uint8_t                 *p_key; /**< pointer to the key of the size defined in keySize */
+    uint8_t                 *p_mask;/**< pointer to the Mask per key  of the size defined
+                                         in keySize. p_Key and p_Mask (if defined) has to be
+                                         of the same size defined in the keySize */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                    /**< parameters for the next for the defined Key in
+                                         the p_Key */
+
+} ioc_fm_pcd_cc_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct ioc_keys_params_t {
+    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
+    uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
+                                                             the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                             key. In the another type of extraction keySize has to be as size of extraction. */
+    ioc_fm_pcd_cc_key_params_t          key_params[IOC_FM_PCD_MAX_NUM_OF_KEYS];
+                                                        /**< it's array with numOfKeys entries each entry in
+                                                             the array of the type ioc_fm_pcd_cc_key_params_t */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params_for_miss;
+                                                        /**< parameters for the next step of
+                                                             unfound (or undefined) key */
+} ioc_keys_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_params_t {
+    ioc_fm_pcd_extract_entry_t          extract_cc_params;  /**< params which defines extraction parameters */
+    ioc_keys_params_t                   keys_params;        /**< params which defines Keys parameters of the
+                                                                 extraction defined in  extractParams */
+    void                                *id;                /**< output parameter; Returns the CC node Id to be used */
+} ioc_fm_pcd_cc_node_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unit_ids list must be in order from lower to higher indexes.
+
+                ioc_fm_pcd_cc_next_engine_params_t is a list of 2^num_of_distinction_units
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                num_of_distinction_units = 2
+                unit_ids = {1,3}
+                next_engine_per_entries_in_grp[0] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - not found;
+                next_engine_per_entries_in_grp[1] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - not found; unit 3 - found;
+                next_engine_per_entries_in_grp[2] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - not found;
+                next_engine_per_entries_in_grp[3] = ioc_fm_pcd_cc_next_engine_params_t for the case that
+                                                    unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_grp_params_t {
+    uint8_t                             num_of_distinction_units;   /**< up to 4 */
+    uint8_t                             unit_ids [IOC_FM_PCD_MAX_NUM_OF_CC_UNITS];
+                                                                    /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics */
+    ioc_fm_pcd_cc_next_engine_params_t  next_engine_per_entries_in_grp[IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
+                                                                    /**< Max size is 16 - if only one group used */
+} ioc_fm_pcd_cc_grp_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+                (must match struct t_FmPcdCcTreeParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_params_t {
+        void                            *net_env_id;    /**< Id of the Network environment as returned
+                                                             by FM_PCD_SetNetEnvCharacteristics */
+        uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
+        ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+                                                        /**< Parameters for each group. */
+        void                            *id;            /**< output parameter; Returns the tree Id to be used */
+} ioc_fm_pcd_cc_tree_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_byte_rate_mode_param_t {
+    ioc_fm_pcd_plcr_frame_length_select     frame_length_selection;     /**< Frame length selection */
+    ioc_fm_pcd_plcr_roll_back_frame_select  roll_back_frame_selection;  /**< relevant option only e_IOC_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                             e_IOC_FM_PCD_PLCR_FULL_FRM_LEN */
+} ioc_fm_pcd_plcr_byte_rate_mode_param_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or
+                RFC 4115 parameters
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_non_passthrough_alg_param_t {
+    ioc_fm_pcd_plcr_rate_mode               rate_mode;                      /**< Byte / Packet */
+    ioc_fm_pcd_plcr_byte_rate_mode_param_t  byte_mode_param;                /**< Valid for Byte NULL for Packet */
+    uint32_t                                comitted_info_rate;             /**< KBits/Sec or Packets/Sec */
+    uint32_t                                comitted_burst_size;            /**< KBits or Packets */
+    uint32_t                                peak_or_accessive_info_rate;    /**< KBits/Sec or Packets/Sec */
+    uint32_t                                peak_or_accessive_burst_size;   /**< KBits or Packets */
+} ioc_fm_pcd_plcr_non_passthrough_alg_param_t;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union ioc_fm_pcd_plcr_next_engine_params_u {
+        ioc_fm_pcd_done_action     action;              /**< Action - when next engine is BMI (done) */
+        void                       *p_profile;          /**< Policer profile handle -  used when next engine
+                                                             is PLCR, must be a SHARED profile */
+        void                       *p_direct_scheme;    /**< Direct scheme select - when next engine is Keygen */
+} ioc_fm_pcd_plcr_next_engine_params_u;
+
+typedef struct fm_pcd_port_params_t {
+    ioc_fm_port_type                    port_type;          /**< Type of port for this profile */
+    uint8_t                             port_id;            /**< FM-Port id of port for this profile */
+} fm_pcd_port_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+                (must match struct t_FmPcdPlcrProfileParams defined in fm_pcd_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_plcr_profile_params_t {
+    bool                                        modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            ioc_fm_pcd_profile_type_selection   profile_type;               /**< Type of policer profile */
+            void                               *p_port;                     /**< Type of policer profile */
+            uint16_t                            relative_profile_id;        /**< Profile id - relative to shared group or to port */
+        } new_params;
+        void                                    *p_profile;                 /**< A handle to a profile - use it when modify=TRUE */
+    } profile_select;
+    ioc_fm_pcd_plcr_algorithm_selection         alg_selection;              /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    ioc_fm_pcd_plcr_color_mode                  color_mode;                 /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        ioc_fm_pcd_plcr_color                   dflt_color;                 /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                                 any incoming packet with the deflt value. */
+        ioc_fm_pcd_plcr_color                   override;                   /**< For Color-Aware modes. The profile response to a
+                                                                                 pre-color value of 2'b11. */
+    } color;
+
+    ioc_fm_pcd_plcr_non_passthrough_alg_param_t non_passthrough_alg_param;  /**< RFC2698 or RFC4115 params */
+
+    ioc_fm_pcd_engine                           next_engine_on_green;       /**< Green next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_green;            /**< Green next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_yellow;      /**< Yellow next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_yellow;           /**< Yellow next engine params */
+
+    ioc_fm_pcd_engine                           next_engine_on_red;         /**< Red next engine type */
+    ioc_fm_pcd_plcr_next_engine_params_u        params_on_red;              /**< Red next engine params */
+
+    bool                                        trap_profile_on_flow_A;     /**< Trap on flow A */
+    bool                                        trap_profile_on_flow_B;     /**< Trap on flow B */
+    bool                                        trap_profile_on_flow_C;     /**< Trap on flow C */
+    void                                        *id;                        /**< output parameter; Returns the profile Id to be used */
+} ioc_fm_pcd_plcr_profile_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC tree next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
+    void                                *id;                /**< CC tree Id to be used */
+    uint8_t                             grp_indx;           /**< A Group index in the tree */
+    uint8_t                             indx;               /**< Entry index in the group defined by grpId */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
+                                                            /**< parameters for the next for the defined Key in the p_Key */
+} ioc_fm_pcd_cc_node_modify_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key and next engine
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for remove CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+} ioc_fm_pcd_cc_node_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   A structure for modifying CC node key
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
+    void                                *id;                /**< CC node Id to be used */
+    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+                                                                 NOTE: This parameter is IGNORED for miss-key!  */
+    uint8_t                             key_size;           /**< Key size of added key */
+    uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
+    uint8_t                             *p_mask;            /**< pointer to the Mask per key  of the size defined
+                                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                                 of the same size defined in the keySize */
+} ioc_fm_pcd_cc_node_modify_key_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in,out] ioc_fm_pcd_net_env_params_t   An structure defining the distiction units for this configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_compat_fm_pcd_net_env_params_t)
+#endif
+#define FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(20), ioc_fm_pcd_net_env_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     ioc_fm_obj_t        An id of a Network environment object.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS_COMPAT  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_DELETE_NET_ENV_CHARACTERISTICS  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(21), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_SET_SCHEME
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'override' should be TRUE. If  the
+                routine is called for a valid scheme and 'override' is FALSE,
+                it will return error.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_params_t   A structure of parameters for defining the scheme
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_SET_SCHEME_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_compat_fm_pcd_kg_scheme_params_t)
+#endif
+#define FM_PCD_IOC_KG_SET_SCHEME    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(24), ioc_fm_pcd_kg_scheme_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_KG_DEL_SCHEME
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     ioc_fm_obj_t        scheme id as initalized by application at FM_PCD_IOC_KG_SET_SCHEME
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_KG_DEL_SCHEME_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_KG_DEL_SCHEME    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(25), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_BUILD_TREE
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in,out] ioc_fm_pcd_cc_tree_params_t     A structure of parameters to define the tree.
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+//#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_compat_fm_pcd_cc_tree_params_t)
+#define FM_PCD_IOC_CC_BUILD_TREE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), compat_uptr_t)
+#endif
+//#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), ioc_fm_pcd_cc_tree_params_t)
+#define FM_PCD_IOC_CC_BUILD_TREE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(26), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_DELETE_TREE
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_DELETE_TREE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_CC_DELETE_TREE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_SET_NODE
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes. p_NodeId returns the node
+                Id to be used by other nodes.
+
+ @Param[in,out] ioc_fm_pcd_cc_node_params_t       A structure for defining the CC node params
+
+ @Return        0 on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_SET_NODE_COMPAT    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), compat_uptr_t)
+#endif
+#define FM_PCD_IOC_CC_SET_NODE    _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(28), void *) /* workaround ...*/
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     ioc_fm_obj_t    An id of a CC-node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_DELETE_NODE_COMPAT    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_CC_DELETE_NODE    _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(29), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_TREE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(30), ioc_fm_pcd_cc_tree_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(31), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_MODIFY_MISS_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(32), ioc_fm_pcd_cc_node_modify_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_REMOVE_KEY
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_compat_fm_pcd_cc_node_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_REMOVE_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(33), ioc_fm_pcd_cc_node_remove_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_ADD_KEY
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_ADD_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(34), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_AND_NEXT_ENGINE   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(35), ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_CC_NODE_MODIFY_KEY
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
+                the node that points to this node
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_compat_fm_pcd_cc_node_modify_key_params_t)
+#endif
+#define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_SET_PROFILE
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in,out] ioc_fm_pcd_plcr_profile_params_t    A structure of parameters for defining a
+                                                    policer profile entry.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_plcr_profile_params_t)
+#endif
+#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     ioc_fm_obj_t        an id of a policer-profile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
+
+#endif /* __FM_PCD_IOCTLS_H */
+/** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
new file mode 100644
index 0000000..b642af8
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -0,0 +1,662 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_ioctls.h
+
+ @Description   FM Port routines
+*//***************************************************************************/
+#ifndef __FM_PORT_IOCTLS_H
+#define __FM_PORT_IOCTLS_H
+
+#include "net_ioctls.h"
+#include "fm_ioctls.h"
+#include "fm_pcd_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API
+
+ @Description   FM Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#ifdef CONFIG_FMAN_P1023
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS       32 /**< Total number of congestion groups in QM */
+#else
+#define IOC_FM_PORT_NUM_OF_CONGESTION_GRPS      256 /**< Total number of congestion groups in QM */
+#endif
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+typedef enum ioc_fm_port_pcd_support {
+    e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0,             /**< BMI to BMI, PCD is not used */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR,  /**< Use Parser, Keygen and Policer */
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY,              /**< Use only Coarse Classification */
+    e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG,            /**< Use Coarse Classification,and Keygen */
+    e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR    /**< Use Coarse Classification, Keygen and Policer */
+#endif
+} ioc_fm_port_pcd_support;
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum fm_port_counters {
+    e_IOC_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_IOC_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_IOC_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} fm_port_counters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct ioc_fm_port_congestion_groups_t {
+    uint16_t    num_of_congestion_grps_to_consider; /**< Size of congestion_grps_to_consider array */
+    uint8_t     congestion_grps_to_consider [IOC_FM_PORT_NUM_OF_CONGESTION_GRPS];   /**< list of congestion groups */
+} ioc_fm_port_congestion_groups_t;
+
+/**************************************************************************//**
+ @Description   struct for defining Dual Tx rate limiting scale
+                (identical to e_FmPortDualRateLimiterScaleDown defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef enum fm_port_dual_rate_limiter_scale_down {
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2,    /**< Divide high rate limiter by 2 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4,    /**< Divide high rate limiter by 4 */
+    e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8     /**< Divide high rate limiter by 8 */
+} fm_port_dual_rate_limiter_scale_down;
+
+/**************************************************************************//**
+ @Description   struct for defining Tx rate limiting
+                (identical to t_FmPortRateLimit defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_rate_limit {
+    uint16_t                            max_burst_size;         /**< in KBytes for Tx ports, in frames
+                                                                     for offline parsing ports. (note that
+                                                                     for early chips burst size is
+                                                                     rounded up to a multiply of 1000 frames).*/
+    uint32_t                            rate_limit;             /**< in Kb/sec for Tx ports, in frame/sec for
+                                                                     offline parsing ports. Rate limit refers to
+                                                                     data rate (rather than line rate). */
+    fm_port_dual_rate_limiter_scale_down rate_limit_divider;    /**< For offline parsing ports only. Not-valid
+                                                                     for some earlier chip revisions */
+} ioc_fm_port_rate_limit_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DISABLE
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+#define FM_PORT_IOC_DISABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(1))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ENABLE
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ENABLE   _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(2))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_RATE_LIMIT
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded to the nearest power of 2 multiplication
+                (i.e. up to twice the required rate).
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_rate_limit A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_RATE_LIMIT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(3), ioc_fm_port_rate_limit_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_REMOVE_RATE_LIMIT
+
+ @Description   Calling this routine disables the previously enabled rate limit.
+
+                May be used for Tx and offline parsing ports only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_REMOVE_RATE_LIMIT _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(5))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_ERRORS_ROUTE
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_frame_err_select_t  A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_SET_ERRORS_ROUTE   _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(4), ioc_fm_port_frame_err_select_t)
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+                (must match struct t_FmPcdKgSchemeSelect defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_scheme_select_t {
+    bool        direct;                     /**< TRUE is the scheme should be accessed directly */
+    void        *scheme_id;                 /**< Scheme id */
+} ioc_fm_pcd_kg_scheme_select_t;
+
+/**************************************************************************//**
+ @Description    A structure for defining the Parser starting point
+                (must match struct t_FmPcdPrsStart defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_start_t {
+    uint8_t             parsing_offset; /**< Number of bytes from begining of packet to
+                                             start parsing */
+    ioc_net_header_type first_prs_hdr;  /**< The type of the first header axpected at
+                                             'parsing_offset' */
+} ioc_fm_pcd_prs_start_t;
+
+/**************************************************************************//**
+ @Description   Scheme is'd structure
+                (must match struct t_FmPcdPortSchemesParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_port_schemes_params_t {
+    uint8_t     num_of_schemes;
+    void        *schemes_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+} ioc_fm_pcd_port_schemes_params_t;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union ioc_fm_pcd_hdr_prs_opts_u {
+    /* MPLS */
+    struct {
+        bool                label_interpretation_enable;/**< When this bit is set, the last MPLS label will be
+                                                             interpreted as described in HW spec table. When the bit
+                                                             is cleared, the parser will advance to MPLS next parse */
+        ioc_net_header_type next_parse;                 /**< must be equal or higher than IPv4 */
+    } mpls_prs_options;
+    /* VLAN */
+    struct {
+        uint16_t            tag_protocol_id1;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t            tag_protocol_id2;           /**< User defined Tag Protocol Identifier, to be recognized
+                                                             on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlan_prs_options;
+    /* IPV6 */
+    struct {
+        bool                routing_hdr_disable;        /**< Disable routing header */
+    } ipv6_prs_options;
+
+    /* UDP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } udp_prs_options;
+
+    /* TCP */
+    struct {
+        bool                pad_ignore_checksum;        /**< TRUE to ignore pad in checksum */
+    } tcp_prs_options;
+} ioc_fm_pcd_hdr_prs_opts_u;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+                (must match struct t_FmPcdPrsAdditionalHdrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
+    ioc_net_header_type         hdr;                /**< Selected header */
+    bool                        err_disable;        /**< TRUE to disable error indication */
+    bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
+                                                         header is recognized by the HW parser. */
+    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
+                                                         attachments exists for the same header,
+                                                         (in the main sw parser code) use this
+                                                         index to distinguish between them. */
+    bool                        use_prs_opts;       /**< TRUE to use parser options. */
+    ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
+                                                         defining the parser options selected.*/
+} ioc_fm_pcd_prs_additional_hdr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+                (must match t_FmPortPcdPrsParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_prs_params_t {
+    uint8_t                                 prs_res_priv_info;          /**< The private info provides a method of inserting
+                                                                             port information into the parser result. This information
+                                                                             may be extracted by Keygen and be used for frames
+                                                                             distribution when a per-port distinction is required,
+                                                                             it may also be used as a port logical id for analyazing
+                                                                             incoming frames. */
+    uint8_t                                 parsing_offset;             /**< Number of bytes from begining of packet to
+                                                                             start parsing */
+    ioc_net_header_type                     first_prs_hdr;              /**< The type of the first header axpected at
+                                                                             'parsingOffset' */
+    bool                                    includeInPrsStatistics;     /**< TRUE to include this port in the parser statistics;
+                                                                              NOTE: this field is not valid when the FN is in "guest" mode. */
+    uint8_t                                 num_of_hdrs_with_additional_params;
+                                                        /**< Normally 0, some headers may get
+                                                             special parameters */
+    ioc_fm_pcd_prs_additional_hdr_params_t  additional_params[IOC_FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< A structure of additional parameters
+                                                             for each header that requires them */
+    bool                                    set_vlan_tpid1;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid1;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                                    set_vlan_tpid2;             /**< TRUE to configure user selection of Ethertype to
+                                                                             indicate a VLAN tag (in addition to the TPID values
+                                                                             0x8100 and 0x88A8). */
+    uint16_t                                vlan_tpid2;                 /**< extra tag to use if setVlanTpid1=TRUE. */
+} ioc_fm_port_pcd_prs_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+                (must match t_FmPortPcdCcParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_cc_params_t {
+    void                *cc_tree_id; /**< CC tree id */
+} ioc_fm_port_pcd_cc_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+                (must match t_FmPortPcdKgParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_kg_params_t {
+    uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
+    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+    bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    void                *direct_scheme_id;              /**< relevant only if direct == TRUE */
+} ioc_fm_port_pcd_kg_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+                (must match t_FmPortPcdPlcrParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_plcr_params_t {
+    void                *plcr_profile_id;               /**< relevant only if
+                                                             e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                             e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} ioc_fm_port_pcd_plcr_params_t;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+                (must match struct t_FmPortPcdParams defined in fm_port_ext.h)
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_params_t {
+    ioc_fm_port_pcd_support         pcd_support;    /**< Relevant for Rx and offline ports only.
+                                                         Describes the active PCD engines for this port. */
+    void                            *net_env_id;    /**< HL Unused in PLCR only mode */
+    ioc_fm_port_pcd_prs_params_t    *p_prs_params;  /**< Parser parameters for this port */
+    ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
+    ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
+    ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+} ioc_fm_port_pcd_params_t;
+
+/**************************************************************************//**
+ @Description   FQID parameters structure
+*//***************************************************************************/
+typedef struct ioc_fm_port_pcd_fqids_params_t {
+    uint32_t            num_fqids;  /**< Number of fqids to be allocated for the port */
+    uint8_t             alignment;  /**< Alignment required for this port */
+    uint32_t            base_fqid;  /**< output parameter - the base fqid */
+} ioc_fm_port_pcd_fqids_params_t;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ALLOC_PCD_FQIDS
+
+ @Description   Allocates FQID's
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in,out] ioc_fm_port_pcd_fqids_params_t  Parameters for allocating FQID's
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ALLOC_PCD_FQIDS   _IOWR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(19), ioc_fm_port_pcd_fqids_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_SET_PCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     ioc_fm_port_pcd_params_t    A Structure of parameters defining the port's PCD
+                                            configuration.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_SET_PCD_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_compat_fm_port_pcd_params_t)
+#endif
+#define FM_PORT_IOC_SET_PCD _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(20), ioc_fm_port_pcd_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DELETE_PCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DELETE_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(21))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_DETACH_PCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_DETACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(22))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_ATTACH_PCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define FM_PORT_IOC_ATTACH_PCD _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(23))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     uint16_t       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_ALLOC_PROFILES     _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(24), uint16_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_FREE_PROFILES
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+#define FM_PORT_IOC_PCD_PLCR_FREE_PROFILES     _IO(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(25))
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     ioc_fm_pcd_kg_scheme_select_t   A structure of parameters for defining whether
+                                                a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_compat_fm_pcd_kg_scheme_select_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_MODIFY_INITIAL_SCHEME _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(26), ioc_fm_pcd_kg_scheme_select_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE
+
+ @Description   This routine may be called for ports with flows e_IOC_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_IOC_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     ioc_fm_obj_t       Policer profile Id as returned from FM_PCD_PlcrSetProfile.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_PLCR_MODIFY_INITIAL_PROFILE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(27), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_CC_MODIFY_TREE
+
+ @Description   This routine may be called to change this port connection to
+                a pre-initializes coarse classification Tree.
+
+ @Param[in]     ioc_fm_obj_t    Id of new coarse classification tree selected for this port.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_compat_fm_obj_t)
+#endif
+#define FM_PORT_IOC_PCD_CC_MODIFY_TREE _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(28), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_BIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not added,
+                just this specific port starts using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_BIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(30), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES
+
+ @Description   These routines may be called for modifying the binding of ports
+                to schemes. The scheme itself is not removed or invalidated,
+                just this specific port stops using it.
+
+ @Param[in]     ioc_fm_pcd_port_schemes_params_t    Schemes parameters structre
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES_COMPAT _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_compat_fm_pcd_port_schemes_params_t)
+#endif
+#define FM_PORT_IOC_PCD_KG_UNBIND_SCHEMES _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(31), ioc_fm_pcd_port_schemes_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     ioc_fm_pcd_prs_start_t  A structure of parameters for defining the
+                                        start point for the parser.
+
+ @Return        0 on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
+
+/** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
+/** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
+/** @} */ /* end of lnx_ioctl_FM_grp group */
+
+
+#endif /* __FM_PORT_IOCTLS_H */
diff --git a/include/linux/fmd/Peripherals/fm_test_ioctls.h b/include/linux/fmd/Peripherals/fm_test_ioctls.h
new file mode 100644
index 0000000..7b90c2b
--- /dev/null
+++ b/include/linux/fmd/Peripherals/fm_test_ioctls.h
@@ -0,0 +1,208 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_test_ioctls.h
+
+ @Description   FM Char device ioctls
+*//***************************************************************************/
+#ifndef __FM_TEST_IOCTLS_H
+#define __FM_TEST_IOCTLS_H
+
+#include "ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API
+
+ @Description   FM-Test Linux ioctls definitions and enums
+
+ @{
+*//***************************************************************************/
+
+#define IOC_FMT_MAX_NUM_OF_PORTS        26
+
+/**************************************************************************//**
+ @Collection    TEST Parameters
+*//***************************************************************************/
+/**************************************************************************//**
+  @Description: Name of the FM-Test chardev
+*//***************************************************************************/
+#define DEV_FM_TEST_NAME                "fm-test-port"
+
+#define DEV_FM_TEST_PORTS_MINOR_BASE    0
+#define DEV_FM_TEST_MAX_MINORS          (DEV_FM_TEST_PORTS_MINOR_BASE + IOC_FMT_MAX_NUM_OF_PORTS)
+
+#define FMT_PORT_IOC_NUM(n)             n
+/* @} */
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_lib_grp FM-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef uint8_t ioc_fmt_xxx_t;
+
+#define FM_PRS_MAX 32
+#define FM_TIME_STAMP_MAX 8
+
+/**************************************************************************//**
+ @Description   FM Port buffer content description
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_context_t {
+    void            *p_user_priv;
+    uint8_t         fm_prs_res[FM_PRS_MAX];
+    uint8_t         fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_buff_context_t;
+
+#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
+typedef struct ioc_fmt_compat_buff_context_t {
+    compat_uptr_t         p_user_priv;
+    uint8_t               fm_prs_res[FM_PRS_MAX];
+    uint8_t               fm_time_stamp[FM_TIME_STAMP_MAX];
+} ioc_fmt_compat_buff_context_t;
+#endif
+
+/**************************************************************************//**
+ @Description   Buffer descriptor
+*//***************************************************************************/
+typedef struct ioc_fmt_buff_desc_t {
+    uint32_t               qid;
+    void                   *p_data;
+    uint32_t               size;
+    uint32_t               status;
+    ioc_fmt_buff_context_t buff_context;
+} ioc_fmt_buff_desc_t;
+
+#if defined(__KERNEL__) && defined(CONFIG_COMPAT)
+typedef struct ioc_fmt_compat_buff_desc_t {
+    uint32_t                qid;
+    compat_uptr_t           p_data;
+    uint32_t                size;
+    uint32_t                status;
+    ioc_fmt_compat_buff_context_t buff_context;
+} ioc_fmt_compat_buff_desc_t;
+#endif
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
+
+ @Description   TODO
+ @{
+*//***************************************************************************/
+
+/** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
+
+ @Description   TODO
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM-Test FM port type
+*//***************************************************************************/
+typedef enum ioc_fmt_port_type {
+    e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
+    e_IOC_FMT_PORT_T_OP,    /**< Offline-parsing port */
+} ioc_fmt_port_type;
+
+/**************************************************************************//**
+ @Description   TODO
+*//***************************************************************************/
+typedef struct ioc_fmt_port_param_t {
+    uint8_t             fm_id;
+    ioc_fmt_port_type   fm_port_type;
+    uint8_t             fm_port_id;
+    uint32_t            num_tx_queues;
+} ioc_fmt_port_param_t;
+
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_INIT
+
+ @Description   TODO
+
+ @Param[in]     ioc_fmt_port_param_t  TODO
+
+ @Cautions      Allowed only after the FM equivalent port is already initialized.
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DIAG_MODE
+
+ @Description   TODO
+
+ @Param[in]     ioc_diag_mode  TODO
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
+
+ @Description   Set IP header manipulations for this port.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DPAECHO_MODE
+
+ @Description   Set DPA in echo mode - all frame are sent back.
+
+ @Param[in]     int     1 to enable; 0 to disable
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)
+
+/** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
+/** @} */ /* end of lnx_ioctl_FMT_grp */
+
+
+#endif /* __FM_TEST_IOCTLS_H */
diff --git a/include/linux/fmd/integrations/Kbuild b/include/linux/fmd/integrations/Kbuild
new file mode 100644
index 0000000..e548d67
--- /dev/null
+++ b/include/linux/fmd/integrations/Kbuild
@@ -0,0 +1 @@
+header-y += integration_ioctls.h
diff --git a/include/linux/fmd/integrations/integration_ioctls.h b/include/linux/fmd/integrations/integration_ioctls.h
new file mode 100644
index 0000000..1642f86
--- /dev/null
+++ b/include/linux/fmd/integrations/integration_ioctls.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          integration_ioctls.h
+
+ @Description   External header file for Integration unit routines.
+*//***************************************************************************/
+
+#ifndef __INTG_IOCTLS_H
+#define __INTG_IOCTLS_H
+
+
+#define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
+#define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
+
+
+#endif /* __INTG_IOCTLS_H */
diff --git a/include/linux/fmd/ioctls.h b/include/linux/fmd/ioctls.h
new file mode 100644
index 0000000..abcc7d1
--- /dev/null
+++ b/include/linux/fmd/ioctls.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          ioctls.h
+
+ @Description   Structures and definitions for Command Relay Ioctls
+*//***************************************************************************/
+
+#ifndef __IOCTLS_H__
+#define __IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+#include "integration_ioctls.h"
+
+
+/**************************************************************************//**
+ @Group         lnx_ioctl_ncsw_grp    NeCommSw Linux User-Space (IOCTL) API
+ @{
+*//***************************************************************************/
+
+#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
+                                                 the NCSW Linux module commands */
+
+
+/**************************************************************************//**
+ @Description   IOCTL Memory allocation types.
+*//***************************************************************************/
+typedef enum ioc_mem_type {
+    e_IOC_MEM_INVALID      = 0x00000000,  /**< Invalid memory type (error) */
+    e_IOC_MEM_CACHABLE_SYS = 0x00000001,  /**< Primary DDR, cacheable segment */
+    e_IOC_MEM_NOCACHE_SYS  = 0x00000004,  /**< Primary DDR, non-cacheable segment */
+    e_IOC_MEM_SECONDARY    = 0x00000002,  /**< Either secondary DDR or SDRAM */
+    e_IOC_MEM_PRAM         = 0x00000008   /**< Multi-user RAM identifier */
+} ioc_mem_type;
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum ioc_comm_mode {
+      e_IOC_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_IOC_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_IOC_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} ioc_comm_mode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum ioc_diag_mode
+{
+    e_IOC_DIAG_MODE_NONE = 0,
+    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
+} ioc_diag_mode;
+
+/** @} */ /* end of lnx_ioctl_ncsw_grp */
+
+
+#endif /* __IOCTLS_H__ */
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
new file mode 100644
index 0000000..afc8755
--- /dev/null
+++ b/include/linux/fmd/net_ioctls.h
@@ -0,0 +1,383 @@
+/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ioctls.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_IOCTLS_H
+#define __NET_IOCTLS_H
+
+#include "ioctls.h"
+
+
+typedef uint8_t ioc_header_field_ppp_t;
+
+#define IOC_NET_HEADER_FIELD_PPP_PID                        (1)
+#define IOC_NET_HEADER_FIELD_PPP_COMPRESSED                 (IOC_NET_HEADER_FIELD_PPP_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_pppoe_t;
+
+#define IOC_NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define IOC_NET_HEADER_FIELD_PPPoE_TYPE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 1)
+#define IOC_NET_HEADER_FIELD_PPPoE_CODE                     (IOC_NET_HEADER_FIELD_PPPoE_VER << 2)
+#define IOC_NET_HEADER_FIELD_PPPoE_SID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 3)
+#define IOC_NET_HEADER_FIELD_PPPoE_LEN                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 4)
+#define IOC_NET_HEADER_FIELD_PPPoE_SESSION                  (IOC_NET_HEADER_FIELD_PPPoE_VER << 5)
+#define IOC_NET_HEADER_FIELD_PPPoE_PID                      (IOC_NET_HEADER_FIELD_PPPoE_VER << 6)
+#define IOC_NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_CKSUM                   (IOC_NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_COMPRESSED              (IOC_NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_eth_t;
+
+#define IOC_NET_HEADER_FIELD_ETH_DA                         (1)
+#define IOC_NET_HEADER_FIELD_ETH_SA                         (IOC_NET_HEADER_FIELD_ETH_DA << 1)
+#define IOC_NET_HEADER_FIELD_ETH_LENGTH                     (IOC_NET_HEADER_FIELD_ETH_DA << 2)
+#define IOC_NET_HEADER_FIELD_ETH_TYPE                       (IOC_NET_HEADER_FIELD_ETH_DA << 3)
+#define IOC_NET_HEADER_FIELD_ETH_FINAL_CKSUM                (IOC_NET_HEADER_FIELD_ETH_DA << 4)
+#define IOC_NET_HEADER_FIELD_ETH_PADDING                    (IOC_NET_HEADER_FIELD_ETH_DA << 5)
+#define IOC_NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t ioc_header_field_ipv4_t;
+
+#define IOC_NET_HEADER_FIELD_IPv4_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv4_HDR_LEN                   (IOC_NET_HEADER_FIELD_IPv4_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv4_TOS                       (IOC_NET_HEADER_FIELD_IPv4_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (IOC_NET_HEADER_FIELD_IPv4_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv4_ID                        (IOC_NET_HEADER_FIELD_IPv4_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_D                    (IOC_NET_HEADER_FIELD_IPv4_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv4_FLAG_M                    (IOC_NET_HEADER_FIELD_IPv4_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv4_OFFSET                    (IOC_NET_HEADER_FIELD_IPv4_VER << 7)
+#define IOC_NET_HEADER_FIELD_IPv4_TTL                       (IOC_NET_HEADER_FIELD_IPv4_VER << 8)
+#define IOC_NET_HEADER_FIELD_IPv4_PROTO                     (IOC_NET_HEADER_FIELD_IPv4_VER << 9)
+#define IOC_NET_HEADER_FIELD_IPv4_CKSUM                     (IOC_NET_HEADER_FIELD_IPv4_VER << 10)
+#define IOC_NET_HEADER_FIELD_IPv4_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 11)
+#define IOC_NET_HEADER_FIELD_IPv4_DST_IP                    (IOC_NET_HEADER_FIELD_IPv4_VER << 12)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS                      (IOC_NET_HEADER_FIELD_IPv4_VER << 13)
+#define IOC_NET_HEADER_FIELD_IPv4_OPTS_COUNT                (IOC_NET_HEADER_FIELD_IPv4_VER << 14)
+#define IOC_NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t ioc_header_field_ipv6_t;
+
+#define IOC_NET_HEADER_FIELD_IPv6_VER                       (1)
+#define IOC_NET_HEADER_FIELD_IPv6_TC                        (IOC_NET_HEADER_FIELD_IPv6_VER << 1)
+#define IOC_NET_HEADER_FIELD_IPv6_SRC_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 2)
+#define IOC_NET_HEADER_FIELD_IPv6_DST_IP                    (IOC_NET_HEADER_FIELD_IPv6_VER << 3)
+#define IOC_NET_HEADER_FIELD_IPv6_NEXT_HDR                  (IOC_NET_HEADER_FIELD_IPv6_VER << 4)
+#define IOC_NET_HEADER_FIELD_IPv6_FL                        (IOC_NET_HEADER_FIELD_IPv6_VER << 5)
+#define IOC_NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (IOC_NET_HEADER_FIELD_IPv6_VER << 6)
+#define IOC_NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define IOC_NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ICMP_CODE                      (IOC_NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_ICMP_CKSUM                     (IOC_NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_ICMP_ID                        (IOC_NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_ICMP_SQ_NUM                    (IOC_NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define IOC_NET_HEADER_FIELD_IGMP_TYPE                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define IOC_NET_HEADER_FIELD_IGMP_CKSUM                     (IOC_NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define IOC_NET_HEADER_FIELD_IGMP_DATA                      (IOC_NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define IOC_NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t ioc_header_field_tcp_t;
+
+#define IOC_NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_TCP_PORT_DST                   (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_TCP_SEQ                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_TCP_ACK                        (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_TCP_OFFSET                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_TCP_FLAGS                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_TCP_WINDOW                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define IOC_NET_HEADER_FIELD_TCP_CKSUM                      (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define IOC_NET_HEADER_FIELD_TCP_URGPTR                     (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS                       (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define IOC_NET_HEADER_FIELD_TCP_OPTS_COUNT                 (IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define IOC_NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t ioc_header_field_sctp_t;
+
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_SCTP_PORT_DST                  (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_VER_TAG                   (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CKSUM                     (IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_dccp_t;
+
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define IOC_NET_HEADER_FIELD_DCCP_PORT_DST                  (IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_udp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define IOC_NET_HEADER_FIELD_UDP_PORT_DST                   (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_LEN                        (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_CKSUM                      (IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+typedef uint8_t ioc_header_field_udp_encap_esp_t;
+
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST         (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 1)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 2)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM            (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 3)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI              (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 4)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
+#define IOC_NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_IPHC_CID                       (1)
+#define IOC_NET_HEADER_FIELD_IPHC_CID_TYPE                  (IOC_NET_HEADER_FIELD_IPHC_CID << 1)
+#define IOC_NET_HEADER_FIELD_IPHC_HCINDEX                   (IOC_NET_HEADER_FIELD_IPHC_CID << 2)
+#define IOC_NET_HEADER_FIELD_IPHC_GEN                       (IOC_NET_HEADER_FIELD_IPHC_CID << 3)
+#define IOC_NET_HEADER_FIELD_IPHC_D_BIT                     (IOC_NET_HEADER_FIELD_IPHC_CID << 4)
+#define IOC_NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((IOC_NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv2_VERSION                 (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv2_LEN                     (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv2_SESSION_ID              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NS                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define IOC_NET_HEADER_FIELD_L2TPv2_NR                      (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define IOC_NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define IOC_NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define IOC_NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define IOC_NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ID                 (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define IOC_NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((IOC_NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t ioc_header_field_vlan_t;
+
+#define IOC_NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define IOC_NET_HEADER_FIELD_VLAN_CFI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define IOC_NET_HEADER_FIELD_VLAN_VID                       (IOC_NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define IOC_NET_HEADER_FIELD_VLAN_LENGTH                    (IOC_NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define IOC_NET_HEADER_FIELD_LLC_SSAP                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 1)
+#define IOC_NET_HEADER_FIELD_LLC_CTRL                       (IOC_NET_HEADER_FIELD_LLC_DSAP << 2)
+#define IOC_NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define IOC_NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define IOC_NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_snap_t;
+
+#define IOC_NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define IOC_NET_HEADER_FIELD_SNAP_PID                       (IOC_NET_HEADER_FIELD_SNAP_OUI << 1)
+#define IOC_NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_llc_snap_t;
+
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define IOC_NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_LLC_SNAP_TYPE << 1) - 1)
+
+#define IOC_NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define IOC_NET_HEADER_FIELD_ARP_PTYPE                      (IOC_NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define IOC_NET_HEADER_FIELD_ARP_HLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define IOC_NET_HEADER_FIELD_ARP_PLEN                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define IOC_NET_HEADER_FIELD_ARP_OPER                       (IOC_NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define IOC_NET_HEADER_FIELD_ARP_SHA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define IOC_NET_HEADER_FIELD_ARP_SPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define IOC_NET_HEADER_FIELD_ARP_THA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define IOC_NET_HEADER_FIELD_ARP_TPA                        (IOC_NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define IOC_NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define IOC_NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define IOC_NET_HEADER_FIELD_RFC2684_NLPID                  (IOC_NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define IOC_NET_HEADER_FIELD_RFC2684_OUI                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define IOC_NET_HEADER_FIELD_RFC2684_PID                    (IOC_NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_OUI                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define IOC_NET_HEADER_FIELD_RFC2684_VPN_IDX                (IOC_NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define IOC_NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_PCDID             (IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define IOC_NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((IOC_NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define IOC_NET_HEADER_FIELD_MAX_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define IOC_NET_HEADER_FIELD_MIN_FRM_SIZE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_TYPE                   (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define IOC_NET_HEADER_FIELD_FRAME_SIZE                     (IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define IOC_NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((IOC_NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t ioc_header_field_gre_t;
+
+#define IOC_NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define IOC_NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((IOC_NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_minencap_t;
+
+#define IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_DST_IP                (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define IOC_NET_HEADER_FIELD_MINENCAP_TYPE                  (IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define IOC_NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_ah_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_NH                    (IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS               ((IOC_NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_ipsec_esp_t;
+
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI                   (1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM          (IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
+#define IOC_NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS            ((IOC_NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
+
+
+typedef uint8_t ioc_header_field_mpls_t;
+
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((IOC_NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef uint8_t ioc_header_field_macsec_t;
+
+#define IOC_NET_HEADER_FIELD_MACSEC_SECTAG                  (1)
+#define IOC_NET_HEADER_FIELD_MACSEC_ALL_FIELDS              ((IOC_NET_HEADER_FIELD_MACSEC_SECTAG << 1) - 1)
+
+typedef enum {
+    e_IOC_NET_HEADER_TYPE_NONE = 0,
+    e_IOC_NET_HEADER_TYPE_PAYLOAD,
+    e_IOC_NET_HEADER_TYPE_ETH,
+    e_IOC_NET_HEADER_TYPE_VLAN,
+    e_IOC_NET_HEADER_TYPE_IPv4,
+    e_IOC_NET_HEADER_TYPE_IPv6,
+    e_IOC_NET_HEADER_TYPE_TCP,
+    e_IOC_NET_HEADER_TYPE_UDP,
+    e_IOC_NET_HEADER_TYPE_IPHC,
+    e_IOC_NET_HEADER_TYPE_SCTP,
+    e_IOC_NET_HEADER_TYPE_SCTP_CHUNK_DATA,
+    e_IOC_NET_HEADER_TYPE_PPPoE,
+    e_IOC_NET_HEADER_TYPE_PPP,
+    e_IOC_NET_HEADER_TYPE_PPPMUX,
+    e_IOC_NET_HEADER_TYPE_PPPMUX_SUBFRAME,
+    e_IOC_NET_HEADER_TYPE_L2TPv2,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_CTRL,
+    e_IOC_NET_HEADER_TYPE_L2TPv3_SESS,
+    e_IOC_NET_HEADER_TYPE_LLC,
+    e_IOC_NET_HEADER_TYPE_LLC_SNAP,
+    e_IOC_NET_HEADER_TYPE_NLPID,
+    e_IOC_NET_HEADER_TYPE_SNAP,
+    e_IOC_NET_HEADER_TYPE_MPLS,
+    e_IOC_NET_HEADER_TYPE_IPSEC_AH,
+    e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
+    e_IOC_NET_HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
+    e_IOC_NET_HEADER_TYPE_MACSEC,        /* moved */
+    e_IOC_NET_HEADER_TYPE_GRE,
+    e_IOC_NET_HEADER_TYPE_MINENCAP,
+    e_IOC_NET_HEADER_TYPE_DCCP,
+    e_IOC_NET_HEADER_TYPE_ICMP,
+    e_IOC_NET_HEADER_TYPE_IGMP,
+    e_IOC_NET_HEADER_TYPE_ARP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP,         /* new */
+    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,    /* new */
+    e_IOC_NET_HEADER_TYPE_RFC2684,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_L4,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM1,
+    e_IOC_NET_HEADER_TYPE_USER_DEFINED_SHIM2,
+    e_IOC_NET_MAX_HEADER_TYPE_COUNT
+} ioc_net_header_type;
+
+
+#endif /* __NET_IOCTLS_H */
-- 
1.7.0.4

