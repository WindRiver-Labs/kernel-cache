From ae1aafb17a330ca2ce42a205aa46d994467bd53d Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 15 Apr 2011 11:00:38 +0800
Subject: [PATCH] fsl_p4080/dpaa: fix incorrect bman release approach

The following path:
------
dpaa_eth_poll()
        |
        + dpa_bp_add_8()
{
        ......
        for (i = 0; i < 8; i++) {
                skb = dev_alloc_skb(dpa_bp->skb_size);
                if (!skb) {
                        printk(KERN_ERR "dev_alloc_skb() failed\n");
                        bm_buffer_set64(&bmb[i], 0);
                        break;
                }

                skbh = (struct sk_buff **)(skb->head + NET_IP_ALIGN);
                *skbh = skb;

                addr = dma_map_single(dpa_bp->dev, skb->head + NET_IP_ALIGN,
                                dpa_bp->size, DMA_FROM_DEVICE);

                bm_buffer_set64(&bmb[i], addr);
        }

        err = bman_release(dpa_bp->pool, bmb, i, 0);

        if (err < 0)
                bmb_free(dpa_bp, bmb);
        else
                *count_ptr += i;
}

Sometiems dev_alloc_skb() would be failed becuase of the restricted memory usage.
Especially if i = 0, there are no any appropriate bman pools we should do release.
So this introduce the kernel page exception from those incorrect approach to bman
pool.

And actually based on the original driver implementation we can avoid this issue
by enable CONFIG_FSL_BMAN_CHECKING to check if num(i) == 0 as shown as the follows:
------
bman_release(struct bman_pool *pool, const struct bm_buffer *bufs, u8 num,
                        u32 flags)
{
        if (!num || (num > 8))
                return -EINVAL;
        if (pool->params.flags & BMAN_POOL_FLAG_NO_RELEASE)
                return -EINVAL;

But:
CONFIG_FSL_BMAN_CHECKING:
        Compiles in additional checks to sanity-check the Bman driver and any
        use of it by other code. Not recommended for performance.

We always disable this option by default. So here only check if i == 0 inside of
dpa_bp_add_8() before calling bman_release() to keep the best performance.

And its unnecessary to call bmb_free() when i = 0 since addr = 0 with i = 0.
------
bmb_free()
        {
        ......
        for (i = 0; i < 8; i++) {
                dma_addr_t addr = bm_buf_addr(&bmb[i]);
                if (!addr)
                        break;

                skbh = (struct sk_buff **)bus_to_virt(addr);
                skb = *skbh;

                dma_unmap_single(bp->dev, addr, bp->size, DMA_FROM_DEVICE);

                dev_kfree_skb(skb);
        }

So we can return directly if i = 0.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/dpa/dpaa_eth.c |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/drivers/net/dpa/dpaa_eth.c b/drivers/net/dpa/dpaa_eth.c
index eb3c934..a2fb940 100644
--- a/drivers/net/dpa/dpaa_eth.c
+++ b/drivers/net/dpa/dpaa_eth.c
@@ -217,7 +217,14 @@ static void dpa_bp_add_8(struct dpa_bp *dpa_bp)
 		bm_buffer_set64(&bmb[i], addr);
 	}
 
+#ifndef CONFIG_FSL_BMAN_CHECKING
+	if (i)
+		err = bman_release(dpa_bp->pool, bmb, i, 0);
+	else
+		return;
+#else
 	err = bman_release(dpa_bp->pool, bmb, i, 0);
+#endif
 
 	if (err < 0)
 		bmb_free(dpa_bp, bmb);
-- 
1.6.5.2

