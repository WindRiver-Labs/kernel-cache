From 2b239cd3833a419d8d0fc6342c4c26c2eddafb3c Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 20 Dec 2010 10:54:33 +0800
Subject: [PATCH 06/28] PME: update PME2 subsystem

Patch taken from FSL vendor SDK 2.2.

Update pattern matching h/w support.

Modify code style.
Add qm_sg_entry_get/set64, qm_fd_addr_get/set64 and
pme_context_a_set/get64 to wrapper other functions.
Add code to support kernel macro: CONFIG_FSL_DPA_CAN_WAIT

Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/Kconfig                |    4 ++
 arch/powerpc/platforms/85xx/Kconfig |    1 +
 drivers/match/Kconfig               |    3 +-
 drivers/match/Makefile              |    1 -
 drivers/match/pme2_ctrl.c           |   71 ++++++++++++++++++++++++++---------
 drivers/match/pme2_db.c             |    4 +-
 drivers/match/pme2_high.c           |   57 ++++++++++++++++++----------
 drivers/match/pme2_low.c            |   31 ++++++---------
 drivers/match/pme2_private.h        |   29 ++++++++------
 drivers/match/pme2_regs.h           |    2 +-
 drivers/match/pme2_sample_db.c      |   21 ++++++----
 drivers/match/pme2_scan.c           |   24 +++++++-----
 drivers/match/pme2_sys.h            |    2 +-
 drivers/match/pme2_sysfs.c          |    3 +-
 drivers/match/pme2_test.h           |    2 +-
 drivers/match/pme2_test_high.c      |    2 +-
 drivers/match/pme2_test_scan.c      |   33 +++++++---------
 include/linux/fsl_pme.h             |   23 +++++++++++-
 18 files changed, 196 insertions(+), 117 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index fca8fae..ea39e55 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -748,6 +748,10 @@ config FSL_PAMU
 	help
 	  Freescale PAMU/IOMMU support
 
+config HAS_FSL_PME
+	bool
+	default n
+
 # Yes MCA RS/6000s exist but Linux-PPC does not currently support any
 config MCA
 	bool
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 71ce241..864187b 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -180,6 +180,7 @@ config P4080_DS
 	select MPC8xxx_GPIO
 	select HAS_RAPIDIO
 	select HAS_FSL_PAMU
+	select HAS_FSL_PME
 	help
 	  This option enables support for the P4080 DS board
  
diff --git a/drivers/match/Kconfig b/drivers/match/Kconfig
index e59cc8e..4ee26df 100644
--- a/drivers/match/Kconfig
+++ b/drivers/match/Kconfig
@@ -2,6 +2,7 @@ menu "Pattern matching support"
 
 menuconfig PATTERN_MATCHING
 	bool "Pattern matching h/w support"
+	depends on HAS_FSL_PME
 	default n
 	---help---
 	  Say Y here to see options for pattern matching drivers.
@@ -179,7 +180,7 @@ config FSL_PME2_TEST_SCAN
 
 config FSL_PME2_TEST_SCAN_WITH_BPID
 	bool "PME2 scan self-test with buffer pool"
-	depends on FSL_PME2_TEST_SCAN
+	depends on FSL_PME2_TEST_SCAN && FSL_BMAN_PORTAL
 	default y
 	---help---
 	  This uses a buffer pool id for scan test
diff --git a/drivers/match/Makefile b/drivers/match/Makefile
index 56aec16..d8980bd 100644
--- a/drivers/match/Makefile
+++ b/drivers/match/Makefile
@@ -3,7 +3,6 @@ obj-$(CONFIG_FSL_PME2)		+= pme2.o
 pme2-y				:= pme2_low.o
 pme2-$(CONFIG_FSL_PME2_HIGH)	+= pme2_high.o
 pme2-$(CONFIG_FSL_PME2_SAMPLE_DB) += pme2_sample_db.o
-obj-$(CONFIG_FSL_PME2_TEST_LOW)	+= pme2_test_low.o
 obj-$(CONFIG_FSL_PME2_TEST_HIGH) += pme2_test_high.o
 obj-$(CONFIG_FSL_PME2_TEST_SCAN) += pme2_test_scan.o
 obj-$(CONFIG_FSL_PME2_DB)       += pme2_db.o
diff --git a/drivers/match/pme2_ctrl.c b/drivers/match/pme2_ctrl.c
index f87519e..191588f 100644
--- a/drivers/match/pme2_ctrl.c
+++ b/drivers/match/pme2_ctrl.c
@@ -102,21 +102,12 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 		return 0;
 	}
 	pr_info("pme: Using %s property '%s'\n", node->full_name, name);
-	/* Props are 64-bit, but dma_addr_t is (currently) 32-bit */
-	BUG_ON(sizeof(*addr) != 4);
-	if(pint[2]) {
-		pr_err("pme: Invalid number of dt properties\n");
-		return -EINVAL;
-	}
-	*addr = pint[1];
-#ifdef CONFIG_PHYS_64BIT
-	*addr |= (u64)pint[0] << 32;
-#endif
+	*addr = ((u64)pint[0] << 32) | (u64)pint[1];
+	*sz = ((u64)pint[2] << 32) | (u64)pint[3];
 	if((u64)*addr & (align - 1)) {
 		pr_err("pme: Invalid alignment, address %016llx\n",(u64)*addr);
 		return -EINVAL;
 	}
-	*sz = pint[3];
 	/* Keep things simple, it's either all in the DRAM range or it's all
 	 * outside. */
 	if (*addr < lmb_end_of_DRAM()) {
@@ -172,7 +163,7 @@ __init void pme2_init_early(void)
 
 /************
  * Section 2
- ************
+ ***********
  * This code is called during driver initialisation. It doesn't do anything with
  * the device-tree entries nor the PME device, it simply creates the sysfs stuff
  * and gives the user something to hold. This could be made loadable, if there
@@ -288,7 +279,7 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 	pme_err_irq = of_irq_to_resource(nprop, 0, NULL);
 	if (unlikely(pme_err_irq == NO_IRQ))
 		dev_warn(dev, "Can't get %s property '%s'\n", nprop->full_name,
-			"interrupts");
+			 "interrupts");
 
 	/* Get configuration properties from device tree */
 	/* First, get register page */
@@ -321,7 +312,7 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 	if (likely(pme_err_irq != NO_IRQ)) {
 		/* Register the pme ISR handler */
 		err = request_irq(pme_err_irq, pme_isr, IRQF_SHARED, "pme-err",
-			dev);
+				  dev);
 		if (err) {
 			dev_err(dev, "request_irq() failed\n");
 			goto out_unmap_ctrl_region;
@@ -351,10 +342,10 @@ static int __devinit of_fsl_pme_probe(struct of_device *ofdev,
 		clkfreq = *value;
 	pme_out(global_pme, SFRCC, DIV_ROUND_UP(clkfreq, 1000000));
 
-	pme_out(global_pme, PDSRBAH, (u32)((u64)dxe_a >> 32));
-	pme_out(global_pme, PDSRBAL, (u32)dxe_a);
-	pme_out(global_pme, SCBARH, (u32)((u64)sre_a >> 32));
-	pme_out(global_pme, SCBARL, (u32)sre_a);
+	pme_out(global_pme, PDSRBAH, upper_32_bits(dxe_a));
+	pme_out(global_pme, PDSRBAL, lower_32_bits(dxe_a));
+	pme_out(global_pme, SCBARH, upper_32_bits(sre_a));
+	pme_out(global_pme, SCBARL, lower_32_bits(sre_a));
 	/* Maximum allocated index into the PDSR table available to the DXE
 	 * Rev 2.0: Max 0xF_FFFC
 	 * Rev 2.1: Max 0x7_FFFC
@@ -1176,6 +1167,50 @@ int pme_attr_get(enum pme_attr attr, u32 *val)
 		attr_val = pme_in(global_pme, SCBARL);
 		break;
 
+	case pme_attr_srrv0:
+		attr_val = pme_in(global_pme, SRRV0);
+		break;
+
+	case pme_attr_srrv1:
+		attr_val = pme_in(global_pme, SRRV1);
+		break;
+
+	case pme_attr_srrv2:
+		attr_val = pme_in(global_pme, SRRV2);
+		break;
+
+	case pme_attr_srrv3:
+		attr_val = pme_in(global_pme, SRRV3);
+		break;
+
+	case pme_attr_srrv4:
+		attr_val = pme_in(global_pme, SRRV4);
+		break;
+
+	case pme_attr_srrv5:
+		attr_val = pme_in(global_pme, SRRV5);
+		break;
+
+	case pme_attr_srrv6:
+		attr_val = pme_in(global_pme, SRRV6);
+		break;
+
+	case pme_attr_srrv7:
+		attr_val = pme_in(global_pme, SRRV7);
+		break;
+
+	case pme_attr_srrfi:
+		attr_val = pme_in(global_pme, SRRFI);
+		break;
+
+	case pme_attr_srri:
+		attr_val = pme_in(global_pme, SRRI);
+		break;
+
+	case pme_attr_srrwc:
+		attr_val = pme_in(global_pme, SRRWC);
+		break;
+
 	default:
 		pr_err("pme: Unknown attr %u\n", attr);
 		return -EINVAL;
diff --git a/drivers/match/pme2_db.c b/drivers/match/pme2_db.c
index 5652b87..b48040f 100644
--- a/drivers/match/pme2_db.c
+++ b/drivers/match/pme2_db.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -356,7 +356,7 @@ static int ioctl_sre_reset(unsigned long arg)
 	do {
 		mdelay(PME_PMFA_SRE_POLL_MS);
 		ret = pme_attr_get(pme_attr_srrr, &srrr_val);
-		if (!ret) {
+		if (ret) {
 			PMEPRCRIT("pme2: Error reading srrr\n");
 			/* bail */
 			break;
diff --git a/drivers/match/pme2_high.c b/drivers/match/pme2_high.c
index e8074b5..ad25350 100644
--- a/drivers/match/pme2_high.c
+++ b/drivers/match/pme2_high.c
@@ -228,9 +228,10 @@ done:
 }
 
 /* this code is factored out of pme_ctx_disable() and get_ctrl() */
-static int empty_pipeline(struct pme_ctx *ctx, u32 flags)
+static int empty_pipeline(struct pme_ctx *ctx, __maybe_unused u32 flags)
 {
 	int ret;
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & PME_CTX_OP_WAIT) {
 		if (flags & PME_CTX_OP_WAIT_INT) {
 			ret = -EINTR;
@@ -240,6 +241,7 @@ static int empty_pipeline(struct pme_ctx *ctx, u32 flags)
 			wait_event(ctx->queue,
 				!(ret = atomic_read(&ctx->refs)));
 	} else
+#endif
 		ret = atomic_read(&ctx->refs);
 	if (ret)
 		/* convert a +ve ref-count to a -ve error code */
@@ -482,12 +484,13 @@ EXPORT_SYMBOL(pme_ctx_reconfigure_rx);
 
 /* Helpers for 'ctrl' and 'work' APIs. These are used when the 'ctx' in question
  * is EXCLUSIVE. */
-static inline void release_exclusive(struct pme_ctx *ctx)
+static inline void release_exclusive(__maybe_unused struct pme_ctx *ctx)
 {
 	unsigned long flags;
 
 	BUG_ON(exclusive_ctx != ctx);
 	BUG_ON(!exclusive_refs);
+	
 	spin_lock_irqsave(&exclusive_lock, flags);
 	if (!(--exclusive_refs)) {
 		exclusive_ctx = NULL;
@@ -499,7 +502,7 @@ static inline void release_exclusive(struct pme_ctx *ctx)
 static int __try_exclusive(struct pme_ctx *ctx)
 {
 	int ret = 0;
-	spin_lock_irq(&exclusive_lock);
+	spin_lock(&ctx->lock);
 	if (exclusive_refs) {
 		/* exclusivity already held, continue if we're the owner */
 		if (exclusive_ctx != ctx)
@@ -512,7 +515,7 @@ static int __try_exclusive(struct pme_ctx *ctx)
 	}
 	if (!ret)
 		exclusive_refs++;
-	spin_unlock_irq(&exclusive_lock);
+	spin_unlock(&ctx->lock);
 	return ret;
 }
 /* Use this macro as the wait expression because we don't want to continue
@@ -520,9 +523,10 @@ static int __try_exclusive(struct pme_ctx *ctx)
  * (-ENODEV). */
 #define try_exclusive(ret, ctx) \
 	(!(ret = __try_exclusive(ctx)) || (ret == -ENODEV))
-static inline int get_exclusive(struct pme_ctx *ctx, u32 flags)
+static inline int get_exclusive(struct pme_ctx *ctx, __maybe_unused u32 flags)
 {
 	int ret;
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & PME_CTX_OP_WAIT) {
 		if (flags & PME_CTX_OP_WAIT_INT) {
 			ret = -EINTR;
@@ -532,15 +536,21 @@ static inline int get_exclusive(struct pme_ctx *ctx, u32 flags)
 			wait_event(exclusive_queue,
 					try_exclusive(ret, ctx));
 	} else
+#endif
 		ret = __try_exclusive(ctx);
 	return ret;
 }
+
 /* Used for 'work' APIs, convert PME->QMAN wait flags. The PME and
  * QMAN "wait" flags have been aligned so that the below conversion should
  * compile with good straight-line speed. */
 static inline u32 ctrl2eq(u32 flags)
 {
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
 	return flags & (QMAN_ENQUEUE_FLAG_WAIT | QMAN_ENQUEUE_FLAG_WAIT_INT);
+#else
+	return flags;
+#endif
 }
 
 static inline void release_work(struct pme_ctx *ctx)
@@ -564,6 +574,7 @@ static int try_work(struct pme_ctx *ctx, u32 flags)
 static int get_work(struct pme_ctx *ctx, u32 flags)
 {
 	int ret = 0;
+#ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & PME_CTX_OP_WAIT) {
 		if (flags & PME_CTX_OP_WAIT_INT) {
 			ret = -EINTR;
@@ -572,6 +583,7 @@ static int get_work(struct pme_ctx *ctx, u32 flags)
 		} else
 			wait_event(ctx->queue, !try_work(ctx, flags));
 	} else
+#endif
 		ret = try_work(ctx, flags);
 	return ret;
 }
@@ -624,6 +636,11 @@ static inline int __update_flow(struct pme_ctx *ctx, u32 flags,
 	BUG_ON(ctx->flags & PME_CTX_FLAG_DIRECT);
 	if (!hw_res)
 		return -ENOMEM;
+	token->internal_flow_ptr = pme_hw_flow_new();
+	if (!token->internal_flow_ptr) {
+		pme_hw_residue_free(hw_res);
+		return -ENOMEM;
+	}
 	token->base_token.cmd_type = pme_cmd_flow_write;
 
 	flags &= ~PME_CTX_OP_PRIVATE;
@@ -648,7 +665,6 @@ static inline int __update_flow(struct pme_ctx *ctx, u32 flags,
 		pme_hw_residue_free(hw_res);
 	/* enqueue the FCW command to PME */
 	memset(&fd, 0, sizeof(fd));
-	token->internal_flow_ptr = pme_hw_flow_new();
 	if (params)
 		memcpy(token->internal_flow_ptr, params,
 			sizeof(struct pme_flow));
@@ -676,6 +692,8 @@ int pme_ctx_ctrl_read_flow(struct pme_ctx *ctx, u32 flags,
 	/* enqueue the FCR command to PME */
 	token->usr_flow_ptr = params;
 	token->internal_flow_ptr = pme_hw_flow_new();
+	if (!token->internal_flow_ptr)
+		return -ENOMEM;
 	memset(&fd, 0, sizeof(fd));
 	pme_fd_cmd_fcr(&fd, (struct pme_flow *)token->internal_flow_ptr);
 	return do_work(ctx, flags, &fd, &token->base_token, NULL, 0);
@@ -690,15 +708,14 @@ int pme_ctx_ctrl_nop(struct pme_ctx *ctx, u32 flags,
 	token->base_token.cmd_type = pme_cmd_nop;
 	/* enqueue the NOP command to PME */
 	memset(&fd, 0, sizeof(fd));
-	fd.addr_hi = 0x00;
-	fd.addr_lo = (u32)token;
+	qm_fd_addr_set64(&fd, (u32)token);
 	pme_fd_cmd_nop(&fd);
 	return do_work(ctx, flags, &fd, &token->base_token, NULL, 0);
 }
 EXPORT_SYMBOL(pme_ctx_ctrl_nop);
 
-static inline void __prep_scan(struct pme_ctx *ctx, struct qm_fd *fd, u32 args,
-				struct pme_ctx_token *token)
+static inline void __prep_scan(__maybe_unused struct pme_ctx *ctx,
+			struct qm_fd *fd, u32 args, struct pme_ctx_token *token)
 {
 	BUG_ON(ctx->flags & PME_CTX_FLAG_PMTCC);
 	token->cmd_type = pme_cmd_scan;
@@ -755,8 +772,7 @@ EXPORT_SYMBOL(pme_ctx_exclusive_dec);
  *
  * We use pop_matching_token() to take care of the mess (inlined, of course). */
 #define MATCH(fd1,fd2) \
-	(((fd1)->addr_hi == (fd2)->addr_hi) && \
-	((fd1)->addr_lo == (fd2)->addr_lo) && \
+	((qm_fd_addr_get64(fd1) == qm_fd_addr_get64(fd2)) && \
 	((fd1)->opaque == (fd2)->opaque))
 static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 						const struct qm_fd *fd)
@@ -771,7 +787,7 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	 * The penalty of the slow-path case is the for() loop plus the fact
 	 * we're optimising for a "likely" match first time, which might hurt
 	 * when that assumption is wrong a few times in succession. */
-	spin_lock(&ctx->lock);
+	spin_lock_irq(&ctx->lock);
 	list_for_each_entry(token, &ctx->tokens, node) {
 		t_fd = (const struct qm_fd *)&token->blob[0];
 		if (likely(MATCH(t_fd, fd))) {
@@ -783,12 +799,12 @@ static inline struct pme_ctx_token *pop_matching_token(struct pme_ctx *ctx,
 	pr_err("PME2 Could not find matching token!\n");
 	BUG();
 found:
-	spin_unlock(&ctx->lock);
+	spin_unlock_irq(&ctx->lock);
 	return token;
 }
 
-static inline void cb_helper(struct qman_portal *portal, struct pme_ctx *ctx,
-				const struct qm_fd *fd, int error)
+static inline void cb_helper(__always_unused struct qman_portal *portal,
+			struct pme_ctx *ctx, const struct qm_fd *fd, int error)
 {
 	struct pme_ctx_token *token;
 	struct pme_ctx_ctrl_token *ctrl_token;
@@ -853,8 +869,8 @@ static enum qman_cb_dqrr_result cb_dqrr(struct qman_portal *portal,
 	return qman_cb_dqrr_consume;
 }
 
-static void cb_ern(struct qman_portal *portal, struct qman_fq *fq,
-				const struct qm_mr_entry *mr)
+static void cb_ern(__always_unused struct qman_portal *portal,
+		struct qman_fq *fq, const struct qm_mr_entry *mr)
 {
 	struct pme_ctx *ctx;
 	struct pme_nostash *data;
@@ -907,8 +923,9 @@ static void cb_dc_ern(struct qman_portal *portal, struct qman_fq *fq,
 	cb_helper(portal, ctx, &mr->dcern.fd, 1);
 }
 
-static void cb_fqs(struct qman_portal *portal, struct qman_fq *fq,
-				const struct qm_mr_entry *mr)
+static void cb_fqs(__always_unused struct qman_portal *portal,
+			__always_unused struct qman_fq *fq,
+			const struct qm_mr_entry *mr)
 {
 	u8 verb = mr->verb & QM_MR_VERB_TYPE_MASK;
 	if (verb == QM_MR_VERB_FQRNI)
diff --git a/drivers/match/pme2_low.c b/drivers/match/pme2_low.c
index 3d94244..aa1457b 100644
--- a/drivers/match/pme2_low.c
+++ b/drivers/match/pme2_low.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -74,6 +74,8 @@ static int pme2_low_init(void)
 	pdev = platform_device_alloc("pme", -1);
 	if (!pdev)
 		goto end;
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(40)))
+		goto end;
 	if (platform_device_add(pdev))
 		goto end;
 #ifdef CONFIG_FSL_PME2_SAMPLE_DB
@@ -187,15 +189,12 @@ void pme_initfq(struct qm_mcc_initfq *initfq, struct pme_hw_flow *flow, u8 qos,
 	initfq->fqd.dest.channel = qm_channel_pme;
 	initfq->fqd.dest.wq = qos;
 	if (flow) {
-		dma_addr_t fcp;
-		fcp = flow_map((struct pme_flow *)flow);
+		dma_addr_t fcp = flow_map((struct pme_flow *)flow);
 		pme_a->mode = pme_mode_flow;
-		pme_a->flow_hi = (u32)((u64)fcp >> 32);
-		pme_a->flow_lo = fcp;
+		pme_context_a_set64(pme_a, fcp);
 	} else {
 		pme_a->mode = pme_mode_direct;
-		pme_a->flow_hi = 0;
-		pme_a->flow_lo = 0;
+		pme_context_a_set64(pme_a, 0);
 	}
 	pme_b->rbpid = rbpid;
 	pme_b->rfqid = rfqid;
@@ -221,20 +220,15 @@ void pme_fd_cmd_fcw(struct qm_fd *fd, u8 flags, struct pme_flow *flow,
 	fcw->flags = flags;
 	if (flags & PME_CMD_FCW_RES) {
 		if (residue) {
-			dma_addr_t rptr;
-			rptr = residue_map(residue);
+			dma_addr_t rptr = residue_map(residue);
 			BUG_ON(!residue);
 			BUG_ON((unsigned long)residue & 63);
-			flow->rptr_hi = (u16)((u64)rptr >> 32);
-			flow->rptr_lo = (u32)rptr;
-		} else {
-			flow->rptr_hi = 0;
-			flow->rptr_lo = 0;
-		}
+			pme_flow_rptr_set64(flow, rptr);
+		} else
+			pme_flow_rptr_set64(flow, 0);
 	}
 	f = flow_map(flow);
-	fd->addr_hi = 0;
-	fd->addr_lo = f;
+	qm_fd_addr_set64(fd, f);
 	fd->format = qm_fd_contig;
 	fd->offset = 0;
 	fd->length20 = sizeof(*flow);
@@ -250,8 +244,7 @@ void pme_fd_cmd_fcr(struct qm_fd *fd, struct pme_flow *flow)
 	BUG_ON((unsigned long)flow & 31);
 	fcr->cmd = pme_cmd_flow_read;
 	f = flow_map(flow);
-	fd->addr_hi = 0;
-	fd->addr_lo = f;
+	qm_fd_addr_set64(fd, f);
 	fd->format = qm_fd_contig;
 	fd->offset = 0;
 	fd->length20 = sizeof(*flow);
diff --git a/drivers/match/pme2_private.h b/drivers/match/pme2_private.h
index 8db0628..50482d4 100644
--- a/drivers/match/pme2_private.h
+++ b/drivers/match/pme2_private.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,27 +46,19 @@
 
 static inline void set_fd_addr(struct qm_fd *fd, dma_addr_t addr)
 {
-	fd->addr_lo = lower_32_bits(addr);
-	fd->addr_hi = upper_32_bits(addr);
+	qm_fd_addr_set64(fd, addr);
 }
 static inline dma_addr_t get_fd_addr(const struct qm_fd *fd)
 {
-	if ((sizeof(dma_addr_t) > 4))
-		return ((fd->addr_hi << 16) << 16) | fd->addr_lo;
-	else
-		return fd->addr_lo;
+	return (dma_addr_t)qm_fd_addr_get64(fd);
 }
 static inline void set_sg_addr(struct qm_sg_entry *sg, dma_addr_t addr)
 {
-	sg->addr_lo = lower_32_bits(addr);
-	sg->addr_hi = upper_32_bits(addr);
+	qm_sg_entry_set64(sg, addr);
 }
 static inline dma_addr_t get_sg_addr(const struct qm_sg_entry *sg)
 {
-	if ((sizeof(dma_addr_t) > 4))
-		return ((sg->addr_hi << 16) << 16) | sg->addr_lo;
-	else
-		return sg->addr_lo;
+	return (dma_addr_t)qm_sg_entry_get64(sg);
 }
 
 /******************/
@@ -85,6 +77,17 @@ struct pme_context_a {
 	u16 flow_hi;
 	u32 flow_lo;
 } __packed;
+static inline u64 pme_context_a_get64(const struct pme_context_a *p)
+{
+	return ((u64)p->flow_hi << 32) | (u64)p->flow_lo;
+}
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define pme_context_a_set64(p, v) \
+	do { \
+		struct pme_context_a *__p931 = (p); \
+		__p931->flow_hi = upper_32_bits(v); \
+		__p931->flow_lo = lower_32_bits(v); \
+	} while (0)
 
 struct pme_context_b {
 	u32 rbpid:8;
diff --git a/drivers/match/pme2_regs.h b/drivers/match/pme2_regs.h
index 9fd309a..55fbba4 100644
--- a/drivers/match/pme2_regs.h
+++ b/drivers/match/pme2_regs.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/match/pme2_sample_db.c b/drivers/match/pme2_sample_db.c
index 85be14f..b7b81b1 100644
--- a/drivers/match/pme2_sample_db.c
+++ b/drivers/match/pme2_sample_db.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, 2010, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -184,7 +184,7 @@ void pme2_sample_db(void)
 		.ern = 0
 	};
 	struct qm_fd fd;
-	struct qm_sg_entry sg_table[2];
+	struct qm_sg_entry *sg_table;
 	int ret;
 	enum pme_status status;
 	struct pme_ctx_token token;
@@ -231,10 +231,10 @@ void pme2_sample_db(void)
 	/* Write the database */
 	memset(&fd, 0, sizeof(struct qm_fd));
 	mem = kmalloc(sizeof(pme_db), GFP_KERNEL);
-	memcpy(mem,pme_db, sizeof(pme_db));
+	memcpy(mem, pme_db, sizeof(pme_db));
 
 	fd.length20 = sizeof(pme_db);
-	fd.addr_lo = pme_map(mem);
+	qm_fd_addr_set64(&fd, pme_map(mem));
 
 	ret = pme_ctx_pmtcc(&ctx.base_ctx, PME_CTX_OP_WAIT, &fd, &token);
 	if (ret == -ENODEV) {
@@ -259,19 +259,23 @@ void pme2_sample_db(void)
 	/* Read back the database */
 	init_completion(&ctx.done);
 	memset(&fd, 0, sizeof(struct qm_fd));
-	memset(&sg_table, 0, sizeof(sg_table));
+	sg_table = kzalloc(2 * sizeof(*sg_table), GFP_KERNEL | GFP_DMA);
 
 	mem = kmalloc(sizeof(db_read), GFP_KERNEL);
 	memcpy(mem,db_read, sizeof(db_read));
 	mem_result = kmalloc(28, GFP_KERNEL);
+	if (!sg_table || !mem || !mem_result) {
+		pr_err("sample_db: out of memory\n");
+		goto _finish_3;
+	}
 
-	sg_table[0].addr_lo = pme_map(mem_result);
+	qm_sg_entry_set64(&sg_table[0], pme_map(mem_result));
 	sg_table[0].length = 28;
-	sg_table[1].addr_lo = pme_map(mem);
+	qm_sg_entry_set64(&sg_table[1], pme_map(mem));
 	sg_table[1].length = sizeof(db_read);
 	sg_table[1].final = 1;
 	fd.format = qm_fd_compound;
-	fd.addr_lo = pme_map(sg_table);
+	qm_fd_addr_set64(&fd, pme_map(sg_table));
 	ret = pme_ctx_pmtcc(&ctx.base_ctx, PME_CTX_OP_WAIT, &fd, &token);
 	if (ret) {
 		pr_err("sample_db: error with pmtcc\n");
@@ -302,6 +306,7 @@ void pme2_sample_db(void)
 	}
 _finish_3:
 	kfree(mem_result);
+	kfree(sg_table);
 _finish_2:
 	kfree(mem);
 	/* Disable */
diff --git a/drivers/match/pme2_scan.c b/drivers/match/pme2_scan.c
index db00d4c..b96f369 100644
--- a/drivers/match/pme2_scan.c
+++ b/drivers/match/pme2_scan.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -363,14 +363,15 @@ static int resetseq_cmd(struct file *fp, struct scan_session *session)
 		ret =  -EINVAL;
 		goto done;
 	}
-	params.seqnum_hi = 0;
-	params.seqnum_lo = 0;
+	pme_flow_seqnum_set64(&params, 0);
 	params.sos = 1;
 
 	ret = pme_ctx_ctrl_update_flow(&session->ctx, PME_CMD_FCW_SEQ, &params,
 			&ctx_ctrl.ctx_ctr);
-	if (!ret)
-		pr_info("pme2_scan: update flow error %d\n", ret);
+	if (ret) {
+		pr_err("pme2_scan: update flow error %d\n", ret);
+		return ret;
+	}
 	wait_for_completion(&ctx_ctrl.cb_done);
 	if (ctx_ctrl.ern || ctx_ctrl.cmd_status || ctx_ctrl.res_flag) {
 		PMEPRINFO("update flow err %d\n", ctx_ctrl.cmd_status);
@@ -462,7 +463,8 @@ static int process_scan_cmd(struct file *fp, struct scan_session *session,
 	/* Setup input frame */
 	token_p->tx_comp[INPUT_FRM].final = 1;
 	token_p->tx_comp[INPUT_FRM].length = token_p->tx_size;
-	token_p->tx_comp[INPUT_FRM].addr_lo = pme_map(token_p->tx_data);
+	qm_sg_entry_set64(&token_p->tx_comp[INPUT_FRM],
+			pme_map(token_p->tx_data));
 
 	/* setup output frame, if output is expected */
 	if (token_p->kernel_op.output.size) {
@@ -477,15 +479,17 @@ static int process_scan_cmd(struct file *fp, struct scan_session *session,
 		}
 		/* Setup output frame */
 		token_p->tx_comp[OUTPUT_FRM].length = token_p->rx_size;
-		token_p->tx_comp[OUTPUT_FRM].addr_lo =
-			pme_map(token_p->rx_data);
+		qm_sg_entry_set64(&token_p->tx_comp[OUTPUT_FRM],
+				pme_map(token_p->rx_data));
 		token_p->tx_fd.format = qm_fd_compound;
 		/* Build compound frame */
-		token_p->tx_fd.addr_lo = pme_map(token_p->tx_comp);
+		qm_fd_addr_set64(&token_p->tx_fd,
+				pme_map(token_p->tx_comp));
 	} else {
 		token_p->tx_fd.format = qm_fd_sg_big;
 		/* Build sg frame */
-		token_p->tx_fd.addr_lo = pme_map(&token_p->tx_comp[INPUT_FRM]);
+		qm_fd_addr_set64(&token_p->tx_fd,
+				pme_map(&token_p->tx_comp[INPUT_FRM]));
 		token_p->tx_fd.length29 = token_p->tx_size;
 	}
 
diff --git a/drivers/match/pme2_sys.h b/drivers/match/pme2_sys.h
index bda1035..62b9970 100644
--- a/drivers/match/pme2_sys.h
+++ b/drivers/match/pme2_sys.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/match/pme2_sysfs.c b/drivers/match/pme2_sysfs.c
index cafcf79..d47bc59 100644
--- a/drivers/match/pme2_sysfs.c
+++ b/drivers/match/pme2_sysfs.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -29,7 +29,6 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "pme2_sys.h"
 #include "pme2_regs.h"
 #include "pme2_private.h"
 
diff --git a/drivers/match/pme2_test.h b/drivers/match/pme2_test.h
index 34e6442..1c7d32d 100644
--- a/drivers/match/pme2_test.h
+++ b/drivers/match/pme2_test.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/match/pme2_test_high.c b/drivers/match/pme2_test_high.c
index 0ef0aa7..2baa080 100644
--- a/drivers/match/pme2_test_high.c
+++ b/drivers/match/pme2_test_high.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/match/pme2_test_scan.c b/drivers/match/pme2_test_scan.c
index 8a5d6e3..5e8d836 100644
--- a/drivers/match/pme2_test_scan.c
+++ b/drivers/match/pme2_test_scan.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -94,10 +94,7 @@ static dma_addr_t bman_buffers_phys_base;
 
 static void release_buffer(dma_addr_t addr)
 {
-	struct bm_buffer bufs_in;
-
-	memset(&bufs_in, 0, sizeof(struct bm_buffer));
-	bufs_in.lo = addr;
+	struct bm_buffer bufs_in = BM_BUFFER_INIT64(addr);
 	if (bman_release(pool, &bufs_in, 1, BMAN_RELEASE_FLAG_WAIT))
 		panic("bman_release() failed\n");
 }
@@ -165,14 +162,14 @@ void pme2_test_scan(void)
 	memset(&sg_table, 0, sizeof(sg_table));
 
 	/* build the result */
-	sg_table[0].addr_lo = pme_map(result_data);
+	qm_sg_entry_set64(&sg_table[0], pme_map(result_data));
 	sg_table[0].length = sizeof(result_data);
-	sg_table[1].addr_lo = pme_map(scan_data);
+	qm_sg_entry_set64(&sg_table[1], pme_map(scan_data));
 	sg_table[1].length = sizeof(scan_data);
 	sg_table[1].final = 1;
 
 	fd._format2 = qm_fd_compound;
-	fd.addr_lo = pme_map(sg_table);
+	qm_fd_addr_set64(&fd, pme_map(sg_table));
 
 	ret = pme_ctx_scan(&a_scan_ctx.base_ctx, 0, &fd,
 		PME_SCAN_ARGS(PME_CMD_SCAN_SR | PME_CMD_SCAN_E, 0, 0xff00),
@@ -196,7 +193,7 @@ void pme2_test_scan(void)
 	/* Build a frame descriptor */
 	memset(&fd, 0, sizeof(struct qm_fd));
 	fd.length20 = sizeof(scan_data);
-	fd.addr_lo = pme_map(scan_data);
+	qm_fd_addr_set64(&fd, pme_map(scan_data));
 
 	ret = pme_ctx_scan(&a_scan_ctx.base_ctx, 0, &fd,
 		PME_SCAN_ARGS(PME_CMD_SCAN_SR | PME_CMD_SCAN_E, 0, 0xff00),
@@ -228,12 +225,12 @@ void pme2_test_scan(void)
 
 	/* build the result */
 	/* result is all zero...use bman */
-	sg_table[1].addr_lo = pme_map(scan_data);
+	qm_sg_entry_set64(&sg_table[1], pme_map(scan_data));
 	sg_table[1].length = sizeof(scan_data);
 	sg_table[1].final = 1;
 
 	fd._format2 = qm_fd_compound;
-	fd.addr_lo = pme_map(sg_table);
+	qm_fd_addr_set64(&fd, pme_map(sg_table));
 
 	ret = pme_ctx_scan(&a_scan_ctx.base_ctx, 0, &fd,
 		PME_SCAN_ARGS(PME_CMD_SCAN_SR | PME_CMD_SCAN_E, 0, 0xff00),
@@ -247,7 +244,7 @@ void pme2_test_scan(void)
 	}
 
 	/* sg result should point to bman buffer */
-	if (!sg_table[0].addr_lo)
+	if (!qm_sg_entry_get64(&sg_table[0]))
 		BUG_ON(1);
 
 	if (memcmp(scan_result, bman_buffers_virt_base, scan_result_size)
@@ -259,7 +256,7 @@ void pme2_test_scan(void)
 		BUG_ON(1);
 	}
 
-	release_buffer(sg_table[0].addr_lo);
+	release_buffer(qm_sg_entry_get64(&sg_table[0]));
 
 	/* Disable */
 	ret = pme_ctx_disable(&a_scan_ctx.base_ctx, PME_CTX_OP_WAIT, NULL);
@@ -305,14 +302,14 @@ void pme2_test_scan(void)
 	memset(&sg_table, 0, sizeof(sg_table));
 
 	/* build the result */
-	sg_table[0].addr_lo = pme_map(result_data);
+	qm_sg_entry_set64(&sg_table[0], pme_map(result_data));
 	sg_table[0].length = sizeof(result_data);
-	sg_table[1].addr_lo = pme_map(scan_data);
+	qm_sg_entry_set64(&sg_table[1], pme_map(scan_data));
 	sg_table[1].length = sizeof(scan_data);
 	sg_table[1].final = 1;
 
 	fd._format2 = qm_fd_compound;
-	fd.addr_lo = pme_map(sg_table);
+	qm_fd_addr_set64(&fd, pme_map(sg_table));
 
 	ret = pme_ctx_scan(&a_scan_ctx.base_ctx, 0, &fd,
 		PME_SCAN_ARGS(PME_CMD_SCAN_SR | PME_CMD_SCAN_E, 0, 0xff00),
@@ -352,7 +349,7 @@ void pme2_test_scan(void)
 	memset(&fd, 0, sizeof(struct qm_fd));
 
 	fd.length20 = sizeof(scan_data);
-	fd.addr_lo = pme_map(scan_data);
+	qm_fd_addr_set64(&fd, pme_map(scan_data));
 
 	ret = pme_ctx_scan(&a_scan_ctx.base_ctx, 0, &fd,
 		PME_SCAN_ARGS(PME_CMD_SCAN_SR | PME_CMD_SCAN_E, 0, 0xff00),
@@ -419,7 +416,7 @@ static int pme2_test_scan_init(void)
 	bman_buffers_virt_base = kmalloc(1<<(bpid_size+5), GFP_KERNEL);
 	bman_buffers_phys_base = pme_map(bman_buffers_virt_base);
 	pr_info("st: virt address %p\n", bman_buffers_virt_base);
-	pr_info("st: physical address 0x%x\n", bman_buffers_phys_base);
+	pr_info("st: physical address 0x%llx\n", bman_buffers_phys_base);
 	pr_info("st: Allocate buffer of size 0x%x\n", 1<<(bpid_size+5));
 
 	release_buffer(bman_buffers_phys_base);
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index cd4db24..0acd267 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2009-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -295,6 +295,27 @@ struct pme_flow {
 	u16 mlim;
 	u32 __reserved6;
 } __packed;
+static inline u64 pme_flow_seqnum_get64(const struct pme_flow *p)
+{
+	return ((u64)p->seqnum_hi << 32) | (u64)p->seqnum_lo;
+}
+static inline u64 pme_flow_rptr_get64(const struct pme_flow *p)
+{
+	return ((u64)p->rptr_hi << 32) | (u64)p->rptr_lo;
+}
+/* Macro, so we compile better if 'v' isn't always 64-bit */
+#define pme_flow_seqnum_set64(p, v) \
+	do { \
+		struct pme_flow *__p931 = (p); \
+		__p931->seqnum_hi = upper_32_bits(v); \
+		__p931->seqnum_lo = lower_32_bits(v); \
+	} while (0)
+#define pme_flow_rptr_set64(p, v) \
+	do { \
+		struct pme_flow *__p931 = (p); \
+		__p931->rptr_hi = upper_32_bits(v); \
+		__p931->rptr_lo = lower_32_bits(v); \
+	} while (0)
 
 /* pme_ctx_ctrl_update_flow(), pme_fd_cmd_fcw() and pme_scan_params::flags
  * use these; */
-- 
1.6.5.2

