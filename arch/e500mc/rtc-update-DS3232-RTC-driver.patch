From 7510220c93220e056be34fe75119abb27df68bd2 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 28 Jun 2011 13:47:23 +0800
Subject: [PATCH 153/233] rtc: update DS3232 RTC driver

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0015-rtc-add-support-for-DS3232-RTC.patch
0016-drivers-rtc-rtc-ds3232.c-add-alarm-function.patch
0017-drivers-rtc-rtc-ds3232.c-fix-time-range-difference-b.patch

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/rtc/rtc-ds3232.c |  133 +++++++++++++++++++++++++++++++++++++--------
 1 files changed, 109 insertions(+), 24 deletions(-)

diff --git a/drivers/rtc/rtc-ds3232.c b/drivers/rtc/rtc-ds3232.c
index bb89cfd..e8e12d5 100644
--- a/drivers/rtc/rtc-ds3232.c
+++ b/drivers/rtc/rtc-ds3232.c
@@ -1,7 +1,8 @@
 /*
  * RTC client/driver for the Maxim/Dallas DS3232 Real-Time Clock over I2C
  *
- * Copyright (C) 2009-2010 Freescale Semiconductor.
+ * Copyright (C) 2009-2011 Freescale Semiconductor.
+ * Author: Jack Lan <jack.lan@freescale.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -127,6 +128,7 @@ static int ds3232_read_time(struct device *dev, struct rtc_time *time)
 	century = month & 0x80;
 
 	/* Write to rtc_time structure */
+
 	time->tm_sec = bcd2bin(second);
 	time->tm_min = bcd2bin(minute);
 	if (twelve_hr) {
@@ -139,15 +141,17 @@ static int ds3232_read_time(struct device *dev, struct rtc_time *time)
 		time->tm_hour = bcd2bin(hour);
 	}
 
-	time->tm_wday = bcd2bin(week);
+	/* Day of the week in linux range is 0~6 while 1~7 in RTC chip */
+	time->tm_wday = bcd2bin(week) - 1;
 	time->tm_mday = bcd2bin(day);
-	time->tm_mon = bcd2bin(month & 0x7F);
+	/* linux tm_mon range:0~11, while month range is 1~12 in RTC chip */
+	time->tm_mon = bcd2bin(month & 0x7F) - 1;
 	if (century)
 		add_century = 100;
 
 	time->tm_year = bcd2bin(year) + add_century;
 
-	return 0;
+	return rtc_valid_tm(time);
 }
 
 static int ds3232_set_time(struct device *dev, struct rtc_time *time)
@@ -160,9 +164,11 @@ static int ds3232_set_time(struct device *dev, struct rtc_time *time)
 	buf[0] = bin2bcd(time->tm_sec);
 	buf[1] = bin2bcd(time->tm_min);
 	buf[2] = bin2bcd(time->tm_hour);
-	buf[3] = bin2bcd(time->tm_wday); /* Day of the week */
+	/* Day of the week in linux range is 0~6 while 1~7 in RTC chip */
+	buf[3] = bin2bcd(time->tm_wday + 1);
 	buf[4] = bin2bcd(time->tm_mday); /* Date */
-	buf[5] = bin2bcd(time->tm_mon);
+	/* linux tm_mon range:0~11, while month range is 1~12 in RTC chip */
+	buf[5] = bin2bcd(time->tm_mon + 1);
 	if (time->tm_year >= 100) {
 		buf[5] |= 0x80;
 		buf[6] = bin2bcd(time->tm_year - 100);
@@ -184,18 +190,19 @@ static int ds3232_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	struct i2c_client *client = to_i2c_client(dev);
 	struct ds3232 *ds3232 = i2c_get_clientdata(client);
 	int control, stat;
-	int ret = 0;
+	int ret;
 	u8 buf[4];
 
 	mutex_lock(&ds3232->mutex);
-	stat = ret = i2c_smbus_read_byte_data(client, DS3232_REG_SR);
-	if (stat < 0)
-		goto out;
 
-	control = ret = i2c_smbus_read_byte_data(client, DS3232_REG_CR);
-	if (control < 0)
+	ret = i2c_smbus_read_byte_data(client, DS3232_REG_SR);
+	if (ret < 0)
 		goto out;
-
+	stat = ret;
+	ret = i2c_smbus_read_byte_data(client, DS3232_REG_CR);
+	if (ret < 0)
+		goto out;
+	control = ret;
 	ret = i2c_smbus_read_i2c_block_data(client, DS3232_REG_ALARM1, 4, buf);
 	if (ret < 0)
 		goto out;
@@ -213,9 +220,10 @@ static int ds3232_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 
 	alarm->enabled = !!(control & DS3232_REG_CR_A1IE);
 	alarm->pending = !!(stat & DS3232_REG_SR_A1F);
+
+	ret = 0;
 out:
 	mutex_unlock(&ds3232->mutex);
-
 	return ret;
 }
 
@@ -228,7 +236,7 @@ static int ds3232_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	struct i2c_client *client = to_i2c_client(dev);
 	struct ds3232 *ds3232 = i2c_get_clientdata(client);
 	int control, stat;
-	int ret = 0;
+	int ret;
 	u8 buf[4];
 
 	if (client->irq <= 0)
@@ -242,27 +250,26 @@ static int ds3232_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	buf[3] = bin2bcd(alarm->time.tm_mday);
 
 	/* clear alarm interrupt enable bit */
-	ret = control = i2c_smbus_read_byte_data(client, DS3232_REG_CR);
+	ret = i2c_smbus_read_byte_data(client, DS3232_REG_CR);
 	if (ret < 0)
 		goto out;
+	control = ret;
 	control &= ~(DS3232_REG_CR_A1IE | DS3232_REG_CR_A2IE);
 	ret = i2c_smbus_write_byte_data(client, DS3232_REG_CR, control);
 	if (ret < 0)
 		goto out;
 
 	/* clear any pending alarm flag */
-	stat = i2c_smbus_read_byte_data(client, DS3232_REG_SR);
-	if (stat < 0)
-		return stat;
-
+	ret = i2c_smbus_read_byte_data(client, DS3232_REG_SR);
+	if (ret < 0)
+		goto out;
+	stat = ret;
 	stat &= ~(DS3232_REG_SR_A1F | DS3232_REG_SR_A2F);
-
 	ret = i2c_smbus_write_byte_data(client, DS3232_REG_SR, stat);
 	if (ret < 0)
-		return ret;
+		goto out;
 
-	ret = i2c_smbus_write_i2c_block_data(client,
-						DS3232_REG_ALARM1, 4, buf);
+	ret = i2c_smbus_write_i2c_block_data(client, DS3232_REG_ALARM1, 4, buf);
 
 	if (alarm->enabled) {
 		control |= DS3232_REG_CR_A1IE;
@@ -273,6 +280,82 @@ out:
 	return ret;
 }
 
+static void ds3232_update_alarm(struct i2c_client *client)
+{
+	struct ds3232 *ds3232 = i2c_get_clientdata(client);
+	int control;
+	int ret;
+	u8 buf[4];
+
+	mutex_lock(&ds3232->mutex);
+
+	ret = i2c_smbus_read_i2c_block_data(client, DS3232_REG_ALARM1, 4, buf);
+	if (ret < 0)
+		goto unlock;
+
+	buf[0] = bcd2bin(buf[0]) < 0 || (ds3232->rtc->irq_data & RTC_UF) ?
+								0x80 : buf[0];
+	buf[1] = bcd2bin(buf[1]) < 0 || (ds3232->rtc->irq_data & RTC_UF) ?
+								0x80 : buf[1];
+	buf[2] = bcd2bin(buf[2]) < 0 || (ds3232->rtc->irq_data & RTC_UF) ?
+								0x80 : buf[2];
+	buf[3] = bcd2bin(buf[3]) < 0 || (ds3232->rtc->irq_data & RTC_UF) ?
+								0x80 : buf[3];
+
+	ret = i2c_smbus_write_i2c_block_data(client, DS3232_REG_ALARM1, 4, buf);
+	if (ret < 0)
+		goto unlock;
+
+	control = i2c_smbus_read_byte_data(client, DS3232_REG_CR);
+	if (control < 0)
+		goto unlock;
+
+	if (ds3232->rtc->irq_data & (RTC_AF | RTC_UF))
+		/* enable alarm1 interrupt */
+		control |= DS3232_REG_CR_A1IE;
+	else
+		/* disable alarm1 interrupt */
+		control &= ~(DS3232_REG_CR_A1IE);
+	i2c_smbus_write_byte_data(client, DS3232_REG_CR, control);
+
+unlock:
+	mutex_unlock(&ds3232->mutex);
+}
+
+static int ds3232_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ds3232 *ds3232 = i2c_get_clientdata(client);
+
+	if (client->irq <= 0)
+		return -EINVAL;
+
+	if (enabled)
+		ds3232->rtc->irq_data |= RTC_AF;
+	else
+		ds3232->rtc->irq_data &= ~RTC_AF;
+
+	ds3232_update_alarm(client);
+	return 0;
+}
+
+static int ds3232_update_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ds3232 *ds3232 = i2c_get_clientdata(client);
+
+	if (client->irq <= 0)
+		return -EINVAL;
+
+	if (enabled)
+		ds3232->rtc->irq_data |= RTC_UF;
+	else
+		ds3232->rtc->irq_data &= ~RTC_UF;
+
+	ds3232_update_alarm(client);
+	return 0;
+}
+
 static irqreturn_t ds3232_irq(int irq, void *dev_id)
 {
 	struct i2c_client *client = dev_id;
@@ -322,6 +405,8 @@ static const struct rtc_class_ops ds3232_rtc_ops = {
 	.set_time = ds3232_set_time,
 	.read_alarm = ds3232_read_alarm,
 	.set_alarm = ds3232_set_alarm,
+	.alarm_irq_enable = ds3232_alarm_irq_enable,
+	.update_irq_enable = ds3232_update_irq_enable,
 };
 
 static int __devinit ds3232_probe(struct i2c_client *client,
-- 
1.7.0.4

