From 1585f42b11797a009014ee102a677fb84c95e7d6 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 11 Nov 2009 21:26:59 -0500
Subject: [PATCH 076/252] qman: enable stashing flow-control (and corenet transaction priorities).

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Applied FSL SDK 2.0.3 patch
"kernel-2.6.30-qman-enable-stashing-flow-control-and-corene.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/hwqueue/Kconfig       |   29 +++++++++++++++++++++++++----
 drivers/hwqueue/qman_config.c |   21 ++++++++++++---------
 2 files changed, 37 insertions(+), 13 deletions(-)

diff --git a/drivers/hwqueue/Kconfig b/drivers/hwqueue/Kconfig
index 8250c22..e2593a3 100644
--- a/drivers/hwqueue/Kconfig
+++ b/drivers/hwqueue/Kconfig
@@ -28,6 +28,10 @@ config FSL_QMAN_HAVE_POLL
 	bool
 	default n
 
+config FSL_QMAN_POLL_LIMIT
+	int
+	default 32
+
 config FSL_QMAN_PORTAL_DISABLEAUTO
 	bool "disable auto-initialisation of cpu-affine portals"
 	depends on FSL_QMAN_PORTAL
@@ -64,10 +68,6 @@ config FSL_QMAN_FQRANGE
 	  provides a s/w allocator implementation that supports allocating
 	  and deallocating FQID ranges, with control over alignment.
 
-config FSL_QMAN_POLL_LIMIT
-	int
-	default 32
-
 config FSL_QMAN_CONFIG
 	bool "Qman device management"
 	default y
@@ -143,6 +143,27 @@ config FSL_QMAN_TEST_HIGH_BUG_VDQCR
 	  Certain (current) versions of the cycle-accurate model don't support
 	  VDQCR.
 
+# H/w settings that can be hard-coded for now.
+
+# Corenet initiator settings. Stash request queues are 4-deep to match cores'
+# ability to snart. Stash priority is 3, other priorities are 2.
+config FSL_QMAN_CI_SCHED_CFG_SRCCIV
+	int
+	depends on FSL_QMAN_CONFIG
+	default 4
+config FSL_QMAN_CI_SCHED_CFG_SRQ_W
+	int
+	depends on FSL_QMAN_CONFIG
+	default 3
+config FSL_QMAN_CI_SCHED_CFG_RW_W
+	int
+	depends on FSL_QMAN_CONFIG
+	default 2
+config FSL_QMAN_CI_SCHED_CFG_BMAN_W
+	int
+	depends on FSL_QMAN_CONFIG
+	default 2
+
 endif # FSL_QMAN
 
 endmenu
diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index 62f12b5..4073565 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -280,15 +280,6 @@ static void qm_set_corenet_bar(struct qman *qm, u16 eba, u32 ba)
 	qm_out(QCSP_BAR, ba);
 }
 
-static void qm_set_corenet_initiator(struct qman *qm, int write_srcciv,
-				u8 srcciv, u8 srq_w, u8 rw_w, u8 bman_w)
-{
-	qm_out(CI_SCHED_CFG, (write_srcciv ? 0x80000000 : 0x0) |
-		((srcciv & 0xf) << 24) |
-		((srq_w & 0x7) << 8) | ((rw_w & 0x7) << 4) |
-		(bman_w & 0x7));
-}
-
 static u8 qm_get_corenet_sourceid(struct qman *qm)
 {
 	return qm_in(SRCIDR);
@@ -306,6 +297,16 @@ static void qm_set_congestion_config(struct qman *qm, u16 pres)
 
 #endif
 
+static void qm_set_corenet_initiator(struct qman *qm)
+{
+	qm_out(CI_SCHED_CFG,
+		0x80000000 | /* write srcciv enable */
+		(CONFIG_FSL_QMAN_CI_SCHED_CFG_SRCCIV << 24) |
+		(CONFIG_FSL_QMAN_CI_SCHED_CFG_SRQ_W << 8) |
+		(CONFIG_FSL_QMAN_CI_SCHED_CFG_RW_W << 4) |
+		CONFIG_FSL_QMAN_CI_SCHED_CFG_BMAN_W);
+}
+
 static void qm_get_version(struct qman *qm, u16 *id, u8 *major, u8 *minor)
 {
 	u32 v = qm_in(IP_REV_1);
@@ -471,6 +472,8 @@ static int __init fsl_qman_init(struct device_node *node)
 	/* thresholds */
 	qm_set_pfdr_threshold(qm, 32, 32);
 	qm_set_sfdr_threshold(qm, 128);
+	/* corenet initiator settings */
+	qm_set_corenet_initiator(qm);
 	/* Workaround for bug 3594: "PAMU Address translation exception during
 	 * qman dqrr stashing". */
 	if (sizeof(dma_addr_t) <= sizeof(u32))
-- 
1.6.5.2

