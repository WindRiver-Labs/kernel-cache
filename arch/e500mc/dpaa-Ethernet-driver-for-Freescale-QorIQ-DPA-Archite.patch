From f919b532bfde5f54a375b7d9cbb404d607350981 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Sat, 22 Jan 2011 14:30:06 -0600
Subject: [PATCH 120/233] dpaa: Ethernet driver for Freescale QorIQ DPA Architecture

Extracted from vendor drop QorIQ-DPAA-SDK-V1-20110609-systembuilder.iso
0150-dpaa-Ethernet-driver-for-Freescale-QorIQ-DPA-Archite.patch

Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/net/Kconfig               |   41 +
 drivers/net/Makefile              |    1 +
 drivers/net/dpa/Makefile          |   18 +
 drivers/net/dpa/dpa-common.h      |  100 ++
 drivers/net/dpa/dpa-ethtool.c     |  232 ++++
 drivers/net/dpa/dpaa_eth-common.h |  153 ++
 drivers/net/dpa/dpaa_eth.c        | 2761 +++++++++++++++++++++++++++++++++++++
 drivers/net/dpa/dpaa_eth.h        |  123 ++
 drivers/net/dpa/fm-wrapper.c      |  151 ++
 drivers/net/dpa/fm-wrapper.h      |   43 +
 drivers/net/dpa/fm.c              |  360 +++++
 drivers/net/dpa/fm.h              |  117 ++
 drivers/net/dpa/fman-conf.h       | 1598 +++++++++++++++++++++
 drivers/net/dpa/mac-api.c         |  478 +++++++
 drivers/net/dpa/mac.c             |  415 ++++++
 drivers/net/dpa/mac.h             |  106 ++
 drivers/net/dpa/offline_port.c    |  325 +++++
 drivers/net/dpa/offline_port.h    |   45 +
 drivers/net/dpa/port-wrapper.c    |  300 ++++
 drivers/net/dpa/port.c            |  242 ++++
 drivers/net/dpa/port.h            |   75 +
 drivers/net/dpa/xgmac_mdio.c      |  286 ++++
 drivers/net/dpa/xgmac_mdio.h      |   61 +
 23 files changed, 8031 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/Makefile
 create mode 100644 drivers/net/dpa/dpa-common.h
 create mode 100644 drivers/net/dpa/dpa-ethtool.c
 create mode 100644 drivers/net/dpa/dpaa_eth-common.h
 create mode 100644 drivers/net/dpa/dpaa_eth.c
 create mode 100644 drivers/net/dpa/dpaa_eth.h
 create mode 100644 drivers/net/dpa/fm-wrapper.c
 create mode 100644 drivers/net/dpa/fm-wrapper.h
 create mode 100644 drivers/net/dpa/fm.c
 create mode 100644 drivers/net/dpa/fm.h
 create mode 100644 drivers/net/dpa/fman-conf.h
 create mode 100644 drivers/net/dpa/mac-api.c
 create mode 100644 drivers/net/dpa/mac.c
 create mode 100644 drivers/net/dpa/mac.h
 create mode 100644 drivers/net/dpa/offline_port.c
 create mode 100644 drivers/net/dpa/offline_port.h
 create mode 100644 drivers/net/dpa/port-wrapper.c
 create mode 100644 drivers/net/dpa/port.c
 create mode 100644 drivers/net/dpa/port.h
 create mode 100644 drivers/net/dpa/xgmac_mdio.c
 create mode 100644 drivers/net/dpa/xgmac_mdio.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2e4ff1f..15e2560 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2843,6 +2843,47 @@ config QLGE
 	  To compile this driver as a module, choose M here: the module
 	  will be called qlge.
 
+config DPA
+	tristate "Freescale Data Path Frame Manager Ethernet"
+	depends on FSL_SOC && FSL_BMAN_PORTAL && FSL_QMAN_PORTAL && FSL_QMAN_FQALLOCATOR && FSL_FMAN
+	select PHYLIB
+
+config DPA_OFFLINE_PORTS
+	bool "Offline Ports support"
+	depends on DPA
+	default y
+	help
+	  The Offline Parsing / Host Command ports (short: OH ports, of Offline ports) provide
+	  most of the functionality of the regular, online ports, except they receive their
+	  frames from a core or an accelerator on the SoC, via QMan frame queues,
+	  rather than directly from the network.
+	  Offline ports are configured via PCD (Parse-Classify-Distribute) schemes, just like
+	  any online FMan port. They deliver the processed frames to frame queues, according
+	  to the applied PCD configurations.
+
+	  Choosing this feature will not impact the functionality and/or performance of the system,
+	  so it is safe to have it.
+
+config DPA_MAX_FRM_SIZE
+	int "Maximum L2 frame size"
+	depends on DPA
+	range 64 9600
+	default "1522"
+	help
+	  Configure this in relation to the maximum possible MTU of your network configuration. In particular,
+	  one would need to increase this value in order to use jumbo frames. DPA_MAX_FRM_SIZE must accomodate
+	  the Ethernet FCS (4 bytes) and one ETH+VLAN header (18 bytes), to a total of 22 bytes in excess of
+	  the desired L3 MTU.
+
+	  Note that having too large a DPA_MAX_FRM_SIZE (much larger than the actual MTU) may lead to buffer
+	  exhaustion, especially in the case of badly fragmented datagrams on the Rx path. Conversely,
+	  having a DPA_MAX_FRM_SIZE smaller than the actual MTU will lead to frames being dropped.
+
+	  This can be overridden by specifying "fsl_fman_phy_max_frm" in the kernel bootargs:
+	    * in Hypervisor-based scenarios, by adding a "chosen" node with the "bootargs" property specifying
+              "fsl_fman_phy_max_frm=<YourValue>";
+	    * in non-Hypervisor-based scenarios, via u-boot's env, by modifying the "bootargs" env variable.
+
 source "drivers/net/sfc/Kconfig"
 
 source "drivers/net/benet/Kconfig"
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index d691b3d..3c77012 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_ATL2) += atlx/
 obj-$(CONFIG_ATL1E) += atl1e/
 obj-$(CONFIG_ATL1C) += atl1c/
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
+obj-$(if $(CONFIG_DPA),y) += dpa/
 obj-$(CONFIG_TEHUTI) += tehuti.o
 obj-$(CONFIG_ENIC) += enic/
 obj-$(CONFIG_JME) += jme.o
diff --git a/drivers/net/dpa/Makefile b/drivers/net/dpa/Makefile
new file mode 100644
index 0000000..e5d7c42
--- /dev/null
+++ b/drivers/net/dpa/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NET_DPA)
+
+#Netcomm SW tree
+obj-$(CONFIG_FSL_FMAN) += NetCommSw/
+obj-$(CONFIG_DPA) += fsl-mac.o fsl-dpa.o
+obj-$(CONFIG_DPA_OFFLINE_PORTS) += fsl-oh.o
+
+fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth.o xgmac_mdio.o
+fsl-mac-objs	:= mac.o mac-api.o
+fsl-oh-objs	:= offline_port.o
diff --git a/drivers/net/dpa/dpa-common.h b/drivers/net/dpa/dpa-common.h
new file mode 100644
index 0000000..a59ef2a
--- /dev/null
+++ b/drivers/net/dpa/dpa-common.h
@@ -0,0 +1,100 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_COMMON_H
+#define __DPA_COMMON_H
+
+#include <linux/kernel.h>	/* pr_*() */
+#include <linux/device.h>	/* dev_*() */
+#include <linux/smp.h>		/* hard_smp_processor_id() */
+#ifndef CONFIG_SMP
+#include <asm/smp.h>		/* hard_smp_processor_id() */
+#endif
+
+#define __file__ KBUILD_BASENAME".c"	/* The basename of the source file is being compiled */
+
+#define __hot
+
+#define cpu_pr_emerg(format, arg...)	\
+	pr_emerg("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_alert(format, arg...)	\
+	pr_alert("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_crit(format, arg...)	\
+	pr_crit("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_err(format, arg...)	\
+	pr_err("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_warning(format, arg...)	\
+	pr_warning("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_notice(format, arg...)	\
+	pr_notice("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_info(format, arg...)	\
+	pr_info("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_debug(format, arg...)	\
+	pr_debug("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+
+/* Keep these in sync with the dev_*() definitions from linux/device.h */
+#define cpu_dev_emerg(dev, format, arg...)	\
+	cpu_pr_emerg("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_alert(dev, format, arg...)	\
+	cpu_pr_alert("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_crit(dev, format, arg...)	\
+	cpu_pr_crit("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_err(dev, format, arg...)	\
+	cpu_pr_err("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_warn(dev, format, arg...)	\
+	cpu_pr_warning("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_notice(dev, format, arg...)	\
+	cpu_pr_notice("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_info(dev, format, arg...)	\
+	cpu_pr_info("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_dbg(dev, format, arg...)	\
+	cpu_pr_debug("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+
+#define cpu_netdev_emerg(net_dev, format, arg...)	\
+	cpu_dev_emerg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_alert(net_dev, format, arg...)	\
+	cpu_dev_alert((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_crit(net_dev, format, arg...)	\
+	cpu_dev_crit((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_err(net_dev, format, arg...)		\
+	cpu_dev_err((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_warn(net_dev, format, arg...)	\
+	cpu_dev_warn((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_notice(net_dev, format, arg...)	\
+	cpu_dev_notice((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_info(net_dev, format, arg...)	\
+	cpu_dev_info((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_dbg(net_dev, format, arg...)		\
+	cpu_dev_dbg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+
+enum {RX, TX};
+
+#endif	/* __DPA_COMMON_H */
diff --git a/drivers/net/dpa/dpa-ethtool.c b/drivers/net/dpa/dpa-ethtool.c
new file mode 100644
index 0000000..04ce5d8
--- /dev/null
+++ b/drivers/net/dpa/dpa-ethtool.c
@@ -0,0 +1,232 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/string.h>
+
+#include "dpaa_eth.h"
+
+static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (priv->mac_dev == NULL) {
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
+		return -ENODEV;
+	}
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
+		return -ENODEV;
+	}
+
+	_errno = phy_ethtool_gset(priv->mac_dev->phy_dev, et_cmd);
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "phy_ethtool_gset() = %d\n", _errno);
+
+	return _errno;
+}
+
+static int __cold dpa_set_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (priv->mac_dev == NULL) {
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
+		return -ENODEV;
+	}
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
+		return -ENODEV;
+	}
+
+	_errno = phy_ethtool_sset(priv->mac_dev->phy_dev, et_cmd);
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "phy_ethtool_sset() = %d\n", _errno);
+
+	return _errno;
+}
+
+static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_drvinfo *drvinfo)
+{
+	int		 _errno;
+
+	strncpy(drvinfo->driver, KBUILD_MODNAME,
+		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->driver)-1] = 0;
+	strncpy(drvinfo->version, VERSION,
+		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->version)-1] = 0;
+	_errno = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%X", 0);
+
+	if (unlikely(_errno >= sizeof(drvinfo->fw_version))) {	/* Truncated output */
+		cpu_netdev_notice(net_dev, "snprintf() = %d\n", _errno);
+	} else if (unlikely(_errno < 0)) {
+		cpu_netdev_warn(net_dev, "snprintf() = %d\n", _errno);
+		memset(drvinfo->fw_version, 0, sizeof(drvinfo->fw_version));
+	}
+	strncpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),
+		sizeof(drvinfo->bus_info) - 1)[sizeof(drvinfo->bus_info)-1] = 0;
+}
+
+uint32_t __cold dpa_get_msglevel(struct net_device *net_dev)
+{
+	return ((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable;
+}
+
+void __cold dpa_set_msglevel(struct net_device *net_dev, uint32_t msg_enable)
+{
+	((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable = msg_enable;
+}
+
+int __cold dpa_nway_reset(struct net_device *net_dev)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (priv->mac_dev == NULL) {
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
+		return -ENODEV;
+	}
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
+		return -ENODEV;
+	}
+
+	_errno = 0;
+	if (priv->mac_dev->phy_dev->autoneg) {
+		_errno = phy_start_aneg(priv->mac_dev->phy_dev);
+		if (unlikely(_errno < 0))
+			cpu_netdev_err(net_dev, "phy_start_aneg() = %d\n",
+					_errno);
+	}
+
+	return _errno;
+}
+
+void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringparam *et_ringparam)
+{
+	et_ringparam->rx_max_pending	   = 0;
+	et_ringparam->rx_mini_max_pending  = 0;
+	et_ringparam->rx_jumbo_max_pending = 0;
+	et_ringparam->tx_max_pending	   = 0;
+
+	et_ringparam->rx_pending	   = 0;
+	et_ringparam->rx_mini_pending	   = 0;
+	et_ringparam->rx_jumbo_pending	   = 0;
+	et_ringparam->tx_pending	   = 0;
+}
+
+void __cold dpa_get_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+{
+	struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (priv->mac_dev == NULL) {
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
+		return;
+	}
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
+		return;
+	}
+
+	et_pauseparam->autoneg	= priv->mac_dev->phy_dev->autoneg;
+}
+
+int __cold dpa_set_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+{
+	struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (priv->mac_dev == NULL) {
+		cpu_netdev_info(net_dev, "This is a MAC-less interface\n");
+		return -ENODEV;
+	}
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "phy device not initialized\n");
+		return -ENODEV;
+	}
+
+	priv->mac_dev->phy_dev->autoneg = et_pauseparam->autoneg;
+
+	return 0;
+}
+
+u32 dpa_get_rx_csum(struct net_device *dev)
+{
+	cpu_netdev_info(dev, "Can't automatically tell the status of "
+		"Rx checksum validation. Feature not available yet.\n"
+		"Rx csum validation is most commonly performed (for supported "
+		"protocols) if a PCD scheme is applied on this interface.\n");
+	return 0;
+}
+
+int dpa_set_rx_csum(struct net_device *dev, uint32_t data)
+{
+	cpu_netdev_info(dev, "Can't automatically %s Rx checksum validation."
+		"Feature not available yet.\n"
+		"Rx csum validation is most commonly performed (for supported "
+		"protocols) if a PCD scheme is applied on this interface.\n",
+		data ? "enable" : "disable");
+	return -EINVAL;
+}
+
+const struct ethtool_ops dpa_ethtool_ops __devinitconst = {
+	.get_settings		= dpa_get_settings,
+	.set_settings		= dpa_set_settings,
+	.get_drvinfo		= dpa_get_drvinfo,
+	.get_msglevel		= dpa_get_msglevel,
+	.set_msglevel		= dpa_set_msglevel,
+	.nway_reset		= dpa_nway_reset,
+	.get_link		= ethtool_op_get_link,
+	.get_ringparam		= dpa_get_ringparam,
+	.get_pauseparam		= dpa_get_pauseparam,
+	.set_pauseparam		= dpa_set_pauseparam,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+	.set_tx_csum		= ethtool_op_set_tx_ipv6_csum,
+	.get_rx_csum		= dpa_get_rx_csum,
+	.set_rx_csum		= dpa_set_rx_csum,
+	.get_sg			= ethtool_op_get_sg,
+	.set_sg			= ethtool_op_set_sg,
+	.get_tso		= ethtool_op_get_tso,
+	.set_tso		= ethtool_op_set_tso,
+	.get_ufo		= ethtool_op_get_ufo,
+	.set_ufo		= ethtool_op_set_ufo,
+	.get_flags		= ethtool_op_get_flags,
+	.set_flags		= ethtool_op_set_flags
+};
diff --git a/drivers/net/dpa/dpaa_eth-common.h b/drivers/net/dpa/dpaa_eth-common.h
new file mode 100644
index 0000000..48e2c35
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth-common.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_COMMON_H
+#define __DPA_COMMON_H
+
+#include <linux/kernel.h>	/* pr_*() */
+#include <linux/device.h>	/* dev_*() */
+#include <linux/smp.h>		/* hard_smp_processor_id() */
+
+#ifndef hard_smp_processor_id
+#define hard_smp_processor_id() smp_processor_id()
+#endif
+
+/* The basename of the source file is being compiled */
+#define __file__ KBUILD_BASENAME".c"
+
+#define __hot
+
+#define cpu_printk(level, format, arg...) \
+	pr_##level("cpu%d/%d: " format, hard_smp_processor_id(), \
+			smp_processor_id(), ##arg)
+#define cpu_pr_emerg(format, arg...)	\
+	cpu_printk(emerg, format, ##arg)
+#define cpu_pr_alert(format, arg...)	\
+	cpu_printk(alert, format, ##arg)
+#define cpu_pr_crit(format, arg...)	\
+	cpu_printk(crit, format, ##arg)
+#define cpu_pr_err(format, arg...)	\
+	cpu_printk(err, format, ##arg)
+#define cpu_pr_warning(format, arg...)	\
+	cpu_printk(warning, format, ##arg)
+#define cpu_pr_notice(format, arg...)	\
+	cpu_printk(notice, format, ##arg)
+#define cpu_pr_info(format, arg...)	\
+	cpu_printk(info, format, ##arg)
+#define cpu_pr_debug(format, arg...)	\
+	cpu_printk(debug, format, ##arg)
+
+/* Keep this in sync with the dev_*() definitions from linux/device.h */
+#define cpu_dev_printk(level, dev, format, arg...) \
+	cpu_pr_##level("%s: %s: " format, dev_driver_string(dev), \
+			dev_name(dev), ##arg)
+
+#define cpu_dev_emerg(dev, format, arg...)	\
+	cpu_dev_printk(emerg, dev, format, ##arg)
+#define cpu_dev_alert(dev, format, arg...)	\
+	cpu_dev_printk(alert, dev, format, ##arg)
+#define cpu_dev_crit(dev, format, arg...)	\
+	cpu_dev_printk(crit, dev, format, ##arg)
+#define cpu_dev_err(dev, format, arg...)	\
+	cpu_dev_printk(err, dev, format, ##arg)
+#define cpu_dev_warn(dev, format, arg...)	\
+	cpu_dev_printk(warning, dev, format, ##arg)
+#define cpu_dev_notice(dev, format, arg...)	\
+	cpu_dev_printk(notice, dev, format, ##arg)
+#define cpu_dev_info(dev, format, arg...)	\
+	cpu_dev_printk(info, dev, format, ##arg)
+#define cpu_dev_dbg(dev, format, arg...)	\
+	cpu_dev_printk(debug, dev, format, ##arg)
+
+#define dpaa_eth_printk(level, dev, format, arg...) \
+	cpu_dev_printk(level, dev, "%s:%hu:%s() " format, \
+			__file__, __LINE__, __func__, ##arg)
+
+#define dpaa_eth_emerg(dev, format, arg...)	\
+	dpaa_eth_printk(emerg, dev, format, ##arg)
+#define dpaa_eth_alert(dev, format, arg...)	\
+	dpaa_eth_printk(alert, dev, format, ##arg)
+#define dpaa_eth_crit(dev, format, arg...)	\
+	dpaa_eth_printk(crit, dev, format, ##arg)
+#define dpaa_eth_err(dev, format, arg...)	\
+	dpaa_eth_printk(err, dev, format, ##arg)
+#define dpaa_eth_warning(dev, format, arg...)	\
+	dpaa_eth_printk(warning, dev, format, ##arg)
+#define dpaa_eth_notice(dev, format, arg...)	\
+	dpaa_eth_printk(notice, dev, format, ##arg)
+#define dpaa_eth_info(dev, format, arg...)	\
+	dpaa_eth_printk(info, dev, format, ##arg)
+#define dpaa_eth_debug(dev, format, arg...)	\
+	dpaa_eth_printk(debug, dev, format, ##arg)
+
+#define cpu_netdev_emerg(net_dev, format, arg...)	\
+	dpaa_eth_emerg((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_alert(net_dev, format, arg...)	\
+	dpaa_eth_alert((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_crit(net_dev, format, arg...)	\
+	dpaa_eth_crit((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_err(net_dev, format, arg...)		\
+	dpaa_eth_err((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_warn(net_dev, format, arg...)	\
+	dpaa_eth_warning((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_notice(net_dev, format, arg...)	\
+	dpaa_eth_notice((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_info(net_dev, format, arg...)	\
+	dpaa_eth_info((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+#define cpu_netdev_dbg(net_dev, format, arg...)		\
+	dpaa_eth_debug((net_dev)->dev.parent, "%s: " format, \
+			(net_dev)->name , ##arg)
+
+enum {RX, TX};
+
+#define DPA_PRIV_DATA_SIZE 16
+#define DPA_PARSE_RESULTS_SIZE sizeof(t_FmPrsResult)
+#define DPA_HASH_RESULTS_SIZE 16
+
+#define dpaa_eth_init_port(type, port, param, errq_id, defq_id) \
+{ \
+	param.errq = errq_id; \
+	param.defq = defq_id; \
+	param.priv_data_size = DPA_PRIV_DATA_SIZE; \
+	param.parse_results = true; \
+	param.hash_results = true; \
+	fm_set_##type##_port_params(port, &param); \
+}
+
+#endif	/* __DPA_COMMON_H */
diff --git a/drivers/net/dpa/dpaa_eth.c b/drivers/net/dpa/dpaa_eth.c
new file mode 100644
index 0000000..4bbf9a0
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth.c
@@ -0,0 +1,2761 @@
+/*
+ * Copyright 2008-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sort.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>	/* arp_hdr_len() */
+#include <linux/if_vlan.h>	/* VLAN_HLEN */
+#include <linux/icmp.h>		/* struct icmphdr */
+#include <linux/ip.h>		/* struct iphdr */
+#include <linux/ipv6.h>		/* struct ipv6hdr */
+#include <linux/udp.h>		/* struct udphdr */
+#include <linux/tcp.h>		/* struct tcphdr */
+#include <linux/net.h>		/* net_ratelimit() */
+#include <linux/if_ether.h>	/* ETH_P_IP and ETH_P_IPV6 */
+#include <linux/highmem.h>
+#include <linux/percpu.h>
+#include <asm/smp.h>		/* get_hard_smp_processor_id() */
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+#include <linux/fsl_bman.h>
+
+#include "fsl_fman.h"
+#include "fm_ext.h"
+
+#include "mac.h"
+#include "dpaa_eth.h"
+
+#define ARRAY2_SIZE(arr)	(ARRAY_SIZE(arr) * ARRAY_SIZE((arr)[0]))
+
+#define DPA_NETIF_FEATURES	(NETIF_F_HW_QDISC)
+#define DEFAULT_COUNT		64
+#define DEFAULT_BUF_SIZE DPA_BP_SIZE(FSL_FMAN_PHY_MAXFRM);
+#define DPA_MAX_TX_BACKLOG	512
+#define DPA_NAPI_WEIGHT		64
+
+#define DPA_BP_REFILL (1 | (smp_processor_id() << 16))
+#define DPA_BP_FINE ((smp_processor_id() << 16))
+#define DPA_BP_REFILL_NEEDED 1
+
+/* Bootarg used to override the Kconfig DPA_MAX_FRM_SIZE value */
+#define FSL_FMAN_PHY_MAXFRM_BOOTARG	"fsl_fman_phy_max_frm"
+
+/*
+ * Values for the L3R field of the FM Parse Results
+ */
+/* L3 Type field: First IP Present IPv4 */
+#define FM_L3_PARSE_RESULT_IPV4	0x8000
+/* L3 Type field: First IP Present IPv6 */
+#define FM_L3_PARSE_RESULT_IPV6	0x4000
+
+/*
+ * Values for the L4R field of the FM Parse Results
+ */
+/* L4 Type field: UDP */
+#define FM_L4_PARSE_RESULT_UDP	0x40
+/* L4 Type field: TCP */
+#define FM_L4_PARSE_RESULT_TCP	0x20
+
+/*
+ * FD status field indicating whether the FM Parser has attempted to validate
+ * the L4 csum of the frame.
+ * Note that having this bit set doesn't necessarily imply that the checksum
+ * is valid. One would have to check the parse results to find that out.
+ */
+#define FM_FD_STAT_L4CV		0x00000004
+
+#define DPA_DESCRIPTION "FSL DPAA Ethernet driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Andy Fleming <afleming@freescale.com>");
+
+MODULE_DESCRIPTION(DPA_DESCRIPTION);
+
+static uint8_t debug = -1;
+module_param(debug, byte, S_IRUGO);
+MODULE_PARM_DESC(debug, "Module/Driver verbosity level");
+
+static uint16_t __devinitdata tx_timeout = 1000;
+module_param(tx_timeout, ushort, S_IRUGO);
+MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *dpa_debugfs_root;
+#endif
+
+/*
+ * Max frame size configurable from Kconfig or bootargs to avoid
+ * allocating oversized (socket)buffers when not using jumbo frames.
+ *
+ * Set once, at boot-time via the fsl_fman_phy_set_max_frm() callback.
+ * Initialization happens long before online_cpu_mask is even set,so it's safe
+ * not to use volatile here.
+ */
+int fsl_fman_phy_maxfrm;
+
+static const char rtx[][3] = {
+	[RX] = "RX",
+	[TX] = "TX"
+};
+
+struct dpa_fq {
+	struct qman_fq		 fq_base;
+	struct list_head	 list;
+	struct net_device	*net_dev;
+	bool			 init;
+	uint32_t fqid;
+	uint32_t flags;
+	uint16_t channel;
+	uint8_t wq;
+};
+
+/* BM */
+
+#ifdef DEBUG
+#define GFP_DPA_BP	(GFP_DMA | __GFP_ZERO | GFP_ATOMIC)
+#else
+#define GFP_DPA_BP	(GFP_DMA | GFP_ATOMIC)
+#endif
+
+#define DPA_BP_HEAD (DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
+			DPA_HASH_RESULTS_SIZE)
+#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + (s) + NET_IP_ALIGN)
+
+#define DPAA_ETH_MAX_PAD (L1_CACHE_BYTES * 8)
+
+#define FM_FD_STAT_ERRORS						\
+	(FM_PORT_FRM_ERR_DMA | FM_PORT_FRM_ERR_PHYSICAL	| \
+	 FM_PORT_FRM_ERR_SIZE | FM_PORT_FRM_ERR_CLS_DISCARD | \
+	 FM_PORT_FRM_ERR_EXTRACTION | FM_PORT_FRM_ERR_NO_SCHEME	| \
+	 FM_PORT_FRM_ERR_ILL_PLCR | FM_PORT_FRM_ERR_PRS_TIMEOUT	| \
+	 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT | FM_PORT_FRM_ERR_PRS_HDR_ERR)
+
+static struct dpa_bp *dpa_bp_array[64];
+
+static struct dpa_bp *default_pool;
+
+static struct dpa_bp *dpa_bpid2pool(int bpid)
+{
+	return dpa_bp_array[bpid];
+}
+
+static void dpa_bp_depletion(struct bman_portal	*portal,
+		struct bman_pool *pool, void *cb_ctx, int depleted)
+{
+	if (net_ratelimit())
+		pr_err("Invalid Pool depleted notification!\n");
+}
+
+static void bmb_free(struct dpa_bp *bp, struct bm_buffer *bmb)
+{
+	int i;
+	struct sk_buff **skbh;
+	struct sk_buff *skb;
+
+	for (i = 0; i < 8; i++) {
+		dma_addr_t addr = bm_buf_addr(&bmb[i]);
+		if (!addr)
+			break;
+
+		skbh = (struct sk_buff **)phys_to_virt(addr);
+		skb = *skbh;
+
+		dma_unmap_single(bp->dev, addr, bp->size, DMA_FROM_DEVICE);
+
+		dev_kfree_skb(skb);
+	}
+}
+
+static void dpa_bp_add_8(struct dpa_bp *dpa_bp)
+{
+	struct bm_buffer bmb[8];
+	struct sk_buff **skbh;
+	dma_addr_t addr;
+	int i;
+	struct sk_buff *skb;
+	int err;
+	unsigned int *count_ptr;
+
+	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+
+	for (i = 0; i < 8; i++) {
+		int pad = i * L1_CACHE_BYTES;
+
+		skb = dev_alloc_skb(dpa_bp->skb_size + pad);
+		if (unlikely(!skb)) {
+			printk(KERN_ERR "dev_alloc_skb() failed\n");
+			bm_buffer_set64(&bmb[i], 0);
+			break;
+		}
+
+		skbh = (struct sk_buff **)(skb->head + NET_IP_ALIGN + pad);
+		*skbh = skb;
+
+		addr = dma_map_single(dpa_bp->dev,
+				skb->head + NET_IP_ALIGN + pad,
+				dpa_bp->size, DMA_FROM_DEVICE);
+
+		bm_buffer_set64(&bmb[i], addr);
+	}
+
+	/* Avoid releasing a completely null buffer; bman_release() requires
+	 * at least one buf. */
+	if (likely(i)) {
+		err = bman_release(dpa_bp->pool, bmb, i, 0);
+
+		if (unlikely(err < 0))
+			bmb_free(dpa_bp, bmb);
+		else
+			*count_ptr += i;
+	}
+}
+
+static void dpa_make_private_pool(struct dpa_bp *dpa_bp)
+{
+	int i;
+
+	dpa_bp->percpu_count = __alloc_percpu(sizeof(*dpa_bp->percpu_count),
+			__alignof__(*dpa_bp->percpu_count));
+
+	dpa_bp->skb_size = dpa_bp->size;
+
+	/* Give each cpu an allotment of "count" buffers */
+	for_each_online_cpu(i) {
+		int *thiscount;
+		int *countptr;
+		int j;
+		thiscount = per_cpu_ptr(dpa_bp->percpu_count,
+				smp_processor_id());
+		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
+
+		for (j = 0; j < dpa_bp->count; j += 8)
+			dpa_bp_add_8(dpa_bp);
+
+		/* Adjust the counts */
+		*countptr = j;
+
+		if (countptr != thiscount)
+			*thiscount = *thiscount - j;
+	}
+}
+
+static int dpa_make_shared_pool(struct dpa_bp *bp)
+{
+	if (dpa_bp_array[bp->bpid]) {
+		bp->vaddr = dpa_bp_array[bp->bpid]->vaddr;
+		return 0;
+	}
+
+	devm_request_mem_region(bp->dev, bp->paddr, bp->size * bp->count,
+			KBUILD_MODNAME);
+	bp->vaddr = devm_ioremap_prot(bp->dev, bp->paddr,
+			bp->size * bp->count, 0);
+	if (bp->vaddr == NULL) {
+		cpu_pr_err("Could not map memory for pool %d\n", bp->bpid);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int __devinit __must_check __attribute__((nonnull))
+dpa_bp_alloc(struct dpa_bp *dpa_bp)
+{
+	int err;
+	struct bman_pool_params	 bp_params;
+	struct platform_device *pdev;
+
+	BUG_ON(dpa_bp->size == 0);
+	BUG_ON(dpa_bp->count == 0);
+
+	bp_params.flags = BMAN_POOL_FLAG_DEPLETION;
+	bp_params.cb = dpa_bp_depletion;
+	bp_params.cb_ctx = dpa_bp;
+
+	/* We support two options.  Either a global shared pool, or
+	 * a specified pool */
+	if (dpa_bp->kernel_pool && default_pool) {
+		atomic_inc(&default_pool->refs);
+		return 0;
+	}
+
+	if (dpa_bp->bpid == 0)
+		bp_params.flags |= BMAN_POOL_FLAG_DYNAMIC_BPID;
+	else
+		bp_params.bpid = dpa_bp->bpid;
+
+	dpa_bp->pool = bman_new_pool(&bp_params);
+	if (unlikely(dpa_bp->pool == NULL)) {
+		cpu_pr_err("bman_new_pool() failed\n");
+		return -ENODEV;
+	}
+
+	dpa_bp->bpid = bman_get_params(dpa_bp->pool)->bpid;
+
+	pdev = platform_device_register_simple("dpaa_eth_bpool",
+			dpa_bp->bpid, NULL, 0);
+	if (IS_ERR(pdev)) {
+		err = PTR_ERR(pdev);
+		goto pdev_register_failed;
+	}
+
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(40)))
+		goto pdev_mask_failed;
+
+	dpa_bp->dev = &pdev->dev;
+
+	if (dpa_bp->kernel_pool) {
+		dpa_make_private_pool(dpa_bp);
+		if (!default_pool)
+			default_pool = dpa_bp;
+	} else {
+		err = dpa_make_shared_pool(dpa_bp);
+		if (err)
+			goto make_shared_pool_failed;
+	}
+
+	if (!dpa_bp_array[dpa_bp->bpid])
+		dpa_bp_array[dpa_bp->bpid] = dpa_bp;
+
+	atomic_set(&dpa_bp->refs, 1);
+
+	return 0;
+
+make_shared_pool_failed:
+pdev_mask_failed:
+	platform_device_unregister(pdev);
+pdev_register_failed:
+	bman_free_pool(dpa_bp->pool);
+
+	return err;
+}
+
+static void __cold __attribute__((nonnull))
+_dpa_bp_free(struct dpa_bp *dpa_bp)
+{
+	uint8_t	bpid;
+
+	if (!atomic_dec_and_test(&dpa_bp->refs))
+		return;
+
+	if (dpa_bp->kernel_pool) {
+		int num;
+
+		do {
+			struct bm_buffer bmb[8];
+			int i;
+
+			num = bman_acquire(dpa_bp->pool, bmb, 8, 0);
+
+			for (i = 0; i < num; i++) {
+				dma_addr_t addr = bm_buf_addr(&bmb[i]);
+				struct sk_buff **skbh = phys_to_virt(addr);
+				struct sk_buff *skb = *skbh;
+
+				dma_unmap_single(dpa_bp->dev, addr,
+						dpa_bp->size, DMA_FROM_DEVICE);
+
+				dev_kfree_skb_any(skb);
+			}
+		} while (num == 8);
+	}
+
+	bpid = dpa_bp->bpid;
+	dpa_bp_array[bpid] = 0;
+	bman_free_pool(dpa_bp->pool);
+}
+
+static void __cold __attribute__((nonnull))
+dpa_bp_free(struct dpa_priv_s *priv, struct dpa_bp *dpa_bp)
+{
+	int i;
+
+	for (i = 0; i < priv->bp_count; i++)
+		_dpa_bp_free(&priv->dpa_bp[i]);
+}
+
+/* QM */
+
+static int __devinit __must_check __attribute__((nonnull))
+_dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qman_fq		*fq;
+	struct qm_mcc_initfq	 initfq;
+	/* Set the QMan taildrop threshold high enough to accomodate
+	 * one 64k frame, plus an extra (here, 16k) for
+	 * other frames awaiting Tx. */
+	const u32		 qman_taildrop_threshold = 0x14000;
+
+	priv = netdev_priv(dpa_fq->net_dev);
+	dev = dpa_fq->net_dev->dev.parent;
+
+	if (dpa_fq->fqid == 0)
+		dpa_fq->flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+
+	dpa_fq->init = !(dpa_fq->flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+	_errno = qman_create_fq(dpa_fq->fqid, dpa_fq->flags, &dpa_fq->fq_base);
+	if (_errno) {
+		dpaa_eth_err(dev, "qman_create_fq() failed\n");
+		return _errno;
+	}
+	fq = &dpa_fq->fq_base;
+
+	if (dpa_fq->init) {
+		initfq.we_mask = QM_INITFQ_WE_DESTWQ;
+		initfq.fqd.dest.channel	= dpa_fq->channel;
+		initfq.fqd.dest.wq = dpa_fq->wq;
+		initfq.we_mask |= QM_INITFQ_WE_TDTHRESH | QM_INITFQ_WE_FQCTRL;
+		qm_fqd_taildrop_set(&initfq.fqd.td, qman_taildrop_threshold, 1);
+		initfq.fqd.fq_ctrl = QM_FQCTRL_TDE | QM_FQCTRL_PREFERINCACHE;
+		if (dpa_fq->flags & QMAN_FQ_FLAG_NO_ENQUEUE) {
+			initfq.we_mask |= QM_INITFQ_WE_CONTEXTA;
+			initfq.fqd.fq_ctrl |=
+				QM_FQCTRL_CTXASTASHING | QM_FQCTRL_AVOIDBLOCK;
+			initfq.fqd.context_a.stashing.exclusive =
+				QM_STASHING_EXCL_DATA | QM_STASHING_EXCL_CTX |
+				QM_STASHING_EXCL_ANNOTATION;
+			initfq.fqd.context_a.stashing.data_cl = 2;
+			initfq.fqd.context_a.stashing.annotation_cl = 1;
+			initfq.fqd.context_a.stashing.context_cl =
+				DIV_ROUND_UP(sizeof(struct qman_fq), 64);
+		};
+
+		_errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+		if (_errno < 0) {
+			dpaa_eth_err(dev, "qman_init_fq(%u) = %d\n",
+					qman_fq_fqid(fq), _errno);
+			qman_destroy_fq(fq, 0);
+			return _errno;
+		}
+	}
+
+	dpa_fq->fqid = qman_fq_fqid(fq);
+	list_add_tail(&dpa_fq->list, list);
+
+	return 0;
+}
+
+static int __cold __attribute__((nonnull))
+_dpa_fq_free(struct device *dev, struct qman_fq *fq)
+{
+	int			 _errno, __errno;
+	struct dpa_fq		*dpa_fq;
+	const struct dpa_priv_s	*priv;
+
+	_errno = 0;
+
+	dpa_fq = container_of(fq, struct dpa_fq, fq_base);
+	priv = netdev_priv(dpa_fq->net_dev);
+
+	if (dpa_fq->init) {
+		_errno = qman_retire_fq(fq, NULL);
+		if (unlikely(_errno < 0) && netif_msg_drv(priv))
+			dpaa_eth_err(dev, "qman_retire_fq(%u) = %d\n",
+					qman_fq_fqid(fq), _errno);
+
+		__errno = qman_oos_fq(fq);
+		if (unlikely(__errno < 0) && netif_msg_drv(priv)) {
+			dpaa_eth_err(dev, "qman_oos_fq(%u) = %d\n",
+					qman_fq_fqid(fq), __errno);
+			if (_errno >= 0)
+				_errno = __errno;
+		}
+	}
+
+	qman_destroy_fq(fq, 0);
+	list_del(&dpa_fq->list);
+
+	return _errno;
+}
+
+static int __cold __attribute__((nonnull))
+dpa_fq_free(struct device *dev, struct list_head *list)
+{
+	int		 _errno, __errno;
+	struct dpa_fq	*dpa_fq, *tmp;
+
+	_errno = 0;
+	list_for_each_entry_safe(dpa_fq, tmp, list, list) {
+		__errno = _dpa_fq_free(dev, (struct qman_fq *)dpa_fq);
+		if (unlikely(__errno < 0) && _errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_length(const struct qm_fd *fd)
+{
+	return fd->length20;
+}
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_offset(const struct qm_fd *fd)
+{
+	return fd->offset;
+}
+
+static int __must_check __attribute__((nonnull))
+dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
+{
+	int				 _errno, __errno, i, j;
+	const struct dpa_priv_s		*priv;
+	const struct qm_sg_entry	*sgt;
+	struct dpa_bp		*_dpa_bp, *dpa_bp;
+	struct bm_buffer		 _bmb, bmb[8];
+
+	priv = netdev_priv(net_dev);
+
+	_bmb.hi	= fd->addr_hi;
+	_bmb.lo	= fd->addr_lo;
+
+	_dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(_dpa_bp));
+
+	_errno = 0;
+	if (fd->format == qm_fd_sg) {
+		sgt = (phys_to_virt(bm_buf_addr(&_bmb)) + dpa_fd_offset(fd));
+
+		i = 0;
+		do {
+			dpa_bp = dpa_bpid2pool(sgt[i].bpid);
+			BUG_ON(IS_ERR(dpa_bp));
+
+			j = 0;
+			do {
+				BUG_ON(sgt[i].extension);
+
+				bmb[j].hi	= sgt[i].addr_hi;
+				bmb[j].lo	= sgt[i].addr_lo;
+				j++; i++;
+			} while (j < ARRAY_SIZE(bmb) &&
+					!sgt[i-1].final &&
+					sgt[i-1].bpid == sgt[i].bpid);
+
+			__errno = bman_release(dpa_bp->pool, bmb, j, 0);
+			if (unlikely(__errno < 0)) {
+				if (netif_msg_drv(priv) && net_ratelimit())
+					cpu_netdev_err(net_dev,
+						"bman_release(%hu) = %d\n",
+						dpa_bp->bpid, _errno);
+				if (_errno >= 0)
+					_errno = __errno;
+			}
+		} while (!sgt[i-1].final);
+	}
+
+	__errno = bman_release(_dpa_bp->pool, &_bmb, 1, 0);
+	if (unlikely(__errno < 0)) {
+		if (netif_msg_drv(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "bman_release(%hu) = %d\n",
+					_dpa_bp->bpid, __errno);
+		if (_errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+/* net_device */
+
+#define NN_ALLOCATED_SPACE(net_dev) \
+		max((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+#define NN_RESERVED_SPACE(net_dev) \
+		min((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+
+#define TT_ALLOCATED_SPACE(net_dev) \
+	max(sizeof(struct icmphdr), max(sizeof(struct udphdr), \
+		sizeof(struct tcphdr)))
+#define TT_RESERVED_SPACE(net_dev) \
+	min(sizeof(struct icmphdr), min(sizeof(struct udphdr), \
+		sizeof(struct tcphdr)))
+
+static struct net_device_stats * __cold
+dpa_get_stats(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	unsigned long *netstats;
+	unsigned long *cpustats;
+	int i, j;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	int numstats = sizeof(net_dev->stats) / sizeof(unsigned long);
+
+	netstats = (unsigned long *)&net_dev->stats;
+
+	memset(netstats, 0, sizeof(net_dev->stats));
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+
+		cpustats = (unsigned long *)&percpu_priv->stats;
+
+		for (j = 0; j < numstats; j++)
+			netstats[j] += cpustats[j];
+	}
+
+	return &net_dev->stats;
+}
+
+static int dpa_change_mtu(struct net_device *net_dev, int new_mtu)
+{
+	const struct dpa_priv_s *priv;
+	const int max_mtu = FSL_FMAN_PHY_MAXFRM - (VLAN_ETH_HLEN + ETH_FCS_LEN);
+	const int min_mtu = 64;
+
+	priv = netdev_priv(net_dev);
+
+	/* Make sure we don't exceed the Ethernet controller's MAXFRM */
+	if (new_mtu < min_mtu || new_mtu > max_mtu) {
+		cpu_netdev_err(net_dev, "Invalid L3 mtu %d "
+				"(must be between %d and %d).\n",
+				new_mtu, min_mtu, max_mtu);
+		return -EINVAL;
+	}
+	net_dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static int dpa_set_mac_address(struct net_device *net_dev, void *addr)
+{
+	const struct dpa_priv_s	*priv;
+	int			 _errno;
+
+	priv = netdev_priv(net_dev);
+
+	_errno = eth_mac_addr(net_dev, addr);
+	if (_errno < 0) {
+		if (netif_msg_drv(priv))
+			cpu_netdev_err(net_dev,
+				       "eth_mac_addr() = %d\n",
+				       _errno);
+		return _errno;
+	}
+
+	if (!priv->mac_dev)
+		/* MAC-less interface, so nothing more to do here */
+		return 0;
+
+	_errno = priv->mac_dev->change_addr(priv->mac_dev, net_dev->dev_addr);
+	if (_errno < 0) {
+		if (netif_msg_drv(priv))
+			cpu_netdev_err(net_dev,
+				       "mac_dev->change_addr() = %d\n",
+				       _errno);
+		return _errno;
+	}
+
+	return 0;
+}
+
+static void __cold dpa_change_rx_flags(struct net_device *net_dev, int flags)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (!priv->mac_dev)
+		return;
+
+	if ((flags & IFF_PROMISC) != 0) {
+		_errno = priv->mac_dev->change_promisc(priv->mac_dev);
+		if (unlikely(_errno < 0) && netif_msg_drv(priv))
+			cpu_netdev_err(net_dev,
+				       "mac_dev->change_promisc() = %d\n",
+				       _errno);
+	}
+}
+
+static void dpa_set_multicast_list(struct net_device *net_dev)
+{
+	int _errno;
+	struct dpa_priv_s *priv;
+
+	priv = netdev_priv(net_dev);
+
+	if (!priv->mac_dev) {
+		if (netif_msg_drv(priv))
+			cpu_netdev_warn(net_dev,
+					"%s() called on MAC-less interface\n",
+					__func__);
+		return;
+	}
+
+	_errno = priv->mac_dev->set_multi(net_dev);
+	if ((_errno < 0) && netif_msg_drv(priv))
+		cpu_netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
+}
+
+/*
+ * When we put the buffer into the pool, we purposefully added
+ * some padding to the address so that the buffers wouldn't all
+ * be page-aligned. But the skb has been reset to a default state,
+ * so it is pointing up to DPAA_ETH_MAX_PAD - L1_CACHE_BYTES bytes
+ * before the actual data. We subtract skb->head from the fd addr,
+ * and then mask off the translated part to get the actual distance.
+ */
+static int dpa_process_one(struct dpa_percpu_priv_s *percpu_priv,
+		struct sk_buff *skb, struct dpa_bp *bp, const struct qm_fd *fd)
+{
+	int *countptr;
+	int cache_fudge = (fd->addr_lo - (u32)skb->head) & (PAGE_SIZE - 1);
+	int data_start;
+
+	countptr = per_cpu_ptr(bp->percpu_count, smp_processor_id());
+
+	(*countptr)--;
+
+	/*
+	 * The skb is currently pointed at head + NET_SKB_PAD. The packet
+	 * starts at skb->head + cache_fudge + fd offset.
+	 */
+	data_start = cache_fudge + dpa_fd_offset(fd) - NET_SKB_PAD;
+	skb_put(skb, dpa_fd_length(fd) + data_start);
+	skb_pull(skb, data_start);
+
+	dma_unmap_single(bp->dev, qm_fd_addr(fd), bp->size, DMA_FROM_DEVICE);
+
+	return 0;
+}
+
+static void _dpa_rx_error(struct net_device *net_dev,
+		const struct dpa_priv_s	*priv,
+		struct dpa_percpu_priv_s *percpu_priv,
+		const struct qm_fd *fd)
+{
+	int _errno;
+
+	if (netif_msg_hw(priv) && net_ratelimit())
+		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+				fd->status & FM_FD_STAT_ERRORS);
+
+	percpu_priv->stats.rx_errors++;
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += dpa_fd_length(fd);
+
+	_errno = dpa_fd_release(net_dev, fd);
+	if (unlikely(_errno < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+}
+
+static void _dpa_tx_error(struct net_device		*net_dev,
+			  const struct dpa_priv_s	*priv,
+			  struct dpa_percpu_priv_s	*percpu_priv,
+			  const struct qm_fd		*fd)
+{
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	dma_addr_t addr = qm_fd_addr(fd);
+	struct dpa_bp *bp = priv->dpa_bp;
+
+	if (netif_msg_hw(priv) && net_ratelimit())
+		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+				fd->status & FM_FD_STAT_ERRORS);
+
+	percpu_priv->stats.tx_errors++;
+
+	skbh = (struct sk_buff **)phys_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb(skb);
+}
+
+static void __hot _dpa_rx(struct net_device *net_dev,
+		const struct dpa_priv_s *priv,
+		struct dpa_percpu_priv_s *percpu_priv,
+		const struct qm_fd *fd)
+{
+	int _errno;
+	int *countptr;
+	struct dpa_bp *dpa_bp;
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	dma_addr_t addr = qm_fd_addr(fd);
+
+	skbh = (struct sk_buff **)phys_to_virt(addr);
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.rx_errors++;
+
+		goto _return_dpa_fd_release;
+	}
+
+	if (unlikely(fd->format != qm_fd_contig)) {
+		percpu_priv->stats.rx_dropped++;
+		if (netif_msg_rx_status(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "Dropping a SG frame\n");
+		goto _return_dpa_fd_release;
+	}
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+
+	skb = *skbh;
+	prefetch(skb);
+
+	/* Fill the SKB */
+	dpa_process_one(percpu_priv, skb, dpa_bp, fd);
+
+	prefetch(skb_shinfo(skb));
+
+	skb->protocol = eth_type_trans(skb, net_dev);
+
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += skb->len;
+
+	if (unlikely(skb->len > net_dev->mtu)) {
+		if ((skb->protocol != ETH_P_8021Q) ||
+				(skb->len > net_dev->mtu + 4)) {
+			percpu_priv->stats.rx_dropped++;
+			goto drop_large_frame;
+		}
+	}
+
+	/* Check if the FMan Parser has already validated the L4 csum.
+	 * Note: This bit always reads 0 on Rev1 silicon, so the csum
+	 * validation will implicitly be done in software. */
+	if (fd->status & FM_FD_STAT_L4CV) {
+		/* If we're here, the csum must be valid (if it hadn't,
+		 * the frame would have been received on the Error FQ,
+		 * respectively on the _dpa_rx_error() path). */
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	} else
+		skb->ip_summed = CHECKSUM_NONE;
+
+	if (unlikely(netif_receive_skb(skb) == NET_RX_DROP))
+		percpu_priv->stats.rx_dropped++;
+
+	net_dev->last_rx = jiffies;
+
+	return;
+
+drop_large_frame:
+	countptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	(*countptr)++;
+	skb_recycle(skb);
+_return_dpa_fd_release:
+	_errno = dpa_fd_release(net_dev, fd);
+	if (unlikely(_errno < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+}
+
+static void dpaa_eth_napi_disable(struct dpa_priv_s *priv)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int i;
+
+	if (priv->shared)
+		return;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		napi_disable(&percpu_priv->napi);
+	}
+}
+
+static void dpaa_eth_napi_enable(struct dpa_priv_s *priv)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int i;
+
+	if (priv->shared)
+		return;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		napi_enable(&percpu_priv->napi);
+	}
+}
+
+static int dpaa_eth_poll(struct napi_struct *napi, int budget)
+{
+	struct dpa_percpu_priv_s *percpu_priv;
+	int cleaned = qman_poll_dqrr(budget);
+	int *countptr;
+
+	percpu_priv = container_of(napi, struct dpa_percpu_priv_s, napi);
+
+	countptr = per_cpu_ptr(percpu_priv->dpa_bp->percpu_count,
+				smp_processor_id());
+
+	if (*countptr < DEFAULT_COUNT / 4) {
+		int i;
+
+		for (i = 0; i < percpu_priv->dpa_bp->count; i += 8)
+			dpa_bp_add_8(percpu_priv->dpa_bp);
+	}
+
+	if (cleaned < budget) {
+		int tmp;
+		napi_complete(napi);
+		tmp = qman_irqsource_add(QM_PIRQ_DQRI);
+		BUG_ON(tmp);
+	}
+
+	return cleaned;
+}
+
+static void __hot _dpa_tx(struct net_device		*net_dev,
+			  const struct dpa_priv_s	*priv,
+			  struct dpa_percpu_priv_s	*percpu_priv,
+			  const struct qm_fd		*fd)
+{
+	struct sk_buff **skbh;
+	struct sk_buff	*skb;
+	dma_addr_t addr = qm_fd_addr(fd);
+	struct dpa_bp *bp = priv->dpa_bp;
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.tx_errors++;
+	}
+
+	skbh = (struct sk_buff **)phys_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb(skb);
+}
+
+static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
+{
+	int i;
+
+	for (i = 0; i < priv->bp_count; i++)
+		if (DPA_BP_SIZE(size) <= priv->dpa_bp[i].size)
+			return &priv->dpa_bp[i];
+	return ERR_PTR(-ENODEV);
+}
+
+static inline void * __must_check __attribute__((nonnull))
+dpa_phys2virt(const struct dpa_bp *dpa_bp, dma_addr_t addr)
+{
+	return dpa_bp->vaddr + (addr - dpa_bp->paddr);
+}
+
+/**
+ * Turn on HW checksum computation for this outgoing frame.
+ * If the current protocol is not something we support in this regard
+ * (or if the stack has already computed the SW checksum), we do nothing.
+ *
+ * Returns 0 if all goes well (or HW csum doesn't apply), and a negative value
+ * otherwise.
+ *
+ * Note that this function may modify the fd->cmd field and the skb data buffer
+ * (the Parse Results area).
+ */
+static inline int dpa_enable_tx_csum(struct dpa_priv_s *dpa_priv,
+	struct sk_buff *skb, struct qm_fd *fd, char *parse_results)
+{
+	t_FmPrsResult *parse_result = NULL;
+	struct iphdr *iph = NULL;
+	struct ipv6hdr *ipv6h = NULL;
+	int l4_proto;
+	int retval = 0;
+
+	if (!dpa_priv->mac_dev || skb->ip_summed != CHECKSUM_PARTIAL)
+		return 0;
+
+	/* Note: L3 csum seems to be already computed in sw, but we can't choose
+	 * L4 alone from the FM configuration anyway. */
+
+	/* Fill in some fields of the Parse Results array, so the FMan
+	 * can find them as if they came from the FMan Parser. */
+	parse_result = (t_FmPrsResult *)parse_results;
+
+	/* Fill in the relevant L3 parse result fields
+	 * and read the L4 protocol type */
+	switch (ntohs(skb->protocol)) {
+	case ETH_P_IP:
+		parse_result->l3r = FM_L3_PARSE_RESULT_IPV4;
+		iph = ip_hdr(skb);
+		BUG_ON(iph == NULL);
+		l4_proto = ntohs(iph->protocol);
+		break;
+	case ETH_P_IPV6:
+		parse_result->l3r = FM_L3_PARSE_RESULT_IPV6;
+		ipv6h = ipv6_hdr(skb);
+		BUG_ON(ipv6h == NULL);
+		l4_proto = ntohs(ipv6h->nexthdr);
+		break;
+	default:
+		/* We shouldn't even be here */
+		if (netif_msg_tx_err(dpa_priv) && net_ratelimit())
+			printk(KERN_ALERT
+				"%s:%hu:%s(): can't compute HW csum "
+				"for L3 proto 0x%x\n",
+				__file__, __LINE__, __func__,
+				ntohs(skb->protocol));
+		retval = -EIO;
+		goto return_error;
+	}
+
+	/* Fill in the relevant L4 parse result fields */
+	switch (l4_proto) {
+	case IPPROTO_UDP:
+		parse_result->l4r = FM_L4_PARSE_RESULT_UDP;
+		break;
+	case IPPROTO_TCP:
+		parse_result->l4r = FM_L4_PARSE_RESULT_TCP;
+		break;
+	default:
+		/* This can as well be a BUG() */
+		if (netif_msg_tx_err(dpa_priv) && net_ratelimit())
+			printk(KERN_ALERT
+				"%s:%hu:%s(): can't compute HW csum "
+				"for L4 proto 0x%x\n",
+				__file__, __LINE__, __func__, l4_proto);
+		retval = -EIO;
+		goto return_error;
+	}
+
+	/* - Can't assume the MAC header was either set, or zeroed.
+	 * - skb->data always starts with the MAC header. */
+	skb_set_mac_header(skb, 0);
+
+	/* At index 0 is IPOffset_1 as defined in the Parse Results */
+	parse_result->ip_off[0] = skb_network_header(skb) -
+		skb_mac_header(skb);
+	parse_result->l4_off = skb_transport_header(skb) -
+		skb_mac_header(skb);
+
+	/* Enable L3 (and L4, if TCP or UDP) HW checksum. */
+	fd->cmd |= FM_FD_CMD_RPD | FM_FD_CMD_DTC;
+
+return_error:
+	return retval;
+}
+
+static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
+			struct dpa_percpu_priv_s *percpu, int queue,
+			struct qm_fd *fd)
+{
+	int err;
+
+	prefetchw(&percpu->start_tx);
+	err = qman_enqueue(priv->egress_fqs[queue], fd, 0);
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(priv->net_dev, "qman_enqueue() = %d\n",
+					err);
+		percpu->stats.tx_errors++;
+		percpu->stats.tx_fifo_errors++;
+		return err;
+	}
+
+	percpu->stats.tx_packets++;
+	percpu->stats.tx_bytes += dpa_fd_length(fd);
+
+	return NETDEV_TX_OK;
+}
+
+static int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct dpa_bp *dpa_bp;
+	struct bm_buffer bmb;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct dpa_priv_s *priv;
+	struct device *dev;
+	struct qm_fd fd;
+	int queue_mapping;
+	int err;
+	void *dpa_bp_vaddr;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	dev = net_dev->dev.parent;
+
+	memset(&fd, 0, sizeof(fd));
+	fd.format = qm_fd_contig;
+
+	queue_mapping = skb_get_queue_mapping(skb);
+
+	dpa_bp = dpa_size2pool(priv, skb_headlen(skb));
+	if (unlikely(IS_ERR(dpa_bp))) {
+		err = PTR_ERR(dpa_bp);
+		goto bpools_too_small_error;
+	}
+
+	err = bman_acquire(dpa_bp->pool, &bmb, 1, 0);
+	if (unlikely(err <= 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "bman_acquire() = %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		if (err == 0)
+			err = -ENOMEM;
+		goto buf_acquire_failed;
+	}
+	fd.bpid = dpa_bp->bpid;
+
+	fd.length20 = skb_headlen(skb);
+	fd.cmd = FM_FD_CMD_FCO;
+	fd.addr_hi = bmb.hi;
+	fd.addr_lo = bmb.lo;
+	fd.offset = DPA_BP_HEAD + NET_IP_ALIGN;
+
+	dpa_bp_vaddr = dpa_phys2virt(dpa_bp, bm_buf_addr(&bmb));
+
+	/* Copy the packet payload */
+	skb_copy_from_linear_data(skb, dpa_bp_vaddr + dpa_fd_offset(&fd),
+		dpa_fd_length(&fd));
+
+	/* Enable L3/L4 hardware checksum computation, if applicable */
+	err = dpa_enable_tx_csum(priv, skb, &fd,
+		dpa_bp_vaddr + DPA_PRIV_DATA_SIZE);
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "Tx HW csum error: %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		goto l3_l4_csum_failed;
+	}
+
+	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+
+l3_l4_csum_failed:
+bpools_too_small_error:
+buf_acquire_failed:
+	/* We're done with the skb */
+	dev_kfree_skb(skb);
+
+	return err;
+}
+
+static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qm_fd		 fd;
+	unsigned int	headroom;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct sk_buff **skbh;
+	dma_addr_t addr;
+	struct dpa_bp *dpa_bp;
+	int queue_mapping;
+	int *countptr;
+	int err;
+	int cache_fudge;
+	int needed_headroom;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	dev = net_dev->dev.parent;
+
+	memset(&fd, 0, sizeof(fd));
+	fd.format = qm_fd_contig;
+
+	headroom = skb_headroom(skb);
+	queue_mapping = skb_get_queue_mapping(skb);
+
+	needed_headroom = (DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE +
+				NET_IP_ALIGN + sizeof(skbh));
+
+	if (headroom < needed_headroom) {
+		struct sk_buff *skb_new;
+
+		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
+		if (!skb_new) {
+			percpu_priv->stats.tx_errors++;
+			kfree_skb(skb);
+			return NETDEV_TX_OK;
+		}
+		kfree_skb(skb);
+		skb = skb_new;
+		headroom = skb_headroom(skb);
+	}
+
+	if (skb_cloned(skb))
+		skb = skb_unshare(skb, GFP_ATOMIC);
+
+	cache_fudge = round_down(headroom - needed_headroom, L1_CACHE_BYTES);
+
+	skbh = (struct sk_buff **)(skb->head + NET_IP_ALIGN + cache_fudge);
+	*skbh = skb;
+
+	dpa_bp = priv->dpa_bp;
+
+	countptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+
+	/* Enable L3/L4 hardware checksum computation.
+	 *
+	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may
+	 * need to write into the skb. */
+	err = dpa_enable_tx_csum(priv, skb, &fd,
+			((char *)skbh) + DPA_PRIV_DATA_SIZE);
+
+	if (unlikely(err < 0)) {
+		if (netif_msg_tx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "HW csum error: %d\n", err);
+		percpu_priv->stats.tx_errors++;
+		goto l3_l4_csum_failed;
+	}
+
+	addr = dma_map_single(dpa_bp->dev, skbh, dpa_bp->size, DMA_TO_DEVICE);
+	if (unlikely(addr == 0)) {
+		if (netif_msg_tx_err(priv)  && net_ratelimit())
+			cpu_netdev_err(net_dev, "dma_map_single() failed\n");
+		err = -EIO;
+		goto dma_map_failed;
+	}
+
+	fd.addr_hi = upper_32_bits(addr);
+	fd.addr_lo = lower_32_bits(addr);
+	fd.length20 = skb->len;
+	fd.offset = headroom - (NET_IP_ALIGN + cache_fudge);
+
+	if (likely(skb_is_recycleable(skb, dpa_bp->skb_size)
+			&& (*countptr + 1 <= dpa_bp->count))) {
+		fd.cmd |= FM_FD_CMD_FCO;
+		fd.bpid = dpa_bp->bpid;
+		skb_recycle(skb);
+		skb = NULL;
+		(*countptr)++;
+		percpu_priv->tx_returned++;
+	}
+
+	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+
+	if (unlikely(err < 0)) {
+		if (fd.cmd & FM_FD_CMD_FCO)
+			(*countptr)--;
+		goto xmit_failed;
+	}
+
+	net_dev->trans_start = jiffies;
+
+	return NETDEV_TX_OK;
+
+xmit_failed:
+	dma_unmap_single(dev, addr, dpa_bp->size, DMA_TO_DEVICE);
+l3_l4_csum_failed:
+dma_map_failed:
+	if (skb)
+		dev_kfree_skb(skb);
+
+	return err;
+}
+
+static enum qman_cb_dqrr_result
+ingress_rx_error_dqrr(struct qman_portal		*portal,
+		      struct qman_fq			*fq,
+		      const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_rx_error(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result __hot
+shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
+		const struct qm_dqrr_entry *dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	int err;
+	const struct qm_fd *fd = &dq->fd;
+	struct dpa_bp *dpa_bp;
+	size_t size;
+	struct sk_buff *skb;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.rx_errors++;
+
+		goto out;
+	}
+
+	percpu_priv->stats.rx_packets++;
+	percpu_priv->stats.rx_bytes += dpa_fd_length(fd);
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(dpa_bp));
+
+	if (fd->format == qm_fd_sg) {
+		percpu_priv->stats.rx_dropped++;
+		if (netif_msg_rx_status(priv) && net_ratelimit())
+			cpu_netdev_warn(net_dev,
+				"%s:%hu:%s(): Dropping a SG frame\n",
+				__file__, __LINE__, __func__);
+		goto out;
+	}
+
+	size = dpa_fd_length(fd);
+
+	skb = __netdev_alloc_skb(net_dev,
+			DPA_BP_HEAD + NET_IP_ALIGN + size, GFP_ATOMIC);
+	if (unlikely(skb == NULL)) {
+		if (netif_msg_rx_err(priv) && net_ratelimit())
+			cpu_netdev_err(net_dev, "Could not alloc skb\n");
+
+		percpu_priv->stats.rx_dropped++;
+
+		goto out;
+	}
+
+	skb_reserve(skb, NET_IP_ALIGN+DPA_BP_HEAD);
+
+	/* Fill the SKB */
+	memcpy(skb_put(skb, dpa_fd_length(fd)),
+			dpa_phys2virt(dpa_bp, qm_fd_addr(fd)) +
+			dpa_fd_offset(fd), dpa_fd_length(fd));
+
+	skb->protocol = eth_type_trans(skb, net_dev);
+
+	if (unlikely(skb->len > net_dev->mtu)) {
+		if ((skb->protocol != ETH_P_8021Q) ||
+				(skb->len > net_dev->mtu + 4)) {
+			percpu_priv->stats.rx_dropped++;
+			dev_kfree_skb_any(skb);
+			goto out;
+		}
+	}
+
+	if (unlikely(netif_rx(skb) != NET_RX_SUCCESS))
+		percpu_priv->stats.rx_dropped++;
+
+	net_dev->last_rx = jiffies;
+
+out:
+	err = dpa_fd_release(net_dev, fd);
+	if (unlikely(err < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during RX\n");
+	}
+
+	return qman_cb_dqrr_consume;
+}
+
+
+static enum qman_cb_dqrr_result __hot
+ingress_rx_default_dqrr(struct qman_portal		*portal,
+			struct qman_fq			*fq,
+			const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (unlikely(dpaa_eth_napi_schedule(percpu_priv))) {
+		percpu_priv->in_interrupt++;
+		return qman_cb_dqrr_stop;
+	}
+
+	prefetchw(&percpu_priv->ingress_calls);
+
+	_dpa_rx(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result
+ingress_tx_error_dqrr(struct qman_portal		*portal,
+		      struct qman_fq			*fq,
+		      const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_tx_error(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result __hot
+ingress_tx_default_dqrr(struct qman_portal		*portal,
+			struct qman_fq			*fq,
+			const struct qm_dqrr_entry	*dq)
+{
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	percpu_priv->tx_confirm++;
+
+	if (dpaa_eth_napi_schedule(percpu_priv))
+		return qman_cb_dqrr_stop;
+
+	_dpa_tx(net_dev, priv, percpu_priv, &dq->fd);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void shared_ern(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	struct net_device *net_dev;
+	const struct dpa_priv_s	*priv;
+	int err;
+	struct dpa_percpu_priv_s *percpu_priv;
+	struct dpa_fq *dpa_fq = (struct dpa_fq *)fq;
+
+	net_dev = dpa_fq->net_dev;
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	err = dpa_fd_release(net_dev, &msg->ern.fd);
+	if (unlikely(err < 0)) {
+		dump_stack();
+		panic("Can't release buffer to the BM during a TX\n");
+	}
+
+	percpu_priv->stats.tx_dropped++;
+	percpu_priv->stats.tx_fifo_errors++;
+}
+
+static void egress_ern(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+	struct sk_buff *skb;
+	struct sk_buff **skbh;
+	struct dpa_percpu_priv_s	*percpu_priv;
+	dma_addr_t addr = qm_fd_addr(&msg->ern.fd);
+	struct dpa_bp *bp;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+	bp = priv->dpa_bp;
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	skbh = (struct sk_buff **)phys_to_virt(addr);
+	skb = *skbh;
+
+	dma_unmap_single(bp->dev, addr, bp->size, DMA_TO_DEVICE);
+
+	dev_kfree_skb_any(skb);
+
+	percpu_priv->stats.tx_dropped++;
+	percpu_priv->stats.tx_fifo_errors++;
+}
+
+static const struct qman_fq rx_shared_fq __devinitconst = {
+		.cb = {shared_rx_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq rx_private_defq __devinitconst = {
+		.cb = {ingress_rx_default_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq rx_private_errq __devinitconst = {
+		.cb = {ingress_rx_error_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq tx_private_defq __devinitconst = {
+		.cb = {ingress_tx_default_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq tx_private_errq __devinitconst = {
+		.cb = {ingress_tx_error_dqrr, NULL, NULL, NULL}
+};
+static const struct qman_fq dummyq __devinitconst = {
+		.cb = {NULL, NULL, NULL, NULL}
+};
+static const struct qman_fq private_egress_fq __devinitconst = {
+	.cb = {NULL, egress_ern, NULL, NULL}
+};
+static const struct qman_fq shared_egress_fq __devinitconst = {
+	.cb = {NULL, shared_ern, NULL, NULL}
+};
+
+static int __cold dpa_start(struct net_device *net_dev)
+{
+	int err, i;
+	struct dpa_priv_s *priv;
+	struct mac_device *mac_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	if (!mac_dev)
+		goto no_mac;
+
+	dpaa_eth_napi_enable(priv);
+
+	err = mac_dev->init_phy(net_dev);
+	if (err < 0) {
+		if (netif_msg_ifup(priv))
+			cpu_netdev_err(net_dev, "init_phy() = %d\n", err);
+		goto init_phy_failed;
+	}
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_enable(mac_dev->port_dev[i]);
+
+	err = priv->mac_dev->start(mac_dev);
+	if (err < 0) {
+		if (netif_msg_ifup(priv))
+			cpu_netdev_err(net_dev, "mac_dev->start() = %d\n", err);
+		goto mac_start_failed;
+	}
+
+no_mac:
+	netif_tx_start_all_queues(net_dev);
+
+	return 0;
+
+mac_start_failed:
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_disable(mac_dev->port_dev[i]);
+
+init_phy_failed:
+	dpaa_eth_napi_disable(priv);
+
+	return err;
+}
+
+static int __cold dpa_stop(struct net_device *net_dev)
+{
+	int _errno, i;
+	struct dpa_priv_s *priv;
+	struct mac_device *mac_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	netif_tx_stop_all_queues(net_dev);
+
+	if (!mac_dev)
+		return 0;
+
+	_errno = mac_dev->stop(mac_dev);
+	if (unlikely(_errno < 0))
+		if (netif_msg_ifdown(priv))
+			cpu_netdev_err(net_dev, "mac_dev->stop() = %d\n",
+					_errno);
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_disable(mac_dev->port_dev[i]);
+
+	if (mac_dev->phy_dev)
+		phy_disconnect(mac_dev->phy_dev);
+	mac_dev->phy_dev = NULL;
+
+	dpaa_eth_napi_disable(priv);
+
+	return _errno;
+}
+
+static void __cold dpa_timeout(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv;
+	struct dpa_percpu_priv_s *percpu_priv;
+
+	priv = netdev_priv(net_dev);
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (netif_msg_timer(priv))
+		cpu_netdev_crit(net_dev, "Transmit timeout latency: %lu ms\n",
+				(jiffies - net_dev->trans_start) * 1000 / HZ);
+
+	percpu_priv->stats.tx_errors++;
+}
+
+static int __devinit dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
+{
+	return ((struct dpa_bp *)dpa_bp0)->size -
+			((struct dpa_bp *)dpa_bp1)->size;
+}
+
+static struct dpa_bp * __devinit __cold __must_check __attribute__((nonnull))
+dpa_bp_probe(struct of_device *_of_dev, size_t *count)
+{
+	int			 i, lenp, na, ns;
+	struct device		*dev;
+	struct device_node	*dev_node;
+	const phandle		*phandle_prop;
+	const uint32_t		*bpid;
+	const uint32_t		*bpool_cfg;
+	struct dpa_bp		*dpa_bp;
+	int has_kernel_pool = 0;
+	int has_shared_pool = 0;
+
+	dev = &_of_dev->dev;
+
+	/* The default is one, if there's no property */
+	*count = 1;
+
+	/* There are three types of buffer pool configuration:
+	 * 1) No bp assignment
+	 * 2) A static assignment to an empty configuration
+	 * 3) A static assignment to one or more configured pools
+	 *
+	 * We don't support using multiple unconfigured pools.
+	 */
+
+	/* Get the buffer pools to be used */
+	phandle_prop = of_get_property(_of_dev->node,
+					"fsl,bman-buffer-pools", &lenp);
+
+	if (phandle_prop)
+		*count = lenp / sizeof(phandle);
+	else {
+		if (default_pool)
+			return default_pool;
+
+		has_kernel_pool = 1;
+	}
+
+	dpa_bp = devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
+	if (unlikely(dpa_bp == NULL)) {
+		dpaa_eth_err(dev, "devm_kzalloc() failed\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	dev_node = of_find_node_by_path("/");
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev, "of_find_node_by_path(/) failed\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	na = of_n_addr_cells(dev_node);
+	ns = of_n_size_cells(dev_node);
+
+	for (i = 0; i < *count && phandle_prop; i++) {
+		of_node_put(dev_node);
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			dpaa_eth_err(dev, "of_find_node_by_phandle() failed\n");
+			return ERR_PTR(-EFAULT);
+		}
+
+		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
+			dpaa_eth_err(dev,
+				"!of_device_is_compatible(%s, fsl,bpool)\n",
+				dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+
+		bpid = of_get_property(dev_node, "fsl,bpid", &lenp);
+		if ((bpid == NULL) || (lenp != sizeof(*bpid))) {
+			dpaa_eth_err(dev, "fsl,bpid property not found.\n");
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+		dpa_bp[i].bpid = *bpid;
+
+		bpool_cfg = of_get_property(dev_node, "fsl,bpool-cfg", &lenp);
+		if (bpool_cfg && (lenp == (2 * ns + na) * sizeof(*bpool_cfg))) {
+			dpa_bp[i].count	= of_read_number(bpool_cfg, ns);
+			dpa_bp[i].size	= of_read_number(bpool_cfg + ns, ns);
+			dpa_bp[i].paddr	=
+				of_read_number(bpool_cfg + 2 * ns, na);
+
+#warning We are ignoring configuration values, here
+			if (dpa_bp[i].paddr == 0)
+				has_kernel_pool = 1;
+			else
+				has_shared_pool = 1;
+		} else {
+			has_kernel_pool = 1;
+		}
+
+		if (i > 0)
+			has_shared_pool = 1;
+	}
+
+	if (has_kernel_pool && has_shared_pool) {
+		dpaa_eth_err(dev, "Invalid buffer pool configuration "
+			"for node %s\n", dev_node->full_name);
+		dpa_bp = ERR_PTR(-EINVAL);
+		goto _return_of_node_put;
+	} else if (has_kernel_pool) {
+		dpa_bp->count = DEFAULT_COUNT;
+		dpa_bp->size = DEFAULT_BUF_SIZE;
+		dpa_bp->kernel_pool = 1;
+	}
+
+	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
+
+	return dpa_bp;
+
+_return_of_node_put:
+	if (dev_node)
+		of_node_put(dev_node);
+
+	return dpa_bp;
+}
+
+static int dpa_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
+			size_t count)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	int i;
+
+	if (dpa_bp->kernel_pool) {
+		priv->shared = 0;
+
+		if (netif_msg_probe(priv))
+			cpu_netdev_info(net_dev,
+				"Using private BM buffer pools\n");
+	} else {
+		priv->shared = 1;
+	}
+
+	priv->dpa_bp = dpa_bp;
+	priv->bp_count = count;
+
+	for (i = 0; i < count; i++) {
+		int err;
+		err = dpa_bp_alloc(&dpa_bp[i]);
+		if (err < 0) {
+			dpa_bp_free(priv, dpa_bp);
+			priv->dpa_bp = NULL;
+			return err;
+		}
+
+		/* For now, just point to the default pool.
+		 * We can add support for more pools, later
+		 */
+		if (dpa_bp->kernel_pool)
+			priv->dpa_bp = default_pool;
+	}
+
+	return 0;
+}
+
+static struct mac_device * __devinit __cold __must_check
+__attribute__((nonnull))
+dpa_mac_probe(struct of_device *_of_dev)
+{
+	struct device		*dpa_dev, *dev;
+	struct device_node	*mac_node;
+	int			 lenp;
+	const phandle		*phandle_prop;
+	struct of_device	*of_dev;
+	struct mac_device	*mac_dev;
+
+	phandle_prop = of_get_property(_of_dev->node, "fsl,fman-mac", &lenp);
+	if (phandle_prop == NULL)
+		return NULL;
+
+	BUG_ON(lenp != sizeof(phandle));
+
+	dpa_dev = &_of_dev->dev;
+
+	mac_node = of_find_node_by_phandle(*phandle_prop);
+	if (unlikely(mac_node == NULL)) {
+		dpaa_eth_err(dpa_dev, "of_find_node_by_phandle() failed\n");
+		return ERR_PTR(-EFAULT);
+	}
+
+	of_dev = of_find_device_by_node(mac_node);
+	if (unlikely(of_dev == NULL)) {
+		dpaa_eth_err(dpa_dev, "of_find_device_by_node(%s) failed\n",
+				mac_node->full_name);
+		of_node_put(mac_node);
+		return ERR_PTR(-EINVAL);
+	}
+	of_node_put(mac_node);
+
+	dev = &of_dev->dev;
+
+	mac_dev = dev_get_drvdata(dev);
+	if (unlikely(mac_dev == NULL)) {
+		dpaa_eth_err(dpa_dev, "dev_get_drvdata(%s) failed\n",
+				dev_name(dev));
+		return ERR_PTR(-EINVAL);
+	}
+
+	return mac_dev;
+}
+
+static const char fsl_qman_frame_queues[][25] __devinitconst = {
+	[RX] = "fsl,qman-frame-queues-rx",
+	[TX] = "fsl,qman-frame-queues-tx"
+};
+
+#ifdef CONFIG_DEBUG_FS
+static int __cold dpa_debugfs_show(struct seq_file *file, void *offset)
+{
+	int				 i;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv, total;
+	struct dpa_bp *dpa_bp;
+	int *countptr;
+	unsigned int count_total = 0;
+
+	BUG_ON(offset == NULL);
+
+	priv = netdev_priv((struct net_device *)file->private);
+
+	dpa_bp = priv->dpa_bp;
+
+	memset(&total, 0, sizeof(total));
+
+	seq_printf(file, "\tirqs\trx\trecycle\tconfirm\tbp count\tneed\n");
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
+
+		total.in_interrupt += percpu_priv->in_interrupt;
+		total.ingress_calls += percpu_priv->stats.rx_packets;
+		total.tx_returned += percpu_priv->tx_returned;
+		total.tx_confirm += percpu_priv->tx_confirm;
+		count_total += *countptr;
+
+		seq_printf(file, "%hu/%hu\t%u\t%lu\t%u\t%u\t%d\n",
+				get_hard_smp_processor_id(i), i,
+				percpu_priv->in_interrupt,
+				percpu_priv->stats.rx_packets,
+				percpu_priv->tx_returned,
+				percpu_priv->tx_confirm,
+				*countptr);
+	}
+	seq_printf(file, "Total\t%u\t%u\t%u\t%u\t%d\n",
+			total.in_interrupt,
+			total.ingress_calls,
+			total.tx_returned,
+			total.tx_confirm, count_total);
+
+	return 0;
+}
+
+static int __cold dpa_debugfs_open(struct inode *inode, struct file *file)
+{
+	int			 _errno;
+	const struct net_device	*net_dev;
+
+	_errno = single_open(file, dpa_debugfs_show, inode->i_private);
+	if (unlikely(_errno < 0)) {
+		net_dev = (struct net_device *)inode->i_private;
+
+		if (netif_msg_drv((struct dpa_priv_s *)netdev_priv(net_dev)))
+			cpu_netdev_err(net_dev, "single_open() = %d\n",
+					_errno);
+	}
+	return _errno;
+}
+
+static const struct file_operations dpa_debugfs_fops = {
+	.open		= dpa_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+#endif
+
+static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
+{
+	return smp_processor_id();
+}
+
+static const struct net_device_ops dpa_private_ops = {
+	.ndo_open = dpa_start,
+	.ndo_start_xmit = dpa_tx,
+	.ndo_stop = dpa_stop,
+	.ndo_change_rx_flags = dpa_change_rx_flags,
+	.ndo_tx_timeout = dpa_timeout,
+	.ndo_get_stats = dpa_get_stats,
+	.ndo_set_mac_address = dpa_set_mac_address,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_select_queue = dpa_select_queue,
+	.ndo_change_mtu = dpa_change_mtu,
+	.ndo_set_multicast_list = dpa_set_multicast_list,
+};
+
+static const struct net_device_ops dpa_shared_ops = {
+	.ndo_open = dpa_start,
+	.ndo_start_xmit = dpa_shared_tx,
+	.ndo_stop = dpa_stop,
+	.ndo_change_rx_flags = dpa_change_rx_flags,
+	.ndo_tx_timeout = dpa_timeout,
+	.ndo_get_stats = dpa_get_stats,
+	.ndo_set_mac_address = dpa_set_mac_address,
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_set_multicast_list = dpa_set_multicast_list,
+};
+
+static int __devinit dpa_get_channel(struct device *dev,
+					struct device_node *dpa_node)
+{
+	struct device_node *dev_node;
+	const uint32_t *channel_id;
+	int lenp;
+
+	dev_node = of_parse_phandle(dpa_node, "fsl,qman-channel", 0);
+	if (dev_node == NULL) {
+		dpaa_eth_err(dev, "Could not find fsl,qman-channel property\n");
+		return -EFAULT;
+	}
+
+	channel_id = of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
+	if ((channel_id == NULL) || (lenp < sizeof(*channel_id))) {
+		dpaa_eth_err(dev, "Could not get fsl,qman-channel-id in %s\n",
+				dev_node->full_name);
+		of_node_put(dev_node);
+		return -EINVAL;
+	}
+	of_node_put(dev_node);
+	return *channel_id;
+}
+
+struct fqid_cell {
+	uint32_t start;
+	uint32_t count;
+};
+
+static const struct fqid_cell default_fqids[][3] __devinitconst = {
+	[RX] = { {0, 1}, {0, 1}, {0, DPAA_ETH_RX_QUEUES} },
+	[TX] = { {0, 1}, {0, 1}, {0, DPAA_ETH_TX_QUEUES} }
+};
+
+static int __devinit
+dpa_fq_probe(struct of_device *_of_dev, struct list_head *list,
+		struct dpa_fq **defq, struct dpa_fq **errq,
+		struct dpa_fq **fqs, int ptype)
+{
+	struct device_node *np = _of_dev->node;
+	struct device *dev = &_of_dev->dev;
+	const struct fqid_cell *fqids;
+	int i, j, lenp;
+	int num_fqids;
+	struct dpa_fq *dpa_fq;
+	int err = 0;
+
+	fqids = of_get_property(np, fsl_qman_frame_queues[ptype], &lenp);
+	if (fqids == NULL) {
+		fqids = default_fqids[ptype];
+		num_fqids = 3;
+	} else
+		num_fqids = lenp / sizeof(*fqids);
+
+	for (i = 0; i < num_fqids; i++) {
+		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * fqids[i].count,
+					GFP_KERNEL);
+		if (dpa_fq == NULL) {
+			dpaa_eth_err(dev, "devm_kzalloc() failed\n");
+			return -ENOMEM;
+		}
+
+		/* The first queue is the Error queue */
+		if (i == 0 && errq) {
+			*errq = dpa_fq;
+
+			if (fqids[i].count != 1) {
+				dpaa_eth_err(dev, "Too many error queues!\n");
+				err = -EINVAL;
+				goto invalid_error_queues;
+			}
+		}
+
+		/* The second queue is the the Default queue */
+		if (i == 1 && defq) {
+			*defq = dpa_fq;
+
+			if (fqids[i].count != 1) {
+				dpaa_eth_err(dev, "Too many default queues!\n");
+				err = -EINVAL;
+				goto invalid_default_queues;
+			}
+		}
+
+		/*
+		 * All subsequent queues are gathered together.
+		 * The first 8 will be used by the private linux interface
+		 * if these are TX queues
+		 */
+		if (i == 2 || (!errq && i == 0 && fqs))
+			*fqs = dpa_fq;
+
+#warning We lost the 8-queue enforcement
+
+#define DPA_NUM_WQS 8
+		for (j = 0; j < fqids[i].count; j++) {
+			dpa_fq[j].fqid = fqids[i].start ?
+				fqids[i].start + j : 0;
+			dpa_fq[j].wq = dpa_fq[j].fqid ?
+				dpa_fq[j].fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
+			list_add_tail(&dpa_fq[j].list, list);
+		}
+	}
+
+invalid_default_queues:
+invalid_error_queues:
+	return err;
+}
+
+static void dpa_setup_ingress(struct dpa_priv_s *priv, struct dpa_fq *fq,
+			const struct qman_fq *template)
+{
+	fq->fq_base = *template;
+	fq->net_dev = priv->net_dev;
+
+	fq->flags = QMAN_FQ_FLAG_NO_ENQUEUE;
+	fq->channel = priv->channel;
+}
+
+static void dpa_setup_egress(struct dpa_priv_s *priv,
+				struct list_head *head, struct dpa_fq *fq,
+				struct fm_port *port)
+{
+	struct list_head *ptr = &fq->list;
+	int i = 0;
+
+	while (true) {
+		struct dpa_fq *iter = list_entry(ptr, struct dpa_fq, list);
+		if (priv->shared)
+			iter->fq_base = shared_egress_fq;
+		else
+			iter->fq_base = private_egress_fq;
+
+		iter->net_dev = priv->net_dev;
+		priv->egress_fqs[i++] = &iter->fq_base;
+
+		if (port) {
+			iter->flags = QMAN_FQ_FLAG_TO_DCPORTAL;
+			iter->channel = fm_get_tx_port_channel(port);
+		} else
+			iter->flags = QMAN_FQ_FLAG_NO_MODIFY;
+
+		if (list_is_last(ptr, head))
+			break;
+
+		ptr = ptr->next;
+	}
+}
+
+static void dpa_setup_ingress_queues(struct dpa_priv_s *priv,
+		struct list_head *head, struct dpa_fq *fq)
+{
+	struct list_head *ptr = &fq->list;
+	u32 fqid = 0;
+	int portals[NR_CPUS];
+	int cpu;
+	int i = 0;
+
+	/* Make a list of the available portals */
+	for_each_online_cpu(cpu) {
+		portals[i++] = cpu;
+	}
+
+	i = 0;
+
+	if (priv->mac_dev)
+		fqid = (priv->mac_dev->res->start & 0x1fffff) >> 6;
+
+	while (true) {
+		struct dpa_fq *iter = list_entry(ptr, struct dpa_fq, list);
+
+		if (priv->shared)
+			dpa_setup_ingress(priv, iter, &rx_shared_fq);
+		else
+			dpa_setup_ingress(priv, iter, &rx_private_defq);
+
+		if (!iter->fqid)
+			iter->fqid = fqid++;
+
+		/* Assign the queues to a channel in a round-robin fashion */
+		iter->channel = portals[i];
+		i = (i + 1) % num_online_cpus();
+
+		if (list_is_last(ptr, head))
+			break;
+
+		ptr = ptr->next;
+	}
+}
+
+static void __devinit
+dpaa_eth_init_tx_port(struct fm_port *port, struct dpa_fq *errq,
+			struct dpa_fq *defq)
+{
+	struct fm_port_non_rx_params tx_port_param;
+
+	dpaa_eth_init_port(tx, port, tx_port_param, errq->fqid, defq->fqid);
+}
+
+static void __devinit
+dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
+			struct dpa_fq *errq, struct dpa_fq *defq)
+{
+	struct fm_port_rx_params rx_port_param;
+	int i;
+
+	count = min(ARRAY_SIZE(rx_port_param.pool_param), count);
+	rx_port_param.num_pools = count;
+	for (i = 0; i < count; i++) {
+		if (i >= rx_port_param.num_pools)
+			break;
+
+		rx_port_param.pool_param[i].id = bp[i].bpid;
+		rx_port_param.pool_param[i].size = bp[i].size;
+	}
+
+	dpaa_eth_init_port(rx, port, rx_port_param, errq->fqid, defq->fqid);
+}
+
+static void dpa_rx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
+			struct dpa_fq *defq, struct dpa_fq *errq,
+			struct dpa_fq *fqs)
+{
+	if (fqs)
+		dpa_setup_ingress_queues(priv, head, fqs);
+
+	/* Only real devices need default/error queues set up */
+	if (!priv->mac_dev)
+		return;
+
+	if (defq->fqid == 0 && netif_msg_probe(priv))
+		cpu_pr_info("Using dynamic RX QM frame queues\n");
+
+	if (priv->shared) {
+		dpa_setup_ingress(priv, defq, &rx_shared_fq);
+		dpa_setup_ingress(priv, errq, &rx_shared_fq);
+	} else {
+		dpa_setup_ingress(priv, defq, &rx_private_defq);
+		dpa_setup_ingress(priv, errq, &rx_private_errq);
+	}
+}
+
+static void dpa_tx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
+			struct dpa_fq *defq, struct dpa_fq *errq,
+			struct dpa_fq *fqs, struct fm_port *port)
+{
+	if (fqs)
+		dpa_setup_egress(priv, head, fqs, port);
+
+	/* Only real devices need default/error queues set up */
+	if (!priv->mac_dev)
+		return;
+
+	if (defq->fqid == 0 && netif_msg_probe(priv))
+		cpu_pr_info("Using dynamic TX QM frame queues\n");
+
+	/* The shared driver doesn't use tx confirmation */
+	if (priv->shared) {
+		dpa_setup_ingress(priv, defq, &dummyq);
+		dpa_setup_ingress(priv, errq, &dummyq);
+	} else {
+		dpa_setup_ingress(priv, defq, &tx_private_defq);
+		dpa_setup_ingress(priv, errq, &tx_private_errq);
+	}
+}
+
+static int dpa_netdev_init(struct device_node *dpa_node,
+		struct net_device *net_dev)
+{
+	int err;
+	const uint8_t *mac_addr;
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct device *dev = net_dev->dev.parent;
+
+	net_dev->features |= DPA_NETIF_FEATURES;
+
+	if (!priv->mac_dev) {
+		/* Get the MAC address */
+		mac_addr = of_get_mac_address(dpa_node);
+		if (mac_addr == NULL) {
+			if (netif_msg_probe(priv))
+				dpaa_eth_err(dev, "No MAC address found!\n");
+			return -EINVAL;
+		}
+	} else {
+		net_dev->mem_start = priv->mac_dev->res->start;
+		net_dev->mem_end = priv->mac_dev->res->end;
+
+		mac_addr = priv->mac_dev->addr;
+		net_dev->features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+	}
+
+	memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
+	memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
+
+	SET_ETHTOOL_OPS(net_dev, &dpa_ethtool_ops);
+	net_dev->needed_headroom = DPA_BP_HEAD;
+	net_dev->watchdog_timeo = tx_timeout * HZ / 1000;
+
+	err = register_netdev(net_dev);
+	if (err < 0) {
+		dpaa_eth_err(dev, "register_netdev() = %d\n", err);
+		return err;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	priv->debugfs_file = debugfs_create_file(net_dev->name, S_IRUGO,
+						 dpa_debugfs_root, net_dev,
+						 &dpa_debugfs_fops);
+	if (unlikely(priv->debugfs_file == NULL)) {
+		cpu_netdev_err(net_dev, "debugfs_create_file(%s/%s/%s) = %d\n",
+				powerpc_debugfs_root->d_iname,
+				dpa_debugfs_root->d_iname,
+				net_dev->name, err);
+
+		unregister_netdev(net_dev);
+		return -ENOMEM;
+	}
+#endif
+
+	return 0;
+}
+
+static int dpa_shared_netdev_init(struct device_node *dpa_node,
+				struct net_device *net_dev)
+{
+	net_dev->netdev_ops = &dpa_shared_ops;
+
+	return dpa_netdev_init(dpa_node, net_dev);
+}
+
+static int dpa_private_netdev_init(struct device_node *dpa_node,
+				struct net_device *net_dev)
+{
+	int i;
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct dpa_percpu_priv_s *percpu_priv;
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		percpu_priv->net_dev = net_dev;
+
+		percpu_priv->dpa_bp = priv->dpa_bp;
+		netif_napi_add(net_dev, &percpu_priv->napi, dpaa_eth_poll,
+			       DPA_NAPI_WEIGHT);
+	}
+
+	net_dev->netdev_ops = &dpa_private_ops;
+
+	return dpa_netdev_init(dpa_node, net_dev);
+}
+
+static int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
+				uint8_t alignment, uint32_t *base_fqid)
+{
+	dpaa_eth_crit(dev, "callback not implemented!\n");
+	BUG();
+
+	return 0;
+}
+
+static ssize_t dpaa_eth_show_addr(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	struct mac_device *mac_dev = priv->mac_dev;
+
+	if (mac_dev)
+		return sprintf(buf, "%llx",
+				(unsigned long long)mac_dev->res->start);
+	else
+		return sprintf(buf, "none");
+}
+
+static DEVICE_ATTR(device_addr, S_IRUGO, dpaa_eth_show_addr, NULL);
+
+static ssize_t dpaa_eth_show_fqids(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct dpa_priv_s *priv = netdev_priv(to_net_dev(dev));
+	ssize_t bytes = 0;
+	int i = 0;
+	char *str;
+	struct dpa_fq *fq;
+	struct dpa_fq *tmp;
+	struct dpa_fq *prev = NULL;
+	u32 first_fqid = 0;
+	u32 last_fqid = 0;
+	char *prevstr = NULL;
+
+	list_for_each_entry_safe(fq, tmp, &priv->dpa_fq_list, list) {
+		void *dqrr = fq->fq_base.cb.dqrr;
+		if (dqrr == ingress_rx_error_dqrr)
+			str = "error";
+		else if (i == 1 && dqrr == ingress_rx_default_dqrr)
+			str = "default";
+		else if (dqrr == ingress_rx_error_dqrr ||
+				dqrr == ingress_rx_default_dqrr)
+			str = "RX";
+		else if (dqrr == ingress_tx_default_dqrr)
+			str = "TX confirmation";
+		else if (dqrr == ingress_tx_error_dqrr)
+			str = "TX error";
+		else if (dqrr == NULL)
+			str = "TX";
+		else
+			str = "unknown";
+
+		if (prev && (abs(fq->fqid - prev->fqid) != 1 ||
+					str != prevstr)) {
+			if (last_fqid == first_fqid)
+				bytes += sprintf(buf + bytes,
+					"%s: %d\n", prevstr, prev->fqid);
+			else
+				bytes += sprintf(buf + bytes,
+					"%s: %d - %d\n", prevstr,
+					first_fqid, last_fqid);
+		}
+
+		if (prev && abs(fq->fqid - prev->fqid) == 1 && str == prevstr)
+			last_fqid = fq->fqid;
+		else
+			first_fqid = last_fqid = fq->fqid;
+
+		prev = fq;
+		prevstr = str;
+		i++;
+	}
+
+	if (last_fqid == first_fqid)
+		bytes += sprintf(buf + bytes, "%s: %d\n", prevstr, prev->fqid);
+	else
+		bytes += sprintf(buf + bytes, "%s: %d - %d\n", prevstr,
+				first_fqid, last_fqid);
+
+	return bytes;
+}
+
+static DEVICE_ATTR(fqids, S_IRUGO, dpaa_eth_show_fqids, NULL);
+
+
+static void __devinit dpaa_eth_sysfs_init(struct device *dev)
+{
+	if (device_create_file(dev, &dev_attr_device_addr))
+		dev_err(dev, "Error creating dpaa_eth addr file\n");
+	if (device_create_file(dev, &dev_attr_fqids))
+		dev_err(dev, "Error creating dpaa_eth fqids file\n");
+}
+static int __devinit
+dpaa_eth_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int err, i;
+	struct device *dev;
+	struct device_node *dpa_node;
+	struct dpa_bp *dpa_bp;
+	struct dpa_fq *dpa_fq, *tmp;
+	struct list_head rxfqlist;
+	struct list_head txfqlist;
+	size_t count;
+	struct net_device *net_dev = NULL;
+	struct dpa_priv_s *priv = NULL;
+	struct dpa_fq *rxdefault = NULL;
+	struct dpa_fq *txdefault = NULL;
+	struct dpa_fq *rxerror = NULL;
+	struct dpa_fq *txerror = NULL;
+	struct dpa_fq *rxextra = NULL;
+	struct dpa_fq *txfqs = NULL;
+	struct fm_port *rxport = NULL;
+	struct fm_port *txport = NULL;
+	struct mac_device *mac_dev;
+	int proxy_enet;
+
+	dev = &_of_dev->dev;
+
+	dpa_node = _of_dev->node;
+
+	if (!of_device_is_available(dpa_node))
+		return -ENODEV;
+
+	/*
+	 * If it's not an fsl,dpa-ethernet node, we just serve as a proxy
+	 * initializer driver, and don't do any linux device setup
+	 */
+	proxy_enet = strcmp(match->compatible, "fsl,dpa-ethernet");
+
+	/*
+	 * Allocate this early, so we can store relevant information in
+	 * the private area
+	 */
+	if (!proxy_enet) {
+		net_dev = alloc_etherdev_mq(sizeof(*priv), DPAA_ETH_TX_QUEUES);
+		if (!net_dev) {
+			dpaa_eth_err(dev, "alloc_etherdev_mq() failed\n");
+			return -ENOMEM;
+		}
+
+		/* Do this here, so we can be verbose early */
+		SET_NETDEV_DEV(net_dev, dev);
+		dev_set_drvdata(dev, net_dev);
+
+		priv = netdev_priv(net_dev);
+		priv->net_dev = net_dev;
+
+		priv->msg_enable = netif_msg_init(debug, -1);
+	}
+
+	/* Get the buffer pools assigned to this interface */
+	dpa_bp = dpa_bp_probe(_of_dev, &count);
+	if (IS_ERR(dpa_bp)) {
+		err = PTR_ERR(dpa_bp);
+		goto bp_probe_failed;
+	}
+
+	mac_dev = dpa_mac_probe(_of_dev);
+	if (IS_ERR(mac_dev)) {
+		err = PTR_ERR(mac_dev);
+		goto mac_probe_failed;
+	} else if (mac_dev) {
+		rxport = mac_dev->port_dev[RX];
+		txport = mac_dev->port_dev[TX];
+	}
+
+	INIT_LIST_HEAD(&rxfqlist);
+	INIT_LIST_HEAD(&txfqlist);
+
+	if (rxport)
+		err = dpa_fq_probe(_of_dev, &rxfqlist, &rxdefault, &rxerror,
+				&rxextra, RX);
+	else
+		err = dpa_fq_probe(_of_dev, &rxfqlist, NULL, NULL,
+				&rxextra, RX);
+
+	if (err < 0)
+		goto rx_fq_probe_failed;
+
+	if (txport)
+		err = dpa_fq_probe(_of_dev, &txfqlist, &txdefault, &txerror,
+				&txfqs, TX);
+	else
+		err = dpa_fq_probe(_of_dev, &txfqlist, NULL, NULL, &txfqs, TX);
+
+	if (err < 0)
+		goto tx_fq_probe_failed;
+
+	/*
+	 * Now we have all of the configuration information.
+	 * We support a number of configurations:
+	 * 1) Private interface - An optimized linux ethernet driver with
+	 *    a real network connection.
+	 * 2) Shared interface - A device intended for virtual connections
+	 *    or for a real interface that is shared between partitions
+	 * 3) Proxy initializer - Just configures the MAC on behalf of
+	 *    another partition
+	 */
+
+	/* bp init */
+	if (net_dev) {
+		err = dpa_bp_create(net_dev, dpa_bp, count);
+
+		if (err < 0)
+			goto bp_create_failed;
+
+		priv->mac_dev = mac_dev;
+
+		priv->channel = dpa_get_channel(dev, dpa_node);
+
+		if (priv->channel < 0) {
+			err = priv->channel;
+			goto get_channel_failed;
+		}
+
+		dpa_rx_fq_init(priv, &rxfqlist, rxdefault, rxerror, rxextra);
+		dpa_tx_fq_init(priv, &txfqlist, txdefault, txerror, txfqs,
+				txport);
+
+		/* Add the FQs to the interface, and make them active */
+		INIT_LIST_HEAD(&priv->dpa_fq_list);
+
+		list_for_each_entry_safe(dpa_fq, tmp, &rxfqlist, list) {
+			err = _dpa_fq_alloc(&priv->dpa_fq_list, dpa_fq);
+			if (err < 0)
+				goto fq_alloc_failed;
+		}
+
+		list_for_each_entry_safe(dpa_fq, tmp, &txfqlist, list) {
+			err = _dpa_fq_alloc(&priv->dpa_fq_list, dpa_fq);
+			if (err < 0)
+				goto fq_alloc_failed;
+		}
+
+	}
+
+	/* All real interfaces need their ports initialized */
+	if (mac_dev) {
+		struct fm_port_pcd_param rx_port_pcd_param;
+
+		dpaa_eth_init_rx_port(rxport, dpa_bp, count, rxerror,
+				rxdefault);
+		dpaa_eth_init_tx_port(txport, txerror, txdefault);
+
+		rx_port_pcd_param.cb = dpa_alloc_pcd_fqids;
+		rx_port_pcd_param.dev = dev;
+		fm_port_pcd_bind(rxport, &rx_port_pcd_param);
+	}
+
+	/*
+	 * Proxy interfaces need to be started, and the allocated
+	 * memory freed
+	 */
+	if (!net_dev) {
+		devm_kfree(&_of_dev->dev, dpa_bp);
+		devm_kfree(&_of_dev->dev, rxdefault);
+		devm_kfree(&_of_dev->dev, rxerror);
+		devm_kfree(&_of_dev->dev, txdefault);
+		devm_kfree(&_of_dev->dev, txerror);
+
+		for_each_port_device(i, mac_dev->port_dev)
+			fm_port_enable(mac_dev->port_dev[i]);
+
+		return 0;
+	}
+
+	/* Now we need to initialize either a private or shared interface */
+	priv->percpu_priv = __alloc_percpu(sizeof(*priv->percpu_priv),
+					   __alignof__(*priv->percpu_priv));
+	if (priv->percpu_priv == NULL) {
+		dpaa_eth_err(dev, "__alloc_percpu() failed\n");
+		err = -ENOMEM;
+		goto alloc_percpu_failed;
+	}
+
+	if (priv->shared)
+		err = dpa_shared_netdev_init(dpa_node, net_dev);
+	else
+		err = dpa_private_netdev_init(dpa_node, net_dev);
+
+	if (err < 0)
+		goto netdev_init_failed;
+
+	dpaa_eth_sysfs_init(&net_dev->dev);
+
+	return 0;
+
+netdev_init_failed:
+	if (net_dev)
+		free_percpu(priv->percpu_priv);
+alloc_percpu_failed:
+fq_alloc_failed:
+	if (net_dev)
+		dpa_fq_free(dev, &priv->dpa_fq_list);
+get_channel_failed:
+	if (net_dev)
+		dpa_bp_free(priv, priv->dpa_bp);
+bp_create_failed:
+tx_fq_probe_failed:
+rx_fq_probe_failed:
+mac_probe_failed:
+bp_probe_failed:
+	dev_set_drvdata(dev, NULL);
+	if (net_dev)
+		free_netdev(net_dev);
+
+	return err;
+}
+
+static const struct of_device_id dpa_match[] __devinitconst = {
+	{
+		.compatible	= "fsl,dpa-ethernet"
+	},
+	{
+		.compatible	= "fsl,dpa-ethernet-init"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, dpa_match);
+
+static int __devexit __cold dpa_remove(struct of_device *of_dev)
+{
+	int			err;
+	struct device		*dev;
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+
+	dev = &of_dev->dev;
+	net_dev = dev_get_drvdata(dev);
+	priv = netdev_priv(net_dev);
+
+	dev_set_drvdata(dev, NULL);
+	unregister_netdev(net_dev);
+
+	err = dpa_fq_free(dev, &priv->dpa_fq_list);
+
+	free_percpu(priv->percpu_priv);
+
+	dpa_bp_free(priv, priv->dpa_bp);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(priv->debugfs_file);
+#endif
+
+	free_netdev(net_dev);
+
+	return err;
+}
+
+static struct of_platform_driver dpa_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= dpa_match,
+	.owner		= THIS_MODULE,
+	.probe		= dpaa_eth_probe,
+	.remove		= __devexit_p(dpa_remove)
+};
+
+static int __init __cold dpa_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+
+#ifdef CONFIG_DEBUG_FS
+	dpa_debugfs_root = debugfs_create_dir(KBUILD_MODNAME,
+					      powerpc_debugfs_root);
+	if (unlikely(dpa_debugfs_root == NULL)) {
+		_errno = -ENOMEM;
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): "
+			   "debugfs_create_dir(%s/"KBUILD_MODNAME") = %d\n",
+			   __file__, __LINE__, __func__,
+			   powerpc_debugfs_root->d_iname, _errno);
+		goto _return;
+	}
+#endif
+
+	_errno = of_register_platform_driver(&dpa_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME
+			": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			__file__, __LINE__, __func__, _errno);
+		goto _return_debugfs_remove;
+	}
+
+	goto _return;
+
+_return_debugfs_remove:
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(dpa_debugfs_root);
+#endif
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(dpa_load);
+
+static void __exit __cold dpa_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&dpa_driver);
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(dpa_debugfs_root);
+#endif
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(dpa_unload);
+
+static int __init fsl_fman_phy_set_max_frm(char *str)
+{
+	int ret = 0;
+
+	ret = get_option(&str, &fsl_fman_phy_maxfrm);
+	if (ret != 1 && ret != 2) {
+		/* This will only work if CONFIG_EARLY_PRINTK is compiled in,
+		 * and something like "earlyprintk=serial,uart0,115200" is
+		 * specified in the bootargs */
+		printk(KERN_INFO "No suitable %s=<int> prop in bootargs; "
+			"will use the default DPA_MAX_FRM_SIZE from Kconfig.\n",
+			FSL_FMAN_PHY_MAXFRM_BOOTARG);
+
+		/* Reset it to the default (invalid) value,
+		 * in case get_option() parsed a starting range. */
+		fsl_fman_phy_maxfrm = 0;
+		return 1;
+	}
+
+	/* Don't allow invalid bootargs */
+	if (fsl_fman_phy_maxfrm < 64 || fsl_fman_phy_maxfrm > 9600) {
+		printk(KERN_WARNING "Invalid %s=%d in bootargs, valid range is "
+			"64-9600.\n", FSL_FMAN_PHY_MAXFRM_BOOTARG,
+			fsl_fman_phy_maxfrm);
+
+		fsl_fman_phy_maxfrm = 0;
+		return 1;
+	}
+
+	return 0;
+}
+early_param(FSL_FMAN_PHY_MAXFRM_BOOTARG, fsl_fman_phy_set_max_frm);
diff --git a/drivers/net/dpa/dpaa_eth.h b/drivers/net/dpa/dpaa_eth.h
new file mode 100644
index 0000000..e4d544d
--- /dev/null
+++ b/drivers/net/dpa/dpaa_eth.h
@@ -0,0 +1,123 @@
+/* 
+ * Copyright 2008-2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_H
+#define __DPA_H
+
+#include <linux/ethtool.h>	/* struct ethtool_ops */
+#include <linux/netdevice.h>
+#include <linux/list.h>		/* struct list_head */
+#include <linux/workqueue.h>	/* struct work_struct */
+#include <linux/skbuff.h>
+#ifdef CONFIG_DEBUG_FS
+#include <linux/dcache.h>	/* struct dentry */
+#endif
+
+#include <linux/fsl_qman.h>	/* struct qman_fq */
+
+#include "dpaa_eth-common.h"
+
+#include "mac.h"		/* struct mac_device */
+
+
+/* number of Tx queues to FMan */
+#define DPAA_ETH_TX_QUEUES	8
+#define DPAA_ETH_RX_QUEUES	128
+
+struct pcd_range {
+	uint32_t			 base;
+	uint32_t			 count;
+};
+
+struct dpa_bp {
+	struct bman_pool		*pool;
+	uint8_t				bpid;
+	struct device			*dev;
+	size_t				count;
+	size_t				size;
+	dma_addr_t			paddr;
+	void				*vaddr;
+	int kernel_pool;
+	int *percpu_count;
+	int *needs_refill;
+	unsigned int skb_size;
+	atomic_t refs;
+};
+
+struct dpa_percpu_priv_s {
+	struct net_device	*net_dev;
+	u32			start_tx;
+	u32			in_interrupt;
+	u32			ingress_calls;
+	u32			tx_returned;
+	u32			tx_confirm;
+	struct dpa_bp *dpa_bp;
+	struct napi_struct napi;
+	struct net_device_stats	 stats;
+};
+
+struct dpa_priv_s {
+	struct dpa_bp *dpa_bp;
+	size_t bp_count;
+	int shared;
+	struct net_device *net_dev;
+
+	uint16_t		 channel;	/* "fsl,qman-channel-id" */
+	struct list_head	 dpa_fq_list;
+	struct qman_fq		*egress_fqs[DPAA_ETH_TX_QUEUES];
+
+	struct mac_device	*mac_dev;
+
+	struct dpa_percpu_priv_s	*percpu_priv;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*debugfs_file;
+#endif
+
+	uint32_t		 msg_enable;	/* net_device message level */
+};
+
+extern const struct ethtool_ops dpa_ethtool_ops;
+
+static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
+{
+	if (unlikely(in_irq())) {
+		/* Disable QMan IRQ and invoke NAPI */
+		int ret = qman_irqsource_remove(QM_PIRQ_DQRI);
+		if (likely(!ret)) {
+			napi_schedule(&percpu_priv->napi);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+#endif	/* __DPA_H */
diff --git a/drivers/net/dpa/fm-wrapper.c b/drivers/net/dpa/fm-wrapper.c
new file mode 100644
index 0000000..94238db
--- /dev/null
+++ b/drivers/net/dpa/fm-wrapper.c
@@ -0,0 +1,151 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>		/* in_be32() */
+#include <linux/of_platform.h>
+#include <sysdev/fsl_soc.h>
+
+#include "dpaa_eth-common.h"
+#include "fm.h"
+#include "fm-wrapper.h"
+
+#include "lnxwrp_fm_ext.h"	/* fm_init() */
+
+#define FM_DESCRIPTION "FSL FMan wrapper based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(FM_DESCRIPTION);
+
+const char	*fm_driver_description __initconst = FM_DESCRIPTION;
+const size_t	 fm_sizeof_priv __devinitconst = sizeof(struct fm_priv_s);
+
+static void fm_exception(t_Handle _fm_dev, e_FmExceptions exception)
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = (struct fm_device *)_fm_dev;
+
+	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void fm_bus_error(t_Handle	_fm_dev,
+			 e_FmPortType	port_type,
+			 uint8_t	cell_index,
+			 uint64_t	addr,
+			 uint8_t	tnum,
+			 uint8_t	partition)
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = (struct fm_device *)_fm_dev;
+
+	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static int __devinit __cold init(struct fm_device *fm_dev)
+{
+	struct fm_priv_s	*priv;
+	int			 i;
+
+	priv = fmdev_priv(fm_dev);
+
+	priv->fm.id			= fm_dev->cell_index;
+	priv->fm.prsActive		= fm_dev->parser_res != NULL;
+	priv->fm.kgActive		= fm_dev->keygen_res != NULL;
+	priv->fm.plcrActive		= fm_dev->policer_res != NULL;
+	priv->fm.pcdActive		= priv->fm.prsActive	||
+					  priv->fm.kgActive	||
+					  priv->fm.plcrActive;
+	priv->fm.fmBaseAddr		= (typeof(priv->fm.fmBaseAddr))fm_dev->vaddr;
+	priv->fm.fmMemSize		= fm_dev->res->end + 1 - fm_dev->res->start;
+	priv->fm.fmMuramBaseAddr	= (typeof(priv->fm.fmMuramBaseAddr))fm_dev->muram_vaddr;
+	priv->fm.fmMuramMemSize		= fm_dev->muram_res->end + 1 - fm_dev->muram_res->start;
+
+	priv->fm.fmDevSettings.param.fmId		= fm_dev->cell_index;
+	priv->fm.fmDevSettings.param.h_App		= &priv->fm;
+	priv->fm.fmDevSettings.param.fmClkFreq		= fsl_get_sys_freq();
+
+	/* Ugly hack! */
+	for (i = 0; i < ARRAY_SIZE(priv->fm.fmDevSettings.param.liodnPerPartition); i++)
+		priv->fm.fmDevSettings.param.liodnPerPartition[i] =
+			in_be32(fm_dev->vaddr + 0xc2000 + 0x60	+ sizeof(uint32_t) * (i / 2)) >>
+			16 * (1 - (i & 1));
+
+	priv->fm.fmDevSettings.param.f_Exceptions	= fm_exception;
+	priv->fm.fmDevSettings.param.f_BusError		= fm_bus_error;
+
+	priv->fm.fmDevSettings.advConfig	= priv->fm_config;
+
+	priv->fm.fmPcdDevSettings.advConfig	= priv->pcd_config;
+
+	priv->fm.active	= true;
+
+	fm_init(&priv->fm);
+
+	return 0;
+}
+
+static irqreturn_t isr(int irq, void *_fm_dev)
+{
+	irqreturn_t		 _errno;
+	struct fm_device	*fm_dev;
+	struct fm_priv_s	*priv;
+
+	fm_dev = _fm_dev;
+
+	priv = fmdev_priv(fm_dev);
+
+	if (likely(priv->fm.h_Dev != NULL)) {
+		FM_Isr(priv->fm.h_Dev);
+		_errno = IRQ_HANDLED;
+	} else
+		_errno = IRQ_NONE;
+
+	return _errno;
+}
+
+static void __devinit __cold setup(struct fm_device *fm_dev)
+{
+	fm_dev->init	= init;
+	fm_dev->isr	= isr;
+	fm_dev->uninit	= NULL;
+}
+
+void (*const fm_setup)(struct fm_device *fm_dev) __devinitconst = setup;
diff --git a/drivers/net/dpa/fm-wrapper.h b/drivers/net/dpa/fm-wrapper.h
new file mode 100644
index 0000000..ae663a3
--- /dev/null
+++ b/drivers/net/dpa/fm-wrapper.h
@@ -0,0 +1,43 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_WRAPPER_H
+#define __FM_WRAPPER_H
+
+#include "lnxwrp_fm.h"	/* t_LnxWrpFmDev */
+
+struct fm_priv_s {
+	t_LnxWrpFmDev			fm;
+	t_SysObjectAdvConfigEntry	fm_config[FM_MAX_NUM_OF_ADV_SETTINGS],
+					pcd_config[FM_MAX_NUM_OF_ADV_SETTINGS];
+};
+
+#endif	/* __FM_WRAPPER_H */
diff --git a/drivers/net/dpa/fm.c b/drivers/net/dpa/fm.c
new file mode 100644
index 0000000..e97d8c3
--- /dev/null
+++ b/drivers/net/dpa/fm.c
@@ -0,0 +1,360 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>		/* devm_ioremap() */
+
+#include "dpaa_eth-common.h"
+#include "fm.h"
+
+static struct fm_device * __devinit __cold
+alloc_fmdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct fm_device *fm_dev))
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = devm_kzalloc(dev, sizeof(*fm_dev) + sizeof_priv, GFP_KERNEL);
+	if (likely(fm_dev == NULL))
+		fm_dev = ERR_PTR(-ENOMEM);
+	else {
+		fm_dev->dev = dev;
+		dev_set_drvdata(dev, fm_dev);
+		setup(fm_dev);
+	}
+
+	return fm_dev;
+}
+
+static int __devexit __cold free_fmdev(struct fm_device *fm_dev)
+{
+	dev_set_drvdata(fm_dev->dev, NULL);
+
+	return likely(fm_dev->uninit) ? fm_dev->uninit(fm_dev) : 0;
+}
+
+struct resource * __cold fm_mem_region(struct of_device *of_dev)
+{
+	return ((struct fm_device *)dev_get_drvdata(&of_dev->dev))->res;
+}
+EXPORT_SYMBOL(fm_mem_region);
+
+const uint16_t irqf[] __devinitconst = {0};
+
+static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+	int			 _errno, interrupt, i, lenp;
+	struct device		*dev;
+	struct device_node	*fm_node, *dev_node;
+	struct fm_device	*fm_dev;
+	struct resource		 res;
+	const uint32_t		*uint32_prop;
+
+	dev = &of_dev->dev;
+
+	fm_dev = alloc_fmdev(dev, fm_sizeof_priv, fm_setup);
+	if (IS_ERR(fm_dev)) {
+		_errno = PTR_ERR(fm_dev);
+		dpaa_eth_err(dev, "alloc_fmdev() = %d\n", _errno);
+		goto _return;
+	}
+
+	fm_node = of_dev->node;
+
+	/* Get the FM interrupts */
+	for (i = 0; i < ARRAY_SIZE(irqf); i++) {
+		interrupt = of_irq_to_resource(fm_node, i, NULL);
+		if (unlikely(interrupt == NO_IRQ)) {
+			dpaa_eth_err(dev,
+				"of_irq_to_resource(%d) = NO_IRQ\n", i);
+			_errno = -EINVAL;
+			goto _return_dev_set_drvdata;
+		}
+
+		if (unlikely(!can_request_irq(interrupt, irqf[i])))
+			dpaa_eth_warn(dev, "can_request_irq(%d) failed\n", i);
+		_errno = devm_request_irq(dev, interrupt, fm_dev->isr, irqf[i], "fman", fm_dev);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(dev, "devm_request_irq(%d) = %d\n",
+					i, _errno);
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	/* Get the port/device address */
+	_errno = of_address_to_resource(fm_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "of_address_to_resource() = %d\n", _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->res = devm_request_mem_region(dev, res.start, res.end + 1 - res.start, "fman");
+	if (unlikely(fm_dev->res == NULL)) {
+		dpaa_eth_err(dev, "devm_request_mem_region(fman) failed\n");
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->vaddr = devm_ioremap(dev,
+				     fm_dev->res->start, fm_dev->res->end + 1 - fm_dev->res->start);
+	if (unlikely(fm_dev->vaddr == 0)) {
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	uint32_prop = of_get_property(fm_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				fm_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	fm_dev->cell_index = *uint32_prop;
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-muram");
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-muram) failed\n");
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	_errno = of_address_to_resource(dev_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				dev_node->full_name, _errno);
+		goto _return_of_node_put;
+	}
+	of_node_put(dev_node);
+
+	fm_dev->muram_res = __devm_request_region(dev, fm_dev->res,
+						  res.start, res.end + 1 - res.start, "muram");
+	if (unlikely(fm_dev->res == NULL)) {
+		dpaa_eth_err(dev, "__devm_request_region(muram) failed\n");
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->muram_vaddr = devm_ioremap(dev, fm_dev->muram_res->start,
+					   fm_dev->muram_res->end + 1 - fm_dev->muram_res->start);
+	if (unlikely(fm_dev->muram_vaddr == 0)) {
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-parser");
+	if (unlikely(dev_node == NULL))
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-parser) failed. "
+			"Won't be using the parser\n");
+	else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->parser_res = __devm_request_region(dev, fm_dev->res,
+							   res.start, res.end + 1 - res.start,
+							   "parser");
+		if (unlikely(fm_dev->res == NULL)) {
+			dpaa_eth_err(dev,
+				"__devm_request_region(parser) failed\n");
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->parser_vaddr = devm_ioremap(
+			dev,
+			fm_dev->parser_res->start,
+			fm_dev->parser_res->end + 1 - fm_dev->parser_res->start);
+		if (unlikely(fm_dev->parser_vaddr == 0)) {
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL,
+						"fsl,fman-keygen");
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-keygen) failed. "
+			"Won't be using the KeyGen\n");
+	} else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->keygen_res = __devm_request_region(dev, fm_dev->res,
+							   res.start, res.end + 1 - res.start,
+							   "keygen");
+		if (unlikely(fm_dev->res == NULL)) {
+			dpaa_eth_err(dev,
+				"__devm_request_region(keygen) failed\n");
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->keygen_vaddr = devm_ioremap(
+			dev,
+			fm_dev->keygen_res->start,
+			fm_dev->keygen_res->end + 1 - fm_dev->keygen_res->start);
+		if (unlikely(fm_dev->keygen_vaddr == 0)) {
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-policer");
+	if (unlikely(dev_node == NULL))
+		dpaa_eth_err(dev,
+			"of_find_compatible_node(fsl,fman-policer) failed. "
+			"Won't be using the policer\n");
+	else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+					dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->policer_res = __devm_request_region(dev, fm_dev->res,
+							    res.start, res.end + 1 - res.start,
+							    "policer");
+		if (unlikely(fm_dev->res == NULL)) {
+			dpaa_eth_err(dev,
+				"__devm_request_region(policer) failed\n");
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->policer_vaddr = devm_ioremap(
+			dev,
+			fm_dev->policer_res->start,
+			fm_dev->policer_res->end + 1 - fm_dev->policer_res->start);
+		if (unlikely(fm_dev->policer_vaddr == 0)) {
+			dpaa_eth_err(dev, "devm_ioremap() failed\n");
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	_errno = fm_dev->init(fm_dev);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	goto _return;
+
+_return_of_node_put:
+	of_node_put(dev_node);
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	return _errno;
+}
+
+static int __devexit __cold fm_remove(struct of_device *of_dev)
+{
+	int		 _errno;
+	struct device	*dev;
+
+	dev = &of_dev->dev;
+
+	_errno = free_fmdev((struct fm_device *)dev_get_drvdata(dev));
+
+	return _errno;
+}
+
+static const struct of_device_id fm_match[] __devinitconst = {
+	{
+		.compatible	= "fsl,fman"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, fm_match);
+
+static struct of_platform_driver fm_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= fm_match,
+	.owner		= THIS_MODULE,
+	.probe		= fm_probe,
+	.remove		= __devexit_p(fm_remove)
+};
+
+static int __init __cold fm_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", fm_driver_description);
+
+	_errno = of_register_platform_driver(&fm_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+		       __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(fm_load);
+
+static void __exit __cold fm_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&fm_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(fm_unload);
diff --git a/drivers/net/dpa/fm.h b/drivers/net/dpa/fm.h
new file mode 100644
index 0000000..0db26ef
--- /dev/null
+++ b/drivers/net/dpa/fm.h
@@ -0,0 +1,117 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_H
+#define __FM_H
+
+#include <linux/ioport.h>	/* struct resource */
+#include <linux/of_device.h>	/* struct of_device */
+#include <linux/irqreturn.h>	/* irqreturn_t */
+
+#define FM_FD_STAT_DME	       0x01000000      /* DMA Error - QMI */
+#define FM_FD_STAT_FHE	       0x00080000      /* Physical Error - BMI */
+#define FM_FD_STAT_FSE	       0x00040000      /* Frame Size Error - BMI */
+#define FM_FD_STAT_DIS	       0x00020000      /* Discarded frame - BMI */
+#define FM_FD_STAT_EOF	       0x00008000      /* Extract Out of Frame - KEYGEN */
+#define FM_FD_STAT_NSS	       0x00004000      /* No Scheme Selected - KEYGEN */
+#define FM_FD_STAT_FCL	       0x00000c00      /* Frame Color - Policer */
+#define FM_FD_STAT_IPP	       0x00000200      /* Illegal Policer Profile - Policer */
+#define FM_FD_STAT_PTE	       0x00000080      /* Parser Timeout Exceeded - Parser */
+#define FM_FD_STAT_ISP	       0x00000040      /* Invalid Soft Parser Instruction - Parser */
+#define FM_FD_STAT_PHE	       0x00000020      /* Parsing Header Error - Parser */
+#define FM_FD_STAT_ERRORS      (FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |     \
+				FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |     \
+				FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |     \
+				FM_FD_STAT_PHE)
+
+#define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
+#define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
+#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
+#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
+#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
+#define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
+
+/* Parse results memory layout */
+struct fman_parse_results {
+	uint8_t		lpid;
+	uint8_t		shimr;
+	uint16_t	l2r;
+	uint16_t	l3r;
+	uint8_t		l4r;
+	uint8_t		cplan;
+	uint16_t	nxthdr;
+	uint16_t	cksum;
+	uint32_t	lcv;
+	uint8_t		shim_off[3];
+	uint8_t		eth_off;
+	uint8_t		llc_snap_off;
+	uint8_t		vlan_off;
+	uint8_t		etype_off;
+	uint8_t		pppoe_off;
+	uint8_t		mpls_off;
+	uint8_t		ip_off;
+	uint8_t		gre_off;
+	uint8_t		l4_off;
+	uint8_t		nxthdr_off;
+} __packed;
+
+struct fm_device {
+	struct device	*dev;
+	void		*priv;
+	uint8_t		 cell_index;
+	struct resource	*res;
+	void		*vaddr;
+
+	struct resource	*muram_res;
+	void		*muram_vaddr;
+	struct resource	*parser_res;
+	void		*parser_vaddr;
+	struct resource	*keygen_res;
+	void		*keygen_vaddr;
+	struct resource	*policer_res;
+	void		*policer_vaddr;
+
+	int (*init)(struct fm_device *fm_dev);
+	irqreturn_t (*isr)(int irq, void *_fm_dev);
+	int (*uninit)(struct fm_device *fm_dev);
+};
+
+static inline void * __attribute((nonnull)) fmdev_priv(const struct fm_device *fm_dev)
+{
+	return (void *)fm_dev + sizeof(*fm_dev);
+}
+
+extern const char	*fm_driver_description;
+extern const size_t	 fm_sizeof_priv;
+extern void (* const fm_setup)(struct fm_device *fm_dev);
+
+#endif	/* __FM_H */
diff --git a/drivers/net/dpa/fman-conf.h b/drivers/net/dpa/fman-conf.h
new file mode 100644
index 0000000..e6768f8
--- /dev/null
+++ b/drivers/net/dpa/fman-conf.h
@@ -0,0 +1,1598 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     - Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     - Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     - Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * \section	Introduction
+ *
+ * This document details the low-level API that is provided for configuration of the Frame Manager
+ * (FMan) block in the Freescale DPA architecture (P4080). These API is used to set up
+ * classification, parsing, QoS and other FMan features.
+ *
+ * Both the FMan LLD/API and this document are work in progress. The implementation is incremental
+ * and centered around, on one side, the functionality implemented in the FMan model/simulator
+ * and, on the other side, the functionality used in the applications using this driver/API.
+ *
+ * As far as BG compliance goes, this driver/API is supposedly based on version/revision .79.
+ * However, where a discrepancy between the BGs and the model/simulator was identified the decision
+ * was made to be follow the model/simulator for the sake of maximizing the working feature set.
+ *
+ * The API is designed to have a consistent look-and-feel with the B/QMan drivers/API. Beyond
+ * that, the code tries to follow the Linux coding style and conventions.
+ *
+ * \section	Virtualization
+ *
+ * Certain components/modules of the FMan can be virtualized easier then others. The \ref BMI,
+ * \ref QMI, \ref Parser, \ref MAC and \ref MDIO can be virtualized easier, in the sense of being
+ * able to assign them to a hypervisor partition and be able to control them without the need to
+ * access global resources that might affect the stability and functionality of other hypervisor
+ * partitions. This virtualization is achieved by having registers mapped in a 4 KB page that can
+ * be mapped in the MMU to a single partition.
+ *
+ * Other blocks in the FMan such as the KeyGen, policer, etc. can be used by multiple partitions
+ * but their cofiguration needs to be programmed/done by a single partition (control-plane
+ * partition) on behalf of the other partitions (data-plane partitions).
+ *
+ * For more information on virtualization and partitioning please refer to the Freescale hypervisor
+ * documentation.
+ */
+
+#ifndef __FMAN_CONF_H
+#define __FMAN_CONF_H
+
+/** \defgroup	Port	Port
+ *  \defgroup	BMI	BMI - BMan interface
+ *  \defgroup	QMI	QMI - QMan interface
+ *  \defgroup	Parser	Parser
+ *  \defgroup	KeyGen	KeyGen - Key generator
+ *  \defgroup	DMA	DMA
+ *  \defgroup	FPM	FPM - FMan processing manager
+ *  \defgroup	Policer	Policer
+ *  \defgroup	MAC	MAC
+ *  \defgroup	MDIO	MDIO
+ */
+
+/* Register level abstraction */
+
+/** \addtogroup	Port
+ *  \details	A port contains the registers for the \ref BMI, \ref QMI and \ref Parser
+ *  @{
+ */
+
+/** \addtogroup	BMI
+ *  @{
+ */
+
+/** \internal
+ *  \brief	BMI commmon port register layout
+ *
+ *  This is a FMan LLD private data structure and should _not_ be used anywhere including in the
+ *  FMan LLD.
+ *
+ *  It is the method of choice for describing the FMan registers offsets and it exists only for that
+ *  purpose.
+ *
+ */
+struct fm_bmi_common_mmap_s {
+	uint32_t	FMBM_INIT;	/* Initialization */
+	uint32_t	FMBM_CFG[3];	/* Configuration */
+	uint8_t		reserved0[0x10];
+	uint32_t	FMBM_IVER;	/* Interrupt EVent */
+	uint32_t	FMBM_IER;	/* Interrupt Enable */
+	uint32_t	FMBM_IFR;	/* Interrupt Force */
+	uint8_t		reserved1[0x14];
+	uint32_t	FMBM_ARB[8];	/* Arbitration */
+	uint32_t	FMBM_BCMA;	/* Buffers Command Mutual Exclusive Access */
+	uint32_t	FMBM_EBC;	/* External Buffers Command */
+	uint32_t	FMBM_EBCR;	/* External Buffers Command Result */
+	uint32_t	FMBM_EPRH;	/* External PointeR High */
+	uint32_t	FMBM_EPRL;	/* External PointeR Low */
+	uint8_t		reserved2[0x18];
+	uint32_t	FMBM_DTC[3];	/* Debug Trap Counter */
+	uint8_t		reserved3[0x4];
+	uint32_t	FMBM_DCV[12];	/* Debug Compare Value */
+	uint32_t	FMBM_DCM[12];	/* Debug Compare Mask */
+	uint32_t	FMBM_GDE;	/* Global Debug Enable */
+	uint32_t	FMBM_PP[63];	/* Port Parameters */
+	uint8_t		reserved4[0x4];
+	uint32_t	FMBM_IPS;	/* Internal Probe Select */
+	uint32_t	FMBM_PFS[63];	/* Port FIFO Size */
+	uint32_t	FMBM_IPD;	/* Internal Probe Data */
+	uint32_t	FMBM_PPID[63];	/* Port Partition ID */
+} __aligned(0x400) __packed;
+
+#define FM_BMI_COMMON_INIT_STR	0x80000000		/* Start */
+
+#define FM_BMI_COMMON_CFG0_FBPS(n)	((n) << 16)	/* Free Buffer Pool Size */
+#define FM_BMI_COMMON_CFG0_FMBM_OF(n)	(n)		/* Free Buffer Pool OFfset */
+#define FM_BMI_COMMON_CFG1_TNTSKS(n)	((n) << 16)	/* Total Number of TaSKS */
+#define FM_BMI_COMMON_CFG1_TDMA(n)	(n)		/* Total DMA */
+
+/** \internal
+ *  \brief		BMI offline parsing/host command port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_oh_mmap_s {
+	uint8_t		reserved0[0x400];
+} __aligned(0x400) __packed;
+
+/** \internal
+ *  \brief		BMI Rx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_rx_mmap_s {
+	uint32_t	FMBM_RCFG;	/* Configuration */
+	uint32_t	FMBM_RST;	/* Status */
+	uint32_t	FMBM_RDA;	/* DMA Attributes */
+	uint32_t	FMBM_RFP;	/* FIFO Parameters */
+	uint32_t	FMBM_RFED;	/* Frame End Data */
+	uint32_t	FMBM_RICP;	/* Internal Context Parameters */
+	uint32_t	FMBM_RIM;	/* Internal Margins */
+	uint32_t	FMBM_REBM;	/* External Buffer Margins */
+	uint32_t	FMBM_RFNE;	/* Frame Next Engine */
+	uint32_t	FMBM_RFCA;	/* Frame Command Attributes */
+	uint32_t	FMBM_RFPNE;	/* Frame Parser Next Engine */
+	uint32_t	FMBM_RPSO;	/* Parse Start Offset */
+	uint32_t	FMBM_RPP;	/* Policer Profile */
+	uint32_t	FMBM_RCCB;	/* Coarse Classification Base */
+	uint8_t		reserved0[0x8];
+	uint32_t	FMBM_RPRAI[8];	/* Parse Results Array Initialization */
+	uint32_t	FMBM_RFQID;	/* Frame Queue ID */
+	uint32_t	FMBM_REFQID;	/* Error Frame Queue ID */
+	uint32_t	FMBM_RFSDM;	/* Frame Status Discard Mask */
+	uint32_t	FMBM_RFSEM;	/* Frame Status Error Mask */
+	uint32_t	FMBM_RFENE;	/* Frame Enqueue Next Engine */
+	uint8_t		reserved1[0x8c];
+	uint32_t	FMBM_EBMPI[8];	/* Buffer Manager Pool Information */
+	uint32_t	FMBM_ACNT[8];	/* Allocate CouNTer */
+	uint8_t		reserved2[0x20];
+	uint32_t	FMBM_CGM[8];	/* Congestion Group Map */
+	uint32_t	FMBM_MPD;	/* Pool Depletion */
+	uint8_t		reserved3[0x7c];
+	uint32_t	FMBM_RSTC;	/* STatistics Counter */
+	uint32_t	FMBM_RFRC;	/* FRame Counter */
+	uint32_t	FMBM_RBFC;	/* Bad Frames Counter */
+	uint32_t	FMBM_RLFC;	/* Large Frames Counter */
+	uint32_t	FMBM_RFFC;	/* Filter Frames Counter */
+	uint32_t	FMBM_RFDC;	/* Frames Discard Counter */
+	uint32_t	FMBM_RFLDEC;	/* Frames List DMA Error Counter */
+	uint32_t	FMBM_RODC;	/* Out of buffers Discard Counter */
+	uint32_t	FMBM_RBDC;	/* Buffers Deallocate Counter */
+	uint8_t		reserved4[0x5c];
+	uint32_t	FMBM_RPC;	/* Performance Counters */
+	uint32_t	FMBM_RPCP;	/* Performance Count Parameters */
+	uint32_t	FMBM_RCCN;	/* Cycle CouNter */
+	uint32_t	FMBM_RTUC;	/* Task Utilization Counter */
+	uint32_t	FMBM_RRQUC;	/* Receive Queue Utilization Counter */
+	uint32_t	FMBM_RDUC;	/* DMA Utilization Counter */
+	uint32_t	FMBM_RFUC;	/* FIFO Utilization Counter */
+	uint32_t	FMBM_RPAC;	/* Pause Activation Counter */
+	uint8_t		reserved5[0x60];
+	uint32_t	FMBM_RDCFG[3];	/* Debug ConFiGuration */
+	uint8_t		reserved6[0x74];
+	uint32_t	FMBM_RIBA;	/* Internal Buffer Allocation */
+	uint32_t	FMBM_RIBD;	/* Internal Buffer Deallocation */
+	uint32_t	FMBM_RIBC;	/* Internal Buffer Chain */
+	uint32_t	FMBM_RIBLF;	/* Internal Buffer Link Follow */
+	uint8_t		reserved7[0x70];
+} __aligned(0x400) __packed;
+
+#define FM_BMI_RX_RCFG_EN		0x80000000	/* ENable */
+#define FM_BMI_RX_RCFG_FDOVR		0x02000000	/* Frame Discard OVerRide */
+#define FM_BMI_RX_RCFG_IM		0x01000000	/* Independent Mode */
+
+#define FM_BMI_RX_RFED_CSI(n)		((n) << 24)	/* CheckSum Ignore */
+#define FM_BMI_RX_RFED_CFED(n)		((n) << 16)	/* Chop Frame's End Data */
+
+#define FM_BMI_RX_RICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
+#define FM_BMI_RX_RICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
+#define FM_BMI_RX_RICP_ICSZ(n)		(n)		/* Internat Context SiZe */
+
+#define FM_BMI_RX_RIM_FOF(n)		((n) << 24)	/* Frame OFfset */
+
+#define FM_BMI_RX_REBM_BSM(n)		((n) << 16)	/* Buffer Start Margin */
+#define FM_BMI_RX_REBM_BEM(n)		(n)		/* Buffer End Margin */
+
+#define FM_BMI_RX_RFNE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_RX_RFCA_OR		0x80000000	/* ORder definition */
+#define FM_BMI_RX_RFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
+#define FM_BMI_RX_RFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
+#define FM_BMI_RX_RFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
+#define FM_BMI_RX_RFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
+#define FM_BMI_RX_RFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
+#define FM_BMI_RX_RFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
+
+#define FM_BMI_RX_RFPNE_HPNIA(n)	(n)		/* Hardware Parser Next Invoked Action */
+
+#define FM_BMI_RX_RPSO_PSO(n)		(n)		/* Parsing Start Offset */
+
+#define FM_BMI_RX_RPP_PNUM(n)		(n)		/* Policer profile */
+
+#define FM_BMI_RX_RCCB_CBASE(n)		(n)		/* Coarse classification BASE */
+
+#define FM_BMI_RX_RPRAI_PRA(n)		(n)		/* Parse Results Array */
+
+#define FM_BMI_RX_RFQID_DFQID(n)	(n)		/* Default Frame Queue ID */
+
+#define FM_BMI_RX_REFQID_EFQID(n)	(n)		/* Error Frame Queue ID */
+
+#define FM_BMI_RX_RFSDM_FSDM(n)		(n)		/* Frame Status Discard Mask */
+
+#define FM_BMI_RX_RFSEM_FSEM(n)		(n)		/* Frame Status Error Mask */
+
+#define FM_BMI_RX_RFENE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_RX_EBMPI_VAL		0x80000000	/* Valid */
+#define FM_BMI_RX_EBMPI_ADCE		0x40000000	/* Allocate/Deallocate Coutners Enable */
+#define FM_BMI_RX_EBMPI_BPID(n)		((n) << 16)	/* Buffer Pool ID */
+#define FM_BMI_RX_EBMPI_PBS(n)		(n)		/* Pool Buffer Size */
+
+/** \internal
+ *  \brief		BMI Tx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_tx_mmap_s {
+	uint32_t	FMBM_TCFG;	/* Configuration */
+	uint32_t	FMBM_TST;	/* STatus */
+	uint32_t	FMBM_TDA;	/* DMA Attributes */
+	uint32_t	FMBM_TFP;	/* FIFO Parameters */
+	uint32_t	FMBM_TFED;	/* Frame End Data */
+	uint32_t	FMBM_TICP;	/* Internal Context Paramenters */
+	uint32_t	FMBM_TFNE;	/* Frame Next Engine */
+	uint32_t	FMBM_TFCA;	/* Framme Command Attributes */
+	uint32_t	FMBM_TCFQID;	/* Confirmation Queue ID */
+	uint32_t	FMBM_TEFQID;	/* Error Frame Queue ID */
+	uint32_t	FMBM_TFENE;	/* Frame Enqueue Next Engine */
+	uint32_t	FMBM_TRLMTS;	/* Rate LiMiTer Scale */
+	uint32_t	FMBM_TRLMT;	/* Rate LiMiTer */
+	uint8_t		reserved0[0x1cc];
+	uint32_t	FMBM_TSTC;	/* STatistics Counter */
+	uint32_t	FMBM_TFRC;	/* FRame Counter */
+	uint32_t	FMBM_TFDC;	/* Frames Discard Counter */
+	uint32_t	FMBM_TFLEDC;	/* Framees Length Error Discard Counter */
+	uint32_t	FMBM_TFUFDC;	/* Frames Unsupported Format Discard Counter */
+	uint32_t	FMBM_TBDC;	/* Buffer Deallocate Counter */
+	uint8_t		reserved1[0x68];
+	uint32_t	FMBM_TPC;	/* Performance Counters */
+	uint32_t	FMBM_TPCP;	/* Performance Count Parameters */
+	uint32_t	FMBM_TCCN;	/* Cycle Counter */
+	uint32_t	FMBM_TTUC;	/* Tasks Utilization Counter */
+	uint32_t	FMBM_TTCQUC;	/* Transmit Confirm Queue Utilization Counter */
+	uint32_t	FMBM_TDUC;	/* DMA Utilization Counter */
+	uint32_t	FMBM_TFUC;	/* FIFO Utilization Counter */
+	uint8_t		reserved2[0x64];
+	uint32_t	FMBM_TDCFG[3];	/* Debug ConFiGuration */
+	uint8_t		reserved3[0x74];
+	uint32_t	FMBM_TIBA;	/* Internal Buffer Allocation */
+	uint32_t	FMBM_TIBD;	/* Internal Buffer Deallocation */
+	uint32_t	FMBM_TIBC;	/* Internal Buffer Chain */
+	uint32_t	FMBM_TIBLF;	/* Internal Buffer Link Follow */
+	uint8_t		reserved4[0x70];
+} __aligned(0x400) __packed;
+
+#define FM_BMI_TX_TCFG_EN		0x80000000	/* ENable  */
+#define FM_BMI_TX_TCFG_IM		0x01000000	/* Independent Mode */
+
+#define FM_BMI_TX_TFP_MFL(n)		((n) << 16)	/* Minimum Fill Level */
+#define FM_BMI_TX_TFP_DPDE(n)		((n) << 12)	/* Dequeue Pipeline Depth */
+#define FM_BMI_TX_TFP_FLCL(n)		(n)		/* FIFO Low Comfort Level */
+
+#define FM_BMI_TX_TICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
+#define FM_BMI_TX_TICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
+#define FM_BMI_TX_TICP_ICSZ(n)		(n)		/* Internat Context SiZe */
+
+#define FM_BMI_TX_TFNE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_TX_TFCA_OR		0x80000000	/* ORder definition */
+#define FM_BMI_TX_TFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
+#define FM_BMI_TX_TFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
+#define FM_BMI_TX_TFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
+#define FM_BMI_TX_TFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
+#define FM_BMI_TX_TFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
+#define FM_BMI_TX_TFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
+
+#define FM_BMI_TX_TCFQID_CFQID(n)	(n)		/* Confirmation Frame Queue ID */
+
+#define FM_BMI_TX_TFENE_NIA(n)		(n)		/* Next Invoked Action */
+
+/** \internal
+ *  \brief		The BMI part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+union fm_port_bmi_mmap_u {
+	struct fm_bmi_common_mmap_s	common;
+	struct fm_bmi_oh_mmap_s		oh;
+	struct fm_bmi_rx_mmap_s		rx;
+	struct fm_bmi_tx_mmap_s		tx;
+} __aligned(0x400) __packed;
+
+/** BMI common register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI common register. This offset is suitable for using
+ *  with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that initializes the internal (MURAM) free buffer pool by writing
+ *  into the FMBM_INIT register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *common_port;
+ *		...
+ *	common_port = fm_port_create(0xfe480000);
+ *		...
+ *	fm_port_out(common_port, FM_BMI_COMMON(INIT), FM_BMI_COMMON_INIT_STR);
+ *		...
+ *	fm_port_destroy(common_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_COMMON(reg)	\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_common_mmap_s, FMBM_##reg))
+
+/** BMI offline parsing/host command register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI offline parsing/host command register. This offset is
+ *  suitable for using with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a O/H port for TX by writing into the FMBM_OCFG
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *oh_port;
+ *		...
+ *	oh_port = fm_port_create(0xfe481000);
+ *		...
+ *	fm_port_out(oh_port, FM_BMI_OH(OCFG), FM_BMI_OH_OCFG_EN);
+ *		...
+ *	fm_port_destroy(oh_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_OH(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_oh_mmap_s, FMBM_##reg))
+
+/** BMI RX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI RX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that reads the status of a RX port by reading from the FMBM_RST
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *rx_port;
+ *		...
+ *	rx_port = fm_port_create(0xfe488000);
+ *		...
+ *	while (fm_port_in(rx_port, FM_BMI_RX(RST)) & FM_BMI_RX_RST_BSY)
+ *		cpu_relax();
+ *	/ * Port not busy * /
+ *		...
+ *	fm_port_destroy(rx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_RX(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_rx_mmap_s, FMBM_##reg))
+
+/** BMI TX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI TX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables TX by writing into the FMBM_TCFG register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *tx_port;
+ *		...
+ *	tx_port = fm_port_create(0xfe4a8000);
+ *		...
+ *	fm_port_out(tx_port, FM_BMI_TX(TCFG), FM_BMI_TX_RCFG_EN);
+ *		...
+ *	fm_port_destroy(tx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_TX(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_tx_mmap_s, FMBM_##reg))
+
+/** @} */
+
+/** \addtogroup	QMI
+ *  @{
+ */
+
+/** \internal
+ *  \brief		QMI common port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_common_mmap_s {
+	uint32_t	FMQM_GC;	/* Global Configuration */
+	uint8_t		reserved0[4];
+	uint32_t	FMQM_EIE;	/* Error Interrupt Event */
+	uint32_t	FMQM_EIEN;	/* Error Interrupt Enable */
+	uint32_t	FMQM_EIF;	/* Error Interrupt Force */
+	uint8_t		reserved1[0x3ec];
+} __aligned(0x400) __packed;
+
+#define FM_QMI_COMMON_GC_EN		0x80000000	/* ENable */
+#define FM_QMI_COMMON_GC_ACC		0x40000000	/* All Counters Clear */
+#define FM_QMI_COMMON_GC_STEN		0x10000000	/* global STatistics Enable */
+#define FM_QMI_COMMON_GC_SR		0x01000000	/* Soft Reset */
+
+#define FM_QMI_IRQ_DEE			0x80000000	/* Double-bit ECC Error */
+
+/** \internal
+ *  \brief		QMI offline parsing/host command and Tx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_oh_tx_mmap_s {
+	uint8_t		reserved0[0x30];
+	uint32_t	FMQM_PDC;	/* Dequeue Configuration */
+	uint8_t		reserved1[0x3cc];
+} __aligned(0x400) __packed;
+
+#define FM_QMI_OH_PDC_PRI		0x80000000	/* Priority */
+#define FM_QMI_OH_PDC_OPT(n)		((n) << 28)	/* dequeue OPTions */
+#define FM_QMI_OH_PDC_PF		0x02000000	/* PreFetch */
+#define FM_QMI_OH_PDC_FRM		0x01000000	/* FRaMe count */
+/* Sub-Portal */
+#define FM_QMI_OH_PDC_SP_MASK		0x00f00000
+#define FM_QMI_OH_PDC_SP(n)		((n) << 20 & FM_QMI_OH_PDC_SP_MASK)
+#define FM_QMI_OH_PDC_WQ(n)		((n) << 16)	/* Work Queue */
+#define FM_QMI_OH_PDC_BC(n)		(n)		/* Byte Count */
+
+#define FM_QMI_TX_PDC_PRI		FM_QMI_OH_PDC_PRI
+#define FM_QMI_TX_PDC_OPT		FM_QMI_OH_PDC_OPT
+#define FM_QMI_TX_PDC_PF		FM_QMI_OH_PDC_PF
+#define FM_QMI_TX_PDC_FRM		FM_QMI_OH_PDC_FRM
+#define FM_QMI_TX_PDC_SP		FM_QMI_OH_PDC_SP
+#define FM_QMI_TX_PDC_WQ		FM_QMI_OH_PDC_WQ
+#define FM_QMI_TX_PDC_BC		FM_QMI_OH_PDC_BC
+
+/** \internal
+ *  \brief		QMI Rx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_rx_mmap_s {
+	uint8_t		reserved0[0x400];
+} __aligned(0x400) __packed;
+
+/** \internal
+ *  \brief		The QMI part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+union fm_port_qmi_mmap_u {
+	struct fm_qmi_common_mmap_s	common;
+	struct fm_qmi_oh_tx_mmap_s	oh;
+	struct fm_qmi_rx_mmap_s		rx;
+	struct fm_qmi_oh_tx_mmap_s	tx;
+} __aligned(0x400) __packed;
+
+/** QMI common register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI common register. This offset is suitable for using
+ *  with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables QMI enqueues and dequeues by writing into the FMQM_GC
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *common_port;
+ *		...
+ *	common_port = fm_port_create(0xfe480000);
+ *		...
+ *	fm_port_out(common_port, FM_QMI_COMMON(GC),
+ *			FM_QMI_COMMON_GC_ENQ_EN | FM_QMI_COMMON_GC_DEQ_EN);
+ *		...
+ *	fm_port_destroy(common_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_COMMON(reg)	\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_common_mmap_s, FMQM_##reg))
+
+/** QMI offline parsing/host command register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI offline parsing/host command register. This offset is
+ *  suitable for using with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a O/H port by writing into the FMQM_PC register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *oh_port;
+ *		...
+ *	oh_port = fm_port_create(0xfe481000);
+ *		...
+ *	fm_port_out(oh_port, FM_QMI_OH(PC), FM_QMI_OH_PC_EN);
+ *		...
+ *	fm_port_destroy(oh_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_OH(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
+
+/** QMI RX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI RX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that reads the enqueue status of a RX port by reading from the
+ *  FMQM_PS register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *rx_port;
+ *		...
+ *	rx_port = fm_port_create(0xfe488000);
+ *		...
+ *	while (fm_port_in(rx_port, FM_QMI_RX(PS)) & FM_QMI_RX_PS_PBSY_ET)
+ *		cpu_relax();
+ *	/ * Port not busy with enqueues * /
+ *		...
+ *	fm_port_destroy(rx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_RX(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_rx_mmap_s, FMQM_##reg))
+
+/** QMI TX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI TX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a TX port by writing into the FMQM_PC register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *tx_port;
+ *		...
+ *	tx_port = fm_port_create(0xfe4a8000);
+ *		...
+ *	fm_port_out(tx_port, FM_QMI_TX(PC), FM_QMI_TX_PC_EN);
+ *		...
+ *	fm_port_destroy(tx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_TX(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
+
+/** @} */
+
+/** \addtogroup	Parser
+ *  @{
+ */
+
+/** \internal
+ *  \brief		Parser common/global register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_parser_common_mmap_s {
+	uint8_t		FMPR_PMDA[0x800];	/* Parse Memory Direct Access */
+	uint32_t	FMPR_SXPAW[0x10];	/* Soft eXamination Parameter Array */
+	uint32_t	FMPR_RPCLIM;		/* Parsing Cycle LImit */
+	uint32_t	FMPR_RPIMAC;		/* Internal Memory Access Control */
+	uint32_t	FMPR_PMEEC;		/* Parse Memory EEC Error Capture */
+	uint8_t		reserved0[0x14];
+	uint32_t	FMPR_PEVR;		/* Event */
+	uint32_t	FMPR_PEVER;		/* Event Enable */
+	uint8_t		reserved1[4];
+	uint32_t	FMPR_PERR;		/* Error */
+	uint32_t	FMPR_PERER;		/* Error Enable */
+	uint8_t		reserved2[0x78c];
+} __aligned(0x1000) __packed;
+
+#define FM_PARSER_COMMON_RPCLIM_RHPCLIM(n)	(n)		/* maximum Parse Cycle LIMit */
+
+#define FM_PARSER_COMMON_RPIMAC_PSTAT		0x00000100	/* Parser STATus */
+#define FM_PARSER_COMMON_RPIMAC_PEN		0x00000001	/* Parser ENable */
+
+#define FM_PARSER_COMMON_PMEEC_CAP		0x80000000	/* CAPtured error indication */
+#define FM_PARSER_COMMON_PMEEC_CET		0x40000000	/* Captured Error Type */
+#define FM_PARSER_COMMON_PMEEC_SERCNT(n)	((n) << 16)	/* Soft ERror CouNTer */
+#define FM_PARSER_COMMON_PMEEC_MEMADDR(n)	(n)		/* ECC error MEMory ADDRess */
+
+#define FM_PARSER_IRQ_SPI(n)			(1 << (16 + (n)))	/* Stopped Port is not Idle */
+#define FM_PARSER_IRQ_SCM			0x00004000	/* Single-bit ECC is at Max */
+
+#define FM_PARSER_EIRQ_IA(n)			(1 << (16 + (n)))	/* Illegal Access */
+#define FM_PARSER_EIRQ_IAG			FM_PARSER_EIRQ_IA(-1)	/* Illegal Access Global*/
+#define FM_PARSER_EIRQ_ECCE			0x00004000		/* ECC multiple-bit Error */
+
+/** \internal
+ *  \brief		The parser part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_port_parser_mmap_s {
+	uint8_t		FMPR_PMDA[0x80];	/* Parse Memory Direct Access */
+	uint8_t		reserved0[0x378];
+	uint32_t	FMPR_PCAC;		/* Configuration Access Control */
+	uint32_t	FMPR_PCTPID;		/* Configured TPID */
+} __aligned(0x400) __packed;
+
+#define FM_PARSER_PCAC_PSTAT	0x00000100	/* Port STATus */
+#define FM_PARSER_PCAC_PSTOP	0x00000001	/* Port STOP */
+
+/** Parser common/global register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a parser common/global register. This offset is suitable
+ *  for using with the fm_in() and fm_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that disables the parser by writing into the FMPR_RPIMAC register:
+ *
+ *  \code
+ *		...
+ *	struct fman *fm;
+ *		...
+ *	fm = fm_create(0xfe400000);
+ *		...
+ *	fm_out(fm, FM_PARSER_COMMON(RPIMAC), 0);
+ *		...
+ *	fm_destroy(fm);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_PARSER_COMMON(reg)	\
+	(offsetof(struct fm_mmap_s, parser) + offsetof(struct fm_parser_common_mmap_s, FMPR_##reg))
+
+/** Parser register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a parser register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that stops a parser port by writing and reading the FMPR_PCAC
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *port;
+ *		...
+ *	port = fm_port_create(0xfe488000);
+ *		...
+ *	fm_port_out(port, FM_PARSER(PCAC), FM_PARSER_PCAC_PSTOP);
+ *	while (fm_port_in(port, FM_PARSER(PCAC)) & FM_PARSER_PCAP_PSTAT)
+ *		cpu_relax();
+ *	/ * The port is stopped * /
+ *		...
+ *	fm_port_destroy(port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_PARSER(reg)		\
+	(offsetof(struct fm_port_mmap_s, parser) + offsetof(struct fm_port_parser_mmap_s, FMPR_##reg))
+
+/** @} */
+
+/* Port */
+
+/** \internal
+ *  \brief		Aggregated port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_port_mmap_s {
+	union fm_port_bmi_mmap_u	bmi;
+	union fm_port_qmi_mmap_u	qmi;
+	struct fm_port_parser_mmap_s	parser;
+	uint8_t				reserved0[0x400];
+} __aligned(0x1000) __packed;
+
+/** @} */
+
+/* Policer */
+
+/** \addtogroup	Policer
+ *  @{
+ */
+
+/** \internal
+ *  \brief		Policer register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_policer_mmap_s {
+	uint8_t		reserved0[0x8c];
+	uint32_t	FMPL_PAR;		/* Profile Action */
+	uint32_t	FMPL_PE_MODE;		/* Profile Entry Mode */
+	uint8_t		reserved1[0xf6c];
+} __aligned(0x1000) __packed;
+
+/** Policer register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPL_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a policer register. This offset is suitable for using with
+ *  the fm_in() and fm_out() functions.
+ *
+ *  \hideinitializer
+ */
+#define FM_POLICER(reg)	\
+	(offsetof(struct fm_mmap_s, policer) + offsetof(struct fm_policer_mmap_s, FMPL_##reg))
+
+/** @} */
+
+/* KeyGen */
+
+/** \addtogroup KeyGen
+ *  @{
+ */
+
+/** \internal
+ *  \brief		KeyGen scheme register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_keygen_scheme_entry_mmap_s {
+	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
+	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
+	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
+	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
+	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
+	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
+	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
+	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
+	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
+	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
+	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
+	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
+	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
+} __aligned(0x100) __packed;
+
+/** \internal
+ *  \brief		KeyGen register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ *  \todo		Identified a suitable overlaying scheme for port partitions, classification
+ *			plans and classification schemes
+ */
+struct fm_keygen_mmap_s {
+	uint32_t	FMKG_GCR;	/* General Configuration */
+	uint32_t	FMKG_ER;	/* Event */
+	uint32_t	FMKG_EMR;	/* Event Mask */
+	uint32_t	FMKG_EER;	/* Error Event */
+	uint32_t	FMKG_EEMR;	/* Error Event Mask */
+	uint32_t	FMKG_SER;	/* Scheme Event */
+	uint32_t	FMKG_SEMR;	/* Scheme Event Mask */
+	uint32_t	FMKG_SEER;	/* Scheme Error Event */
+	uint32_t	FMKG_SEEMR;	/* Scheme Error Event Mask */
+	uint32_t	FMKG_GSR;	/* Global Status */
+	uint32_t	FMKG_TPC;	/* Total Packet Counter */
+	uint32_t	FMKG_SERC;	/* Soft Error Capture */
+	uint8_t		reserved0[0x10];
+	uint32_t	FMKG_FDOR;	/* Frame Data Offset */
+	uint32_t	FMKG_GDVR[2];	/* Global Default Value */
+	uint8_t		reserved1[0xb4];
+	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
+	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
+	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
+	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
+	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
+	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
+	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
+	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
+	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
+	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
+	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
+	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
+	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
+	uint8_t		reserved2[0xa8];
+	uint32_t	FMKG_AR;	/* Action */
+	uint8_t		reserved3[0xe00];
+} __aligned(0x1000) __packed;
+
+#define FM_KEYGEN_GCR_EN		0x80000000		/* ENable */
+#define FM_KEYGEN_GCR_DEFNIA(n)		(n)			/* DEFault Next Invoked Action */
+
+#define FM_KEYGEN_EIRQ_DECC		0x80000000		/* Double-bit ECC error */
+#define FM_KEYGEN_EIRQ_IEE		0x40000000		/* Initialization Entry Error */
+#define FM_KEYGEN_EIRQ_KSO		0x20000000		/* KeyGen Size Overflow */
+
+#define FM_KEYGEN_SIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme interrupt */
+
+#define FM_KEYGEN_SEIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme error interrupt */
+
+#define FM_KEYGEN_GSR_BSY		0x80000000		/* Busy */
+
+#define FM_KEYGEN_TPC_TPCNT(n)		(n)			/* Total Packet CouNTer */
+
+#define FM_KEYGEN_SERC_CAP		0x80000000		/* CAPtured error indication */
+#define FM_KEYGEN_SERC_CET		0x40000000		/* Captured Error Type */
+#define FM_KEYGEN_SERC_SERCNT(n)	((n) << 16)		/* Soft ERror CouNTer */
+#define FM_KEYGEN_SERC_ET		0x00008000		/* Entry Type */
+#define FM_KEYGEN_SERC_SOFS(n)		((n) << 8)		/* Scheme OFfSet capture */
+#define FM_KEYGEN_SERC_NUM(n)		(n)			/* Scheme/Classification plan NUMber capture */
+
+#define FM_KEYGEN_FDOR_OFFSET(n)	(n)			/* OFFSET to the end of the parsing point */
+
+#define FM_KEYGEN_GDVR_DV(n)		(n)			/* Default Value */
+
+#define FM_KEYGEN_AR_GO			0x80000000		/* Activate the atomic scheme entry access */
+#define FM_KEYGEN_AR_RW			0x40000000		/* Read/Write access type */
+#define FM_KEYGEN_AR_PORTID(n)		((n) << 24)		/* Port ID */
+/* SELect entry */
+#define FM_KEYGEN_AR_SEL_MASK		0x00c00000
+#define FM_KEYGEN_AR_SEL(n)		((n) << 22 & FM_KEYGEN_AR_SEL_MASK)
+/* Scheme/Classification NUMber */
+#define FM_KEYGEN_AR_NUM_MASK		0x001f0000
+#define FM_KEYGEN_AR_NUM(n)		((n) << 16 & FM_KEYGEN_AR_NUM_MASK)
+#define FM_KEYGEN_AR_WSEL(n)		(n)			/* Word SELect */
+
+#define FM_KEYGEN_SE_MODE_SI		0x80000000		/* Scheme Initialization bit */
+#define FM_KEYGEN_SE_MODE_IM		0x40000000		/* Index Mode */
+#define FM_KEYGEN_SE_MODE_PL		0x01000000		/* PoLicer type */
+#define FM_KEYGEN_SE_MODE_NIA(n)	(n)			/* scheme Next Instruction Address */
+#define FM_KEYGEN_EKFC_PORTID		0x80000000		/* PORT ID */
+#define FM_KEYGEN_EKFC_MACDST		0x40000000		/* MAC DeSTination address */
+#define FM_KEYGEN_EKFC_MACSRC		0x20000000		/* MAC SouRCe address */
+#define FM_KEYGEN_EKFC_TC1		0x10000000		/* TCI from the first VLAN header */
+#define FM_KEYGEN_EKFC_TC2		0x08000000		/* TCI from the second VLAN header */
+#define FM_KEYGEN_EKFC_ETYPE		0x04000000		/* Ethernet TYPE */
+#define FM_KEYGEN_EKFC_PPPSID		0x02000000		/* PPPoE Session ID */
+#define FM_KEYGEN_EKFC_PPPPID		0x01000000		/* PPPoE Protocol ID */
+#define FM_KEYGEN_EKFC_MPLS1		0x00800000		/* MPLS from first label */
+#define FM_KEYGEN_EKFC_MPLS2		0x00400000		/* MPLS from seconf label */
+#define FM_KEYGEN_EKFC_MPLS3		0x00200000		/* MPLS from third label */
+#define FM_KEYGEN_EKFC_IPSRC		0x00100000		/* IP SouRCe address */
+#define FM_KEYGEN_EKFC_IPDST		0x00080000		/* IP DeSTination Address */
+#define FM_KEYGEN_EKFC_PTYPE		0x00040000		/* IP Protocol TYPE */
+#define FM_KEYGEN_EKFC_IPTOS		0x00020000		/* IP Type Of Service */
+#define FM_KEYGEN_EKFC_TIPSRC		0x00008000		/* Tunneled IP SouRCe address */
+#define FM_KEYGEN_EKFC_TIPDST		0x00004000		/* Tunneled IP DeSTination address */
+#define FM_KEYGEN_EKFC_TIPTYPE		0x00002000		/* Tunneled IP Protocol TYPE */
+#define FM_KEYGEN_EKFC_TIPTOS		0x00001000		/* Tunneled IP Type Of Service */
+#define FM_KEYGEN_EKFC_IPSECSPI		0x00000400		/* IPSEC SPI */
+#define FM_KEYGEN_EKFC_IPSECNH		0x00000200		/* IPSEC Next Header */
+#define FM_KEYGEN_EKFC_L4PSRC		0x00000004		/* L4 Protocol SouRCe port */
+#define FM_KEYGEN_EKFC_L4PDST		0x00000002		/* L4 Protocol DeSTination port */
+#define FM_KEYGEN_EKFC_TFLG		0x00000001		/* TCP FLaGs */
+
+#define FM_KEYGEN_EKDV_MACDV(n)		((n) << 30)		/*  */
+#define FM_KEYGEN_EKDV_TCDV(n)		((n) << 28)		/*  */
+#define FM_KEYGEN_EKDV_ETYPEDV(n)	((n) << 26)		/*  */
+#define FM_KEYGEN_EKDV_PPPSIDDV(n)	((n) << 24)		/*  */
+#define FM_KEYGEN_EKDV_PPPPIDDV(n)	((n) << 22)		/*  */
+#define FM_KEYGEN_EKDV_MPLSDV(n)	((n) << 20)		/*  */
+#define FM_KEYGEN_EKDV_IPADV(n)		((n) << 18)		/*  */
+#define FM_KEYGEN_EKDV_PTYPEDV(n)	((n) << 16)		/*  */
+#define FM_KEYGEN_EKDV_IPTOSDV(n)	((n) << 14)		/*  */
+#define FM_KEYGEN_EKDV_IP6FLDV(n)	((n) << 12)		/*  */
+#define FM_KEYGEN_EKDV_IPSECSPIDV(n)	((n) << 10)		/*  */
+#define FM_KEYGEN_EKDV_L4PDV(n)		((n) << 8)		/*  */
+#define FM_KEYGEN_EKDV_TFLAGDV(n)	((n) << 6)		/*  */
+
+#define FM_KEYGEN_BMCH_MCS0(n)		((n) << 26)		/* Mask Command Select 0 */
+#define FM_KEYGEN_BMCH_MCS1(n)		((n) << 20)		/* Mask Command Select 1 */
+#define FM_KEYGEN_BMCH_MO0(n)		((n) << 16)		/* Mask Offset0 */
+#define FM_KEYGEN_BMCH_MCS2(n)		((n) << 10)		/* Mask Command Select 2 */
+#define FM_KEYGEN_BMCH_MCS3(n)		((n) << 4)		/* Mast Command Select 3 */
+#define FM_KEYGEN_BMCH_MO1(n)		(n)			/* Mask Offst 1 */
+
+#define FM_KEYGEN_BMCL_BM0(n)		((n) << 24)		/* Bit Mask 0 */
+#define FM_KEYGEN_BMCL_BM1(n)		((n) << 16)		/* Bit Mask 1 */
+#define FM_KEYGEN_BMCL_BM2(n)		((n) << 8)		/* Bit Mask 2 */
+#define FM_KEYGEN_BMCL_BM3(n)		(n)			/* Bit Mask 3 */
+
+#define FM_KEYGEN_FQB_MO2(n)		((n) << 28)		/* Mask Offset 2 */
+#define FM_KEYGEN_FQB_MO3(n)		((n) << 24)		/* Mask Offset 3*/
+#define FM_KEYGEN_FQB_FQBASE(n)		(n)			/* Frame Queue Base */
+
+/* Hash SHIFT right */
+#define FM_KEYGEN_HC_HSHIFT_MASK	0x3f000000
+#define FM_KEYGEN_HC_HSHIFT(n)		((n) << 24 & FM_KEYGEN_HC_HSHIFT)
+/* Hash MASK */
+#define FM_KEYGEN_HC_HMASK_MASK		0x00ffffff
+#define FM_KEYGEN_HC_HMASK(n)		((n) & FM_KEYGEN_HC_HMASK_MASK)
+
+#define FM_KEYGEN_PPC_PPS(n)		((n) << 12)		/* Policer Profile Shift */
+#define FM_KEYGEN_PPC_PPMASK(n)		((n) << 16)		/* Policer Profile MASK */
+#define FM_KEYGEN_PPC_PPBASE(n)		(n)			/* Policer Profile BASE */
+
+#define FM_KEYGEN_GEC_V			0x80000000		/* Valid */
+#define FM_KEYGEN_GEC_DV(n)		((n) << 29)		/* Default Value */
+#define FM_KEYGEN_GEC_SIZE(n)		((n) << 24)		/* SIZE */
+#define FM_KEYGEN_GEC_MASK(n)		((n) << 16)		/* MASK */
+#define FM_KEYGEN_GEC_TYPE		0x00008000		/* command TYPE */
+#define FM_KEYGEN_GEC_HT(n)		((n) << 8)		/* Header Type */
+#define FM_KEYGEN_GEC_EO(n)		(n)			/* Extract Offset */
+
+#define FM_KEYGEN_SPC_PC(n)		(n)			/* Packet Counter */
+
+#define FM_KEYGEN_DV_DV(n)		(n)			/* Default Value */
+
+#define FM_KEYGEN_DC_DE			0x80000000		/* Debug Enable */
+
+#define FM_KEYGEN_MV_MV(n)		(n)			/* Match Vector */
+
+/** KeyGen register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMKG_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a KeyGen register. This offset is suitable for using with
+ *  the fm_keygen_in() and fm_keygen_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables the KeyGen by writing into the FMKG_GCR register:
+ *
+ *  \code
+ *		...
+ *	struct fman_keygen *keygen;
+ *		...
+ *	keygen = fm_keygen_create(0xfe4c1000);
+ *		...
+ *	fm_keygen_out(keygen, FM_KEYGEN(GCR), FM_KEYGEN_GCR_EN);
+ *		...
+ *	fm_keygen_destroy(keygen);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_KEYGEN(reg)	\
+	(offsetof(struct fm_mmap_s, keygen) + offsetof(struct fm_keygen_mmap_s, FMKG_##reg))
+
+/** @} */
+
+/* DMA */
+
+/** \addtogroup	DMA
+ *  @{
+ */
+
+/** \internal
+ *  \brief		DMA register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dma_mmap_s {
+	uint8_t		reserved0[0x60];
+	uint32_t	FMDM_PLR[32];	/* PID-LIODN */
+	uint8_t		reserved1[0xf20];
+} __aligned(0x1000) __packed;
+
+#define FM_DMA(reg) (offsetof(struct fm_mmap_s, dma) + offsetof(struct fm_dma_mmap_s, FMDM_##reg))
+
+/** @} */
+
+/* FPM */
+
+/** \addtogroup	FPM
+ *  @{
+ */
+
+/** \internal
+ *  \brief		FPM register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_fpm_mmap_s {
+	uint32_t	FMFP_TNC;	/* TNUM control */
+	uint32_t	FMFP_PRC;	/* PoRt_id Control */
+	uint8_t		reserved0[0x18];
+	uint32_t	FMFP_REV[8];	/* RISC EVent */
+	uint32_t	FMFP_REE[8];	/* RISC Event Enable */
+	uint8_t		reserved1[0xfa0];
+} __aligned(0x1000) __packed;
+
+#define FM_FPM(reg) (offsetof(struct fm_mmap_s, fpm) + offsetof(struct fm_fpm_mmap_s, FMFP_##reg))
+
+/** @} */
+
+/* dTSEC */
+
+/** \addtogroup MAC
+ * @{
+ */
+
+/** \internal
+ *  \brief		dTSEC register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dtsec_mmap_s {
+	uint8_t		reserved0[0x100];
+	uint32_t	MACCFG[2];	/* MAC ConFiGuration */
+	uint8_t		reserved1[0xef8];
+} __aligned(0x1000) __packed;
+
+/** dTSEC register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG
+ *
+ *  Use this macro to get the offset of a dTSEC register. This offset is suitable for using with
+ *  the fm_mac_in() and fm_mac_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that initializes a dTSEC to append a CRC to all frames by writing
+ *  into the MACCFG2 register:
+ *
+ *  \code
+ *		...
+ *	struct fman_mac *mac;
+ *		...
+ *	mac = fm_mac_create(0xfe4e0000);
+ *		...
+ *	fm_mac_out(mac, FM_DTSEC(MACCFG[1]), FM_DTSEC_MACCFG2_CRC_EN);
+ *		...
+ *	fm_mac_destroy(mac);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_DTSEC(reg) offsetof(struct fm_dtsec_mmap_s, reg)
+
+/** @} */
+
+/** \addtogroup MDIO
+ *  @{
+ */
+
+/** \internal
+ *  \brief		MDIO register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_mdio_mmap_s {
+	uint8_t	reserved[0x1000];
+}  __aligned(0x1000) __packed;
+
+/** @} */
+
+/** \internal
+ *  \brief		Aggregated dTSEC and MDIO register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dtsec_mdio_mmap_s {
+	struct fm_dtsec_mmap_s	dtsec;
+	struct fm_mdio_mmap_s	mdio;
+}  __aligned(0x2000) __packed;
+
+/* FMan */
+
+/** \internal
+ *  \brief		Aggregated FMan register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_mmap_s {
+	uint8_t				MURAM[0x80000];
+	struct fm_port_mmap_s		ports[0x40];
+	struct fm_policer_mmap_s	policer;
+	struct fm_keygen_mmap_s		keygen;
+	struct fm_dma_mmap_s		dma;
+	struct fm_fpm_mmap_s		fpm;
+	uint8_t				reserved1[0x3000];
+	struct fm_parser_common_mmap_s	parser;
+	uint8_t				reserved2[0x18000];
+	struct fm_dtsec_mdio_mmap_s	dtsec_mdio[4];
+	uint8_t				reserved3[0x18000];
+} __aligned(0x100000) __packed;
+
+/** Parse results memory layout */
+struct fman_parse_results {
+	uint8_t		lpid;
+	uint8_t		shimr;
+	uint16_t	l2r;
+	uint16_t	l3r;
+	uint8_t		l4r;
+	uint8_t		cplan;
+	uint16_t	nxthdr;
+	uint16_t	cksum;
+	uint32_t	lcv;
+	uint8_t		shim_off[3];
+	uint8_t		eth_off;
+	uint8_t		llc_snap_off;
+	uint8_t		vlan_off;
+	uint8_t		etype_off;
+	uint8_t		pppoe_off;
+	uint8_t		mpls_off;
+	uint8_t		ip_off;
+	uint8_t		gre_off;
+	uint8_t		l4_off;
+	uint8_t		nxthdr_off;
+} __packed;
+
+/* Low-level abstractions */
+
+/** \struct	fman
+ *  \brief	Handle to a FMan object/device
+ *  \details	Used with the fm_in() and fm_out() register access functions
+ */
+struct fman;
+
+/** Get a handle to a FMan device/object
+ *
+ *  \note	For an usage example please see FM_PARSER_COMMON()
+ */
+static inline struct fman __iomem *fm_create(void *regs)
+{
+	return (struct fman *)regs;
+}
+
+/** Read a 32-bit register from the FMan CCSR memory space
+ *
+ *  \note	Use this function as a last resort. It's preferable to use more specific functions
+ *		such as fm_port_in(), etc.
+ */
+static inline uint32_t fm_in(const struct fman *fm,	/**< FMan handle */
+			     off_t reg_off)		/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm + reg_off));
+}
+
+/** Write a 32-bit register into the FMan CCSR memory space
+ *
+ *  \note		Use this function as a last resort. It's preferable to use more specific
+ *			functions such as fm_port_out(), etc.
+ *
+ *  \copydetails	fm_create
+ */
+static inline void fm_out(struct fman *fm,	/**< FMan handle */
+			  off_t reg_off,	/**< Register offset */
+			  uint32_t val)		/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm + reg_off), val);
+}
+
+/** Release a handle to a FMan device
+ *
+ *  \copydetails	fm_create
+ */
+static inline void fm_destroy(struct fman *regs __maybe_unused)
+{
+}
+
+/** \addtogroup	Port
+ *  @{
+ */
+
+/** Hardware port IDs */
+enum fm_port {
+	fm_port_common,
+	fm_port_oh0,
+	fm_port_oh1,
+	fm_port_oh2,
+	fm_port_oh3,
+	fm_port_oh4,
+	fm_port_oh5,
+	fm_port_oh6,
+	fm_port_rx0,
+	fm_port_rx1,
+	fm_port_rx2,
+	fm_port_rx3,
+	fm_port_rx4 = 0x10,
+	fm_port_tx0 = 0x28,
+	fm_port_tx1,
+	fm_port_tx2,
+	fm_port_tx3,
+	fm_port_tx4 = 0x30
+} __packed;
+
+/** \struct	fman_port
+ *  \brief	Port handle
+ *  \details	Used with the fm_port_in() and fm_port_out() register access functions
+ */
+struct fman_port;
+
+/** Get a handle to a port
+ *
+ *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_RX(),
+ *		FM_BMI_TX(), FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_RX(), FM_QMI_TX() or/and
+ *		FM_PARSER().
+ */
+static inline struct fman_port __iomem *fm_port_create(void *regs)
+{
+	return (struct fman_port *)regs;
+}
+
+/** Read a 32-bit register from a port CCSR memory space
+ *
+ *  \note	For an usage example please see one of FM_BMI_RX(), FM_QMI_RX() or/and FM_PARSER().
+ */
+static inline uint32_t fm_port_in(const struct fman_port *fm_port,	/**< Port handle */
+				  off_t reg_off)			/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm_port + reg_off));
+}
+
+/** Write a 32-bit register to a port CCSR memory space
+ *
+ *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_TX(),
+ *		FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_TX() or/and FM_PARSER().
+ */
+static inline void fm_port_out(struct fman_port *fm_port,	/**< Port handle */
+			       off_t reg_off,			/**< Register offset */
+			       uint32_t val)			/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm_port + reg_off), val);
+}
+
+/** Release a handle to a port
+ *
+ *  \copydetails	fm_port_create
+ */
+static inline void fm_port_destroy(struct fman_port *regs __maybe_unused)
+{
+}
+
+/** @} */
+
+/** \addtogroup	KeyGen
+ *  @{
+ */
+
+/** KeyGen handle
+ */
+struct fman_keygen {
+	struct fm_keygen_mmap_s	*mmap;
+	bool			 busy;
+};
+
+/** Get a handle to KeyGen
+ *
+ *  \note	For a usage example please see FM_KEYGEN() or fm_keygen_entry_start().
+ *
+ *  \todo	No memory allocation
+ */
+static inline struct fman_keygen __iomem *fm_keygen_create(void *regs)
+{
+	struct fman_keygen	*fm_keygen;
+
+	fm_keygen = kzalloc(sizeof(*fm_keygen), GFP_KERNEL);
+	if (likely(fm_keygen != NULL))
+		fm_keygen->mmap = (typeof(fm_keygen->mmap))regs;
+
+	return fm_keygen;
+}
+
+static inline struct fman *keygen_to_fman(struct fman_keygen *fm_keygen)
+{
+	return (struct fman *)container_of(fm_keygen->mmap, struct fm_mmap_s, keygen);
+}
+
+/** Read a 32-bit register from the KeyGen CCSR memory space */
+static inline uint32_t fm_keygen_in(struct fman_keygen *fm_keygen, off_t reg_off)
+{
+	return fm_in(keygen_to_fman(fm_keygen), reg_off);
+}
+
+/** Write a 32-bit register to the KeyGen CCSR memory space
+ *
+ *  \copydetails	fm_keygen_create
+ */
+static inline void fm_keygen_out(struct fman_keygen *fm_keygen, off_t reg_off, uint32_t val)
+{
+	fm_out(keygen_to_fman(fm_keygen), reg_off, val);
+}
+
+/** Release a handle to KeyGen
+ *
+ *  \copydetails	fm_keygen_create
+ *
+ *  \todo		No memory allocation
+ */
+static inline void fm_keygen_destroy(struct fman_keygen *fm_keygen)
+{
+	kfree(fm_keygen);
+}
+
+/** @} */
+
+/** \addtogroup	MAC
+ *  @{
+ */
+
+/** \struct	fman_mac
+ *  \brief	MAC handle
+ *  \details	Used with the fm_mac_in() and fm_mac_out() register access functions
+ *  \note	Currently supports only the dTSEC(s).
+ */
+struct fman_mac;
+
+/** Get a handle to a MAC
+ *
+ *  \note	For an usage example see FM_DTSEC()
+ */
+static inline struct fman_mac __iomem *fm_mac_create(void *regs)
+{
+	return (struct fman_mac *)regs;
+}
+
+/** Read a 32-bit register from a MAC CCSR memory space */
+static inline uint32_t fm_mac_in(const struct fman_mac *fm_mac,	/**< MAC handle */
+				 off_t reg_off)			/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm_mac + reg_off));
+}
+
+/** Write a 32-bit register to a MAC CCSR memory space
+ *
+ *  \copydetails	fm_mac_create
+ */
+static inline void fm_mac_out(struct fman_mac *fm_mac,	/**< MAC handle */
+			      off_t reg_off,		/**< Register offset */
+			      uint32_t val)		/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm_mac + reg_off), val);
+}
+
+/** Release a handle to a MAC
+ *
+ *  \copydetails	fm_mac_create
+ */
+static inline void fm_mac_destroy(struct fman_mac *regs __maybe_unused)
+{
+}
+
+/** @} */
+
+#define FM_FD_STAT_DME		0x01000000	/* DMA Error - QMI */
+#define FM_FD_STAT_FHE		0x00080000	/* Physical Error - BMI */
+#define FM_FD_STAT_FSE		0x00040000	/* Frame Size Error - BMI */
+#define FM_FD_STAT_DIS		0x00020000	/* Discarded frame - BMI */
+#define FM_FD_STAT_EOF		0x00008000	/* Extract Out of Frame - KEYGEN */
+#define FM_FD_STAT_NSS		0x00004000	/* No Scheme Selected - KEYGEN */
+#define FM_FD_STAT_FCL		0x00000c00	/* Frame Color - Policer */
+#define FM_FD_STAT_IPP		0x00000200	/* Illegal Policer Profile - Policer */
+#define FM_FD_STAT_PTE		0x00000080	/* Parser Timeout Exceeded - Parser */
+#define FM_FD_STAT_ISP		0x00000040	/* Invalid Soft Parser Instruction - Parser */
+#define FM_FD_STAT_PHE		0x00000020	/* Parsing Header Error - Parser */
+#define FM_FD_STAT_ERRORS	(FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |	\
+				 FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |	\
+				 FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |	\
+				 FM_FD_STAT_PHE)
+
+#define FM_FD_CMD_FCO	0x80000000	/* Frame queue Context Override */
+#define FM_FD_CMD_RPD	0x40000000	/* Read Prepended Data */
+#define FM_FD_CMD_UDP	0x20000000	/* Update Prepended Data */
+#define FM_FD_CMD_BMF	0x10000000	/* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC	0x08000000	/* Do TCP Checksum */
+#define FM_FD_CMD_DME	0x01000000	/* DMA Error */
+#define FM_FD_CMD_CFQ	0x00ffffff	/* Confirmation Frame Queue */
+
+/* High-level abstractions */
+
+/* KeyGen */
+
+/** \addtogroup	KeyGen
+ *  @{
+ */
+
+/** KeyGen entry types
+ *
+ *  The Keygen uses the same registers area to overlay three different functionalities. Access to
+ *  register sets should be guarded with calls to fm_keygen_entry_start() and fm_keygen_commit().
+ */
+enum fman_keygen_entry_type {
+	fman_keygen_scheme,	/**< Classification scheme */
+	fman_keygen_plan,	/**< Classification plan */
+	fman_keygen_port	/**< Port partition */
+} __packed;
+
+/** KeyGen entry handle */
+struct fman_keygen_entry {
+	struct fman_keygen		*fm_keygen;
+	uint32_t			 ar;
+};
+
+/** Start reading/writing a new KeyGen entry
+ *
+ *  Once a KeyGen entry handle is aquired, use the fm_keygen_in() and fm_keygen_out() to access the
+ *  entry registers and activate the entry using fm_keygen_commit(). In order to abandon an entry
+ *  before activating it and start a new kind of entry use again fm_keygen_entry_start().
+ *
+ *  \par	Example:
+ *
+ *  Here is a partial sequence of code that ilustrates how to program/write a classification scheme:
+ *
+ *  \code
+ *		...
+ *	struct fman_keygen		*keygen;
+ *	struct fman_keygen_entry	*keygen_entry;
+ *		...
+ *	keygen = fm_keygen_create(0xfe4c1000);
+ *		...
+ *	keygen_entry = fm_keygen_entry_start(keygen, false, fman_keygen_scheme, 0);
+ *		...
+ *	/ * Hash based on the IP source and destination addresses and TOS bits * /
+ *	fm_keygen_out(keygen, FM_KEYGEN(SE_EKFC), FM_KEYGEN_EKFC_IPSRC |
+ *						  FM_KEYGEN_EKFC_IPDST |
+ *						  FM_KEYGEN_EKFC_IPTOS);
+ *		...
+ *	fm_keygen_commit(keygen_entry);
+ *		...
+ *	fm_keygen_destroy(keygen);
+ *		...
+ *  \endcode
+ *
+ *  \todo	No memory allocation
+ */
+static inline struct fman_keygen_entry *
+fm_keygen_entry_start(struct fman_keygen		*fm_keygen,	/**< KeyGen handle */
+		      bool				 read,		/**< Read or write  */
+		      enum fman_keygen_entry_type	 type,		/**< Entry type */
+		      uint8_t				 index)		/**< Entry index */
+{
+	struct fman_keygen_entry	*fm_keygen_entry;
+
+	if (fm_keygen->busy == true)
+		return NULL;
+
+	while(fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
+		cpu_relax();
+
+	fm_keygen_entry = kzalloc(sizeof(*fm_keygen_entry), GFP_KERNEL);
+	if (likely(fm_keygen_entry != NULL)) {
+		fm_keygen_entry->fm_keygen = fm_keygen;
+
+		fm_keygen_entry->ar = FM_KEYGEN_AR_GO		|
+				      FM_KEYGEN_AR_SEL(type)	|
+				      FM_KEYGEN_AR_NUM(index);
+		if (read == true) {
+			fm_keygen_entry->ar |= FM_KEYGEN_AR_RW;
+			fm_keygen_out(fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
+			while (fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
+				cpu_relax();
+		}
+
+		fm_keygen->busy = true;
+	}
+
+	return fm_keygen_entry;
+}
+
+/** Activate the current KeyGen entry
+ *
+ *  \note	For an usage example please see fm_keygen_entry_start()
+ *
+ *  \todo	No memory allocation
+ */
+static inline void fm_keygen_commit(struct fman_keygen_entry *fm_keygen_entry)
+{
+	BUG_ON(fm_keygen_entry->fm_keygen->busy == false);
+
+	if ((fm_keygen_entry->ar & FM_KEYGEN_AR_RW) == 0)	/* Write access type */
+		fm_keygen_out(fm_keygen_entry->fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
+
+	fm_keygen_entry->fm_keygen->busy = false;
+	kfree(fm_keygen_entry);
+}
+
+/** @} */
+
+enum fm_isr_reg {
+	fm_isr_status,
+	fm_isr_enable
+} __packed;
+
+/** FMan engine code
+ *
+ *  To be used by/with fm_nia() for building the NIA codes for the \ref BMI, \ref KeyGen, etc.
+ */
+enum fm_engine {
+	fm_risc,		/**< RISC */
+	fm_parser = 0x11,	/**< \ref Parser \hideinitializer */
+	fm_keygen,		/**< \ref KeyGen*/
+	fm_policer,		/**< \ref Policer */
+	fm_bmi,			/**< \ref BMI */
+	fm_qmi_enqueue,		/**< \ref QMI */
+	fm_qmi_dequeue		/**< \ref QMI */
+} __packed;
+
+#define FM_NIA_OPR_SHIFT	23
+#define FM_NIA_OPR_MASK		0x00800000
+#define FM_NIA_ENG_SHIFT	18
+#define FM_NIA_ENG_MASK		0x007c0000
+#define FM_NIA_AC_SHIFT		0
+#define FM_NIA_AC_MASK		0x0003ffff
+
+/** Build NIA codes */
+static inline uint32_t fm_nia(bool opr,			/**< Use order preservation */
+			      enum fm_engine eng,	/**< Next engine */
+			      uint32_t ac)		/**< Action code */
+{
+	return (opr	<< FM_NIA_OPR_SHIFT	& FM_NIA_OPR_MASK)	|
+	       (eng	<< FM_NIA_ENG_SHIFT	& FM_NIA_ENG_MASK)	|
+	       (ac	<< FM_NIA_AC_SHIFT	& FM_NIA_AC_MASK);
+}
+
+#endif	/* __FMAN_CONF_H */
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
new file mode 100644
index 0000000..1511f67
--- /dev/null
+++ b/drivers/net/dpa/mac-api.c
@@ -0,0 +1,478 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_mdio.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
+
+#include "dpaa_eth-common.h"
+#include "dpaa_eth.h"
+#include "mac.h"
+
+#include "error_ext.h"	/* GET_ERROR_TYPE, E_OK */
+#include "fm_mac_ext.h"
+
+#define MAC_DESCRIPTION "FSL FMan MAC API based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(MAC_DESCRIPTION);
+
+struct mac_priv_s {
+	t_Handle	mac;
+};
+
+const char	*mac_driver_description __initconst = MAC_DESCRIPTION;
+const size_t	 mac_sizeof_priv[] __devinitconst = {
+	[DTSEC] = sizeof(struct mac_priv_s),
+	[XGMAC] = sizeof(struct mac_priv_s)
+};
+
+static const e_EnetMode _100[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= e_ENET_MODE_MII_100,
+	[PHY_INTERFACE_MODE_RMII]	= e_ENET_MODE_RMII_100
+};
+
+static const e_EnetMode _1000[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_GMII]	= e_ENET_MODE_GMII_1000,
+	[PHY_INTERFACE_MODE_SGMII]	= e_ENET_MODE_SGMII_1000,
+	[PHY_INTERFACE_MODE_TBI]	= e_ENET_MODE_TBI_1000,
+	[PHY_INTERFACE_MODE_RGMII]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_ID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RTBI]	= e_ENET_MODE_RTBI_1000
+};
+
+static e_EnetMode __devinit __cold __attribute__((nonnull))
+macdev2enetinterface(const struct mac_device *mac_dev)
+{
+	switch (mac_dev->max_speed) {
+	case SPEED_100:
+		return _100[mac_dev->phy_if];
+	case SPEED_1000:
+		return _1000[mac_dev->phy_if];
+	case SPEED_10000:
+		return e_ENET_MODE_XGMII_10000;
+	default:
+		return e_ENET_MODE_MII_100;
+	}
+}
+
+static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exception)
+{
+	struct mac_device	*mac_dev;
+
+	mac_dev = (struct mac_device *)_mac_dev;
+
+	if (e_FM_MAC_EX_10G_RX_FIFO_OVFL == exception) {
+		/* don't flag RX FIFO after the first */
+		FM_MAC_SetException(
+		    ((struct mac_priv_s *)macdev_priv(_mac_dev))->mac,
+		    e_FM_MAC_EX_10G_RX_FIFO_OVFL, false);
+		printk(KERN_ERR "10G MAC got RX FIFO Error = %x\n", exception);
+	}
+
+	cpu_dev_dbg(mac_dev->dev, "%s:%s() -> %d\n", __file__, __func__,
+		exception);
+}
+
+static int __devinit __cold init(struct mac_device *mac_dev)
+{
+	int					_errno;
+	t_Error				err;
+	struct mac_priv_s	*priv;
+	t_FmMacParams		param;
+	uint32_t			version;
+
+	priv = macdev_priv(mac_dev);
+
+	param.baseAddr =  (typeof(param.baseAddr))(uintptr_t)devm_ioremap(
+		mac_dev->dev, mac_dev->res->start, 0x2000);
+	param.enetMode	= macdev2enetinterface(mac_dev);
+	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr),
+		sizeof(mac_dev->addr)));
+	param.macId			= mac_dev->cell_index;
+	param.h_Fm 			= (t_Handle)mac_dev->fm;
+	param.mdioIrq		= NO_IRQ;
+	param.f_Exception	= mac_exception;
+	param.f_Event		= mac_exception;
+	param.h_App			= mac_dev;
+
+	priv->mac = FM_MAC_Config(&param);
+	if (unlikely(priv->mac == NULL)) {
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Config() failed\n");
+		_errno = -EINVAL;
+		goto _return;
+	}
+
+	err = FM_MAC_ConfigMaxFrameLength(priv->mac, FSL_FMAN_PHY_MAXFRM);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(mac_dev->dev,
+			"FM_MAC_ConfigMaxFrameLength() = 0x%08x\n", err);
+		goto _return_fm_mac_free;
+	}
+
+	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000) {
+		/* 10G always works with pad and CRC */
+		err = FM_MAC_ConfigPadAndCrc(priv->mac, true);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_ConfigPadAndCrc() = 0x%08x\n", err);
+			goto _return_fm_mac_free;
+		}
+
+		err = FM_MAC_ConfigHalfDuplex(priv->mac, mac_dev->half_duplex);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_ConfigHalfDuplex() = 0x%08x\n", err);
+			goto _return_fm_mac_free;
+		}
+	}
+	else  {
+		err = FM_MAC_ConfigResetOnInit(priv->mac, true);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_ConfigResetOnInit() = 0x%08x\n", err);
+			goto _return_fm_mac_free;
+		}
+	}
+
+	err = FM_MAC_Init(priv->mac);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Init() = 0x%08x\n", err);
+		goto _return_fm_mac_free;
+	}
+
+	/* For 10G MAC, disable Tx ECC exception */
+	if (macdev2enetinterface(mac_dev) == e_ENET_MODE_XGMII_10000) {
+		err = FM_MAC_SetException(priv->mac,
+					  e_FM_MAC_EX_10G_1TX_ECC_ER, FALSE);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_SetException() = 0x%08x\n", err);
+			goto _return_fm_mac_free;
+		}
+	}
+
+	err = FM_MAC_GetVesrion(priv->mac, &version);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_GetVesrion() = 0x%08x\n",
+				err);
+		goto _return_fm_mac_free;
+	}
+	cpu_dev_info(mac_dev->dev, "FMan %s version: 0x%08x\n",
+		((macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000) ?
+			"dTSEC" : "XGEC"), version);
+
+	goto _return;
+
+
+_return_fm_mac_free:
+	err = FM_MAC_Free(priv->mac);
+	if (unlikely(-GET_ERROR_TYPE(err) < 0))
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Free() = 0x%08x\n", err);
+_return:
+	return _errno;
+}
+
+static int __cold start(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+	struct phy_device *phy_dev = mac_dev->phy_dev;
+
+	err = FM_MAC_Enable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			e_COMM_MODE_RX_AND_TX);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Enable() = 0x%08x\n", err);
+
+	if (phy_dev) {
+		if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
+			phy_start(phy_dev);
+		else if (phy_dev->drv->read_status)
+			phy_dev->drv->read_status(phy_dev);
+	}
+
+	return _errno;
+}
+
+static int __cold stop(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	if (mac_dev->phy_dev &&
+		(macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000))
+		phy_stop(mac_dev->phy_dev);
+
+	err = FM_MAC_Disable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+				e_COMM_MODE_RX_AND_TX);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Disable() = 0x%08x\n", err);
+
+	return _errno;
+}
+
+static int __cold change_promisc(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_SetPromiscuous(
+			((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			mac_dev->promisc = !mac_dev->promisc);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_SetPromiscuous() = 0x%08x\n", err);
+
+	return _errno;
+}
+
+static int __cold set_multi(struct net_device *net_dev)
+{
+	struct dpa_priv_s       *priv;
+	struct mac_device       *mac_dev;
+	struct mac_priv_s 	*mac_priv;
+	struct mac_address	*old_addr, *tmp;
+	struct dev_mc_list	*new_addr;
+	int 			 _errno;
+	t_Error 		 err;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+	mac_priv = macdev_priv(mac_dev);
+
+	/* Clear previous address list */
+	list_for_each_entry_safe(old_addr, tmp, &mac_dev->mc_addr_list, list) {
+		err = FM_MAC_RemoveHashMacAddr(mac_priv->mac,
+					       (t_EnetAddr  *)old_addr->addr);
+		_errno = -GET_ERROR_TYPE(err);
+		if (_errno < 0) {
+			dpaa_eth_err(mac_dev->dev,
+				"FM_MAC_RemoveHashMacAddr() = 0x%08x\n", err);
+			return _errno;
+		}
+		list_del(&old_addr->list);
+		kfree(old_addr);
+	}
+
+	/* Add all the addresses from the new list */
+	netdev_for_each_mc_addr(new_addr, net_dev) {
+		err = FM_MAC_AddHashMacAddr(mac_priv->mac,
+				(t_EnetAddr *)new_addr->dmi_addr);
+		_errno = -GET_ERROR_TYPE(err);
+		if (_errno < 0) {
+			dpaa_eth_err(mac_dev->dev,
+				     "FM_MAC_AddHashMacAddr() = 0x%08x\n", err);
+			return _errno;
+		}
+		tmp = kmalloc(sizeof(struct mac_address), GFP_ATOMIC);
+		if (!tmp) {
+			dpaa_eth_err(mac_dev->dev, "Out of memory\n");
+			return -ENOMEM;
+		}
+		memcpy(tmp->addr, new_addr->dmi_addr, ETH_ALEN);
+		list_add(&tmp->list, &mac_dev->mc_addr_list);
+	}
+	return 0;
+}
+
+static int __cold change_addr(struct mac_device *mac_dev, uint8_t *addr)
+{
+	int	_errno;
+	t_Error err;
+
+	err = FM_MAC_ModifyMacAddr(
+			((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			(t_EnetAddr *)addr);
+	_errno = -GET_ERROR_TYPE(err);
+	if (_errno < 0)
+		dpaa_eth_err(mac_dev->dev,
+			     "FM_MAC_ModifyMacAddr() = 0x%08x\n", err);
+
+	return _errno;
+}
+
+static void adjust_link(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct mac_device *mac_dev = priv->mac_dev;
+	struct phy_device *phy_dev = mac_dev->phy_dev;
+	int	 _errno;
+	t_Error	 err;
+
+	if (!phy_dev->link)
+		return;
+
+	err = FM_MAC_AdjustLink(
+			((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			phy_dev->speed, phy_dev->duplex);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_AdjustLink() = 0x%08x\n",
+				err);
+
+	return;
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int dtsec_init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct mac_device	*mac_dev;
+	struct phy_device	*phy_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	if (!mac_dev->phy_node)
+		phy_dev = phy_connect(net_dev, mac_dev->fixed_bus_id,
+				&adjust_link, 0, mac_dev->phy_if);
+	else
+		phy_dev = of_phy_connect(net_dev, mac_dev->phy_node,
+				&adjust_link, 0, mac_dev->phy_if);
+	if (unlikely(phy_dev == NULL) || IS_ERR(phy_dev)) {
+		cpu_netdev_err(net_dev, "Could not connect to PHY %s\n",
+				mac_dev->phy_node ?
+					mac_dev->phy_node->full_name :
+					mac_dev->fixed_bus_id);
+		return phy_dev == NULL ? -ENODEV : PTR_ERR(phy_dev);
+	}
+
+	/* Remove any features not supported by the controller */
+	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->advertising = phy_dev->supported;
+
+	priv->mac_dev->phy_dev = phy_dev;
+
+	return 0;
+}
+
+static int xgmac_init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct mac_device *mac_dev = priv->mac_dev;
+	struct phy_device *phy_dev;
+
+	if (!mac_dev->phy_node)
+		phy_dev = phy_attach(net_dev, mac_dev->fixed_bus_id, 0,
+				mac_dev->phy_if);
+	else
+		phy_dev = of_phy_attach(net_dev, mac_dev->phy_node, 0,
+				mac_dev->phy_if);
+	if (unlikely(phy_dev == NULL) || IS_ERR(phy_dev)) {
+		cpu_netdev_err(net_dev, "Could not attach to PHY %s\n",
+				mac_dev->phy_node ?
+					mac_dev->phy_node->full_name :
+					mac_dev->fixed_bus_id);
+		return phy_dev == NULL ? -ENODEV : PTR_ERR(phy_dev);
+	}
+
+	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->advertising = phy_dev->supported;
+
+	mac_dev->phy_dev = phy_dev;
+
+	return 0;
+}
+
+static int __cold uninit(struct mac_device *mac_dev)
+{
+	int			 _errno, __errno;
+	t_Error			 err;
+	const struct mac_priv_s	*priv;
+
+	priv = macdev_priv(mac_dev);
+
+	err = FM_MAC_Disable(priv->mac, e_COMM_MODE_RX_AND_TX);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Disable() = 0x%08x\n", err);
+
+	err = FM_MAC_Free(priv->mac);
+	__errno = -GET_ERROR_TYPE(err);
+	if (unlikely(__errno < 0)) {
+		dpaa_eth_err(mac_dev->dev, "FM_MAC_Free() = 0x%08x\n", err);
+		if (_errno < 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
+{
+	mac_dev->init_phy	= dtsec_init_phy;
+	mac_dev->init		= init;
+	mac_dev->start		= start;
+	mac_dev->stop		= stop;
+	mac_dev->change_promisc	= change_promisc;
+	mac_dev->change_addr    = change_addr;
+	mac_dev->set_multi      = set_multi;
+	mac_dev->uninit		= uninit;
+}
+
+static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
+{
+	mac_dev->init_phy	= xgmac_init_phy;
+	mac_dev->init		= init;
+	mac_dev->start		= start;
+	mac_dev->stop		= stop;
+	mac_dev->change_promisc	= change_promisc;
+	mac_dev->change_addr    = change_addr;
+	mac_dev->set_multi      = set_multi;
+	mac_dev->uninit		= uninit;
+}
+
+void (*const mac_setup[])(struct mac_device *mac_dev) __devinitconst = {
+	[DTSEC] = setup_dtsec,
+	[XGMAC] = setup_xgmac
+};
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
new file mode 100644
index 0000000..3f7f790
--- /dev/null
+++ b/drivers/net/dpa/mac.c
@@ -0,0 +1,415 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/phy.h>
+
+#include "dpaa_eth-common.h"
+
+#include "lnxwrp_fm_ext.h"
+
+#include "fsl_pq_mdio.h"
+#include "mac.h"
+
+#define DTSEC_SUPPORTED \
+	(SUPPORTED_10baseT_Half \
+	| SUPPORTED_10baseT_Full \
+	| SUPPORTED_100baseT_Half \
+	| SUPPORTED_100baseT_Full \
+	| SUPPORTED_1000baseT_Half \
+	| SUPPORTED_1000baseT_Full \
+	| SUPPORTED_Autoneg \
+	| SUPPORTED_MII)
+
+static const char phy_str[][11] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= "mii",
+	[PHY_INTERFACE_MODE_GMII]	= "gmii",
+	[PHY_INTERFACE_MODE_SGMII]	= "sgmii",
+	[PHY_INTERFACE_MODE_TBI]	= "tbi",
+	[PHY_INTERFACE_MODE_RMII]	= "rmii",
+	[PHY_INTERFACE_MODE_RGMII]	= "rgmii",
+	[PHY_INTERFACE_MODE_RGMII_ID]	= "rgmii-id",
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= "rgmii-rxid",
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= "rgmii-txid",
+	[PHY_INTERFACE_MODE_RTBI]	= "rtbi",
+	[PHY_INTERFACE_MODE_XGMII]	= "xgmii"
+};
+
+static phy_interface_t __devinit __pure __attribute__((nonnull)) str2phy(const char *str)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(phy_str); i++)
+		if (strcmp(str, phy_str[i]) == 0)
+			return (phy_interface_t)i;
+
+	return PHY_INTERFACE_MODE_MII;
+}
+
+static const uint16_t phy2speed[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= SPEED_100,
+	[PHY_INTERFACE_MODE_GMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_SGMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_TBI]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RMII]	= SPEED_100,
+	[PHY_INTERFACE_MODE_RGMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_ID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RTBI]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_XGMII]	= SPEED_10000
+};
+
+static struct mac_device * __devinit __cold
+alloc_macdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct mac_device *mac_dev))
+{
+	struct mac_device	*mac_dev;
+
+	mac_dev = devm_kzalloc(dev, sizeof(*mac_dev) + sizeof_priv, GFP_KERNEL);
+	if (unlikely(mac_dev == NULL))
+		mac_dev = ERR_PTR(-ENOMEM);
+	else {
+		mac_dev->dev = dev;
+		dev_set_drvdata(dev, mac_dev);
+		setup(mac_dev);
+	}
+
+	return mac_dev;
+}
+
+static int __devexit __cold free_macdev(struct mac_device *mac_dev)
+{
+	dev_set_drvdata(mac_dev->dev, NULL);
+
+	return mac_dev->uninit(mac_dev);
+}
+
+static const struct of_device_id mac_match[] __devinitconst = {
+	[DTSEC] = {
+		.compatible	= "fsl,fman-1g-mac"
+	},
+	[XGMAC] = {
+		.compatible	= "fsl,fman-10g-mac"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mac_match);
+
+static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int			 _errno, i, lenp;
+	struct device		*dev;
+	struct device_node	*mac_node, *dev_node;
+	struct mac_device	*mac_dev;
+	struct of_device	*of_dev;
+	struct resource		 res;
+	const uint8_t		*mac_addr;
+	const char		*char_prop;
+	const phandle		*phandle_prop;
+	const uint32_t		*uint32_prop;
+
+	dev = &_of_dev->dev;
+
+	mac_node = _of_dev->node;
+
+	for (i = 0; i < ARRAY_SIZE(mac_match) - 1 && match != mac_match + i; i++);
+	BUG_ON(i >= ARRAY_SIZE(mac_match) - 1);
+
+	mac_dev = alloc_macdev(dev, mac_sizeof_priv[i], mac_setup[i]);
+	if (IS_ERR(mac_dev)) {
+		_errno = PTR_ERR(mac_dev);
+		dpaa_eth_err(dev, "alloc_macdev() = %d\n", _errno);
+		goto _return;
+	}
+
+	INIT_LIST_HEAD(&mac_dev->mc_addr_list);
+
+	/* Get the FM node */
+	dev_node = of_get_parent(mac_node);
+	if (unlikely(dev_node == NULL)) {
+		dpaa_eth_err(dev, "of_get_parent(%s) failed\n",
+				mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	of_dev = of_find_device_by_node(dev_node);
+	if (unlikely(of_dev == NULL)) {
+		dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+				dev_node->full_name);
+		_errno = -EINVAL;
+		goto _return_of_node_put;
+	}
+
+	mac_dev->fm_dev = fm_bind(&of_dev->dev);
+	if (unlikely(mac_dev->fm_dev == NULL)) {
+		dpaa_eth_err(dev, "fm_bind(%s) failed\n", dev_node->full_name);
+		_errno = -ENODEV;
+		goto _return_of_node_put;
+	}
+
+    mac_dev->fm = (void *)fm_get_handle(mac_dev->fm_dev);
+	of_node_put(dev_node);
+
+	/* Get the address of the memory mapped registers */
+	_errno = of_address_to_resource(mac_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				mac_node->full_name, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	mac_dev->res = __devm_request_region(
+		dev,
+		fm_get_mem_region(mac_dev->fm_dev),
+		res.start, res.end + 1 - res.start, "mac");
+	if (unlikely(mac_dev->res == NULL)) {
+		dpaa_eth_err(dev, "__devm_request_mem_region(mac) failed\n");
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	mac_dev->vaddr = devm_ioremap(dev, mac_dev->res->start,
+				      mac_dev->res->end + 1 - mac_dev->res->start);
+	if (unlikely(mac_dev->vaddr == NULL)) {
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	/*
+	 * XXX: Warning, future versions of Linux will most likely not even
+	 * call the driver code to allow us to override the TBIPA value,
+	 * we'll need to address this when we move to newer kernel rev
+	 */
+#define TBIPA_OFFSET		0x1c
+#define TBIPA_DEFAULT_ADDR	5
+	mac_dev->tbi_node = of_parse_phandle(mac_node, "tbi-handle", 0);
+	if (mac_dev->tbi_node) {
+		u32 tbiaddr = TBIPA_DEFAULT_ADDR;
+
+		uint32_prop = of_get_property(mac_dev->tbi_node, "reg", NULL);
+		if (uint32_prop)
+			tbiaddr = *uint32_prop;
+		out_be32(mac_dev->vaddr + TBIPA_OFFSET, tbiaddr);
+	}
+
+	if (!of_device_is_available(mac_node)) {
+		devm_iounmap(dev, mac_dev->vaddr);
+		__devm_release_region(dev, fm_get_mem_region(mac_dev->fm_dev),
+			res.start, res.end + 1 - res.start);
+		fm_unbind(mac_dev->fm_dev);
+		devm_kfree(dev, mac_dev);
+		dev_set_drvdata(dev, NULL);
+		return -ENODEV;
+	}
+
+	/* Get the cell-index */
+	uint32_prop = of_get_property(mac_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	mac_dev->cell_index = *uint32_prop;
+
+	/* Get the MAC address */
+	mac_addr = of_get_mac_address(mac_node);
+	if (unlikely(mac_addr == NULL)) {
+		dpaa_eth_err(dev, "of_get_mac_address(%s) failed\n",
+				mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	memcpy(mac_dev->addr, mac_addr, sizeof(mac_dev->addr));
+
+	/* Get the port handles */
+	phandle_prop = of_get_property(mac_node, "fsl,port-handles", &lenp);
+	if (unlikely(phandle_prop == NULL)) {
+		dpaa_eth_err(dev, "of_get_property(%s, port-handles) failed\n",
+				mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(phandle) * ARRAY_SIZE(mac_dev->port_dev));
+
+	for_each_port_device(i, mac_dev->port_dev) {
+		/* Find the port node */
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			dpaa_eth_err(dev, "of_find_node_by_phandle() failed\n");
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+
+		of_dev = of_find_device_by_node(dev_node);
+		if (unlikely(of_dev == NULL)) {
+			dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+					dev_node->full_name);
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+
+		mac_dev->port_dev[i] = fm_port_bind(&of_dev->dev);
+		if (unlikely(mac_dev->port_dev[i] == NULL)) {
+			dpaa_eth_err(dev, "dev_get_drvdata(%s) failed\n",
+					dev_node->full_name);
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+	}
+
+	/* Get the PHY connection type */
+	char_prop = (const char *)of_get_property(mac_node,
+						"phy-connection-type", NULL);
+	if (unlikely(char_prop == NULL)) {
+		dpaa_eth_warning(dev,
+				"of_get_property(%s, phy-connection-type) "
+				"failed. Defaulting to MII\n",
+				mac_node->full_name);
+		mac_dev->phy_if = PHY_INTERFACE_MODE_MII;
+	} else
+		mac_dev->phy_if = str2phy(char_prop);
+
+	mac_dev->link		= false;
+	mac_dev->half_duplex	= false;
+	mac_dev->speed		= phy2speed[mac_dev->phy_if];
+	mac_dev->max_speed	= mac_dev->speed;
+	mac_dev->if_support = DTSEC_SUPPORTED;
+	if (strstr(char_prop, "sgmii") && (mac_dev->max_speed == 1000))
+		mac_dev->if_support &= ~SUPPORTED_1000baseT_Half;
+	if (strstr(char_prop, "xgmii"))
+		mac_dev->if_support = SUPPORTED_10000baseT_Full;
+
+	/* Get the rest of the PHY information */
+	mac_dev->phy_node = of_parse_phandle(mac_node, "phy-handle", 0);
+	if (mac_dev->phy_node == NULL) {
+		int sz;
+		const u32 *phy_id = of_get_property(mac_node, "fixed-link",
+							&sz);
+		if (!phy_id || sz < sizeof(*phy_id)) {
+			cpu_dev_err(dev, "No PHY (or fixed link) found\n");
+			_errno = -EINVAL;
+			goto _return_dev_set_drvdata;
+		}
+
+		sprintf(mac_dev->fixed_bus_id, PHY_ID_FMT, "0", phy_id[0]);
+	}
+
+	_errno = mac_dev->init(mac_dev);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "mac_dev->init() = %d\n", _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	cpu_dev_info(dev,
+		"FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
+		     mac_dev->addr[0], mac_dev->addr[1], mac_dev->addr[2],
+		     mac_dev->addr[3], mac_dev->addr[4], mac_dev->addr[5]);
+
+	goto _return;
+
+_return_of_node_put:
+	of_node_put(dev_node);
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	return _errno;
+}
+
+static int __devexit __cold mac_remove(struct of_device *of_dev)
+{
+	int			 i, _errno;
+	struct device		*dev;
+	struct mac_device	*mac_dev;
+
+	dev = &of_dev->dev;
+	mac_dev = (struct mac_device *)dev_get_drvdata(dev);
+
+	for_each_port_device(i, mac_dev->port_dev)
+		fm_port_unbind(mac_dev->port_dev[i]);
+
+	fm_unbind(mac_dev->fm_dev);
+
+	_errno = free_macdev(mac_dev);
+
+	return _errno;
+}
+
+static struct of_platform_driver mac_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= mac_match,
+	.owner		= THIS_MODULE,
+	.probe		= mac_probe,
+	.remove		= __devexit_p(mac_remove)
+};
+
+static int __init __cold mac_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", mac_driver_description);
+
+	_errno = of_register_platform_driver(&mac_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			   __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(mac_load);
+
+static void __exit __cold mac_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&mac_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(mac_unload);
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
new file mode 100644
index 0000000..93d767c
--- /dev/null
+++ b/drivers/net/dpa/mac.h
@@ -0,0 +1,106 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MAC_H
+#define __MAC_H
+
+#include <linux/device.h>	/* struct device, BUS_ID_SIZE */
+#include <linux/if_ether.h>	/* ETH_ALEN */
+#include <linux/phy.h>		/* phy_interface_t, struct phy_device */
+#include <linux/list.h>
+
+#include "fsl_fman.h"		/* struct port_device */
+
+#ifndef CONFIG_DPA_MAX_FRM_SIZE
+#define CONFIG_DPA_MAX_FRM_SIZE		0
+#endif
+/* Max frame size, across all interfaces; must be large enough to accomodate
+ * the network MTU, but small enough to avoid wasting skb memory. */
+#define FSL_FMAN_PHY_MAXFRM \
+	(fsl_fman_phy_maxfrm ? fsl_fman_phy_maxfrm : CONFIG_DPA_MAX_FRM_SIZE)
+
+enum {DTSEC, XGMAC};
+
+struct mac_device {
+	struct device		*dev;
+	void			*priv;
+	uint8_t			 cell_index;
+	struct resource		*res;
+	void			*vaddr;
+	uint8_t			 addr[ETH_ALEN];
+	bool			 promisc;
+
+	struct fm		*fm_dev;
+	struct fm_port		*port_dev[2];
+
+	phy_interface_t		 phy_if;
+	u32			 if_support;
+	bool			 link;
+	bool			 half_duplex;
+	uint16_t		 speed;
+	uint16_t		 max_speed;
+	struct device_node	*phy_node;
+	char			fixed_bus_id[MII_BUS_ID_SIZE + 3];
+	struct device_node	*tbi_node;
+	struct phy_device	*phy_dev;
+	void			*fm;
+	/* List of multicast addresses */
+	struct list_head	 mc_addr_list;
+
+	int (*init_phy)(struct net_device *net_dev);
+	int (*init)(struct mac_device *mac_dev);
+	int (*start)(struct mac_device *mac_dev);
+	int (*stop)(struct mac_device *mac_dev);
+	int (*change_promisc)(struct mac_device *mac_dev);
+	int (*change_addr)(struct mac_device *mac_dev, uint8_t *addr);
+	int (*set_multi)(struct net_device *net_dev);
+	int (*uninit)(struct mac_device *mac_dev);
+};
+
+struct mac_address {
+	uint8_t addr[ETH_ALEN];
+	struct list_head list;
+};
+
+#define for_each_port_device(i, port_dev)	\
+	for (i = 0; i < ARRAY_SIZE(port_dev); i++)
+
+static inline void * __attribute((nonnull)) macdev_priv(const struct mac_device *mac_dev)
+{
+	return (void *)mac_dev + sizeof(*mac_dev);
+}
+
+extern const char	*mac_driver_description;
+extern const size_t	 mac_sizeof_priv[];
+extern void (*const mac_setup[])(struct mac_device *mac_dev);
+extern int		 fsl_fman_phy_maxfrm;
+
+#endif	/* __MAC_H */
diff --git a/drivers/net/dpa/offline_port.c b/drivers/net/dpa/offline_port.c
new file mode 100644
index 0000000..4e97e95
--- /dev/null
+++ b/drivers/net/dpa/offline_port.c
@@ -0,0 +1,325 @@
+/*
+ * Copyright 2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Offline Parsing / Host Command port driver for FSL QorIQ FMan.
+ * Validates device-tree configuration and sets up the offline ports.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include "offline_port.h"
+#include "dpaa_eth-common.h"
+
+#define OH_MOD_DESCRIPTION	"FSL FMan Offline Parsing port driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Bogdan Hamciuc <bogdan.hamciuc@freescale.com>");
+MODULE_DESCRIPTION(OH_MOD_DESCRIPTION);
+
+
+static const struct of_device_id oh_port_match_table[] __devinitconst = {
+	{
+		.compatible	= "fsl,dpa-oh"
+	},
+	{
+		.compatible	= "fsl,dpa-oh-shared"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, oh_port_match_table);
+
+static int oh_port_remove(struct of_device *_of_dev);
+static int oh_port_probe(struct of_device *_of_dev,
+	const struct of_device_id *match);
+
+static struct of_platform_driver oh_port_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= oh_port_match_table,
+	.owner		= THIS_MODULE,
+	.probe		= oh_port_probe,
+	.remove		= __devexit_p(oh_port_remove)
+};
+
+/* Allocation code for the OH port's PCD frame queues */
+static int __devinit __cold alloc_oh_pcd_fqids(struct device *dev,
+	uint32_t num,
+	uint8_t alignment,
+	uint32_t *base_fqid)
+{
+	cpu_dev_crit(dev, "callback not implemented!\n");
+	BUG();
+
+	return 0;
+}
+
+static int __devinit
+oh_port_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	struct device		*dpa_oh_dev;
+	struct device_node	*dpa_oh_node;
+	int			 lenp, _errno = 0, fq_idx;
+	const phandle		*oh_port_handle;
+	struct of_device	*oh_of_dev;
+	struct device_node	*oh_node;
+	struct device		*oh_dev;
+	struct dpa_oh_config_s	*oh_config;
+	uint32_t		*oh_all_queues;
+	uint32_t		 queues_count;
+	uint32_t		 crt_fqid_base;
+	uint32_t		 crt_fq_count;
+	struct fm_port_non_rx_params	oh_port_tx_params;
+	struct fm_port_pcd_param	oh_port_pcd_params;
+	/* True if the current partition owns the OH port. */
+	bool init_oh_port;
+
+	dpa_oh_dev = &_of_dev->dev;
+	dpa_oh_node = _of_dev->node;
+	BUG_ON(dpa_oh_node == NULL);
+
+	cpu_dev_dbg(dpa_oh_dev, "Probing OH port...\n");
+
+	/*
+	 * Find the referenced OH node
+	 */
+
+	oh_port_handle = of_get_property(dpa_oh_node,
+		"fsl,fman-oh-port", &lenp);
+	if (oh_port_handle == NULL) {
+		cpu_dev_err(dpa_oh_dev, "No OH port handle found in node %s\n",
+			dpa_oh_node->full_name);
+		return -EINVAL;
+	}
+
+	BUG_ON(lenp % sizeof(*oh_port_handle));
+	if (lenp != sizeof(*oh_port_handle)) {
+		cpu_dev_err(dpa_oh_dev, "Found %d OH port bindings in node %s, "
+			"only 1 phandle is allowed.\n",
+			lenp / sizeof(*oh_port_handle), dpa_oh_node->full_name);
+		return -EINVAL;
+	}
+
+	/* Read configuration for the OH port */
+	oh_node = of_find_node_by_phandle(*oh_port_handle);
+	if (oh_node == NULL) {
+		cpu_dev_err(dpa_oh_dev, "Can't find OH node referenced from "
+			"node %s\n", dpa_oh_node->full_name);
+		return -EINVAL;
+	}
+	cpu_dev_info(dpa_oh_dev, "Found OH node handle compatible with %s.\n",
+		match->compatible);
+
+	oh_of_dev = of_find_device_by_node(oh_node);
+	BUG_ON(oh_of_dev == NULL);
+	oh_dev = &oh_of_dev->dev;
+	of_node_put(oh_node);
+
+	/*
+	 * The OH port must be initialized exactly once.
+	 * The following scenarios are of interest:
+	 *	- the node is Linux-private (will always initialize it);
+	 *	- the node is shared between two Linux partitions
+	 *	  (only one of them will initialize it);
+	 *	- the node is shared between a Linux and a LWE partition
+	 *	  (Linux will initialize it) - "fsl,dpa-oh-shared"
+	 */
+
+	/* Check if the current partition owns the OH port
+	 * and ought to initialize it. It may be the case that we leave this
+	 * to another (also Linux) partition. */
+	init_oh_port = strcmp(match->compatible, "fsl,dpa-oh-shared");
+
+	/* If we aren't the "owner" of the OH node, we're done here. */
+	if (!init_oh_port) {
+		cpu_dev_dbg(dpa_oh_dev, "Not owning the shared OH port %s, "
+			"will not initialize it.\n", oh_node->full_name);
+		return 0;
+	}
+
+	/* Allocate OH dev private data */
+	oh_config = devm_kzalloc(dpa_oh_dev, sizeof(*oh_config), GFP_KERNEL);
+	if (oh_config == NULL) {
+		cpu_dev_err(dpa_oh_dev, "Can't allocate private data for "
+			"OH node %s referenced from node %s!\n",
+			oh_node->full_name, dpa_oh_node->full_name);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Read FQ ids/nums for the DPA OH node
+	 */
+	oh_all_queues = (uint32_t *)of_get_property(dpa_oh_node,
+		"fsl,qman-frame-queues-oh", &lenp);
+	if (oh_all_queues == NULL) {
+		cpu_dev_err(dpa_oh_dev, "No frame queues have been "
+			"defined for OH node %s referenced from node %s\n",
+			oh_node->full_name, dpa_oh_node->full_name);
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+
+	/* Check that the OH error and default FQs are there */
+	BUG_ON(lenp % (2 * sizeof(*oh_all_queues)));
+	queues_count = lenp / (2 * sizeof(*oh_all_queues));
+	if (queues_count != 2) {
+		dpaa_eth_err(dpa_oh_dev, "Error and Default queues must be "
+			"defined for OH node %s referenced from node %s\n",
+			oh_node->full_name, dpa_oh_node->full_name);
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+
+	/* Read the FQIDs defined for this OH port */
+	cpu_dev_dbg(dpa_oh_dev, "Reading %d queues...\n", queues_count);
+	fq_idx = 0;
+
+	/* Error FQID - must be present */
+	crt_fqid_base = oh_all_queues[fq_idx++];
+	crt_fq_count = oh_all_queues[fq_idx++];
+	if (crt_fq_count != 1) {
+		cpu_dev_err(dpa_oh_dev, "Only 1 Error FQ allowed in OH node %s "
+			"referenced from node %s (read: %d FQIDs).\n",
+			oh_node->full_name, dpa_oh_node->full_name,
+			crt_fq_count);
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+	oh_config->error_fqid = crt_fqid_base;
+	cpu_dev_dbg(dpa_oh_dev, "Read Error FQID 0x%x for OH port %s.\n",
+		oh_config->error_fqid, oh_node->full_name);
+
+	/* Default FQID - must be present */
+	crt_fqid_base = oh_all_queues[fq_idx++];
+	crt_fq_count = oh_all_queues[fq_idx++];
+	if (crt_fq_count != 1) {
+		cpu_dev_err(dpa_oh_dev, "Only 1 Default FQ allowed "
+			"in OH node %s referenced from %s (read: %d FQIDs).\n",
+			oh_node->full_name, dpa_oh_node->full_name,
+			crt_fq_count);
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+	oh_config->default_fqid = crt_fqid_base;
+	cpu_dev_dbg(dpa_oh_dev, "Read Default FQID 0x%x for OH port %s.\n",
+		oh_config->default_fqid, oh_node->full_name);
+
+	/* Get a handle to the fm_port so we can set
+	 * its configuration params */
+	oh_config->oh_port = fm_port_bind(oh_dev);
+	if (oh_config->oh_port == NULL) {
+		cpu_dev_err(dpa_oh_dev, "NULL drvdata from fm port dev %s!\n",
+			oh_node->full_name);
+		_errno = -EINVAL;
+		goto return_kfree;
+	}
+
+	/* Set Tx params */
+	dpaa_eth_init_port(tx, oh_config->oh_port, oh_port_tx_params,
+		oh_config->error_fqid, oh_config->default_fqid);
+	/* Set PCD params */
+	oh_port_pcd_params.cb = alloc_oh_pcd_fqids;
+	oh_port_pcd_params.dev = dpa_oh_dev;
+	fm_port_pcd_bind(oh_config->oh_port, &oh_port_pcd_params);
+
+	dev_set_drvdata(dpa_oh_dev, oh_config);
+
+	/* Enable the OH port */
+	fm_port_enable(oh_config->oh_port);
+	cpu_dev_info(dpa_oh_dev, "OH port %s enabled.\n", oh_node->full_name);
+
+	return 0;
+
+return_kfree:
+	devm_kfree(dpa_oh_dev, oh_config);
+	return _errno;
+}
+
+static int __devexit __cold oh_port_remove(struct of_device *_of_dev)
+{
+	int _errno = 0;
+	struct dpa_oh_config_s *oh_config;
+
+	cpu_pr_info("Removing OH port...\n");
+
+	oh_config = dev_get_drvdata(&_of_dev->dev);
+	if (oh_config == NULL) {
+		cpu_pr_err(KBUILD_MODNAME
+			": %s:%hu:%s(): No OH config in device private data!\n",
+			__file__, __LINE__, __func__);
+		_errno = -ENODEV;
+		goto return_error;
+	}
+	if (oh_config->oh_port == NULL) {
+		cpu_pr_err(KBUILD_MODNAME
+			": %s:%hu:%s(): No fm port in device private data!\n",
+			__file__, __LINE__, __func__);
+		_errno = -EINVAL;
+		goto return_error;
+	}
+
+	fm_port_disable(oh_config->oh_port);
+	devm_kfree(&_of_dev->dev, oh_config);
+	dev_set_drvdata(&_of_dev->dev, NULL);
+
+return_error:
+	return _errno;
+}
+
+static int __init __cold oh_port_load(void)
+{
+	int _errno;
+
+	cpu_pr_info(KBUILD_MODNAME ": " OH_MOD_DESCRIPTION " (" VERSION ")\n");
+
+	_errno = of_register_platform_driver(&oh_port_driver);
+	if (_errno < 0) {
+		cpu_pr_err(KBUILD_MODNAME
+			": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			__file__, __LINE__, __func__, _errno);
+	}
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+	return _errno;
+}
+module_init(oh_port_load);
+
+static void __exit __cold oh_port_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&oh_port_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(oh_port_unload);
diff --git a/drivers/net/dpa/offline_port.h b/drivers/net/dpa/offline_port.h
new file mode 100644
index 0000000..1b1a63f
--- /dev/null
+++ b/drivers/net/dpa/offline_port.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __OFFLINE_PORT_H
+#define __OFFLINE_PORT_H
+
+#include "fsl_fman.h"
+
+/* OH port configuration */
+struct dpa_oh_config_s {
+	uint32_t		error_fqid;
+	uint32_t		default_fqid;
+	struct fm_port		*oh_port;
+};
+
+#endif /* __OFFLINE_PORT_H */
diff --git a/drivers/net/dpa/port-wrapper.c b/drivers/net/dpa/port-wrapper.c
new file mode 100644
index 0000000..185ebee
--- /dev/null
+++ b/drivers/net/dpa/port-wrapper.c
@@ -0,0 +1,300 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>		/* in_be32() */
+#include <linux/of_platform.h>
+
+#include "dpaa_eth-common.h"
+#include "fm.h"			/* fmdev_priv() */
+#include "fm-wrapper.h"		/* struct fm_priv_s */
+#include "port.h"
+
+#include "fm_common.h"		/* BASE_RX/TX_PORTID */
+#include "lnxwrp_fm.h"		/* t_LnxWrpFmPortDev */
+#include "lnxwrp_fm_ext.h"
+
+#define PORT_DESCRIPTION "FSL FMan port wrapper based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(PORT_DESCRIPTION);
+
+struct port_priv_s {
+	t_LnxWrpFmPortDev		*port;
+	t_SysObjectAdvConfigEntry	 config[FM_MAX_NUM_OF_ADV_SETTINGS];
+};
+
+struct rx_priv_s {
+	struct port_priv_s	port;
+	fm_port_rx_params_t	param;
+};
+
+struct tx_priv_s {
+	struct port_priv_s	port;
+	fm_port_non_rx_params_t	param;
+};
+
+const char	*port_driver_description __initconst = PORT_DESCRIPTION;
+const size_t	 port_sizeof_priv[] __devinitconst = {
+	[RX] = sizeof(struct rx_priv_s),
+	[TX] = sizeof(struct tx_priv_s)
+};
+
+/* RX */
+
+static int __devinit __cold __attribute__((nonnull))
+init(const struct port_device *port_dev, uint8_t logical_index)
+{
+	struct port_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	priv->port->id		= logical_index;
+	priv->port->baseAddr	= (typeof(priv->port->baseAddr))port_dev->vaddr;
+	priv->port->memSize	= port_dev->res->end + 1 - port_dev->res->start;
+
+	priv->port->settings.param.fmId		= port_dev->fm_dev->cell_index;
+	priv->port->settings.param.portId	= logical_index;
+	priv->port->settings.param.h_App	= priv->port;
+
+	priv->port->settings.advConfig		= priv->config;
+
+	priv->port->h_LnxWrpFmDev	= &((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm;
+
+	return 0;
+}
+
+static int __devinit __cold init_rx(struct port_device *port_dev)
+{
+	struct rx_priv_s	*priv;
+	uint8_t			 logical_index;
+
+	priv = portdev_priv(port_dev);
+
+	logical_index = port_dev->cell_index - BASE_RX_PORTID;
+	priv->port.port =
+		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.rxPorts + logical_index;
+
+	priv->port.port->settings.param.portType	= e_FM_PORT_TYPE_RX;
+
+	/* Ugly hack! */
+	priv->port.port->settings.param.specificParams.rxParams.rxPartitionId	=
+		in_be32(port_dev->fm_dev->vaddr + 0x80000 + 0x300 +
+			sizeof(uint32_t) * port_dev->cell_index);
+
+	priv->param.priv_data_size	= 16;
+	priv->param.parse_results	= true;
+
+	priv->port.port->defPcd	= e_FM_PCD_PARSE_RESULTS;
+
+	return init(port_dev, logical_index);
+}
+
+static int __cold __attribute__((nonnull)) _init_rx(const struct port_device *port_dev)
+{
+	const struct rx_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	priv->port.port->active	= true;
+
+	fm_set_rx_port_params(priv->port.port, &priv->param);
+
+	return 0;
+}
+
+static int __devinit __cold set_default_fq_rx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct rx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
+	return 0;
+}
+
+static int __devinit __cold set_error_fq_rx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct rx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
+	return 0;
+}
+
+static int __devinit __cold
+set_bp_info_rx(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count)
+{
+	int			 i;
+	struct rx_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	priv->param.num_pools = min(count,
+			(uint8_t)ARRAY_SIZE(priv->param.pool_param));
+	for (i = 0; i < priv->param.num_pools; i++) {
+		priv->param.pool_param[i].id	= bp_info[i].bpid;
+		priv->param.pool_param[i].size	= bp_info[i].size;
+	}
+
+	return 0;
+}
+
+static int __cold start_rx(struct port_device *port_dev)
+{
+	int			 _errno;
+	const struct rx_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	if (unlikely(!priv->port.port->active)) {
+		_errno = _init_rx(port_dev);
+		if (unlikely(_errno < 0))
+			goto _return;
+	}
+
+	fm_port_enable(priv->port.port);
+	_errno = 0;
+
+_return:
+	return _errno;
+}
+
+static int __cold stop(struct port_device *port_dev)
+{
+	fm_port_disable(((struct port_priv_s *)portdev_priv(port_dev))->port);
+	return 0;
+}
+
+#ifdef CONFIG_BUG
+static uint8_t get_lpid(const struct port_device *port_dev)
+{
+	return port_dev->fm_dev->cell_index << 6 | port_dev->cell_index;
+}
+#endif
+
+/* TX */
+
+static int __devinit __cold init_tx(struct port_device *port_dev)
+{
+	struct tx_priv_s	*priv;
+	uint8_t			 logical_index;
+
+	priv = portdev_priv(port_dev);
+
+	logical_index = port_dev->cell_index - BASE_TX_PORTID;
+	priv->port.port =
+		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.txPorts + logical_index;
+
+	priv->port.port->settings.param.portType = e_FM_PORT_TYPE_TX;
+
+	priv->port.port->settings.param.specificParams.nonRxParams.deqSubPortal	=
+		port_dev->channel & 0xf;
+
+	priv->port.port->defPcd	= e_NO_PCD;
+
+	return init(port_dev, logical_index);
+}
+
+static int __cold __attribute__((nonnull)) _init_tx(const struct port_device *port_dev)
+{
+	const struct tx_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	priv->port.port->active	= true;
+
+	fm_set_tx_port_params(priv->port.port, &priv->param);
+
+	return 0;
+}
+
+static int __devinit __cold set_default_fq_tx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct tx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
+	return 0;
+}
+
+static int __devinit __cold set_error_fq_tx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct tx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
+	return 0;
+}
+
+static int __cold start_tx(struct port_device *port_dev)
+{
+	int			 _errno;
+	const struct tx_priv_s	*priv;
+
+	priv = portdev_priv(port_dev);
+
+	if (unlikely(!priv->port.port->active)) {
+		_errno = _init_tx(port_dev);
+		if (unlikely(_errno < 0))
+			goto _return;
+	}
+
+	fm_port_enable(priv->port.port);
+	_errno = 0;
+
+_return:
+	return _errno;
+}
+
+static void __devinit __cold setup_rx(struct port_device *port_dev)
+{
+	port_dev->init			= init_rx;
+	port_dev->start			= start_rx;
+	port_dev->stop			= stop;
+	port_dev->set_default_fq	= set_default_fq_rx;
+	port_dev->set_error_fq		= set_error_fq_rx;
+	port_dev->set_bp_info		= set_bp_info_rx;
+#ifdef CONFIG_BUG
+	port_dev->get_lpid		= get_lpid;
+#endif
+	port_dev->uninit		= NULL;
+}
+
+static void __devinit __cold setup_tx(struct port_device *port_dev)
+{
+	port_dev->init			= init_tx;
+	port_dev->start			= start_tx;
+	port_dev->stop			= stop;
+	port_dev->set_default_fq	= set_default_fq_tx;
+	port_dev->set_error_fq		= set_error_fq_tx;
+	port_dev->set_bp_info		= NULL;
+#ifdef CONFIG_BUG
+	port_dev->get_lpid		= NULL;
+#endif
+	port_dev->uninit		= NULL;
+}
+
+void (*const port_setup[])(struct port_device *port_dev) __devinitconst = {
+	[RX] = setup_rx,
+	[TX] = setup_tx
+};
diff --git a/drivers/net/dpa/port.c b/drivers/net/dpa/port.c
new file mode 100644
index 0000000..ff5430e
--- /dev/null
+++ b/drivers/net/dpa/port.c
@@ -0,0 +1,242 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/io.h>		/* devm_ioremap() */
+
+#include "dpaa_eth-common.h"
+#include "port.h"
+
+static struct port_device * __devinit __cold
+alloc_portdev(struct device *dev, size_t sizeof_priv,
+		void (*setup)(struct port_device *port_dev))
+{
+	struct port_device *port_dev;
+
+	port_dev = devm_kzalloc(dev, sizeof(*port_dev) + sizeof_priv,
+			GFP_KERNEL);
+	if (port_dev == NULL)
+		return ERR_PTR(-ENOMEM);
+
+	port_dev->dev = dev;
+	dev_set_drvdata(dev, port_dev);
+	setup(port_dev);
+
+	return port_dev;
+}
+
+static int __devexit __cold free_portdev(struct port_device *port_dev)
+{
+	dev_set_drvdata(port_dev->dev, NULL);
+
+	return likely(port_dev->uninit) ? port_dev->uninit(port_dev) : 0;
+}
+
+static const struct of_device_id port_match[] __devinitconst = {
+	[RX] = {
+		.compatible	= "fsl,fman-port-rx"
+	},
+	[TX] = {
+		.compatible	= "fsl,fman-port-tx"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, port_match);
+
+static const char port_type[][8] __devinitconst = {
+	[RX] = "port-rx",
+	[TX] = "port-tx"
+};
+
+static int __devinit __cold port_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int			 _errno, i, lenp;
+	struct device		*dev;
+	struct device_node	*port_node, *fm_node;
+	struct port_device	*port_dev;
+	struct of_device	*of_dev;
+	struct resource		 res;
+	const uint32_t		*uint32_prop;
+
+	dev = &_of_dev->dev;
+
+	port_node = _of_dev->node;
+
+	for (i = 0; i < ARRAY_SIZE(port_match) - 1 && match != port_match + i; i++);
+	BUG_ON(i >= ARRAY_SIZE(port_match) - 1);
+
+	port_dev = alloc_portdev(dev, port_sizeof_priv[i], port_setup[i]);
+	if (IS_ERR(port_dev)) {
+		dpaa_eth_err(dev, "alloc_portdev() = %d\n", _errno);
+		_errno = PTR_ERR(port_dev);
+		goto _return;
+	}
+
+	/* Get the FM node */
+	fm_node = of_get_parent(port_node);
+	if (unlikely(fm_node == NULL)) {
+		dpaa_eth_err(dev, "of_get_parent(%s) failed\n",
+				port_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	of_dev = of_find_device_by_node(fm_node);
+	if (unlikely(of_dev == NULL)) {
+		dpaa_eth_err(dev, "of_find_device_by_node(%s) failed\n",
+				fm_node->full_name);
+		of_node_put(fm_node);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	of_node_put(fm_node);
+
+	port_dev->fm_dev = dev_get_drvdata(&of_dev->dev);
+	BUG_ON(port_dev->fm_dev == NULL);
+
+	/* Get the address of the memory mapped registers */
+	_errno = of_address_to_resource(port_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "of_address_to_resource(%s) = %d\n",
+				port_node->full_name, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	port_dev->res = __devm_request_region(dev, port_dev->fm_dev->res,
+					      res.start, res.end + 1 - res.start, port_type[i]);
+	if (unlikely(port_dev->res == NULL)) {
+		dpaa_eth_err(dev, "__devm_request_mem_region(port) failed\n");
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	port_dev->vaddr = devm_ioremap(dev, port_dev->res->start,
+				       port_dev->res->end + 1 - port_dev->res->start);
+	if (unlikely(port_dev->vaddr == NULL)) {
+		dpaa_eth_err(dev, "devm_ioremap() failed\n");
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	uint32_prop = of_get_property(port_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		dpaa_eth_err(dev, "of_get_property(%s, cell-index) failed\n",
+				port_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	port_dev->cell_index = *uint32_prop;
+
+	if (match != port_match + RX) {
+		uint32_prop = of_get_property(port_node,
+				"fsl,qman-channel-id", &lenp);
+		if (unlikely(uint32_prop == NULL)) {
+			dpaa_eth_err(dev,
+				"of_get_property(%s, fsl,qman-channel-id)"
+				" failed\n", port_node->full_name);
+			_errno = -EINVAL;
+			goto _return_dev_set_drvdata;
+		}
+		BUG_ON(lenp != sizeof(uint32_t));
+		port_dev->channel = *uint32_prop;
+	}
+
+	_errno = port_dev->init(port_dev);
+	if (unlikely(_errno < 0)) {
+		dpaa_eth_err(dev, "port_dev->init() = %d\n", _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	goto _return;
+
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	return _errno;
+}
+
+static int __devexit __cold port_remove(struct of_device *of_dev)
+{
+	int		 _errno;
+	struct device	*dev;
+
+	dev = &of_dev->dev;
+
+	_errno = free_portdev((struct port_device *)dev_get_drvdata(dev));
+
+	return _errno;
+}
+
+static struct of_platform_driver port_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= port_match,
+	.owner		= THIS_MODULE,
+	.probe		= port_probe,
+	.remove		= __devexit_p(port_remove)
+};
+
+static int __init __cold port_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", port_driver_description);
+
+	_errno = of_register_platform_driver(&port_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			   __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(port_load);
+
+static void __exit __cold port_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&port_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(port_unload);
diff --git a/drivers/net/dpa/port.h b/drivers/net/dpa/port.h
new file mode 100644
index 0000000..5d8f4d3
--- /dev/null
+++ b/drivers/net/dpa/port.h
@@ -0,0 +1,75 @@
+/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PORT_H
+#define __PORT_H
+
+#include <linux/device.h>	/* struct device */
+
+#include "fm.h"			/* struct fm_device */
+
+struct port_bp_info {
+	uint8_t	bpid;
+	size_t	size;
+};
+
+struct port_device {
+	struct device		*dev;
+	void			*priv;
+	uint8_t			 cell_index;
+	struct resource		*res;
+	void			*vaddr;
+	uint16_t		 channel;
+
+	struct fm_device	*fm_dev;
+
+	int (*init)(struct port_device *port_dev);
+	int (*set_default_fq)(struct port_device *port_dev, uint32_t fq);
+	int (*set_error_fq)(struct port_device *port_dev, uint32_t fq);
+	int (*set_bp_info)(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count);
+	int (*start)(struct port_device *port_dev);
+	int (*stop)(struct port_device *port_dev);
+#ifdef CONFIG_BUG
+	uint8_t (*get_lpid)(const struct port_device *port_dev);
+#endif
+	int (*uninit)(struct port_device *port_dev);
+};
+
+static inline void * __attribute((nonnull)) portdev_priv(const struct port_device *port_dev)
+{
+	return (void *)port_dev + sizeof(*port_dev);
+}
+
+extern const char	*port_driver_description;
+extern const size_t	 port_sizeof_priv[];
+extern void (*const port_setup[])(struct port_device *port_dev);
+
+#endif	/* __PORT_H */
diff --git a/drivers/net/dpa/xgmac_mdio.c b/drivers/net/dpa/xgmac_mdio.c
new file mode 100644
index 0000000..b35f2f4
--- /dev/null
+++ b/drivers/net/dpa/xgmac_mdio.c
@@ -0,0 +1,286 @@
+/* Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * QorIQ 10-G MDIO Controller
+ *
+ * Author: Andy Fleming <afleming@freescale.com>
+ *
+ * Based on fsl_pq_mdio.c
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_mdio.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/irq.h>
+
+#include "xgmac_mdio.h"
+
+/* Write value to the PHY for this device to the register at regnum, */
+/* waiting until the write is done before it returns.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+int xgmac_mdio_write(struct mii_bus *bus, int port_addr,
+			int dev_addr, int regnum, u16 value)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	u32 mdio_ctl, mdio_stat;
+
+	/* Setup the MII Mgmt clock speed */
+	mdio_stat = MDIO_STAT_CLKDIV(100);
+	/* workaround for erratum XAUI3, only needs for Rev1 silicon */
+	if ((mfspr(SPRN_SVR) & 0xff) == 0x10)
+		mdio_stat |= 0xc;
+	out_be32(&regs->mdio_stat, mdio_stat);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Set the port and dev addr */
+	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Set the register address */
+	out_be32(&regs->mdio_addr, regnum & 0xffff);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Write the value to the register */
+	out_be32(&regs->mdio_data, MDIO_DATA(value));
+
+	/* Wait till the MDIO write is complete */
+	while ((in_be32(&regs->mdio_data)) & MDIO_DATA_BSY)
+		cpu_relax();
+
+	return 0;
+}
+
+
+/* Reads from register regnum in the PHY for device dev, */
+/* returning the value.  Clears miimcom first.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+int xgmac_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	u32 mdio_ctl, mdio_stat;
+
+	/* Setup the MII Mgmt clock speed */
+	mdio_stat = MDIO_STAT_CLKDIV(100);
+	/* workaround for erratum XAUI3, only needs for Rev1 silicon */
+	if ((mfspr(SPRN_SVR) & 0xff) == 0x10)
+		mdio_stat |= 0xc;
+	out_be32(&regs->mdio_stat, mdio_stat);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Set the Port and Device Addrs */
+	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Set the register address */
+	out_be32(&regs->mdio_addr, regnum & 0xffff);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Initiate the read */
+	mdio_ctl |= MDIO_CTL_READ;
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Wait till the MDIO write is complete */
+	while ((in_be32(&regs->mdio_data)) & MDIO_DATA_BSY)
+		cpu_relax();
+
+	return in_be32(&regs->mdio_data) & 0xffff;
+}
+
+
+/* Reset the MIIM registers, and wait for the bus to free */
+static int xgmac_mdio_reset(struct mii_bus *bus)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	int timeout = PHY_INIT_TIMEOUT;
+	u32 mdio_stat;
+
+	mutex_lock(&bus->mdio_lock);
+
+	/* Setup the MII Mgmt clock speed */
+	mdio_stat = MDIO_STAT_CLKDIV(100);
+	/* workaround for erratum XAUI3, only needs for Rev1 silicon */
+	if ((mfspr(SPRN_SVR) & 0xff) == 0x10)
+		mdio_stat |= 0xc;
+	out_be32(&regs->mdio_stat, mdio_stat);
+
+	/* Wait till the bus is free */
+	while (((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY) && timeout--)
+		cpu_relax();
+
+	mutex_unlock(&bus->mdio_lock);
+
+	if (timeout < 0) {
+		printk(KERN_ERR "%s: The MII Bus is stuck!\n",
+				bus->name);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+static int xgmac_mdio_probe(struct of_device *ofdev,
+		const struct of_device_id *match)
+{
+	struct tgec_mdio_controller __iomem *regs;
+	struct device_node *np = ofdev->node;
+	struct mii_bus *new_bus;
+	u64 addr, size;
+	int err = 0;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	new_bus = mdiobus_alloc();
+	if (NULL == new_bus)
+		return -ENOMEM;
+
+	new_bus->name = "Freescale XGMAC MDIO Bus",
+	new_bus->read = &xgmac_mdio_read,
+	new_bus->write = &xgmac_mdio_write,
+	new_bus->reset = &xgmac_mdio_reset,
+
+	/* Set the PHY base address */
+	addr = of_translate_address(np, of_get_address(np, 0, &size, NULL));
+	regs = ioremap(addr, size);
+
+	if (NULL == regs) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	new_bus->priv = (void __force *)regs;
+
+	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+
+	if (NULL == new_bus->irq) {
+		err = -ENOMEM;
+		goto err_irq_alloc;
+	}
+
+	new_bus->parent = &ofdev->dev;
+	dev_set_drvdata(&ofdev->dev, new_bus);
+
+	sprintf(new_bus->id, "%s", np->name);
+
+	err = of_mdiobus_register(new_bus, np);
+
+	if (err) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+				new_bus->name);
+		goto err_registration;
+	}
+
+	return 0;
+
+err_registration:
+	kfree(new_bus->irq);
+err_irq_alloc:
+	iounmap(regs);
+err_ioremap:
+	return err;
+}
+
+
+static int xgmac_mdio_remove(struct of_device *ofdev)
+{
+	struct device *device = &ofdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(device);
+
+	mdiobus_unregister(bus);
+
+	dev_set_drvdata(device, NULL);
+
+	iounmap((void __iomem *)bus->priv);
+	bus->priv = NULL;
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static struct of_device_id xgmac_mdio_match[] = {
+	{
+		.compatible = "fsl,fman-xmdio",
+	},
+	{},
+};
+
+static struct of_platform_driver xgmac_mdio_driver = {
+	.name = "fsl-fman_xmdio",
+	.probe = xgmac_mdio_probe,
+	.remove = xgmac_mdio_remove,
+	.match_table = xgmac_mdio_match,
+};
+
+int __init xgmac_mdio_init(void)
+{
+	return of_register_platform_driver(&xgmac_mdio_driver);
+}
+
+void xgmac_mdio_exit(void)
+{
+	of_unregister_platform_driver(&xgmac_mdio_driver);
+}
+subsys_initcall_sync(xgmac_mdio_init);
+module_exit(xgmac_mdio_exit);
diff --git a/drivers/net/dpa/xgmac_mdio.h b/drivers/net/dpa/xgmac_mdio.h
new file mode 100644
index 0000000..6eb49cd
--- /dev/null
+++ b/drivers/net/dpa/xgmac_mdio.h
@@ -0,0 +1,61 @@
+/* Copyright 2009-2011 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Freescale FMAN XGMAC MDIO Driver -- MDIO Management Bus Implementation
+ * Driver for the MDIO bus controller on QorIQ 10G ports
+ *
+ * Author: Andy Fleming
+ */
+
+#ifndef __XGMAC_MDIO_H
+#define __XGMAC_MDIO_H
+
+struct tgec_mdio_controller {
+	u32	res0[0xc];
+	u32	mdio_stat;	/* MDIO configuration and status */
+	u32	mdio_ctl;	/* MDIO control */
+	u32	mdio_data;	/* MDIO data */
+	u32	mdio_addr;	/* MDIO address */
+} __attribute__ ((packed));
+
+#define MDIO_STAT_CLKDIV(x)	(((x>>1) & 0xff) << 8)
+#define MDIO_STAT_BSY		(1 << 0)
+#define MDIO_STAT_RD_ER		(1 << 1)
+#define MDIO_CTL_DEV_ADDR(x) 	(x & 0x1f)
+#define MDIO_CTL_PORT_ADDR(x)	((x & 0x1f) << 5)
+#define MDIO_CTL_PRE_DIS	(1 << 10)
+#define MDIO_CTL_SCAN_EN	(1 << 11)
+#define MDIO_CTL_POST_INC	(1 << 14)
+#define MDIO_CTL_READ		(1 << 15)
+
+#define MDIO_DATA(x)		(x & 0xffff)
+#define MDIO_DATA_BSY		(1 << 31)
+
+#endif /* __XGMAC_MDIO_H */
-- 
1.7.0.4

