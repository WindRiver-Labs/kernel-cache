From 6818c1f7d5144869e0fcd07395803fa774c3dae0 Mon Sep 17 00:00:00 2001
From: Xufeng Zhang <xufeng.zhang@windriver.com>
Date: Thu, 19 Apr 2012 10:19:58 +0800
Subject: [PATCH] powerpc/e500: fix breakage with fsl_rio_mcheck_exception

commit 82a9a4809f4cb4ce3f17da99a8150df8455fa096 upstream

The wrong MCSR bit was being used on e500mc.  MCSR_BUS_RBERR only exists
on e500v1/v2.  Use MCSR_LD on e500mc, and remove all MCSR checking
in fsl_rio_mcheck_exception as we now no longer call that function
if the appropriate bit in MCSR is not set.

If RIO support was enabled at compile-time, but was never probed, just
return from fsl_rio_mcheck_exception rather than dereference a NULL
pointer.

TODO: There is still a remaining, though comparitively minor, issue in
that this recovery mechanism will falsely engage if there's an unrelated
MCSR_LD event at the same time as a RIO error.

Signed-off-by: Scott Wood <scottwood@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

[As recoverable variable has already been set to 0 if not branch to
silent_out, it's unnecessary to clear it again afterwards.]

Signed-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>
---
 arch/powerpc/kernel/traps.c   |   20 ++++++++++----------
 arch/powerpc/sysdev/fsl_rio.c |   37 ++++++++++++++++++++-----------------
 2 files changed, 30 insertions(+), 27 deletions(-)

diff --git a/arch/powerpc/kernel/traps.c b/arch/powerpc/kernel/traps.c
index b386209..277add0 100644
--- a/arch/powerpc/kernel/traps.c
+++ b/arch/powerpc/kernel/traps.c
@@ -402,6 +402,14 @@ int machine_check_e500mc(struct pt_regs *regs)
 	unsigned long reason = mcsr;
 	int recoverable = 1;
 
+	if (reason & MCSR_LD) {
+#ifdef CONFIG_RAPIDIO
+		recoverable = fsl_rio_mcheck_exception(regs);
+#endif
+		if (recoverable == 1)
+			goto silent_out;
+        }
+
 	printk("Machine check in kernel mode.\n");
 	printk("Caused by (from MCSR=%lx): ", reason);
 
@@ -444,10 +452,8 @@ int machine_check_e500mc(struct pt_regs *regs)
 		recoverable = 0;
 	}
 
-	if (reason & MCSR_LD) {
+	if (reason & MCSR_LD)
 		printk("Load Error Report\n");
-		recoverable = 0;
-	}
 
 	if (reason & MCSR_ST) {
 		printk("Store Error Report\n");
@@ -477,13 +483,7 @@ int machine_check_e500mc(struct pt_regs *regs)
 		       reason & MCSR_MEA ? "Effective" : "Physical", addr);
 	}
 
-	if (reason & MCSR_BUS_RBERR) {
-		printk("Bus - Read Data Bus Error\n");
-#ifdef CONFIG_RAPIDIO
-		recoverable = fsl_rio_mcheck_exception(regs);
-#endif
-	}
-
+silent_out:
 	mtspr(SPRN_MCSR, mcsr);
 	return mfspr(SPRN_MCSR) == 0 && recoverable;
 }
diff --git a/arch/powerpc/sysdev/fsl_rio.c b/arch/powerpc/sysdev/fsl_rio.c
index caa5065..cfc7337 100644
--- a/arch/powerpc/sysdev/fsl_rio.c
+++ b/arch/powerpc/sysdev/fsl_rio.c
@@ -244,31 +244,34 @@ struct rio_priv {
 
 static void __iomem *rio_regs_win;
 
+#ifdef CONFIG_E500
 int fsl_rio_mcheck_exception(struct pt_regs *regs)
 {
-	const struct exception_table_entry *entry = NULL;
-	unsigned long reason = mfspr(SPRN_MCSR);
-
-	/* covers both e500v1/v2 and e500mc */
-	if (reason & (MCSR_BUS_RBERR | MCSR_LD)) {
-		reason = in_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR));
-		if (reason & (RIO_LTLEDCSR_IER | RIO_LTLEDCSR_PRT)) {
-			/* Check if we are prepared to handle this fault */
-			entry = search_exception_tables(regs->nip);
-			if (entry) {
-				pr_debug("RIO: %s - MC Exception handled\n",
-					 __func__);
-				out_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR),
-					 0);
-				regs->msr |= MSR_RI;
-				regs->nip = entry->fixup;
-				return 1;
-			}
+	const struct exception_table_entry *entry;
+	unsigned long reason;
+
+	if (!rio_regs_win)
+		return 0;
+
+	reason = in_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR));
+	if (reason & (RIO_LTLEDCSR_IER | RIO_LTLEDCSR_PRT)) {
+		/* Check if we are prepared to handle this fault */
+		entry = search_exception_tables(regs->nip);
+		if (entry) {
+			pr_debug("RIO: %s - MC Exception handled\n",
+					__func__);
+			out_be32((u32 *)(rio_regs_win + RIO_LTLEDCSR),
+					0);
+			regs->msr |= MSR_RI;
+			regs->nip = entry->fixup;
+			return 1;
 		}
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(fsl_rio_mcheck_exception);
+#endif
 
 /**
  * fsl_rio_doorbell_send - Send a MPC85xx doorbell message
-- 
1.7.0.4

