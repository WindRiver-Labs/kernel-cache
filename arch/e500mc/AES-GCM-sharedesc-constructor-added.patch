From 91f7b79d588b0743751311592e08aea881bcdda1 Mon Sep 17 00:00:00 2001
From: Steve Cornelius <steve.cornelius@freescale.com>
Date: Tue, 13 Oct 2009 11:05:28 -0700
Subject: [PATCH] AES-GCM sharedesc constructor added

Added sharedesc constructor for AES-GCM, as well as shared
descriptors for KFHA.

Signed-off-by: Steve Cornelius <steve.cornelius@freescale.com>
[Applied FSL SDK 2.0.3 patch
"kernel-2.6.30--AES-GCM-sharedesc-constructor-added.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/crypto/caam/dcl/dcl.h         |   23 +++-
 drivers/crypto/caam/dcl/protoshared.c |  257 ++++++++++++++++++++++++++++++---
 2 files changed, 255 insertions(+), 25 deletions(-)

diff --git a/drivers/crypto/caam/dcl/dcl.h b/drivers/crypto/caam/dcl/dcl.h
index 7dbdbdc..6144a55 100644
--- a/drivers/crypto/caam/dcl/dcl.h
+++ b/drivers/crypto/caam/dcl/dcl.h
@@ -524,14 +524,22 @@ int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
-			    u_int8_t bearer, u_int8_t direction,
-			    u_int8_t clear);
+			    u_int8_t bearer, u_int8_t direction);
 
 int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
-			    u_int32_t fresh, u_int8_t direction,
-			    u_int8_t clear);
+			    u_int32_t fresh, u_int8_t direction);
+
+int32_t cnstr_shdsc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			      u_int8_t *key, u_int32_t keylen,
+			      enum algdir dir, u_int32_t count,
+			      u_int8_t bearer, u_int8_t direction);
+
+int32_t cnstr_shdsc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			      u_int8_t *key, u_int32_t keylen,
+			      enum algdir dir, u_int32_t count,
+			      u_int32_t fresh, u_int8_t direction);
 
 int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 				  u_int8_t *key, u_int32_t keylen,
@@ -539,6 +547,11 @@ int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 				  enum algdir dir, u_int32_t cipher,
 				  u_int8_t clear);
 
+int32_t cnstr_shdsc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
+			    enum mdstatesel mdstate, enum icvsel icv,
+			    enum algdir dir);
+
 int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 			 u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
 			 u_int8_t clear);
@@ -547,7 +560,7 @@ int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 				       u_int8_t *key, u_int32_t keysz,
 				       u_int32_t count, u_int32_t bearer,
 				       u_int32_t direction,
-				       u_int32_t payload_sz, u_int8_t clear);
+				       u_int32_t payload_sz);
 
 /*
  * Section 5 - disassembler definitions
diff --git a/drivers/crypto/caam/dcl/protoshared.c b/drivers/crypto/caam/dcl/protoshared.c
index 70230cc..69a1f7a 100644
--- a/drivers/crypto/caam/dcl/protoshared.c
+++ b/drivers/crypto/caam/dcl/protoshared.c
@@ -697,14 +697,12 @@ EXPORT_SYMBOL(cnstr_shdsc_macsec_decap);
  * @count - UEA2 count value (32 bits)
  * @bearer - UEA2 bearer ID (5 bits)
  * @direction - UEA2 direction (1 bit)
- * @clear - nonzero if descriptor buffer clear requested
  **/
 
 int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
-			    u_int8_t bearer, u_int8_t direction,
-			    u_int8_t clear)
+			    u_int8_t bearer, u_int8_t direction)
 {
 	u_int32_t *start;
 	u_int16_t startidx, endidx;
@@ -722,10 +720,6 @@ int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 	if (!descbuf)
 		return -1;
 
-	/* If user requested a buffer clear, do it from the start */
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
 	/* Save current location for computing start index */
 	startidx = descbuf - start;
 
@@ -753,11 +747,11 @@ int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
 					   FIFOLDST_VLF,
 					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 32);
+					   FIFOLD_TYPE_LASTBOTH), 0);
 
 	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
 					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 32);
+					    FIFOST_TYPE_MESSAGE_DATA, 0);
 
 	/* Now update the header with size/offsets */
 	endidx = descbuf - start;
@@ -781,14 +775,12 @@ EXPORT_SYMBOL(cnstr_shdsc_snow_f8);
  * @count - UEA2 count value (32 bits)
  * @fresh - UEA2 fresh value ID (32 bits)
  * @direction - UEA2 direction (1 bit)
- * @clear - nonzero if descriptor buffer clear requested
  **/
 
 int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
-			    u_int32_t fresh, u_int8_t direction,
-			    u_int8_t clear)
+			    u_int32_t fresh, u_int8_t direction)
 {
 	u_int32_t *start;
 	u_int16_t startidx, endidx;
@@ -808,10 +800,6 @@ int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 	if (!descbuf)
 		return -1;
 
-	/* buffer clear */
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
 	startidx = descbuf - start;
 
 	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
@@ -854,6 +842,157 @@ EXPORT_SYMBOL(cnstr_shdsc_snow_f9);
 
 
 /**
+ * Kasumi/f8 as a shared descriptor
+ *
+ * @descbuf - pointer to descriptor-under-construction buffer
+ * @bufsize - points to size to be updated at completion
+ * @key - cipher key
+ * @keylen - size of key in bits
+ * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
+ * @count - count value (32 bits)
+ * @bearer - bearer ID (5 bits)
+ * @direction - direction (1 bit)
+ **/
+int32_t cnstr_shdsc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			      u_int8_t *key, u_int32_t keylen,
+			      enum algdir dir, u_int32_t count,
+			      u_int8_t bearer, u_int8_t direction)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	u_int64_t COUNT       = count;
+	u_int64_t BEARER      = bearer;
+	u_int64_t DIRECTION   = direction;
+
+	u_int64_t context = (COUNT << 32) | (BEARER << 27) | (DIRECTION << 26);
+
+	start = descbuf++; /* save start for eventual header write */
+
+	/* Verify a clean buffer */
+	if (!descbuf)
+		return -1;
+
+	/* Save current location for computing start index */
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 0);
+
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
+					    FIFOLDST_VLF,
+					    FIFOST_TYPE_MESSAGE_DATA, 0);
+
+	/* Now update the header with size/offsets */
+	endidx = descbuf - start;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_kasumi_f8);
+
+/**
+ * Kasumi/f9 as a shared descriptor
+ *
+ * @descbuf - pointer to descriptor-under-construction buffer
+ * @bufsize - points to size to be updated at completion
+ * @key - cipher key
+ * @keylen - size of key in bits
+ * @dir - cipher direction (DIR_ENCRYPT/DIR_DECRYPT)
+ * @count - count value (32 bits)
+ * @fresh - fresh value ID (32 bits)
+ * @direction - direction (1 bit)
+ **/
+int32_t cnstr_shdsc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			      u_int8_t *key, u_int32_t keylen,
+			      enum algdir dir, u_int32_t count,
+			      u_int32_t fresh, u_int8_t direction)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	u_int64_t ct = count;
+	u_int64_t fr = fresh;
+	u_int64_t dr = direction;
+
+	u_int64_t context[2];
+
+	context[0] = (ct << 32) | (dr << 26);
+	context[1] = fr;
+
+	start = descbuf++; /* header skip */
+
+	if (!descbuf)
+		return -1;
+
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	/* compute sequences */
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F9,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, &context, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   FIFOLDST_VLF,
+					   (FIFOLD_TYPE_MSG |
+					   FIFOLD_TYPE_LASTBOTH), 0);
+
+	/* Save lower half of MAC out into a 32-bit sequence */
+	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
+				       LDST_SRCDST_BYTE_CONTEXT, 0, 4);
+
+	endidx = descbuf - start;
+
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_kasumi_f9);
+
+/**
  * CBC blockcipher
  * @descbuf - descriptor buffer
  * @bufsize - limit/returned descriptor buffer size
@@ -915,11 +1054,11 @@ int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
 					   FIFOLDST_VLF,
 					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 32);
+					   FIFOLD_TYPE_LASTBOTH), 0);
 
 	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB,
 					    FIFOLDST_VLF,
-					    FIFOST_TYPE_MESSAGE_DATA, 32);
+					    FIFOST_TYPE_MESSAGE_DATA, 0);
 
 	/* Now update the header with size/offsets */
 	endidx = descbuf - start;
@@ -932,6 +1071,84 @@ int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 EXPORT_SYMBOL(cnstr_shdsc_cbc_blkcipher);
 
 /**
+ * Constructs an AES-GCM shared descriptor - cnstr_shdsc_aes_gcm()
+ *
+ * @descbuf - pointer to buffer that will hold constructed descriptor
+ * @bufsize - pointer to size of descriptor once constructed
+ * @key - pointer to AES key
+ * @keylen - AES key size
+ * @ctx - pointer to GCM context. This is a concatenation of:
+ *        - MAC (128 bits)
+ *        - Yi (128 bits)
+ *        - Y0 (128 bits)
+ *        - IV (64 bits)
+ *        - Text bitsize (64 bits)
+ *        See the AESA section of the blockguide for more information
+ * @mdstate - select MDSTATE_UPDATE, MDSTATE_INIT, or MDSTATE_FINAL if a
+ *            partial MAC operation is desired, else select MDSTATE_COMPLETE
+ * @icv - select ICV_CHECK_ON if an ICV mac compare is requested
+ * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed for the cipher operation
+ *
+ * Input is taken from the input sequence, output is written to the output
+ * sequence, and the GCM mac is appended to the output sequence
+**/
+int32_t cnstr_shdsc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
+			    enum mdstatesel mdstate, enum icvsel icv,
+			    enum algdir dir)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t mval;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_INLINE,
+				 ITEM_CLASS1);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+			     OP_ALG_ALGSEL_AES, OP_ALG_AAI_GCM,
+			     mdstate, icv, dir);
+
+	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB, 0,
+				  LDST_SRCDST_BYTE_CONTEXT, 0, 64,
+				  ITEM_REFERENCE);
+
+	mval = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQINLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_SEQINLEN,
+				  MATH_SRC1_REG2, MATH_DEST_VARSEQOUTLEN,
+				  4, 0, 0, 0, &mval);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB,
+					   LDST_VLF,
+					   FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1,
+					   0);
+
+	descbuf = cmd_insert_seq_fifo_store(descbuf, FIFOLD_CLASS_SKIP,
+					    LDST_VLF,
+					    FIFOST_TYPE_MESSAGE_DATA, 0);
+
+	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_1_CCB, 0,
+				       LDST_SRCDST_BYTE_CONTEXT, 0, 64);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_aes_gcm);
+
+
+/**
  * HMAC shared
  * @descbuf - descriptor buffer
  * @bufsize - limit/returned descriptor buffer size
@@ -1018,7 +1235,7 @@ int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_2_CCB,
 					   FIFOLDST_VLF,
 					   (FIFOLD_TYPE_MSG |
-					   FIFOLD_TYPE_LASTBOTH), 32);
+					   FIFOLD_TYPE_LASTBOTH), 0);
 
 	descbuf = cmd_insert_seq_store(descbuf, LDST_CLASS_2_CCB, 0,
 				       LDST_SRCDST_BYTE_CONTEXT, 0, storelen);
@@ -1075,7 +1292,7 @@ int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 				       u_int8_t *key, u_int32_t keysz,
 				       u_int32_t count, u_int32_t bearer,
 				       u_int32_t direction,
-				       u_int32_t payload_sz, u_int8_t clear)
+				       u_int32_t payload_sz)
 {
 	u_int32_t *start;
 	u_int16_t startidx, endidx;
-- 
1.6.0.3

