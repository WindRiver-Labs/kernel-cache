From a2c55f6ab96a7e4ac578003ac83e08c9012a4b71 Mon Sep 17 00:00:00 2001
From: Freescale <freescale@freescale.com>
Date: Tue, 21 Apr 2009 10:54:55 -0700
Subject: [PATCH] kernel-2.6.30-initial-CAAM-driver-updates-4080-sdk2.0-dual.patch

[Cleanly applied the FSL SDK 2.0.3 patch:
"kernel-2.6.30-initial-CAAM-driver-updates-4080-sdk2.0-dual.patch"
no Signed-off-by present in original patch]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/crypto/caam/compat.h               |    2 +
 drivers/crypto/caam/ctrl.c                 |  103 ++-
 drivers/crypto/caam/dcl/cmdgen.c           |  270 ++--
 drivers/crypto/caam/dcl/dcl.h              |  201 +--
 drivers/crypto/caam/dcl/disasm.c           | 2498 ++++++++++------------------
 drivers/crypto/caam/dcl/jobdesc.c          |  312 ++++-
 drivers/crypto/caam/dcl/protoshared.c      |  816 ++++++----
 drivers/crypto/caam/desc.h                 |  102 +-
 drivers/crypto/caam/error.c                |  243 +++
 drivers/crypto/caam/error.h                |   38 +
 drivers/crypto/caam/intern.h               |   36 +-
 drivers/crypto/caam/jq.c                   |  111 +-
 drivers/crypto/caam/jq_test/caam_jqtest.c  |   13 +-
 drivers/crypto/caam/jq_test/caam_jqtest.h  |    4 +-
 drivers/crypto/caam/jq_test/jq_blkcipher.c |  111 +-
 drivers/crypto/caam/jq_test/jq_ipsec.c     |  378 ++++-
 drivers/crypto/caam/jq_test/jq_snow.c      |   76 +-
 drivers/crypto/caam/pdb.h                  |  393 +++++
 drivers/crypto/caam/regs.h                 |   44 +-
 19 files changed, 3297 insertions(+), 2454 deletions(-)
 create mode 100644 drivers/crypto/caam/error.c
 create mode 100644 drivers/crypto/caam/error.h
 create mode 100644 drivers/crypto/caam/pdb.h

diff --git a/drivers/crypto/caam/compat.h b/drivers/crypto/caam/compat.h
index b4d33c1..caef4e2 100644
--- a/drivers/crypto/caam/compat.h
+++ b/drivers/crypto/caam/compat.h
@@ -51,6 +51,7 @@
 #include <linux/in.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <linux/debugfs.h>
 #include <net/xfrm.h>
 
 #include <crypto/algapi.h>
@@ -59,6 +60,7 @@
 #include <crypto/sha.h>
 #include <crypto/aead.h>
 #include <crypto/authenc.h>
+#include <crypto/scatterwalk.h>
 
 #define PRINT(format, arg...) printk(format, ##arg)
 
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 8360dd5..16cceb9 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -34,9 +34,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/of_platform.h>
-#include <linux/interrupt.h>
-
+#include "compat.h"
 #include "regs.h"
 #include "intern.h"
 #include "jq.h"
@@ -81,6 +79,11 @@ static int caam_remove(struct of_device *ofdev)
 	if (ctrlpriv->qi_present)
 		wr_reg32(&ctrlpriv->qi->qi_control_lo, QICTL_STOP);
 
+	/* Shut down debug views */
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(ctrlpriv->dfs_root);
+#endif
+
 	/* Unmap controller region */
 	iounmap(&ctrlpriv->ctrl);
 
@@ -105,6 +108,7 @@ static int caam_probe(struct of_device *ofdev,
 	struct device_node *nprop, *np;
 	struct caam_full *topregs;
 	struct caam_drv_private *ctrlpriv;
+	u32 mstrcfg;
 
 	ctrlpriv = kzalloc(sizeof(struct caam_drv_private), GFP_KERNEL);
 	if (!ctrlpriv)
@@ -129,6 +133,11 @@ static int caam_probe(struct of_device *ofdev,
 	/* Get the IRQ of the controller (for security violations only) */
 	ctrlpriv->secvio_irq = of_irq_to_resource(nprop, 0, NULL);
 
+	/* Enable DECO watchdogs in master configuration register */
+	mstrcfg = rd_reg32(&ctrlpriv->ctrl->mcr);
+	mstrcfg |= MCFGR_WDENABLE;
+	wr_reg32(&ctrlpriv->ctrl->mcr, mstrcfg);
+
 	/*
 	 * Device tree provides no information on the actual number
 	 * of DECOs instantiated in the device. Total available will
@@ -200,6 +209,94 @@ static int caam_probe(struct of_device *ofdev,
 	caam_jq_algapi_init(dev);
 #endif
 
+#ifdef CONFIG_DEBUG_FS
+	/*
+	 * FIXME: needs better naming distinction, as some amalgamation of
+	 * "caam" and nprop->full_name. The OF name isn't distinctive,
+	 * but does separate instances
+	 */
+	ctrlpriv->dfs_root = debugfs_create_dir("caam", NULL);
+	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
+
+	/* Controller-level - performance monitor counters */
+	ctrlpriv->ctl_rq_dequeued =
+		debugfs_create_u64("rq_dequeued",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.req_dequeued);
+	ctrlpriv->ctl_ob_enc_req =
+		debugfs_create_u64("ob_rq_encrypted",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ob_enc_req);
+	ctrlpriv->ctl_ib_dec_req =
+		debugfs_create_u64("ib_rq_decrypted",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ib_dec_req);
+	ctrlpriv->ctl_ob_enc_bytes =
+		debugfs_create_u64("ob_bytes_encrypted",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ob_enc_bytes);
+	ctrlpriv->ctl_ob_prot_bytes =
+		debugfs_create_u64("ob_bytes_protected",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ob_prot_bytes);
+	ctrlpriv->ctl_ib_dec_bytes =
+		debugfs_create_u64("ib_bytes_decrypted",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ib_dec_bytes);
+	ctrlpriv->ctl_ib_valid_bytes =
+		debugfs_create_u64("ib_bytes_validated",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.ib_valid_bytes);
+
+	/* Controller level - global status values */
+	ctrlpriv->ctl_faultaddr =
+		debugfs_create_u64("fault_addr",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.faultaddr);
+	ctrlpriv->ctl_faultdetail =
+		debugfs_create_u32("fault_detail",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.faultdetail);
+	ctrlpriv->ctl_faultstatus =
+		debugfs_create_u32("fault_status",
+				   S_IFCHR | S_IRUSR | S_IRGRP | S_IROTH,
+				   ctrlpriv->ctl,
+				   &ctrlpriv->ctrl->perfmon.status);
+
+	/* Internal covering keys (useful in non-secure mode only) */
+	ctrlpriv->ctl_kek_wrap.data = &ctrlpriv->ctrl->kek[0];
+	ctrlpriv->ctl_kek_wrap.size = KEK_KEY_SIZE * sizeof(__be32);
+	ctrlpriv->ctl_kek = debugfs_create_blob("kek",
+						S_IFCHR | S_IRUSR |
+						S_IRGRP | S_IROTH,
+						ctrlpriv->ctl,
+						&ctrlpriv->ctl_kek_wrap);
+
+	ctrlpriv->ctl_tkek_wrap.data = &ctrlpriv->ctrl->tkek[0];
+	ctrlpriv->ctl_tkek_wrap.size = KEK_KEY_SIZE * sizeof(__be32);
+	ctrlpriv->ctl_tkek = debugfs_create_blob("tkek",
+						 S_IFCHR | S_IRUSR |
+						 S_IRGRP | S_IROTH,
+						 ctrlpriv->ctl,
+						 &ctrlpriv->ctl_tkek_wrap);
+
+	ctrlpriv->ctl_tdsk_wrap.data = &ctrlpriv->ctrl->tdsk[0];
+	ctrlpriv->ctl_tdsk_wrap.size = KEK_KEY_SIZE * sizeof(__be32);
+	ctrlpriv->ctl_tdsk = debugfs_create_blob("tdsk",
+						 S_IFCHR | S_IRUSR |
+						 S_IRGRP | S_IROTH,
+						 ctrlpriv->ctl,
+						 &ctrlpriv->ctl_tdsk_wrap);
+#endif
 	return 0;
 }
 
diff --git a/drivers/crypto/caam/dcl/cmdgen.c b/drivers/crypto/caam/dcl/cmdgen.c
index 27ec65c..3eb89c5 100644
--- a/drivers/crypto/caam/dcl/cmdgen.c
+++ b/drivers/crypto/caam/dcl/cmdgen.c
@@ -1,6 +1,6 @@
 /*
  * CAAM Descriptor Construction Library
- * Descriptor Command Generator
+ * Descriptor Instruction Generator
  *
  * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
  * All Rights Reserved
@@ -50,7 +50,7 @@
  * Returns: Pointer to next incremental descriptor word past the header
  * just constructed. If an error occurred, returns 0.
  *
- * @descwd   = pointer to target descriptor word to hold this command.
+ * @descwd   = pointer to target descriptor word to hold this instruction.
  *             Note that this should always be the first word of a
  *             descriptor.
  * @startidx = index to continuation of descriptor data, normally the
@@ -284,7 +284,7 @@ u_int32_t *cmd_insert_key(u_int32_t *descwd, u_int8_t *key, u_int32_t keylen,
 
 /**
  * cmd_insert_seq_key()
- * Insert a sequence key command into a descriptor
+ * Insert a key command into a descriptor using a sequence
  *
  * Returns: If successful, returns a pointer to the target word
  * incremented past the newly-inserted command (including item pointer
@@ -389,8 +389,9 @@ u_int32_t *cmd_insert_seq_key(u_int32_t *descwd, u_int32_t keylen,
  * just constructed. If an error occurred, returns 0;
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
- *              the final word of a single descriptor.
+ *              this command. For an OPERATION instruction within the
+ *              scope of a protocol descriptor, this is normally
+ *              the final word of that descriptor.
  *
  * @cipheralg = blockcipher selection for this protocol descriptor.
  *              This should be one of CIPHER_TYPE_IPSEC_.
@@ -515,8 +516,9 @@ u_int32_t *cmd_insert_proto_op_ipsec(u_int32_t *descwd, u_int8_t cipheralg,
  * AES-CCM
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
- *              the final word of a single descriptor.
+ *              this command. For an OPERATION instruction within the
+ *              scope of a protocol descriptor, this is normally
+ *              the final word of that descriptor.
  *
  * @mode      = nonzero is OFDMa, else assume OFDM
  *
@@ -527,7 +529,8 @@ u_int32_t *cmd_insert_proto_op_wimax(u_int32_t *descwd, u_int8_t mode,
 				     enum protdir dir)
 {
 	*descwd = CMD_OPERATION | OP_PCLID_WIMAX |
-		  (mode ? OP_PCL_WIMAX_OFDMA : OP_PCL_WIMAX_OFDM);
+		  (mode ? OP_PCL_WIMAX_OFDMA : OP_PCL_WIMAX_OFDM) |
+		  (dir ? OP_TYPE_DECAP_PROTOCOL : OP_TYPE_ENCAP_PROTOCOL);
 
 	return descwd++;
 }
@@ -536,15 +539,17 @@ u_int32_t *cmd_insert_proto_op_wimax(u_int32_t *descwd, u_int8_t mode,
  * Insert a 802.11 WiFi protocol OP instruction
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
- *              the final word of a single descriptor.
+ *              this command. For an OPERATION instruction within the
+ *              scope of a protocol descriptor, this is normally
+ *              the final word of that descriptor.
  *
  * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
  *              decapsulation operations.
  **/
 u_int32_t *cmd_insert_proto_op_wifi(u_int32_t *descwd, enum protdir dir)
 {
-	*descwd = CMD_OPERATION | OP_PCLID_WIFI | OP_PCL_WIFI;
+	*descwd = CMD_OPERATION | OP_PCLID_WIFI | OP_PCL_WIFI |
+		  (dir ? OP_TYPE_DECAP_PROTOCOL : OP_TYPE_ENCAP_PROTOCOL);
 
 	return descwd++;
 }
@@ -553,7 +558,8 @@ u_int32_t *cmd_insert_proto_op_wifi(u_int32_t *descwd, enum protdir dir)
  * Insert a MacSec protocol OP instruction
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
+ *              this instruction. For an OPERATION instruction within
+ *              the scope of a protocol descriptor, this is normally
  *              the final word of a single descriptor.
  *
  * @dir       = Select DIR_ENCAP for encapsulation, or DIR_DECAP for
@@ -561,7 +567,8 @@ u_int32_t *cmd_insert_proto_op_wifi(u_int32_t *descwd, enum protdir dir)
  **/
 u_int32_t *cmd_insert_proto_op_macsec(u_int32_t *descwd, enum protdir dir)
 {
-	*descwd = CMD_OPERATION | OP_PCLID_MACSEC | OP_PCL_MACSEC;
+	*descwd = CMD_OPERATION | OP_PCLID_MACSEC | OP_PCL_MACSEC |
+		  (dir ? OP_TYPE_DECAP_PROTOCOL : OP_TYPE_ENCAP_PROTOCOL);
 
 	return descwd++;
 }
@@ -572,7 +579,8 @@ u_int32_t *cmd_insert_proto_op_macsec(u_int32_t *descwd, enum protdir dir)
  * cmd_insert_proto_op_unidir()
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
+ *              this instruction. For an OPERATION instruction within
+ *              the scope of a protocol descriptor, this is normally
  *              the final word of a single descriptor.
  *
  * @protid    = Select any PROTID field for a unidirectional protocol
@@ -590,13 +598,13 @@ u_int32_t *cmd_insert_proto_op_unidir(u_int32_t *descwd, u_int32_t protid,
 
 /**
  * cmd_insert_alg_op()
- * Insert a simple algorithm operation command into a descriptor
+ * Insert a simple algorithm operation instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command.
+ *              this instruction.
  *
  * @optype = use as class 1 or 2 with OP_TYPE_CLASSx_ALG
  *
@@ -643,7 +651,7 @@ u_int32_t *cmd_insert_alg_op(u_int32_t *descwd, u_int32_t optype,
  **/
 u_int32_t *cmd_insert_pkha_op(u_int32_t *descwd, u_int32_t pkmode)
 {
-	*descwd = CMD_OPERATION | OP_TYPE_CLASS1_ALG | OP_ALG_PK | pkmode;
+	*descwd = CMD_OPERATION | OP_TYPE_PK | OP_ALG_PK | pkmode;
 
 	return ++descwd;
 }
@@ -655,14 +663,13 @@ u_int32_t *cmd_insert_pkha_op(u_int32_t *descwd, u_int32_t pkmode)
  */
 /**
  * cmd_insert_seq_in_ptr()
- * Insert an SEQ IN PTR command into a descriptor
+ * Insert an SEQ IN PTR instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
- *              the final word of a single descriptor.
+ *              this instruction.
  * @ptr       = bus address pointing to the input data buffer
  * @len       = input length
  * @sgref     = pointer is actual data, or a scatter-gather list
@@ -689,14 +696,13 @@ u_int32_t *cmd_insert_seq_in_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
 
 /**
  * cmd_insert_seq_out_ptr()
- * Insert an SEQ OUT PTR command into a descriptor
+ * Insert an SEQ OUT PTR instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just insertted. If an error occurred, returns 0;
  *
  * @descwd    = pointer to target descriptor word intended to hold
- *              this command. For an OPERATION command, this is normally
- *              the final word of a single descriptor.
+ *              this instruction.
  * @ptr       = bus address pointing to the output data buffer
  * @len       = output length
  * @sgref     = pointer is actual data, or a scatter-gather list
@@ -724,14 +730,13 @@ u_int32_t *cmd_insert_seq_out_ptr(u_int32_t *descwd, void *ptr, u_int32_t len,
 
 /**
  * cmd_insert_load()
- * Insert an LOAD command into a descriptor
+ * Insert an LOAD instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
+ *                 this instruction.
  *
  * @data         = pointer to data to be loaded
  *
@@ -762,6 +767,19 @@ u_int32_t *cmd_insert_load(u_int32_t *descwd, void *data,
 		  (offset << LDST_OFFSET_SHIFT) | len |
 		  ((imm & LDST_IMM_MASK) << LDST_IMM_SHIFT);
 
+	/*
+	 * Special case for DECO control uses bits in
+	 * offset and length to control a DECO. If it's selected,
+	 * we'll also force an IMM, but no immediate data is
+	 * actually used
+	 */
+	if ((class_access == LDST_CLASS_DECO) &&
+	    (dest == LDST_SRCDST_WORD_DECOCTRL)) {
+		*descwd |= LDST_IMM;
+		descwd++;
+		return descwd;
+	}
+
 	descwd++;
 
 	if (imm == ITEM_INLINE) {
@@ -778,12 +796,45 @@ u_int32_t *cmd_insert_load(u_int32_t *descwd, void *data,
 }
 
 /**
- * cmd_insert_fifo_load()
- * Insert a FIFO_LOAD command into a descriptor
+ * cmd_insert_seq_load()
+ * Insert an SEQ LOAD instruction into a descriptor
  *
  * Returns: Pointer to next incremental descriptor word past the command
  * just constructed. If an error occurred, returns 0;
  *
+ * @descwd       = pointer to target descriptor word intended to hold
+ *                 this command. For an OPERATION command, this is normally
+ *                 the final word of a single descriptor.
+ * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
+ *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
+ *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
+ *               = LDST_CLASS_DECO    = access DECO objects
+ * @variable_len_flag = use the variable input sequence length
+ * @dest         = destination
+ * @offset       = the start point for writing in the destination
+ * @len          = length of data in bytes
+ *
+ **/
+u_int32_t *cmd_insert_seq_load(u_int32_t *descwd, u_int32_t class_access,
+			       u_int32_t variable_len_flag, u_int32_t dest,
+			       u_int8_t offset, u_int8_t len)
+{
+	*descwd = CMD_SEQ_LOAD | (class_access & CLASS_MASK) |
+		  (variable_len_flag ? LDST_SGF : 0) |
+		  ((dest & LDST_SRCDST_MASK) << LDST_SRCDST_SHIFT) |
+		  ((offset & LDST_OFFSET_MASK) << LDST_OFFSET_SHIFT) |
+		  ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
+
+	return descwd + 1;
+}
+
+/**
+ * cmd_insert_fifo_load()
+ * Insert a FIFO_LOAD instruction into a descriptor
+ *
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
+ *
  * @descwd = pointer to target descriptor word intended to hold
  *           this command.
  *
@@ -839,48 +890,14 @@ u_int32_t *cmd_insert_fifo_load(u_int32_t *descwd, void *data, u_int32_t len,
 }
 
 /**
- * cmd_insert_seq_load()
- * Insert an SEQ LOAD command into a descriptor
- *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
- *
- * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
- * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
- *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
- *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
- *               = LDST_CLASS_DECO    = access DECO objects
- * @variable_len_flag = use the variable input sequence length
- * @dest         = destination
- * @offset       = the start point for writing in the destination
- * @len          = length of data in bytes
- *
- **/
-u_int32_t *cmd_insert_seq_load(u_int32_t *descwd, u_int32_t class_access,
-			       u_int32_t variable_len_flag, u_int32_t dest,
-			       u_int8_t offset, u_int8_t len)
-{
-	*descwd = CMD_SEQ_LOAD | (class_access & CLASS_MASK) |
-		  (variable_len_flag ? LDST_SGF : 0) |
-		  ((dest & LDST_SRCDST_MASK) << LDST_SRCDST_SHIFT) |
-		  ((offset & LDST_OFFSET_MASK) << LDST_OFFSET_SHIFT) |
-		  ((len & LDST_LEN_MASK) << LDST_LEN_SHIFT);
-
-	return descwd + 1;
-}
-
-/**
  * cmd_insert_seq_fifo_load()
  * Insert an SEQ FIFO LOAD command into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
+ *                 this instruction.
  * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
  *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
  *               = LDST_CLASS_2_CCB   = access class 2 objects in CCB
@@ -910,12 +927,11 @@ u_int32_t *cmd_insert_seq_fifo_load(u_int32_t *descwd, u_int32_t class_access,
  * cmd_insert_store()
  * Insert a STORE command into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just insertted. If an error occurred, returns 0;
  *
  * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
+ *                 this instruction.
  *
  * @data         = pointer to data to be stored
  *
@@ -964,14 +980,13 @@ u_int32_t *cmd_insert_store(u_int32_t *descwd, void *data,
 
 /**
  * cmd_insert_seq_store()
- * Insert a SEQ STORE command into a descriptor
+ * Insert a SEQ STORE instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
+ *                 this instruction.
  *
  * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
  *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
@@ -1000,17 +1015,17 @@ u_int32_t *cmd_insert_seq_store(u_int32_t *descwd, u_int32_t class_access,
 
 /**
  * cmd_insert_fifo_store()
- * Insert a FIFO_STORE command into a descriptor
+ * Insert a FIFO_STORE instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental descriptor word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd = pointer to target descriptor word intended to hold
- *           this command.
+ *           this instruction.
  *
  * @data   = pointer to data to be loaded
  *
- * @len    = length of data in bits (NOT bytes)
+ * @len    = length of data in bytes
  *
  * @class  = LDST_CLASS_IND_CCB = access class-independent objects in CCB
  *         = LDST_CLASS_1_CCB   = access class 1 objects in CCB
@@ -1019,14 +1034,14 @@ u_int32_t *cmd_insert_seq_store(u_int32_t *descwd, u_int32_t class_access,
  *
  * @sgflag = reference is a scatter/gather list if FIFOLDST_SGF
  *
- * @imm    = destination data is to be inlined into descriptor itself
+ * @imm    = store data is to be inlined into descriptor itself
  *           if FIFOLDST_IMM
  *
  * @ext    = use extended length field following the pointer if
  *           FIFOLDST_EXT
  *
- * @type   = FIFO input type, an OR combination of FIFOLD_TYPE_
- *           type and last/flush bits
+ * @type   = FIFO input type, an OR combination of FIFOST_TYPE_
+ *           type and last/flush bits for class1 and 2.
  **/
 u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
 				 u_int32_t class_access, u_int32_t sgflag,
@@ -1035,7 +1050,7 @@ u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
 	int words;
 	u_int32_t *nextin;
 
-	*descwd = CMD_FIFO_LOAD | (class_access & CLASS_MASK) | sgflag |
+	*descwd = CMD_FIFO_STORE | (class_access & CLASS_MASK) | sgflag |
 		  imm | ext | type;
 
 	if (!ext)
@@ -1061,14 +1076,13 @@ u_int32_t *cmd_insert_fifo_store(u_int32_t *descwd, void *data, u_int32_t len,
 
 /**
  * cmd_insert_seq_fifo_store()
- * Insert a SEQ FIFO STORE command into a descriptor
+ * Insert a SEQ FIFO STORE instruction into a descriptor
  *
- * Returns: Pointer to next incremental descriptor word past the command
- * just constructed. If an error occurred, returns 0;
+ * Returns: Pointer to next incremental instruction word past the instruction
+ * just inserted. If an error occurred, returns 0;
  *
  * @descwd       = pointer to target descriptor word intended to hold
- *                 this command. For an OPERATION command, this is normally
- *                 the final word of a single descriptor.
+ *                 this instruction.
  *
  * @class_access = LDST_CLASS_IND_CCB = access class-independent objects in CCB
  *               = LDST_CLASS_1_CCB   = access class 1 objects in CCB
@@ -1100,13 +1114,18 @@ u_int32_t *cmd_insert_seq_fifo_store(u_int32_t *descwd, u_int32_t class_access,
 
 /**
  * cmd_insert_jump()
- * Insert a JUMP command into a descriptor
+ * Insert a JUMP instruction into a descriptor
  *
- * Returns: pointer to next incremental descriptor word past the command
- * just constructed. No error is returned.
+ * Returns: pointer to next incremental descriptor word past the instruction
+ * just inserted. No error is returned.
  *
  * @descwd = pointer to target descriptor word intended to hold this
- *           command.
+ *           instruction.
+ *
+ * @class = CLASS_NONE - not a checkpoint
+ *        = CLASS_1 - done checkpoint on class 1
+ *        = CLASS_2 - done checkpoint on class 2
+ *        = CLASS_BOTH - done checkpoint on both
  *
  * @jtype = type of jump operation to perform, of JUMP_TYPE_
  *
@@ -1121,10 +1140,11 @@ u_int32_t *cmd_insert_seq_fifo_store(u_int32_t *descwd, u_int32_t class_access,
  *            if jtype = JUMP_NONLOCAL
  **/
 u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
-			   u_int32_t test, u_int32_t cond,
-			   u_int8_t offset, u_int32_t *jmpdesc)
+			   u_int32_t class, u_int32_t test, u_int32_t cond,
+			   int8_t offset, u_int32_t *jmpdesc)
 {
-	*descwd++ = CMD_JUMP | jtype | test | cond | offset;
+	*descwd++ = CMD_JUMP | class | jtype | test | cond |
+		    (offset & 0x000000ff);
 
 	if (jtype == JUMP_TYPE_NONLOCAL)
 		*descwd++ = (u_int32_t)jmpdesc;
@@ -1134,13 +1154,13 @@ u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
 
 /**
  * cmd_insert_math()
- * Insert a MATH command into a descriptor
+ * Insert a MATH instruction into a descriptor
  *
- * Returns: pointer to next incremental descriptor word past the command
- * just constructed. No error is returned.
+ * Returns: pointer to next incremental descriptor word past the instruction
+ * just inserted. No error is returned.
  *
  * @descwd = pointer to target descriptor word intended to hold this
- *           command.
+ *           instruction.
  *
  * @func = Function to perform. One of MATH_FUN_
  *
@@ -1158,41 +1178,49 @@ u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
  * @stall = if MATH_STALL, cause the instruction to require one extra
  *          clock cycle, else use MATH_NO_STALL.
  *
- * @immediate = if MATH_IMMEDIATE, will insert a 4 byte immediate
+ * @immediate = if MATH_IFB, will insert an immediate four byte
  *              value into the descriptor to use as 1 of the two
- *              sources, else if not needed, use MATH_NO_IMMEDIATE
+ *              sources.
+ *
+ * @data = inline data sized per len or MATH_IFB
  *
- * @data = inline data sized per len. If MATH_IMMEDIATE is used,
- *           must only be a 4-byte value to inline into the descriptor
  **/
 u_int32_t *cmd_insert_math(u_int32_t *descwd, u_int32_t func,
 			    u_int32_t src0, u_int32_t src1,
 			    u_int32_t dest, u_int32_t len,
 			    u_int32_t flagupd, u_int32_t stall,
 			    u_int32_t immediate, u_int32_t *data)
- {
+{
 
 	*descwd++ = CMD_MATH | func | src0 | src1 | dest |
 		    (len & MATH_LEN_MASK) | flagupd | stall | immediate;
 
-	if ((immediate) ||
-	   ((src0 & MATH_SRC0_MASK) == MATH_SRC0_IMM) ||
-	   ((src1 & MATH_SRC1_MASK) == MATH_SRC1_IMM))
-		*descwd++ = *data;
-
+	/*
+	 * If IFB, add 4 byte immediate, else if one of two sources
+	 * are immediate, add data by length
+	 */
+	if (immediate == MATH_IFB) {
+		memcpy(descwd, data, 4);
+		descwd++;
+	} else
+		if (((src0 & MATH_SRC0_MASK) == MATH_SRC0_IMM) ||
+		((src1 & MATH_SRC1_MASK) == MATH_SRC1_IMM)) {
+			memcpy(descwd, data, len);
+			descwd += len >> 2;
+		}
 
 	return descwd;
- }
+}
 
 /**
  * cmd_insert_move()
- * Insert a MOVE command into a descriptor
+ * Insert a MOVE instruction into a descriptor
  *
  * Returns: pointer to next incremental descriptor word past the
- * command just constructed. No error is returned.
+ * instruction just inserted. No error is returned.
  *
  * @descwd = pointer to target descriptor word intended to hold this
- *           command.
+ *           instruction.
  *
  * @waitcomp = if MOVE_WAITCOMPLETE specified, stall execution until
  *             the MOVE completes. This is only valid if it is using
diff --git a/drivers/crypto/caam/dcl/dcl.h b/drivers/crypto/caam/dcl/dcl.h
index 7dbdbdc..ae22128 100644
--- a/drivers/crypto/caam/dcl/dcl.h
+++ b/drivers/crypto/caam/dcl/dcl.h
@@ -37,6 +37,8 @@
 #define DCL_H
 
 #include "../desc.h"
+#include "../pdb.h"
+
 
 /*
  * Section 1 - Descriptor command construction definitions
@@ -121,86 +123,6 @@ enum mktrust {
 	DESC_STD
 };
 
-#define MOVE_NOWAIT       0
-#define MOVE_WAITCOMPLETE MOVE_WAITCOMP
-
-/*
- * LOAD/STORE constants
- */
-
-
-
-
-/*
- * JUMP condition codes
- * First set is standard condition codes, second is for sharing control
- * Any combination within a set is legal, cross-set combinations are not
- */
-
-/* Standard conditions */
-#define JUMP_CC_MATH_NV		(JUMP_COND_MATH_NV)
-#define JUMP_CC_MATH_C		(JUMP_COND_MATH_C)
-#define JUMP_CC_MATH_Z		(JUMP_COND_MATH_Z)
-#define JUMP_CC_MATH_N		(JUMP_COND_MATH_N)
-#define JUMP_CC_PKHA_PRIME	(JUMP_COND_PK_PRIME)
-#define JUMP_CC_PKHA_GCD_1	(JUMP_COND_PK_GCD_1)
-#define JUMP_CC_PKHA_ZERO	(JUMP_COND_PK_0)
-
-/* Sharing conditions */
-#define JUMP_CC_SHARE_NCP	(JUMP_COND_NCP | JUMP_JSL)
-#define JUMP_CC_SHARE_NOP	(JUMP_COND_NOP | JUMP_JSL)
-#define JUMP_CC_SHARE_NIFP	(JUMP_COND_NIFP | JUMP_JSL)
-#define JUMP_CC_SHARE_NIP	(JUMP_COND_NIP | JUMP_JSL)
-#define JUMP_CC_SHARE_CALM	(JUMP_COND_CALM | JUMP_JSL)
-#define JUMP_CC_SHARE_SELF	(JUMP_COND_SELF | JUMP_JSL)
-#define JUMP_CC_SHARE_SHRD	(JUMP_COND_SHRD | JUMP_JSL)
-#define JUMP_CC_SHARE_JQP	(JUMP_COND_JQP | JUMP_JSL)
-
-/*
- * cmd_insert_move() destination combinations
- */
-#define MOVE_INTSRC_DEST_CLASS1_CTX	(MOVE_DEST_CLASS1CTX)
-#define MOVE_INTSRC_DEST_CLASS2_CTX	(MOVE_DEST_CLASS2CTX)
-#define MOVE_INTSRC_DEST_OUT_FIFO	(MOVE_DEST_OUTFIFO)
-#define MOVE_INTSRC_DEST_DESCBUF	(MOVE_DEST_DESCBUF)
-#define MOVE_INTSRC_DEST_DESCBUF_OFFSET16 \
-	(MOVE_DEST_DESCBUF | (1 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_DESCBUF_OFFSET32 \
-	(MOVE_DEST_DESCBUF | (2 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_DESCBUF_OFFSET48 \
-	(MOVE_DEST_DESCBUF | (3 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_MATH0		(MOVE_DEST_MATH0)
-#define MOVE_INTSRC_DEST_MATH1		(MOVE_DEST_MATH1)
-#define MOVE_INTSRC_DEST_MATH2		(MOVE_DEST_MATH2)
-#define MOVE_INTSRC_DEST_MATH3		(MOVE_DEST_MATH3)
-#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO	(MOVE_DEST_CLASS1INFIFO)
-#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_FLUSH \
-	(MOVE_DEST_CLASS1INFIFO | (2 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_LAST \
-	(MOVE_DEST_CLASS1INFIFO | (1 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_CLASS1_IN_FIFO_FLUSHLAST \
-	(MOVE_DEST_CLASS1INFIFO | (3 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_CLASS2_IN_FIFO	(MOVE_DEST_CLASS2INFIFO)
-#define MOVE_INTSRC_DEST_CLASS2_IN_FIFO_LAST \
-	(MOVE_DEST_CLASS2INFIFO | (1 << MOVE_AUX_SHIFT))
-#define MOVE_INTSRC_DEST_PKHA_A		(MOVE_DEST_PK_A)
-#define MOVE_INTSRC_DEST_CLASS1_KEY	(MOVE_DEST_CLASS1KEY)
-#define MOVE_INTSRC_DEST_CLASS2_KEY	(MOVE_DEST_CLASS2KEY)
-
-
-/*
- * Extra option bits for MATH instructions
- */
-
-#define MATH_FLAG_UPDATE      0
-#define MATH_FLAG_NO_UPDATE   MATH_NFU
-
-#define MATH_STALL            MATH_STL
-#define MATH_NO_STALL         0
-
-#define MATH_IMMEDIATE        MATH_IFB
-#define MATH_NO_IMMEDIATE     0
-
 /*
  * Type selectors for cipher types in IPSec protocol OP instructions
  */
@@ -218,7 +140,6 @@ enum mktrust {
 /*
  * Type selectors for authentication in IPSec protocol OP instructions
  */
-
 #define AUTH_TYPE_IPSEC_MD5HMAC_96            1
 #define AUTH_TYPE_IPSEC_SHA1HMAC_96           2
 #define AUTH_TYPE_IPSEC_AESXCBCMAC_96         6
@@ -228,13 +149,6 @@ enum mktrust {
 #define AUTH_TYPE_IPSEC_SHA2HMAC_512          14
 
 /*
- * Type selectors for bulk algorithm OP instructions
- */
-#define ALG_OP_CLASS1		1
-#define ALG_OP_CLASS2		2
-
-
-/*
  * Command Generator Prototypes
  */
 u_int32_t *cmd_insert_shared_hdr(u_int32_t *descwd, u_int8_t startidx,
@@ -316,8 +230,8 @@ u_int32_t *cmd_insert_seq_fifo_store(u_int32_t *descwd, u_int32_t class_access,
 				     u_int32_t out_type, u_int32_t len);
 
 u_int32_t *cmd_insert_jump(u_int32_t *descwd, u_int32_t jtype,
-			   u_int32_t test, u_int32_t cond,
-			   u_int8_t offset, u_int32_t *jmpdesc);
+			   u_int32_t class, u_int32_t test, u_int32_t cond,
+			   int8_t offset, u_int32_t *jmpdesc);
 
 u_int32_t *cmd_insert_move(u_int32_t *descwd, u_int32_t waitcomp,
 			   u_int32_t src, u_int32_t dst, u_int8_t offset,
@@ -366,6 +280,26 @@ int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
 			      struct pk_in_params *pkin, u_int8_t *out,
 			      u_int32_t out_siz, u_int8_t clear);
 
+int cnstr_jobdesc_mdsplitkey(u_int32_t *descbuf, u_int16_t *bufsize,
+			     u_int8_t *key, u_int32_t cipher,
+			     u_int8_t *padbuf);
+
+int cnstr_jobdesc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
+			  u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
+			  enum mdstatesel mdstate, enum icvsel icv,
+			  enum algdir dir, u_int8_t *in, u_int8_t *out,
+			  u_int16_t size, u_int8_t *mac);
+
+int cnstr_jobdesc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t *ctx,
+			    u_int8_t *in, u_int8_t *out, u_int16_t size);
+
+int cnstr_jobdesc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t *ctx,
+			    u_int8_t *in, u_int16_t size, u_int8_t *mac);
+
 /*
  * Section 3 - Single-pass descriptor construction definitions
  */
@@ -374,22 +308,8 @@ int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
  * Section 4 - Protocol descriptor construction definitions
  */
 
-struct dsa_pdb {
-	u_int8_t  sgf_ln; /* s/g bitmask for q r g w f c d ab in 31:24 */
-			  /* L in 17:7, n in 6:0 */
-	u_int8_t *q;
-	u_int8_t *r;
-	u_int8_t *g;
-	u_int8_t *w;
-	u_int8_t *f;
-	u_int8_t *c;
-	u_int8_t *d;
-	u_int8_t *tmp; /* temporary data */
-	u_int8_t *ab;  /* only used if ECC processing */
-};
-
 int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
-			    struct dsa_pdb *dsadata, u_int8_t *msg,
+			    struct dsa_verify_pdb *dsadata, u_int8_t *msg,
 			    u_int32_t msg_sz, u_int8_t clear);
 
 /* If protocol descriptor, IPV4 or 6? */
@@ -449,8 +369,8 @@ struct cipherparams {
 	u_int32_t  keylen;
 };
 
-/* Common definitions for specifying Protocol Data Blocks */
 
+/* Generic IPSec - to be deprecated */
 struct seqnum {
 	enum esn              esn;
 	enum antirply_winsiz  antirplysz;
@@ -466,27 +386,6 @@ struct pdbcont {
 	struct seqnum         seq;
 };
 
-struct wimax_pdb {
-	u_int8_t  framecheck;  /* nonzero if FCS to be included */
-	u_int32_t nonce;
-	u_int8_t  b0_flags;
-	u_int8_t  iv_flags;    /* decap only */
-	u_int8_t  ctr_flags;
-	u_int16_t ctr_initial_count;
-	u_int32_t PN;
-	u_int16_t antireplay_len;
-};
-
-struct macsec_pdb {
-	u_int8_t  framecheck;  /* nonzero if FCS to be included */
-	u_int16_t aad_len;
-	u_int64_t sci;
-	u_int32_t PN;
-	u_int16_t ethertype;
-	u_int8_t  tci_an;
-	u_int8_t  antireplay_len;
-};
-
 int32_t cnstr_pcl_shdsc_ipsec_cbc_decap(u_int32_t *descbuf,
 					u_int16_t *bufsize,
 					struct pdbcont *pdb,
@@ -501,26 +400,39 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t *descbuf,
 					struct authparams *authdata,
 					u_int8_t clear);
 
+int32_t cnstr_shdsc_ipsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				    struct ipsec_encap_pdb *pdb,
+				    u_int8_t *opthdr,
+				    struct cipherparams *cipherdata,
+				    struct authparams *authdata);
+
+int32_t cnstr_shdsc_ipsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct ipsec_decap_pdb *pdb,
+				struct cipherparams *cipherdata,
+				struct authparams *authdata);
+
+
 int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_pdb *pdb,
+				struct wimax_encap_pdb *pdb,
 				struct cipherparams *cipherdata,
-				u_int8_t mode, u_int8_t clear);
+				u_int8_t mode);
 
 int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_pdb *pdb,
+				struct wimax_decap_pdb *pdb,
 				struct cipherparams *cipherdata,
-				u_int8_t mode, u_int8_t clear);
+				u_int8_t mode);
 
 int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_pdb *pdb,
-				 struct cipherparams *cipherdata,
-				 u_int8_t clear);
+				 struct macsec_encap_pdb *pdb,
+				 struct cipherparams *cipherdata);
 
 int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_pdb *pdb,
-				 struct cipherparams *cipherdata,
-				 u_int8_t clear);
+				 struct macsec_decap_pdb *pdb,
+				 struct cipherparams *cipherdata);
 
+/*
+ * Non protocol sharedesc constructors
+ */
 int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
@@ -547,14 +459,25 @@ int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 				       u_int8_t *key, u_int32_t keysz,
 				       u_int32_t count, u_int32_t bearer,
 				       u_int32_t direction,
-				       u_int32_t payload_sz, u_int8_t clear);
+				       u_int16_t payload_sz, u_int8_t clear);
+
+int32_t cnstr_pcl_shdsc_3gpp_rlc_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				       u_int8_t *key, u_int32_t keysz,
+				       u_int32_t count, u_int32_t bearer,
+				       u_int32_t direction,
+				       u_int16_t payload_sz);
 
 /*
  * Section 5 - disassembler definitions
  */
+
+/* Disassembler options */
+#define DISASM_SHOW_OFFSETS	0x01 /* display instruction indices */
+#define DISASM_SHOW_RAW		0x02 /* display each raw instruction */
+
 void desc_hexdump(u_int32_t *descdata, u_int32_t  size, u_int32_t wordsperline,
 		  int8_t *indentstr);
 
-void caam_desc_disasm(u_int32_t *desc);
+void caam_desc_disasm(u_int32_t *desc, u_int32_t opts);
 
 #endif /* DCL_H */
diff --git a/drivers/crypto/caam/dcl/disasm.c b/drivers/crypto/caam/dcl/disasm.c
index 4b60768..8f811b6 100644
--- a/drivers/crypto/caam/dcl/disasm.c
+++ b/drivers/crypto/caam/dcl/disasm.c
@@ -39,7 +39,330 @@
 #include "../compat.h"
 #include "dcl.h"
 
-#define NULL_LEADER (int8_t *)"            "
+#define MAX_LEADER_LEN 31 /* offset + raw + instruction-name-length */
+
+/* Descriptor header/shrheader share enums */
+static const char *deschdr_share[] = {
+	"never", "wait", "serial", "always", "defer",
+};
+
+/* KEY/SEQ_KEY instruction-specific class enums */
+static const char *key_class[] = {
+	"<rsvd>", "class1", "class2", "<rsvd>",
+};
+
+/* LOAD/STORE instruction-specific class enums */
+static const char *ldst_class[] = {
+	"class-ind-ccb", "class-1-ccb", "class-2-ccb", "deco",
+};
+
+/* FIFO_LOAD/FIFO_STORE instruction-specific class enums */
+static const char *fifoldst_class[] = {
+	"skip", "class1", "class2", "both",
+};
+
+/* KEY/SEQ_KEY instruction destination enums */
+static const char *key_dest[] = {
+	"keyreg", "pk-e", "af-sbox", "md-split",
+};
+
+/* FIFO_STORE/SEQ_FIFO_STORE output data type enums */
+static const char *fifo_output_data_type[] = {
+	"pk-a0", "pk-a1", "pk-a2", "pk-a3",
+	"pk-b0", "pk-b1", "pk-b2", "pk-b3",
+	"pk-n", "<rsvd>", "<rsvd>", "<rsvd>",
+	"pk-a", "pk-b", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"afha-s-jdk", "afha-s-tdk", "pkha-e-jdk", "pkha-e-tdk",
+	"keyreg-jdk", "keyreg-tdk", "mdsplit-jdk", "mdsplit-tdk",
+	"outfifo-jdk", "outfifo-tdk", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"msgdata", "<rsvd>", "<rsvd>", "<rsvd>",
+	"rng-ref", "rng-outfifo", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "seqfifo-skip",
+};
+
+/* LOAD/STORE instruction source/destination by class */
+static const char *ldstr_srcdst[4][0x80] = {
+{
+	/* Class-independent CCB destination set */
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "cha-ctrl", "irq-ctrl",
+	"clrw", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "info-fifo", "<rsvd>",
+	"indata-fifo", "<rsvd>", "output-fifo", "<rsvd>",
+},
+{
+	/* Class1 CCB destination set */
+	"class1-mode", "class1-keysz", "class1-datasz", "class1-icvsz",
+	"<rsvd>", "<rsvd>", "<rsvd>",  "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "aadsz",
+	"class1-ivsz", "<rsvd>", "<rsvd>", "class1-altdsz",
+	"pk-a-sz", "pk-b-sz", "pk-n-sz", "pk-e-sz",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"class1-ctx", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"class1-key", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+},
+{
+	/* Class2 CCB destination set */
+	"class2-mode", "class2-keysz", "class2-datasz", "class2-ivsz",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"class2-ctx", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"class2-key", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>",  "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+},
+{
+	/* DECO destination set */
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "deco-ctrl", "deco-povrd",
+	"deco-math0", "deco-math1", "deco-math2", "deco-math3",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"descbuf", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+} };
+
+/* JUMP instruction destination type enums */
+static const char *jump_types[] = {
+	"local", "nonlocal", "halt", "halt-user",
+};
+
+/* JUMP instruction test enums */
+static const char *jump_tests[] = {
+	"all", "!all", "any", "!any",
+};
+
+/* LOAD_FIFO/SEQ_LOAD_FIFO instruction PK input type enums */
+static const char *load_pkha_inp_types[] = {
+	"a0", "a1", "a2", "a3",
+	"b0", "b1", "b2", "b3",
+	"n", "<rsvd>", "<rsvd>", "<rsvd>",
+	"a", "b", "<rsvd>", "<rsvd>",
+};
+
+/* LOAD_FIFO/SEQ_LOAD_FIFO instruction non-PK input type enums */
+static const char *load_inp_types[] = {
+	"<rsvd>", "<rsvd>", "msgdata", "msgdata1->2",
+	"iv", "bitlendata",
+};
+
+/* MOVE instruction source enums */
+static const char *move_src[] = {
+	"class1-ctx", "class2-ctx", "out-fifo", "descbuf",
+	"math0", "math1", "math2", "math3",
+	"inp-fifo",
+};
+
+/* MOVE instruction destination enums */
+static const char *move_dst[] = {
+	"class1-ctx", "class2-ctx", "output-fifo", "descbuf",
+	"math0", "math1", "math2", "math3",
+	"class1-inp-fifo", "class2-inp-fifo", "<rsvd>", "<rsvd>",
+	"pk-a", "class1-key", "class2-key", "<rsvd>",
+};
+
+/* MATH instruction source 0 enumerations */
+static const char *math_src0[] = {
+	"math0", "math1", "math2", "math3",
+	"imm", "<rsvd>", "<rsvd>", "<rsvd>",
+	"seqin", "seqout", "vseqin", "vseqout",
+	"0" "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* MATH instruction source1 enumerations (not same as src0) */
+static const char *math_src1[] = {
+	"math0", "math1", "math2", "math3",
+	"imm", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "inp-fifo", "out-fifo",
+	"1" "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* MATH instruction destination enumerations */
+static const char *math_dest[] = {
+	"math0", "math1", "math2", "math3",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"seqin", "seqout", "vseqin", "vseqout",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<none>",
+};
+
+/* MATH instruction function enumerations */
+static const char *math_fun[] = {
+	"add", "addc", "sub", "subb",
+	"or", "and", "xor", "lsh",
+	"rsh", "lshd", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* SIGNATURE instruction type enumerations */
+static const char *sig_type[] = {
+	"final", "final-restore", "final-nonzero", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "imm-2", "imm-3",
+	"imm-4", "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* OPERATION instruction unidirectional protocol enums */
+static const char *unidir_pcl[] = {
+	"<rsvd> ", "ikev1-prf ", "ikev2-prf ", "<rsvd> ",
+	"<rsvd> ", "<rsvd> ", "<rsvd> ", "<rsvd> ",
+	"ssl3.0-prf ", "tls1.0-prf ", "tls1.1-prf ", "<rsvd> ",
+	"dtls1.0-prf ", "blob ", "<rsvd> ", "<rsvd> ",
+	"<rsvd> ", "<rsvd> ", "<rsvd> ", "<rsvd> ",
+	"pk-pargen ", "dsa-sign ", "dsa-verify ", "<rsvd> ",
+	"<rsvd> ", "<rsvd> ", "<rsvd> ", "<rsvd> ",
+	"<rsvd> ", "<rsvd> ", "<rsvd> ", "<rsvd> ",
+};
+
+/* OPERATION instruction protocol info cipher types - IPSec/SRTP */
+static const char *ipsec_pclinfo_cipher[] = {
+	"<rsvd>", "des", "des", "3des",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"aes-cbc", "aes-ctr", "aes-ccm8", "aes-ccm12",
+	"aes-ccm16", "<rsvd>", "aes-gcm8", "aes-gcm12",
+	"aes-gcm16", "<rsvd>", "aes-xts", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* OPERATION instruction protocol info authentication types - IPSec/SRTP */
+static const char *ipsec_pclinfo_auth[] = {
+	"<none>", "hmac-md5-96", "hmac-sha1-96", "<rsvd>",
+	"<rsvd>", "aes-xcbcmac-96", "hmac-md5-128", "hmac-sha1-160",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"hmac-sha2-256-128", "hmac-sha2-384-192",
+	"hmac-sha2-512-256", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+/* OPERATION instruction PKHA algorithmic functions (PKHA_MODE_LS) */
+static const char *pk_function[] = {
+	"<rsvd>", "clrmem", "a+b%n", "a-b%n",
+	"b-a%n", "a*b%n", "a^e%n", "a%n",
+	"a^-1%n", "ecc-p1+p2", "ecc-p1+p1", "ecc-e*p1",
+	"monty-const", "crt-const", "gcd(a,n)", "miller-rabin",
+	"cpymem-n-sz", "cpymem-src-sz", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+	"<rsvd>", "<rsvd>", "<rsvd>", "<rsvd>",
+};
+
+static const char *pk_srcdst[] = {
+	"a",
+	"b",
+	"e", /* technically not legal for a source, legal as dest */
+	"n",
+};
 
 /*
  * Simple hexdumper for use by the disassembler. Displays 32-bit
@@ -55,7 +378,7 @@
 void desc_hexdump(u_int32_t *descdata,
 		  u_int32_t  size,
 		  u_int32_t  wordsperline,
-		  int8_t    *indentstr)
+		  int8_t    *leader)
 {
 	int i, idx, rem, line;
 
@@ -63,7 +386,7 @@ void desc_hexdump(u_int32_t *descdata,
 	rem = size;
 
 	while (rem) {
-		PRINT("%s[%02d] ", indentstr, idx);
+		PRINT("%s[%02d] ", leader, idx);
 		if (rem <= wordsperline)
 			line = rem;
 		else
@@ -75,34 +398,14 @@ void desc_hexdump(u_int32_t *descdata,
 		}
 		PRINT("\n");
 	};
-
 }
 EXPORT_SYMBOL(desc_hexdump);
 
-
 static void show_shrhdr(u_int32_t *hdr)
 {
-	PRINT("   shrdesc: stidx=%d len=%d ",
-	       (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
-	       *hdr & HDR_DESCLEN_SHR_MASK);
-
-	switch (*hdr & (HDR_SD_SHARE_MASK << HDR_SD_SHARE_SHIFT)) {
-	case HDR_SHARE_NEVER:
-		PRINT("share-never ");
-		break;
-
-	case HDR_SHARE_WAIT:
-		PRINT("share-wait ");
-		break;
-
-	case HDR_SHARE_SERIAL:
-		PRINT("share-serial ");
-		break;
-
-	case HDR_SHARE_ALWAYS:
-		PRINT("share-always ");
-		break;
-	}
+	PRINT("   shrdesc: stidx=%d share=%s ",
+	      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
+	      deschdr_share[(*hdr >> HDR_SD_SHARE_SHIFT) & HDR_SD_SHARE_MASK]);
 
 	if (*hdr & HDR_DNR)
 		PRINT("noreplay ");
@@ -113,41 +416,20 @@ static void show_shrhdr(u_int32_t *hdr)
 	if (*hdr & HDR_PROP_DNR)
 		PRINT("propdnr ");
 
-	PRINT("\n");
+	PRINT("len=%d\n", *hdr & HDR_DESCLEN_SHR_MASK);
 }
 
 static void show_hdr(u_int32_t *hdr)
 {
 	if (*hdr & HDR_SHARED) {
-		PRINT("   jobdesc: shrsz=%d len=%d ",
-		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
-		      *hdr & HDR_DESCLEN_MASK);
+		PRINT("   jobdesc: shrsz=%d ",
+		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK);
 	} else {
-		PRINT("   jobdesc: stidx=%d len=%d ",
-		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK,
-		      *hdr & HDR_DESCLEN_MASK);
-	}
-	switch (*hdr & (HDR_JD_SHARE_MASK << HDR_JD_SHARE_SHIFT)) {
-	case HDR_SHARE_NEVER:
-		PRINT("share-never ");
-		break;
-
-	case HDR_SHARE_WAIT:
-		PRINT("share-wait ");
-		break;
-
-	case HDR_SHARE_SERIAL:
-		PRINT("share-serial ");
-		break;
-
-	case HDR_SHARE_ALWAYS:
-		PRINT("share-always ");
-		break;
-
-	case HDR_SHARE_DEFER:
-		PRINT("share-defer ");
-		break;
+		PRINT("   jobdesc: stidx=%d ",
+		      (*hdr >> HDR_START_IDX_SHIFT) & HDR_START_IDX_MASK);
 	}
+	PRINT("share=%s ",
+	      deschdr_share[(*hdr >> HDR_SD_SHARE_SHIFT) & HDR_SD_SHARE_MASK]);
 
 	if (*hdr & HDR_DNR)
 		PRINT("noreplay ");
@@ -164,346 +446,172 @@ static void show_hdr(u_int32_t *hdr)
 	if (*hdr & HDR_REVERSE)
 		PRINT("reversed ");
 
-	PRINT("\n");
+	PRINT("len=%d\n", *hdr & HDR_DESCLEN_MASK);
 }
 
-static void show_key(u_int32_t *cmd, u_int8_t *idx)
+static void show_key(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	u_int32_t keylen, *keydata;
 
-	keylen  = *cmd & KEY_LENGTH_MASK;
+	keylen = *cmd & KEY_LENGTH_MASK;
 	keydata = cmd + 1; /* point to key or pointer */
 
-	PRINT("       key: len=%d ", keylen);
-
-	switch (*cmd & CLASS_MASK) {
-	case CLASS_1:
-		PRINT("class1");
-		break;
-
-	case CLASS_2:
-		PRINT("class2");
-		break;
-
-	}
-
-	switch (*cmd & KEY_DEST_MASK) {
-	case KEY_DEST_CLASS_REG:
-		PRINT("->keyreg ");
-		break;
-
-	case KEY_DEST_PKHA_E:
-		PRINT("->pk-e ");
-		break;
-
-	case KEY_DEST_AFHA_SBOX:
-		PRINT("->af-sbox ");
-		break;
-
-	case KEY_DEST_MDHA_SPLIT:
-		PRINT("->md-split ");
-		break;
-	}
+	PRINT("       key: %s->%s len=%d ",
+	      key_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT],
+	      key_dest[(*cmd & KEY_DEST_MASK) >> KEY_DEST_SHIFT],
+	      keylen);
 
 	if (*cmd & KEY_SGF)
-		PRINT("scattered ");
+		PRINT("s/g ");
 
 	if (*cmd & KEY_ENC)
-		PRINT("encrypted ");
+		PRINT("enc ");
 
 	if (*cmd & KEY_IMM)
-		PRINT("inline ");
+		PRINT("imm ");
 
 	PRINT("\n");
-
-	(*idx)++;
-
 	if (*cmd & KEY_IMM) {
-		desc_hexdump(keydata, keylen >> 2, 4, NULL_LEADER);
+		desc_hexdump(keydata, keylen >> 2, 4, leader);
 		(*idx) += keylen >> 2;
 	} else {
-		PRINT("          : @0x%08x\n", *keydata);
-		(*idx)++;
+		PRINT("%s@0x%08x\n", leader, *keydata);
+		(*idx)++; /* key pointer follows instruction */
 	}
+	(*idx)++;
 }
 
-static void show_seq_key(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_key(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	u_int32_t keylen, *keydata;
 
 	keylen  = *cmd & KEY_LENGTH_MASK;
 	keydata = cmd + 1;
 
-	PRINT("    seqkey: len=%d ", keylen);
-
-	switch (*cmd & CLASS_MASK) {
-	case CLASS_1:
-		PRINT("class1");
-		break;
-
-	case CLASS_2:
-		PRINT("class2");
-		break;
-	}
-
-	switch (*cmd & KEY_DEST_MASK) {
-	case KEY_DEST_CLASS_REG:
-		PRINT("->keyreg ");
-		break;
-
-	case KEY_DEST_PKHA_E:
-		PRINT("->pk-e ");
-		break;
-
-	case KEY_DEST_AFHA_SBOX:
-		PRINT("->af-sbox ");
-		break;
-
-	case KEY_DEST_MDHA_SPLIT:
-		PRINT("->md-split ");
-		break;
-	}
+	PRINT("    seqkey: %s->%s len=%d ",
+	      key_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT],
+	      key_dest[(*cmd & KEY_DEST_MASK) >> KEY_DEST_SHIFT],
+	      keylen);
 
 	if (*cmd & KEY_VLF)
-		PRINT("variable ");
+		PRINT("vlf ");
 
 	if (*cmd & KEY_ENC)
-		PRINT("encrypted ");
+		PRINT("enc ");
 
 	if (*cmd & KEY_IMM)
-		PRINT("inline ");
+		PRINT("imm ");
 
 	PRINT("\n");
-	(*idx)++;
-
 	if (*cmd & KEY_IMM) {
-		desc_hexdump(keydata, keylen >> 2, 4, NULL_LEADER);
+		desc_hexdump(keydata, keylen >> 2, 4, leader);
 		(*idx) += keylen >> 2;
 	} else {
-		PRINT("          : @0x%08x\n", *keydata);
+		PRINT("%s@0x%08x\n", leader, *keydata);
 		(*idx)++;
 	}
+	(*idx)++;
 }
 
-static void show_load(u_int32_t *cmd, u_int8_t *idx)
+static void show_load(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	u_int32_t ldlen, *lddata;
+	u_int8_t class;
 
 	ldlen  = *cmd & LDST_LEN_MASK;
 	lddata = cmd + 1; /* point to key or pointer */
 
-	PRINT("        ld: ");
-
-	switch (*cmd & CLASS_MASK) {
-	case LDST_CLASS_IND_CCB:
-		PRINT("CCB-class-ind");
-		break;
-
-	case LDST_CLASS_1_CCB:
-		PRINT("CCB-class1");
-		break;
-
-	case LDST_CLASS_2_CCB:
-		PRINT("CCB-class2");
-		break;
-
-	case LDST_CLASS_DECO:
-		PRINT("DECO");
-		break;
-	}
+	class = (*cmd & CLASS_MASK) >> CLASS_SHIFT;
+	PRINT("        ld: %s->%s len=%d offs=%d",
+	      ldst_class[class],
+	      ldstr_srcdst[class][(*cmd & LDST_SRCDST_MASK) >>
+				  LDST_SRCDST_SHIFT],
+	      (*cmd & LDST_LEN_MASK),
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
 
 	if (*cmd & LDST_SGF)
-		PRINT(" scatter-gather");
+		PRINT(" s/g");
 
 	if (*cmd & LDST_IMM)
-		PRINT(" inline");
-
-	switch (*cmd & LDST_SRCDST_MASK) {
-	case LDST_SRCDST_BYTE_CONTEXT:
-		PRINT(" byte-ctx");
-		break;
-
-	case LDST_SRCDST_BYTE_KEY:
-		PRINT(" byte-key");
-		break;
-
-	case LDST_SRCDST_BYTE_INFIFO:
-		PRINT(" byte-infifo");
-		break;
-
-	case LDST_SRCDST_BYTE_OUTFIFO:
-		PRINT(" byte-outfifo");
-		break;
-
-	case LDST_SRCDST_WORD_MODE_REG:
-		PRINT(" word-mode");
-		break;
-
-	case LDST_SRCDST_WORD_KEYSZ_REG:
-		PRINT(" word-keysz");
-		break;
-
-	case LDST_SRCDST_WORD_DATASZ_REG:
-		PRINT(" word-datasz");
-		break;
-
-	case LDST_SRCDST_WORD_ICVSZ_REG:
-		PRINT(" word-icvsz");
-		break;
-
-	case LDST_SRCDST_WORD_CHACTRL:
-		PRINT(" word-cha-ctrl");
-		break;
-
-	case LDST_SRCDST_WORD_IRQCTRL:
-		PRINT(" word-irq-ctrl");
-		break;
+		PRINT(" imm");
 
-	case LDST_SRCDST_WORD_CLRW:
-		PRINT(" word-clear");
-		break;
+	PRINT("\n");
 
-	case LDST_SRCDST_WORD_STAT:
-		PRINT(" word-status");
-		break;
+	/*
+	 * Special case for immediate load to DECO control. In this case
+	 * only, the immediate value is the bits in offset/length, NOT
+	 * the data following the instruction, so, skip the trailing
+	 * data processing step.
+	 */
 
-	default:
-		PRINT(" <unk-dest>");
-		break;
+	if (((*cmd & LDST_CLASS_MASK) ==  LDST_CLASS_DECO) &&
+	    ((*cmd & LDST_SRCDST_MASK) == LDST_SRCDST_WORD_DECOCTRL)) {
+		(*idx)++;
+		return;
 	}
 
-	PRINT(" offset=%d len=%d",
-	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT,
-	      (*cmd & LDST_LEN_MASK));
-
-	PRINT("\n");
-
 	if (*cmd & LDST_IMM) {
-		desc_hexdump(lddata, ldlen >> 2, 4, NULL_LEADER);
+		desc_hexdump(lddata, ldlen >> 2, 4, leader);
 		(*idx) += ldlen >> 2;
 	} else {
-		PRINT("          : @0x%08x\n", *lddata);
+		PRINT("%s@0x%08x\n", leader, *lddata);
 		(*idx)++;
 	}
-
 	(*idx)++;
 }
 
-static void show_seq_load(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_load(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT("     seqld: ");
-
-	switch (*cmd & CLASS_MASK) {
-	case LDST_CLASS_IND_CCB:
-		PRINT("CCB-class-ind");
-		break;
-
-	case LDST_CLASS_1_CCB:
-		PRINT("CCB-class1");
-		break;
+	u_int8_t class;
 
-	case LDST_CLASS_2_CCB:
-		PRINT("CCB-class2");
-		break;
-
-	case LDST_CLASS_DECO:
-		PRINT("DECO");
-		break;
-	}
+	class = (*cmd & CLASS_MASK) >> CLASS_SHIFT;
+	PRINT("     seqld: %s->%s len=%d offs=%d",
+	      ldst_class[class],
+	      ldstr_srcdst[class][(*cmd & LDST_SRCDST_MASK) >>
+				  LDST_SRCDST_SHIFT],
+	      (*cmd & LDST_LEN_MASK),
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
 
 	if (*cmd & LDST_VLF)
-		PRINT(" variable");
-
-	switch (*cmd & LDST_SRCDST_MASK) {
-	case LDST_SRCDST_BYTE_CONTEXT:
-		PRINT(" byte-ctx");
-		break;
-
-	case LDST_SRCDST_BYTE_KEY:
-		PRINT(" byte-key");
-		break;
-
-	case LDST_SRCDST_BYTE_INFIFO:
-		PRINT(" byte-infifo");
-		break;
-
-	case LDST_SRCDST_BYTE_OUTFIFO:
-		PRINT(" byte-outfifo");
-		break;
-
-	case LDST_SRCDST_WORD_MODE_REG:
-		PRINT(" word-mode");
-		break;
-
-	case LDST_SRCDST_WORD_KEYSZ_REG:
-		PRINT(" word-keysz");
-		break;
-
-	case LDST_SRCDST_WORD_DATASZ_REG:
-		PRINT(" word-datasz");
-		break;
-
-	case LDST_SRCDST_WORD_ICVSZ_REG:
-		PRINT(" word-icvsz");
-		break;
-
-	case LDST_SRCDST_WORD_CHACTRL:
-		PRINT(" word-cha-ctrl");
-		break;
-
-	case LDST_SRCDST_WORD_IRQCTRL:
-		PRINT(" word-irq-ctrl");
-		break;
-
-	case LDST_SRCDST_WORD_CLRW:
-		PRINT(" word-clear");
-		break;
-
-	case LDST_SRCDST_WORD_STAT:
-		PRINT(" word-status");
-		break;
-
-	default:
-		PRINT(" <unk-dest>");
-		break;
-	}
-
-	PRINT(" offset=%d len=%d",
-	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT,
-	      (*cmd & LDST_LEN_MASK));
+		PRINT(" vlf");
 
 	PRINT("\n");
 	(*idx)++;
 }
 
-static void show_fifo_load(u_int32_t *cmd, u_int8_t *idx)
+static void show_fifo_load(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	u_int16_t datalen;
-	u_int32_t *data;
+	u_int32_t *trdata, len;
 
-	data = cmd + 1;
+	len  = *cmd & FIFOLDST_LEN_MASK;
+	trdata = cmd + 1;
 
-	PRINT("    fifold: class=");
-	switch (*cmd & CLASS_MASK) {
-	case FIFOLD_CLASS_SKIP:
-		PRINT("skip");
-		break;
+	PRINT("    fifold: %s",
+	      fifoldst_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT]);
 
-	case FIFOLD_CLASS_CLASS1:
-		PRINT("class1");
-		break;
+	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK)
+		PRINT(" pk-%s",
+		      load_pkha_inp_types[(*cmd & FIFOLD_TYPE_PK_TYPEMASK) >>
+					  FIFOLD_TYPE_SHIFT]);
+	else {
+		PRINT(" %s",
+		      load_inp_types[(*cmd & FIFOLD_TYPE_MSG_MASK) >>
+				     FIFOLD_CONT_TYPE_SHIFT]);
 
-	case FIFOLD_CLASS_CLASS2:
-		PRINT("class2");
-		break;
+		if (*cmd & FIFOLD_TYPE_LAST2)
+			PRINT("-last2");
 
-	case FIFOLD_CLASS_BOTH:
-		PRINT("both");
-		break;
+		if (*cmd & FIFOLD_TYPE_LAST1)
+			PRINT("-last1");
+
+		if (*cmd & FIFOLD_TYPE_FLUSH1)
+			PRINT("-flush1");
 	}
 
+	PRINT(" len=%d", len);
+
 	if (*cmd & FIFOLDST_SGF_MASK)
-		PRINT(" sgf");
+		PRINT(" s/g");
 
 	if (*cmd & FIFOLD_IMM_MASK)
 		PRINT(" imm");
@@ -511,125 +619,53 @@ static void show_fifo_load(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & FIFOLDST_EXT_MASK)
 		PRINT(" ext");
 
-	PRINT(" type=");
-	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK) {
-		PRINT("pk-");
-		switch (*cmd * FIFOLD_TYPE_PK_TYPEMASK) {
-		case FIFOLD_TYPE_PK_A0:
-			PRINT("a0");
-			break;
-
-		case FIFOLD_TYPE_PK_A1:
-			PRINT("a1");
-			break;
-
-		case FIFOLD_TYPE_PK_A2:
-			PRINT("a2");
-			break;
-
-		case FIFOLD_TYPE_PK_A3:
-			PRINT("a3");
-			break;
-
-		case FIFOLD_TYPE_PK_B0:
-			PRINT("b0");
-			break;
-
-		case FIFOLD_TYPE_PK_B1:
-			PRINT("b1");
-			break;
-
-		case FIFOLD_TYPE_PK_B2:
-			PRINT("b2");
-			break;
-
-		case FIFOLD_TYPE_PK_B3:
-			PRINT("b3");
-			break;
-
-		case FIFOLD_TYPE_PK_N:
-			PRINT("n");
-			break;
+	(*idx)++; /* Bump index either to extension or next instruction */
 
-		case FIFOLD_TYPE_PK_A:
-			PRINT("a");
-			break;
-
-		case FIFOLD_TYPE_PK_B:
-			PRINT("b");
-			break;
-		}
-	} else {
-		switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
-		case FIFOLD_TYPE_MSG:
-			PRINT("msg");
-			break;
+	PRINT("\n");
+	if (*cmd & FIFOLD_IMM) {
+		desc_hexdump(trdata, len >> 2, 4, leader);
+		(*idx) += len >> 2;
+	} else { /* is just trailing pointer */
+		PRINT("%s@0x%08x\n", leader, *trdata);
+		(*idx)++;
+	}
 
-		case FIFOLD_TYPE_MSG1OUT2:
-			PRINT("msg1->2");
-			break;
+	if (*cmd & FIFOLDST_EXT) {
+		PRINT("%sextlen=%d\n", leader, *(++trdata));
+		(*idx)++;
+	}
+}
 
-		case FIFOLD_TYPE_IV:
-			PRINT("IV");
-			break;
+static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
+{
+	u_int32_t *trdata, len;
 
-		case FIFOLD_TYPE_BITDATA:
-			PRINT("bit");
-			break;
+	len  = *cmd & FIFOLDST_LEN_MASK;
+	trdata = cmd + 1;
 
-		case FIFOLD_TYPE_AAD:
-			PRINT("AAD");
-			break;
+	PRINT(" seqfifold: %s",
+	      fifoldst_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT]);
 
-		case FIFOLD_TYPE_ICV:
-			PRINT("ICV");
-			break;
-		}
+	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK)
+		PRINT(" pk-%s",
+		      load_pkha_inp_types[(*cmd * FIFOLD_TYPE_PK_TYPEMASK) >>
+					  FIFOLD_TYPE_SHIFT]);
+	else {
+		PRINT(" %s",
+		      load_inp_types[(*cmd & FIFOLD_TYPE_MSG_MASK) >>
+				     FIFOLD_CONT_TYPE_SHIFT]);
 
 		if (*cmd & FIFOLD_TYPE_LAST2)
-			PRINT("-l2");
+			PRINT("-last2");
 
 		if (*cmd & FIFOLD_TYPE_LAST1)
-			PRINT("-l1");
+			PRINT("-last1");
 
 		if (*cmd & FIFOLD_TYPE_FLUSH1)
-			PRINT("-f1");
+			PRINT("-flush1");
 	}
 
-	datalen = (*cmd & FIFOLDST_LEN_MASK);
-	PRINT(" len = %d\n", datalen);
-	(*idx)++;
-
-	if (*cmd & FIFOLDST_EXT)
-		PRINT("          : extlen=0x%08x\n", (*idx)++);
-
-}
-
-static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx)
-{
-	u_int16_t datalen;
-	u_int32_t *data;
-
-	data = cmd + 1;
-
-	PRINT(" seqfifold: class=");
-	switch (*cmd & CLASS_MASK) {
-	case FIFOLD_CLASS_SKIP:
-		PRINT("skip");
-		break;
-
-	case FIFOLD_CLASS_CLASS1:
-		PRINT("class1");
-		break;
-
-	case FIFOLD_CLASS_CLASS2:
-		PRINT("class2");
-		break;
-
-	case FIFOLD_CLASS_BOTH:
-		PRINT("both");
-		break;
-	}
+	PRINT(" len=%d", len);
 
 	if (*cmd & FIFOLDST_VLF_MASK)
 		PRINT(" vlf");
@@ -640,288 +676,90 @@ static void show_seq_fifo_load(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & FIFOLDST_EXT_MASK)
 		PRINT(" ext");
 
-	PRINT(" type=");
-	if ((*cmd & FIFOLD_TYPE_PK_MASK) == FIFOLD_TYPE_PK) {
-		PRINT("pk-");
-		switch (*cmd * FIFOLD_TYPE_PK_TYPEMASK) {
-		case FIFOLD_TYPE_PK_A0:
-			PRINT("a0");
-			break;
-
-		case FIFOLD_TYPE_PK_A1:
-			PRINT("a1");
-			break;
-
-		case FIFOLD_TYPE_PK_A2:
-			PRINT("a2");
-			break;
-
-		case FIFOLD_TYPE_PK_A3:
-			PRINT("a3");
-			break;
-
-		case FIFOLD_TYPE_PK_B0:
-			PRINT("b0");
-			break;
-
-		case FIFOLD_TYPE_PK_B1:
-			PRINT("b1");
-			break;
-
-		case FIFOLD_TYPE_PK_B2:
-			PRINT("b2");
-			break;
-
-		case FIFOLD_TYPE_PK_B3:
-			PRINT("b3");
-			break;
-
-		case FIFOLD_TYPE_PK_N:
-			PRINT("n");
-			break;
-
-		case FIFOLD_TYPE_PK_A:
-			PRINT("a");
-			break;
-
-		case FIFOLD_TYPE_PK_B:
-			PRINT("b");
-			break;
-		}
-	} else {
-		switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
-		case FIFOLD_TYPE_MSG:
-			PRINT("msg");
-			break;
-
-		case FIFOLD_TYPE_MSG1OUT2:
-			PRINT("msg1->2");
-			break;
-
-		case FIFOLD_TYPE_IV:
-			PRINT("IV");
-			break;
-
-		case FIFOLD_TYPE_BITDATA:
-			PRINT("bit");
-			break;
-
-		case FIFOLD_TYPE_AAD:
-			PRINT("AAD");
-			break;
-
-		case FIFOLD_TYPE_ICV:
-			PRINT("ICV");
-			break;
-		}
-
-		if (*cmd & FIFOLD_TYPE_LAST2)
-			PRINT("-l2");
-
-		if (*cmd & FIFOLD_TYPE_LAST1)
-			PRINT("-l1");
-
-		if (*cmd & FIFOLD_TYPE_FLUSH1)
-			PRINT("-f1");
-	}
+	PRINT("\n");
 
-	datalen = (*cmd & FIFOLDST_LEN_MASK);
-	PRINT(" len = %d\n", datalen);
 	(*idx)++;
 
-	if (*cmd & FIFOLDST_EXT)
-		PRINT("          : extlen=0x%08x\n", (*idx)++);
+	if (*cmd & FIFOLD_IMM) {
+		desc_hexdump(trdata, len >> 2, 4, leader);
+		(*idx) += len >> 2;
+	}
 
+	if (*cmd & FIFOLDST_EXT) {
+		PRINT("%sextlen=%d\n", leader, *(++trdata));
+		(*idx)++;
+	}
 }
 
-static void show_store(u_int32_t *cmd, u_int8_t *idx)
+static void show_store(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT("       str: ");
-	switch (*cmd & LDST_CLASS_MASK) {
-	case LDST_CLASS_IND_CCB:
-		PRINT("ccb-indep ");
-		break;
+	u_int32_t stlen, *stdata;
+	u_int8_t class;
 
-	case LDST_CLASS_1_CCB:
-		PRINT("ccb-class1 ");
-		break;
+	class = (*cmd & CLASS_MASK) >> CLASS_SHIFT;
+	stlen  = *cmd & LDST_LEN_MASK;
+	stdata = cmd + 1;
 
-	case LDST_CLASS_2_CCB:
-		PRINT("ccb-class2 ");
-		break;
-
-	case LDST_CLASS_DECO:
-		PRINT("deco ");
-		break;
-	}
+	PRINT("       str: %s %s len=%d offs=%d\n",
+	      ldst_class[class],
+	      ldstr_srcdst[class]
+			  [(*cmd & LDST_SRCDST_MASK) >> LDST_SRCDST_SHIFT],
+	      (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT,
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
 
 	if (*cmd & LDST_SGF)
-		PRINT("sgf ");
+		PRINT(" s/g");
 
 	if (*cmd & LDST_IMM)
-		PRINT("imm ");
-
-	PRINT("src=");
-	switch (*cmd & LDST_SRCDST_MASK) {
-	case LDST_SRCDST_BYTE_CONTEXT:
-		PRINT("byte-ctx ");
-		break;
-
-	case LDST_SRCDST_BYTE_KEY:
-		PRINT("byte-key ");
-		break;
-
-	case LDST_SRCDST_WORD_MODE_REG:
-		PRINT("word-mode ");
-		break;
-
-	case LDST_SRCDST_WORD_KEYSZ_REG:
-		PRINT("word-keysz ");
-		break;
-
-	case LDST_SRCDST_WORD_DATASZ_REG:
-		PRINT("word-datasz ");
-		break;
-
-	case LDST_SRCDST_WORD_ICVSZ_REG:
-		PRINT("word-icvsz ");
-		break;
-
-	case LDST_SRCDST_WORD_CHACTRL:
-		PRINT("cha-ctrl ");
-		break;
-
-	case LDST_SRCDST_WORD_IRQCTRL:
-		PRINT("irq-ctrl ");
-		break;
-
-	case LDST_SRCDST_WORD_CLRW:
-		PRINT("clr-written ");
-		break;
+		PRINT(" imm");
 
-	case LDST_SRCDST_WORD_STAT:
-		PRINT("status ");
-		break;
+	(*idx)++;
 
-	default:
-		PRINT("(unk) ");
-		break;
+	if (*cmd & LDST_IMM) {
+		desc_hexdump(stdata, stlen >> 2, 4, leader);
+		(*idx) += stlen >> 2;
+	} else {
+		PRINT("%s@0x%08x\n", leader, *stdata);
+		(*idx)++;
 	}
-
-	PRINT("offset=%d ", (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
-	PRINT("len=%d ", (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT);
-	PRINT("\n");
-	(*idx)++;
 }
 
-static void show_seq_store(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_store(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT("    seqstr: ");
-	switch (*cmd & LDST_CLASS_MASK) {
-	case LDST_CLASS_IND_CCB:
-		PRINT("ccb-indep ");
-		break;
-
-	case LDST_CLASS_1_CCB:
-		PRINT("ccb-class1 ");
-		break;
+	u_int8_t class;
 
-	case LDST_CLASS_2_CCB:
-		PRINT("ccb-class2 ");
-		break;
+	class = (*cmd & CLASS_MASK) >> CLASS_SHIFT;
 
-	case LDST_CLASS_DECO:
-		PRINT("deco ");
-		break;
-	}
+	PRINT("    seqstr: %s %s len=%d offs=%d\n",
+	      ldst_class[class],
+	      ldstr_srcdst[class]
+			  [(*cmd & LDST_SRCDST_MASK) >> LDST_SRCDST_SHIFT],
+	      (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT,
+	      (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
 
 	if (*cmd & LDST_VLF)
-		PRINT("vlf ");
+		PRINT(" vlf");
 
 	if (*cmd & LDST_IMM)
-		PRINT("imm ");
-
-	PRINT("src=");
-	switch (*cmd & LDST_SRCDST_MASK) {
-	case LDST_SRCDST_BYTE_CONTEXT:
-		PRINT("byte-ctx ");
-		break;
-
-	case LDST_SRCDST_BYTE_KEY:
-		PRINT("byte-key ");
-		break;
-
-	case LDST_SRCDST_WORD_MODE_REG:
-		PRINT("word-mode ");
-		break;
-
-	case LDST_SRCDST_WORD_KEYSZ_REG:
-		PRINT("word-keysz ");
-		break;
-
-	case LDST_SRCDST_WORD_DATASZ_REG:
-		PRINT("word-datasz ");
-		break;
-
-	case LDST_SRCDST_WORD_ICVSZ_REG:
-		PRINT("word-icvsz ");
-		break;
-
-	case LDST_SRCDST_WORD_CHACTRL:
-		PRINT("cha-ctrl ");
-		break;
-
-	case LDST_SRCDST_WORD_IRQCTRL:
-		PRINT("irq-ctrl ");
-		break;
-
-	case LDST_SRCDST_WORD_CLRW:
-		PRINT("clr-written ");
-		break;
-
-	case LDST_SRCDST_WORD_STAT:
-		PRINT("status ");
-		break;
-
-	default:
-		PRINT("<unk> ");
-		break;
-	}
+		PRINT(" imm");
 
-	PRINT("offset=%d ", (*cmd & LDST_OFFSET_MASK) >> LDST_OFFSET_SHIFT);
-	PRINT("len=%d ", (*cmd & LDST_LEN_MASK) >> LDST_LEN_SHIFT);
-	PRINT("\n");
 	(*idx)++;
 }
 
-static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx)
+static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	u_int16_t datalen;
-	u_int32_t *data;
-
-	data = cmd + 1;
-
-	PRINT("   fifostr: class=");
-	switch (*cmd & CLASS_MASK) {
-	case FIFOST_CLASS_NORMAL:
-		PRINT("norm");
-		break;
-
-	case FIFOST_CLASS_CLASS1KEY:
-		PRINT("class1");
-		break;
+	u_int32_t *trdata, len;
 
-	case FIFOST_CLASS_CLASS2KEY:
-		PRINT("class2");
-		break;
+	len  = *cmd & FIFOLDST_LEN_MASK;
+	trdata = cmd + 1;
 
-	default:
-		PRINT("<unk>");
-		break;
-	}
+	PRINT("   fifostr: %s %s len=%d",
+	      fifoldst_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT],
+	      fifo_output_data_type[(*cmd & FIFOST_TYPE_MASK) >>
+				    FIFOST_TYPE_SHIFT], len);
 
 	if (*cmd & FIFOLDST_SGF_MASK)
-		PRINT(" sgf");
+		PRINT(" s/g");
 
 	if (*cmd & FIFOST_CONT_MASK)
 		PRINT(" cont");
@@ -929,148 +767,34 @@ static void show_fifo_store(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & FIFOLDST_EXT_MASK)
 		PRINT(" ext");
 
-	PRINT(" type=");
-	switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
-	case FIFOST_TYPE_PKHA_A0:
-		PRINT("pk-a0");
-		break;
-
-	case FIFOST_TYPE_PKHA_A1:
-		PRINT("pk-a1");
-		break;
-
-	case FIFOST_TYPE_PKHA_A2:
-		PRINT("pk-a2");
-		break;
-
-	case FIFOST_TYPE_PKHA_A3:
-		PRINT("pk-a3");
-		break;
-
-	case FIFOST_TYPE_PKHA_B0:
-		PRINT("pk-b0");
-		break;
-
-	case FIFOST_TYPE_PKHA_B1:
-		PRINT("pk-b1");
-		break;
-
-	case FIFOST_TYPE_PKHA_B2:
-		PRINT("pk-b2");
-		break;
-
-	case FIFOST_TYPE_PKHA_B3:
-		PRINT("pk-b3");
-		break;
-
-	case FIFOST_TYPE_PKHA_N:
-		PRINT("pk-n");
-		break;
-
-	case FIFOST_TYPE_PKHA_A:
-		PRINT("pk-a");
-		break;
-
-	case FIFOST_TYPE_PKHA_B:
-		PRINT("pk-b");
-		break;
-
-	case FIFOST_TYPE_AF_SBOX_JKEK:
-		PRINT("af-sbox-jkek");
-		break;
-
-	case FIFOST_TYPE_AF_SBOX_TKEK:
-		PRINT("af-sbox-tkek");
-		break;
-
-	case FIFOST_TYPE_PKHA_E_JKEK:
-		PRINT("pk-e-jkek");
-		break;
-
-	case FIFOST_TYPE_PKHA_E_TKEK:
-		PRINT("pk-e-tkek");
-		break;
-
-	case FIFOST_TYPE_KEY_KEK:
-		PRINT("key-kek");
-		break;
-
-	case FIFOST_TYPE_KEY_TKEK:
-		PRINT("key-tkek");
-		break;
-
-	case FIFOST_TYPE_SPLIT_KEK:
-		PRINT("split-kek");
-		break;
-
-	case FIFOST_TYPE_SPLIT_TKEK:
-		PRINT("split-tkek");
-		break;
-
-	case FIFOST_TYPE_OUTFIFO_KEK:
-		PRINT("outf-kek");
-		break;
-
-	case FIFOST_TYPE_OUTFIFO_TKEK:
-		PRINT("outf-tkek");
-		break;
-
-	case FIFOST_TYPE_MESSAGE_DATA:
-		PRINT("msg");
-		break;
-
-	case FIFOST_TYPE_RNGSTORE:
-		PRINT("rng");
-		break;
-
-	case FIFOST_TYPE_RNGFIFO:
-		PRINT("rngf");
-		break;
-
-	case FIFOST_TYPE_SKIP:
-		PRINT("skip");
-		break;
-
-	default:
-		PRINT("<unk>");
-		break;
-	};
-
-	datalen = (*cmd & FIFOLDST_LEN_MASK);
-	PRINT(" len = %d\n", datalen);
+	PRINT("\n");
 	(*idx)++;
 
-	if (*cmd & FIFOLDST_EXT)
-		PRINT("          : extlen=0x%08x\n", (*idx)++);
+	if (*cmd & FIFOST_IMM) {
+		desc_hexdump(trdata, len >> 2, 4, leader);
+		(*idx) += len >> 2;
+	} else {
+		PRINT("%s@0x%08x\n", leader, *trdata);
+		(*idx)++;
+	}
 
-	(*idx)++;
+	if (*cmd & FIFOLDST_EXT) {
+		PRINT("%sextlen=%d\n", leader, *(++trdata));
+		(*idx)++;
+	}
 }
 
-static void show_seq_fifo_store(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_fifo_store(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	u_int16_t datalen;
-	u_int32_t *data;
-
-	data = cmd + 1;
-
-	PRINT("seqfifostr: class=");
-	switch (*cmd & CLASS_MASK) {
-	case FIFOST_CLASS_NORMAL:
-		PRINT("norm");
-		break;
-
-	case FIFOST_CLASS_CLASS1KEY:
-		PRINT("class1");
-		break;
+	u_int32_t pcmd, *trdata, len;
 
-	case FIFOST_CLASS_CLASS2KEY:
-		PRINT("class2");
-		break;
+	len  = *cmd & FIFOLDST_LEN_MASK;
+	trdata = cmd + 1;
 
-	default:
-		PRINT("<unk>");
-		break;
-	}
+	PRINT("seqfifostr: %s %s len=%d",
+	      fifoldst_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT],
+	      fifo_output_data_type[(*cmd & FIFOST_TYPE_MASK) >>
+				    FIFOST_TYPE_SHIFT], len);
 
 	if (*cmd & FIFOLDST_VLF_MASK)
 		PRINT(" vlf");
@@ -1081,232 +805,28 @@ static void show_seq_fifo_store(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & FIFOLDST_EXT_MASK)
 		PRINT(" ext");
 
-	PRINT(" type=");
-	switch (*cmd & FIFOLD_TYPE_MSG_MASK)  {
-	case FIFOST_TYPE_PKHA_A0:
-		PRINT("pk-a0");
-		break;
-
-	case FIFOST_TYPE_PKHA_A1:
-		PRINT("pk-a1");
-		break;
-
-	case FIFOST_TYPE_PKHA_A2:
-		PRINT("pk-a2");
-		break;
-
-	case FIFOST_TYPE_PKHA_A3:
-		PRINT("pk-a3");
-		break;
-
-	case FIFOST_TYPE_PKHA_B0:
-		PRINT("pk-b0");
-		break;
-
-	case FIFOST_TYPE_PKHA_B1:
-		PRINT("pk-b1");
-		break;
-
-	case FIFOST_TYPE_PKHA_B2:
-		PRINT("pk-b2");
-		break;
-
-	case FIFOST_TYPE_PKHA_B3:
-		PRINT("pk-b3");
-		break;
-
-	case FIFOST_TYPE_PKHA_N:
-		PRINT("pk-n");
-		break;
-
-	case FIFOST_TYPE_PKHA_A:
-		PRINT("pk-a");
-		break;
-
-	case FIFOST_TYPE_PKHA_B:
-		PRINT("pk-b");
-		break;
-
-	case FIFOST_TYPE_AF_SBOX_JKEK:
-		PRINT("af-sbox-jkek");
-		break;
-
-	case FIFOST_TYPE_AF_SBOX_TKEK:
-		PRINT("af-sbox-tkek");
-		break;
-
-	case FIFOST_TYPE_PKHA_E_JKEK:
-		PRINT("pk-e-jkek");
-		break;
-
-	case FIFOST_TYPE_PKHA_E_TKEK:
-		PRINT("pk-e-tkek");
-		break;
-
-	case FIFOST_TYPE_KEY_KEK:
-		PRINT("key-kek");
-		break;
-
-	case FIFOST_TYPE_KEY_TKEK:
-		PRINT("key-tkek");
-		break;
-
-	case FIFOST_TYPE_SPLIT_KEK:
-		PRINT("split-kek");
-		break;
-
-	case FIFOST_TYPE_SPLIT_TKEK:
-		PRINT("split-tkek");
-		break;
-
-	case FIFOST_TYPE_OUTFIFO_KEK:
-		PRINT("outf-kek");
-		break;
-
-	case FIFOST_TYPE_OUTFIFO_TKEK:
-		PRINT("outf-tkek");
-		break;
-
-	case FIFOST_TYPE_MESSAGE_DATA:
-		PRINT("msg");
-		break;
-
-	case FIFOST_TYPE_RNGSTORE:
-		PRINT("rng");
-		break;
-
-	case FIFOST_TYPE_RNGFIFO:
-		PRINT("rngf");
-		break;
-
-	case FIFOST_TYPE_SKIP:
-		PRINT("skip");
-		break;
-
-	default:
-		PRINT("<unk>");
-		break;
-	};
-
-	datalen = (*cmd & FIFOLDST_LEN_MASK);
-	PRINT(" len = %d\n", datalen);
-	(*idx)++;
-
-	if (*cmd & FIFOLDST_EXT)
-		PRINT("          : extlen=0x%08x\n", (*idx)++);
-
-	(*idx)++;
-}
-
-static void show_move(u_int32_t *cmd, u_int8_t *idx)
-{
-	PRINT("      move: ");
-
-	switch (*cmd & MOVE_SRC_MASK) {
-	case MOVE_SRC_CLASS1CTX:
-		PRINT("class1-ctx");
-		break;
-
-	case MOVE_SRC_CLASS2CTX:
-		PRINT("class2-ctx");
-		break;
-
-	case MOVE_SRC_OUTFIFO:
-		PRINT("outfifo");
-		break;
-
-	case MOVE_SRC_DESCBUF:
-		PRINT("descbuf");
-		break;
-
-	case MOVE_SRC_MATH0:
-		PRINT("math0");
-		break;
-
-	case MOVE_SRC_MATH1:
-		PRINT("math1");
-		break;
-
-	case MOVE_SRC_MATH2:
-		PRINT("math2");
-		break;
-
-	case MOVE_SRC_MATH3:
-		PRINT("math3");
-		break;
-
-	case MOVE_SRC_INFIFO:
-		PRINT("infifo");
-		break;
+	PRINT("\n");
+	pcmd = *cmd;
+	(*idx)++; /* Bump index either to extension or next instruction */
 
-	default:
-		PRINT("<unk>");
-		break;
+	if (pcmd & FIFOST_IMM) {
+		desc_hexdump(trdata, len >> 2, 4, leader);
+		(*idx) += len >> 2;
 	}
 
-	PRINT("->");
-
-	switch (*cmd & MOVE_DEST_MASK) {
-	case MOVE_DEST_CLASS1CTX:
-		PRINT("class1-ctx ");
-		break;
-
-	case MOVE_DEST_CLASS2CTX:
-		PRINT("class2-ctx ");
-		break;
-
-	case MOVE_DEST_OUTFIFO:
-		PRINT("outfifo ");
-		break;
-
-	case MOVE_DEST_DESCBUF:
-		PRINT("descbuf ");
-		break;
-
-	case MOVE_DEST_MATH0:
-		PRINT("math0 ");
-		break;
-
-	case MOVE_DEST_MATH1:
-		PRINT("math1 ");
-		break;
-
-	case MOVE_DEST_MATH2:
-		PRINT("math2 ");
-		break;
-
-	case MOVE_DEST_MATH3:
-		PRINT("math3 ");
-		break;
-
-	case MOVE_DEST_CLASS1INFIFO:
-		PRINT("class1-infifo ");
-		break;
-
-	case MOVE_DEST_CLASS2INFIFO:
-		PRINT("class2-infifo ");
-		break;
-
-	case MOVE_DEST_PK_A:
-		PRINT("pk-a ");
-		break;
-
-	case MOVE_DEST_CLASS1KEY:
-		PRINT("class1-key ");
-		break;
-
-	case MOVE_DEST_CLASS2KEY:
-		PRINT("class2-key ");
-		break;
-
-	default:
-		PRINT("<unk> ");
-		break;
+	if (pcmd & FIFOLDST_EXT) {
+		PRINT("%sextlen=%d\n", leader, *(++trdata));
+		(*idx)++;
 	}
+}
 
-	PRINT("offset=%d ", (*cmd & MOVE_OFFSET_MASK) >> MOVE_OFFSET_SHIFT);
-
-	PRINT("length=%d ", (*cmd & MOVE_LEN_MASK) >> MOVE_LEN_SHIFT);
+static void show_move(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
+{
+	PRINT("      move: %s->%s len=%d offs=%d",
+	      move_src[(*cmd & MOVE_SRC_MASK) >> MOVE_SRC_SHIFT],
+	      move_dst[(*cmd & MOVE_DEST_MASK) >> MOVE_DEST_SHIFT],
+	      (*cmd & MOVE_LEN_MASK) >> MOVE_LEN_SHIFT,
+	      (*cmd & MOVE_OFFSET_MASK) >> MOVE_OFFSET_SHIFT);
 
 	if (*cmd & MOVE_WAITCOMP)
 		PRINT("wait ");
@@ -1315,148 +835,54 @@ static void show_move(u_int32_t *cmd, u_int8_t *idx)
 	(*idx)++;
 }
 
-static void decode_unidir_pcl_op(u_int32_t *cmd)
-{
-	switch (*cmd & OP_PCLID_MASK) {
-	case OP_PCLID_IKEV1_PRF:
-		PRINT("ike_v1_prf ");
-		break;
-	case OP_PCLID_IKEV2_PRF:
-		PRINT("ike_v2_prf ");
-		break;
-	case OP_PCLID_SSL30_PRF:
-		PRINT("ssl3.0_prf ");
-		break;
-	case OP_PCLID_TLS10_PRF:
-		PRINT("tls1.0_prf ");
-		break;
-	case OP_PCLID_TLS11_PRF:
-		PRINT("tls1.1_prf ");
-		break;
-	case OP_PCLID_DTLS10_PRF:
-		PRINT("dtls1.0_prf ");
-		break;
-	}
-}
-
-static void decode_ipsec_pclinfo(u_int32_t *cmd)
-{
-	switch (*cmd & OP_PCL_IPSEC_CIPHER_MASK) {
-	case OP_PCL_IPSEC_DES_IV64:
-		PRINT("des-iv64 ");
-		break;
-
-	case OP_PCL_IPSEC_DES:
-		PRINT("des ");
-		break;
-
-	case OP_PCL_IPSEC_3DES:
-		PRINT("3des ");
-		break;
-
-	case OP_PCL_IPSEC_AES_CBC:
-		PRINT("aes-cbc ");
-		break;
-
-	case OP_PCL_IPSEC_AES_CTR:
-		PRINT("aes-ctr ");
-		break;
-
-	case OP_PCL_IPSEC_AES_XTS:
-		PRINT("aes-xts ");
-		break;
-
-	case OP_PCL_IPSEC_AES_CCM8:
-		PRINT("aes-ccm8 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_CCM12:
-		PRINT("aes-ccm12 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_CCM16:
-		PRINT("aes-ccm16 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_GCM8:
-		PRINT("aes-ccm8 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_GCM12:
-		PRINT("aes-ccm12 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_GCM16:
-		PRINT("aes-ccm16 ");
-		break;
-	}
-
-	switch (*cmd & OP_PCL_IPSEC_AUTH_MASK) {
-	case OP_PCL_IPSEC_HMAC_NULL:
-		PRINT("hmac-null ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_MD5_96:
-		PRINT("hmac-md5-96 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_SHA1_96:
-		PRINT("hmac-sha1-96 ");
-		break;
-
-	case OP_PCL_IPSEC_AES_XCBC_MAC_96:
-		PRINT("aes-xcbcmac-96 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_MD5_128:
-		PRINT("hmac-md5-128 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_SHA1_160:
-		PRINT("hmac-sha1-160 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_SHA2_256_128:
-		PRINT("hmac-sha2-256-128 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_SHA2_384_192:
-		PRINT("hmac-sha2-384-192 ");
-		break;
-
-	case OP_PCL_IPSEC_HMAC_SHA2_512_256:
-		PRINT("hmac-sha2-512-256 ");
-		break;
-	}
-}
-
 /* need a BUNCH of these decoded... */
 static void decode_bidir_pcl_op(u_int32_t *cmd)
 {
 	switch (*cmd & OP_PCLID_MASK) {
 	case OP_PCLID_IPSEC:
-		PRINT("ipsec ");
-		decode_ipsec_pclinfo(cmd);
+		PRINT("ipsec %s %s ",
+		      ipsec_pclinfo_cipher[(*cmd & OP_PCL_IPSEC_CIPHER_MASK) >>
+					   8],
+		      ipsec_pclinfo_auth[(*cmd & OP_PCL_IPSEC_AUTH_MASK)]);
 		break;
 
 	case OP_PCLID_SRTP:
-		PRINT("srtp ");
-		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		PRINT("srtp %s %s ",
+		      ipsec_pclinfo_cipher[(*cmd & OP_PCL_IPSEC_CIPHER_MASK) >>
+		      8],
+		      ipsec_pclinfo_auth[(*cmd & OP_PCL_IPSEC_AUTH_MASK)]);
 		break;
 
 	case OP_PCLID_MACSEC:
 		PRINT("macsec ");
-		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		if ((*cmd & OP_PCLINFO_MASK) == OP_PCL_MACSEC)
+			PRINT("aes-ccm-8 ");
+		else
+			PRINT("<rsvd 0x%04x> ", *cmd & OP_PCLINFO_MASK);
 		break;
 
 	case OP_PCLID_WIFI:
 		PRINT("wifi ");
-		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		if ((*cmd & OP_PCLINFO_MASK) == OP_PCL_WIFI)
+			PRINT("aes-gcm-16 ");
+		else
+			PRINT("<rsvd 0x%04x> ", *cmd & OP_PCLINFO_MASK);
 		break;
 
 	case OP_PCLID_WIMAX:
 		PRINT("wimax ");
-		PRINT("pclinfo=0x%04x ", *cmd & OP_PCLINFO_MASK);
+		switch (*cmd & OP_PCLINFO_MASK) {
+		case OP_PCL_WIMAX_OFDM:
+			PRINT("ofdm ");
+			break;
+
+		case OP_PCL_WIMAX_OFDMA:
+			PRINT("ofdma ");
+			break;
+
+		default:
+			PRINT("<rsvd 0x%04x> ", *cmd & OP_PCLINFO_MASK);
+		}
 		break;
 
 	case OP_PCLID_SSL30:
@@ -1486,30 +912,6 @@ static void decode_bidir_pcl_op(u_int32_t *cmd)
 	}
 }
 
-static void decode_pk_op(u_int32_t *cmd)
-{
-	switch (*cmd & OP_PCLID_MASK) {
-	case OP_PCLID_PRF:
-		PRINT("prf ");
-		break;
-	case OP_PCLID_BLOB:
-		PRINT("sm-blob ");
-		break;
-	case OP_PCLID_SECRETKEY:
-		PRINT("secret-key ");
-		break;
-	case OP_PCLID_PUBLICKEYPAIR:
-		PRINT("pk-pair ");
-		break;
-	case OP_PCLID_DSASIGN:
-		PRINT("dsa-sign ");
-		break;
-	case OP_PCLID_DSAVERIFY:
-		PRINT("dsa-verify ");
-		break;
-	}
-}
-
 static void decode_class12_op(u_int32_t *cmd)
 {
 	/* Algorithm type */
@@ -1571,7 +973,7 @@ static void decode_class12_op(u_int32_t *cmd)
 		break;
 
 	default:
-		PRINT("unknown-alg ");
+		PRINT("<rsvd> ");
 	}
 
 	/* Additional info */
@@ -1689,100 +1091,99 @@ static void decode_class12_op(u_int32_t *cmd)
 		case OP_ALG_AAI_DK:
 			PRINT("dk ");
 			break;
-
 		}
 		break;
 
 	case OP_ALG_ALGSEL_DES:
 	case OP_ALG_ALGSEL_3DES:
-	switch (*cmd & OP_ALG_AAI_MASK) {
-	case OP_ALG_AAI_CBC:
-		PRINT("cbc ");
-		break;
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_CBC:
+			PRINT("cbc ");
+			break;
 
-	case OP_ALG_AAI_ECB:
-		PRINT("ecb ");
-		break;
+		case OP_ALG_AAI_ECB:
+			PRINT("ecb ");
+			break;
 
-	case OP_ALG_AAI_CFB:
-		PRINT("cfb ");
-		break;
+		case OP_ALG_AAI_CFB:
+			PRINT("cfb ");
+			break;
 
-	case OP_ALG_AAI_OFB:
-		PRINT("ofb ");
-		break;
+		case OP_ALG_AAI_OFB:
+			PRINT("ofb ");
+			break;
 
-	case OP_ALG_AAI_CHECKODD:
-		PRINT("chkodd ");
+		case OP_ALG_AAI_CHECKODD:
+			PRINT("chkodd ");
+			break;
+		}
 		break;
-	}
-	break;
 
 	case OP_ALG_ALGSEL_RNG:
-	switch (*cmd & OP_ALG_AAI_MASK) {
-	case OP_ALG_AAI_RNG:
-		PRINT("rng ");
-		break;
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_RNG:
+			PRINT("rng ");
+			break;
 
-	case OP_ALG_AAI_RNG_NOZERO:
-		PRINT("rng-no0 ");
-		break;
+		case OP_ALG_AAI_RNG_NOZERO:
+			PRINT("rng-no0 ");
+			break;
 
-	case OP_ALG_AAI_RNG_ODD:
-		PRINT("rngodd ");
+		case OP_ALG_AAI_RNG_ODD:
+			PRINT("rngodd ");
+			break;
+		}
 		break;
-	}
-	break;
 
 
 	case OP_ALG_ALGSEL_SNOW:
 	case OP_ALG_ALGSEL_KASUMI:
-	switch (*cmd & OP_ALG_AAI_MASK) {
-	case OP_ALG_AAI_F8:
-		PRINT("f8 ");
-		break;
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_F8:
+			PRINT("f8 ");
+			break;
 
-	case OP_ALG_AAI_F9:
-		PRINT("f9 ");
-		break;
+		case OP_ALG_AAI_F9:
+			PRINT("f9 ");
+			break;
 
-	case OP_ALG_AAI_GSM:
-		PRINT("gsm ");
-		break;
+		case OP_ALG_AAI_GSM:
+			PRINT("gsm ");
+			break;
 
-	case OP_ALG_AAI_EDGE:
-		PRINT("edge ");
+		case OP_ALG_AAI_EDGE:
+			PRINT("edge ");
+			break;
+		}
 		break;
-	}
-	break;
 
 	case OP_ALG_ALGSEL_CRC:
-	switch (*cmd & OP_ALG_AAI_MASK) {
-	case OP_ALG_AAI_802:
-		PRINT("802 ");
-		break;
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_802:
+			PRINT("802 ");
+			break;
 
-	case OP_ALG_AAI_3385:
-		PRINT("3385 ");
-		break;
+		case OP_ALG_AAI_3385:
+			PRINT("3385 ");
+			break;
 
-	case OP_ALG_AAI_CUST_POLY:
-		PRINT("custom-poly ");
-		break;
+		case OP_ALG_AAI_CUST_POLY:
+			PRINT("custom-poly ");
+			break;
 
-	case OP_ALG_AAI_DIS:
-		PRINT("dis ");
-		break;
+		case OP_ALG_AAI_DIS:
+			PRINT("dis ");
+			break;
 
-	case OP_ALG_AAI_DOS:
-		PRINT("dos ");
-		break;
+		case OP_ALG_AAI_DOS:
+			PRINT("dos ");
+			break;
 
-	case OP_ALG_AAI_DOC:
-		PRINT("doc ");
+		case OP_ALG_AAI_DOC:
+			PRINT("doc ");
+			break;
+		}
 		break;
-	}
-	break;
 
 	case OP_ALG_ALGSEL_MD5:
 	case OP_ALG_ALGSEL_SHA1:
@@ -1790,20 +1191,20 @@ static void decode_class12_op(u_int32_t *cmd)
 	case OP_ALG_ALGSEL_SHA256:
 	case OP_ALG_ALGSEL_SHA384:
 	case OP_ALG_ALGSEL_SHA512:
-	switch (*cmd & OP_ALG_AAI_MASK) {
-	case OP_ALG_AAI_HMAC:
-		PRINT("hmac ");
-		break;
+		switch (*cmd & OP_ALG_AAI_MASK) {
+		case OP_ALG_AAI_HMAC:
+			PRINT("hmac ");
+			break;
 
-	case OP_ALG_AAI_SMAC:
-		PRINT("smac ");
-		break;
+		case OP_ALG_AAI_SMAC:
+			PRINT("smac ");
+			break;
 
-	case OP_ALG_AAI_HMAC_PRECOMP:
-		PRINT("hmac-pre ");
+		case OP_ALG_AAI_HMAC_PRECOMP:
+			PRINT("hmac-pre ");
+			break;
+		}
 		break;
-	}
-	break;
 
 	default:
 		PRINT("unknown-aai ");
@@ -1833,45 +1234,130 @@ static void decode_class12_op(u_int32_t *cmd)
 		PRINT("icv ");
 
 	if (*cmd & OP_ALG_DIR_MASK)
-		PRINT("encrypt ");
+		PRINT("enc ");
 	else
-		PRINT("decrypt ");
+		PRINT("dec ");
 
 }
 
+static void show_op_pk_clrmem_args(u_int32_t inst)
+{
+	if (inst & OP_ALG_PKMODE_A_RAM)
+		PRINT("a ");
+
+	if (inst & OP_ALG_PKMODE_B_RAM)
+		PRINT("b ");
+
+	if (inst & OP_ALG_PKMODE_E_RAM)
+		PRINT("e ");
+
+	if (inst & OP_ALG_PKMODE_N_RAM)
+		PRINT("n ");
+}
+
+static void show_op_pk_modmath_args(u_int32_t inst)
+{
+	if (inst & OP_ALG_PKMODE_MOD_IN_MONTY)
+		PRINT("inmont ");
+
+	if (inst & OP_ALG_PKMODE_MOD_OUT_MONTY)
+		PRINT("outmont ");
+
+	if (inst & OP_ALG_PKMODE_MOD_F2M)
+		PRINT("poly ");
+
+	if (inst & OP_ALG_PKMODE_MOD_R2_IN)
+		PRINT("r2%%n-inp ");
+
+	if (inst & OP_ALG_PKMODE_PRJECTV)
+		PRINT("prj ");
+
+	if (inst & OP_ALG_PKMODE_TIME_EQ)
+		PRINT("teq ");
+
+	if (inst & OP_ALG_PKMODE_OUT_A)
+		PRINT("->a ");
+	else
+		PRINT("->b ");
+}
+
+static void show_op_pk_cpymem_args(u_int32_t inst)
+{
+	u_int8_t srcregix, dstregix, srcsegix, dstsegix;
+
+	srcregix = (inst & OP_ALG_PKMODE_SRC_REG_MASK) >>
+		   OP_ALG_PKMODE_SRC_REG_SHIFT;
+	dstregix = (inst & OP_ALG_PKMODE_DST_REG_MASK) >>
+		   OP_ALG_PKMODE_DST_REG_SHIFT;
+	srcsegix = (inst & OP_ALG_PKMODE_SRC_SEG_MASK) >>
+		   OP_ALG_PKMODE_SRC_SEG_SHIFT;
+	dstsegix = (inst & OP_ALG_PKMODE_DST_SEG_MASK) >>
+		   OP_ALG_PKMODE_DST_SEG_SHIFT;
+
+	PRINT("%s[%d]->%s[%d] ", pk_srcdst[srcregix], srcsegix,
+	      pk_srcdst[dstregix], dstsegix);
+}
 
-static void show_op(u_int32_t *cmd, u_int8_t *idx)
+static void show_op(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT(" operation: type=");
+	PRINT(" operation: ");
 
 	switch (*cmd & OP_TYPE_MASK) {
 	case OP_TYPE_UNI_PROTOCOL:
-		PRINT("unidir-pcl ");
-		decode_unidir_pcl_op(cmd);
+		PRINT("uni-pcl ");
+		PRINT("%s ",
+		      unidir_pcl[(*cmd & OP_PCLID_MASK) >> OP_PCLID_SHIFT]);
 		break;
 
 	case OP_TYPE_PK:
-		PRINT("public-key ");
-		decode_pk_op(cmd);
+		PRINT("pk %s ",
+		      pk_function[*cmd & OP_ALG_PK_FUN_MASK]);
+		switch (*cmd & OP_ALG_PK_FUN_MASK) {
+		case OP_ALG_PKMODE_CLEARMEM:
+			show_op_pk_clrmem_args(*cmd);
+			break;
+
+		case OP_ALG_PKMODE_MOD_ADD:
+		case OP_ALG_PKMODE_MOD_SUB_AB:
+		case OP_ALG_PKMODE_MOD_SUB_BA:
+		case OP_ALG_PKMODE_MOD_MULT:
+		case OP_ALG_PKMODE_MOD_EXPO:
+		case OP_ALG_PKMODE_MOD_REDUCT:
+		case OP_ALG_PKMODE_MOD_INV:
+		case OP_ALG_PKMODE_MOD_ECC_ADD:
+		case OP_ALG_PKMODE_MOD_ECC_DBL:
+		case OP_ALG_PKMODE_MOD_ECC_MULT:
+		case OP_ALG_PKMODE_MOD_MONT_CNST:
+		case OP_ALG_PKMODE_MOD_CRT_CNST:
+		case OP_ALG_PKMODE_MOD_GCD:
+		case OP_ALG_PKMODE_MOD_PRIMALITY:
+			show_op_pk_modmath_args(*cmd);
+			break;
+
+		case OP_ALG_PKMODE_CPYMEM_N_SZ:
+		case OP_ALG_PKMODE_CPYMEM_SRC_SZ:
+			show_op_pk_cpymem_args(*cmd);
+			break;
+		}
 		break;
 
 	case OP_TYPE_CLASS1_ALG:
-		PRINT("class1-op ");
+		PRINT("cls1-op ");
 		decode_class12_op(cmd);
 		break;
 
 	case OP_TYPE_CLASS2_ALG:
-		PRINT("class2-op ");
+		PRINT("cls2-op ");
 		decode_class12_op(cmd);
 		break;
 
 	case OP_TYPE_DECAP_PROTOCOL:
-		PRINT("decap-pcl ");
+		PRINT("decap ");
 		decode_bidir_pcl_op(cmd);
 		break;
 
 	case OP_TYPE_ENCAP_PROTOCOL:
-		PRINT("encap-pcl ");
+		PRINT("encap ");
 		decode_bidir_pcl_op(cmd);
 		break;
 	}
@@ -1879,119 +1365,79 @@ static void show_op(u_int32_t *cmd, u_int8_t *idx)
 	(*idx)++;
 }
 
-static void show_signature(u_int32_t *cmd, u_int8_t *idx)
+static void show_signature(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT(" signature: ");
-	PRINT("\n");
+	PRINT(" signature: %s\n",
+	      sig_type[(*cmd & SIGN_TYPE_MASK) >> SIGN_TYPE_SHIFT]);
 	(*idx)++;
+
+	/* Process 8 word signature */
+	desc_hexdump(cmd + 1, 8, 4, leader);
+	idx += 8;
 }
 
-static void show_jump(u_int32_t *cmd, u_int8_t *idx)
+static void show_jump(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
-	PRINT("      jump: ");
-	switch (*cmd & CLASS_MASK) {
-	case CLASS_NONE:
-		break;
-
-	case CLASS_1:
-		PRINT("class-1 ");
-		break;
-
-	case CLASS_2:
-		PRINT("class-2 ");
-		break;
-
-	case CLASS_BOTH:
-		PRINT("class-both ");
-		break;
-	}
-
-
-	switch (*cmd & JUMP_TYPE_MASK) {
-	case JUMP_TYPE_LOCAL:
-		PRINT("local");
-		break;
-
-	case JUMP_TYPE_NONLOCAL:
-		PRINT("nonlocal");
-		break;
+	u_int32_t cond;
+	int8_t relidx, offset;
 
-	case JUMP_TYPE_HALT:
-		PRINT("halt");
-		break;
-
-	case JUMP_TYPE_HALT_USER:
-		PRINT("halt-user");
-		break;
-	}
-
-	switch (*cmd & JUMP_TEST_MASK) {
-	case JUMP_TEST_ALL:
-		PRINT(" all");
-		break;
-
-	case JUMP_TEST_INVALL:
-		PRINT(" !all");
-		break;
-
-	case JUMP_TEST_ANY:
-		PRINT(" any");
-		break;
-
-	case JUMP_TEST_INVANY:
-		PRINT(" !any");
-		break;
-	}
+	PRINT("      jump: %s %s %s",
+	      fifoldst_class[(*cmd & CLASS_MASK) >> CLASS_SHIFT],
+	      jump_types[(*cmd & JUMP_TYPE_MASK) >> JUMP_TYPE_SHIFT],
+	      jump_tests[(*cmd & JUMP_TEST_MASK) >> JUMP_TEST_SHIFT]);
 
+	cond = (*cmd & (JUMP_COND_MASK & ~JUMP_JSL));
 	if (!(*cmd & JUMP_JSL)) {
-		if (*cmd & JUMP_COND_PK_0)
+		if (cond & JUMP_COND_PK_0)
 			PRINT(" pk-0");
 
-		if (*cmd & JUMP_COND_PK_GCD_1)
+		if (cond & JUMP_COND_PK_GCD_1)
 			PRINT(" pk-gcd=1");
 
-		if (*cmd & JUMP_COND_PK_PRIME)
+		if (cond & JUMP_COND_PK_PRIME)
 			PRINT(" pk-prime");
 
-		if (*cmd & JUMP_COND_MATH_N)
+		if (cond & JUMP_COND_MATH_N)
 			PRINT(" math-n");
 
-		if (*cmd & JUMP_COND_MATH_Z)
+		if (cond & JUMP_COND_MATH_Z)
 			PRINT(" math-z");
 
-		if (*cmd & JUMP_COND_MATH_C)
+		if (cond & JUMP_COND_MATH_C)
 			PRINT(" math-c");
 
-		if (*cmd & JUMP_COND_MATH_NV)
+		if (cond & JUMP_COND_MATH_NV)
 			PRINT(" math-nv");
 	} else {
-		if (*cmd & JUMP_COND_JQP)
+		if (cond & JUMP_COND_JQP)
 			PRINT(" jq-pend");
 
-		if (*cmd & JUMP_COND_SHRD)
+		if (cond & JUMP_COND_SHRD)
 			PRINT(" share-skip");
 
-		if (*cmd & JUMP_COND_SELF)
+		if (cond & JUMP_COND_SELF)
 			PRINT(" share-ctx");
 
-		if (*cmd & JUMP_COND_CALM)
+		if (cond & JUMP_COND_CALM)
 			PRINT(" complete");
 
-		if (*cmd & JUMP_COND_NIP)
+		if (cond & JUMP_COND_NIP)
 			PRINT(" no-input");
 
-		if (*cmd & JUMP_COND_NIFP)
+		if (cond & JUMP_COND_NIFP)
 			PRINT(" no-infifo");
 
-		if (*cmd & JUMP_COND_NOP)
+		if (cond & JUMP_COND_NOP)
 			PRINT(" no-output");
 
-		if (*cmd & JUMP_COND_NCP)
+		if (cond & JUMP_COND_NCP)
 			PRINT(" no-ctxld");
 	}
 
+	relidx = *idx; /* sign extend index to compute relative instruction */
+	offset = *cmd & JUMP_OFFSET_MASK;
 	if ((*cmd & JUMP_TYPE_MASK) == JUMP_TYPE_LOCAL) {
-		PRINT(" ->offset=%d\n", (*cmd & JUMP_OFFSET_MASK));
+		PRINT(" ->%d [%02d]\n", offset, relidx + offset);
 		(*idx)++;
 	} else {
 		PRINT(" ->@0x%08x\n", (*idx + 1));
@@ -1999,14 +1445,20 @@ static void show_jump(u_int32_t *cmd, u_int8_t *idx)
 	}
 }
 
-static void show_math(u_int32_t *cmd, u_int8_t *idx)
+static void show_math(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	u_int32_t mathlen, *mathdata;
 
 	mathlen  = *cmd & MATH_LEN_MASK;
 	mathdata = cmd + 1;
 
-	PRINT("      math: ");
+	PRINT("      math: %s.%s.%s->%s len=%d ",
+	      math_src0[(*cmd & MATH_SRC0_MASK) >> MATH_SRC0_SHIFT],
+	      math_fun[(*cmd & MATH_FUN_MASK) >> MATH_FUN_SHIFT],
+	      math_src1[(*cmd & MATH_SRC1_MASK) >> MATH_SRC1_SHIFT],
+	      math_dest[(*cmd & MATH_DEST_MASK) >> MATH_DEST_SHIFT],
+	      mathlen);
+
 	if (*cmd & MATH_IFB)
 		PRINT("imm4 ");
 	if (*cmd & MATH_NFU)
@@ -2014,186 +1466,23 @@ static void show_math(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & MATH_STL)
 		PRINT("stall ");
 
-	PRINT("fun=");
-	switch (*cmd & MATH_FUN_MASK) {
-	case MATH_FUN_ADD:
-		PRINT("add");
-		break;
-
-	case MATH_FUN_ADDC:
-		PRINT("addc");
-		break;
-
-	case MATH_FUN_SUB:
-		PRINT("sub");
-		break;
-
-	case MATH_FUN_SUBB:
-		PRINT("subc");
-		break;
-
-	case MATH_FUN_OR:
-		PRINT("or");
-		break;
-
-	case MATH_FUN_AND:
-		PRINT("and");
-		break;
-
-	case MATH_FUN_XOR:
-		PRINT("xor");
-		break;
-
-	case MATH_FUN_LSHIFT:
-		PRINT("lsh");
-		break;
-
-	case MATH_FUN_RSHIFT:
-		PRINT("rsh");
-		break;
-
-	case MATH_FUN_SHLD:
-		PRINT("shld");
-		break;
-	}
-
-
-	PRINT(" src0=");
-	switch (*cmd & MATH_SRC0_MASK) {
-	case MATH_SRC0_REG0:
-		PRINT("r0");
-		break;
-
-	case MATH_SRC0_REG1:
-		PRINT("r1");
-		break;
-
-	case MATH_SRC0_REG2:
-		PRINT("r2");
-		break;
-
-	case MATH_SRC0_REG3:
-		PRINT("r3");
-		break;
-
-	case MATH_SRC0_IMM:
-		PRINT("imm");
-		break;
-
-	case MATH_SRC0_SEQINLEN:
-		PRINT("seqinlen");
-		break;
-
-	case MATH_SRC0_SEQOUTLEN:
-		PRINT("seqoutlen");
-		break;
-
-	case MATH_SRC0_VARSEQINLEN:
-		PRINT("vseqinlen");
-		break;
-
-	case MATH_SRC0_VARSEQOUTLEN:
-		PRINT("vseqoutlen");
-		break;
-
-	case MATH_SRC0_ZERO:
-		PRINT("0");
-		break;
-	};
-
-	PRINT(" src1=");
-	switch (*cmd & MATH_SRC1_MASK) {
-	case MATH_SRC1_REG0:
-		PRINT("r0");
-		break;
-
-	case MATH_SRC1_REG1:
-		PRINT("r1");
-		break;
-
-	case MATH_SRC1_REG2:
-		PRINT("r2");
-		break;
-
-	case MATH_SRC1_REG3:
-		PRINT("r3");
-		break;
-
-	case MATH_SRC1_IMM:
-		PRINT("imm");
-		break;
-
-	case MATH_SRC1_INFIFO:
-		PRINT("infifo");
-		break;
-
-	case MATH_SRC1_OUTFIFO:
-		PRINT("outfifo");
-		break;
-
-	case MATH_SRC1_ONE:
-		PRINT("1");
-		break;
-
-	};
-
-	PRINT(" dest=");
-	switch (*cmd & MATH_DEST_MASK) {
-	case MATH_DEST_REG0:
-		PRINT("r0");
-		break;
-
-	case MATH_DEST_REG1:
-		PRINT("r1");
-		break;
-
-	case MATH_DEST_REG2:
-		PRINT("r2");
-		break;
-
-	case MATH_DEST_REG3:
-		PRINT("r3");
-		break;
-
-	case MATH_DEST_SEQINLEN:
-		PRINT("seqinlen");
-		break;
-
-	case MATH_DEST_SEQOUTLEN:
-		PRINT("seqoutlen");
-		break;
-
-	case MATH_DEST_VARSEQINLEN:
-		PRINT("vseqinlen");
-		break;
-
-	case MATH_DEST_VARSEQOUTLEN:
-		PRINT("vseqoutlen");
-		break;
-
-	case MATH_DEST_NONE:
-		PRINT("none");
-		break;
-	};
-
-	PRINT(" len=%d\n", mathlen);
-
+	PRINT("\n");
 	(*idx)++;
 
 	if  (((*cmd & MATH_SRC0_MASK) == MATH_SRC0_IMM) ||
 	     ((*cmd & MATH_SRC1_MASK) == MATH_SRC1_IMM)) {
-		desc_hexdump(cmd + 1, 1, 4, (int8_t *)"            ");
+		desc_hexdump(cmd + 1, 1, 4, leader);
 		(*idx)++;
 	};
 };
 
-static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	PRINT("  seqinptr:");
 	if (*cmd & SQIN_RBS)
-		PRINT(" release buf");
+		PRINT(" rls-buf");
 	if (*cmd & SQIN_INL)
-		PRINT(" inline");
+		PRINT(" imm");
 	if (*cmd & SQIN_SGF)
 		PRINT(" s/g");
 	if (*cmd & SQIN_PRE) {
@@ -2205,18 +1494,18 @@ static void show_seq_in_ptr(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & SQIN_EXT)
 		PRINT(" EXT");
 	else
-		PRINT(" len=%d", *cmd & 0xffff);
+		PRINT(" %d", *cmd & 0xffff);
 	if (*cmd & SQIN_RTO)
 		PRINT(" RTO");
 	PRINT("\n");
 	(*idx)++;
 }
 
-static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx)
+static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
 {
 	PRINT(" seqoutptr:");
 	if (*cmd & SQOUT_SGF)
-		PRINT(" scatter-gather");
+		PRINT(" s/g");
 	if (*cmd & SQOUT_PRE) {
 		PRINT(" PRE");
 	} else {
@@ -2226,58 +1515,152 @@ static void show_seq_out_ptr(u_int32_t *cmd, u_int8_t *idx)
 	if (*cmd & SQOUT_EXT)
 		PRINT(" EXT");
 	else
-		PRINT(" len=%d", *cmd & 0xffff);
+		PRINT(" %d", *cmd & 0xffff);
 	PRINT("\n");
 	(*idx)++;
 }
 
+static void show_illegal_inst(u_int32_t *cmd, u_int8_t *idx, int8_t *leader)
+{
+	PRINT("<illegal-instruction>\n");
+	(*idx)++;
+}
+
+/* Handlers for each instruction based on CTYPE as an enumeration */
+static void (*inst_disasm_handler[])(u_int32_t *, u_int8_t *, int8_t *) = {
+	show_key,
+	show_seq_key,
+	show_load,
+	show_seq_load,
+	show_fifo_load,
+	show_seq_fifo_load,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_store,
+	show_seq_store,
+	show_fifo_store,
+	show_seq_fifo_store,
+	show_illegal_inst,
+	show_move,
+	show_op,
+	show_illegal_inst,
+	show_signature,
+	show_illegal_inst,
+	show_jump,
+	show_math,
+	show_illegal_inst, /* header */
+	show_illegal_inst, /* shared header */
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_illegal_inst,
+	show_seq_in_ptr,
+	show_seq_out_ptr,
+};
+
 /**
  * caam_desc_disasm() - Top-level descriptor disassembler
  * @desc - points to the descriptor to disassemble. First command
- *         must be a header, or shared header, and the overall size
- *         is determined by this. Does not handle a QI preheader as
- *         it's first command, and cannot yet follow links in a list
- *         of descriptors
+ *	   must be a header, or shared header, and the overall size
+ *	   is determined by this. Does not handle a QI preheader as
+ *	   it's first command, and cannot yet follow links in a list
+ *	   of descriptors
+ * @opts - selects options for output:
+ *	   DISASM_SHOW_OFFSETS - displays the index/offset of each
+ *				 instruction in the descriptor. Helpful
+ *				 for visualizing flow control changes
+ *         DISASM_SHOW_RAW     - displays value of each instruction
  **/
-void caam_desc_disasm(u_int32_t *desc)
+void caam_desc_disasm(u_int32_t *desc, u_int32_t opts)
 {
-	u_int8_t   len, idx, stidx;
+	u_int8_t len, idx, stidx;
+	int8_t emptyleader[MAX_LEADER_LEN], pdbleader[MAX_LEADER_LEN];
 
 	stidx  = 0;
 
 	/*
-	 * First word must be header or shared header, or we're done
+	 * Build up padded leader strings for non-instruction content
+	 * These get used for pointer and PDB content dumps
+	 */
+	emptyleader[0] = 0;
+	pdbleader[0] = 0;
+
+	/* Offset leader is a 5-char string, e.g. "[xx] " */
+	if (opts & DISASM_SHOW_OFFSETS) {
+		strcat((char *)emptyleader, "     ");
+		strcat((char *)pdbleader, "     ");
+	}
+
+	/* Raw instruction leader is an 11-char string, e.g. "0xnnnnnnnn " */
+	if (opts & DISASM_SHOW_RAW) {
+		strcat((char *)emptyleader, "           ");
+		strcat((char *)pdbleader, "           ");
+	}
+
+	/* Finish out leaders. Instruction names use a 12-char space */
+	strcat((char *)emptyleader, "            ");
+	strcat((char *)pdbleader, "     (pdb): ");
+
+	/*
+	 * Now examine our descriptor, starting with it's header.
+	 * First word must be header or shared header, or we quit
+	 * under the assumption that a bad desc pointer was passed.
 	 * If we have a valid header, save off indices and size for
 	 * determining descriptor area boundaries
 	 */
 	switch (*desc & CMD_MASK) {
 	case CMD_SHARED_DESC_HDR:
+		if (opts & DISASM_SHOW_OFFSETS)
+			PRINT("[%02d] ", 0);
+		if (opts & DISASM_SHOW_RAW)
+			PRINT("0x%08x ", desc[0]);
+		show_shrhdr(desc);
 		len   = *desc & HDR_DESCLEN_SHR_MASK;
-		/* if shared, stidx becomes size of PDB space */
 		stidx = (*desc >> HDR_START_IDX_SHIFT) &
 			HDR_START_IDX_MASK;
-		show_shrhdr(desc);
+
+		if (stidx == 0)
+			stidx++;
+
 		/*
 		 * Show PDB area (that between header and startindex)
 		 * Improve PDB content dumps later...
 		 */
-		desc_hexdump(&desc[1], stidx - 1, 4, (int8_t *)"     (pdb): ");
+		if (stidx > 1) /* >1 means real PDB data exists */
+			desc_hexdump(&desc[1], stidx - 1, 4,
+				     (int8_t *)pdbleader);
+
 		idx = stidx;
 		break;
 
 	case CMD_DESC_HDR:
+		if (opts & DISASM_SHOW_OFFSETS)
+			PRINT("[%02d] ", 0);
+		if (opts & DISASM_SHOW_RAW)
+			PRINT("0x%08x ", desc[0]);
+		show_hdr(desc);
 		len   = *desc & HDR_DESCLEN_MASK;
-		/* if std header, stidx is size of sharedesc */
 		stidx = (*desc >> HDR_START_IDX_SHIFT) &
 			HDR_START_IDX_MASK;
 
-		show_hdr(desc);
-		idx = 1; /* next instruction past header */
+		/* Start index of 0 really just means 1, so fix */
+		if (stidx == 0)
+			stidx++;
 
+		/* Skip sharedesc pointer if SHARED, else display PDB */
 		if (*desc & HDR_SHARED) {
 			stidx = 2; /* just skip past sharedesc ptr */
-			PRINT("            sharedesc->0x%08x\n", desc[1]);
-		}
+			PRINT("%s sharedesc->0x%08x\n", emptyleader, desc[1]);
+		} else
+			if (stidx > 1) /* >1 means real PDB data exists */
+				desc_hexdump(&desc[1], stidx - 1, 4,
+					     (int8_t *)pdbleader);
+
+		idx = stidx;
 		break;
 
 	default:
@@ -2286,87 +1669,14 @@ void caam_desc_disasm(u_int32_t *desc)
 		return;
 	}
 
-
-	/*
-	 * Now go process remaining commands in sequence
-	 */
-
-
+	/* Header verified, now process sequential instructions */
 	while (idx < len) {
-		switch (desc[idx] & CMD_MASK) {
-		case CMD_KEY:
-			show_key(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_KEY:
-			show_seq_key(&desc[idx], &idx);
-			break;
-
-		case CMD_LOAD:
-			show_load(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_LOAD:
-			show_seq_load(&desc[idx], &idx);
-			break;
-
-		case CMD_FIFO_LOAD:
-			show_fifo_load(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_FIFO_LOAD:
-			show_seq_fifo_load(&desc[idx], &idx);
-			break;
-
-		case CMD_STORE:
-			show_store(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_STORE:
-			show_seq_store(&desc[idx], &idx);
-			break;
-
-		case CMD_FIFO_STORE:
-			show_fifo_store(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_FIFO_STORE:
-			show_seq_fifo_store(&desc[idx], &idx);
-			break;
-
-		case CMD_MOVE:
-			show_move(&desc[idx], &idx);
-			break;
-
-		case CMD_OPERATION:
-			show_op(&desc[idx], &idx);
-			break;
-
-		case CMD_SIGNATURE:
-			show_signature(&desc[idx], &idx);
-			break;
-
-		case CMD_JUMP:
-			show_jump(&desc[idx], &idx);
-			break;
-
-		case CMD_MATH:
-			show_math(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_IN_PTR:
-			show_seq_in_ptr(&desc[idx], &idx);
-			break;
-
-		case CMD_SEQ_OUT_PTR:
-			show_seq_out_ptr(&desc[idx], &idx);
-			break;
-
-		default:
-			PRINT("<unrecognized command>: 0x%08x\n",
-			      desc[idx++]);
-			break;
-		}
+		if (opts & DISASM_SHOW_OFFSETS)
+			PRINT("[%02d] ", idx);
+		if (opts & DISASM_SHOW_RAW)
+			PRINT("0x%08x ", desc[idx]);
+		inst_disasm_handler[(desc[idx] & CMD_MASK) >> CMD_SHIFT]
+				    (&desc[idx], &idx, emptyleader);
 	}
 }
 EXPORT_SYMBOL(caam_desc_disasm);
diff --git a/drivers/crypto/caam/dcl/jobdesc.c b/drivers/crypto/caam/dcl/jobdesc.c
index 28939d2..69affcb 100644
--- a/drivers/crypto/caam/dcl/jobdesc.c
+++ b/drivers/crypto/caam/dcl/jobdesc.c
@@ -36,6 +36,8 @@
 #include "../compat.h"
 #include "dcl.h"
 
+/* Sizes for MDHA pads (*not* keys): MD5, SHA1, 224, 256, 384, 512 */
+static const u_int8_t mdpadlen[] = { 16, 20, 32, 32, 64, 64 };
 
 /**
  * cnstr_seq_jobdesc() - Construct simple sequence job descriptor
@@ -94,10 +96,7 @@ int cnstr_seq_jobdesc(u_int32_t *jobdesc, u_int16_t *jobdescsz,
 
 	return 0;
 }
-
-
-
-
+EXPORT_SYMBOL(cnstr_seq_jobdesc);
 
 /**
  * Construct a blockcipher request as a single job
@@ -115,7 +114,6 @@ int cnstr_seq_jobdesc(u_int32_t *jobdesc, u_int16_t *jobdescsz,
  * @cipher - algorithm from OP_ALG_ALGSEL_
  * @clear - clear descriptor buffer before construction
  **/
-
 int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
 				u_int8_t *data_in, u_int8_t *data_out,
 				u_int32_t datasz,
@@ -173,18 +171,16 @@ int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
 					    FIFOLDST_VLF,
 					    FIFOST_TYPE_MESSAGE_DATA, 0);
 
-
 	/* Now update the header with size/offsets */
 	endidx = descbuf - start;
-	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
 		       ORDER_FORWARD, DESC_STD);
 
 	*bufsz = endidx;
 
 	return 0;
 }
-
-
+EXPORT_SYMBOL(cnstr_jobdesc_blkcipher_cbc);
 
 /**
  * HMAC as a single job
@@ -198,7 +194,6 @@ int cnstr_jobdesc_blkcipher_cbc(u_int32_t *descbuf, u_int16_t *bufsz,
  * @icv     - HMAC comparison for ICV, NULL if no check desired
  * @clear   - clear buffer before writing
  **/
-
 int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 			   u_int8_t *msg, u_int32_t msgsz, u_int8_t *digest,
 			   u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
@@ -246,7 +241,6 @@ int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 	else
 		opicv = ICV_CHECK_OFF;
 
-
 	startidx = descbuf - start;
 
 	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
@@ -267,7 +261,7 @@ int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 				   ITEM_REFERENCE);
 
 	endidx = descbuf - start;
-	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
 		       ORDER_FORWARD, DESC_STD);
 
 	*bufsize = endidx;
@@ -277,6 +271,273 @@ int32_t cnstr_jobdesc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 EXPORT_SYMBOL(cnstr_jobdesc_hmac);
 
 /**
+ * Generate an MDHA split key - cnstr_jobdesc_mdsplitkey()
+ *
+ * @descbuf - pointer to buffer to hold constructed descriptor
+ *
+ * @bufsiz - pointer to size of descriptor once constructed
+ *
+ * @key - HMAC key to generate ipad/opad from. Size is determined
+ *        by cipher. Note that SHA224/384 pads are not truncated.
+ *
+ *                              keysize  splitsize  buffersize
+ *        ----------------------------------------------------
+ *	  - OP_ALG_ALGSEL_MD5    = 16        32         32
+ *	  - OP_ALG_ALGSEL_SHA1   = 20        40         48
+ *	  - OP_ALG_ALGSEL_SHA224 = 28        64         64
+ *	  - OP_ALG_ALGSEL_SHA256 = 32        64         64
+ *	  - OP_ALG_ALGSEL_SHA384 = 48       128        128
+ *	  - OP_ALG_ALGSEL_SHA512 = 64       128        128
+ *
+ * @cipher - HMAC algorithm selection, one of OP_ALG_ALGSEL_
+ *
+ * @padbuf - buffer to store generated ipad/opad. Should be 2x
+ *           the (untruncated) HMAC keysize for chosen cipher
+ *           rounded up to the nearest 16-byte boundary
+ *           (16 bytes = AES blocksize). See the table under "key"
+ *           above.
+ **/
+int cnstr_jobdesc_mdsplitkey(u_int32_t *descbuf, u_int16_t *bufsize,
+			     u_int8_t *key, u_int32_t cipher,
+			     u_int8_t *padbuf)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int8_t keylen, storelen;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	/* Pick key length from cipher submask as an enum */
+	keylen = mdpadlen[(cipher & OP_ALG_ALGSEL_SUBMASK) >>
+			  OP_ALG_ALGSEL_SHIFT];
+
+	storelen = keylen * 2;
+
+	/* Load the HMAC key */
+	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS2);
+
+	/*
+	 * Select HMAC op with init only, this sets up key unroll
+	 * Have DECRYPT selected here, although MDHA doesn't care
+	 */
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG, cipher,
+				    OP_ALG_AAI_HMAC, MDSTATE_INIT,
+				    ICV_CHECK_OFF, DIR_DECRYPT);
+
+	/* FIFO load of 0 to kickstart MDHA (this will generate pads) */
+	descbuf = cmd_insert_fifo_load(descbuf, NULL, 0, LDST_CLASS_2_CCB,
+				       0, FIFOLD_IMM, 0,
+				       (FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST2));
+
+	/* Wait for store to complete before proceeding */
+	/* This is a tapeout1 dependency */
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_2,
+				  JUMP_TEST_ALL, 0,
+				  1, NULL);
+
+	/* Now store the split key pair with that specific type */
+	descbuf = cmd_insert_fifo_store(descbuf, padbuf, storelen,
+					LDST_CLASS_2_CCB, 0, 0, 0,
+					FIFOST_TYPE_SPLIT_KEK);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_jobdesc_mdsplitkey);
+
+/**
+ * Constructs an AES-GCM job descriptor - cnstr_jobdesc_aes_gcm()
+ *
+ * @descbuf - pointer to buffer that will hold constructed descriptor
+ * @bufsize - pointer to size of descriptor once constructed
+ * @key - pointer to AES key
+ * @keylen - AES key size
+ * @ctx - pointer to GCM context. This is a concatenation of:
+ *        - MAC (128 bits)
+ *        - Yi (128 bits)
+ *        - Y0 (128 bits)
+ *        - IV (64 bits)
+ *        - Text bitsize (64 bits)
+ *        See the AESA section of the blockguide for more information
+ * @mdstate - select MDSTATE_UPDATE, MDSTATE_INIT, or MDSTATE_FINAL if a
+ *            partial MAC operation is desired, else select MDSTATE_COMPLETE
+ * @icv - select ICV_CHECK_ON if an ICV mac compare is requested
+ * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed for the cipher operation
+ * @in - pointer to input text buffer
+ * @out - pointer to output text buffer
+ * @size - size of data to be processed
+ * @mac - pointer to output MAC. This can point to the head of CTX if an
+ *        updated MAC is required for subsequent operations
+ **/
+int cnstr_jobdesc_aes_gcm(u_int32_t *descbuf, u_int16_t *bufsize,
+			  u_int8_t *key, u_int32_t keylen, u_int8_t *ctx,
+			  enum mdstatesel mdstate, enum icvsel icv,
+			  enum algdir dir, u_int8_t *in, u_int8_t *out,
+			  u_int16_t size, u_int8_t *mac)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen * 8, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+			     OP_ALG_ALGSEL_AES, OP_ALG_AAI_GCM,
+			     mdstate, icv, dir);
+
+	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB, 0,
+				  LDST_SRCDST_BYTE_CONTEXT, 0, 64,
+				  ITEM_REFERENCE);
+
+	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
+				       0, 0, 0,
+				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
+
+	descbuf = cmd_insert_fifo_store(descbuf, out, size, FIFOLD_CLASS_SKIP,
+					0, 0, 0, FIFOST_TYPE_MESSAGE_DATA);
+
+	descbuf = cmd_insert_store(descbuf, mac, LDST_CLASS_1_CCB, 0,
+				   LDST_SRCDST_BYTE_CONTEXT, 0, 64,
+				   ITEM_REFERENCE);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_jobdesc_aes_gcm);
+
+/**
+ * Generate a Kasumi f8 job descriptor - cnstr_jobdesc_kasumi_f8()
+ *
+ * @descbuf - pointer to buffer that will hold constructed descriptor
+ * @bufsize - pointer to size of descriptor once constructed
+ * @key - pointer to KFHA cipher key
+ * @keylen - cipher key length
+ * @dir - select DIR_ENCRYPT or DIR_DECRYPT as needed
+ * @ctx - points to preformatted f8 context block, containing 32-bit count
+ *        (word 0), bearer (word 1 bits 0:5), direction (word 1 bit 6),
+ *        ca (word 1 bits 7:16), and cb (word 1 bits 17:31). Refer to the
+ *        KFHA section of the block guide for more detail.
+ * @in - pointer to input data text
+ * @out - pointer to output data text
+ * @size - size of data to be processed
+ **/
+int cnstr_jobdesc_kasumi_f8(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t *ctx,
+			    u_int8_t *in, u_int8_t *out, u_int16_t size)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 8,
+				  ITEM_REFERENCE);
+
+	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
+				       0, 0, 0,
+				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
+
+	descbuf = cmd_insert_fifo_store(descbuf, out, size, FIFOLD_CLASS_SKIP,
+					0, 0, 0, FIFOST_TYPE_MESSAGE_DATA);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_jobdesc_kasumi_f8);
+
+/**
+ * Generate a Kasumi f9 (authentication) job descriptor -
+ * cnstr_jobdesc_kasumi_f9()
+ *
+ * @descbuf - pointer to buffer that will hold constructed descriptor
+ * @bufsize - pointer to size of descriptor once constructed
+ * @key - pointer to cipher key
+ * @keylen - size of cipher key
+ * @dir - select DIR_DECRYPT and DIR_ENCRYPT
+ * @ctx - points to preformatted f8 context block, containzing 32-bit count
+ *        (word 0), bearer (word 1 bits 0:5), direction (word 1 bit 6),
+ *        ca (word 1 bits 7:16), cb (word 1 bits 17:31), fresh (word 2),
+ *        and the ICV input (word 3). Refer to the KFHA section of the
+ *        block guide for more detail.
+ * @in - pointer to input data
+ * @size - size of input data
+ * @mac - pointer to output MAC
+ **/
+int cnstr_jobdesc_kasumi_f9(u_int32_t *descbuf, u_int16_t *bufsize,
+			    u_int8_t *key, u_int32_t keylen,
+			    enum algdir dir, u_int32_t *ctx,
+			    u_int8_t *in, u_int16_t size, u_int8_t *mac)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+
+	start = descbuf++;
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_key(descbuf, key, keylen, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F9,
+				    MDSTATE_COMPLETE, ICV_CHECK_OFF, dir);
+
+	descbuf = cmd_insert_load(descbuf, ctx, LDST_CLASS_1_CCB,
+				  0, LDST_SRCDST_BYTE_CONTEXT, 0, 16,
+				  ITEM_REFERENCE);
+
+	descbuf = cmd_insert_fifo_load(descbuf, in, size, LDST_CLASS_1_CCB,
+				       0, 0, 0,
+				       FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);
+
+	descbuf = cmd_insert_store(descbuf, mac, LDST_CLASS_1_CCB, 0,
+				   LDST_SRCDST_BYTE_CONTEXT, 0, 4,
+				   ITEM_REFERENCE);
+
+	endidx = descbuf - start;
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
+		       ORDER_FORWARD, DESC_STD);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_jobdesc_kasumi_f9);
+
+/**
  * RSA exponentiation as a single job - cnstr_jobdesc_pkha_rsaexp()
  *
  * @descbuf - pointer to buffer to hold descriptor
@@ -287,7 +548,6 @@ EXPORT_SYMBOL(cnstr_jobdesc_hmac);
  * @clear - nonzero if descriptor buffer space is to be cleared
  *          before construction
  **/
-
 int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
 			      struct pk_in_params *pkin,
 			      u_int8_t *out, u_int32_t out_siz,
@@ -328,17 +588,17 @@ int cnstr_jobdesc_pkha_rsaexp(u_int32_t *descbuf, u_int16_t *bufsz,
 					FIFOST_TYPE_PKHA_B);
 
 	endidx = descbuf - start;
-	cmd_insert_hdr(start, 0, endidx, SHR_NEVER, SHRNXT_LENGTH,
+	cmd_insert_hdr(start, 1, endidx, SHR_NEVER, SHRNXT_LENGTH,
 		       ORDER_FORWARD, DESC_STD);
 
 	*bufsz = endidx;
 	return 0;
 }
+EXPORT_SYMBOL(cnstr_jobdesc_pkha_rsaexp);
 
 /* FIXME: clear-written reg content should perhaps be defined in desc.h */
 static const u_int32_t clrw_imm = 0x00210000;
 
-
 /**
  * Binary DSA-verify as a single job - cnstr_jobdesc_dsaverify()
  *
@@ -349,20 +609,20 @@ static const u_int32_t clrw_imm = 0x00210000;
  * @msg_sz - size of message to verify
  * @clear - clear buffer before writing descriptor
  **/
-
 int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
-			    struct dsa_pdb *dsadata, u_int8_t *msg,
+			    struct dsa_verify_pdb *dsadata, u_int8_t *msg,
 			    u_int32_t msg_sz, u_int8_t clear)
 {
 	u_int32_t *start;
 	u_int16_t startidx, endidx;
 
-	start = descbuf++;
-	startidx = descbuf - start;
+	start = descbuf;
 
-	/* Build 9-word PDB with pointers to params */
-	memcpy(descbuf, dsadata, 9 * sizeof(u_int32_t));
-	descbuf += 9;
+	/* Build PDB with pointers to params */
+	memcpy(descbuf, dsadata, sizeof(struct dsa_verify_pdb));
+	descbuf += sizeof(struct dsa_verify_pdb) >> 2;
+
+	startidx = descbuf - start;
 
 	/* SHA1 hash command */
 	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS2_ALG,
@@ -380,8 +640,8 @@ int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
 			    LDST_SRCDST_BYTE_CONTEXT, 0, 20, ITEM_REFERENCE);
 
 	/* Wait for CALM */
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
-				  JUMP_COND_CALM, 1, NULL);
+	descbuf = cmd_insert_jump(descbuf, CLASS_2, JUMP_TYPE_LOCAL,
+				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
 
 	/* LOAD immediate to clear-written register */
 	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&clrw_imm, CLASS_NONE,
@@ -395,10 +655,12 @@ int cnstr_jobdesc_dsaverify(u_int32_t *descbuf, u_int16_t *bufsz,
 					     OP_PCL_PKPROT_F2M);
 
 	/* Header, factor in PDB offset */
-	endidx = descbuf - start;
+	endidx = descbuf - start + 1;
 	cmd_insert_hdr(start, startidx, endidx, SHR_NEVER, SHRNXT_LENGTH,
 		       ORDER_FORWARD, DESC_STD);
 
 	*bufsz = endidx;
 	return 0;
 }
+EXPORT_SYMBOL(cnstr_jobdesc_dsaverify);
+
diff --git a/drivers/crypto/caam/dcl/protoshared.c b/drivers/crypto/caam/dcl/protoshared.c
index 70230cc..6755331 100644
--- a/drivers/crypto/caam/dcl/protoshared.c
+++ b/drivers/crypto/caam/dcl/protoshared.c
@@ -309,7 +309,6 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
 		}
 	}
 
-
 	/* Save current location for computing start index */
 	startidx = descbuf - start;
 
@@ -326,7 +325,6 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
 				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				 ITEM_INLINE, ITEM_CLASS1);
 
-
 	/* Now insert the operation command */
 	descbuf = cmd_insert_proto_op_ipsec(descbuf,
 					    cipherdata->algtype,
@@ -348,105 +346,249 @@ int32_t cnstr_pcl_shdsc_ipsec_cbc_encap(u_int32_t           *descbuf,
 EXPORT_SYMBOL(cnstr_pcl_shdsc_ipsec_cbc_encap);
 
 /**
- * 802.16 WiMAX encapsulation
+ * Construct IPSec ESP encapsulation protocol-level sharedesc
+ * Requires a covered MDHA splitkey.
  *
- * @descbuf - Pointer to descriptor build buffer
+ * Inputs:
+ * @descbuf - pointer to buffer used for descriptor construction
  *
- * @bufsize - Pointer to value to write size of built descriptor to
+ * @bufsize - pointer to size to be written back upon completion
  *
- * @pdb.framecheck - nonzero if frame check word to be included
- * @pdb.nonce - Nonce to use
- * @pdb.b0_flags - B0 flags
- * @pdb.ctr_flags - CTR flags
- * @pdb.PN - PN value
+ * @pdb - pointer to the PDB to be used with this descriptor. This
+ *       structure will be copied inline to the descriptor under
+ *       construction. No error checking will be made. Refer to the
+ *       block guide for a detailed discussion of the decapsulation
+ *       PDB, and it's unioned sub structure that is cipher-dependent
  *
- * @cipherdata.keylen - key size in bytes
- * @cipherdata.key - key data to inline
+ * @opthdr - Optional header to be prepended to an encapsulated frame.
+ *           Size of the optional header is defined in pdb.opt_hdr_len
  *
- * @mode - nonzero for OFDMa, else OFDM
+ * @cipherdata - Pointer to blockcipher transform definitions.
  *
- * @clear - nonzero clears descriptor buffer
+ * @authdata - Pointer to authentication transform definitions. Note
+ *             that since a split key is to be used, the size of the
+ *             split key itself is specified (even though the buffer
+ *             containing the key may have additional padding depending
+ *             on the size).
+ **/
+int32_t cnstr_shdsc_ipsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				    struct ipsec_encap_pdb *pdb,
+				    u_int8_t *opthdr,
+				    struct cipherparams *cipherdata,
+				    struct authparams *authdata)
+{
+	u_int32_t *start, *keyjump, opthdrsz;
+	u_int16_t startidx, endidx;
+
+	start = descbuf;
+
+	/* Compute optional header size, rounded up to descriptor word size */
+	opthdrsz = (pdb->ip_hdr_len + 3) & ~3;
+
+	/* copy in core of PDB */
+	memcpy(descbuf, pdb, sizeof(struct ipsec_encap_pdb));
+	descbuf += sizeof(struct ipsec_encap_pdb) >> 2;
+
+	/*
+	 * If optional header, compute optional header size
+	 * rounded up to descriptor word size, and copy in
+	 */
+	if (pdb->ip_hdr_len) {
+		opthdrsz = (pdb->ip_hdr_len + 3) & ~3;
+		memcpy(descbuf, opthdr, opthdrsz);
+		descbuf += opthdrsz >> 2;
+	}
+
+	startidx = descbuf - start;
+
+	/*
+	 * Insert an empty instruction for a shared-JUMP past the keys
+	 * Update later, once the size of the key block is known
+	 */
+	keyjump = descbuf++;
+
+	/* Insert keys */
+	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
+				 PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
+				 ITEM_REFERENCE, ITEM_CLASS2);
+
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_REFERENCE, ITEM_CLASS1);
+
+	/*
+	 * Key jump can now be written (now that we know the size of the
+	 * key block). This can now happen anytime before the final
+	 * sizes are computed.
+	 */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
+	descbuf = cmd_insert_proto_op_ipsec(descbuf,
+					    cipherdata->algtype,
+					    authdata->algtype,
+					    DIR_ENCAP);
+
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
+	*bufsize = endidx;
+	return 0;
+};
+EXPORT_SYMBOL(cnstr_shdsc_ipsec_encap);
+
+/**
+ * Construct IPSec ESP decapsulation protocol-level sharedesc
+ * Requires a covered MDHA splitkey.
+ *
+ * Inputs:
+ * @descbuf - pointer to buffer used for descriptor construction
+ *
+ * @bufsize - pointer to size to be written back upon completion
+ *
+ * @pdb - pointer to the PDB to be used with this descriptor. This
+ *       structure will be copied inline to the descriptor under
+ *       construction. No error checking will be made. Refer to the
+ *       block guide for a detailed discussion of the decapsulation
+ *       PDB, and it's unioned sub structure that is cipher-dependent
+ *
+ * @cipherdata - Pointer to blockcipher transform definitions.
  *
+ * @authdata - Pointer to authentication transform definitions. Note
+ *             that since a split key is to be used, the size of the
+ *             split key itself is specified (even though the buffer
+ *             containing the key may have additional padding depending
+ *             on the size).
  **/
-int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_pdb *pdb,
+int32_t cnstr_shdsc_ipsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct ipsec_decap_pdb *pdb,
 				struct cipherparams *cipherdata,
-				u_int8_t mode, u_int8_t clear)
+				struct authparams *authdata)
 {
-	u_int32_t pdbopts;
-	u_int32_t *start;
+	u_int32_t *start, *keyjump;
 	u_int16_t startidx, endidx;
 
-	start = descbuf++;
+	start = descbuf;
 
-	if (!descbuf)
-		return -1;
+	/* copy in PDB */
+	memcpy(descbuf, pdb, sizeof(struct ipsec_decap_pdb));
+	descbuf += sizeof(struct ipsec_decap_pdb) >> 2;
 
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+	startidx = descbuf - start;
 
 	/*
-	 * Construct encap PDB
-	 * u24 - (reserved)
-	 * u8  - options
-	 * u32 - nonce
-	 * u8  - b0 flags
-	 * u8  - counter flags
-	 * u16 - counter init
-	 * u32 - PN
+	 * Insert an empty instruction for a shared-JUMP past the keys
+	 * Update later, once the size of the key block is known
 	 */
+	keyjump = descbuf++;
 
-	/* options word */
-	if (pdb->framecheck)
-		pdbopts = 1;
-	*descbuf++ = pdbopts;
+	/* Insert keys */
+	descbuf = cmd_insert_key(descbuf, authdata->key, authdata->keylen,
+				 PTR_DIRECT, KEYDST_MD_SPLIT, KEY_COVERED,
+				 ITEM_REFERENCE, ITEM_CLASS2);
 
-	/* Nonce */
-	pdbopts = pdb->nonce;
-	*descbuf++ = pdbopts;
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_REFERENCE, ITEM_CLASS1);
 
-	/* B0 flags / CTR flags / initial counter */
-	pdbopts = (pdb->b0_flags << 24) | (pdb->ctr_flags << 16) |
-		  pdb->ctr_initial_count;
-	*descbuf++ = pdbopts;
+	/*
+	 * Key jump comes here (now that we know the size of the key block.
+	 * Update before we insert the OP
+	 */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
 
-	/* PN word */
-	pdbopts = pdb->PN;
-	*descbuf++ = pdbopts;
+	descbuf = cmd_insert_proto_op_ipsec(descbuf,
+					    cipherdata->algtype,
+					    authdata->algtype,
+					    DIR_DECAP);
+
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
+	*bufsize = endidx;
+	return 0;
+};
+EXPORT_SYMBOL(cnstr_shdsc_ipsec_decap);
+
+/**
+ * IEEE 802.11i WiFi encapsulation
+ **/
+int32_t cnstr_shdsc_wifi_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wifi_encap_pdb *pdb,
+				struct cipherparams *cipherdata)
+{
+	u_int32_t *start, *keyjump;
+	u_int16_t startidx, endidx;
+
+	start = descbuf;
+
+	memcpy(descbuf, pdb, sizeof(struct wifi_encap_pdb));
+	descbuf += sizeof(struct wifi_encap_pdb) >> 2;
 
-	/* Done with PDB, build AES-CTR key block */
 	startidx = descbuf - start;
+	keyjump = descbuf++;
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
+
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
+	descbuf = cmd_insert_proto_op_wifi(descbuf, DIR_ENCAP);
+
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_wifi_encap);
+
+/**
+ * IEEE 802.11 WiFi decapsulation
+ **/
+int32_t cnstr_shdsc_wifi_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wifi_decap_pdb *pdb,
+				struct cipherparams *cipherdata)
+{
+	u_int32_t *start, *keyjump;
+	u_int16_t startidx, endidx;
+
+	start = descbuf;
 
+	memcpy(descbuf, pdb, sizeof(struct wifi_decap_pdb));
+	descbuf += sizeof(struct wifi_decap_pdb) >> 2;
+
+	startidx = descbuf - start;
+	keyjump = descbuf++;
 	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
 				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				 ITEM_INLINE, ITEM_CLASS1);
 
-	/* end with OPERATION */
-	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_ENCAP);
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
+	descbuf = cmd_insert_proto_op_wifi(descbuf, DIR_DECAP);
 
-	/* Now compute shared header */
 	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
 	*bufsize = endidx;
 
 	return 0;
 }
-EXPORT_SYMBOL(cnstr_shdsc_wimax_encap);
+EXPORT_SYMBOL(cnstr_shdsc_wifi_decap);
 
 /**
- * 802.16 WiMAX decapsulation
+ * 802.16 WiMAX encapsulation
  *
  * @descbuf - Pointer to descriptor build buffer
  *
  * @bufsize - Pointer to value to write size of built descriptor to
  *
- * @pdb.framecheck - nonzero if frame check word to be included
- * @pdb.nonce - Nonce to use
- * @pdb.iv_flags - IV flags
- * @pdb.ctr_flags - counter flags
- * @pdb.ctr_initial_count - counter value
- * @pdb.PN - PN value
- * @pdb.antireplay_len - length of antireplay window
+ * @pdb - pointer to pre-initialized PDB
  *
  * @cipherdata.keylen - key size in bytes
  * @cipherdata.key - key data to inline
@@ -454,78 +596,86 @@ EXPORT_SYMBOL(cnstr_shdsc_wimax_encap);
  * @mode - nonzero for OFDMa, else OFDM
  *
  * @clear - nonzero clears descriptor buffer
+ *
  **/
-
-int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				struct wimax_pdb *pdb,
+int32_t cnstr_shdsc_wimax_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_encap_pdb *pdb,
 				struct cipherparams *cipherdata,
-				u_int8_t mode, u_int8_t clear)
+				u_int8_t mode)
 {
-	u_int32_t pdbopts;
-	u_int32_t *start;
+	u_int32_t *start, *keyjump;
 	u_int16_t startidx, endidx;
 
-	start = descbuf++;
+	start = descbuf;
 
-	if (!descbuf)
-		return -1;
+	memcpy(descbuf, pdb, sizeof(struct wimax_encap_pdb));
+	descbuf += sizeof(struct wimax_encap_pdb) >> 2;
 
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
+	startidx = descbuf - start;
+	keyjump = descbuf++;
+	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
+				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
+				 ITEM_INLINE, ITEM_CLASS1);
 
-	/*
-	 * Construct decap PDB
-	 * u24 - (reserved)
-	 * u8  - options
-	 * u32 - nonce
-	 * u8  - IV flags
-	 * u8  - counter flags
-	 * u16 - counter init
-	 * u32 - PN
-	 * u16 - (reserved)
-	 * u16 - antireplay length
-	 * u64 - antireplay scorecard
-	 */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
 
-	/* options word */
-	if (pdb->framecheck)
-		pdbopts = 1;
-	if (pdb->antireplay_len)
-		pdbopts |= 0x40;
-	*descbuf++ = pdbopts;
+	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_ENCAP);
 
-	/* Nonce */
-	pdbopts = pdb->nonce;
-	*descbuf++ = pdbopts;
+	/* Now compute shared header */
+	endidx = descbuf - start + 1;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
+	*bufsize = endidx;
 
-	/* IV flags / CTR flags / initial counter */
-	pdbopts = (pdb->iv_flags << 24) | (pdb->ctr_flags << 16) |
-		  pdb->ctr_initial_count;
-	*descbuf++ = pdbopts;
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_shdsc_wimax_encap);
 
-	/* PN word */
-	pdbopts = pdb->PN;
-	*descbuf++ = pdbopts;
+/**
+ * 802.16 WiMAX decapsulation
+ *
+ * @descbuf - Pointer to descriptor build buffer
+ *
+ * @bufsize - Pointer to value to write size of built descriptor to
+ *
+ * @pdb - pointer to pre-initialized PDB
+ *
+ * @cipherdata.keylen - key size in bytes
+ * @cipherdata.key - key data to inline
+ *
+ * @mode - nonzero for OFDMa, else OFDM
+ *
+ * @clear - nonzero clears descriptor buffer
+ **/
+int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
+				struct wimax_decap_pdb *pdb,
+				struct cipherparams *cipherdata,
+				u_int8_t mode)
+{
+	u_int32_t *start, *keyjump;
+	u_int16_t startidx, endidx;
 
-	/* Antireplay */
-	pdbopts = pdb->antireplay_len;
-	*descbuf++ = pdbopts; /* write length */
-	memset(descbuf, 0, 8);
-	descbuf += 2;
+	start = descbuf;
 
-	/* Done with PDB, build key block */
-	startidx = descbuf - start;
+	memcpy(descbuf, pdb, sizeof(struct wimax_decap_pdb));
+	descbuf += sizeof(struct wimax_decap_pdb) >> 2;
 
+	startidx = descbuf - start;
+	keyjump = descbuf++;
 	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
 				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				 ITEM_INLINE, ITEM_CLASS1);
 
-	/* end with OPERATION */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
 	descbuf = cmd_insert_proto_op_wimax(descbuf, mode, DIR_DECAP);
 
 	/* Now compute shared header */
 	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
 	*bufsize = endidx;
 
 	return 0;
@@ -533,19 +683,13 @@ int32_t cnstr_shdsc_wimax_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 EXPORT_SYMBOL(cnstr_shdsc_wimax_decap);
 
 /**
- * MacSec encapsulation
+ * 802.1AE MacSec encapsulation
  *
  * @descbuf - Pointer to descriptor build buffer
  *
  * @bufsize - Pointer to value to write size of built descriptor to
  *
- * pdb.framecheck - nonzero if frame-check-sequence is to be
- *                  included in the output
- * pdb.aad_len - length of AAD to include
- * pdb.sci - SCI, if to be included
- * pdb.PN - packet number
- * pdb.ethertype - 16 bit ethertype to include
- * pdb.tci_an - TCI/AN byte
+ * @pdb - pointer to pre-initialized PDB
  *
  * @cipherdata.keylen - key size in bytes
  * @cipherdata.key - key data to inline
@@ -554,52 +698,31 @@ EXPORT_SYMBOL(cnstr_shdsc_wimax_decap);
  **/
 
 int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_pdb *pdb,
-				 struct cipherparams *cipherdata,
-				 u_int8_t clear)
+				 struct macsec_encap_pdb *pdb,
+				 struct cipherparams *cipherdata)
 {
-	u_int32_t pdbopts;
-	u_int32_t *start;
+	u_int32_t *start, *keyjump;
 	u_int16_t startidx, endidx;
 
-	start = descbuf++;
+	start = descbuf;
 
-	if (!descbuf)
-		return -1;
-
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	/* options word */
-	pdbopts = pdb->aad_len >> 16;
-	if (pdb->framecheck)
-		pdbopts |= 1;
-	*descbuf++ = pdbopts;
-
-	/* SCI */
-	memcpy(descbuf, &pdb->sci, 8);
-	descbuf += 2;
-
-	pdbopts = (pdb->ethertype << 16) | (pdb->tci_an << 8);
-	*descbuf++ = pdbopts;
-
-	/* PN word */
-	pdbopts = pdb->PN;
-	*descbuf++ = pdbopts;
+	memcpy(descbuf, pdb, sizeof(struct macsec_encap_pdb));
+	descbuf += sizeof(struct macsec_encap_pdb) >> 2;
 
-	/* Done with PDB, build key block */
 	startidx = descbuf - start;
-
+	keyjump = descbuf++;
 	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
 				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				 ITEM_INLINE, ITEM_CLASS1);
 
-	/* end with OPERATION */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
 	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_ENCAP);
 
-	/* Now compute shared header */
 	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
 	*bufsize = endidx;
 
 	return 0;
@@ -607,19 +730,13 @@ int32_t cnstr_shdsc_macsec_encap(u_int32_t *descbuf, u_int16_t *bufsize,
 EXPORT_SYMBOL(cnstr_shdsc_macsec_encap);
 
 /**
- * MacSec decapsulation
+ * 802.1AE MacSec decapsulation
  *
  * @descbuf - Pointer to descriptor build buffer
  *
  * @bufsize - Pointer to value to write size of built descriptor to
  *
- * pdb.framecheck - nonzero if frame-check-sequence is on
- * pdb.aad_len - length of AAD used
- * pdb.sci - SCI, if to be used
- * pdb.PN - packet number
- * pdb.ethertype - 16 bit ethertype
- * pdb.tci_an - TCI/AN byte
- * pdb.antireplay_len - antireplay length
+ * @pdb - pointer to pre-initialized PDB
  *
  * @cipherdata.keylen - key size in bytes
  * @cipherdata.key - key data to inline
@@ -627,59 +744,31 @@ EXPORT_SYMBOL(cnstr_shdsc_macsec_encap);
  * @clear - nonzero clears descriptor buffer
  **/
 int32_t cnstr_shdsc_macsec_decap(u_int32_t *descbuf, u_int16_t *bufsize,
-				 struct macsec_pdb *pdb,
-				 struct cipherparams *cipherdata,
-				 u_int8_t clear)
+				 struct macsec_decap_pdb *pdb,
+				 struct cipherparams *cipherdata)
 {
-	u_int32_t pdbopts;
-	u_int32_t *start;
+	u_int32_t *start, *keyjump;
 	u_int16_t startidx, endidx;
 
-	start = descbuf++;
-
-	if (!descbuf)
-		return -1;
-
-	if (clear)
-		memset(start, 0, (*bufsize * sizeof(u_int32_t)));
-
-	/* options word */
-	pdbopts = pdb->aad_len >> 16;
-	if (pdb->framecheck)
-		pdbopts |= 1;
-	if (pdb->antireplay_len)
-		pdbopts |= 0x40;
-	*descbuf++ = pdbopts;
-
-	/* SCI */
-	memcpy(descbuf, &pdb->sci, 8);
-	descbuf += 2;
-
-	/* antireplay length */
-	pdbopts = pdb->antireplay_len;
-	*descbuf++ = pdbopts;
-
-	/* PN word */
-	pdbopts = pdb->PN;
-	*descbuf++ = pdbopts;
+	start = descbuf;
 
-	/* antireplay scorecard */
-	memset(descbuf, 0, 8);
-	descbuf += 2;
+	memcpy(descbuf, pdb, sizeof(struct macsec_decap_pdb));
+	descbuf += sizeof(struct macsec_decap_pdb) >> 2;
 
-	/* Done with PDB, build key block */
 	startidx = descbuf - start;
-
+	keyjump = descbuf++;
 	descbuf = cmd_insert_key(descbuf, cipherdata->key, cipherdata->keylen,
 				 PTR_DIRECT, KEYDST_KEYREG, KEY_CLEAR,
 				 ITEM_INLINE, ITEM_CLASS1);
 
-	/* end with OPERATION */
+	cmd_insert_jump(keyjump, JUMP_TYPE_LOCAL, CLASS_BOTH, JUMP_TEST_ALL,
+			JUMP_COND_SHRD | JUMP_COND_SELF, descbuf - keyjump,
+			NULL);
+
 	descbuf = cmd_insert_proto_op_macsec(descbuf, DIR_DECAP);
 
-	/* Now compute shared header */
 	endidx = descbuf - start + 1;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_SERIAL);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_SERIAL);
 	*bufsize = endidx;
 
 	return 0;
@@ -699,7 +788,6 @@ EXPORT_SYMBOL(cnstr_shdsc_macsec_decap);
  * @direction - UEA2 direction (1 bit)
  * @clear - nonzero if descriptor buffer clear requested
  **/
-
 int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
@@ -762,7 +850,7 @@ int32_t cnstr_shdsc_snow_f8(u_int32_t *descbuf, u_int16_t *bufsize,
 	/* Now update the header with size/offsets */
 	endidx = descbuf - start;
 
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
 
 	*bufsize = endidx;
 
@@ -783,7 +871,6 @@ EXPORT_SYMBOL(cnstr_shdsc_snow_f8);
  * @direction - UEA2 direction (1 bit)
  * @clear - nonzero if descriptor buffer clear requested
  **/
-
 int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 			    u_int8_t *key, u_int32_t keylen,
 			    enum algdir dir, u_int32_t count,
@@ -843,7 +930,7 @@ int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 
 	endidx = descbuf - start;
 
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
 
 	*bufsize = endidx;
 
@@ -851,8 +938,6 @@ int32_t cnstr_shdsc_snow_f9(u_int32_t *descbuf, u_int16_t *bufsize,
 }
 EXPORT_SYMBOL(cnstr_shdsc_snow_f9);
 
-
-
 /**
  * CBC blockcipher
  * @descbuf - descriptor buffer
@@ -865,7 +950,6 @@ EXPORT_SYMBOL(cnstr_shdsc_snow_f9);
  * @cipher  - OP_ALG_ALGSEL_AES/DES/3DES
  * @clear   - clear buffer before writing
  **/
-
 int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 				  u_int8_t *key, u_int32_t keylen,
 				  u_int8_t *iv, u_int32_t ivlen,
@@ -923,7 +1007,7 @@ int32_t cnstr_shdsc_cbc_blkcipher(u_int32_t *descbuf, u_int16_t *bufsize,
 
 	/* Now update the header with size/offsets */
 	endidx = descbuf - start;
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
 
 	*bufsize = endidx;
 
@@ -940,7 +1024,6 @@ EXPORT_SYMBOL(cnstr_shdsc_cbc_blkcipher);
  * @icv     - HMAC comparison for ICV, NULL if no check desired
  * @clear   - clear buffer before writing
  **/
-
 int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 			 u_int8_t *key, u_int32_t cipher, u_int8_t *icv,
 			 u_int8_t clear)
@@ -992,7 +1075,6 @@ int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 	else
 		opicv = ICV_CHECK_OFF;
 
-
 	startidx = descbuf - start;
 
 	descbuf = cmd_insert_key(descbuf, key, storelen * 8, PTR_DIRECT,
@@ -1025,7 +1107,7 @@ int32_t cnstr_shdsc_hmac(u_int32_t *descbuf, u_int16_t *bufsize,
 
 	endidx = descbuf - start;
 
-	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_SAVE, SHR_ALWAYS);
 
 	*bufsize = endidx;
 
@@ -1046,214 +1128,338 @@ EXPORT_SYMBOL(cnstr_shdsc_hmac);
  * @payload_sz - size of payload (this is not using VLF)
  * @clear - clear descriptor buffer before construction
  **/
-
-/* FIXME: these should be built from bit defs not yet present in desc.h */
-static const u_int32_t rlc_fifo_cmd[] = {
-	/* IFIFO dest=skip,flush,stype=DFIFO,dtype=msg,len=3 */
-	0x04F00003u,
-	 /* IFIFO dest=skip,flush,stype=DFIFO,dtype=msg,len=80 */
-	0x04F00050u,
-	/* IFIFO dest=class1,last1,flush1,stype=DFIFO,dtype=msg,len=80 */
-	0x54F00050u
-};
-
-static const u_int32_t rlc_segnum_mask[] = {
-	0x00000fff,
-	0x00000000
-};
-
-/* misc values for adding immediates to math/move/load/etc. */
-static const u_int32_t cmd_imm_src[] = {
-	0, 1, 19, 16, 4, 60, 8
-};
-
-static const u_int8_t jump_imm_src[] = {
-	-10
-};
-
 int32_t cnstr_pcl_shdsc_3gpp_rlc_decap(u_int32_t *descbuf, u_int16_t *bufsize,
 				       u_int8_t *key, u_int32_t keysz,
 				       u_int32_t count, u_int32_t bearer,
 				       u_int32_t direction,
-				       u_int32_t payload_sz, u_int8_t clear)
+				       u_int16_t payload_sz, u_int8_t clear)
 {
 	u_int32_t *start;
 	u_int16_t startidx, endidx;
 	u_int32_t kctx[2];
+	u_int32_t ififo_cmd;
+	u_int32_t tmp_imm;
+	u_int64_t rlc_segnum_mask = 0x00000fff00000000ull;
 
 	start = descbuf++;
 
 	if (!descbuf)
 		return -1;
 
-
 	/* build count/bearer/direction as register-loadable words */
 	kctx[0] = count;
 	kctx[1] = ((bearer & 0x1f) << 27) | ((direction & 0x01) << 26);
 
 	startidx = descbuf - start;
 
-	/* Key */
-	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT, KEYDST_KEYREG,
-				 KEY_CLEAR, ITEM_REFERENCE, ITEM_CLASS1);
+	/* Load the cipher key */
+	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
 
-	/* load DCTRL - disable auto Info FIFO entries */
+	/* Shut off automatic Info FIFO entries */
 	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
 				  LDST_SRCDST_WORD_DECOCTRL, 0x08, 0x00,
 				  ITEM_INLINE);
 
-	/* get encrypted RLC PDU w/header */
+	/* Read encrypted 83-byte RLC PDU w/header */
 	descbuf = cmd_insert_seq_fifo_load(descbuf, LDST_CLASS_1_CCB, 0,
 					   FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1,
 					   83);
 
-	/* load imm Info FIFO */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[1],
-				  LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_INFO_FIFO, 0, 8,
+	/* Stuff info-fifo with 3-byte then payload-size flush */
+	ififo_cmd = 0x04F00003; /* FIXME: bitdefs in desc.h would be better */
+	descbuf = cmd_insert_load(descbuf, &ififo_cmd,
+				  LDST_CLASS_IND_CCB, 0,
+				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
 				  ITEM_INLINE);
 
-	/* load imm Info FIFO */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[2],
-				  LDST_CLASS_DECO, 0,
-				  LDST_SRCDST_WORD_INFO_FIFO, 0, 8,
+	ififo_cmd = 0x04f00000 | payload_sz;
+	descbuf = cmd_insert_load(descbuf, &ififo_cmd,
+				  LDST_CLASS_IND_CCB, 0,
+				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
 				  ITEM_INLINE);
 
-	/* load imm MATH0 */
+	/* Now load prebuilt cipher context for KFHA */
 	descbuf = cmd_insert_load(descbuf, kctx, LDST_CLASS_DECO, 0,
 				  LDST_SRCDST_WORD_DECO_MATH0, 0, 8,
 				  ITEM_INLINE);
 
-	/* add imm: IFIFO + 0 -> MATH1 (3B from InfoFIFO) */
+	/* Get PDU header, left align, and store */
+	tmp_imm = 0;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
-				  MATH_SRC1_INFIFO, MATH_DEST_REG0, 8, 0, 0,
-				  MATH_IFB, (u_int32_t *)&cmd_imm_src[0]);
+				  MATH_SRC1_INFIFO, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
 
-	/* shl imm: MATH1 << 4 -> MATH1 (left-align RLC PDU header) */
-	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
+	tmp_imm = 4;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG1,
 				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  MATH_IFB, (u_int32_t *)&cmd_imm_src[1]);
+				  MATH_IFB, &tmp_imm);
 
-	/* MATH1 (2B PDU) -> OFIFO (8 bytes get moved) */
 	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
 				  MOVE_DEST_OUTFIFO, 0, 2);
 
-	/* Store 2-byte PDU header */
 	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_IND_CCB, 0,
 					    FIFOST_TYPE_MESSAGE_DATA, 2);
 
-	/* wait for DMA CALM */
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
-				  JUMP_COND_CALM, 1, NULL);
+	/* wait for DMA CALM before proceeding */
+	descbuf = cmd_insert_jump(descbuf, CLASS_NONE, JUMP_TYPE_LOCAL,
+				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
 
-	/* DCTRL - reset OFIFO to flush extra 6 bytes */
+	/* reset output FIFO */
 	descbuf = cmd_insert_load(descbuf, NULL, LDST_CLASS_DECO, 0,
 				  LDST_SRCDST_WORD_DECOCTRL, 0, 32,
 				  ITEM_INLINE);
 
-	/* shr imm MATH1 -> MATH2 (align seqnum with PPDB data) */
+	/* Align sequence number with PPDB, add it, then use as c1 context */
+	tmp_imm = 19;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
 				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
-				  MATH_IFB, (u_int32_t *)&cmd_imm_src[2]);
+				  MATH_IFB, &tmp_imm);
 
-	/* mask Math2 to isolate seqnum */
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG2,
 				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0, 0,
-				  (u_int32_t *)rlc_segnum_mask);
+				  (u_int32_t *)&rlc_segnum_mask);
 
-	/* add seqnum to PPDB data */
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
-				  MATH_SRC1_REG2, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_SRC1_REG2, MATH_DEST_REG0, 8, 0, 0,
 				  0, NULL);
 
-	/* MATH0 (PPDB data) -> CTX1 */
 	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH0,
 				  MOVE_DEST_CLASS1CTX, 0, 8);
 
-	/* shl imm: MATH1 << 16 -> MATH1 (4 bits left) */
+	/* shift sequence number left 4 */
+	tmp_imm = 16;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG1,
 				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
-				  0, (u_int32_t *)&cmd_imm_src[3]);
+				  MATH_IFB, &tmp_imm);
 
-	/* load imm MATH3 */
-	descbuf = cmd_insert_load(descbuf, &payload_sz, LDST_CLASS_DECO,
+	tmp_imm = payload_sz; /* convert to 32-bit immediate */
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_DECO,
 				  0, LDST_SRCDST_WORD_DECO_MATH3, 0, 4,
 				  ITEM_INLINE);
 
-	/* add imm: IFIFO (next 8B of payload) + 0 -> MATH2 */
+	/*
+	 * Top of payload loop. Process 8 bytes of payload,
+	 * shift right to M0
+	 */
+	tmp_imm = 0;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_IMM,
 				  MATH_SRC1_INFIFO, MATH_DEST_REG2,
-				  8, 0, 0, 0, (u_int32_t *)&cmd_imm_src[0]);
+				  8, 0, 0, MATH_IFB, &tmp_imm);
 
-	/* shr imm: Math2 >> 4 -> MATH0 */
+	tmp_imm = 4;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG2,
 				  MATH_SRC1_IMM, MATH_DEST_REG0,
-				  8, 0, 0, 0, (u_int32_t *)&cmd_imm_src[4]);
+				  8, 0, 0, MATH_IFB, &tmp_imm);
 
-	/* or: MATH0 (60 lsbs) | MATH1 (4 msbs) -> MATH1 */
+	/* 64 bits to in fifo */
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_OR, MATH_SRC0_REG0,
 				  MATH_SRC1_REG1, MATH_DEST_REG1, 8, 0, 0, 0,
 				  NULL);
 
-	/* MATH1 -> IFIFO */
 	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1,
 				  MOVE_DEST_CLASS1INFIFO, 0, 8);
 
-	/* shl imm: MATH2 << 60 -> MATH1 */
+	tmp_imm = 60;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG2,
-				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0, 0,
-				  (u_int32_t *)&cmd_imm_src[5]);
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
 
-	/* dec MATH3 by 8 (number of bytes loaded) */
+	/* M3 = data processed */
+	tmp_imm = 8;
 	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_REG3,
 				  MATH_SRC1_IMM, MATH_DEST_REG3, 8, 0, 0,
-				  MATH_IFB, (u_int32_t *)&cmd_imm_src[6]);
+				  MATH_IFB, &tmp_imm);
 
-	/* jump back to L1 if MATH3 counter indicates more data */
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, JUMP_TEST_ALL,
+	/* end of 8 byte processing loop, go back to top if more  */
+	descbuf = cmd_insert_jump(descbuf, CLASS_NONE, JUMP_TYPE_LOCAL,
+				  JUMP_TEST_INVALL,
 				  JUMP_COND_MATH_NV | JUMP_COND_MATH_Z,
-				  jump_imm_src[0], NULL);
+				  -11, NULL);
 
-	/* load Class1 Data Size (exec before InfoFIFO entry made w/last1) */
-	descbuf = cmd_insert_load(descbuf, &payload_sz, LDST_CLASS_1_CCB,
+	/* Get c1 data size */
+	tmp_imm = payload_sz; /* convert to 32-bit imm value */
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_1_CCB,
 				  0, LDST_SRCDST_WORD_DATASZ_REG, 0, 4,
 				  ITEM_INLINE);
 
-	/* load Info FIFO */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&rlc_fifo_cmd[3],
-				  LDST_CLASS_DECO, 0,
+	/* Set up info-fifo for OP, store, wait for done */
+	ififo_cmd = 0x54f00000 | payload_sz;
+	descbuf = cmd_insert_load(descbuf, &ififo_cmd, LDST_CLASS_IND_CCB, 0,
 				  LDST_SRCDST_WORD_INFO_FIFO, 0, 4,
 				  ITEM_INLINE);
 
-	/* operation KFHA f8 initfinal */
 	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
 				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
 				    OP_ALG_AS_INITFINAL, ICV_CHECK_OFF,
-				    DIR_ENCRYPT);
+				    DIR_DECRYPT);
 
-	/* store msg */
-	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_1_CCB, 0,
+	descbuf = cmd_insert_seq_fifo_store(descbuf, LDST_CLASS_IND_CCB, 0,
 					    FIFOST_TYPE_MESSAGE_DATA,
 					    payload_sz);
 
-	/* wait for CLASS1 CHA done */
-	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL,
+	descbuf = cmd_insert_jump(descbuf, CLASS_1, JUMP_TYPE_LOCAL,
 				  JUMP_TEST_ALL, 0, 1, NULL);
 
-	/* load imm to cha ClrWrittenReg to clear mode */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&cmd_imm_src[1],
-				  LDST_CLASS_IND_CCB, 0,
+	/*
+	 * Cleanup. Clear mode, and release CHA
+	 */
+	tmp_imm = 1;
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB, 0,
 				  LDST_SRCDST_WORD_CLRW, 0, 4, ITEM_INLINE);
 
-	/* load imm to cha CTL to release KFHA */
-	descbuf = cmd_insert_load(descbuf, (u_int32_t *)&cmd_imm_src[3],
-				  LDST_CLASS_IND_CCB, 0,
+	tmp_imm = 0x10;
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB, 0,
 				  LDST_SRCDST_WORD_CHACTRL, 0, 4, ITEM_INLINE);
 
-	endidx = descbuf - start + 1; /* add 1 to include header */
+	/* Finally, header update once length known */
+	endidx = descbuf - start;
+	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
+
+	*bufsize = endidx;
+
+	return 0;
+}
+EXPORT_SYMBOL(cnstr_pcl_shdsc_3gpp_rlc_decap);
+
+int32_t cnstr_pcl_shdsc_3gpp_rlc_encap(u_int32_t *descbuf, u_int16_t *bufsize,
+				       u_int8_t *key, u_int32_t keysz,
+				       u_int32_t count, u_int32_t bearer,
+				       u_int32_t direction,
+				       u_int16_t payload_sz)
+{
+	u_int32_t *start;
+	u_int16_t startidx, endidx;
+	u_int32_t kctx[2];
+	u_int32_t tmp_imm;
+
+	start = descbuf++;
+
+	if (!descbuf)
+		return -1;
+
+	/* build count/bearer/direction as register-loadable words */
+	kctx[0] = count;
+	kctx[1] = ((bearer & 0x1f) << 27) | ((direction & 0x01) << 26);
+
+	startidx = descbuf - start;
+
+	descbuf = cmd_insert_seq_load(descbuf, LDST_CLASS_DECO, 0,
+				      LDST_SRCDST_WORD_DECO_MATH1, 0, 2);
+
+	descbuf = cmd_insert_load(descbuf, kctx, LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_DECO_MATH0, 0, 8,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_key(descbuf, key, keysz, PTR_DIRECT,
+				 KEYDST_KEYREG, KEY_CLEAR, ITEM_REFERENCE,
+				 ITEM_CLASS1);
+
+	descbuf = cmd_insert_seq_fifo_load(descbuf, CLASS_1, 0,
+					   FIFOLD_TYPE_LAST1, payload_sz);
+
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
+				  JUMP_TEST_ALL, JUMP_COND_CALM, 1, NULL);
+
+	tmp_imm = 4;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	tmp_imm = 15;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG1,
+				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	tmp_imm = 0x0fff0000;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG2, 8, 0, 0,
+				  0, &tmp_imm);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_ADD, MATH_SRC0_REG0,
+				  MATH_SRC1_REG2, MATH_DEST_REG0, 8, 0, 0, 0,
+				  NULL);
+
+	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH0,
+				  MOVE_DEST_CLASS1CTX, 0, 8);
+
+	descbuf = cmd_insert_alg_op(descbuf, OP_TYPE_CLASS1_ALG,
+				    OP_ALG_ALGSEL_KASUMI, OP_ALG_AAI_F8,
+				    OP_ALG_AS_INITFINAL, ICV_CHECK_OFF,
+				    DIR_ENCRYPT);
+
+	tmp_imm = payload_sz + 3;
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_DECO, 0,
+				  LDST_SRCDST_WORD_DECO_MATH3, 0, 4,
+				  ITEM_INLINE);
+
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_1,
+				  JUMP_TEST_ALL, 0, 1, NULL);
+
+	tmp_imm = 1;
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB,
+				  0, LDST_SRCDST_WORD_CLRW, 0, 4,
+				  ITEM_INLINE);
+
+	tmp_imm = 0x10;
+	descbuf = cmd_insert_load(descbuf, &tmp_imm, LDST_CLASS_IND_CCB,
+				  0, LDST_SRCDST_WORD_CHACTRL, 0, 4,
+				  ITEM_INLINE);
+
+	tmp_imm = 0;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_ZERO,
+				  MATH_SRC1_REG2, MATH_DEST_REG2, 8, MATH_NFU,
+				  0, MATH_IFB, &tmp_imm);
+
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
+				  JUMP_TEST_ANY, JUMP_COND_MATH_Z, 2, NULL);
+
+	descbuf = cmd_insert_move(descbuf, MOVE_WAITCOMP, MOVE_SRC_OUTFIFO,
+				  MOVE_DEST_MATH2, 0, 8);
+
+	tmp_imm = 20;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_RSHIFT, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG0, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_OR, MATH_SRC0_REG0,
+				  MATH_SRC1_REG1, MATH_DEST_REG1, 8, 0, 0, 0,
+				  NULL);
+
+	descbuf = cmd_insert_move(descbuf, 0, MOVE_SRC_MATH1, MOVE_DEST_OUTFIFO,
+				  0, 8);
+
+	tmp_imm = 8;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_SUB, MATH_SRC0_REG3,
+				  MATH_SRC1_IMM, MATH_DEST_REG3, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	tmp_imm = 44;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_LSHIFT, MATH_SRC0_REG2,
+				  MATH_SRC1_IMM, MATH_DEST_REG1, 8, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
+				  JUMP_TEST_ANY, JUMP_COND_MATH_NV, 4, NULL);
+
+	tmp_imm = 0xfffc;
+	descbuf = cmd_insert_math(descbuf, MATH_FUN_AND, MATH_SRC0_REG3,
+				  MATH_SRC1_IMM, MATH_DEST_NONE, 4, 0, 0,
+				  MATH_IFB, &tmp_imm);
+
+	descbuf = cmd_insert_jump(descbuf, JUMP_TYPE_LOCAL, CLASS_NONE,
+				  JUMP_TEST_ALL, 0, -14, NULL);
+
+	descbuf = cmd_insert_seq_store(descbuf, FIFOLD_CLASS_SKIP, 0,
+				       FIFOST_TYPE_MESSAGE_DATA, 0,
+				       payload_sz + 3);
+
+	endidx = descbuf - start;
 	cmd_insert_shared_hdr(start, startidx, endidx, CTX_ERASE, SHR_ALWAYS);
 
 	*bufsize = endidx;
 
 	return 0;
 }
+EXPORT_SYMBOL(cnstr_pcl_shdsc_3gpp_rlc_encap);
diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h
index 71b6c18..1cd2674 100644
--- a/drivers/crypto/caam/desc.h
+++ b/drivers/crypto/caam/desc.h
@@ -36,8 +36,11 @@
 #ifndef DESC_H
 #define DESC_H
 
-/* Max size of any CAAM descriptor in 32-bit words */
-#define MAX_CAAM_DESCSIZE       63
+/* Max size of any CAAM descriptor in 32-bit words, inclusive of header */
+#define MAX_CAAM_DESCSIZE       64
+
+/* Block size of any entity covered/uncovered with a KEK/TKEK */
+#define KEK_BLOCKSIZE		16
 
 /*
  * Supported descriptor command types as they show up
@@ -274,11 +277,15 @@
 #define FIFOLDST_SGF            (1 << FIFOLDST_SGF_SHIFT)
 #define FIFOLDST_VLF            (1 << FIFOLDST_SGF_SHIFT)
 
-/* Immediate - Key follows command in descriptor */
+/* Immediate - Data follows command in descriptor */
 #define FIFOLD_IMM_SHIFT      23
 #define FIFOLD_IMM_MASK       (1 << FIFOLD_IMM_SHIFT)
 #define FIFOLD_IMM            (1 << FIFOLD_IMM_SHIFT)
 
+#define FIFOST_IMM_SHIFT      23
+#define FIFOST_IMM_MASK       (1 << FIFOST_IMM_SHIFT)
+#define FIFOST_IMM            (1 << FIFOST_IMM_SHIFT)
+
 /* Continue - Not the last FIFO store to come */
 #define FIFOST_CONT_SHIFT     23
 #define FIFOST_CONT_MASK      (1 << FIFOST_CONT_SHIFT)
@@ -294,6 +301,7 @@
 
 /* Input data type.*/
 #define FIFOLD_TYPE_SHIFT       16
+#define FIFOLD_CONT_TYPE_SHIFT  19 /* shift past last-flush bits */
 #define FIFOLD_TYPE_MASK        (0x3f << FIFOLD_TYPE_SHIFT)
 
 /* PK types */
@@ -1053,27 +1061,28 @@
 #define OP_PCL_PKPROT_F2M                        0x0001
 
 /* For non-protocol/alg-only op commands */
-#define OP_ALG_TYPE_SHIFT  24
-#define OP_ALG_TYPE_MASK   (0x7 << OP_ALG_TYPE_SHIFT)
-#define OP_ALG_TYPE_CLASS1 2
-#define OP_ALG_TYPE_CLASS2 4
-
-#define OP_ALG_ALGSEL_SHIFT   16
-#define OP_ALG_ALGSEL_MASK    (0xff << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_AES     (0x10 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_DES     (0x20 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_3DES    (0x21 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_ARC4    (0x30 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_MD5     (0x40 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SHA1    (0x41 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SHA224  (0x42 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SHA256  (0x43 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SHA384  (0x44 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SHA512  (0x45 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_RNG     (0x50 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_SNOW    (0x60 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_KASUMI  (0x70 << OP_ALG_ALGSEL_SHIFT)
-#define OP_ALG_ALGSEL_CRC     (0x90 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_TYPE_SHIFT	24
+#define OP_ALG_TYPE_MASK	(0x7 << OP_ALG_TYPE_SHIFT)
+#define OP_ALG_TYPE_CLASS1	2
+#define OP_ALG_TYPE_CLASS2	4
+
+#define OP_ALG_ALGSEL_SHIFT	16
+#define OP_ALG_ALGSEL_MASK	(0xff << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SUBMASK	(0x0f << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_AES	(0x10 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_DES	(0x20 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_3DES	(0x21 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_ARC4	(0x30 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_MD5	(0x40 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA1	(0x41 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA224	(0x42 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA256	(0x43 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA384	(0x44 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SHA512	(0x45 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_RNG	(0x50 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_SNOW	(0x60 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_KASUMI	(0x70 << OP_ALG_ALGSEL_SHIFT)
+#define OP_ALG_ALGSEL_CRC	(0x90 << OP_ALG_ALGSEL_SHIFT)
 
 #define OP_ALG_AAI_SHIFT	4
 #define OP_ALG_AAI_MASK		(0x1ff << OP_ALG_AAI_SHIFT)
@@ -1154,6 +1163,7 @@
 
 /* PKHA algorithm type set */
 #define OP_ALG_PK                    0x00800000
+#define OP_ALG_PK_FUN_MASK           0x3f /* clrmem, modmath, or cpymem */
 
 /* PKHA mode clear memory functions */
 #define OP_ALG_PKMODE_A_RAM          0x80000
@@ -1187,23 +1197,32 @@
 #define OP_ALG_PKMODE_MOD_PRIMALITY  0x00f
 
 /* PKHA mode copy-memory functions */
-#define OP_ALG_PKMODE_SRC_REG_A      0x00000
-#define OP_ALG_PKMODE_SRC_REG_B      0x20000
-#define OP_ALG_PKMODE_SRC_REG_N      0x60000
-#define OP_ALG_PKMODE_DST_REG_A      0x00000
-#define OP_ALG_PKMODE_DST_REG_B      0x04000
-#define OP_ALG_PKMODE_DST_REG_E      0x08000
-#define OP_ALG_PKMODE_DST_REG_N      0x0c000
-#define OP_ALG_PKMODE_SRC_SEG_0      0x00000
-#define OP_ALG_PKMODE_SRC_SEG_1      0x01000
-#define OP_ALG_PKMODE_SRC_SEG_2      0x02000
-#define OP_ALG_PKMODE_SRC_SEG_3      0x03000
-#define OP_ALG_PKMODE_DST_SEG_0      0x00000
-#define OP_ALG_PKMODE_DST_SEG_1      0x00400
-#define OP_ALG_PKMODE_DST_SEG_2      0x00800
-#define OP_ALG_PKMODE_DST_SEG_3      0x00c00
-#define OP_ALG_PKMODE_CPYMEM_N_SZ    0x00080
-#define OP_ALG_PKMODE_CPYMEM_SRC_SZ  0x00081
+#define OP_ALG_PKMODE_SRC_REG_SHIFT  13
+#define OP_ALG_PKMODE_SRC_REG_MASK   (7 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_SHIFT  10
+#define OP_ALG_PKMODE_DST_REG_MASK   (7 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_SHIFT  8
+#define OP_ALG_PKMODE_SRC_SEG_MASK   (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_SHIFT  6
+#define OP_ALG_PKMODE_DST_SEG_MASK   (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+
+#define OP_ALG_PKMODE_SRC_REG_A      (0 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_B      (1 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_REG_N      (3 << OP_ALG_PKMODE_SRC_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_A      (0 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_B      (1 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_E      (2 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_DST_REG_N      (3 << OP_ALG_PKMODE_DST_REG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_0      (0 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_1      (1 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_2      (2 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_SRC_SEG_3      (3 << OP_ALG_PKMODE_SRC_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_0      (0 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_1      (1 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_2      (2 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_DST_SEG_3      (3 << OP_ALG_PKMODE_DST_SEG_SHIFT)
+#define OP_ALG_PKMODE_CPYMEM_N_SZ    0x80
+#define OP_ALG_PKMODE_CPYMEM_SRC_SZ  0x81
 
 /*
  * SEQ_IN_PTR Command Constructs
@@ -1246,6 +1265,7 @@
 
 /* TYPE field is all that's relevant */
 #define SIGN_TYPE_SHIFT         16
+#define SIGN_TYPE_MASK          (0x0f << SIGN_TYPE_SHIFT)
 
 #define SIGN_TYPE_FINAL         (0x00 << SIGN_TYPE_SHIFT)
 #define SIGN_TYPE_FINAL_RESTORE (0x01 << SIGN_TYPE_SHIFT)
diff --git a/drivers/crypto/caam/error.c b/drivers/crypto/caam/error.c
new file mode 100644
index 0000000..0750184
--- /dev/null
+++ b/drivers/crypto/caam/error.c
@@ -0,0 +1,243 @@
+/*
+ * CAAM Error Reporting
+ *
+ * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "compat.h"
+#include "regs.h"
+#include "intern.h"
+#include "desc.h"
+#include "jq.h"
+
+#define SPRINTFCAT(str, format, param, max_alloc)		\
+{								\
+	char *tmp;						\
+								\
+	tmp = kmalloc(sizeof(format) + max_alloc, GFP_KERNEL);	\
+	sprintf(tmp, format, param);				\
+	strcat(str, tmp);					\
+	kfree(tmp);						\
+}
+
+static void report_jump_idx(u32 status, char *outstr)
+{
+	u8 idx = (status & JQSTA_DECOERR_INDEX_MASK) >>
+		  JQSTA_DECOERR_INDEX_SHIFT;
+
+	if (status & JQSTA_DECOERR_JUMP)
+		strcat(outstr, "jump tgt desc idx ");
+	else
+		strcat(outstr, "desc idx ");
+
+	SPRINTFCAT(outstr, "%d: ", idx, sizeof("255"));
+}
+
+static void report_ccb_status(u32 status, char *outstr)
+{
+	char *cha_id_list[] = {
+		"",
+		"AES",
+		"DES, 3DES",
+		"ARC4",
+		"MD5, SHA-1, SH-224, SHA-256, SHA-384, SHA-512",
+		"RNG",
+		"SNOW f8, SNOW f9",
+		"Kasumi f8, f9",
+		"All Public Key Algorithms",
+		"CRC",
+	};
+	char *err_id_list[] = {
+		"None. No error.",
+		"Mode error.",
+		"Data size error.",
+		"Key size error.",
+		"PKHA A memory size error.",
+		"PKHA B memory size error.",
+		"Data arrived out of sequence error.",
+		"PKHA divide-by-zero error.",
+		"PKHA modulus even error.",
+		"DES key parity error.",
+		"ICV check failed.",
+		"Hardware error.",
+		"Unsupported CCM AAD size.",
+		"Invalid CHA selected.",
+	};
+	u8 cha_id = (status & JQSTA_CCBERR_CHAID_MASK) >>
+		    JQSTA_CCBERR_CHAID_SHIFT;
+	u8 err_id = status & JQSTA_CCBERR_ERRID_MASK;
+
+	report_jump_idx(status, outstr);
+
+	if (cha_id < sizeof(cha_id_list)) {
+		SPRINTFCAT(outstr, "%s: ", cha_id_list[cha_id],
+			   strlen(cha_id_list[cha_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified cha_id value 0x%02x: ",
+			   cha_id, sizeof("ff"));
+	}
+
+	if (err_id < sizeof(err_id_list)) {
+		SPRINTFCAT(outstr, "%s", err_id_list[err_id],
+			   strlen(err_id_list[err_id]));
+	} else {
+		SPRINTFCAT(outstr, "unidentified err_id value 0x%02x",
+			   err_id, sizeof("ff"));
+	}
+}
+
+static void report_jump_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_deco_status(u32 status, char *outstr)
+{
+	const struct {
+		u8 value;
+		char *error_text;
+	} desc_error_list[] = {
+		{ 0x00, "None. No error." },
+		{ 0x01, "Link Length Error. The length in the links do not "
+			"equal the length in the Descriptor." },
+		{ 0x02, "Link Pointer Error. The pointer in link is Null "
+			"(Zero)." },
+		{ 0x03, "Job Queue Control Error. There is a bad value in "
+			"the Job Queue Control register." },
+		{ 0x04, "Invalid DESCRIPTOR Command. The Descriptor command "
+			"field is invalid." },
+		{ 0x05, "Order Error. The commands in the Descriptor are out "
+			"of order." },
+		{ 0x06, "Invalid KEY Command. The key command is invalid." },
+		{ 0x07, "Invalid LOAD Command. The load command is invalid." },
+		{ 0x08, "Invalid STORE Command. The store command is "
+			"invalid." },
+		{ 0x09, "Invalid OPERATION Command. The operation command is "
+			"invalid." },
+		{ 0x0A, "Invalid FIFO LOAD Command. The FIFO load command is "
+			"invalid." },
+		{ 0x0B, "Invalid FIFO STORE Command. The FIFO store command "
+			"is invalid." },
+		{ 0x0C, "Invalid MOVE Command. The move command is invalid." },
+		{ 0x0D, "Invalid JUMP Command. The jump command is invalid." },
+		{ 0x0E, "Invalid MATH Command. The math command is invalid." },
+		{ 0x0F, "Invalid Signed Hash Command. The signed hash command "
+			"is invalid." },
+		{ 0x10, "Invalid Sequence Command. The SEQ KEY, SEQ LOAD, "
+			"SEQ FIFO LOAD, SEQ FIFIO STORE, SEQ IN PTR OR SEQ "
+			"OUT PTR command is invalid." },
+		{ 0x11, "Internal Error. There is an internal error in the "
+			"DECO block. This is a catch all." },
+		{ 0x12, "Init Header Error. The Shared Descriptor is "
+			"invalid." },
+		{ 0x13, "Header Error. Invalid length or parity." },
+		{ 0x14, "Burster Error. Burster has gotten to an illegal "
+			"state." },
+		{ 0x15, "Secure Desc Error. The signed hash of a secure "
+			"Descriptor failed." },
+		{ 0x16, "DMA Error. A DMA error was encountered." },
+		{ 0x17, "Burster IFIFO Error. Burster detected a FIFO LOAD "
+			"command and a LOAD command both trying to put data "
+			"into the input FIFO." },
+		{ 0x1A, "Job failed due to JQ reset" },
+		{ 0x1B, "Job failed due to Fail Mode" },
+		{ 0x1C, "DECO Watchdog timer timeout error" },
+		{ 0x80, "DNR error" },
+		{ 0x81, "undefined protocol command" },
+		{ 0x82, "invalid setting in PDB" },
+		{ 0x83, "Anti-replay LATE error" },
+		{ 0x84, "Anti-replay REPLAY error" },
+		{ 0x85, "Sequence number overflow" },
+		{ 0x86, "Sigver invalid signature" },
+		{ 0x87, "DSA Sign Illegal test descriptor" },
+		{ 0xC1, "Blob command error - Undefined mode" },
+		{ 0xC2, "Blob command error - Secure Memory Blob mode error" },
+		{ 0xC4, "Blob command error - Black Blob key or input size "
+			"error" },
+		{ 0xC8, "Blob command error: Trusted/Secure mode error" },
+		{ 0x1D, "Shared Descriptor attempted to load key from a "
+			"locked DECO" },
+		{ 0x1E, "Shared Descriptor attempted to share data from a "
+			"DECO that had a Descriptor error" },
+	};
+	u8 desc_error = status & JQSTA_DECOERR_ERROR_MASK;
+	int i;
+
+	report_jump_idx(status, outstr);
+
+	for (i = 0; i < sizeof(desc_error_list); i++)
+		if (desc_error_list[i].value == desc_error)
+			break;
+
+	if (i != sizeof(desc_error_list) && desc_error_list[i].error_text) {
+		SPRINTFCAT(outstr, "%s", desc_error_list[i].error_text,
+			   strlen(desc_error_list[i].error_text));
+	} else {
+		SPRINTFCAT(outstr, "unidentified error value 0x%02x",
+			   desc_error, sizeof("ff"));
+	}
+}
+
+static void report_jq_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+static void report_cond_code_status(u32 status, char *outstr)
+{
+	SPRINTFCAT(outstr, "%s() not implemented", __func__, sizeof(__func__));
+}
+
+char *caam_jq_strstatus(char *outstr, u32 status)
+{
+	struct stat_src {
+		void (*report_ssed)(u32 status, char *outstr);
+		char *error;
+	} status_src[] = {
+		{ NULL, "No error" },
+		{ NULL, NULL },
+		{ report_ccb_status, "CCB" },
+		{ report_jump_status, "Jump" },
+		{ report_deco_status, "DECO" },
+		{ NULL, NULL },
+		{ report_jq_status, "Job Queue" },
+		{ report_cond_code_status, "Condition Code" },
+	};
+	u32 ssrc = status >> JQSTA_SSRC_SHIFT;
+
+	sprintf(outstr, "%s: ", status_src[ssrc].error);
+
+	if (status_src[ssrc].report_ssed)
+		status_src[ssrc].report_ssed(status, outstr);
+
+	return outstr;
+}
+EXPORT_SYMBOL(caam_jq_strstatus);
diff --git a/drivers/crypto/caam/error.h b/drivers/crypto/caam/error.h
new file mode 100644
index 0000000..1cbb798
--- /dev/null
+++ b/drivers/crypto/caam/error.h
@@ -0,0 +1,38 @@
+/*
+ * CAAM Error Reporting code header file
+ *
+ * Copyright (c) 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CAAM_ERROR_H
+#define CAAM_ERROR_H
+char *caam_jq_strstatus(char *outstr, u32 status);
+#endif /* CAAM_ERROR_H */
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 102c09c..4374d9c 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -42,6 +42,17 @@
 /* Currently comes from Kconfig param as a ^2 (driver-required) */
 #define JOBQ_DEPTH (1 << CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE)
 
+/* Kconfig params for interrupt coalescing if selected (else zero) */
+#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_INTC
+#define JOBQ_INTC JQCFG_ICEN
+#define JOBQ_INTC_TIME_THLD CONFIG_CRYPTO_DEV_FSL_CAAM_INTC_TIME_THLD
+#define JOBQ_INTC_COUNT_THLD CONFIG_CRYPTO_DEV_FSL_CAAM_INTC_COUNT_THLD
+#else
+#define JOBQ_INTC 0
+#define JOBQ_INTC_TIME_THLD 0
+#define JOBQ_INTC_COUNT_THLD 0
+#endif
+
 /*
  * Storage for tracking each in-process entry moving across a queue
  * Each entry on an output ring needs one of these
@@ -64,14 +75,13 @@ struct caam_drv_private_jq {
 
 	/* Job ring info */
 	int ringsize;	/* Size of rings (assume input = output) */
+	struct caam_jqentry_info *entinfo; 	/* Alloc'ed 1 per ring entry */
+	spinlock_t inplock ____cacheline_aligned; /* Input ring index lock */
 	int inp_ring_write_index;	/* Input index "tail" */
-	int out_ring_read_index;	/* Output index "tail" */
 	int *inpring;	/* Base of input ring, alloc DMA-safe */
+	spinlock_t outlock ____cacheline_aligned; /* Output ring index lock */
+	int out_ring_read_index;	/* Output index "tail" */
 	struct jq_outentry *outring;	/* Base of output ring, DMA-safe */
-	struct caam_jqentry_info *entinfo; 	/* Alloc'ed 1 per ring entry */
-	spinlock_t inplock;	/* Input ring index lock */
-	spinlock_t outlock;	/* Output ring index lock */
-
 };
 
 /*
@@ -107,6 +117,22 @@ struct caam_drv_private {
 	struct device *algapi_jq;
 	/* list of registered crypto algorithms (mk generic context handle?) */
 	struct list_head alg_list;
+
+	/*
+	 * debugfs entries for developer view into driver/device
+	 * variables at runtime.
+	 */
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dfs_root;
+	struct dentry *ctl; /* controller dir */
+	struct dentry *ctl_rq_dequeued, *ctl_ob_enc_req, *ctl_ib_dec_req;
+	struct dentry *ctl_ob_enc_bytes, *ctl_ob_prot_bytes;
+	struct dentry *ctl_ib_dec_bytes, *ctl_ib_valid_bytes;
+	struct dentry *ctl_faultaddr, *ctl_faultdetail, *ctl_faultstatus;
+
+	struct debugfs_blob_wrapper ctl_kek_wrap, ctl_tkek_wrap, ctl_tdsk_wrap;
+	struct dentry *ctl_kek, *ctl_tkek, *ctl_tdsk;
+#endif
 };
 
 void caam_jq_algapi_init(struct device *dev);
diff --git a/drivers/crypto/caam/jq.c b/drivers/crypto/caam/jq.c
index 0d71a69..0e287b5 100644
--- a/drivers/crypto/caam/jq.c
+++ b/drivers/crypto/caam/jq.c
@@ -34,10 +34,7 @@
  *
  */
 
-#include <linux/interrupt.h>
-#include <linux/dma-mapping.h>
-#include <linux/of_platform.h>
-
+#include "compat.h"
 #include "regs.h"
 #include "jq.h"
 #include "desc.h"
@@ -65,8 +62,12 @@ irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
 	 */
 	BUG_ON(irqstate & JQINT_JQ_ERROR);
 
+	/* mask valid interrupts */
+	setbits32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
+
 	/* Have valid interrupt at this point, just ACK and trigger */
 	wr_reg32(&jqp->qregs->jqintstatus, irqstate);
+
 	tasklet_schedule(&jqp->irqtask);
 
 	return IRQ_HANDLED;
@@ -75,39 +76,67 @@ irqreturn_t caam_jq_interrupt(int irq, void *st_dev)
 /* Deferred service handler, run as interrupt-fired tasklet */
 void caam_jq_dequeue(unsigned long devarg)
 {
-	int idx;
+	int jobs_in_outring, hw_idx, sw_idx, i;
 	struct device *dev = (struct device *)devarg;
 	struct caam_drv_private_jq *jqp = dev_get_drvdata(dev);
 	void (*usercall)(struct device *dev, u32 *desc, u32 status, void *arg);
 	u32 *userdesc, userstatus;
 	void *userarg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&jqp->outlock, flags);
+
+	jobs_in_outring = rd_reg32(&jqp->qregs->outring_used);
 
 	/* Processing single output entries at this time */
-	while (rd_reg32(&jqp->qregs->outring_used)) {
-		spin_lock(&jqp->outlock);
-		idx = jqp->out_ring_read_index;
-		BUG_ON((idx > JOBQ_DEPTH) || (idx < 0));
+	while (jobs_in_outring--) {
+		hw_idx = jqp->out_ring_read_index & (JOBQ_DEPTH - 1);
+
+		for (i = 0; i < JOBQ_DEPTH; i++) {
+			rmb();
+			if (bus_to_virt((u32)jqp->outring[hw_idx].desc) ==
+			    jqp->entinfo[(hw_idx + i) & (JOBQ_DEPTH - 1)].
+			    desc_addr_virt)
+				break; /* found */
+		}
+		BUG_ON(i == JOBQ_DEPTH); /*failed to find matching descriptor*/
+
+		sw_idx = (hw_idx + i) & (JOBQ_DEPTH - 1);
 
 		/* Unmap just-run descriptor so we can post-process */
-		dma_unmap_single(dev, (u32)jqp->outring[idx].desc,
-				 jqp->entinfo[idx].desc_size,
+		dma_unmap_single(dev, (u32)jqp->outring[hw_idx].desc,
+				 jqp->entinfo[sw_idx].desc_size,
 				 DMA_BIDIRECTIONAL);
 
 		/* Stash callback params for use outside of lock */
-		usercall = jqp->entinfo[idx].callbk;
-		userarg = jqp->entinfo[idx].cbkarg;
-		userdesc = jqp->entinfo[idx].desc_addr_virt;
-		userstatus = jqp->outring[idx].jqstatus;
+		usercall = jqp->entinfo[sw_idx].callbk;
+		userarg = jqp->entinfo[sw_idx].cbkarg;
+		userdesc = jqp->entinfo[sw_idx].desc_addr_virt;
+		userstatus = jqp->outring[hw_idx].jqstatus;
 
 		/* Remove entry from ring */
+		jqp->entinfo[sw_idx].desc_addr_virt = 0;
+		smp_wmb();
 		jqp->out_ring_read_index++;
-		jqp->out_ring_read_index &= (JOBQ_DEPTH - 1);
+
+		/* set done */
 		wr_reg32(&jqp->qregs->outring_rmvd, 1);
-		spin_unlock(&jqp->outlock);
+
+		spin_unlock_irqrestore(&jqp->outlock, flags);
 
 		/* Finally, execute user's callback */
 		usercall(dev, userdesc, userstatus, userarg);
+
+		spin_lock_irqsave(&jqp->outlock, flags);
 	}
+
+	spin_unlock_irqrestore(&jqp->outlock, flags);
+
+	/* reenable / unmask IRQs */
+	clrbits32(&jqp->qregs->qconfig_lo, JQCFG_IMSK);
+
+	if (rd_reg32(&jqp->qregs->outring_used))
+		tasklet_schedule(&jqp->irqtask);
 }
 
 /**
@@ -125,6 +154,7 @@ int caam_jq_register(struct device *ctrldev, struct device **qdev)
 {
 	struct caam_drv_private *ctrlpriv;
 	struct caam_drv_private_jq *jqpriv;
+	unsigned long flags;
 	int q;
 
 	jqpriv = NULL;
@@ -132,19 +162,19 @@ int caam_jq_register(struct device *ctrldev, struct device **qdev)
 
 
 	/* Lock, if free queue - assign, unlock */
-	spin_lock(&ctrlpriv->jq_alloc_lock);
+	spin_lock_irqsave(&ctrlpriv->jq_alloc_lock, flags);
 	for (q = 0; q < ctrlpriv->total_jobqs; q++) {
 		jqpriv = dev_get_drvdata(ctrlpriv->jqdev[q]);
 		if (jqpriv->assign == JOBQ_UNASSIGNED) {
 			jqpriv->assign = JOBQ_ASSIGNED;
 			*qdev = ctrlpriv->jqdev[q];
-			spin_unlock(&ctrlpriv->jq_alloc_lock);
+			spin_unlock_irqrestore(&ctrlpriv->jq_alloc_lock, flags);
 			return q;
 		}
 	}
 
 	/* If assigned, write dev where caller needs it */
-	spin_unlock(&ctrlpriv->jq_alloc_lock);
+	spin_unlock_irqrestore(&ctrlpriv->jq_alloc_lock, flags);
 	*qdev = NULL;
 	return -ENODEV;
 }
@@ -161,6 +191,7 @@ int caam_jq_deregister(struct device *qdev)
 {
 	struct caam_drv_private_jq *jqpriv = dev_get_drvdata(qdev);
 	struct caam_drv_private *ctrlpriv;
+	unsigned long flags;
 
 	/* Get the owning controller's private space */
 	ctrlpriv = dev_get_drvdata(jqpriv->parentdev);
@@ -173,9 +204,9 @@ int caam_jq_deregister(struct device *qdev)
 		return -EBUSY;
 
 	/* Release queue */
-	spin_lock(&ctrlpriv->jq_alloc_lock);
+	spin_lock_irqsave(&ctrlpriv->jq_alloc_lock, flags);
 	jqpriv->assign = JOBQ_UNASSIGNED;
-	spin_unlock(&ctrlpriv->jq_alloc_lock);
+	spin_unlock_irqrestore(&ctrlpriv->jq_alloc_lock, flags);
 
 	return 0;
 }
@@ -215,6 +246,7 @@ EXPORT_SYMBOL(caam_jq_deregister);
 		    void *areq)
 {
 	struct caam_drv_private_jq *jqp;
+	unsigned long flags;
 	int idx;
 
 	jqp = dev_get_drvdata(dev);
@@ -232,10 +264,13 @@ EXPORT_SYMBOL(caam_jq_deregister);
 	 * TODO: should be able to walk a list, but maps only
 	 * one jobdesc at a time for now
 	 */
-	spin_lock(&jqp->inplock);
-	BUG_ON((jqp->inp_ring_write_index > JOBQ_DEPTH) ||
-	       (jqp->inp_ring_write_index < 0));
-	idx = jqp->inp_ring_write_index;
+	spin_lock_irqsave(&jqp->inplock, flags);
+	idx = jqp->inp_ring_write_index & (JOBQ_DEPTH - 1);
+
+	if (jqp->entinfo[idx].desc_addr_virt != 0) {
+		spin_unlock_irqrestore(&jqp->inplock, flags);
+		return -EBUSY; /* no room */
+	}
 
 	/* Store off info that the tasklet will need */
 	jqp->entinfo[idx].desc_addr_virt = desc;
@@ -252,15 +287,17 @@ EXPORT_SYMBOL(caam_jq_deregister);
 	if (dma_mapping_error(dev, jqp->inpring[idx])) {
 		dev_err(dev,
 			"caam_jq_enqueue(): can't map jobdesc\n");
-		spin_unlock(&jqp->inplock);
+		spin_unlock_irqrestore(&jqp->inplock, flags);
 		return -EIO;
 	}
-	wr_reg32(&jqp->qregs->inpring_jobadd, 1);
-
 	/* Bump/wrap index and unlock */
+	smp_wmb();
 	jqp->inp_ring_write_index++;
-	jqp->inp_ring_write_index &= (JOBQ_DEPTH - 1);
-	spin_unlock(&jqp->inplock);
+
+	wmb();
+	wr_reg32(&jqp->qregs->inpring_jobadd, 1);
+
+	spin_unlock_irqrestore(&jqp->inplock, flags);
 
 	return 0;
 }
@@ -331,7 +368,12 @@ int caam_jq_init(struct device *dev)
 	spin_lock_init(&jqp->inplock);
 	spin_lock_init(&jqp->outlock);
 
-	/* Connect job queue interrupt handler. No coalescing yet */
+	/* Select interrupt coalescing parameters */
+	setbits32(&jqp->qregs->qconfig_lo, JOBQ_INTC |
+		  (JOBQ_INTC_COUNT_THLD << JQCFG_ICDCT_SHIFT) |
+		  (JOBQ_INTC_TIME_THLD << JQCFG_ICTT_SHIFT));
+
+	/* Connect job queue interrupt handler. */
 	tasklet_init(&jqp->irqtask, caam_jq_dequeue, (u32)dev);
 	error = request_irq(jqp->irq, caam_jq_interrupt, 0,
 			    "caam-jobq", dev);
@@ -437,11 +479,6 @@ int caam_jq_probe(struct of_device *ofdev,
 	dev_set_drvdata(jqdev, jqpriv);
 	ctrlpriv->jqdev[q] = jqdev;
 
-	/* FIXME: temporary detective code */
-	dev_info(jqdev,
-		 "caam_jq_probe: dev[%d] %08x, priv %08x, reg %08x\n",
-		 q, (u32)jqdev, (u32)jqpriv, (u32)jqpriv->qregs);
-
 	/* Identify the interrupt */
 	jqpriv->irq = of_irq_to_resource(np, 0, NULL);
 
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.c b/drivers/crypto/caam/jq_test/caam_jqtest.c
index 0f49c11..78b3112 100644
--- a/drivers/crypto/caam/jq_test/caam_jqtest.c
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.c
@@ -35,10 +35,7 @@
 
 #include "caam_jqtest.h"
 
-#define JQTEST_CYCLES 100
-
-wait_queue_head_t jqtest_wq;
-wait_queue_t jqtest_wqentry;
+#define JQTEST_CYCLES 3
 
 static int __init caam_jqtest(void)
 {
@@ -47,7 +44,6 @@ static int __init caam_jqtest(void)
 	struct device_node *ctrlnode;
 	struct of_device *ofdev;
 
-
 	/* Find a CAAM instance via device tree */
 	ctrlnode = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");
 	if (ctrlnode == NULL) {
@@ -74,18 +70,13 @@ static int __init caam_jqtest(void)
 		return -1;
 	}
 
-	/* Have a device queue for us to use. Set up waitqueue */
-	init_waitqueue_head(&jqtest_wq);
-	init_waitqueue_entry(&jqtest_wqentry, current);
-	add_wait_queue(&jqtest_wq, &jqtest_wqentry);
-
 	/* Now run cases */
 	printk(KERN_INFO "caam_jqtest: running cases on %d available queues\n",
 	       owned_queues);
 	for (q = 0; q < owned_queues; q++) {
 		for (i = 0; i < JQTEST_CYCLES; i++) {
 
-			stat = jq_ipsec_esp_no_term(qdev[q], NO_SHOW_DESC);
+			stat = jq_ipsec_esp_split(qdev[q], NO_SHOW_DESC);
 			if (stat)
 				printk(KERN_INFO
 				"jq_ipsec_esp_noterm: fail on queue %d\n",
diff --git a/drivers/crypto/caam/jq_test/caam_jqtest.h b/drivers/crypto/caam/jq_test/caam_jqtest.h
index 01c75d5..a762ee7 100644
--- a/drivers/crypto/caam/jq_test/caam_jqtest.h
+++ b/drivers/crypto/caam/jq_test/caam_jqtest.h
@@ -37,13 +37,15 @@
 
 #include "../compat.h"
 #include "../desc.h"
+#include "../pdb.h"
 #include "../dcl/dcl.h"
 #include "../jq.h"
+#include "../error.h"
 
 #define SHOW_DESC 1
 #define NO_SHOW_DESC 0
 
-int jq_ipsec_esp_no_term(struct device *dev, int showdesc);
+int jq_ipsec_esp_split(struct device *dev, int showdesc);
 int jq_snow_f8(struct device *dev, int showdesc);
 int jq_snow_f9(struct device *dev, int show);
 int jq_aes_cbc_shared(struct device *dev, int show);
diff --git a/drivers/crypto/caam/jq_test/jq_blkcipher.c b/drivers/crypto/caam/jq_test/jq_blkcipher.c
index b3cc6b9..f050da6 100644
--- a/drivers/crypto/caam/jq_test/jq_blkcipher.c
+++ b/drivers/crypto/caam/jq_test/jq_blkcipher.c
@@ -34,34 +34,6 @@
 
 #include "caam_jqtest.h"
 
-#if 0
-static const u_int8_t key[] = {
-	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
-	0xf0, 0xe1, 0xd2, 0xc3, 0xb4, 0xa5, 0x96, 0x87
-};
-
-static const u_int8_t in[] = {
-	"Now is the time for all good men"
-};
-
-static const u_int8_t iv[] = {
-	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
-	0x01, 0x23, 0x45, 0x57, 0x89, 0xab, 0xcd, 0xef
-};
-
-static const u_int8_t out[] = {
-	0x1e, 0x4d, 0xe7, 0x24, 0xeb, 0x93, 0xb0, 0xe0,
-	0xea, 0x74, 0xe0, 0x1b, 0x1b, 0x2f, 0x17, 0x2e,
-	0xcf, 0xa9, 0xad, 0x2a, 0x0e, 0x63, 0xd3, 0x6e,
-	0xef, 0x4a, 0x07, 0x69, 0x02, 0xca, 0xa2, 0x4b
-};
-
-#define AES_TESTSET_SIZE 32
-#define AES_KEY_SIZE 16
-#define AES_IV_SIZE 16
-
-#endif
-
 static const u_int8_t in[] = {
 	0xC4, 0x75, 0xC5, 0xFA, 0x30, 0x86, 0x21, 0x3F,
 	0x1A, 0xEC, 0xDA, 0xA1, 0x0E, 0xBF, 0xF3, 0x71,
@@ -144,28 +116,32 @@ static const u_int8_t key[] = {
 #define AES_KEY_SIZE 32
 #define AES_IV_SIZE 16
 
-extern wait_queue_head_t jqtest_wq;
+static struct completion completion;
 
 void jq_blkcipher_done(struct device *dev, u32 *head, u32 status, void *auxarg)
 {
-	(*(int *)auxarg)++;
-	wake_up_interruptible(&jqtest_wq);
+	/* Write back returned status, and continue */
+	*(u32 *)auxarg = status;
+	complete(&completion);
 }
 
-
 int jq_aes_cbc_shared(struct device *dev, int show)
 {
 	int stat, exit, rtnval = 0;
 	u32 *sdesc, *jdesc, *sdmap, *jdmap;
 	u8 *inbuf, *outbuf, *inmap, *outmap;
 	u16 sdsz, jdsz, inbufsz, outbufsz;
-	int jqarg;
+	u32 rqstatus;
+	u8 err[256];
+	u8 testname[] = "jq_aes_cbc_shared";
 
 	sdsz = 64 * sizeof(u32);
 	jdsz = 16 * sizeof(u32);
 	inbufsz = AES_TESTSET_SIZE;
 	outbufsz = AES_TESTSET_SIZE;
 
+	init_completion(&completion);
+
 	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
 	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
 	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
@@ -174,7 +150,7 @@ int jq_aes_cbc_shared(struct device *dev, int show)
 
 	if ((sdesc == NULL) || (jdesc == NULL) ||
 	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "jq_aes_cbc_shared: can't get buffers\n");
+		printk(KERN_INFO "%s: can't get buffers\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		kfree(inbuf);
@@ -183,6 +159,7 @@ int jq_aes_cbc_shared(struct device *dev, int show)
 	};
 
 	memcpy(inbuf, in, inbufsz);
+	memset(outbuf, 0, outbufsz);
 
 	stat = cnstr_shdsc_cbc_blkcipher(sdesc, &sdsz, (u_int8_t *)key,
 					 AES_KEY_SIZE * 8,
@@ -190,7 +167,7 @@ int jq_aes_cbc_shared(struct device *dev, int show)
 					 DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
 	if (stat) {
 		printk(KERN_INFO
-		       "jq_aes_cbc_shared: sharedesc construct failed\n");
+		       "%s: sharedesc construct failed\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		kfree(inbuf);
@@ -208,29 +185,37 @@ int jq_aes_cbc_shared(struct device *dev, int show)
 	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
 
 	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc);
-		caam_desc_disasm(sdesc);
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
+		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
 	}
 
-	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done, (void *)&jqarg);
+	init_completion(&completion);
+
+	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done,
+			       (void *)&rqstatus);
 	if (stat) {
-		printk(KERN_INFO "jq_aes_cbc_shared: can't enqueue\n");
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
 		rtnval = -1;
 	}
-	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	exit = wait_for_completion_interruptible(&completion);
 	if (exit)
-		printk(KERN_INFO "jq_aes_cbc_shared: interrupted\n");
+		printk(KERN_INFO "%s: interrupted\n", testname);
 
 	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
 	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
 
-	if (memcmp(out, outbuf, outbufsz)) {
-		printk(KERN_INFO "jq_aes_cbc_shared: output mismatch\n");
-		printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
-			outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
-	}
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
+		       rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+	} else
+		if (memcmp(out, outbuf, outbufsz)) {
+			printk(KERN_INFO "%s: output mismatch\n", testname);
+			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
+			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
+		}
 
 	kfree(sdesc);
 	kfree(jdesc);
@@ -247,7 +232,11 @@ int jq_aes_cbc_job(struct device *dev, int show)
 	u8 *inbuf, *outbuf, *inmap, *outmap;
 	u8 *keybuf, *keymap, *ivbuf, *ivmap;
 	u16 jdsz, inbufsz, outbufsz;
-	int jqarg;
+	u32 rqstatus;
+	u8 err[256];
+	u8 testname[] = "jq_aes_cbc_job";
+
+	init_completion(&completion);
 
 	jdsz = 64 * sizeof(u32);
 	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
@@ -261,7 +250,7 @@ int jq_aes_cbc_job(struct device *dev, int show)
 
 	if ((jdesc == NULL) || (inbuf == NULL) || (outbuf == NULL) ||
 	    (keybuf == NULL) || (ivbuf == NULL)) {
-		printk(KERN_INFO "jq_aes_cbc_job: can't get buffers\n");
+		printk(KERN_INFO "%s: can't get buffers\n", testname);
 		kfree(jdesc);
 		kfree(inbuf);
 		kfree(outbuf);
@@ -273,6 +262,7 @@ int jq_aes_cbc_job(struct device *dev, int show)
 	memcpy(inbuf, in, inbufsz);
 	memcpy(keybuf, key, AES_KEY_SIZE);
 	memcpy(ivbuf, iv, AES_IV_SIZE);
+	memset(outbuf, 0, outbufsz);
 
 	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
 	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
@@ -287,30 +277,39 @@ int jq_aes_cbc_job(struct device *dev, int show)
 					   DIR_DECRYPT, OP_ALG_ALGSEL_AES, 0);
 	if (stat) {
 		printk(KERN_INFO
-		       "jq_aes_cbc_job: jobdesc construct failed\n");
+		       "%s: jobdesc construct failed\n", testname);
 		kfree(jdesc);
 		return -1;
 	};
 
 	if (show == SHOW_DESC)
-		caam_desc_disasm(jdesc);
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
 
-	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done, (void *)&jqarg);
+	stat = caam_jq_enqueue(dev, jdesc, jq_blkcipher_done,
+			       (void *)&rqstatus);
 	if (stat) {
-		printk(KERN_INFO "jq_aes_cbc_job: can't enqueue\n");
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
 		rtnval = -1;
 	}
-	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	exit = wait_for_completion_interruptible(&completion);
 	if (exit)
-		printk(KERN_INFO "jq_aes_cbc_job: interrupted\n");
+		printk(KERN_INFO "%s: interrupted\n", testname);
 
 	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
 	dma_unmap_single(dev, (u32)keymap, AES_KEY_SIZE, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)ivmap, AES_IV_SIZE, DMA_TO_DEVICE);
 
-	if (memcmp(out, outbuf, outbufsz))
-		printk(KERN_INFO "jq_aes_cbc_job: output mismatch\n");
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
+		       rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+	} else
+		if (memcmp(out, outbuf, outbufsz)) {
+			printk(KERN_INFO "%s: output mismatch\n", testname);
+			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
+			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
+		}
 
 	kfree(jdesc);
 	kfree(inbuf);
diff --git a/drivers/crypto/caam/jq_test/jq_ipsec.c b/drivers/crypto/caam/jq_test/jq_ipsec.c
index 24e91cf..f3ba49a 100644
--- a/drivers/crypto/caam/jq_test/jq_ipsec.c
+++ b/drivers/crypto/caam/jq_test/jq_ipsec.c
@@ -35,133 +35,347 @@
 #include "caam_jqtest.h"
 
 
-
+/* Class 2 padded all the way out to 64 bytes */
 static u8 class_2_key[] = {
-	0x00, 0xe0, 0xf0, 0xa0,
-	0x00, 0xd0, 0xf0, 0xa0,
-	0x0a, 0xd0, 0xf0, 0xa0,
-	0x0b, 0xd0, 0xf0, 0xa0,
-	0x0f, 0xd0, 0xf0, 0xa0 };
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f };
 
 static u8 class_1_key[] = {
-	0x00, 0x0e, 0x0f, 0x00,
-	0x0c, 0x0f, 0x0a, 0x00,
-	0x0a, 0x0f, 0x0a, 0x00,
-	0x0b, 0x0f, 0x0a, 0x00 };
+	0x00, 0x0e, 0x0f, 0x00, 0x0c, 0x0f, 0x0a, 0x00,
+	0x0a, 0x0f, 0x0a, 0x00, 0x0b, 0x0f, 0x0a, 0x00 };
+
+#define OPTHDRSZ 52
+static const u_int8_t opthdr[] = {
+	0x34, 0x00, 0x10, 0x45, 0x00, 0x40, 0x25, 0x12,
+	0xd2, 0x86, 0x06, 0x40, 0x77, 0x46, 0x43, 0x0a,
+	0xc0, 0x46, 0x43, 0x0a, 0x16, 0x00, 0x22, 0xd0,
+	0x5d, 0x89, 0x18, 0x88, 0x9c, 0xee, 0x19, 0x12,
+	0xbc, 0x21, 0x10, 0x80, 0x00, 0x00, 0x08, 0x98,
+	0x0a, 0x08, 0x01, 0x01, 0x22, 0x75, 0x9a, 0xa6,
+	0xdb, 0x14, 0x3f, 0x08
+};
 
+static const u_int8_t incmp[] = {
+	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x02, 0x03, 0x14, 0x15, 0x06, 0x07,
+	0x18, 0x19, 0x0a, 0x0b, 0x1c, 0x1d, 0x0e, 0x0f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
+	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+};
 
-extern wait_queue_head_t jqtest_wq;
+static struct completion completion;
 
 void jq_ipsec_done(struct device *dev, u32 *head, u32 status, void *auxarg)
 {
-	/* Bump volatile completion test value and wake calling thread */
-	(*(int *)auxarg)++;
-	wake_up_interruptible(&jqtest_wq);
+	/* Write back returned status, and continue */
+	*(u32 *)auxarg = status;
+	complete(&completion);
 }
 
+#define SHA1_HMAC_KEYSZ 20
+#define SHA1_HMAC_PADSZ 20
+#define SHA224_HMAC_KEYSZ 28
+#define SHA224_HMAC_PADSZ 32
+#define SHA256_HMAC_KEYSZ 32
+#define SHA256_HMAC_PADSZ 32
+#define SHA384_HMAC_KEYSZ 48
+#define SHA384_HMAC_PADSZ 64
+#define SHA512_HMAC_KEYSZ 64
+#define SHA512_HMAC_PADSZ 64
+
+#define AES_KEYSZ 16
 
-int jq_ipsec_esp_no_term(struct device *dev, int show)
+int jq_ipsec_esp_split(struct device *dev, int show)
 {
 	int stat, exit, rtnval = 0;
-	u32 *sdesc, *jdesc, *sdmap, *jdmap;
-	u8 *inbuf, *outbuf, *inmap, *outmap;
-	u16 sdsz, jdsz, inbufsz, outbufsz;
-	int jqarg;
-	struct pdbcont pdb;
-	struct cipherparams cipher;
+	u32 *jdesc, *jdmap, *encapdesc, *encapdmap, *decapdesc, *decapdmap;
+	u32 rqstatus;
+	u8 *hmackeybuf, *spkeybuf, *hmackeymap, *spkeymap;
+	u8 *inbuf, *encapbuf, *decapbuf, *inmap, *encapmap, *decapmap;
+	u8 *cipherkeybuf, *cipherkeymap;
+	u16 jdsz, encapdsz, decapdsz, cipherkeysz, hmackeysz;
+	u16 padsz, inbufsz, encapbufsz, decapbufsz;
+	struct ipsec_encap_pdb encappdb;
+	struct ipsec_decap_pdb decappdb;
 	struct authparams auth;
+	struct cipherparams cipher;
+	u8 err[256];
+	u8 testname[] = "jq_ipsec_esp_split";
 
-	jqarg = 0;
-
-	/* Allocate more than necessary for both descs */
-	sdsz = 64 * sizeof(u32);
-	jdsz = 16 * sizeof(u32);
-	sdesc = kzalloc(sdsz, GFP_KERNEL | GFP_DMA);
-	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+	init_completion(&completion);
 
-	/* Allocate buffers */
+	/*
+	 * Compute buffer/descriptor sizes
+	 */
+	cipherkeysz = AES_KEYSZ;
+	hmackeysz = SHA1_HMAC_KEYSZ;
+	padsz = SHA1_HMAC_PADSZ;
 	inbufsz = 64;
-	outbufsz = 116;
+	encapbufsz = 8+16+inbufsz+28; /* payload+SPI+IV+pad+padlen+ICV */
+	decapbufsz = inbufsz;
+
+	jdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
+	encapdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
+	decapdsz = MAX_CAAM_DESCSIZE * sizeof(u32);
+
+	/*
+	 * Alloc buffer/descriptor space
+	 */
+	hmackeybuf = kmalloc(hmackeysz, GFP_KERNEL | GFP_DMA);
+	cipherkeybuf = kmalloc(cipherkeysz, GFP_KERNEL | GFP_DMA);
+	spkeybuf = kmalloc(padsz, GFP_KERNEL | GFP_DMA);
 	inbuf = kmalloc(inbufsz, GFP_KERNEL | GFP_DMA);
-	outbuf = kmalloc(outbufsz, GFP_KERNEL | GFP_DMA);
-
-	if ((sdesc == NULL) || (jdesc == NULL) ||
-	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "jq_ipsec_esp_no_term: can't get buffers\n");
-		kfree(sdesc);
-		kfree(jdesc);
-		kfree(inbuf);
-		kfree(outbuf);
-		return -1;
+	encapbuf = kmalloc(encapbufsz, GFP_KERNEL | GFP_DMA);
+	decapbuf = kmalloc(decapbufsz, GFP_KERNEL | GFP_DMA);
+
+	jdesc = kzalloc(jdsz, GFP_KERNEL | GFP_DMA);
+	encapdesc = kzalloc(encapdsz, GFP_KERNEL | GFP_DMA);
+	decapdesc = kzalloc(decapdsz, GFP_KERNEL | GFP_DMA);
+
+	if ((hmackeybuf == NULL) || (cipherkeybuf == NULL) ||
+	    (spkeybuf == NULL) || (jdesc == NULL) || (encapdesc == NULL) ||
+	    (decapdesc == NULL) || (inbuf == NULL) || (encapbuf == NULL) ||
+	    (decapbuf == NULL)) {
+		printk(KERN_INFO "%s: can't get buffers\n", testname);
+		rtnval = -1;
+		goto freeup;
 	};
 
-	/* Fill out PDB options, no optional header */
-	pdb.opthdrlen = 0;
-	pdb.opthdr = NULL;
-	pdb.transmode = PDB_TUNNEL;
-	pdb.pclvers = PDB_IPV4;
-	pdb.outfmt = PDB_OUTPUT_COPYALL;
-	pdb.ivsrc = PDB_IV_FROM_RNG;
-	pdb.seq.esn = PDB_NO_ESN;
-	pdb.seq.antirplysz = PDB_ANTIRPLY_NONE;
-
-	/* Do transforms */
+	/*
+	 * First step, generate MD split-key for shared descriptors to use
+	 * Precoat key buffer
+	 */
+	memcpy(hmackeybuf, class_2_key, hmackeysz);
+
+	/* Map job, input key, output splitkey */
+	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
+	hmackeymap = (u8 *)dma_map_single(dev, hmackeybuf, hmackeysz,
+					  DMA_TO_DEVICE);
+	spkeymap = (u8 *)dma_map_single(dev, spkeybuf, padsz,
+					DMA_FROM_DEVICE);
+
+	/*
+	 * Construct keysplitter using mapped HMAC input buffer
+	 * and mapped split key output buffer
+	 */
+	stat = cnstr_jobdesc_mdsplitkey(jdesc, &jdsz, hmackeymap,
+					OP_ALG_ALGSEL_SHA1, spkeymap);
+
+	if (show == SHOW_DESC)
+		caam_desc_disasm(jdesc, DISASM_SHOW_RAW | DISASM_SHOW_OFFSETS);
+
+	/* Execute keysplitter */
+	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
+	if (stat) {
+		printk(KERN_INFO "%s can't enqueue\n", testname);
+		rtnval = -1;
+	}
+	exit = wait_for_completion_interruptible(&completion);
+	if (exit) {
+		printk(KERN_INFO "%s interrupted\n", testname);
+		rtnval = -1;
+	}
+
+	/* Unmap splitter desc, input key, output splitkey */
+	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)hmackeymap, hmackeysz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)spkeymap, padsz, DMA_FROM_DEVICE);
+
+	/* If problem, report, free jobdesc and splitkey, return */
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
+		       rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+		goto freeup;
+	}
+
+	/*
+	 * Now we have a covered HMAC split key. Build our encapsulation
+	 * and decapsulation descriptors
+	 */
+
+	/* Precoat blockcipher key */
+	memcpy(cipherkeybuf, class_1_key, cipherkeysz);
+
+	/*
+	 * Set up a PDB for the encapsulation side. In this case, am not
+	 * doing header prepend
+	 */
+	memset(&encappdb, 0, sizeof(encappdb));
+	/* encappdb.options = PDBOPTS_ESPCBC_TUNNEL; */
+	/* encappdb.opt_hdr_len = OPTHDRSZ; */
+	encappdb.cbc.iv[0] = 0x01234569;
+	encappdb.cbc.iv[1] = 0x89abcdef;
+	encappdb.cbc.iv[2] = 0xfedcba98;
+	encappdb.cbc.iv[3] = 0x76543210;
+
+	/* Set up a PDB for the decapsulation side */
+	/* decappdb.ip_hdr_len = OPTHDRSZ; */
+	decappdb.options = PDBOPTS_ESPCBC_OUTFMT;
+
+	/* Map key buffers before the descbuild */
+	spkeymap = (u8 *)dma_map_single(dev, spkeybuf, padsz, DMA_TO_DEVICE);
+	cipherkeymap = (u8 *)dma_map_single(dev, cipherkeybuf, 16,
+					    DMA_TO_DEVICE);
+
+	/* Now set up transforms with mapped cipher and auth keys */
 	cipher.algtype = CIPHER_TYPE_IPSEC_AESCBC;
-	cipher.key = class_1_key;
-	cipher.keylen = 16 * 8; /* AES keysize in bits */
+	cipher.key = cipherkeymap;
+	cipher.keylen = cipherkeysz * 8; /* AES keysize in bits */
 
 	auth.algtype = AUTH_TYPE_IPSEC_SHA1HMAC_96;
-	auth.key = class_2_key;
-	auth.keylen = 20 * 8; /* SHA1 keysize in bits */
+	auth.key = spkeymap;
+	auth.keylen = SHA1_HMAC_KEYSZ * 2 * 8;
+
+	/*
+	 * Have our keys, cipher selections, and PDB set up for the
+	 * sharedesc constructor. Now construct it
+	 */
+	stat = cnstr_shdsc_ipsec_encap(encapdesc, &encapdsz, &encappdb,
+				       (u8 *)opthdr, &cipher, &auth);
+	if (stat) {
+		printk(KERN_INFO
+		       "%s: encap sharedesc construct failed\n", testname);
+		goto freeup;
+		return -1;
+	};
 
-	/* Now construct */
-	stat = cnstr_pcl_shdsc_ipsec_cbc_encap(sdesc, &sdsz, &pdb, &cipher,
-					       &auth, 0);
+	stat = cnstr_shdsc_ipsec_decap(decapdesc, &decapdsz, &decappdb,
+				       &cipher, &auth);
 	if (stat) {
 		printk(KERN_INFO
-		       "jq_ipsec_esp_no_term: sharedesc construct failed\n");
-		kfree(sdesc);
-		kfree(jdesc);
+		       "%s: decap sharedesc construct failed\n", testname);
+		goto freeup;
 		return -1;
 	};
 
-	/* Map data prior to jobdesc build */
-	sdmap = (u32 *)dma_map_single(dev, sdesc, sdsz, DMA_BIDIRECTIONAL);
+	/*
+	 * Starting encapsulation phase. Precoat the input frame
+	 * with a known pattern
+	 */
+	memcpy(inbuf, incmp, inbufsz);
+
+	/*
+	 * Encap shared descriptor is ready to go. Now, map it.
+	 * Also, map the input frame and output frame before building
+	 * a sequence job descriptor to run the frame
+	 */
+	encapdmap = (u32 *)dma_map_single(dev, encapdesc, encapdsz,
+					  DMA_BIDIRECTIONAL);
 	inmap = (u8 *)dma_map_single(dev, inbuf, inbufsz, DMA_TO_DEVICE);
-	outmap = (u8 *)dma_map_single(dev, outbuf, outbufsz, DMA_FROM_DEVICE);
+	encapmap = (u8 *)dma_map_single(dev, encapbuf, encapbufsz,
+					DMA_FROM_DEVICE);
 
-	/* build jobdesc */
-	cnstr_seq_jobdesc(jdesc, &jdsz, sdmap, sdsz, inmap, inbufsz,
-			  outmap, outbufsz);
+	/* With mapped buffers, build/map jobdesc for this frame */
+	stat = cnstr_seq_jobdesc(jdesc, &jdsz, encapdmap, encapdsz,
+				 inmap, inbufsz, encapmap, encapbufsz);
 
-	/* map jobdesc */
 	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
+	if (stat) {
+		printk(KERN_INFO
+		       "%s: encap jobdesc construct failed\n", testname);
+		goto freeup;
+		return -1;
+	};
 
 	/* Show it before we run it */
 	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc);
-		caam_desc_disasm(sdesc);
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
+		caam_desc_disasm(encapdesc, DISASM_SHOW_OFFSETS);
 	}
 
-	/* Enqueue and block*/
-	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&jqarg);
+	/* Enqueue the encapsulation job and block */
+	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
 	if (stat) {
-		printk(KERN_INFO "jq_ipsec_esp_no_term: can't enqueue\n");
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
+		rtnval = -1;
+	}
+	exit = wait_for_completion_interruptible(&completion);
+	if (exit) {
+		printk(KERN_INFO "%s interrupted\n", testname);
 		rtnval = -1;
 	}
-	exit = wait_event_interruptible(jqtest_wq, (jqarg));
-	if (exit)
-		printk(KERN_INFO "jq_ipsec_esp_no_term: interrupted\n");
-
 
-	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
+	/* Upmap shared desc, job desc, and inputs */
+	dma_unmap_single(dev, (u32)encapdmap, encapdsz, DMA_BIDIRECTIONAL);
 	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
-	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
-	kfree(sdesc);
+	dma_unmap_single(dev, (u32)encapmap, encapbufsz, DMA_FROM_DEVICE);
+
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n",
+		       testname, rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+		goto freeup;
+	}
+
+	/*
+	 * Now do decapsulation phase. Map the decapsulation descriptor
+	 * and encapsulation-input/decapsulation-output frames in their
+	 * correct directions
+	 */
+	decapdmap = (u32 *)dma_map_single(dev, decapdesc, decapdsz,
+					  DMA_BIDIRECTIONAL);
+	encapmap = (u8 *)dma_map_single(dev, encapbuf, encapbufsz,
+					DMA_TO_DEVICE);
+	decapmap = (u8 *)dma_map_single(dev, decapbuf, decapbufsz,
+					DMA_FROM_DEVICE);
+
+	/* With mapped buffers, build/map jobdesc for this frame */
+	stat = cnstr_seq_jobdesc(jdesc, &jdsz, decapdmap, decapdsz,
+				 encapmap, encapbufsz, decapmap, decapbufsz);
+
+	jdmap = (u32 *)dma_map_single(dev, jdesc, jdsz, DMA_TO_DEVICE);
+	if (stat) {
+		printk(KERN_INFO
+		       "%s: encap jobdesc construct failed\n", testname);
+		goto freeup;
+		return -1;
+	};
+
+	if (show == SHOW_DESC) {
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
+		caam_desc_disasm(decapdesc, DISASM_SHOW_OFFSETS);
+	}
+
+	/* Enqueue the decapsulation job and block */
+	stat = caam_jq_enqueue(dev, jdesc, jq_ipsec_done, (void *)&rqstatus);
+	if (stat) {
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
+		rtnval = -1;
+	}
+	exit = wait_for_completion_interruptible(&completion);
+	if (exit) {
+		printk(KERN_INFO "%s interrupted\n", testname);
+		rtnval = -1;
+	}
+
+	/* Upmap shared desc, job desc, inputs and outputs */
+	dma_unmap_single(dev, (u32)decapdmap, decapdsz, DMA_BIDIRECTIONAL);
+	dma_unmap_single(dev, (u32)jdmap, jdsz, DMA_TO_DEVICE);
+	dma_unmap_single(dev, (u32)encapmap, encapbufsz, DMA_FROM_DEVICE);
+	dma_unmap_single(dev, (u32)decapmap, decapbufsz, DMA_FROM_DEVICE);
+
+
+freeup:
+	kfree(hmackeybuf);
+	kfree(cipherkeybuf);
+	kfree(spkeybuf);
 	kfree(jdesc);
+	kfree(encapdesc);
+	kfree(decapdesc);
 	kfree(inbuf);
-	kfree(outbuf);
-
+	kfree(encapbuf);
+	kfree(decapbuf);
 	return rtnval;
 }
+
diff --git a/drivers/crypto/caam/jq_test/jq_snow.c b/drivers/crypto/caam/jq_test/jq_snow.c
index 8f890de..ac11c12 100644
--- a/drivers/crypto/caam/jq_test/jq_snow.c
+++ b/drivers/crypto/caam/jq_test/jq_snow.c
@@ -74,13 +74,13 @@ static const u_int32_t count = 0x398a59b4;
 static const u_int8_t bearer = 0x15;
 static const u_int8_t direction = 0x1;
 
-extern wait_queue_head_t jqtest_wq;
+static struct completion completion;
 
 void jq_snow_done(struct device *dev, u32 *head, u32 status, void *auxarg)
 {
-	/* Bump volatile completion test value and wake calling thread */
-	(*(int *)auxarg)++;
-	wake_up_interruptible(&jqtest_wq);
+	/* Write back returned status, and continue */
+	*(u32 *)auxarg = status;
+	complete(&completion);
 }
 
 int jq_snow_f8(struct device *dev, int show)
@@ -89,9 +89,11 @@ int jq_snow_f8(struct device *dev, int show)
 	u32 *sdesc, *jdesc, *sdmap;
 	u8 *inbuf, *outbuf, *inmap, *outmap;
 	u16 sdsz, jdsz, inbufsz, outbufsz;
-	int jqarg;
+	u32 rqstatus;
+	u8 err[256];
+	u8 testname[] = "jq_snow_f8";
 
-	jqarg = 0;
+	init_completion(&completion);
 
 	/* Allocate more than necessary for both descs */
 	sdsz = 64 * sizeof(u32);
@@ -107,7 +109,7 @@ int jq_snow_f8(struct device *dev, int show)
 
 	if ((sdesc == NULL) || (jdesc == NULL) ||
 	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "jq_snow_f8: can't get buffers\n");
+		printk(KERN_INFO "%s: can't get buffers\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		kfree(inbuf);
@@ -123,7 +125,7 @@ int jq_snow_f8(struct device *dev, int show)
 
 	if (stat) {
 		printk(KERN_INFO
-		       "jq_snow_f8: sharedesc construct failed\n");
+		       "%s: sharedesc construct failed\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		return -1;
@@ -141,26 +143,34 @@ int jq_snow_f8(struct device *dev, int show)
 
 	/* Show it before we run it */
 	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc);
-		caam_desc_disasm(sdesc);
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
+		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
 	}
 
 	/* Enqueue and block*/
-	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&jqarg);
+	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&rqstatus);
 	if (stat) {
-		printk(KERN_INFO "jq_snow_f8: can't enqueue\n");
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
 		rtnval = -1;
 	}
-	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	exit = wait_for_completion_interruptible(&completion);
 	if (exit)
-		printk(KERN_INFO "jq_snow_f8: interrupted\n");
+		printk(KERN_INFO "%s: interrupted\n", testname);
 
 	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
 	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
 
-	if (memcmp(output_msg_data, outbuf, outbufsz))
-		printk(KERN_INFO "jq_snow_f8: output mismatch\n");
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
+		       rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+	} else
+		if (memcmp(output_msg_data, outbuf, outbufsz)) {
+			printk(KERN_INFO "%s: output mismatch\n", testname);
+			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
+			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
+		}
 
 	kfree(sdesc);
 	kfree(jdesc);
@@ -198,9 +208,11 @@ int jq_snow_f9(struct device *dev, int show)
 	u32 *sdesc, *jdesc, *sdmap;
 	u8 *inbuf, *outbuf, *inmap, *outmap;
 	u16 sdsz, jdsz, inbufsz, outbufsz;
-	int jqarg;
+	u32 rqstatus;
+	u8 err[256];
+	u8 testname[] = "jq_snow_f9";
 
-	jqarg = 0;
+	init_completion(&completion);
 
 	/* Allocate more than necessary for both descs */
 	sdsz = 64 * sizeof(u32);
@@ -216,7 +228,7 @@ int jq_snow_f9(struct device *dev, int show)
 
 	if ((sdesc == NULL) || (jdesc == NULL) ||
 	    (inbuf == NULL) || (outbuf == NULL)) {
-		printk(KERN_INFO "jq_snow_f9: can't get buffers\n");
+		printk(KERN_INFO "%s: can't get buffers\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		kfree(inbuf);
@@ -232,7 +244,7 @@ int jq_snow_f9(struct device *dev, int show)
 
 	if (stat) {
 		printk(KERN_INFO
-		       "jq_snow_f9: sharedesc construct failed\n");
+		       "%s: sharedesc construct failed\n", testname);
 		kfree(sdesc);
 		kfree(jdesc);
 		return -1;
@@ -249,26 +261,34 @@ int jq_snow_f9(struct device *dev, int show)
 
 	/* Show it before we run it */
 	if (show == SHOW_DESC) {
-		caam_desc_disasm(jdesc);
-		caam_desc_disasm(sdesc);
+		caam_desc_disasm(jdesc, DISASM_SHOW_OFFSETS);
+		caam_desc_disasm(sdesc, DISASM_SHOW_OFFSETS);
 	}
 
 	/* Enqueue and block*/
-	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&jqarg);
+	stat = caam_jq_enqueue(dev, jdesc, jq_snow_done, (void *)&rqstatus);
 	if (stat) {
-		printk(KERN_INFO "jq_snow_f9: can't enqueue\n");
+		printk(KERN_INFO "%s: can't enqueue\n", testname);
 		rtnval = -1;
 	}
-	exit = wait_event_interruptible(jqtest_wq, (jqarg));
+	exit = wait_for_completion_interruptible(&completion);
 	if (exit)
-		printk(KERN_INFO "jq_snow_f9: interrupted\n");
+		printk(KERN_INFO "%s: interrupted\n", testname);
 
 	dma_unmap_single(dev, (u32)sdmap, sdsz, DMA_BIDIRECTIONAL);
 	dma_unmap_single(dev, (u32)inmap, inbufsz, DMA_TO_DEVICE);
 	dma_unmap_single(dev, (u32)outmap, outbufsz, DMA_FROM_DEVICE);
 
-	if (memcmp(uia2_out, outbuf, outbufsz))
-		printk(KERN_INFO "jq_snow_f9: output mismatch\n");
+	if ((rtnval) || (rqstatus)) {
+		printk(KERN_INFO "%s: request status = 0x%08x\n", testname,
+		       rqstatus);
+		printk(KERN_INFO "%s\n", caam_jq_strstatus(err, rqstatus));
+	} else
+		if (memcmp(uia2_out, outbuf, outbufsz)) {
+			printk(KERN_INFO "%s: output mismatch\n", testname);
+			printk(KERN_INFO "0x%02x 0x%02x 0x%02x 0x%02x\n",
+			       outbuf[0], outbuf[1], outbuf[2], outbuf[3]);
+		}
 
 	kfree(sdesc);
 	kfree(jdesc);
diff --git a/drivers/crypto/caam/pdb.h b/drivers/crypto/caam/pdb.h
new file mode 100644
index 0000000..3ced12a
--- /dev/null
+++ b/drivers/crypto/caam/pdb.h
@@ -0,0 +1,393 @@
+/*
+ * CAAM Protocol Data Block (PDB) definition header file
+ *
+ * Copyright (c) 2008, 2009, Freescale Semiconductor, Inc.
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CAAM_PDB_H
+#define CAAM_PDB_H
+
+/*
+ * General IPSec encap/decap PDB definitions
+ */
+struct ipsec_encap_cbc {
+	__be32 iv[4];
+} __packed;
+
+struct ipsec_encap_ctr {
+	__be32 ctr_nonce;
+	__be32 ctr_initial;
+	__be32 iv[2];
+} __packed;
+
+struct ipsec_encap_ccm {
+	__be32 salt; /* lower 24 bits */
+	u8 b0_flags;
+	u8 ctr_flags;
+	__be16 ctr_initial;
+	__be32 iv[2];
+} __packed;
+
+struct ipsec_encap_gcm {
+	__be32 salt; /* lower 24 bits */
+	__be32 rsvd1;
+	__be32 iv[2];
+} __packed;
+
+struct ipsec_encap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd;
+	u8 ip_nh;
+	u8 ip_nh_offset;
+	u8 options;
+	__be32 seq_num_ext_hi;
+	__be32 seq_num;
+	union {
+		struct ipsec_encap_cbc cbc;
+		struct ipsec_encap_ctr ctr;
+		struct ipsec_encap_ccm ccm;
+		struct ipsec_encap_gcm gcm;
+	};
+	__be32 spi;
+	__be16 rsvd1;
+	__be16 ip_hdr_len;
+	__be32 ip_hdr[0]; /* optional IP Header content */
+} __packed;
+
+struct ipsec_decap_cbc {
+	__be32 rsvd[2];
+} __packed;
+
+struct ipsec_decap_ctr {
+	__be32 salt;
+	__be32 ctr_initial;
+} __packed;
+
+struct ipsec_decap_ccm {
+	__be32 salt;
+	u8 iv_flags;
+	u8 ctr_flags;
+	__be16 ctr_initial;
+} __packed;
+
+struct ipsec_decap_gcm {
+	__be32 salt;
+	__be32 resvd;
+} __packed;
+
+struct ipsec_decap_pdb {
+	__be32 desc_hdr;
+	__be16 ip_hdr_len;
+	u8 ip_nh_offset;
+	u8 options;
+	union {
+		struct ipsec_decap_cbc cbc;
+		struct ipsec_decap_ctr ctr;
+		struct ipsec_decap_ccm ccm;
+		struct ipsec_decap_gcm gcm;
+	};
+	__be32 seq_num_ext_hi;
+	__be32 seq_num;
+	__be32 anti_replay[2];
+	__be32 end_index[0];
+} __packed;
+
+/*
+ * IEEE 802.11i WiFi Protocol Data Block
+ */
+#define WIFI_PDBOPTS_FCS	0x01
+#define WIFI_PDBOPTS_AR		0x40
+
+struct wifi_encap_pdb {
+	__be32 desc_hdr;
+	__be16 mac_hdr_len;
+	u8 rsvd;
+	u8 options;
+	u8 iv_flags;
+	u8 pri;
+	__be16 pn1;
+	__be32 pn2;
+	__be16 frm_ctrl_mask;
+	__be16 seq_ctrl_mask;
+	u8 rsvd1[2];
+	u8 cnst;
+	u8 key_id;
+	u8 ctr_flags;
+	u8 rsvd2;
+	__be16 ctr_init;
+} __packed;
+
+struct wifi_decap_pdb {
+	__be32 desc_hdr;
+	__be16 mac_hdr_len;
+	u8 rsvd;
+	u8 options;
+	u8 iv_flags;
+	u8 pri;
+	__be16 pn1;
+	__be32 pn2;
+	__be16 frm_ctrl_mask;
+	__be16 seq_ctrl_mask;
+	u8 rsvd1[4];
+	u8 ctr_flags;
+	u8 rsvd2;
+	__be16 ctr_init;
+} __packed;
+
+/*
+ * IEEE 802.16 WiMAX Protocol Data Block
+ */
+#define WIMAX_PDBOPTS_FCS	0x01
+#define WIMAX_PDBOPTS_AR	0x40 /* decap only */
+
+struct wimax_encap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd[3];
+	u8 options;
+	__be32 nonce;
+	u8 b0_flags;
+	u8 ctr_flags;
+	__be16 ctr_init;
+	/* begin DECO writeback region */
+	__be32 pn;
+	/* end DECO writeback region */
+} __packed;
+
+struct wimax_decap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd[3];
+	u8 options;
+	__be32 nonce;
+	u8 iv_flags;
+	u8 ctr_flags;
+	__be16 ctr_init;
+	/* begin DECO writeback region */
+	__be32 pn;
+	u8 rsvd1[2];
+	__be16 antireplay_len;
+	__be64 antireplay_scorecard;
+	/* end DECO writeback region */
+} __packed;
+
+/*
+ * IEEE 801.AE MacSEC Protocol Data Block
+ */
+#define MACSEC_PDBOPTS_FCS	0x01
+#define MACSEC_PDBOPTS_AR	0x40 /* used in decap only */
+
+struct macsec_encap_pdb {
+	__be32 desc_hdr;
+	__be16 aad_len;
+	u8 rsvd;
+	u8 options;
+	__be64 sci;
+	__be16 ethertype;
+	u8 tci_an;
+	u8 rsvd1;
+	/* begin DECO writeback region */
+	__be32 pn;
+	/* end DECO writeback region */
+} __packed;
+
+struct macsec_decap_pdb {
+	__be32 desc_hdr;
+	__be16 aad_len;
+	u8 rsvd;
+	u8 options;
+	__be64 sci;
+	u8 rsvd1[3];
+	/* begin DECO writeback region */
+	u8 antireplay_len;
+	__be32 pn;
+	__be64 antireplay_scorecard;
+	/* end DECO writeback region */
+} __packed;
+
+/*
+ * SSL/TLS/DTLS Protocol Data Blocks
+ */
+
+#define TLS_PDBOPTS_ARS32	0x40
+#define TLS_PDBOPTS_ARS64	0xc0
+#define TLS_PDBOPTS_OUTFMT	0x08
+#define TLS_PDBOPTS_IV_WRTBK	0x02 /* 1.1/1.2/DTLS only */
+#define TLS_PDBOPTS_EXP_RND_IV	0x01 /* 1.1/1.2/DTLS only */
+
+struct tls_block_encap_pdb {
+	__be32 desc_hdr;
+	u8 type;
+	u8 version[2];
+	u8 options;
+	__be64 seq_num;
+	__be32 iv[4];
+} __packed;
+
+struct tls_stream_encap_pdb {
+	__be32 desc_hdr;
+	u8 type;
+	u8 version[2];
+	u8 options;
+	__be64 seq_num;
+	u8 i;
+	u8 j;
+	u8 rsvd1[2];
+} __packed;
+
+struct dtls_block_encap_pdb {
+	__be32 desc_hdr;
+	u8 type;
+	u8 version[2];
+	u8 options;
+	__be16 epoch;
+	__be16 seq_num[3];
+	__be32 iv[4];
+} __packed;
+
+struct tls_block_decap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd[3];
+	u8 options;
+	__be64 seq_num;
+	__be32 iv[4];
+} __packed;
+
+struct tls_stream_decap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd[3];
+	u8 options;
+	__be64 seq_num;
+	u8 i;
+	u8 j;
+	u8 rsvd1[2];
+} __packed;
+
+struct dtls_block_decap_pdb {
+	__be32 desc_hdr;
+	u8 rsvd[3];
+	u8 options;
+	__be16 epoch;
+	__be16 seq_num[3];
+	__be32 iv[4];
+	__be64 antireplay_scorecard;
+} __packed;
+
+/*
+ * SRTP Protocol Data Blocks
+ */
+#define SRTP_PDBOPTS_MKI	0x08
+#define SRTP_PDBOPTS_AR		0x40
+
+struct srtp_encap_pdb {
+	__be32 desc_hdr;
+	u8 x_len;
+	u8 mki_len;
+	u8 n_tag;
+	u8 options;
+	__be32 cnst0;
+	u8 rsvd[2];
+	__be16 cnst1;
+	__be16 salt[7];
+	__be16 cnst2;
+	__be32 rsvd1;
+	__be32 roc;
+	__be32 opt_mki;
+} __packed;
+
+struct srtp_decap_pdb {
+	__be32 desc_hdr;
+	u8 x_len;
+	u8 mki_len;
+	u8 n_tag;
+	u8 options;
+	__be32 cnst0;
+	u8 rsvd[2];
+	__be16 cnst1;
+	__be16 salt[7];
+	__be16 cnst2;
+	__be16 rsvd1;
+	__be16 seq_num;
+	__be32 roc;
+	__be64 antireplay_scorecard;
+} __packed;
+
+/*
+ * DSA/ECDSA Protocol Data Blocks
+ * Two of these exist: DSA-SIGN, and DSA-VERIFY. They are similar
+ * except for the treatment of "w" for verify, "s" for sign,
+ * and the placement of "a,b".
+ */
+#define DSA_PDB_SGF_SHIFT	24
+#define DSA_PDB_SGF_MASK	(0xff << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_Q		(0x80 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_R		(0x40 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_G		(0x20 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_W		(0x10 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_S		(0x10 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_F		(0x08 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_C		(0x04 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_D		(0x02 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_AB_SIGN	(0x02 << DSA_PDB_SGF_SHIFT)
+#define DSA_PDB_SGF_AB_VERIFY	(0x01 << DSA_PDB_SGF_SHIFT)
+
+#define DSA_PDB_L_SHIFT		7
+#define DSA_PDB_L_MASK		(0x3ff << DSA_PDB_L_SHIFT)
+
+#define DSA_PDB_N_MASK		0x7f
+
+struct dsa_sign_pdb {
+	__be32 desc_hdr;
+	__be32 sgf_ln; /* Use DSA_PDB_ defintions per above */
+	u8 *q;
+	u8 *r;
+	u8 *g;	/* or Gx,y */
+	u8 *s;
+	u8 *f;
+	u8 *c;
+	u8 *d;
+	u8 *ab;  /* ECC only */
+	u8 *u;
+} __packed;
+
+struct dsa_verify_pdb {
+	__be32 desc_hdr;
+	__be32 sgf_ln;
+	u8 *q;
+	u8 *r;
+	u8 *g;	/* or Gx,y */
+	u8 *w;  /* or Wx,y */
+	u8 *f;
+	u8 *c;
+	u8 *d;
+	u8 *tmp; /* temporary data block */
+	u8 *ab;  /* only used if ECC processing */
+} __packed;
+
+#endif
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index e8cf409..8adb16c 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -229,6 +229,10 @@ struct rngtst {
  * starts base + 0x0000 padded out to 0x1000
  */
 
+#define KEK_KEY_SIZE		8
+#define TKEK_KEY_SIZE		8
+#define TDSK_KEY_SIZE		8
+
 struct caam_ctrl {
 	/* Basic Configuration Section                          000-02f */
 	/* Read/Writable                                                */
@@ -248,9 +252,9 @@ struct caam_ctrl {
 
 	/* Key Encryption/Decryption Configuration              400-47f */
 	/* Read/Writable only while in Non-secure mode                  */
-	__be32 kek[8];		/* KEK - Key Encryption Key */
-	__be32 tkek[8];		/* TKEK - Trusted Key Encryption Key */
-	__be32 tdsk[8];		/* TDSK - Trusted Desc Signing Key */
+	__be32 kek[KEK_KEY_SIZE];	/* KEK - Key Encryption Key */
+	__be32 tkek[TKEK_KEY_SIZE];	/* TKEK - Trusted Key Encryption Key */
+	__be32 tdsk[TDSK_KEY_SIZE];	/* TDSK - Trusted Desc Signing Key */
 	__be32 rsvd6[104];
 
 	/* RNG Test/Verification/Debug Access                   600-6b7 */
@@ -266,6 +270,30 @@ struct caam_ctrl {
 };
 
 /*
+ * Controller master config register defs
+ */
+#define MCFGR_SWRESET		0x80000000 /* software reset */
+#define MCFGR_WDENABLE		0x40000000 /* DECO watchdog enable */
+#define MCFGR_WDFAIL		0x20000000 /* DECO watchdog force-fail */
+#define MCFGR_DMA_RESET		0x10000000
+#define MCFGR_LONG_PTR		0x00010000 /* Use >32-bit desc addressing */
+
+/* AXI read cache control */
+#define MCFGR_ARCACHE_SHIFT	12
+#define MCFGR_ARCACHE_MASK	(0xf << MCFGR_ARCACHE_SHIFT)
+
+/* AXI write cache control */
+#define MCFGR_AWCACHE_SHIFT	8
+#define MCFGR_AWCACHE_MASK	(0xf << MCFGR_AWCACHE_SHIFT)
+
+/* AXI pipeline depth */
+#define MCFGR_AXIPIPE_SHIFT	4
+#define MCFGR_AXIPIPE_MASK	(0xf << MCFGR_AXIPIPE_SHIFT)
+
+#define MCFGR_AXIPRI		0x00000008 /* Assert AXI priority sideband */
+#define MCFGR_BURST_64		0x00000001 /* Max burst size */
+
+/*
  * caam_job_queue - direct job queue setup
  * 1-4 possible per instantiation, base + 1000/2000/3000/4000
  * Padded out to 0x1000
@@ -326,6 +354,7 @@ struct caam_job_queue {
  * Also note, same values written out as status through QI
  * in the command/status field of a frame descriptor
  */
+#define JQSTA_SSRC_SHIFT            28
 #define JQSTA_SSRC_MASK             0xf0000000
 
 #define JQSTA_SSRC_NONE             0x00000000
@@ -336,6 +365,7 @@ struct caam_job_queue {
 #define JQSTA_SSRC_JUMP_HALT_CC     0x70000000
 
 #define JQSTA_DECOERR_JUMP          0x08000000
+#define JQSTA_DECOERR_INDEX_SHIFT   8
 #define JQSTA_DECOERR_INDEX_MASK    0xff00
 #define JQSTA_DECOERR_ERROR_MASK    0x00ff
 
@@ -424,9 +454,11 @@ struct caam_job_queue {
 #define JQINT_ERR_TYPE_REMOVE_OFL   8
 #define JQINT_ERR_TYPE_ADD_OFL      9
 
-#define JQCFG_SOE                   0x04
-#define JQCFG_ICEN                  0x02
-#define JQCFG_IMSK                  0x01
+#define JQCFG_SOE		0x04
+#define JQCFG_ICEN		0x02
+#define JQCFG_IMSK		0x01
+#define JQCFG_ICDCT_SHIFT	8
+#define JQCFG_ICTT_SHIFT	16
 
 #define JQCR_RESET                  0x01
 
-- 
1.6.5.2

