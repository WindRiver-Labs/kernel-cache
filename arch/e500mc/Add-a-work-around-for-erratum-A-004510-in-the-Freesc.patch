From bc431664bd849a6ed66dde45f49228ee7706145d Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Tue, 10 Jul 2012 11:24:30 +0800
Subject: [PATCH] Add a work-around for erratum A-004510 in the Freescale PAMU
 device driver

Provide libedit_20110709-3.0.bb to be used for 5.0 build system.

Erratum A-004510 says that under certain load conditions, modified cache lines
can be discarded, causing data corruption.

The work-around for erratum A-004510 says that only one core at a time can
generate transactions that snoop the PAMU, and use a spinlock that protects
reads/writes to the PAACT ensures this.

Integrated-by: Tiejun Chen <tiejun.chen@windriver.com>
Integrated-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 arch/powerpc/Kconfig           |  13 ++
 arch/powerpc/sysdev/fsl_pamu.c | 285 +++++++++++++++++++++++++++++++++++++++++
 2 files changed, 298 insertions(+)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 75df4c8..8308496 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -755,6 +755,19 @@ config FSL_PAMU
 	help
 	  Freescale PAMU/IOMMU support
 
+config FSL_PAMU_ERRATUM_A_004510
+	bool "Enable PAMU work-around for erratum A-004510"
+	depends on FSL_PAMU
+	# For now, enable this by default, so that we don't have to update
+	# defconfigs.  All current PAMU-enabled SOCs have the erratum.
+	default y
+	help
+	  Select this option to enable a work-around for erratum A-004510
+	  in the Freescale PAMU device driver.  Erratum A-004510 says that
+	  under certain load conditions, modified cache lines can be discarded,
+	  causing data corruption.  This option enables the PAMU portion of
+	  the work-around.
+
 config HAS_FSL_QBMAN
 	bool "Datapath Acceleration Queue and Buffer management"
 	help
diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index f905169..538ac5f 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -43,6 +43,15 @@
 
 #include "fsl_pamu.h"
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+/*
+ * The work-around for erratum A-004510 says that only one core at a time can
+ * generate transactions that snoop the PAMU.  A spinlock that protects
+ * reads/writes to the PAACT ensures this.
+ */
+static DEFINE_SPINLOCK(pamu_lock);
+#endif
+
 #define PAMUBYPENR 0x604
 
 /* define indexes for each operation mapping scenario */
@@ -55,6 +64,10 @@ void setup_omt(struct ome *omt)
 {
 	struct ome *ome;
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_lock(&pamu_lock);
+#endif
+
 	/* Configure OMI_QMAN */
 	ome = &omt[OMI_QMAN];
 
@@ -95,6 +108,10 @@ void setup_omt(struct ome *omt)
 	ome = &omt[OMI_CAAM];
 	ome->moe[IOE_READ_IDX]  = EOE_VALID | EOE_READI;
 	ome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;
+
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_unlock(&pamu_lock);
+#endif
 }
 
 #define L1 1
@@ -181,6 +198,10 @@ void setup_liodns(struct ppaace *ppaact)
 	const u32 *prop;
 	u32 cache_id, prop_cnt;
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_lock(&pamu_lock);
+#endif
+
 	for (i = 0; i < PAACE_NUMBER_ENTRIES; i++) {
 		ppaace = &ppaact[i];
 		ppaace->pt = PAACE_PT_PRIMARY;
@@ -247,6 +268,10 @@ void setup_liodns(struct ppaace *ppaact)
 		}
 		of_node_put(qman_dn);
 	}
+
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_unlock(&pamu_lock);
+#endif
 }
 
 int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,
@@ -256,6 +281,10 @@ int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,
 	phys_addr_t phys;
 	struct pamu_mmap_regs *pamu_regs;
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_lock(&pamu_lock);
+#endif
+
 	pc = (u32 *) (pamu_reg_base + PAMU_PC);
 	pamu_regs = (struct pamu_mmap_regs *) 
 		(pamu_reg_base + PAMU_MMAP_REGS_BASE);
@@ -285,6 +314,11 @@ int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,
 	out_be32((u32 *)(pamu_reg_base + PAMU_PICS),
 			PAMU_ACCESS_VIOLATION_ENABLE);
 	out_be32(pc, PAMU_PC_PE | PAMU_PC_OCE | PAMU_PC_SPCC | PAMU_PC_PPCC);
+
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_unlock(&pamu_lock);
+#endif
+
 	return 0;
 }
 
@@ -294,6 +328,202 @@ irqreturn_t pamu_av_isr(int irq, void *arg)
 	/* NOTREACHED */
 }
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+
+/*
+ * The work-around for erratum A-004510 says we need to create a coherency
+ * subdomain (CSD), which means we need to create a LAW (local access window)
+ * just for the PAACT and OMT, and then give it a unique CSD ID.  Linux
+ * normally doesn't touch the LAWs, so we define everything here.
+ */
+
+#define LAWAR_EN		0x80000000
+#define LAWAR_TARGET_MASK	0x0FF00000
+#define LAWAR_TARGET_SHIFT	20
+#define LAWAR_SIZE_MASK		0x0000003F
+#define LAWAR_CSDID_MASK	0x000FF000
+#define LAWAR_CSDID_SHIFT	12
+
+#ifdef CONFIG_P204x_RDB
+#define CSD_PORT_ID	0xFF000000
+#elif CONFIG_P3041_DS
+#define CSD_PORT_ID	0xFF000000
+#elif CONFIG_P4080_DS
+#define CSD_PORT_ID	0xFFF80000
+#elif CONFIG_P5020_DS || CONFIG_SBCP4080
+#define CSD_PORT_ID	0xFC000000
+#endif
+
+enum law_size {
+	LAW_SIZE_4K = 0xb,
+	LAW_SIZE_8K,
+	LAW_SIZE_16K,
+	LAW_SIZE_32K,
+	LAW_SIZE_64K,
+	LAW_SIZE_128K,
+	LAW_SIZE_256K,
+	LAW_SIZE_512K,
+	LAW_SIZE_1M,
+	LAW_SIZE_2M,
+	LAW_SIZE_4M,
+	LAW_SIZE_8M,
+	LAW_SIZE_16M,
+	LAW_SIZE_32M,
+	LAW_SIZE_64M,
+	LAW_SIZE_128M,
+	LAW_SIZE_256M,
+	LAW_SIZE_512M,
+	LAW_SIZE_1G,
+	LAW_SIZE_2G,
+	LAW_SIZE_4G,
+	LAW_SIZE_8G,
+	LAW_SIZE_16G,
+	LAW_SIZE_32G,
+};
+
+struct ccsr_law {
+	u32	lawbarh;	/* LAWn base address high */
+	u32	lawbarl;	/* LAWn base address low */
+	u32	lawar;		/* LAWn attributes */
+	u32	reserved;
+};
+
+#define make64(high, low) (((u64)(high) << 32) | (low))
+
+/*
+ * Create a coherence subdomain for a given memory block.
+ */
+static int __init create_csd(phys_addr_t phys, size_t size)
+{
+	struct device_node *np;
+	const __be32 *iprop;
+	void __iomem *lac = NULL;	/* Local Access Control registers */
+	struct ccsr_law __iomem *law;
+	void __iomem *ccm = NULL;
+	u32 __iomem *csdids;
+	unsigned int i, num_laws, num_csds;
+	u32 law_target = 0;
+	u32 csd_id = 0;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,corenet-law");
+	if (!np)
+		return -ENODEV;
+
+	iprop = of_get_property(np, "fsl,num-laws", NULL);
+	if (!iprop) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	num_laws = be32_to_cpup(iprop);
+	if (!num_laws) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	lac = of_iomap(np, 0);
+	if (!lac) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	/* LAW registers are at offset 0xC00 */
+	law = lac + 0xC00;
+
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,corenet-cf");
+	if (!np) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	iprop = of_get_property(np, "fsl,ccf-num-csdids", NULL);
+	if (!iprop) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	num_csds = be32_to_cpup(iprop);
+	if (!num_csds) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	ccm = of_iomap(np, 0);
+	if (!ccm) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	/* The undocumented CSDID registers are at offset 0x600 */
+	csdids = ccm + 0x600;
+
+	of_node_put(np);
+	np = NULL;
+
+	/* Find an unused coherence subdomain ID */
+	for (csd_id = 0; csd_id < num_csds; csd_id++) {
+		if (!csdids[csd_id])
+			break;
+	}
+
+	/* Store the Port ID in the (undocumented) proper CIDMRxx register */
+	csdids[csd_id] = CSD_PORT_ID;
+
+	/* Find the DDR LAW that maps to our buffer. */
+	for (i = 0; i < num_laws; i++) {
+		if (law[i].lawar & LAWAR_EN) {
+			phys_addr_t law_start, law_end;
+
+			law_start = make64(law[i].lawbarh, law[i].lawbarl);
+			law_end = law_start +
+				(1ULL << ((law[i].lawar & LAWAR_SIZE_MASK) + 1));
+
+			if (law_start <= phys && phys < law_end) {
+				law_target = law[i].lawar & LAWAR_TARGET_MASK;
+				break;
+			}
+		}
+	}
+
+	if (i == 0 || i == num_laws) {
+		/* This should never happen*/
+		ret = -ENOENT;
+		goto error;
+	}
+
+	/* Find a free LAW entry */
+	while (law[--i].lawar & LAWAR_EN) {
+		if (i == 0) {
+			/* No higher priority LAW slots available */
+			ret = -ENOENT;
+			goto error;
+		}
+	}
+
+	law[i].lawbarh = upper_32_bits(phys);
+	law[i].lawbarl = lower_32_bits(phys);
+	wmb();
+	law[i].lawar = LAWAR_EN | law_target | (csd_id << LAWAR_CSDID_SHIFT) |
+		(LAW_SIZE_4K + get_order(size));
+	wmb();
+
+error:
+	if (ccm)
+		iounmap(ccm);
+
+	if (lac)
+		iounmap(lac);
+
+	if (np)
+		of_node_put(np);
+
+	return ret;
+}
+#endif
+
 static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 				     const struct of_device_id *match)
 {
@@ -306,6 +536,11 @@ static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 	struct ome *omt = NULL;
 	int irq;
 	struct page *p;
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	size_t mem_size = 0;
+	unsigned int order = 0;
+	int ret;
+#endif
 
 	printk(KERN_INFO "Setting Freescale static PAMU/IOMMU configuration\n");
 
@@ -339,6 +574,55 @@ static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 	}
 	of_node_put(guts_node);
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	/*
+	 * To simplify the allocation of a coherency domain, we allocate the
+	 * PAACT and the OMT in the same memory buffer.  Unfortunately, this
+	 * wastes more memory compared to allocating the buffers separately.
+	 */
+
+	/* Determine how much memory we need */
+	mem_size = (PAGE_SIZE << get_order(PAACT_SIZE)) +
+		(PAGE_SIZE << get_order(OMT_SIZE));
+	order = get_order(mem_size);
+
+	p = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
+	if (!p) {
+		dev_err(&dev->dev, "unable to allocate PAACT/OMT block\n");
+		iounmap(guts_regs);
+		iounmap(pamu_regs);
+		return -ENOMEM;
+	}
+
+	ppaact = page_address(p);
+
+	/* Make sure the memory is naturally aligned */
+	if (page_to_phys(p) & ((PAGE_SIZE << order) - 1)) {
+		dev_err(&dev->dev, "PAACT/OMT block is unaligned\n");
+		free_pages((unsigned long)ppaact, order);
+		iounmap(guts_regs);
+		iounmap(pamu_regs);
+		return -ENOMEM;
+	}
+
+	/* This assumes that PAACT_SIZE is larger than OMT_SIZE */
+	omt = (void *)ppaact + (PAGE_SIZE << get_order(PAACT_SIZE));
+
+	dev_dbg(&dev->dev, "ppaact virt=%p phys=0x%llx\n", ppaact,
+		(unsigned long long) page_to_phys(p));
+
+	dev_dbg(&dev->dev, "omt virt=%p phys=0x%llx\n", omt,
+		(unsigned long long) virt_to_phys(omt));
+
+	ret = create_csd(page_to_phys(p), mem_size);
+	if (ret) {
+		dev_err(&dev->dev, "could not create coherence subdomain\n");
+		free_pages((unsigned long)ppaact, order);
+		iounmap(guts_regs);
+		iounmap(pamu_regs);
+		return ret;
+	}
+#else
 	p = alloc_pages(GFP_KERNEL, get_order(PAACT_SIZE));
 	if (!p) {
 		printk(KERN_ERR "Unable to allocate space for PAACT table\n");
@@ -365,6 +649,7 @@ static int __devinit fsl_of_pamu_probe(struct of_device *dev,
 
 	pr_debug("fsl_pamu, omt_mem, v : %p, p : 0x%lx\n", 
 			omt, virt_to_phys(omt));
+#endif
 
 	pamubypenr = in_be32(guts_regs + PAMUBYPENR);
 
-- 
1.7.11

