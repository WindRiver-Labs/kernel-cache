From 76443aa3f4811545eb1fbb596e5c4dd90c869a68 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Sat, 30 Jan 2010 10:48:24 -0600
Subject: [PATCH 113/252] Guarantee TX confirmation cleanup some time

Under high load, the RX processing thread was starving the TX cleanup
thread, which meant that we never freed the buffers we had RXed.  Add
quota which restricts the maximum number of packets RX can handle before
yielding to another thread.  For now, we allow each network interface to
handle 32 frames per queue (tx/rx default/error) before rescheduling
itself, and allowing another interface's work thread to operate.

Signed-off-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Emil Medve <emilian.medve@freescale.com>
[Cleanly applied the FSL SDK 2.0.3 patch:
"kernel-2.6.30-v2-Guarantee-TX-confirmation-cleanup-some-ti.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/dpa.c |   20 +++++++++++++++++---
 1 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 85d3d46..d42beb0 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+/* Copyright (c) 2008 - 2010, Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -1602,6 +1602,8 @@ static void __hot dpa_work(struct work_struct *fd_work)
 	const struct dpa_priv_s		*priv;
 	struct dpa_percpu_priv_s	*percpu_priv;
 	struct dpa_fd			*dpa_fd, *tmp;
+	unsigned int quota = 0;
+	unsigned int retry = 0;
 
 	percpu_priv = (typeof(percpu_priv))container_of(
 		fd_work, struct dpa_percpu_priv_s, fd_work);
@@ -1619,9 +1621,9 @@ static void __hot dpa_work(struct work_struct *fd_work)
 #endif
 
 	/* RX, TX */
-	for (i = 0; i < ARRAY_SIZE(percpu_priv->fd_list); i++)
+	for (i = 0; i < ARRAY_SIZE(percpu_priv->fd_list); i++) {
 		/* Error, default*/
-		for (j = 0; j < ARRAY_SIZE(percpu_priv->fd_list[i]); j++)
+		for (j = 0; j < ARRAY_SIZE(percpu_priv->fd_list[i]); j++) {
 			list_for_each_entry_safe(dpa_fd, tmp,
 						 &percpu_priv->fd_list[i][j],
 						 list) {
@@ -1635,7 +1637,19 @@ static void __hot dpa_work(struct work_struct *fd_work)
 #endif
 			list_add_tail(&dpa_fd->list, &percpu_priv->free_list);
 			local_irq_enable();
+
+			if (++quota > 32) {
+				quota = 0;
+				retry = 1;
+				break;
+			}
+			}
 		}
+	}
+
+	/* Try again later if we're not done */
+	if (retry)
+		schedule_work(fd_work);
 
 	if (netif_msg_intr(priv))
 		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
-- 
1.6.5.2

