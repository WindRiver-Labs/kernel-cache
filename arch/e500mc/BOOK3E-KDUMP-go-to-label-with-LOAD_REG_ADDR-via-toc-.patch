From 6b45f8bca0387ca025705c3abe5bd45edd46d427 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 17 Oct 2011 13:21:40 +0800
Subject: [PATCH 4/6] BOOK3E/KDUMP: go to label with LOAD_REG_ADDR via toc for RELOCATABLE kernel

We can't just use a direct branch to label because the distance
from here to there depends on where the kernel ends up being put.
So we have to go anywhere with LOAD_REG_ADDR via toc.

Additionally, for interrupt label we use SPRN_SPRG3/4 to save/restore used GPRGs
since for 64-bit embedded
        - SPRG3 unused
        - SPRG4 unused
its safe enough. And we have to extend the gap between each interrupt because we
need more instructions to implement this.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/exception-64e.h |   19 +++++++++++
 arch/powerpc/kernel/exceptions-64e.S     |   26 +++++++++++++++
 arch/powerpc/kernel/head_64.S            |    6 +++
 arch/powerpc/mm/tlb_low_64e.S            |   52 ++++++++++++++++++++++++++++++
 4 files changed, 103 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/exception-64e.h b/arch/powerpc/include/asm/exception-64e.h
index 9b57a27..963d37e 100644
--- a/arch/powerpc/include/asm/exception-64e.h
+++ b/arch/powerpc/include/asm/exception-64e.h
@@ -72,9 +72,20 @@
 #define EX_TLB_SIZE	(13 * 8)
 #endif
 
+#ifndef CONFIG_CRASH_DUMP
 #define	START_EXCEPTION(label)						\
 	.globl exc_##label##_book3e;					\
 exc_##label##_book3e:
+#else
+#define	START_EXCEPTION(label)						\
+	.globl exc_##label##_book3e;					\
+exc_##label##_book3e:							\
+	mtctr	r10;							\
+	mfspr	r10,SPRN_SPRG3;						\
+	mfspr	r2,SPRN_SPRG4;						\
+	.globl kdump_exc_##label##_book3e;				\
+kdump_exc_##label##_book3e:
+#endif
 
 /* TLB miss exception prolog
  *
@@ -194,10 +205,18 @@ exc_##label##_book3e:
 #define TLB_MISS_STATS_SAVE_INFO
 #endif
 
+#ifndef CONFIG_CRASH_DUMP
 #define SET_IVOR(vector_number, vector_offset)	\
 	li	r3,vector_offset@l; 		\
 	ori	r3,r3,interrupt_base_book3e@l;	\
 	mtspr	SPRN_IVOR##vector_number,r3;
+#else
+#define SET_IVOR(vector_number, vector_offset)	\
+	LOAD_REG_ADDR(r3,interrupt_base_book3e);\
+	andi.	r3,r3,0xFFFF;			\
+	ori	r3,r3,(vector_offset * 2)@l;	\
+	mtspr	SPRN_IVOR##vector_number,r3;
+#endif
 
 #endif /* _ASM_POWERPC_EXCEPTION_64E_H */
 
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 5172066..6b34a79 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -191,10 +191,32 @@ exc_##n##_bad_stack:							    \
 	sth	r1,PACA_TRAP_SAVE(r13);	/* store trap */		    \
 	b	bad_stack_book3e;	/* bad stack error */
 
+#ifndef CONFIG_CRASH_DUMP
 #define	EXCEPTION_STUB(loc, label)					\
 	. = interrupt_base_book3e + loc;				\
 	nop;	/* To make debug interrupts happy */			\
 	b	exc_##label##_book3e;
+#else
+/* We can't just use a direct branch to label because the distance
+ * from here to there depends on where the kernel ends up being put.
+ * So we have to go anywhere via toc. Here use SPRN_SPRG3/4 to save/restore
+ * GPRGs since for 64-bit embedded
+ *	- SPRG3 unused
+ *	- SPRG4 unused
+ * its safe enough.
+*/
+#define	EXCEPTION_STUB(loc, label)					\
+	. = interrupt_base_book3e + loc * 2;				\
+	nop;	/* To make debug interrupts happy */			\
+	mtspr	SPRN_SPRG3,r10;						\
+	mtspr	SPRN_SPRG4,r2;						\
+	mfctr	r10;							\
+	mfspr	r2,SPRN_SPRG_PACA;					\
+	ld	r2,PACATOC(r2);						\
+	LOAD_REG_ADDR(r2, exc_##label##_book3e);			\
+	mtctr	r2;							\
+	bctr;
+#endif
 
 #define ACK_NONE(r)
 #define ACK_DEC(r)							\
@@ -1090,6 +1112,10 @@ _GLOBAL(book3e_secondary_thread_init)
 _STATIC(init_core_book3e)
 	/* Establish the interrupt vector base */
 	LOAD_REG_IMMEDIATE(r3, interrupt_base_book3e)
+#ifdef CONFIG_CRASH_DUMP
+	tovirt(r2,r2)
+	LOAD_REG_ADDR(r3, interrupt_base_book3e)
+#endif
 	mtspr	SPRN_IVPR,r3
 	sync
 	blr
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index f8526cc..15ccd18 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -445,7 +445,13 @@ _STATIC(__after_prom_start)
 	cmplwi	cr0,r7,1
 	bne	3f
 
+#if defined(CONFIG_PPC_BOOK3E)
+	LOAD_REG_ADDR(r5, interrupt_end_book3e)
+	LOAD_REG_ADDR(r11, _stext)
+	sub	r5,r5,r11
+#else
 	li	r5,__end_interrupts - _stext	/* just copy interrupts */
+#endif
 	b	5f
 3:
 #endif
diff --git a/arch/powerpc/mm/tlb_low_64e.S b/arch/powerpc/mm/tlb_low_64e.S
index fb1f1e4..21b6fd7 100644
--- a/arch/powerpc/mm/tlb_low_64e.S
+++ b/arch/powerpc/mm/tlb_low_64e.S
@@ -105,7 +105,11 @@
 	 */
 	TLB_MISS_STATS_D(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 
 /* Instruction TLB miss */
 	START_EXCEPTION(instruction_tlb_miss)
@@ -151,7 +155,11 @@
 	/* We got a crappy address, just fault */
 	TLB_MISS_STATS_I(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 /*
  * This is the guts of the first-level TLB miss handler for direct
@@ -261,10 +269,18 @@ normal_tlb_miss_access_fault:
 	mtspr	SPRN_ESR,r15
 	TLB_MISS_STATS_D(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 1:	TLB_MISS_STATS_I(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 
 /*
@@ -432,10 +448,18 @@ virt_page_table_tlb_miss_fault:
 	mtspr	SPRN_ESR,r16
 	TLB_MISS_STATS_D(MMSTAT_TLB_MISS_PT_FAULT);
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 1:	TLB_MISS_STATS_I(MMSTAT_TLB_MISS_PT_FAULT);
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 virt_page_table_tlb_miss_whacko_fault:
 	/* The linear fault will restart everything so ESR and DEAR will
@@ -443,7 +467,11 @@ virt_page_table_tlb_miss_whacko_fault:
 	 */
 	TLB_MISS_STATS_X(MMSTAT_TLB_MISS_PT_FAULT);
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 
 
 /**************************************************************
@@ -493,7 +521,11 @@ virt_page_table_tlb_miss_whacko_fault:
 	 */
 	TLB_MISS_STATS_D(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 
 /* Instruction TLB miss */
 	START_EXCEPTION(instruction_tlb_miss_htw)
@@ -536,7 +568,11 @@ virt_page_table_tlb_miss_whacko_fault:
 	/* We got a crappy address, just fault */
 	TLB_MISS_STATS_I(MMSTAT_TLB_MISS_NORM_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 
 /*
@@ -647,10 +683,18 @@ htw_tlb_miss_fault:
 	mtspr	SPRN_ESR,r14
 	TLB_MISS_STATS_D(MMSTAT_TLB_MISS_PT_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 1:	TLB_MISS_STATS_I(MMSTAT_TLB_MISS_PT_FAULT)
 	TLB_MISS_EPILOG_ERROR
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 /*
  * This is the guts of "any" level TLB miss handler for kernel linear
@@ -725,9 +769,17 @@ tlb_load_linear_fault:
 	cmpdi	cr0,r14,-1
 	beq	1f
 	TLB_MISS_EPILOG_ERROR_SPECIAL
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_data_storage_book3e
+#else
+	b	kdump_exc_data_storage_book3e
+#endif
 1:	TLB_MISS_EPILOG_ERROR_SPECIAL
+#ifndef CONFIG_CRASH_DUMP
 	b	exc_instruction_storage_book3e
+#else
+	b	kdump_exc_instruction_storage_book3e
+#endif
 
 
 #ifdef CONFIG_BOOK3E_MMU_TLB_STATS
-- 
1.7.0.4

