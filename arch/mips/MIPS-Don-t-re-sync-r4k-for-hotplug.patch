From a535f951775101dbc87d51fbe582700607138fc1 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 3 Mar 2011 16:08:22 +0800
Subject: [PATCH] MIPS: Don't re-sync r4k for hotplug

R4K is synced in SMP initialization, hotplug doesn't need to re-sync it.

And hotplug can not re-sync it for it may get a dead lock and make the
system hang.

	synchronise_count_master():

		[...]
		atomic_set(&count_count_start, 0);
		[...]

count_count_start is 0 after all cpus are up:

	synchronise_count_slave():

		[...]
	ncpus = num_online_cpus();
	for (i = 0; i < NR_LOOPS; i++) {
		atomic_inc(&count_count_start);
		while (atomic_read(&count_count_start) != ncpus)
			mb();
		[...]

If one cpu is offline and online later, count_count_start is always 1
and will never equal to ncpus, then, it will loop in the above while and
this cpu will stall.

This adds a count_finish_flag, set it after all cpus are synced and
check it when enter into synchronise_count_slave(), if count_finish_flag
is set, return directly.

BTW, synchronise_count_slave() is called by start_secondary().

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/kernel/sync-r4k.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index 05dd170..ca47b4f 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -24,6 +24,9 @@ static atomic_t __cpuinitdata count_start_flag = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_start = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_count_stop = ATOMIC_INIT(0);
 static atomic_t __cpuinitdata count_reference = ATOMIC_INIT(0);
+#ifdef CONFIG_HOTPLUG_CPU
+static atomic_t __cpuinitdata count_finish_flag = ATOMIC_INIT(0);
+#endif
 
 #define COUNTON	100
 #define NR_LOOPS 5
@@ -106,6 +109,11 @@ void __cpuinit synchronise_count_master(void)
 	 * so no point in alarming people
 	 */
 	printk("done.\n");
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* Safely mark the finish flag here */
+	atomic_set(&count_finish_flag, 1);
+#endif
 }
 
 void __cpuinit synchronise_count_slave(void)
@@ -125,6 +133,14 @@ void __cpuinit synchronise_count_slave(void)
 
 	local_irq_save(flags);
 
+#ifdef CONFIG_HOTPLUG_CPU
+	/* No need to re-sync it when up the cpu via cpu hotplug */
+	if (atomic_read(&count_finish_flag)) {
+		local_irq_restore(flags);
+		return;
+	}
+#endif
+
 	/*
 	 * Not every cpu is online at the time this gets called,
 	 * so we first wait for the master to say everyone is ready
-- 
1.6.5.2

