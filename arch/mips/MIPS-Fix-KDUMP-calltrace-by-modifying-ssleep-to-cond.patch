From d5e0f918fce5b8b1c9760d20cb36b0e0368286ca Mon Sep 17 00:00:00 2001
From: Tian Le <le.tian@windriver.com>
Date: Fri, 25 Feb 2011 16:31:24 +0800
Subject: [PATCH] MIPS: Fix KDUMP calltrace by modifying ssleep to conditional ssleep

The calltrace is caused by bash thread scheduling in atomic context.
the preempt disable comes from the handling of the sysrq-c
(triggered by "echo c > /proc/sysrq-trigger") in __handle_sysrq(),
where it takes a spinlock before calling the sysrq handler. The handler
in turn calls die(), which, on MIPS, for some reason, sleeps for 5
seconds before calling panic(). A valid solution for this
would be to put the ssleep() call in die() within two checks.

Signed-off-by: Tian Le <le.tian@windriver.com>
---
 arch/mips/kernel/traps.c |   13 ++++++++++++-
 1 files changed, 12 insertions(+), 1 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 78c3b96..a8bf7dd 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -365,6 +365,9 @@ void show_registers(const struct pt_regs *regs)
 
 static DEFINE_SPINLOCK(die_lock);
 
+#ifdef CONFIG_KEXEC
+extern struct kimage *kexec_crash_image;
+#endif
 void __noreturn die(const char * str, struct pt_regs * regs)
 {
 	static int die_counter;
@@ -394,8 +397,16 @@ void __noreturn die(const char * str, struct pt_regs * regs)
 		panic("Fatal exception in interrupt");
 
 	if (panic_on_oops) {
+		int do_sleep = 1;
 		printk(KERN_EMERG "Fatal exception: panic in 5 seconds\n");
-		ssleep(5);
+
+#ifdef CONFIG_KEXEC
+		if (kexec_crash_image)
+			do_sleep = 0;
+#endif
+		if (do_sleep)
+			ssleep(5);
+
 		panic("Fatal exception");
 	}
 
-- 
1.7.0.4

