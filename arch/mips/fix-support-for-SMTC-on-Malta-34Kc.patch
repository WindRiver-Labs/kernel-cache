From 0b595837027a4ef9f6c4621f055651b915a2cd6e Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 12 Apr 2010 20:59:38 +0800
Subject: [PATCH 6/8] fix support for SMTC on Malta 34Kc

Although current kernel can support SMTC on Malta 34Kc after overcoming
the introduction of dyntick, there are still two issues to be fixed as
the following:

a) CPU name is NULL on SMTC
For SMTC the kernel probes CPU name only one time so we have to provide
others cpu (TC) name.

b) Kernel panic while executing init
The 34kc supports using r4k_wait_irqoff. If one TC, which is configured not
to handle the interrupt, executes wait to enter idle. When it reworks by
IPI we need to force exit from the wait and do a direct post of the IPI. But
the original condition judging whether the TC enters wait section is imprecise:
=====
void r4k_wait_irqoff(void)
{
        local_irq_disable();
        if (!need_resched())
                __asm__("       .set    push            \n"
                        "       .set    mips3           \n"
                        "       wait                    \n"
                        "       .set    pop             \n");
        local_irq_enable();
        __asm__("       .globl __pastwait       \n"
                "__pastwait:                    \n");
        return;
}
=====
        if (cpu_wait == r4k_wait_irqoff) {
                tcrestart = read_tc_c0_tcrestart();
                if (tcrestart >= (unsigned long)r4k_wait_irqoff
                    && tcrestart < (unsigned long)__pastwait) {
                        write_tc_c0_tcrestart(__pastwait);
                        tcstatus &= ~TCSTATUS_IXMT;
                        write_tc_c0_tcstatus(tcstatus);
                        goto postdirect;
                }
        }
=====

Obviously, if the TC enter r4k_wait_irqoff and just disable local irq it
receive the interrupt and has to exit immediately without enabling local irq!
So we should handle this precisely only the TC enter the real wait section
within __startwait and __endwait:
=====
void r4k_wait_irqoff(void)
{
	local_irq_disable();
	if (!need_resched())
		__asm__(" 	.globl __startwait	\n"
			"__startwait:			\n"
			"	.set	push		\n"
			"	.set	mips3		\n"
			"	wait			\n"
			"	.set	pop		\n"
			" 	.globl __pastwait	\n"
			"__pastwait:			\n");
	local_irq_enable();
	return;
}

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/mips/kernel/cpu-probe.c |   22 ++++++++++++++++++----
 arch/mips/kernel/smtc.c      |    4 ++--
 2 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index be5bb16..7e1e51b 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -62,13 +62,15 @@ void r4k_wait_irqoff(void)
 {
 	local_irq_disable();
 	if (!need_resched())
-		__asm__("	.set	push		\n"
+		__asm__(" 	.globl __startwait	\n"
+			"__startwait:			\n"
+			"	.set	push		\n"
 			"	.set	mips3		\n"
 			"	wait			\n"
-			"	.set	pop		\n");
+			"	.set	pop		\n"
+			" 	.globl __pastwait	\n"
+			"__pastwait:			\n");
 	local_irq_enable();
-	__asm__(" 	.globl __pastwait	\n"
-		"__pastwait:			\n");
 	return;
 }
 
@@ -939,6 +941,9 @@ __cpuinit void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int cpu = smp_processor_id();
+#ifdef CONFIG_MIPS_MT_SMTC
+	unsigned int i = 0;
+#endif
 
 	c->processor_id	= PRID_IMP_UNKNOWN;
 	c->fpu_id	= FPIR_IMP_NONE;
@@ -994,6 +999,15 @@ __cpuinit void cpu_probe(void)
 		}
 	}
 
+#ifdef CONFIG_MIPS_MT_SMTC
+	/*
+	 * The SMTC kernel probes only one time so it's necessary to provide
+	 * others cpu name here,.
+	 */
+	for (i = 0; i < NR_CPUS;i++)
+		if(i != cpu)
+			__cpu_name[i] = __cpu_name[cpu];
+#endif
 	if (cpu_has_mips_r2)
 		c->srsets = ((read_c0_srsctl() >> 26) & 0x0f) + 1;
 	else
diff --git a/arch/mips/kernel/smtc.c b/arch/mips/kernel/smtc.c
index 23499b5..1468a93 100644
--- a/arch/mips/kernel/smtc.c
+++ b/arch/mips/kernel/smtc.c
@@ -797,7 +797,7 @@ void smtc_send_ipi(int cpu, int type, unsigned int action)
 	unsigned long flags;
 	int mtflags;
 	unsigned long tcrestart;
-	extern void r4k_wait_irqoff(void), __pastwait(void);
+	extern void r4k_wait_irqoff(void), __startwait(void), __pastwait(void);
 	int set_resched_flag = (type == LINUX_SMP_IPI &&
 				action == SMP_RESCHEDULE_YOURSELF);
 
@@ -853,7 +853,7 @@ void smtc_send_ipi(int cpu, int type, unsigned int action)
 			 */
 			if (cpu_wait == r4k_wait_irqoff) {
 				tcrestart = read_tc_c0_tcrestart();
-				if (tcrestart >= (unsigned long)r4k_wait_irqoff
+				if (tcrestart >= (unsigned long)__startwait
 				    && tcrestart < (unsigned long)__pastwait) {
 					write_tc_c0_tcrestart(__pastwait);
 					tcstatus &= ~TCSTATUS_IXMT;
-- 
1.6.5.2

